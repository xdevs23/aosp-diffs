```diff
diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
index 77bd2a6b2..dd5c49092 100644
--- a/.github/workflows/build.yml
+++ b/.github/workflows/build.yml
@@ -49,14 +49,14 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -75,13 +75,13 @@ jobs:
     runs-on: ubuntu-22.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
     - name: Run linkspector
-      uses: umbrelladocs/action-linkspector@v1
+      uses: umbrelladocs/action-linkspector@a0567ce1c7c13de4a2358587492ed43cab5d0102 # v1.3.4
       with:
         github_token: ${{ secrets.GITHUB_TOKEN }}
         reporter: github-pr-review
@@ -91,14 +91,14 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -114,7 +114,7 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -154,7 +154,7 @@ jobs:
       CXX: ${{ matrix.compiler_cpp }}
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -173,7 +173,7 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -192,7 +192,7 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -210,7 +210,7 @@ jobs:
         path: third_party/mbedtls/repo
     - name: Build
       run: |
-        ./script/test build
+        OT_OPTIONS='-DCMAKE_POLICY_VERSION_MINIMUM=3.5' ./script/test build
 
   arm-gcc:
     name: arm-gcc-${{ matrix.gcc_ver }}
@@ -251,7 +251,7 @@ jobs:
             gcc_extract_dir: arm-gnu-toolchain-14.2.rel1-x86_64-arm-none-eabi
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -284,7 +284,7 @@ jobs:
       CXX: g++-${{ matrix.gcc_ver }}
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -317,7 +317,7 @@ jobs:
       CXX: clang++-${{ matrix.clang_ver }}
     steps:
       - name: Harden Runner
-        uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
         with:
           egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -340,7 +340,7 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -376,7 +376,7 @@ jobs:
       CXX: ${{ matrix.CXX }}
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -400,7 +400,7 @@ jobs:
       image: openthread/environment
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -411,7 +411,7 @@ jobs:
       run: apt update && apt install -y unzip
     - name: Setup NDK
       id: setup-ndk
-      uses: nttld/setup-ndk@v1
+      uses: nttld/setup-ndk@afb4c9964b521afb97c864b7d40b11e6911bd410 # v1.5.0
       with:
         ndk-version: r25c
         local-cache: true
diff --git a/.github/workflows/codeql.yml b/.github/workflows/codeql.yml
index 54c432f6c..42d73489c 100644
--- a/.github/workflows/codeql.yml
+++ b/.github/workflows/codeql.yml
@@ -54,7 +54,7 @@ jobs:
 
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -66,7 +66,7 @@ jobs:
         sudo apt-get --no-install-recommends install -y ninja-build libreadline-dev libncurses-dev
 
     - name: Initialize CodeQL
-      uses: github/codeql-action/init@df409f7d9260372bd5f19e5b04e83cb3c43714ae # v3.27.9
+      uses: github/codeql-action/init@ff0a06e83cb2de871e5a09832bc6a81e7276941f # v3.28.18
       with:
         languages: ${{ matrix.language }}
         # If you wish to specify custom queries, you can do so here or in a config file.
@@ -80,6 +80,6 @@ jobs:
         ./script/test build
 
     - name: Perform CodeQL Analysis
-      uses: github/codeql-action/analyze@df409f7d9260372bd5f19e5b04e83cb3c43714ae # v3.27.9
+      uses: github/codeql-action/analyze@ff0a06e83cb2de871e5a09832bc6a81e7276941f # v3.28.18
       with:
         category: "/language:${{matrix.language}}"
diff --git a/.github/workflows/docker.yml b/.github/workflows/docker.yml
index e03da966c..fdb18103b 100644
--- a/.github/workflows/docker.yml
+++ b/.github/workflows/docker.yml
@@ -61,7 +61,7 @@ jobs:
 
     steps:
       - name: Harden Runner
-        uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
         with:
           egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -76,25 +76,25 @@ jobs:
 
       - name: Docker meta
         id: meta
-        uses: docker/metadata-action@v5
+        uses: docker/metadata-action@902fa8ec7d6ecbf8d84d538b9b233a880e428804 # v5.7.0
         with:
           images: |
             ${{ env.DOCKERHUB_REPO }}
 
       - name: Login to Docker Hub
         if: success() && github.repository == 'openthread/openthread' && github.event_name != 'pull_request'
-        uses: docker/login-action@9780b0c442fbb1117ed29e0efdff1e18412f7567 # v3.3.0
+        uses: docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772 # v3.4.0
         with:
           username: ${{ secrets.DOCKER_USERNAME }}
           password: ${{ secrets.DOCKER_PASSWORD }}
 
       - name: Set up Docker Buildx
-        uses: docker/setup-buildx-action@f7ce87c1d6bead3e36075b2ce75da1f6cc28aaca # v3.9.0
+        uses: docker/setup-buildx-action@b5ca514318bd6ebac0fb2aedd5d36ec1b5c232a2 # v3.10.0
 
       - name: Build and push by digest
         if: success()
         id: build
-        uses: docker/build-push-action@v6
+        uses: docker/build-push-action@1dc73863535b631f98b2378be8619f83b136f4a0 # v6.17.0
         with:
           file: etc/docker/environment/Dockerfile
           platforms: ${{ matrix.platform }}
@@ -111,7 +111,7 @@ jobs:
 
       - name: Upload digest
         if: success() && github.repository == 'openthread/openthread' && github.event_name != 'pull_request'
-        uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+        uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
         with:
           name: digests-${{ env.PLATFORM_PAIR }}
           path: ${{ runner.temp }}/digests/*
@@ -125,29 +125,29 @@ jobs:
       - build
     steps:
       - name: Harden Runner
-        uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
         with:
           egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
       - name: Download digests
-        uses: actions/download-artifact@v4
+        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
         with:
           path: ${{ runner.temp }}/digests
           pattern: digests-*
           merge-multiple: true
 
       - name: Login to Docker Hub
-        uses: docker/login-action@9780b0c442fbb1117ed29e0efdff1e18412f7567 # v3.3.0
+        uses: docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772 # v3.4.0
         with:
           username: ${{ secrets.DOCKER_USERNAME }}
           password: ${{ secrets.DOCKER_PASSWORD }}
 
       - name: Set up Docker Buildx
-        uses: docker/setup-buildx-action@f7ce87c1d6bead3e36075b2ce75da1f6cc28aaca # v3.9.0
+        uses: docker/setup-buildx-action@b5ca514318bd6ebac0fb2aedd5d36ec1b5c232a2 # v3.10.0
 
       - name: Docker meta
         id: meta
-        uses: docker/metadata-action@v5
+        uses: docker/metadata-action@902fa8ec7d6ecbf8d84d538b9b233a880e428804 #	v5.7.0
         with:
           images: |
             ${{ env.DOCKERHUB_REPO }}
diff --git a/.github/workflows/fuzz.yml b/.github/workflows/fuzz.yml
index 399b51c87..faef20d9b 100644
--- a/.github/workflows/fuzz.yml
+++ b/.github/workflows/fuzz.yml
@@ -45,7 +45,7 @@ jobs:
    runs-on: ubuntu-24.04
    steps:
    - name: Harden Runner
-     uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+     uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
      with:
        egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -61,7 +61,7 @@ jobs:
        fuzz-seconds: 1800
        dry-run: false
    - name: Upload Crash
-     uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+     uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
      if: failure()
      with:
        name: artifacts
diff --git a/.github/workflows/makefile-check.yml b/.github/workflows/makefile-check.yml
index b94bfa0aa..10aa0d2b8 100644
--- a/.github/workflows/makefile-check.yml
+++ b/.github/workflows/makefile-check.yml
@@ -48,7 +48,7 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
diff --git a/.github/workflows/otbr.yml b/.github/workflows/otbr.yml
index 4ab17ec1a..eec9df56b 100644
--- a/.github/workflows/otbr.yml
+++ b/.github/workflows/otbr.yml
@@ -87,12 +87,12 @@ jobs:
         export CI_ENV="$(bash <(curl -s https://codecov.io/env)) -e GITHUB_ACTIONS -e COVERAGE"
         echo "CI_ENV=${CI_ENV}"
         sudo -E ./script/test cert_suite ./tests/scripts/thread-cert/backbone/*.py || (sudo chmod a+r ot_testing/* && false)
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-thread-1-3-backbone-docker
         path: /tmp/coverage/
         retention-days: 1
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() }}
       with:
         name: thread-1-3-backbone-results
@@ -105,7 +105,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-thread-1-3-backbone
         path: tmp/coverage.info
@@ -153,12 +153,6 @@ jobs:
             packet_verification: 1
             nat64: 0
             description: ""
-          - otbr_mdns: "avahi"
-            otbr_trel: 1
-            cert_scripts: ./tests/scripts/thread-cert/border_router/*.py
-            packet_verification: 2
-            nat64: 0
-            description: ""
           - otbr_mdns: "avahi"
             otbr_trel: 0
             cert_scripts: ./tests/scripts/thread-cert/border_router/*.py
@@ -210,12 +204,12 @@ jobs:
         export CI_ENV="$(bash <(curl -s https://codecov.io/env)) -e GITHUB_ACTIONS -e COVERAGE"
         echo "CI_ENV=${CI_ENV}"
         sudo -E ./script/test cert_suite ${{ matrix.cert_scripts }} || (sudo chmod a+r ot_testing/* && false)
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-br-docker-${{ matrix.description }}-${{ matrix.otbr_mdns }}-${{matrix.otbr_trel}}
         path: /tmp/coverage/
         retention-days: 1
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() }}
       with:
         name: br-results-${{ matrix.description }}-${{ matrix.otbr_mdns }}-${{matrix.otbr_trel}}
@@ -228,7 +222,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-br-${{ matrix.description }}-${{ matrix.otbr_mdns }}-${{matrix.otbr_trel}}
         path: tmp/coverage.info
@@ -257,7 +251,7 @@ jobs:
         script/test combine_coverage
     - name: Upload Coverage
       continue-on-error: true
-      uses: codecov/codecov-action@0565863a31f2c772f9f0395002a31e3f06189574 # v5.4.0
+      uses: codecov/codecov-action@ad3126e916f78f00edff4ed0317cf185271ccc2d # v5.4.2
       env:
         CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
       with:
diff --git a/.github/workflows/otci.yml b/.github/workflows/otci.yml
index 6833fbe63..e7d160068 100644
--- a/.github/workflows/otci.yml
+++ b/.github/workflows/otci.yml
@@ -57,12 +57,12 @@ jobs:
       REAL_DEVICE: 0
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
diff --git a/.github/workflows/otns.yml b/.github/workflows/otns.yml
index b6be31679..f5f6fa3e0 100644
--- a/.github/workflows/otns.yml
+++ b/.github/workflows/otns.yml
@@ -58,16 +58,16 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
-    - uses: actions/setup-go@41dfa10bad2bb2ae585af6ee5bb4d7d973ad74ed # v5.1.0
+    - uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0
       with:
         go-version: "1.20"
     - name: Set up Python
-      uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+      uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: "3.9"
     - name: Bootstrap
@@ -82,7 +82,7 @@ jobs:
           cd /tmp/otns
           ./script/test py-unittests
         )
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() }}
       with:
         name: unittests-pcaps
@@ -92,7 +92,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-otns-unittests
         path: tmp/coverage.info
@@ -103,11 +103,11 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
       - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
-      - uses: actions/setup-go@41dfa10bad2bb2ae585af6ee5bb4d7d973ad74ed # v5.1.0
+      - uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0
         with:
           go-version: "1.20"
       - name: Set up Python
-        uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+        uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
         with:
           python-version: "3.9"
       - name: Bootstrap
@@ -122,7 +122,7 @@ jobs:
             cd /tmp/otns
             ./script/test py-examples
           )
-      - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+      - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
         if: ${{ failure() }}
         with:
           name: examples-pcaps
@@ -132,7 +132,7 @@ jobs:
       - name: Generate Coverage
         run: |
           ./script/test generate_coverage gcc
-      - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+      - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
         with:
           name: cov-otns-examples
           path: tmp/coverage.info
@@ -160,16 +160,16 @@ jobs:
       STRESS_LEVEL: ${{ matrix.stress_level }}
     steps:
       - name: Harden Runner
-        uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
         with:
           egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
       - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
-      - uses: actions/setup-go@41dfa10bad2bb2ae585af6ee5bb4d7d973ad74ed # v5.1.0
+      - uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0
         with:
           go-version: "1.20"
       - name: Set up Python
-        uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+        uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
         with:
           python-version: "3.9"
       - name: Bootstrap
@@ -184,7 +184,7 @@ jobs:
             cd /tmp/otns
             ./script/test stress-tests ${{ matrix.suite }}
           )
-      - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+      - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
         if: ${{ failure() }}
         with:
           name: stress-tests-${{ matrix.suite }}-pcaps
@@ -194,7 +194,7 @@ jobs:
       - name: Generate Coverage
         run: |
           ./script/test generate_coverage gcc
-      - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+      - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
         with:
           name: cov-otns-stress-tests-${{ matrix.suite }}
           path: tmp/coverage.info
@@ -208,7 +208,7 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
       - name: Harden Runner
-        uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
         with:
           egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
diff --git a/.github/workflows/posix.yml b/.github/workflows/posix.yml
index a2e927998..30eb244cd 100644
--- a/.github/workflows/posix.yml
+++ b/.github/workflows/posix.yml
@@ -52,12 +52,12 @@ jobs:
       CXXFLAGS: -DCLI_COAP_SECURE_USE_COAP_DEFAULT_HANDLER=1 -DOPENTHREAD_CONFIG_MLE_MAX_CHILDREN=15
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -81,7 +81,7 @@ jobs:
           CRASHED=$(./script/test check_crash | tail -1)
           [[ $CRASHED -eq "1" ]] && echo "Crashed!" || echo "Not crashed."
           echo "CRASHED_RCP=$CRASHED" >> $GITHUB_ENV
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() && env.CRASHED_RCP == '1' }}
       with:
         name: core-expect-rcp
@@ -90,7 +90,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-expects-linux-1
         path: tmp/coverage.info
@@ -115,13 +115,13 @@ jobs:
           CRASHED=$(./script/test check_crash | tail -1)
           [[ $CRASHED -eq "1" ]] && echo "Crashed!" || echo "Not crashed."
           echo "CRASHED_TUN=$CRASHED" >> $GITHUB_ENV
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() && env.CRASHED_TUN == '1' }}
       with:
         name: core-expect-linux
         path: |
           ./ot-core-dump/*
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() }}
       with:
         name: syslog-expect-linux
@@ -129,7 +129,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-expects-linux-2
         path: tmp/coverage.info
@@ -144,14 +144,14 @@ jobs:
       VIRTUAL_TIME: 1
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -166,7 +166,7 @@ jobs:
     - name: Run
       run: |
         MAX_JOBS=$(getconf _NPROCESSORS_ONLN) ./script/test cert_suite ./tests/scripts/thread-cert/Cert_*.py ./tests/scripts/thread-cert/test_*.py
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() }}
       with:
         name: thread-cert
@@ -174,7 +174,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-thread-cert
         path: tmp/coverage.info
@@ -192,7 +192,7 @@ jobs:
       OT_READLINE: 'readline'
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -225,7 +225,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-pty-linux-${{ matrix.OT_DAEMON }}
         path: tmp/coverage.info
@@ -243,7 +243,7 @@ jobs:
       OT_READLINE: 'off'
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -274,7 +274,7 @@ jobs:
     runs-on: ubuntu-22.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -295,7 +295,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-rcp-stack-reset
         path: tmp/coverage.info
@@ -309,7 +309,7 @@ jobs:
     runs-on: ubuntu-22.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -328,7 +328,7 @@ jobs:
       run: |
         script/test combine_coverage
     - name: Upload Coverage
-      uses: codecov/codecov-action@0565863a31f2c772f9f0395002a31e3f06189574 # v5.4.0
+      uses: codecov/codecov-action@ad3126e916f78f00edff4ed0317cf185271ccc2d # v5.4.2
       env:
         CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
       with:
diff --git a/.github/workflows/scorecards.yml b/.github/workflows/scorecards.yml
index 552cacdd2..8448014f5 100644
--- a/.github/workflows/scorecards.yml
+++ b/.github/workflows/scorecards.yml
@@ -87,7 +87,7 @@ jobs:
       # Upload the results as artifacts (optional). Commenting out will disable uploads of run results in SARIF
       # format to the repository Actions tab.
       - name: "Upload artifact"
-        uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v3.1.0
+        uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v3.1.0
         with:
           name: SARIF file
           path: results.sarif
@@ -95,6 +95,6 @@ jobs:
 
       # Upload the results to GitHub's code scanning dashboard.
       - name: "Upload to code-scanning"
-        uses: github/codeql-action/upload-sarif@df409f7d9260372bd5f19e5b04e83cb3c43714ae # v2.1.27
+        uses: github/codeql-action/upload-sarif@ff0a06e83cb2de871e5a09832bc6a81e7276941f # v2.1.27
         with:
           sarif_file: results.sarif
diff --git a/.github/workflows/simulation-1.1.yml b/.github/workflows/simulation-1.1.yml
index 704996fff..9ec81eaec 100644
--- a/.github/workflows/simulation-1.1.yml
+++ b/.github/workflows/simulation-1.1.yml
@@ -55,14 +55,14 @@ jobs:
       MULTIPLY: 3
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -80,7 +80,7 @@ jobs:
     - name: Run
       run: |
         ./script/test cert_suite ./tests/scripts/thread-cert/Cert_*.py ./tests/scripts/thread-cert/test_*.py
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() }}
       with:
         name: packet-verification-pcaps
@@ -90,7 +90,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-packet-verification
         path: tmp/coverage.info
@@ -108,14 +108,14 @@ jobs:
       VIRTUAL_TIME: 1
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -130,7 +130,7 @@ jobs:
     - name: Run
       run: |
         ./script/test cert_suite ./tests/scripts/thread-cert/Cert_*.py ./tests/scripts/thread-cert/test_*.py
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() }}
       with:
         name: cli-ftd-thread-cert
@@ -138,7 +138,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-cli-ftd
         path: tmp/coverage.info
@@ -163,14 +163,14 @@ jobs:
       MESSAGE_USE_HEAP: ${{ matrix.message_use_heap }}
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -185,7 +185,7 @@ jobs:
     - name: Run
       run: |
         ./script/test cert_suite ./tests/scripts/thread-cert/Cert_*.py ./tests/scripts/thread-cert/test_*.py
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() }}
       with:
         name: cli-mtd-thread-cert
@@ -193,7 +193,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-cli-mtd-${{ matrix.message_use_heap }}
         path: tmp/coverage.info
@@ -211,14 +211,14 @@ jobs:
       VIRTUAL_TIME: 1
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -233,7 +233,7 @@ jobs:
     - name: Run
       run: |
         ./script/test cert_suite ./tests/scripts/thread-cert/Cert_*.py ./tests/scripts/thread-cert/test_*.py
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() }}
       with:
         name: cli-time-sync-thread-cert
@@ -241,7 +241,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-cli-time-sync
         path: tmp/coverage.info
@@ -255,12 +255,12 @@ jobs:
       THREAD_VERSION: 1.1
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -280,7 +280,7 @@ jobs:
           CRASHED=$(./script/test check_crash | tail -1)
           [[ $CRASHED -eq "1" ]] && echo "Crashed!" || echo "Not crashed."
           echo "CRASHED_CLI=$CRASHED" >> $GITHUB_ENV
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() && env.CRASHED_CLI == '1' }}
       with:
         name: core-expect-cli
@@ -289,7 +289,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-expects
         path: tmp/coverage.info
@@ -301,14 +301,14 @@ jobs:
       THREAD_VERSION: 1.1
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -323,13 +323,14 @@ jobs:
       run: |
         cd /tmp/ot-commissioner
         script/bootstrap.sh
-        cmake -GNinja                           \
-              -DCMAKE_CXX_STANDARD=11           \
-              -DCMAKE_CXX_STANDARD_REQUIRED=ON  \
-              -DCMAKE_BUILD_TYPE=Release        \
-              -DCMAKE_INSTALL_PREFIX=/usr/local \
-              -DOT_COMM_COVERAGE=ON             \
-              -DOT_COMM_CCM=OFF                 \
+        cmake -GNinja                            \
+              -DCMAKE_POLICY_VERSION_MINIMUM=3.5 \
+              -DCMAKE_CXX_STANDARD=11            \
+              -DCMAKE_CXX_STANDARD_REQUIRED=ON   \
+              -DCMAKE_BUILD_TYPE=Release         \
+              -DCMAKE_INSTALL_PREFIX=/usr/local  \
+              -DOT_COMM_COVERAGE=ON              \
+              -DOT_COMM_CCM=OFF                  \
               -S . -B build
         cmake --build build
         sudo cmake --install build
@@ -342,7 +343,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-ot-commissioner
         path: tmp/coverage.info
@@ -357,14 +358,14 @@ jobs:
       CXXFLAGS: "-DOPENTHREAD_CONFIG_LOG_PREPEND_UPTIME=0"
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -378,7 +379,7 @@ jobs:
     - name: Run
       run: |
         ./script/test cert_suite ./tests/scripts/thread-cert/Cert_*.py ./tests/scripts/thread-cert/test_*.py
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() }}
       with:
         name: ot_testing
@@ -386,7 +387,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-multiple-instance
         path: tmp/coverage.info
@@ -398,7 +399,7 @@ jobs:
       COVERAGE: 1
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -414,7 +415,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-simulation-local-host
         path: tmp/coverage.info
@@ -432,7 +433,7 @@ jobs:
     runs-on: ubuntu-22.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -451,7 +452,7 @@ jobs:
       run: |
         script/test combine_coverage
     - name: Upload Coverage
-      uses: codecov/codecov-action@0565863a31f2c772f9f0395002a31e3f06189574 # v5.4.0
+      uses: codecov/codecov-action@ad3126e916f78f00edff4ed0317cf185271ccc2d # v5.4.2
       env:
         CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
       with:
diff --git a/.github/workflows/simulation-1.4.yml b/.github/workflows/simulation-1.4.yml
index 615e25db5..a8dc55aea 100644
--- a/.github/workflows/simulation-1.4.yml
+++ b/.github/workflows/simulation-1.4.yml
@@ -66,14 +66,14 @@ jobs:
         arch: ["m32", "m64"]
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -99,12 +99,12 @@ jobs:
           CRASHED=$(./script/test check_crash | tail -1)
           [[ $CRASHED -eq "1" ]] && echo "Crashed!" || echo "Not crashed."
           echo "CRASHED=$CRASHED" >> $GITHUB_ENV
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() }}
       with:
         name: thread-1-4-${{ matrix.compiler.c }}-${{ matrix.arch }}-pcaps
         path: "*.pcap"
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() && env.CRASHED == '1' }}
       with:
         name: core-packet-verification-thread-1-4
@@ -113,7 +113,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage "${{ matrix.compiler.gcov }}"
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-thread-1-4-${{ matrix.compiler.c }}-${{ matrix.arch }}
         path: tmp/coverage.info
@@ -132,14 +132,14 @@ jobs:
       INTER_OP_BBR: 0
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -174,14 +174,14 @@ jobs:
           CRASHED=$(./script/test check_crash | tail -1)
           [[ $CRASHED -eq "1" ]] && echo "Crashed!" || echo "Not crashed."
           echo "CRASHED=$CRASHED" >> $GITHUB_ENV
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() }}
       with:
         name: packet-verification-low-power-pcaps
         path: |
           *.pcap
           *.json
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() && env.CRASHED == '1' }}
       with:
         name: core-packet-verification-low-power
@@ -190,7 +190,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-packet-verification-low-power
         path: tmp/coverage.info
@@ -207,14 +207,14 @@ jobs:
       MULTIPLY: 3
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -232,7 +232,7 @@ jobs:
     - name: Run
       run: |
         ./script/test cert_suite ./tests/scripts/thread-cert/Cert_*.py ./tests/scripts/thread-cert/test_*.py
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() }}
       with:
         name: packet-verification-1.1-on-1.4-pcaps
@@ -242,7 +242,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-packet-verification-1-1-on-1-4
         path: tmp/coverage.info
@@ -259,14 +259,14 @@ jobs:
       VIRTUAL_TIME: 1
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -282,7 +282,7 @@ jobs:
       run: |
         ulimit -c unlimited
         ./script/test cert_suite ./tests/scripts/thread-cert/addon_test_channel_manager_autocsl*.py
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() }}
       with:
         name: channel-manager-csl
@@ -290,7 +290,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-channel-manager-csl
         path: tmp/coverage.info
@@ -304,14 +304,14 @@ jobs:
       VIRTUAL_TIME: 0
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -331,7 +331,7 @@ jobs:
           CRASHED=$(./script/test check_crash | tail -1)
           [[ $CRASHED -eq "1" ]] && echo "Crashed!" || echo "Not crashed."
           echo "CRASHED=$CRASHED" >> $GITHUB_ENV
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() && env.CRASHED == '1' }}
       with:
         name: core-expect-1-4
@@ -340,7 +340,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-expects
         path: tmp/coverage.info
@@ -359,14 +359,14 @@ jobs:
       INTER_OP: 1
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -394,12 +394,12 @@ jobs:
           CRASHED=$(./script/test check_crash | tail -1)
           [[ $CRASHED -eq "1" ]] && echo "Crashed!" || echo "Not crashed."
           echo "CRASHED=$CRASHED" >> $GITHUB_ENV
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() }}
       with:
         name: thread-1-4-posix-pcaps
         path: "*.pcap"
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: ${{ failure() && env.CRASHED == '1' }}
       with:
         name: core-thread-1-4-posix
@@ -408,7 +408,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-thread-1-4-posix
         path: tmp/coverage.info
@@ -424,7 +424,7 @@ jobs:
     runs-on: ubuntu-22.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -443,7 +443,7 @@ jobs:
       run: |
         script/test combine_coverage
     - name: Upload Coverage
-      uses: codecov/codecov-action@0565863a31f2c772f9f0395002a31e3f06189574 # v5.4.0
+      uses: codecov/codecov-action@ad3126e916f78f00edff4ed0317cf185271ccc2d # v5.4.2
       env:
         CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
       with:
diff --git a/.github/workflows/size.yml b/.github/workflows/size.yml
index 21f3c13ff..39bdd9c8c 100644
--- a/.github/workflows/size.yml
+++ b/.github/workflows/size.yml
@@ -49,7 +49,7 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
diff --git a/.github/workflows/toranj.yml b/.github/workflows/toranj.yml
index 2863b2605..a0c7dd370 100644
--- a/.github/workflows/toranj.yml
+++ b/.github/workflows/toranj.yml
@@ -59,14 +59,14 @@ jobs:
       TORANJ_EVENT_NAME: ${{ github.event_name }}
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -94,14 +94,14 @@ jobs:
       TORANJ_CLI: 1
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -119,7 +119,7 @@ jobs:
       if: "matrix.TORANJ_RADIO != 'multi'"
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       if: "matrix.TORANJ_RADIO != 'multi'"
       with:
         name: cov-toranj-cli-${{ matrix.TORANJ_RADIO }}
@@ -131,14 +131,14 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
       with:
         submodules: true
-    - uses: actions/setup-python@42375524e23c412d93fb67b49958b491fce71c38 # v5.4.0
+    - uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
       with:
         python-version: '3.12'
         cache: pip
@@ -173,7 +173,7 @@ jobs:
     runs-on: macos-14
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -195,7 +195,7 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -219,7 +219,7 @@ jobs:
     runs-on: ubuntu-22.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -238,7 +238,7 @@ jobs:
       run: |
         script/test combine_coverage
     - name: Upload Coverage
-      uses: codecov/codecov-action@0565863a31f2c772f9f0395002a31e3f06189574 # v5.4.0
+      uses: codecov/codecov-action@ad3126e916f78f00edff4ed0317cf185271ccc2d # v5.4.2
       env:
         CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
       with:
diff --git a/.github/workflows/unit.yml b/.github/workflows/unit.yml
index d661b094c..99629dfc6 100644
--- a/.github/workflows/unit.yml
+++ b/.github/workflows/unit.yml
@@ -49,7 +49,7 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -67,7 +67,7 @@ jobs:
       COVERAGE: 1
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -77,7 +77,7 @@ jobs:
     - name: Bootstrap
       run: |
         sudo apt-get update
-        sudo apt-get --no-install-recommends install -y ninja-build lcov
+        sudo apt-get --no-install-recommends install -y ninja-build lcov libgtest-dev libgmock-dev
     - name: Build Simulation
       run: ./script/cmake-build simulation -DOT_BUILD_GTEST=ON -DOT_BORDER_ROUTING=ON -DOT_BORDER_ROUTING_DHCP6_PD=ON
     - name: Test Simulation
@@ -88,7 +88,7 @@ jobs:
       run: cd build/simulation && ninja test
     - name: Build NCP Simulation
       run: ./script/cmake-build simulation -DOT_BUILD_GTEST=OFF -DOT_MTD=OFF -DOT_RCP=OFF -DOT_APP_CLI=OFF -DOT_APP_RCP=OFF \
-               -DOT_BORDER_ROUTING=ON -DOT_NCP_INFRA_IF=ON -DOT_SRP_SERVER=ON -DOT_NCP_DNSSD=ON -DOT_PLATFORM_DNSSD=ON
+               -DOT_BORDER_ROUTING=ON -DOT_NCP_INFRA_IF=ON -DOT_SRP_SERVER=ON -DOT_NCP_DNSSD=ON -DOT_PLATFORM_DNSSD=ON -DOT_NCP_CLI_STREAM=ON
     - name: Test NCP Simulation
       run: cd build/simulation && ninja test
     - name: Build POSIX
@@ -98,7 +98,7 @@ jobs:
     - name: Generate Coverage
       run: |
         ./script/test generate_coverage gcc
-    - uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
+    - uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
       with:
         name: cov-unit-tests
         path: tmp/coverage.info
@@ -109,7 +109,7 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
@@ -128,7 +128,7 @@ jobs:
       run: |
         script/test combine_coverage
     - name: Upload Coverage
-      uses: codecov/codecov-action@0565863a31f2c772f9f0395002a31e3f06189574 # v5.4.0
+      uses: codecov/codecov-action@ad3126e916f78f00edff4ed0317cf185271ccc2d # v5.4.2
       env:
         CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
       with:
diff --git a/.github/workflows/version.yml b/.github/workflows/version.yml
index ed6958f0b..7b1be0644 100644
--- a/.github/workflows/version.yml
+++ b/.github/workflows/version.yml
@@ -45,7 +45,7 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
     - name: Harden Runner
-      uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
+      uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
       with:
         egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
 
diff --git a/Android.bp b/Android.bp
index d21c37113..bcc96c57b 100644
--- a/Android.bp
+++ b/Android.bp
@@ -268,6 +268,8 @@ filegroup {
         "src/core/radio/trel_interface.cpp",
         "src/core/radio/trel_link.cpp",
         "src/core/radio/trel_packet.cpp",
+        "src/core/radio/trel_peer.cpp",
+        "src/core/radio/trel_peer_discoverer.cpp",
         "src/core/thread/address_resolver.cpp",
         "src/core/thread/announce_begin_server.cpp",
         "src/core/thread/announce_sender.cpp",
@@ -289,7 +291,7 @@ filegroup {
         "src/core/thread/mesh_forwarder_ftd.cpp",
         "src/core/thread/mesh_forwarder_mtd.cpp",
         "src/core/thread/mle.cpp",
-        "src/core/thread/mle_router.cpp",
+        "src/core/thread/mle_ftd.cpp",
         "src/core/thread/mle_tlvs.cpp",
         "src/core/thread/mle_types.cpp",
         "src/core/thread/mlr_manager.cpp",
@@ -311,10 +313,12 @@ filegroup {
         "src/core/thread/router.cpp",
         "src/core/thread/router_table.cpp",
         "src/core/thread/src_match_controller.cpp",
+        "src/core/thread/thread_link_info.cpp",
         "src/core/thread/thread_netif.cpp",
         "src/core/thread/time_sync_service.cpp",
         "src/core/thread/tmf.cpp",
         "src/core/thread/uri_paths.cpp",
+        "src/core/thread/version.cpp",
         "src/core/utils/channel_manager.cpp",
         "src/core/utils/channel_monitor.cpp",
         "src/core/utils/flash.cpp",
@@ -519,6 +523,8 @@ cc_library_static {
         // run below Android U (34).
         "-Wno-unguarded-availability",
         "-Wno-c99-extensions",
+        // Suppress warning in src/core/net/srp_client.cpp
+        "-Wno-implicit-fallthrough",
     ],
 
     vintf_fragments: ["src/android/thread_network_hal/device_manifest.xml"],
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 71eb77ead..f4500181d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -122,15 +122,21 @@ list(APPEND OT_PUBLIC_INCLUDES ${PROJECT_SOURCE_DIR}/include)
 if(OT_PLATFORM STREQUAL "posix")
     target_include_directories(ot-config INTERFACE ${PROJECT_SOURCE_DIR}/src/posix/platform)
     target_compile_definitions(ot-config INTERFACE OPENTHREAD_PLATFORM_POSIX=1)
+    target_compile_definitions(ot-config INTERFACE OPENTHREAD_PLATFORM_NEXUS=0)
     add_subdirectory("${PROJECT_SOURCE_DIR}/src/posix/platform")
 elseif(OT_PLATFORM STREQUAL "external")
+    target_compile_definitions(ot-config INTERFACE OPENTHREAD_PLATFORM_POSIX=0)
+    target_compile_definitions(ot-config INTERFACE OPENTHREAD_PLATFORM_NEXUS=0)
     # skip in this case
 elseif(OT_PLATFORM STREQUAL "nexus")
     if (OT_APP_CLI OR OT_APP_NCP OR OT_APP_RCP)
         message(FATAL_ERROR "no app (cli/ncp/rcp) should be enabled with nexus simulation platform")
     endif()
     target_compile_definitions(ot-config INTERFACE OPENTHREAD_PLATFORM_NEXUS=1)
+    target_compile_definitions(ot-config INTERFACE OPENTHREAD_PLATFORM_POSIX=0)
 else()
+    target_compile_definitions(ot-config INTERFACE OPENTHREAD_PLATFORM_POSIX=0)
+    target_compile_definitions(ot-config INTERFACE OPENTHREAD_PLATFORM_NEXUS=0)
     target_include_directories(ot-config INTERFACE ${PROJECT_SOURCE_DIR}/examples/platforms/${OT_PLATFORM})
     add_subdirectory("${PROJECT_SOURCE_DIR}/examples/platforms/${OT_PLATFORM}")
 endif()
diff --git a/README.md b/README.md
index f05287406..e0b138b77 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,4 @@
-[![OpenThread][ot-logo]][ot-repo] [![Build][ot-gh-action-build-svg]][ot-gh-action-build] [![Simulation][ot-gh-action-simulation-svg]][ot-gh-action-simulation] [![Docker][ot-gh-action-docker-svg]][ot-gh-action-docker] [![Coverage Status][ot-codecov-svg]][ot-codecov]
+[![OpenThread][ot-logo]][ot-repo] [![Build][ot-gh-action-build-svg]][ot-gh-action-build] [![Simulation][ot-gh-action-simulation-svg]][ot-gh-action-simulation] [![Docker][ot-gh-action-docker-svg]][ot-gh-action-docker] [![Coverage Status][ot-codecov-svg]][ot-codecov] [![Ask DeepWiki][deep-wiki-svg]][deep-wiki]
 
 ---
 
@@ -24,6 +24,8 @@ More information about Thread can be found at [threadgroup.org](http://threadgro
 [ot-gh-action-docker-svg]: https://github.com/openthread/openthread/workflows/Docker/badge.svg?branch=main&event=push
 [ot-codecov]: https://codecov.io/gh/openthread/openthread
 [ot-codecov-svg]: https://codecov.io/gh/openthread/openthread/branch/main/graph/badge.svg
+[deep-wiki]: https://deepwiki.com/openthread/openthread
+[deep-wiki-svg]: https://deepwiki.com/badge.svg
 
 # Who supports OpenThread?
 
diff --git a/etc/cmake/options.cmake b/etc/cmake/options.cmake
index 92a516a90..bffda1fa4 100644
--- a/etc/cmake/options.cmake
+++ b/etc/cmake/options.cmake
@@ -176,6 +176,7 @@ ot_option(OT_BLE_TCAT OPENTHREAD_CONFIG_BLE_TCAT_ENABLE "Ble based thread commis
 ot_option(OT_BORDER_AGENT OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE "border agent")
 ot_option(OT_BORDER_AGENT_EPSKC OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE "border agent ephemeral PSKc")
 ot_option(OT_BORDER_AGENT_ID OPENTHREAD_CONFIG_BORDER_AGENT_ID_ENABLE "create and save border agent ID")
+ot_option(OT_BORDER_AGENT_MESHCOP_SERVICE OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE "border agent meshcop service")
 ot_option(OT_BORDER_ROUTER OPENTHREAD_CONFIG_BORDER_ROUTER_ENABLE "border router")
 ot_option(OT_BORDER_ROUTING OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE "border routing")
 ot_option(OT_BORDER_ROUTING_DHCP6_PD OPENTHREAD_CONFIG_BORDER_ROUTING_DHCP6_PD_ENABLE "dhcpv6 pd support in border routing")
@@ -261,6 +262,7 @@ ot_option(OT_UPTIME OPENTHREAD_CONFIG_UPTIME_ENABLE "uptime")
 ot_option(OT_VERHOEFF_CHECKSUM OPENTHREAD_CONFIG_VERHOEFF_CHECKSUM_ENABLE "verhoeff checksum")
 ot_option(OT_WAKEUP_COORDINATOR OPENTHREAD_CONFIG_WAKEUP_COORDINATOR_ENABLE "wake-up coordinator")
 ot_option(OT_WAKEUP_END_DEVICE OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE "wake-up end device")
+ot_option(OT_SPINEL_CP_RESET_FAIL_CALLBACK_ENABLE OPENTHREAD_SPINEL_CONFIG_COPROCESSOR_RESET_FAILURE_CALLBACK_ENABLE "CP reset failure callback")
 
 option(OT_DOC "build OpenThread documentation")
 message(STATUS "- - - - - - - - - - - - - - - - ")
@@ -331,6 +333,7 @@ ot_multi_option(OT_LOG_OUTPUT OT_LOG_OUTPUT_VALUES OPENTHREAD_CONFIG_LOG_OUTPUT
 ot_string_option(OT_VENDOR_NAME OPENTHREAD_CONFIG_NET_DIAG_VENDOR_NAME "set the vendor name config")
 ot_string_option(OT_VENDOR_MODEL OPENTHREAD_CONFIG_NET_DIAG_VENDOR_MODEL "set the vendor model config")
 ot_string_option(OT_VENDOR_SW_VERSION OPENTHREAD_CONFIG_NET_DIAG_VENDOR_SW_VERSION "set the vendor sw version config")
+ot_string_option(OT_BORDER_AGENT_SERVICE_NAME OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_BASE_NAME "set the border agent service base name")
 
 set(OT_POWER_SUPPLY_VALUES "BATTERY" "EXTERNAL" "EXTERNAL_STABLE" "EXTERNAL_UNSTABLE")
 ot_multi_option(OT_POWER_SUPPLY OT_POWER_SUPPLY_VALUES OPENTHREAD_CONFIG_DEVICE_POWER_SUPPLY OT_POWER_SUPPLY_ "set the device power supply config")
diff --git a/examples/apps/cli/ftd.cmake b/examples/apps/cli/ftd.cmake
index 9ed9be18c..6cbe17ef8 100644
--- a/examples/apps/cli/ftd.cmake
+++ b/examples/apps/cli/ftd.cmake
@@ -33,6 +33,13 @@ add_executable(ot-cli-ftd
 
 target_include_directories(ot-cli-ftd PRIVATE ${COMMON_INCLUDES})
 
+target_compile_definitions(ot-cli-ftd
+    PRIVATE
+        OPENTHREAD_FTD=1
+        OPENTHREAD_MTD=0
+        OPENTHREAD_RADIO=0
+)
+
 if(NOT DEFINED OT_PLATFORM_LIB_FTD)
     set(OT_PLATFORM_LIB_FTD ${OT_PLATFORM_LIB})
 endif()
diff --git a/examples/apps/cli/mtd.cmake b/examples/apps/cli/mtd.cmake
index 786f74161..df15ac713 100644
--- a/examples/apps/cli/mtd.cmake
+++ b/examples/apps/cli/mtd.cmake
@@ -33,6 +33,13 @@ add_executable(ot-cli-mtd
 
 target_include_directories(ot-cli-mtd PRIVATE ${COMMON_INCLUDES})
 
+target_compile_definitions(ot-cli-mtd
+    PRIVATE
+        OPENTHREAD_FTD=0
+        OPENTHREAD_MTD=1
+        OPENTHREAD_RADIO=0
+)
+
 if(NOT DEFINED OT_PLATFORM_LIB_MTD)
     set(OT_PLATFORM_LIB_MTD ${OT_PLATFORM_LIB})
 endif()
diff --git a/examples/apps/cli/radio.cmake b/examples/apps/cli/radio.cmake
index b2fe5d968..442407426 100644
--- a/examples/apps/cli/radio.cmake
+++ b/examples/apps/cli/radio.cmake
@@ -33,6 +33,13 @@ add_executable(ot-cli-radio
 
 target_include_directories(ot-cli-radio PRIVATE ${COMMON_INCLUDES})
 
+target_compile_definitions(ot-cli-radio
+    PRIVATE
+        OPENTHREAD_FTD=0
+        OPENTHREAD_MTD=0
+        OPENTHREAD_RADIO=1
+)
+
 if(NOT DEFINED OT_PLATFORM_LIB_RCP)
     set(OT_PLATFORM_LIB_RCP ${OT_PLATFORM_LIB})
 endif()
diff --git a/examples/platforms/simulation/dns.c b/examples/platforms/simulation/dns.c
index 0542af062..66ac155bb 100644
--- a/examples/platforms/simulation/dns.c
+++ b/examples/platforms/simulation/dns.c
@@ -32,6 +32,13 @@
 
 #if OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE
 
+bool otPlatDnsIsUpstreamQueryAvailable(otInstance *aInstance)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+
+    return true;
+}
+
 void otPlatDnsStartUpstreamQuery(otInstance *aInstance, otPlatDnsUpstreamQuery *aTxn, const otMessage *aQuery)
 {
     OT_UNUSED_VARIABLE(aInstance);
diff --git a/examples/platforms/simulation/dnssd.c b/examples/platforms/simulation/dnssd.c
index ab5ae998e..9b83227c6 100644
--- a/examples/platforms/simulation/dnssd.c
+++ b/examples/platforms/simulation/dnssd.c
@@ -164,4 +164,16 @@ void otPlatDnssdStopIp4AddressResolver(otInstance *aInstance, const otPlatDnssdA
     OT_UNUSED_VARIABLE(aResolver);
 }
 
+void otPlatDnssdStartRecordQuerier(otInstance *aInstance, const otPlatDnssdRecordQuerier *aQuerier)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    OT_UNUSED_VARIABLE(aQuerier);
+}
+
+void otPlatDnssdStopRecordQuerier(otInstance *aInstance, const otPlatDnssdRecordQuerier *aQuerier)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    OT_UNUSED_VARIABLE(aQuerier);
+}
+
 #endif // OPENTHREAD_CONFIG_PLATFORM_DNSSD_ENABLE && OPENTHREAD_SIMULATION_IMPLEMENT_DNSSD
diff --git a/include/openthread/backbone_router_ftd.h b/include/openthread/backbone_router_ftd.h
index 64fc71615..e27551959 100644
--- a/include/openthread/backbone_router_ftd.h
+++ b/include/openthread/backbone_router_ftd.h
@@ -328,7 +328,7 @@ typedef enum
  *
  * @param[in] aContext  The user context pointer.
  * @param[in] aEvent    The ND Proxy event.
- * @param[in] aDua      The Domain Unicast Address of the ND Proxy, or `nullptr` if @p aEvent is
+ * @param[in] aDua      The Domain Unicast Address of the ND Proxy, or NULL if @p aEvent is
  *                      `OT_BACKBONE_ROUTER_NDPROXY_CLEARED`.
  */
 typedef void (*otBackboneRouterNdProxyCallback)(void                        *aContext,
@@ -385,7 +385,7 @@ typedef enum
  *
  * @param[in] aContext       The user context pointer.
  * @param[in] aEvent         The Domain Prefix event.
- * @param[in] aDomainPrefix  The new Domain Prefix if added or changed, nullptr otherwise.
+ * @param[in] aDomainPrefix  The new Domain Prefix if added or changed, NULL otherwise.
  */
 typedef void (*otBackboneRouterDomainPrefixCallback)(void                             *aContext,
                                                      otBackboneRouterDomainPrefixEvent aEvent,
diff --git a/include/openthread/border_agent.h b/include/openthread/border_agent.h
index 920b294dc..9038396b8 100644
--- a/include/openthread/border_agent.h
+++ b/include/openthread/border_agent.h
@@ -35,6 +35,7 @@
 #ifndef OPENTHREAD_BORDER_AGENT_H_
 #define OPENTHREAD_BORDER_AGENT_H_
 
+#include <openthread/dns.h>
 #include <openthread/instance.h>
 #include <openthread/ip6.h>
 
@@ -117,7 +118,30 @@ typedef struct otBorderAgentSessionIterator
     uint64_t mData;
 } otBorderAgentSessionIterator;
 
-#define OT_BORDER_AGENT_MESHCOP_SERVICE_TXT_DATA_MAX_LENGTH 128
+/**
+ * Maximum length of the OT core generated MeshCoP Service TXT data.
+ *
+ * Each field has the format:
+ * | Length (1 byte) | "Keyname=" | Data |
+ *
+ * Fields:
+ * Border Agent Id (id)                 - 4 + 16 = 20 bytes
+ * Version of TXT record format (rv)    - 4 + 1  = 5 bytes
+ * Network Name (nn)                    - 4 + 16 = 20 bytes
+ * ExtendedPanId (xp)                   - 4 + 8 = 12 bytes
+ * Thread Version (tv)                  - 4 + 5 = 9 bytes
+ * Extended Address (xa)                - 4 + 8 = 12 bytes
+ * State Bitmap (sb)                    - 4 + 4 = 8 bytes
+ * Partition Id (pt)                    - 4 + 4 = 8 bytes
+ * Active Timestamp (at)                - 4 + 8 = 12 bytes
+ * Backbone Router Sequence Number (sq) - 4 + 1 = 5 bytes
+ * Backbone Router Udp Port (bb)        - 4 + 2 = 6 bytes
+ * Backbone Router Domain Name (dn)     - 4 + 16 = 20 bytes
+ * On-Mesh Routable Prefix (omr)        - 5 + 9 = 14 bytes
+ *
+ * Maximum possible data length: 151 bytes
+ */
+#define OT_BORDER_AGENT_MESHCOP_SERVICE_TXT_DATA_MAX_LENGTH 256
 
 /**
  * Represents the Border Agent MeshCoP Service TXT data.
@@ -129,7 +153,35 @@ typedef struct otBorderAgentMeshCoPServiceTxtData
 } otBorderAgentMeshCoPServiceTxtData;
 
 /**
- * Indicates whether or not the Border Agent service is active and running.
+ * Enables or disables the Border Agent service on the device.
+ *
+ * By default, the Border Agent service is enabled when the `OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE` feature is used.
+ * This function allows higher-layer code to explicitly control its state. This can be useful in scenarios such as:
+ *
+ * - The higher-layer code wishes to delay the start of the Border Agent service (and its mDNS advertisement of the
+ *  `_meshcop._udp` service on the infrastructure link). This allows time to prepare or determine vendor-specific TXT
+ *   data entries for inclusion.
+ * - Unit tests or test scripts might disable the Border Agent service to prevent it from interfering with specific
+ *   test steps. For example, tests validating mDNS or DNS-SD functionality may disable the Border Agent to prevent its
+ *   registration of the MeshCoP service.
+ *
+ * @param[in] aInstance  The OpenThread instance.
+ * @param[in] aEnabled   A boolean to indicate whether to to enable (TRUE), or disable (FALSE).
+ */
+void otBorderAgentSetEnabled(otInstance *aInstance, bool aEnabled);
+
+/**
+ * Indicates whether or not the Border Agent service is enabled.
+ *
+ * @param[in] aInstance  The OpenThread instance.
+ *
+ * @retval TRUE   The Border Agent service is enabled.
+ * @retval FALSE  The Border Agent service is disabled.
+ */
+bool otBorderAgentIsEnabled(otInstance *aInstance);
+
+/**
+ * Indicates whether or not the Border Agent service is enabled and also active.
  *
  * While the Border Agent is active, external commissioner candidates can try to connect to and establish secure DTLS
  * sessions with the Border Agent using PSKc. A connected commissioner can then petition to become a full commissioner.
@@ -184,6 +236,12 @@ void otBorderAgentSetMeshCoPServiceChangedCallback(otInstance
 /**
  * Gets the MeshCoP service TXT data.
  *
+ * The generated TXT data includes a subset of keys (depending on the device's current state and whether features are
+ * enabled) as specified in the documentation of the `OT_BORDER_AGENT_MESHCOP_SERVICE_TXT_DATA_MAX_LENGTH` constant.
+ * Notably, if `OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE` is enabled and `otBorderAgentSetVendorTxtData()`
+ * was used to set extra vendor-specific TXT data bytes, those vendor-specified TXT data bytes are NOT included in the
+ * TXT data returned by this function.
+ *
  * @param[in]  aInstance  A pointer to an OpenThread instance.
  * @param[out] aTxtData   A pointer to a MeshCoP Service TXT data struct to get the data.
  *
@@ -192,6 +250,65 @@ void otBorderAgentSetMeshCoPServiceChangedCallback(otInstance
  */
 otError otBorderAgentGetMeshCoPServiceTxtData(otInstance *aInstance, otBorderAgentMeshCoPServiceTxtData *aTxtData);
 
+/**
+ * Maximum string length of base name used in `otBorderAgentSetMeshCoPServiceBaseName()`.
+ *
+ * The full DNS label is constructed by appending the Extended Address of the device (as 16-character hex digits) to
+ * the given base name.
+ */
+#define OT_BORDER_AGENT_MESHCOP_SERVICE_BASE_NAME_MAX_LENGTH (OT_DNS_MAX_LABEL_SIZE - 17)
+
+/**
+ * Sets the base name to construct the service instance name used when advertising the mDNS `_meshcop._udp` service by
+ * the Border Agent.
+ *
+ * Requires the `OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE` feature.
+ *
+ * The name can also be configured using the `OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_BASE_NAME` configuration
+ * option (which is the recommended way to specify this name). This API is provided for projects where the name needs
+ * to be set after device initialization and at run-time.
+ *
+ * Per the Thread specification, the service instance should be a user-friendly name identifying the device model or
+ * product. A recommended format is "VendorName ProductName".
+ *
+ * To construct the full name and ensure name uniqueness, the OpenThread Border Agent module will append the Extended
+ * Address of the device (as 16-character hex digits) to the given base name.
+ *
+ * Note that the same name will be used for the ephemeral key service `_meshcop-e._udp` when the ephemeral key feature
+ * is enabled and used.
+ *
+ * @param[in] aInstance  The OpenThread instance.
+ * @param[in] aBaseName  The base name to use (MUST not be NULL).
+ *
+ * @retval OT_ERROR_NONE          The name was set successfully.
+ * @retval OT_ERROR_INVALID_ARGS  The name is too long or invalid.
+ */
+otError otBorderAgentSetMeshCoPServiceBaseName(otInstance *aInstance, const char *aBaseName);
+
+/**
+ * Sets the vendor extra TXT data to be included when the Border Agent advertises the mDNS `_meshcop._udp` service.
+ *
+ * Requires the `OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE` feature.
+ *
+ * The provided @p aVendorData bytes are appended as they appear in the buffer to the end of the TXT data generated by
+ * the Border Agent itself, and are then included in the advertised mDNS `_meshcop._udp` service.
+ *
+ * This function itself does not perform any validation of the format of the provided @p aVendorData. Therefore, the
+ * caller MUST ensure it is formatted properly. Per the Thread specification, vendor-specific Key-Value TXT data pairs
+ * use TXT keys starting with 'v'. For example, `vn` for vendor name and generally `v*`.
+ *
+ * The OpenThread stack will create and retain its own copy of the bytes in @p aVendorData. So, the buffer passed to
+ * this function does not need to persist beyond the scope of the call.
+ *
+ * The vendor TXT data can be set at any time while the Border Agent is in any state. If there is a change from the
+ * previously set value, it will trigger an update of the registered mDNS service to advertise the new TXT data.
+ *
+ * @param[in] aInstance          The OpenThread instance.
+ * @param[in] aVendorData        A pointer to the buffer containing the vendor TXT data.
+ * @param[in] aVendorDataLength  The length of @p aVendorData in bytes.
+ */
+void otBorderAgentSetVendorTxtData(otInstance *aInstance, const uint8_t *aVendorData, uint16_t aVendorDataLength);
+
 /**
  * Gets the randomly generated Border Agent ID.
  *
diff --git a/include/openthread/border_routing.h b/include/openthread/border_routing.h
index 3eb12c147..5ed54bf8f 100644
--- a/include/openthread/border_routing.h
+++ b/include/openthread/border_routing.h
@@ -127,6 +127,20 @@ typedef struct otBorderRoutingPrefixTableEntry
     uint32_t                   mPreferredLifetime;   ///< Preferred lifetime of the on-link prefix when `mIsOnLink`.
 } otBorderRoutingPrefixTableEntry;
 
+/**
+ * Represents a discovered Recursive DNS Server (RDNSS) address entry.
+ *
+ * Address entries are discovered by processing the RDNSS options within received Router Advertisement messages from
+ * routers on infrastructure link.
+ */
+typedef struct otBorderRoutingRdnssAddrEntry
+{
+    otBorderRoutingRouterEntry mRouter;              ///< Information about the router advertising this address.
+    otIp6Address               mAddress;             ///< The DNS Server IPv6 address.
+    uint32_t                   mMsecSinceLastUpdate; ///< Milliseconds since last update of this address.
+    uint32_t                   mLifetime;            ///< Lifetime of the address (in seconds).
+} otBorderRoutingRdnssAddrEntry;
+
 /**
  * Represents information about a peer Border Router found in the Network Data.
  */
@@ -146,6 +160,19 @@ typedef struct otPdProcessedRaInfo
     uint32_t mLastPlatformRaMsec;      ///< The timestamp of last processed RA message.
 } otPdProcessedRaInfo;
 
+/**
+ * Represents the configuration options related to the OMR prefix.
+ *
+ * This is used in `otBorderRoutingSetOmrConfig()` to offer manual administration options to explicitly configure
+ * the OMR prefix or to disable it.
+ */
+typedef enum
+{
+    OT_BORDER_ROUTING_OMR_CONFIG_AUTO,     ///< BR auto-generates the local OMR prefix.
+    OT_BORDER_ROUTING_OMR_CONFIG_CUSTOM,   ///< BR uses a given custom OMR prefix.
+    OT_BORDER_ROUTING_OMR_CONFIG_DISABLED, ///< BR does not add local/PD OMR prefix in Network Data.
+} otBorderRoutingOmrConfig;
+
 /**
  * Represents the state of Border Routing Manager.
  */
@@ -212,6 +239,56 @@ otError otBorderRoutingSetEnabled(otInstance *aInstance, bool aEnabled);
  */
 otBorderRoutingState otBorderRoutingGetState(otInstance *aInstance);
 
+/**
+ * Configures the OMR prefix handling in the Border Routing Manager.
+ *
+ * This function offers manual administration options to explicitly configure the OMR prefix or to disable it.
+ *
+ * By default, `OT_BORDER_ROUTING_OMR_CONFIG_AUTO` is used. In this mode, the Border Routing Manager automatically
+ * selects and manages the OMR prefix. This can involve auto-generating a local prefix or utilizing a prefix obtained
+ * through DHCPv6 PD (Prefix Delegation), if the feature is enabled.
+ *
+ * The `OT_BORDER_ROUTING_OMR_CONFIG_CUSTOM` option enables the use of a user-specified OMR prefix. When this option
+ * is selected, the @p aOmrPrefix and @p aPreference parameters are used to define the custom OMR prefix and its
+ * associated preference. These parameters are ignored for other configuration modes, and @p aOmrPrefix can be `NULL`.
+ *
+ * The `OT_BORDER_ROUTING_OMR_CONFIG_DISABLED` option disables the Border Routing Manager's management of the OMR
+ * prefix. The Routing Manager module itself will not add any local or DHCPv6 PD OMR prefixes to the Network Data.
+ *
+ * @param[in] aInstance      A pointer to the OpenThread instance.
+ * @param[in] aConfig        The desired OMR configuration.
+ * @param[in] aOmrPrefix     A pointer to the custom OMR prefix. Required only when @p aConfig is
+ *                           `OT_BORDER_ROUTING_OMR_CONFIG_CUSTOM`. Otherwise, it can be `NULL`.
+ * @param[in] aPreference    The preference associated with the custom OMR prefix.
+ *
+ * @retval OT_ERROR_NONE           The OMR configuration was successfully set to @p aConfig.
+ * @retval OT_ERROR_INVALID_ARGS   The provided custom OMR prefix (@p aOmrPrefix) is invalid.
+ */
+otError otBorderRoutingSetOmrConfig(otInstance              *aInstance,
+                                    otBorderRoutingOmrConfig aConfig,
+                                    const otIp6Prefix       *aOmrPrefix,
+                                    otRoutePreference        aPreference);
+
+/**
+ * Gets the current OMR prefix configuration mode.
+ *
+ * This function retrieves the current OMR configuration and, if a custom OMR prefix is configured, the custom prefix
+ * and its associated preference.
+ *
+ * If the caller does not require the custom OMR prefix and preference, the @p aOmrPrefix and @p aPreference parameters
+ * can be set to `NULL`.
+ *
+ * @param[in]  aInstance      A pointer to the OpenThread instance.
+ * @param[out] aOmrPrefix     A pointer to an `otIp6Prefix` to return the custom OMR prefix, if the configuration is
+ *                            `OT_BORDER_ROUTING_OMR_CONFIG_CUSTOM`.
+ * @param[out] aPreference    A pointer to return the preference associated with the custom OMR prefix.
+ *
+ * @return The current OMR prefix configuration mode.
+ */
+otBorderRoutingOmrConfig otBorderRoutingGetOmrConfig(otInstance        *aInstance,
+                                                     otIp6Prefix       *aOmrPrefix,
+                                                     otRoutePreference *aPreference);
+
 /**
  * Gets the current preference used when advertising Route Info Options (RIO) in Router Advertisement
  * messages sent over the infrastructure link.
@@ -455,7 +532,6 @@ void otBorderRoutingPrefixTableInitIterator(otInstance *aInstance, otBorderRouti
 otError otBorderRoutingGetNextPrefixTableEntry(otInstance                         *aInstance,
                                                otBorderRoutingPrefixTableIterator *aIterator,
                                                otBorderRoutingPrefixTableEntry    *aEntry);
-
 /**
  * Iterates over the discovered router entries on the infrastructure link.
  *
@@ -520,6 +596,124 @@ otError otBorderRoutingGetNextPeerBrEntry(otInstance                           *
  */
 uint16_t otBorderRoutingCountPeerBrs(otInstance *aInstance, uint32_t *aMinAge);
 
+/**
+ * A callback function pointer called when the multi-AIL detection state changes.
+ *
+ * This callback function is invoked by the OpenThread stack whenever the Routing Manager determines a change in
+ * whether Border Routers on the Thread mesh might be connected to different Adjacent Infrastructure Links (AILs).
+ *
+ * See `otBorderRoutingIsMultiAilDetected()` for more details.
+ *
+ * @param[in] aDetected   `TRUE` if multiple AILs are now detected, `FALSE` otherwise.
+ * @param[in] aContext    A pointer to arbitrary context information provided when the callback was registered
+ *                        using `otBorderRoutingSetMultiAilCallback()`.
+ */
+typedef void (*otBorderRoutingMultiAilCallback)(bool aDetected, void *aContext);
+
+/**
+ * Gets the current detected state regarding multiple Adjacent Infrastructure Links (AILs).
+ *
+ * Requires `OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE`.
+ *
+ * It returns whether the Routing Manager currently believes that Border Routers (BRs) on the Thread mesh may be
+ * connected to different AILs.
+ *
+ * The detection mechanism operates as follows: The Routing Manager monitors the number of peer BRs listed in the
+ * Thread Network Data (see `otBorderRoutingCountPeerBrs()`) and compares this count with the number of peer BRs
+ * discovered by processing received Router Advertisement (RA) messages on its connected AIL. If the count derived from
+ * Network Data consistently exceeds the count derived from RAs for a detection duration of 10 minutes, it concludes
+ * that BRs are likely connected to different AILs. To clear state a shorter window of 1 minute is used.
+ *
+ * The detection window of 10 minutes helps to avoid false positives due to transient changes. The Routing Manager uses
+ * 200 seconds for reachability checks of peer BRs (sending Neighbor Solicitation). Stale Network Data entries are
+ * also expected to age out within a few minutes. So a 10-minute detection time accommodates both cases.
+ *
+ * While generally effective, this detection mechanism may get less reliable in scenarios with a large number of
+ * BRs, particularly exceeding ten. This is related to the "Network Data Publisher" mechanism, where BRs might refrain
+ * from publishing their external route information in the Network Data to conserve its limited size, potentially
+ * skewing the Network Data BR count.
+ *
+ * @param[in] aInstance  A pointer to the OpenThread instance.
+ *
+ * @retval TRUE   Has detected that BRs are likely connected to multiple AILs.
+ * @retval FALSE  Has not detected (or no longer detects) that BRs are connected to multiple AILs.
+ */
+bool otBorderRoutingIsMultiAilDetected(otInstance *aInstance);
+
+/**
+ * Sets a callback function to be notified of changes in the multi-AIL detection state.
+ *
+ * Requires `OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE`.
+ *
+ * Subsequent calls to this function will overwrite the previous callback setting. Using `NULL` for @p aCallback will
+ * disable the callback.
+ *
+ * @param[in] aInstance  A pointer to the OpenThread instance.
+ * @param[in] aCallback  A pointer to the function (`otBorderRoutingMultiAilCallback`) to be called
+ *                       upon state changes, or `NULL` to unregister a previously set callback.
+ * @param[in] aContext   A pointer to application-specific context that will be passed back
+ *                       in the `aCallback` function. This can be `NULL` if no context is needed.
+ */
+void otBorderRoutingSetMultiAilCallback(otInstance                     *aInstance,
+                                        otBorderRoutingMultiAilCallback aCallback,
+                                        void                           *aContext);
+
+/**
+ * Iterates over the Recursive DNS Server (RDNSS) address entries.
+ *
+ * Address entries are discovered by processing the RDNSS options within received Router Advertisement messages from
+ * routers on infrastructure link.
+ *
+ * Address entries associated with the same discovered router on an infrastructure link are guaranteed to be grouped
+ * together (retrieved back-to-back).
+ *
+ * @param[in]     aInstance    The OpenThread instance.
+ * @param[in,out] aIterator    A pointer to the iterator.
+ * @param[out]    aEntry       A pointer to the entry to populate.
+ *
+ * @retval OT_ERROR_NONE          Iterated to the next address entry, @p aEntry and @p aIterator are updated.
+ * @retval OT_ERROR_NOT_FOUND     No more entries in the table.
+ * @retval OT_ERROR_INVALID_ARSG  The iterator is invalid (used to iterate over other entry types, e.g. prefix).
+ */
+otError otBorderRoutingGetNextRdnssAddrEntry(otInstance                         *aInstance,
+                                             otBorderRoutingPrefixTableIterator *aIterator,
+                                             otBorderRoutingRdnssAddrEntry      *aEntry);
+
+/**
+ * Callback function pointer to notify of changes to discovered Recursive DNS Server (RDNSS) address entries.
+ *
+ * Address entries are discovered by processing the RDNSS options within received Router Advertisement messages from
+ * routers on infrastructure link.
+ *
+ * The `otBorderRoutingGetNextRdnssAddrEntry()` function can be used to iterate over the discovered RDNSS address
+ * entries.
+ *
+ * This callback is invoked when any of the following changes occur to the address entries associated with a discovered
+ * router:
+ * - A new RDNSS address is advertised by the router.
+ * - A previously discovered address is removed due to the router advertising it with a zero lifetime.
+ * - A previously discovered address has aged out (its lifetime expired without being re-advertised).
+ * - We determine that the router that advertised the address is now unreachable, and therefore all its associated
+ *   entries are removed.
+ *
+ * @param[in] aContext  A pointer to arbitrary context information.
+ */
+typedef void (*otBorderRoutingRdnssAddrCallback)(void *aContext);
+
+/**
+ * Sets the callback to be notified of changes to discovered Recursive DNS Server (RDNSS) address entries.
+ *
+ * A subsequent call to this function, replaces a previously set callback.
+ *
+ * @param[in] aInstance   The OpenThread instance.
+ * @param[in] aCallback   The callback function pointer. Can be `NULL` if no callback is required.
+ * @param[in] aConext     An arbitrary context information (used when invoking the callback).
+ *
+ */
+void otBorderRoutingSetRdnssAddrCallback(otInstance                      *aInstance,
+                                         otBorderRoutingRdnssAddrCallback aCallback,
+                                         void                            *aContext);
+
 /**
  * Enables / Disables DHCPv6 Prefix Delegation.
  *
diff --git a/include/openthread/coap_secure.h b/include/openthread/coap_secure.h
index 349e5ca22..67043f55d 100644
--- a/include/openthread/coap_secure.h
+++ b/include/openthread/coap_secure.h
@@ -76,6 +76,7 @@ typedef enum otCoapSecureConnectEvent
     OT_COAP_SECURE_DISCONNECTED_LOCAL_CLOSED, ///< Disconnected locally
     OT_COAP_SECURE_DISCONNECTED_MAX_ATTEMPTS, ///< Disconnected due to reaching the max connection attempts
     OT_COAP_SECURE_DISCONNECTED_ERROR,        ///< Disconnected due to an error
+    OT_COAP_SECURE_DISCONNECTED_TIMEOUT,      ///< Disconnected locally due to session timeout
 } otCoapSecureConnectEvent;
 
 /**
diff --git a/include/openthread/dataset.h b/include/openthread/dataset.h
index 840f0d87e..1444ca59d 100644
--- a/include/openthread/dataset.h
+++ b/include/openthread/dataset.h
@@ -152,7 +152,10 @@ typedef struct otSecurityPolicy
 } otSecurityPolicy;
 
 /**
- * Represents Channel Mask.
+ * Represents a Channel Mask.
+ *
+ * The least significant bit (LSB), also referred to as bit 0, corresponds to channel number 0, and so on.
+ *
  */
 typedef uint32_t otChannelMask;
 
diff --git a/include/openthread/dns_client.h b/include/openthread/dns_client.h
index 5dc82ad8d..8833e0dff 100644
--- a/include/openthread/dns_client.h
+++ b/include/openthread/dns_client.h
@@ -646,6 +646,139 @@ otError otDnsServiceResponseGetHostAddress(const otDnsServiceResponse *aResponse
                                            otIp6Address               *aAddress,
                                            uint32_t                   *aTtl);
 
+/**
+ * An opaque representation of a response to a query for an arbitrary record type.
+ *
+ * Pointers to instance of this type are provided from callback `otDnsRecordCallback`.
+ */
+typedef struct otDnsRecordResponse otDnsRecordResponse;
+
+/**
+ * Pointer is called when a DNS response is received for a DNS query to an arbitrary record type.
+ *
+ * Within this callback the user can use `otDnsRecordResponseGet{Item}()` functions along with the @p aResponse
+ * pointer to get more info about the response.
+ *
+ * The @p aResponse pointer can only be used within this callback and after returning from this function it will not
+ * stay valid, so the user MUST NOT retain the @p aResponse pointer for later use.
+ *
+ * @param[in]  aError     The result of the DNS transaction.
+ * @param[in]  aResponse  A pointer to the response (it is always non-NULL).
+ * @param[in]  aContext   A pointer to application-specific context.
+ *
+ * The @p aError can have the following:
+ *
+ *  - OT_ERROR_NONE              A response was received successfully.
+ *  - OT_ERROR_ABORT             A DNS transaction was aborted by the stack.
+ *  - OT_ERROR_RESPONSE_TIMEOUT  No DNS response has been received within timeout.
+ *
+ */
+typedef void (*otDnsRecordCallback)(otError aError, const otDnsRecordResponse *aResponse, void *aContext);
+
+/**
+ * Represents a section in a DNS query/response message.
+ */
+typedef enum
+{
+    OT_DNS_SECTION_ANSWER,     ///< Answer section.
+    OT_DNS_SECTION_AUTHORITY,  ///< Authority section.
+    OT_DNS_SECTION_ADDITIONAL, ///< Additional section.
+} otDnsRecordSection;
+
+/**
+ * Represents info for a record in an `otDnsRecordResponse`.
+ *
+ * This struct is used as input to `otDnsRecordResponseGetRecordInfo()`.
+ */
+typedef struct otDnsRecordInfo
+{
+    char              *mNameBuffer;     ///< Buffer to output the name (MUST NOT be NULL).
+    uint16_t           mNameBufferSize; ///< Size of `mNameBuffer`.
+    uint16_t           mRecordType;     ///< The record type.
+    uint16_t           mRecordLength;   ///< The record data length (in bytes).
+    uint32_t           mTtl;            ///< Record TTL (in seconds).
+    uint8_t           *mDataBuffer;     ///< Buffer to output the data (Can be NULL if data not needed).
+    uint16_t           mDataBufferSize; ///< On input, size of `mDataBuffer`. On output number of bytes written.
+    otDnsRecordSection mSection;        ///< Indicates the section of the record.
+} otDnsRecordInfo;
+
+/**
+ * Sends a DNS query for a given record type and name.
+ *
+ * Requires `OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE`.
+ *
+ * The @p aConfig can be NULL. In this case the default config (from `otDnsClientGetDefaultConfig()`) will be used as
+ * the config for this query. In a non-NULL @p aConfig, some of the fields can be left unspecified (value zero). The
+ * unspecified fields are then replaced by the values from the default config.
+ *
+ * @param[in]  aInstance        A pointer to an OpenThread instance.
+ * @param[in]  aRecordType      The resource record type to query.
+ * @param[in]  aFirstLabel      The first label of the name to be queried (can be NULL if not needed).
+ * @param[in]  aNextLabels      The next labels of the name to be queried (MUST NOT be NULL).
+ * @param[in]  aCallback        A function pointer that shall be called on response reception or time-out.
+ * @param[in]  aContext         A pointer to arbitrary context information used when @p aCallback is invoked.
+ * @param[in]  aConfig          A pointer to the config to use for this query.
+ *
+ * @retval OT_ERROR_NONE          Query sent successfully. @p aCallback will be invoked to report the outcome.
+ * @retval OT_ERROR_NO_BUFS       Insufficient buffer to prepare and send query.
+ * @retval OT_ERROR_INVALID_STATE Cannot send query since Thread interface is not up.
+ */
+otError otDnsClientQueryRecord(otInstance             *aInstance,
+                               uint16_t                aRecordType,
+                               const char             *aFirstLabel,
+                               const char             *aNextLabels,
+                               otDnsRecordCallback     aCallback,
+                               void                   *aContext,
+                               const otDnsQueryConfig *aConfig);
+
+/**
+ * Gets the query name associated with a record query DNS response.
+ *
+ * MUST only be used from `otDnsRecordCallback`.
+ *
+ * @param[in]  aResponse         A pointer to the response.
+ * @param[out] aNameBuffer       A buffer to char array to output the full query name (MUST NOT be NULL).
+ * @param[in]  aNameBufferSize   The size of @p aNameBuffer.
+ *
+ * @retval OT_ERROR_NONE     The full query name was read successfully.
+ * @retval OT_ERROR_NO_BUFS  The name does not fit in @p aNameBuffer.
+ */
+otError otDnsRecordResponseGetQueryName(const otDnsRecordResponse *aResponse,
+                                        char                      *aNameBuffer,
+                                        uint16_t                   aNameBufferSize);
+
+/**
+ * Reads the records from a DNS query response.
+ *
+ * MUST only be used from `otDnsRecordCallback`.
+ *
+ * The response may include multiple records. @p aIndex can be used to iterate through the list. Index zero gets the
+ * first record and so on. When we reach the end of the list, `OT_ERROR_NOT_FOUND` is returned.
+ *
+ * Upon successful retrieval (`OT_ERROR_NONE`):
+ * - `mRecordLength` is set to the actual length of the record's data.
+ * - The data is copied into `mDataBuffer` (if not `NULL`) up to its capacity specified by `mDataBufferSize`.
+ * - `mDataBufferSize` is then updated to reflect the number of bytes actually written into `mDataBuffer`.
+ *
+ * If the retrieved record type is NS, CNAME, SOA, PTR, MX, RP, AFSDB, RT, PX, SRV, KX, DNAME, or NSEC, the record
+ * data in the received response contains a DNS name which may use DNS name compression. For these specific record
+ * types, the record data is first decompressed such that it contains the full uncompressed DNS name. This decompressed
+ * data is then provided in `mDataBuffer`, and `mRecordDataLength` will indicate the length of this decompressed data.
+ * For all other record types, the record data is read and provided as it appears in the received response message.
+ *
+ * @param[in]  aResponse       A pointer to the response.
+ * @param[in]  aIndex          The record index to retrieve.
+ * @param[out] aRecordInfo     A pointer to a `otDnsRecordInfo` to populate with read record info.
+ *
+ * @retval OT_ERROR_NONE       The record was read successfully.
+ * @retval OT_ERROR_NOT_FOUND  No record in @p aResponse at @p aIndex.
+ * @retval OT_ERROR_PARSE      Could not parse the records in the @p aResponse.
+ * @retval OT_ERROR_NO_BUFS    The record name does not fit in the provided `mNameBufferSize` in @p aRecordInfo, or
+ *                             failed to allocate buffer to decompress a compressed DNS name.
+ */
+otError otDnsRecordResponseGetRecordInfo(const otDnsRecordResponse *aResponse,
+                                         uint16_t                   aIndex,
+                                         otDnsRecordInfo           *aRecordInfo);
 /**
  * @}
  */
diff --git a/include/openthread/history_tracker.h b/include/openthread/history_tracker.h
index ec9280560..e48e071d3 100644
--- a/include/openthread/history_tracker.h
+++ b/include/openthread/history_tracker.h
@@ -235,6 +235,26 @@ typedef struct otHistoryTrackerExternalRouteInfo
     otHistoryTrackerNetDataEvent mEvent; ///< Indicates the event (added/removed).
 } otHistoryTrackerExternalRouteInfo;
 
+/**
+ * Represents events during the Border Agent's ePSKc journey.
+ */
+typedef enum
+{
+    OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_ACTIVATED,                   ///< ePSKc mode is activated.
+    OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_CONNECTED,                   ///< Secure session is connected.
+    OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_PETITIONED,                  ///< Commissioner petition is received.
+    OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_RETRIEVED_ACTIVE_DATASET,    ///< Active dataset is retrieved.
+    OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_RETRIEVED_PENDING_DATASET,   ///< Pending dataset is retrieved.
+    OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_KEEP_ALIVE,                  ///< Keep alive message is received.
+    OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_DEACTIVATED_LOCAL_CLOSE,     ///< Deactivated by a call to the API.
+    OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_DEACTIVATED_REMOTE_CLOSE,    ///< Disconnected by the peer.
+    OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_DEACTIVATED_SESSION_ERROR,   ///< Disconnected due to some error.
+    OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_DEACTIVATED_SESSION_TIMEOUT, ///< Disconnected due to timeout.
+    OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_DEACTIVATED_MAX_ATTEMPTS,    ///< Max allowed attempts reached.
+    OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_DEACTIVATED_EPSKC_TIMEOUT,   ///< ePSKc mode timed out.
+    OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_DEACTIVATED_UNKNOWN,         ///< Deactivated for an unknown reason.
+} otHistoryTrackerBorderAgentEpskcEvent;
+
 /**
  * Initializes an `otHistoryTrackerIterator`.
  *
@@ -397,6 +417,23 @@ const otHistoryTrackerExternalRouteInfo *otHistoryTrackerIterateExternalRouteHis
     otHistoryTrackerIterator *aIterator,
     uint32_t                 *aEntryAge);
 
+/**
+ * Iterates over the entries in the Border Agent ePSKc history list.
+ *
+ * @param[in]     aInstance  A pointer to the OpenThread instance.
+ * @param[in,out] aIterator  A pointer to an iterator. MUST be initialized or the behavior is undefined.
+ * @param[out]    aEntryAge  A pointer to a variable to output the entry's age. MUST NOT be NULL.
+ *                           Age is provided as the duration (in milliseconds) from when entry was recorded to
+ *                           @p aIterator initialization time. It is set to `OT_HISTORY_TRACKER_MAX_AGE` for entries
+ *                           older than max age.
+ *
+ * @returns The `otHistoryTrackerBorderAgentEpskcEvent` entry or `NULL` if no more entries in the list.
+ */
+const otHistoryTrackerBorderAgentEpskcEvent *otHistoryTrackerIterateBorderAgentEpskcEventHistory(
+    otInstance               *aInstance,
+    otHistoryTrackerIterator *aIterator,
+    uint32_t                 *aEntryAge);
+
 /**
  * Converts a given entry age to a human-readable string.
  *
diff --git a/include/openthread/instance.h b/include/openthread/instance.h
index e53305d93..689979e71 100644
--- a/include/openthread/instance.h
+++ b/include/openthread/instance.h
@@ -52,7 +52,7 @@ extern "C" {
  *
  * @note This number versions both OpenThread platform and user APIs.
  */
-#define OPENTHREAD_API_VERSION (483)
+#define OPENTHREAD_API_VERSION (511)
 
 /**
  * @addtogroup api-instance
@@ -114,6 +114,18 @@ otInstance *otInstanceInitSingle(void);
  */
 otInstance *otInstanceInitMultiple(uint8_t aIdx);
 
+/**
+ * Gets the index of the OpenThread instance when multiple instance is in use.
+ *
+ * This function is available when both `OPENTHREAD_CONFIG_MULTIPLE_INSTANCE_ENABLE` and
+ * `OPENTHREAD_CONFIG_MULTIPLE_STATIC_INSTANCE_ENABLE` are enabled.
+ *
+ * @param[in] aInstance The reference of the OpenThread instance to get index.
+ *
+ * @returns The index of the OpenThread instance.
+ */
+uint8_t otInstanceGetIndex(otInstance *aInstance);
+
 /**
  * Gets the instance identifier.
  *
diff --git a/include/openthread/link.h b/include/openthread/link.h
index ccdc2c7aa..5d41d1de1 100644
--- a/include/openthread/link.h
+++ b/include/openthread/link.h
@@ -1102,7 +1102,7 @@ otError otLinkSetRegion(otInstance *aInstance, uint16_t aRegionCode);
  * @param[out] aRegionCode  The radio region code. The `aRegionCode >> 8` is first ascii char
  *                          and the `aRegionCode & 0xff` is the second ascii char.
  *
- * @retval  OT_ERROR_INVALID_ARGS     @p aRegionCode is nullptr.
+ * @retval  OT_ERROR_INVALID_ARGS     @p aRegionCode is NULL.
  * @retval  OT_ERROR_FAILED           Other platform specific errors.
  * @retval  OT_ERROR_NONE             Successfully got region code.
  * @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented.
diff --git a/include/openthread/mdns.h b/include/openthread/mdns.h
index c77b4c71d..a40cbb8e7 100644
--- a/include/openthread/mdns.h
+++ b/include/openthread/mdns.h
@@ -40,6 +40,7 @@
 #include <openthread/error.h>
 #include <openthread/instance.h>
 #include <openthread/ip6.h>
+#include <openthread/nat64.h>
 #include <openthread/platform/dnssd.h>
 
 #ifdef __cplusplus
@@ -141,6 +142,20 @@ typedef enum otMdnsEntryState
     OT_MDNS_ENTRY_STATE_REMOVING,   ///< Entry is being removed (sending "goodbye" announcements).
 } otMdnsEntryState;
 
+/**
+ * Represents a local host IPv4 or IPv6 address entry.
+ */
+typedef struct otMdnsLocalHostAddress
+{
+    bool     mIsIp6;        ///< Indicates whether the address is IPv6 (`true`) or IPv4 (`false`).
+    uint32_t mInfraIfIndex; ///< The infrastructure network interface index.
+    union
+    {
+        otIp6Address mIp6; ///< The IPv6 address (valid when `mIsIp6` is true).
+        otIp4Address mIp4; ///< The IPv4 address (valid when `mIsIp6` is false).
+    } mAddress;            ///< The address.
+} otMdnsLocalHostAddress;
+
 /**
  * Enables or disables the mDNS module.
  *
@@ -203,6 +218,29 @@ bool otMdnsIsQuestionUnicastAllowed(otInstance *aInstance);
  */
 void otMdnsSetConflictCallback(otInstance *aInstance, otMdnsConflictCallback aCallback);
 
+/**
+ * Gets the local host name.
+ *
+ * @param[in] aInstance     The OpenThread instance.
+ *
+ * @returns The local host name.
+ */
+const char *otMdnsGetLocalHostName(otInstance *aInstance);
+
+/**
+ * Sets the local host name.
+ *
+ * The local host name can be set only when the mDNS module is disabled. If not set the mDNS module itself will
+ * auto-generate the local host name.
+ *
+ * @param[in] aInstance   The OpenThread instance.
+ * @param[in] aName       The local host name to use, can be to `NULL` to allow the mDNS module to choose the name.
+ *
+ * @retval OT_ERROR_NONE            The local host name was successfully set.
+ * @retval OT_ERROR_INVALID_STATE   mDNS module is already enabled.
+ */
+otError otMdnsSetLocalHostName(otInstance *aInstance, const char *aName);
+
 /**
  * Registers or updates a host on mDNS.
  *
@@ -273,7 +311,8 @@ otError otMdnsUnregisterHost(otInstance *aInstance, const otMdnsHost *aHost);
  *   contain dot `.` character which is allowed in a service instance label.
  * - The `mServiceType` specifies the service type (e.g., "_tst._udp"). It is treated as multiple dot `.` separated
  *   labels. It MUST NOT contain the domain name.
- * - The `mHostName` field specifies the host name of the service. MUST NOT contain the domain name.
+ * - The `mHostName` field specifies the host name of the service if it is not NULL. Otherwise, if it is NULL, it
+ *   indicates that this service is for the local host (this device itself).
  * - The `mSubTypeLabels` is an array of strings representing sub-types associated with the service. Each array entry
  *   is a sub-type label. The `mSubTypeLabels can be NULL if there is no sub-type. Otherwise, the array length is
  *   specified by `mSubTypeLabelsLength`.
@@ -474,6 +513,27 @@ otError otMdnsGetNextService(otInstance       *aInstance,
  */
 otError otMdnsGetNextKey(otInstance *aInstance, otMdnsIterator *aIterator, otMdnsKey *aKey, otMdnsEntryState *aState);
 
+/**
+ * Iterates over the local host IPv6 and IPv4 addresses tracked by OpenThread mDNS module.
+ *
+ * Requires `OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE`.
+ *
+ * The platform layer is responsible for monitoring and reporting all host IPv4 and IPv6 addresses to the OpenThread
+ * mDNS module, which then tracks the full address list (see `otPlatMdnsHandleHostAddressEvent()`). This function
+ * allows iteration through this tracked list, primarily intended for information and debugging purposes.
+ *
+ * @param[in]   aInstance           The OpenThread instance.
+ * @param[out]  aIterator           Pointer to the iterator to use.
+ * @param[out]  aAddress            Pointer to an `otMdnsLocalHostAddress` to output the next address entry.
+ *
+ * @retval OT_ERROR_NONE            The @p aAddress, and @p aIterator are updated successfully.
+ * @retval OT_ERROR_NOT_FOUND       Reached the end of the list.
+ * @retval OT_ERROR_INVALID_ARGS    Iterator is not valid.
+ */
+otError otMdnsGetNextLocalHostAddress(otInstance             *aInstance,
+                                      otMdnsIterator         *aIterator,
+                                      otMdnsLocalHostAddress *aAddress);
+
 /**
  * Represents a service browser.
  *
@@ -550,6 +610,21 @@ typedef otPlatDnssdAddressAndTtl otMdnsAddressAndTtl;
  */
 typedef otPlatDnssdAddressResult otMdnsAddressResult;
 
+/**
+ * Represents a record query result.
+ */
+typedef otPlatDnssdRecordResult otMdnsRecordResult;
+
+/**
+ * Represents the callback function used to report a record querier result.
+ */
+typedef otPlatDnssdRecordCallback otMdnsRecordCallback;
+
+/**
+ * Represents a record querier.
+ */
+typedef otPlatDnssdRecordQuerier otMdnsRecordQuerier;
+
 /**
  * Starts a service browser.
  *
@@ -734,6 +809,63 @@ otError otMdnsStartIp4AddressResolver(otInstance *aInstance, const otMdnsAddress
  */
 otError otMdnsStopIp4AddressResolver(otInstance *aInstance, const otMdnsAddressResolver *aResolver);
 
+/**
+ * Starts a record querier.
+ *
+ * Initiates a continuous query for a given `mRecordType` as specified in @p aQuerier. The queried name is specified
+ * by the combination of `mFirstLabel` and `mNextLabels` (optional rest of the labels) in @p aQuerier. The
+ * `mFirstLabel` MUST be non-NULL but `mNextLabels` can be `NULL` if there are no other labels. The `mNextLabels`
+ * MUST NOT include the domain name. The reason for a separate first label is to allow it to include a dot `.`
+ * character (as allowed for service instance labels).
+ *
+ * Discovered results are reported through the `mCallback` function in @p aQuerier, providing the record data bytes
+ * (RDATA). For NS, CNAME, SOA, PTR, MX, RP, AFSDB, RT, PX, SRV, KX, DNAME, and NSEC record types, the RDATA format
+ * contains one or more DNS names (which may use DNS name compression). For the above list, the reported record data
+ * bytes via @p mCallback will be decompressed to contain the full DNS name(s). For all other record types, the record
+ * data bytes are provided exactly as they appear in the received mDNS response. This aligns the implementation with
+ * RFC 6762 (section 18.14) regarding the use of name compression.
+ *
+ * A removed record data is indicated with a TTL value of zero. The callback may be invoked immediately with cached
+ * information (if available) and potentially before this function returns. When cached results are used, the reported
+ * TTL value will reflect the original TTL from the last received response.
+ *
+ * Multiple querier instances can be started for the same name, provided they use different callback functions.
+ *
+ * The record querier MUST not be used for record types PTR, SRV, TXT, A, and AAAA. Otherwise, `OT_ERROR_INVALID_ARGS`
+ * will be returned. For these, browsers/resolvers can be used. This design is intentional to enable the implementation
+ * of an "opportunistic cache mechanism", where, depending on currently active service browsers/resolvers, the mDNS
+ * implementation will also monitor and cache related records (e.g., when a service is resolved, the address records
+ * associated with its host name are cached even if there is no active address resolver for this hostname).
+ *
+ * The @p aQuerier and all its contained information (strings) are only valid during this call. The platform MUST save
+ * a copy of the information if it wants to retain the information after returning from this function.
+ *
+ * @param[in] aInstance   The OpenThread instance.
+ * @param[in] aQuerier    The record querier to be started.
+ *
+ * @retval OT_ERROR_NONE           Record @p aQuerier started successfully.
+ * @retval OT_ERROR_INVALID_STATE  mDNS module is not enabled.
+ * @retval OT_ERROR_ALREADY        An identical querier (same name, record type, and callback) is already active.
+ * @retval OT_ERROR_INVALID_ARGS   The `mRecordType` in @p aQuerier is invalid. MUST use browser/resolvers.
+ */
+otError otMdnsStartRecordQuerier(otInstance *aInstance, const otMdnsRecordQuerier *aQuerier);
+
+/**
+ * Stops a record querier.
+ *
+ * No action is performed if no matching querier with the same name and callback is currently active.
+ *
+ * The @p aQuerier and all its contained information (strings) are only valid during this call. The platform MUST save
+ * a copy of the information if it wants to retain the information after returning from this function.
+ *
+ * @param[in] aInstance   The OpenThread instance.
+ * @param[in] aQuerier    The record querier to be stopped.
+ *
+ * @retval OT_ERROR_NONE           Querier stopped successfully.
+ * @retval OT_ERROR_INVALID_STATE  mDNS module is not enabled.
+ */
+otError otMdnsStopRecordQuerier(otInstance *aInstance, const otMdnsRecordQuerier *aQuerier);
+
 /**
  * Represents additional information about a browser/resolver and its cached results.
  */
@@ -862,6 +994,30 @@ otError otMdnsGetNextIp4AddressResolver(otInstance            *aInstance,
                                         otMdnsAddressResolver *aResolver,
                                         otMdnsCacheInfo       *aInfo);
 
+/**
+ * Iterates over record querier entries.
+ *
+ * Requires `OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE`.
+ *
+ * On success, @p aQuerier is populated with information about the next querier . The `mCallback` field is always
+ * set to `NULL` as there may be multiple active querier with different callbacks. Other pointers within the
+ * `otMdnsRecordQuerier` structure remain valid until the next call to any OpenThread stack's public or platform
+ * API/callback.
+ *
+ * @param[in]  aInstance   The OpenThread instance.
+ * @param[in]  aIterator   Pointer to the iterator.
+ * @param[out] aQuerier    Pointer to an `otMdnsRecordQuerier` to return the information about the next one.
+ * @param[out] aInfo       Pointer to an `otMdnsCacheInfo` to return additional information.
+ *
+ * @retval OT_ERROR_NONE         @p aQuerier, @p aInfo, & @p aIterator are updated successfully.
+ * @retval OT_ERROR_NOT_FOUND    Reached the end of the list.
+ * @retval OT_ERROR_INVALID_ARG  @p aIterator is not valid.
+ */
+otError otMdnsGetNextRecordQuerier(otInstance          *aInstance,
+                                   otMdnsIterator      *aIterator,
+                                   otMdnsRecordQuerier *aQuerier,
+                                   otMdnsCacheInfo     *aInfo);
+
 /**
  * @}
  */
diff --git a/include/openthread/nat64.h b/include/openthread/nat64.h
index 1ac93701a..c6c6ace4a 100644
--- a/include/openthread/nat64.h
+++ b/include/openthread/nat64.h
@@ -446,7 +446,7 @@ void otIp4ToIp4MappedIp6Address(const otIp4Address *aIp4Address, otIp6Address *a
  * truncated but the outputted string is always null-terminated.
  *
  * @param[in]  aAddress  A pointer to an IPv4 address (MUST NOT be NULL).
- * @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be `nullptr`).
+ * @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL).
  * @param[in]  aSize     The size of @p aBuffer (in bytes).
  */
 void otIp4AddressToString(const otIp4Address *aAddress, char *aBuffer, uint16_t aSize);
@@ -474,7 +474,7 @@ otError otIp4CidrFromString(const char *aString, otIp4Cidr *aCidr);
  * truncated but the outputted string is always null-terminated.
  *
  * @param[in]  aCidr     A pointer to an IPv4 CIDR (MUST NOT be NULL).
- * @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be `nullptr`).
+ * @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL).
  * @param[in]  aSize     The size of @p aBuffer (in bytes).
  */
 void otIp4CidrToString(const otIp4Cidr *aCidr, char *aBuffer, uint16_t aSize);
diff --git a/include/openthread/netdata.h b/include/openthread/netdata.h
index 934ec5b9e..a7a3dd4ac 100644
--- a/include/openthread/netdata.h
+++ b/include/openthread/netdata.h
@@ -76,9 +76,10 @@ typedef struct otBorderRouterConfig
  */
 typedef struct otLowpanContextInfo
 {
-    uint8_t     mContextId;    ///< The 6LoWPAN Context ID.
-    bool        mCompressFlag; ///< The compress flag.
-    otIp6Prefix mPrefix;       ///< The associated IPv6 prefix.
+    uint8_t     mContextId;        ///< The 6LoWPAN Context ID.
+    bool        mCompressFlag : 1; ///< The compress flag.
+    bool        mStable : 1;       ///< Whether the Context TLV is marked as Stable Network Data.
+    otIp6Prefix mPrefix;           ///< The associated IPv6 prefix.
 } otLowpanContextInfo;
 
 /**
diff --git a/include/openthread/netdiag.h b/include/openthread/netdiag.h
index 762f81dff..392c9a441 100644
--- a/include/openthread/netdiag.h
+++ b/include/openthread/netdiag.h
@@ -35,6 +35,7 @@
 #ifndef OPENTHREAD_NETDIAG_H_
 #define OPENTHREAD_NETDIAG_H_
 
+#include <openthread/dataset.h>
 #include <openthread/ip6.h>
 #include <openthread/thread.h>
 
@@ -48,35 +49,37 @@ extern "C" {
  * @{
  */
 
-#define OT_NETWORK_DIAGNOSTIC_TLV_EXT_ADDRESS 0           ///< MAC Extended Address TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_SHORT_ADDRESS 1         ///< Address16 TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_MODE 2                  ///< Mode TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_TIMEOUT 3               ///< Timeout TLV (max polling time period for SEDs)
-#define OT_NETWORK_DIAGNOSTIC_TLV_CONNECTIVITY 4          ///< Connectivity TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_ROUTE 5                 ///< Route64 TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_LEADER_DATA 6           ///< Leader Data TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_NETWORK_DATA 7          ///< Network Data TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_IP6_ADDR_LIST 8         ///< IPv6 Address List TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_MAC_COUNTERS 9          ///< MAC Counters TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_BATTERY_LEVEL 14        ///< Battery Level TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_SUPPLY_VOLTAGE 15       ///< Supply Voltage TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_CHILD_TABLE 16          ///< Child Table TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_CHANNEL_PAGES 17        ///< Channel Pages TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_TYPE_LIST 18            ///< Type List TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_MAX_CHILD_TIMEOUT 19    ///< Max Child Timeout TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_EUI64 23                ///< EUI64 TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_VERSION 24              ///< Thread Version TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_NAME 25          ///< Vendor Name TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_MODEL 26         ///< Vendor Model TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_SW_VERSION 27    ///< Vendor SW Version TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_THREAD_STACK_VERSION 28 ///< Thread Stack Version TLV (codebase/commit version)
-#define OT_NETWORK_DIAGNOSTIC_TLV_CHILD 29                ///< Child TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_CHILD_IP6_ADDR_LIST 30  ///< Child IPv6 Address List TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_ROUTER_NEIGHBOR 31      ///< Router Neighbor TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_ANSWER 32               ///< Answer TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_QUERY_ID 33             ///< Query ID TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_MLE_COUNTERS 34         ///< MLE Counters TLV
-#define OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_APP_URL 35       ///< Vendor App URL TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_EXT_ADDRESS 0             ///< MAC Extended Address TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_SHORT_ADDRESS 1           ///< Address16 TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_MODE 2                    ///< Mode TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_TIMEOUT 3                 ///< Timeout TLV (max polling time period for SEDs)
+#define OT_NETWORK_DIAGNOSTIC_TLV_CONNECTIVITY 4            ///< Connectivity TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_ROUTE 5                   ///< Route64 TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_LEADER_DATA 6             ///< Leader Data TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_NETWORK_DATA 7            ///< Network Data TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_IP6_ADDR_LIST 8           ///< IPv6 Address List TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_MAC_COUNTERS 9            ///< MAC Counters TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_BATTERY_LEVEL 14          ///< Battery Level TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_SUPPLY_VOLTAGE 15         ///< Supply Voltage TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_CHILD_TABLE 16            ///< Child Table TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_CHANNEL_PAGES 17          ///< Channel Pages TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_TYPE_LIST 18              ///< Type List TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_MAX_CHILD_TIMEOUT 19      ///< Max Child Timeout TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_EUI64 23                  ///< EUI64 TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_VERSION 24                ///< Thread Version TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_NAME 25            ///< Vendor Name TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_MODEL 26           ///< Vendor Model TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_SW_VERSION 27      ///< Vendor SW Version TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_THREAD_STACK_VERSION 28   ///< Thread Stack Version TLV (codebase/commit version)
+#define OT_NETWORK_DIAGNOSTIC_TLV_CHILD 29                  ///< Child TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_CHILD_IP6_ADDR_LIST 30    ///< Child IPv6 Address List TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_ROUTER_NEIGHBOR 31        ///< Router Neighbor TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_ANSWER 32                 ///< Answer TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_QUERY_ID 33               ///< Query ID TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_MLE_COUNTERS 34           ///< MLE Counters TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_APP_URL 35         ///< Vendor App URL TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_NON_PREFERRED_CHANNELS 36 ///< Non-Preferred Channels Mask TLV
+#define OT_NETWORK_DIAGNOSTIC_TLV_ENHANCED_ROUTE 37         ///< Enhanced Route TLV
 
 #define OT_NETWORK_DIAGNOSTIC_MAX_VENDOR_NAME_TLV_LENGTH 32          ///< Max length of Vendor Name TLV.
 #define OT_NETWORK_DIAGNOSTIC_MAX_VENDOR_MODEL_TLV_LENGTH 32         ///< Max length of Vendor Model TLV.
@@ -128,6 +131,51 @@ typedef struct otNetworkDiagRoute
     otNetworkDiagRouteData mRouteData[OT_NETWORK_MAX_ROUTER_ID + 1]; ///< Link Quality and Routing Cost data.
 } otNetworkDiagRoute;
 
+/**
+ * Represents a Network Diagnostic Enhanced Route data.
+ */
+typedef struct otNetworkDiagEnhRouteData
+{
+    uint8_t mRouterId;           ///< The Router ID.
+    bool    mIsSelf : 1;         ///< This is the queried device itself. If set, the other fields should be ignored.
+    bool    mHasLink : 1;        ///< Indicates whether the queried device has a direct link with router.
+    uint8_t mLinkQualityOut : 2; ///< Link Quality Out (applicable when `mHasLink`).
+    uint8_t mLinkQualityIn : 2;  ///< Link Quality In (applicable when `mHasLink`).
+
+    /**
+     * The next hop Router ID tracked towards this router.
+     *
+     * This field indicates the next hop router towards `mRouterId` when using multi-hop forwarding.
+     *
+     * If the device has no direct link with the router (`mHasLink == false`), this field indicates the next hop router
+     * that would be used to forward messages destined to `mRouterId`.
+     *
+     * If the device has a direct link with the router (`mHasLink == true`), this field indicates the alternate
+     * multi-hop path that may be used. Note that whether the direct link or this alternate path through the next hop
+     * is used to forward messages depends on their associated total path costs.
+     *
+     * If there is no next hop, then `OT_NETWORK_MAX_ROUTER_ID + 1` is used.
+     */
+    uint8_t mNextHop;
+
+    /**
+     * The route cost associated with forwarding to `mRouterId` using `mNextHop` (when valid).
+     *
+     * This is the route cost `mNextHop` has claimed to have towards `mRouterId`. Importantly, it does not include the
+     * link cost to send to `mNextHop` itself.
+     */
+    uint8_t mNextHopCost;
+} otNetworkDiagEnhRouteData;
+
+/**
+ * Represents a Network Diagnostic Enhanced Route TLV value.
+ */
+typedef struct otNetworkDiagEnhRoute
+{
+    uint8_t                   mRouteCount;                              ///< Number of `mRouteData` entries.
+    otNetworkDiagEnhRouteData mRouteData[OT_NETWORK_MAX_ROUTER_ID + 1]; ///< Route Data per router.
+} otNetworkDiagEnhRoute;
+
 /**
  * Represents a Network Diagnostic Mac Counters value.
  *
@@ -195,6 +243,7 @@ typedef struct otNetworkDiagTlv
         uint32_t                  mTimeout;
         otNetworkDiagConnectivity mConnectivity;
         otNetworkDiagRoute        mRoute;
+        otNetworkDiagEnhRoute     mEnhRoute;
         otLeaderData              mLeaderData;
         otNetworkDiagMacCounters  mMacCounters;
         otNetworkDiagMleCounters  mMleCounters;
@@ -207,6 +256,7 @@ typedef struct otNetworkDiagTlv
         char                      mVendorSwVersion[OT_NETWORK_DIAGNOSTIC_MAX_VENDOR_SW_VERSION_TLV_LENGTH + 1];
         char                      mThreadStackVersion[OT_NETWORK_DIAGNOSTIC_MAX_THREAD_STACK_VERSION_TLV_LENGTH + 1];
         char                      mVendorAppUrl[OT_NETWORK_DIAGNOSTIC_MAX_VENDOR_APP_URL_TLV_LENGTH + 1];
+        otChannelMask             mNonPreferredChannels;
         struct
         {
             uint8_t mCount;
@@ -406,6 +456,48 @@ otError otThreadSetVendorSwVersion(otInstance *aInstance, const char *aVendorSwV
  */
 otError otThreadSetVendorAppUrl(otInstance *aInstance, const char *aVendorAppUrl);
 
+/**
+ * Callback function pointer to notify when a Network Diagnostic Reset request message is received for the
+ * `OT_NETWORK_DIAGNOSTIC_TLV_NON_PREFERRED_CHANNELS` TLV.
+ *
+ * This is used to inform the device to reevaluate the channels that are presently included in the non-preferred
+ * channels list and update it if needed based on the reevaluation.
+ *
+ * @param[in] aContext   A pointer to application-specific context.
+ */
+typedef void (*otThreadNonPreferredChannelsResetCallback)(void *aContext);
+
+/**
+ * Sets the non-preferred channels value for `OT_NETWORK_DIAGNOSTIC_TLV_NON_PREFERRED_CHANNELS` TLV.
+ *
+ * This value is used to respond to a Network Diagnostic Get request for this TLV.
+ *
+ * @param[in] aInstance      A pointer to an OpenThread instance.
+ * @param[in] aChannelMask   A channel mask specifying the non-preferred channels.
+ */
+void otThreadSetNonPreferredChannels(otInstance *aInstance, otChannelMask aChannelMask);
+
+/**
+ * Gets the non-preferred channels for `OT_NETWORK_DIAGNOSTIC_TLV_NON_PREFERRED_CHANNELS` TLV.
+ *
+ * @returns The non-preferred channels as a channel mask.
+ */
+otChannelMask otThreadGetNonPreferredChannels(otInstance *aInstance);
+
+/**
+ * Sets the callback to notify when a Network Diagnostic Reset request message is received for the
+ * `OT_NETWORK_DIAGNOSTIC_TLV_NON_PREFERRED_CHANNELS` TLV.
+ *
+ * A subsequent call to this function will replace the previously set callback.
+ *
+ * @param[in] aInstance      A pointer to an OpenThread instance.
+ * @param[in] aCallback      The callback function pointer. Can be NULL.
+ * @param[in] aContext       A pointer to application-specific context used with @p aCallback.
+ */
+void otThreadSetNonPreferredChannelsResetCallback(otInstance                               *aInstance,
+                                                  otThreadNonPreferredChannelsResetCallback aCallback,
+                                                  void                                     *aContext);
+
 /**
  * @}
  */
diff --git a/include/openthread/platform/dns.h b/include/openthread/platform/dns.h
index 326fded12..3ca6eac6c 100644
--- a/include/openthread/platform/dns.h
+++ b/include/openthread/platform/dns.h
@@ -56,6 +56,23 @@ extern "C" {
  */
 typedef struct otPlatDnsUpstreamQuery otPlatDnsUpstreamQuery;
 
+/**
+ * Indicates whether upstream DNS query functionality is available on the platform.
+ *
+ * This function allows the platform to inform the OpenThread stack if no upstream DNS server is
+ * available.
+ *
+ * This function is used to optimize query handling. If this function returns `false` (e.g., no upstream DNS server is
+ * currently available), one can avoid attempting an upstream resolution (which would likely time out) and instead
+ * immediately send an appropriate negative response (e.g., `SERVFAIL`) to the DNS client.
+ *
+ * @param[in] aInstance  The OpenThread instance.
+ *
+ * @retval TRUE   Upstream DNS query functionality is available.
+ * @retval FALSE  Upstream DNS query functionality is not available.
+ */
+bool otPlatDnsIsUpstreamQueryAvailable(otInstance *aInstance);
+
 /**
  * Starts an upstream query transaction.
  *
@@ -87,11 +104,11 @@ void otPlatDnsCancelUpstreamQuery(otInstance *aInstance, otPlatDnsUpstreamQuery
  * The transaction will be released, so the platform must not call on the same transaction twice. This function passes
  * the ownership of `aResponse` to OpenThread stack.
  *
- * Platform can pass a nullptr to close a transaction without a response.
+ * Platform can pass NULL to close a transaction without a response.
  *
  * @param[in] aInstance  The OpenThread instance structure.
  * @param[in] aTxn       A pointer to the opaque DNS query transaction object.
- * @param[in] aResponse  A message buffer of the DNS response payload or `nullptr` to close a transaction without a
+ * @param[in] aResponse  A message buffer of the DNS response payload or NULL to close a transaction without a
  *                       response.
  */
 extern void otPlatDnsUpstreamQueryDone(otInstance *aInstance, otPlatDnsUpstreamQuery *aTxn, otMessage *aResponse);
diff --git a/include/openthread/platform/dnssd.h b/include/openthread/platform/dnssd.h
index a64589bea..beff2fcbb 100644
--- a/include/openthread/platform/dnssd.h
+++ b/include/openthread/platform/dnssd.h
@@ -539,6 +539,40 @@ typedef struct otPlatDnssdAddressResolver
     otPlatDnssdAddressCallback mCallback;     ///< The callback to report result.
 } otPlatDnssdAddressResolver;
 
+/**
+ * Represents a record query result.
+ */
+typedef struct otPlatDnssdRecordResult
+{
+    const char    *mFirstLabel;       ///< The first label of the name to be queried.
+    const char    *mNextLabels;       ///< The rest of the name labels. Does not include domain name. Can be NULL.
+    uint16_t       mRecordType;       ///< The record type.
+    const uint8_t *mRecordData;       ///< The record data bytes.
+    uint16_t       mRecordDataLength; ///< Number of bytes in record data.
+    uint32_t       mTtl;              ///< TTL in seconds. Zero TTL indicates removal the data.
+    uint32_t       mInfraIfIndex;     ///< The infrastructure network interface index.
+} otPlatDnssdRecordResult;
+
+/**
+ * Represents the callback function used to report a record querier result.
+ *
+ * @param[in] aInstance    The OpenThread instance.
+ * @param[in] aResult      The record querier result.
+ */
+typedef void (*otPlatDnssdRecordCallback)(otInstance *aInstance, const otPlatDnssdRecordResult *aResult);
+
+/**
+ * Represents a record querier.
+ */
+typedef struct otPlatDnssdRecordQuerier
+{
+    const char               *mFirstLabel;   ///< The first label of the name to be queried. MUST NOT be NULL.
+    const char               *mNextLabels;   ///< The rest of name labels, excluding domain name. Can be NULL.
+    uint16_t                  mRecordType;   ///< The record type to query.
+    uint32_t                  mInfraIfIndex; ///< The infrastructure network interface index.
+    otPlatDnssdRecordCallback mCallback;     ///< The callback to report result.
+} otPlatDnssdRecordQuerier;
+
 /**
  * Starts a service browser.
  *
@@ -718,6 +752,46 @@ void otPlatDnssdStartIp4AddressResolver(otInstance *aInstance, const otPlatDnssd
  */
 void otPlatDnssdStopIp4AddressResolver(otInstance *aInstance, const otPlatDnssdAddressResolver *aResolver);
 
+/**
+ * Starts a record querier.
+ *
+ * Initiates a continuous query for a given `mRecordType` as specified in @p aQuerier. The queried name is specified
+ * by the combination of `mFirstLabel` and `mNextLabels` (optional rest of the labels) in @p aQuerier. The
+ * `mFirstLabel` is always non-NULL but `mNextLabels` can be `NULL` if there are no other labels. The `mNextLabels
+ * does not include the domain name. The reason for a separate first label is to allow it to include a dot `.`
+ * character (as allowed for service instance labels).
+ *
+ * Discovered results should be reported through the `mCallback` function in @p aQuerier, providing the raw record
+ * data bytes. A removed record data is indicated with a TTL value of zero. The callback may be invoked immediately
+ * with cached information (if available) and potentially before this function returns. When cached results are used,
+ * the reported TTL value should reflect the original TTL from the last received response.
+ *
+ * Multiple querier instances can be started for the same name, provided they use different callback functions.
+ *
+ * OpenThread will only use a record querier for types other than PTR, SRV, TXT, A, and AAAA. For those, specific
+ * browsers or resolvers are used. The platform implementation, therefore, can choose to restrict its implementation.
+ *
+ * The @p aQuerier and all its contained information (strings) are only valid during this call. The platform MUST save
+ * a copy of the information if it wants to retain the information after returning from this function.
+ *
+ * @param[in] aInstance   The OpenThread instance.
+ * @param[in] aQuerier    The record querier to be started.
+ */
+void otPlatDnssdStartRecordQuerier(otInstance *aInstance, const otPlatDnssdRecordQuerier *aQuerier);
+
+/**
+ * Stops a record querier.
+ *
+ * No action is performed if no matching querier with the same name, record type and callback is currently active.
+ *
+ * The @p aQuerier and all its contained information (strings) are only valid during this call. The platform MUST save
+ * a copy of the information if it wants to retain the information after returning from this function.
+ *
+ * @param[in] aInstance   The OpenThread instance.
+ * @param[in] aQuerier    The record querier to be stopped.
+ */
+void otPlatDnssdStopRecordQuerier(otInstance *aInstance, const otPlatDnssdRecordQuerier *aQuerier);
+
 /**
  * @}
  */
diff --git a/include/openthread/platform/mdns_socket.h b/include/openthread/platform/mdns_socket.h
index e6a205281..009e5fbdc 100644
--- a/include/openthread/platform/mdns_socket.h
+++ b/include/openthread/platform/mdns_socket.h
@@ -75,6 +75,10 @@ typedef struct otPlatMdnsAddressInfo
  *
  * While enabled, all received messages MUST be reported back using `otPlatMdnsHandleReceive()` callback.
  *
+ * When enabled, the platform MUST also monitor and report all IPv4 and IPv6 addresses assigned to the network
+ * interface using the `otPlatMdnsHandleHostAddressEvent()` callback function. Refer to the documentation of this
+ * callback for detailed information on the callback's usage and parameters.
+ *
  * @param[in] aInstance        The OpernThread instance.
  * @param[in] aEnable          Indicate whether to enable or disable.
  * @param[in] aInfraInfIndex   The infrastructure network interface index.
@@ -154,6 +158,64 @@ extern void otPlatMdnsHandleReceive(otInstance                  *aInstance,
                                     bool                         aIsUnicast,
                                     const otPlatMdnsAddressInfo *aAddress);
 
+/**
+ * Callback to notify OpenThread mDNS module of host address changes.
+ *
+ * When `otPlatMdnsSetListeningEnabled()` enables mDNS listening on an `aInfraIfIndex`, the platform MUST monitor and
+ * report ALL IPv4 and IPv6 addresses assigned to this network interface.
+ *
+ * When mDNS is enabled:
+ * - The platform MUST retrieve ALL currently assigned IPv4 and IPv6 addresses on the specified interface.
+ * - For each retrieved address, the platform MUST call `otPlatMdnsHandleHostAddressEvent()` to add the address.
+ * - The IPv4 addresses are represented using IPv4-mapped IPv6 format.
+ *
+ * Ongoing monitoring (while enabled):
+ * - The platform MUST continuously monitor the specified interface for address changes.
+ * - When the address list changes, the platform MUST notify the OpenThread stack of the change using one of the
+ *   following methods:
+ *   A. Call this callback for each affected address, indicating the change (addition or removal using @p aAdded).
+ *   B. Alternatively, call the `otPlatMdnsHandleHostAddressRemoveAll()` callback once, immediately followed by
+ *      invoking this callback for every currently assigned IPv4 and IPv6 address on the interface adding them
+ *      (@p aAdded set to `TRUE`), providing the completed updated address list.
+ * - These two approaches offer flexibility for platforms with varying capabilities, such as different operating
+ *   systems and network stacks. Some network stacks may provide mechanisms to identify the added or removed
+ *   addresses, while others may only provide the new list upon a change.
+ *
+ *  When mDNS is disabled:
+ * - The platform MUST cease monitoring for address changes on the interface.
+ * - The platform does NOT need to explicitly signal the removal of addresses upon disable. The OpenThread stack
+ *   automatically clears its internal address list.
+ * - If address monitoring is re-enabled later, the platform MUST repeat the "enable" steps again, retrieving and
+ *   reporting ALL current addresses.
+ *
+ * The OpenThread stack maintains an internal list of host addresses. It updates this list automatically upon receiving
+ * calls to `otPlatMdnsHandleHostAddressEvent()`.
+ * - OpenThread's mDNS implementation uses a short guard time (4 msec) before taking action (e.g., announcing new
+ *   addresses). This allows multiple changes to be grouped and announced together.
+ * - OpenThread's mDNS implementation also handles transient changes, e.g., an address is removed and then quickly
+ *   re-added. It ensures that announcements are only made when there is a change to the list (from what was
+ *   announced before). This simplifies the platform's responsibility as it can simply report all observed changes.
+ *
+ * @param[in] aInstance     The OpenThread instance.
+ * @param[in] aAddress      IP Address. IPv4-mapped IPv6 format is used to represent an IPv4 address.
+ * @param[in] aAdded        Boolean to indicate whether the address added (`TRUE`) or removed (`FALSE`).
+ * @param[in] aInfraIfIndex The interface index.
+ */
+extern void otPlatMdnsHandleHostAddressEvent(otInstance         *aInstance,
+                                             const otIp6Address *aAddress,
+                                             bool                aAdded,
+                                             uint32_t            aInfraIfIndex);
+
+/**
+ * Callback to notify OpenThread mDNS module to remove all previously added host IPv4 and IPv6 addresses.
+ *
+ * See documentation of `otPlatMdnsHandleHostAddressEvent()` for how this callback MUST be used.
+ *
+ * @param[in] aInstance     The OpenThread instance.
+ * @param[in] aInfraIfIndex The interface index.
+ */
+extern void otPlatMdnsHandleHostAddressRemoveAll(otInstance *aInstance, uint32_t aInfraIfIndex);
+
 /**
  * @}
  */
diff --git a/include/openthread/platform/multipan.h b/include/openthread/platform/multipan.h
index adece8af6..897dcb297 100644
--- a/include/openthread/platform/multipan.h
+++ b/include/openthread/platform/multipan.h
@@ -115,7 +115,7 @@ extern void otPlatMultipanSwitchoverDone(otInstance *aInstance, bool aSuccess);
  *
  * @param[in] aIid  The IID of the interface.
  *
- * @retval  Instance pointer if aIid is has an instance assigned, nullptr otherwise.
+ * @retval  Instance pointer if aIid is has an instance assigned, NULL otherwise.
  */
 otInstance *otPlatMultipanIidToInstance(uint8_t aIid);
 
diff --git a/include/openthread/platform/radio.h b/include/openthread/platform/radio.h
index 7cef06b9d..b49be9cfd 100644
--- a/include/openthread/platform/radio.h
+++ b/include/openthread/platform/radio.h
@@ -895,7 +895,7 @@ otError otPlatRadioReceive(otInstance *aInstance, uint8_t aChannel);
 otError otPlatRadioReceiveAt(otInstance *aInstance, uint8_t aChannel, uint32_t aStart, uint32_t aDuration);
 
 /**
- * The radio driver calls this method to notify OpenThread of a received frame.
+ * The radio driver calls this function to notify OpenThread of a received frame.
  *
  * @param[in]  aInstance The OpenThread instance structure.
  * @param[in]  aFrame    A pointer to the received frame or NULL if the receive operation failed.
@@ -906,7 +906,7 @@ otError otPlatRadioReceiveAt(otInstance *aInstance, uint8_t aChannel, uint32_t a
 extern void otPlatRadioReceiveDone(otInstance *aInstance, otRadioFrame *aFrame, otError aError);
 
 /**
- * The radio driver calls this method to notify OpenThread diagnostics module of a received frame.
+ * The radio driver calls this function to notify OpenThread diagnostics module of a received frame.
  *
  * Is used when diagnostics is enabled.
  *
@@ -950,7 +950,7 @@ otRadioFrame *otPlatRadioGetTransmitBuffer(otInstance *aInstance);
 otError otPlatRadioTransmit(otInstance *aInstance, otRadioFrame *aFrame);
 
 /**
- * The radio driver calls this method to notify OpenThread that the transmission has started.
+ * The radio driver calls this function to notify OpenThread that the transmission has started.
  *
  * @note  This function should be called by the same thread that executes all of the other OpenThread code. It should
  *        not be called by ISR or any other task.
@@ -978,7 +978,7 @@ extern void otPlatRadioTxStarted(otInstance *aInstance, otRadioFrame *aFrame);
 extern void otPlatRadioTxDone(otInstance *aInstance, otRadioFrame *aFrame, otRadioFrame *aAckFrame, otError aError);
 
 /**
- * The radio driver calls this method to notify OpenThread diagnostics module that the transmission has completed.
+ * The radio driver calls this function to notify OpenThread diagnostics module that the transmission has completed.
  *
  * Is used when diagnostics is enabled.
  *
@@ -991,11 +991,14 @@ extern void otPlatRadioTxDone(otInstance *aInstance, otRadioFrame *aFrame, otRad
 extern void otPlatDiagRadioTransmitDone(otInstance *aInstance, otRadioFrame *aFrame, otError aError);
 
 /**
- * Get the most recent RSSI measurement.
+ * Return a recent RSSI measurement when the radio is in receive state.
  *
- * @param[in] aInstance  The OpenThread instance structure.
+ * If the radio is not in receive state, then `OT_RADIO_RSSI_INVALID` MUST be returned. If the radio is in receive
+ * state, then a single RSSI measurement is taken on the current receive channel and returned.
+ *
+ * @param[in] aInstance The OpenThread instance structure.
  *
- * @returns The RSSI in dBm when it is valid.  127 when RSSI is invalid.
+ * @returns The RSSI in dBm when it is valid. `OT_RADIO_RSSI_INVALID` when RSSI is invalid.
  */
 int8_t otPlatRadioGetRssi(otInstance *aInstance);
 
@@ -1015,7 +1018,7 @@ int8_t otPlatRadioGetRssi(otInstance *aInstance);
 otError otPlatRadioEnergyScan(otInstance *aInstance, uint8_t aScanChannel, uint16_t aScanDuration);
 
 /**
- * The radio driver calls this method to notify OpenThread that the energy scan is complete.
+ * The radio driver calls this function to notify OpenThread that the energy scan is complete.
  *
  * Is used when radio provides OT_RADIO_CAPS_ENERGY_SCAN capability.
  *
@@ -1025,7 +1028,7 @@ otError otPlatRadioEnergyScan(otInstance *aInstance, uint8_t aScanChannel, uint1
 extern void otPlatRadioEnergyScanDone(otInstance *aInstance, int8_t aEnergyScanMaxRssi);
 
 /**
- * The radio driver calls this method to notify OpenThread that the spinel bus latency has been changed.
+ * The radio driver calls this function to notify OpenThread that the spinel bus latency has been changed.
  *
  * @param[in]  aInstance  The OpenThread instance structure.
  */
@@ -1166,10 +1169,15 @@ otError otPlatRadioGetCoexMetrics(otInstance *aInstance, otRadioCoexMetrics *aCo
 /**
  * Enable or disable CSL receiver.
  *
+ * Regarding @p aExtAddr, this function assumes big-endian byte order. Note that this differs from
+ * `otPlatRadioSetExtendedAddress()`, `otPlatRadioAddSrcMatchExtEntry()`, and `otPlatRadioClearSrcMatchExtEntry()`,
+ * which use little-endian byte order for the Extended MAC address.
+ *
  * @param[in]  aInstance     The OpenThread instance structure.
  * @param[in]  aCslPeriod    CSL period, 0 for disabling CSL. CSL period is in unit of 10 symbols.
  * @param[in]  aShortAddr    The short source address of CSL receiver's peer.
- * @param[in]  aExtAddr      The extended source address of CSL receiver's peer.
+ * @param[in]  aExtAddr      The extended source address of CSL receiver's peer. The @p aExtAddr assumes big-endian
+ *                           byte order.
  *
  * @note Platforms should use CSL peer addresses to include CSL IE when generating enhanced acks.
  *
@@ -1185,7 +1193,7 @@ otError otPlatRadioEnableCsl(otInstance         *aInstance,
 /**
  * Reset CSL receiver in the platform.
  *
- * @note Defaults to `otPlatRadioEnableCsl(aInstance,0, Mac::kShortAddrInvalid, nullptr);`
+ * @note Defaults to `otPlatRadioEnableCsl(aInstance,0, Mac::kShortAddrInvalid, NULL);`
  *
  * @param[in]  aInstance     The OpenThread instance structure.
  *
@@ -1290,7 +1298,7 @@ otError otPlatRadioSetRegion(otInstance *aInstance, uint16_t aRegionCode);
  * @param[in]  aInstance    The OpenThread instance structure.
  * @param[out] aRegionCode  The radio region.
  *
- * @retval  OT_ERROR_INVALID_ARGS     @p aRegionCode is nullptr.
+ * @retval  OT_ERROR_INVALID_ARGS     @p aRegionCode is NULL.
  * @retval  OT_ERROR_FAILED           Other platform specific errors.
  * @retval  OT_ERROR_NONE             Successfully got region code.
  * @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented.
@@ -1301,15 +1309,20 @@ otError otPlatRadioGetRegion(otInstance *aInstance, uint16_t *aRegionCode);
  * Enable/disable or update Enhanced-ACK Based Probing in radio for a specific Initiator.
  *
  * After Enhanced-ACK Based Probing is configured by a specific Probing Initiator, the Enhanced-ACK sent to that
- * node should include Vendor-Specific IE containing Link Metrics data. This method informs the radio to start/stop to
+ * node should include Vendor-Specific IE containing Link Metrics data. This function informs the radio to start/stop to
  * collect Link Metrics data and include Vendor-Specific IE that containing the data in Enhanced-ACK sent to that
  * Probing Initiator.
  *
+ * Regarding @p aExtAddress, this function assumes big-endian byte order. Note that this differs from
+ * `otPlatRadioSetExtendedAddress()`, `otPlatRadioAddSrcMatchExtEntry()`, and `otPlatRadioClearSrcMatchExtEntry()`,
+ * which use little-endian byte order for the Extended MAC address.
+ *
  * @param[in]  aInstance     The OpenThread instance structure.
  * @param[in]  aLinkMetrics  This parameter specifies what metrics to query. Per spec 4.11.3.4.4.6, at most 2 metrics
  *                           can be specified. The probing would be disabled if @p `aLinkMetrics` is bitwise 0.
  * @param[in]  aShortAddress The short address of the Probing Initiator.
- * @param[in]  aExtAddress   The extended source address of the Probing Initiator. @p aExtAddr MUST NOT be `NULL`.
+ * @param[in]  aExtAddress   The extended source address of the Probing Initiator. @p aExtAddress MUST NOT be `NULL`.
+ *                           The @p aExtAddress assumes big-endian byte order.
  *
  * @retval  OT_ERROR_NONE            Successfully configured the Enhanced-ACK Based Probing.
  * @retval  OT_ERROR_INVALID_ARGS    @p aExtAddress is `NULL`.
diff --git a/include/openthread/thread.h b/include/openthread/thread.h
index 173fa0920..8be4cec6e 100644
--- a/include/openthread/thread.h
+++ b/include/openthread/thread.h
@@ -178,11 +178,6 @@ typedef struct otMleCounters
     uint16_t mBetterPartitionAttachAttempts; ///< Number of attempts to attach to a better partition.
     uint16_t mBetterParentAttachAttempts;    ///< Number of attempts to attach to find a better parent (parent search).
 
-    /**
-     * Role time tracking.
-     *
-     * When uptime feature is enabled (OPENTHREAD_CONFIG_UPTIME_ENABLE = 1) time spent in each MLE role is tracked.
-     */
     uint64_t mDisabledTime; ///< Number of milliseconds device has been in OT_DEVICE_ROLE_DISABLED role.
     uint64_t mDetachedTime; ///< Number of milliseconds device has been in OT_DEVICE_ROLE_DETACHED role.
     uint64_t mChildTime;    ///< Number of milliseconds device has been in OT_DEVICE_ROLE_CHILD role.
@@ -934,8 +929,6 @@ void otThreadResetMleCounters(otInstance *aInstance);
 /**
  * Gets the current attach duration (number of seconds since the device last attached).
  *
- * Requires the `OPENTHREAD_CONFIG_UPTIME_ENABLE` feature.
- *
  * If the device is not currently attached, zero will be returned.
  *
  * Unlike the role-tracking variables in `otMleCounters`, which track the cumulative time the device is in each role,
diff --git a/include/openthread/thread_ftd.h b/include/openthread/thread_ftd.h
index dbe06c341..4571a0bf1 100644
--- a/include/openthread/thread_ftd.h
+++ b/include/openthread/thread_ftd.h
@@ -57,7 +57,7 @@ typedef struct
     otExtAddress mExtAddress;           ///< IEEE 802.15.4 Extended Address
     uint32_t     mTimeout;              ///< Timeout
     uint32_t     mAge;                  ///< Seconds since last heard
-    uint64_t     mConnectionTime;       ///< Seconds since attach (requires `OPENTHREAD_CONFIG_UPTIME_ENABLE`)
+    uint64_t     mConnectionTime;       ///< Seconds since attach
     uint16_t     mRloc16;               ///< RLOC16
     uint16_t     mChildId;              ///< Child ID
     uint8_t      mNetworkDataVersion;   ///< Network Data Version
diff --git a/include/openthread/trel.h b/include/openthread/trel.h
index 271d68677..23e4c47e6 100644
--- a/include/openthread/trel.h
+++ b/include/openthread/trel.h
@@ -68,7 +68,7 @@ typedef struct otTrelPeer
 /**
  * Represents an iterator for iterating over TREL peer table entries.
  */
-typedef uint16_t otTrelPeerIterator;
+typedef const void *otTrelPeerIterator;
 
 /**
  * Enables or disables TREL operation.
diff --git a/script/bootstrap b/script/bootstrap
index c79481744..3900df82f 100755
--- a/script/bootstrap
+++ b/script/bootstrap
@@ -56,7 +56,7 @@ install_packages_apt()
 
     # apt-get update and install dependencies
     sudo apt-get update
-    sudo apt-get --no-install-recommends install -y g++ lsb-release cmake ninja-build shellcheck
+    sudo apt-get --no-install-recommends install -y g++ lsb-release cmake ninja-build shellcheck libgtest-dev libgmock-dev
 
     echo 'Installing GNU Arm Embedded Toolchain...'
 
diff --git a/script/check-posix-build-cmake b/script/check-posix-build-cmake
index 63f67c683..965da3f22 100755
--- a/script/check-posix-build-cmake
+++ b/script/check-posix-build-cmake
@@ -76,7 +76,7 @@ main()
     fi
 
     reset_source
-    build -DOT_POSIX_RCP_VENDOR_BUS=ON "$@"
+    build -DOT_POSIX_RCP_VENDOR_BUS=ON -DOT_SPINEL_CP_RESET_FAIL_CALLBACK_ENABLE=ON "$@"
 }
 
 main "$@"
diff --git a/script/test b/script/test
index 128b0ae09..9ee6862c6 100755
--- a/script/test
+++ b/script/test
@@ -414,7 +414,7 @@ do_build_otbr_docker()
             third_party/openthread/repo
         rm -rf .git
 
-        docker build -t "${otbr_docker_image}" -f etc/docker/Dockerfile . \
+        docker build -t "${otbr_docker_image}" -f etc/docker/test/Dockerfile . \
             "${docker_build_args[@]}" \
             --build-arg OTBR_OPTIONS="${otbr_options[*]}"
     )
diff --git a/src/android/logging.c b/src/android/logging.c
index 889267aab..2291f7565 100644
--- a/src/android/logging.c
+++ b/src/android/logging.c
@@ -55,9 +55,9 @@ void otPlatLog(otLogLevel aLogLevel, otLogRegion aLogRegion, const char *aFormat
         priority = ANDROID_LOG_FATAL;
         break;
     case OT_LOG_LEVEL_WARN:
+    case OT_LOG_LEVEL_NOTE:
         priority = ANDROID_LOG_WARN;
         break;
-    case OT_LOG_LEVEL_NOTE:
     case OT_LOG_LEVEL_INFO:
         priority = ANDROID_LOG_INFO;
         break;
diff --git a/src/android/openthread-core-android-config.h b/src/android/openthread-core-android-config.h
index 1534dcf2f..86dc38e91 100644
--- a/src/android/openthread-core-android-config.h
+++ b/src/android/openthread-core-android-config.h
@@ -270,6 +270,7 @@ static_assert(OPENTHREAD_CONFIG_NUM_MESSAGE_BUFFERS * (32 * sizeof(void *)) ==
 #define OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE 1
 #define OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE 1
 #define OPENTHREAD_CONFIG_BACKBONE_ROUTER_MULTICAST_ROUTING_ENABLE 1
+#define OPENTHREAD_CONFIG_DNS_CLIENT_ENABLE 1
 #define OPENTHREAD_CONFIG_DNSSD_SERVER_ENABLE 1
 #define OPENTHREAD_CONFIG_ECDSA_ENABLE 1
 #define OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE 1
@@ -279,6 +280,7 @@ static_assert(OPENTHREAD_CONFIG_NUM_MESSAGE_BUFFERS * (32 * sizeof(void *)) ==
 #define OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE 1
 #define OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE 1
 #define OPENTHREAD_CONFIG_PING_SENDER_ENABLE 1
+#define OPENTHREAD_CONFIG_SRP_CLIENT_ENABLE 1
 #define OPENTHREAD_CONFIG_SRP_SERVER_ENABLE 1
 #define OPENTHREAD_CONFIG_TMF_NETDATA_SERVICE_ENABLE 1
 #define OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE 1
@@ -360,4 +362,43 @@ static_assert(OPENTHREAD_CONFIG_NUM_MESSAGE_BUFFERS * (32 * sizeof(void *)) ==
 // Enables setting vendor info to network diagnostic
 #define OPENTHREAD_CONFIG_NET_DIAG_VENDOR_INFO_SET_API_ENABLE 1
 
+// Enable multiple Adjacent Infrastructure Links (AILs) detection feature
+#define OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE 1
+
+// Enable History Tracker module
+#define OPENTHREAD_CONFIG_HISTORY_TRACKER_ENABLE 1
+
+// Disables Network Info in History Tracker
+#define OPENTHREAD_CONFIG_HISTORY_TRACKER_NET_INFO_LIST_SIZE 0
+
+// Disables unicast IPv6 address in History Tracker
+#define OPENTHREAD_CONFIG_HISTORY_TRACKER_UNICAST_ADDRESS_LIST_SIZE 0
+
+// Disables multicast IPv6 address in History Tracker
+#define OPENTHREAD_CONFIG_HISTORY_TRACKER_MULTICAST_ADDRESS_LIST_SIZE 0
+
+// Disables RX list in History Tracker
+#define OPENTHREAD_CONFIG_HISTORY_TRACKER_RX_LIST_SIZE 0
+
+// Disables TX list in History Tracker
+#define OPENTHREAD_CONFIG_HISTORY_TRACKER_TX_LIST_SIZE 0
+
+// Disables exclusion of Thread Control message (e.g., MLE, TMF) from TX and RX history
+#define OPENTHREAD_CONFIG_HISTORY_TRACKER_EXCLUDE_THREAD_CONTROL_MESSAGES 0
+
+// Disables neighbor table list in History Tracker
+#define OPENTHREAD_CONFIG_HISTORY_TRACKER_NEIGHBOR_LIST_SIZE 0
+
+// Disables router table in History Tracker
+#define OPENTHREAD_CONFIG_HISTORY_TRACKER_ROUTER_LIST_SIZE 0
+
+// Disables On Mesh Prefix in History Tracker
+#define OPENTHREAD_CONFIG_HISTORY_TRACKER_ON_MESH_PREFIX_LIST_SIZE 0
+
+// Disables External Route list in History Tracker
+#define OPENTHREAD_CONFIG_HISTORY_TRACKER_EXTERNAL_ROUTE_LIST_SIZE 0
+
+// Enables Epskc events in History Tracker to collect Epskc journey stats
+#define OPENTHREAD_CONFIG_HISTORY_TRACKER_EPSKC_EVENT_SIZE 64
+
 #endif // OPENTHREAD_CORE_ANDROID_CONFIG_H_
diff --git a/src/cli/README.md b/src/cli/README.md
index eacbbe35e..8b2c87806 100644
--- a/src/cli/README.md
+++ b/src/cli/README.md
@@ -143,8 +143,6 @@ Done
 
 Prints the attach time (duration since device was last attached).
 
-Requires `OPENTHREAD_CONFIG_UPTIME_ENABLE`.
-
 Duration is formatted as `{hh}:{mm}:{ss}` for hours, minutes, and seconds if it is less than one day. If the duration is longer than one day, the format is `{dd}d.{hh}:{mm}:{ss}`.
 
 ```bash
@@ -363,6 +361,29 @@ Done
 
 Show current Border Agent information.
 
+### ba enable
+
+Enables Border Agent service.
+
+By default, the Border Agent service is enabled. The `ba enable` and `ba disable` allow user to explicitly control its state. This can be useful in scenarios such as:
+
+- The user wishes to delay the start of the Border Agent service (and its mDNS advertisement of the `_meshcop._udp` service on the infrastructure link). This allows time to prepare or determine vendor-specific TXT data entries for inclusion.
+- Unit tests or test scripts might disable the Border Agent service to prevent it from interfering with specific test steps. For example, tests validating mDNS or DNS-SD functionality may disable the Border Agent to prevent its registration of the MeshCoP service.
+
+```
+> ba enable
+Done
+```
+
+### ba disable
+
+Disables Border Agent service.
+
+```
+> ba disable
+Done
+```
+
 ### ba port
 
 Print Border Agent's service port.
@@ -379,8 +400,9 @@ Print Border Agent's state.
 
 Possible states are
 
-- `Active`: Border Agent is active.
-- `Inactive`: Border Agent is not active.
+- `Disabled`: Border Agent service is disabled.
+- `Inactive`: Border Agent service is enabled but not yet active.
+- `Active`: Border Agent service is enabled and active. External commissioner can connect and establish secure DTLS sessions with the Border Agent using PSKc
 
 ```bash
 > ba state
@@ -388,6 +410,21 @@ Active
 Done
 ```
 
+### ba servicebasename \<name\>
+
+Sets the base name to construct the service instance name used when advertising the mDNS `_meshcop._udp` service by the Border Agent.
+
+Requires the `OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE` feature.
+
+The name can also be configured using the `OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_BASE_NAME` configuration option (which is the recommended way to specify this name). This CLI command (and its corresponding API) is provided for projects where the name needs to be set after device initialization and at run-time.
+
+Per the Thread specification, the service instance should be a user-friendly name identifying the device model or product. A recommended format is "VendorName ProductName". To construct the full name and ensure name uniqueness, the OpenThread Border Agent module will append the Extended Address of the device (as 16-character hex digits) to the given base name. Note that the same name will be used for the ephemeral key service `_meshcop-e._udp` when the ephemeral key feature is enabled and used.
+
+```bash
+ba servicebasename OpenThreadBorderAgent
+Done
+```
+
 ### ba sessions
 
 Prints the list of Border Agent's sessions. Information per session:
@@ -1112,7 +1149,6 @@ Get the counter value.
 
 Note:
 
-- `OPENTHREAD_CONFIG_UPTIME_ENABLE` is required for MLE role time tracking in `counters mle`
 - `OPENTHREAD_CONFIG_IP6_BR_COUNTERS_ENABLE` is required for `counters br`
 
 ```bash
@@ -1206,11 +1242,13 @@ Get the CSL configuration.
 
 CSL period is shown in microseconds.
 
+`OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE` is required.
+
 ```bash
 > csl
-Channel: 11
-Period: 160000us
-Timeout: 1000s
+channel: 11
+period: 160000us
+timeout: 1000s
 Done
 ```
 
@@ -1218,6 +1256,8 @@ Done
 
 Set CSL channel.
 
+`OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE` is required.
+
 ```bash
 > csl channel 20
 Done
@@ -1229,6 +1269,8 @@ Set CSL period in microseconds. Disable CSL by setting this parameter to `0`.
 
 The CSL period MUST be a multiple 160 microseconds which is 802.15.4 "ten symbols time".
 
+`OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE` is required.
+
 ```bash
 > csl period 30000000
 Done
@@ -1238,11 +1280,37 @@ Done
 
 Set the CSL timeout in seconds.
 
+`OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE` is required.
+
 ```bash
 > csl timeout 10
 Done
 ```
 
+### csl accuracy
+
+Gets the CSL Accuracy in units of PPM.
+
+`OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE` or `OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE` is required.
+
+```bash
+> csl accuracy
+20
+Done
+```
+
+### csl uncertainty
+
+Gets the CSL Uncertainty in units of 10 us.
+
+`OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE` or `OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE` is required.
+
+```bash
+> csl uncertainty
+10
+Done
+```
+
 ### debug
 
 Executes a series of CLI commands to gather information about the device and thread network. This is intended for debugging.
@@ -1573,6 +1641,28 @@ Service instance label is provided first, followed by the service name (note tha
 
 The parameters after `service-name` are optional. Any unspecified (or zero) value for these optional parameters is replaced by the value from the current default config (`dns config`).
 
+### dns query \<record-type\> \<first-label\> \<next-labels\> \[DNS server IP\] \[DNS server port\] \[response timeout (ms)\] \[max tx attempts\] \[recursion desired (boolean)\]
+
+Requires `OPENTHREAD_CONFIG_DNS_CLIENT_ENABLE` and `OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE`.
+
+Sends a DNS query for a given record type and DNS name. DNS name is provided as a first label, followed by the next labels which are dot '.' separated. Note that the first label can itself contain the dot '.' character.
+
+The `record-type` is a numerical value corresponding to the DNS RRType values.
+
+The parameters after `next-labels` are optional. Any unspecified (or zero) value for these optional parameters is replaced by the value from the current default config (`dns config`).
+
+If record type is `PTR` (12), `CNAME` (5), `DNAME` (39), `NS` (2), or `SRV` (33), the record data in the received response contains a DNS name which may use DNS name compression. For these specific record types, the record data is first decompressed such that it contains the full uncompressed DNS name. This decompressed data is then provided in the output. For all other record types, the record data is read and provided as it appears in the received response message.
+
+```bash
+> dns query 25 myhost default.service.arpa.
+DNS query response for myhost.default.service.arpa.
+0)
+    RecordType:25, RecordLength: 32, TTL:7108, Section:answer
+    Name:myhost.default.service.arpa.
+    RecordData:[001900010000e02d00440201030d4983605c0406803deb2d672cc42224773977]
+Done
+```
+
 ### dns server upstream \[enable|disable\]
 
 Enable/Disable the upstream DNS feature. If no argument is provided, it prints whether the upstream DNS feature is enabled.
@@ -2876,13 +2966,26 @@ Done
 
 ### networkdiagnostic reset \<addr\> \<type\> ..
 
-Send network diagnostic request to reset \<addr\>'s tlv of \<type\>s. Currently only `MAC Counters`(9) is supported.
+Send network diagnostic request to reset \<addr\>'s tlv of \<type\>s. Currently `MAC Counters`(9) is supported.
 
 ```bash
 > diagnostic reset fd00:db8::ff:fe00:0 9
 Done
 ```
 
+### networkdiagnostic nonpreferredchannels
+
+Get or set the non-preferred channels value as a channel mask. This is used to respond to a Network Diagnostics Get request for the corresponding TLV. The channel mask is a 32-bit unsigned integer value where the least significant bit (LSB), also referred to as bit 0, corresponds to channel number 0, and so on.
+
+```bash
+> networkdiagnostic nonpreferredchannels 0x4000000
+Done
+
+> networkdiagnostic nonpreferredchannels
+0x4000000
+Done
+```
+
 ### networkidtimeout
 
 Get the NETWORK_ID_TIMEOUT parameter used in the Router role.
@@ -3773,7 +3876,7 @@ Return state of current state.
 
 ```bash
 > state
-offline, disabled, detached, child, router or leader
+disabled, detached, child, router or leader
 Done
 ```
 
diff --git a/src/cli/README_BR.md b/src/cli/README_BR.md
index dddb123a5..be98847db 100644
--- a/src/cli/README_BR.md
+++ b/src/cli/README_BR.md
@@ -33,12 +33,15 @@ Print BR command help menu.
 counters
 disable
 enable
+multiail
+omrconfig
 omrprefix
 onlinkprefix
 pd
 peers
 prefixtable
 raoptions
+rdnsstable
 rioprf
 routeprf
 routers
@@ -116,6 +119,104 @@ RS TxFailed: 0
 Done
 ```
 
+### multiail
+
+Usage : `br multiail`
+
+Requires `OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE`.
+
+Get the current detected state regarding multiple Adjacent Infrastructure Links (AILs) indicating whether the Routing Manager currently believes that Border Routers (BRs) on the Thread mesh may be connected to different AILs.
+
+The detection mechanism operates as follows: The Routing Manager monitors the number of peer BRs listed in the Thread Network Data (see `br peers`) and compares this count with the number of peer BRs discovered by processing received Router Advertisement (RA) messages on its connected AIL. If the count derived from Network Data consistently exceeds the count derived from RAs for a detection duration of 10 minutes, it concludes that BRs are likely connected to different AILs. To clear the state a shorter window of 1 minute is used.
+
+The detection window of 10 minutes helps to avoid false positives due to transient changes. The Routing Manager uses 200 seconds for reachability checks of peer BRs (sending Neighbor Solicitation). Stale Network Data entries are also expected to age out within a few minutes. So a 10-minute detection time accommodates both cases.
+
+While generally effective, this detection mechanism may get less reliable in scenarios with a large number of BRs, particularly exceeding ten. This is related to the "Network Data Publisher" mechanism, where BRs might refrain from publishing their external route information in the Network Data to conserve its limited size, potentially skewing the Network Data BR count.
+
+```bash
+> br multiail
+not detected
+Done
+
+> br multiail
+detected
+Done
+```
+
+Usage: `br multiail callback enable|disable`
+
+Enable or disable callback to be notified of changes in the multi-AIL detection state.
+
+```bash
+> br multiail callback enable
+Done
+
+BR multi AIL callback: detected
+
+> br multiail
+detected
+Done
+
+BR multi AIL callback: cleared
+```
+
+### omrconfig
+
+Usage: `br omrconfig`
+
+Get the current OMR prefix configuration mode.
+
+The possible modes are:
+
+- `auto`: BR auto-generates the local OMR prefix.
+- `custom`: BR uses a given custom OMR prefix with its associated preference.
+- `disabled`: BR does not add local/PD OMR prefix in Network Data.
+
+```bash
+> br omrconfig
+auto
+Done
+```
+
+Usage: `br omrconfig auto`
+
+Set the current OMR prefix configuration mode to `auto`.
+
+```
+> br omrconfig auto
+Done
+
+> br omrconfig
+auto
+Done
+```
+
+Usage: `br omrconfig custom <prefix> [high|med|low]`
+
+Set the current OMR prefix configuration mode to `custom`
+
+```
+> br omrconfig custom fd00::/64 med
+Done
+
+> br omrconfig
+custom (fd00:0:0:0::/64, prf:med)
+Done
+```
+
+Usage: `br omrconfig disable`
+
+Set the current OMR prefix configuration mode to `disabled`
+
+```
+> br omrconfig disable
+Done
+
+> br omrconfig
+disabled
+Done
+```
+
 ### omrprefix
 
 Usage: `br omrprefix [local|favored]`
@@ -314,6 +415,30 @@ Clear any previously set additional options to append at the end of emitted Rout
 Done
 ```
 
+### rdnsstable
+
+Usage: `br rdnsstable`
+
+Get the discovered Recursive DNS Server (RDNSS) address table by Border Routing Manager on the infrastructure link.
+
+Info per entry:
+
+- IPv6 address
+- Lifetime in seconds
+- Milliseconds since last received Router Advertisement containing this address
+- The router IPv6 address which advertised this prefix
+- Flags in received Router Advertisement header:
+  - M: Managed Address Config flag
+  - O: Other Config flag
+  - S: SNAC Router flag
+
+```bash
+> br rdnsstable
+fd00:1234:5678::1, lifetime:500, ms-since-rx:29526, router:ff02:0:0:0:0:0:0:1 (M:0 O:0 S:1)
+fd00:aaaa::2, lifetime:500, ms-since-rx:107, router:ff02:0:0:0:0:0:0:1 (M:0 O:0 S:1)
+Done
+```
+
 ### rioprf
 
 Usage: `br rioprf`
diff --git a/src/cli/README_DATASET.md b/src/cli/README_DATASET.md
index 5e7003761..40d311355 100644
--- a/src/cli/README_DATASET.md
+++ b/src/cli/README_DATASET.md
@@ -346,7 +346,7 @@ Done
 
 ### active
 
-Usage: `dataset active [-x]`
+Usage: `dataset active [-x|-ns]`
 
 Print Active Operational Dataset in human-readable form.
 
@@ -366,6 +366,24 @@ Security Policy: 672 onrc 0
 Done
 ```
 
+Print Active Operational Dataset in human-readable form and redact the sensitive values.
+
+```bash
+> dataset active -ns
+Active Timestamp: 1
+Channel: 15
+Wake-up Channel: 16
+Channel Mask: 0x07fff800
+Ext PAN ID: 39758ec8144b07fb
+Mesh Local Prefix: fdf1:f1ad:d079:7dc0::/64
+Network Key: [Redacted]
+Network Name: OpenThread-5938
+PAN ID: 0x5938
+PSKc: [Redacted]
+Security Policy: 672 onrc 0
+Done
+```
+
 Print Active Operational Dataset as hex-encoded TLVs.
 
 ```bash
@@ -620,7 +638,7 @@ Done
 
 ### pending
 
-Usage: `dataset pending [-x]`
+Usage: `dataset pending [-x|-ns]`
 
 Print Pending Operational Dataset in human-readable form.
 
@@ -641,6 +659,25 @@ Security Policy: 672 onrc 0
 Done
 ```
 
+Print Pending Operational Dataset in human-readable form and redact the sensitive values.
+
+```bash
+> dataset pending -ns
+Pending Timestamp: 2
+Active Timestamp: 1
+Channel: 26
+Channel Mask: 0x07fff800
+Delay: 58706
+Ext PAN ID: a74182f4d3f4de41
+Mesh Local Prefix: fd46:c1b9:e159:5574::/64
+Network Key: [Redacted]
+Network Name: OpenThread-bff8
+PAN ID: 0xbff8
+PSKc: [Redacted]
+Security Policy: 672 onrc 0
+Done
+```
+
 Print Pending Operational Dataset as hex-encoded TLVs.
 
 ```bash
diff --git a/src/cli/README_NETDATA.md b/src/cli/README_NETDATA.md
index 824b548ac..96bf00bb6 100644
--- a/src/cli/README_NETDATA.md
+++ b/src/cli/README_NETDATA.md
@@ -380,7 +380,11 @@ Service entries are listed under `Services` header:
 
 - The prefix
 - Context ID
-- Compress flag (`c` if marked or `-` otherwise).
+- Flags:
+  - s: Stable flag
+  - c: Compress flag
+
+When there are no other flags, `-` will be used.
 
 Commissioning Dataset information is printed under `Commissioning` header:
 
@@ -403,7 +407,7 @@ fd00:4567:0:0::/64 s med 8000
 Services:
 44970 5d fddead00beef00007bad0069ce45948504d2 s a000 0
 Contexts:
-fd00:dead:beef:cafe::/64 1 c
+fd00:dead:beef:cafe::/64 1 sc
 Commissioning:
 1248 dc00 9988 00000000000120000000000000000000 e
 Done
diff --git a/src/cli/README_SRP_SERVER.md b/src/cli/README_SRP_SERVER.md
index 791a2da45..cd91f78b2 100644
--- a/src/cli/README_SRP_SERVER.md
+++ b/src/cli/README_SRP_SERVER.md
@@ -37,6 +37,7 @@ faststart
 help
 host
 lease
+port
 seqnum
 service
 state
@@ -192,6 +193,18 @@ Set LEASE and KEY-LEASE values.
 Done
 ```
 
+### port
+
+Usage: `srp server port`
+
+Get the port number the SRP server is listening to. If the server is not running, `0` will be returned.
+
+```bash
+> srp server port
+53536
+Done
+```
+
 ### seqnum
 
 Usage: `srp server seqnum [<seqnum>]`
diff --git a/src/cli/cli.cpp b/src/cli/cli.cpp
index 048a86c63..fc93c62b1 100644
--- a/src/cli/cli.cpp
+++ b/src/cli/cli.cpp
@@ -410,7 +410,6 @@ otError Interpreter::SetUserCommands(const otCliCommand *aCommands, uint8_t aLen
 
 #if OPENTHREAD_FTD || OPENTHREAD_MTD
 
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
 /**
  * @cli attachtime
  * @code
@@ -419,7 +418,7 @@ otError Interpreter::SetUserCommands(const otCliCommand *aCommands, uint8_t aLen
  * Done
  * @endcode
  * @par
- * Prints the current attach time (duration since device was last attached). Requires `OPENTHREAD_CONFIG_UPTIME_ENABLE`.
+ * Prints the current attach time (duration since device was last attached).
  * Duration is formatted as `{hh}:{mm}:{ss}` for hours, minutes, and seconds if it is less than one day. If the
  * duration is longer than one day, the format is `{dd}d.{hh}:{mm}:{ss}`.
  */
@@ -436,7 +435,6 @@ template <> otError Interpreter::Process<Cmd("attachtime")>(Arg aArgs[])
 exit:
     return error;
 }
-#endif
 
 #if OPENTHREAD_CONFIG_HISTORY_TRACKER_ENABLE
 template <> otError Interpreter::Process<Cmd("history")>(Arg aArgs[]) { return mHistory.Process(aArgs); }
@@ -447,6 +445,23 @@ template <> otError Interpreter::Process<Cmd("ba")>(Arg aArgs[])
 {
     otError error = OT_ERROR_NONE;
 
+    /**
+     * @cli ba (enable, disable)
+     * @code
+     * ba enable
+     * Done
+     * @endcode
+     * @code
+     * ba disable
+     * Done
+     * @endcode
+     * @cparam ba  @ca{enable|disable}
+     * @par api_copy
+     * #otBorderAgentSetEnabled
+     */
+    if (ProcessEnableDisable(aArgs, otBorderAgentSetEnabled) == OT_ERROR_NONE)
+    {
+    }
     /**
      * @cli ba port
      * @code
@@ -457,7 +472,7 @@ template <> otError Interpreter::Process<Cmd("ba")>(Arg aArgs[])
      * @par api_copy
      * #otBorderAgentGetUdpPort
      */
-    if (aArgs[0] == "port")
+    else if (aArgs[0] == "port")
     {
         OutputLine("%u", otBorderAgentGetUdpPort(GetInstancePtr()));
     }
@@ -468,13 +483,41 @@ template <> otError Interpreter::Process<Cmd("ba")>(Arg aArgs[])
      * Active
      * Done
      * @endcode
-     * @par api_copy
-     * #otBorderAgentIsActive
+     * @par
+     * Prints the current state of the Border Agent service. Possible states are:
+     * - `Disabled`: Border Agent service is disabled.
+     * - `Inactive`: Border Agent service is enabled but not yet active.
+     * - `Active`: Border Agent service is enabled and active. External commissioner can connect and establish secure
+     *   DTLS sessions with the Border Agent using PSKc
+     * @sa #otBorderAgentIsActive
      */
     else if (aArgs[0] == "state")
     {
-        OutputLine("%s", otBorderAgentIsActive(GetInstancePtr()) ? "Active" : "Inactive");
+        if (!otBorderAgentIsEnabled(GetInstancePtr()))
+        {
+            OutputLine("Disabled");
+        }
+        else
+        {
+            OutputLine("%s", otBorderAgentIsActive(GetInstancePtr()) ? "Active" : "Inactive");
+        }
+    }
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+    /**
+     * @cli ba servicebasename
+     * @code
+     * ba servicebasename OpenThreadBorderAgent
+     * Done
+     * @endcode
+     * @par api_copy
+     * #otBorderAgentSetMeshCoPServiceBaseName
+     */
+    else if (aArgs[0] == "servicebasename")
+    {
+        VerifyOrExit(!aArgs[1].IsEmpty() && aArgs[2].IsEmpty(), error = OT_ERROR_INVALID_ARGS);
+        error = otBorderAgentSetMeshCoPServiceBaseName(GetInstancePtr(), aArgs[1].GetCString());
     }
+#endif
     /**
      * @cli ba sessions
      * @code
@@ -2459,6 +2502,12 @@ template <> otError Interpreter::Process<Cmd("counters")>(Arg aArgs[])
                 const char                    *mName;
             };
 
+            struct MleTimeCounterName
+            {
+                const uint64_t otMleCounters::*mValuePtr;
+                const char                    *mName;
+            };
+
             static const MleCounterName kCounterNames[] = {
                 {&otMleCounters::mDisabledRole, "Role Disabled"},
                 {&otMleCounters::mDetachedRole, "Role Detached"},
@@ -2472,36 +2521,27 @@ template <> otError Interpreter::Process<Cmd("counters")>(Arg aArgs[])
                 {&otMleCounters::mParentChanges, "Parent Changes"},
             };
 
+            static const MleTimeCounterName kTimeCounterNames[] = {
+                {&otMleCounters::mDisabledTime, "Disabled"}, {&otMleCounters::mDetachedTime, "Detached"},
+                {&otMleCounters::mChildTime, "Child"},       {&otMleCounters::mRouterTime, "Router"},
+                {&otMleCounters::mLeaderTime, "Leader"},
+            };
+
             const otMleCounters *mleCounters = otThreadGetMleCounters(GetInstancePtr());
 
             for (const MleCounterName &counter : kCounterNames)
             {
                 OutputLine("%s: %u", counter.mName, mleCounters->*counter.mValuePtr);
             }
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
-            {
-                struct MleTimeCounterName
-                {
-                    const uint64_t otMleCounters::*mValuePtr;
-                    const char                    *mName;
-                };
-
-                static const MleTimeCounterName kTimeCounterNames[] = {
-                    {&otMleCounters::mDisabledTime, "Disabled"}, {&otMleCounters::mDetachedTime, "Detached"},
-                    {&otMleCounters::mChildTime, "Child"},       {&otMleCounters::mRouterTime, "Router"},
-                    {&otMleCounters::mLeaderTime, "Leader"},
-                };
-
-                for (const MleTimeCounterName &counter : kTimeCounterNames)
-                {
-                    OutputFormat("Time %s Milli: ", counter.mName);
-                    OutputUint64Line(mleCounters->*counter.mValuePtr);
-                }
 
-                OutputFormat("Time Tracked Milli: ");
-                OutputUint64Line(mleCounters->mTrackedTime);
+            for (const MleTimeCounterName &counter : kTimeCounterNames)
+            {
+                OutputFormat("Time %s Milli: ", counter.mName);
+                OutputUint64Line(mleCounters->*counter.mValuePtr);
             }
-#endif
+
+            OutputFormat("Time Tracked Milli: ");
+            OutputUint64Line(mleCounters->mTrackedTime);
         }
         /**
          * @cli counters mle reset
@@ -2587,28 +2627,64 @@ template <> otError Interpreter::Process<Cmd("counters")>(Arg aArgs[])
     return error;
 }
 
-#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE || OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE
 template <> otError Interpreter::Process<Cmd("csl")>(Arg aArgs[])
 {
     otError error = OT_ERROR_NONE;
 
+    /**
+     * @cli csl accuracy
+     * @code
+     * csl accuracy
+     * 20
+     * Done
+     * @endcode
+     * @par
+     * Gets the CSL Accuracy in units of PPM.
+     * @par
+     * `OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE` or `OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE` is required.
+     * @sa otPlatRadioGetCslAccuracy
+     */
+    if (aArgs[0] == "accuracy")
+    {
+        OutputLine("%u", otPlatRadioGetCslAccuracy(GetInstancePtr()));
+    }
+    /**
+     * @cli csl uncertainty
+     * @code
+     * csl uncertainty
+     * 10
+     * Done
+     * @endcode
+     * @par
+     * Gets the CSL Uncertainty in units of 10 us.
+     * @par
+     * `OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE` or `OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE` is required.
+     * @sa otPlatRadioGetCslUncertainty
+     */
+    else if (aArgs[0] == "uncertainty")
+    {
+        OutputLine("%u", otPlatRadioGetCslUncertainty(GetInstancePtr()));
+    }
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
     /**
      * @cli csl
      * @code
      * csl
-     * Channel: 11
-     * Period: 160000us
-     * Timeout: 1000s
+     * channel: 11
+     * period: 160000us
+     * timeout: 1000s
      * Done
      * @endcode
      * @par
      * Gets the CSL configuration.
+     * @par
+     * `OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE` is required.
      * @sa otLinkGetCslChannel
      * @sa otLinkGetCslPeriod
-     * @sa otLinkGetCslPeriod
      * @sa otLinkGetCslTimeout
      */
-    if (aArgs[0].IsEmpty())
+    else if (aArgs[0].IsEmpty())
     {
         OutputLine("channel: %u", otLinkGetCslChannel(GetInstancePtr()));
         OutputLine("period: %luus", ToUlong(otLinkGetCslPeriod(GetInstancePtr())));
@@ -2623,6 +2699,8 @@ template <> otError Interpreter::Process<Cmd("csl")>(Arg aArgs[])
      * @cparam csl channel @ca{channel}
      * @par api_copy
      * #otLinkSetCslChannel
+     * @par
+     * `OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE` is required.
      */
     else if (aArgs[0] == "channel")
     {
@@ -2637,6 +2715,8 @@ template <> otError Interpreter::Process<Cmd("csl")>(Arg aArgs[])
      * @cparam csl period @ca{period}
      * @par api_copy
      * #otLinkSetCslPeriod
+     * @par
+     * `OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE` is required.
      */
     else if (aArgs[0] == "period")
     {
@@ -2651,11 +2731,14 @@ template <> otError Interpreter::Process<Cmd("csl")>(Arg aArgs[])
      * @cparam csl timeout @ca{timeout}
      * @par api_copy
      * #otLinkSetCslTimeout
+     * @par
+     * `OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE` is required.
      */
     else if (aArgs[0] == "timeout")
     {
         error = ProcessSet(aArgs + 1, otLinkSetCslTimeout);
     }
+#endif // OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
     else
     {
         error = OT_ERROR_INVALID_ARGS;
@@ -2663,7 +2746,7 @@ template <> otError Interpreter::Process<Cmd("csl")>(Arg aArgs[])
 
     return error;
 }
-#endif // OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
+#endif // OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE || OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE
 
 #if OPENTHREAD_FTD
 template <> otError Interpreter::Process<Cmd("delaytimermin")>(Arg aArgs[])
@@ -3302,8 +3385,6 @@ exit:
 
 template <> otError Interpreter::Process<Cmd("instanceid")>(Arg aArgs[])
 {
-    otError error = OT_ERROR_INVALID_ARGS;
-
     /**
      * @cli instanceid
      * @code
@@ -3314,13 +3395,7 @@ template <> otError Interpreter::Process<Cmd("instanceid")>(Arg aArgs[])
      * @par api_copy
      * #otInstanceGetId
      */
-    if (aArgs[0].IsEmpty())
-    {
-        OutputLine("%lu", ToUlong(otInstanceGetId(GetInstancePtr())));
-        error = OT_ERROR_NONE;
-    }
-
-    return error;
+    return ProcessGet(aArgs, otInstanceGetId);
 }
 
 template <> otError Interpreter::Process<Cmd("ipaddr")>(Arg aArgs[])
@@ -4085,8 +4160,6 @@ template <> otError Interpreter::Process<Cmd("pskcref")>(Arg aArgs[])
     }
     else
     {
-        otPskcRef pskcRef;
-
         /**
          * @cli pskcref (set)
          * @code
@@ -4097,19 +4170,9 @@ template <> otError Interpreter::Process<Cmd("pskcref")>(Arg aArgs[])
          * @par api_copy
          * #otThreadSetPskcRef
          */
-        if (aArgs[1].IsEmpty())
-        {
-            SuccessOrExit(error = aArgs[0].ParseAsUint32(pskcRef));
-        }
-        else
-        {
-            ExitNow(error = OT_ERROR_INVALID_ARGS);
-        }
-
-        error = otThreadSetPskcRef(GetInstancePtr(), pskcRef);
+        error = ProcessSet(aArgs, otThreadSetPskcRef);
     }
 
-exit:
     return error;
 }
 #endif
@@ -4570,7 +4633,6 @@ template <> otError Interpreter::Process<Cmd("neighbor")>(Arg aArgs[])
             OutputLine("| %5lu |", ToUlong(neighborInfo.mAge));
         }
     }
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
     /**
      * @cli neighbor conntime
      * @code
@@ -4649,7 +4711,6 @@ template <> otError Interpreter::Process<Cmd("neighbor")>(Arg aArgs[])
             }
         }
     }
-#endif
     else
     {
         error = OT_ERROR_INVALID_ARGS;
@@ -4884,13 +4945,9 @@ template <> otError Interpreter::Process<Cmd("networkkeyref")>(Arg aArgs[])
     }
     else
     {
-        otNetworkKeyRef keyRef;
-
-        SuccessOrExit(error = aArgs[0].ParseAsUint32(keyRef));
-        SuccessOrExit(error = otThreadSetNetworkKeyRef(GetInstancePtr(), keyRef));
+        error = ProcessSet(aArgs, otThreadSetNetworkKeyRef);
     }
 
-exit:
     return error;
 }
 #endif
@@ -6717,8 +6774,11 @@ template <> otError Interpreter::Process<Cmd("targetpower")>(Arg aArgs[])
     uint32_t channelMask;
 
     SuccessOrExit(error = aArgs[0].ParseAsUint8(channel));
+    VerifyOrExit(channel < BitSizeOf(channelMask), error = OT_ERROR_INVALID_ARGS);
+
     channelMask = otLinkGetSupportedChannelMask(GetInstancePtr());
     VerifyOrExit((1 << channel) & channelMask, error = OT_ERROR_INVALID_ARGS);
+
     SuccessOrExit(error = aArgs[1].ParseAsInt16(targetPower));
 
     error = otPlatRadioSetChannelTargetPower(GetInstancePtr(), channel, targetPower);
@@ -7496,6 +7556,46 @@ template <> otError Interpreter::Process<Cmd("networkdiagnostic")>(Arg aArgs[])
     uint8_t      tlvTypes[kMaxTlvs];
     uint8_t      count = 0;
 
+    if (aArgs[0] == "nonpreferredchannels")
+    {
+        /**
+         * @cli networkdiagnostic nonpreferredchannels
+         * @code
+         * networkdiagnostic nonpreferredchannels
+         * 0x4000000
+         * Done
+         * @endcode
+         * @par api_copy
+         * #otThreadGetNonPreferredChannels
+         */
+        if (aArgs[1].IsEmpty())
+        {
+            OutputLine("0x%lx", ToUlong(otThreadGetNonPreferredChannels(GetInstancePtr())));
+        }
+        /**
+         * @cli networkdiagnostic nonpreferredchannels (set)
+         * @code
+         * networkdiagnostic nonpreferredchannels 0x4000000
+         * Done
+         * @endcode
+         * @par api_copy
+         * #otThreadSetNonPreferredChannels
+         * @cparam networkdiagnostic nonprfchannelmas @ca{mask}
+         */
+        else
+        {
+            otChannelMask mask;
+
+            SuccessOrExit(error = aArgs[1].ParseAsUint32(mask));
+            VerifyOrExit(aArgs[2].IsEmpty(), error = OT_ERROR_INVALID_ARGS);
+            otThreadSetNonPreferredChannels(GetInstancePtr(), mask);
+        }
+
+        ExitNow();
+    }
+
+    // Process args for `get` and `reset` commands.
+
     SuccessOrExit(error = aArgs[1].ParseAsIp6Address(address));
 
     for (Arg *arg = &aArgs[2]; !arg->IsEmpty(); arg++)
@@ -7523,7 +7623,7 @@ template <> otError Interpreter::Process<Cmd("networkdiagnostic")>(Arg aArgs[])
      * @code
      * networkdiagnostic get ff02::1 0 1
      * DIAG_GET.rsp/ans: 00080e336e1c41494e1c01020c00
-     * Ext Address: '0e336e1c41494e1c'
+     * Ext Address: 0e336e1c41494e1c
      * Rloc16: 0x0c00
      * Done
      * DIAG_GET.rsp/ans: 00083efcdb7e3f9eb0f201021800
@@ -7559,6 +7659,7 @@ template <> otError Interpreter::Process<Cmd("networkdiagnostic")>(Arg aArgs[])
      * - `29`: Child TLV
      * - `34`: MLE Counters TLV
      * - `35`: Vendor App URL TLV
+     * - `37`: Enhanced Route TLV
      * @par
      * Sends a network diagnostic request to retrieve specified Type Length Values (TLVs)
      * for the specified addresses(es).
@@ -7667,6 +7768,10 @@ void Interpreter::HandleDiagnosticGetResponse(otError                 aError,
             OutputLine("Route:");
             OutputRoute(kIndentSize, diagTlv.mData.mRoute);
             break;
+        case OT_NETWORK_DIAGNOSTIC_TLV_ENHANCED_ROUTE:
+            OutputLine("EnhRoute:");
+            OutputEnhRoute(kIndentSize, diagTlv.mData.mEnhRoute);
+            break;
         case OT_NETWORK_DIAGNOSTIC_TLV_LEADER_DATA:
             OutputLine("Leader Data:");
             OutputLeaderData(kIndentSize, diagTlv.mData.mLeaderData);
@@ -7732,6 +7837,9 @@ void Interpreter::HandleDiagnosticGetResponse(otError                 aError,
         case OT_NETWORK_DIAGNOSTIC_TLV_THREAD_STACK_VERSION:
             OutputLine("Thread Stack Version: %s", diagTlv.mData.mThreadStackVersion);
             break;
+        case OT_NETWORK_DIAGNOSTIC_TLV_NON_PREFERRED_CHANNELS:
+            OutputLine("Non-preferred Channels Mask: 0x%lx", ToUlong(diagTlv.mData.mNonPreferredChannels));
+            break;
         default:
             break;
         }
@@ -7760,6 +7868,7 @@ void Interpreter::OutputConnectivity(uint8_t aIndentSize, const otNetworkDiagCon
     OutputLine(aIndentSize, "SedBufferSize: %u", aConnectivity.mSedBufferSize);
     OutputLine(aIndentSize, "SedDatagramCount: %u", aConnectivity.mSedDatagramCount);
 }
+
 void Interpreter::OutputRoute(uint8_t aIndentSize, const otNetworkDiagRoute &aRoute)
 {
     OutputLine(aIndentSize, "IdSequence: %u", aRoute.mIdSequence);
@@ -7782,6 +7891,36 @@ void Interpreter::OutputRouteData(uint8_t aIndentSize, const otNetworkDiagRouteD
     OutputLine(aIndentSize, "RouteCost: %u", aRouteData.mRouteCost);
 }
 
+void Interpreter::OutputEnhRoute(uint8_t aIndentSize, const otNetworkDiagEnhRoute &aEnhRoute)
+{
+    static constexpr uint8_t kInvalidRouterId = OT_NETWORK_MAX_ROUTER_ID + 1;
+
+    for (uint8_t index = 0; index < aEnhRoute.mRouteCount; index++)
+    {
+        const otNetworkDiagEnhRouteData &routeData = aEnhRoute.mRouteData[index];
+
+        OutputFormat(aIndentSize, "- RouterId:%-2u", routeData.mRouterId);
+
+        if (routeData.mIsSelf)
+        {
+            OutputLine(" The queried device");
+            continue;
+        }
+
+        OutputFormat(" HasLink:%-3s LinkQualityOut:%u LinkQualityIn:%u ", routeData.mHasLink ? "yes" : "no",
+                     routeData.mLinkQualityOut, routeData.mLinkQualityIn);
+
+        if (routeData.mNextHop == kInvalidRouterId)
+        {
+            OutputLine("NextHop:na NextHopCost:na");
+        }
+        else
+        {
+            OutputLine("NextHop:%-2u NextHopCost:%u", routeData.mNextHop, routeData.mNextHopCost);
+        }
+    }
+}
+
 void Interpreter::OutputLeaderData(uint8_t aIndentSize, const otLeaderData &aLeaderData)
 {
     OutputLine(aIndentSize, "PartitionId: 0x%08lx", ToUlong(aLeaderData.mPartitionId));
@@ -8146,9 +8285,7 @@ otError Interpreter::ProcessCommand(Arg aArgs[])
 
     static constexpr Command kCommands[] = {
 #if OPENTHREAD_FTD || OPENTHREAD_MTD
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
         CmdEntry("attachtime"),
-#endif
 #if OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE
         CmdEntry("ba"),
 #endif
@@ -8188,7 +8325,7 @@ otError Interpreter::ProcessCommand(Arg aArgs[])
         CmdEntry("contextreusedelay"),
 #endif
         CmdEntry("counters"),
-#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE || OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE
         CmdEntry("csl"),
 #endif
         CmdEntry("dataset"),
diff --git a/src/cli/cli.hpp b/src/cli/cli.hpp
index 71a4b1b21..46d714577 100644
--- a/src/cli/cli.hpp
+++ b/src/cli/cli.hpp
@@ -262,6 +262,7 @@ private:
     void OutputConnectivity(uint8_t aIndentSize, const otNetworkDiagConnectivity &aConnectivity);
     void OutputRoute(uint8_t aIndentSize, const otNetworkDiagRoute &aRoute);
     void OutputRouteData(uint8_t aIndentSize, const otNetworkDiagRouteData &aRouteData);
+    void OutputEnhRoute(uint8_t aIndentSize, const otNetworkDiagEnhRoute &aEnhRoute);
     void OutputLeaderData(uint8_t aIndentSize, const otLeaderData &aLeaderData);
     void OutputNetworkDiagMacCounters(uint8_t aIndentSize, const otNetworkDiagMacCounters &aMacCounters);
     void OutputNetworkDiagMleCounters(uint8_t aIndentSize, const otNetworkDiagMleCounters &aMleCounters);
diff --git a/src/cli/cli_br.cpp b/src/cli/cli_br.cpp
index 98d203c86..156f68b14 100644
--- a/src/cli/cli_br.cpp
+++ b/src/cli/cli_br.cpp
@@ -143,6 +143,70 @@ exit:
     return error;
 }
 
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+
+template <> otError Br::Process<Cmd("multiail")>(Arg aArgs[])
+{
+    otError error = OT_ERROR_NONE;
+
+    /**
+     * @cli br multiail
+     * @code
+     * br multiail
+     * not detected
+     * @endcode
+     * @par api_copy
+     * #otBorderRoutingIsMultiAilDetected
+     */
+    if (aArgs[0].IsEmpty())
+    {
+        OutputLine("%sdetected", otBorderRoutingIsMultiAilDetected(GetInstancePtr()) ? "" : "not ");
+    }
+    /**
+     * @cli br multiail callback
+     * @code
+     * br multiail callback enable
+     * Done
+     * @endcode
+     * @cparam br multiail callback @ca{enable|disable}
+     * @par api_copy
+     * #otBorderRoutingSetMultiAilCallback
+     */
+    else if (aArgs[0] == "callback")
+    {
+        bool                            enable;
+        otBorderRoutingMultiAilCallback callback = nullptr;
+
+        SuccessOrExit(error = ParseEnableOrDisable(aArgs[1], enable));
+
+        if (enable)
+        {
+            callback = &HandleMultiAilDetected;
+        }
+
+        otBorderRoutingSetMultiAilCallback(GetInstancePtr(), callback, this);
+    }
+    else
+    {
+        error = OT_ERROR_INVALID_ARGS;
+    }
+
+exit:
+    return error;
+}
+
+void Br::HandleMultiAilDetected(bool aDetected, void *aContext)
+{
+    static_cast<Br *>(aContext)->HandleMultiAilDetected(aDetected);
+}
+
+void Br::HandleMultiAilDetected(bool aDetected)
+{
+    OutputLine("BR multi AIL callback: %s", aDetected ? "detected" : "cleared");
+}
+
+#endif // OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+
 otError Br::ParsePrefixTypeArgs(Arg aArgs[], PrefixType &aFlags)
 {
     otError error = OT_ERROR_NONE;
@@ -174,6 +238,114 @@ exit:
     return error;
 }
 
+template <> otError Br::Process<Cmd("omrconfig")>(Arg aArgs[])
+{
+    otError                  error = OT_ERROR_NONE;
+    otIp6Prefix              customPrefix;
+    otRoutePreference        preference;
+    otBorderRoutingOmrConfig omrConfig;
+
+    /**
+     * @cli br omrconfig
+     * @code
+     * br omrconfig
+     * auto
+     * Done
+     * @endcode
+     * @code
+     * br omrconfig
+     * custom (fd00:0:0:0::/64, prf:med)
+     * Done
+     * @endcode
+     * @par
+     * Outputs current OMR prefix configuration mode.
+     * @sa otBorderRoutingGetOmrConfig
+     */
+    if (aArgs[0].IsEmpty())
+    {
+        omrConfig = otBorderRoutingGetOmrConfig(GetInstancePtr(), &customPrefix, &preference);
+
+        switch (omrConfig)
+        {
+        case OT_BORDER_ROUTING_OMR_CONFIG_AUTO:
+            OutputLine("auto");
+            break;
+        case OT_BORDER_ROUTING_OMR_CONFIG_CUSTOM:
+            OutputFormat("custom (");
+            OutputIp6Prefix(customPrefix);
+            OutputLine(", prf:%s)", PreferenceToString(preference));
+            break;
+        case OT_BORDER_ROUTING_OMR_CONFIG_DISABLED:
+            OutputLine("disabled");
+            break;
+        }
+    }
+    else
+    {
+        ClearAllBytes(customPrefix);
+        preference = OT_ROUTE_PREFERENCE_MED;
+
+        /**
+         * @cli br omrconfig auto
+         * @code
+         * br omrconfig auto
+         * Done
+         * @endcode
+         * @par
+         * Sets OMR prefix configuration mode to `auto` In this mode, the Border Routing Manager automatically
+         * selects and manages the OMR prefix.
+         */
+        if (aArgs[0] == "auto")
+        {
+            omrConfig = OT_BORDER_ROUTING_OMR_CONFIG_AUTO;
+            VerifyOrExit(aArgs[1].IsEmpty(), error = OT_ERROR_INVALID_ARGS);
+        }
+        /**
+         * @cli br omrconfig custom
+         * @code
+         * br omrconfig custom fd00::/64 med
+         * Done
+         * @endcode
+         * @cparam br omrconfig custom @ca{prefix} [@ca{high}|@ca{med}|@ca{low}]
+         * @par
+         * Sets OMR prefix configuration mode to `custom`. In this mode, a custom OMR prefix and its associated
+         * preference are used.
+         */
+        else if (aArgs[0] == "custom")
+        {
+            omrConfig = OT_BORDER_ROUTING_OMR_CONFIG_CUSTOM;
+
+            SuccessOrExit(error = aArgs[1].ParseAsIp6Prefix(customPrefix));
+            SuccessOrExit(error = Interpreter::ParsePreference(aArgs[2], preference));
+            VerifyOrExit(aArgs[3].IsEmpty(), error = OT_ERROR_INVALID_ARGS);
+        }
+        /**
+         * @cli br omrconfig disable
+         * @code
+         * br omrconfig disable
+         * Done
+         * @endcode
+         * @cparam br omrconfig disable
+         * @par
+         * Sets OMR prefix configuration mode to `disable` which prevents the Border Routing Manager from adding any
+         * local or DHCPv6 PD OMR prefixes to the Network Data.
+         */
+        else if (aArgs[0] == "disable")
+        {
+            omrConfig = OT_BORDER_ROUTING_OMR_CONFIG_DISABLED;
+        }
+        else
+        {
+            ExitNow(error = OT_ERROR_INVALID_ARGS);
+        }
+
+        error = otBorderRoutingSetOmrConfig(GetInstancePtr(), omrConfig, &customPrefix, preference);
+    }
+
+exit:
+    return error;
+}
+
 /**
  * @cli br omrprefix
  * @code
@@ -526,6 +698,51 @@ exit:
     return error;
 }
 
+/**
+ * @cli br rdnsstable
+ * @code
+ * br rdnsstable
+ * fd00:1234:5678::1, lifetime:500, ms-since-rx:29526, router:ff02:0:0:0:0:0:0:1 (M:0 O:0 S:1)
+ * fd00:aaaa::2, lifetime:500, ms-since-rx:107, router:ff02:0:0:0:0:0:0:1 (M:0 O:0 S:1)
+ * Done
+ * @endcode
+ * @par
+ * Get the discovered Recursive DNS Server (RDNSS) address table by Border Routing Manager on the infrastructure link.
+ * Info per entry:
+ * - IPv6 address
+ * - Lifetime in seconds
+ * - Milliseconds since last received Router Advertisement containing this address
+ * - The router IPv6 address which advertised this prefix
+ * - Flags in received Router Advertisement header:
+ *   - M: Managed Address Config flag
+ *   - O: Other Config flag
+ *   - S: SNAC Router flag
+ * @sa otBorderRoutingGetNextRdnssAddrEntry
+ */
+template <> otError Br::Process<Cmd("rdnsstable")>(Arg aArgs[])
+{
+    otError                            error = OT_ERROR_NONE;
+    otBorderRoutingPrefixTableIterator iterator;
+    otBorderRoutingRdnssAddrEntry      entry;
+
+    VerifyOrExit(aArgs[0].IsEmpty(), error = OT_ERROR_INVALID_ARGS);
+
+    otBorderRoutingPrefixTableInitIterator(GetInstancePtr(), &iterator);
+
+    while (otBorderRoutingGetNextRdnssAddrEntry(GetInstancePtr(), &iterator, &entry) == OT_ERROR_NONE)
+    {
+        char string[OT_IP6_ADDRESS_STRING_SIZE];
+
+        otIp6AddressToString(&entry.mAddress, string, sizeof(string));
+        OutputFormat("%s, lifetime:%lu, ms-since-rx:%lu, router:", string, ToUlong(entry.mLifetime),
+                     ToUlong(entry.mMsecSinceLastUpdate));
+        OutputRouterInfo(entry.mRouter, kShortVersion);
+    }
+
+exit:
+    return error;
+}
+
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_DHCP6_PD_ENABLE
 template <> otError Br::Process<Cmd("pd")>(Arg aArgs[])
 {
@@ -877,9 +1094,13 @@ otError Br::Process(Arg aArgs[])
         CmdEntry("disable"),
         CmdEntry("enable"),
         CmdEntry("init"),
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+        CmdEntry("multiail"),
+#endif
 #if OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE
         CmdEntry("nat64prefix"),
 #endif
+        CmdEntry("omrconfig"),
         CmdEntry("omrprefix"),
         CmdEntry("onlinkprefix"),
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_DHCP6_PD_ENABLE
@@ -890,6 +1111,7 @@ otError Br::Process(Arg aArgs[])
 #endif
         CmdEntry("prefixtable"),
         CmdEntry("raoptions"),
+        CmdEntry("rdnsstable"),
         CmdEntry("rioprf"),
         CmdEntry("routeprf"),
         CmdEntry("routers"),
diff --git a/src/cli/cli_br.hpp b/src/cli/cli_br.hpp
index 26d56d8b0..d5c13793f 100644
--- a/src/cli/cli_br.hpp
+++ b/src/cli/cli_br.hpp
@@ -93,6 +93,11 @@ private:
 
     otError ParsePrefixTypeArgs(Arg aArgs[], PrefixType &aFlags);
     void    OutputRouterInfo(const otBorderRoutingRouterEntry &aEntry, RouterOutputMode aMode);
+
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+    static void HandleMultiAilDetected(bool aDetected, void *aContext);
+    void        HandleMultiAilDetected(bool aDetected);
+#endif
 };
 
 } // namespace Cli
diff --git a/src/cli/cli_commissioner.cpp b/src/cli/cli_commissioner.cpp
index 76d61925b..52c637df3 100644
--- a/src/cli/cli_commissioner.cpp
+++ b/src/cli/cli_commissioner.cpp
@@ -528,19 +528,7 @@ template <> otError Commissioner::Process<Cmd("sessionid")>(Arg aArgs[])
  */
 template <> otError Commissioner::Process<Cmd("id")>(Arg aArgs[])
 {
-    otError error;
-
-    if (aArgs[0].IsEmpty())
-    {
-        OutputLine("%s", otCommissionerGetId(GetInstancePtr()));
-        error = OT_ERROR_NONE;
-    }
-    else
-    {
-        error = otCommissionerSetId(GetInstancePtr(), aArgs[0].GetCString());
-    }
-
-    return error;
+    return ProcessGetSet(aArgs, otCommissionerGetId, otCommissionerSetId);
 }
 
 /**
diff --git a/src/cli/cli_dataset.cpp b/src/cli/cli_dataset.cpp
index d7d7d678e..8394d9c77 100644
--- a/src/cli/cli_dataset.cpp
+++ b/src/cli/cli_dataset.cpp
@@ -578,28 +578,29 @@ exit:
     return error;
 }
 
-otError Dataset::Print(otOperationalDatasetTlvs &aDatasetTlvs)
+otError Dataset::Print(otOperationalDatasetTlvs &aDatasetTlvs, bool aNonsensitiveOnly)
 {
     struct ComponentTitle
     {
-        const char *mTitle; // Title to output.
-        const char *mName;  // To use with `LookupMapper()`.
+        const char *mTitle;       // Title to output.
+        const char *mName;        // To use with `LookupMapper()`.
+        bool        mIsSensitive; // Whether the field is sensitive.
     };
 
     static const ComponentTitle kTitles[] = {
-        {"Pending Timestamp", "pendingtimestamp"},
-        {"Active Timestamp", "activetimestamp"},
-        {"Channel", "channel"},
-        {"Wake-up Channel", "wakeupchannel"},
-        {"Channel Mask", "channelmask"},
-        {"Delay", "delay"},
-        {"Ext PAN ID", "extpanid"},
-        {"Mesh Local Prefix", "meshlocalprefix"},
-        {"Network Key", "networkkey"},
-        {"Network Name", "networkname"},
-        {"PAN ID", "panid"},
-        {"PSKc", "pskc"},
-        {"Security Policy", "securitypolicy"},
+        {"Pending Timestamp", "pendingtimestamp", false},
+        {"Active Timestamp", "activetimestamp", false},
+        {"Channel", "channel", false},
+        {"Wake-up Channel", "wakeupchannel", false},
+        {"Channel Mask", "channelmask", false},
+        {"Delay", "delay", false},
+        {"Ext PAN ID", "extpanid", false},
+        {"Mesh Local Prefix", "meshlocalprefix", false},
+        {"Network Key", "networkkey", true},
+        {"Network Name", "networkname", false},
+        {"PAN ID", "panid", false},
+        {"PSKc", "pskc", true},
+        {"Security Policy", "securitypolicy", false},
     };
 
     otError              error;
@@ -609,12 +610,21 @@ otError Dataset::Print(otOperationalDatasetTlvs &aDatasetTlvs)
 
     for (const ComponentTitle &title : kTitles)
     {
-        const ComponentMapper *mapper = LookupMapper(title.mName);
+        const ComponentMapper *mapper;
+
+        mapper = LookupMapper(title.mName);
 
         if (dataset.mComponents.*mapper->mIsPresentPtr)
         {
             OutputFormat("%s: ", title.mTitle);
-            (this->*mapper->mOutput)(dataset);
+            if (aNonsensitiveOnly && title.mIsSensitive)
+            {
+                OutputLine("[Redacted]");
+            }
+            else
+            {
+                (this->*mapper->mOutput)(dataset);
+            }
         }
     }
 
@@ -688,8 +698,24 @@ exit:
  * 0e08000000000001000000030000103506000...3023d82c841eff0e68db86f35740c030000ff
  * Done
  * @endcode
- * @cparam dataset active [-x]
- * The optional `-x` argument prints the Active Operational %Dataset values as hex-encoded TLVs.
+ * @code
+ * dataset active -ns
+ * Active Timestamp: 1
+ * Channel: 13
+ * Channel Mask: 0x07fff800
+ * Ext PAN ID: d63e8e3e495ebbc3
+ * Mesh Local Prefix: fd3d:b50b:f96d:722d::/64
+ * Network Key: [Redacted]
+ * Network Name: OpenThread-8f28
+ * PAN ID: 0x8f28
+ * PSKc: [Redacted]
+ * Security Policy: 0, onrcb
+ * Done
+ * @endcode
+ * @cparam dataset active [-x|-ns]
+ * * The optional `-x` argument prints the Active Operational Dataset values as hex-encoded TLVs.
+ * * The optional `-ns` argument prints the Active Operational Dataset values and redact the sensitive values, including
+ * the network key and PSKc fields.
  * @par api_copy
  * #otDatasetGetActive
  * @par
@@ -704,12 +730,16 @@ template <> otError Dataset::Process<Cmd("active")>(Arg aArgs[])
 
     if (aArgs[0].IsEmpty())
     {
-        error = Print(dataset);
+        error = Print(dataset, /* aNonsensitiveOnly */ false);
     }
     else if (aArgs[0] == "-x")
     {
         OutputBytesLine(dataset.mTlvs, dataset.mLength);
     }
+    else if (aArgs[0] == "-ns")
+    {
+        error = Print(dataset, /* aNonsensitiveOnly */ true);
+    }
     else
     {
         error = OT_ERROR_INVALID_ARGS;
@@ -728,12 +758,16 @@ template <> otError Dataset::Process<Cmd("pending")>(Arg aArgs[])
 
     if (aArgs[0].IsEmpty())
     {
-        error = Print(datasetTlvs);
+        error = Print(datasetTlvs, /* aNonsensitiveOnly */ false);
     }
     else if (aArgs[0] == "-x")
     {
         OutputBytesLine(datasetTlvs.mTlvs, datasetTlvs.mLength);
     }
+    else if (aArgs[0] == "-ns")
+    {
+        error = Print(datasetTlvs, /* aNonsensitiveOnly */ true);
+    }
     else
     {
         error = OT_ERROR_INVALID_ARGS;
@@ -1283,7 +1317,7 @@ otError Dataset::Process(Arg aArgs[])
 
     if (aArgs[0].IsEmpty())
     {
-        ExitNow(error = Print(sDatasetTlvs));
+        ExitNow(error = Print(sDatasetTlvs, /* aNonsensitiveOnly */ false));
     }
 
     /**
diff --git a/src/cli/cli_dataset.hpp b/src/cli/cli_dataset.hpp
index 1ad5bb05b..985f19d46 100644
--- a/src/cli/cli_dataset.hpp
+++ b/src/cli/cli_dataset.hpp
@@ -124,7 +124,7 @@ private:
 
     template <CommandId kCommandId> otError Process(Arg aArgs[]);
 
-    otError Print(otOperationalDatasetTlvs &aDatasetTlvs);
+    otError Print(otOperationalDatasetTlvs &aDatasetTlvs, bool aNonsensitiveOnly);
 
 #if OPENTHREAD_CONFIG_DATASET_UPDATER_ENABLE && OPENTHREAD_FTD
     otError     ProcessUpdater(Arg aArgs[]);
diff --git a/src/cli/cli_dns.cpp b/src/cli/cli_dns.cpp
index 0ad238dd8..7672ba181 100644
--- a/src/cli/cli_dns.cpp
+++ b/src/cli/cli_dns.cpp
@@ -410,6 +410,55 @@ exit:
 
 #endif // OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
 
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+
+/**
+ * @cli dns query
+ * @cparam dns query @ca{record-type} @ca{first-label} @ca{next-labels} <!--
+ * -->                 [@ca{DNS-server-IP}] [@ca{DNS-server-port}] <!--
+ * -->                 [@ca{response-timeout-ms}] [@ca{max-tx-attempts}] <!--
+ * -->                 [@ca{recursion-desired-boolean}]
+ * @code
+ * dns query 25 myhost default.service.arpa.
+ * DNS query response for myhost.default.service.arpa.
+ * 0)
+ *     RecordType:25, RecordLength: 32, TTL:7108, Section:answer
+ *     Name:myhost.default.service.arpa.
+ *     RecordData:[001900010000e02d00440201030d4983605c0406803deb2d672cc42224773977]
+ * Done
+ * @endcode
+ * @par
+ * Send a DNS query for a given record type and DNS name.
+ * DNS name is provided as a first label, followed by the next labels
+ * which are dot '.' separated. Note that the first label can itself
+ * contain the dot '.' character.
+ * @par
+ * The parameters after `next-labels` are optional. Any unspecified (or zero)
+ * value for these optional parameters is replaced by the value from the
+ * current default config (`dns config`).
+ * @par
+ * `OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE` is required.
+ */
+template <> otError Dns::Process<Cmd("query")>(Arg aArgs[])
+{
+    otError           error = OT_ERROR_NONE;
+    otDnsQueryConfig  queryConfig;
+    otDnsQueryConfig *config = &queryConfig;
+    uint16_t          recordType;
+
+    SuccessOrExit(error = aArgs[0].ParseAsUint16(recordType));
+    VerifyOrExit(!aArgs[2].IsEmpty(), error = OT_ERROR_INVALID_ARGS);
+    SuccessOrExit(error = GetDnsConfig(aArgs + 3, config));
+    SuccessOrExit(error = otDnsClientQueryRecord(GetInstancePtr(), recordType, aArgs[1].GetCString(),
+                                                 aArgs[2].GetCString(), &HandleDnsRecordResponse, this, config));
+    error = OT_ERROR_PENDING;
+
+exit:
+    return error;
+}
+
+#endif // OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+
 //----------------------------------------------------------------------------------------------------------------------
 
 void Dns::OutputResult(otError aError) { Interpreter::GetInterpreter().OutputResult(aError); }
@@ -524,28 +573,29 @@ void Dns::HandleDnsAddressResponse(otError aError, const otDnsAddressResponse *a
 
 void Dns::HandleDnsAddressResponse(otError aError, const otDnsAddressResponse *aResponse)
 {
+    otError      error;
     char         hostName[OT_DNS_MAX_NAME_SIZE];
     otIp6Address address;
     uint32_t     ttl;
+    uint16_t     index = 0;
 
-    IgnoreError(otDnsAddressResponseGetHostName(aResponse, hostName, sizeof(hostName)));
-
+    SuccessOrExit(error = otDnsAddressResponseGetHostName(aResponse, hostName, sizeof(hostName)));
     OutputFormat("DNS response for %s - ", hostName);
 
-    if (aError == OT_ERROR_NONE)
-    {
-        uint16_t index = 0;
+    error = aError;
+    SuccessOrExit(error);
 
-        while (otDnsAddressResponseGetAddress(aResponse, index, &address, &ttl) == OT_ERROR_NONE)
-        {
-            OutputIp6Address(address);
-            OutputFormat(" TTL:%lu ", ToUlong(ttl));
-            index++;
-        }
+    while (otDnsAddressResponseGetAddress(aResponse, index, &address, &ttl) == OT_ERROR_NONE)
+    {
+        OutputIp6Address(address);
+        OutputFormat(" TTL:%lu ", ToUlong(ttl));
+        index++;
     }
 
     OutputNewLine();
-    OutputResult(aError);
+
+exit:
+    OutputResult(error);
 }
 
 #if OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
@@ -581,39 +631,39 @@ void Dns::HandleDnsBrowseResponse(otError aError, const otDnsBrowseResponse *aRe
 
 void Dns::HandleDnsBrowseResponse(otError aError, const otDnsBrowseResponse *aResponse)
 {
+    Error            error;
     char             name[OT_DNS_MAX_NAME_SIZE];
     char             label[OT_DNS_MAX_LABEL_SIZE];
     uint8_t          txtBuffer[kMaxTxtDataSize];
     otDnsServiceInfo serviceInfo;
+    uint16_t         index = 0;
 
-    IgnoreError(otDnsBrowseResponseGetServiceName(aResponse, name, sizeof(name)));
-
+    SuccessOrExit(error = otDnsBrowseResponseGetServiceName(aResponse, name, sizeof(name)));
     OutputLine("DNS browse response for %s", name);
 
-    if (aError == OT_ERROR_NONE)
-    {
-        uint16_t index = 0;
-
-        while (otDnsBrowseResponseGetServiceInstance(aResponse, index, label, sizeof(label)) == OT_ERROR_NONE)
-        {
-            OutputLine("%s", label);
-            index++;
+    error = aError;
+    SuccessOrExit(error);
 
-            serviceInfo.mHostNameBuffer     = name;
-            serviceInfo.mHostNameBufferSize = sizeof(name);
-            serviceInfo.mTxtData            = txtBuffer;
-            serviceInfo.mTxtDataSize        = sizeof(txtBuffer);
+    while (otDnsBrowseResponseGetServiceInstance(aResponse, index, label, sizeof(label)) == OT_ERROR_NONE)
+    {
+        OutputLine("%s", label);
+        index++;
 
-            if (otDnsBrowseResponseGetServiceInfo(aResponse, label, &serviceInfo) == OT_ERROR_NONE)
-            {
-                OutputDnsServiceInfo(kIndentSize, serviceInfo);
-            }
+        serviceInfo.mHostNameBuffer     = name;
+        serviceInfo.mHostNameBufferSize = sizeof(name);
+        serviceInfo.mTxtData            = txtBuffer;
+        serviceInfo.mTxtDataSize        = sizeof(txtBuffer);
 
-            OutputNewLine();
+        if (otDnsBrowseResponseGetServiceInfo(aResponse, label, &serviceInfo) == OT_ERROR_NONE)
+        {
+            OutputDnsServiceInfo(kIndentSize, serviceInfo);
         }
+
+        OutputNewLine();
     }
 
-    OutputResult(aError);
+exit:
+    OutputResult(error);
 }
 
 void Dns::HandleDnsServiceResponse(otError aError, const otDnsServiceResponse *aResponse, void *aContext)
@@ -623,33 +673,107 @@ void Dns::HandleDnsServiceResponse(otError aError, const otDnsServiceResponse *a
 
 void Dns::HandleDnsServiceResponse(otError aError, const otDnsServiceResponse *aResponse)
 {
+    otError          error;
     char             name[OT_DNS_MAX_NAME_SIZE];
     char             label[OT_DNS_MAX_LABEL_SIZE];
     uint8_t          txtBuffer[kMaxTxtDataSize];
     otDnsServiceInfo serviceInfo;
 
-    IgnoreError(otDnsServiceResponseGetServiceName(aResponse, label, sizeof(label), name, sizeof(name)));
-
+    SuccessOrExit(error = otDnsServiceResponseGetServiceName(aResponse, label, sizeof(label), name, sizeof(name)));
     OutputLine("DNS service resolution response for %s for service %s", label, name);
 
-    if (aError == OT_ERROR_NONE)
+    error = aError;
+    SuccessOrExit(error);
+
+    serviceInfo.mHostNameBuffer     = name;
+    serviceInfo.mHostNameBufferSize = sizeof(name);
+    serviceInfo.mTxtData            = txtBuffer;
+    serviceInfo.mTxtDataSize        = sizeof(txtBuffer);
+
+    if (otDnsServiceResponseGetServiceInfo(aResponse, &serviceInfo) == OT_ERROR_NONE)
     {
-        serviceInfo.mHostNameBuffer     = name;
-        serviceInfo.mHostNameBufferSize = sizeof(name);
-        serviceInfo.mTxtData            = txtBuffer;
-        serviceInfo.mTxtDataSize        = sizeof(txtBuffer);
+        OutputDnsServiceInfo(/* aIndentSize */ 0, serviceInfo);
+        OutputNewLine();
+    }
+
+exit:
+    OutputResult(error);
+}
+
+#endif // OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
+
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+void Dns::HandleDnsRecordResponse(otError aError, const otDnsRecordResponse *aResponse, void *aContext)
+{
+    static_cast<Dns *>(aContext)->HandleDnsRecordResponse(aError, aResponse);
+}
+
+void Dns::HandleDnsRecordResponse(otError aError, const otDnsRecordResponse *aResponse)
+{
+    otError         error;
+    char            name[OT_DNS_MAX_NAME_SIZE];
+    uint8_t         data[kMaxRrDataSize];
+    otDnsRecordInfo recordInfo;
 
-        if (otDnsServiceResponseGetServiceInfo(aResponse, &serviceInfo) == OT_ERROR_NONE)
+    SuccessOrExit(error = otDnsRecordResponseGetQueryName(aResponse, name, sizeof(name)));
+    OutputLine("DNS query response for %s ", name);
+
+    error = aError;
+    SuccessOrExit(error);
+
+    for (uint16_t index = 0;; index++)
+    {
+        ClearAllBytes(recordInfo);
+        recordInfo.mNameBuffer     = name;
+        recordInfo.mNameBufferSize = sizeof(name);
+        recordInfo.mDataBuffer     = data;
+        recordInfo.mDataBufferSize = sizeof(data);
+
+        error = otDnsRecordResponseGetRecordInfo(aResponse, index, &recordInfo);
+
+        if (error == OT_ERROR_NOT_FOUND)
+        {
+            error = OT_ERROR_NONE;
+            ExitNow();
+        }
+
+        SuccessOrExit(error);
+
+        OutputLine("%u)", index);
+        OutputLine(kIndentSize, "RecordType:%u, RecordLength:%u, TTL:%lu, Section:%s", recordInfo.mRecordType,
+                   recordInfo.mRecordLength, ToUlong(recordInfo.mTtl), RecordSectionToString(recordInfo.mSection));
+        OutputLine(kIndentSize, "Name:%s", recordInfo.mNameBuffer);
+        OutputFormat(kIndentSize, "RecordData:[");
+        OutputBytes(recordInfo.mDataBuffer, recordInfo.mDataBufferSize);
+
+        if (recordInfo.mDataBufferSize != recordInfo.mRecordLength)
         {
-            OutputDnsServiceInfo(/* aIndentSize */ 0, serviceInfo);
-            OutputNewLine();
+            OutputFormat("...");
         }
+
+        OutputLine("]");
     }
 
-    OutputResult(aError);
+exit:
+    OutputResult(error);
 }
 
-#endif // OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
+const char *Dns::RecordSectionToString(otDnsRecordSection aSection)
+{
+    const char *const kSectionString[] = {
+        "answer",     // (0) OT_DNS_SECTION_ANSWER
+        "authority",  // (1) OT_DNS_SECTION_AUTHORITY
+        "additional", // (2) OT_DNS_SECTION_ADDITIONAL
+    };
+
+    static_assert(0 == OT_DNS_SECTION_ANSWER, "OT_DNS_SECTION_ANSWER value is incorrect");
+    static_assert(1 == OT_DNS_SECTION_AUTHORITY, "OT_DNS_SECTION_AUTHORITY value is incorrect");
+    static_assert(2 == OT_DNS_SECTION_ADDITIONAL, "OT_DNS_SECTION_ADDITIONALATA value is incorrect");
+
+    return Stringify(aSection, kSectionString);
+}
+#endif // OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+
 #endif // OPENTHREAD_CONFIG_DNS_CLIENT_ENABLE
 
 #if OPENTHREAD_CONFIG_DNSSD_SERVER_ENABLE
@@ -716,6 +840,9 @@ otError Dns::Process(Arg aArgs[])
 #endif
 #if OPENTHREAD_CONFIG_DNS_CLIENT_ENABLE
         CmdEntry("config"),
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+        CmdEntry("query"),
+#endif
         CmdEntry("resolve"),
 #if OPENTHREAD_CONFIG_DNS_CLIENT_NAT64_ENABLE
         CmdEntry("resolve4"),
diff --git a/src/cli/cli_dns.hpp b/src/cli/cli_dns.hpp
index 297f1e89f..1edef305f 100644
--- a/src/cli/cli_dns.hpp
+++ b/src/cli/cli_dns.hpp
@@ -92,6 +92,9 @@ public:
 private:
     static constexpr uint8_t  kIndentSize     = 4;
     static constexpr uint16_t kMaxTxtDataSize = OPENTHREAD_CONFIG_CLI_TXT_RECORD_MAX_SIZE;
+    static constexpr uint8_t  kMaxRrDataSize  = 128;
+
+    static const char *const kServiceModeStrings[];
 
     using Command = CommandEntry<Dns>;
 
@@ -104,9 +107,8 @@ private:
     otError     ParseDnsServiceMode(const Arg &aArg, otDnsServiceMode &aMode) const;
     static void HandleDnsAddressResponse(otError aError, const otDnsAddressResponse *aResponse, void *aContext);
     void        HandleDnsAddressResponse(otError aError, const otDnsAddressResponse *aResponse);
-#if OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
-    static const char *const kServiceModeStrings[];
 
+#if OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
     typedef otError (&ResolveServiceFn)(otInstance *,
                                         const char *,
                                         const char *,
@@ -121,7 +123,15 @@ private:
     static void HandleDnsServiceResponse(otError aError, const otDnsServiceResponse *aResponse, void *aContext);
     void        HandleDnsServiceResponse(otError aError, const otDnsServiceResponse *aResponse);
 #endif
+
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+    static void HandleDnsRecordResponse(otError aError, const otDnsRecordResponse *aResponse, void *aContext);
+    void        HandleDnsRecordResponse(otError aError, const otDnsRecordResponse *aResponse);
+
+    static const char *RecordSectionToString(otDnsRecordSection aSection);
 #endif
+
+#endif // OPENTHREAD_CONFIG_DNS_CLIENT_ENABLE
 };
 
 } // namespace Cli
diff --git a/src/cli/cli_mdns.cpp b/src/cli/cli_mdns.cpp
index 8a4e08ee4..32b7399b2 100644
--- a/src/cli/cli_mdns.cpp
+++ b/src/cli/cli_mdns.cpp
@@ -86,6 +86,11 @@ template <> otError Mdns::Process<Cmd("unicastquestion")>(Arg aArgs[])
     return ProcessEnableDisable(aArgs, otMdnsIsQuestionUnicastAllowed, otMdnsSetQuestionUnicastAllowed);
 }
 
+template <> otError Mdns::Process<Cmd("localhostname")>(Arg aArgs[])
+{
+    return ProcessGetSet(aArgs, otMdnsGetLocalHostName, otMdnsSetLocalHostName);
+}
+
 void Mdns::OutputHost(const otMdnsHost &aHost)
 {
     OutputLine("Host %s", aHost.mHostName);
@@ -600,6 +605,51 @@ exit:
     return error;
 }
 
+template <> otError Mdns::Process<Cmd("localhostaddrs")>(Arg aArgs[])
+{
+    otError                error    = OT_ERROR_NONE;
+    otMdnsIterator        *iterator = nullptr;
+    otMdnsLocalHostAddress addr;
+
+    VerifyOrExit(aArgs[0].IsEmpty(), error = OT_ERROR_INVALID_ARGS);
+
+    iterator = otMdnsAllocateIterator(GetInstancePtr());
+    VerifyOrExit(iterator != nullptr, error = OT_ERROR_NO_BUFS);
+
+    while (true)
+    {
+        error = otMdnsGetNextLocalHostAddress(GetInstancePtr(), iterator, &addr);
+
+        if (error == OT_ERROR_NOT_FOUND)
+        {
+            error = OT_ERROR_NONE;
+            ExitNow();
+        }
+
+        SuccessOrExit(error);
+
+        if (addr.mIsIp6)
+        {
+            OutputIp6AddressLine(addr.mAddress.mIp6);
+        }
+        else
+        {
+            char ip4AddressString[OT_IP4_ADDRESS_STRING_SIZE];
+
+            otIp4AddressToString(&addr.mAddress.mIp4, ip4AddressString, sizeof(ip4AddressString));
+            OutputLine("%s", ip4AddressString);
+        }
+    }
+
+exit:
+    if (iterator != nullptr)
+    {
+        otMdnsFreeIterator(GetInstancePtr(), iterator);
+    }
+
+    return error;
+}
+
 #endif // OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
 
 otError Mdns::ParseStartOrStop(const Arg &aArg, bool &aIsStart)
@@ -879,6 +929,64 @@ void Mdns::HandleIp4AddressResult(otInstance *aInstance, const otMdnsAddressResu
     Interpreter::GetInterpreter().mMdns.HandleAddressResult(*aResult, kIp4Address);
 }
 
+template <> otError Mdns::Process<Cmd("recordquerier")>(Arg aArgs[])
+{
+    // mdns recordquerier start|stop <record-type> <first-label> [<next-labels>]
+
+    otError             error;
+    otMdnsRecordQuerier querier;
+    bool                isStart;
+
+    ClearAllBytes(querier);
+
+    SuccessOrExit(error = ParseStartOrStop(aArgs[0], isStart));
+
+    SuccessOrExit(error = aArgs[1].ParseAsUint16(querier.mRecordType));
+
+    VerifyOrExit(!aArgs[2].IsEmpty(), error = OT_ERROR_INVALID_ARGS);
+    querier.mFirstLabel = aArgs[2].GetCString();
+
+    if (!aArgs[3].IsEmpty())
+    {
+        querier.mNextLabels = aArgs[3].GetCString();
+        VerifyOrExit(aArgs[4].IsEmpty(), error = OT_ERROR_INVALID_ARGS);
+    }
+
+    querier.mInfraIfIndex = mInfraIfIndex;
+    querier.mCallback     = HandleRecordResult;
+
+    if (isStart)
+    {
+        error = otMdnsStartRecordQuerier(GetInstancePtr(), &querier);
+    }
+    else
+    {
+        error = otMdnsStopRecordQuerier(GetInstancePtr(), &querier);
+    }
+
+exit:
+    return error;
+}
+
+void Mdns::HandleRecordResult(otInstance *aInstance, const otMdnsRecordResult *aResult)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+
+    Interpreter::GetInterpreter().mMdns.HandleRecordResult(*aResult);
+}
+
+void Mdns::HandleRecordResult(const otMdnsRecordResult &aResult)
+{
+    OutputLine("mDNS result for record %u and name %s %s", aResult.mRecordType, aResult.mFirstLabel,
+               aResult.mNextLabels == nullptr ? "" : aResult.mNextLabels);
+
+    OutputFormat(kIndentSize, "data: ");
+    OutputBytesLine(aResult.mRecordData, aResult.mRecordDataLength);
+
+    OutputLine(kIndentSize, "ttl: %lu", ToUlong(aResult.mTtl));
+    OutputLine(kIndentSize, "if-index: %lu", ToUlong(aResult.mInfraIfIndex));
+}
+
 #if OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
 
 template <> otError Mdns::Process<Cmd("browsers")>(Arg aArgs[])
@@ -1083,6 +1191,46 @@ exit:
     return error;
 }
 
+template <> otError Mdns::Process<Cmd("recordqueriers")>(Arg aArgs[])
+{
+    // mdns recordqueriers
+
+    otError             error;
+    otMdnsIterator     *iterator = nullptr;
+    otMdnsCacheInfo     info;
+    otMdnsRecordQuerier querier;
+
+    VerifyOrExit(aArgs[0].IsEmpty(), error = OT_ERROR_INVALID_ARGS);
+
+    iterator = otMdnsAllocateIterator(GetInstancePtr());
+    VerifyOrExit(iterator != nullptr, error = OT_ERROR_NO_BUFS);
+
+    while (true)
+    {
+        error = otMdnsGetNextRecordQuerier(GetInstancePtr(), iterator, &querier, &info);
+
+        if (error == OT_ERROR_NOT_FOUND)
+        {
+            error = OT_ERROR_NONE;
+            ExitNow();
+        }
+
+        SuccessOrExit(error);
+
+        OutputLine("Record querier for type %u and name %s %s", querier.mRecordType, querier.mFirstLabel,
+                   querier.mNextLabels == nullptr ? "" : querier.mNextLabels);
+        OutputCacheInfo(info);
+    }
+
+exit:
+    if (iterator != nullptr)
+    {
+        otMdnsFreeIterator(GetInstancePtr(), iterator);
+    }
+
+    return error;
+}
+
 #endif // OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
 
 otError Mdns::Process(Arg aArgs[])
@@ -1110,6 +1258,14 @@ otError Mdns::Process(Arg aArgs[])
 #if OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
         CmdEntry("ip6resolvers"),
         CmdEntry("keys"),
+#endif
+#if OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
+        CmdEntry("localhostaddrs"),
+#endif
+        CmdEntry("localhostname"),
+        CmdEntry("recordquerier"),
+#if OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
+        CmdEntry("recordqueriers"),
 #endif
         CmdEntry("register"),
 #if OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
diff --git a/src/cli/cli_mdns.hpp b/src/cli/cli_mdns.hpp
index a2fb03e46..1b8555cab 100644
--- a/src/cli/cli_mdns.hpp
+++ b/src/cli/cli_mdns.hpp
@@ -117,6 +117,7 @@ private:
     void    HandleSrvResult(const otMdnsSrvResult &aResult);
     void    HandleTxtResult(const otMdnsTxtResult &aResult);
     void    HandleAddressResult(const otMdnsAddressResult &aResult, IpAddressType aType);
+    void    HandleRecordResult(const otMdnsRecordResult &aResult);
 
     static otError ParseStartOrStop(const Arg &aArg, bool &aIsStart);
     static void    HandleRegisterationDone(otInstance *aInstance, otMdnsRequestId aRequestId, otError aError);
@@ -125,6 +126,7 @@ private:
     static void    HandleTxtResult(otInstance *aInstance, const otMdnsTxtResult *aResult);
     static void    HandleIp6AddressResult(otInstance *aInstance, const otMdnsAddressResult *aResult);
     static void    HandleIp4AddressResult(otInstance *aInstance, const otMdnsAddressResult *aResult);
+    static void    HandleRecordResult(otInstance *aInstance, const otMdnsRecordResult *aResult);
 
     static otError ParseServiceArgs(Arg aArgs[], otMdnsService &aService, Buffers &aBuffers);
 
diff --git a/src/cli/cli_network_data.cpp b/src/cli/cli_network_data.cpp
index 1a85ddfcd..ef79f016c 100644
--- a/src/cli/cli_network_data.cpp
+++ b/src/cli/cli_network_data.cpp
@@ -173,6 +173,32 @@ void NetworkData::OutputService(const otServiceConfig &aConfig)
     OutputLine(" %04x %u", aConfig.mServerConfig.mRloc16, aConfig.mServiceId);
 }
 
+void NetworkData::OutputContext(const otLowpanContextInfo &aConfig)
+{
+    FlagsString flagsString;
+    char       *flagsPtr = &flagsString[0];
+
+    if (aConfig.mStable)
+    {
+        *flagsPtr++ = 's';
+    }
+
+    if (aConfig.mCompressFlag)
+    {
+        *flagsPtr++ = 'c';
+    }
+
+    if (flagsPtr == &flagsString[0])
+    {
+        *flagsPtr++ = '-';
+    }
+
+    *flagsPtr = '\0';
+
+    OutputIp6Prefix(aConfig.mPrefix);
+    OutputLine(" %u %s", aConfig.mContextId, flagsString);
+}
+
 /**
  * @cli netdata length
  * @code
@@ -639,8 +665,7 @@ void NetworkData::OutputNetworkData(bool aLocal, uint16_t aRloc16)
 
     while (otNetDataGetNextLowpanContextInfo(GetInstancePtr(), &iterator, &context) == OT_ERROR_NONE)
     {
-        OutputIp6Prefix(context.mPrefix);
-        OutputLine(" %u %c", context.mContextId, context.mCompressFlag ? 'c' : '-');
+        OutputContext(context);
     }
 
     otNetDataGetCommissioningDataset(GetInstancePtr(), &dataset);
@@ -742,7 +767,7 @@ exit:
  * 44970 5d c000 s 4000 0
  * 44970 01 9a04b000000e10 s 4000 1
  * Contexts:
- * fd00:dead:beef:cafe::/64 1 c
+ * fd00:dead:beef:cafe::/64 1 sc
  * Commissioning:
  * 1248 dc00 9988 00000000000120000000000000000000 e
  * Done
@@ -759,6 +784,7 @@ exit:
  * Routes:
  * Services:
  * Done
+ * @endcode
  * @cparam netdata show [@ca{-x}|@ca{rloc16}]
  * *   The optional `-x` argument gets Network Data as hex-encoded TLVs.
  * *   The optional `rloc16` argument gets all prefix/route/service entries associated with a given RLOC16.
@@ -802,7 +828,10 @@ exit:
  * 6LoWPAN Context IDs are listed under `Contexts` header:
  * * The prefix
  * * Context ID
- * * Compress flag (`c` if marked or `-` otherwise).
+ * * Flags
+ *   * s: Stable flag
+ *   * c: Compress flag
+ *   * -: If there are no flags
  * @par
  * Commissioning Dataset information is printed under `Commissioning` header:
  * * Session ID if present in Dataset or `-` otherwise
diff --git a/src/cli/cli_network_data.hpp b/src/cli/cli_network_data.hpp
index 5ef7b101e..47d71de4c 100644
--- a/src/cli/cli_network_data.hpp
+++ b/src/cli/cli_network_data.hpp
@@ -129,6 +129,7 @@ private:
     otError GetNextRoute(otNetworkDataIterator *aIterator, otExternalRouteConfig *aConfig, bool aLocal);
     otError GetNextService(otNetworkDataIterator *aIterator, otServiceConfig *aConfig, bool aLocal);
 
+    void    OutputContext(const otLowpanContextInfo &aConfig);
     otError OutputBinary(bool aLocal);
     void    OutputNetworkData(bool aLocal, uint16_t aRloc16);
 
diff --git a/src/cli/cli_srp_server.cpp b/src/cli/cli_srp_server.cpp
index f2a7dc543..39b938a2b 100644
--- a/src/cli/cli_srp_server.cpp
+++ b/src/cli/cli_srp_server.cpp
@@ -152,18 +152,7 @@ template <> otError SrpServer::Process<Cmd("auto")>(Arg aArgs[])
  */
 template <> otError SrpServer::Process<Cmd("domain")>(Arg aArgs[])
 {
-    otError error = OT_ERROR_NONE;
-
-    if (aArgs[0].IsEmpty())
-    {
-        OutputLine("%s", otSrpServerGetDomain(GetInstancePtr()));
-    }
-    else
-    {
-        error = otSrpServerSetDomain(GetInstancePtr(), aArgs[0].GetCString());
-    }
-
-    return error;
+    return ProcessGetSet(aArgs, otSrpServerGetDomain, otSrpServerSetDomain);
 }
 
 #if OPENTHREAD_CONFIG_SRP_SERVER_FAST_START_MODE_ENABLE
@@ -554,6 +543,18 @@ exit:
     return error;
 }
 
+/**
+ * @cli srp server port (get)
+ * @code
+ * srp server port
+ * 53536
+ * Done
+ * @endcode
+ * @par api_copy
+ * #otSrpServerGetPort
+ */
+template <> otError SrpServer::Process<Cmd("port")>(Arg aArgs[]) { return ProcessGet(aArgs, otSrpServerGetPort); }
+
 /**
  * @cli srp server seqnum (get,set)
  * @code
@@ -575,22 +576,7 @@ exit:
  */
 template <> otError SrpServer::Process<Cmd("seqnum")>(Arg aArgs[])
 {
-    otError error = OT_ERROR_NONE;
-
-    if (aArgs[0].IsEmpty())
-    {
-        OutputLine("%u", otSrpServerGetAnycastModeSequenceNumber(GetInstancePtr()));
-    }
-    else
-    {
-        uint8_t sequenceNumber;
-
-        SuccessOrExit(error = aArgs[0].ParseAsUint8(sequenceNumber));
-        error = otSrpServerSetAnycastModeSequenceNumber(GetInstancePtr(), sequenceNumber);
-    }
-
-exit:
-    return error;
+    return ProcessGetSet(aArgs, otSrpServerGetAnycastModeSequenceNumber, otSrpServerSetAnycastModeSequenceNumber);
 }
 
 otError SrpServer::Process(Arg aArgs[])
@@ -613,6 +599,7 @@ otError SrpServer::Process(Arg aArgs[])
 #endif
         CmdEntry("host"),
         CmdEntry("lease"),
+        CmdEntry("port"),
         CmdEntry("seqnum"),
         CmdEntry("service"),
         CmdEntry("state"),
diff --git a/src/cli/ftd.cmake b/src/cli/ftd.cmake
index 7b6f08a00..ce9966207 100644
--- a/src/cli/ftd.cmake
+++ b/src/cli/ftd.cmake
@@ -37,6 +37,7 @@ target_compile_definitions(openthread-cli-ftd
 
 target_compile_options(openthread-cli-ftd PRIVATE
     ${OT_CFLAGS}
+    -Wundef
 )
 
 target_include_directories(openthread-cli-ftd PUBLIC ${OT_PUBLIC_INCLUDES} PRIVATE ${COMMON_INCLUDES})
diff --git a/src/cli/mtd.cmake b/src/cli/mtd.cmake
index 733bfaaa9..f5f035f73 100644
--- a/src/cli/mtd.cmake
+++ b/src/cli/mtd.cmake
@@ -37,6 +37,7 @@ target_compile_definitions(openthread-cli-mtd
 
 target_compile_options(openthread-cli-mtd PRIVATE
     ${OT_CFLAGS}
+    -Wundef
 )
 
 target_include_directories(openthread-cli-mtd PUBLIC ${OT_PUBLIC_INCLUDES} PRIVATE ${COMMON_INCLUDES})
diff --git a/src/cli/radio.cmake b/src/cli/radio.cmake
index 47652d2c6..709a84ca8 100644
--- a/src/cli/radio.cmake
+++ b/src/cli/radio.cmake
@@ -38,6 +38,7 @@ target_compile_definitions(openthread-cli-radio
 
 target_compile_options(openthread-cli-radio PRIVATE
     ${OT_CFLAGS}
+    -Wundef
 )
 
 target_include_directories(openthread-cli-radio PUBLIC ${OT_PUBLIC_INCLUDES} PRIVATE ${COMMON_INCLUDES})
diff --git a/src/core/BUILD.gn b/src/core/BUILD.gn
index 918bc3333..60985b9d8 100644
--- a/src/core/BUILD.gn
+++ b/src/core/BUILD.gn
@@ -617,6 +617,10 @@ openthread_core_files = [
   "radio/trel_link.hpp",
   "radio/trel_packet.cpp",
   "radio/trel_packet.hpp",
+  "radio/trel_peer.cpp",
+  "radio/trel_peer.hpp",
+  "radio/trel_peer_discoverer.cpp",
+  "radio/trel_peer_discoverer.hpp",
   "thread/address_resolver.cpp",
   "thread/address_resolver.hpp",
   "thread/announce_begin_server.cpp",
@@ -660,8 +664,7 @@ openthread_core_files = [
   "thread/mesh_forwarder_mtd.cpp",
   "thread/mle.cpp",
   "thread/mle.hpp",
-  "thread/mle_router.cpp",
-  "thread/mle_router.hpp",
+  "thread/mle_ftd.cpp",
   "thread/mle_tlvs.cpp",
   "thread/mle_tlvs.hpp",
   "thread/mle_types.cpp",
@@ -704,6 +707,8 @@ openthread_core_files = [
   "thread/router_table.hpp",
   "thread/src_match_controller.cpp",
   "thread/src_match_controller.hpp",
+  "thread/thread_link_info.cpp",
+  "thread/thread_link_info.hpp",
   "thread/thread_netif.cpp",
   "thread/thread_netif.hpp",
   "thread/thread_tlvs.hpp",
diff --git a/src/core/CMakeLists.txt b/src/core/CMakeLists.txt
index 16d5db54d..4509311cc 100644
--- a/src/core/CMakeLists.txt
+++ b/src/core/CMakeLists.txt
@@ -203,6 +203,8 @@ set(COMMON_SOURCES
     radio/trel_interface.cpp
     radio/trel_link.cpp
     radio/trel_packet.cpp
+    radio/trel_peer.cpp
+    radio/trel_peer_discoverer.cpp
     thread/address_resolver.cpp
     thread/announce_begin_server.cpp
     thread/announce_sender.cpp
@@ -224,7 +226,7 @@ set(COMMON_SOURCES
     thread/mesh_forwarder_ftd.cpp
     thread/mesh_forwarder_mtd.cpp
     thread/mle.cpp
-    thread/mle_router.cpp
+    thread/mle_ftd.cpp
     thread/mle_tlvs.cpp
     thread/mle_types.cpp
     thread/mlr_manager.cpp
@@ -246,6 +248,7 @@ set(COMMON_SOURCES
     thread/router.cpp
     thread/router_table.cpp
     thread/src_match_controller.cpp
+    thread/thread_link_info.cpp
     thread/thread_netif.cpp
     thread/time_sync_service.cpp
     thread/tmf.cpp
diff --git a/src/core/api/border_agent_api.cpp b/src/core/api/border_agent_api.cpp
index 4a83ed6d6..b52b7f833 100644
--- a/src/core/api/border_agent_api.cpp
+++ b/src/core/api/border_agent_api.cpp
@@ -42,6 +42,35 @@
 
 using namespace ot;
 
+void otBorderAgentSetEnabled(otInstance *aInstance, bool aEnabled)
+{
+    AsCoreType(aInstance).Get<MeshCoP::BorderAgent>().SetEnabled(aEnabled);
+}
+
+bool otBorderAgentIsEnabled(otInstance *aInstance)
+{
+    return AsCoreType(aInstance).Get<MeshCoP::BorderAgent>().IsEnabled();
+}
+
+bool otBorderAgentIsActive(otInstance *aInstance)
+{
+    return AsCoreType(aInstance).Get<MeshCoP::BorderAgent>().IsRunning();
+}
+
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+otError otBorderAgentSetMeshCoPServiceBaseName(otInstance *aInstance, const char *aBaseName)
+{
+    AssertPointerIsNotNull(aBaseName);
+
+    return AsCoreType(aInstance).Get<MeshCoP::BorderAgent>().SetServiceBaseName(aBaseName);
+}
+
+void otBorderAgentSetVendorTxtData(otInstance *aInstance, const uint8_t *aVendorData, uint16_t aVendorDataLength)
+{
+    AsCoreType(aInstance).Get<MeshCoP::BorderAgent>().SetVendorTxtData(aVendorData, aVendorDataLength);
+}
+#endif
+
 #if OPENTHREAD_CONFIG_BORDER_AGENT_ID_ENABLE
 otError otBorderAgentGetId(otInstance *aInstance, otBorderAgentId *aId)
 {
@@ -54,11 +83,6 @@ otError otBorderAgentSetId(otInstance *aInstance, const otBorderAgentId *aId)
 }
 #endif
 
-bool otBorderAgentIsActive(otInstance *aInstance)
-{
-    return AsCoreType(aInstance).Get<MeshCoP::BorderAgent>().IsRunning();
-}
-
 uint16_t otBorderAgentGetUdpPort(otInstance *aInstance)
 {
     return AsCoreType(aInstance).Get<MeshCoP::BorderAgent>().GetUdpPort();
@@ -80,12 +104,12 @@ void otBorderAgentSetMeshCoPServiceChangedCallback(otInstance
                                                    otBorderAgentMeshCoPServiceChangedCallback aCallback,
                                                    void                                      *aContext)
 {
-    AsCoreType(aInstance).Get<MeshCoP::BorderAgent>().SetMeshCoPServiceChangedCallback(aCallback, aContext);
+    AsCoreType(aInstance).Get<MeshCoP::BorderAgent>().SetServiceChangedCallback(aCallback, aContext);
 }
 
 otError otBorderAgentGetMeshCoPServiceTxtData(otInstance *aInstance, otBorderAgentMeshCoPServiceTxtData *aTxtData)
 {
-    return AsCoreType(aInstance).Get<MeshCoP::BorderAgent>().GetMeshCoPServiceTxtData(*aTxtData);
+    return AsCoreType(aInstance).Get<MeshCoP::BorderAgent>().PrepareServiceTxtData(*aTxtData);
 }
 
 const otBorderAgentCounters *otBorderAgentGetCounters(otInstance *aInstance)
diff --git a/src/core/api/border_routing_api.cpp b/src/core/api/border_routing_api.cpp
index 306c9c282..183db0693 100644
--- a/src/core/api/border_routing_api.cpp
+++ b/src/core/api/border_routing_api.cpp
@@ -54,6 +54,34 @@ otBorderRoutingState otBorderRoutingGetState(otInstance *aInstance)
     return MapEnum(AsCoreType(aInstance).Get<BorderRouter::RoutingManager>().GetState());
 }
 
+otError otBorderRoutingSetOmrConfig(otInstance              *aInstance,
+                                    otBorderRoutingOmrConfig aConfig,
+                                    const otIp6Prefix       *aOmrPrefix,
+                                    otRoutePreference        aPreference)
+{
+    return AsCoreType(aInstance).Get<BorderRouter::RoutingManager>().SetOmrConfig(
+        MapEnum(aConfig), AsCoreTypePtr(aOmrPrefix),
+        static_cast<BorderRouter::RoutingManager::RoutePreference>(aPreference));
+}
+
+otBorderRoutingOmrConfig otBorderRoutingGetOmrConfig(otInstance        *aInstance,
+                                                     otIp6Prefix       *aOmrPrefix,
+                                                     otRoutePreference *aPreference)
+{
+    BorderRouter::RoutingManager::RoutePreference preference;
+    BorderRouter::RoutingManager::OmrConfig       omrConfig;
+
+    omrConfig =
+        AsCoreType(aInstance).Get<BorderRouter::RoutingManager>().GetOmrConfig(AsCoreTypePtr(aOmrPrefix), &preference);
+
+    if (aPreference != nullptr)
+    {
+        *aPreference = static_cast<otRoutePreference>(preference);
+    }
+
+    return MapEnum(omrConfig);
+}
+
 otRoutePreference otBorderRoutingGetRouteInfoOptionPreference(otInstance *aInstance)
 {
     return static_cast<otRoutePreference>(
@@ -190,6 +218,23 @@ otError otBorderRoutingGetNextRouterEntry(otInstance                         *aI
     return AsCoreType(aInstance).Get<BorderRouter::RoutingManager>().GetNextRouterEntry(*aIterator, *aEntry);
 }
 
+otError otBorderRoutingGetNextRdnssAddrEntry(otInstance                         *aInstance,
+                                             otBorderRoutingPrefixTableIterator *aIterator,
+                                             otBorderRoutingRdnssAddrEntry      *aEntry)
+{
+    AssertPointerIsNotNull(aIterator);
+    AssertPointerIsNotNull(aEntry);
+
+    return AsCoreType(aInstance).Get<BorderRouter::RoutingManager>().GetNextRdnssAddrEntry(*aIterator, *aEntry);
+}
+
+void otBorderRoutingSetRdnssAddrCallback(otInstance                      *aInstance,
+                                         otBorderRoutingRdnssAddrCallback aCallback,
+                                         void                            *aContext)
+{
+    AsCoreType(aInstance).Get<BorderRouter::RoutingManager>().SetRdnssAddrCallback(aCallback, aContext);
+}
+
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_TRACK_PEER_BR_INFO_ENABLE
 
 otError otBorderRoutingGetNextPeerBrEntry(otInstance                           *aInstance,
@@ -212,6 +257,22 @@ uint16_t otBorderRoutingCountPeerBrs(otInstance *aInstance, uint32_t *aMinAge)
 
 #endif
 
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+
+bool otBorderRoutingIsMultiAilDetected(otInstance *aInstance)
+{
+    return AsCoreType(aInstance).Get<BorderRouter::RoutingManager>().IsMultiAilDetected();
+}
+
+void otBorderRoutingSetMultiAilCallback(otInstance                     *aInstance,
+                                        otBorderRoutingMultiAilCallback aCallback,
+                                        void                           *aContext)
+{
+    AsCoreType(aInstance).Get<BorderRouter::RoutingManager>().SetMultiAilCallback(aCallback, aContext);
+}
+
+#endif
+
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_DHCP6_PD_ENABLE
 
 void otBorderRoutingDhcp6PdSetEnabled(otInstance *aInstance, bool aEnabled)
diff --git a/src/core/api/coap_api.cpp b/src/core/api/coap_api.cpp
index c10728533..f3fad3697 100644
--- a/src/core/api/coap_api.cpp
+++ b/src/core/api/coap_api.cpp
@@ -41,7 +41,7 @@ using namespace ot;
 
 otMessage *otCoapNewMessage(otInstance *aInstance, const otMessageSettings *aSettings)
 {
-    return AsCoreType(aInstance).GetApplicationCoap().NewMessage(Message::Settings::From(aSettings));
+    return AsCoreType(aInstance).Get<Coap::ApplicationCoap>().NewMessage(Message::Settings::From(aSettings));
 }
 
 void otCoapMessageInit(otMessage *aMessage, otCoapType aType, otCoapCode aCode)
@@ -219,9 +219,9 @@ otError otCoapSendRequestBlockWiseWithParameters(otInstance                 *aIn
         VerifyOrExit(txParameters.IsValid(), error = kErrorInvalidArgs);
     }
 
-    error = AsCoreType(aInstance).GetApplicationCoap().SendMessage(AsCoapMessage(aMessage), AsCoreType(aMessageInfo),
-                                                                   txParameters, aHandler, aContext, aTransmitHook,
-                                                                   aReceiveHook);
+    error = AsCoreType(aInstance).Get<Coap::ApplicationCoap>().SendMessage(
+        AsCoapMessage(aMessage), AsCoreType(aMessageInfo), txParameters, aHandler, aContext, aTransmitHook,
+        aReceiveHook);
 
 exit:
     return error;
@@ -246,8 +246,8 @@ otError otCoapSendRequestWithParameters(otInstance               *aInstance,
         VerifyOrExit(txParameters.IsValid(), error = kErrorInvalidArgs);
     }
 
-    error = AsCoreType(aInstance).GetApplicationCoap().SendMessage(AsCoapMessage(aMessage), AsCoreType(aMessageInfo),
-                                                                   txParameters, aHandler, aContext);
+    error = AsCoreType(aInstance).Get<Coap::ApplicationCoap>().SendMessage(
+        AsCoapMessage(aMessage), AsCoreType(aMessageInfo), txParameters, aHandler, aContext);
 
 exit:
     return error;
@@ -255,36 +255,36 @@ exit:
 
 otError otCoapStart(otInstance *aInstance, uint16_t aPort)
 {
-    return AsCoreType(aInstance).GetApplicationCoap().Start(aPort);
+    return AsCoreType(aInstance).Get<Coap::ApplicationCoap>().Start(aPort);
 }
 
-otError otCoapStop(otInstance *aInstance) { return AsCoreType(aInstance).GetApplicationCoap().Stop(); }
+otError otCoapStop(otInstance *aInstance) { return AsCoreType(aInstance).Get<Coap::ApplicationCoap>().Stop(); }
 
 #if OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE
 void otCoapAddBlockWiseResource(otInstance *aInstance, otCoapBlockwiseResource *aResource)
 {
-    AsCoreType(aInstance).GetApplicationCoap().AddBlockWiseResource(AsCoreType(aResource));
+    AsCoreType(aInstance).Get<Coap::ApplicationCoap>().AddBlockWiseResource(AsCoreType(aResource));
 }
 
 void otCoapRemoveBlockWiseResource(otInstance *aInstance, otCoapBlockwiseResource *aResource)
 {
-    AsCoreType(aInstance).GetApplicationCoap().RemoveBlockWiseResource(AsCoreType(aResource));
+    AsCoreType(aInstance).Get<Coap::ApplicationCoap>().RemoveBlockWiseResource(AsCoreType(aResource));
 }
 #endif
 
 void otCoapAddResource(otInstance *aInstance, otCoapResource *aResource)
 {
-    AsCoreType(aInstance).GetApplicationCoap().AddResource(AsCoreType(aResource));
+    AsCoreType(aInstance).Get<Coap::ApplicationCoap>().AddResource(AsCoreType(aResource));
 }
 
 void otCoapRemoveResource(otInstance *aInstance, otCoapResource *aResource)
 {
-    AsCoreType(aInstance).GetApplicationCoap().RemoveResource(AsCoreType(aResource));
+    AsCoreType(aInstance).Get<Coap::ApplicationCoap>().RemoveResource(AsCoreType(aResource));
 }
 
 void otCoapSetDefaultHandler(otInstance *aInstance, otCoapRequestHandler aHandler, void *aContext)
 {
-    AsCoreType(aInstance).GetApplicationCoap().SetDefaultHandler(aHandler, aContext);
+    AsCoreType(aInstance).Get<Coap::ApplicationCoap>().SetDefaultHandler(aHandler, aContext);
 }
 
 #if OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE
@@ -299,9 +299,9 @@ otError otCoapSendResponseBlockWiseWithParameters(otInstance                 *aI
 
     VerifyOrExit(!AsCoreType(aMessage).IsOriginThreadNetif(), error = kErrorInvalidArgs);
 
-    error = AsCoreType(aInstance).GetApplicationCoap().SendMessage(AsCoapMessage(aMessage), AsCoreType(aMessageInfo),
-                                                                   Coap::TxParameters::From(aTxParameters), nullptr,
-                                                                   aContext, aTransmitHook, nullptr);
+    error = AsCoreType(aInstance).Get<Coap::ApplicationCoap>().SendMessage(
+        AsCoapMessage(aMessage), AsCoreType(aMessageInfo), Coap::TxParameters::From(aTxParameters), nullptr, aContext,
+        aTransmitHook, nullptr);
 exit:
     return error;
 }
@@ -316,7 +316,7 @@ otError otCoapSendResponseWithParameters(otInstance               *aInstance,
 
     VerifyOrExit(!AsCoreType(aMessage).IsOriginThreadNetif(), error = kErrorInvalidArgs);
 
-    error = AsCoreType(aInstance).GetApplicationCoap().SendMessage(
+    error = AsCoreType(aInstance).Get<Coap::ApplicationCoap>().SendMessage(
         AsCoapMessage(aMessage), AsCoreType(aMessageInfo), Coap::TxParameters::From(aTxParameters), nullptr, nullptr);
 
 exit:
diff --git a/src/core/api/coap_secure_api.cpp b/src/core/api/coap_secure_api.cpp
index 59e3bbff8..3f322543a 100644
--- a/src/core/api/coap_secure_api.cpp
+++ b/src/core/api/coap_secure_api.cpp
@@ -43,8 +43,8 @@ otError otCoapSecureStart(otInstance *aInstance, uint16_t aPort)
 {
     otError error;
 
-    SuccessOrExit(error = AsCoreType(aInstance).GetApplicationCoapSecure().Open());
-    error = AsCoreType(aInstance).GetApplicationCoapSecure().Bind(aPort);
+    SuccessOrExit(error = AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().Open());
+    error = AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().Bind(aPort);
 
 exit:
     return error;
@@ -58,8 +58,8 @@ otError otCoapSecureStartWithMaxConnAttempts(otInstance                  *aInsta
 {
     Error error = kErrorAlready;
 
-    SuccessOrExit(
-        AsCoreType(aInstance).GetApplicationCoapSecure().SetMaxConnectionAttempts(aMaxAttempts, aCallback, aContext));
+    SuccessOrExit(AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().SetMaxConnectionAttempts(
+        aMaxAttempts, aCallback, aContext));
     error = otCoapSecureStart(aInstance, aPort);
 
 exit:
@@ -73,16 +73,16 @@ void otCoapSecureSetCertificate(otInstance    *aInstance,
                                 const uint8_t *aPrivateKey,
                                 uint32_t       aPrivateKeyLength)
 {
-    AsCoreType(aInstance).GetApplicationCoapSecure().SetCertificate(aX509Cert, aX509Length, aPrivateKey,
-                                                                    aPrivateKeyLength);
+    AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().SetCertificate(aX509Cert, aX509Length, aPrivateKey,
+                                                                            aPrivateKeyLength);
 }
 
 void otCoapSecureSetCaCertificateChain(otInstance    *aInstance,
                                        const uint8_t *aX509CaCertificateChain,
                                        uint32_t       aX509CaCertChainLength)
 {
-    AsCoreType(aInstance).GetApplicationCoapSecure().SetCaCertificateChain(aX509CaCertificateChain,
-                                                                           aX509CaCertChainLength);
+    AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().SetCaCertificateChain(aX509CaCertificateChain,
+                                                                                   aX509CaCertChainLength);
 }
 #endif // MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
 
@@ -96,7 +96,8 @@ void otCoapSecureSetPsk(otInstance    *aInstance,
     AssertPointerIsNotNull(aPsk);
     AssertPointerIsNotNull(aPskIdentity);
 
-    AsCoreType(aInstance).GetApplicationCoapSecure().SetPreSharedKey(aPsk, aPskLength, aPskIdentity, aPskIdLength);
+    AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().SetPreSharedKey(aPsk, aPskLength, aPskIdentity,
+                                                                             aPskIdLength);
 }
 #endif // MBEDTLS_KEY_EXCHANGE_PSK_ENABLED
 
@@ -108,14 +109,14 @@ otError otCoapSecureGetPeerCertificateBase64(otInstance    *aInstance,
 {
     AssertPointerIsNotNull(aPeerCert);
 
-    return AsCoreType(aInstance).GetApplicationCoapSecure().GetPeerCertificateBase64(aPeerCert, aCertLength,
-                                                                                     aCertBufferSize);
+    return AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().GetPeerCertificateBase64(aPeerCert, aCertLength,
+                                                                                             aCertBufferSize);
 }
 #endif // defined(MBEDTLS_BASE64_C) && defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
 
 void otCoapSecureSetSslAuthMode(otInstance *aInstance, bool aVerifyPeerCertificate)
 {
-    AsCoreType(aInstance).GetApplicationCoapSecure().SetSslAuthMode(aVerifyPeerCertificate);
+    AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().SetSslAuthMode(aVerifyPeerCertificate);
 }
 
 otError otCoapSecureConnect(otInstance                     *aInstance,
@@ -123,26 +124,32 @@ otError otCoapSecureConnect(otInstance                     *aInstance,
                             otHandleCoapSecureClientConnect aHandler,
                             void                           *aContext)
 {
-    AsCoreType(aInstance).GetApplicationCoapSecure().SetConnectCallback(aHandler, aContext);
+    AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().SetConnectCallback(aHandler, aContext);
 
-    return AsCoreType(aInstance).GetApplicationCoapSecure().Connect(AsCoreType(aSockAddr));
+    return AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().Connect(AsCoreType(aSockAddr));
 }
 
-void otCoapSecureDisconnect(otInstance *aInstance) { AsCoreType(aInstance).GetApplicationCoapSecure().Disconnect(); }
+void otCoapSecureDisconnect(otInstance *aInstance)
+{
+    AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().Disconnect();
+}
 
 bool otCoapSecureIsConnected(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).GetApplicationCoapSecure().IsConnected();
+    return AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().IsConnected();
 }
 
 bool otCoapSecureIsConnectionActive(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).GetApplicationCoapSecure().IsConnectionActive();
+    return AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().IsConnectionActive();
 }
 
-bool otCoapSecureIsClosed(otInstance *aInstance) { return AsCoreType(aInstance).GetApplicationCoapSecure().IsClosed(); }
+bool otCoapSecureIsClosed(otInstance *aInstance)
+{
+    return AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().IsClosed();
+}
 
-void otCoapSecureStop(otInstance *aInstance) { AsCoreType(aInstance).GetApplicationCoapSecure().Close(); }
+void otCoapSecureStop(otInstance *aInstance) { AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().Close(); }
 
 #if OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE
 otError otCoapSecureSendRequestBlockWise(otInstance                 *aInstance,
@@ -152,8 +159,8 @@ otError otCoapSecureSendRequestBlockWise(otInstance                 *aInstance,
                                          otCoapBlockwiseTransmitHook aTransmitHook,
                                          otCoapBlockwiseReceiveHook  aReceiveHook)
 {
-    return AsCoreType(aInstance).GetApplicationCoapSecure().SendMessage(AsCoapMessage(aMessage), aHandler, aContext,
-                                                                        aTransmitHook, aReceiveHook);
+    return AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().SendMessage(AsCoapMessage(aMessage), aHandler,
+                                                                                aContext, aTransmitHook, aReceiveHook);
 }
 #endif
 
@@ -162,41 +169,42 @@ otError otCoapSecureSendRequest(otInstance           *aInstance,
                                 otCoapResponseHandler aHandler,
                                 void                 *aContext)
 {
-    return AsCoreType(aInstance).GetApplicationCoapSecure().SendMessage(AsCoapMessage(aMessage), aHandler, aContext);
+    return AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().SendMessage(AsCoapMessage(aMessage), aHandler,
+                                                                                aContext);
 }
 
 #if OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE
 void otCoapSecureAddBlockWiseResource(otInstance *aInstance, otCoapBlockwiseResource *aResource)
 {
-    AsCoreType(aInstance).GetApplicationCoapSecure().AddBlockWiseResource(AsCoreType(aResource));
+    AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().AddBlockWiseResource(AsCoreType(aResource));
 }
 
 void otCoapSecureRemoveBlockWiseResource(otInstance *aInstance, otCoapBlockwiseResource *aResource)
 {
-    AsCoreType(aInstance).GetApplicationCoapSecure().RemoveBlockWiseResource(AsCoreType(aResource));
+    AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().RemoveBlockWiseResource(AsCoreType(aResource));
 }
 #endif
 
 void otCoapSecureAddResource(otInstance *aInstance, otCoapResource *aResource)
 {
-    AsCoreType(aInstance).GetApplicationCoapSecure().AddResource(AsCoreType(aResource));
+    AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().AddResource(AsCoreType(aResource));
 }
 
 void otCoapSecureRemoveResource(otInstance *aInstance, otCoapResource *aResource)
 {
-    AsCoreType(aInstance).GetApplicationCoapSecure().RemoveResource(AsCoreType(aResource));
+    AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().RemoveResource(AsCoreType(aResource));
 }
 
 void otCoapSecureSetClientConnectEventCallback(otInstance                     *aInstance,
                                                otHandleCoapSecureClientConnect aHandler,
                                                void                           *aContext)
 {
-    AsCoreType(aInstance).GetApplicationCoapSecure().SetConnectCallback(aHandler, aContext);
+    AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().SetConnectCallback(aHandler, aContext);
 }
 
 void otCoapSecureSetDefaultHandler(otInstance *aInstance, otCoapRequestHandler aHandler, void *aContext)
 {
-    AsCoreType(aInstance).GetApplicationCoapSecure().SetDefaultHandler(aHandler, aContext);
+    AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().SetDefaultHandler(aHandler, aContext);
 }
 
 #if OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE
@@ -208,8 +216,8 @@ otError otCoapSecureSendResponseBlockWise(otInstance                 *aInstance,
 {
     OT_UNUSED_VARIABLE(aMessageInfo);
 
-    return AsCoreType(aInstance).GetApplicationCoapSecure().SendMessage(AsCoapMessage(aMessage), nullptr, aContext,
-                                                                        aTransmitHook);
+    return AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().SendMessage(AsCoapMessage(aMessage), nullptr,
+                                                                                aContext, aTransmitHook);
 }
 #endif
 
@@ -217,7 +225,7 @@ otError otCoapSecureSendResponse(otInstance *aInstance, otMessage *aMessage, con
 {
     OT_UNUSED_VARIABLE(aMessageInfo);
 
-    return AsCoreType(aInstance).GetApplicationCoapSecure().SendMessage(AsCoapMessage(aMessage));
+    return AsCoreType(aInstance).Get<Coap::ApplicationCoapSecure>().SendMessage(AsCoapMessage(aMessage));
 }
 
 #endif // OPENTHREAD_CONFIG_COAP_SECURE_API_ENABLE
diff --git a/src/core/api/dns_api.cpp b/src/core/api/dns_api.cpp
index 5a5de8ab2..a2a37f935 100644
--- a/src/core/api/dns_api.cpp
+++ b/src/core/api/dns_api.cpp
@@ -253,4 +253,38 @@ otError otDnsServiceResponseGetHostAddress(const otDnsServiceResponse *aResponse
 
 #endif // OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
 
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+
+otError otDnsClientQueryRecord(otInstance             *aInstance,
+                               uint16_t                aRecordType,
+                               const char             *aFirstLabel,
+                               const char             *aNextLabels,
+                               otDnsRecordCallback     aCallback,
+                               void                   *aContext,
+                               const otDnsQueryConfig *aConfig)
+{
+    AssertPointerIsNotNull(aNextLabels);
+
+    return AsCoreType(aInstance).Get<Dns::Client>().QueryRecord(aRecordType, aFirstLabel, aNextLabels, aCallback,
+                                                                aContext, AsCoreTypePtr(aConfig));
+}
+
+otError otDnsRecordResponseGetQueryName(const otDnsRecordResponse *aResponse,
+                                        char                      *aNameBuffer,
+                                        uint16_t                   aNameBufferSize)
+{
+    AssertPointerIsNotNull(aNameBuffer);
+
+    return AsCoreType(aResponse).GetQueryName(aNameBuffer, aNameBufferSize);
+}
+
+otError otDnsRecordResponseGetRecordInfo(const otDnsRecordResponse *aResponse,
+                                         uint16_t                   aIndex,
+                                         otDnsRecordInfo           *aRecordInfo)
+{
+    return AsCoreType(aResponse).GetRecordInfo(aIndex, AsCoreType(aRecordInfo));
+}
+
+#endif // OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+
 #endif // OPENTHREAD_CONFIG_DNS_CLIENT_ENABLE
diff --git a/src/core/api/history_tracker_api.cpp b/src/core/api/history_tracker_api.cpp
index 5b4b5f0f5..5a002f7d3 100644
--- a/src/core/api/history_tracker_api.cpp
+++ b/src/core/api/history_tracker_api.cpp
@@ -129,6 +129,19 @@ const otHistoryTrackerExternalRouteInfo *otHistoryTrackerIterateExternalRouteHis
                                                                                           *aEntryAge);
 }
 
+#if OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE && OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
+const otHistoryTrackerBorderAgentEpskcEvent *otHistoryTrackerIterateBorderAgentEpskcEventHistory(
+    otInstance               *aInstance,
+    otHistoryTrackerIterator *aIterator,
+    uint32_t                 *aEntryAge)
+{
+    AssertPointerIsNotNull(aEntryAge);
+
+    return AsCoreType(aInstance).Get<Utils::HistoryTracker>().IterateEpskcEventHistory(AsCoreType(aIterator),
+                                                                                       *aEntryAge);
+}
+#endif
+
 void otHistoryTrackerEntryAgeToString(uint32_t aEntryAge, char *aBuffer, uint16_t aSize)
 {
     Utils::HistoryTracker::EntryAgeToString(aEntryAge, aBuffer, aSize);
diff --git a/src/core/api/instance_api.cpp b/src/core/api/instance_api.cpp
index 39190ca1f..733224243 100644
--- a/src/core/api/instance_api.cpp
+++ b/src/core/api/instance_api.cpp
@@ -65,6 +65,7 @@ otInstance *otInstanceInitMultiple(uint8_t aIdx)
 
     return instance;
 }
+uint8_t otInstanceGetIndex(otInstance *aInstance) { return Instance::GetIdx(AsCoreTypePtr(aInstance)); }
 #endif // OPENTHREAD_CONFIG_MULTIPLE_STATIC_INSTANCE_ENABLE
 otInstance *otInstanceInit(void *aInstanceBuffer, size_t *aInstanceBufferSize)
 {
diff --git a/src/core/api/ip6_api.cpp b/src/core/api/ip6_api.cpp
index a72e64a01..3ff0941e5 100644
--- a/src/core/api/ip6_api.cpp
+++ b/src/core/api/ip6_api.cpp
@@ -266,7 +266,7 @@ void otIp6SetSlaacPrefixFilter(otInstance *aInstance, otIp6SlaacPrefixFilter aFi
 
 otError otIp6SetMeshLocalIid(otInstance *aInstance, const otIp6InterfaceIdentifier *aIid)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().SetMeshLocalIid(AsCoreType(aIid));
+    return AsCoreType(aInstance).Get<Mle::Mle>().SetMeshLocalIid(AsCoreType(aIid));
 }
 
 #endif
diff --git a/src/core/api/link_api.cpp b/src/core/api/link_api.cpp
index 1a46d51aa..f53373370 100644
--- a/src/core/api/link_api.cpp
+++ b/src/core/api/link_api.cpp
@@ -69,7 +69,7 @@ otError otLinkSetChannel(otInstance *aInstance, uint8_t aChannel)
     }
 #endif
 
-    VerifyOrExit(instance.Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(instance.Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
 
     SuccessOrExit(error = instance.Get<Mac::Mac>().SetPanChannel(aChannel));
     instance.Get<MeshCoP::ActiveDatasetManager>().Clear();
@@ -90,7 +90,7 @@ otError otLinkSetWakeupChannel(otInstance *aInstance, uint8_t aChannel)
     Error     error    = kErrorNone;
     Instance &instance = AsCoreType(aInstance);
 
-    VerifyOrExit(instance.Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(instance.Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
 
     SuccessOrExit(error = instance.Get<Mac::Mac>().SetWakeupChannel(aChannel));
 
@@ -112,7 +112,7 @@ otError otLinkSetSupportedChannelMask(otInstance *aInstance, uint32_t aChannelMa
     Error     error    = kErrorNone;
     Instance &instance = AsCoreType(aInstance);
 
-    VerifyOrExit(instance.Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(instance.Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
 
     instance.Get<Mac::Mac>().SetSupportedChannelMask(Mac::ChannelMask(aChannelMask));
 
@@ -130,11 +130,11 @@ otError otLinkSetExtendedAddress(otInstance *aInstance, const otExtAddress *aExt
     Error     error    = kErrorNone;
     Instance &instance = AsCoreType(aInstance);
 
-    VerifyOrExit(instance.Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(instance.Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
 
     instance.Get<Mac::Mac>().SetExtAddress(AsCoreType(aExtAddress));
 
-    instance.Get<Mle::MleRouter>().UpdateLinkLocalAddress();
+    instance.Get<Mle::Mle>().UpdateLinkLocalAddress();
 
 exit:
     return error;
@@ -152,7 +152,7 @@ otError otLinkSetPanId(otInstance *aInstance, otPanId aPanId)
     Error     error    = kErrorNone;
     Instance &instance = AsCoreType(aInstance);
 
-    VerifyOrExit(instance.Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(instance.Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
 
     instance.Get<Mac::Mac>().SetPanId(aPanId);
     instance.Get<MeshCoP::ActiveDatasetManager>().Clear();
@@ -421,7 +421,7 @@ uint16_t otLinkGetCcaFailureRate(otInstance *aInstance)
 #if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
 bool otLinkIsCslEnabled(otInstance *aInstance) { return AsCoreType(aInstance).Get<Mac::Mac>().IsCslEnabled(); }
 
-bool otLinkIsCslSupported(otInstance *aInstance) { return AsCoreType(aInstance).Get<Mac::Mac>().IsCslSupported(); }
+bool otLinkIsCslSupported(otInstance *aInstance) { return AsCoreType(aInstance).Get<Mle::Mle>().IsCslSupported(); }
 
 uint8_t otLinkGetCslChannel(otInstance *aInstance) { return AsCoreType(aInstance).Get<Mac::Mac>().GetCslChannel(); }
 
@@ -464,17 +464,14 @@ exit:
     return error;
 }
 
-uint32_t otLinkGetCslTimeout(otInstance *aInstance)
-{
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetCslTimeout();
-}
+uint32_t otLinkGetCslTimeout(otInstance *aInstance) { return AsCoreType(aInstance).Get<Mle::Mle>().GetCslTimeout(); }
 
 otError otLinkSetCslTimeout(otInstance *aInstance, uint32_t aTimeout)
 {
     Error error = kErrorNone;
 
     VerifyOrExit(kMaxCslTimeout >= aTimeout, error = kErrorInvalidArgs);
-    AsCoreType(aInstance).Get<Mle::MleRouter>().SetCslTimeout(aTimeout);
+    AsCoreType(aInstance).Get<Mle::Mle>().SetCslTimeout(aTimeout);
 
 exit:
     return error;
diff --git a/src/core/api/mdns_api.cpp b/src/core/api/mdns_api.cpp
index 7d737211f..1df04df0b 100644
--- a/src/core/api/mdns_api.cpp
+++ b/src/core/api/mdns_api.cpp
@@ -61,6 +61,16 @@ void otMdnsSetConflictCallback(otInstance *aInstance, otMdnsConflictCallback aCa
     AsCoreType(aInstance).Get<Dns::Multicast::Core>().SetConflictCallback(aCallback);
 }
 
+const char *otMdnsGetLocalHostName(otInstance *aInstance)
+{
+    return AsCoreType(aInstance).Get<Dns::Multicast::Core>().GetLocalHostName();
+}
+
+otError otMdnsSetLocalHostName(otInstance *aInstance, const char *aName)
+{
+    return AsCoreType(aInstance).Get<Dns::Multicast::Core>().SetLocalHostName(aName);
+}
+
 otError otMdnsRegisterHost(otInstance            *aInstance,
                            const otMdnsHost      *aHost,
                            otMdnsRequestId        aRequestId,
@@ -156,6 +166,17 @@ otError otMdnsGetNextKey(otInstance *aInstance, otMdnsIterator *aIterator, otMdn
     return AsCoreType(aInstance).Get<Dns::Multicast::Core>().GetNextKey(*aIterator, *aKey, *aState);
 }
 
+otError otMdnsGetNextLocalHostAddress(otInstance             *aInstance,
+                                      otMdnsIterator         *aIterator,
+                                      otMdnsLocalHostAddress *aAddress)
+
+{
+    AssertPointerIsNotNull(aIterator);
+    AssertPointerIsNotNull(aAddress);
+
+    return AsCoreType(aInstance).Get<Dns::Multicast::Core>().GetNextLocalHostAddress(*aIterator, *aAddress);
+}
+
 #endif // OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
 
 otError otMdnsStartBrowser(otInstance *aInstance, const otMdnsBrowser *aBroswer)
@@ -228,6 +249,20 @@ otError otMdnsStopIp4AddressResolver(otInstance *aInstance, const otMdnsAddressR
     return AsCoreType(aInstance).Get<Dns::Multicast::Core>().StopIp4AddressResolver(*aResolver);
 }
 
+otError otMdnsStartRecordQuerier(otInstance *aInstance, const otMdnsRecordQuerier *aQuerier)
+{
+    AssertPointerIsNotNull(aQuerier);
+
+    return AsCoreType(aInstance).Get<Dns::Multicast::Core>().StartRecordQuerier(*aQuerier);
+}
+
+otError otMdnsStopRecordQuerier(otInstance *aInstance, const otMdnsRecordQuerier *aQuerier)
+{
+    AssertPointerIsNotNull(aQuerier);
+
+    return AsCoreType(aInstance).Get<Dns::Multicast::Core>().StopRecordQuerier(*aQuerier);
+}
+
 #if OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
 
 otError otMdnsGetNextBrowser(otInstance      *aInstance,
@@ -290,6 +325,18 @@ otError otMdnsGetNextIp4AddressResolver(otInstance            *aInstance,
     return AsCoreType(aInstance).Get<Dns::Multicast::Core>().GetNextIp4AddressResolver(*aIterator, *aResolver, *aInfo);
 }
 
+otError otMdnsGetNextRecordQuerier(otInstance          *aInstance,
+                                   otMdnsIterator      *aIterator,
+                                   otMdnsRecordQuerier *aQuerier,
+                                   otMdnsCacheInfo     *aInfo)
+{
+    AssertPointerIsNotNull(aIterator);
+    AssertPointerIsNotNull(aQuerier);
+    AssertPointerIsNotNull(aInfo);
+
+    return AsCoreType(aInstance).Get<Dns::Multicast::Core>().GetNextRecordQuerier(*aIterator, *aQuerier, *aInfo);
+}
+
 #endif // OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
 
 #endif // OPENTHREAD_CONFIG_MULTICAST_DNS_ENABLE && OPENTHREAD_CONFIG_MULTICAST_DNS_PUBLIC_API_ENABLE
diff --git a/src/core/api/netdata_api.cpp b/src/core/api/netdata_api.cpp
index 1a5bec859..9db82b122 100644
--- a/src/core/api/netdata_api.cpp
+++ b/src/core/api/netdata_api.cpp
@@ -108,12 +108,12 @@ void otNetDataGetCommissioningDataset(otInstance *aInstance, otCommissioningData
 
 uint8_t otNetDataGetVersion(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetLeaderData().GetDataVersion(NetworkData::kFullSet);
+    return AsCoreType(aInstance).Get<Mle::Mle>().GetLeaderData().GetDataVersion(NetworkData::kFullSet);
 }
 
 uint8_t otNetDataGetStableVersion(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetLeaderData().GetDataVersion(NetworkData::kStableSubset);
+    return AsCoreType(aInstance).Get<Mle::Mle>().GetLeaderData().GetDataVersion(NetworkData::kStableSubset);
 }
 
 otError otNetDataSteeringDataCheckJoiner(otInstance *aInstance, const otExtAddress *aEui64)
diff --git a/src/core/api/netdiag_api.cpp b/src/core/api/netdiag_api.cpp
index fe026aaba..623ca53ed 100644
--- a/src/core/api/netdiag_api.cpp
+++ b/src/core/api/netdiag_api.cpp
@@ -112,3 +112,20 @@ otError otThreadSetVendorAppUrl(otInstance *aInstance, const char *aVendorAppUrl
     return AsCoreType(aInstance).Get<NetworkDiagnostic::Server>().SetVendorAppUrl(aVendorAppUrl);
 }
 #endif
+
+void otThreadSetNonPreferredChannels(otInstance *aInstance, otChannelMask aChannelMask)
+{
+    return AsCoreType(aInstance).Get<NetworkDiagnostic::Server>().SetNonPreferredChannels(aChannelMask);
+}
+
+otChannelMask otThreadGetNonPreferredChannels(otInstance *aInstance)
+{
+    return AsCoreType(aInstance).Get<NetworkDiagnostic::Server>().GetNonPreferredChannels();
+}
+
+void otThreadSetNonPreferredChannelsResetCallback(otInstance                               *aInstance,
+                                                  otThreadNonPreferredChannelsResetCallback aCallback,
+                                                  void                                     *aContext)
+{
+    AsCoreType(aInstance).Get<NetworkDiagnostic::Server>().SetNonPreferredChannelsResetCallback(aCallback, aContext);
+}
diff --git a/src/core/api/network_time_api.cpp b/src/core/api/network_time_api.cpp
index 19c52f323..29d826b31 100644
--- a/src/core/api/network_time_api.cpp
+++ b/src/core/api/network_time_api.cpp
@@ -52,7 +52,7 @@ otError otNetworkTimeSetSyncPeriod(otInstance *aInstance, uint16_t aTimeSyncPeri
 {
     Error error = kErrorNone;
 
-    VerifyOrExit(AsCoreType(aInstance).Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(AsCoreType(aInstance).Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
 
     AsCoreType(aInstance).Get<TimeSync>().SetTimeSyncPeriod(aTimeSyncPeriod);
 
@@ -69,7 +69,7 @@ otError otNetworkTimeSetXtalThreshold(otInstance *aInstance, uint16_t aXtalThres
 {
     Error error = kErrorNone;
 
-    VerifyOrExit(AsCoreType(aInstance).Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(AsCoreType(aInstance).Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
 
     AsCoreType(aInstance).Get<TimeSync>().SetXtalThreshold(aXtalThreshold);
 
diff --git a/src/core/api/thread_api.cpp b/src/core/api/thread_api.cpp
index 0f89e0afa..d3529f054 100644
--- a/src/core/api/thread_api.cpp
+++ b/src/core/api/thread_api.cpp
@@ -39,14 +39,11 @@
 
 using namespace ot;
 
-uint32_t otThreadGetChildTimeout(otInstance *aInstance)
-{
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetTimeout();
-}
+uint32_t otThreadGetChildTimeout(otInstance *aInstance) { return AsCoreType(aInstance).Get<Mle::Mle>().GetTimeout(); }
 
 void otThreadSetChildTimeout(otInstance *aInstance, uint32_t aTimeout)
 {
-    AsCoreType(aInstance).Get<Mle::MleRouter>().SetTimeout(aTimeout);
+    AsCoreType(aInstance).Get<Mle::Mle>().SetTimeout(aTimeout);
 }
 
 const otExtendedPanId *otThreadGetExtendedPanId(otInstance *aInstance)
@@ -60,7 +57,7 @@ otError otThreadSetExtendedPanId(otInstance *aInstance, const otExtendedPanId *a
     Instance                     &instance = AsCoreType(aInstance);
     const MeshCoP::ExtendedPanId &extPanId = AsCoreType(aExtendedPanId);
 
-    VerifyOrExit(instance.Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(instance.Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
 
     instance.Get<MeshCoP::ExtendedPanIdManager>().SetExtPanId(extPanId);
 
@@ -86,14 +83,14 @@ otLinkModeConfig otThreadGetLinkMode(otInstance *aInstance)
 {
     otLinkModeConfig config;
 
-    AsCoreType(aInstance).Get<Mle::MleRouter>().GetDeviceMode().Get(config);
+    AsCoreType(aInstance).Get<Mle::Mle>().GetDeviceMode().Get(config);
 
     return config;
 }
 
 otError otThreadSetLinkMode(otInstance *aInstance, otLinkModeConfig aConfig)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().SetDeviceMode(Mle::DeviceMode(aConfig));
+    return AsCoreType(aInstance).Get<Mle::Mle>().SetDeviceMode(Mle::DeviceMode(aConfig));
 }
 
 void otThreadGetNetworkKey(otInstance *aInstance, otNetworkKey *aNetworkKey)
@@ -113,7 +110,7 @@ otError otThreadSetNetworkKey(otInstance *aInstance, const otNetworkKey *aKey)
     Error     error    = kErrorNone;
     Instance &instance = AsCoreType(aInstance);
 
-    VerifyOrExit(instance.Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(instance.Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
 
     instance.Get<KeyManager>().SetNetworkKey(AsCoreType(aKey));
 
@@ -132,7 +129,7 @@ otError otThreadSetNetworkKeyRef(otInstance *aInstance, otNetworkKeyRef aKeyRef)
 
     VerifyOrExit(aKeyRef != 0, error = kErrorInvalidArgs);
 
-    VerifyOrExit(instance.Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(instance.Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
 
     instance.Get<KeyManager>().SetNetworkKeyRef((aKeyRef));
     instance.Get<MeshCoP::ActiveDatasetManager>().Clear();
@@ -145,26 +142,26 @@ exit:
 
 const otIp6Address *otThreadGetRloc(otInstance *aInstance)
 {
-    return &AsCoreType(aInstance).Get<Mle::MleRouter>().GetMeshLocalRloc();
+    return &AsCoreType(aInstance).Get<Mle::Mle>().GetMeshLocalRloc();
 }
 
 const otIp6Address *otThreadGetMeshLocalEid(otInstance *aInstance)
 {
-    return &AsCoreType(aInstance).Get<Mle::MleRouter>().GetMeshLocalEid();
+    return &AsCoreType(aInstance).Get<Mle::Mle>().GetMeshLocalEid();
 }
 
 const otMeshLocalPrefix *otThreadGetMeshLocalPrefix(otInstance *aInstance)
 {
-    return &AsCoreType(aInstance).Get<Mle::MleRouter>().GetMeshLocalPrefix();
+    return &AsCoreType(aInstance).Get<Mle::Mle>().GetMeshLocalPrefix();
 }
 
 otError otThreadSetMeshLocalPrefix(otInstance *aInstance, const otMeshLocalPrefix *aMeshLocalPrefix)
 {
     Error error = kErrorNone;
 
-    VerifyOrExit(AsCoreType(aInstance).Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(AsCoreType(aInstance).Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
 
-    AsCoreType(aInstance).Get<Mle::MleRouter>().SetMeshLocalPrefix(AsCoreType(aMeshLocalPrefix));
+    AsCoreType(aInstance).Get<Mle::Mle>().SetMeshLocalPrefix(AsCoreType(aMeshLocalPrefix));
     AsCoreType(aInstance).Get<MeshCoP::ActiveDatasetManager>().Clear();
     AsCoreType(aInstance).Get<MeshCoP::PendingDatasetManager>().Clear();
 
@@ -174,17 +171,17 @@ exit:
 
 const otIp6Address *otThreadGetLinkLocalIp6Address(otInstance *aInstance)
 {
-    return &AsCoreType(aInstance).Get<Mle::MleRouter>().GetLinkLocalAddress();
+    return &AsCoreType(aInstance).Get<Mle::Mle>().GetLinkLocalAddress();
 }
 
 const otIp6Address *otThreadGetLinkLocalAllThreadNodesMulticastAddress(otInstance *aInstance)
 {
-    return &AsCoreType(aInstance).Get<Mle::MleRouter>().GetLinkLocalAllThreadNodesAddress();
+    return &AsCoreType(aInstance).Get<Mle::Mle>().GetLinkLocalAllThreadNodesAddress();
 }
 
 const otIp6Address *otThreadGetRealmLocalAllThreadNodesMulticastAddress(otInstance *aInstance)
 {
-    return &AsCoreType(aInstance).Get<Mle::MleRouter>().GetRealmLocalAllThreadNodesAddress();
+    return &AsCoreType(aInstance).Get<Mle::Mle>().GetRealmLocalAllThreadNodesAddress();
 }
 
 otError otThreadGetServiceAloc(otInstance *aInstance, uint8_t aServiceId, otIp6Address *aServiceAloc)
@@ -207,7 +204,7 @@ otError otThreadSetNetworkName(otInstance *aInstance, const char *aNetworkName)
 {
     Error error = kErrorNone;
 
-    VerifyOrExit(AsCoreType(aInstance).Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(AsCoreType(aInstance).Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
 
 #if !OPENTHREAD_CONFIG_ALLOW_EMPTY_NETWORK_NAME
     // Thread interfaces support a zero length name internally for backwards compatibility, but new names
@@ -233,7 +230,7 @@ otError otThreadSetDomainName(otInstance *aInstance, const char *aDomainName)
 {
     Error error = kErrorNone;
 
-    VerifyOrExit(AsCoreType(aInstance).Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(AsCoreType(aInstance).Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
 
     error = AsCoreType(aInstance).Get<MeshCoP::NetworkNameManager>().SetDomainName(aDomainName);
 
@@ -295,12 +292,9 @@ void otThreadSetKeySwitchGuardTime(otInstance *aInstance, uint16_t aKeySwitchGua
     AsCoreType(aInstance).Get<KeyManager>().SetKeySwitchGuardTime(aKeySwitchGuardTime);
 }
 
-otError otThreadBecomeDetached(otInstance *aInstance)
-{
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().BecomeDetached();
-}
+otError otThreadBecomeDetached(otInstance *aInstance) { return AsCoreType(aInstance).Get<Mle::Mle>().BecomeDetached(); }
 
-otError otThreadBecomeChild(otInstance *aInstance) { return AsCoreType(aInstance).Get<Mle::MleRouter>().BecomeChild(); }
+otError otThreadBecomeChild(otInstance *aInstance) { return AsCoreType(aInstance).Get<Mle::Mle>().BecomeChild(); }
 
 otError otThreadGetNextNeighborInfo(otInstance *aInstance, otNeighborInfoIterator *aIterator, otNeighborInfo *aInfo)
 {
@@ -311,7 +305,7 @@ otError otThreadGetNextNeighborInfo(otInstance *aInstance, otNeighborInfoIterato
 
 otDeviceRole otThreadGetDeviceRole(otInstance *aInstance)
 {
-    return MapEnum(AsCoreType(aInstance).Get<Mle::MleRouter>().GetRole());
+    return MapEnum(AsCoreType(aInstance).Get<Mle::Mle>().GetRole());
 }
 
 const char *otThreadDeviceRoleToString(otDeviceRole aRole) { return Mle::RoleToString(MapEnum(aRole)); }
@@ -322,29 +316,26 @@ otError otThreadGetLeaderData(otInstance *aInstance, otLeaderData *aLeaderData)
 
     AssertPointerIsNotNull(aLeaderData);
 
-    VerifyOrExit(AsCoreType(aInstance).Get<Mle::MleRouter>().IsAttached(), error = kErrorDetached);
-    *aLeaderData = AsCoreType(aInstance).Get<Mle::MleRouter>().GetLeaderData();
+    VerifyOrExit(AsCoreType(aInstance).Get<Mle::Mle>().IsAttached(), error = kErrorDetached);
+    *aLeaderData = AsCoreType(aInstance).Get<Mle::Mle>().GetLeaderData();
 
 exit:
     return error;
 }
 
-uint8_t otThreadGetLeaderRouterId(otInstance *aInstance)
-{
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetLeaderId();
-}
+uint8_t otThreadGetLeaderRouterId(otInstance *aInstance) { return AsCoreType(aInstance).Get<Mle::Mle>().GetLeaderId(); }
 
 uint8_t otThreadGetLeaderWeight(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetLeaderData().GetWeighting();
+    return AsCoreType(aInstance).Get<Mle::Mle>().GetLeaderData().GetWeighting();
 }
 
 uint32_t otThreadGetPartitionId(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetLeaderData().GetPartitionId();
+    return AsCoreType(aInstance).Get<Mle::Mle>().GetLeaderData().GetPartitionId();
 }
 
-uint16_t otThreadGetRloc16(otInstance *aInstance) { return AsCoreType(aInstance).Get<Mle::MleRouter>().GetRloc16(); }
+uint16_t otThreadGetRloc16(otInstance *aInstance) { return AsCoreType(aInstance).Get<Mle::Mle>().GetRloc16(); }
 
 otError otThreadGetParentInfo(otInstance *aInstance, otRouterInfo *aParentInfo)
 {
@@ -357,7 +348,7 @@ otError otThreadGetParentAverageRssi(otInstance *aInstance, int8_t *aParentRssi)
 
     AssertPointerIsNotNull(aParentRssi);
 
-    *aParentRssi = AsCoreType(aInstance).Get<Mle::MleRouter>().GetParent().GetLinkInfo().GetAverageRss();
+    *aParentRssi = AsCoreType(aInstance).Get<Mle::Mle>().GetParent().GetLinkInfo().GetAverageRss();
 
     VerifyOrExit(*aParentRssi != Radio::kInvalidRssi, error = kErrorFailed);
 
@@ -371,7 +362,7 @@ otError otThreadGetParentLastRssi(otInstance *aInstance, int8_t *aLastRssi)
 
     AssertPointerIsNotNull(aLastRssi);
 
-    *aLastRssi = AsCoreType(aInstance).Get<Mle::MleRouter>().GetParent().GetLinkInfo().GetLastRss();
+    *aLastRssi = AsCoreType(aInstance).Get<Mle::Mle>().GetParent().GetLinkInfo().GetLastRss();
 
     VerifyOrExit(*aLastRssi != Radio::kInvalidRssi, error = kErrorFailed);
 
@@ -390,11 +381,11 @@ otError otThreadSetEnabled(otInstance *aInstance, bool aEnabled)
 
     if (aEnabled)
     {
-        error = AsCoreType(aInstance).Get<Mle::MleRouter>().Start();
+        error = AsCoreType(aInstance).Get<Mle::Mle>().Start();
     }
     else
     {
-        AsCoreType(aInstance).Get<Mle::MleRouter>().Stop();
+        AsCoreType(aInstance).Get<Mle::Mle>().Stop();
     }
 
     return error;
@@ -407,7 +398,7 @@ bool otThreadIsSingleton(otInstance *aInstance)
     bool isSingleton = false;
 
 #if OPENTHREAD_FTD
-    isSingleton = AsCoreType(aInstance).Get<Mle::MleRouter>().IsSingleton();
+    isSingleton = AsCoreType(aInstance).Get<Mle::Mle>().IsSingleton();
 #else
     OT_UNUSED_VARIABLE(aInstance);
 #endif
@@ -470,24 +461,22 @@ void otThreadResetTimeInQueueStat(otInstance *aInstance)
 
 const otMleCounters *otThreadGetMleCounters(otInstance *aInstance)
 {
-    return &AsCoreType(aInstance).Get<Mle::MleRouter>().GetCounters();
+    return &AsCoreType(aInstance).Get<Mle::Mle>().GetCounters();
 }
 
-void otThreadResetMleCounters(otInstance *aInstance) { AsCoreType(aInstance).Get<Mle::MleRouter>().ResetCounters(); }
+void otThreadResetMleCounters(otInstance *aInstance) { AsCoreType(aInstance).Get<Mle::Mle>().ResetCounters(); }
 
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
 uint32_t otThreadGetCurrentAttachDuration(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetCurrentAttachDuration();
+    return AsCoreType(aInstance).Get<Mle::Mle>().GetCurrentAttachDuration();
 }
-#endif
 
 #if OPENTHREAD_CONFIG_MLE_PARENT_RESPONSE_CALLBACK_API_ENABLE
 void otThreadRegisterParentResponseCallback(otInstance                    *aInstance,
                                             otThreadParentResponseCallback aCallback,
                                             void                          *aContext)
 {
-    AsCoreType(aInstance).Get<Mle::MleRouter>().RegisterParentResponseStatsCallback(aCallback, aContext);
+    AsCoreType(aInstance).Get<Mle::Mle>().RegisterParentResponseStatsCallback(aCallback, aContext);
 }
 #endif
 
@@ -508,7 +497,7 @@ bool otThreadIsAnycastLocateInProgress(otInstance *aInstance)
 
 otError otThreadDetachGracefully(otInstance *aInstance, otDetachGracefullyCallback aCallback, void *aContext)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().DetachGracefully(aCallback, aContext);
+    return AsCoreType(aInstance).Get<Mle::Mle>().DetachGracefully(aCallback, aContext);
 }
 
 #if OPENTHREAD_CONFIG_DYNAMIC_STORE_FRAME_AHEAD_COUNTER_ENABLE
diff --git a/src/core/api/thread_ftd_api.cpp b/src/core/api/thread_ftd_api.cpp
index f02cd70b5..4b758f6d5 100644
--- a/src/core/api/thread_ftd_api.cpp
+++ b/src/core/api/thread_ftd_api.cpp
@@ -51,62 +51,62 @@ otError otThreadSetMaxAllowedChildren(otInstance *aInstance, uint16_t aMaxChildr
 
 uint8_t otThreadGetMaxChildIpAddresses(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetMaxChildIpAddresses();
+    return AsCoreType(aInstance).Get<Mle::Mle>().GetMaxChildIpAddresses();
 }
 
 #if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
 otError otThreadSetMaxChildIpAddresses(otInstance *aInstance, uint8_t aMaxIpAddresses)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().SetMaxChildIpAddresses(aMaxIpAddresses);
+    return AsCoreType(aInstance).Get<Mle::Mle>().SetMaxChildIpAddresses(aMaxIpAddresses);
 }
 #endif
 
 bool otThreadIsRouterEligible(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().IsRouterEligible();
+    return AsCoreType(aInstance).Get<Mle::Mle>().IsRouterEligible();
 }
 
 otError otThreadSetRouterEligible(otInstance *aInstance, bool aEligible)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().SetRouterEligible(aEligible);
+    return AsCoreType(aInstance).Get<Mle::Mle>().SetRouterEligible(aEligible);
 }
 
 otError otThreadSetPreferredRouterId(otInstance *aInstance, uint8_t aRouterId)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().SetPreferredRouterId(aRouterId);
+    return AsCoreType(aInstance).Get<Mle::Mle>().SetPreferredRouterId(aRouterId);
 }
 
 #if OPENTHREAD_CONFIG_MLE_DEVICE_PROPERTY_LEADER_WEIGHT_ENABLE
 const otDeviceProperties *otThreadGetDeviceProperties(otInstance *aInstance)
 {
-    return &AsCoreType(aInstance).Get<Mle::MleRouter>().GetDeviceProperties();
+    return &AsCoreType(aInstance).Get<Mle::Mle>().GetDeviceProperties();
 }
 
 void otThreadSetDeviceProperties(otInstance *aInstance, const otDeviceProperties *aDeviceProperties)
 {
-    AsCoreType(aInstance).Get<Mle::MleRouter>().SetDeviceProperties(AsCoreType(aDeviceProperties));
+    AsCoreType(aInstance).Get<Mle::Mle>().SetDeviceProperties(AsCoreType(aDeviceProperties));
 }
 #endif
 
 uint8_t otThreadGetLocalLeaderWeight(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetLeaderWeight();
+    return AsCoreType(aInstance).Get<Mle::Mle>().GetLeaderWeight();
 }
 
 void otThreadSetLocalLeaderWeight(otInstance *aInstance, uint8_t aWeight)
 {
-    AsCoreType(aInstance).Get<Mle::MleRouter>().SetLeaderWeight(aWeight);
+    AsCoreType(aInstance).Get<Mle::Mle>().SetLeaderWeight(aWeight);
 }
 
 #if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
 uint32_t otThreadGetPreferredLeaderPartitionId(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetPreferredLeaderPartitionId();
+    return AsCoreType(aInstance).Get<Mle::Mle>().GetPreferredLeaderPartitionId();
 }
 
 void otThreadSetPreferredLeaderPartitionId(otInstance *aInstance, uint32_t aPartitionId)
 {
-    AsCoreType(aInstance).Get<Mle::MleRouter>().SetPreferredLeaderPartitionId(aPartitionId);
+    AsCoreType(aInstance).Get<Mle::Mle>().SetPreferredLeaderPartitionId(aPartitionId);
 }
 #endif
 
@@ -134,32 +134,32 @@ void otThreadSetContextIdReuseDelay(otInstance *aInstance, uint32_t aDelay)
 
 uint8_t otThreadGetNetworkIdTimeout(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetNetworkIdTimeout();
+    return AsCoreType(aInstance).Get<Mle::Mle>().GetNetworkIdTimeout();
 }
 
 void otThreadSetNetworkIdTimeout(otInstance *aInstance, uint8_t aTimeout)
 {
-    AsCoreType(aInstance).Get<Mle::MleRouter>().SetNetworkIdTimeout(aTimeout);
+    AsCoreType(aInstance).Get<Mle::Mle>().SetNetworkIdTimeout(aTimeout);
 }
 
 uint8_t otThreadGetRouterUpgradeThreshold(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetRouterUpgradeThreshold();
+    return AsCoreType(aInstance).Get<Mle::Mle>().GetRouterUpgradeThreshold();
 }
 
 void otThreadSetRouterUpgradeThreshold(otInstance *aInstance, uint8_t aThreshold)
 {
-    AsCoreType(aInstance).Get<Mle::MleRouter>().SetRouterUpgradeThreshold(aThreshold);
+    AsCoreType(aInstance).Get<Mle::Mle>().SetRouterUpgradeThreshold(aThreshold);
 }
 
 uint8_t otThreadGetChildRouterLinks(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetChildRouterLinks();
+    return AsCoreType(aInstance).Get<Mle::Mle>().GetChildRouterLinks();
 }
 
 otError otThreadSetChildRouterLinks(otInstance *aInstance, uint8_t aChildRouterLinks)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().SetChildRouterLinks(aChildRouterLinks);
+    return AsCoreType(aInstance).Get<Mle::Mle>().SetChildRouterLinks(aChildRouterLinks);
 }
 
 otError otThreadReleaseRouterId(otInstance *aInstance, uint8_t aRouterId)
@@ -176,32 +176,32 @@ exit:
 
 otError otThreadBecomeRouter(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().BecomeRouter(ThreadStatusTlv::kHaveChildIdRequest);
+    return AsCoreType(aInstance).Get<Mle::Mle>().BecomeRouter(ThreadStatusTlv::kHaveChildIdRequest);
 }
 
 otError otThreadBecomeLeader(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().BecomeLeader(/* aCheckWeight */ true);
+    return AsCoreType(aInstance).Get<Mle::Mle>().BecomeLeader(/* aCheckWeight */ true);
 }
 
 uint8_t otThreadGetRouterDowngradeThreshold(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetRouterDowngradeThreshold();
+    return AsCoreType(aInstance).Get<Mle::Mle>().GetRouterDowngradeThreshold();
 }
 
 void otThreadSetRouterDowngradeThreshold(otInstance *aInstance, uint8_t aThreshold)
 {
-    AsCoreType(aInstance).Get<Mle::MleRouter>().SetRouterDowngradeThreshold(aThreshold);
+    AsCoreType(aInstance).Get<Mle::Mle>().SetRouterDowngradeThreshold(aThreshold);
 }
 
 uint8_t otThreadGetRouterSelectionJitter(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetRouterSelectionJitter();
+    return AsCoreType(aInstance).Get<Mle::Mle>().GetRouterSelectionJitter();
 }
 
 void otThreadSetRouterSelectionJitter(otInstance *aInstance, uint8_t aRouterJitter)
 {
-    AsCoreType(aInstance).Get<Mle::MleRouter>().SetRouterSelectionJitter(aRouterJitter);
+    AsCoreType(aInstance).Get<Mle::Mle>().SetRouterSelectionJitter(aRouterJitter);
 }
 
 otError otThreadGetChildInfoById(otInstance *aInstance, uint16_t aChildId, otChildInfo *aChildInfo)
@@ -260,7 +260,7 @@ otError otThreadGetNextCacheEntry(otInstance *aInstance, otCacheEntryInfo *aEntr
 #if OPENTHREAD_CONFIG_MLE_STEERING_DATA_SET_OOB_ENABLE
 void otThreadSetSteeringData(otInstance *aInstance, const otExtAddress *aExtAddress)
 {
-    AsCoreType(aInstance).Get<Mle::MleRouter>().SetSteeringData(AsCoreTypePtr(aExtAddress));
+    AsCoreType(aInstance).Get<Mle::Mle>().SetSteeringData(AsCoreTypePtr(aExtAddress));
 }
 #endif
 
@@ -277,7 +277,7 @@ otError otThreadSetPskc(otInstance *aInstance, const otPskc *aPskc)
 {
     Error error = kErrorNone;
 
-    VerifyOrExit(AsCoreType(aInstance).Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(AsCoreType(aInstance).Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
 
     AsCoreType(aInstance).Get<KeyManager>().SetPskc(AsCoreType(aPskc));
     AsCoreType(aInstance).Get<MeshCoP::ActiveDatasetManager>().Clear();
@@ -294,7 +294,7 @@ otError otThreadSetPskcRef(otInstance *aInstance, otPskcRef aKeyRef)
     Instance &instance = AsCoreType(aInstance);
 
     VerifyOrExit(aKeyRef != 0, error = kErrorInvalidArgs);
-    VerifyOrExit(instance.Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(instance.Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
 
     instance.Get<KeyManager>().SetPskcRef(aKeyRef);
     instance.Get<MeshCoP::ActiveDatasetManager>().Clear();
@@ -307,12 +307,12 @@ exit:
 
 int8_t otThreadGetParentPriority(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetAssignParentPriority();
+    return AsCoreType(aInstance).Get<Mle::Mle>().GetAssignParentPriority();
 }
 
 otError otThreadSetParentPriority(otInstance *aInstance, int8_t aParentPriority)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().SetAssignParentPriority(aParentPriority);
+    return AsCoreType(aInstance).Get<Mle::Mle>().SetAssignParentPriority(aParentPriority);
 }
 
 void otThreadRegisterNeighborTableCallback(otInstance *aInstance, otNeighborTableCallback aCallback)
@@ -324,7 +324,7 @@ void otThreadSetDiscoveryRequestCallback(otInstance                      *aInsta
                                          otThreadDiscoveryRequestCallback aCallback,
                                          void                            *aContext)
 {
-    AsCoreType(aInstance).Get<Mle::MleRouter>().SetDiscoveryRequestCallback(aCallback, aContext);
+    AsCoreType(aInstance).Get<Mle::Mle>().SetDiscoveryRequestCallback(aCallback, aContext);
 }
 
 #if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
@@ -351,12 +351,12 @@ otError otThreadSendProactiveBackboneNotification(otInstance               *aIns
 
 void otThreadSetCcmEnabled(otInstance *aInstance, bool aEnabled)
 {
-    AsCoreType(aInstance).Get<Mle::MleRouter>().SetCcmEnabled(aEnabled);
+    AsCoreType(aInstance).Get<Mle::Mle>().SetCcmEnabled(aEnabled);
 }
 
 void otThreadSetThreadVersionCheckEnabled(otInstance *aInstance, bool aEnabled)
 {
-    AsCoreType(aInstance).Get<Mle::MleRouter>().SetThreadVersionCheckEnabled(aEnabled);
+    AsCoreType(aInstance).Get<Mle::Mle>().SetThreadVersionCheckEnabled(aEnabled);
 }
 
 void otThreadSetTmfOriginFilterEnabled(otInstance *aInstance, bool aEnabled)
@@ -384,7 +384,7 @@ otError otThreadSetRouterIdRange(otInstance *aInstance, uint8_t aMinRouterId, ui
 
 uint32_t otThreadGetAdvertisementTrickleIntervalMax(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Mle::MleRouter>().GetAdvertisementTrickleIntervalMax();
+    return AsCoreType(aInstance).Get<Mle::Mle>().GetAdvertisementTrickleIntervalMax();
 }
 
 #endif // OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
diff --git a/src/core/api/trel_api.cpp b/src/core/api/trel_api.cpp
index 35ad34b44..779097b25 100644
--- a/src/core/api/trel_api.cpp
+++ b/src/core/api/trel_api.cpp
@@ -50,17 +50,17 @@ bool otTrelIsEnabled(otInstance *aInstance) { return AsCoreType(aInstance).Get<T
 
 void otTrelInitPeerIterator(otInstance *aInstance, otTrelPeerIterator *aIterator)
 {
-    AsCoreType(aInstance).Get<Trel::Interface>().InitIterator(*aIterator);
+    AsCoreType(aInstance).Get<Trel::PeerTable>().InitIterator(*aIterator);
 }
 
 const otTrelPeer *otTrelGetNextPeer(otInstance *aInstance, otTrelPeerIterator *aIterator)
 {
-    return AsCoreType(aInstance).Get<Trel::Interface>().GetNextPeer(*aIterator);
+    return AsCoreType(aInstance).Get<Trel::PeerTable>().GetNextPeer(*aIterator);
 }
 
 uint16_t otTrelGetNumberOfPeers(otInstance *aInstance)
 {
-    return AsCoreType(aInstance).Get<Trel::Interface>().GetNumberOfPeers();
+    return AsCoreType(aInstance).Get<Trel::PeerTable>().GetNumberOfPeers();
 }
 
 void otTrelSetFilterEnabled(otInstance *aInstance, bool aEnable)
diff --git a/src/core/api/udp_api.cpp b/src/core/api/udp_api.cpp
index d6096ad11..dde53dc76 100644
--- a/src/core/api/udp_api.cpp
+++ b/src/core/api/udp_api.cpp
@@ -97,7 +97,7 @@ void otUdpForwardReceive(otInstance         *aInstance,
 {
     Ip6::MessageInfo messageInfo;
 
-    messageInfo.SetSockAddr(AsCoreType(aInstance).Get<Mle::MleRouter>().GetMeshLocalRloc());
+    messageInfo.SetSockAddr(AsCoreType(aInstance).Get<Mle::Mle>().GetMeshLocalRloc());
     messageInfo.SetSockPort(aSockPort);
     messageInfo.SetPeerAddr(AsCoreType(aPeerAddr));
     messageInfo.SetPeerPort(aPeerPort);
diff --git a/src/core/backbone_router/bbr_local.cpp b/src/core/backbone_router/bbr_local.cpp
index 2f5e20f12..84b18aefa 100644
--- a/src/core/backbone_router/bbr_local.cpp
+++ b/src/core/backbone_router/bbr_local.cpp
@@ -176,7 +176,7 @@ Error Local::AddService(RegisterMode aMode)
     {
     case kDecideBasedOnState:
         VerifyOrExit(!Get<BackboneRouter::Leader>().HasPrimary() ||
-                     Get<BackboneRouter::Leader>().GetServer16() == Get<Mle::MleRouter>().GetRloc16());
+                     Get<BackboneRouter::Leader>().GetServer16() == Get<Mle::Mle>().GetRloc16());
         break;
     case kForceRegistration:
         break;
@@ -213,7 +213,7 @@ void Local::SetState(State aState)
     {
     case kStateDisabled:
         // Update All Network Backbone Routers Multicast Address for both Secondary and Primary state.
-        mAllNetworkBackboneRouters.SetMulticastNetworkPrefix(Get<Mle::MleRouter>().GetMeshLocalPrefix());
+        mAllNetworkBackboneRouters.SetMulticastNetworkPrefix(Get<Mle::Mle>().GetMeshLocalPrefix());
         break;
     case kStateSecondary:
         break;
@@ -225,7 +225,7 @@ void Local::SetState(State aState)
     if (aState == kStatePrimary)
     {
         // Add Primary Backbone Router ALOC for Primary Backbone Router.
-        mBbrPrimaryAloc.GetAddress().SetPrefix(Get<Mle::MleRouter>().GetMeshLocalPrefix());
+        mBbrPrimaryAloc.GetAddress().SetPrefix(Get<Mle::Mle>().GetMeshLocalPrefix());
         Get<ThreadNetif>().AddUnicastAddress(mBbrPrimaryAloc);
     }
 
@@ -241,14 +241,14 @@ void Local::HandleBackboneRouterPrimaryUpdate(Leader::State aState, const Config
 {
     OT_UNUSED_VARIABLE(aState);
 
-    VerifyOrExit(IsEnabled() && Get<Mle::MleRouter>().IsAttached());
+    VerifyOrExit(IsEnabled() && Get<Mle::Mle>().IsAttached());
 
     // Wait some jitter before trying to Register.
     if (aConfig.mServer16 == Mle::kInvalidRloc16)
     {
         mRegistrationTimeout = 1;
 
-        if (!Get<Mle::MleRouter>().IsLeader())
+        if (!Get<Mle::Mle>().IsLeader())
         {
             mRegistrationTimeout +=
                 Random::NonCrypto::GetUint16InRange(0, static_cast<uint16_t>(mRegistrationJitter) + 1);
@@ -256,7 +256,7 @@ void Local::HandleBackboneRouterPrimaryUpdate(Leader::State aState, const Config
 
         Get<TimeTicker>().RegisterReceiver(TimeTicker::kBbrLocal);
     }
-    else if (aConfig.mServer16 != Get<Mle::MleRouter>().GetRloc16())
+    else if (aConfig.mServer16 != Get<Mle::Mle>().GetRloc16())
     {
         Reset();
     }
@@ -285,7 +285,7 @@ void Local::HandleTimeTick(void)
     // Delay registration while router role transition is pending
     // (i.e., device may soon switch from REED to router role).
 
-    VerifyOrExit(!Get<Mle::MleRouter>().IsRouterRoleTransitionPending());
+    VerifyOrExit(!Get<Mle::Mle>().IsRouterRoleTransitionPending());
 
     if (mRegistrationTimeout > 0)
     {
@@ -362,7 +362,7 @@ void Local::ApplyNewMeshLocalPrefix(void)
     VerifyOrExit(IsEnabled());
 
     Get<BackboneTmfAgent>().UnsubscribeMulticast(mAllNetworkBackboneRouters);
-    mAllNetworkBackboneRouters.SetMulticastNetworkPrefix(Get<Mle::MleRouter>().GetMeshLocalPrefix());
+    mAllNetworkBackboneRouters.SetMulticastNetworkPrefix(Get<Mle::Mle>().GetMeshLocalPrefix());
     Get<BackboneTmfAgent>().SubscribeMulticast(mAllNetworkBackboneRouters);
 
 exit:
diff --git a/src/core/backbone_router/bbr_manager.cpp b/src/core/backbone_router/bbr_manager.cpp
index 5c2a9e24a..859c42934 100644
--- a/src/core/backbone_router/bbr_manager.cpp
+++ b/src/core/backbone_router/bbr_manager.cpp
@@ -495,7 +495,7 @@ bool Manager::ShouldForwardDuaToBackbone(const Ip6::Address &aAddress)
     // Do not forward to Backbone if the DUA belongs to a MTD Child (which may have failed in DUA registration)
     VerifyOrExit(Get<NeighborTable>().FindNeighbor(aAddress) == nullptr);
     // Forward to Backbone only if the DUA is resolved to the PBBR's RLOC16
-    VerifyOrExit(Get<AddressResolver>().LookUp(aAddress) == Get<Mle::MleRouter>().GetRloc16());
+    VerifyOrExit(Get<AddressResolver>().LookUp(aAddress) == Get<Mle::Mle>().GetRloc16());
 
     forwardToBackbone = true;
 
@@ -688,7 +688,7 @@ void Manager::HandleDadBackboneAnswer(const Ip6::Address &aDua, const Ip6::Inter
     {
         Ip6::Address dest;
 
-        dest.SetToRoutingLocator(Get<Mle::MleRouter>().GetMeshLocalPrefix(), ndProxy->GetRloc16());
+        dest.SetToRoutingLocator(Get<Mle::Mle>().GetMeshLocalPrefix(), ndProxy->GetRloc16());
         Get<AddressResolver>().SendAddressError(aDua, aMeshLocalIid, &dest);
     }
 
@@ -706,7 +706,7 @@ void Manager::HandleExtendedBackboneAnswer(const Ip6::Address             &aDua,
 {
     Ip6::Address dest;
 
-    dest.SetToRoutingLocator(Get<Mle::MleRouter>().GetMeshLocalPrefix(), aSrcRloc16);
+    dest.SetToRoutingLocator(Get<Mle::Mle>().GetMeshLocalPrefix(), aSrcRloc16);
     Get<AddressResolver>().SendAddressQueryResponse(aDua, aMeshLocalIid, &aTimeSinceLastTransaction, dest);
 
     LogInfo("HandleExtendedBackboneAnswer: target=%s, mliid=%s, LTT=%lus, rloc16=%04x", aDua.ToString().AsCString(),
diff --git a/src/core/border_router/routing_manager.cpp b/src/core/border_router/routing_manager.cpp
index 5b80aec20..7797082f7 100644
--- a/src/core/border_router/routing_manager.cpp
+++ b/src/core/border_router/routing_manager.cpp
@@ -59,6 +59,9 @@ RoutingManager::RoutingManager(Instance &aInstance)
     , mOnLinkPrefixManager(aInstance)
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_TRACK_PEER_BR_INFO_ENABLE
     , mNetDataPeerBrTracker(aInstance)
+#endif
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+    , mMultiAilDetector(aInstance)
 #endif
     , mRxRaTracker(aInstance)
     , mRoutePublisher(aInstance)
@@ -281,7 +284,7 @@ exit:
 
 void RoutingManager::EvaluateState(void)
 {
-    if (mIsEnabled && Get<Mle::MleRouter>().IsAttached() && mInfraIf.IsRunning())
+    if (mIsEnabled && Get<Mle::Mle>().IsAttached() && mInfraIf.IsRunning())
     {
         Start();
     }
@@ -308,6 +311,9 @@ void RoutingManager::Start(void)
 #endif
 #if OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE
         mNat64PrefixManager.Start();
+#endif
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+        mMultiAilDetector.Start();
 #endif
     }
 }
@@ -324,6 +330,9 @@ void RoutingManager::Stop(void)
 #if OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE
     mNat64PrefixManager.Stop();
 #endif
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+    mMultiAilDetector.Stop();
+#endif
 
     SendRouterAdvertisement(kInvalidateAllPrevPrefixes);
 
@@ -494,8 +503,7 @@ bool RoutingManager::IsInitialPolicyEvaluationDone(void) const
     // the emitted Router Advert message on infrastructure side
     // and published in the Thread Network Data.
 
-    return mIsRunning && !mOmrPrefixManager.GetFavoredPrefix().IsEmpty() &&
-           mOnLinkPrefixManager.IsInitalEvaluationDone();
+    return mIsRunning && mOmrPrefixManager.IsInitalEvaluationDone() && mOnLinkPrefixManager.IsInitalEvaluationDone();
 }
 
 void RoutingManager::ScheduleRoutingPolicyEvaluation(ScheduleMode aMode)
@@ -763,6 +771,9 @@ void RoutingManager::HandleRaPrefixTableChanged(void)
 
     mOnLinkPrefixManager.HandleRaPrefixTableChanged();
     mRoutePublisher.Evaluate();
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+    mMultiAilDetector.Evaluate();
+#endif
 
 exit:
     return;
@@ -885,6 +896,11 @@ void RoutingManager::LogRouteInfoOption(const Ip6::Prefix &aPrefix, uint32_t aLi
             RoutePreferenceToString(aPreference));
 }
 
+void RoutingManager::LogRecursiveDnsServerOption(const Ip6::Address &aAddress, uint32_t aLifetime)
+{
+    LogInfo("- RDNSS %s (lifetime:%lu)", aAddress.ToString().AsCString(), ToUlong(aLifetime));
+}
+
 const char *RoutingManager::RouterAdvOriginToString(RouterAdvOrigin aRaOrigin)
 {
     static const char *const kOriginStrings[] = {
@@ -909,6 +925,7 @@ const char *RoutingManager::RouterAdvOriginToString(RouterAdvOrigin aRaOrigin)
 void RoutingManager::LogRaHeader(const RouterAdvert::Header &) {}
 void RoutingManager::LogPrefixInfoOption(const Ip6::Prefix &, uint32_t, uint32_t) {}
 void RoutingManager::LogRouteInfoOption(const Ip6::Prefix &, uint32_t, RoutePreference) {}
+void RoutingManager::LogRecursiveDnsServerOption(const Ip6::Address &, uint32_t) {}
 
 #endif // OT_SHOULD_LOG_AT(OT_LOG_LEVEL_INFO)
 
@@ -1046,10 +1063,33 @@ void RoutingManager::RoutePrefix::CopyInfoTo(PrefixTableEntry &aEntry, TimeMilli
     aEntry.mRoutePreference     = static_cast<otRoutePreference>(GetRoutePreference());
 }
 
+//---------------------------------------------------------------------------------------------------------------------
+// RdnssAddress
+
+void RoutingManager::RdnssAddress::SetFrom(const RecursiveDnsServerOption &aRdnss, uint8_t aAddressIndex)
+{
+    mAddress        = aRdnss.GetAddressAt(aAddressIndex);
+    mLifetime       = aRdnss.GetLifetime();
+    mLastUpdateTime = TimerMilli::GetNow();
+}
+
+TimeMilli RoutingManager::RdnssAddress::GetExpireTime(void) const
+{
+    return RoutingManager::CalculateExpirationTime(mLastUpdateTime, mLifetime);
+}
+
+void RoutingManager::RdnssAddress::CopyInfoTo(RdnssAddrEntry &aEntry, TimeMilli aNow) const
+{
+    aEntry.mAddress             = GetAddress();
+    aEntry.mMsecSinceLastUpdate = aNow - GetLastUpdateTime();
+    aEntry.mLifetime            = GetLifetime();
+}
+
 //---------------------------------------------------------------------------------------------------------------------
 // NetDataPeerBrTracker
 
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_TRACK_PEER_BR_INFO_ENABLE
+
 RoutingManager::NetDataPeerBrTracker::NetDataPeerBrTracker(Instance &aInstance)
     : InstanceLocator(aInstance)
 {
@@ -1057,7 +1097,7 @@ RoutingManager::NetDataPeerBrTracker::NetDataPeerBrTracker(Instance &aInstance)
 
 uint16_t RoutingManager::NetDataPeerBrTracker::CountPeerBrs(uint32_t &aMinAge) const
 {
-    uint32_t uptime = Uptime::MsecToSec(Get<Uptime>().GetUptime());
+    uint32_t uptime = Get<Uptime>().GetUptimeInSeconds();
     uint16_t count  = 0;
 
     aMinAge = NumericLimits<uint16_t>::kMax;
@@ -1120,17 +1160,102 @@ void RoutingManager::NetDataPeerBrTracker::HandleNotifierEvents(Events aEvents)
         VerifyOrExit(newEntry != nullptr, LogWarn("Failed to allocate `PeerBr` entry"));
 
         newEntry->mRloc16       = rloc16;
-        newEntry->mDiscoverTime = Uptime::MsecToSec(Get<Uptime>().GetUptime());
+        newEntry->mDiscoverTime = Get<Uptime>().GetUptimeInSeconds();
 
         mPeerBrs.Push(*newEntry);
     }
 
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+    Get<RoutingManager>().mMultiAilDetector.Evaluate();
+#endif
+
 exit:
     return;
 }
 
 #endif // OPENTHREAD_CONFIG_BORDER_ROUTING_TRACK_PEER_BR_INFO_ENABLE
 
+//---------------------------------------------------------------------------------------------------------------------
+// MultiAilDetector
+
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+
+RoutingManager::MultiAilDetector::MultiAilDetector(Instance &aInstance)
+    : InstanceLocator(aInstance)
+    , mDetected(false)
+    , mNetDataPeerBrCount(0)
+    , mRxRaTrackerPeerBrCount(0)
+    , mTimer(aInstance)
+{
+}
+
+void RoutingManager::MultiAilDetector::Stop(void)
+{
+    mTimer.Stop();
+    mDetected               = false;
+    mNetDataPeerBrCount     = 0;
+    mRxRaTrackerPeerBrCount = 0;
+}
+
+void RoutingManager::MultiAilDetector::Evaluate(void)
+{
+    uint16_t count;
+    uint32_t minAge;
+    bool     detected;
+
+    VerifyOrExit(Get<RoutingManager>().IsRunning());
+
+    count = Get<RoutingManager>().mNetDataPeerBrTracker.CountPeerBrs(minAge);
+
+    if (count != mNetDataPeerBrCount)
+    {
+        LogInfo("Peer BR count from netdata: %u -> %u", mNetDataPeerBrCount, count);
+        mNetDataPeerBrCount = count;
+    }
+
+    count = Get<RoutingManager>().mRxRaTracker.CountPeerBrs();
+
+    if (count != mRxRaTrackerPeerBrCount)
+    {
+        LogInfo("Peer BR count from RaTracker: %u -> %u", mRxRaTrackerPeerBrCount, count);
+        mRxRaTrackerPeerBrCount = count;
+    }
+
+    detected = (mNetDataPeerBrCount > mRxRaTrackerPeerBrCount);
+
+    if (detected == mDetected)
+    {
+        mTimer.Stop();
+    }
+    else if (!mTimer.IsRunning())
+    {
+        mTimer.Start(detected ? kDetectTime : kClearTime);
+    }
+
+exit:
+    return;
+}
+
+void RoutingManager::MultiAilDetector::HandleTimer(void)
+{
+    if (!mDetected)
+    {
+        LogNote("BRs on multi AIL detected - BRs are likely connected to different infra-links");
+        LogInfo("More peer BRs in netdata vs from rx RAs for past %lu seconds", ToUlong(Time::MsecToSec(kDetectTime)));
+        LogInfo("NetData Peer BR count: %u, RaTracker Peer BR count: %u", mNetDataPeerBrCount, mRxRaTrackerPeerBrCount);
+        mDetected = true;
+    }
+    else
+    {
+        LogNote("BRs on multi AIL detection cleared");
+        mDetected = false;
+    }
+
+    mCallback.InvokeIfSet(mDetected);
+}
+
+#endif // OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+
 //---------------------------------------------------------------------------------------------------------------------
 // RxRaTracker
 
@@ -1139,7 +1264,9 @@ RoutingManager::RxRaTracker::RxRaTracker(Instance &aInstance)
     , mExpirationTimer(aInstance)
     , mStaleTimer(aInstance)
     , mRouterTimer(aInstance)
+    , mRdnssAddrTimer(aInstance)
     , mSignalTask(aInstance)
+    , mRdnssAddrTask(aInstance)
 {
     mLocalRaHeader.Clear();
 }
@@ -1155,6 +1282,7 @@ void RoutingManager::RxRaTracker::Stop(void)
     mExpirationTimer.Stop();
     mStaleTimer.Stop();
     mRouterTimer.Stop();
+    mRdnssAddrTimer.Stop();
 }
 
 void RoutingManager::RxRaTracker::ProcessRouterAdvertMessage(const RouterAdvert::RxMessage &aRaMessage,
@@ -1181,7 +1309,7 @@ void RoutingManager::RxRaTracker::ProcessRouterAdvertMessage(const RouterAdvert:
 
         router = newEntry;
         router->Clear();
-        router->mDiscoverTime = Uptime::MsecToSec(Get<Uptime>().GetUptime());
+        router->mDiscoverTime = Get<Uptime>().GetUptimeInSeconds();
         router->mAddress      = aSrcAddress;
 
         mRouters.Push(*newEntry);
@@ -1207,6 +1335,10 @@ void RoutingManager::RxRaTracker::ProcessRouterAdvertMessage(const RouterAdvert:
             ProcessRouteInfoOption(static_cast<const RouteInfoOption &>(option), *router);
             break;
 
+        case Option::kTypeRecursiveDnsServer:
+            ProcessRecursiveDnsServerOption(static_cast<const RecursiveDnsServerOption &>(option), *router);
+            break;
+
         default:
             break;
         }
@@ -1410,6 +1542,58 @@ exit:
     return;
 }
 
+void RoutingManager::RxRaTracker::ProcessRecursiveDnsServerOption(const RecursiveDnsServerOption &aRdnss,
+                                                                  Router                         &aRouter)
+{
+    Entry<RdnssAddress> *entry;
+    bool                 didChange = false;
+    uint32_t             lifetime;
+
+    VerifyOrExit(aRdnss.IsValid());
+
+    lifetime = aRdnss.GetLifetime();
+
+    for (uint8_t index = 0; index < aRdnss.GetNumAddresses(); index++)
+    {
+        const Ip6::Address &address = aRdnss.GetAddressAt(index);
+
+        LogRecursiveDnsServerOption(address, lifetime);
+
+        if (lifetime == 0)
+        {
+            didChange |= (aRouter.mRdnssAddresses.RemoveAndFreeAllMatching(address));
+            continue;
+        }
+
+        entry = aRouter.mRdnssAddresses.FindMatching(address);
+
+        if (entry != nullptr)
+        {
+            entry->SetFrom(aRdnss, index);
+        }
+        else
+        {
+            entry = AllocateEntry<RdnssAddress>();
+
+            if (entry == nullptr)
+            {
+                LogWarn("Discovered too many entries, ignore RDNSS address %s", address.ToString().AsCString());
+                ExitNow();
+            }
+
+            entry->SetFrom(aRdnss, index);
+            aRouter.mRdnssAddresses.Push(*entry);
+            didChange = true;
+        }
+    }
+
+exit:
+    if (didChange)
+    {
+        mRdnssAddrTask.Post();
+    }
+}
+
 #if !OPENTHREAD_CONFIG_BORDER_ROUTING_USE_HEAP_ENABLE
 
 template <>
@@ -1425,18 +1609,17 @@ exit:
     return router;
 }
 
-template <class PrefixType>
-RoutingManager::RxRaTracker::Entry<PrefixType> *RoutingManager::RxRaTracker::AllocateEntry(void)
+template <class Type> RoutingManager::RxRaTracker::Entry<Type> *RoutingManager::RxRaTracker::AllocateEntry(void)
 {
-    static_assert(TypeTraits::IsSame<PrefixType, OnLinkPrefix>::kValue ||
-                      TypeTraits::IsSame<PrefixType, RoutePrefix>::kValue,
-                  "PrefixType MSUT be either RoutePrefix or OnLinkPrefix");
+    static_assert(TypeTraits::IsSame<Type, OnLinkPrefix>::kValue || TypeTraits::IsSame<Type, RoutePrefix>::kValue ||
+                      TypeTraits::IsSame<Type, RdnssAddress>::kValue,
+                  "Type MSUT be either RoutePrefix, OnLinkPrefix, or RdnssAddress");
 
-    Entry<PrefixType> *entry       = nullptr;
-    SharedEntry       *sharedEntry = mEntryPool.Allocate();
+    Entry<Type> *entry       = nullptr;
+    SharedEntry *sharedEntry = mEntryPool.Allocate();
 
     VerifyOrExit(sharedEntry != nullptr);
-    entry = &sharedEntry->GetEntry<PrefixType>();
+    entry = &sharedEntry->GetEntry<Type>();
     entry->Init(GetInstance());
 
 exit:
@@ -1447,14 +1630,15 @@ template <> void RoutingManager::RxRaTracker::Entry<RoutingManager::RxRaTracker:
 {
     mOnLinkPrefixes.Free();
     mRoutePrefixes.Free();
+    mRdnssAddresses.Free();
     Get<RoutingManager>().mRxRaTracker.mRouterPool.Free(*this);
 }
 
-template <class PrefixType> void RoutingManager::RxRaTracker::Entry<PrefixType>::Free(void)
+template <class Type> void RoutingManager::RxRaTracker::Entry<Type>::Free(void)
 {
-    static_assert(TypeTraits::IsSame<PrefixType, OnLinkPrefix>::kValue ||
-                      TypeTraits::IsSame<PrefixType, RoutePrefix>::kValue,
-                  "PrefixType MSUT be either RoutePrefix or OnLinkPrefix");
+    static_assert(TypeTraits::IsSame<Type, OnLinkPrefix>::kValue || TypeTraits::IsSame<Type, RoutePrefix>::kValue ||
+                      TypeTraits::IsSame<Type, RdnssAddress>::kValue,
+                  "Type MSUT be either RoutePrefix, OnLinkPrefix, or RdnssAddress");
 
     Get<RoutingManager>().mRxRaTracker.mEntryPool.Free(*reinterpret_cast<SharedEntry *>(this));
 }
@@ -1551,6 +1735,14 @@ void RoutingManager::RxRaTracker::RemoveOrDeprecateOldEntries(TimeMilli aTimeThr
                 entry.ClearValidLifetime();
             }
         }
+
+        for (RdnssAddress &entry : router.mRdnssAddresses)
+        {
+            if (entry.GetLastUpdateTime() <= aTimeThreshold)
+            {
+                entry.ClearLifetime();
+            }
+        }
     }
 
     if (mLocalRaHeader.IsValid() && (mLocalRaHeaderUpdateTime <= aTimeThreshold))
@@ -1568,12 +1760,29 @@ void RoutingManager::RxRaTracker::Evaluate(void)
     NextFireTime    routerTimeoutTime(now);
     NextFireTime    entryExpireTime(now);
     NextFireTime    staleTime(now);
+    NextFireTime    rdnsssAddrExpireTime(now);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Remove expired entries associated with each router
+
+    for (Router &router : mRouters)
+    {
+        ExpirationChecker expirationChecker(now);
+
+        router.mOnLinkPrefixes.RemoveAndFreeAllMatching(expirationChecker);
+        router.mRoutePrefixes.RemoveAndFreeAllMatching(expirationChecker);
+
+        if (router.mRdnssAddresses.RemoveAndFreeAllMatching(expirationChecker))
+        {
+            mRdnssAddrTask.Post();
+        }
+    }
 
     //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-    // Remove expired prefix entries in routers and then remove any
-    // router that has no prefix entries or flags.
+    // Remove any router entry that no longer has any valid on-link
+    // or route prefixes, RDNSS addresses, or other relevant flags set.
 
-    mRouters.RemoveAndFreeAllMatching(Router::EmptyChecker(now));
+    mRouters.RemoveAndFreeAllMatching(Router::EmptyChecker());
 
     //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     // Determine decision factors (favored on-link prefix, has any
@@ -1649,6 +1858,11 @@ void RoutingManager::RxRaTracker::Evaluate(void)
                 DetermineStaleTimeFor(entry, staleTime);
             }
         }
+
+        for (const RdnssAddress &entry : router.mRdnssAddresses)
+        {
+            rdnsssAddrExpireTime.UpdateIfEarlier(entry.GetExpireTime());
+        }
     }
 
     if (mLocalRaHeader.IsValid())
@@ -1666,6 +1880,7 @@ void RoutingManager::RxRaTracker::Evaluate(void)
     mRouterTimer.FireAt(routerTimeoutTime);
     mExpirationTimer.FireAt(entryExpireTime);
     mStaleTimer.FireAt(staleTime);
+    mRdnssAddrTimer.FireAt(rdnsssAddrExpireTime);
 }
 
 void RoutingManager::RxRaTracker::DetermineStaleTimeFor(const OnLinkPrefix &aPrefix, NextFireTime &aStaleTime)
@@ -1742,6 +1957,8 @@ void RoutingManager::RxRaTracker::HandleExpirationTimer(void) { Evaluate(); }
 
 void RoutingManager::RxRaTracker::HandleSignalTask(void) { Get<RoutingManager>().HandleRaPrefixTableChanged(); }
 
+void RoutingManager::RxRaTracker::HandleRdnssAddrTask(void) { mRdnssCallback.InvokeIfSet(); }
+
 void RoutingManager::RxRaTracker::ProcessNeighborAdvertMessage(const NeighborAdvertMessage &aNaMessage)
 {
     Router *router;
@@ -1800,12 +2017,19 @@ void RoutingManager::RxRaTracker::HandleRouterTimer(void)
             {
                 entry.ClearValidLifetime();
             }
+
+            for (RdnssAddress &entry : router.mRdnssAddresses)
+            {
+                entry.ClearLifetime();
+            }
         }
     }
 
     Evaluate();
 }
 
+void RoutingManager::RxRaTracker::HandleRdnssAddrTimer(void) { Evaluate(); }
+
 void RoutingManager::RxRaTracker::SendNeighborSolicitToRouter(const Router &aRouter)
 {
     InfraIf::Icmp6Packet  packet;
@@ -1893,7 +2117,7 @@ exit:
 
 void RoutingManager::RxRaTracker::InitIterator(PrefixTableIterator &aIterator) const
 {
-    static_cast<Iterator &>(aIterator).Init(mRouters.GetHead(), Uptime::MsecToSec(Get<Uptime>().GetUptime()));
+    static_cast<Iterator &>(aIterator).Init(mRouters.GetHead(), Get<Uptime>().GetUptimeInSeconds());
 }
 
 Error RoutingManager::RxRaTracker::GetNextEntry(PrefixTableIterator &aIterator, PrefixTableEntry &aEntry) const
@@ -1935,6 +2159,38 @@ exit:
     return error;
 }
 
+Error RoutingManager::RxRaTracker::GetNextRdnssAddr(PrefixTableIterator &aIterator, RdnssAddrEntry &aEntry) const
+{
+    Error     error    = kErrorNone;
+    Iterator &iterator = static_cast<Iterator &>(aIterator);
+
+    ClearAllBytes(aEntry);
+
+    SuccessOrExit(error = iterator.AdvanceToNextRdnssAddrEntry());
+
+    iterator.GetRouter()->CopyInfoTo(aEntry.mRouter, iterator.GetInitTime(), iterator.GetInitUptime());
+    iterator.GetEntry<RdnssAddress>()->CopyInfoTo(aEntry, iterator.GetInitTime());
+
+exit:
+    return error;
+}
+
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_TRACK_PEER_BR_INFO_ENABLE
+uint16_t RoutingManager::RxRaTracker::CountPeerBrs(void) const
+{
+    uint16_t count = 0;
+
+    for (const Router &router : mRouters)
+    {
+        if (!router.mIsLocalDevice && router.IsPeerBr())
+        {
+            count++;
+        }
+    }
+
+    return count;
+}
+#endif
 //---------------------------------------------------------------------------------------------------------------------
 // RxRaTracker::Iterator
 
@@ -2029,6 +2285,28 @@ exit:
     return error;
 }
 
+Error RoutingManager::RxRaTracker::Iterator::AdvanceToNextRdnssAddrEntry(void)
+{
+    Error error = kErrorNone;
+
+    VerifyOrExit(GetRouter() != nullptr, error = kErrorNotFound);
+
+    if (HasEntry())
+    {
+        VerifyOrExit(GetType() == kRdnssAddrIterator, error = kErrorInvalidArgs);
+        SetEntry(GetEntry<RdnssAddress>()->GetNext());
+    }
+
+    while (!HasEntry())
+    {
+        SuccessOrExit(error = AdvanceToNextRouter(kRdnssAddrIterator));
+        SetEntry(GetRouter()->mRdnssAddresses.GetHead());
+    }
+
+exit:
+    return error;
+}
+
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_TRACK_PEER_BR_INFO_ENABLE
 
 Error RoutingManager::RxRaTracker::Iterator::AdvanceToNextPeerBr(const PeerBr *aPeerBrsHead)
@@ -2099,26 +2377,22 @@ exit:
 
 bool RoutingManager::RxRaTracker::Router::Matches(const EmptyChecker &aChecker)
 {
-    // First removes all expired on-link or router prefixes. Then
-    // checks whether or not the router has any useful info.
+    OT_UNUSED_VARIABLE(aChecker);
 
     bool hasFlags = false;
 
-    mOnLinkPrefixes.RemoveAndFreeAllMatching(aChecker);
-    mRoutePrefixes.RemoveAndFreeAllMatching(aChecker);
-
     // Router can be removed if it does not advertise M or O flags and
-    // also does not have any advertised prefix entries (RIO/PIO). If
-    // the router already failed to respond to max NS probe attempts,
-    // we consider it as offline and therefore do not consider its
-    // flags anymore.
+    // also does not have any advertised prefix entries (RIO/PIO) or
+    // RDNSS address entries. If the router already failed to respond
+    // to max NS probe attempts, we consider it as offline and
+    // therefore do not consider its flags anymore.
 
     if (IsReachable())
     {
         hasFlags = (mManagedAddressConfigFlag || mOtherConfigFlag);
     }
 
-    return !hasFlags && mOnLinkPrefixes.IsEmpty() && mRoutePrefixes.IsEmpty();
+    return !hasFlags && mOnLinkPrefixes.IsEmpty() && mRoutePrefixes.IsEmpty() && mRdnssAddresses.IsEmpty();
 }
 
 bool RoutingManager::RxRaTracker::Router::IsPeerBr(void) const
@@ -2221,12 +2495,6 @@ bool RoutingManager::FavoredOmrPrefix::IsInfrastructureDerived(void) const
     return !IsEmpty() && (mPreference >= NetworkData::kRoutePreferenceMedium);
 }
 
-bool RoutingManager::FavoredOmrPrefix::operator==(const FavoredOmrPrefix &aOther) const
-{
-    return (mPreference == aOther.mPreference) && (mIsDomainPrefix == aOther.mIsDomainPrefix) &&
-           (mPrefix == aOther.mPrefix);
-}
-
 void RoutingManager::FavoredOmrPrefix::SetFrom(const NetworkData::OnMeshPrefixConfig &aOnMeshPrefixConfig)
 {
     mPrefix         = aOnMeshPrefixConfig.GetPrefix();
@@ -2265,6 +2533,7 @@ bool RoutingManager::FavoredOmrPrefix::IsFavoredOver(const NetworkData::OnMeshPr
 
 RoutingManager::OmrPrefixManager::OmrPrefixManager(Instance &aInstance)
     : InstanceLocator(aInstance)
+    , mConfig(kOmrConfigAuto)
     , mIsLocalAddedInNetData(false)
     , mDefaultRoute(false)
 {
@@ -2293,6 +2562,69 @@ void RoutingManager::OmrPrefixManager::Stop(void)
     ClearFavoredPrefix();
 }
 
+bool RoutingManager::OmrPrefixManager::IsInitalEvaluationDone(void) const
+{
+    // This method indicates whether or not we are done with the
+    // initial policy evaluation of the OMR prefix, i.e., either
+    // we have discovered a favored OMR  prefix (added by us or another BR)
+    // or if `OmrConfig` is set to disable OMR prefix management.
+
+    return !mFavoredPrefix.IsEmpty() || (mConfig == kOmrConfigDisabled);
+}
+
+RoutingManager::OmrConfig RoutingManager::OmrPrefixManager::GetConfig(Ip6::Prefix     *aPrefix,
+                                                                      RoutePreference *aPreference) const
+{
+    if (mConfig == kOmrConfigCustom)
+    {
+        if (aPrefix != nullptr)
+        {
+            *aPrefix = mCustomPrefix.GetPrefix();
+        }
+
+        if (aPreference != nullptr)
+        {
+            *aPreference = mCustomPrefix.GetPreference();
+        }
+    }
+
+    return mConfig;
+}
+
+Error RoutingManager::OmrPrefixManager::SetConfig(OmrConfig          aConfig,
+                                                  const Ip6::Prefix *aPrefix,
+                                                  RoutePreference    aPreference)
+{
+    Error     error = kErrorNone;
+    OmrPrefix customPrefix;
+
+    if (aConfig == kOmrConfigCustom)
+    {
+        VerifyOrExit((aPrefix != nullptr) && IsValidOmrPrefix(*aPrefix), error = kErrorInvalidArgs);
+
+        customPrefix.mPrefix     = *aPrefix;
+        customPrefix.mPreference = aPreference;
+    }
+
+    VerifyOrExit((aConfig != mConfig) || (customPrefix != mCustomPrefix));
+
+    LogInfo("OMR config: %s -> %s", OmrConfigToString(mConfig), OmrConfigToString(aConfig));
+
+    if (aConfig == kOmrConfigCustom)
+    {
+        LogInfo("OMR custom prefix set to %s (prf:%s)", customPrefix.GetPrefix().ToString().AsCString(),
+                RoutePreferenceToString(customPrefix.GetPreference()));
+    }
+
+    mConfig       = aConfig;
+    mCustomPrefix = customPrefix;
+
+    Get<RoutingManager>().ScheduleRoutingPolicyEvaluation(kImmediately);
+
+exit:
+    return error;
+}
+
 void RoutingManager::OmrPrefixManager::SetFavordPrefix(const OmrPrefix &aOmrPrefix)
 {
     FavoredOmrPrefix oldFavoredPrefix = mFavoredPrefix;
@@ -2302,7 +2634,7 @@ void RoutingManager::OmrPrefixManager::SetFavordPrefix(const OmrPrefix &aOmrPref
     if (oldFavoredPrefix != mFavoredPrefix)
     {
 #if OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE
-        Get<MeshCoP::BorderAgent>().PostNotifyMeshCoPServiceChangedTask();
+        Get<MeshCoP::BorderAgent>().HandleFavoredOmrPrefixChanged();
 #endif
         LogInfo("Favored OMR prefix: %s -> %s", FavoredToString(oldFavoredPrefix).AsCString(),
                 FavoredToString(mFavoredPrefix).AsCString());
@@ -2332,40 +2664,78 @@ void RoutingManager::OmrPrefixManager::DetermineFavoredPrefixInNetData(FavoredOm
     }
 }
 
-void RoutingManager::OmrPrefixManager::Evaluate(void)
+void RoutingManager::OmrPrefixManager::UpdateLocalPrefix(void)
 {
-    FavoredOmrPrefix favoredPrefix;
-
-    OT_ASSERT(Get<RoutingManager>().IsRunning());
-
-    DetermineFavoredPrefixInNetData(favoredPrefix);
+    // Determine the local prefix and remove any outdated previous
+    // local prefix which may have been added in the Network Data.
 
-    // Determine the local prefix and remove outdated prefix published by us.
-#if OPENTHREAD_CONFIG_BORDER_ROUTING_DHCP6_PD_ENABLE
-    if (Get<RoutingManager>().mPdPrefixManager.HasPrefix())
+    switch (mConfig)
     {
-        if (mLocalPrefix.GetPrefix() != Get<RoutingManager>().mPdPrefixManager.GetPrefix())
+    case kOmrConfigAuto:
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_DHCP6_PD_ENABLE
+        if (Get<RoutingManager>().mPdPrefixManager.HasPrefix())
+        {
+            if (mLocalPrefix.GetPrefix() != Get<RoutingManager>().mPdPrefixManager.GetPrefix())
+            {
+                RemoveLocalFromNetData();
+                mLocalPrefix.mPrefix         = Get<RoutingManager>().mPdPrefixManager.GetPrefix();
+                mLocalPrefix.mPreference     = PdPrefixManager::kPdRoutePreference;
+                mLocalPrefix.mIsDomainPrefix = false;
+                LogInfo("Setting local OMR prefix to PD prefix: %s", mLocalPrefix.GetPrefix().ToString().AsCString());
+            }
+        }
+        else
+#endif
+            if (mLocalPrefix.GetPrefix() != mGeneratedPrefix)
         {
             RemoveLocalFromNetData();
-            mLocalPrefix.mPrefix         = Get<RoutingManager>().mPdPrefixManager.GetPrefix();
-            mLocalPrefix.mPreference     = PdPrefixManager::kPdRoutePreference;
+            mLocalPrefix.mPrefix         = mGeneratedPrefix;
+            mLocalPrefix.mPreference     = RoutePreference::kRoutePreferenceLow;
             mLocalPrefix.mIsDomainPrefix = false;
-            LogInfo("Setting local OMR prefix to PD prefix: %s", mLocalPrefix.GetPrefix().ToString().AsCString());
+            LogInfo("Setting local OMR prefix to generated prefix: %s",
+                    mLocalPrefix.GetPrefix().ToString().AsCString());
         }
+
+        break;
+
+    case kOmrConfigCustom:
+        if (mLocalPrefix != mCustomPrefix)
+        {
+            RemoveLocalFromNetData();
+            mLocalPrefix = mCustomPrefix;
+            LogInfo("Setting local OMR prefix to custom prefix: %s", mLocalPrefix.GetPrefix().ToString().AsCString());
+        }
+
+        break;
+
+    case kOmrConfigDisabled:
+        if (!mLocalPrefix.IsEmpty())
+        {
+            RemoveLocalFromNetData();
+            mLocalPrefix.Clear();
+        }
+        break;
     }
-    else
-#endif
-        if (mLocalPrefix.GetPrefix() != mGeneratedPrefix)
-    {
-        RemoveLocalFromNetData();
-        mLocalPrefix.mPrefix         = mGeneratedPrefix;
-        mLocalPrefix.mPreference     = RoutePreference::kRoutePreferenceLow;
-        mLocalPrefix.mIsDomainPrefix = false;
-        LogInfo("Setting local OMR prefix to generated prefix: %s", mLocalPrefix.GetPrefix().ToString().AsCString());
-    }
+}
+
+void RoutingManager::OmrPrefixManager::Evaluate(void)
+{
+    FavoredOmrPrefix favoredPrefix;
+
+    OT_ASSERT(Get<RoutingManager>().IsRunning());
+
+    DetermineFavoredPrefixInNetData(favoredPrefix);
+
+    UpdateLocalPrefix();
 
     // Decide if we need to add or remove our local OMR prefix.
 
+    if (mLocalPrefix.IsEmpty())
+    {
+        SetFavordPrefix(favoredPrefix);
+        ExitNow();
+    }
+
     if (favoredPrefix.IsEmpty() || favoredPrefix.GetPreference() < mLocalPrefix.GetPreference())
     {
         SuccessOrExit(AddLocalToNetData());
@@ -2463,7 +2833,6 @@ void RoutingManager::OmrPrefixManager::RemoveLocalFromNetData(void)
     if (error != kErrorNone)
     {
         LogWarn("Failed to remove %s from Thread Network Data: %s", LocalToString().AsCString(), ErrorToString(error));
-        ExitNow();
     }
 
     mIsLocalAddedInNetData = false;
@@ -2526,6 +2895,25 @@ RoutingManager::OmrPrefixManager::InfoString RoutingManager::OmrPrefixManager::F
     return string;
 }
 
+const char *RoutingManager::OmrPrefixManager::OmrConfigToString(OmrConfig aConfig)
+{
+    static const char *const kConfigStrings[] = {
+        "auto",     // (0) kOmrConfigAuto
+        "custom",   // (1) kOmrConfigCustom
+        "disabled", // (2) kOmrConfigDisabled
+    };
+
+    struct EnumCheck
+    {
+        InitEnumValidatorCounter();
+        ValidateNextEnum(kOmrConfigAuto);
+        ValidateNextEnum(kOmrConfigCustom);
+        ValidateNextEnum(kOmrConfigDisabled);
+    };
+
+    return kConfigStrings[aConfig];
+}
+
 //---------------------------------------------------------------------------------------------------------------------
 // OnLinkPrefixManager
 
diff --git a/src/core/border_router/routing_manager.hpp b/src/core/border_router/routing_manager.hpp
index ea09cdd12..e5c458a69 100644
--- a/src/core/border_router/routing_manager.hpp
+++ b/src/core/border_router/routing_manager.hpp
@@ -46,14 +46,15 @@
 #error "OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE is required for OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE."
 #endif
 
-#if !OPENTHREAD_CONFIG_UPTIME_ENABLE
-#error "OPENTHREAD_CONFIG_UPTIME_ENABLE is required for OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE"
-#endif
-
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_TRACK_PEER_BR_INFO_ENABLE && !OPENTHREAD_CONFIG_BORDER_ROUTING_USE_HEAP_ENABLE
 #error "TRACK_PEER_BR_INFO_ENABLE feature requires OPENTHREAD_CONFIG_BORDER_ROUTING_USE_HEAP_ENABLE"
 #endif
 
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE && \
+    !OPENTHREAD_CONFIG_BORDER_ROUTING_TRACK_PEER_BR_INFO_ENABLE
+#error "MULTI_AIL_DETECTION_ENABLE feature requires OPENTHREAD_CONFIG_BORDER_ROUTING_TRACK_PEER_BR_INFO_ENABLE"
+#endif
+
 #include <openthread/border_routing.h>
 #include <openthread/nat64.h>
 #include <openthread/netdata.h>
@@ -109,9 +110,12 @@ public:
     typedef otBorderRoutingPrefixTableIterator    PrefixTableIterator; ///< Prefix Table Iterator.
     typedef otBorderRoutingPrefixTableEntry       PrefixTableEntry;    ///< Prefix Table Entry.
     typedef otBorderRoutingRouterEntry            RouterEntry;         ///< Router Entry.
+    typedef otBorderRoutingRdnssAddrEntry         RdnssAddrEntry;      ///< RDNSS Address Entry.
+    typedef otBorderRoutingRdnssAddrCallback      RdnssAddrCallback;   ///< RDNS Address changed callback.
     typedef otBorderRoutingPeerBorderRouterEntry  PeerBrEntry;         ///< Peer Border Router Entry.
     typedef otPdProcessedRaInfo                   PdProcessedRaInfo;   ///< Data of PdProcessedRaInfo.
     typedef otBorderRoutingRequestDhcp6PdCallback PdCallback;          ///< DHCPv6 PD callback.
+    typedef otBorderRoutingMultiAilCallback       MultiAilCallback;    ///< Multi AIL detection callback.
 
     /**
      * This constant specifies the maximum number of route prefixes that may be published by `RoutingManager`
@@ -137,6 +141,16 @@ public:
         kStateRunning       = OT_BORDER_ROUTING_STATE_RUNNING,       ///< Initialized, enabled, and running.
     };
 
+    /**
+     * Represents the admin configuration options related to the OMR prefix.
+     */
+    enum OmrConfig : uint8_t
+    {
+        kOmrConfigAuto     = OT_BORDER_ROUTING_OMR_CONFIG_AUTO,     ///< BR auto-generates the local OMR prefix.
+        kOmrConfigCustom   = OT_BORDER_ROUTING_OMR_CONFIG_CUSTOM,   ///< BR uses a given custom OMR prefix.
+        kOmrConfigDisabled = OT_BORDER_ROUTING_OMR_CONFIG_DISABLED, ///< BR does not add local/PD OMR prefix in NetData.
+    };
+
     /**
      * This enumeration represents the states of DHCPv6 PD in `RoutingManager`.
      */
@@ -211,6 +225,39 @@ public:
      */
     void RequestStop(void) { Stop(); }
 
+    /**
+     * Configures the OMR prefix handling in the Border Routing Manager.
+     *
+     * @param[in] aConfig        The desired OMR configuration.
+     * @param[in] aOmrPrefix     A pointer to the custom OMR prefix. Required only when @p aConfig is
+     *                           `kOmrConfigCustom`. Otherwise, it can be `nullptr`.
+     * @param[in] aPreference    The preference associated with the custom OMR prefix.
+     *
+     * @retval kErrorNone          The OMR configuration was successfully set to @p aConfig.
+     * @retval kErrorInvalidArgs   The provided custom OMR prefix (@p aOmrPrefix) is invalid.
+     */
+    Error SetOmrConfig(OmrConfig aConfig, const Ip6::Prefix *aOmrPrefix, RoutePreference aPreference)
+    {
+        return mOmrPrefixManager.SetConfig(aConfig, aOmrPrefix, aPreference);
+    }
+
+    /**
+     * Gets the current OMR prefix configuration mode.
+     *
+     * If the caller does not require the custom OMR prefix and preference, the @p aOmrPrefix and @p aPreference
+     * parameters can be set to `nullptr`.
+     *
+     * @param[out] aOmrPrefix     A pointer to an `otIp6Prefix` to return the custom OMR prefix, if the configuration
+     *                            is `kOmrConfigCustom`.
+     * @param[out] aPreference    A pointer to return the preference associated with the custom OMR prefix.
+     *
+     * @return The current OMR prefix configuration mode.
+     */
+    OmrConfig GetOmrConfig(Ip6::Prefix *aPrefix, RoutePreference *aPreference) const
+    {
+        return mOmrPrefixManager.GetConfig(aPrefix, aPreference);
+    }
+
     /**
      * Gets the current preference used when advertising Route Info Options (RIO) in Router Advertisement
      * messages sent over the infrastructure link.
@@ -472,6 +519,35 @@ public:
         return mRxRaTracker.GetNextRouter(aIterator, aEntry);
     }
 
+    /**
+     * Iterates over the discovered Recursive DNS Server (RDNSS) address entries.
+     *
+     * @param[in,out] aIterator    An iterator.
+     * @param[out]    aEntry       A reference to the entry to populate.
+     *
+     * @retval kErrorNone         Iterated to the next address entry, @p aEntry and @p aIterator are updated.
+     * @retval kErrorNotFound     No more entries in the table.
+     * @retval kErrorInvalidArgs  The @p aIterator is not valid (e.g. used to iterate over other entry types).
+     */
+    Error GetNextRdnssAddrEntry(PrefixTableIterator &aIterator, RdnssAddrEntry &aEntry)
+    {
+        return mRxRaTracker.GetNextRdnssAddr(aIterator, aEntry);
+    }
+
+    /**
+     * Sets the callback to be notified of changes to discovered Recursive DNS Server (RDNSS) address entries.
+     *
+     * A subsequent call to this method, replaces a previously set callback.
+     *
+     * @param[in] aCallback   The callback function pointer. Can be `nullptr` if no callback is required.
+     * @param[in] aConext     An arbitrary context information (used when invoking the callback).
+     *
+     */
+    void SetRdnssAddrCallback(RdnssAddrCallback aCallback, void *aContext)
+    {
+        mRxRaTracker.SetRdnssCallback(aCallback, aContext);
+    }
+
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_TRACK_PEER_BR_INFO_ENABLE
 
     /**
@@ -502,6 +578,37 @@ public:
 
 #endif // OPENTHREAD_CONFIG_BORDER_ROUTING_TRACK_PEER_BR_INFO_ENABLE
 
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+
+    /**
+     * Gets the current detected state regarding multiple Adjacent Infrastructure Links (AILs).
+     *
+     * It returns whether the Routing Manager currently believes that Border Routers (BRs) on the Thread mesh may be
+     * connected to different AILs.
+     *
+     * See `otBorderRoutingIsMultiAilDetected()` for more details about detection process.
+     *
+     * @retval TRUE   Has detected that BRs are likely connected to multiple AILs.
+     * @retval FALSE  Has not detected (or no longer detects) that BRs are connected to multiple AILs.
+     */
+    bool IsMultiAilDetected(void) const { return mMultiAilDetector.IsDetected(); }
+
+    /**
+     * Sets a callback function to be notified of changes in the multi-AIL detection state.
+     *
+     * Subsequent calls to this function will overwrite the previous callback setting. Using `NULL` for @p aCallback
+     * will disable the callback.
+     *
+     * @param[in] aCallback  The callback function
+     * @param[in] aContext   A pointer to application-specific context used with @p aCallback.
+     */
+    void SetMultiAilCallback(MultiAilCallback aCallback, void *aContext)
+    {
+        mMultiAilDetector.SetCallback(aCallback, aContext);
+    }
+
+#endif // OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+
 #if OPENTHREAD_CONFIG_SRP_SERVER_ENABLE
     /**
      * Determines whether to enable/disable SRP server when the auto-enable mode is changed on SRP server.
@@ -642,16 +749,17 @@ private:
     //------------------------------------------------------------------------------------------------------------------
     // Typedefs
 
-    using Option                = Ip6::Nd::Option;
-    using PrefixInfoOption      = Ip6::Nd::PrefixInfoOption;
-    using RouteInfoOption       = Ip6::Nd::RouteInfoOption;
-    using RaFlagsExtOption      = Ip6::Nd::RaFlagsExtOption;
-    using RouterAdvert          = Ip6::Nd::RouterAdvert;
-    using NeighborAdvertMessage = Ip6::Nd::NeighborAdvertMessage;
-    using TxMessage             = Ip6::Nd::TxMessage;
-    using NeighborSolicitHeader = Ip6::Nd::NeighborSolicitHeader;
-    using RouterSolicitHeader   = Ip6::Nd::RouterSolicitHeader;
-    using LinkLayerAddress      = InfraIf::LinkLayerAddress;
+    using Option                   = Ip6::Nd::Option;
+    using PrefixInfoOption         = Ip6::Nd::PrefixInfoOption;
+    using RouteInfoOption          = Ip6::Nd::RouteInfoOption;
+    using RaFlagsExtOption         = Ip6::Nd::RaFlagsExtOption;
+    using RecursiveDnsServerOption = Ip6::Nd::RecursiveDnsServerOption;
+    using RouterAdvert             = Ip6::Nd::RouterAdvert;
+    using NeighborAdvertMessage    = Ip6::Nd::NeighborAdvertMessage;
+    using TxMessage                = Ip6::Nd::TxMessage;
+    using NeighborSolicitHeader    = Ip6::Nd::NeighborSolicitHeader;
+    using RouterSolicitHeader      = Ip6::Nd::RouterSolicitHeader;
+    using LinkLayerAddress         = InfraIf::LinkLayerAddress;
 
     //------------------------------------------------------------------------------------------------------------------
     // Enumerations
@@ -680,18 +788,18 @@ private:
     //------------------------------------------------------------------------------------------------------------------
     // Nested types
 
+    struct ExpirationChecker
+    {
+        explicit ExpirationChecker(TimeMilli aNow) { mNow = aNow; }
+        TimeMilli mNow;
+    };
+
     class LifetimedPrefix
     {
         // Represents an IPv6 prefix with its valid lifetime. Used as
         // base class for `OnLinkPrefix` or `RoutePrefix`.
 
     public:
-        struct ExpirationChecker
-        {
-            explicit ExpirationChecker(TimeMilli aNow) { mNow = aNow; }
-            TimeMilli mNow;
-        };
-
         const Ip6::Prefix &GetPrefix(void) const { return mPrefix; }
         Ip6::Prefix       &GetPrefix(void) { return mPrefix; }
         const TimeMilli   &GetLastUpdateTime(void) const { return mLastUpdateTime; }
@@ -759,6 +867,28 @@ private:
 
     //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
+    class RdnssAddress
+    {
+    public:
+        void                SetFrom(const RecursiveDnsServerOption &aRdnss, uint8_t aAddressIndex);
+        const Ip6::Address &GetAddress(void) const { return mAddress; }
+        const TimeMilli    &GetLastUpdateTime(void) const { return mLastUpdateTime; }
+        uint32_t            GetLifetime(void) const { return mLifetime; }
+        TimeMilli           GetExpireTime(void) const;
+        void                ClearLifetime(void) { mLifetime = 0; }
+        void                CopyInfoTo(RdnssAddrEntry &aEntry, TimeMilli aNow) const;
+
+        bool Matches(const Ip6::Address &aAddress) const { return (mAddress == aAddress); }
+        bool Matches(const ExpirationChecker &aChecker) const { return (GetExpireTime() <= aChecker.mNow); }
+
+    private:
+        Ip6::Address mAddress;
+        uint32_t     mLifetime;
+        TimeMilli    mLastUpdateTime;
+    };
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_TRACK_PEER_BR_INFO_ENABLE
 
     class RxRaTracker;
@@ -804,10 +934,62 @@ private:
 
     //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+
+    void HandleMultiAilDetectorTimer(void) { mMultiAilDetector.HandleTimer(); }
+
+    class MultiAilDetector : public InstanceLocator
+    {
+        // Detects whether BRs may be connected to different AILs by
+        // tracking the number of peer BRs from netdata versus from
+        // `RxRaTracker`. If the netdata count exceeds the RA-tracked
+        // count for more than `kDetectTime` (10 minutes), it notifies
+        // this using the provided callback. To clear the state,
+        // `kClearTime` (1 minute) is used.
+        //
+        // This longer detection window of 10 minutes helps to avoid
+        // false positives due to transient changes. `RxRaTracker` uses
+        // 200 seconds for reachability checks of peer BRs. Stale
+        // Network Data entries are also expected to age out within a
+        // few minutes. So 10-minute detection time accommodates both.
+
+        friend class RxRaTracker;
+
+    public:
+        explicit MultiAilDetector(Instance &aInstance);
+
+        void SetCallback(MultiAilCallback aCallback, void *aContext) { mCallback.Set(aCallback, aContext); }
+        bool IsDetected(void) const { return mDetected; }
+
+        void Start(void) { Evaluate(); }
+        void Stop(void);
+        void Evaluate(void);
+        void HandleTimer(void);
+
+    private:
+        static constexpr uint32_t kDetectTime = 10 * Time::kOneMinuteInMsec;
+        static constexpr uint32_t kClearTime  = 1 * Time::kOneMinuteInMsec;
+
+        using DetectCallback = Callback<MultiAilCallback>;
+        using DetectTimer    = TimerMilliIn<RoutingManager, &RoutingManager::HandleMultiAilDetectorTimer>;
+
+        bool           mDetected;
+        uint16_t       mNetDataPeerBrCount;
+        uint16_t       mRxRaTrackerPeerBrCount;
+        DetectTimer    mTimer;
+        DetectCallback mCallback;
+    };
+
+#endif // OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
     void HandleRxRaTrackerSignalTask(void) { mRxRaTracker.HandleSignalTask(); }
+    void HandleRxRaTrackerRdnssAddrTask(void) { mRxRaTracker.HandleRdnssAddrTask(); }
     void HandleRxRaTrackerExpirationTimer(void) { mRxRaTracker.HandleExpirationTimer(); }
     void HandleRxRaTrackerStaleTimer(void) { mRxRaTracker.HandleStaleTimer(); }
     void HandleRxRaTrackerRouterTimer(void) { mRxRaTracker.HandleRouterTimer(); }
+    void HandleRxRaTrackerRdnssAddrTimer(void) { mRxRaTracker.HandleRdnssAddrTimer(); }
 
     class RxRaTracker : public InstanceLocator
     {
@@ -831,6 +1013,8 @@ private:
         void Start(void);
         void Stop(void);
 
+        void SetRdnssCallback(RdnssAddrCallback aCallback, void *aContext) { mRdnssCallback.Set(aCallback, aContext); }
+
         void ProcessRouterAdvertMessage(const RouterAdvert::RxMessage &aRaMessage,
                                         const Ip6::Address            &aSrcAddress,
                                         RouterAdvOrigin                aRaOrigin);
@@ -853,6 +1037,11 @@ private:
         void  InitIterator(PrefixTableIterator &aIterator) const;
         Error GetNextEntry(PrefixTableIterator &aIterator, PrefixTableEntry &aEntry) const;
         Error GetNextRouter(PrefixTableIterator &aIterator, RouterEntry &aEntry) const;
+        Error GetNextRdnssAddr(PrefixTableIterator &aIterator, RdnssAddrEntry &aEntry) const;
+
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_TRACK_PEER_BR_INFO_ENABLE
+        uint16_t CountPeerBrs(void) const;
+#endif
 
         // Callbacks notifying of changes
         void RemoveOrDeprecateOldEntries(TimeMilli aTimeThreshold);
@@ -861,9 +1050,11 @@ private:
 
         // Tasklet or timer callbacks
         void HandleSignalTask(void);
+        void HandleRdnssAddrTask(void);
         void HandleExpirationTimer(void);
         void HandleStaleTimer(void);
         void HandleRouterTimer(void);
+        void HandleRdnssAddrTimer(void);
 
     private:
         //-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
@@ -906,7 +1097,9 @@ private:
 
             static_assert(kMaxNsProbes < 255, "kMaxNsProbes MUST not be 255");
 
-            typedef LifetimedPrefix::ExpirationChecker EmptyChecker;
+            struct EmptyChecker
+            {
+            };
 
             bool IsReachable(void) const { return mNsProbeCount <= kMaxNsProbes; }
             bool ShouldCheckReachability(void) const;
@@ -919,6 +1112,7 @@ private:
 
             using OnLinkPrefixList = OwningList<Entry<OnLinkPrefix>>;
             using RoutePrefixList  = OwningList<Entry<RoutePrefix>>;
+            using RdnssAddressList = OwningList<Entry<RdnssAddress>>;
 
             // `mDiscoverTime` tracks the initial discovery time of
             // this router. To accommodate longer durations, the
@@ -933,6 +1127,7 @@ private:
             Ip6::Address     mAddress;
             OnLinkPrefixList mOnLinkPrefixes;
             RoutePrefixList  mRoutePrefixes;
+            RdnssAddressList mRdnssAddresses;
             uint32_t         mDiscoverTime;
             TimeMilli        mLastUpdateTime;
             TimeMilli        mTimeoutTime;
@@ -954,6 +1149,7 @@ private:
                 kUnspecified,
                 kRouterIterator,
                 kPrefixIterator,
+                kRdnssAddrIterator,
                 kPeerBrIterator,
             };
 
@@ -966,15 +1162,16 @@ private:
             void                 Init(const Entry<Router> *aRoutersHead, uint32_t aUptime);
             Error                AdvanceToNextRouter(Type aType);
             Error                AdvanceToNextEntry(void);
+            Error                AdvanceToNextRdnssAddrEntry(void);
             uint32_t             GetInitUptime(void) const { return mData0; }
             TimeMilli            GetInitTime(void) const { return TimeMilli(mData1); }
             Type                 GetType(void) const { return static_cast<Type>(mData2); }
             const Entry<Router> *GetRouter(void) const { return static_cast<const Entry<Router> *>(mPtr1); }
             EntryType            GetEntryType(void) const { return static_cast<EntryType>(mData3); }
 
-            template <class PrefixType> const Entry<PrefixType> *GetEntry(void) const
+            template <typename ObjectType> const Entry<ObjectType> *GetEntry(void) const
             {
-                return static_cast<const Entry<PrefixType> *>(mPtr2);
+                return static_cast<const Entry<ObjectType> *>(mPtr2);
             }
 
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_TRACK_PEER_BR_INFO_ENABLE
@@ -1007,11 +1204,12 @@ private:
             SharedEntry       *GetNext(void) { return mNext; }
             const SharedEntry *GetNext(void) const { return mNext; }
 
-            template <class PrefixType> Entry<PrefixType> &GetEntry(void);
+            template <class Type> Entry<Type> &GetEntry(void);
 
             SharedEntry        *mNext;
             Entry<OnLinkPrefix> mOnLinkEntry;
             Entry<RoutePrefix>  mRouteEntry;
+            Entry<RdnssAddress> mRdnssAddrEntry;
         };
 #endif
 
@@ -1039,6 +1237,7 @@ private:
         void ProcessRaHeader(const RouterAdvert::Header &aRaHeader, Router &aRouter, RouterAdvOrigin aRaOrigin);
         void ProcessPrefixInfoOption(const PrefixInfoOption &aPio, Router &aRouter);
         void ProcessRouteInfoOption(const RouteInfoOption &aRio, Router &aRouter);
+        void ProcessRecursiveDnsServerOption(const RecursiveDnsServerOption &aRdnss, Router &aRouter);
         void Evaluate(void);
         void DetermineStaleTimeFor(const OnLinkPrefix &aPrefix, NextFireTime &aStaleTime);
         void DetermineStaleTimeFor(const RoutePrefix &aPrefix, NextFireTime &aStaleTime);
@@ -1050,17 +1249,23 @@ private:
 #endif
 
         using SignalTask      = TaskletIn<RoutingManager, &RoutingManager::HandleRxRaTrackerSignalTask>;
+        using RdnssAddrTask   = TaskletIn<RoutingManager, &RoutingManager::HandleRxRaTrackerRdnssAddrTask>;
         using ExpirationTimer = TimerMilliIn<RoutingManager, &RoutingManager::HandleRxRaTrackerExpirationTimer>;
         using StaleTimer      = TimerMilliIn<RoutingManager, &RoutingManager::HandleRxRaTrackerStaleTimer>;
         using RouterTimer     = TimerMilliIn<RoutingManager, &RoutingManager::HandleRxRaTrackerRouterTimer>;
+        using RdnssAddrTimer  = TimerMilliIn<RoutingManager, &RoutingManager::HandleRxRaTrackerRdnssAddrTimer>;
         using RouterList      = OwningList<Entry<Router>>;
+        using RdnssCallback   = Callback<RdnssAddrCallback>;
 
         DecisionFactors      mDecisionFactors;
         RouterList           mRouters;
         ExpirationTimer      mExpirationTimer;
         StaleTimer           mStaleTimer;
         RouterTimer          mRouterTimer;
+        RdnssAddrTimer       mRdnssAddrTimer;
         SignalTask           mSignalTask;
+        RdnssAddrTask        mRdnssAddrTask;
+        RdnssCallback        mRdnssCallback;
         RouterAdvert::Header mLocalRaHeader;
         TimeMilli            mLocalRaHeaderUpdateTime;
 
@@ -1074,7 +1279,7 @@ private:
 
     class OmrPrefixManager;
 
-    class OmrPrefix : public Clearable<OmrPrefix>
+    class OmrPrefix : public Clearable<OmrPrefix>, public Equatable<OmrPrefix>
     {
         friend class OmrPrefixManager;
 
@@ -1094,13 +1299,12 @@ private:
 
     //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
-    class FavoredOmrPrefix : public OmrPrefix, public Unequatable<FavoredOmrPrefix>
+    class FavoredOmrPrefix : public OmrPrefix
     {
         friend class OmrPrefixManager;
 
     public:
         bool IsInfrastructureDerived(void) const;
-        bool operator==(const FavoredOmrPrefix &aOther) const;
 
     private:
         void SetFrom(const NetworkData::OnMeshPrefixConfig &aOnMeshPrefixConfig);
@@ -1118,6 +1322,9 @@ private:
         void                    Init(const Ip6::Prefix &aBrUlaPrefix);
         void                    Start(void);
         void                    Stop(void);
+        bool                    IsInitalEvaluationDone(void) const;
+        OmrConfig               GetConfig(Ip6::Prefix *aPrefix, RoutePreference *aPreference) const;
+        Error                   SetConfig(OmrConfig aConfig, const Ip6::Prefix *aPrefix, RoutePreference aPreference);
         void                    Evaluate(void);
         void                    UpdateDefaultRouteFlag(bool aDefaultRoute);
         bool                    ShouldAdvertiseLocalAsRio(void) const;
@@ -1133,13 +1340,18 @@ private:
         void       SetFavordPrefix(const OmrPrefix &aOmrPrefix);
         void       ClearFavoredPrefix(void) { SetFavordPrefix(OmrPrefix()); }
         void       DetermineFavoredPrefixInNetData(FavoredOmrPrefix &aFavoredPrefix);
+        void       UpdateLocalPrefix(void);
         Error      AddLocalToNetData(void);
         Error      AddOrUpdateLocalInNetData(void);
         void       RemoveLocalFromNetData(void);
         InfoString LocalToString(void) const;
         InfoString FavoredToString(const FavoredOmrPrefix &aFavoredPrefix) const;
 
+        static const char *OmrConfigToString(OmrConfig aConfig);
+
+        OmrConfig        mConfig;
         OmrPrefix        mLocalPrefix;
+        OmrPrefix        mCustomPrefix;
         Ip6::Prefix      mGeneratedPrefix;
         FavoredOmrPrefix mFavoredPrefix;
         bool             mIsLocalAddedInNetData;
@@ -1551,6 +1763,7 @@ private:
     static void LogRaHeader(const RouterAdvert::Header &aRaHeader);
     static void LogPrefixInfoOption(const Ip6::Prefix &aPrefix, uint32_t aValidLifetime, uint32_t aPreferredLifetime);
     static void LogRouteInfoOption(const Ip6::Prefix &aPrefix, uint32_t aLifetime, RoutePreference aPreference);
+    static void LogRecursiveDnsServerOption(const Ip6::Address &aAddress, uint32_t aLifetime);
 
     static const char *RouterAdvOriginToString(RouterAdvOrigin aRaOrigin);
 
@@ -1584,6 +1797,10 @@ private:
     NetDataPeerBrTracker mNetDataPeerBrTracker;
 #endif
 
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+    MultiAilDetector mMultiAilDetector;
+#endif
+
     RxRaTracker mRxRaTracker;
 
     RoutePublisher mRoutePublisher;
@@ -1622,6 +1839,13 @@ inline RoutingManager::RxRaTracker::Entry<RoutingManager::RoutePrefix>
     return mRouteEntry;
 }
 
+template <>
+inline RoutingManager::RxRaTracker::Entry<RoutingManager::RdnssAddress>
+    &RoutingManager::RxRaTracker::SharedEntry::GetEntry(void)
+{
+    return mRdnssAddrEntry;
+}
+
 // Declare template (full) specializations for `Router` type.
 
 template <>
@@ -1635,6 +1859,7 @@ template <> void RoutingManager::RxRaTracker::Entry<RoutingManager::RxRaTracker:
 } // namespace BorderRouter
 
 DefineMapEnum(otBorderRoutingState, BorderRouter::RoutingManager::State);
+DefineMapEnum(otBorderRoutingOmrConfig, BorderRouter::RoutingManager::OmrConfig);
 DefineMapEnum(otBorderRoutingDhcp6PdState, BorderRouter::RoutingManager::Dhcp6PdState);
 
 } // namespace ot
diff --git a/src/core/coap/coap.cpp b/src/core/coap/coap.cpp
index b57bb6ae0..7437e7b2b 100644
--- a/src/core/coap/coap.cpp
+++ b/src/core/coap/coap.cpp
@@ -448,6 +448,31 @@ exit:
     return error;
 }
 
+void CoapBase::ScheduleRetransmissionTimer(void)
+{
+    NextFireTime nextTime;
+    Metadata     metadata;
+
+    for (const Message &message : mPendingRequests)
+    {
+        metadata.ReadFrom(message);
+
+#if OPENTHREAD_CONFIG_COAP_OBSERVE_API_ENABLE
+        if (message.IsRequest() && metadata.mObserve && metadata.mAcknowledged)
+        {
+            // This is an RFC7641 subscription which is already acknowledged.
+            // We do not time it out, so skip it when determining the next
+            // fire time.
+            continue;
+        }
+#endif
+
+        nextTime.UpdateIfEarlier(metadata.mNextTimerShot);
+    }
+
+    mRetransmissionTimer.FireAt(nextTime);
+}
+
 void CoapBase::HandleRetransmissionTimer(Timer &aTimer)
 {
     static_cast<Coap *>(static_cast<TimerMilliContext &>(aTimer).GetContext())->HandleRetransmissionTimer();
@@ -455,7 +480,7 @@ void CoapBase::HandleRetransmissionTimer(Timer &aTimer)
 
 void CoapBase::HandleRetransmissionTimer(void)
 {
-    NextFireTime     nextTime;
+    TimeMilli        now = TimerMilli::GetNow();
     Metadata         metadata;
     Ip6::MessageInfo messageInfo;
 
@@ -463,7 +488,7 @@ void CoapBase::HandleRetransmissionTimer(void)
     {
         metadata.ReadFrom(message);
 
-        if (nextTime.GetNow() >= metadata.mNextTimerShot)
+        if (now >= metadata.mNextTimerShot)
         {
 #if OPENTHREAD_CONFIG_COAP_OBSERVE_API_ENABLE
             if (message.IsRequest() && metadata.mObserve && metadata.mAcknowledged)
@@ -483,7 +508,7 @@ void CoapBase::HandleRetransmissionTimer(void)
             // Increment retransmission counter and timer.
             metadata.mRetransmissionsRemaining--;
             metadata.mRetransmissionTimeout *= 2;
-            metadata.mNextTimerShot = nextTime.GetNow() + metadata.mRetransmissionTimeout;
+            metadata.mNextTimerShot = now + metadata.mRetransmissionTimeout;
             metadata.UpdateIn(message);
 
             // Retransmit
@@ -501,11 +526,9 @@ void CoapBase::HandleRetransmissionTimer(void)
                 SendCopy(message, messageInfo);
             }
         }
-
-        nextTime.UpdateIfEarlier(metadata.mNextTimerShot);
     }
 
-    mRetransmissionTimer.FireAt(nextTime);
+    ScheduleRetransmissionTimer();
 }
 
 void CoapBase::FinalizeCoapTransaction(Message                &aRequest,
@@ -541,6 +564,15 @@ Error CoapBase::AbortTransaction(ResponseHandler aHandler, void *aContext)
     return error;
 }
 
+void CoapBase::GetRequestAndCachedResponsesQueueInfo(MessageQueue::Info &aQueueInfo) const
+{
+    MessageQueue::Info info;
+
+    mPendingRequests.GetInfo(aQueueInfo);
+    mResponsesQueue.GetResponses().GetInfo(info);
+    MessageQueue::AddQueueInfos(aQueueInfo, info);
+}
+
 Message *CoapBase::CopyAndEnqueueMessage(const Message &aMessage, uint16_t aCopyLength, const Metadata &aMetadata)
 {
     Error    error       = kErrorNone;
@@ -550,9 +582,8 @@ Message *CoapBase::CopyAndEnqueueMessage(const Message &aMessage, uint16_t aCopy
 
     SuccessOrExit(error = aMetadata.AppendTo(*messageCopy));
 
-    mRetransmissionTimer.FireAtIfEarlier(aMetadata.mNextTimerShot);
-
     mPendingRequests.Enqueue(*messageCopy);
+    ScheduleRetransmissionTimer();
 
 exit:
     FreeAndNullMessageOnError(messageCopy, error);
@@ -561,17 +592,8 @@ exit:
 
 void CoapBase::DequeueMessage(Message &aMessage)
 {
-    mPendingRequests.Dequeue(aMessage);
-
-    if (mRetransmissionTimer.IsRunning() && (mPendingRequests.GetHead() == nullptr))
-    {
-        mRetransmissionTimer.Stop();
-    }
-
-    aMessage.Free();
-
-    // No need to worry that the earliest pending message was removed -
-    // the timer would just shoot earlier and then it'd be setup again.
+    mPendingRequests.DequeueAndFree(aMessage);
+    ScheduleRetransmissionTimer();
 }
 
 #if OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE
diff --git a/src/core/coap/coap.hpp b/src/core/coap/coap.hpp
index e21879dc4..b03ca6cd3 100644
--- a/src/core/coap/coap.hpp
+++ b/src/core/coap/coap.hpp
@@ -720,18 +720,14 @@ public:
     void SetInterceptor(Interceptor aInterceptor, void *aContext) { mInterceptor.Set(aInterceptor, aContext); }
 
     /**
-     * Returns a reference to the request message list.
+     * Retrieves aggregated information about the CoAP request and cached response message queues.
      *
-     * @returns A reference to the request message list.
-     */
-    const MessageQueue &GetRequestMessages(void) const { return mPendingRequests; }
-
-    /**
-     * Returns a reference to the cached response list.
+     * Provides combined statistics, such as the total number of messages and data buffers currently used across all
+     * queues associated with CoAP requests and cached responses within this CoAP instance.
      *
-     * @returns A reference to the cached response list.
+     * @param[out] aQueueInfo     A `MessageQueue::Info` to populate with info about the queues.
      */
-    const MessageQueue &GetCachedResponses(void) const { return mResponsesQueue.GetResponses(); }
+    void GetRequestAndCachedResponsesQueueInfo(MessageQueue::Info &aQueueInfo) const;
 
 protected:
     /**
@@ -821,6 +817,7 @@ private:
     Message *InitMessage(Message *aMessage, Type aType, Uri aUri);
     Message *InitResponse(Message *aMessage, const Message &aRequest);
 
+    void        ScheduleRetransmissionTimer(void);
     static void HandleRetransmissionTimer(Timer &aTimer);
     void        HandleRetransmissionTimer(void);
 
@@ -936,6 +933,25 @@ private:
     Error        Send(ot::Message &aMessage, const Ip6::MessageInfo &aMessageInfo);
 };
 
+#if OPENTHREAD_CONFIG_COAP_API_ENABLE
+/**
+ * Represents an Application CoAP.
+ */
+class ApplicationCoap : public Coap
+{
+public:
+    /**
+     * Initializes the object.
+     *
+     * @param[in] aInstance      A reference to the OpenThread instance.
+     */
+    explicit ApplicationCoap(Instance &aInstance)
+        : Coap(aInstance)
+    {
+    }
+};
+#endif
+
 } // namespace Coap
 
 DefineCoreType(otCoapTxParameters, Coap::TxParameters);
diff --git a/src/core/common/message.cpp b/src/core/common/message.cpp
index 044cf8948..45be0d99e 100644
--- a/src/core/common/message.cpp
+++ b/src/core/common/message.cpp
@@ -944,6 +944,8 @@ Message::ConstIterator MessageQueue::begin(void) const { return Message::ConstIt
 
 void MessageQueue::GetInfo(Info &aInfo) const
 {
+    ClearAllBytes(aInfo);
+
     for (const Message &message : *this)
     {
         aInfo.mNumMessages++;
@@ -952,6 +954,13 @@ void MessageQueue::GetInfo(Info &aInfo) const
     }
 }
 
+void MessageQueue::AddQueueInfos(Info &aInfo, const Info &aOther)
+{
+    aInfo.mNumMessages += aOther.mNumMessages;
+    aInfo.mNumBuffers += aOther.mNumBuffers;
+    aInfo.mTotalBytes += aOther.mTotalBytes;
+}
+
 //---------------------------------------------------------------------------------------------------------------------
 // PriorityQueue
 
@@ -1093,6 +1102,8 @@ Message::ConstIterator PriorityQueue::begin(void) const { return Message::ConstI
 
 void PriorityQueue::GetInfo(Info &aInfo) const
 {
+    ClearAllBytes(aInfo);
+
     for (const Message &message : *this)
     {
         aInfo.mNumMessages++;
diff --git a/src/core/common/message.hpp b/src/core/common/message.hpp
index 008b1f77c..54e6a0551 100644
--- a/src/core/common/message.hpp
+++ b/src/core/common/message.hpp
@@ -59,6 +59,7 @@
 #include "mac/mac_types.hpp"
 #include "thread/child_mask.hpp"
 #include "thread/link_quality.hpp"
+#include "thread/thread_link_info.hpp"
 
 /**
  * Represents an opaque (and empty) type for an OpenThread message buffer.
@@ -147,7 +148,6 @@ class Message;
 class MessagePool;
 class MessageQueue;
 class PriorityQueue;
-class ThreadLinkInfo;
 
 /**
  * Represents the link security mode indicating whether to use MAC (layer two) security.
@@ -1643,15 +1643,21 @@ public:
     /**
      * Gets the information about number of messages and buffers in the queue.
      *
-     * Updates `aInfo` and adds number of message/buffers in the message queue to the corresponding member
-     * variable in `aInfo`. The caller needs to make sure `aInfo` is initialized before calling this method (e.g.,
-     * clearing `aInfo`). Same `aInfo` can be passed in multiple calls of `GetInfo(aInfo)` on different queues to add
-     * up the number of messages/buffers on different queues.
-     *
-     * @param[out] aInfo  A reference to `Info` structure to update.ni
+     * @param[out] aInfo  A reference to `Info` structure to update.
      */
     void GetInfo(Info &aInfo) const;
 
+    /**
+     * Adds the queue statistics from one queue `Info` to another.
+     *
+     * Aggregates queue information by adding the counts (e.g., number of messages, buffers, total bytes) from
+     * @p aOther to the corresponding counts in @p aInfo.
+     *
+     * @param[in,out] aInfo    A queue `Info` to update.
+     * @param[in]     aOther   A queue `Info` to add to @p aInfo.
+     */
+    static void AddQueueInfos(Info &aInfo, const Info &aOther);
+
     // The following methods are intended to support range-based `for`
     // loop iteration over the queue entries and should not be used
     // directly. The range-based `for` works correctly even if the
diff --git a/src/core/common/num_utils.hpp b/src/core/common/num_utils.hpp
index ab5753eb9..18ee2a6dd 100644
--- a/src/core/common/num_utils.hpp
+++ b/src/core/common/num_utils.hpp
@@ -34,6 +34,7 @@
 #ifndef NUM_UTILS_HPP_
 #define NUM_UTILS_HPP_
 
+#include "common/encoding.hpp"
 #include "common/numeric_limits.hpp"
 #include "common/type_traits.hpp"
 
@@ -241,7 +242,7 @@ inline unsigned long ToUlong(uint32_t aUint32) { return static_cast<unsigned lon
 /**
  * Counts the number of `1` bits in the binary representation of a given unsigned int bit-mask value.
  *
- * @tparam UintType   The unsigned int type (MUST be `uint8_t`, uint16_t`, uint32_t`, or `uint64_t`).
+ * @tparam UintType   The unsigned int type (MUST be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`).
  *
  * @param[in] aMask   A bit mask.
  *
@@ -264,6 +265,259 @@ template <typename UintType> uint8_t CountBitsInMask(UintType aMask)
     return count;
 }
 
+/**
+ * Sets the specified bit of the given integer to 1.
+ *
+ * @tparam UintType   The value type (MUST be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`).
+ *
+ * @param[in,out]  aBits       The integer to set the bit.
+ * @param[in]      aBitOffset  The bit offset to set. The bit offset starts with zero corresponding to the
+ *                             least-significant bit.
+ */
+template <typename UintType> void SetBit(UintType &aBits, uint8_t aBitOffset)
+{
+    static_assert(TypeTraits::IsSame<UintType, uint8_t>::kValue || TypeTraits::IsSame<UintType, uint16_t>::kValue ||
+                      TypeTraits::IsSame<UintType, uint32_t>::kValue || TypeTraits::IsSame<UintType, uint64_t>::kValue,
+                  "UintType must be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`");
+
+    aBits = aBits | (static_cast<UintType>(1) << aBitOffset);
+}
+
+/**
+ * Clears the specified bit of the given integer.
+ *
+ * @tparam UintType   The value type (MUST be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`).
+ *
+ * @param[in,out]  aBits       The integer to clear the bit.
+ * @param[in]      aBitOffset  The bit offset to clear. The bit offset starts with zero corresponding to the
+ *                             least-significant bit.
+ */
+template <typename UintType> void ClearBit(UintType &aBits, uint8_t aBitOffset)
+{
+    static_assert(TypeTraits::IsSame<UintType, uint8_t>::kValue || TypeTraits::IsSame<UintType, uint16_t>::kValue ||
+                      TypeTraits::IsSame<UintType, uint32_t>::kValue || TypeTraits::IsSame<UintType, uint64_t>::kValue,
+                  "UintType must be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`");
+
+    aBits = aBits & (~(static_cast<UintType>(1) << aBitOffset));
+}
+
+/**
+ * Gets the value of the specified bit of the given integer.
+ *
+ * @tparam UintType   The value type (MUST be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`).
+ *
+ * @param[in] aBits       The integer to get the bit.
+ * @param[in] aBitOffset  The bit offset to get. The bit offset starts with zero corresponding to the
+ *                        least-significant bit.
+ *
+ * @returns The value of the specified bit.
+ */
+template <typename UintType> bool GetBit(UintType aBits, uint8_t aBitOffset)
+{
+    static_assert(TypeTraits::IsSame<UintType, uint8_t>::kValue || TypeTraits::IsSame<UintType, uint16_t>::kValue ||
+                      TypeTraits::IsSame<UintType, uint32_t>::kValue || TypeTraits::IsSame<UintType, uint64_t>::kValue,
+                  "UintType must be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`");
+
+    return (aBits & (static_cast<UintType>(1) << aBitOffset)) != 0;
+}
+
+/**
+ * Writes the specified bit of the given integer to the given value (0 or 1).
+ *
+ * @tparam UintType   The value type (MUST be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`).
+ *
+ * @param[in,out]  aBits      The integer to write the bit.
+ * @param[in]      aBitOffset The bit offset to get. The bit offset starts with zero corresponding to the
+ *                            least-significant bit.
+ * @param[in]      aValue     The value to write.
+ */
+template <typename UintType> void WriteBit(UintType &aBits, uint8_t aBitOffset, bool aValue)
+{
+    static_assert(TypeTraits::IsSame<UintType, uint8_t>::kValue || TypeTraits::IsSame<UintType, uint16_t>::kValue ||
+                      TypeTraits::IsSame<UintType, uint32_t>::kValue || TypeTraits::IsSame<UintType, uint64_t>::kValue,
+                  "UintType must be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`");
+
+    if (aValue)
+    {
+        SetBit<UintType>(aBits, aBitOffset);
+    }
+    else
+    {
+        ClearBit<UintType>(aBits, aBitOffset);
+    }
+}
+
+/**
+ * Gets the offset of the lowest non-zero bit in the given mask.
+ *
+ * @tparam UintType  The value type (MUST be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`).
+ *
+ * @param[in] aMask  The mask (MUST not be 0) to calculate the offset of the lowest non-zero bit.
+ *
+ * @returns The offset of the lowest non-zero bit in the mask.
+ */
+template <typename UintType> inline constexpr uint8_t BitOffsetOfMask(UintType aMask)
+{
+    static_assert(TypeTraits::IsSame<UintType, uint8_t>::kValue || TypeTraits::IsSame<UintType, uint16_t>::kValue ||
+                      TypeTraits::IsSame<UintType, uint32_t>::kValue || TypeTraits::IsSame<UintType, uint64_t>::kValue,
+                  "UintType must be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`");
+
+    return (aMask & 0x1) ? 0 : (1 + BitOffsetOfMask<UintType>(aMask >> 1));
+}
+
+/**
+ * Writes the specified bits of the given integer to the given value.
+ *
+ * @tparam UintType   The value type (MUST be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`).
+ * @tparam kMask      The bit mask (MUST not be 0) to write. The @p kMask must be provided in a shifted form.
+ * @tparam kOffset    The bit offset to write. The default @p kOffset is computed from the given @p kMask.
+ *
+ * @param[in,out]  aBits   The integer to write the bits.
+ * @param[in]      aValue  The value to write.
+ */
+template <typename UintType, UintType kMask, UintType kOffset = BitOffsetOfMask(kMask)>
+void WriteBits(UintType &aBits, UintType aValue)
+{
+    static_assert(TypeTraits::IsSame<UintType, uint8_t>::kValue || TypeTraits::IsSame<UintType, uint16_t>::kValue ||
+                      TypeTraits::IsSame<UintType, uint32_t>::kValue || TypeTraits::IsSame<UintType, uint64_t>::kValue,
+                  "UintType must be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`");
+
+    aBits = ((aBits & ~kMask) | ((aValue << kOffset) & kMask));
+}
+
+/**
+ * Writes the specified bits of the given integer to the given value and returns the updated integer.
+ *
+ * @tparam UintType   The value type (MUST be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`).
+ * @tparam kMask      The bit mask (MUST not be 0) to write. The @p kMask must be provided in a shifted form.
+ * @tparam kOffset    The bit offset to write. The default @p kOffset is computed from the given @p kMask.
+ *
+ * @param[in] aBits   The integer to write the bits.
+ * @param[in] aValue  The value to write.
+ *
+ * @returns The updated integer.
+ */
+template <typename UintType, UintType kMask, UintType kOffset = BitOffsetOfMask(kMask)>
+UintType UpdateBits(UintType aBits, UintType aValue)
+{
+    static_assert(TypeTraits::IsSame<UintType, uint8_t>::kValue || TypeTraits::IsSame<UintType, uint16_t>::kValue ||
+                      TypeTraits::IsSame<UintType, uint32_t>::kValue || TypeTraits::IsSame<UintType, uint64_t>::kValue,
+                  "UintType must be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`");
+
+    return ((aBits & ~kMask) | ((aValue << kOffset) & kMask));
+}
+
+/**
+ * Read the value of the specified bits of the given integer.
+ *
+ * @tparam UintType   The value type (MUST be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`).
+ * @tparam kMask      The bit mask (MUST not be 0) to write. The @p kMask must be provided in a shifted form.
+ * @tparam kOffset    The bit offset to write. The default @p kOffset is computed from the given @p kMask.
+ *
+ * @param[in] aBits   The integer to read the bits.
+ *
+ * @returns The value of the specified bits.
+ */
+template <typename UintType, UintType kMask, UintType kOffset = BitOffsetOfMask(kMask)>
+UintType ReadBits(UintType aBits)
+{
+    static_assert(TypeTraits::IsSame<UintType, uint8_t>::kValue || TypeTraits::IsSame<UintType, uint16_t>::kValue ||
+                      TypeTraits::IsSame<UintType, uint32_t>::kValue || TypeTraits::IsSame<UintType, uint64_t>::kValue,
+                  "UintType must be `uint8_t`, `uint16_t`, `uint32_t`, or `uint64_t`");
+
+    return (aBits & kMask) >> kOffset;
+}
+
+/**
+ * Writes the specified bits of the given integer stored in little-endian format to the given value and returns the
+ * updated integer stored in little-endian format.
+ *
+ * @tparam UintType   The value type (MUST be `uint16_t`, `uint32_t`, or `uint64_t`).
+ * @tparam kMask      The bit mask (MUST not be 0) to write. The @p kMask must be provided in a shifted form.
+ * @tparam kOffset    The bit offset to write. The default @p kOffset is computed from the given @p kMask.
+ *
+ * @param[in]  aBits   The integer to write the bits.
+ * @param[in]  aValue  The value to write.
+ *
+ * @returns The updated integer.
+ */
+template <typename UintType, UintType kMask, UintType kOffset = BitOffsetOfMask(kMask)>
+UintType UpdateBitsLittleEndian(UintType aBits, UintType aValue)
+{
+    static_assert(TypeTraits::IsSame<UintType, uint16_t>::kValue || TypeTraits::IsSame<UintType, uint32_t>::kValue ||
+                      TypeTraits::IsSame<UintType, uint64_t>::kValue,
+                  "UintType must be `uint16_t`, `uint32_t`, or `uint64_t`");
+
+    return LittleEndian::HostSwap<UintType>((LittleEndian::HostSwap<UintType>(aBits) & ~kMask) |
+                                            ((aValue << kOffset) & kMask));
+}
+
+/**
+ * Writes the specified bits of the given integer stored in big-endian format to the given value and returns the updated
+ * integer stored in big-endian format.
+ *
+ * @tparam UintType   The value type (MUST be `uint16_t`, `uint32_t`, or `uint64_t`).
+ * @tparam kMask      The bit mask (MUST not be 0) to write. The @p kMask must be provided in a shifted form.
+ * @tparam kOffset    The bit offset to write. The default @p kOffset is computed from the given @p kMask.
+ *
+ * @param[in]  aBits   A pointer to the integer to write the bits.
+ * @param[in]  aValue  The value to write.
+ *
+ * @returns The updated integer.
+ */
+template <typename UintType, UintType kMask, UintType kOffset = BitOffsetOfMask(kMask)>
+UintType UpdateBitsBigEndian(UintType aBits, UintType aValue)
+{
+    static_assert(TypeTraits::IsSame<UintType, uint16_t>::kValue || TypeTraits::IsSame<UintType, uint32_t>::kValue ||
+                      TypeTraits::IsSame<UintType, uint64_t>::kValue,
+                  "UintType must be `uint16_t`, `uint32_t`, or `uint64_t`");
+
+    return BigEndian::HostSwap<UintType>((BigEndian::HostSwap<UintType>(aBits) & ~kMask) |
+                                         ((aValue << kOffset) & kMask));
+}
+
+/**
+ * Read the value of the specified bits of the given integer stored in little-endian format.
+ *
+ * @tparam UintType   The value type (MUST be `uint16_t`, `uint32_t`, or `uint64_t`).
+ * @tparam kMask      The bit mask (MUST not be 0) to write. The @p kMask must be provided in a shifted form.
+ * @tparam kOffset    The bit offset to write. The default @p kOffset is computed from the given @p kMask.
+ *
+ * @param[in] aBits   The integer stored in little-endian format to read the bits.
+ *
+ * @returns The value of the specified bits.
+ */
+template <typename UintType, UintType kMask, UintType kOffset = BitOffsetOfMask(kMask)>
+UintType ReadBitsLittleEndian(UintType aBits)
+{
+    static_assert(TypeTraits::IsSame<UintType, uint16_t>::kValue || TypeTraits::IsSame<UintType, uint32_t>::kValue ||
+                      TypeTraits::IsSame<UintType, uint64_t>::kValue,
+                  "UintType must be `uint16_t`, `uint32_t`, or `uint64_t`");
+
+    return (LittleEndian::HostSwap<UintType>(aBits) & kMask) >> kOffset;
+}
+
+/**
+ * Read the value of the specified bits of the given integer stored in big-endian format.
+ *
+ * @tparam UintType   The value type (MUST be `uint16_t`, `uint32_t`, or `uint64_t`).
+ * @tparam kMask      The bit mask (MUST not be 0) to write. The @p kMask must be provided in a shifted form.
+ * @tparam kOffset    The bit offset to write. The default @p kOffset is computed from the given @p kMask.
+ *
+ * @param[in] aBits   The integer stored in big-endian format to read the bits.
+ *
+ * @returns The value of the specified bits.
+ */
+template <typename UintType, UintType kMask, UintType kOffset = BitOffsetOfMask(kMask)>
+UintType ReadBitsBigEndian(UintType aBits)
+{
+    static_assert(TypeTraits::IsSame<UintType, uint16_t>::kValue || TypeTraits::IsSame<UintType, uint32_t>::kValue ||
+                      TypeTraits::IsSame<UintType, uint64_t>::kValue,
+                  "UintType must be `uint16_t`, `uint32_t`, or `uint64_t`");
+
+    return (BigEndian::HostSwap<UintType>(aBits) & kMask) >> kOffset;
+}
+
 } // namespace ot
 
 #endif // NUM_UTILS_HPP_
diff --git a/src/core/common/time_ticker.cpp b/src/core/common/time_ticker.cpp
index 5efa1a49d..eeaba6dfb 100644
--- a/src/core/common/time_ticker.cpp
+++ b/src/core/common/time_ticker.cpp
@@ -74,9 +74,9 @@ void TimeTicker::HandleTimer(void)
     }
 
 #if OPENTHREAD_FTD
-    if (mReceivers & Mask(kMleRouter))
+    if (mReceivers & Mask(kMle))
     {
-        Get<Mle::MleRouter>().HandleTimeTick();
+        Get<Mle::Mle>().HandleTimeTick();
     }
 
     if (mReceivers & Mask(kAddressResolver))
diff --git a/src/core/common/time_ticker.hpp b/src/core/common/time_ticker.hpp
index 8243abe6d..55873a3b7 100644
--- a/src/core/common/time_ticker.hpp
+++ b/src/core/common/time_ticker.hpp
@@ -62,7 +62,7 @@ public:
     enum Receiver : uint8_t
     {
         kMeshForwarder,          ///< `MeshForwarder`
-        kMleRouter,              ///< `Mle::MleRouter`
+        kMle,                    ///< `Mle::Mle`
         kAddressResolver,        ///< `AddressResolver`
         kChildSupervisor,        ///< `ChildSupervisor`
         kIp6FragmentReassembler, ///< `Ip6::Ip6` (handling of fragmented messages)
diff --git a/src/core/common/uptime.cpp b/src/core/common/uptime.cpp
index ca544c316..e809c95b8 100644
--- a/src/core/common/uptime.cpp
+++ b/src/core/common/uptime.cpp
@@ -85,6 +85,8 @@ void Uptime::GetUptime(char *aBuffer, uint16_t aSize) const
     UptimeToString(GetUptime(), writer, /* aIncludeMsec */ true);
 }
 
+uint32_t Uptime::GetUptimeInSeconds(void) const { return MsecToSec(GetUptime()); }
+
 void Uptime::HandleTimer(void)
 {
     if (mTimer.GetFireTime() == mStartTime)
diff --git a/src/core/common/uptime.hpp b/src/core/common/uptime.hpp
index f238f11d7..4b7550039 100644
--- a/src/core/common/uptime.hpp
+++ b/src/core/common/uptime.hpp
@@ -36,8 +36,8 @@
 
 #include "openthread-core-config.h"
 
-#if !OPENTHREAD_CONFIG_UPTIME_ENABLE && OPENTHREAD_FTD
-#error "OPENTHREAD_CONFIG_UPTIME_ENABLE is required for FTD"
+#if (OPENTHREAD_FTD || OPENTHREAD_MTD) && !OPENTHREAD_CONFIG_UPTIME_ENABLE
+#error "OPENTHREAD_CONFIG_UPTIME_ENABLE is required for FTD or MTD builds"
 #endif
 
 #if OPENTHREAD_CONFIG_UPTIME_ENABLE
@@ -101,6 +101,13 @@ public:
      */
     static void UptimeToString(uint64_t aUptime, StringWriter &aWriter, bool aIncludeMsec);
 
+    /**
+     * Returns the current device uptime in seconds.
+     *
+     * @returns The uptime in seconds.
+     */
+    uint32_t GetUptimeInSeconds(void) const;
+
     /**
      * Converts a given uptime as number of milliseconds to number of seconds.
      *
diff --git a/src/core/config/border_agent.h b/src/core/config/border_agent.h
index edb99d380..2341a2c05 100644
--- a/src/core/config/border_agent.h
+++ b/src/core/config/border_agent.h
@@ -89,6 +89,38 @@
     OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
 #endif
 
+/**
+ * @def OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+ *
+ * Define to 1 to enable Border Agent to manage registering/updating of the mDNS MeshCoP service(s) on the
+ * infrastructure link
+ *
+ * This includes the ephemeral key service when the `OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE` is enabled.
+ */
+#ifndef OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+#define OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE \
+    (OPENTHREAD_CONFIG_PLATFORM_DNSSD_ENABLE || OPENTHREAD_CONFIG_MULTICAST_DNS_ENABLE)
+#endif
+
+/**
+ * @def OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_BASE_NAME
+ *
+ * Specifies the base name to construct the service instance name used when advertising the mDNS `_meshcop._udp`
+ * service by the Border Agent.
+ *
+ * Applicable when the `OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE` feature is enabled.
+ *
+ * The name can also be configured using the `otBorderAgentSetMeshCoPServiceBaseName()` API at run-time.
+ *
+ * Per the Thread specification, the service instance should be a user-friendly name identifying the device model or
+ * product. A recommended format is "VendorName ProductName".
+ *
+ * The name MUST have a length less than or equal to `OT_BORDER_AGENT_MESHCOP_SERVICE_BASE_NAME_MAX_LENGTH` (47 chars).
+ */
+#ifndef OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_BASE_NAME
+#define OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_BASE_NAME "OpenThread BR (unspecified vendor) "
+#endif
+
 /**
  * @}
  */
diff --git a/src/core/config/border_routing.h b/src/core/config/border_routing.h
index 19508a16f..a8fb56dc4 100644
--- a/src/core/config/border_routing.h
+++ b/src/core/config/border_routing.h
@@ -83,6 +83,23 @@
 #define OPENTHREAD_CONFIG_BORDER_ROUTING_TRACK_PEER_BR_INFO_ENABLE OPENTHREAD_CONFIG_BORDER_ROUTING_USE_HEAP_ENABLE
 #endif
 
+/**
+ * @def OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+ *
+ * Define to 1 to enable Routing Manager multiple Adjacent Infrastructure Links (AILs) detection feature.
+ *
+ * The detection mechanism operates as follows: The Routing Manager monitors the number of peer BRs listed in the
+ * Thread Network Data (see `otBorderRoutingCountPeerBrs()`) and compares this count with the number of peer BRs
+ * discovered by processing received Router Advertisement (RA) messages on its connected AIL. If the count derived from
+ * Network Data consistently exceeds the count derived from RAs for a detection duration of 10 minutes, it concludes
+ * that BRs are likely connected to different AILs. To clear state a shorter window of 1 minute is used.
+ *
+ * See `otBorderRoutingIsMultiAilDetected()` for more details.
+ */
+#ifndef OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE
+#define OPENTHREAD_CONFIG_BORDER_ROUTING_MULTI_AIL_DETECTION_ENABLE OPENTHREAD_CONFIG_BORDER_ROUTING_USE_HEAP_ENABLE
+#endif
+
 /**
  * @def OPENTHREAD_CONFIG_BORDER_ROUTING_REACHABILITY_CHECK_ICMP6_ERROR_ENABLE
  *
diff --git a/src/core/config/dns_client.h b/src/core/config/dns_client.h
index cc9ab5749..f11173cfc 100644
--- a/src/core/config/dns_client.h
+++ b/src/core/config/dns_client.h
@@ -84,6 +84,15 @@
 #define OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE 1
 #endif
 
+/**
+ * @def OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+ *
+ * Define to 1 to enable support for a query of arbitrary DNS record type.
+ */
+#ifndef OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+#define OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE 1
+#endif
+
 /**
  * @def OPENTHREAD_CONFIG_DNS_CLIENT_DEFAULT_SERVER_ADDRESS_AUTO_SET_ENABLE
  *
diff --git a/src/core/config/history_tracker.h b/src/core/config/history_tracker.h
index c18386418..ef9c63721 100644
--- a/src/core/config/history_tracker.h
+++ b/src/core/config/history_tracker.h
@@ -160,6 +160,17 @@
 #define OPENTHREAD_CONFIG_HISTORY_TRACKER_EXTERNAL_ROUTE_LIST_SIZE 32
 #endif
 
+/**
+ * @def OPENTHREAD_CONFIG_HISTORY_TRACKER_EPSKC_EVENT_SIZE
+ *
+ * Specifies the maximum number of entries in Border Agent ePSKc history list.
+ *
+ * Can be set to zero to configure History Tracker module not to collect any ePSKc journey info.
+ */
+#ifndef OPENTHREAD_CONFIG_HISTORY_TRACKER_EPSKC_EVENT_SIZE
+#define OPENTHREAD_CONFIG_HISTORY_TRACKER_EPSKC_EVENT_SIZE 64
+#endif
+
 /**
  * @}
  */
diff --git a/src/core/config/misc.h b/src/core/config/misc.h
index 7fb9139d7..fe5aaa62f 100644
--- a/src/core/config/misc.h
+++ b/src/core/config/misc.h
@@ -117,6 +117,10 @@
  * @def OPENTHREAD_CONFIG_UPTIME_ENABLE
  *
  * Define to 1 to enable tracking the uptime of OpenThread instance.
+ *
+ * On FTD/MTD builds this feature is now mandatory and MUST be enabled. This config is therefore only applicable for
+ * RADIO/RCP builds.
+ *
  */
 #ifndef OPENTHREAD_CONFIG_UPTIME_ENABLE
 #define OPENTHREAD_CONFIG_UPTIME_ENABLE (OPENTHREAD_FTD || OPENTHREAD_MTD)
@@ -377,6 +381,15 @@
 #define OPENTHREAD_CONFIG_POSIX_SETTINGS_PATH "tmp"
 #endif
 
+/**
+ * @def OPENTHREAD_CONFIG_PLATFORM_BOOTLOADER_MODE_ENABLE
+ *
+ * Define to 1 to enable support reset to bootloader mode.
+ */
+#ifndef OPENTHREAD_CONFIG_PLATFORM_BOOTLOADER_MODE_ENABLE
+#define OPENTHREAD_CONFIG_PLATFORM_BOOTLOADER_MODE_ENABLE 0
+#endif
+
 /**
  * @def OPENTHREAD_CONFIG_PLATFORM_FLASH_API_ENABLE
  *
@@ -586,6 +599,24 @@
 #define OPENTHREAD_CONFIG_PLATFORM_LOG_CRASH_DUMP_ENABLE 0
 #endif
 
+/**
+ * @def OPENTHREAD_ENABLE_VENDOR_EXTENSION
+ *
+ * Define to 1 to enable vendor extension support.
+ */
+#ifndef OPENTHREAD_ENABLE_VENDOR_EXTENSION
+#define OPENTHREAD_ENABLE_VENDOR_EXTENSION 0
+#endif
+
+/**
+ * @def OPENTHREAD_EXAMPLES_SIMULATION
+ *
+ * Define 1 to to enable simulation example support.
+ */
+#ifndef OPENTHREAD_EXAMPLES_SIMULATION
+#define OPENTHREAD_EXAMPLES_SIMULATION 0
+#endif
+
 /**
  * @}
  */
diff --git a/src/core/config/srp_client.h b/src/core/config/srp_client.h
index 45a738598..29cf2e1eb 100644
--- a/src/core/config/srp_client.h
+++ b/src/core/config/srp_client.h
@@ -278,8 +278,12 @@
  * This config is applicable only when `OPENTHREAD_CONFIG_SRP_CLIENT_BUFFERS_ENABLE` is enabled.
  */
 #ifndef OPENTHREAD_CONFIG_SRP_CLIENT_BUFFERS_MAX_SERVICES
+#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
+#define OPENTHREAD_CONFIG_SRP_CLIENT_BUFFERS_MAX_SERVICES 8
+#else
 #define OPENTHREAD_CONFIG_SRP_CLIENT_BUFFERS_MAX_SERVICES 2
 #endif
+#endif
 
 /**
  * @def OPENTHREAD_CONFIG_SRP_CLIENT_BUFFERS_MAX_HOST_ADDRESSES
diff --git a/src/core/config/trel.h b/src/core/config/trel.h
index e4e04643f..dbd4dea25 100644
--- a/src/core/config/trel.h
+++ b/src/core/config/trel.h
@@ -43,14 +43,23 @@
  * @{
  */
 
+/**
+ * @def OPENTHREAD_CONFIG_TREL_USE_HEAP_ENABLE
+ *
+ * Define as 1 to allow TREL modules to use heap allocated objects (e.g. for the TREL peer table).
+ */
+#ifndef OPENTHREAD_CONFIG_TREL_USE_HEAP_ENABLE
+#define OPENTHREAD_CONFIG_TREL_USE_HEAP_ENABLE 0
+#endif
+
 /**
  * @def OPENTHREAD_CONFIG_TREL_PEER_TABLE_SIZE
  *
- * Specifies the capacity of TREL peer table. Only non-zero value
- * will be directly used for setting the TREL peer table capacity.
- * Zero value lets the size to be determined by the OT stack itself
- * which is derived based on other configurations such as a child
- * table size, neighbor table size, etc.
+ * Specifies the capacity of TREL peer table. Only non-zero value will be directly used for setting the TREL peer table
+ * capacity. Zero value lets the size to be determined by the OT stack itself which is derived based on other
+ * configurations such as a child table size, neighbor table size, etc.
+ *
+ * Applicable when `OPENTHREAD_CONFIG_TREL_USE_HEAP_ENABLE` is not used.
  */
 #ifndef OPENTHREAD_CONFIG_TREL_PEER_TABLE_SIZE
 #define OPENTHREAD_CONFIG_TREL_PEER_TABLE_SIZE (0)
diff --git a/src/core/ftd.cmake b/src/core/ftd.cmake
index 074c4362c..2e16087cd 100644
--- a/src/core/ftd.cmake
+++ b/src/core/ftd.cmake
@@ -36,6 +36,7 @@ target_compile_definitions(openthread-ftd PRIVATE
 
 target_compile_options(openthread-ftd PRIVATE
     ${OT_CFLAGS}
+    -Wundef
 )
 
 target_include_directories(openthread-ftd PUBLIC ${OT_PUBLIC_INCLUDES} PRIVATE ${COMMON_INCLUDES})
diff --git a/src/core/instance/instance.cpp b/src/core/instance/instance.cpp
index 48f341526..e0748b359 100644
--- a/src/core/instance/instance.cpp
+++ b/src/core/instance/instance.cpp
@@ -40,6 +40,10 @@
 
 namespace ot {
 
+#if (OPENTHREAD_FTD + OPENTHREAD_MTD + OPENTHREAD_RADIO) != 1
+#error "Exactly one of {OPENTHREAD_FTD, OPENTHREAD_MTD, OPENTHREAD_RADIO} MUST be set"
+#endif
+
 #if !OPENTHREAD_CONFIG_MULTIPLE_INSTANCE_ENABLE
 
 // Define the raw storage used for OpenThread instance (in single-instance case).
@@ -142,7 +146,7 @@ Instance::Instance(void)
     , mLowpan(*this)
     , mMac(*this)
     , mMeshForwarder(*this)
-    , mMleRouter(*this)
+    , mMle(*this)
     , mDiscoverScanner(*this)
     , mAddressResolver(*this)
 #if OPENTHREAD_CONFIG_MULTI_RADIO
@@ -399,12 +403,16 @@ void Instance::AfterInit(void)
     // Restore datasets and network information
 
     Get<Settings>().Init();
-    Get<Mle::MleRouter>().Restore();
+    Get<Mle::Mle>().Restore();
 
 #if OPENTHREAD_CONFIG_RADIO_LINK_TREL_ENABLE
     Get<Trel::Link>().AfterInit();
 #endif
 
+#if OPENTHREAD_CONFIG_MULTICAST_DNS_ENABLE
+    Get<Dns::Multicast::Core>().AfterInstanceInit();
+#endif
+
 #endif // OPENTHREAD_MTD || OPENTHREAD_FTD
 
 #if OPENTHREAD_ENABLE_VENDOR_EXTENSION
@@ -462,7 +470,7 @@ Error Instance::ErasePersistentInfo(void)
 {
     Error error = kErrorNone;
 
-    VerifyOrExit(Get<Mle::MleRouter>().IsDisabled(), error = kErrorInvalidState);
+    VerifyOrExit(Get<Mle::Mle>().IsDisabled(), error = kErrorInvalidState);
     Get<Settings>().Wipe();
 #if OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE
     Get<KeyManager>().DestroyTemporaryKeys();
@@ -481,27 +489,23 @@ void Instance::GetBufferInfo(BufferInfo &aInfo)
     aInfo.mFreeBuffers    = Get<MessagePool>().GetFreeBufferCount();
     aInfo.mMaxUsedBuffers = Get<MessagePool>().GetMaxUsedBufferCount();
 
-    Get<MeshForwarder>().GetSendQueue().GetInfo(aInfo.m6loSendQueue);
-    Get<MeshForwarder>().GetReassemblyQueue().GetInfo(aInfo.m6loReassemblyQueue);
-    Get<Ip6::Ip6>().GetSendQueue().GetInfo(aInfo.mIp6Queue);
+    Get<MeshForwarder>().GetQueueInfo(aInfo.m6loSendQueue, aInfo.m6loReassemblyQueue);
+    Get<Ip6::Ip6>().GetSendQueueInfo(aInfo.mIp6Queue);
 
 #if OPENTHREAD_FTD
-    Get<Ip6::Mpl>().GetBufferedMessageSet().GetInfo(aInfo.mMplQueue);
+    Get<Ip6::Mpl>().GetBufferedMessageSetInfo(aInfo.mMplQueue);
 #endif
 
-    Get<Mle::MleRouter>().GetMessageQueue().GetInfo(aInfo.mMleQueue);
+    Get<Mle::Mle>().GetMessageQueueInfo(aInfo.mMleQueue);
 
-    Get<Tmf::Agent>().GetRequestMessages().GetInfo(aInfo.mCoapQueue);
-    Get<Tmf::Agent>().GetCachedResponses().GetInfo(aInfo.mCoapQueue);
+    Get<Tmf::Agent>().GetRequestAndCachedResponsesQueueInfo(aInfo.mCoapQueue);
 
 #if OPENTHREAD_CONFIG_SECURE_TRANSPORT_ENABLE
-    Get<Tmf::SecureAgent>().GetRequestMessages().GetInfo(aInfo.mCoapSecureQueue);
-    Get<Tmf::SecureAgent>().GetCachedResponses().GetInfo(aInfo.mCoapSecureQueue);
+    Get<Tmf::SecureAgent>().GetRequestAndCachedResponsesQueueInfo(aInfo.mCoapSecureQueue);
 #endif
 
 #if OPENTHREAD_CONFIG_COAP_API_ENABLE
-    GetApplicationCoap().GetRequestMessages().GetInfo(aInfo.mApplicationCoapQueue);
-    GetApplicationCoap().GetCachedResponses().GetInfo(aInfo.mApplicationCoapQueue);
+    Get<Coap::ApplicationCoap>().GetRequestAndCachedResponsesQueueInfo(aInfo.mApplicationCoapQueue);
 #endif
 }
 
diff --git a/src/core/instance/instance.hpp b/src/core/instance/instance.hpp
index ac48d6c43..210311027 100644
--- a/src/core/instance/instance.hpp
+++ b/src/core/instance/instance.hpp
@@ -122,7 +122,6 @@
 #include "thread/link_quality.hpp"
 #include "thread/mesh_forwarder.hpp"
 #include "thread/mle.hpp"
-#include "thread/mle_router.hpp"
 #include "thread/mlr_manager.hpp"
 #include "thread/network_data_local.hpp"
 #include "thread/network_data_notifier.hpp"
@@ -354,24 +353,6 @@ public:
     static Utils::Heap &GetHeap(void);
 #endif
 
-#if OPENTHREAD_CONFIG_COAP_API_ENABLE
-    /**
-     * Returns a reference to application COAP object.
-     *
-     * @returns A reference to the application COAP object.
-     */
-    Coap::Coap &GetApplicationCoap(void) { return mApplicationCoap; }
-#endif
-
-#if OPENTHREAD_CONFIG_COAP_SECURE_API_ENABLE
-    /**
-     * Returns a reference to application COAP Secure object.
-     *
-     * @returns A reference to the application COAP Secure object.
-     */
-    Coap::ApplicationCoapSecure &GetApplicationCoapSecure(void) { return mApplicationCoapSecure; }
-#endif
-
 #if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
     /**
      * Enables/disables the "DNS name compressions" mode.
@@ -569,7 +550,7 @@ private:
     Lowpan::Lowpan                 mLowpan;
     Mac::Mac                       mMac;
     MeshForwarder                  mMeshForwarder;
-    Mle::MleRouter                 mMleRouter;
+    Mle::Mle                       mMle;
     Mle::DiscoverScanner           mDiscoverScanner;
     AddressResolver                mAddressResolver;
 
@@ -672,7 +653,7 @@ private:
 #endif
 
 #if OPENTHREAD_CONFIG_COAP_API_ENABLE
-    Coap::Coap mApplicationCoap;
+    Coap::ApplicationCoap mApplicationCoap;
 #endif
 
 #if OPENTHREAD_CONFIG_COAP_SECURE_API_ENABLE
@@ -788,24 +769,20 @@ template <> inline Crypto::Storage::KeyRefManager &Instance::Get(void) { return
 template <> inline RadioSelector &Instance::Get(void) { return mRadioSelector; }
 #endif
 
-template <> inline Mle::Mle &Instance::Get(void) { return mMleRouter; }
-
-#if OPENTHREAD_FTD
-template <> inline Mle::MleRouter &Instance::Get(void) { return mMleRouter; }
-#endif
+template <> inline Mle::Mle &Instance::Get(void) { return mMle; }
 
 template <> inline Mle::DiscoverScanner &Instance::Get(void) { return mDiscoverScanner; }
 
-template <> inline NeighborTable &Instance::Get(void) { return mMleRouter.mNeighborTable; }
+template <> inline NeighborTable &Instance::Get(void) { return mMle.mNeighborTable; }
 
 #if OPENTHREAD_FTD
-template <> inline ChildTable &Instance::Get(void) { return mMleRouter.mChildTable; }
+template <> inline ChildTable &Instance::Get(void) { return mMle.mChildTable; }
 
-template <> inline RouterTable &Instance::Get(void) { return mMleRouter.mRouterTable; }
+template <> inline RouterTable &Instance::Get(void) { return mMle.mRouterTable; }
 #endif
 
 #if OPENTHREAD_CONFIG_WAKEUP_COORDINATOR_ENABLE
-template <> inline WakeupTxScheduler &Instance::Get(void) { return mMleRouter.mWakeupTxScheduler; }
+template <> inline WakeupTxScheduler &Instance::Get(void) { return mMle.mWakeupTxScheduler; }
 #endif
 
 template <> inline Ip6::Netif &Instance::Get(void) { return mThreadNetif; }
@@ -822,6 +799,10 @@ template <> inline Mac::SubMac &Instance::Get(void) { return mMac.mLinks.mSubMac
 template <> inline Trel::Link &Instance::Get(void) { return mMac.mLinks.mTrel; }
 
 template <> inline Trel::Interface &Instance::Get(void) { return mMac.mLinks.mTrel.mInterface; }
+
+template <> inline Trel::PeerTable &Instance::Get(void) { return mMac.mLinks.mTrel.mPeerTable; }
+
+template <> inline Trel::PeerDiscoverer &Instance::Get(void) { return mMac.mLinks.mTrel.mPeerDiscoverer; }
 #endif
 
 #if OPENTHREAD_CONFIG_MAC_FILTER_ENABLE
@@ -1104,6 +1085,14 @@ template <> inline Srp::AdvertisingProxy &Instance::Get(void) { return mSrpAdver
 #endif
 #endif // OPENTHREAD_CONFIG_SRP_SERVER_ENABLE
 
+#if OPENTHREAD_CONFIG_COAP_API_ENABLE
+template <> inline Coap::ApplicationCoap &Instance::Get(void) { return mApplicationCoap; }
+#endif
+
+#if OPENTHREAD_CONFIG_COAP_SECURE_API_ENABLE
+template <> inline Coap::ApplicationCoapSecure &Instance::Get(void) { return mApplicationCoapSecure; }
+#endif
+
 #if OPENTHREAD_CONFIG_BLE_TCAT_ENABLE
 template <> inline Ble::BleSecure &Instance::Get(void) { return mApplicationBleSecure; }
 #endif
diff --git a/src/core/mac/channel_mask.hpp b/src/core/mac/channel_mask.hpp
index 983f8a784..841e5430f 100644
--- a/src/core/mac/channel_mask.hpp
+++ b/src/core/mac/channel_mask.hpp
@@ -135,7 +135,7 @@ public:
      */
     bool ContainsChannel(uint8_t aChannel) const
     {
-        return (aChannel < BitSizeOf(mMask)) ? ((1UL << aChannel) & mMask) != 0 : false;
+        return (aChannel < BitSizeOf(mMask)) ? GetBit(mMask, aChannel) : false;
     }
 
     /**
@@ -147,7 +147,7 @@ public:
     {
         if (aChannel < BitSizeOf(mMask))
         {
-            mMask |= (1UL << aChannel);
+            SetBit<uint32_t>(mMask, aChannel);
         }
     }
 
@@ -160,7 +160,7 @@ public:
     {
         if (aChannel < BitSizeOf(mMask))
         {
-            mMask &= ~(1UL << aChannel);
+            ClearBit<uint32_t>(mMask, aChannel);
         }
     }
 
diff --git a/src/core/mac/data_poll_handler.cpp b/src/core/mac/data_poll_handler.cpp
index b3d975970..e567daf9d 100644
--- a/src/core/mac/data_poll_handler.cpp
+++ b/src/core/mac/data_poll_handler.cpp
@@ -90,7 +90,7 @@ void DataPollHandler::HandleDataPoll(Mac::RxFrame &aFrame)
     uint16_t     indirectMsgCount;
 
     VerifyOrExit(aFrame.GetSecurityEnabled());
-    VerifyOrExit(!Get<Mle::MleRouter>().IsDetached());
+    VerifyOrExit(!Get<Mle::Mle>().IsDetached());
 
     SuccessOrExit(aFrame.GetSrcAddr(macSource));
     child = Get<ChildTable>().FindChild(macSource, Child::kInStateValidOrRestoring);
diff --git a/src/core/mac/data_poll_sender.cpp b/src/core/mac/data_poll_sender.cpp
index c21bbacfe..f434e4ff6 100644
--- a/src/core/mac/data_poll_sender.cpp
+++ b/src/core/mac/data_poll_sender.cpp
@@ -57,16 +57,16 @@ DataPollSender::DataPollSender(Instance &aInstance)
 
 const Neighbor &DataPollSender::GetParent(void) const
 {
-    const Neighbor &parentCandidate = Get<Mle::MleRouter>().GetParentCandidate();
+    const Neighbor &parentCandidate = Get<Mle::Mle>().GetParentCandidate();
 
-    return parentCandidate.IsStateValid() ? parentCandidate : Get<Mle::MleRouter>().GetParent();
+    return parentCandidate.IsStateValid() ? parentCandidate : Get<Mle::Mle>().GetParent();
 }
 
 void DataPollSender::StartPolling(void)
 {
     VerifyOrExit(!mEnabled);
 
-    OT_ASSERT(!Get<Mle::MleRouter>().IsRxOnWhenIdle());
+    OT_ASSERT(!Get<Mle::Mle>().IsRxOnWhenIdle());
 
     mEnabled = true;
     ScheduleNextPoll(kRecalculatePollPeriod);
@@ -136,7 +136,7 @@ Error DataPollSender::GetPollDestinationAddress(Mac::Address &aDest) const
 
     // Use extended address attaching to a new parent (i.e. parent is the parent candidate).
     if ((Get<Mac::Mac>().GetShortAddress() == Mac::kShortAddrInvalid) ||
-        (&parent == &Get<Mle::MleRouter>().GetParentCandidate()))
+        (&parent == &Get<Mle::Mle>().GetParentCandidate()))
     {
         aDest.SetExtended(parent.GetExtAddress());
     }
@@ -206,7 +206,7 @@ void DataPollSender::HandlePollSent(Mac::TxFrame &aFrame, Error aError)
     if (GetParent().IsStateInvalid())
     {
         StopPolling();
-        IgnoreError(Get<Mle::MleRouter>().BecomeDetached());
+        IgnoreError(Get<Mle::Mle>().BecomeDetached());
         ExitNow();
     }
 
@@ -328,7 +328,7 @@ void DataPollSender::ProcessTxDone(const Mac::TxFrame &aFrame, const Mac::RxFram
     bool sendDataPoll = false;
 
     VerifyOrExit(mEnabled);
-    VerifyOrExit(Get<Mle::MleRouter>().GetParent().IsEnhancedKeepAliveSupported());
+    VerifyOrExit(Get<Mle::Mle>().GetParent().IsEnhancedKeepAliveSupported());
     VerifyOrExit(aFrame.GetSecurityEnabled());
 
 #if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
@@ -522,12 +522,12 @@ uint32_t DataPollSender::GetDefaultPollPeriod(void) const
     uint32_t pollAhead = static_cast<uint32_t>(kRetxPollPeriod) * kMaxPollRetxAttempts;
     uint32_t period;
 
-    period = Time::SecToMsec(Min(Get<Mle::MleRouter>().GetTimeout(), Time::MsecToSec(TimerMilli::kMaxDelay)));
+    period = Time::SecToMsec(Min(Get<Mle::Mle>().GetTimeout(), Time::MsecToSec(TimerMilli::kMaxDelay)));
 
 #if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE && OPENTHREAD_CONFIG_MAC_CSL_AUTO_SYNC_ENABLE
     if (Get<Mac::Mac>().IsCslEnabled())
     {
-        period    = Min(period, Time::SecToMsec(Get<Mle::MleRouter>().GetCslTimeout()));
+        period    = Min(period, Time::SecToMsec(Get<Mle::Mle>().GetCslTimeout()));
         pollAhead = static_cast<uint32_t>(kRetxPollPeriod);
     }
 #endif
diff --git a/src/core/mac/mac.cpp b/src/core/mac/mac.cpp
index f58606828..d759dbf8f 100644
--- a/src/core/mac/mac.cpp
+++ b/src/core/mac/mac.cpp
@@ -83,6 +83,8 @@ Mac::Mac(Instance &aInstance)
 #endif
 #endif
 #if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
+    , mIsCslEnabled(false)
+    , mIsCslCapable(false)
     , mCslChannel(0)
     , mCslPeriod(0)
 #endif
@@ -423,6 +425,9 @@ exit:
 Error Mac::SetPanChannel(uint8_t aChannel)
 {
     Error error = kErrorNone;
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
+    bool isPanChannelChanged = (mPanChannel != aChannel);
+#endif
 
     VerifyOrExit(mSupportedChannelMask.ContainsChannel(aChannel), error = kErrorInvalidArgs);
 
@@ -435,7 +440,10 @@ Error Mac::SetPanChannel(uint8_t aChannel)
     mRadioChannel = mPanChannel;
 
 #if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
-    UpdateCsl();
+    if ((mCslChannel == 0) && isPanChannelChanged)
+    {
+        UpdateCslParameters();
+    }
 #endif
 
     UpdateIdleMode();
@@ -1871,7 +1879,7 @@ void Mac::HandleReceivedFrame(RxFrame *aFrame, Error aError)
 
 #if OPENTHREAD_FTD
         // Allow multicasts from neighbor routers if FTD
-        if (neighbor == nullptr && dstaddr.IsBroadcast() && Get<Mle::MleRouter>().IsFullThreadDevice())
+        if (neighbor == nullptr && dstaddr.IsBroadcast() && Get<Mle::Mle>().IsFullThreadDevice())
         {
             neighbor = Get<NeighborTable>().FindRxOnlyNeighborRouter(srcaddr);
         }
@@ -2423,36 +2431,32 @@ exit:
 #endif
 
 #if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
-void Mac::UpdateCsl(void)
+void Mac::SetCslCapable(bool aIsCslCapable)
 {
-    uint16_t period  = IsCslEnabled() ? GetCslPeriod() : 0;
-    uint8_t  channel = GetCslChannel() ? GetCslChannel() : mRadioChannel;
+    VerifyOrExit(mIsCslCapable != aIsCslCapable);
+    mIsCslCapable = aIsCslCapable;
+    UpdateCslState();
 
-    if (mLinks.UpdateCsl(period, channel, Get<Mle::Mle>().GetParent().GetRloc16(),
-                         Get<Mle::Mle>().GetParent().GetExtAddress()))
-    {
-        if (Get<Mle::Mle>().IsChild())
-        {
-            Get<DataPollSender>().RecalculatePollPeriod();
-
-            if (period != 0)
-            {
-                Get<Mle::Mle>().ScheduleChildUpdateRequest();
-            }
-        }
-
-        UpdateIdleMode();
-    }
+exit:
+    return;
 }
 
 void Mac::SetCslChannel(uint8_t aChannel)
 {
+    VerifyOrExit(mCslChannel != aChannel);
     mCslChannel = aChannel;
-    UpdateCsl();
+    UpdateCslParameters();
+
+exit:
+    return;
 }
 
 void Mac::SetCslPeriod(uint16_t aPeriod)
 {
+    bool shouldUpdateCslState;
+
+    VerifyOrExit(mCslPeriod != aPeriod);
+
 #if OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE
     if (IsWakeupListenEnabled() && aPeriod != 0)
     {
@@ -2461,27 +2465,80 @@ void Mac::SetCslPeriod(uint16_t aPeriod)
     }
 #endif
 
-    mCslPeriod = aPeriod;
-    UpdateCsl();
+    // A CSL period value of 0 means that the CSL is disabled.
+    shouldUpdateCslState = ((mCslPeriod == 0) != (aPeriod == 0));
+    mCslPeriod           = aPeriod;
+
+    if (shouldUpdateCslState)
+    {
+        UpdateCslState();
+    }
+    else
+    {
+        UpdateCslParameters();
+    }
+
+exit:
+    return;
 }
 
-uint32_t Mac::GetCslPeriodInMsec(void) const
+void Mac::UpdateCslState(void)
 {
-    return DivideAndRoundToClosest<uint32_t>(CslPeriodToUsec(GetCslPeriod()), 1000u);
+    // This method will enable/disable CSL when the CSL state (enabled/disabled) is changed. Otherwise, nothing to do.
+    bool isCslEnabled = mIsCslCapable && (mCslPeriod > 0);
+
+    VerifyOrExit(mIsCslEnabled != isCslEnabled);
+
+    mIsCslEnabled = isCslEnabled;
+
+    if (mIsCslEnabled)
+    {
+        UpdateCslParameters();
+        // Request the Mac to enter sleep state.
+        UpdateIdleMode();
+    }
+    else
+    {
+        // The platform API `otPlatRadioEnableCsl()` description says that disable CSL by setting the CSL period to 0.
+        // However, this description does not say whether the parameter `aExtAddr` can be set to nullptr or how to set
+        // the `aExtAddr` when the CSL is disabled. Here, an empty ExtAddress is set to meet the API requirement.
+        ExtAddress extAddress;
+
+        extAddress.Fill(0);
+        mLinks.SetCslParams(0, 0, kShortAddrInvalid, extAddress);
+    }
+
+    LogInfo("CSL receiver is %s", mIsCslEnabled ? "enabled" : "disabled");
+
+exit:
+    return;
 }
 
-uint32_t Mac::CslPeriodToUsec(uint16_t aPeriodInTenSymbols)
+void Mac::UpdateCslParameters(void)
 {
-    return static_cast<uint32_t>(aPeriodInTenSymbols) * kUsPerTenSymbols;
-}
+    // This method will set all CSL parameters when the CSL is enabled. Otherwise, nothing to do.
+    uint8_t cslChannel;
+
+    VerifyOrExit(mIsCslEnabled);
 
-bool Mac::IsCslEnabled(void) const { return !Get<Mle::Mle>().IsRxOnWhenIdle() && IsCslCapable(); }
+    cslChannel = GetCslChannel() ? GetCslChannel() : mPanChannel;
+    mLinks.SetCslParams(GetCslPeriod(), cslChannel, Get<Mle::Mle>().GetParent().GetRloc16(),
+                        Get<Mle::Mle>().GetParent().GetExtAddress());
+    Get<DataPollSender>().RecalculatePollPeriod();
+    Get<Mle::Mle>().ScheduleChildUpdateRequest();
+
+exit:
+    return;
+}
 
-bool Mac::IsCslCapable(void) const { return (GetCslPeriod() > 0) && IsCslSupported(); }
+uint32_t Mac::GetCslPeriodInMsec(void) const
+{
+    return DivideAndRoundToClosest<uint32_t>(CslPeriodToUsec(GetCslPeriod()), 1000u);
+}
 
-bool Mac::IsCslSupported(void) const
+uint32_t Mac::CslPeriodToUsec(uint16_t aPeriodInTenSymbols)
 {
-    return Get<Mle::MleRouter>().IsChild() && Get<Mle::Mle>().GetParent().IsEnhancedKeepAliveSupported();
+    return static_cast<uint32_t>(aPeriodInTenSymbols) * kUsPerTenSymbols;
 }
 #endif // OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
 
diff --git a/src/core/mac/mac.hpp b/src/core/mac/mac.hpp
index 109bbbb65..ec79e9f69 100644
--- a/src/core/mac/mac.hpp
+++ b/src/core/mac/mac.hpp
@@ -581,9 +581,12 @@ public:
     void SetCslChannel(uint8_t aChannel);
 
     /**
-     * Centralizes CSL state switching conditions evaluating, configuring SubMac accordingly.
+     * Sets whether the MLE layer is capable of starting CSL.
+     *
+     * @retval TRUE   If MLE layer is capable of starting CSL.
+     * @retval FALSE  If MLE layer is not capable of starting CSL.
      */
-    void UpdateCsl(void);
+    void SetCslCapable(bool aIsCslCapable);
 
     /**
      * Gets the CSL period.
@@ -624,23 +627,7 @@ public:
      * @retval TRUE   If CSL is enabled.
      * @retval FALSE  If CSL is not enabled.
      */
-    bool IsCslEnabled(void) const;
-
-    /**
-     * Indicates whether Link is capable of starting CSL.
-     *
-     * @retval TRUE   If Link is capable of starting CSL.
-     * @retval FALSE  If link is not capable of starting CSL.
-     */
-    bool IsCslCapable(void) const;
-
-    /**
-     * Indicates whether the device is connected to a parent which supports CSL.
-     *
-     * @retval TRUE   If parent supports CSL.
-     * @retval FALSE  If parent does not support CSL.
-     */
-    bool IsCslSupported(void) const;
+    bool IsCslEnabled(void) const { return mIsCslEnabled; }
 
     /**
      * Returns parent CSL accuracy (clock accuracy and uncertainty).
@@ -870,6 +857,10 @@ private:
 #if OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE
     void ProcessCsl(const RxFrame &aFrame, const Address &aSrcAddr);
 #endif
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
+    void UpdateCslParameters(void);
+    void UpdateCslState(void);
+#endif
 #if OPENTHREAD_CONFIG_MLE_LINK_METRICS_INITIATOR_ENABLE
     void ProcessEnhAckProbing(const RxFrame &aFrame, const Neighbor &aNeighbor);
 #endif
@@ -917,6 +908,8 @@ private:
     TimeMilli mCslTxFireTime;
 #endif
 #if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
+    bool mIsCslEnabled : 1;
+    bool mIsCslCapable : 1;
     // When Mac::mCslChannel is 0, it indicates that CSL channel has not been specified by the upper layer.
     uint8_t  mCslChannel;
     uint16_t mCslPeriod;
diff --git a/src/core/mac/mac_frame.cpp b/src/core/mac/mac_frame.cpp
index 1bcdc20a4..01266213e 100644
--- a/src/core/mac/mac_frame.cpp
+++ b/src/core/mac/mac_frame.cpp
@@ -1336,9 +1336,7 @@ void TxFrame::CopyFrom(const TxFrame &aFromFrame)
 
 void TxFrame::ProcessTransmitAesCcm(const ExtAddress &aExtAddress)
 {
-#if OPENTHREAD_RADIO && !OPENTHREAD_CONFIG_MAC_SOFTWARE_TX_SECURITY_ENABLE
-    OT_UNUSED_VARIABLE(aExtAddress);
-#else
+#if OPENTHREAD_FTD || OPENTHREAD_MTD || OPENTHREAD_CONFIG_MAC_SOFTWARE_TX_SECURITY_ENABLE
     uint32_t       frameCounter = 0;
     uint8_t        securityLevel;
     uint8_t        nonce[Crypto::AesCcm::kNonceSize];
@@ -1364,7 +1362,9 @@ void TxFrame::ProcessTransmitAesCcm(const ExtAddress &aExtAddress)
 
 exit:
     return;
-#endif // OPENTHREAD_RADIO && !OPENTHREAD_CONFIG_MAC_SOFTWARE_TX_SECURITY_ENABLE
+#else
+    OT_UNUSED_VARIABLE(aExtAddress);
+#endif // OPENTHREAD_FTD || OPENTHREAD_MTD || OPENTHREAD_CONFIG_MAC_SOFTWARE_TX_SECURITY_ENABLE
 }
 
 void TxFrame::GenerateImmAck(const RxFrame &aFrame, bool aIsFramePending)
@@ -1512,12 +1512,7 @@ exit:
 
 Error RxFrame::ProcessReceiveAesCcm(const ExtAddress &aExtAddress, const KeyMaterial &aMacKey)
 {
-#if OPENTHREAD_RADIO
-    OT_UNUSED_VARIABLE(aExtAddress);
-    OT_UNUSED_VARIABLE(aMacKey);
-
-    return kErrorNone;
-#else
+#if OPENTHREAD_FTD || OPENTHREAD_MTD
     Error          error        = kErrorSecurity;
     uint32_t       frameCounter = 0;
     uint8_t        securityLevel;
@@ -1555,7 +1550,12 @@ Error RxFrame::ProcessReceiveAesCcm(const ExtAddress &aExtAddress, const KeyMate
 
 exit:
     return error;
-#endif // OPENTHREAD_RADIO
+#else
+    OT_UNUSED_VARIABLE(aExtAddress);
+    OT_UNUSED_VARIABLE(aMacKey);
+
+    return kErrorNone;
+#endif // OPENTHREAD_FTD || OPENTHREAD_MTD
 }
 
 // LCOV_EXCL_START
diff --git a/src/core/mac/mac_header_ie.hpp b/src/core/mac/mac_header_ie.hpp
index 7948429a6..a7e60f133 100644
--- a/src/core/mac/mac_header_ie.hpp
+++ b/src/core/mac/mac_header_ie.hpp
@@ -75,32 +75,28 @@ public:
      *
      * @returns the IE Element Id.
      */
-    uint16_t GetId(void) const { return (LittleEndian::HostSwap16(mFields.m16) & kIdMask) >> kIdOffset; }
+    uint16_t GetId(void) const { return ReadBitsLittleEndian<uint16_t, kIdMask>(mFields.m16); }
 
     /**
      * Sets the IE Element Id.
      *
      * @param[in]  aId  The IE Element Id.
      */
-    void SetId(uint16_t aId)
-    {
-        mFields.m16 = LittleEndian::HostSwap16((LittleEndian::HostSwap16(mFields.m16) & ~kIdMask) |
-                                               ((aId << kIdOffset) & kIdMask));
-    }
+    void SetId(uint16_t aId) { mFields.m16 = UpdateBitsLittleEndian<uint16_t, kIdMask>(mFields.m16, aId); }
 
     /**
      * Returns the IE content length.
      *
      * @returns the IE content length.
      */
-    uint8_t GetLength(void) const { return mFields.m8[0] & kLengthMask; }
+    uint8_t GetLength(void) const { return ReadBits<uint8_t, kLengthMask>(mFields.m8[0]); }
 
     /**
      * Sets the IE content length.
      *
      * @param[in]  aLength  The IE content length.
      */
-    void SetLength(uint8_t aLength) { mFields.m8[0] = (mFields.m8[0] & ~kLengthMask) | (aLength & kLengthMask); }
+    void SetLength(uint8_t aLength) { WriteBits<uint8_t, kLengthMask>(mFields.m8[0], aLength); }
 
 private:
     // Header IE format:
@@ -351,7 +347,7 @@ public:
      *
      * @returns the Retry Interval in the units of Wake-up Intervals (7.5ms by default).
      */
-    uint8_t GetRetryInterval(void) const { return (mConnectionWindow & kRetryIntervalMask) >> kRetryIntervalOffset; }
+    uint8_t GetRetryInterval(void) const { return ReadBits<uint8_t, kRetryIntervalMask>(mConnectionWindow); }
 
     /**
      * Sets the Retry Interval.
@@ -360,7 +356,7 @@ public:
      */
     void SetRetryInterval(uint8_t aRetryInterval)
     {
-        mConnectionWindow = (aRetryInterval << kRetryIntervalOffset) | (mConnectionWindow & ~kRetryIntervalMask);
+        WriteBits<uint8_t, kRetryIntervalMask>(mConnectionWindow, aRetryInterval);
     }
 
     /**
@@ -371,17 +367,14 @@ public:
      *
      * @returns the Retry Count.
      */
-    uint8_t GetRetryCount(void) const { return mConnectionWindow & kRetryCountMask; }
+    uint8_t GetRetryCount(void) const { return ReadBits<uint8_t, kRetryCountMask>(mConnectionWindow); }
 
     /**
      * Sets the Retry Count
      *
      * @param[in]  aRetryCount  The Retry Count.
      */
-    void SetRetryCount(uint8_t aRetryCount)
-    {
-        mConnectionWindow = aRetryCount | (mConnectionWindow & ~kRetryCountMask);
-    }
+    void SetRetryCount(uint8_t aRetryCount) { WriteBits<uint8_t, kRetryCountMask>(mConnectionWindow, aRetryCount); }
 
 private:
     static constexpr uint8_t kRetryIntervalOffset = 4;
diff --git a/src/core/mac/mac_links.hpp b/src/core/mac/mac_links.hpp
index 592d48e0b..ac668bec3 100644
--- a/src/core/mac/mac_links.hpp
+++ b/src/core/mac/mac_links.hpp
@@ -461,28 +461,22 @@ public:
 
 #if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
     /**
-     * Configures CSL parameters in all radios.
+     * Sets CSL parameters in all radios.
      *
      * @param[in]  aPeriod    The CSL period.
      * @param[in]  aChannel   The CSL channel.
      * @param[in]  aShortAddr The short source address of CSL receiver's peer.
      * @param[in]  aExtAddr   The extended source address of CSL receiver's peer.
-     *
-     * @retval  TRUE if CSL Period or CSL Channel changed.
-     * @retval  FALSE if CSL Period and CSL Channel did not change.
      */
-    bool UpdateCsl(uint16_t aPeriod, uint8_t aChannel, ShortAddress aShortAddr, const ExtAddress &aExtAddr)
+    void SetCslParams(uint16_t aPeriod, uint8_t aChannel, ShortAddress aShortAddr, const ExtAddress &aExtAddr)
     {
-        bool retval = false;
-
         OT_UNUSED_VARIABLE(aPeriod);
         OT_UNUSED_VARIABLE(aChannel);
         OT_UNUSED_VARIABLE(aShortAddr);
         OT_UNUSED_VARIABLE(aExtAddr);
 #if OPENTHREAD_CONFIG_RADIO_LINK_IEEE_802_15_4_ENABLE
-        retval = mSubMac.UpdateCsl(aPeriod, aChannel, aShortAddr, aExtAddr);
+        mSubMac.SetCslParams(aPeriod, aChannel, aShortAddr, aExtAddr);
 #endif
-        return retval;
     }
 #endif // OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
 
diff --git a/src/core/mac/mac_types.cpp b/src/core/mac/mac_types.cpp
index fdfa2ad84..9944623c4 100644
--- a/src/core/mac/mac_types.cpp
+++ b/src/core/mac/mac_types.cpp
@@ -38,6 +38,9 @@
 #include "common/code_utils.hpp"
 #include "common/random.hpp"
 #include "common/string.hpp"
+#if OPENTHREAD_FTD || OPENTHREAD_MTD
+#include "net/ip6_address.hpp"
+#endif
 
 namespace ot {
 namespace Mac {
@@ -55,12 +58,20 @@ PanId GenerateRandomPanId(void)
 }
 
 #if OPENTHREAD_FTD || OPENTHREAD_MTD
+
 void ExtAddress::GenerateRandom(void)
 {
     IgnoreError(Random::Crypto::Fill(*this));
     SetGroup(false);
     SetLocal(true);
 }
+
+void ExtAddress::SetFromIid(const Ip6::InterfaceIdentifier &aIid)
+{
+    Set(aIid.GetBytes());
+    ToggleLocal();
+}
+
 #endif
 
 bool ExtAddress::operator==(const ExtAddress &aOther) const { return (memcmp(m8, aOther.m8, sizeof(m8)) == 0); }
@@ -92,6 +103,14 @@ void ExtAddress::CopyAddress(uint8_t *aDst, const uint8_t *aSrc, CopyByteOrder a
     }
 }
 
+#if OPENTHREAD_FTD || OPENTHREAD_MTD
+void Address::SetExtendedFromIid(const Ip6::InterfaceIdentifier &aIid)
+{
+    mShared.mExtAddress.SetFromIid(aIid);
+    mType = kTypeExtended;
+}
+#endif
+
 bool Address::operator==(const Address &aOther) const
 {
     bool ret = false;
diff --git a/src/core/mac/mac_types.hpp b/src/core/mac/mac_types.hpp
index efa0455b5..e7b2a59b6 100644
--- a/src/core/mac/mac_types.hpp
+++ b/src/core/mac/mac_types.hpp
@@ -50,6 +50,13 @@
 #include "crypto/storage.hpp"
 
 namespace ot {
+
+#if OPENTHREAD_FTD || OPENTHREAD_MTD
+namespace Ip6 {
+class InterfaceIdentifier;
+}
+#endif
+
 namespace Mac {
 
 /**
@@ -115,6 +122,13 @@ public:
      * Generates a random IEEE 802.15.4 Extended Address.
      */
     void GenerateRandom(void);
+
+    /**
+     * Sets the Extended Address from a given IPv6 Address Interface Identifier.
+     *
+     * @param[in] aIid   The IPv6 Interface Identifier to convert to Extended Address.
+     */
+    void SetFromIid(const Ip6::InterfaceIdentifier &aIid);
 #endif
 
     /**
@@ -356,6 +370,15 @@ public:
         mType = kTypeExtended;
     }
 
+#if OPENTHREAD_FTD || OPENTHREAD_MTD
+    /**
+     * Sets the address as an Extended Address from a given IPv6 Address Interface Identifier.
+     *
+     * @param[in] aIid   The IPv6 Interface Identifier to convert to Extended Address.
+     */
+    void SetExtendedFromIid(const Ip6::InterfaceIdentifier &aIid);
+#endif
+
     /**
      * Indicates whether or not the address is a Short Broadcast Address.
      *
diff --git a/src/core/mac/sub_mac.cpp b/src/core/mac/sub_mac.cpp
index ff1172b8f..9d4bf8e4c 100644
--- a/src/core/mac/sub_mac.cpp
+++ b/src/core/mac/sub_mac.cpp
@@ -240,10 +240,10 @@ Error SubMac::Sleep(void)
 {
     Error error = kErrorNone;
 
-#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
-    if (IsCslEnabled())
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE || OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE
+    if (IsRadioSampleEnabled())
     {
-        CslSample();
+        RadioSample();
     }
     else
 #endif
@@ -343,8 +343,8 @@ Error SubMac::Send(void)
 #endif
     case kStateSleep:
     case kStateReceive:
-#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
-    case kStateCslSample:
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE || OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE
+    case kStateRadioSample:
 #endif
         break;
 
@@ -721,8 +721,8 @@ Error SubMac::EnergyScan(uint8_t aScanChannel, uint16_t aScanDuration)
 
     case kStateReceive:
     case kStateSleep:
-#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
-    case kStateCslSample:
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE || OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE
+    case kStateRadioSample:
 #endif
         break;
     }
@@ -1029,6 +1029,99 @@ void SubMac::StartTimerAt(Time aStartTime, uint32_t aDelayUs)
 #endif
 }
 
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE || OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE
+void SubMac::RadioSample(void)
+{
+#if OPENTHREAD_CONFIG_MAC_FILTER_ENABLE
+    VerifyOrExit(!mRadioFilterEnabled, IgnoreError(Get<Radio>().Sleep()));
+#endif
+
+    SetState(kStateRadioSample);
+
+    if (!RadioSupportsReceiveTiming())
+    {
+        UpdateRadioSampleState();
+    }
+
+#if OPENTHREAD_CONFIG_MAC_FILTER_ENABLE
+exit:
+#endif
+    return;
+}
+
+bool SubMac::IsRadioSampleEnabled(void) const
+{
+    bool ret = false;
+
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
+    ret = IsCslEnabled();
+#endif
+
+#if OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE
+    ret = ret || mIsWedEnabled;
+#endif
+
+    return ret;
+}
+
+/*
+ * The radio state (receive/sleep) is determined by the request from both CSL and WED:
+ * 1. If both CSL and WED request to enter sleep state, the radio is set to sleep state.
+ * 2. If either CSL or WED requests to enter the receive state and the other requests to enter sleep state, the radio
+ *    is set to receive state using the channel that is requested to enter the receive state.
+ * 3. If both CSL and WED request to enter the receive state, the radio is set to the receive state using the CSL
+ *    channel.
+ *
+ * The diagram below illustrates how to set the radio state based on the request of WED and CSL.
+ *
+ * CSL   ------========------------========------------========------------========---
+ *             ^       ^
+ *             |       |
+ *             | mIsCslSampling=false
+ *     mIsCslSampling=true
+ *
+ * WED   -----------++++++++----------------++++++++----------------++++++++----------
+ *                  ^       ^
+ *                  |       |
+ *                  | mIsWedSampling=false
+ *         mIsWedSampling=true
+ *
+ * Radio ------========+++++-------========-++++++++---========-----+++++++========---
+ *             ^       ^    ^
+ *             |       |    |
+ *             |       | Radio::Sleep()
+ *             |  Radio::Receive(WedCh)
+ *      Radio::Receive(CslCh)
+ */
+void SubMac::UpdateRadioSampleState(void)
+{
+    VerifyOrExit(mState == kStateRadioSample);
+
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
+    if (mIsCslSampling)
+    {
+        IgnoreError(Get<Radio>().Receive(mCslChannel));
+        ExitNow();
+    }
+#endif
+
+#if OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE
+    if (mIsWedSampling)
+    {
+        IgnoreError(Get<Radio>().Receive(mWakeupChannel));
+        ExitNow();
+    }
+#endif
+
+#if !OPENTHREAD_CONFIG_MAC_CSL_DEBUG_ENABLE
+    IgnoreError(Get<Radio>().Sleep()); // Don't actually sleep for debugging
+#endif
+
+exit:
+    return;
+}
+#endif // OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE || OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE
+
 // LCOV_EXCL_START
 
 const char *SubMac::StateToString(State aState)
@@ -1046,8 +1139,8 @@ const char *SubMac::StateToString(State aState)
 #if !OPENTHREAD_MTD && OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE
         "CslTransmit", // (7) kStateCslTransmit
 #endif
-#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
-        "CslSample", // (8) kStateCslSample
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE || OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE
+        "RadioSample", // (8) kStateRadioSample
 #endif
     };
 
@@ -1067,8 +1160,8 @@ const char *SubMac::StateToString(State aState)
 #if !OPENTHREAD_MTD && OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE
         ValidateNextEnum(kStateCslTransmit);
 #endif
-#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
-        ValidateNextEnum(kStateCslSample);
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE || OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE
+        ValidateNextEnum(kStateRadioSample);
 #endif
     };
 
diff --git a/src/core/mac/sub_mac.hpp b/src/core/mac/sub_mac.hpp
index 2e2ee8947..6cab2ce06 100644
--- a/src/core/mac/sub_mac.hpp
+++ b/src/core/mac/sub_mac.hpp
@@ -295,9 +295,11 @@ public:
     Error Disable(void);
 
     /**
-     * Transitions the radio to Sleep.
+     * Request radio to transition to sleep state.
      *
-     * @retval kErrorNone          Successfully transitioned to Sleep.
+     * The `SubMac` layer may enter `Receive()` state when the CSL receiver is enabled.
+     *
+     * @retval kErrorNone          Successfully transitioned to Sleep or the radio is handled by the CSL receiver.
      * @retval kErrorBusy          The radio was transmitting.
      * @retval kErrorInvalidState  The radio was disabled.
      */
@@ -376,17 +378,14 @@ public:
 
 #if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
     /**
-     * Configures CSL parameters in 'SubMac'.
+     * Sets CSL parameters in 'SubMac'.
      *
-     * @param[in]  aPeriod    The CSL period (in unit of 10 symbols).
+     * @param[in]  aPeriod    The CSL period (in unit of 10 symbols), 0 for disabling CSL receiver.
      * @param[in]  aChannel   The CSL channel.
      * @param[in]  aShortAddr The short source address of CSL receiver's peer.
      * @param[in]  aExtAddr   The extended source address of CSL receiver's peer.
-     *
-     * @retval  TRUE if CSL Period or CSL Channel changed.
-     * @retval  FALSE if CSL Period and CSL Channel did not change.
      */
-    bool UpdateCsl(uint16_t aPeriod, uint8_t aChannel, ShortAddress aShortAddr, const ExtAddress &aExtAddr);
+    void SetCslParams(uint16_t aPeriod, uint8_t aChannel, ShortAddress aShortAddr, const ExtAddress &aExtAddr);
 
     /**
      * Returns parent CSL accuracy (clock accuracy and uncertainty).
@@ -502,7 +501,6 @@ public:
 private:
 #if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
     void        CslInit(void);
-    void        CslSample(void);
     void        UpdateCslLastSyncTimestamp(TxFrame &aFrame, RxFrame *aAckFrame);
     void        UpdateCslLastSyncTimestamp(RxFrame *aFrame, Error aError);
     static void HandleCslTimer(Timer &aTimer);
@@ -521,6 +519,8 @@ private:
     void        WedInit(void);
     static void HandleWedTimer(Timer &aTimer);
     void        HandleWedTimer(void);
+    void        HandleWedReceiveAt(void);
+    void        HandleWedReceiveOrSleep(void);
 #endif
 
     static constexpr uint8_t  kCsmaMinBe         = 3;                  // macMinBE (IEEE 802.15.4-2006).
@@ -554,8 +554,9 @@ private:
 #if !OPENTHREAD_MTD && OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE
         kStateCslTransmit, // CSL transmission.
 #endif
-#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
-        kStateCslSample, // CSL receive.
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE || OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE
+        kStateRadioSample, // Mac layer has requested the SubMac to enter sleep state, but the SubMac is in the periodic
+                           // sample state.
 #endif
     };
 
@@ -629,6 +630,12 @@ private:
     void               SetState(State aState);
     static const char *StateToString(State aState);
 
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE || OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE
+    bool IsRadioSampleEnabled(void) const;
+    void UpdateRadioSampleState(void);
+    void RadioSample(void);
+#endif
+
     using SubMacTimer =
 #if OPENTHREAD_CONFIG_PLATFORM_USEC_TIMER_ENABLE
         TimerMicroIn<SubMac, &SubMac::HandleTimer>;
@@ -663,18 +670,22 @@ private:
     SubMacTimer mTimer;
 
 #if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
-    uint16_t mCslPeriod;            // The CSL sample period, in units of 10 symbols (160 microseconds).
-    uint8_t  mCslChannel : 7;       // The CSL sample channel.
-    bool     mIsCslSampling : 1;    // Indicates that the radio is receiving in CSL state for platforms not supporting
-                                    // delayed reception.
-    uint16_t    mCslPeerShort;      // The CSL peer short address.
-    TimeMicro   mCslSampleTime;     // The CSL sample time of the current period relative to the local radio clock.
-    TimeMicro   mCslLastSync;       // The timestamp of the last successful CSL synchronization.
-    CslAccuracy mCslParentAccuracy; // The parent's CSL accuracy (clock accuracy and uncertainty).
+    uint16_t mCslPeriod;             // The CSL sample period, in units of 10 symbols (160 microseconds).
+    uint8_t  mCslChannel : 7;        // The CSL sample channel.
+    bool     mIsCslSampling : 1;     // Indicates that the current time is in CSL sample window
+                                     // for platforms not supporting `Radio::ReceiveAt()`.
+    uint16_t    mCslPeerShort;       // The CSL peer short address.
+    uint32_t    mCslSampleTimeRadio; // The CSL sample time of the current period based on radio time (lower 32-bit).
+    TimeMicro   mCslSampleTimeLocal; // The CSL sample time of the current period based on local time.
+    TimeMicro   mCslLastSync;        // The timestamp of the last successful CSL synchronization.
+    CslAccuracy mCslParentAccuracy;  // The parent's CSL accuracy (clock accuracy and uncertainty).
     TimerMicro  mCslTimer;
 #endif
 
 #if OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE
+    bool mIsWedSampling : 1;          // Indicates that the current time is in WED's sample window
+                                      // for platforms not supporting `Radio::ReceiveAt()`.
+    bool       mIsWedEnabled : 1;     // Indicates if the WED is enabled.
     uint32_t   mWakeupListenInterval; // The wake-up listen interval, in microseconds.
     uint32_t   mWakeupListenDuration; // The wake-up listen duration, in microseconds.
     uint8_t    mWakeupChannel;        // The wake-up sample channel.
diff --git a/src/core/mac/sub_mac_csl_receiver.cpp b/src/core/mac/sub_mac_csl_receiver.cpp
index f0b83659f..9a7b94b1c 100644
--- a/src/core/mac/sub_mac_csl_receiver.cpp
+++ b/src/core/mac/sub_mac_csl_receiver.cpp
@@ -44,12 +44,13 @@ RegisterLogModule("SubMac");
 
 void SubMac::CslInit(void)
 {
-    mCslPeriod     = 0;
-    mCslChannel    = 0;
-    mCslPeerShort  = 0;
-    mIsCslSampling = false;
-    mCslSampleTime = TimeMicro{0};
-    mCslLastSync   = TimeMicro{0};
+    mCslPeriod          = 0;
+    mCslChannel         = 0;
+    mCslPeerShort       = 0;
+    mIsCslSampling      = false;
+    mCslSampleTimeRadio = 0;
+    mCslSampleTimeLocal.SetValue(0);
+    mCslLastSync.SetValue(0);
     mCslTimer.Stop();
 }
 
@@ -85,29 +86,7 @@ exit:
     return;
 }
 
-void SubMac::CslSample(void)
-{
-#if OPENTHREAD_CONFIG_MAC_FILTER_ENABLE
-    VerifyOrExit(!mRadioFilterEnabled, IgnoreError(Get<Radio>().Sleep()));
-#endif
-
-    SetState(kStateCslSample);
-
-    if (mIsCslSampling && !RadioSupportsReceiveTiming())
-    {
-        IgnoreError(Get<Radio>().Receive(mCslChannel));
-        ExitNow();
-    }
-
-#if !OPENTHREAD_CONFIG_MAC_CSL_DEBUG_ENABLE
-    IgnoreError(Get<Radio>().Sleep()); // Don't actually sleep for debugging
-#endif
-
-exit:
-    return;
-}
-
-bool SubMac::UpdateCsl(uint16_t aPeriod, uint8_t aChannel, ShortAddress aShortAddr, const ExtAddress &aExtAddr)
+void SubMac::SetCslParams(uint16_t aPeriod, uint8_t aChannel, ShortAddress aShortAddr, const ExtAddress &aExtAddr)
 {
     bool diffPeriod  = aPeriod != mCslPeriod;
     bool diffChannel = aChannel != mCslChannel;
@@ -118,20 +97,27 @@ bool SubMac::UpdateCsl(uint16_t aPeriod, uint8_t aChannel, ShortAddress aShortAd
     mCslChannel = aChannel;
 
     VerifyOrExit(diffPeriod || diffPeer);
-    mCslPeriod    = aPeriod;
     mCslPeerShort = aShortAddr;
     IgnoreError(Get<Radio>().EnableCsl(aPeriod, aShortAddr, aExtAddr));
 
+    mIsCslSampling = false;
+    mCslPeriod     = aPeriod;
+
     mCslTimer.Stop();
     if (mCslPeriod > 0)
     {
-        mCslSampleTime = TimeMicro(static_cast<uint32_t>(Get<Radio>().GetNow()));
-        mIsCslSampling = false;
+        mCslSampleTimeRadio = static_cast<uint32_t>(Get<Radio>().GetNow());
+        mCslSampleTimeLocal = TimerMicro::GetNow();
+
         HandleCslTimer();
     }
+    else if (!RadioSupportsReceiveTiming())
+    {
+        UpdateRadioSampleState();
+    }
 
 exit:
-    return retval;
+    return;
 }
 
 void SubMac::HandleCslTimer(Timer &aTimer) { aTimer.Get<SubMac>().HandleCslTimer(); }
@@ -173,13 +159,15 @@ void SubMac::HandleCslReceiveAt(uint32_t aTimeAhead, uint32_t aTimeAfter)
     uint32_t winStart;
     uint32_t winDuration;
 
-    mCslTimer.FireAt(mCslSampleTime - aTimeAhead + periodUs);
+    mCslTimer.FireAt(mCslSampleTimeLocal - aTimeAhead + periodUs);
     aTimeAhead -= kCslReceiveTimeAhead;
-    winStart    = mCslSampleTime.GetValue() - aTimeAhead;
+    winStart    = mCslSampleTimeRadio - aTimeAhead;
     winDuration = aTimeAhead + aTimeAfter;
-    mCslSampleTime += periodUs;
 
-    Get<Radio>().UpdateCslSampleTime(mCslSampleTime.GetValue());
+    mCslSampleTimeRadio += periodUs;
+    mCslSampleTimeLocal += periodUs;
+
+    Get<Radio>().UpdateCslSampleTime(mCslSampleTimeRadio);
 
     // Schedule reception window for any state except RX - so that CSL RX Window has lower priority
     // than scanning or RX after the data poll.
@@ -208,12 +196,9 @@ void SubMac::HandleCslReceiveOrSleep(uint32_t aTimeAhead, uint32_t aTimeAfter)
     if (mIsCslSampling)
     {
         mIsCslSampling = false;
-        mCslTimer.FireAt(mCslSampleTime - aTimeAhead);
-        if (mState == kStateCslSample)
+        mCslTimer.FireAt(mCslSampleTimeLocal - aTimeAhead);
+        if (mState == kStateRadioSample)
         {
-#if !OPENTHREAD_CONFIG_MAC_CSL_DEBUG_ENABLE
-            IgnoreError(Get<Radio>().Sleep()); // Don't actually sleep for debugging
-#endif
             LogDebg("CSL sleep %lu", ToUlong(mCslTimer.GetNow().GetValue()));
         }
     }
@@ -223,20 +208,20 @@ void SubMac::HandleCslReceiveOrSleep(uint32_t aTimeAhead, uint32_t aTimeAfter)
         uint32_t winStart;
         uint32_t winDuration;
 
-        mCslTimer.FireAt(mCslSampleTime + aTimeAfter);
+        mCslTimer.FireAt(mCslSampleTimeLocal + aTimeAfter);
         mIsCslSampling = true;
         winStart       = TimerMicro::GetNow().GetValue();
         winDuration    = aTimeAhead + aTimeAfter;
-        mCslSampleTime += periodUs;
 
-        Get<Radio>().UpdateCslSampleTime(mCslSampleTime.GetValue());
-        if (mState == kStateCslSample)
-        {
-            IgnoreError(Get<Radio>().Receive(mCslChannel));
-        }
+        mCslSampleTimeRadio += periodUs;
+        mCslSampleTimeLocal += periodUs;
+
+        Get<Radio>().UpdateCslSampleTime(mCslSampleTimeRadio);
 
         LogCslWindow(winStart, winDuration);
     }
+
+    UpdateRadioSampleState();
 }
 
 void SubMac::GetCslWindowEdges(uint32_t &aAhead, uint32_t &aAfter)
@@ -307,13 +292,13 @@ void SubMac::LogReceived(RxFrame *aFrame)
             mIsCslSampling ? "CslSample" : "CslSleep",
             ToUlong(static_cast<uint32_t>(aFrame->mInfo.mRxInfo.mTimestamp)));
 
-    VerifyOrExit(mState == kStateCslSample);
+    VerifyOrExit(mState == kStateRadioSample);
 
     GetCslWindowEdges(ahead, after);
     ahead -= kMinReceiveOnAhead + kCslReceiveTimeAhead;
 
-    sampleTime = mCslSampleTime.GetValue() - mCslPeriod * kUsPerTenSymbols;
-    deviation  = aFrame->mInfo.mRxInfo.mTimestamp + kRadioHeaderPhrDuration - sampleTime;
+    sampleTime = mCslSampleTimeRadio - mCslPeriod * kUsPerTenSymbols;
+    deviation  = static_cast<uint32_t>(aFrame->mInfo.mRxInfo.mTimestamp) + kRadioHeaderPhrDuration - sampleTime;
 
     // This logs three values (all in microseconds):
     // - Absolute sample time in which the CSL receiver expected the MHR of the received frame.
diff --git a/src/core/mac/sub_mac_wed.cpp b/src/core/mac/sub_mac_wed.cpp
index 741be2770..9cbd32560 100644
--- a/src/core/mac/sub_mac_wed.cpp
+++ b/src/core/mac/sub_mac_wed.cpp
@@ -44,17 +44,20 @@ RegisterLogModule("SubMac");
 
 void SubMac::WedInit(void)
 {
+    mIsWedSampling        = false;
+    mIsWedEnabled         = false;
     mWakeupListenInterval = 0;
     mWedTimer.Stop();
 }
 
 void SubMac::UpdateWakeupListening(bool aEnable, uint32_t aInterval, uint32_t aDuration, uint8_t aChannel)
 {
-    VerifyOrExit(RadioSupportsReceiveTiming());
-
     mWakeupListenInterval = aInterval;
     mWakeupListenDuration = aDuration;
     mWakeupChannel        = aChannel;
+    mIsWedSampling        = false;
+    mIsWedEnabled         = aEnable;
+
     mWedTimer.Stop();
 
     if (aEnable)
@@ -64,14 +67,27 @@ void SubMac::UpdateWakeupListening(bool aEnable, uint32_t aInterval, uint32_t aD
 
         HandleWedTimer();
     }
-
-exit:
-    return;
+    else if (!RadioSupportsReceiveTiming())
+    {
+        UpdateRadioSampleState();
+    }
 }
 
 void SubMac::HandleWedTimer(Timer &aTimer) { aTimer.Get<SubMac>().HandleWedTimer(); }
 
 void SubMac::HandleWedTimer(void)
+{
+    if (RadioSupportsReceiveTiming())
+    {
+        HandleWedReceiveAt();
+    }
+    else
+    {
+        HandleWedReceiveOrSleep();
+    }
+}
+
+void SubMac::HandleWedReceiveAt(void)
 {
     mWedSampleTime += mWakeupListenInterval;
     mWedSampleTimeRadio += mWakeupListenInterval;
@@ -84,6 +100,26 @@ void SubMac::HandleWedTimer(void)
     }
 }
 
+void SubMac::HandleWedReceiveOrSleep(void)
+{
+    TimeMilli fireTime;
+
+    mIsWedSampling = !mIsWedSampling;
+
+    if (mIsWedSampling)
+    {
+        fireTime = mWedSampleTime + mWakeupListenDuration + kMinReceiveOnAfter;
+    }
+    else
+    {
+        mWedSampleTime += mWakeupListenInterval;
+        fireTime = mWedSampleTime - kMinReceiveOnAhead;
+    }
+
+    mWedTimer.FireAt(fireTime);
+
+    UpdateRadioSampleState();
+}
 } // namespace Mac
 } // namespace ot
 
diff --git a/src/core/meshcop/border_agent.cpp b/src/core/meshcop/border_agent.cpp
index 9f039248a..45d1b30ad 100644
--- a/src/core/meshcop/border_agent.cpp
+++ b/src/core/meshcop/border_agent.cpp
@@ -45,19 +45,34 @@ RegisterLogModule("BorderAgent");
 //----------------------------------------------------------------------------------------------------------------------
 // `BorderAgent`
 
+const char BorderAgent::kTxtDataRecordVersion[] = "1";
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+const char BorderAgent::kServiceType[]            = "_meshcop._udp";
+const char BorderAgent::kDefaultBaseServiceName[] = OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_BASE_NAME;
+#endif
+
 BorderAgent::BorderAgent(Instance &aInstance)
     : InstanceLocator(aInstance)
+    , mEnabled(true)
     , mIsRunning(false)
     , mDtlsTransport(aInstance, kNoLinkSecurity)
 #if OPENTHREAD_CONFIG_BORDER_AGENT_ID_ENABLE
     , mIdInitialized(false)
 #endif
-    , mNotifyMeshCoPServiceChangedTask(aInstance)
+    , mServiceTask(aInstance)
 #if OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
     , mEphemeralKeyManager(aInstance)
 #endif
 {
     ClearAllBytes(mCounters);
+
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+    ClearAllBytes(mServiceName);
+    PostServiceTask();
+
+    static_assert(sizeof(kDefaultBaseServiceName) - 1 <= kBaseServiceNameMaxLen,
+                  "OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_BASE_NAME is too long");
+#endif
 }
 
 #if OPENTHREAD_CONFIG_BORDER_AGENT_ID_ENABLE
@@ -73,7 +88,7 @@ Error BorderAgent::GetId(Id &aId)
 
     if (Get<Settings>().Read<Settings::BorderAgentId>(mId) != kErrorNone)
     {
-        Random::NonCrypto::Fill(mId);
+        mId.GenerateRandom();
         SuccessOrExit(error = Get<Settings>().Save<Settings::BorderAgentId>(mId));
     }
 
@@ -88,15 +103,51 @@ Error BorderAgent::SetId(const Id &aId)
 {
     Error error = kErrorNone;
 
+    if (mIdInitialized)
+    {
+        VerifyOrExit(aId != mId);
+    }
+
     SuccessOrExit(error = Get<Settings>().Save<Settings::BorderAgentId>(aId));
     mId            = aId;
     mIdInitialized = true;
+    PostServiceTask();
 
 exit:
     return error;
 }
 #endif // OPENTHREAD_CONFIG_BORDER_AGENT_ID_ENABLE
 
+void BorderAgent::SetEnabled(bool aEnabled)
+{
+    VerifyOrExit(mEnabled != aEnabled);
+    mEnabled = aEnabled;
+    LogInfo("%sabling Border Agent", mEnabled ? "En" : "Dis");
+    UpdateState();
+
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+    if (!mEnabled)
+    {
+        UnregisterService();
+    }
+#endif
+
+exit:
+    return;
+}
+
+void BorderAgent::UpdateState(void)
+{
+    if (mEnabled && Get<Mle::Mle>().IsAttached())
+    {
+        Start();
+    }
+    else
+    {
+        Stop();
+    }
+}
+
 void BorderAgent::Start(void)
 {
     Error error = kErrorNone;
@@ -115,7 +166,7 @@ void BorderAgent::Start(void)
     pskc.Clear();
 
     mIsRunning = true;
-    PostNotifyMeshCoPServiceChangedTask();
+    PostServiceTask();
 
     LogInfo("Border Agent start listening on port %u", GetUdpPort());
 
@@ -134,7 +185,7 @@ void BorderAgent::Stop(void)
 
     mDtlsTransport.Close();
     mIsRunning = false;
-    PostNotifyMeshCoPServiceChangedTask();
+    PostServiceTask();
 
     LogInfo("Border Agent stopped");
 
@@ -144,38 +195,26 @@ exit:
 
 uint16_t BorderAgent::GetUdpPort(void) const { return mDtlsTransport.GetUdpPort(); }
 
-void BorderAgent::SetMeshCoPServiceChangedCallback(MeshCoPServiceChangedCallback aCallback, void *aContext)
+void BorderAgent::SetServiceChangedCallback(ServiceChangedCallback aCallback, void *aContext)
 {
-    mMeshCoPServiceChangedCallback.Set(aCallback, aContext);
+    mServiceChangedCallback.Set(aCallback, aContext);
 
-    mNotifyMeshCoPServiceChangedTask.Post();
-}
-
-Error BorderAgent::GetMeshCoPServiceTxtData(MeshCoPServiceTxtData &aTxtData) const
-{
-    MeshCoPTxtEncoder meshCoPTxtEncoder(GetInstance(), aTxtData);
-
-    return meshCoPTxtEncoder.EncodeTxtData();
+    PostServiceTask();
 }
 
 void BorderAgent::HandleNotifierEvents(Events aEvents)
 {
     if (aEvents.Contains(kEventThreadRoleChanged))
     {
-        if (Get<Mle::MleRouter>().IsAttached())
-        {
-            Start();
-        }
-        else
-        {
-            Stop();
-        }
+        UpdateState();
     }
 
+    VerifyOrExit(mEnabled);
+
     if (aEvents.ContainsAny(kEventThreadRoleChanged | kEventThreadExtPanIdChanged | kEventThreadNetworkNameChanged |
                             kEventThreadBackboneRouterStateChanged | kEventActiveDatasetChanged))
     {
-        PostNotifyMeshCoPServiceChangedTask();
+        PostServiceTask();
     }
 
     if (aEvents.ContainsAny(kEventPskcChanged))
@@ -347,164 +386,260 @@ exit:
     FreeMessageOnError(message, error);
 }
 
-void BorderAgent::NotifyMeshCoPServiceChanged(void) { mMeshCoPServiceChangedCallback.InvokeIfSet(); }
+void BorderAgent::PostServiceTask(void)
+{
+    VerifyOrExit(mEnabled);
+
+#if !OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+    VerifyOrExit(mServiceChangedCallback.IsSet());
+#endif
+
+    mServiceTask.Post();
+
+exit:
+    return;
+}
+
+void BorderAgent::HandleServiceTask(void)
+{
+    VerifyOrExit(mEnabled);
+
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+    RegisterService();
+#endif
+    mServiceChangedCallback.InvokeIfSet();
+
+exit:
+    return;
+}
+
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
 
-void BorderAgent::PostNotifyMeshCoPServiceChangedTask(void)
+Error BorderAgent::SetServiceBaseName(const char *aBaseName)
 {
-    if (mMeshCoPServiceChangedCallback.IsSet())
+    Error                  error = kErrorNone;
+    Dns::Name::LabelBuffer newName;
+
+    VerifyOrExit(StringLength(aBaseName, kBaseServiceNameMaxLen + 1) <= kBaseServiceNameMaxLen,
+                 error = kErrorInvalidArgs);
+
+    ConstrcutServiceName(aBaseName, newName);
+
+    VerifyOrExit(!StringMatch(newName, mServiceName));
+
+    UnregisterService();
+    IgnoreError(StringCopy(mServiceName, newName));
+    RegisterService();
+
+exit:
+    return error;
+}
+
+void BorderAgent::SetVendorTxtData(const uint8_t *aVendorData, uint16_t aVendorDataLength)
+{
+    VerifyOrExit(!mVendorTxtData.Matches(aVendorData, aVendorDataLength));
+
+    SuccessOrAssert(mVendorTxtData.SetFrom(aVendorData, aVendorDataLength));
+    PostServiceTask();
+
+exit:
+    return;
+}
+
+const char *BorderAgent::GetServiceName(void)
+{
+    if (IsServiceNameEmpty())
     {
-        mNotifyMeshCoPServiceChangedTask.Post();
+        ConstrcutServiceName(kDefaultBaseServiceName, mServiceName);
     }
+
+    return mServiceName;
 }
 
-//----------------------------------------------------------------------------------------------------------------------
-// BorderAgent::MeshCoPTxtEncoder
+void BorderAgent::ConstrcutServiceName(const char *aBaseName, Dns::Name::LabelBuffer &aNameBuffer)
+{
+    StringWriter writer(aNameBuffer, sizeof(Dns::Name::LabelBuffer));
+
+    writer.Append("%.*s%s", kBaseServiceNameMaxLen, aBaseName, Get<Mac::Mac>().GetExtAddress().ToString().AsCString());
+}
 
-Error BorderAgent::MeshCoPTxtEncoder::AppendTxtEntry(const char *aKey, const void *aValue, uint16_t aValueLength)
+void BorderAgent::RegisterService(void)
 {
-    Dns::TxtEntry txtEntry;
+    Dnssd::Service service;
+    uint8_t       *txtDataBuffer;
+    uint16_t       txtDataBufferSize;
+    uint16_t       txtDataLength;
+
+    VerifyOrExit(Get<Dnssd>().IsReady());
+
+    // Allocate a large enough buffer to fit both the TXT data
+    // generated by Border Agent itself and the vendor extra
+    // TXT data. The vendor TXT Data is appended at the
+    // end.
+
+    txtDataBufferSize = kTxtDataMaxSize + mVendorTxtData.GetLength();
+    txtDataBuffer     = reinterpret_cast<uint8_t *>(Heap::CAlloc(txtDataBufferSize, sizeof(uint8_t)));
+    OT_ASSERT(txtDataBuffer != nullptr);
+
+    SuccessOrAssert(PrepareServiceTxtData(txtDataBuffer, txtDataBufferSize, txtDataLength));
+
+    if (mVendorTxtData.GetLength() != 0)
+    {
+        mVendorTxtData.CopyBytesTo(txtDataBuffer + txtDataLength);
+        txtDataLength += mVendorTxtData.GetLength();
+    }
 
-    txtEntry.Init(aKey, reinterpret_cast<const uint8_t *>(aValue), aValueLength);
-    return txtEntry.AppendTo(mAppender);
+    service.Clear();
+    service.mServiceInstance = GetServiceName();
+    service.mServiceType     = kServiceType;
+    service.mPort            = IsRunning() ? GetUdpPort() : kDummyUdpPort;
+    service.mTxtData         = txtDataBuffer;
+    service.mTxtDataLength   = txtDataLength;
+
+    Get<Dnssd>().RegisterService(service, /* aRequestId */ 0, /* aCallback */ nullptr);
+
+    Heap::Free(txtDataBuffer);
+
+exit:
+    return;
 }
 
-template <> Error BorderAgent::MeshCoPTxtEncoder::AppendTxtEntry<NameData>(const char *aKey, const NameData &aObject)
+void BorderAgent::UnregisterService(void)
 {
-    return AppendTxtEntry(aKey, aObject.GetBuffer(), aObject.GetLength());
+    Dnssd::Service service;
+
+    VerifyOrExit(Get<Dnssd>().IsReady());
+    VerifyOrExit(!IsServiceNameEmpty());
+
+    service.Clear();
+    service.mServiceInstance = GetServiceName();
+    service.mServiceType     = kServiceType;
+
+    Get<Dnssd>().UnregisterService(service, /* aRequestId */ 0, /* aCallback */ nullptr);
+
+exit:
+    return;
 }
 
-Error BorderAgent::MeshCoPTxtEncoder::EncodeTxtData(void)
+#endif // OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+
+Error BorderAgent::PrepareServiceTxtData(ServiceTxtData &aTxtData)
 {
-    Error error = kErrorNone;
-#if OPENTHREAD_CONFIG_BORDER_AGENT_ID_ENABLE
-    Id id;
-#endif
-    StateBitmap state;
+    return PrepareServiceTxtData(aTxtData.mData, sizeof(aTxtData.mData), aTxtData.mLength);
+}
+
+Error BorderAgent::PrepareServiceTxtData(uint8_t *aBuffer, uint16_t aBufferSize, uint16_t &aLength)
+{
+    Error               error = kErrorNone;
+    Dns::TxtDataEncoder encoder(aBuffer, aBufferSize);
 
 #if OPENTHREAD_CONFIG_BORDER_AGENT_ID_ENABLE
-    if (Get<BorderAgent>().GetId(id) == kErrorNone)
     {
-        SuccessOrExit(error = AppendTxtEntry("id", id));
+        Id id;
+
+        if (GetId(id) == kErrorNone)
+        {
+            SuccessOrExit(error = encoder.AppendEntry("id", id));
+        }
     }
 #endif
-    SuccessOrExit(error = AppendTxtEntry("nn", Get<NetworkNameManager>().GetNetworkName().GetAsData()));
-    SuccessOrExit(error = AppendTxtEntry("xp", Get<ExtendedPanIdManager>().GetExtPanId()));
-    SuccessOrExit(error = AppendTxtEntry("tv", NameData(kThreadVersionString, strlen(kThreadVersionString))));
-    SuccessOrExit(error = AppendTxtEntry("xa", Get<Mac::Mac>().GetExtAddress()));
-
-    state = GetStateBitmap();
-    SuccessOrExit(error = AppendTxtEntry("sb", BigEndian::HostSwap32(state.ToUint32())));
-
-    if (state.mThreadIfStatus == kThreadIfStatusActive)
+    SuccessOrExit(error = encoder.AppendStringEntry("rv", kTxtDataRecordVersion));
+    SuccessOrExit(error = encoder.AppendNameEntry("nn", Get<NetworkNameManager>().GetNetworkName().GetAsData()));
+    SuccessOrExit(error = encoder.AppendEntry("xp", Get<ExtendedPanIdManager>().GetExtPanId()));
+    SuccessOrExit(error = encoder.AppendStringEntry("tv", kThreadVersionString));
+    SuccessOrExit(error = encoder.AppendEntry("xa", Get<Mac::Mac>().GetExtAddress()));
+    SuccessOrExit(error = encoder.AppendBigEndianUintEntry("sb", DetermineStateBitmap()));
+
+    if (Get<Mle::Mle>().IsAttached())
     {
-        SuccessOrExit(error = AppendTxtEntry(
-                          "pt", BigEndian::HostSwap32(Get<Mle::MleRouter>().GetLeaderData().GetPartitionId())));
+        SuccessOrExit(error = encoder.AppendBigEndianUintEntry("pt", Get<Mle::Mle>().GetLeaderData().GetPartitionId()));
+
         if (Get<MeshCoP::ActiveDatasetManager>().GetTimestamp().IsValid())
         {
-            SuccessOrExit(error = AppendTxtEntry("at", Get<MeshCoP::ActiveDatasetManager>().GetTimestamp()));
+            SuccessOrExit(error = encoder.AppendEntry("at", Get<MeshCoP::ActiveDatasetManager>().GetTimestamp()));
         }
     }
 
 #if OPENTHREAD_FTD && OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE
-    SuccessOrExit(error = AppendBbrTxtEntry(state));
-#endif
-#if OTBR_ENABLE_BORDER_ROUTING
-    SuccessOrExit(error = AppendOmrTxtEntry());
-#endif
-    mTxtData.mLength = mAppender.GetAppendedLength();
-
-exit:
-    return error;
-}
-
-#if OPENTHREAD_FTD && OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE
-Error BorderAgent::MeshCoPTxtEncoder::AppendBbrTxtEntry(StateBitmap aState)
-{
-    Error             error      = kErrorNone;
-    const DomainName &domainName = Get<MeshCoP::NetworkNameManager>().GetDomainName();
-
-    if (aState.mBbrIsActive)
+    if (Get<Mle::Mle>().IsAttached() && Get<BackboneRouter::Local>().IsEnabled())
     {
         BackboneRouter::Config bbrConfig;
 
         Get<BackboneRouter::Local>().GetConfig(bbrConfig);
-        SuccessOrExit(error = AppendTxtEntry("sq", bbrConfig.mSequenceNumber));
-        SuccessOrExit(error = AppendTxtEntry("bb", BigEndian::HostSwap16(BackboneRouter::kBackboneUdpPort)));
+        SuccessOrExit(error = encoder.AppendEntry("sq", bbrConfig.mSequenceNumber));
+        SuccessOrExit(error = encoder.AppendBigEndianUintEntry("bb", BackboneRouter::kBackboneUdpPort));
     }
 
-    error = AppendTxtEntry(
-        "dn", NameData(domainName.GetAsCString(), StringLength(domainName.GetAsCString(), sizeof(domainName))));
-
-exit:
-    return error;
-}
-#endif // OPENTHREAD_FTD && OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE
+    SuccessOrExit(error =
+                      encoder.AppendNameEntry("dn", Get<MeshCoP::NetworkNameManager>().GetDomainName().GetAsData()));
+#endif
 
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE
-Error BorderAgent::MeshCoPTxtEncoder::AppendOmrTxtEntry(void)
-{
-    Error                                         error = kErrorNone;
-    Ip6::Prefix                                   prefix;
-    BorderRouter::RoutingManager::RoutePreference preference;
-
-    if ((error = Get<BorderRouter::RoutingManager>().GetFavoredOmrPrefix(prefix, preference)) == kErrorNone)
     {
-        uint8_t omrData[Ip6::NetworkPrefix::kSize + 1];
-        omrData[0] = prefix.GetLength();
-        memcpy(omrData + 1, prefix.GetBytes(), prefix.GetBytesSize());
+        Ip6::Prefix                                   prefix;
+        BorderRouter::RoutingManager::RoutePreference preference;
+
+        if (Get<BorderRouter::RoutingManager>().GetFavoredOmrPrefix(prefix, preference) == kErrorNone &&
+            prefix.GetLength() > 0)
+        {
+            uint8_t omrData[Ip6::NetworkPrefix::kSize + 1];
+
+            omrData[0] = prefix.GetLength();
+            memcpy(omrData + 1, prefix.GetBytes(), prefix.GetBytesSize());
 
-        SuccessOrExit(error = AppendTxtEntry("omr", omrData));
+            SuccessOrExit(error = encoder.AppendEntry("omr", omrData));
+        }
     }
+#endif
+
+    aLength = encoder.GetLength();
 
 exit:
     return error;
 }
-#endif
 
-BorderAgent::MeshCoPTxtEncoder::StateBitmap BorderAgent::MeshCoPTxtEncoder::GetStateBitmap(void)
+uint32_t BorderAgent::DetermineStateBitmap(void) const
 {
-    StateBitmap state;
+    uint32_t bitmap = 0;
 
-    state.mConnectionMode = kConnectionModePskc;
-    state.mAvailability   = kAvailabilityHigh;
+    bitmap |= (IsRunning() ? StateBitmap::kConnectionModePskc : StateBitmap::kConnectionModeDisabled);
+    bitmap |= StateBitmap::kAvailabilityHigh;
 
-    switch (Get<Mle::MleRouter>().GetRole())
+    switch (Get<Mle::Mle>().GetRole())
     {
     case Mle::DeviceRole::kRoleDisabled:
-        state.mThreadIfStatus = kThreadIfStatusNotInitialized;
-        state.mThreadRole     = kThreadRoleDisabledOrDetached;
+        bitmap |= (StateBitmap::kThreadIfStatusNotInitialized | StateBitmap::kThreadRoleDisabledOrDetached);
         break;
     case Mle::DeviceRole::kRoleDetached:
-        state.mThreadIfStatus = kThreadIfStatusInitialized;
-        state.mThreadRole     = kThreadRoleDisabledOrDetached;
+        bitmap |= (StateBitmap::kThreadIfStatusInitialized | StateBitmap::kThreadRoleDisabledOrDetached);
         break;
     case Mle::DeviceRole::kRoleChild:
-        state.mThreadIfStatus = kThreadIfStatusActive;
-        state.mThreadRole     = kThreadRoleChild;
+        bitmap |= (StateBitmap::kThreadIfStatusActive | StateBitmap::kThreadRoleChild);
         break;
     case Mle::DeviceRole::kRoleRouter:
-        state.mThreadIfStatus = kThreadIfStatusActive;
-        state.mThreadRole     = kThreadRoleRouter;
+        bitmap |= (StateBitmap::kThreadIfStatusActive | StateBitmap::kThreadRoleRouter);
         break;
     case Mle::DeviceRole::kRoleLeader:
-        state.mThreadIfStatus = kThreadIfStatusActive;
-        state.mThreadRole     = kThreadRoleLeader;
+        bitmap |= (StateBitmap::kThreadIfStatusActive | StateBitmap::kThreadRoleLeader);
         break;
     }
 
 #if OPENTHREAD_FTD && OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE
-    state.mBbrIsActive = state.mThreadIfStatus == kThreadIfStatusActive &&
-                         Get<BackboneRouter::Local>().GetState() != BackboneRouter::Local::State::kStateDisabled;
-    state.mBbrIsPrimary = state.mThreadIfStatus == kThreadIfStatusActive &&
-                          Get<BackboneRouter::Local>().GetState() == BackboneRouter::Local::State::kStatePrimary;
+    if (Get<Mle::Mle>().IsAttached())
+    {
+        bitmap |= (Get<BackboneRouter::Local>().IsEnabled() ? StateBitmap::kFlagBbrIsActive : 0);
+        bitmap |= (Get<BackboneRouter::Local>().IsPrimary() ? StateBitmap::kFlagBbrIsPrimary : 0);
+    }
 #endif
 
 #if OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
-    state.mEpskcSupported =
-        Get<BorderAgent::EphemeralKeyManager>().GetState() != EphemeralKeyManager::State::kStateDisabled;
+    if (mEphemeralKeyManager.GetState() != EphemeralKeyManager::kStateDisabled)
+    {
+        bitmap |= StateBitmap::kFlagEpskcSupported;
+    }
 #endif
 
-    return state;
+    return bitmap;
 }
 
 //----------------------------------------------------------------------------------------------------------------------
@@ -540,6 +675,10 @@ exit:
 
 #if OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
 
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+const char BorderAgent::EphemeralKeyManager::kServiceType[] = "_meshcop-e._udp";
+#endif
+
 BorderAgent::EphemeralKeyManager::EphemeralKeyManager(Instance &aInstance)
     : InstanceLocator(aInstance)
 #if OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_FEATURE_ENABLED_BY_DEFAULT
@@ -560,14 +699,14 @@ void BorderAgent::EphemeralKeyManager::SetEnabled(bool aEnabled)
     {
         VerifyOrExit(mState == kStateDisabled);
         SetState(kStateStopped);
-        Get<BorderAgent>().PostNotifyMeshCoPServiceChangedTask();
+        Get<BorderAgent>().PostServiceTask();
     }
     else
     {
         VerifyOrExit(mState != kStateDisabled);
         Stop();
         SetState(kStateDisabled);
-        Get<BorderAgent>().PostNotifyMeshCoPServiceChangedTask();
+        Get<BorderAgent>().PostServiceTask();
     }
 
 exit:
@@ -607,6 +746,9 @@ exit:
     {
     case kErrorNone:
         Get<BorderAgent>().mCounters.mEpskcActivations++;
+#if OPENTHREAD_CONFIG_HISTORY_TRACKER_ENABLE
+        Get<Utils::HistoryTracker>().RecordEpskcEvent(Utils::HistoryTracker::kEpskcActivated);
+#endif
         break;
     case kErrorInvalidState:
         Get<BorderAgent>().mCounters.mEpskcInvalidBaStateErrors++;
@@ -624,7 +766,7 @@ exit:
 
 void BorderAgent::EphemeralKeyManager::Stop(void) { Stop(kReasonLocalDisconnect); }
 
-void BorderAgent::EphemeralKeyManager::Stop(StopReason aReason)
+void BorderAgent::EphemeralKeyManager::Stop(DeactivationReason aReason)
 {
     switch (mState)
     {
@@ -637,44 +779,87 @@ void BorderAgent::EphemeralKeyManager::Stop(StopReason aReason)
         ExitNow();
     }
 
-    LogInfo("Stopping ephemeral key use - reason: %s", StopReasonToString(aReason));
+    LogInfo("Stopping ephemeral key use - reason: %s", DeactivationReasonToString(aReason));
     SetState(kStateStopped);
 
     mTimer.Stop();
     mDtlsTransport.Close();
 
-    switch (aReason)
-    {
-    case kReasonLocalDisconnect:
-        Get<BorderAgent>().mCounters.mEpskcDeactivationClears++;
-        break;
-    case kReasonPeerDisconnect:
-        Get<BorderAgent>().mCounters.mEpskcDeactivationDisconnects++;
-        break;
-    case kReasonSessionError:
-        Get<BorderAgent>().mCounters.mEpskcStartSecureSessionErrors++;
-        break;
-    case kReasonMaxFailedAttempts:
-        Get<BorderAgent>().mCounters.mEpskcDeactivationMaxAttempts++;
-        break;
-    case kReasonTimeout:
-        Get<BorderAgent>().mCounters.mEpskcDeactivationTimeouts++;
-        break;
-    case kReasonUnknown:
-        break;
-    }
+    UpdateCountersAndRecordEvent(aReason);
 
 exit:
     return;
 }
 
+void BorderAgent::EphemeralKeyManager::UpdateCountersAndRecordEvent(DeactivationReason aReason)
+{
+    struct ReasonToCounterEventEntry
+    {
+        DeactivationReason mReason;
+        uint8_t            mEvent; // Raw values of `Utils::HistoryTracker::Epskc` enum.
+        uint32_t Counters::*mCounterPtr;
+    };
+
+#if OPENTHREAD_CONFIG_HISTORY_TRACKER_ENABLE
+#define ReasonEntry(kReason, kCounter, kEvent)                       \
+    {                                                                \
+        kReason, Utils::HistoryTracker::kEvent, &Counters::kCounter, \
+    }
+#else
+#define ReasonEntry(kReason, kCounter, kEvent) \
+    {                                          \
+        kReason, 0, &Counters::kCounter        \
+    }
+#endif
+
+    static const ReasonToCounterEventEntry kReasonToCounterEventEntries[] = {
+        ReasonEntry(kReasonLocalDisconnect, mEpskcDeactivationClears, kEpskcDeactivatedLocalClose),
+        ReasonEntry(kReasonSessionTimeout, mEpskcDeactivationClears, kEpskcDeactivatedSessionTimeout),
+        ReasonEntry(kReasonPeerDisconnect, mEpskcDeactivationDisconnects, kEpskcDeactivatedRemoteClose),
+        ReasonEntry(kReasonSessionError, mEpskcStartSecureSessionErrors, kEpskcDeactivatedSessionError),
+        ReasonEntry(kReasonMaxFailedAttempts, mEpskcDeactivationMaxAttempts, kEpskcDeactivatedMaxAttempts),
+        ReasonEntry(kReasonEpskcTimeout, mEpskcDeactivationTimeouts, kEpskcDeactivatedEpskcTimeout),
+    };
+
+#undef ReasonEntry
+
+#if OPENTHREAD_CONFIG_HISTORY_TRACKER_ENABLE
+    Utils::HistoryTracker::EpskcEvent event = Utils::HistoryTracker::kEpskcDeactivatedUnknown;
+#endif
+
+    for (const ReasonToCounterEventEntry &entry : kReasonToCounterEventEntries)
+    {
+        if (aReason == entry.mReason)
+        {
+            (Get<BorderAgent>().mCounters.*(entry.mCounterPtr))++;
+#if OPENTHREAD_CONFIG_HISTORY_TRACKER_ENABLE
+            event = static_cast<Utils::HistoryTracker::EpskcEvent>(entry.mEvent);
+#endif
+            break;
+        }
+    }
+
+#if OPENTHREAD_CONFIG_HISTORY_TRACKER_ENABLE
+    Get<Utils::HistoryTracker>().RecordEpskcEvent(event);
+#endif
+}
+
 void BorderAgent::EphemeralKeyManager::SetState(State aState)
 {
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+    bool isServiceRegistered = ShouldRegisterService();
+#endif
+
     VerifyOrExit(mState != aState);
     LogInfo("Ephemeral key - state: %s -> %s", StateToString(mState), StateToString(aState));
     mState = aState;
     mCallbackTask.Post();
 
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+    VerifyOrExit(isServiceRegistered != ShouldRegisterService());
+    RegisterOrUnregisterService();
+#endif
+
 exit:
     return;
 }
@@ -720,14 +905,16 @@ void BorderAgent::EphemeralKeyManager::HandleSessionConnected(void)
 {
     SetState(kStateConnected);
     Get<BorderAgent>().mCounters.mEpskcSecureSessionSuccesses++;
+#if OPENTHREAD_CONFIG_HISTORY_TRACKER_ENABLE
+    Get<Utils::HistoryTracker>().RecordEpskcEvent(Utils::HistoryTracker::kEpskcConnected);
+#endif
 }
 
 void BorderAgent::EphemeralKeyManager::HandleSessionDisconnected(SecureSession::ConnectEvent aEvent)
 {
-    StopReason reason = kReasonUnknown;
+    DeactivationReason reason = kReasonUnknown;
 
     // The ephemeral key can be used once
-
     VerifyOrExit((mState == kStateConnected) || (mState == kStateAccepted));
 
     switch (aEvent)
@@ -741,6 +928,9 @@ void BorderAgent::EphemeralKeyManager::HandleSessionDisconnected(SecureSession::
     case SecureSession::kDisconnectedMaxAttempts:
         reason = kReasonMaxFailedAttempts;
         break;
+    case SecureSession::kDisconnectedTimeout:
+        reason = kReasonSessionTimeout;
+        break;
     default:
         break;
     }
@@ -755,9 +945,12 @@ void BorderAgent::EphemeralKeyManager::HandleCommissionerPetitionAccepted(void)
 {
     SetState(kStateAccepted);
     Get<BorderAgent>().mCounters.mEpskcCommissionerPetitions++;
+#if OPENTHREAD_CONFIG_HISTORY_TRACKER_ENABLE
+    Get<Utils::HistoryTracker>().RecordEpskcEvent(Utils::HistoryTracker::kEpskcPetitioned);
+#endif
 }
 
-void BorderAgent::EphemeralKeyManager::HandleTimer(void) { Stop(kReasonTimeout); }
+void BorderAgent::EphemeralKeyManager::HandleTimer(void) { Stop(kReasonEpskcTimeout); }
 
 void BorderAgent::EphemeralKeyManager::HandleTask(void) { mCallback.InvokeIfSet(); }
 
@@ -772,6 +965,53 @@ void BorderAgent::EphemeralKeyManager::HandleTransportClosed(void)
     ;
 }
 
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+
+bool BorderAgent::EphemeralKeyManager::ShouldRegisterService(void) const
+{
+    bool shouldRegister = false;
+
+    switch (mState)
+    {
+    case kStateDisabled:
+    case kStateStopped:
+        break;
+    case kStateStarted:
+    case kStateConnected:
+    case kStateAccepted:
+        shouldRegister = true;
+        break;
+    }
+
+    return shouldRegister;
+}
+
+void BorderAgent::EphemeralKeyManager::RegisterOrUnregisterService(void)
+{
+    Dnssd::Service service;
+
+    VerifyOrExit(Get<Dnssd>().IsReady());
+
+    service.Clear();
+    service.mServiceInstance = Get<BorderAgent>().GetServiceName();
+    service.mServiceType     = kServiceType;
+    service.mPort            = GetUdpPort();
+
+    if (ShouldRegisterService())
+    {
+        Get<Dnssd>().RegisterService(service, /* aRequestId */ 0, /* aCallback */ nullptr);
+    }
+    else
+    {
+        Get<Dnssd>().UnregisterService(service, /* aRequestId */ 0, /* aCallback */ nullptr);
+    }
+
+exit:
+    return;
+}
+
+#endif // OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+
 const char *BorderAgent::EphemeralKeyManager::StateToString(State aState)
 {
     static const char *const kStateStrings[] = {
@@ -797,15 +1037,16 @@ const char *BorderAgent::EphemeralKeyManager::StateToString(State aState)
 
 #if OT_SHOULD_LOG_AT(OT_LOG_LEVEL_INFO)
 
-const char *BorderAgent::EphemeralKeyManager::StopReasonToString(StopReason aReason)
+const char *BorderAgent::EphemeralKeyManager::DeactivationReasonToString(DeactivationReason aReason)
 {
     static const char *const kReasonStrings[] = {
         "LocalDisconnect",   // (0) kReasonLocalDisconnect
         "PeerDisconnect",    // (1) kReasonPeerDisconnect
         "SessionError",      // (2) kReasonSessionError
-        "MaxFailedAttempts", // (3) kReasonMaxFailedAttempts
-        "Timeout",           // (4) kReasonTimeout
-        "Unknown",           // (5) kReasonUnknown
+        "SessionTimeout",    // (3) kReasonSessionTimeout
+        "MaxFailedAttempts", // (4) kReasonMaxFailedAttempts
+        "EpskcTimeout",      // (5) kReasonTimeout
+        "Unknown",           // (6) kReasonUnknown
     };
 
     struct EnumCheck
@@ -814,8 +1055,9 @@ const char *BorderAgent::EphemeralKeyManager::StopReasonToString(StopReason aRea
         ValidateNextEnum(kReasonLocalDisconnect);
         ValidateNextEnum(kReasonPeerDisconnect);
         ValidateNextEnum(kReasonSessionError);
+        ValidateNextEnum(kReasonSessionTimeout);
         ValidateNextEnum(kReasonMaxFailedAttempts);
-        ValidateNextEnum(kReasonTimeout);
+        ValidateNextEnum(kReasonEpskcTimeout);
         ValidateNextEnum(kReasonUnknown);
     };
 
@@ -929,6 +1171,12 @@ void BorderAgent::CoapDtlsSession::HandleTmfCommissionerKeepAlive(Coap::Message
     VerifyOrExit(mIsActiveCommissioner);
     SuccessOrExit(ForwardToLeader(aMessage, aMessageInfo, kUriLeaderKeepAlive));
     mTimer.Start(kKeepAliveTimeout);
+#if OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE && OPENTHREAD_CONFIG_HISTORY_TRACKER_ENABLE
+    if (Get<EphemeralKeyManager>().OwnsSession(*this))
+    {
+        Get<Utils::HistoryTracker>().RecordEpskcEvent(Utils::HistoryTracker::kEpskcKeepAlive);
+    }
+#endif
 
 exit:
     return;
@@ -1259,11 +1507,23 @@ void BorderAgent::CoapDtlsSession::HandleTmfDatasetGet(Coap::Message &aMessage,
     case kUriActiveGet:
         response = Get<ActiveDatasetManager>().ProcessGetRequest(aMessage, DatasetManager::kIgnoreSecurityPolicyFlags);
         Get<BorderAgent>().mCounters.mMgmtActiveGets++;
+#if OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE && OPENTHREAD_CONFIG_HISTORY_TRACKER_ENABLE
+        if (Get<EphemeralKeyManager>().OwnsSession(*this))
+        {
+            Get<Utils::HistoryTracker>().RecordEpskcEvent(Utils::HistoryTracker::kEpskcRetrievedActiveDataset);
+        }
+#endif
         break;
 
     case kUriPendingGet:
         response = Get<PendingDatasetManager>().ProcessGetRequest(aMessage, DatasetManager::kIgnoreSecurityPolicyFlags);
         Get<BorderAgent>().mCounters.mMgmtPendingGets++;
+#if OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE && OPENTHREAD_CONFIG_HISTORY_TRACKER_ENABLE
+        if (Get<EphemeralKeyManager>().OwnsSession(*this))
+        {
+            Get<Utils::HistoryTracker>().RecordEpskcEvent(Utils::HistoryTracker::kEpskcRetrievedPendingDataset);
+        }
+#endif
         break;
 
     case kUriCommissionerGet:
@@ -1295,7 +1555,7 @@ void BorderAgent::CoapDtlsSession::HandleTimer(void)
     if (IsConnected())
     {
         LogInfo("Session timed out - disconnecting");
-        Disconnect();
+        DisconnectTimeout();
     }
 }
 
diff --git a/src/core/meshcop/border_agent.hpp b/src/core/meshcop/border_agent.hpp
index d289af216..2c1dd4c3f 100644
--- a/src/core/meshcop/border_agent.hpp
+++ b/src/core/meshcop/border_agent.hpp
@@ -39,11 +39,13 @@
 #if OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE
 
 #include <openthread/border_agent.h>
+#include <openthread/history_tracker.h>
 
 #include "border_router/routing_manager.hpp"
 #include "common/appender.hpp"
 #include "common/as_core_type.hpp"
 #include "common/heap_allocatable.hpp"
+#include "common/heap_data.hpp"
 #include "common/linked_list.hpp"
 #include "common/locator.hpp"
 #include "common/non_copyable.hpp"
@@ -53,6 +55,7 @@
 #include "meshcop/dataset.hpp"
 #include "meshcop/secure_transport.hpp"
 #include "net/dns_types.hpp"
+#include "net/dnssd.hpp"
 #include "net/socket.hpp"
 #include "net/udp6.hpp"
 #include "thread/tmf.hpp"
@@ -66,14 +69,25 @@ namespace MeshCoP {
 #error "Border Agent feature requires `OPENTHREAD_CONFIG_SECURE_TRANSPORT_ENABLE`"
 #endif
 
-#if !OPENTHREAD_CONFIG_UPTIME_ENABLE
-#error "Border Agent feature requires `OPENTHREAD_CONFIG_UPTIME_ENABLE`"
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+
+#if !(OPENTHREAD_CONFIG_PLATFORM_DNSSD_ENABLE || OPENTHREAD_CONFIG_MULTICAST_DNS_ENABLE)
+#error "OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE requires either the native mDNS or platform DNS-SD APIs"
+#endif
+
+#if !OPENTHREAD_CONFIG_BORDER_AGENT_ID_ENABLE
+#error "OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE requires OPENTHREAD_CONFIG_BORDER_AGENT_ID_ENABLE"
+#endif
+
 #endif
 
 class BorderAgent : public InstanceLocator, private NonCopyable
 {
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE
     friend class ot::BorderRouter::RoutingManager;
+#endif
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+    friend ot::Dnssd;
 #endif
     friend class ot::Notifier;
     friend class Tmf::Agent;
@@ -81,9 +95,10 @@ class BorderAgent : public InstanceLocator, private NonCopyable
     class CoapDtlsSession;
 
 public:
-    typedef otBorderAgentId          Id;          ///< Border Agent ID.
-    typedef otBorderAgentCounters    Counters;    ///< Border Agent Counters.
-    typedef otBorderAgentSessionInfo SessionInfo; ///< A session info.
+    typedef otBorderAgentCounters                      Counters;               ///< Border Agent Counters.
+    typedef otBorderAgentSessionInfo                   SessionInfo;            ///< A session info.
+    typedef otBorderAgentMeshCoPServiceChangedCallback ServiceChangedCallback; ///< Service changed callback.
+    typedef otBorderAgentMeshCoPServiceTxtData         ServiceTxtData;         ///< Service TXT data.
 
     /**
      * Represents an iterator for secure sessions.
@@ -122,7 +137,54 @@ public:
      */
     explicit BorderAgent(Instance &aInstance);
 
+    /**
+     * Enables or disables the Border Agent service.
+     *
+     * By default, the Border Agent service is enabled. This method allows us to explicitly control its state. This can
+     * be useful in scenarios such as:
+     * - The code wishes to delay the start of the Border Agent service (and its mDNS advertisement of the
+     *   `_meshcop._udp` service on the infrastructure link). This allows time to prepare or determine vendor-specific
+     *   TXT data entries for inclusion.
+     * - Unit tests or test scripts might disable the Border Agent service to prevent it from interfering with specific
+     *   test steps. For example, tests validating mDNS or DNS-SD functionality may disable the Border Agent to prevent
+     *   its  registration of the MeshCoP service.
+     *
+     * @param[in] aEnabled  Whether to enable or disable.
+     */
+    void SetEnabled(bool aEnabled);
+
+    /**
+     * Indicated whether or not the Border Agent is enabled.
+     *
+     * @retval TRUE   The Border Agent is enabled.
+     * @retval FALSE  The Border Agent is disabled.
+     */
+    bool IsEnabled(void) const { return mEnabled; }
+
+    /**
+     * Indicates whether the Border Agent service is enabled and running.
+     *
+     * @retval TRUE  Border Agent service is running.
+     * @retval FALSE Border Agent service is not running.
+     */
+    bool IsRunning(void) const { return mIsRunning; }
+
 #if OPENTHREAD_CONFIG_BORDER_AGENT_ID_ENABLE
+    /**
+     *  Represents a Border Agent Identifier.
+     */
+    struct Id : public otBorderAgentId, public Clearable<Id>, public Equatable<Id>
+    {
+        static constexpr uint16_t kLength = OT_BORDER_AGENT_ID_LENGTH; ///< The ID length (number of bytes).
+
+        /**
+         * Generates a random ID.
+         */
+        void GenerateRandom(void) { Random::NonCrypto::Fill(mId); }
+    };
+
+    static_assert(sizeof(Id) == Id::kLength, "sizeof(Id) is not valid");
+
     /**
      * Gets the randomly generated Border Agent ID.
      *
@@ -144,7 +206,7 @@ public:
      * to set the ID only once after factory reset. If the ID has never been set by calling this
      * method, a random ID will be generated and returned when `GetId()` is called.
      *
-     * @param[out] aId  specifies the Border Agent ID.
+     * @param[in] aId   The Border Agent ID.
      *
      * @retval kErrorNone  If successfully set the Border Agent ID.
      * @retval ...         If failed to set the Border Agent ID.
@@ -159,16 +221,6 @@ public:
      */
     uint16_t GetUdpPort(void) const;
 
-    /**
-     * Indicates whether the Border Agent service is running.
-     *
-     * @retval TRUE  Border Agent service is running.
-     * @retval FALSE Border Agent service is not running.
-     */
-    bool IsRunning(void) const { return mIsRunning; }
-
-    typedef otBorderAgentMeshCoPServiceChangedCallback MeshCoPServiceChangedCallback;
-
     /**
      * Sets the callback function used by the Border Agent to notify any changes on the MeshCoP service TXT values.
      *
@@ -182,19 +234,51 @@ public:
      * @param[in] aCallback  The callback to invoke when there are any changes of the MeshCoP service.
      * @param[in] aContext   A pointer to application-specific context.
      */
-    void SetMeshCoPServiceChangedCallback(MeshCoPServiceChangedCallback aCallback, void *aContext);
-
-    typedef otBorderAgentMeshCoPServiceTxtData MeshCoPServiceTxtData;
+    void SetServiceChangedCallback(ServiceChangedCallback aCallback, void *aContext);
 
     /**
-     * Gets the MeshCoP service TXT data.
+     * Prepares the MeshCoP service TXT data.
      *
      * @param[out] aTxtData   A reference to a MeshCoP Service TXT data struct to get the data.
      *
      * @retval kErrorNone     If successfully retrieved the Border Agent MeshCoP Service TXT data.
      * @retval kErrorNoBufs   If the buffer in @p aTxtData doesn't have enough size.
      */
-    Error GetMeshCoPServiceTxtData(MeshCoPServiceTxtData &aTxtData) const;
+    Error PrepareServiceTxtData(ServiceTxtData &aTxtData);
+
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+    /**
+     * Sets the base name to construct the service instance name used when advertising the mDNS `_meshcop._udp` service
+     * by the Border Agent.
+     *
+     * @param[in] aBaseName  The base name to use (MUST not be NULL).
+     *
+     * @retval kErrorNone          The name was set successfully.
+     * @retval kErrorInvalidArgs   The name is too long or invalid.
+     */
+    Error SetServiceBaseName(const char *aBaseName);
+
+    /**
+     * Sets the vendor extra TXT data to be included when the Border Agent advertises the mDNS `_meshcop._udp` service.
+     *
+     * The provided @p aVendorData bytes are appended as they appear in the buffer to the end of the TXT data generated
+     * by the Border Agent itself, and are then included in the advertised mDNS `_meshcop._udp` service.
+     *
+     * This method itself does not perform any validation of the format of the provided @p aVendorData. Therefore, the
+     * caller MUST ensure it is formatted properly. Per the Thread specification, vendor-specific Key-Value TXT data
+     * pairs use TXT keys starting with 'v'. For example, `vn` for vendor name.
+     *
+     * The `BorderAgent` will create and retain its own copy of the bytes in @p aVendorData. So, the buffer passed to
+     * this method does not need to persist beyond the scope of the call.
+     *
+     * The vendor TXT data can be set at any time while the Border Agent is in any state. If there is a change from the
+     * previously set value, it will trigger an update of the registered mDNS service to advertise the new TXT data.
+     *
+     * @param[in] aVendorData        A pointer to the buffer containing the vendor TXT data.
+     * @param[in] aVendorDataLength  The length of @p aVendorData in bytes.
+     */
+    void SetVendorTxtData(const uint8_t *aVendorData, uint16_t aVendorDataLength);
+#endif
 
 #if OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
     /**
@@ -306,26 +390,32 @@ public:
 
         static_assert(kMaxKeyLength <= Dtls::Transport::kPskMaxLength, "Max e-key len is larger than max PSK len");
 
-        enum StopReason : uint8_t
+        enum DeactivationReason : uint8_t
         {
             kReasonLocalDisconnect,
             kReasonPeerDisconnect,
             kReasonSessionError,
+            kReasonSessionTimeout,
             kReasonMaxFailedAttempts,
-            kReasonTimeout,
+            kReasonEpskcTimeout,
             kReasonUnknown,
         };
 
         explicit EphemeralKeyManager(Instance &aInstance);
 
         void SetState(State aState);
-        void Stop(StopReason aReason);
+        void Stop(DeactivationReason aReason);
         void HandleTimer(void);
         void HandleTask(void);
         bool OwnsSession(CoapDtlsSession &aSession) const { return mCoapDtlsSession == &aSession; }
         void HandleSessionConnected(void);
         void HandleSessionDisconnected(SecureSession::ConnectEvent aEvent);
         void HandleCommissionerPetitionAccepted(void);
+        void UpdateCountersAndRecordEvent(DeactivationReason aReason);
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+        bool ShouldRegisterService(void) const;
+        void RegisterOrUnregisterService(void);
+#endif
 
         // Session or Transport callbacks
         static SecureSession *HandleAcceptSession(void *aContext, const Ip6::MessageInfo &aMessageInfo);
@@ -336,7 +426,11 @@ public:
         void                  HandleTransportClosed(void);
 
 #if OT_SHOULD_LOG_AT(OT_LOG_LEVEL_INFO)
-        static const char *StopReasonToString(StopReason aReason);
+        static const char *DeactivationReasonToString(DeactivationReason aReason);
+#endif
+
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+        static const char kServiceType[];
 #endif
 
         using TimeoutTimer = TimerMilliIn<EphemeralKeyManager, &EphemeralKeyManager::HandleTimer>;
@@ -369,6 +463,12 @@ public:
 private:
     static constexpr uint16_t kUdpPort          = OPENTHREAD_CONFIG_BORDER_AGENT_UDP_PORT;
     static constexpr uint32_t kKeepAliveTimeout = 50 * 1000; // Timeout to reject a commissioner (in msec)
+    static constexpr uint16_t kTxtDataMaxSize   = OT_BORDER_AGENT_MESHCOP_SERVICE_TXT_DATA_MAX_LENGTH;
+
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+    static constexpr uint16_t kDummyUdpPort          = 49152;
+    static constexpr uint8_t  kBaseServiceNameMaxLen = OT_BORDER_AGENT_MESHCOP_SERVICE_BASE_NAME_MAX_LENGTH;
+#endif
 
     class CoapDtlsSession : public Coap::SecureSession, public Heap::Allocatable<CoapDtlsSession>
     {
@@ -438,108 +538,52 @@ private:
         uint64_t                   mAllocationTime;
     };
 
-    class MeshCoPTxtEncoder : public InstanceLocator
+    struct StateBitmap
     {
-    public:
-        MeshCoPTxtEncoder(Instance &aInstance, MeshCoPServiceTxtData &aTxtData)
-            : InstanceLocator(aInstance)
-            , mTxtData(aTxtData)
-            , mAppender(mTxtData.mData, sizeof(mTxtData.mData))
-        {
-        }
-
-        enum : uint8_t
-        {
-            kConnectionModeDisabled = 0,
-            kConnectionModePskc     = 1,
-            kConnectionModePskd     = 2,
-            kConnectionModeVendor   = 3,
-            kConnectionModeX509     = 4,
-        };
-
-        enum : uint8_t
-        {
-            kThreadIfStatusNotInitialized = 0,
-            kThreadIfStatusInitialized    = 1,
-            kThreadIfStatusActive         = 2,
-        };
-
-        enum : uint8_t
-        {
-            kThreadRoleDisabledOrDetached = 0,
-            kThreadRoleChild              = 1,
-            kThreadRoleRouter             = 2,
-            kThreadRoleLeader             = 3,
-        };
-
-        enum : uint8_t
-        {
-            kAvailabilityInfrequent = 0,
-            kAvailabilityHigh       = 1,
-        };
-
-        struct StateBitmap
-        {
-            uint32_t mConnectionMode : 3;
-            uint32_t mThreadIfStatus : 2;
-            uint32_t mAvailability : 2;
-            uint32_t mBbrIsActive : 1;
-            uint32_t mBbrIsPrimary : 1;
-            uint32_t mThreadRole : 2;
-            uint32_t mEpskcSupported : 1;
-
-            StateBitmap(void)
-                : mConnectionMode(0)
-                , mThreadIfStatus(0)
-                , mAvailability(0)
-                , mBbrIsActive(0)
-                , mBbrIsPrimary(0)
-                , mThreadRole(kThreadRoleDisabledOrDetached)
-                , mEpskcSupported(0)
-            {
-            }
-
-            uint32_t ToUint32(void) const
-            {
-                uint32_t bitmap = 0;
-
-                bitmap |= mConnectionMode << 0;
-                bitmap |= mThreadIfStatus << 3;
-                bitmap |= mAvailability << 5;
-                bitmap |= mBbrIsActive << 7;
-                bitmap |= mBbrIsPrimary << 8;
-                bitmap |= mThreadRole << 9;
-                bitmap |= mEpskcSupported << 11;
-                return bitmap;
-            }
-        };
-
-        Error EncodeTxtData(void);
-
-    private:
-        Error AppendTxtEntry(const char *aKey, const void *aValue, uint16_t aValueLength);
-
-        template <typename ObjectType> Error AppendTxtEntry(const char *aKey, const ObjectType &aObject)
-        {
-            static_assert(!TypeTraits::IsPointer<ObjectType>::kValue, "ObjectType must not be a pointer");
-            static_assert(!TypeTraits::IsSame<ObjectType, NameData>::kValue, "ObjectType must not be `NameData`");
-
-            return AppendTxtEntry(aKey, &aObject, sizeof(ObjectType));
-        }
-
-#if OPENTHREAD_FTD && OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE
-        Error AppendBbrTxtEntry(StateBitmap aState);
-#endif
-#if OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE
-        Error AppendOmrTxtEntry(void);
-#endif
-
-        StateBitmap GetStateBitmap(void);
-
-        MeshCoPServiceTxtData &mTxtData;
-        Appender               mAppender;
+        // --- State Bitmap ConnectionMode ---
+        static constexpr uint8_t  kOffsetConnectionMode   = 0;
+        static constexpr uint32_t kMaskConnectionMode     = 7 << kOffsetConnectionMode;
+        static constexpr uint32_t kConnectionModeDisabled = 0 << kOffsetConnectionMode;
+        static constexpr uint32_t kConnectionModePskc     = 1 << kOffsetConnectionMode;
+        static constexpr uint32_t kConnectionModePskd     = 2 << kOffsetConnectionMode;
+        static constexpr uint32_t kConnectionModeVendor   = 3 << kOffsetConnectionMode;
+        static constexpr uint32_t kConnectionModeX509     = 4 << kOffsetConnectionMode;
+
+        // --- State Bitmap ThreadIfStatus ---
+        static constexpr uint8_t  kOffsetThreadIfStatus         = 3;
+        static constexpr uint32_t kMaskThreadIfStatus           = 3 << kOffsetThreadIfStatus;
+        static constexpr uint32_t kThreadIfStatusNotInitialized = 0 << kOffsetThreadIfStatus;
+        static constexpr uint32_t kThreadIfStatusInitialized    = 1 << kOffsetThreadIfStatus;
+        static constexpr uint32_t kThreadIfStatusActive         = 2 << kOffsetThreadIfStatus;
+
+        // --- State Bitmap Availability ---
+        static constexpr uint8_t  kOffsetAvailability     = 5;
+        static constexpr uint32_t kMaskAvailability       = 3 << kOffsetAvailability;
+        static constexpr uint32_t kAvailabilityInfrequent = 0 << kOffsetAvailability;
+        static constexpr uint32_t kAvailabilityHigh       = 1 << kOffsetAvailability;
+
+        // --- State Bitmap BbrIsActive ---
+        static constexpr uint8_t  kOffsetBbrIsActive = 7;
+        static constexpr uint32_t kFlagBbrIsActive   = 1 << kOffsetBbrIsActive;
+
+        // --- State Bitmap BbrIsPrimary ---
+        static constexpr uint8_t  kOffsetBbrIsPrimary = 8;
+        static constexpr uint32_t kFlagBbrIsPrimary   = 1 << kOffsetBbrIsPrimary;
+
+        // --- State Bitmap ThreadRole ---
+        static constexpr uint8_t  kOffsetThreadRole             = 9;
+        static constexpr uint32_t kMaskThreadRole               = 3 << kOffsetThreadRole;
+        static constexpr uint32_t kThreadRoleDisabledOrDetached = 0 << kOffsetThreadRole;
+        static constexpr uint32_t kThreadRoleChild              = 1 << kOffsetThreadRole;
+        static constexpr uint32_t kThreadRoleRouter             = 2 << kOffsetThreadRole;
+        static constexpr uint32_t kThreadRoleLeader             = 3 << kOffsetThreadRole;
+
+        // --- State Bitmap EpskcSupported ---
+        static constexpr uint8_t  kOffsetEpskcSupported = 11;
+        static constexpr uint32_t kFlagEpskcSupported   = 1 << kOffsetEpskcSupported;
     };
 
+    void UpdateState(void);
     void Start(void);
     void Stop(void);
     void HandleNotifierEvents(Events aEvents);
@@ -558,21 +602,48 @@ private:
 
     static Coap::Message::Code CoapCodeFromError(Error aError);
 
-    void PostNotifyMeshCoPServiceChangedTask(void);
-    void NotifyMeshCoPServiceChanged(void);
+    Error    PrepareServiceTxtData(uint8_t *aBuffer, uint16_t aBufferSize, uint16_t &aLength);
+    uint32_t DetermineStateBitmap(void) const;
+
+    void PostServiceTask(void);
+    void HandleServiceTask(void);
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE
+    // Callback from `RoutingManager`
+    void HandleFavoredOmrPrefixChanged(void) { PostServiceTask(); }
+#endif
+
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+    const char *GetServiceName(void);
+    bool        IsServiceNameEmpty(void) const { return mServiceName[0] == kNullChar; }
+    void        ConstrcutServiceName(const char *aBaseName, Dns::Name::LabelBuffer &aNameBuffer);
+    void        RegisterService(void);
+    void        UnregisterService(void);
+    void        HandleDnssdPlatformStateChange(void) { PostServiceTask(); }
+#endif
+
+    using ServiceTask = TaskletIn<BorderAgent, &BorderAgent::HandleServiceTask>;
 
-    using NotifyMeshCoPServiceChangedTask = TaskletIn<BorderAgent, &BorderAgent::NotifyMeshCoPServiceChanged>;
+    static const char kTxtDataRecordVersion[];
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+    static const char kServiceType[];
+    static const char kDefaultBaseServiceName[];
+#endif
 
+    bool            mEnabled;
     bool            mIsRunning;
     Dtls::Transport mDtlsTransport;
 #if OPENTHREAD_CONFIG_BORDER_AGENT_ID_ENABLE
     Id   mId;
     bool mIdInitialized;
 #endif
-    Callback<MeshCoPServiceChangedCallback> mMeshCoPServiceChangedCallback;
-    NotifyMeshCoPServiceChangedTask         mNotifyMeshCoPServiceChangedTask;
+    Callback<ServiceChangedCallback> mServiceChangedCallback;
+    ServiceTask                      mServiceTask;
 #if OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
     EphemeralKeyManager mEphemeralKeyManager;
+#endif
+#if OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+    Dns::Name::LabelBuffer mServiceName;
+    Heap::Data             mVendorTxtData;
 #endif
     Counters mCounters;
 };
@@ -581,7 +652,10 @@ DeclareTmfHandler(BorderAgent, kUriRelayRx);
 
 } // namespace MeshCoP
 
+#if OPENTHREAD_CONFIG_BORDER_AGENT_ID_ENABLE
 DefineCoreType(otBorderAgentId, MeshCoP::BorderAgent::Id);
+#endif
+
 DefineCoreType(otBorderAgentSessionIterator, MeshCoP::BorderAgent::SessionIterator);
 
 #if OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
diff --git a/src/core/meshcop/commissioner.cpp b/src/core/meshcop/commissioner.cpp
index 4557ea602..83b2e5b98 100644
--- a/src/core/meshcop/commissioner.cpp
+++ b/src/core/meshcop/commissioner.cpp
@@ -99,7 +99,7 @@ void Commissioner::SignalJoinerEvent(JoinerEvent aEvent, const Joiner *aJoiner)
     }
     else if (aJoiner == mActiveJoiner)
     {
-        mJoinerIid.ConvertToExtAddress(joinerId);
+        joinerId.SetFromIid(mJoinerIid);
     }
     else
     {
@@ -265,7 +265,7 @@ Error Commissioner::Start(StateCallback aStateCallback, JoinerCallback aJoinerCa
 {
     Error error = kErrorNone;
 
-    VerifyOrExit(Get<Mle::MleRouter>().IsAttached(), error = kErrorInvalidState);
+    VerifyOrExit(Get<Mle::Mle>().IsAttached(), error = kErrorInvalidState);
     VerifyOrExit(mState == kStateDisabled, error = kErrorAlready);
 
     SuccessOrExit(error = Get<Tmf::SecureAgent>().Open());
@@ -900,7 +900,7 @@ template <> void Commissioner::HandleTmf<kUriRelayRx>(Coap::Message &aMessage, c
         Joiner         *joiner;
 
         mJoinerIid = joinerIid;
-        mJoinerIid.ConvertToExtAddress(receivedId);
+        receivedId.SetFromIid(mJoinerIid);
 
         joiner = FindBestMatchingJoinerEntry(receivedId);
         VerifyOrExit(joiner != nullptr);
@@ -932,7 +932,7 @@ template <> void Commissioner::HandleTmf<kUriRelayRx>(Coap::Message &aMessage, c
     aMessage.SetOffset(offsetRange.GetOffset());
     SuccessOrExit(error = aMessage.SetLength(offsetRange.GetEndOffset()));
 
-    joinerMessageInfo.SetPeerAddr(Get<Mle::MleRouter>().GetMeshLocalEid());
+    joinerMessageInfo.SetPeerAddr(Get<Mle::Mle>().GetMeshLocalEid());
     joinerMessageInfo.GetPeerAddr().SetIid(mJoinerIid);
     joinerMessageInfo.SetPeerPort(mJoinerPort);
 
diff --git a/src/core/meshcop/dataset_manager.cpp b/src/core/meshcop/dataset_manager.cpp
index 049ce263b..38aba5b48 100644
--- a/src/core/meshcop/dataset_manager.cpp
+++ b/src/core/meshcop/dataset_manager.cpp
@@ -229,7 +229,7 @@ Error DatasetManager::ApplyConfiguration(const Dataset &aDataset) const
 #endif
 
         case Tlv::kMeshLocalPrefix:
-            Get<Mle::MleRouter>().SetMeshLocalPrefix(cur->ReadValueAs<MeshLocalPrefixTlv>());
+            Get<Mle::Mle>().SetMeshLocalPrefix(cur->ReadValueAs<MeshLocalPrefixTlv>());
             break;
 
         case Tlv::kSecurityPolicy:
@@ -324,7 +324,7 @@ void DatasetManager::SaveLocal(const Dataset &aDataset)
 {
     LocalSave(aDataset);
 
-    switch (Get<Mle::MleRouter>().GetRole())
+    switch (Get<Mle::Mle>().GetRole())
     {
     case Mle::kRoleDisabled:
         Restore(aDataset);
@@ -439,7 +439,7 @@ void DatasetManager::SyncLocalWithLeader(const Dataset &aDataset)
     Error error = kErrorNone;
 
     VerifyOrExit(!mMgmtPending, error = kErrorBusy);
-    VerifyOrExit(Get<Mle::MleRouter>().IsChild() || Get<Mle::MleRouter>().IsRouter(), error = kErrorInvalidState);
+    VerifyOrExit(Get<Mle::Mle>().IsChild() || Get<Mle::Mle>().IsRouter(), error = kErrorInvalidState);
 
     VerifyOrExit(mNetworkTimestamp < mLocalTimestamp, error = kErrorAlready);
 
diff --git a/src/core/meshcop/dataset_manager_ftd.cpp b/src/core/meshcop/dataset_manager_ftd.cpp
index 0b57437f8..6c4c9de3c 100644
--- a/src/core/meshcop/dataset_manager_ftd.cpp
+++ b/src/core/meshcop/dataset_manager_ftd.cpp
@@ -98,7 +98,7 @@ Error DatasetManager::ProcessSetOrReplaceRequest(MgmtCommand          aCommand,
     }
 
     if ((dataset.Read<MeshLocalPrefixTlv>(meshLocalPrefix) == kErrorNone) &&
-        (meshLocalPrefix != Get<Mle::MleRouter>().GetMeshLocalPrefix()))
+        (meshLocalPrefix != Get<Mle::Mle>().GetMeshLocalPrefix()))
     {
         aInfo.mAffectsConnectivity = true;
     }
@@ -262,7 +262,7 @@ Error ActiveDatasetManager::GenerateLocal(void)
     Error   error = kErrorNone;
     Dataset dataset;
 
-    VerifyOrExit(Get<Mle::MleRouter>().IsAttached(), error = kErrorInvalidState);
+    VerifyOrExit(Get<Mle::Mle>().IsAttached(), error = kErrorInvalidState);
     VerifyOrExit(!mLocalTimestamp.IsValid(), error = kErrorAlready);
 
     IgnoreError(Read(dataset));
@@ -306,7 +306,7 @@ Error ActiveDatasetManager::GenerateLocal(void)
 
     if (!dataset.Contains<MeshLocalPrefixTlv>())
     {
-        IgnoreError(dataset.Write<MeshLocalPrefixTlv>(Get<Mle::MleRouter>().GetMeshLocalPrefix()));
+        IgnoreError(dataset.Write<MeshLocalPrefixTlv>(Get<Mle::Mle>().GetMeshLocalPrefix()));
     }
 
     if (!dataset.Contains<NetworkKeyTlv>())
diff --git a/src/core/meshcop/joiner.cpp b/src/core/meshcop/joiner.cpp
index b22513b26..4e7cf7fbf 100644
--- a/src/core/meshcop/joiner.cpp
+++ b/src/core/meshcop/joiner.cpp
@@ -135,7 +135,7 @@ Error Joiner::Start(const char      *aPskd,
     // Use random-generated extended address.
     randomAddress.GenerateRandom();
     Get<Mac::Mac>().SetExtAddress(randomAddress);
-    Get<Mle::MleRouter>().UpdateLinkLocalAddress();
+    Get<Mle::Mle>().UpdateLinkLocalAddress();
 
     SuccessOrExit(error = Get<Tmf::SecureAgent>().Open(Ip6::NetifIdentifier::kNetifThreadInternal));
     SuccessOrExit(error = Get<Tmf::SecureAgent>().Bind(kJoinerUdpPort));
@@ -249,14 +249,14 @@ void Joiner::HandleDiscoverResult(Mle::DiscoverScanner::ScanResult *aResult)
 {
     VerifyOrExit(mState == kStateDiscover);
 
-    if (aResult != nullptr && aResult->mJoinerUdpPort > 0)
+    if (aResult != nullptr)
     {
         SaveDiscoveredJoinerRouter(*aResult);
     }
     else
     {
         Get<Mac::Mac>().SetExtAddress(mId);
-        Get<Mle::MleRouter>().UpdateLinkLocalAddress();
+        Get<Mle::Mle>().UpdateLinkLocalAddress();
 
         mJoinerRouterIndex = 0;
         TryNextJoinerRouter(kErrorNone);
@@ -270,9 +270,11 @@ void Joiner::SaveDiscoveredJoinerRouter(const Mle::DiscoverScanner::ScanResult &
 {
     uint8_t       priority;
     bool          doesAllowAny;
-    JoinerRouter *end = GetArrayEnd(mJoinerRouters);
+    JoinerRouter *end;
     JoinerRouter *entry;
 
+    VerifyOrExit(aResult.mJoinerUdpPort > 0);
+
     doesAllowAny = AsCoreType(&aResult.mSteeringData).PermitsAllJoiners();
 
     LogInfo("Joiner discover network: %s, pan:0x%04x, port:%d, chan:%d, rssi:%d, allow-any:%s",
@@ -284,6 +286,8 @@ void Joiner::SaveDiscoveredJoinerRouter(const Mle::DiscoverScanner::ScanResult &
     // We keep the list sorted based on priority. Find the place to
     // add the new result.
 
+    end = GetArrayEnd(mJoinerRouters);
+
     for (entry = &mJoinerRouters[0]; entry < end; entry++)
     {
         if (priority > entry->mPriority)
@@ -573,7 +577,7 @@ void Joiner::HandleTimer(void)
 
         extAddress.GenerateRandom();
         Get<Mac::Mac>().SetExtAddress(extAddress);
-        Get<Mle::MleRouter>().UpdateLinkLocalAddress();
+        Get<Mle::Mle>().UpdateLinkLocalAddress();
 
         error = kErrorNone;
         break;
diff --git a/src/core/meshcop/joiner_router.cpp b/src/core/meshcop/joiner_router.cpp
index 6d515aa81..b93ed9a0b 100644
--- a/src/core/meshcop/joiner_router.cpp
+++ b/src/core/meshcop/joiner_router.cpp
@@ -61,7 +61,7 @@ void JoinerRouter::HandleNotifierEvents(Events aEvents)
 
 void JoinerRouter::Start(void)
 {
-    VerifyOrExit(Get<Mle::MleRouter>().IsFullThreadDevice());
+    VerifyOrExit(Get<Mle::Mle>().IsFullThreadDevice());
 
     if (Get<NetworkData::Leader>().IsJoiningAllowed())
     {
@@ -132,7 +132,7 @@ void JoinerRouter::HandleUdpReceive(Message &aMessage, const Ip6::MessageInfo &a
 
     SuccessOrExit(error = Tlv::Append<JoinerUdpPortTlv>(*message, aMessageInfo.GetPeerPort()));
     SuccessOrExit(error = Tlv::Append<JoinerIidTlv>(*message, aMessageInfo.GetPeerAddr().GetIid()));
-    SuccessOrExit(error = Tlv::Append<JoinerRouterLocatorTlv>(*message, Get<Mle::MleRouter>().GetRloc16()));
+    SuccessOrExit(error = Tlv::Append<JoinerRouterLocatorTlv>(*message, Get<Mle::Mle>().GetRloc16()));
 
     offsetRange.InitFromMessageOffsetToEnd(aMessage);
 
diff --git a/src/core/meshcop/meshcop_leader.cpp b/src/core/meshcop/meshcop_leader.cpp
index 3f8e746ca..24028c197 100644
--- a/src/core/meshcop/meshcop_leader.cpp
+++ b/src/core/meshcop/meshcop_leader.cpp
@@ -60,9 +60,9 @@ template <> void Leader::HandleTmf<kUriLeaderPetition>(Coap::Message &aMessage,
 
     LogInfo("Received %s", UriToString<kUriLeaderPetition>());
 
-    VerifyOrExit(Get<Mle::MleRouter>().IsLeader());
+    VerifyOrExit(Get<Mle::Mle>().IsLeader());
 
-    VerifyOrExit(Get<Mle::MleRouter>().IsRoutingLocator(aMessageInfo.GetPeerAddr()));
+    VerifyOrExit(Get<Mle::Mle>().IsRoutingLocator(aMessageInfo.GetPeerAddr()));
 
     SuccessOrExit(Tlv::Find<CommissionerIdTlv>(aMessage, commissionerId));
 
@@ -124,7 +124,7 @@ template <> void Leader::HandleTmf<kUriLeaderKeepAlive>(Coap::Message &aMessage,
 
     LogInfo("Received %s", UriToString<kUriLeaderKeepAlive>());
 
-    VerifyOrExit(Get<Mle::MleRouter>().IsLeader());
+    VerifyOrExit(Get<Mle::Mle>().IsLeader());
 
     SuccessOrExit(Tlv::Find<StateTlv>(aMessage, state));
 
@@ -214,7 +214,7 @@ exit:
 
 void Leader::HandleTimer(void)
 {
-    VerifyOrExit(Get<Mle::MleRouter>().IsLeader());
+    VerifyOrExit(Get<Mle::Mle>().IsLeader());
 
     ResignCommissioner();
 
diff --git a/src/core/meshcop/meshcop_tlvs.cpp b/src/core/meshcop/meshcop_tlvs.cpp
index db54907e5..03ebef398 100644
--- a/src/core/meshcop/meshcop_tlvs.cpp
+++ b/src/core/meshcop/meshcop_tlvs.cpp
@@ -140,20 +140,26 @@ Error ChannelMaskTlv::ReadChannelMask(uint32_t &aChannelMask) const
 Error ChannelMaskTlv::FindIn(const Message &aMessage, uint32_t &aChannelMask)
 {
     Error       error;
-    EntriesData entriesData;
     OffsetRange offsetRange;
 
-    entriesData.Clear();
-    entriesData.mMessage = &aMessage;
-
     SuccessOrExit(error = FindTlvValueOffsetRange(aMessage, Tlv::kChannelMask, offsetRange));
-    entriesData.mOffsetRange = offsetRange;
-    error                    = entriesData.Parse(aChannelMask);
+    error = ParseValue(aMessage, offsetRange, aChannelMask);
 
 exit:
     return error;
 }
 
+Error ChannelMaskTlv::ParseValue(const Message &aMessage, const OffsetRange &aOffsetRange, uint32_t &aChannelMask)
+{
+    EntriesData entriesData;
+
+    entriesData.Clear();
+    entriesData.mMessage     = &aMessage;
+    entriesData.mOffsetRange = aOffsetRange;
+
+    return entriesData.Parse(aChannelMask);
+}
+
 Error ChannelMaskTlv::EntriesData::Parse(uint32_t &aChannelMask)
 {
     // Validates and parses the Channel Mask TLV entries for each
@@ -217,7 +223,7 @@ exit:
     return error;
 }
 
-void ChannelMaskTlv::PrepareValue(Value &aValue, uint32_t aChannelMask)
+void ChannelMaskTlv::PrepareValue(Value &aValue, uint32_t aChannelMask, bool aIncludeZeroPageMasks)
 {
     Entry *entry = reinterpret_cast<Entry *>(aValue.mData);
 
@@ -227,7 +233,7 @@ void ChannelMaskTlv::PrepareValue(Value &aValue, uint32_t aChannelMask)
     {
         uint32_t mask = (Radio::ChannelMaskForPage(page) & aChannelMask);
 
-        if (mask != 0)
+        if ((mask != 0) || aIncludeZeroPageMasks)
         {
             entry->SetChannelPage(page);
             entry->SetMaskLength(kMaskLength);
diff --git a/src/core/meshcop/meshcop_tlvs.hpp b/src/core/meshcop/meshcop_tlvs.hpp
index 713384aca..1c472fbec 100644
--- a/src/core/meshcop/meshcop_tlvs.hpp
+++ b/src/core/meshcop/meshcop_tlvs.hpp
@@ -640,13 +640,31 @@ public:
      */
     static Error FindIn(const Message &aMessage, uint32_t &aChannelMask);
 
+    /**
+     * Parses and validates the TLV value and returns the combined channel mask for all supported channel pages
+     * included in the TLV.
+     *
+     * The Channel Mask TLV value entries for each channel page are parsed one by one and `aChannelMask` is updated
+     * to return the combined mask for all channel pages that are supported by radio. Note that @p aOffsetRange
+     * corresponds to offset range where the TLV value resides within @p aMessage (not the full TLV).
+     *
+     * @param[in]  aMessage       The message to read the TLV value from.
+     * @param[in]  aOffsetRange   The offset range for the TLV value.
+     * @param[out] aChannelMask   A reference to return the channel mask.
+     *
+     * @retval kErrorNone       Successfully parsed the TLV value, @p aChannelMask is updated.
+     * @retval kErrorParse      Failed to parse the TLV value.
+     */
+    static Error ParseValue(const Message &aMessage, const OffsetRange &aOffsetRange, uint32_t &aChannelMask);
+
     /**
      * Prepares Channel Mask TLV value for appending/writing.
      *
-     * @param[out] aValue        A reference to `Value` structure to populate.
-     * @param[in]  aChannelMask  The combined channel mask for all supported channel pages.
+     * @param[out] aValue                A reference to `Value` structure to populate.
+     * @param[in]  aChannelMask          The combined channel mask for all supported channel pages.
+     * @param[in]  aIncludeZeroPageMasks Determine whether to include or skip a zero mask for a supported channel page.
      */
-    static void PrepareValue(Value &aValue, uint32_t aChannelMask);
+    static void PrepareValue(Value &aValue, uint32_t aChannelMask, bool aIncludeZeroPageMasks = false);
 
     /**
      * Prepares a Channel Mask TLV value and appends the TLV to a given message.
@@ -816,7 +834,7 @@ public:
      *
      * @returns The Build value.
      */
-    uint16_t GetBuild(void) const { return (BigEndian::HostSwap16(mBuildRevision) & kBuildMask) >> kBuildOffset; }
+    uint16_t GetBuild(void) const { return ReadBitsBigEndian<uint16_t, kBuildMask>(mBuildRevision); }
 
     /**
      * Sets the Build value.
@@ -825,8 +843,7 @@ public:
      */
     void SetBuild(uint16_t aBuild)
     {
-        mBuildRevision = BigEndian::HostSwap16((BigEndian::HostSwap16(mBuildRevision) & ~kBuildMask) |
-                                               ((aBuild << kBuildOffset) & kBuildMask));
+        mBuildRevision = UpdateBitsBigEndian<uint16_t, kBuildMask>(mBuildRevision, aBuild);
     }
 
     /**
@@ -834,7 +851,7 @@ public:
      *
      * @returns The Revision value.
      */
-    uint8_t GetRevision(void) const { return (BigEndian::HostSwap16(mBuildRevision) & kRevMask) >> kRevOffset; }
+    uint8_t GetRevision(void) const { return ReadBitsBigEndian<uint16_t, kRevMask>(mBuildRevision); }
 
     /**
      * Sets the Revision value.
@@ -843,8 +860,7 @@ public:
      */
     void SetRevision(uint8_t aRevision)
     {
-        mBuildRevision = BigEndian::HostSwap16((BigEndian::HostSwap16(mBuildRevision) & ~kRevMask) |
-                                               ((aRevision << kRevOffset) & kRevMask));
+        mBuildRevision = UpdateBitsBigEndian<uint16_t, kRevMask>(mBuildRevision, static_cast<uint16_t>(aRevision));
     }
 
     /**
@@ -852,34 +868,28 @@ public:
      *
      * @returns The Minor value.
      */
-    uint8_t GetMinor(void) const { return (mMinorMajor & kMinorMask) >> kMinorOffset; }
+    uint8_t GetMinor(void) const { return ReadBits<uint8_t, kMinorMask>(mMinorMajor); }
 
     /**
      * Sets the Minor value.
      *
      * @param[in]  aMinor  The Minor value.
      */
-    void SetMinor(uint8_t aMinor)
-    {
-        mMinorMajor = (mMinorMajor & ~kMinorMask) | ((aMinor << kMinorOffset) & kMinorMask);
-    }
+    void SetMinor(uint8_t aMinor) { WriteBits<uint8_t, kMinorMask>(mMinorMajor, aMinor); }
 
     /**
      * Returns the Major value.
      *
      * @returns The Major value.
      */
-    uint8_t GetMajor(void) const { return (mMinorMajor & kMajorMask) >> kMajorOffset; }
+    uint8_t GetMajor(void) const { return ReadBits<uint8_t, kMajorMask>(mMinorMajor); }
 
     /**
      * Sets the Major value.
      *
      * @param[in] aMajor  The Major value.
      */
-    void SetMajor(uint8_t aMajor)
-    {
-        mMinorMajor = (mMinorMajor & ~kMajorMask) | ((aMajor << kMajorOffset) & kMajorMask);
-    }
+    void SetMajor(uint8_t aMajor) { WriteBits<uint8_t, kMajorMask>(mMinorMajor, aMajor); }
 
 private:
     // For `mBuildRevision`
@@ -988,10 +998,7 @@ public:
      *
      * @param[in]  aVersion  The Version value.
      */
-    void SetVersion(uint8_t aVersion)
-    {
-        mFlags = (mFlags & ~kVersionMask) | ((aVersion << kVersionOffset) & kVersionMask);
-    }
+    void SetVersion(uint8_t aVersion) { WriteBits<uint8_t, kVersionMask>(mFlags, aVersion); }
 
     /**
      * Indicates whether or not the Joiner flag is set.
@@ -1006,17 +1013,7 @@ public:
      *
      * @param[in]  aJoiner  TRUE if set, FALSE otherwise.
      */
-    void SetJoiner(bool aJoiner)
-    {
-        if (aJoiner)
-        {
-            mFlags |= kJoinerMask;
-        }
-        else
-        {
-            mFlags &= ~kJoinerMask;
-        }
-    }
+    void SetJoiner(bool aJoiner) { WriteBit<uint8_t>(mFlags, kJoinerOffset, aJoiner); }
 
 private:
     static constexpr uint8_t kVersionOffset = 4;
@@ -1059,17 +1056,14 @@ public:
      *
      * @returns The Version value.
      */
-    uint8_t GetVersion(void) const { return mFlags >> kVersionOffset; }
+    uint8_t GetVersion(void) const { return ReadBits<uint8_t, kVersionMask>(mFlags); }
 
     /**
      * Sets the Version value.
      *
      * @param[in]  aVersion  The Version value.
      */
-    void SetVersion(uint8_t aVersion)
-    {
-        mFlags = (mFlags & ~kVersionMask) | ((aVersion << kVersionOffset) & kVersionMask);
-    }
+    void SetVersion(uint8_t aVersion) { WriteBits<uint8_t, kVersionMask>(mFlags, aVersion); }
 
     /**
      * Indicates whether or not the Native Commissioner flag is set.
@@ -1077,7 +1071,7 @@ public:
      * @retval TRUE   If the Native Commissioner flag is set.
      * @retval FALSE  If the Native Commissioner flag is not set.
      */
-    bool IsNativeCommissioner(void) const { return (mFlags & kNativeMask) != 0; }
+    bool IsNativeCommissioner(void) const { return GetBit<uint8_t>(mFlags, kNativeOffset); }
 
     /**
      * Sets the Native Commissioner flag.
@@ -1086,14 +1080,7 @@ public:
      */
     void SetNativeCommissioner(bool aNativeCommissioner)
     {
-        if (aNativeCommissioner)
-        {
-            mFlags |= kNativeMask;
-        }
-        else
-        {
-            mFlags &= ~kNativeMask;
-        }
+        WriteBit<uint8_t>(mFlags, kNativeOffset, aNativeCommissioner);
     }
 
     /**
@@ -1102,32 +1089,20 @@ public:
      * @retval TRUE   If the Commercial Commissioning Mode flag is set.
      * @retval FALSE  If the Commercial Commissioning Mode flag is not set.
      */
-    bool IsCommercialCommissioningMode(void) const { return (mFlags & kCcmMask) != 0; }
+    bool IsCommercialCommissioningMode(void) const { return GetBit<uint8_t>(mFlags, kCcmOffset); }
 
     /**
      * Sets the Commercial Commissioning Mode flag.
      *
      * @param[in]  aCcm  TRUE if set, FALSE otherwise.
      */
-    void SetCommercialCommissioningMode(bool aCcm)
-    {
-        if (aCcm)
-        {
-            mFlags |= kCcmMask;
-        }
-        else
-        {
-            mFlags &= ~kCcmMask;
-        }
-    }
+    void SetCommercialCommissioningMode(bool aCcm) { WriteBit<uint8_t>(mFlags, kCcmOffset, aCcm); }
 
 private:
     static constexpr uint8_t kVersionOffset = 4;
     static constexpr uint8_t kVersionMask   = 0xf << kVersionOffset;
     static constexpr uint8_t kNativeOffset  = 3;
-    static constexpr uint8_t kNativeMask    = 1 << kNativeOffset;
     static constexpr uint8_t kCcmOffset     = 2;
-    static constexpr uint8_t kCcmMask       = 1 << kCcmOffset;
 
     uint8_t mFlags;
     uint8_t mReserved;
diff --git a/src/core/meshcop/secure_transport.cpp b/src/core/meshcop/secure_transport.cpp
index a9546ad81..13e61fe32 100644
--- a/src/core/meshcop/secure_transport.cpp
+++ b/src/core/meshcop/secure_transport.cpp
@@ -311,6 +311,13 @@ Error SecureSession::Setup(void)
         VerifyOrExit(rval == 0);
     }
 
+#if defined(MBEDTLS_X509_CRT_PARSE_C)
+    if (!mIsServer)
+    {
+        mbedtls_ssl_set_hostname(&mSsl, nullptr);
+    }
+#endif
+
     mReceiveMessage = nullptr;
     mMessageSubType = Message::kSubTypeNone;
 
diff --git a/src/core/meshcop/secure_transport.hpp b/src/core/meshcop/secure_transport.hpp
index 5e2c14f0e..d5fcaec00 100644
--- a/src/core/meshcop/secure_transport.hpp
+++ b/src/core/meshcop/secure_transport.hpp
@@ -118,6 +118,7 @@ public:
     static constexpr ConnectEvent kDisconnectedLocalClosed = OT_COAP_SECURE_DISCONNECTED_LOCAL_CLOSED;
     static constexpr ConnectEvent kDisconnectedMaxAttempts = OT_COAP_SECURE_DISCONNECTED_MAX_ATTEMPTS;
     static constexpr ConnectEvent kDisconnectedError       = OT_COAP_SECURE_DISCONNECTED_ERROR;
+    static constexpr ConnectEvent kDisconnectedTimeout     = OT_COAP_SECURE_DISCONNECTED_TIMEOUT;
 
     /**
      * Function pointer which is called reporting a session connection event.
@@ -176,6 +177,11 @@ public:
      */
     void Disconnect(void) { Disconnect(kDisconnectedLocalClosed); }
 
+    /**
+     * Disconnects the session due to timeout.
+     */
+    void DisconnectTimeout(void) { Disconnect(kDisconnectedTimeout); }
+
     /**
      * Sends message to the secure session.
      *
diff --git a/src/core/meshcop/tcat_agent.cpp b/src/core/meshcop/tcat_agent.cpp
index c98850aa5..805ce212d 100644
--- a/src/core/meshcop/tcat_agent.cpp
+++ b/src/core/meshcop/tcat_agent.cpp
@@ -37,6 +37,7 @@
 #if OPENTHREAD_CONFIG_BLE_TCAT_ENABLE
 
 #include "instance/instance.hpp"
+#include "thread/network_diagnostic.hpp"
 
 namespace ot {
 namespace MeshCoP {
@@ -408,6 +409,10 @@ Error TcatAgent::HandleSingleTlv(const Message &aIncomingMessage, Message &aOutg
             error = HandleGetActiveOperationalDataset(aOutgoingMessage, response);
             break;
 
+        case kTlvGetDiagnosticTlvs:
+            error = HandleGetDiagnosticTlvs(aIncomingMessage, aOutgoingMessage, offset, length, response);
+            break;
+
         case kTlvStartThreadInterface:
             error = HandleStartThreadInterface();
             break;
@@ -584,6 +589,65 @@ exit:
     return error;
 }
 
+Error TcatAgent::HandleGetDiagnosticTlvs(const Message &aIncomingMessage,
+                                         Message       &aOutgoingMessage,
+                                         uint16_t       aOffset,
+                                         uint16_t       aLength,
+                                         bool          &aResponse)
+{
+    Error           error = kErrorNone;
+    OffsetRange     offsetRange;
+    ot::ExtendedTlv extTlv;
+    uint16_t        initialLength;
+    uint16_t        length;
+
+    if (!CheckCommandClassAuthorizationFlags(mCommissionerAuthorizationField.mCommissioningFlags,
+                                             mDeviceAuthorizationField.mCommissioningFlags, nullptr))
+    {
+        error = kErrorRejected;
+        ExitNow();
+    }
+
+    offsetRange.Init(aOffset, aLength);
+    initialLength = aOutgoingMessage.GetLength();
+
+    // Start with extTlv to avoid the need for a temporary message buffer to calucalate reply length
+    extTlv.SetType(kTlvResponseWithPayload);
+    extTlv.SetLength(0);
+    SuccessOrExit(error = aOutgoingMessage.Append(extTlv));
+
+    error =
+        Get<NetworkDiagnostic::Server>().AppendRequestedTlvsForTcat(aIncomingMessage, aOutgoingMessage, offsetRange);
+
+    // Ensure enough message buffers are left for transmission of the result. Report error otherwise.
+    if (Get<MessagePool>().GetFreeBufferCount() < kBufferReserve)
+    {
+        error = kErrorNoBufs;
+    }
+
+    if (error != kErrorNone)
+    {
+        IgnoreError(aOutgoingMessage.SetLength(initialLength));
+        ExitNow();
+    }
+
+    length = aOutgoingMessage.GetLength() - initialLength - sizeof(extTlv);
+
+    if (length > 0)
+    {
+        extTlv.SetLength(length);
+        aOutgoingMessage.WriteBytes(initialLength, &extTlv, sizeof(extTlv));
+        aResponse = true;
+    }
+    else
+    {
+        IgnoreError(aOutgoingMessage.SetLength(initialLength));
+    }
+
+exit:
+    return error;
+}
+
 Error TcatAgent::HandleDecomission(void)
 {
     Error         error = kErrorNone;
@@ -860,7 +924,7 @@ Error TcatAgent::HandleStartThreadInterface(void)
 #endif
 
     Get<ThreadNetif>().Up();
-    error = Get<Mle::MleRouter>().Start();
+    error = Get<Mle::Mle>().Start();
 
 exit:
     return error;
diff --git a/src/core/meshcop/tcat_agent.hpp b/src/core/meshcop/tcat_agent.hpp
index 3781a714d..9225d5afe 100644
--- a/src/core/meshcop/tcat_agent.hpp
+++ b/src/core/meshcop/tcat_agent.hpp
@@ -340,6 +340,11 @@ private:
     Error HandleSingleTlv(const Message &aIncomingMessage, Message &aOutgoingMessage);
     Error HandleSetActiveOperationalDataset(const Message &aIncomingMessage, uint16_t aOffset, uint16_t aLength);
     Error HandleGetActiveOperationalDataset(Message &aOutgoingMessage, bool &aResponse);
+    Error HandleGetDiagnosticTlvs(const Message &aIncomingMessage,
+                                  Message       &aOutgoingMessage,
+                                  uint16_t       aOffset,
+                                  uint16_t       aLength,
+                                  bool          &response);
     Error HandleDecomission(void);
     Error HandlePing(const Message &aIncomingMessage,
                      Message       &aOutgoingMessage,
@@ -383,6 +388,7 @@ private:
     static constexpr uint16_t kTcatMaxDeviceIdSize       = OT_TCAT_MAX_DEVICEID_SIZE;
     static constexpr uint16_t kInstallCodeMaxSize        = 255;
     static constexpr uint16_t kCommissionerCertMaxLength = 1024;
+    static constexpr uint16_t kBufferReserve             = 2048 / (kBufferSize - sizeof(otMessageBuffer)) + 1;
 
     JoinerPskd                       mJoinerPskd;
     const VendorInfo                *mVendorInfo;
diff --git a/src/core/meshcop/timestamp.cpp b/src/core/meshcop/timestamp.cpp
index 59732fe9b..1c0fb1570 100644
--- a/src/core/meshcop/timestamp.cpp
+++ b/src/core/meshcop/timestamp.cpp
@@ -92,7 +92,7 @@ void Timestamp::SetSeconds(uint64_t aSeconds)
 
 void Timestamp::SetTicks(uint16_t aTicks)
 {
-    SetTicksAndAuthFlag((GetTicksAndAuthFlag() & ~kTicksMask) | ((aTicks << kTicksOffset) & kTicksMask));
+    SetTicksAndAuthFlag(UpdateBits<uint16_t, kTicksMask>(GetTicksAndAuthFlag(), aTicks));
 }
 
 void Timestamp::SetAuthoritative(bool aAuthoritative)
diff --git a/src/core/mtd.cmake b/src/core/mtd.cmake
index ae8d9e3ef..ebef0d3b4 100644
--- a/src/core/mtd.cmake
+++ b/src/core/mtd.cmake
@@ -36,6 +36,7 @@ target_compile_definitions(openthread-mtd PRIVATE
 
 target_compile_options(openthread-mtd PRIVATE
     ${OT_CFLAGS}
+    -Wundef
 )
 
 target_include_directories(openthread-mtd PUBLIC ${OT_PUBLIC_INCLUDES} PRIVATE ${COMMON_INCLUDES})
diff --git a/src/core/net/dhcp6_client.cpp b/src/core/net/dhcp6_client.cpp
index b8b99e6e5..4a461b478 100644
--- a/src/core/net/dhcp6_client.cpp
+++ b/src/core/net/dhcp6_client.cpp
@@ -268,9 +268,9 @@ void Client::Solicit(uint16_t aRloc16)
 #if OPENTHREAD_ENABLE_DHCP6_MULTICAST_SOLICIT
     messageInfo.GetPeerAddr().SetToRealmLocalAllRoutersMulticast();
 #else
-    messageInfo.GetPeerAddr().SetToRoutingLocator(Get<Mle::MleRouter>().GetMeshLocalPrefix(), aRloc16);
+    messageInfo.GetPeerAddr().SetToRoutingLocator(Get<Mle::Mle>().GetMeshLocalPrefix(), aRloc16);
 #endif
-    messageInfo.SetSockAddr(Get<Mle::MleRouter>().GetMeshLocalRloc());
+    messageInfo.SetSockAddr(Get<Mle::Mle>().GetMeshLocalRloc());
     messageInfo.mPeerPort = kDhcpServerPort;
 
     SuccessOrExit(error = mSocket.SendTo(*message, messageInfo));
diff --git a/src/core/net/dhcp6_server.cpp b/src/core/net/dhcp6_server.cpp
index 7e9c07e47..e595189af 100644
--- a/src/core/net/dhcp6_server.cpp
+++ b/src/core/net/dhcp6_server.cpp
@@ -54,7 +54,7 @@ Server::Server(Instance &aInstance)
 Error Server::UpdateService(void)
 {
     Error                           error  = kErrorNone;
-    uint16_t                        rloc16 = Get<Mle::MleRouter>().GetRloc16();
+    uint16_t                        rloc16 = Get<Mle::Mle>().GetRloc16();
     NetworkData::Iterator           iterator;
     NetworkData::OnMeshPrefixConfig config;
     Lowpan::Context                 lowpanContext;
@@ -159,7 +159,7 @@ void Server::AddPrefixAgent(const Ip6::Prefix &aIp6Prefix, const Lowpan::Context
 
     VerifyOrExit(newEntry != nullptr, error = kErrorNoBufs);
 
-    newEntry->Set(aIp6Prefix, Get<Mle::MleRouter>().GetMeshLocalPrefix(), aContext.mContextId);
+    newEntry->Set(aIp6Prefix, Get<Mle::Mle>().GetMeshLocalPrefix(), aContext.mContextId);
     Get<ThreadNetif>().AddUnicastAddress(newEntry->GetAloc());
     mPrefixAgentsCount++;
 
diff --git a/src/core/net/dns_client.cpp b/src/core/net/dns_client.cpp
index 070fec156..d5a242e81 100644
--- a/src/core/net/dns_client.cpp
+++ b/src/core/net/dns_client.cpp
@@ -374,6 +374,68 @@ exit:
 
 #endif // OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
 
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+
+Error Client::Response::ReadRecordInfo(uint16_t aIndex, RecordInfo &aRecordInfo) const
+{
+    Error             error;
+    uint16_t          offset;
+    ResourceRecord    record;
+    OwnedPtr<Message> decompressedData;
+
+    if (aIndex < mAnswerRecordCount)
+    {
+        aRecordInfo.mSection = MapEnum(RecordInfo::kSectionAnswer);
+    }
+    else if (aIndex < mAnswerRecordCount + mAuthorityRecordCount)
+    {
+        aRecordInfo.mSection = MapEnum(RecordInfo::kSectionAuthority);
+    }
+    else if (aIndex < mAnswerRecordCount + mAuthorityRecordCount + mAdditionalRecordCount)
+    {
+        aRecordInfo.mSection = MapEnum(RecordInfo::kSectionAdditional);
+    }
+    else
+    {
+        ExitNow(error = kErrorNotFound);
+    }
+
+    offset = mAnswerOffset;
+    SuccessOrExit(error = ResourceRecord::ParseRecords(*mMessage, offset, aIndex));
+
+    SuccessOrExit(error = Name::ReadName(*mMessage, offset, aRecordInfo.mNameBuffer, aRecordInfo.mNameBufferSize));
+
+    SuccessOrExit(error = mMessage->Read(offset, record));
+
+    SuccessOrExit(error = ResourceRecord::DecompressRecordData(*mMessage, offset, decompressedData));
+
+    aRecordInfo.mRecordType   = record.GetType();
+    aRecordInfo.mRecordLength = (decompressedData != nullptr) ? decompressedData->GetLength() : record.GetLength();
+    aRecordInfo.mTtl          = record.GetTtl();
+
+    if (aRecordInfo.mDataBuffer == nullptr)
+    {
+        aRecordInfo.mDataBufferSize = 0;
+        ExitNow();
+    }
+
+    aRecordInfo.mDataBufferSize = Min(aRecordInfo.mRecordLength, aRecordInfo.mDataBufferSize);
+
+    if (decompressedData != nullptr)
+    {
+        decompressedData->ReadBytes(0, aRecordInfo.mDataBuffer, aRecordInfo.mDataBufferSize);
+    }
+    else
+    {
+        mMessage->ReadBytes(offset + sizeof(ResourceRecord), aRecordInfo.mDataBuffer, aRecordInfo.mDataBufferSize);
+    }
+
+exit:
+    return error;
+}
+
+#endif // OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+
 void Client::Response::PopulateFrom(const Message &aMessage)
 {
     // Populate `Response` with info from `aMessage`.
@@ -394,11 +456,13 @@ void Client::Response::PopulateFrom(const Message &aMessage)
 
     mAnswerOffset = offset;
     IgnoreError(ResourceRecord::ParseRecords(aMessage, offset, header.GetAnswerCount()));
+    mAuthorityOffset = offset;
     IgnoreError(ResourceRecord::ParseRecords(aMessage, offset, header.GetAuthorityRecordCount()));
     mAdditionalOffset = offset;
     IgnoreError(ResourceRecord::ParseRecords(aMessage, offset, header.GetAdditionalRecordCount()));
 
     mAnswerRecordCount     = header.GetAnswerCount();
+    mAuthorityRecordCount  = header.GetAuthorityRecordCount();
     mAdditionalRecordCount = header.GetAdditionalRecordCount();
 }
 
@@ -691,42 +755,6 @@ Error Client::ServiceResponse::GetHostAddress(const char   *aHostName,
 //---------------------------------------------------------------------------------------------------------------------
 // Client
 
-const uint16_t Client::kIp6AddressQueryRecordTypes[] = {ResourceRecord::kTypeAaaa};
-#if OPENTHREAD_CONFIG_DNS_CLIENT_NAT64_ENABLE
-const uint16_t Client::kIp4AddressQueryRecordTypes[] = {ResourceRecord::kTypeA};
-#endif
-#if OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
-const uint16_t Client::kBrowseQueryRecordTypes[]  = {ResourceRecord::kTypePtr};
-const uint16_t Client::kServiceQueryRecordTypes[] = {ResourceRecord::kTypeSrv, ResourceRecord::kTypeTxt};
-#endif
-
-const uint8_t Client::kQuestionCount[] = {
-    /* kIp6AddressQuery -> */ GetArrayLength(kIp6AddressQueryRecordTypes), // AAAA record
-#if OPENTHREAD_CONFIG_DNS_CLIENT_NAT64_ENABLE
-    /* kIp4AddressQuery -> */ GetArrayLength(kIp4AddressQueryRecordTypes), // A record
-#endif
-#if OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
-    /* kBrowseQuery        -> */ GetArrayLength(kBrowseQueryRecordTypes),  // PTR record
-    /* kServiceQuerySrvTxt -> */ GetArrayLength(kServiceQueryRecordTypes), // SRV and TXT records
-    /* kServiceQuerySrv    -> */ 1,                                        // SRV record only
-    /* kServiceQueryTxt    -> */ 1,                                        // TXT record only
-#endif
-};
-
-const uint16_t *const Client::kQuestionRecordTypes[] = {
-    /* kIp6AddressQuery -> */ kIp6AddressQueryRecordTypes,
-#if OPENTHREAD_CONFIG_DNS_CLIENT_NAT64_ENABLE
-    /* kIp4AddressQuery -> */ kIp4AddressQueryRecordTypes,
-#endif
-#if OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
-    /* kBrowseQuery  -> */ kBrowseQueryRecordTypes,
-    /* kServiceQuerySrvTxt -> */ kServiceQueryRecordTypes,
-    /* kServiceQuerySrv    -> */ &kServiceQueryRecordTypes[0],
-    /* kServiceQueryTxt    -> */ &kServiceQueryRecordTypes[1],
-
-#endif
-};
-
 Client::Client(Instance &aInstance)
     : InstanceLocator(aInstance)
     , mSocket(aInstance, *this)
@@ -972,6 +1000,28 @@ exit:
 
 #endif // OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
 
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+Error Client::QueryRecord(uint16_t           aRecordType,
+                          const char        *aFirstLabel,
+                          const char        *aNextLabels,
+                          RecordCallback     aCallback,
+                          void              *aContext,
+                          const QueryConfig *aConfig)
+{
+    QueryInfo info;
+
+    info.Clear();
+    info.mQueryType  = kRecordQuery;
+    info.mRecordType = aRecordType;
+    info.mConfig.SetFrom(aConfig, mDefaultConfig);
+    info.mCallback.mRecordCallback = aCallback;
+    info.mCallbackContext          = aContext;
+
+    return StartQuery(info, aFirstLabel, aNextLabels);
+}
+
+#endif // OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+
 Error Client::StartQuery(QueryInfo &aInfo, const char *aLabel, const char *aName, QueryType aSecondType)
 {
     // The `aLabel` can be `nullptr` and then `aName` provides the
@@ -1117,7 +1167,14 @@ Error Client::SendQuery(Query &aQuery, QueryInfo &aInfo, bool aUpdateTimer)
         header.SetRecursionDesiredFlag();
     }
 
-    header.SetQuestionCount(kQuestionCount[aInfo.mQueryType]);
+    header.SetQuestionCount(1);
+
+#if OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
+    if (aInfo.mQueryType == kServiceQuerySrvTxt)
+    {
+        header.SetQuestionCount(2);
+    }
+#endif
 
     message = mSocket.NewMessage();
     VerifyOrExit(message != nullptr, error = kErrorNoBufs);
@@ -1126,11 +1183,16 @@ Error Client::SendQuery(Query &aQuery, QueryInfo &aInfo, bool aUpdateTimer)
 
     // Prepare the question section.
 
-    for (uint8_t num = 0; num < kQuestionCount[aInfo.mQueryType]; num++)
+    SuccessOrExit(error = AppendNameFromQuery(aQuery, *message));
+    SuccessOrExit(error = message->Append(Question(DetermineQuestionRecordType(aInfo))));
+
+#if OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
+    if (aInfo.mQueryType == kServiceQuerySrvTxt)
     {
         SuccessOrExit(error = AppendNameFromQuery(aQuery, *message));
-        SuccessOrExit(error = message->Append(Question(kQuestionRecordTypes[aInfo.mQueryType][num])));
+        SuccessOrExit(error = message->Append(Question(ResourceRecord::kTypeTxt)));
     }
+#endif
 
     length = message->GetLength() - message->GetOffset();
 
@@ -1204,6 +1266,53 @@ exit:
     return error;
 }
 
+uint16_t Client::DetermineQuestionRecordType(const QueryInfo &aInfo) const
+{
+    // Determine the first record type to include in Question
+    // section based on the `mQueryType`.
+
+    uint8_t recordType = 0;
+
+    switch (aInfo.mQueryType)
+    {
+    case kIp6AddressQuery:
+        recordType = ResourceRecord::kTypeAaaa;
+        break;
+
+#if OPENTHREAD_CONFIG_DNS_CLIENT_NAT64_ENABLE
+    case kIp4AddressQuery:
+        recordType = ResourceRecord::kTypeA;
+        break;
+#endif
+
+#if OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
+    case kBrowseQuery:
+        recordType = ResourceRecord::kTypePtr;
+        break;
+
+    case kServiceQuerySrv:
+    case kServiceQuerySrvTxt:
+        recordType = ResourceRecord::kTypeSrv;
+        break;
+
+    case kServiceQueryTxt:
+        recordType = ResourceRecord::kTypeTxt;
+        break;
+#endif
+
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+    case kRecordQuery:
+        recordType = aInfo.mRecordType;
+        break;
+#endif
+
+    case kNoQuery:
+        break;
+    }
+
+    return recordType;
+}
+
 Error Client::AppendNameFromQuery(const Query &aQuery, Message &aMessage)
 {
     // The name is encoded and included after the `Info` in `aQuery`
@@ -1259,6 +1368,14 @@ void Client::FinalizeQuery(Response &aResponse, Error aError)
             callback.mServiceCallback(aError, &aResponse, context);
         }
         break;
+#endif
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+    case kRecordQuery:
+        if (callback.mRecordCallback != nullptr)
+        {
+            callback.mRecordCallback(aError, &aResponse, context);
+        }
+        break;
 #endif
     case kNoQuery:
         break;
@@ -1359,6 +1476,7 @@ Error Client::ParseResponse(const Message &aResponseMessage, Query *&aQuery, Err
 {
     Error     error  = kErrorNone;
     uint16_t  offset = aResponseMessage.GetOffset();
+    uint16_t  questionCount;
     Header    header;
     QueryInfo info;
     Name      queryName;
@@ -1379,9 +1497,18 @@ Error Client::ParseResponse(const Message &aResponseMessage, Query *&aQuery, Err
 
     // Check the Question Section
 
-    if (header.GetQuestionCount() == kQuestionCount[info.mQueryType])
+    questionCount = 1;
+
+#if OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
+    if (info.mQueryType == kServiceQuerySrvTxt)
     {
-        for (uint8_t num = 0; num < kQuestionCount[info.mQueryType]; num++)
+        questionCount = 2;
+    }
+#endif
+
+    if (header.GetQuestionCount() == questionCount)
+    {
+        for (uint16_t num = 0; num < questionCount; num++)
         {
             SuccessOrExit(error = Name::CompareName(aResponseMessage, offset, queryName));
             offset += sizeof(Question);
@@ -1403,10 +1530,12 @@ Error Client::ParseResponse(const Message &aResponseMessage, Query *&aQuery, Err
 
     aResponseError = Header::ResponseCodeToError(header.GetResponseCode());
 
+#if OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
     if ((aResponseError == kErrorNone) && (info.mQueryType == kServiceQuerySrvTxt))
     {
         RecordServerAsCapableOfMultiQuestions(info.mConfig.GetServerSockAddr().GetAddress());
     }
+#endif
 
 exit:
     return error;
@@ -1808,7 +1937,7 @@ Error Client::ReadFromLinkBuffer(const otLinkedBuffer *&aLinkedBuffer,
     //    `aOffset` and `aLinkedBuffer` are updated.
     // - `kErrorNotFound` is not enough bytes available to read
     //    from `aLinkedBuffer`.
-    // - `kErrorNotBufs` if cannot grow `aMessage` to append bytes.
+    // - `kErrorNoBufs` if cannot grow `aMessage` to append bytes.
 
     Error error = kErrorNone;
 
diff --git a/src/core/net/dns_client.hpp b/src/core/net/dns_client.hpp
index 4591e5db3..d7abf4e0f 100644
--- a/src/core/net/dns_client.hpp
+++ b/src/core/net/dns_client.hpp
@@ -90,6 +90,17 @@ struct otDnsServiceResponse
 
 #endif // OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
 
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+
+/**
+ * Represents an opaque (and empty) type for a response to arbitrary record DNS query.
+ */
+struct otDnsRecordResponse
+{
+};
+
+#endif
+
 namespace ot {
 
 namespace Srp {
@@ -266,6 +277,25 @@ public:
     typedef otDnsServiceInfo ServiceInfo;
 #endif
 
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+    /**
+     * Provides info for a DNS record in a query response.
+     */
+    class RecordInfo : public otDnsRecordInfo
+    {
+    public:
+        /**
+         * Represents a section in a DNS response.
+         */
+        enum RecordSection : uint8_t
+        {
+            kSectionAnswer     = OT_DNS_SECTION_ANSWER,     ///< Answer section.
+            kSectionAuthority  = OT_DNS_SECTION_AUTHORITY,  ///< Authority section.
+            kSectionAdditional = OT_DNS_SECTION_ADDITIONAL, ///< Additional section.
+        };
+    };
+#endif
+
     /**
      * Represents a DNS query response.
      */
@@ -273,6 +303,9 @@ public:
 #if OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
                      public otDnsBrowseResponse,
                      public otDnsServiceResponse,
+#endif
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+                     public otDnsRecordResponse,
 #endif
                      public Clearable<Response>
     {
@@ -303,6 +336,9 @@ public:
         void  InitServiceInfo(ServiceInfo &aServiceInfo) const;
         Error ReadServiceInfo(Section aSection, const Name &aName, ServiceInfo &aServiceInfo) const;
         Error ReadTxtRecord(Section aSection, const Name &aName, ServiceInfo &aServiceInfo) const;
+#endif
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+        Error ReadRecordInfo(uint16_t aIndex, RecordInfo &aRecordInfo) const;
 #endif
         void PopulateFrom(const Message &aMessage);
 
@@ -312,6 +348,8 @@ public:
         Response      *mNext;                  // The next response when we have related queries.
         uint16_t       mAnswerOffset;          // Answer section offset in `mMessage`.
         uint16_t       mAnswerRecordCount;     // Number of records in answer section.
+        uint16_t       mAuthorityOffset;       // Authority section offset in `mMessage`.
+        uint16_t       mAuthorityRecordCount;  // Number of records in authority section.
         uint16_t       mAdditionalOffset;      // Additional data section offset in `mMessage`.
         uint16_t       mAdditionalRecordCount; // Number of records in additional data section.
 #if OPENTHREAD_CONFIG_DNS_CLIENT_NAT64_ENABLE
@@ -560,6 +598,75 @@ public:
 
 #endif // OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
 
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+
+    /**
+     * Represents the function pointer callback which is called when a DNS response for a DNS query response
+     * is received.
+     */
+    typedef otDnsRecordCallback RecordCallback;
+
+    /**
+     * Represents a record query response.
+     */
+    class RecordResponse : public Response
+    {
+        friend class Client;
+
+    public:
+        /**
+         * Gets the query name associated with a record DNS query.
+         *
+         * MUST only be used from `RecordCallback`.
+         *
+         * @param[out] aNameBuffer       A buffer to char array to output the name.
+         * @param[in]  aNameBufferSize   The size of @p aNameBuffer.
+         *
+         * @retval kErrorNone    The host name was read successfully.
+         * @retval kErrorNoBufs  The name does not fit in @p aNameBuffer.
+         */
+        Error GetQueryName(char *aNameBuffer, uint16_t aNameBufferSize) const
+        {
+            return GetName(aNameBuffer, aNameBufferSize);
+        }
+
+        /**
+         * Gets the record data from a DNS query response.
+         *
+         * MUST only be used from `RecordCallback`.
+         *
+         * The response may include multiple records. @p aIndex can be used to iterate through the list. Index zero gets
+         * the first record and so on. When we reach the end of the list, `kErrorNotFound` is returned.
+         *
+         * Upon successful retrieval (`kErrorNone`):
+         * - `mRecordLength` is set to the actual length of the record's data.
+         * - The data is copied into `mDataBuffer` (if not `NULL`) up to its capacity specified by `mDataBufferSize`.
+         * - `mDataBufferSize` is then updated to reflect the number of bytes actually written into `mDataBuffer`.
+         *
+         * If the retrieved record type is PTR (12), CNAME (5), DNAME (39), NS (2), or SRV (33), the record data in the
+         * received response contains a DNS name which may use DNS name compression. For these specific record types,
+         * the record data is first decompressed such that it contains the full uncompressed DNS name. This
+         * decompressed data is then provided in `mDataBuffer`, and `mRecordDataLength` will indicate the length of
+         * this decompressed data. For all other record types, the record data is read and provided as it appears in
+         * the received response message.
+         *
+         * @param[in]  aIndex            The record index to retrieve.
+         * @param[out] aRecordInfo       A reference to a `RecordInfo` struct to populate from the read record.
+         *
+         * @retval kErrorNone            The record data was read successfully.
+         * @retval kErrorNotFound        No record in @p aResponse at @p aIndex.
+         * @retval kErrorParse           Could not parse the records.
+         * @retval kErrorNoBufs          The name does not fit in the provided `mNameBufferSize` in @p aRecordInfo, or
+         *                               failed to allocate buffer to decompress a DNS name (for PTR, SRV, CNAME).
+         */
+        Error GetRecordInfo(uint16_t aIndex, RecordInfo &aRecordInfo) const
+        {
+            return ReadRecordInfo(aIndex, aRecordInfo);
+        }
+    };
+
+#endif // OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+
     /**
      * Initializes the object.
      *
@@ -724,6 +831,33 @@ public:
 
 #endif // OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
 
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+    /**
+     * Sends a DNS query for a given record type and name.
+     *
+     * The @p aConfig can be `nullptr`. In this case the default config (from `GetDefaultConfig()`) will be used as
+     * the config for this query. In a non-NULL @p aConfig, some of the fields can be left unspecified (value zero).
+     * The unspecified fields are then replaced by the values from the default config.
+     *
+     * @param[in] aRecordType   The resource record type (RRType) to query.
+     * @param[in] aFirstLabel   The first label of the name to be queried (can be NULL if not needed).
+     * @param[in] aNextLabels   The next labels of the name to be queried (MUST NOT be NULL).
+     * @param[in] aCallback     A function pointer that shall be called on response reception or time-out.
+     * @param[in] aContext      A pointer to arbitrary context information used with @p aCallback.
+     * @param[in] aConfig       A pointer to the config to use for this query (or NULL for default config).
+     *
+     * @retval kErrorNone          Query sent successfully. @p aCallback will be invoked to report the outcome.
+     * @retval kErrorNoBufs        Insufficient buffer to prepare and send query.
+     * @retval kErrorInvalidState  Cannot send query since Thread interface is not up.
+     */
+    Error QueryRecord(uint16_t           aRecordType,
+                      const char        *aFirstLabel,
+                      const char        *aNextLabels,
+                      RecordCallback     aCallback,
+                      void              *aContext,
+                      const QueryConfig *aConfig = nullptr);
+#endif
+
 private:
     static constexpr uint16_t kMaxCnameAliasNameChanges     = 40;
     static constexpr uint8_t  kLimitedQueryServersArraySize = 3;
@@ -739,6 +873,9 @@ private:
         kServiceQuerySrvTxt, // Service instance resolution both SRV and TXT records.
         kServiceQuerySrv,    // Service instance resolution SRV record only.
         kServiceQueryTxt,    // Service instance resolution TXT record only.
+#endif
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+        kRecordQuery,
 #endif
         kNoQuery,
     };
@@ -759,6 +896,9 @@ private:
 #if OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
         BrowseCallback  mBrowseCallback;
         ServiceCallback mServiceCallback;
+#endif
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+        RecordCallback mRecordCallback;
 #endif
     };
 
@@ -776,9 +916,12 @@ private:
         QueryConfig mConfig;
         uint8_t     mTransmissionCount;
         bool        mShouldResolveHostAddr;
-        Query      *mMainQuery;
-        Query      *mNextQuery;
-        Message    *mSavedResponse;
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+        uint16_t mRecordType; // Used only when `mQueryType == kRecordQuery`
+#endif
+        Query   *mMainQuery;
+        Query   *mNextQuery;
+        Message *mSavedResponse;
         // Followed by the name (service, host, instance) encoded as a `Dns::Name`.
     };
 
@@ -790,6 +933,7 @@ private:
     void        UpdateQuery(Query &aQuery, const QueryInfo &aInfo) { aQuery.Write(0, aInfo); }
     Query      &FindMainQuery(Query &aQuery);
     Error       SendQuery(Query &aQuery, QueryInfo &aInfo, bool aUpdateTimer);
+    uint16_t    DetermineQuestionRecordType(const QueryInfo &aInfo) const;
     void        FinalizeQuery(Query &aQuery, Error aError);
     void        FinalizeQuery(Response &Response, Error aError);
     static void GetQueryTypeAndCallback(const Query &aQuery, QueryType &aType, Callback &aCallback, void *&aContext);
@@ -849,18 +993,6 @@ private:
     void  PrepareTcpMessage(Message &aMessage);
 #endif // OPENTHREAD_CONFIG_DNS_CLIENT_OVER_TCP_ENABLE
 
-    static const uint8_t         kQuestionCount[];
-    static const uint16_t *const kQuestionRecordTypes[];
-
-    static const uint16_t kIp6AddressQueryRecordTypes[];
-#if OPENTHREAD_CONFIG_DNS_CLIENT_NAT64_ENABLE
-    static const uint16_t kIp4AddressQueryRecordTypes[];
-#endif
-#if OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE
-    static const uint16_t kBrowseQueryRecordTypes[];
-    static const uint16_t kServiceQueryRecordTypes[];
-#endif
-
     static constexpr uint16_t kUdpQueryMaxSize = 512;
 
     using RetryTimer   = TimerMilliIn<Client, &Client::HandleTimer>;
@@ -896,6 +1028,11 @@ DefineCoreType(otDnsBrowseResponse, Dns::Client::BrowseResponse);
 DefineCoreType(otDnsServiceResponse, Dns::Client::ServiceResponse);
 DefineCoreType(otDnsServiceInfo, Dns::Client::ServiceInfo);
 #endif
+#if OPENTHREAD_CONFIG_DNS_CLIENT_ARBITRARY_RECORD_QUERY_ENABLE
+DefineCoreType(otDnsRecordResponse, Dns::Client::RecordResponse);
+DefineCoreType(otDnsRecordInfo, Dns::Client::RecordInfo);
+DefineMapEnum(otDnsRecordSection, Dns::Client::RecordInfo::RecordSection);
+#endif
 
 } // namespace ot
 
diff --git a/src/core/net/dns_types.cpp b/src/core/net/dns_types.cpp
index 41ed989a5..d3bfd6c10 100644
--- a/src/core/net/dns_types.cpp
+++ b/src/core/net/dns_types.cpp
@@ -111,8 +111,11 @@ bool Name::Matches(const char *aFirstLabel, const char *aLabels, const char *aDo
             VerifyOrExit(matches);
         }
 
-        matches = CompareAndSkipLabels(namePtr, aLabels, kLabelSeparatorChar);
-        VerifyOrExit(matches);
+        if (aLabels != nullptr)
+        {
+            matches = CompareAndSkipLabels(namePtr, aLabels, kLabelSeparatorChar);
+            VerifyOrExit(matches);
+        }
 
         matches = CompareAndSkipLabels(namePtr, aDomain, kNullChar);
     }
@@ -125,7 +128,11 @@ bool Name::Matches(const char *aFirstLabel, const char *aLabels, const char *aDo
             SuccessOrExit(CompareLabel(*mMessage, offset, aFirstLabel));
         }
 
-        SuccessOrExit(CompareMultipleLabels(*mMessage, offset, aLabels));
+        if (aLabels != nullptr)
+        {
+            SuccessOrExit(CompareMultipleLabels(*mMessage, offset, aLabels));
+        }
+
         SuccessOrExit(CompareName(*mMessage, offset, aDomain));
         matches = true;
     }
@@ -798,6 +805,15 @@ bool Name::IsSameDomain(const char *aDomain1, const char *aDomain2)
     return IsSubDomainOf(aDomain1, aDomain2) && IsSubDomainOf(aDomain2, aDomain1);
 }
 
+void ResourceRecord::UpdateRecordLengthInMessage(Message &aMessage, uint16_t aOffset)
+{
+    ResourceRecord record;
+
+    IgnoreError(aMessage.Read(aOffset, record));
+    record.SetLength(aMessage.GetLength() - aOffset - sizeof(ResourceRecord));
+    aMessage.Write(aOffset, record);
+}
+
 Error ResourceRecord::ParseRecords(const Message &aMessage, uint16_t &aOffset, uint16_t aNumRecords)
 {
     Error error = kErrorNone;
@@ -1020,6 +1036,200 @@ exit:
     return error;
 }
 
+const ResourceRecord::DataRecipe *ResourceRecord::FindDataRecipeFor(uint16_t aRecordType)
+{
+    static constexpr DataRecipe kRecipes[] = {
+        {kTypeNs, 0, 1, 0},
+        {kTypeCname, 0, 1, 0},
+        {kTypeSoa, 0, 2, 5 * sizeof(uint32_t)}, // mname, rname, followed by five 32-bit values.
+        {kTypePtr, 0, 1, 0},
+        {kTypeMx, sizeof(uint16_t), 1, 0},    // `preference` 16-bit field, exchange name [RFC 1035]
+        {kTypeRp, 0, 2, 0},                   /// `mbox-dname` `txt-dname` [RFC 1183]
+        {kTypeAfsdb, sizeof(uint16_t), 1, 0}, // `sub-type` 16-bit field, host name [RFC 1183]
+        {kTypeRt, sizeof(uint16_t), 1, 0},    // `preference` 16-bit field, host name [RFC 1183]
+        {kTypePx, sizeof(uint16_t), 2, 0},    // `preference` 16-bit field, two names [RFC 2163]
+        {kTypeSrv, sizeof(SrvRecord) - sizeof(ResourceRecord), 1, 0},
+        {kTypeKx, sizeof(uint16_t), 1, 0}, // `preference` 16-bit field, name [RFC 2230]
+        {kTypeDname, 0, 1, 0},
+        {kTypeNsec, 0, 1, NsecRecord::TypeBitMap::kMinSize},
+    };
+
+    static_assert(BinarySearch::IsSorted(kRecipes), "kRecipes is not sorted");
+
+    return BinarySearch::Find(aRecordType, kRecipes);
+}
+
+Error ResourceRecord::DecompressRecordData(const Message &aMessage, uint16_t aOffset, OwnedPtr<Message> &aDataMsg)
+{
+    // Reads the `ResourceRecord` header to identify the record type
+    // and uses a predefined recipe to parse the record data.
+
+    Error             error;
+    ResourceRecord    record;
+    const DataRecipe *recipe;
+    uint16_t          startOffset;
+    uint16_t          remainingLength;
+
+    SuccessOrExit(error = record.ReadFrom(aMessage, aOffset));
+    aOffset += sizeof(ResourceRecord);
+
+    recipe = FindDataRecipeFor(record.GetType());
+
+    if (recipe == nullptr)
+    {
+        aDataMsg.Free();
+        error = kErrorNone;
+        ExitNow();
+    }
+
+    aDataMsg.Reset(aMessage.Get<MessagePool>().Allocate(Message::kTypeOther));
+    VerifyOrExit(!aDataMsg.IsNull(), error = kErrorNoBufs);
+
+    startOffset = aOffset;
+
+    // Check and copy the prefix bytes in the record data.
+
+    VerifyOrExit(record.GetLength() >= recipe->mNumPrefixBytes, error = kErrorParse);
+    SuccessOrExit(error = aDataMsg->AppendBytesFromMessage(aMessage, aOffset, recipe->mNumPrefixBytes));
+    aOffset += recipe->mNumPrefixBytes;
+
+    // Read and decompress embedded DNS names in the record data.
+
+    for (uint8_t numNames = 0; numNames < recipe->mNumNames; numNames++)
+    {
+        Name name(aMessage, aOffset);
+
+        // ParseName() updates `aOffset` to point to the byte after
+        // the end of name field.
+
+        SuccessOrExit(error = Name::ParseName(aMessage, aOffset));
+        SuccessOrExit(error = name.AppendTo(*aDataMsg));
+    }
+
+    // Determine the remaining length after the names in the record
+    // data. Ensure we have at least `mMinNumSuffixBytes` and copy
+    // them into `aDataMsg`.
+
+    VerifyOrExit(aOffset - startOffset <= record.GetLength(), error = kErrorParse);
+    remainingLength = record.GetLength() - (aOffset - startOffset);
+
+    VerifyOrExit(remainingLength >= recipe->mMinNumSuffixBytes, error = kErrorParse);
+
+    SuccessOrExit(error = aDataMsg->AppendBytesFromMessage(aMessage, aOffset, remainingLength));
+
+exit:
+    return error;
+}
+
+Error ResourceRecord::AppendTranslatedRecordDataTo(Message                       &aMessage,
+                                                   uint16_t                       aRecordType,
+                                                   const Data<kWithUint16Length> &aData,
+                                                   const char                    *aOriginalDomain,
+                                                   uint16_t                       aTranslatedDomainOffset)
+{
+    Error             error  = kErrorNone;
+    const DataRecipe *recipe = FindDataRecipeFor(aRecordType);
+    OwnedPtr<Message> dataMsg;
+    uint16_t          offset;
+    uint16_t          remainingLength;
+
+    if (recipe == nullptr)
+    {
+        error = aMessage.AppendData(aData);
+        ExitNow();
+    }
+
+    dataMsg.Reset(aMessage.Get<MessagePool>().Allocate(Message::kTypeOther));
+    VerifyOrExit(dataMsg != nullptr, error = kErrorNoBufs);
+    SuccessOrExit(error = dataMsg->AppendData(aData));
+
+    // Append the prefix bytes in the record data.
+
+    offset = 0;
+    SuccessOrExit(error = aMessage.AppendBytesFromMessage(*dataMsg, offset, recipe->mNumPrefixBytes));
+    offset += recipe->mNumPrefixBytes;
+
+    // Translate and append the embedded DNS names
+
+    for (uint8_t numNames = 0; numNames < recipe->mNumNames; numNames++)
+    {
+        Name::LabelBuffer label;
+        uint8_t           labelLength;
+        uint16_t          labelOffset;
+
+        // Read labels one by one and append them to `aMessage`.
+        // First, check if the remaining labels match the original
+        // domain name and if so, append the translated domain name
+        // (as a compressed pointer label) instead.
+
+        labelOffset = offset;
+
+        while (true)
+        {
+            uint16_t compareOffset = labelOffset;
+
+            if (Name::CompareName(*dataMsg, compareOffset, aOriginalDomain) == kErrorNone)
+            {
+                SuccessOrExit(error = Name::AppendPointerLabel(aTranslatedDomainOffset, aMessage));
+                break;
+            }
+
+            labelLength = sizeof(label);
+            error       = Name::ReadLabel(*dataMsg, labelOffset, label, labelLength);
+
+            if (error == kErrorNotFound)
+            {
+                // Reached end of the label
+                break;
+            }
+
+            SuccessOrExit(error);
+
+            SuccessOrExit(error = Name::AppendLabel(label, aMessage));
+        }
+
+        // Parse name and update `offset` to the end of name field.
+        SuccessOrExit(error = Name::ParseName(*dataMsg, offset));
+    }
+
+    // Append the extra bytes after the name(s).
+
+    VerifyOrExit(offset <= dataMsg->GetLength(), error = kErrorParse);
+    remainingLength = dataMsg->GetLength() - offset;
+
+    VerifyOrExit(remainingLength >= recipe->mMinNumSuffixBytes, error = kErrorParse);
+    SuccessOrExit(error = aMessage.AppendBytesFromMessage(*dataMsg, offset, remainingLength));
+
+exit:
+    return error;
+}
+
+ResourceRecord::TypeInfoString ResourceRecord::TypeToString(uint16_t aRecordType)
+{
+    static constexpr Stringify::Entry kRecordTypeTable[] = {
+        {kTypeA, "A"},     {kTypeNs, "NS"},       {kTypeCname, "CNAME"}, {kTypeSoa, "SOA"},     {kTypePtr, "PTR"},
+        {kTypeMx, "MX"},   {kTypeTxt, "TXT"},     {kTypeRp, "RP"},       {kTypeAfsdb, "AFSDB"}, {kTypeRt, "RT"},
+        {kTypeSig, "SIG"}, {kTypeKey, "KEY"},     {kTypePx, "PX"},       {kTypeAaaa, "AAAA"},   {kTypeSrv, "SRV"},
+        {kTypeKx, "KX"},   {kTypeDname, "DNAME"}, {kTypeOpt, "OPT"},     {kTypeNsec, "NSEC"},   {kTypeAny, "ANY"},
+    };
+
+    static_assert(Stringify::IsSorted(kRecordTypeTable), "kRecordTypeTable is not sorted");
+
+    TypeInfoString string;
+    const char    *lookupResult = Stringify::Lookup(aRecordType, kRecordTypeTable, nullptr);
+
+    if (lookupResult != nullptr)
+    {
+        string.Append("%s", lookupResult);
+    }
+    else
+    {
+        string.Append("RR:%u", aRecordType);
+    }
+
+    return string;
+}
+
 void TxtEntry::Iterator::Init(const uint8_t *aTxtData, uint16_t aTxtDataLength)
 {
     SetTxtData(aTxtData);
@@ -1180,6 +1390,24 @@ exit:
     return error;
 }
 
+Error TxtDataEncoder::AppendBytesEntry(const char *aKey, const void *aBuffer, uint16_t aLength)
+{
+    return TxtEntry(aKey, reinterpret_cast<const uint8_t *>(aBuffer), aLength).AppendTo(mAppender);
+}
+
+Error TxtDataEncoder::AppendStringEntry(const char *aKey, const char *aStringValue)
+{
+    Error    error;
+    uint16_t length = StringLength(aStringValue, kMaxStringEntryLength + 1);
+
+    VerifyOrExit(length <= kMaxStringEntryLength, error = kErrorInvalidArgs);
+
+    error = AppendBytesEntry(aKey, aStringValue, length);
+
+exit:
+    return error;
+}
+
 bool AaaaRecord::IsValid(void) const
 {
     return GetType() == Dns::ResourceRecord::kTypeAaaa && GetSize() == sizeof(*this);
diff --git a/src/core/net/dns_types.hpp b/src/core/net/dns_types.hpp
index 23f16bc76..ae87efda7 100644
--- a/src/core/net/dns_types.hpp
+++ b/src/core/net/dns_types.hpp
@@ -42,9 +42,13 @@
 #include "common/appender.hpp"
 #include "common/as_core_type.hpp"
 #include "common/clearable.hpp"
+#include "common/data.hpp"
 #include "common/encoding.hpp"
 #include "common/equatable.hpp"
 #include "common/message.hpp"
+#include "common/owned_ptr.hpp"
+#include "common/string.hpp"
+#include "common/type_traits.hpp"
 #include "crypto/ecdsa.hpp"
 #include "net/ip4_types.hpp"
 #include "net/ip6_address.hpp"
@@ -115,30 +119,26 @@ public:
      *
      * @returns The type of the message.
      */
-    Type GetType(void) const { return static_cast<Type>((mFlags[0] & kQrFlagMask) >> kQrFlagOffset); }
+    Type GetType(void) const { return static_cast<Type>(ReadBits<uint8_t, kQrFlagMask>(mFlags[0])); }
 
     /**
      * Sets the type of the message.
      *
      * @param[in]  aType The type of the message.
      */
-    void SetType(Type aType)
-    {
-        mFlags[0] &= ~kQrFlagMask;
-        mFlags[0] |= static_cast<uint8_t>(aType) << kQrFlagOffset;
-    }
+    void SetType(Type aType) { WriteBits<uint8_t, kQrFlagMask>(mFlags[0], static_cast<uint8_t>(aType)); }
 
     /**
-     * Defines types of query.
+     * Defines types of query (OpCode).
      */
     enum QueryType : uint8_t
     {
-        kQueryTypeStandard = 0,
-        kQueryTypeInverse  = 1,
-        kQueryTypeStatus   = 2,
-        kQueryTypeNotify   = 4,
-        kQueryTypeUpdate   = 5,
-        kQueryTypeDso      = 6,
+        kQueryTypeStandard = 0, ///< Query
+        kQueryTypeInverse  = 1, ///< IQuery
+        kQueryTypeStatus   = 2, ///< Status
+        kQueryTypeNotify   = 4, ///< Notify
+        kQueryTypeUpdate   = 5, ///< Update
+        kQueryTypeDso      = 6, ///< DNS Stateful Operations
     };
 
     /**
@@ -146,18 +146,14 @@ public:
      *
      * @returns The type of the query.
      */
-    QueryType GetQueryType(void) const { return static_cast<QueryType>((mFlags[0] & kOpCodeMask) >> kOpCodeOffset); }
+    QueryType GetQueryType(void) const { return static_cast<QueryType>(ReadBits<uint8_t, kOpCodeMask>(mFlags[0])); }
 
     /**
      * Sets the type of the query.
      *
      * @param[in]  aType The type of the query.
      */
-    void SetQueryType(QueryType aType)
-    {
-        mFlags[0] &= ~kOpCodeMask;
-        mFlags[0] |= static_cast<uint8_t>(aType) << kOpCodeOffset;
-    }
+    void SetQueryType(QueryType aType) { WriteBits<uint8_t, kOpCodeMask>(mFlags[0], static_cast<uint8_t>(aType)); }
 
     /**
      * Specifies in response message if the responding name server is an
@@ -165,34 +161,34 @@ public:
      *
      * @returns True if Authoritative Answer flag (AA) is set in the header, false otherwise.
      */
-    bool IsAuthoritativeAnswerFlagSet(void) const { return (mFlags[0] & kAaFlagMask) == kAaFlagMask; }
+    bool IsAuthoritativeAnswerFlagSet(void) const { return GetBit<uint8_t>(mFlags[0], kAaFlagOffset); }
 
     /**
      * Clears the Authoritative Answer flag (AA) in the header.
      */
-    void ClearAuthoritativeAnswerFlag(void) { mFlags[0] &= ~kAaFlagMask; }
+    void ClearAuthoritativeAnswerFlag(void) { ClearBit<uint8_t>(mFlags[0], kAaFlagOffset); }
 
     /**
      * Sets the Authoritative Answer flag (AA) in the header.
      */
-    void SetAuthoritativeAnswerFlag(void) { mFlags[0] |= kAaFlagMask; }
+    void SetAuthoritativeAnswerFlag(void) { SetBit<uint8_t>(mFlags[0], kAaFlagOffset); }
 
     /**
      * Specifies if message is truncated.
      *
      * @returns True if Truncation flag (TC) is set in the header, false otherwise.
      */
-    bool IsTruncationFlagSet(void) const { return (mFlags[0] & kTcFlagMask) == kTcFlagMask; }
+    bool IsTruncationFlagSet(void) const { return GetBit<uint8_t>(mFlags[0], kTcFlagOffset); }
 
     /**
      * Clears the Truncation flag (TC) in the header.
      */
-    void ClearTruncationFlag(void) { mFlags[0] &= ~kTcFlagMask; }
+    void ClearTruncationFlag(void) { ClearBit<uint8_t>(mFlags[0], kTcFlagOffset); }
 
     /**
      * Sets the Truncation flag (TC) in the header.
      */
-    void SetTruncationFlag(void) { mFlags[0] |= kTcFlagMask; }
+    void SetTruncationFlag(void) { SetBit<uint8_t>(mFlags[0], kTcFlagOffset); }
 
     /**
      * Specifies if resolver wants to direct the name server to pursue
@@ -200,55 +196,55 @@ public:
      *
      * @returns True if Recursion Desired flag (RD) is set in the header, false otherwise.
      */
-    bool IsRecursionDesiredFlagSet(void) const { return (mFlags[0] & kRdFlagMask) == kRdFlagMask; }
+    bool IsRecursionDesiredFlagSet(void) const { return GetBit<uint8_t>(mFlags[0], kRdFlagOffset); }
 
     /**
      * Clears the Recursion Desired flag (RD) in the header.
      */
-    void ClearRecursionDesiredFlag(void) { mFlags[0] &= ~kRdFlagMask; }
+    void ClearRecursionDesiredFlag(void) { ClearBit<uint8_t>(mFlags[0], kRdFlagOffset); }
 
     /**
      * Sets the Recursion Desired flag (RD) in the header.
      */
-    void SetRecursionDesiredFlag(void) { mFlags[0] |= kRdFlagMask; }
+    void SetRecursionDesiredFlag(void) { SetBit<uint8_t>(mFlags[0], kRdFlagOffset); }
 
     /**
      * Denotes whether recursive query support is available in the name server.
      *
      * @returns True if Recursion Available flag (RA) is set in the header, false otherwise.
      */
-    bool IsRecursionAvailableFlagSet(void) const { return (mFlags[1] & kRaFlagMask) == kRaFlagMask; }
+    bool IsRecursionAvailableFlagSet(void) const { return GetBit<uint8_t>(mFlags[1], kRaFlagOffset); }
 
     /**
      * Clears the Recursion Available flag (RA) in the header.
      */
-    void ClearRecursionAvailableFlag(void) { mFlags[1] &= ~kRaFlagMask; }
+    void ClearRecursionAvailableFlag(void) { ClearBit<uint8_t>(mFlags[1], kRaFlagOffset); }
 
     /**
      * Sets the Recursion Available flag (RA) in the header.
      */
-    void SetRecursionAvailableFlag(void) { mFlags[1] |= kRaFlagMask; }
+    void SetRecursionAvailableFlag(void) { SetBit<uint8_t>(mFlags[1], kRaFlagOffset); }
 
     /**
-     * Defines response codes.
+     * Defines response codes (RCODEs).
      */
     enum Response : uint8_t
     {
-        kResponseSuccess         = 0,  ///< Success (no error condition).
-        kResponseFormatError     = 1,  ///< Server unable to interpret request due to format error.
-        kResponseServerFailure   = 2,  ///< Server encountered an internal failure.
-        kResponseNameError       = 3,  ///< Name that ought to exist, does not exists.
-        kResponseNotImplemented  = 4,  ///< Server does not support the query type (OpCode).
-        kResponseRefused         = 5,  ///< Server refused to perform operation for policy or security reasons.
-        kResponseNameExists      = 6,  ///< Some name that ought not to exist, does exist.
-        kResponseRecordExists    = 7,  ///< Some RRset that ought not to exist, does exist.
-        kResponseRecordNotExists = 8,  ///< Some RRset that ought to exist, does not exist.
-        kResponseNotAuth         = 9,  ///< Service is not authoritative for zone.
-        kResponseNotZone         = 10, ///< A name is not in the zone.
-        kDsoTypeNotImplemented   = 11, ///< DSO TLV TYPE is not implemented.
-        kResponseBadName         = 20, ///< Bad name.
-        kResponseBadAlg          = 21, ///< Bad algorithm.
-        kResponseBadTruncation   = 22, ///< Bad truncation.
+        kResponseSuccess         = 0,  ///< Success (no error condition, NoError).
+        kResponseFormatError     = 1,  ///< Server unable to interpret request due to format error (FormErr).
+        kResponseServerFailure   = 2,  ///< Server encountered an internal failure (ServFail).
+        kResponseNameError       = 3,  ///< Name that ought to exist, does not exist (NXDomain).
+        kResponseNotImplemented  = 4,  ///< Server does not support the query type or OpCode (NotImp).
+        kResponseRefused         = 5,  ///< Server refused to perform operation for policy/security reasons (Refused).
+        kResponseNameExists      = 6,  ///< Some name that ought not to exist, does exist (YXDomain).
+        kResponseRecordExists    = 7,  ///< Some RRset that ought not to exist, does exist (YXRRSet).
+        kResponseRecordNotExists = 8,  ///< Some RRset that ought to exist, does not exist (NXRRSet).
+        kResponseNotAuth         = 9,  ///< Service is not authoritative for zone (NotAuth).
+        kResponseNotZone         = 10, ///< A name is not in the zone (NotZone).
+        kDsoTypeNotImplemented   = 11, ///< DSO TLV TYPE is not implemented (DSOTYPENI).
+        kResponseBadName         = 20, ///< Bad name (BADNAME).
+        kResponseBadAlg          = 21, ///< Bad algorithm (BADALG).
+        kResponseBadTruncation   = 22, ///< Bad truncation (BADTRUNC).
     };
 
     /**
@@ -256,7 +252,7 @@ public:
      *
      * @returns The response code from the header.
      */
-    Response GetResponseCode(void) const { return static_cast<Response>((mFlags[1] & kRCodeMask) >> kRCodeOffset); }
+    Response GetResponseCode(void) const { return static_cast<Response>(ReadBits<uint8_t, kRCodeMask>(mFlags[1])); }
 
     /**
      * Sets the response code.
@@ -265,8 +261,7 @@ public:
      */
     void SetResponseCode(Response aResponse)
     {
-        mFlags[1] &= ~kRCodeMask;
-        mFlags[1] |= static_cast<uint8_t>(aResponse) << kRCodeOffset;
+        WriteBits<uint8_t, kRCodeMask>(mFlags[1], static_cast<uint8_t>(aResponse));
     }
 
     /**
@@ -356,13 +351,9 @@ private:
     static constexpr uint8_t kOpCodeOffset = 3;                     // OpCode field offset.
     static constexpr uint8_t kOpCodeMask   = 0x0f << kOpCodeOffset; // OpCode field mask.
     static constexpr uint8_t kAaFlagOffset = 2;                     // AA Flag offset.
-    static constexpr uint8_t kAaFlagMask   = 0x01 << kAaFlagOffset; // AA Flag mask.
     static constexpr uint8_t kTcFlagOffset = 1;                     // TC Flag offset.
-    static constexpr uint8_t kTcFlagMask   = 0x01 << kTcFlagOffset; // TC Flag mask.
     static constexpr uint8_t kRdFlagOffset = 0;                     // RD Flag offset.
-    static constexpr uint8_t kRdFlagMask   = 0x01 << kRdFlagOffset; // RD Flag mask.
     static constexpr uint8_t kRaFlagOffset = 7;                     // RA Flag offset.
-    static constexpr uint8_t kRaFlagMask   = 0x01 << kRaFlagOffset; // RA Flag mask.
     static constexpr uint8_t kRCodeOffset  = 0;                     // RCODE field offset.
     static constexpr uint8_t kRCodeMask    = 0x0f << kRCodeOffset;  // RCODE field mask.
 
@@ -606,15 +597,15 @@ public:
      * @p aFirstLabel can be `nullptr` if not needed. But if non-null, it is treated as a single label and can itself
      * include dot `.` character.
      *
-     * The @p aLabels MUST NOT be `nullptr` and MUST follow  "<label1>.<label2>.<label3>", i.e., a sequence of one or
-     * more labels separated by dot '.' char, and it MUST NOT end with dot `.`.
+     * The @p aLabels can be `nullptr`. If it is provided it MUST follow  "<label1>.<label2>.<label3>", i.e., a
+     * sequence of one or more labels separated by dot '.' char, and it MUST NOT end with dot `.`.
      *
      * @p aDomain MUST NOT be `nullptr` and MUST have at least one label and MUST always end with a dot `.` character.
      *
      * If the above conditions are not satisfied, the behavior of this method is undefined.
      *
      * @param[in] aFirstLabel     A first label to check. Can be `nullptr`.
-     * @param[in] aLabels         A string of dot separated labels, MUST NOT end with dot.
+     * @param[in] aLabels         A string of dot separated labels, MUST NOT end with dot. Can be `nullptr`
      * @param[in] aDomain         Domain name. MUST end with dot.
      *
      * @retval TRUE   The name matches the given components.
@@ -1255,6 +1246,138 @@ private:
     static constexpr char    kKeyValueSeparator      = '=';
 };
 
+/**
+ * Represents a TXT data encoder.
+ */
+class TxtDataEncoder
+{
+public:
+    /**
+     * Maximum string length supported by `AppendStringEntry()`.
+     */
+    static constexpr uint16_t kMaxStringEntryLength = 256;
+
+    /**
+     * Initializes the `TxtDataEncoder` to append to a `Message`.
+     *
+     * New TXT data entries are appended to the end of @p aMessage, growing its length.
+     *
+     * @param[in] aMessage   The message to append to.
+     */
+    explicit TxtDataEncoder(Message &aMessage)
+        : mAppender(aMessage)
+    {
+    }
+
+    /**
+     * Initializes the `TxtDataEncoder` to append in a given a buffer
+     *
+     * New TXT data entries are appended in the buffer starting from @p aBuffer up to is size @p aSize. The encoder
+     * does not allow content to be appended beyond the size of the buffer.
+     *
+     * @param[in] aBuffer  A pointer to start of buffer.
+     * @param[in] aSize    The maximum size of @p aBuffer (number of available bytes in buffer).
+     */
+    TxtDataEncoder(uint8_t *aBuffer, uint16_t aSize)
+        : mAppender(aBuffer, aSize)
+    {
+    }
+
+    /**
+     * Returns the number of bytes in the TXT data container.
+     *
+     * When `TxtDataEncoder` uses a byte buffer container, this will return the number of encoded bytes in the buffer.
+     * When `TxtDataEncoder` uses a `Message`, this will return the message's current length, which includes any
+     * previously appended bytes in the message.
+     *
+     * @returns The number of bytes in the provided TXT data container.
+     */
+    uint16_t GetLength(void) const { return mAppender.GetAppendedLength(); }
+
+    /**
+     * Appends a TXT entry for a given key and given value as a byte array.
+     *
+     * @param[in] aKey     The TXT entry key string
+     * @param[in] aBuffer  A pointer to buffer containing the TXT entry value.
+     * @param[in] aLength  Number of bytes in @p aBuffer.
+     *
+     * @retval kErrorNone    Successfully appended the TXT entry.
+     * @retval kErrorNoBufs  Insufficient available buffers to append the entry.
+     */
+    Error AppendBytesEntry(const char *aKey, const void *aBuffer, uint16_t aLength);
+
+    /**
+     * Appends a TXT entry for a given key and a given object as the entry's value.
+     *
+     * @tparam    ObjectType   The value object type.
+
+     * @param[in] aKey      The TXT entry key string
+     * @param[in] aObject   A reference to the value object.
+     *
+     * @retval kErrorNone    Successfully appended the TXT entry.
+     * @retval kErrorNoBufs  Insufficient available buffers to append the entry.
+     */
+    template <typename ObjectType> Error AppendEntry(const char *aKey, const ObjectType &aObject)
+    {
+        static_assert(!TypeTraits::IsPointer<ObjectType>::kValue, "ObjectType must not be a pointer");
+
+        return AppendBytesEntry(aKey, &aObject, sizeof(ObjectType));
+    }
+
+    /**
+     * Appends a TXT entry for a given key and a given string for entry's value.
+     *
+     * The string length of @p aStringValues should not exceed `kMaxStringEntryLength`, otherwise `kErrorInvalidAgrs`
+     * is returned.
+     *
+     * @param[in] aKey           The TXT entry key string
+     * @param[in] aStringValue   The value string.
+     *
+     * @retval kErrorNone         Successfully appended the TXT entry.
+     * @retval kErrorNoBufs       Insufficient available buffers to append the entry.
+     * @retval kErrorInvalidArgs  The @p aStringValue is too long.
+     */
+    Error AppendStringEntry(const char *aKey, const char *aStringValue);
+
+    /**
+     * Appends a TXT entry for a given key and a given unsigned integral value using big-endian encoding.
+     *
+     * @tparam    UintType   The unsigned int type (`uint16_t` or `uint32_t`).
+     *
+     * @param[in] aKey           The TXT entry key string
+     * @param[in] aUintValue     The unsigned integer value.
+     *
+     * @retval kErrorNone         Successfully appended the TXT entry.
+     * @retval kErrorNoBufs       Insufficient available buffers to append the entry.
+     */
+    template <typename UintType> Error AppendBigEndianUintEntry(const char *aKey, UintType aUintValue)
+    {
+        static_assert(TypeTraits::IsSame<UintType, uint8_t>::kValue || TypeTraits::IsSame<UintType, uint16_t>::kValue ||
+                          TypeTraits::IsSame<UintType, uint32_t>::kValue ||
+                          TypeTraits::IsSame<UintType, uint64_t>::kValue,
+                      "UintType must be uint8/uint16/uint32/uint64");
+
+        return AppendEntry<UintType>(aKey, BigEndian::HostSwap<UintType>(aUintValue));
+    }
+
+    /**
+     * Appends a TXT entry for a given key and a given `NameData` as value.
+     *
+     * @param[in] aKey           The TXT entry key string
+     * @param[in] aNameData      The value as `NameData`
+     *
+     * @retval kErrorNone         Successfully appended the TXT entry.
+     * @retval kErrorNoBufs       Insufficient available buffers to append the entry.
+     */
+    Error AppendNameEntry(const char *aKey, const MeshCoP::NameData &aNameData)
+    {
+        return AppendBytesEntry(aKey, aNameData.GetBuffer(), aNameData.GetLength());
+    }
+
+private:
+    Appender mAppender;
+};
+
 /**
  * Implements Resource Record (RR) body format.
  */
@@ -1264,26 +1387,38 @@ class ResourceRecord
     friend class OptRecord;
 
 public:
-    // Resource Record Types.
+    // Resource Record Types (RRTypes).
     static constexpr uint16_t kTypeZero  = 0;   ///< Zero as special indicator for the SIG RR (SIG(0) from RFC 2931).
-    static constexpr uint16_t kTypeA     = 1;   ///< Address record (IPv4).
-    static constexpr uint16_t kTypeSoa   = 6;   ///< Start of (zone of) authority.
+    static constexpr uint16_t kTypeA     = 1;   ///< IPv4 address record (A).
+    static constexpr uint16_t kTypeNs    = 2;   ///< NS record (an authoritative name server).
     static constexpr uint16_t kTypeCname = 5;   ///< CNAME record.
+    static constexpr uint16_t kTypeSoa   = 6;   ///< SOA record (start of (zone of) authority).
     static constexpr uint16_t kTypePtr   = 12;  ///< PTR record.
+    static constexpr uint16_t kTypeMx    = 15;  ///< MX record (mail exchange).
     static constexpr uint16_t kTypeTxt   = 16;  ///< TXT record.
+    static constexpr uint16_t kTypeRp    = 17;  ///< RP record (Responsible Person).
+    static constexpr uint16_t kTypeAfsdb = 18;  ///< AFSDB record (AFS Data Base location).
+    static constexpr uint16_t kTypeRt    = 21;  ///< RT record (Route Through).
     static constexpr uint16_t kTypeSig   = 24;  ///< SIG record.
     static constexpr uint16_t kTypeKey   = 25;  ///< KEY record.
-    static constexpr uint16_t kTypeAaaa  = 28;  ///< IPv6 address record.
+    static constexpr uint16_t kTypePx    = 26;  ///< PX record (X.400 mail mapping information).
+    static constexpr uint16_t kTypeAaaa  = 28;  ///< IPv6 address (AAAA) record.
     static constexpr uint16_t kTypeSrv   = 33;  ///< SRV locator record.
-    static constexpr uint16_t kTypeOpt   = 41;  ///< Option record.
+    static constexpr uint16_t kTypeKx    = 36;  ///< KX record (Key Exchanger).
+    static constexpr uint16_t kTypeDname = 39;  ///< DNAME record.
+    static constexpr uint16_t kTypeOpt   = 41;  ///< Option (OPT) record.
     static constexpr uint16_t kTypeNsec  = 47;  ///< NSEC record.
-    static constexpr uint16_t kTypeAny   = 255; ///< ANY record.
+    static constexpr uint16_t kTypeAny   = 255; ///< ANY (*) record.
 
-    // Resource Record Class Codes.
+    // Resource Record Class Codes (CLASS).
     static constexpr uint16_t kClassInternet = 1;   ///< Class code Internet (IN).
     static constexpr uint16_t kClassNone     = 254; ///< Class code None (NONE) - RFC 2136.
     static constexpr uint16_t kClassAny      = 255; ///< Class code Any (ANY).
 
+    static constexpr uint16_t kTypeStringSize = 17; ///< Size of `TypeInfoString`.
+
+    typedef String<kTypeStringSize> TypeInfoString; /// A string to represent a resource record type (human-readable).
+
     /**
      * Initializes the resource record by setting its type and class.
      *
@@ -1375,6 +1510,18 @@ public:
      */
     uint32_t GetSize(void) const { return sizeof(ResourceRecord) + GetLength(); }
 
+    /**
+     * Updates the record length in a message.
+     *
+     * This method should be called after all the record data fields are appended to the message. It uses the current
+     * message length along with @p aOffset to determine the record length and then updates it within the @p aMessage.
+     * The @p aOffset should point to to the start of the `ResourceRecord` in @p aMessage.
+     *
+     * @param[in] aMessage   The message to update.
+     * @param[in] aOffset    The offset to the start of `ResourceRecord` in @p aMessage.
+     */
+    static void UpdateRecordLengthInMessage(Message &aMessage, uint16_t aOffset);
+
     /**
      * Parses and skips over a given number of resource records in a message from a given offset.
      *
@@ -1492,6 +1639,76 @@ public:
         return ReadRecord(aMessage, aOffset, RecordType::kType, aRecord, sizeof(RecordType));
     }
 
+    /**
+     * Parses and decompresses record data for specific record types where the record data format can contain one or
+     * more compressed DNS names.
+     *
+     * The following record types are handled: NS, CNAME, SOA, PTR, MX, RP, AFSDB, RT, PX, SRV, KX, DNAME, and NSEC.
+     *
+     * If the record type is not in the list above, this method returns `kErrorNone`, with @p aDataMsg remaining
+     * as `nullptr`.
+     *
+     * If the record type is in the above list (requires decompression) and is processed successfully, a new message
+     * is allocated where the decompressed record data is placed. The allocated message is returned via @p aDataMsg
+     * (its ownership is passed to the caller as indicated by the use of `OwnedPtr`). The allocated message contains
+     * the decompressed record data. Importantly it does not include the `ResourceRecord` header.
+     *
+     * When decompressing the record data, this method ensures any embedded DNS names are well-formed and parsable.
+     * It also verifies the record data meets the expected data format (e.g., minimum length based on the record type).
+     * Any additional bytes beyond the expected record data format are also copied to `aDataMsg`. No deep semantic
+     * validation of the record data content is performed.
+     *
+     * @param[in]  aMessage    The message to read from. `aMessage.GetOffset()` MUST point to the start of DNS header
+     *                         (this is used to handle compressed names).
+     * @param[in]  aOffset     The offset in @p aMessage pointing to the byte after the record name and the start of
+     *                         `ResourceRecord` fields.
+     * @param[out] aDataMsg    A reference to an `OwnedPtr<Message>` to output the allocated message containing the
+     *                         decompressed record data. On input, it should be set to `nullptr`.
+     *
+     * @retval kErrorNone       The record type did not require decompression, or decompression was successful.
+     * @retval kErrorNoBufs     Failed to allocate a buffer to return the decompressed data.
+     * @retval kErrorParse      The record data format is invalid.
+     */
+    static Error DecompressRecordData(const Message &aMessage, uint16_t aOffset, OwnedPtr<Message> &aDataMsg);
+
+    /**
+     * Translates embedded DNS names in record data (if needed) and appends the translated data to a given message.
+     *
+     * For records with type NS, CNAME, SOA, PTR, MX, RP, AFSDB, RT, PX, SRV, KX, DNAME, or NSEC, the record data
+     * includes one or more embedded DNS names. For these record types, if the embedded DNS name uses the given
+     * @p aOriginalDomain, it is replaced with the translated domain name before appending it to @p aMessage.
+     * Otherwise, the name is appended as it appears in the record data. This is intended for use by the Discovery
+     * Proxy where the RDATA from mDNS will use the `.local.` domain name, which then needs to be translated to the
+     * Thread network domain name (`default.service.arpa.`).
+     *
+     * For other record types, the record data @p aData is appended as is.
+     *
+     * @param[in] aMessage                  The message to append the (translated) record data to.
+     * @param[in] aRecordType               The record type.
+     * @param[in] aData                     The record data (to translate and append).
+     * @param[in] aOriginalDomain           The original domain name.
+     * @param[in] aTranslatedDomainOffset   The offset of the translated domain name in @p aMessage.
+     *
+     * @retval kErrorNone     The (translated) record data was successfully appended to @p aMessage.
+     * @retval kErrorNoBufs   Failed to allocate new buffers.
+     * @retval kErrorParse    The given @p aData format is not valid.
+     *
+     */
+    static Error AppendTranslatedRecordDataTo(Message                       &aMessage,
+                                              uint16_t                       aRecordType,
+                                              const Data<kWithUint16Length> &aData,
+                                              const char                    *aOriginalDomain,
+                                              uint16_t                       aTranslatedDomainOffset);
+
+    /**
+     * Returns a human-readable string representation of a given resource record type.
+     *
+     * @param[in] aRecordType  The resource record type to convert.
+     *
+     * @returns human-readable string representation of a given resource record type.
+     */
+    static TypeInfoString TypeToString(uint16_t aRecordType);
+
 protected:
     Error ReadName(const Message &aMessage,
                    uint16_t      &aOffset,
@@ -1504,6 +1721,21 @@ protected:
 private:
     static constexpr uint16_t kType = kTypeAny; // This is intended for used by `ReadRecord<RecordType>()` only.
 
+    struct DataRecipe // RDATA recipe for record types that contain one or more embedded DNS names
+    {
+        int Compare(uint16_t aRecordType) const { return (aRecordType - mRecordType); }
+
+        constexpr static bool AreInOrder(const DataRecipe &aFirst, const DataRecipe &aSecond)
+        {
+            return (aFirst.mRecordType < aSecond.mRecordType);
+        }
+
+        uint16_t mRecordType;        // The record type.
+        uint8_t  mNumPrefixBytes;    // Number of bytes in RDATA before the first name.
+        uint8_t  mNumNames;          // Number of DNS names embedded in the RDATA.
+        uint16_t mMinNumSuffixBytes; // Minimum number of expected bytes in RDATA after the last name.
+    };
+
     static Error FindRecord(const Message  &aMessage,
                             uint16_t       &aOffset,
                             uint16_t        aNumRecords,
@@ -1519,6 +1751,8 @@ private:
                             ResourceRecord &aRecord,
                             uint16_t        aMinRecordSize);
 
+    static const DataRecipe *FindDataRecipeFor(uint16_t aRecordType);
+
     Error CheckRecord(const Message &aMessage, uint16_t aOffset) const;
     Error ReadFrom(const Message &aMessage, uint16_t aOffset);
 
diff --git a/src/core/net/dnssd.cpp b/src/core/net/dnssd.cpp
index 128c562c0..27f193088 100644
--- a/src/core/net/dnssd.cpp
+++ b/src/core/net/dnssd.cpp
@@ -473,6 +473,50 @@ exit:
     return;
 }
 
+void Dnssd::StartRecordQuerier(const RecordQuerier &aQuerier)
+{
+    VerifyOrExit(IsReady());
+
+#if OPENTHREAD_CONFIG_PLATFORM_DNSSD_ALLOW_RUN_TIME_SELECTION
+    if (mUseNativeMdns)
+#endif
+#if OPENTHREAD_CONFIG_MULTICAST_DNS_ENABLE
+    {
+        IgnoreError(Get<Dns::Multicast::Core>().StartRecordQuerier(aQuerier));
+        ExitNow();
+    }
+#endif
+
+#if OPENTHREAD_CONFIG_PLATFORM_DNSSD_ENABLE
+    otPlatDnssdStartRecordQuerier(&GetInstance(), &aQuerier);
+#endif
+
+exit:
+    return;
+}
+
+void Dnssd::StopRecordQuerier(const RecordQuerier &aQuerier)
+{
+    VerifyOrExit(IsReady());
+
+#if OPENTHREAD_CONFIG_PLATFORM_DNSSD_ALLOW_RUN_TIME_SELECTION
+    if (mUseNativeMdns)
+#endif
+#if OPENTHREAD_CONFIG_MULTICAST_DNS_ENABLE
+    {
+        IgnoreError(Get<Dns::Multicast::Core>().StopRecordQuerier(aQuerier));
+        ExitNow();
+    }
+#endif
+
+#if OPENTHREAD_CONFIG_PLATFORM_DNSSD_ENABLE
+    otPlatDnssdStopRecordQuerier(&GetInstance(), &aQuerier);
+#endif
+
+exit:
+    return;
+}
+
 void Dnssd::HandleStateChange(void)
 {
 #if OPENTHREAD_CONFIG_SRP_SERVER_ADVERTISING_PROXY_ENABLE
@@ -482,6 +526,10 @@ void Dnssd::HandleStateChange(void)
 #if OPENTHREAD_CONFIG_DNSSD_SERVER_ENABLE && OPENTHREAD_CONFIG_DNSSD_DISCOVERY_PROXY_ENABLE
     Get<Dns::ServiceDiscovery::Server>().HandleDnssdPlatformStateChange();
 #endif
+
+#if OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE && OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_ENABLE
+    Get<MeshCoP::BorderAgent>().HandleDnssdPlatformStateChange();
+#endif
 }
 
 #if OPENTHREAD_CONFIG_MULTICAST_DNS_ENABLE
diff --git a/src/core/net/dnssd.hpp b/src/core/net/dnssd.hpp
index 3f1a58107..8b5044799 100644
--- a/src/core/net/dnssd.hpp
+++ b/src/core/net/dnssd.hpp
@@ -93,12 +93,14 @@ public:
     typedef otPlatDnssdBrowseCallback   BrowseCallback;   ///< Browser callback.
     typedef otPlatDnssdSrvCallback      SrvCallback;      ///< SRV callback.
     typedef otPlatDnssdTxtCallback      TxtCallback;      ///< TXT callback.
-    typedef otPlatDnssdAddressCallback  AddressCallback;  ///< Address callback
+    typedef otPlatDnssdAddressCallback  AddressCallback;  ///< Address callback.
+    typedef otPlatDnssdRecordCallback   RecordCallback;   ///< Record callback.
     typedef otPlatDnssdBrowseResult     BrowseResult;     ///< Browser result.
     typedef otPlatDnssdSrvResult        SrvResult;        ///< SRV result.
     typedef otPlatDnssdTxtResult        TxtResult;        ///< TXT result.
     typedef otPlatDnssdAddressResult    AddressResult;    ///< Address result.
     typedef otPlatDnssdAddressAndTtl    AddressAndTtl;    ///< Address and TTL.
+    typedef otPlatDnssdRecordResult     RecordResult;     ///< Record result.
 
     class Host : public otPlatDnssdHost, public Clearable<Host> ///< Host information.
     {
@@ -128,6 +130,10 @@ public:
     {
     };
 
+    class RecordQuerier : public otPlatDnssdRecordQuerier, public Clearable<RecordQuerier> ///< Record querier.
+    {
+    };
+
     /**
      * Represents a range of `RequestId` values.
      *
@@ -381,6 +387,26 @@ public:
      */
     void StopIp4AddressResolver(const AddressResolver &aResolver);
 
+    /**
+     * Starts a record querier.
+     *
+     * Refer to the documentation for `otPlatDnssdStartRecordQuerier()` for a more detailed description of the
+     * behavior of this method.
+     *
+     * @param[in] aQuerier    The querier to be started.
+     */
+    void StartRecordQuerier(const RecordQuerier &aQuerier);
+
+    /**
+     * Stops a record querier.
+     *
+     * Refer to the documentation for `otPlatDnssdStopRecordQuerier()` for a more detailed description of the
+     * behavior of this method.
+     *
+     * @param[in] aQuerier    The querier to stop.
+     */
+    void StopRecordQuerier(const RecordQuerier &aQuerier);
+
 #if OPENTHREAD_CONFIG_MULTICAST_DNS_ENABLE
     /**
      * Handles native mDNS state change.
diff --git a/src/core/net/dnssd_server.cpp b/src/core/net/dnssd_server.cpp
index ff3176aa5..8520fd958 100644
--- a/src/core/net/dnssd_server.cpp
+++ b/src/core/net/dnssd_server.cpp
@@ -45,11 +45,16 @@ RegisterLogModule("DnssdServer");
 
 const char Server::kDefaultDomainName[] = "default.service.arpa.";
 const char Server::kSubLabel[]          = "_sub";
+const char Server::kMdnsDomainName[]    = "local.";
 
 #if OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE
 const char *Server::kBlockedDomains[] = {"ipv4only.arpa."};
 #endif
 
+#if OPENTHREAD_CONFIG_SRP_SERVER_ENABLE || OPENTHREAD_CONFIG_DNSSD_DISCOVERY_PROXY_ENABLE
+const char Server::kSoaRnameLabel[] = "postmaster";
+#endif
+
 Server::Server(Instance &aInstance)
     : InstanceLocator(aInstance)
     , mSocket(aInstance, *this)
@@ -63,6 +68,10 @@ Server::Server(Instance &aInstance)
     , mTestMode(kTestModeDisabled)
 {
     mCounters.Clear();
+
+#if OPENTHREAD_CONFIG_SRP_SERVER_ENABLE || OPENTHREAD_CONFIG_DNSSD_DISCOVERY_PROXY_ENABLE
+    ClearAllBytes(mSoaServerName);
+#endif
 }
 
 Error Server::Start(void)
@@ -78,6 +87,10 @@ Error Server::Start(void)
     Get<Srp::Server>().HandleDnssdServerStateChange();
 #endif
 
+#if OPENTHREAD_CONFIG_SRP_SERVER_ENABLE || OPENTHREAD_CONFIG_DNSSD_DISCOVERY_PROXY_ENABLE
+    ConstructSoaServerName();
+#endif
+
     LogInfo("Started");
 
 #if OPENTHREAD_CONFIG_DNSSD_DISCOVERY_PROXY_ENABLE
@@ -157,17 +170,13 @@ void Server::ProcessQuery(Request &aRequest)
     Response     response(GetInstance());
 
 #if OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE
-    if (mEnableUpstreamQuery && ShouldForwardToUpstream(aRequest))
+    if (ShouldForwardToUpstream(aRequest))
     {
-        Error error = ResolveByUpstream(aRequest);
-
-        if (error == kErrorNone)
+        if (ResolveByUpstream(aRequest) == kErrorNone)
         {
             ExitNow();
         }
 
-        LogWarnOnError(error, "forwarding to upstream");
-
         rcode = Header::kResponseServerFailure;
 
         // Continue to allocate and prepare the response message
@@ -190,6 +199,13 @@ void Server::ProcessQuery(Request &aRequest)
     response.Log();
 #endif
 
+#if OPENTHREAD_CONFIG_SRP_SERVER_ENABLE || OPENTHREAD_CONFIG_DNSSD_DISCOVERY_PROXY_ENABLE
+    // Try to resolve SOA/NS queries. If successfully
+    // resolved, the response will not be empty.
+    VerifyOrExit(response.ResolveSoaOrNsQuery() == kErrorNone, rcode = Header::kResponseServerFailure);
+    VerifyOrExit(response.IsEmpty());
+#endif
+
 #if OPENTHREAD_CONFIG_SRP_SERVER_ENABLE
     switch (response.ResolveBySrp())
     {
@@ -207,6 +223,10 @@ void Server::ProcessQuery(Request &aRequest)
     }
 #endif
 
+    // `ResolveByProxy` may take ownership of `response.mMessage` and
+    // setting it to `nullptr`. In such a case, the `response.Send()`
+    // call will effectively do nothing.
+
     ResolveByProxy(response, *aRequest.mMessageInfo);
 
 exit:
@@ -289,6 +309,21 @@ exit:
     return;
 }
 
+bool Server::Questions::IsFor(uint16_t aRrType) const
+{
+    // Check if any of questions is for `aRrType`.
+
+    return (mFirstRrType == aRrType) || (mSecondRrType == aRrType);
+}
+
+Server::Section Server::Questions::SectionFor(uint16_t aRrType) const
+{
+    // Determine section to append `aRrType` record based on the
+    // query questions.
+
+    return (IsFor(aRrType) || IsFor(kRrTypeAny)) ? kAnswerSection : kAdditionalDataSection;
+}
+
 Server::ResponseCode Server::Request::ParseQuestions(uint8_t aTestMode, bool &aShouldRespond)
 {
     // Parse header and questions from a `Request` query message and
@@ -310,26 +345,7 @@ Server::ResponseCode Server::Request::ParseQuestions(uint8_t aTestMode, bool &aS
     SuccessOrExit(mMessage->Read(offset, question));
     offset += sizeof(question);
 
-    switch (question.GetType())
-    {
-    case ResourceRecord::kTypePtr:
-        mType = kPtrQuery;
-        break;
-    case ResourceRecord::kTypeSrv:
-        mType = kSrvQuery;
-        break;
-    case ResourceRecord::kTypeTxt:
-        mType = kTxtQuery;
-        break;
-    case ResourceRecord::kTypeAaaa:
-        mType = kAaaaQuery;
-        break;
-    case ResourceRecord::kTypeA:
-        mType = kAQuery;
-        break;
-    default:
-        ExitNow(rcode = Header::kResponseNotImplemented);
-    }
+    mQuestions.mFirstRrType = question.GetType();
 
     if (questionCount > 1)
     {
@@ -338,24 +354,15 @@ Server::ResponseCode Server::Request::ParseQuestions(uint8_t aTestMode, bool &aS
 
         VerifyOrExit(questionCount == 2);
 
+        // Allow SRV and TXT questions for the same service
+        // instance name in the same query.
+
         SuccessOrExit(Name::CompareName(*mMessage, offset, *mMessage, sizeof(Header)));
         SuccessOrExit(mMessage->Read(offset, question));
 
-        switch (question.GetType())
-        {
-        case ResourceRecord::kTypeSrv:
-            VerifyOrExit(mType == kTxtQuery);
-            break;
-
-        case ResourceRecord::kTypeTxt:
-            VerifyOrExit(mType == kSrvQuery);
-            break;
+        mQuestions.mSecondRrType = question.GetType();
 
-        default:
-            ExitNow();
-        }
-
-        mType = kSrvTxtQuery;
+        VerifyOrExit(mQuestions.IsFor(kRrTypeSrv) && mQuestions.IsFor(kRrTypeTxt));
     }
 
     rcode = Header::kResponseSuccess;
@@ -369,19 +376,14 @@ Server::ResponseCode Server::Response::AddQuestionsFrom(const Request &aRequest)
     ResponseCode rcode = Header::kResponseServerFailure;
     uint16_t     offset;
 
-    mType = aRequest.mType;
+    mQuestions = aRequest.mQuestions;
 
     // Read the name from `aRequest.mMessage` and append it as is to
     // the response message. This ensures all name formats, including
     // service instance names with dot characters in the instance
     // label, are appended correctly.
 
-    SuccessOrExit(Name(*aRequest.mMessage, sizeof(Header)).AppendTo(*mMessage));
-
-    // Check the name to include the correct domain name and determine
-    // the domain name offset (for DNS name compression).
-
-    VerifyOrExit(ParseQueryName() == kErrorNone, rcode = Header::kResponseNameError);
+    SuccessOrExit(Name(*aRequest.mMessage, kQueryNameOffset).AppendTo(*mMessage));
 
     mHeader.SetQuestionCount(aRequest.mHeader.GetQuestionCount());
 
@@ -406,16 +408,36 @@ Server::ResponseCode Server::Response::AddQuestionsFrom(const Request &aRequest)
         SuccessOrExit(mMessage->Append(question));
     }
 
-    rcode = Header::kResponseSuccess;
+    // Check the name to include the correct domain name and determine
+    // the domain name offset (for DNS name compression).
+
+    rcode = (ParseQueryName() == kErrorNone) ? Header::kResponseSuccess : Header::kResponseNameError;
 
 exit:
+    if (rcode == Header::kResponseServerFailure)
+    {
+        // If we fail to add questions to the response message
+        // (no buffer), we clear the question count in the header and
+        // just include the header in the message.
+
+        mHeader.SetQuestionCount(0);
+        IgnoreError(mMessage->SetLength(sizeof(Header)));
+    }
+
     return rcode;
 }
 
+bool Server::Response::IsEmpty(void) const
+{
+    return (mHeader.GetAnswerCount() == 0) && (mHeader.GetAuthorityRecordCount() == 0) &&
+           (mHeader.GetAdditionalRecordCount() == 0);
+}
+
 Error Server::Response::ParseQueryName(void)
 {
-    // Parses and validates the query name and updates
-    // the name compression offsets.
+    // Parses the query name, determines name compression
+    // offsets, and validates that the query name is for
+    // `kDefaultDomainName` ("default.service.arpa.").
 
     Error        error = kErrorNone;
     Name::Buffer name;
@@ -424,31 +446,17 @@ Error Server::Response::ParseQueryName(void)
     offset = sizeof(Header);
     SuccessOrExit(error = Name::ReadName(*mMessage, offset, name));
 
-    switch (mType)
-    {
-    case kPtrQuery:
-        // `mOffsets.mServiceName` may be updated as we read labels and if we
-        // determine that the query name is a sub-type service.
-        mOffsets.mServiceName = sizeof(Header);
-        break;
-
-    case kSrvQuery:
-    case kTxtQuery:
-    case kSrvTxtQuery:
-        mOffsets.mInstanceName = sizeof(Header);
-        break;
-
-    case kAaaaQuery:
-    case kAQuery:
-        mOffsets.mHostName = sizeof(Header);
-        break;
-    }
+    // `mOffsets.mServiceName` may be updated as we read labels and if we
+    // determine that the query name is a sub-type service.
+    mOffsets.mServiceName  = kQueryNameOffset;
+    mOffsets.mInstanceName = kQueryNameOffset;
+    mOffsets.mHostName     = kQueryNameOffset;
 
     // Read the query name labels one by one to check if the name is
     // service sub-type and also check that it is sub-domain of the
     // default domain name and determine its offset
 
-    offset = sizeof(Header);
+    offset = kQueryNameOffset;
 
     while (true)
     {
@@ -456,13 +464,6 @@ Error Server::Response::ParseQueryName(void)
         uint8_t           labelLength = sizeof(label);
         uint16_t          comapreOffset;
 
-        SuccessOrExit(error = Name::ReadLabel(*mMessage, offset, label, labelLength));
-
-        if ((mType == kPtrQuery) && StringMatch(label, kSubLabel, kStringCaseInsensitiveMatch))
-        {
-            mOffsets.mServiceName = offset;
-        }
-
         comapreOffset = offset;
 
         if (Name::CompareName(*mMessage, comapreOffset, kDefaultDomainName) == kErrorNone)
@@ -470,9 +471,15 @@ Error Server::Response::ParseQueryName(void)
             mOffsets.mDomainName = offset;
             ExitNow();
         }
-    }
 
-    error = kErrorParse;
+        SuccessOrExit(error = Name::ReadLabel(*mMessage, offset, label, labelLength));
+
+        if ((mQuestions.IsFor(kRrTypePtr) || mQuestions.IsFor(kRrTypeAny)) &&
+            StringMatch(label, kSubLabel, kStringCaseInsensitiveMatch))
+        {
+            mOffsets.mServiceName = offset;
+        }
+    }
 
 exit:
     return error;
@@ -482,7 +489,21 @@ void Server::Response::ReadQueryName(Name::Buffer &aName) const { Server::ReadQu
 
 bool Server::Response::QueryNameMatches(const char *aName) const { return Server::QueryNameMatches(*mMessage, aName); }
 
-Error Server::Response::AppendQueryName(void) { return Name::AppendPointerLabel(sizeof(Header), *mMessage); }
+bool Server::Response::QueryNameIsForDomain(const char *aDomainName) const
+{
+    return Server::QueryNameIsForDomain(*mMessage, aDomainName);
+}
+
+Error Server::Response::AppendQueryName(void) { return Name::AppendPointerLabel(kQueryNameOffset, *mMessage); }
+
+#if OPENTHREAD_CONFIG_SRP_SERVER_ENABLE
+Error Server::Response::AppendPtrRecord(const Srp::Server::Service &aService)
+{
+    uint32_t ttl = TimeMilli::MsecToSec(aService.GetExpireTime() - TimerMilli::GetNow());
+
+    return AppendPtrRecord(aService.GetInstanceLabel(), ttl);
+}
+#endif
 
 Error Server::Response::AppendPtrRecord(const char *aInstanceLabel, uint32_t aTtl)
 {
@@ -502,7 +523,7 @@ Error Server::Response::AppendPtrRecord(const char *aInstanceLabel, uint32_t aTt
     SuccessOrExit(error = Name::AppendLabel(aInstanceLabel, *mMessage));
     SuccessOrExit(error = Name::AppendPointerLabel(mOffsets.mServiceName, *mMessage));
 
-    UpdateRecordLength(ptrRecord, recordOffset);
+    ResourceRecord::UpdateRecordLengthInMessage(*mMessage, recordOffset);
 
     IncResourceRecordCount();
 
@@ -536,6 +557,7 @@ Error Server::Response::AppendSrvRecord(const char *aHostName,
     SrvRecord    srvRecord;
     uint16_t     recordOffset;
     Name::Buffer hostLabels;
+    uint16_t     nameOffset;
 
     SuccessOrExit(error = Name::ExtractLabels(aHostName, kDefaultDomainName, hostLabels));
 
@@ -545,7 +567,8 @@ Error Server::Response::AppendSrvRecord(const char *aHostName,
     srvRecord.SetWeight(aWeight);
     srvRecord.SetPort(aPort);
 
-    SuccessOrExit(error = Name::AppendPointerLabel(mOffsets.mInstanceName, *mMessage));
+    nameOffset = mQuestions.IsFor(kRrTypeAny) ? kQueryNameOffset : mOffsets.mInstanceName;
+    SuccessOrExit(error = Name::AppendPointerLabel(nameOffset, *mMessage));
 
     recordOffset = mMessage->GetLength();
     SuccessOrExit(error = mMessage->Append(srvRecord));
@@ -554,7 +577,7 @@ Error Server::Response::AppendSrvRecord(const char *aHostName,
     SuccessOrExit(error = Name::AppendMultipleLabels(hostLabels, *mMessage));
     SuccessOrExit(error = Name::AppendPointerLabel(mOffsets.mDomainName, *mMessage));
 
-    UpdateRecordLength(srvRecord, recordOffset);
+    ResourceRecord::UpdateRecordLengthInMessage(*mMessage, recordOffset);
 
     IncResourceRecordCount();
 
@@ -563,6 +586,11 @@ exit:
 }
 
 #if OPENTHREAD_CONFIG_SRP_SERVER_ENABLE
+Error Server::Response::AppendHostAddresses(const Srp::Server::Service &aService)
+{
+    return AppendHostAddresses(aService.GetHost());
+}
+
 Error Server::Response::AppendHostAddresses(const Srp::Server::Host &aHost)
 {
     const Ip6::Address *addrs;
@@ -618,6 +646,7 @@ Error Server::Response::AppendAaaaRecord(const Ip6::Address &aAddress, uint32_t
 {
     Error      error = kErrorNone;
     AaaaRecord aaaaRecord;
+    uint16_t   nameOffset;
 
     VerifyOrExit(!aAddress.IsIp4Mapped());
 
@@ -625,7 +654,8 @@ Error Server::Response::AppendAaaaRecord(const Ip6::Address &aAddress, uint32_t
     aaaaRecord.SetTtl(aTtl);
     aaaaRecord.SetAddress(aAddress);
 
-    SuccessOrExit(error = Name::AppendPointerLabel(mOffsets.mHostName, *mMessage));
+    nameOffset = mQuestions.IsFor(kRrTypeAny) ? kQueryNameOffset : mOffsets.mHostName;
+    SuccessOrExit(error = Name::AppendPointerLabel(nameOffset, *mMessage));
     SuccessOrExit(error = mMessage->Append(aaaaRecord));
     IncResourceRecordCount();
 
@@ -638,6 +668,7 @@ Error Server::Response::AppendARecord(const Ip6::Address &aAddress, uint32_t aTt
     Error        error = kErrorNone;
     ARecord      aRecord;
     Ip4::Address ip4Address;
+    uint16_t     nameOffset;
 
     SuccessOrExit(ip4Address.ExtractFromIp4MappedIp6Address(aAddress));
 
@@ -645,7 +676,8 @@ Error Server::Response::AppendARecord(const Ip6::Address &aAddress, uint32_t aTt
     aRecord.SetTtl(aTtl);
     aRecord.SetAddress(ip4Address);
 
-    SuccessOrExit(error = Name::AppendPointerLabel(mOffsets.mHostName, *mMessage));
+    nameOffset = mQuestions.IsFor(kRrTypeAny) ? kQueryNameOffset : mOffsets.mHostName;
+    SuccessOrExit(error = Name::AppendPointerLabel(nameOffset, *mMessage));
     SuccessOrExit(error = mMessage->Append(aRecord));
     IncResourceRecordCount();
 
@@ -670,6 +702,7 @@ Error Server::Response::AppendTxtRecord(const void *aTxtData, uint16_t aTxtLengt
 {
     Error     error = kErrorNone;
     TxtRecord txtRecord;
+    uint16_t  nameOffset;
     uint8_t   emptyTxt = 0;
 
     if (aTxtLength == 0)
@@ -682,7 +715,8 @@ Error Server::Response::AppendTxtRecord(const void *aTxtData, uint16_t aTxtLengt
     txtRecord.SetTtl(aTtl);
     txtRecord.SetLength(aTxtLength);
 
-    SuccessOrExit(error = Name::AppendPointerLabel(mOffsets.mInstanceName, *mMessage));
+    nameOffset = mQuestions.IsFor(kRrTypeAny) ? kQueryNameOffset : mOffsets.mInstanceName;
+    SuccessOrExit(error = Name::AppendPointerLabel(nameOffset, *mMessage));
     SuccessOrExit(error = mMessage->Append(txtRecord));
     SuccessOrExit(error = mMessage->AppendBytes(aTxtData, aTxtLength));
 
@@ -692,16 +726,85 @@ exit:
     return error;
 }
 
-void Server::Response::UpdateRecordLength(ResourceRecord &aRecord, uint16_t aOffset)
+#if OPENTHREAD_CONFIG_SRP_SERVER_ENABLE
+Error Server::Response::AppendKeyRecord(const Srp::Server::Host &aHost)
+{
+    Ecdsa256KeyRecord keyRecord;
+    RecordData        keyData;
+    uint32_t          ttl;
+
+    keyRecord.Init();
+    keyRecord.SetFlags(KeyRecord::kAuthConfidPermitted, KeyRecord::kOwnerNonZone, KeyRecord::kSignatoryFlagGeneral);
+    keyRecord.SetProtocol(KeyRecord::kProtocolDnsSec);
+    keyRecord.SetAlgorithm(KeyRecord::kAlgorithmEcdsaP256Sha256);
+    keyRecord.SetLength(sizeof(Ecdsa256KeyRecord) - sizeof(ResourceRecord));
+    keyRecord.SetKey(aHost.GetKey());
+    keyData.InitFrom(keyRecord);
+
+    ttl = TimeMilli::MsecToSec(aHost.GetExpireTime() - TimerMilli::GetNow());
+
+    return AppendGenericRecord(Ecdsa256KeyRecord::kType, keyData, ttl);
+}
+#endif
+
+Error Server::Response::AppendGenericRecord(uint16_t aRrType, const RecordData &aData, uint32_t aTtl)
+{
+    Error          error = kErrorNone;
+    ResourceRecord record;
+    uint16_t       recordOffset;
+
+    record.Init(aRrType);
+    record.SetTtl(aTtl);
+
+    SuccessOrExit(error = Name::AppendPointerLabel(kQueryNameOffset, *mMessage));
+
+    recordOffset = mMessage->GetLength();
+    SuccessOrExit(error = mMessage->Append(record));
+
+    SuccessOrExit(error = ResourceRecord::AppendTranslatedRecordDataTo(*mMessage, aRrType, aData, kMdnsDomainName,
+                                                                       mOffsets.mDomainName));
+    ResourceRecord::UpdateRecordLengthInMessage(*mMessage, recordOffset);
+
+    IncResourceRecordCount();
+
+exit:
+    return error;
+}
+
+template <typename ServiceType> Error Server::Response::AppendServiceRecords(const ServiceType &aService)
 {
-    // Calculates RR DATA length and updates and re-writes it in the
-    // response message. This should be called immediately
-    // after all the fields in the record are written in the message.
-    // `aOffset` gives the offset in the message to the start of the
-    // record.
+    static const Section kSections[] = {kAnswerSection, kAdditionalDataSection};
+
+    // Append SRV and TXT records along with associated host AAAA addresses
+    // in the proper sections.
+
+    Error error = kErrorNone;
+
+    for (Section section : kSections)
+    {
+        mSection = section;
+
+        if (mSection == kAdditionalDataSection)
+        {
+            VerifyOrExit(!mQuestions.IsFor(kRrTypeAny));
+            VerifyOrExit(!(Get<Server>().mTestMode & kTestModeEmptyAdditionalSection));
+        }
+
+        if (mSection == mQuestions.SectionFor(kRrTypeSrv))
+        {
+            SuccessOrExit(error = AppendSrvRecord(aService));
+        }
+
+        if (mSection == mQuestions.SectionFor(kRrTypeTxt))
+        {
+            SuccessOrExit(error = AppendTxtRecord(aService));
+        }
+    }
+
+    error = AppendHostAddresses(aService);
 
-    aRecord.SetLength(mMessage->GetLength() - aOffset - sizeof(Dns::ResourceRecord));
-    mMessage->Write(aOffset, aRecord);
+exit:
+    return error;
 }
 
 void Server::Response::IncResourceRecordCount(void)
@@ -711,6 +814,9 @@ void Server::Response::IncResourceRecordCount(void)
     case kAnswerSection:
         mHeader.SetAnswerCount(mHeader.GetAnswerCount() + 1);
         break;
+    case kAuthoritySection:
+        mHeader.SetAuthorityRecordCount(mHeader.GetAuthorityRecordCount() + 1);
+        break;
     case kAdditionalDataSection:
         mHeader.SetAdditionalRecordCount(mHeader.GetAdditionalRecordCount() + 1);
         break;
@@ -721,34 +827,13 @@ void Server::Response::IncResourceRecordCount(void)
 void Server::Response::Log(void) const
 {
     Name::Buffer name;
+    bool         hasTwoQuestions = (mQuestions.mSecondRrType != 0);
 
     ReadQueryName(name);
-    LogInfo("%s query for '%s'", QueryTypeToString(mType), name);
-}
-
-const char *Server::Response::QueryTypeToString(QueryType aType)
-{
-    static const char *const kTypeNames[] = {
-        "PTR",       // (0) kPtrQuery
-        "SRV",       // (1) kSrvQuery
-        "TXT",       // (2) kTxtQuery
-        "SRV & TXT", // (3) kSrvTxtQuery
-        "AAAA",      // (4) kAaaaQuery
-        "A",         // (5) kAQuery
-    };
 
-    struct EumCheck
-    {
-        InitEnumValidatorCounter();
-        ValidateNextEnum(kPtrQuery);
-        ValidateNextEnum(kSrvQuery);
-        ValidateNextEnum(kTxtQuery);
-        ValidateNextEnum(kSrvTxtQuery);
-        ValidateNextEnum(kAaaaQuery);
-        ValidateNextEnum(kAQuery);
-    };
-
-    return kTypeNames[aType];
+    LogInfo("%s%s%s query for '%s'", ResourceRecord::TypeToString(mQuestions.mFirstRrType).AsCString(),
+            hasTwoQuestions ? " and " : "",
+            hasTwoQuestions ? ResourceRecord::TypeToString(mQuestions.mSecondRrType).AsCString() : "", name);
 }
 #endif
 
@@ -756,13 +841,8 @@ const char *Server::Response::QueryTypeToString(QueryType aType)
 
 Error Server::Response::ResolveBySrp(void)
 {
-    static const Section kSections[] = {kAnswerSection, kAdditionalDataSection};
-
-    Error                       error          = kErrorNotFound;
+    Error                       error          = kErrorNone;
     const Srp::Server::Service *matchedService = nullptr;
-    bool                        found          = false;
-    Section                     srvSection;
-    Section                     txtSection;
 
     mSection = kAnswerSection;
 
@@ -773,20 +853,12 @@ Error Server::Response::ResolveBySrp(void)
             continue;
         }
 
-        if ((mType == kAaaaQuery) || (mType == kAQuery))
+        if (QueryNameMatches(host.GetFullName()))
         {
-            if (QueryNameMatches(host.GetFullName()))
-            {
-                mSection = (mType == kAaaaQuery) ? kAnswerSection : kAdditionalDataSection;
-                error    = AppendHostAddresses(host);
-                ExitNow();
-            }
-
-            continue;
+            error = ResolveUsingSrpHost(host);
+            ExitNow();
         }
 
-        // `mType` is PTR or SRV/TXT query
-
         for (const Srp::Server::Service &service : host.GetServices())
         {
             if (service.IsDeleted())
@@ -794,66 +866,74 @@ Error Server::Response::ResolveBySrp(void)
                 continue;
             }
 
-            if (mType == kPtrQuery)
+            if (QueryNameMatches(service.GetInstanceName()))
             {
-                if (QueryNameMatchesService(service))
-                {
-                    uint32_t ttl = TimeMilli::MsecToSec(service.GetExpireTime() - TimerMilli::GetNow());
-
-                    SuccessOrExit(error = AppendPtrRecord(service.GetInstanceLabel(), ttl));
-                    matchedService = &service;
-                }
+                error = ResolveUsingSrpService(service);
+                ExitNow();
             }
-            else if (QueryNameMatches(service.GetInstanceName()))
+
+            if ((mQuestions.IsFor(kRrTypePtr) || mQuestions.IsFor(kRrTypeAny)) && QueryNameMatchesService(service))
             {
+                SuccessOrExit(error = AppendPtrRecord(service));
                 matchedService = &service;
-                found          = true;
-                break;
             }
         }
-
-        if (found)
-        {
-            break;
-        }
     }
 
-    VerifyOrExit(matchedService != nullptr);
+    VerifyOrExit(matchedService != nullptr, error = kErrorNotFound);
 
-    if (mType == kPtrQuery)
-    {
-        // Skip adding additional records, when answering a
-        // PTR query with more than one answer. This is the
-        // recommended behavior to keep the size of the
-        // response small.
+    // We append SRV/TXT/AAAA records in additional section for a PTR
+    // query when there is only a single matched service. This is the
+    // recommended behavior to keep the size of the response small.
 
-        VerifyOrExit(mHeader.GetAnswerCount() == 1);
+    if (mQuestions.IsFor(kRrTypePtr) && (mHeader.GetAnswerCount() == 1))
+    {
+        error = AppendServiceRecords(*matchedService);
     }
 
-    srvSection = ((mType == kSrvQuery) || (mType == kSrvTxtQuery)) ? kAnswerSection : kAdditionalDataSection;
-    txtSection = ((mType == kTxtQuery) || (mType == kSrvTxtQuery)) ? kAnswerSection : kAdditionalDataSection;
+exit:
+    return error;
+}
 
-    for (Section section : kSections)
+Error Server::Response::ResolveUsingSrpHost(const Srp::Server::Host &aHost)
+{
+    // The query name is already checked to match the `aHost` name.
+
+    Error error = kErrorNone;
+
+    if (mQuestions.IsFor(kRrTypeAaaa) || mQuestions.IsFor(kRrTypeA) || mQuestions.IsFor(kRrTypeAny))
     {
-        mSection = section;
+        mSection = mQuestions.SectionFor(kRrTypeAaaa);
+        SuccessOrExit(error = AppendHostAddresses(aHost));
+    }
 
-        if (mSection == kAdditionalDataSection)
-        {
-            VerifyOrExit(!(Get<Server>().mTestMode & kTestModeEmptyAdditionalSection));
-        }
+    if (mQuestions.IsFor(kRrTypeKey) || mQuestions.IsFor(kRrTypeAny))
+    {
+        mSection = kAnswerSection;
+        SuccessOrExit(error = AppendKeyRecord(aHost));
+    }
 
-        if (srvSection == mSection)
-        {
-            SuccessOrExit(error = AppendSrvRecord(*matchedService));
-        }
+exit:
+    return error;
+}
 
-        if (txtSection == mSection)
-        {
-            SuccessOrExit(error = AppendTxtRecord(*matchedService));
-        }
+Error Server::Response::ResolveUsingSrpService(const Srp::Server::Service &aService)
+{
+    // The query name is already checked to match the
+    // `aService` instance name.
+
+    Error error = kErrorNone;
+
+    if (mQuestions.IsFor(kRrTypeKey) || mQuestions.IsFor(kRrTypeAny))
+    {
+        mSection = kAnswerSection;
+        SuccessOrExit(error = AppendKeyRecord(aService.GetHost()));
     }
 
-    SuccessOrExit(error = AppendHostAddresses(matchedService->GetHost()));
+    if (mQuestions.IsFor(kRrTypeSrv) || mQuestions.IsFor(kRrTypeTxt) || mQuestions.IsFor(kRrTypeAny))
+    {
+        SuccessOrExit(error = AppendServiceRecords(aService));
+    }
 
 exit:
     return error;
@@ -880,13 +960,158 @@ exit:
 
 #endif // OPENTHREAD_CONFIG_SRP_SERVER_ENABLE
 
+#if OPENTHREAD_CONFIG_SRP_SERVER_ENABLE || OPENTHREAD_CONFIG_DNSSD_DISCOVERY_PROXY_ENABLE
+
+void Server::ConstructSoaServerName(void)
+{
+    if (mSoaServerName[0] == kNullChar)
+    {
+        StringWriter writer(mSoaServerName, sizeof(mSoaServerName));
+
+        writer.Append("otDNS%s", Get<Mac::Mac>().GetExtAddress().ToString().AsCString());
+    }
+}
+
+Error Server::Response::ResolveSoaOrNsQuery(void)
+{
+    Error error = kErrorNone;
+
+    VerifyOrExit(QueryNameIsForDomain(kDefaultDomainName));
+
+    mSection = kAnswerSection;
+
+    // Handle AAAA (or ANY) query for the server host name used for
+    // SOA/NS answer.
+
+    if (mQuestions.IsFor(kRrTypeAaaa) || mQuestions.IsFor(kRrTypeAny))
+    {
+        Name::Buffer serverFullName;
+
+        ConstructFullName(Get<Server>().mSoaServerName, serverFullName);
+
+        if (QueryNameMatches(serverFullName))
+        {
+            for (Ip6::Netif::UnicastAddress &unicastAddr : Get<ThreadNetif>().GetUnicastAddresses())
+            {
+                if (!unicastAddr.mValid || !unicastAddr.mPreferred || unicastAddr.GetAddress().IsLinkLocalUnicast() ||
+                    Get<Mle::Mle>().IsMeshLocalAddress(unicastAddr.GetAddress()))
+                {
+                    continue;
+                }
+
+                SuccessOrExit(error = AppendAaaaRecord(unicastAddr.GetAddress(), kServerAaaaTtl));
+            }
+
+            if (IsEmpty())
+            {
+                SuccessOrExit(error = AppendAaaaRecord(Get<Mle::Mle>().GetMeshLocalEid(), kServerAaaaTtl));
+            }
+
+            ExitNow();
+        }
+    }
+
+    // Handle SOA or NS (or ANY) queries. The SOA or NS query should
+    // be for the domain name (`default.service.arpa`). If it is for a
+    // name under the default domain, e.g. `host1.default.service.arpa`,
+    // we provide the SOA record in Authority section in the response.
+
+    if (!QueryNameMatches(kDefaultDomainName))
+    {
+        VerifyOrExit(mQuestions.IsFor(kRrTypeSoa) || mQuestions.IsFor(kRrTypeNs));
+        mSection = kAuthoritySection;
+        ExitNow(error = AppendSoaRecord());
+    }
+
+    if (mQuestions.IsFor(kRrTypeSoa) || mQuestions.IsFor(kRrTypeAny))
+    {
+        SuccessOrExit(error = AppendSoaRecord());
+    }
+
+    if (mQuestions.IsFor(kRrTypeNs) || mQuestions.IsFor(kRrTypeAny))
+    {
+        SuccessOrExit(error = AppendNsRecord());
+    }
+
+exit:
+    return error;
+}
+
+Error Server::Response::AppendSoaRecord(void)
+{
+    const uint32_t kFields[] = {
+        kSoaSerial, kSoaRefresh, kSoaRetry, kSoaExpire, kSoaMinimum,
+    };
+
+    Error          error = kErrorNone;
+    ResourceRecord record;
+    uint16_t       offset;
+
+    record.Init(kRrTypeSoa);
+    record.SetTtl(kSoaTtl);
+
+    SuccessOrExit(error = Name::AppendPointerLabel(mOffsets.mDomainName, *mMessage));
+
+    offset = mMessage->GetLength();
+    SuccessOrExit(error = mMessage->Append(record));
+
+    // MNAME
+    SuccessOrExit(error = Name::AppendLabel(Get<Server>().mSoaServerName, *mMessage));
+    SuccessOrExit(error = Name::AppendPointerLabel(mOffsets.mDomainName, *mMessage));
+
+    // RNAME: Use constant "postmaster.<domain>"
+    SuccessOrExit(error = Name::AppendLabel(kSoaRnameLabel, *mMessage));
+    SuccessOrExit(error = Name::AppendPointerLabel(mOffsets.mDomainName, *mMessage));
+
+    for (uint32_t fieldValue : kFields)
+    {
+        SuccessOrExit(error = mMessage->Append<uint32_t>(BigEndian::HostSwap32(fieldValue)));
+    }
+
+    ResourceRecord::UpdateRecordLengthInMessage(*mMessage, offset);
+
+    IncResourceRecordCount();
+
+exit:
+    return error;
+}
+
+Error Server::Response::AppendNsRecord(void)
+{
+    Error          error = kErrorNone;
+    ResourceRecord record;
+    uint16_t       offset;
+
+    record.Init(kRrTypeNs);
+    record.SetTtl(kNsTtl);
+
+    SuccessOrExit(error = Name::AppendPointerLabel(mOffsets.mDomainName, *mMessage));
+
+    offset = mMessage->GetLength();
+    SuccessOrExit(error = mMessage->Append(record));
+
+    SuccessOrExit(error = Name::AppendLabel(Get<Server>().mSoaServerName, *mMessage));
+    SuccessOrExit(error = Name::AppendPointerLabel(mOffsets.mDomainName, *mMessage));
+
+    ResourceRecord::UpdateRecordLengthInMessage(*mMessage, offset);
+
+    IncResourceRecordCount();
+
+exit:
+    return error;
+}
+
+#endif //  OPENTHREAD_CONFIG_SRP_SERVER_ENABLE || OPENTHREAD_CONFIG_DNSSD_DISCOVERY_PROXY_ENABLE
+
 #if OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE
-bool Server::ShouldForwardToUpstream(const Request &aRequest)
+bool Server::ShouldForwardToUpstream(const Request &aRequest) const
 {
     bool         shouldForward = false;
     uint16_t     readOffset;
     Name::Buffer name;
 
+    VerifyOrExit(mEnableUpstreamQuery);
+
     VerifyOrExit(aRequest.mHeader.IsRecursionDesiredFlagSet());
     readOffset = sizeof(Header);
 
@@ -961,10 +1186,13 @@ Error Server::ResolveByUpstream(const Request &aRequest)
     txn = AllocateUpstreamQueryTransaction(*aRequest.mMessageInfo);
     VerifyOrExit(txn != nullptr, error = kErrorNoBufs);
 
+    VerifyOrExit(otPlatDnsIsUpstreamQueryAvailable(&GetInstance()), error = kErrorInvalidState);
+
     otPlatDnsStartUpstreamQuery(&GetInstance(), txn, aRequest.mMessage);
     mCounters.mUpstreamDnsCounters.mQueries++;
 
 exit:
+    LogWarnOnError(error, "forward to upstream");
     return error;
 }
 #endif // OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE
@@ -983,7 +1211,7 @@ void Server::ResolveByProxy(Response &aResponse, const Ip6::MessageInfo &aMessag
     // We try to convert `aResponse.mMessage` to a `ProxyQuery` by
     // appending `ProxyQueryInfo` to it.
 
-    info.mType        = aResponse.mType;
+    info.mQuestions   = aResponse.mQuestions;
     info.mMessageInfo = aMessageInfo;
     info.mExpireTime  = TimerMilli::GetNow() + kQueryTimeout;
     info.mOffsets     = aResponse.mOffsets;
@@ -1042,6 +1270,14 @@ bool Server::QueryNameMatches(const Message &aQuery, const char *aName)
     return (Name::CompareName(aQuery, offset, aName) == kErrorNone);
 }
 
+bool Server::QueryNameIsForDomain(const Message &aQuery, const char *aDomainName)
+{
+    Name::Buffer name;
+
+    ReadQueryName(aQuery, name);
+    return Name::IsSubDomainOf(name, aDomainName);
+}
+
 void Server::ReadQueryInstanceName(const ProxyQuery &aQuery, const ProxyQueryInfo &aInfo, Name::Buffer &aName)
 {
     uint16_t offset = aInfo.mOffsets.mInstanceName;
@@ -1111,11 +1347,23 @@ void Server::ConstructFullName(const char *aLabels, Name::Buffer &aFullName)
     fullName.Append("%s.%s", aLabels, kDefaultDomainName);
 }
 
-void Server::ConstructFullInstanceName(const char *aInstanceLabel, const char *aServiceType, Name::Buffer &aFullName)
+void Server::ConstructFullName(const char *aFirstLabel, const char *aNextLabels, Name::Buffer &aFullName)
 {
     StringWriter fullName(aFullName, sizeof(aFullName));
 
-    fullName.Append("%s.%s.%s", aInstanceLabel, aServiceType, kDefaultDomainName);
+    fullName.Append("%s.", aFirstLabel);
+
+    if (aNextLabels != nullptr)
+    {
+        fullName.Append("%s.", aNextLabels);
+    }
+
+    fullName.Append("%s", kDefaultDomainName);
+}
+
+void Server::ConstructFullInstanceName(const char *aInstanceLabel, const char *aServiceType, Name::Buffer &aFullName)
+{
+    ConstructFullName(aInstanceLabel, aServiceType, aFullName);
 }
 
 void Server::ConstructFullServiceSubTypeName(const char   *aServiceType,
@@ -1162,19 +1410,15 @@ void Server::Response::InitFrom(ProxyQuery &aQuery, const ProxyQueryInfo &aInfo)
 {
     mMessage.Reset(&aQuery);
     IgnoreError(mMessage->Read(0, mHeader));
-    mType    = aInfo.mType;
-    mOffsets = aInfo.mOffsets;
+    mQuestions = aInfo.mQuestions;
+    mOffsets   = aInfo.mOffsets;
 }
 
 void Server::Response::Answer(const ServiceInstanceInfo &aInstanceInfo, const Ip6::MessageInfo &aMessageInfo)
 {
-    static const Section kSections[] = {kAnswerSection, kAdditionalDataSection};
-
-    Error   error      = kErrorNone;
-    Section srvSection = ((mType == kSrvQuery) || (mType == kSrvTxtQuery)) ? kAnswerSection : kAdditionalDataSection;
-    Section txtSection = ((mType == kTxtQuery) || (mType == kSrvTxtQuery)) ? kAnswerSection : kAdditionalDataSection;
+    Error error = kErrorNone;
 
-    if (mType == kPtrQuery)
+    if (mQuestions.IsFor(kRrTypePtr))
     {
         Name::LabelBuffer instanceLabel;
 
@@ -1183,27 +1427,7 @@ void Server::Response::Answer(const ServiceInstanceInfo &aInstanceInfo, const Ip
         SuccessOrExit(error = AppendPtrRecord(instanceLabel, aInstanceInfo.mTtl));
     }
 
-    for (Section section : kSections)
-    {
-        mSection = section;
-
-        if (mSection == kAdditionalDataSection)
-        {
-            VerifyOrExit(!(Get<Server>().mTestMode & kTestModeEmptyAdditionalSection));
-        }
-
-        if (srvSection == mSection)
-        {
-            SuccessOrExit(error = AppendSrvRecord(aInstanceInfo));
-        }
-
-        if (txtSection == mSection)
-        {
-            SuccessOrExit(error = AppendTxtRecord(aInstanceInfo));
-        }
-    }
-
-    error = AppendHostAddresses(aInstanceInfo);
+    error = AppendServiceRecords(aInstanceInfo);
 
 exit:
     if (error != kErrorNone)
@@ -1216,10 +1440,9 @@ exit:
 
 void Server::Response::Answer(const HostInfo &aHostInfo, const Ip6::MessageInfo &aMessageInfo)
 {
-    // Caller already ensures that `mType` is either `kAaaaQuery` or
-    // `kAQuery`.
+    // Caller already ensures that question is either for AAAA or A record.
 
-    AddrType addrType = (mType == kAaaaQuery) ? kIp6AddrType : kIp4AddrType;
+    AddrType addrType = mQuestions.IsFor(kRrTypeAaaa) ? kIp6AddrType : kIp4AddrType;
 
     mSection = kAnswerSection;
 
@@ -1255,21 +1478,13 @@ void Server::HandleDiscoveredServiceInstance(const char *aServiceFullName, const
 
         info.ReadFrom(query);
 
-        switch (info.mType)
+        if (info.mQuestions.IsFor(kRrTypePtr))
         {
-        case kPtrQuery:
             canAnswer = QueryNameMatches(query, aServiceFullName);
-            break;
-
-        case kSrvQuery:
-        case kTxtQuery:
-        case kSrvTxtQuery:
+        }
+        else if (info.mQuestions.IsFor(kRrTypeSrv) || info.mQuestions.IsFor(kRrTypeTxt))
+        {
             canAnswer = QueryNameMatches(query, aInstanceInfo.mFullName);
-            break;
-
-        case kAaaaQuery:
-        case kAQuery:
-            break;
         }
 
         if (canAnswer)
@@ -1292,22 +1507,17 @@ void Server::HandleDiscoveredHost(const char *aHostFullName, const HostInfo &aHo
 
         info.ReadFrom(query);
 
-        switch (info.mType)
+        if (!info.mQuestions.IsFor(kRrTypeAaaa) && !info.mQuestions.IsFor(kRrTypeA))
         {
-        case kAaaaQuery:
-        case kAQuery:
-            if (QueryNameMatches(query, aHostFullName))
-            {
-                Response response(GetInstance());
-
-                RemoveQueryAndPrepareResponse(query, info, response);
-                response.Answer(aHostInfo, info.mMessageInfo);
-            }
+            continue;
+        }
 
-            break;
+        if (QueryNameMatches(query, aHostFullName))
+        {
+            Response response(GetInstance());
 
-        default:
-            break;
+            RemoveQueryAndPrepareResponse(query, info, response);
+            response.Answer(aHostInfo, info.mMessageInfo);
         }
     }
 }
@@ -1328,23 +1538,15 @@ Server::DnsQueryType Server::GetQueryTypeAndName(const otDnssdQuery *aQuery, Dns
     ReadQueryName(*query, aName);
     info.ReadFrom(*query);
 
-    type = kDnsQueryBrowse;
+    type = kDnsQueryResolveHost;
 
-    switch (info.mType)
+    if (info.mQuestions.IsFor(kRrTypePtr))
+    {
+        type = kDnsQueryBrowse;
+    }
+    else if (info.mQuestions.IsFor(kRrTypeSrv) || info.mQuestions.IsFor(kRrTypeTxt))
     {
-    case kPtrQuery:
-        break;
-
-    case kSrvQuery:
-    case kTxtQuery:
-    case kSrvTxtQuery:
         type = kDnsQueryResolve;
-        break;
-
-    case kAaaaQuery:
-    case kAQuery:
-        type = kDnsQueryResolveHost;
-        break;
     }
 
     return type;
@@ -1505,31 +1707,41 @@ exit:
 
 void Server::DiscoveryProxy::Resolve(ProxyQuery &aQuery, ProxyQueryInfo &aInfo)
 {
-    ProxyAction action = kNoAction;
+    // Determine which proxy action to start with based on the query's
+    // question record type(s). Note that the order in which the record
+    // types are checked is important. Particularly if the query
+    // contains questions for both SRV and TXT records, we want to
+    // start with the `kResolvingSrv` action first.
 
-    switch (aInfo.mType)
+    struct ActionEntry
     {
-    case kPtrQuery:
-        action = kBrowsing;
-        break;
+        uint16_t    mRrType;
+        ProxyAction mAction;
+    };
 
-    case kSrvQuery:
-    case kSrvTxtQuery:
-        action = kResolvingSrv;
-        break;
+    static const ActionEntry kActionTable[] = {
+        {kRrTypePtr, kBrowsing},             // PTR  -> Browser
+        {kRrTypeSrv, kResolvingSrv},         // SRV  -> SrvResolver
+        {kRrTypeTxt, kResolvingTxt},         // TXT  -> TxtResolver
+        {kRrTypeAaaa, kResolvingIp6Address}, // AAAA -> Ip6AddressResolver
+        {kRrTypeA, kResolvingIp4Address},    // A    -> Ip4AddressResolver
+                                             // Misc -> RecordQuerier
+    };
 
-    case kTxtQuery:
-        action = kResolvingTxt;
-        break;
+    ProxyAction action;
 
-    case kAaaaQuery:
-        action = kResolvingIp6Address;
-        break;
-    case kAQuery:
-        action = kResolvingIp4Address;
-        break;
+    for (const ActionEntry &entry : kActionTable)
+    {
+        if (aInfo.mQuestions.IsFor(entry.mRrType))
+        {
+            action = entry.mAction;
+            ExitNow();
+        }
     }
 
+    action = kQueryingRecord;
+
+exit:
     Perform(action, aQuery, aInfo);
 }
 
@@ -1537,6 +1749,7 @@ void Server::DiscoveryProxy::Perform(ProxyAction aAction, ProxyQuery &aQuery, Pr
 {
     bool         shouldStart;
     Name::Buffer name;
+    uint16_t     querierRrType;
 
     VerifyOrExit(aAction != kNoAction);
 
@@ -1552,7 +1765,9 @@ void Server::DiscoveryProxy::Perform(ProxyAction aAction, ProxyQuery &aQuery, Pr
 
     ReadNameFor(aAction, aQuery, aInfo, name);
 
-    shouldStart = !HasActive(aAction, name);
+    querierRrType = (aAction == kQueryingRecord) ? aInfo.mQuestions.mFirstRrType : 0;
+
+    shouldStart = !HasActive(aAction, name, querierRrType);
 
     aInfo.mAction = aAction;
     aInfo.UpdateIn(aQuery);
@@ -1576,6 +1791,7 @@ void Server::DiscoveryProxy::ReadNameFor(ProxyAction     aAction,
     case kNoAction:
         break;
     case kBrowsing:
+    case kQueryingRecord:
         ReadQueryName(aQuery, aName);
         break;
     case kResolvingSrv:
@@ -1597,6 +1813,7 @@ void Server::DiscoveryProxy::CancelAction(ProxyQuery &aQuery, ProxyQueryInfo &aI
 
     ProxyAction  action = aInfo.mAction;
     Name::Buffer name;
+    uint16_t     querierRrType;
 
     VerifyOrExit(mIsRunning);
     VerifyOrExit(action != kNoAction);
@@ -1604,14 +1821,15 @@ void Server::DiscoveryProxy::CancelAction(ProxyQuery &aQuery, ProxyQueryInfo &aI
     // We first update the `aInfo` on `aQuery` before calling
     // `HasActive()`. This ensures that the current query is not
     // taken into account when we try to determine if any query
-    // is waiting for same `aAction` browser/resolver.
+    // is waiting for same `action` browser/resolver.
 
     ReadNameFor(action, aQuery, aInfo, name);
+    querierRrType = (action == kQueryingRecord) ? aInfo.mQuestions.mFirstRrType : 0;
 
     aInfo.mAction = kNoAction;
     aInfo.UpdateIn(aQuery);
 
-    VerifyOrExit(!HasActive(action, name));
+    VerifyOrExit(!HasActive(action, name, querierRrType));
     UpdateProxy(kStop, action, aQuery, aInfo, name);
 
 exit:
@@ -1646,6 +1864,9 @@ void Server::DiscoveryProxy::UpdateProxy(Command               aCommand,
     case kResolvingIp4Address:
         StartOrStopIp4Resolver(aCommand, aName);
         break;
+    case kQueryingRecord:
+        StartOrStopRecordQuerier(aCommand, aQuery, aInfo);
+        break;
     }
 }
 
@@ -1807,21 +2028,74 @@ void Server::DiscoveryProxy::StartOrStopIp4Resolver(Command aCommand, Name::Buff
     }
 }
 
+void Server::DiscoveryProxy::StartOrStopRecordQuerier(Command               aCommand,
+                                                      const ProxyQuery     &aQuery,
+                                                      const ProxyQueryInfo &aInfo)
+{
+    // Start or stop a record querier.
+
+    Dnssd::RecordQuerier querier;
+    Name::LabelBuffer    firstLabel;
+    Name::Buffer         nextLabels;
+    uint16_t             offset      = sizeof(Header);
+    uint8_t              labelLength = sizeof(firstLabel);
+
+    IgnoreError(Dns::Name::ReadLabel(aQuery, offset, firstLabel, labelLength));
+    IgnoreError(Dns::Name::ReadName(aQuery, offset, nextLabels));
+
+    querier.mFirstLabel   = firstLabel;
+    querier.mNextLabels   = (StripDomainName(nextLabels) == kErrorNone) ? nextLabels : nullptr;
+    querier.mRecordType   = aInfo.mQuestions.mFirstRrType;
+    querier.mInfraIfIndex = Get<BorderRouter::InfraIf>().GetIfIndex();
+    querier.mCallback     = HandleRecordResult;
+
+    switch (aCommand)
+    {
+    case kStart:
+        Get<Dnssd>().StartRecordQuerier(querier);
+        break;
+
+    case kStop:
+        Get<Dnssd>().StopRecordQuerier(querier);
+        break;
+    }
+}
+
 bool Server::DiscoveryProxy::QueryMatches(const ProxyQuery     &aQuery,
                                           const ProxyQueryInfo &aInfo,
                                           ProxyAction           aAction,
-                                          const Name::Buffer   &aName) const
+                                          const Name::Buffer   &aName,
+                                          uint16_t              aQuerierRrType,
+                                          RrTypeMatchMode       aRrTypeMatchMode) const
 {
     // Check whether `aQuery` is performing `aAction` and
-    // its name matches `aName`.
+    // its name matches `aName`. The `aQuerierRrType` and
+    // `aRrTypeMatchMode` are only used when the action is
+    // `kQueryingRecord` to indicate queried record type and
+    // how to determine a match.
 
     bool matches = false;
 
     VerifyOrExit(aInfo.mAction == aAction);
 
+    if (aAction == kQueryingRecord)
+    {
+        switch (aRrTypeMatchMode)
+        {
+        case kRequireExactMatch:
+            VerifyOrExit(aInfo.mQuestions.IsFor(aQuerierRrType));
+            break;
+
+        case kPermitAnyOrExactMatch:
+            VerifyOrExit(aInfo.mQuestions.IsFor(aQuerierRrType) || aInfo.mQuestions.IsFor(kRrTypeAny));
+            break;
+        }
+    }
+
     switch (aAction)
     {
     case kBrowsing:
+    case kQueryingRecord:
         VerifyOrExit(QueryNameMatches(aQuery, aName));
         break;
     case kResolvingSrv:
@@ -1842,10 +2116,12 @@ exit:
     return matches;
 }
 
-bool Server::DiscoveryProxy::HasActive(ProxyAction aAction, const Name::Buffer &aName) const
+bool Server::DiscoveryProxy::HasActive(ProxyAction aAction, const Name::Buffer &aName, uint16_t aQuerierRrType) const
 {
-    // Determine whether or not we have an active browser/resolver
-    // corresponding to `aAction` for `aName`.
+    // Determine whether or not we have an active browser, resolver, or record
+    // querier corresponding to `aAction` for `aName`. The `aQuerierRrType`
+    // is only used when the action is `kQueryingRecord` to indicate the
+    // `RecordQuerier` record type.
 
     bool has = false;
 
@@ -1855,7 +2131,7 @@ bool Server::DiscoveryProxy::HasActive(ProxyAction aAction, const Name::Buffer &
 
         info.ReadFrom(query);
 
-        if (QueryMatches(query, info, aAction, aName))
+        if (QueryMatches(query, info, aAction, aName, aQuerierRrType, kRequireExactMatch))
         {
             has = true;
             break;
@@ -2011,6 +2287,26 @@ exit:
     return;
 }
 
+void Server::DiscoveryProxy::HandleRecordResult(otInstance *aInstance, const otPlatDnssdRecordResult *aResult)
+{
+    AsCoreType(aInstance).Get<Server>().mDiscoveryProxy.HandleRecordResult(*aResult);
+}
+
+void Server::DiscoveryProxy::HandleRecordResult(const Dnssd::RecordResult &aResult)
+{
+    Name::Buffer name;
+
+    VerifyOrExit(mIsRunning);
+    VerifyOrExit(aResult.mTtl != 0);
+    VerifyOrExit(aResult.mInfraIfIndex == Get<BorderRouter::InfraIf>().GetIfIndex());
+
+    ConstructFullName(aResult.mFirstLabel, aResult.mNextLabels, name);
+    HandleResult(kQueryingRecord, name, &Response::AppendGenericRecord, ProxyResult(aResult));
+
+exit:
+    return;
+}
+
 void Server::DiscoveryProxy::HandleResult(ProxyAction         aAction,
                                           const Name::Buffer &aName,
                                           ResponseAppender    aAppender,
@@ -2027,6 +2323,9 @@ void Server::DiscoveryProxy::HandleResult(ProxyAction         aAction,
     ProxyQueryList nextActionQueries;
     ProxyQueryInfo info;
     ProxyAction    nextAction;
+    uint16_t       querierRrType;
+
+    querierRrType = (aAction == kQueryingRecord) ? aResult.mRecordResult->mRecordType : 0;
 
     for (ProxyQuery &query : Get<Server>().mProxyQueries)
     {
@@ -2035,7 +2334,7 @@ void Server::DiscoveryProxy::HandleResult(ProxyAction         aAction,
 
         info.ReadFrom(query);
 
-        if (!QueryMatches(query, info, aAction, aName))
+        if (!QueryMatches(query, info, aAction, aName, querierRrType, kPermitAnyOrExactMatch))
         {
             continue;
         }
@@ -2050,21 +2349,26 @@ void Server::DiscoveryProxy::HandleResult(ProxyAction         aAction,
             nextAction = kResolvingSrv;
             break;
         case kResolvingSrv:
-            nextAction = (info.mType == kSrvQuery) ? kResolvingIp6Address : kResolvingTxt;
+            nextAction = (info.mQuestions.IsFor(kRrTypeSrv) && !info.mQuestions.IsFor(kRrTypeTxt))
+                             ? kResolvingIp6Address
+                             : kResolvingTxt;
             break;
         case kResolvingTxt:
-            nextAction = (info.mType == kTxtQuery) ? kNoAction : kResolvingIp6Address;
+            nextAction = (info.mQuestions.IsFor(kRrTypeTxt) && !info.mQuestions.IsFor(kRrTypeSrv))
+                             ? kNoAction
+                             : kResolvingIp6Address;
             break;
         case kNoAction:
         case kResolvingIp6Address:
         case kResolvingIp4Address:
+        case kQueryingRecord:
             break;
         }
 
         shouldFinalize = (nextAction == kNoAction);
 
         if ((Get<Server>().mTestMode & kTestModeEmptyAdditionalSection) &&
-            IsActionForAdditionalSection(nextAction, info.mType))
+            IsActionForAdditionalSection(nextAction, info.mQuestions))
         {
             shouldFinalize = true;
         }
@@ -2135,33 +2439,35 @@ void Server::DiscoveryProxy::HandleResult(ProxyAction         aAction,
     }
 }
 
-bool Server::DiscoveryProxy::IsActionForAdditionalSection(ProxyAction aAction, QueryType aQueryType)
+bool Server::DiscoveryProxy::IsActionForAdditionalSection(ProxyAction aAction, const Questions &aQuestions)
 {
-    bool isForAddnlSection = false;
+    bool     isForAddnlSection = false;
+    uint16_t rrType            = 0;
 
     switch (aAction)
     {
     case kResolvingSrv:
-        VerifyOrExit((aQueryType == kSrvQuery) || (aQueryType == kSrvTxtQuery));
+        rrType = kRrTypeSrv;
         break;
     case kResolvingTxt:
-        VerifyOrExit((aQueryType == kTxtQuery) || (aQueryType == kSrvTxtQuery));
+        rrType = kRrTypeTxt;
         break;
 
     case kResolvingIp6Address:
-        VerifyOrExit(aQueryType == kAaaaQuery);
+        rrType = kRrTypeAaaa;
         break;
 
     case kResolvingIp4Address:
-        VerifyOrExit(aQueryType == kAQuery);
+        rrType = kRrTypeA;
         break;
 
     case kNoAction:
     case kBrowsing:
+    case kQueryingRecord:
         ExitNow();
     }
 
-    isForAddnlSection = true;
+    isForAddnlSection = aQuestions.SectionFor(rrType) == kAdditionalDataSection;
 
 exit:
     return isForAddnlSection;
@@ -2181,7 +2487,7 @@ Error Server::Response::AppendSrvRecord(const ProxyResult &aResult)
     const Dnssd::SrvResult *srvResult = aResult.mSrvResult;
     Name::Buffer            fullHostName;
 
-    mSection = ((mType == kSrvQuery) || (mType == kSrvTxtQuery)) ? kAnswerSection : kAdditionalDataSection;
+    mSection = mQuestions.SectionFor(kRrTypeSrv);
 
     ConstructFullName(srvResult->mHostName, fullHostName);
 
@@ -2192,7 +2498,7 @@ Error Server::Response::AppendTxtRecord(const ProxyResult &aResult)
 {
     const Dnssd::TxtResult *txtResult = aResult.mTxtResult;
 
-    mSection = ((mType == kTxtQuery) || (mType == kSrvTxtQuery)) ? kAnswerSection : kAdditionalDataSection;
+    mSection = mQuestions.SectionFor(kRrTypeTxt);
 
     return AppendTxtRecord(txtResult->mTxtData, txtResult->mTxtDataLength, txtResult->mTtl);
 }
@@ -2202,7 +2508,7 @@ Error Server::Response::AppendHostIp6Addresses(const ProxyResult &aResult)
     Error                       error      = kErrorNone;
     const Dnssd::AddressResult *addrResult = aResult.mAddressResult;
 
-    mSection = (mType == kAaaaQuery) ? kAnswerSection : kAdditionalDataSection;
+    mSection = mQuestions.SectionFor(kRrTypeAaaa);
 
     for (uint16_t index = 0; index < addrResult->mAddressesLength; index++)
     {
@@ -2231,7 +2537,7 @@ Error Server::Response::AppendHostIp4Addresses(const ProxyResult &aResult)
     Error                       error      = kErrorNone;
     const Dnssd::AddressResult *addrResult = aResult.mAddressResult;
 
-    mSection = (mType == kAQuery) ? kAnswerSection : kAdditionalDataSection;
+    mSection = mQuestions.SectionFor(kRrTypeA);
 
     for (uint16_t index = 0; index < addrResult->mAddressesLength; index++)
     {
@@ -2250,6 +2556,18 @@ exit:
     return error;
 }
 
+Error Server::Response::AppendGenericRecord(const ProxyResult &aResult)
+{
+    const Dnssd::RecordResult *result = aResult.mRecordResult;
+    RecordData                 data;
+
+    mSection = kAnswerSection;
+
+    data.Init(result->mRecordData, result->mRecordDataLength);
+
+    return AppendGenericRecord(result->mRecordType, data, result->mTtl);
+}
+
 bool Server::IsProxyAddressValid(const Ip6::Address &aAddress)
 {
     return !aAddress.IsLinkLocalUnicast() && !aAddress.IsMulticast() && !aAddress.IsUnspecified() &&
@@ -2263,6 +2581,14 @@ bool Server::IsProxyAddressValid(const Ip6::Address &aAddress)
 } // namespace ot
 
 #if OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE && OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_MOCK_PLAT_APIS_ENABLE
+
+bool otPlatDnsIsUpstreamQueryAvailable(otInstance *aInstance)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+
+    return true;
+}
+
 void otPlatDnsStartUpstreamQuery(otInstance *aInstance, otPlatDnsUpstreamQuery *aTxn, const otMessage *aQuery)
 {
     OT_UNUSED_VARIABLE(aInstance);
diff --git a/src/core/net/dnssd_server.hpp b/src/core/net/dnssd_server.hpp
index d5e2daad2..c6539cab2 100644
--- a/src/core/net/dnssd_server.hpp
+++ b/src/core/net/dnssd_server.hpp
@@ -311,24 +311,36 @@ private:
     static constexpr uint32_t kQueryTimeout                 = OPENTHREAD_CONFIG_DNSSD_QUERY_TIMEOUT;
     static constexpr uint16_t kMaxConcurrentUpstreamQueries = 32;
 
+    static constexpr uint16_t kRrTypeA     = ResourceRecord::kTypeA;
+    static constexpr uint16_t kRrTypeNs    = ResourceRecord::kTypeNs;
+    static constexpr uint16_t kRrTypeSoa   = ResourceRecord::kTypeSoa;
+    static constexpr uint16_t kRrTypeCname = ResourceRecord::kTypeCname;
+    static constexpr uint16_t kRrTypePtr   = ResourceRecord::kTypePtr;
+    static constexpr uint16_t kRrTypeTxt   = ResourceRecord::kTypeTxt;
+    static constexpr uint16_t kRrTypeKey   = ResourceRecord::kTypeKey;
+    static constexpr uint16_t kRrTypeAaaa  = ResourceRecord::kTypeAaaa;
+    static constexpr uint16_t kRrTypeSrv   = ResourceRecord::kTypeSrv;
+    static constexpr uint16_t kRrTypeAny   = ResourceRecord::kTypeAny;
+
+    // Recommended values for SOA record (RFC 8766 section 6.1).
+    static constexpr uint32_t kSoaSerial     = 0;
+    static constexpr uint32_t kSoaRefresh    = 7200;
+    static constexpr uint32_t kSoaRetry      = 3600;
+    static constexpr uint32_t kSoaExpire     = 86400;
+    static constexpr uint32_t kSoaMinimum    = 10;
+    static constexpr uint32_t kSoaTtl        = 7200;
+    static constexpr uint32_t kNsTtl         = 7200;
+    static constexpr uint32_t kServerAaaaTtl = 3600;
+
     typedef Header::Response ResponseCode;
 
     typedef Message      ProxyQuery;
     typedef MessageQueue ProxyQueryList;
 
-    enum QueryType : uint8_t
-    {
-        kPtrQuery,
-        kSrvQuery,
-        kTxtQuery,
-        kSrvTxtQuery,
-        kAaaaQuery,
-        kAQuery,
-    };
-
     enum Section : uint8_t
     {
         kAnswerSection,
+        kAuthoritySection,
         kAdditionalDataSection,
     };
 
@@ -346,10 +358,24 @@ private:
         kResolvingSrv,
         kResolvingTxt,
         kResolvingIp6Address,
-        kResolvingIp4Address
+        kResolvingIp4Address,
+        kQueryingRecord,
     };
 #endif
 
+    typedef Data<kWithUint16Length> RecordData;
+
+    struct Questions
+    {
+        Questions(void) { mFirstRrType = 0, mSecondRrType = 0; }
+
+        bool    IsFor(uint16_t aRrType) const;
+        Section SectionFor(uint16_t aRrType) const;
+
+        uint16_t mFirstRrType;
+        uint16_t mSecondRrType;
+    };
+
     struct Request
     {
         ResponseCode ParseQuestions(uint8_t aTestMode, bool &aShouldRespond);
@@ -357,7 +383,7 @@ private:
         const Message          *mMessage;
         const Ip6::MessageInfo *mMessageInfo;
         Header                  mHeader;
-        QueryType               mType;
+        Questions               mQuestions;
     };
 
     struct ProxyQueryInfo;
@@ -377,26 +403,32 @@ private:
         explicit ProxyResult(const Dnssd::SrvResult &aSrvResult) { mSrvResult = &aSrvResult; }
         explicit ProxyResult(const Dnssd::TxtResult &aTxtResult) { mTxtResult = &aTxtResult; }
         explicit ProxyResult(const Dnssd::AddressResult &aAddressResult) { mAddressResult = &aAddressResult; }
+        explicit ProxyResult(const Dnssd::RecordResult &aRecordResult) { mRecordResult = &aRecordResult; }
 
         const Dnssd::BrowseResult  *mBrowseResult;
         const Dnssd::SrvResult     *mSrvResult;
         const Dnssd::TxtResult     *mTxtResult;
         const Dnssd::AddressResult *mAddressResult;
+        const Dnssd::RecordResult  *mRecordResult;
     };
 #endif
 
     class Response : public InstanceLocator, private NonCopyable
     {
     public:
+        static constexpr uint16_t kQueryNameOffset = sizeof(Header);
+
         explicit Response(Instance &aInstance);
         ResponseCode AddQuestionsFrom(const Request &aRequest);
 
         Error AllocateAndInitFrom(const Request &aRequest);
         void  InitFrom(ProxyQuery &aQuery, const ProxyQueryInfo &aInfo);
         void  SetResponseCode(ResponseCode aResponseCode) { mHeader.SetResponseCode(aResponseCode); }
+        bool  IsEmpty(void) const;
         Error ParseQueryName(void);
         void  ReadQueryName(Name::Buffer &aName) const;
         bool  QueryNameMatches(const char *aName) const;
+        bool  QueryNameIsForDomain(const char *aDomainName) const;
         Error AppendQueryName(void);
         Error AppendPtrRecord(const char *aInstanceLabel, uint32_t aTtl);
         Error AppendSrvRecord(const ServiceInstanceInfo &aInstanceInfo);
@@ -407,12 +439,12 @@ private:
                               uint16_t    aPort);
         Error AppendTxtRecord(const ServiceInstanceInfo &aInstanceInfo);
         Error AppendTxtRecord(const void *aTxtData, uint16_t aTxtLength, uint32_t aTtl);
+        Error AppendGenericRecord(uint16_t aRrType, const RecordData &aData, uint32_t aTtl);
         Error AppendHostAddresses(AddrType aAddrType, const HostInfo &aHostInfo);
         Error AppendHostAddresses(const ServiceInstanceInfo &aInstanceInfo);
         Error AppendHostAddresses(AddrType aAddrType, const Ip6::Address *aAddrs, uint16_t aAddrsLength, uint32_t aTtl);
         Error AppendAaaaRecord(const Ip6::Address &aAddress, uint32_t aTtl);
         Error AppendARecord(const Ip6::Address &aAddress, uint32_t aTtl);
-        void  UpdateRecordLength(ResourceRecord &aRecord, uint16_t aOffset);
         void  IncResourceRecordCount(void);
         void  Send(const Ip6::MessageInfo &aMessageInfo);
         void  Answer(const HostInfo &aHostInfo, const Ip6::MessageInfo &aMessageInfo);
@@ -420,10 +452,15 @@ private:
         Error ExtractServiceInstanceLabel(const char *aInstanceName, Name::LabelBuffer &aLabel);
 #if OPENTHREAD_CONFIG_SRP_SERVER_ENABLE
         Error ResolveBySrp(void);
+        Error ResolveUsingSrpHost(const Srp::Server::Host &aHost);
+        Error ResolveUsingSrpService(const Srp::Server::Service &aService);
         bool  QueryNameMatchesService(const Srp::Server::Service &aService) const;
+        Error AppendPtrRecord(const Srp::Server::Service &aService);
         Error AppendSrvRecord(const Srp::Server::Service &aService);
         Error AppendTxtRecord(const Srp::Server::Service &aService);
+        Error AppendHostAddresses(const Srp::Server::Service &aService);
         Error AppendHostAddresses(const Srp::Server::Host &aHost);
+        Error AppendKeyRecord(const Srp::Server::Host &aHost);
 #endif
 #if OPENTHREAD_CONFIG_DNSSD_DISCOVERY_PROXY_ENABLE
         Error AppendPtrRecord(const ProxyResult &aResult);
@@ -431,23 +468,29 @@ private:
         Error AppendTxtRecord(const ProxyResult &aResult);
         Error AppendHostIp6Addresses(const ProxyResult &aResult);
         Error AppendHostIp4Addresses(const ProxyResult &aResult);
+        Error AppendGenericRecord(const ProxyResult &aResult);
+#endif
+#if OPENTHREAD_CONFIG_SRP_SERVER_ENABLE || OPENTHREAD_CONFIG_DNSSD_DISCOVERY_PROXY_ENABLE
+        Error ResolveSoaOrNsQuery(void);
+        Error AppendSoaRecord(void);
+        Error AppendNsRecord(void);
 #endif
+        template <typename ServiceType> Error AppendServiceRecords(const ServiceType &aService);
 
 #if OT_SHOULD_LOG_AT(OT_LOG_LEVEL_INFO)
-        void               Log(void) const;
-        static const char *QueryTypeToString(QueryType aType);
+        void Log(void) const;
 #endif
 
         OwnedPtr<Message> mMessage;
         Header            mHeader;
-        QueryType         mType;
+        Questions         mQuestions;
         Section           mSection;
         NameOffsets       mOffsets;
     };
 
     struct ProxyQueryInfo : Message::FooterData<ProxyQueryInfo>
     {
-        QueryType        mType;
+        Questions        mQuestions;
         Ip6::MessageInfo mMessageInfo;
         TimeMilli        mExpireTime;
         NameOffsets      mOffsets;
@@ -478,15 +521,23 @@ private:
             kStop,
         };
 
+        enum RrTypeMatchMode : uint8_t
+        {
+            kRequireExactMatch,     // Require record type to match exactly.
+            kPermitAnyOrExactMatch, // Permit ANY record type in addition to exact match.
+        };
+
         typedef Error (Response::*ResponseAppender)(const ProxyResult &aResult);
 
         void Perform(ProxyAction aAction, ProxyQuery &aQuery, ProxyQueryInfo &aInfo);
         void ReadNameFor(ProxyAction aAction, ProxyQuery &aQuery, ProxyQueryInfo &aInfo, Name::Buffer &aName) const;
-        bool HasActive(ProxyAction aAction, const Name::Buffer &aName) const;
+        bool HasActive(ProxyAction aAction, const Name::Buffer &aName, uint16_t aQuerierRrType) const;
         bool QueryMatches(const ProxyQuery     &aQuery,
                           const ProxyQueryInfo &aInfo,
                           ProxyAction           aAction,
-                          const Name::Buffer   &aName) const;
+                          const Name::Buffer   &aName,
+                          uint16_t              aQuerierRrType,
+                          RrTypeMatchMode       aRrTypeMatchMode) const;
         void UpdateProxy(Command               aCommand,
                          ProxyAction           aAction,
                          const ProxyQuery     &aQuery,
@@ -497,24 +548,27 @@ private:
         void StartOrStopTxtResolver(Command aCommand, const ProxyQuery &aQuery, const ProxyQueryInfo &aInfo);
         void StartOrStopIp6Resolver(Command aCommand, Name::Buffer &aHostName);
         void StartOrStopIp4Resolver(Command aCommand, Name::Buffer &aHostName);
+        void StartOrStopRecordQuerier(Command aCommand, const ProxyQuery &aQuery, const ProxyQueryInfo &aInfo);
 
         static void HandleBrowseResult(otInstance *aInstance, const otPlatDnssdBrowseResult *aResult);
         static void HandleSrvResult(otInstance *aInstance, const otPlatDnssdSrvResult *aResult);
         static void HandleTxtResult(otInstance *aInstance, const otPlatDnssdTxtResult *aResult);
         static void HandleIp6AddressResult(otInstance *aInstance, const otPlatDnssdAddressResult *aResult);
         static void HandleIp4AddressResult(otInstance *aInstance, const otPlatDnssdAddressResult *aResult);
+        static void HandleRecordResult(otInstance *aInstance, const otPlatDnssdRecordResult *aResult);
 
         void HandleBrowseResult(const Dnssd::BrowseResult &aResult);
         void HandleSrvResult(const Dnssd::SrvResult &aResult);
         void HandleTxtResult(const Dnssd::TxtResult &aResult);
         void HandleIp6AddressResult(const Dnssd::AddressResult &aResult);
         void HandleIp4AddressResult(const Dnssd::AddressResult &aResult);
+        void HandleRecordResult(const Dnssd::RecordResult &aResult);
         void HandleResult(ProxyAction         aAction,
                           const Name::Buffer &aName,
                           ResponseAppender    aAppender,
                           const ProxyResult  &aResult);
 
-        static bool IsActionForAdditionalSection(ProxyAction aAction, QueryType aQueryType);
+        static bool IsActionForAdditionalSection(ProxyAction aAction, const Questions &aQuestions);
 
         bool mIsRunning;
     };
@@ -529,6 +583,7 @@ private:
 
     static void  ReadQueryName(const Message &aQuery, Name::Buffer &aName);
     static bool  QueryNameMatches(const Message &aQuery, const char *aName);
+    static bool  QueryNameIsForDomain(const Message &aQuery, const char *aDomainName);
     static void  ReadQueryInstanceName(const ProxyQuery &aQuery, const ProxyQueryInfo &aInfo, Name::Buffer &aName);
     static void  ReadQueryInstanceName(const ProxyQuery     &aQuery,
                                        const ProxyQueryInfo &aInfo,
@@ -540,6 +595,7 @@ private:
     static Error StripDomainName(const char *aFullName, Name::Buffer &aLabels);
     static Error StripDomainName(Name::Buffer &aName);
     static void  ConstructFullName(const char *aLabels, Name::Buffer &aFullName);
+    static void  ConstructFullName(const char *aFirstLabel, const char *aNextLabels, Name::Buffer &aFullName);
     static void  ConstructFullInstanceName(const char   *aInstanceLabel,
                                            const char   *aServiceType,
                                            Name::Buffer &aFullName);
@@ -554,12 +610,16 @@ private:
 #endif
 
 #if OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE
-    static bool               ShouldForwardToUpstream(const Request &aRequest);
+    bool                      ShouldForwardToUpstream(const Request &aRequest) const;
     UpstreamQueryTransaction *AllocateUpstreamQueryTransaction(const Ip6::MessageInfo &aMessageInfo);
     void                      ResetUpstreamQueryTransaction(UpstreamQueryTransaction &aTxn, Error aError);
     Error                     ResolveByUpstream(const Request &aRequest);
 #endif
 
+#if OPENTHREAD_CONFIG_SRP_SERVER_ENABLE || OPENTHREAD_CONFIG_DNSSD_DISCOVERY_PROXY_ENABLE
+    void ConstructSoaServerName(void);
+#endif
+
     void HandleTimer(void);
     void ResetTimer(void);
 
@@ -570,9 +630,13 @@ private:
 
     static const char kDefaultDomainName[];
     static const char kSubLabel[];
+    static const char kMdnsDomainName[];
 #if OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE
     static const char *kBlockedDomains[];
 #endif
+#if OPENTHREAD_CONFIG_SRP_SERVER_ENABLE || OPENTHREAD_CONFIG_DNSSD_DISCOVERY_PROXY_ENABLE
+    static const char kSoaRnameLabel[];
+#endif
 
     ServerSocket mSocket;
 
@@ -584,6 +648,10 @@ private:
     DiscoveryProxy mDiscoveryProxy;
 #endif
 
+#if OPENTHREAD_CONFIG_SRP_SERVER_ENABLE || OPENTHREAD_CONFIG_DNSSD_DISCOVERY_PROXY_ENABLE
+    Name::LabelBuffer mSoaServerName;
+#endif
+
 #if OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE
     bool                     mEnableUpstreamQuery;
     UpstreamQueryTransaction mUpstreamQueryTransactions[kMaxConcurrentUpstreamQueries];
diff --git a/src/core/net/ip6.cpp b/src/core/net/ip6.cpp
index 972c4f855..54aa594a6 100644
--- a/src/core/net/ip6.cpp
+++ b/src/core/net/ip6.cpp
@@ -750,7 +750,7 @@ void Ip6::UpdateReassemblyList(void)
     {
         if (now - message.GetTimestamp() >= TimeMilli::SecToMsec(kReassemblyTimeout))
         {
-            LogNote("Reassembly timeout.");
+            LogInfo("Reassembly timeout.");
             SendIcmpError(message, Icmp::Header::kTypeTimeExceeded, Icmp::Header::kCodeFragmReasTimeEx);
 
             mReassemblyList.DequeueAndFree(message);
@@ -1071,83 +1071,124 @@ exit:
     return error;
 }
 
-Error Ip6::HandleDatagram(OwnedPtr<Message> aMessagePtr, bool aIsReassembled)
+void Ip6::DetermineAction(const Message &aMessage,
+                          const Header  &aHeader,
+                          bool          &aForwardThread,
+                          bool          &aForwardHost,
+                          bool          &aReceive) const
 {
-    Error   error;
-    Header  header;
-    bool    receive;
-    bool    forwardThread;
-    bool    forwardHost;
-    uint8_t nextHeader;
-
-    receive       = false;
-    forwardThread = false;
-    forwardHost   = false;
+    // Determine `aForwardThread`, `aForwardHost` and `aReceive`
+    // based on the destination address and message origin.
 
-    SuccessOrExit(error = header.ParseFrom(*aMessagePtr));
-
-    if (!aMessagePtr->IsOriginHostTrusted())
-    {
-        VerifyOrExit(!header.GetSource().IsLoopback() && !header.GetDestination().IsLoopback(), error = kErrorDrop);
-    }
+    uint16_t rloc16;
 
-    // Determine `forwardThread`, `forwardHost` and `receive`
-    // based on the destination address.
+    aForwardThread = false;
+    aForwardHost   = false;
+    aReceive       = false;
 
-    if (header.GetDestination().IsMulticast())
+    if (aHeader.GetDestination().IsMulticast())
     {
         // Destination is multicast
 
-        forwardThread = !aMessagePtr->IsOriginThreadNetif();
+        // Forward multicast message to thread unless we received it
+        // on Thread netif.
+
+        aForwardThread = !aMessage.IsOriginThreadNetif();
 
 #if OPENTHREAD_FTD
-        if (aMessagePtr->IsOriginThreadNetif() && header.GetDestination().IsMulticastLargerThanRealmLocal() &&
-            Get<ChildTable>().HasSleepyChildWithAddress(header.GetDestination()))
+        if (aMessage.IsOriginThreadNetif() && aHeader.GetDestination().IsMulticastLargerThanRealmLocal() &&
+            Get<ChildTable>().HasSleepyChildWithAddress(aHeader.GetDestination()))
         {
-            forwardThread = true;
+            aForwardThread = true;
         }
 #endif
 
         // Always forward multicast packets to host network stack
-        forwardHost = true;
+        aForwardHost = true;
+
+        // If subscribed to the multicast address, receive if it is from the
+        // Thread netif or if multicast loop is allowed.
 
-        if ((aMessagePtr->IsOriginThreadNetif() || aMessagePtr->GetMulticastLoop()) &&
-            Get<ThreadNetif>().IsMulticastSubscribed(header.GetDestination()))
+        if ((aMessage.IsOriginThreadNetif() || aMessage.GetMulticastLoop()) &&
+            Get<ThreadNetif>().IsMulticastSubscribed(aHeader.GetDestination()))
         {
-            receive = true;
+            aReceive = true;
         }
+
+        ExitNow();
     }
-    else
+
+    // Destination is unicast
+
+    if (Get<ThreadNetif>().HasUnicastAddress(aHeader.GetDestination()))
     {
-        // Destination is unicast
+        aReceive = true;
+        ExitNow();
+    }
 
-        if (Get<ThreadNetif>().HasUnicastAddress(header.GetDestination()))
-        {
-            receive = true;
-        }
-        else if (!aMessagePtr->IsOriginThreadNetif() || !header.GetDestination().IsLinkLocalUnicast())
-        {
-            if (header.GetDestination().IsLinkLocalUnicast())
-            {
-                forwardThread = true;
-            }
-            else if (IsOnLink(header.GetDestination()))
-            {
+    if (aHeader.GetDestination().IsLinkLocalUnicast())
+    {
+        // Forward a message with a link-local destination address
+        // to thread, unless it is received on the Thread netif.
+
+        aForwardThread = !aMessage.IsOriginThreadNetif();
+        ExitNow();
+    }
+
+    if (IsOnLink(aHeader.GetDestination()))
+    {
 #if OPENTHREAD_FTD && OPENTHREAD_CONFIG_BACKBONE_ROUTER_DUA_NDPROXYING_ENABLE
-                forwardThread = (!aMessagePtr->IsLoopbackToHostAllowed() ||
-                                 !Get<BackboneRouter::Manager>().ShouldForwardDuaToBackbone(header.GetDestination()));
+        aForwardThread = (!aMessage.IsLoopbackToHostAllowed() ||
+                          !Get<BackboneRouter::Manager>().ShouldForwardDuaToBackbone(aHeader.GetDestination()));
+        aForwardHost   = !aForwardThread;
 #else
-                forwardThread = true;
+        aForwardThread = true;
 #endif
-            }
-            else if (RouteLookup(header.GetSource(), header.GetDestination()) == kErrorNone)
-            {
-                forwardThread = true;
-            }
+        ExitNow();
+    }
 
-            forwardHost = !forwardThread;
-        }
+    if (Get<NetworkData::Leader>().RouteLookup(aHeader.GetSource(), aHeader.GetDestination(), rloc16) != kErrorNone)
+    {
+        // No route in mesh, forward to host (as a last resort).
+        LogInfo("Failed to find valid route for: %s", aHeader.GetDestination().ToString().AsCString());
+        aForwardHost = true;
+        ExitNow();
+    }
+
+    // `RouteLookup()` found a destination within the mesh. If we are
+    // the destination (device is acting as a Border Router), forward
+    // it to the host. Otherwise, forward to Thread.
+
+    if (Get<Mle::Mle>().HasRloc16(rloc16))
+    {
+        aForwardHost = true;
     }
+    else
+    {
+        aForwardThread = true;
+    }
+
+exit:
+    return;
+}
+
+Error Ip6::HandleDatagram(OwnedPtr<Message> aMessagePtr, bool aIsReassembled)
+{
+    Error   error;
+    Header  header;
+    bool    receive;
+    bool    forwardThread;
+    bool    forwardHost;
+    uint8_t nextHeader;
+
+    SuccessOrExit(error = header.ParseFrom(*aMessagePtr));
+
+    if (!aMessagePtr->IsOriginHostTrusted())
+    {
+        VerifyOrExit(!header.GetSource().IsLoopback() && !header.GetDestination().IsLoopback(), error = kErrorDrop);
+    }
+
+    DetermineAction(*aMessagePtr, header, forwardThread, forwardHost, receive);
 
     aMessagePtr->SetOffset(sizeof(header));
 
@@ -1234,7 +1275,7 @@ Error Ip6::HandleDatagram(OwnedPtr<Message> aMessagePtr, bool aIsReassembled)
 
                 if (udpHeader.GetDestinationPort() == Tmf::kUdpPort)
                 {
-                    LogNote("Dropping TMF message from untrusted origin");
+                    LogInfo("Dropping TMF message from untrusted origin");
                     ExitNow(error = kErrorDrop);
                 }
             }
@@ -1376,28 +1417,6 @@ exit:
     return isOnLink;
 }
 
-Error Ip6::RouteLookup(const Address &aSource, const Address &aDestination) const
-{
-    Error    error;
-    uint16_t rloc;
-
-    error = Get<NetworkData::Leader>().RouteLookup(aSource, aDestination, rloc);
-
-    if (error == kErrorNone)
-    {
-        if (rloc == Get<Mle::MleRouter>().GetRloc16())
-        {
-            error = kErrorNoRoute;
-        }
-    }
-    else
-    {
-        LogNote("Failed to find valid route for: %s", aDestination.ToString().AsCString());
-    }
-
-    return error;
-}
-
 #if OPENTHREAD_CONFIG_IP6_BR_COUNTERS_ENABLE
 
 void Ip6::UpdateBorderRoutingCounters(const Header &aHeader, uint16_t aMessageLength, bool aIsInbound)
diff --git a/src/core/net/ip6.hpp b/src/core/net/ip6.hpp
index d06270965..30a9569f8 100644
--- a/src/core/net/ip6.hpp
+++ b/src/core/net/ip6.hpp
@@ -269,11 +269,11 @@ public:
     const Address *SelectSourceAddress(const Address &aDestination) const;
 
     /**
-     * Returns a reference to the send queue.
+     * Retrieves information about the IPv6 send queue.
      *
-     * @returns A reference to the send queue.
+     * @param[out] aQueueInfo     A `PriorityQueue::Info` to populate with info about the send queue.
      */
-    const PriorityQueue &GetSendQueue(void) const { return mSendQueue; }
+    void GetSendQueueInfo(PriorityQueue::Info &aQueueInfo) const { mSendQueue.GetInfo(aQueueInfo); }
 
     /**
      * Converts an IP protocol number to a string.
@@ -293,6 +293,13 @@ public:
      */
     static const char *EcnToString(Ecn aEcn);
 
+    /**
+     * Indicates whether the address is on the thread link or not.
+     *
+     * @returns TRUE if the address is on the thread link, FALSE otherwise.
+     */
+    bool IsOnLink(const Address &aAddress) const;
+
 #if OPENTHREAD_CONFIG_IP6_BR_COUNTERS_ENABLE
 
     typedef otBorderRoutingCounters BrCounters; ///< Border Routing counters.
@@ -349,6 +356,11 @@ private:
 
     void  EnqueueDatagram(Message &aMessage);
     void  HandleSendQueue(void);
+    void  DetermineAction(const Message &aMessage,
+                          const Header  &aHeader,
+                          bool          &aForwardThread,
+                          bool          &aForwardHost,
+                          bool          &aReceive) const;
     Error PassToHost(OwnedPtr<Message> &aMessagePtr,
                      const Header      &aHeader,
                      uint8_t            aIpProto,
@@ -376,8 +388,6 @@ private:
                   OwnedPtr<Message> &aMessagePtr,
                   uint8_t            aIpProto,
                   Message::Ownership aMessageOwnership);
-    bool  IsOnLink(const Address &aAddress) const;
-    Error RouteLookup(const Address &aSource, const Address &aDestination) const;
 #if OPENTHREAD_CONFIG_IP6_BR_COUNTERS_ENABLE
     void UpdateBorderRoutingCounters(const Header &aHeader, uint16_t aMessageLength, bool aIsInbound);
 #endif
diff --git a/src/core/net/ip6_address.cpp b/src/core/net/ip6_address.cpp
index 47ca92ef4..e1c4dfe5c 100644
--- a/src/core/net/ip6_address.cpp
+++ b/src/core/net/ip6_address.cpp
@@ -256,18 +256,6 @@ void InterfaceIdentifier::SetFromExtAddress(const Mac::ExtAddress &aExtAddress)
     addr.CopyTo(mFields.m8);
 }
 
-void InterfaceIdentifier::ConvertToExtAddress(Mac::ExtAddress &aExtAddress) const
-{
-    aExtAddress.Set(mFields.m8);
-    aExtAddress.ToggleLocal();
-}
-
-void InterfaceIdentifier::ConvertToMacAddress(Mac::Address &aMacAddress) const
-{
-    aMacAddress.SetExtended(mFields.m8);
-    aMacAddress.GetExtended().ToggleLocal();
-}
-
 void InterfaceIdentifier::SetToLocator(uint16_t aLocator)
 {
     // Locator IID pattern `0000:00ff:fe00:xxxx`
diff --git a/src/core/net/ip6_address.hpp b/src/core/net/ip6_address.hpp
index 1bc358e7b..16b197ce2 100644
--- a/src/core/net/ip6_address.hpp
+++ b/src/core/net/ip6_address.hpp
@@ -408,20 +408,6 @@ public:
      */
     void SetFromExtAddress(const Mac::ExtAddress &aExtAddress);
 
-    /**
-     * Converts the Interface Identifier to an IEEE 802.15.4 Extended Address.
-     *
-     * @param[out]  aExtAddress  A reference to an Extended Address where the converted address is placed.
-     */
-    void ConvertToExtAddress(Mac::ExtAddress &aExtAddress) const;
-
-    /**
-     * Converts the Interface Identifier to an IEEE 802.15.4 MAC Address.
-     *
-     * @param[out]  aMacAddress  A reference to a MAC Address where the converted address is placed.
-     */
-    void ConvertToMacAddress(Mac::Address &aMacAddress) const;
-
     /**
      * Sets the Interface Identifier to Routing/Anycast Locator pattern `0000:00ff:fe00:xxxx` with a given
      * locator (RLOC16 or ALOC16) value.
diff --git a/src/core/net/ip6_filter.cpp b/src/core/net/ip6_filter.cpp
index ec0b56256..c10835b9d 100644
--- a/src/core/net/ip6_filter.cpp
+++ b/src/core/net/ip6_filter.cpp
@@ -57,7 +57,7 @@ bool Filter::Accept(Message &aMessage) const
     VerifyOrExit(headers.GetDestinationAddress().IsLinkLocalUnicastOrMulticast());
 
     // Allow all link-local IPv6 datagrams when Thread is not enabled
-    if (Get<Mle::MleRouter>().GetRole() == Mle::kRoleDisabled)
+    if (Get<Mle::Mle>().GetRole() == Mle::kRoleDisabled)
     {
         ExitNow(rval = true);
     }
diff --git a/src/core/net/ip6_headers.hpp b/src/core/net/ip6_headers.hpp
index 4114d6e15..0ba242289 100644
--- a/src/core/net/ip6_headers.hpp
+++ b/src/core/net/ip6_headers.hpp
@@ -138,8 +138,7 @@ public:
      */
     uint8_t GetTrafficClass(void) const
     {
-        return static_cast<uint8_t>((BigEndian::HostSwap16(mVerTcFlow.m16[0]) & kTrafficClassMask) >>
-                                    kTrafficClassOffset);
+        return static_cast<uint8_t>(ReadBitsBigEndian<uint16_t, kTrafficClassMask>(mVerTcFlow.m16[0]));
     }
 
     /**
@@ -150,8 +149,7 @@ public:
     void SetTrafficClass(uint8_t aTc)
     {
         mVerTcFlow.m16[0] =
-            BigEndian::HostSwap16((BigEndian::HostSwap16(mVerTcFlow.m16[0]) & ~kTrafficClassMask) |
-                                  ((static_cast<uint16_t>(aTc) << kTrafficClassOffset) & kTrafficClassMask));
+            UpdateBitsBigEndian<uint16_t, kTrafficClassMask>(mVerTcFlow.m16[0], static_cast<uint16_t>(aTc));
     }
 
     /**
@@ -161,7 +159,7 @@ public:
      */
     uint8_t GetDscp(void) const
     {
-        return static_cast<uint8_t>((BigEndian::HostSwap16(mVerTcFlow.m16[0]) & kDscpMask) >> kDscpOffset);
+        return static_cast<uint8_t>(ReadBitsBigEndian<uint16_t, kDscpMask>(mVerTcFlow.m16[0]));
     }
 
     /**
@@ -171,8 +169,7 @@ public:
      */
     void SetDscp(uint8_t aDscp)
     {
-        mVerTcFlow.m16[0] = BigEndian::HostSwap16((BigEndian::HostSwap16(mVerTcFlow.m16[0]) & ~kDscpMask) |
-                                                  ((static_cast<uint16_t>(aDscp) << kDscpOffset) & kDscpMask));
+        mVerTcFlow.m16[0] = UpdateBitsBigEndian<uint16_t, kDscpMask>(mVerTcFlow.m16[0], static_cast<uint16_t>(aDscp));
     }
 
     /**
@@ -180,32 +177,28 @@ public:
      *
      * @returns The ECN value.
      */
-    Ecn GetEcn(void) const { return static_cast<Ecn>((mVerTcFlow.m8[1] & kEcnMask) >> kEcnOffset); }
+    Ecn GetEcn(void) const { return static_cast<Ecn>(ReadBits<uint8_t, kEcnMask>(mVerTcFlow.m8[1])); }
 
     /**
      * Sets the 2-bit Explicit Congestion Notification (ECN) in IPv6 header..
      *
      * @param[in]  aEcn  The ECN value.
      */
-    void SetEcn(Ecn aEcn) { mVerTcFlow.m8[1] = (mVerTcFlow.m8[1] & ~kEcnMask) | ((aEcn << kEcnOffset) & kEcnMask); }
+    void SetEcn(Ecn aEcn) { WriteBits<uint8_t, kEcnMask>(mVerTcFlow.m8[1], aEcn); }
 
     /**
      * Gets the 20-bit Flow field.
      *
      * @returns  The Flow value.
      */
-    uint32_t GetFlow(void) const { return BigEndian::HostSwap32(mVerTcFlow.m32) & kFlowMask; }
+    uint32_t GetFlow(void) const { return ReadBitsBigEndian<uint32_t, kFlowMask>(mVerTcFlow.m32); }
 
     /**
      * Sets the 20-bit Flow field in IPv6 header.
      *
      * @param[in] aFlow  The Flow value.
      */
-    void SetFlow(uint32_t aFlow)
-    {
-        mVerTcFlow.m32 =
-            BigEndian::HostSwap32((BigEndian::HostSwap32(mVerTcFlow.m32) & ~kFlowMask) | (aFlow & kFlowMask));
-    }
+    void SetFlow(uint32_t aFlow) { mVerTcFlow.m32 = UpdateBitsBigEndian<uint32_t, kFlowMask>(mVerTcFlow.m32, aFlow); }
 
     /**
      * Returns the IPv6 Payload Length value.
@@ -582,7 +575,7 @@ public:
      *
      * @returns The Fragment Offset value.
      */
-    uint16_t GetOffset(void) const { return (BigEndian::HostSwap16(mOffsetMore) & kOffsetMask) >> kOffsetOffset; }
+    uint16_t GetOffset(void) const { return ReadBitsBigEndian<uint16_t, kOffsetMask>(mOffsetMore); }
 
     /**
      * Sets the Fragment Offset value.
@@ -592,8 +585,8 @@ public:
     void SetOffset(uint16_t aOffset)
     {
         uint16_t tmp = BigEndian::HostSwap16(mOffsetMore);
-        tmp          = (tmp & ~kOffsetMask) | ((aOffset << kOffsetOffset) & kOffsetMask);
-        mOffsetMore  = BigEndian::HostSwap16(tmp);
+        WriteBits<uint16_t, kOffsetMask>(tmp, aOffset);
+        mOffsetMore = BigEndian::HostSwap16(tmp);
     }
 
     /**
diff --git a/src/core/net/ip6_mpl.hpp b/src/core/net/ip6_mpl.hpp
index 8f88564dc..38d930a6d 100644
--- a/src/core/net/ip6_mpl.hpp
+++ b/src/core/net/ip6_mpl.hpp
@@ -189,11 +189,11 @@ public:
 
 #if OPENTHREAD_FTD
     /**
-     * Returns a reference to the buffered message set.
+     * Retrieves information about the message queue containing buffered message set.
      *
-     * @returns A reference to the buffered message set.
+     * @param[out] aQueueInfo    A `MessageQueue::Info` to populate with info about the queue.
      */
-    const MessageQueue &GetBufferedMessageSet(void) const { return mBufferedMessageSet; }
+    void GetBufferedMessageSetInfo(MessageQueue::Info &aQueueInfo) { mBufferedMessageSet.GetInfo(aQueueInfo); }
 #endif
 
 private:
diff --git a/src/core/net/mdns.cpp b/src/core/net/mdns.cpp
index 977513567..c285e72f6 100644
--- a/src/core/net/mdns.cpp
+++ b/src/core/net/mdns.cpp
@@ -55,6 +55,19 @@ extern "C" void otPlatMdnsHandleReceive(otInstance                  *aInstance,
     AsCoreType(aInstance).Get<Core>().HandleMessage(AsCoreType(aMessage), aIsUnicast, AsCoreType(aAddress));
 }
 
+extern "C" void otPlatMdnsHandleHostAddressEvent(otInstance         *aInstance,
+                                                 const otIp6Address *aAddress,
+                                                 bool                aAdded,
+                                                 uint32_t            aInfraIfIndex)
+{
+    AsCoreType(aInstance).Get<Core>().HandleHostAddressEvent(AsCoreType(aAddress), aAdded, aInfraIfIndex);
+}
+
+extern "C" void otPlatMdnsHandleHostAddressRemoveAll(otInstance *aInstance, uint32_t aInfraIfIndex)
+{
+    AsCoreType(aInstance).Get<Core>().HandleHostAddressRemoveAll(aInfraIfIndex);
+}
+
 //----------------------------------------------------------------------------------------------------------------------
 // Core
 
@@ -70,6 +83,7 @@ Core::Core(Instance &aInstance)
     , mIsQuestionUnicastAllowed(kDefaultQuAllowed)
     , mMaxMessageSize(kMaxMessageSize)
     , mInfraIfIndex(0)
+    , mLocalHost(aInstance)
     , mMultiPacketRxMessages(aInstance)
     , mNextProbeTxTime(TimerMilli::GetNow() - 1)
     , mEntryTimer(aInstance)
@@ -82,6 +96,19 @@ Core::Core(Instance &aInstance)
 {
 }
 
+void Core::AfterInstanceInit(void)
+{
+    // This is called immediately after the OpenThread `Instance` is
+    // initialized (i.e., after all constructors are called and saved
+    // information from `Settings` is restored). This call triggers
+    // the generation of the local host name, which is derived from
+    // the device's extended MAC address. This ensures that the MAC
+    // address is restored from the non-volatile settings, and the
+    // generated name remains consistent across device reboots.
+
+    mLocalHost.GenerateName();
+}
+
 Error Core::SetEnabled(bool aEnable, uint32_t aInfraIfIndex)
 {
     Error error = kErrorNone;
@@ -99,10 +126,8 @@ Error Core::SetEnabled(bool aEnable, uint32_t aInfraIfIndex)
     else
     {
         LogInfo("Disabling");
-    }
 
-    if (!mIsEnabled)
-    {
+        mLocalHost.ClearAddresses();
         mHostEntries.Clear();
         mServiceEntries.Clear();
         mServiceTypes.Clear();
@@ -115,6 +140,7 @@ Error Core::SetEnabled(bool aEnable, uint32_t aInfraIfIndex)
         mTxtCacheList.Clear();
         mIp6AddrCacheList.Clear();
         mIp4AddrCacheList.Clear();
+        mRecordCacheList.Clear();
         mCacheTimer.Stop();
     }
 
@@ -218,6 +244,11 @@ Error Core::GetNextKey(Iterator &aIterator, Key &aKey, EntryState &aState) const
     return static_cast<EntryIterator &>(aIterator).GetNextKey(aKey, aState);
 }
 
+Error Core::GetNextLocalHostAddress(Iterator &aIterator, LocalHostAddress &aAddress)
+{
+    return static_cast<EntryIterator &>(aIterator).GetNextLocalHostAddress(aAddress);
+}
+
 Error Core::GetNextBrowser(Iterator &aIterator, Browser &aBrowser, CacheInfo &aInfo) const
 {
     return static_cast<EntryIterator &>(aIterator).GetNextBrowser(aBrowser, aInfo);
@@ -243,6 +274,11 @@ Error Core::GetNextIp4AddressResolver(Iterator &aIterator, AddressResolver &aRes
     return static_cast<EntryIterator &>(aIterator).GetNextIp4AddressResolver(aResolver, aInfo);
 }
 
+Error Core::GetNextRecordQuerier(Iterator &aIterator, RecordQuerier &aQuerier, CacheInfo &aInfo) const
+{
+    return static_cast<EntryIterator &>(aIterator).GetNextRecordQuerier(aQuerier, aInfo);
+}
+
 #endif // OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
 
 void Core::InvokeConflictCallback(const char *aName, const char *aServiceType)
@@ -252,6 +288,14 @@ void Core::InvokeConflictCallback(const char *aName, const char *aServiceType)
         mConflictCallback(&GetInstance(), aName, aServiceType);
     }
 }
+
+void Core::HandleHostAddressEvent(const Ip6::Address &aAddress, bool aAdded, uint32_t aInfraIfIndex)
+{
+    mLocalHost.HandleAddressEvent(aAddress, aAdded, aInfraIfIndex);
+}
+
+void Core::HandleHostAddressRemoveAll(uint32_t aInfraIfIndex) { mLocalHost.HandleAddressRemoveAll(aInfraIfIndex); }
+
 void Core::HandleMessage(Message &aMessage, bool aIsUnicast, const AddressInfo &aSenderAddress)
 {
     OwnedPtr<Message>   messagePtr(&aMessage);
@@ -424,17 +468,6 @@ void Core::UpdateCacheFlushFlagIn(ResourceRecord &aResourceRecord, Section aSect
     }
 }
 
-void Core::UpdateRecordLengthInMessage(ResourceRecord &aRecord, Message &aMessage, uint16_t aOffset)
-{
-    // Determines the records DATA length and updates it in a message.
-    // Should be called immediately after all the fields in the
-    // record are appended to the message. `aOffset` gives the offset
-    // in the message to the start of the record.
-
-    aRecord.SetLength(aMessage.GetLength() - aOffset - sizeof(ResourceRecord));
-    aMessage.Write(aOffset, aRecord);
-}
-
 void Core::UpdateCompressOffset(uint16_t &aOffset, uint16_t aNewOffset)
 {
     if ((aOffset == kUnspecifiedOffset) && (aNewOffset != kUnspecifiedOffset))
@@ -534,6 +567,11 @@ exit:
     return matches;
 }
 
+bool Core::AddressArray::Matches(const AddressArray &aOther) const
+{
+    return Matches(aOther.AsCArray(), aOther.GetLength());
+}
+
 void Core::AddressArray::SetFrom(const Ip6::Address *aAddresses, uint16_t aNumAddresses)
 {
     Free();
@@ -1192,7 +1230,7 @@ bool Core::Entry::ShouldAnswerNsec(TimeMilli aNow) const
     return mMulticastNsecPending && (GetNsecAnswerTime() <= aNow);
 }
 
-void Core::Entry::AnswerNonProbe(const AnswerInfo &aInfo, RecordAndType *aRecords, uint16_t aRecordsLength)
+void Core::Entry::AnswerNonProbe(const AnswerInfo &aInfo, RecordAndTypeArray &aRecordAndTypes)
 {
     // Schedule answers for all matching records in `aRecords` array
     // to a given non-probe question.
@@ -1200,9 +1238,9 @@ void Core::Entry::AnswerNonProbe(const AnswerInfo &aInfo, RecordAndType *aRecord
     bool allEmptyOrZeroTtl = true;
     bool answerNsec        = true;
 
-    for (uint16_t index = 0; index < aRecordsLength; index++)
+    for (RecordAndType &recordAndType : aRecordAndTypes)
     {
-        RecordInfo &record = aRecords[index].mRecord;
+        RecordInfo &record = *recordAndType.mRecord;
 
         if (!record.CanAnswer())
         {
@@ -1212,7 +1250,7 @@ void Core::Entry::AnswerNonProbe(const AnswerInfo &aInfo, RecordAndType *aRecord
 
         allEmptyOrZeroTtl = false;
 
-        if (QuestionMatches(aInfo.mQuestionRrType, aRecords[index].mType))
+        if (QuestionMatches(aInfo.mQuestionRrType, recordAndType.mType))
         {
             answerNsec = false;
             record.ScheduleAnswer(aInfo);
@@ -1229,7 +1267,7 @@ void Core::Entry::AnswerNonProbe(const AnswerInfo &aInfo, RecordAndType *aRecord
     }
 }
 
-void Core::Entry::AnswerProbe(const AnswerInfo &aInfo, RecordAndType *aRecords, uint16_t aRecordsLength)
+void Core::Entry::AnswerProbe(const AnswerInfo &aInfo, RecordAndTypeArray &aRecordAndTypes)
 {
     bool       allEmptyOrZeroTtl = true;
     bool       shouldDelay       = false;
@@ -1240,9 +1278,9 @@ void Core::Entry::AnswerProbe(const AnswerInfo &aInfo, RecordAndType *aRecords,
 
     OT_ASSERT(info.mIsProbe);
 
-    for (uint16_t index = 0; index < aRecordsLength; index++)
+    for (RecordAndType &recordAndType : aRecordAndTypes)
     {
-        RecordInfo &record = aRecords[index].mRecord;
+        RecordInfo &record = *recordAndType.mRecord;
         TimeMilli   lastMulticastTime;
 
         if (!record.CanAnswer())
@@ -1288,9 +1326,9 @@ void Core::Entry::AnswerProbe(const AnswerInfo &aInfo, RecordAndType *aRecords,
         info.mAnswerDelay = 0;
     }
 
-    for (uint16_t index = 0; index < aRecordsLength; index++)
+    for (RecordAndType &recordAndType : aRecordAndTypes)
     {
-        aRecords[index].mRecord.ScheduleAnswer(info);
+        recordAndType.mRecord->ScheduleAnswer(info);
     }
 
 exit:
@@ -1440,7 +1478,7 @@ void Core::Entry::AppendNsecRecordTo(TxMessage       &aTxMessage,
 
     SuccessOrAssert(message.AppendBytes(&bitmap, bitmap.GetSize()));
 
-    UpdateRecordLengthInMessage(nsec, message, offset);
+    ResourceRecord::UpdateRecordLengthInMessage(message, offset);
     aTxMessage.IncrementRecordCount(aSection);
 
     mAppendedNsec = true;
@@ -1463,6 +1501,204 @@ exit:
     return error;
 }
 
+//----------------------------------------------------------------------------------------------------------------------
+// Core::Entry::RecordAndTypeArray
+
+void Core::Entry::RecordAndTypeArray::Add(RecordInfo &aRecord, uint16_t aType)
+{
+    RecordAndType *entry = PushBack();
+
+    OT_ASSERT(entry != nullptr);
+    entry->mRecord = &aRecord;
+    entry->mType   = aType;
+}
+
+//----------------------------------------------------------------------------------------------------------------------
+// Core::LocalHost
+
+Core::LocalHost::LocalHost(Instance &aInstance)
+    : InstanceLocator(aInstance)
+    , mEventTimer(aInstance)
+{
+    GenerateName();
+}
+
+Error Core::LocalHost::SetName(const char *aName)
+{
+    Error error = kErrorNone;
+
+    VerifyOrExit(!Get<Core>().mIsEnabled, error = kErrorInvalidState);
+
+    if (aName == nullptr)
+    {
+        GenerateName();
+    }
+    else
+    {
+        SuccessOrAssert(mName.Set(aName));
+    }
+
+exit:
+    return error;
+}
+
+void Core::LocalHost::GenerateName(void)
+{
+    Name::LabelBuffer name;
+    StringWriter      writer(name, sizeof(name));
+
+    writer.Append("ot%s", Get<Mac::Mac>().GetExtAddress().ToString().AsCString());
+
+    SuccessOrAssert(mName.Set(name));
+}
+
+void Core::LocalHost::ClearAddresses(void)
+{
+    mIp4Addresses.Free();
+    mIp6Addresses.Free();
+    mAddrEvents.Clear();
+    mEventTimer.Stop();
+}
+
+void Core::LocalHost::HandleAddressEvent(const Ip6::Address &aAddress, bool aAdded, uint32_t aInfraIfIndex)
+{
+    AddrEvent *addrEvent;
+
+    VerifyOrExit(Get<Core>().mIsEnabled);
+    VerifyOrExit(aInfraIfIndex == Get<Core>().mInfraIfIndex);
+
+    LogInfo("Host address %s event: %s", aAddress.ToString().AsCString(), aAdded ? "added" : "removed");
+
+    addrEvent = AddrEvent::Allocate(aAddress, aAdded);
+    OT_ASSERT(addrEvent != nullptr);
+
+    // Before we add the new event, we remove any previous events in the
+    // list that match the same address. This way we always track the
+    // latest event for each address. This handles the case where
+    // a "removed" address event is quickly followed by an "added" event
+    // for the same address.
+    //
+    // The events are processed after a short guard delay time
+    // `kGuardTimeToProcessAddrEvents`. This ensures multiple changes
+    // to be grouped and announced together.
+
+    mAddrEvents.RemoveAndFreeAllMatching(aAddress);
+    mAddrEvents.Push(*addrEvent);
+
+    if (!mEventTimer.IsRunning())
+    {
+        mEventTimer.Start(kGuardTimeToProcessAddrEvents);
+    }
+
+exit:
+    return;
+}
+
+void Core::LocalHost::HandleAddressRemoveAll(uint32_t aInfraIfIndex)
+{
+    VerifyOrExit(Get<Core>().mIsEnabled);
+    VerifyOrExit(aInfraIfIndex == Get<Core>().mInfraIfIndex);
+
+    mAddrEvents.Clear();
+    mEventTimer.Stop();
+
+    LogInfo("Host address event: remove all");
+
+    for (const Ip6::Address &address : mIp4Addresses)
+    {
+        HandleAddressEvent(address, /* aAdded */ false, aInfraIfIndex);
+    }
+
+    for (const Ip6::Address &address : mIp6Addresses)
+    {
+        HandleAddressEvent(address, /* aAdded */ false, aInfraIfIndex);
+    }
+
+exit:
+    return;
+}
+
+void Core::LocalHost::HandleEventTimer(void)
+{
+    // Process all saved `AddrEvents` and update IPv4 and IPv6
+    // address lists.
+
+    static const AddrType kAddrTypes[] = {kIp4AddrType, kIp6AddrType};
+
+    VerifyOrExit(Get<Core>().mIsEnabled);
+
+    for (AddrType addrType : kAddrTypes)
+    {
+        AddressArray &addresses = (addrType == kIp4AddrType) ? mIp4Addresses : mIp6Addresses;
+        AddressArray  oldAddresses;
+
+        oldAddresses.TakeFrom(static_cast<AddressArray &&>(addresses));
+        addresses.Clear();
+
+        // First, add existing addresses (from old list) that did not
+        // change (there is no "removed" event).
+
+        for (const Ip6::Address &address : oldAddresses)
+        {
+            const AddrEvent *addrEvent = mAddrEvents.FindMatching(address);
+
+            if ((addrEvent == nullptr) || addrEvent->mAdded)
+            {
+                SuccessOrAssert(addresses.PushBack(address));
+            }
+        }
+
+        // Next, add any new addresses for which we got an "added"
+        // event.
+
+        for (const AddrEvent &addrEvent : mAddrEvents)
+        {
+            if (!addrEvent.Matches(addrType))
+            {
+                continue;
+            }
+
+            if (addrEvent.mAdded && !addresses.Contains(addrEvent.mAddress))
+            {
+                SuccessOrAssert(addresses.PushBack(addrEvent.mAddress));
+            }
+        }
+    }
+
+    IgnoreError(Get<Core>().Register<HostEntry>(*this, /* aRequestId */ 0, /* aCallback */ nullptr));
+
+exit:
+    mAddrEvents.Clear();
+}
+
+//----------------------------------------------------------------------------------------------------------------------
+// Core::LocalHost::AddrEvent
+
+Core::LocalHost::AddrEvent::AddrEvent(const Ip6::Address &aAddress, bool aAdded)
+    : mNext(nullptr)
+    , mAddress(aAddress)
+    , mAdded(aAdded)
+{
+}
+
+bool Core::LocalHost::AddrEvent::Matches(AddrType aType) const
+{
+    bool matches = false;
+    bool isIp4   = mAddress.IsIp4Mapped();
+
+    switch (aType)
+    {
+    case kIp4AddrType:
+        matches = isIp4;
+        break;
+    case kIp6AddrType:
+        matches = !isIp4;
+        break;
+    }
+
+    return matches;
+}
+
 //----------------------------------------------------------------------------------------------------------------------
 // Core::HostEntry
 
@@ -1486,11 +1722,24 @@ bool Core::HostEntry::Matches(const Name &aName) const
 
 bool Core::HostEntry::Matches(const Host &aHost) const { return NameMatch(mName, aHost.mHostName); }
 
+bool Core::HostEntry::Matches(const LocalHost &aLocalHost) const { return NameMatch(mName, aLocalHost.GetName()); }
+
 bool Core::HostEntry::Matches(const Key &aKey) const { return !IsKeyForService(aKey) && NameMatch(mName, aKey.mName); }
 
 bool Core::HostEntry::Matches(const Heap::String &aName) const { return NameMatch(mName, aName); }
 
-bool Core::HostEntry::IsEmpty(void) const { return !mAddrRecord.IsPresent() && !mKeyRecord.IsPresent(); }
+bool Core::HostEntry::IsEmpty(void) const
+{
+    bool isEmpty = false;
+
+    VerifyOrExit(!mKeyRecord.IsPresent() && !mIp6AddrRecord.IsPresent());
+    VerifyOrExit((mIp4AddrRecord == nullptr) || !mIp4AddrRecord->IsPresent());
+
+    isEmpty = true;
+
+exit:
+    return isEmpty;
+}
 
 void Core::HostEntry::Register(const Host &aHost, const Callback &aCallback)
 {
@@ -1519,8 +1768,8 @@ void Core::HostEntry::Register(const Host &aHost, const Callback &aCallback)
         ExitNow();
     }
 
-    mAddrRecord.UpdateTtl(DetermineTtl(aHost.mTtl, kDefaultTtl));
-    mAddrRecord.UpdateProperty(mAddresses, AsCoreTypePtr(aHost.mAddresses), aHost.mAddressesLength);
+    mIp6AddrRecord.UpdateTtl(DetermineTtl(aHost.mTtl, kDefaultTtl));
+    mIp6AddrRecord.UpdateAddresses(aHost);
 
     DetermineNextFireTime();
     ScheduleTimer();
@@ -1529,6 +1778,46 @@ exit:
     return;
 }
 
+void Core::HostEntry::Register(const LocalHost &aLocalHost, const Callback &aCallback)
+{
+    SetCallback(aCallback);
+
+    if (aLocalHost.GetIp6Addresses().IsEmpty())
+    {
+        if (mIp6AddrRecord.IsPresent())
+        {
+            mIp6AddrRecord.UpdateTtl(0);
+        }
+    }
+    else
+    {
+        mIp6AddrRecord.UpdateTtl(kDefaultTtl);
+        mIp6AddrRecord.UpdateAddresses(aLocalHost.GetIp6Addresses());
+    }
+
+    if (aLocalHost.GetIp4Addresses().IsEmpty())
+    {
+        if ((mIp4AddrRecord != nullptr) && mIp4AddrRecord->IsPresent())
+        {
+            mIp4AddrRecord->UpdateTtl(0);
+        }
+    }
+    else
+    {
+        if (mIp4AddrRecord == nullptr)
+        {
+            mIp4AddrRecord.Reset(AddrRecord::Allocate());
+            OT_ASSERT(mIp4AddrRecord != nullptr);
+        }
+
+        mIp4AddrRecord->UpdateTtl(kDefaultTtl);
+        mIp4AddrRecord->UpdateAddresses(aLocalHost.GetIp4Addresses());
+    }
+
+    DetermineNextFireTime();
+    ScheduleTimer();
+}
+
 void Core::HostEntry::Register(const Key &aKey, const Callback &aCallback)
 {
     Entry::Register(aKey, aCallback);
@@ -1541,14 +1830,14 @@ void Core::HostEntry::Unregister(const Host &aHost)
 {
     OT_UNUSED_VARIABLE(aHost);
 
-    VerifyOrExit(mAddrRecord.IsPresent());
+    VerifyOrExit(mIp6AddrRecord.IsPresent());
 
     ClearCallback();
 
     switch (GetState())
     {
     case kRegistered:
-        mAddrRecord.UpdateTtl(0);
+        mIp6AddrRecord.UpdateTtl(0);
         DetermineNextFireTime();
         ScheduleTimer();
         break;
@@ -1579,8 +1868,12 @@ void Core::HostEntry::Unregister(const Key &aKey)
 
 void Core::HostEntry::ClearHost(void)
 {
-    mAddrRecord.Clear();
-    mAddresses.Free();
+    mIp6AddrRecord.Clear();
+
+    if (mIp4AddrRecord != nullptr)
+    {
+        mIp4AddrRecord->Clear();
+    }
 }
 
 void Core::HostEntry::ScheduleToRemoveIfEmpty(void)
@@ -1606,20 +1899,25 @@ exit:
 
 void Core::HostEntry::AnswerQuestion(const AnswerInfo &aInfo)
 {
-    RecordAndType records[] = {
-        {mAddrRecord, ResourceRecord::kTypeAaaa},
-        {mKeyRecord, ResourceRecord::kTypeKey},
-    };
+    RecordAndTypeArray recordAndTypes;
 
     VerifyOrExit(GetState() == kRegistered);
 
+    recordAndTypes.Add(mIp6AddrRecord, ResourceRecord::kTypeAaaa);
+    recordAndTypes.Add(mKeyRecord, ResourceRecord::kTypeKey);
+
+    if (mIp4AddrRecord != nullptr)
+    {
+        recordAndTypes.Add(*mIp4AddrRecord, ResourceRecord::kTypeA);
+    }
+
     if (aInfo.mIsProbe)
     {
-        AnswerProbe(aInfo, records, GetArrayLength(records));
+        AnswerProbe(aInfo, recordAndTypes);
     }
     else
     {
-        AnswerNonProbe(aInfo, records, GetArrayLength(records));
+        AnswerNonProbe(aInfo, recordAndTypes);
     }
 
     DetermineNextFireTime();
@@ -1638,7 +1936,12 @@ void Core::HostEntry::ClearAppendState(void)
 
     Entry::ClearAppendState();
 
-    mAddrRecord.MarkAsNotAppended();
+    mIp6AddrRecord.MarkAsNotAppended();
+
+    if (mIp4AddrRecord != nullptr)
+    {
+        mIp4AddrRecord->MarkAsNotAppended();
+    }
 
     mNameOffset = kUnspecifiedOffset;
 }
@@ -1654,7 +1957,8 @@ void Core::HostEntry::PrepareProbe(TxMessage &aProbe)
         AppendNameTo(aProbe, kQuestionSection);
         AppendQuestionTo(aProbe);
 
-        AppendAddressRecordsTo(aProbe, kAuthoritySection);
+        AppendIp6AddressRecordsTo(aProbe, kAuthoritySection);
+        AppendIp4AddressRecordsTo(aProbe, kAuthoritySection);
         AppendKeyRecordTo(aProbe, kAuthoritySection);
 
         aProbe.CheckSizeLimitToPrepareAgain(prepareAgain);
@@ -1664,7 +1968,13 @@ void Core::HostEntry::PrepareProbe(TxMessage &aProbe)
 
 void Core::HostEntry::StartAnnouncing(void)
 {
-    mAddrRecord.StartAnnouncing();
+    mIp6AddrRecord.StartAnnouncing();
+
+    if (mIp4AddrRecord != nullptr)
+    {
+        mIp4AddrRecord->StartAnnouncing();
+    }
+
     mKeyRecord.StartAnnouncing();
 }
 
@@ -1689,9 +1999,15 @@ void Core::HostEntry::PrepareResponseRecords(EntryContext &aContext)
     bool       appendNsec = false;
     TxMessage &response   = aContext.mResponseMessage;
 
-    if (mAddrRecord.ShouldAppendTo(aContext))
+    if (mIp6AddrRecord.ShouldAppendTo(aContext))
+    {
+        AppendIp6AddressRecordsTo(response, kAnswerSection);
+        appendNsec = true;
+    }
+
+    if ((mIp4AddrRecord != nullptr) && mIp4AddrRecord->ShouldAppendTo(aContext))
     {
-        AppendAddressRecordsTo(response, kAnswerSection);
+        AppendIp4AddressRecordsTo(response, kAnswerSection);
         appendNsec = true;
     }
 
@@ -1712,7 +2028,12 @@ void Core::HostEntry::UpdateRecordsState(const TxMessage &aResponse)
     // Updates state after a response is prepared.
 
     Entry::UpdateRecordsState(aResponse);
-    mAddrRecord.UpdateStateAfterAnswer(aResponse);
+    mIp6AddrRecord.UpdateStateAfterAnswer(aResponse);
+
+    if (mIp4AddrRecord != nullptr)
+    {
+        mIp4AddrRecord->UpdateStateAfterAnswer(aResponse);
+    }
 
     if (IsEmpty())
     {
@@ -1725,7 +2046,12 @@ void Core::HostEntry::DetermineNextFireTime(void)
     VerifyOrExit(GetState() == kRegistered);
 
     Entry::DetermineNextFireTime();
-    mAddrRecord.UpdateFireTimeOn(*this);
+    mIp6AddrRecord.UpdateFireTimeOn(*this);
+
+    if (mIp4AddrRecord != nullptr)
+    {
+        mIp4AddrRecord->UpdateFireTimeOn(*this);
+    }
 
 exit:
     return;
@@ -1736,33 +2062,72 @@ void Core::HostEntry::DetermineNextAggrTxTime(NextFireTime &aNextAggrTxTime) con
     VerifyOrExit(GetState() == kRegistered);
 
     Entry::DetermineNextAggrTxTime(aNextAggrTxTime);
-    mAddrRecord.DetermineNextAggrTxTime(aNextAggrTxTime);
+    mIp6AddrRecord.DetermineNextAggrTxTime(aNextAggrTxTime);
+
+    if (mIp4AddrRecord != nullptr)
+    {
+        mIp4AddrRecord->DetermineNextAggrTxTime(aNextAggrTxTime);
+    }
 
 exit:
     return;
 }
 
-void Core::HostEntry::AppendAddressRecordsTo(TxMessage &aTxMessage, Section aSection)
+void Core::HostEntry::AppendIp6AddressRecordsTo(TxMessage &aTxMessage, Section aSection)
+{
+    AppendAddressRecordsTo(aTxMessage, aSection, mIp6AddrRecord, /* aIp6 */ true);
+}
+
+void Core::HostEntry::AppendIp4AddressRecordsTo(TxMessage &aTxMessage, Section aSection)
+{
+    if (mIp4AddrRecord != nullptr)
+    {
+        AppendAddressRecordsTo(aTxMessage, aSection, *mIp4AddrRecord, /* aIp6 */ false);
+    }
+}
+
+void Core::HostEntry::AppendAddressRecordsTo(TxMessage  &aTxMessage,
+                                             Section     aSection,
+                                             AddrRecord &aAddrRecord,
+                                             bool        aIp6)
 {
     Message *message;
     bool     isLegacyUnicast = (aTxMessage.GetType() == TxMessage::kLegacyUnicastResponse);
 
-    VerifyOrExit(mAddrRecord.CanAppend());
-    mAddrRecord.MarkAsAppended(aTxMessage, aSection);
+    VerifyOrExit(aAddrRecord.CanAppend());
+    aAddrRecord.MarkAsAppended(aTxMessage, aSection);
 
     message = &aTxMessage.SelectMessageFor(aSection);
 
-    for (const Ip6::Address &address : mAddresses)
+    for (const Ip6::Address &address : aAddrRecord.mAddresses)
     {
-        AaaaRecord aaaaRecord;
+        AppendNameTo(aTxMessage, aSection);
+
+        if (aIp6)
+        {
+            AaaaRecord aaaaRecord;
 
-        aaaaRecord.Init();
-        aaaaRecord.SetAddress(address);
-        aaaaRecord.SetTtl(mAddrRecord.GetTtl(isLegacyUnicast));
-        UpdateCacheFlushFlagIn(aaaaRecord, aSection, isLegacyUnicast);
+            aaaaRecord.Init();
+            aaaaRecord.SetAddress(address);
+            aaaaRecord.SetTtl(aAddrRecord.GetTtl(isLegacyUnicast));
+            UpdateCacheFlushFlagIn(aaaaRecord, aSection, isLegacyUnicast);
 
-        AppendNameTo(aTxMessage, aSection);
-        SuccessOrAssert(message->Append(aaaaRecord));
+            SuccessOrAssert(message->Append(aaaaRecord));
+        }
+        else
+        {
+            Ip4::Address ip4Address;
+            ARecord      aRecord;
+
+            SuccessOrAssert(ip4Address.ExtractFromIp4MappedIp6Address(address));
+
+            aRecord.Init();
+            aRecord.SetAddress(ip4Address);
+            aRecord.SetTtl(aAddrRecord.GetTtl(isLegacyUnicast));
+            UpdateCacheFlushFlagIn(aRecord, aSection, isLegacyUnicast);
+
+            SuccessOrAssert(message->Append(aRecord));
+        }
 
         aTxMessage.IncrementRecordCount(aSection);
     }
@@ -1780,11 +2145,16 @@ void Core::HostEntry::AppendNsecRecordTo(TxMessage &aTxMessage, Section aSection
 {
     TypeArray types;
 
-    if (mAddrRecord.IsPresent() && (mAddrRecord.GetTtl() > 0))
+    if (mIp6AddrRecord.IsPresent() && (mIp6AddrRecord.GetTtl() > 0))
     {
         types.Add(ResourceRecord::kTypeAaaa);
     }
 
+    if ((mIp4AddrRecord != nullptr) && mIp4AddrRecord->IsPresent() && (mIp4AddrRecord->GetTtl() > 0))
+    {
+        types.Add(ResourceRecord::kTypeA);
+    }
+
     if (mKeyRecord.IsPresent() && (mKeyRecord.GetTtl() > 0))
     {
         types.Add(ResourceRecord::kTypeKey);
@@ -1814,18 +2184,28 @@ exit:
     return;
 }
 
+void Core::HostEntry::MarkToAppendAddrRecordsInAdditionalData(void)
+{
+    mIp6AddrRecord.MarkToAppendInAdditionalData();
+
+    if (mIp4AddrRecord != nullptr)
+    {
+        mIp4AddrRecord->MarkToAppendInAdditionalData();
+    }
+}
+
 #if OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
 
 Error Core::HostEntry::CopyInfoTo(Host &aHost, EntryState &aState) const
 {
     Error error = kErrorNone;
 
-    VerifyOrExit(mAddrRecord.IsPresent(), error = kErrorNotFound);
+    VerifyOrExit(mIp6AddrRecord.IsPresent(), error = kErrorNotFound);
 
     aHost.mHostName        = mName.AsCString();
-    aHost.mAddresses       = mAddresses.AsCArray();
-    aHost.mAddressesLength = mAddresses.GetLength();
-    aHost.mTtl             = mAddrRecord.GetTtl();
+    aHost.mAddresses       = mIp6AddrRecord.mAddresses.AsCArray();
+    aHost.mAddressesLength = mIp6AddrRecord.mAddresses.GetLength();
+    aHost.mTtl             = mIp6AddrRecord.GetTtl();
     aHost.mInfraIfIndex    = Get<Core>().mInfraIfIndex;
     aState                 = static_cast<EntryState>(GetState());
 
@@ -1848,6 +2228,25 @@ exit:
 
 #endif // OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
 
+//----------------------------------------------------------------------------------------------------------------------
+// Core::HostEntry::AddrRecord
+
+void Core::HostEntry::AddrRecord::Clear(void)
+{
+    RecordInfo::Clear();
+    mAddresses.Free();
+}
+
+void Core::HostEntry::AddrRecord::UpdateAddresses(const Host &aHost)
+{
+    UpdateProperty(mAddresses, AsCoreTypePtr(aHost.mAddresses), aHost.mAddressesLength);
+}
+
+void Core::HostEntry::AddrRecord::UpdateAddresses(const AddressArray &aAddresses)
+{
+    UpdateProperty(mAddresses, aAddresses.AsCArray(), aAddresses.GetLength());
+}
+
 //----------------------------------------------------------------------------------------------------------------------
 // Core::ServiceEntry
 
@@ -1933,7 +2332,8 @@ exit:
 
 void Core::ServiceEntry::Register(const Service &aService, const Callback &aCallback)
 {
-    uint32_t ttl = DetermineTtl(aService.mTtl, kDefaultTtl);
+    const char *hostName;
+    uint32_t    ttl = DetermineTtl(aService.mTtl, kDefaultTtl);
 
     if (GetState() == kRemoving)
     {
@@ -1978,8 +2378,10 @@ void Core::ServiceEntry::Register(const Service &aService, const Callback &aCall
 
     // Register SRV record info.
 
+    hostName = (aService.mHostName != nullptr) ? aService.mHostName : Get<Core>().mLocalHost.GetName();
+
     mSrvRecord.UpdateTtl(ttl);
-    mSrvRecord.UpdateProperty(mHostName, aService.mHostName);
+    mSrvRecord.UpdateProperty(mHostName, hostName);
     mSrvRecord.UpdateProperty(mPriority, aService.mPriority);
     mSrvRecord.UpdateProperty(mWeight, aService.mWeight);
     mSrvRecord.UpdateProperty(mPort, aService.mPort);
@@ -2097,21 +2499,21 @@ exit:
 
 void Core::ServiceEntry::AnswerServiceNameQuestion(const AnswerInfo &aInfo)
 {
-    RecordAndType records[] = {
-        {mSrvRecord, ResourceRecord::kTypeSrv},
-        {mTxtRecord, ResourceRecord::kTypeTxt},
-        {mKeyRecord, ResourceRecord::kTypeKey},
-    };
+    RecordAndTypeArray recordAndTypes;
 
     VerifyOrExit(GetState() == kRegistered);
 
+    recordAndTypes.Add(mSrvRecord, ResourceRecord::kTypeSrv);
+    recordAndTypes.Add(mTxtRecord, ResourceRecord::kTypeTxt);
+    recordAndTypes.Add(mKeyRecord, ResourceRecord::kTypeKey);
+
     if (aInfo.mIsProbe)
     {
-        AnswerProbe(aInfo, records, GetArrayLength(records));
+        AnswerProbe(aInfo, recordAndTypes);
     }
     else
     {
-        AnswerNonProbe(aInfo, records, GetArrayLength(records));
+        AnswerNonProbe(aInfo, recordAndTypes);
     }
 
     DetermineNextFireTime();
@@ -2307,7 +2709,7 @@ void Core::ServiceEntry::PrepareResponseRecords(EntryContext &aContext)
 
         if (hostEntry != nullptr)
         {
-            hostEntry->mAddrRecord.MarkToAppendInAdditionalData();
+            hostEntry->MarkToAppendAddrRecordsInAdditionalData();
         }
     }
 
@@ -2318,7 +2720,7 @@ void Core::ServiceEntry::PrepareResponseRecords(EntryContext &aContext)
 
         if ((mSrvRecord.GetTtl() > 0) && (hostEntry != nullptr))
         {
-            hostEntry->mAddrRecord.MarkToAppendInAdditionalData();
+            hostEntry->MarkToAppendAddrRecordsInAdditionalData();
         }
     }
 
@@ -2346,9 +2748,17 @@ void Core::ServiceEntry::PrepareResponseRecords(EntryContext &aContext)
         AppendTxtRecordTo(response, kAdditionalDataSection);
     }
 
-    if ((hostEntry != nullptr) && (hostEntry->mAddrRecord.ShouldAppendInAdditionalDataSection()))
+    if (hostEntry != nullptr)
     {
-        hostEntry->AppendAddressRecordsTo(response, kAdditionalDataSection);
+        if (hostEntry->mIp6AddrRecord.ShouldAppendInAdditionalDataSection())
+        {
+            hostEntry->AppendIp6AddressRecordsTo(response, kAdditionalDataSection);
+        }
+
+        if ((hostEntry->mIp4AddrRecord != nullptr) && hostEntry->mIp4AddrRecord->ShouldAppendInAdditionalDataSection())
+        {
+            hostEntry->AppendIp4AddressRecordsTo(response, kAdditionalDataSection);
+        }
     }
 
     if (appendNsec || ShouldAnswerNsec(aContext.GetNow()))
@@ -2422,6 +2832,8 @@ void Core::ServiceEntry::DiscoverOffsetsAndHost(HostEntry *&aHostEntry)
     // and name compression offsets from the previously appended
     // entries.
 
+    // TODO: Need to handle name matching host name
+
     aHostEntry = Get<Core>().mHostEntries.FindMatching(mHostName);
 
     if ((aHostEntry != nullptr) && (aHostEntry->GetState() != GetState()))
@@ -2566,7 +2978,7 @@ void Core::ServiceEntry::AppendSrvRecordTo(TxMessage &aTxMessage, Section aSecti
     offset = message->GetLength();
     SuccessOrAssert(message->Append(srv));
     AppendHostNameTo(aTxMessage, aSection);
-    UpdateRecordLengthInMessage(srv, *message, offset);
+    ResourceRecord::UpdateRecordLengthInMessage(*message, offset);
 
     aTxMessage.IncrementRecordCount(aSection);
 
@@ -2631,7 +3043,7 @@ void Core::ServiceEntry::AppendPtrRecordTo(TxMessage &aTxMessage, Section aSecti
     offset = message->GetLength();
     SuccessOrAssert(message->Append(ptr));
     AppendServiceNameTo(aTxMessage, aSection);
-    UpdateRecordLengthInMessage(ptr, *message, offset);
+    ResourceRecord::UpdateRecordLengthInMessage(*message, offset);
 
     aTxMessage.IncrementRecordCount(aSection);
 
@@ -2967,7 +3379,7 @@ void Core::ServiceType::AppendPtrRecordTo(TxMessage &aResponse, uint16_t aServic
     offset = message->GetLength();
     SuccessOrAssert(message->Append(ptr));
     aResponse.AppendServiceType(kAnswerSection, mServiceType.AsCString(), aServiceTypeOffset);
-    UpdateRecordLengthInMessage(ptr, *message, offset);
+    ResourceRecord::UpdateRecordLengthInMessage(*message, offset);
 
     aResponse.IncrementRecordCount(kAnswerSection);
 
@@ -3703,7 +4115,7 @@ void Core::RxMessage::ProcessQuestion(Question &aQuestion)
         ExitNow();
     }
 
-    // Check if question name matches a `HostEntry` or a `ServiceEntry`
+    // Check if question name matches a `HostEntry` or a `ServiceEntry`.
 
     aQuestion.mEntry = Get<Core>().mHostEntries.FindMatching(name);
 
@@ -4092,9 +4504,19 @@ void Core::RxMessage::ProcessResponse(void)
             addrCache.CommitNewResponseEntries();
         }
     }
-}
 
-void Core::RxMessage::IterateOnAllRecordsInResponse(RecordProcessor aRecordProcessor)
+    if (!Get<Core>().mRecordCacheList.IsEmpty())
+    {
+        IterateOnAllRecordsInResponse(&RxMessage::ProcessOtherRecord);
+
+        for (RecordCache &recordCache : Get<Core>().mRecordCacheList)
+        {
+            recordCache.CommitNewResponseEntries();
+        }
+    }
+}
+
+void Core::RxMessage::IterateOnAllRecordsInResponse(RecordProcessor aRecordProcessor)
 {
     // Iterates over all records in the response, calling
     // `aRecordProcessor` for each.
@@ -4225,6 +4647,22 @@ exit:
     return;
 }
 
+void Core::RxMessage::ProcessOtherRecord(const Name &aName, const ResourceRecord &aRecord, uint16_t aRecordOffset)
+{
+    // Unlike other `Process{Specific}Record()` methods where
+    // we know for sure that we can have only one match, for
+    // `RecordQuerier` we may have multiple matches, due to
+    // the possibility of using `ANY` for record type.
+
+    for (RecordCache &recordCache : Get<Core>().mRecordCacheList)
+    {
+        if (recordCache.Matches(aName, aRecord.GetType()))
+        {
+            recordCache.ProcessResponseRecord(*mMessagePtr, aRecord, aRecordOffset);
+        }
+    }
+}
+
 //---------------------------------------------------------------------------------------------------------------------
 // Core::RxMessage::Question
 
@@ -4429,6 +4867,9 @@ void Core::TxMessageHistory::HandleTimer(void)
     mTimer.FireAtIfEarlier(nextTime);
 }
 
+//---------------------------------------------------------------------------------------------------------------------
+// Core
+
 template <typename CacheType, typename BrowserResolverType>
 Error Core::Start(const BrowserResolverType &aBrowserOrResolver)
 {
@@ -4489,6 +4930,28 @@ Error Core::StartIp6AddressResolver(const AddressResolver &aResolver)
     return Start<Ip6AddrCache, AddressResolver>(aResolver);
 }
 
+Error Core::StartRecordQuerier(const RecordQuerier &aQuerier)
+{
+    Error error;
+
+    switch (aQuerier.mRecordType)
+    {
+    case ResourceRecord::kTypePtr:
+    case ResourceRecord::kTypeSrv:
+    case ResourceRecord::kTypeTxt:
+    case ResourceRecord::kTypeAaaa:
+    case ResourceRecord::kTypeA:
+        error = kErrorInvalidArgs;
+        break;
+
+    default:
+        error = Start<RecordCache, RecordQuerier>(aQuerier);
+        break;
+    }
+
+    return error;
+}
+
 Error Core::StopIp6AddressResolver(const AddressResolver &aResolver)
 {
     return Stop<Ip6AddrCache, AddressResolver>(aResolver);
@@ -4504,6 +4967,8 @@ Error Core::StopIp4AddressResolver(const AddressResolver &aResolver)
     return Stop<Ip4AddrCache, AddressResolver>(aResolver);
 }
 
+Error Core::StopRecordQuerier(const RecordQuerier &aQuerier) { return Stop<RecordCache, RecordQuerier>(aQuerier); }
+
 void Core::AddPassiveSrvTxtCache(const char *aServiceInstance, const char *aServiceType)
 {
     ServiceName serviceName(aServiceInstance, aServiceType);
@@ -4548,6 +5013,7 @@ void Core::HandleCacheTimer(void)
     mTxtCacheList.RemoveAndFreeAllMatching(expireChecker);
     mIp6AddrCacheList.RemoveAndFreeAllMatching(expireChecker);
     mIp4AddrCacheList.RemoveAndFreeAllMatching(expireChecker);
+    mRecordCacheList.RemoveAndFreeAllMatching(expireChecker);
 
     // Process cache types in a specific order to optimize name
     // compression when constructing query messages.
@@ -4577,6 +5043,11 @@ void Core::HandleCacheTimer(void)
         addrCache.HandleTimer(context);
     }
 
+    for (RecordCache &recordCache : mRecordCacheList)
+    {
+        recordCache.HandleTimer(context);
+    }
+
     context.mQueryMessage.Send();
 
     mCacheTimer.FireAtIfEarlier(context.mNextFireTime);
@@ -4612,6 +5083,11 @@ void Core::HandleCacheTask(void)
     {
         addrCache.ClearEmptyCallbacks();
     }
+
+    for (RecordCache &recordCache : mRecordCacheList)
+    {
+        recordCache.ClearEmptyCallbacks();
+    }
 }
 
 TimeMilli Core::RandomizeFirstProbeTxTime(void)
@@ -4681,6 +5157,14 @@ void Core::ResultCallback::Invoke(Instance &aInstance, const AddressResult &aRes
     }
 }
 
+void Core::ResultCallback::Invoke(Instance &aInstance, const RecordResult &aResult) const
+{
+    if (mSharedCallback.mRecord != nullptr)
+    {
+        mSharedCallback.mRecord(&aInstance, &aResult);
+    }
+}
+
 //---------------------------------------------------------------------------------------------------------------------
 // Core::CacheContext
 
@@ -4836,19 +5320,31 @@ void Core::CacheEntry::SetIsActive(bool aIsActive)
     // considered "active" when associated with at least one
     // resolver/browser. "Passive" entries (without a resolver/browser)
     // continue to process mDNS responses for updates but will not send
-    // queries. Passive entries are deleted after `kNonActiveDeleteTimeout`
-    // if no resolver/browser is added.
+    // queries. Passive entries are deleted after the "delete timeout"
+    // if no resolver/browser/querier is added.
 
     mIsActive = aIsActive;
 
     if (!mIsActive)
     {
         mQueryPending = false;
-        mDeleteTime   = TimerMilli::GetNow() + kNonActiveDeleteTimeout;
+        mDeleteTime   = TimerMilli::GetNow() + DetermineDeleteTimeout();
         SetFireTime(mDeleteTime);
     }
 }
 
+uint32_t Core::CacheEntry::DetermineDeleteTimeout(void) const
+{
+    uint32_t timeout = kNonActiveDeleteTimeout;
+
+    if ((mType == kRecordCache) && (As<RecordCache>().mRecordType == ResourceRecord::kTypeAny))
+    {
+        timeout = kNonActiveDeleteTimeoutForAnyRecord;
+    }
+
+    return timeout;
+}
+
 bool Core::CacheEntry::ShouldDelete(TimeMilli aNow) const { return !mIsActive && (mDeleteTime <= aNow); }
 
 void Core::CacheEntry::StartInitialQueries(void)
@@ -4915,6 +5411,7 @@ Error Core::CacheEntry::Add(const ResultCallback &aCallback)
         switch (mType)
         {
         case kBrowseCache:
+        case kRecordCache:
             shouldStart = true;
             break;
         case kSrvCache:
@@ -4954,6 +5451,9 @@ Error Core::CacheEntry::Add(const ResultCallback &aCallback)
     case kIp4AddrCache:
         As<AddrCache>().ReportResultsTo(*callback);
         break;
+    case kRecordCache:
+        As<RecordCache>().ReportResultsTo(*callback);
+        break;
     }
 
 exit:
@@ -5010,6 +5510,9 @@ void Core::CacheEntry::HandleTimer(CacheContext &aContext)
         // compress offset since the host name would not be used
         // in any other query question.
         break;
+
+    case kRecordCache:
+        break;
     }
 
     VerifyOrExit(HasFireTime());
@@ -5042,6 +5545,9 @@ void Core::CacheEntry::HandleTimer(CacheContext &aContext)
     case kIp4AddrCache:
         As<AddrCache>().ProcessExpiredRecords(aContext.GetNow());
         break;
+    case kRecordCache:
+        As<RecordCache>().ProcessExpiredRecords(aContext.GetNow());
+        break;
     }
 
     DetermineNextFireTime();
@@ -5069,6 +5575,9 @@ Core::ResultCallback *Core::CacheEntry::FindCallbackMatching(const ResultCallbac
     case kIp4AddrCache:
         callback = mCallbacks.FindMatching(aCallback.mSharedCallback.mAddress);
         break;
+    case kRecordCache:
+        callback = mCallbacks.FindMatching(aCallback.mSharedCallback.mRecord);
+        break;
     }
 
     return callback;
@@ -5107,6 +5616,9 @@ void Core::CacheEntry::DetermineNextFireTime(void)
     case kIp4AddrCache:
         As<AddrCache>().DetermineRecordFireTime();
         break;
+    case kRecordCache:
+        As<RecordCache>().DetermineRecordFireTime();
+        break;
     }
 }
 
@@ -5139,6 +5651,9 @@ void Core::CacheEntry::PrepareQuery(CacheContext &aContext)
         case kIp4AddrCache:
             As<Ip4AddrCache>().PrepareAQuestion(query);
             break;
+        case kRecordCache:
+            As<RecordCache>().PrepareQueryQuestion(query);
+            break;
         }
 
         query.CheckSizeLimitToPrepareAgain(prepareAgain);
@@ -5169,6 +5684,8 @@ void Core::CacheEntry::PrepareQuery(CacheContext &aContext)
     case kIp4AddrCache:
         As<AddrCache>().UpdateRecordStateAfterQuery(aContext.GetNow());
         break;
+    case kRecordCache:
+        As<RecordCache>().UpdateRecordStateAfterQuery(aContext.GetNow());
     }
 }
 
@@ -5425,7 +5942,7 @@ void Core::BrowseCache::AppendKnownAnswer(TxMessage &aTxMessage, const PtrEntry
     SuccessOrAssert(Name::AppendLabel(aPtrEntry.mServiceInstance.AsCString(), message));
     aTxMessage.AppendServiceType(kAnswerSection, mServiceType.AsCString(), mServiceTypeOffset);
 
-    UpdateRecordLengthInMessage(ptr, message, offset);
+    ResourceRecord::UpdateRecordLengthInMessage(message, offset);
 
     aTxMessage.IncrementRecordCount(kAnswerSection);
 }
@@ -6404,6 +6921,414 @@ exit:
 
 void Core::Ip4AddrCache::PrepareAQuestion(TxMessage &aQuery) { PrepareQueryQuestion(aQuery, ResourceRecord::kTypeA); }
 
+//---------------------------------------------------------------------------------------------------------------------
+// Core::RecordCache
+
+Error Core::RecordCache::Init(Instance &aInstance, const RecordQuerier &aQuerier)
+{
+    Error error;
+
+    CacheEntry::Init(aInstance, kRecordCache);
+
+    mNext = nullptr;
+    SuccessOrExit(error = mFirstLabel.Set(aQuerier.mFirstLabel));
+    SuccessOrExit(error = mNextLabels.Set(aQuerier.mNextLabels));
+    mRecordType = aQuerier.mRecordType;
+
+exit:
+    return error;
+}
+
+bool Core::RecordCache::Matches(const Name &aFullName, uint16_t aRecordType) const
+{
+    return QuestionMatches(mRecordType, aRecordType) &&
+           aFullName.Matches(mFirstLabel.AsCString(), mNextLabels.AsCString(), kLocalDomain);
+}
+
+bool Core::RecordCache::Matches(const RecordQuerier &aQuerier) const
+{
+    bool matches = false;
+
+    VerifyOrExit(aQuerier.mRecordType == mRecordType);
+
+    VerifyOrExit(NameMatch(mFirstLabel, aQuerier.mFirstLabel));
+
+    if (mNextLabels.IsNull())
+    {
+        VerifyOrExit(aQuerier.mNextLabels == nullptr);
+    }
+    else
+    {
+        VerifyOrExit(NameMatch(mNextLabels, aQuerier.mNextLabels));
+    }
+
+    matches = true;
+
+exit:
+    return matches;
+}
+
+bool Core::RecordCache::Matches(const ExpireChecker &aExpireChecker) const { return ShouldDelete(aExpireChecker.mNow); }
+
+Error Core::RecordCache::Add(const RecordQuerier &aQuerier)
+{
+    return CacheEntry::Add(ResultCallback(aQuerier.mCallback));
+}
+
+void Core::RecordCache::Remove(const RecordQuerier &aQuerier)
+{
+    return CacheEntry::Remove(ResultCallback(aQuerier.mCallback));
+}
+
+void Core::RecordCache::PrepareQueryQuestion(TxMessage &aQuery)
+{
+    Question question;
+
+    question.SetType(mRecordType);
+    question.SetClass(ResourceRecord::kClassInternet);
+
+    AppendNameTo(aQuery, kQuestionSection);
+    SuccessOrAssert(aQuery.SelectMessageFor(kQuestionSection).Append(question));
+
+    aQuery.IncrementRecordCount(kQuestionSection);
+}
+
+void Core::RecordCache::AppendNameTo(TxMessage &aTxMessage, Section aSection)
+{
+    uint16_t      compressOffset = kUnspecifiedOffset;
+    AppendOutcome outcome;
+
+    outcome = aTxMessage.AppendLabel(aSection, mFirstLabel.AsCString(), compressOffset);
+    VerifyOrExit(outcome != kAppendedFullNameAsCompressed);
+
+    if (!mNextLabels.IsNull())
+    {
+        compressOffset = kUnspecifiedOffset;
+        outcome        = aTxMessage.AppendMultipleLabels(aSection, mNextLabels.AsCString(), compressOffset);
+        VerifyOrExit(outcome != kAppendedFullNameAsCompressed);
+    }
+
+    aTxMessage.AppendDomainName(aSection);
+
+exit:
+    return;
+}
+
+void Core::RecordCache::UpdateRecordStateAfterQuery(TimeMilli aNow)
+{
+    for (RecordEntry &entry : mCommittedEntries)
+    {
+        entry.mRecord.UpdateStateAfterQuery(aNow);
+    }
+}
+
+void Core::RecordCache::ProcessResponseRecord(const Message        &aMessage,
+                                              const ResourceRecord &aRecord,
+                                              uint16_t              aRecordOffset)
+{
+    // Name and record type in `aMessage` are already matched.
+
+    // First, checks if the record data needs to be decompressed
+    // (the record data format can contain one or more compressed DNS
+    // names). This check applies to records: NS, CNAME, SOA, PTR,
+    // MX, RP, AFSDB, RT, PX, SRV, KX, DNAME, and NSEC.
+    //
+    // Then, adds the new record data to the `mNewEntries` list. This
+    // step occurs as the records in a received response are
+    // processed one by one. Once all records are processed,
+    // `CommitNewResponseEntries()` is called to update the list.
+
+    OwnedPtr<Message> dataMsg;
+    Heap::Data        data;
+    NewRecordEntry   *entry;
+
+    SuccessOrExit(ResourceRecord::DecompressRecordData(aMessage, aRecordOffset, dataMsg));
+
+    if (dataMsg != nullptr)
+    {
+        SuccessOrAssert(data.SetFrom(*dataMsg));
+    }
+    else
+    {
+        SuccessOrAssert(data.SetFrom(aMessage, aRecordOffset + sizeof(ResourceRecord), aRecord.GetLength()));
+    }
+
+    // Check for duplicates in the same response. If there
+    // are exact duplicates, we remember the last one in the
+    // response message.
+
+    entry = mNewEntries.FindMatching(aRecord.GetType(), data);
+
+    if (entry != nullptr)
+    {
+        entry->mCacheFlush = (aRecord.GetClass() & kClassCacheFlushFlag);
+        entry->mTtl        = aRecord.GetTtl();
+    }
+    else
+    {
+        entry = NewRecordEntry::Allocate(aRecord, data);
+        OT_ASSERT(entry != nullptr);
+
+        mNewEntries.Push(*entry);
+    }
+
+exit:
+    return;
+}
+
+void Core::RecordCache::CommitNewResponseEntries(void)
+{
+    // If `RecordQuerier` is used for record type ANY, multiple new
+    // records with different types may be included in the received
+    // response. We process and commit all the new records matching
+    // the same type, together.
+
+    while (!mNewEntries.IsEmpty())
+    {
+        uint16_t recordType = mNewEntries.GetHead()->mType;
+
+        CommitNewEntriesForType(recordType);
+    }
+
+    mCommittedEntries.RemoveAndFreeAllMatching(EmptyChecker());
+
+    DetermineNextFireTime();
+    ScheduleTimer();
+}
+
+void Core::RecordCache::CommitNewEntriesForType(uint16_t aRecordType)
+{
+    bool                       shouldFlush = false;
+    OwningList<NewRecordEntry> newMatchingEntries;
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Filter and remove all new entries that match `aRecordType`.
+
+    mNewEntries.RemoveAllMatching(newMatchingEntries, aRecordType);
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Determine whether we should flush cache for previously
+    // committed records of `aRecordType`.
+
+    for (const NewRecordEntry &newEntry : newMatchingEntries)
+    {
+        if (newEntry.mCacheFlush)
+        {
+            shouldFlush = true;
+            break;
+        }
+    }
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Invoke callbacks if there is any change.
+
+    // If we need to flush, check any entry in the previously
+    // `mCommittedEntries` that does not appear in the new list
+    // and signal their removal.
+
+    if (shouldFlush)
+    {
+        for (RecordEntry &entry : mCommittedEntries)
+        {
+            if (!entry.Matches(aRecordType))
+            {
+                continue;
+            }
+
+            if (!newMatchingEntries.ContainsMatching(entry.mType, entry.mData))
+            {
+                entry.mRecord.RefreshTtl(0);
+                PrepareResultAndInvokeCallbacks(entry);
+            }
+        }
+    }
+
+    // Signal addition of any new entries or if there is any
+    // change to an existing entry (TTL value changed).
+
+    for (const NewRecordEntry &newEntry : newMatchingEntries)
+    {
+        RecordEntry *entry        = mCommittedEntries.FindMatching(newEntry.mType, newEntry.mData);
+        bool         shouldSignal = false;
+
+        if (entry == nullptr)
+        {
+            shouldSignal = (newEntry.mTtl > 0);
+        }
+        else
+        {
+            shouldSignal = (entry->GetTtl() != newEntry.mTtl);
+        }
+
+        if (shouldSignal)
+        {
+            PrepareResultAndInvokeCallbacks(newEntry);
+        }
+    }
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Now merge the new entries into the `mCommittedEntries` list.
+
+    if (shouldFlush)
+    {
+        mCommittedEntries.RemoveAndFreeAllMatching(aRecordType);
+
+        if (mRecordType != ResourceRecord::kTypeAny)
+        {
+            StopInitialQueries();
+        }
+    }
+
+    while (!newMatchingEntries.IsEmpty())
+    {
+        OwnedPtr<NewRecordEntry> newEntry = newMatchingEntries.Pop();
+        RecordEntry             *entry;
+
+        entry = mCommittedEntries.FindMatching(newEntry->mType, newEntry->mData);
+
+        if (entry != nullptr)
+        {
+            entry->mRecord.RefreshTtl(newEntry->mTtl);
+        }
+        else
+        {
+            entry = RecordEntry::Allocate(*newEntry);
+            OT_ASSERT(entry != nullptr);
+
+            mCommittedEntries.Push(*entry);
+        }
+    }
+}
+
+void Core::RecordCache::DetermineRecordFireTime(void)
+{
+    for (RecordEntry &entry : mCommittedEntries)
+    {
+        entry.mRecord.UpdateQueryAndFireTimeOn(*this);
+    }
+}
+
+void Core::RecordCache::ProcessExpiredRecords(TimeMilli aNow)
+{
+    OwningList<RecordEntry> expiredEntries;
+
+    mCommittedEntries.RemoveAllMatching(expiredEntries, ExpireChecker(aNow));
+
+    for (RecordEntry &entry : expiredEntries)
+    {
+        entry.mRecord.RefreshTtl(0);
+        PrepareResultAndInvokeCallbacks(entry);
+    }
+}
+
+void Core::RecordCache::ReportResultsTo(ResultCallback &aCallback) const
+{
+    for (const RecordEntry &entry : mCommittedEntries)
+    {
+        RecordResult result;
+
+        PreareResultFor(entry.mType, entry.mData, entry.GetTtl(), result);
+        aCallback.Invoke(GetInstance(), result);
+    }
+}
+
+void Core::RecordCache::PreareResultFor(uint16_t          aType,
+                                        const Heap::Data &aData,
+                                        uint32_t          aTtl,
+                                        RecordResult     &aResult) const
+{
+    ClearAllBytes(aResult);
+    aResult.mFirstLabel       = mFirstLabel.AsCString();
+    aResult.mNextLabels       = mNextLabels.AsCString();
+    aResult.mRecordType       = aType;
+    aResult.mRecordData       = aData.GetBytes();
+    aResult.mRecordDataLength = aData.GetLength();
+    aResult.mTtl              = aTtl;
+    aResult.mInfraIfIndex     = Get<Core>().mInfraIfIndex;
+}
+
+void Core::RecordCache::PrepareResultAndInvokeCallbacks(const RecordEntry &aEntry)
+{
+    PrepareResultAndInvokeCallbacks(aEntry.mType, aEntry.mData, aEntry.GetTtl());
+}
+
+void Core::RecordCache::PrepareResultAndInvokeCallbacks(const NewRecordEntry &aNewEntry)
+{
+    PrepareResultAndInvokeCallbacks(aNewEntry.mType, aNewEntry.mData, aNewEntry.mTtl);
+}
+
+void Core::RecordCache::PrepareResultAndInvokeCallbacks(uint16_t aType, const Heap::Data &aData, uint32_t aTtl)
+{
+    RecordResult result;
+
+    PreareResultFor(aType, aData, aTtl, result);
+    InvokeCallbacks(result);
+}
+
+#if OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
+
+void Core::RecordCache::CopyInfoTo(RecordQuerier &aQuerier, CacheInfo &aInfo) const
+{
+    aQuerier.mFirstLabel    = mFirstLabel.AsCString();
+    aQuerier.mNextLabels    = mNextLabels.AsCString();
+    aQuerier.mRecordType    = mRecordType;
+    aQuerier.mInfraIfIndex  = Get<Core>().mInfraIfIndex;
+    aQuerier.mCallback      = nullptr;
+    aInfo.mIsActive         = IsActive();
+    aInfo.mHasCachedResults = !mCommittedEntries.IsEmpty();
+}
+
+#endif
+
+//---------------------------------------------------------------------------------------------------------------------
+// Core::RecordCache::NewRecordEntry
+
+Core::RecordCache::NewRecordEntry::NewRecordEntry(const ResourceRecord &aRecord, Heap::Data &aData)
+    : mNext(nullptr)
+    , mCacheFlush(aRecord.GetClass() & kClassCacheFlushFlag)
+    , mType(aRecord.GetType())
+    , mTtl(aRecord.GetTtl())
+    , mData(static_cast<Heap::Data &&>(aData))
+{
+}
+
+bool Core::RecordCache::NewRecordEntry::Matches(uint16_t aType) const { return (mType == aType); }
+
+bool Core::RecordCache::NewRecordEntry::Matches(uint16_t aType, const Heap::Data &aData) const
+{
+    return (mType == aType) && (aData == mData);
+}
+
+//---------------------------------------------------------------------------------------------------------------------
+// Core::RecordCache::RecordEntry
+
+Core::RecordCache::RecordEntry::RecordEntry(NewRecordEntry &aNewEntry)
+    : mNext(nullptr)
+    , mType(aNewEntry.mType)
+    , mData(static_cast<Heap::Data &&>(aNewEntry.mData))
+{
+    mRecord.RefreshTtl(aNewEntry.mTtl);
+}
+
+bool Core::RecordCache::RecordEntry::Matches(uint16_t aType) const { return (mType == aType); }
+
+bool Core::RecordCache::RecordEntry::Matches(uint16_t aType, const Heap::Data &aData) const
+{
+    return (mType == aType) && (mData == aData);
+}
+
+bool Core::RecordCache::RecordEntry::Matches(const ExpireChecker &aExpireChecker) const
+{
+    return mRecord.ShouldExpire(aExpireChecker.mNow);
+}
+
+bool Core::RecordCache::RecordEntry::Matches(EmptyChecker aChecker) const
+{
+    OT_UNUSED_VARIABLE(aChecker);
+
+    return !mRecord.IsPresent();
+}
+
 //---------------------------------------------------------------------------------------------------------------------
 // Core::Iterator
 
@@ -6503,6 +7428,50 @@ exit:
     return error;
 }
 
+Error Core::EntryIterator::GetNextLocalHostAddress(LocalHostAddress &aAddress)
+{
+    Error        error = kErrorNone;
+    uint16_t     index;
+    Ip4::Address ip4Addr;
+
+    if (mType == kUnspecified)
+    {
+        mLocalHostAddrIndex = 0;
+        mType               = kLocalHostAddress;
+    }
+    else
+    {
+        VerifyOrExit(mType == kLocalHostAddress, error = kErrorInvalidArgs);
+    }
+
+    ClearAllBytes(aAddress);
+
+    index = mLocalHostAddrIndex;
+
+    if (index < Get<Core>().mLocalHost.GetIp6Addresses().GetLength())
+    {
+        aAddress.mIsIp6        = true;
+        aAddress.mAddress.mIp6 = Get<Core>().mLocalHost.GetIp6Addresses()[index];
+    }
+    else
+    {
+        index -= Get<Core>().mLocalHost.GetIp6Addresses().GetLength();
+
+        VerifyOrExit(index < Get<Core>().mLocalHost.GetIp4Addresses().GetLength(), error = kErrorNotFound);
+
+        IgnoreError(ip4Addr.ExtractFromIp4MappedIp6Address(Get<Core>().mLocalHost.GetIp4Addresses()[index]));
+
+        aAddress.mIsIp6        = false;
+        aAddress.mAddress.mIp4 = ip4Addr;
+    }
+
+    aAddress.mInfraIfIndex = Get<Core>().mInfraIfIndex;
+    mLocalHostAddrIndex++;
+
+exit:
+    return error;
+}
+
 Error Core::EntryIterator::GetNextBrowser(Browser &aBrowser, CacheInfo &aInfo)
 {
     Error error = kErrorNone;
@@ -6618,6 +7587,29 @@ exit:
     return error;
 }
 
+Error Core::EntryIterator::GetNextRecordQuerier(RecordQuerier &aQuerier, CacheInfo &aInfo)
+{
+    Error error = kErrorNone;
+
+    if (mType == kUnspecified)
+    {
+        mRecordCache = Get<Core>().mRecordCacheList.GetHead();
+        mType        = kRecordQuerier;
+    }
+    else
+    {
+        VerifyOrExit(mType == kRecordQuerier, error = kErrorInvalidArgs);
+    }
+
+    VerifyOrExit(mRecordCache != nullptr, error = kErrorNotFound);
+
+    mRecordCache->CopyInfoTo(aQuerier, aInfo);
+    mRecordCache = mRecordCache->GetNext();
+
+exit:
+    return error;
+}
+
 #endif // OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
 
 } // namespace Multicast
diff --git a/src/core/net/mdns.hpp b/src/core/net/mdns.hpp
index 549fc0a2a..13d5eaf88 100644
--- a/src/core/net/mdns.hpp
+++ b/src/core/net/mdns.hpp
@@ -77,16 +77,32 @@ extern "C" void otPlatMdnsHandleReceive(otInstance                  *aInstance,
                                         bool                         aIsUnicast,
                                         const otPlatMdnsAddressInfo *aAddress);
 
+extern "C" void otPlatMdnsHandleHostAddressEvent(otInstance         *aInstance,
+                                                 const otIp6Address *aAddress,
+                                                 bool                aAdded,
+                                                 uint32_t            aInfraIfIndex);
+
+extern "C" void otPlatMdnsHandleHostAddressRemoveAll(otInstance *aInstance, uint32_t aInfraIfIndex);
+
 /**
  * Implements Multicast DNS (mDNS) core.
  */
 class Core : public InstanceLocator, private NonCopyable
 {
+    friend class ot::Instance;
+
     friend void otPlatMdnsHandleReceive(otInstance                  *aInstance,
                                         otMessage                   *aMessage,
                                         bool                         aIsUnicast,
                                         const otPlatMdnsAddressInfo *aAddress);
 
+    friend void otPlatMdnsHandleHostAddressEvent(otInstance         *aInstance,
+                                                 const otIp6Address *aAddress,
+                                                 bool                aAdded,
+                                                 uint32_t            aInfraIfIndex);
+
+    friend void otPlatMdnsHandleHostAddressRemoveAll(otInstance *aInstance, uint32_t aInfraIfIndex);
+
 public:
     /**
      * Initializes a `Core` instance.
@@ -102,6 +118,7 @@ public:
     typedef otMdnsHost             Host;             ///< Host information.
     typedef otMdnsService          Service;          ///< Service information.
     typedef otMdnsKey              Key;              ///< Key information.
+    typedef otMdnsLocalHostAddress LocalHostAddress; ///< Local host address information.
     typedef otMdnsBrowser          Browser;          ///< Browser.
     typedef otMdnsBrowseCallback   BrowseCallback;   ///< Browser callback.
     typedef otMdnsBrowseResult     BrowseResult;     ///< Browser result.
@@ -115,6 +132,9 @@ public:
     typedef otMdnsAddressCallback  AddressCallback;  ///< Address callback
     typedef otMdnsAddressResult    AddressResult;    ///< Address result.
     typedef otMdnsAddressAndTtl    AddressAndTtl;    ///< Address and TTL.
+    typedef otMdnsRecordResult     RecordResult;     ///< Record query result
+    typedef otMdnsRecordCallback   RecordCallback;   ///< Record query callback.
+    typedef otMdnsRecordQuerier    RecordQuerier;    ///< Record querier.
     typedef otMdnsIterator         Iterator;         ///< An entry iterator.
     typedef otMdnsCacheInfo        CacheInfo;        ///< Cache information.
 
@@ -162,6 +182,26 @@ public:
      */
     bool IsEnabled(void) const { return mIsEnabled; }
 
+    /**
+     * Gets the local host name.
+     *
+     * @returns The local host name.
+     */
+    const char *GetLocalHostName(void) { return mLocalHost.GetName(); }
+
+    /**
+     * Sets the local host name.
+     *
+     * The local host name can be set only when the mDNS module is disabled. If not set the mDNS module itself will
+     * generate the local host name.
+     *
+     * @param[in] aName   The local host name to use, can be to `nullptr` to allow the mDNS module to choose the name.
+     *
+     * @retval kErrorNone           The local host name was successfully set.
+     * @retval kErrorInvalidState   mDNS module is already enabled.
+     */
+    Error SetLocalHostName(const char *aName) { return mLocalHost.SetName(aName); }
+
 #if OPENTHREAD_CONFIG_MULTICAST_DNS_AUTO_ENABLE_ON_INFRA_IF
     /**
      * Notifies `AdvertisingProxy` that `InfraIf` state changed.
@@ -261,7 +301,8 @@ public:
      *   contain dot `.` character which is allowed in a service instance label.
      * - The `mServiceType` specifies the service type (e.g., "_tst._udp"). It is treated as multiple dot `.` separated
      *   labels. It MUST NOT contain the domain name.
-     * - The `mHostName` field specifies the host name of the service. MUST NOT contain the domain name.
+     * - The `mHostName` field specifies the host name of the service if it is not `nullptr`. Otherwise, if it is
+     *   `nullptr`, it indicates that this service is for the local host (this device itself).
      * - The `mSubTypeLabels` is an array of strings representing sub-types associated with the service. Each array
      *   entry is a sub-type label. The `mSubTypeLabels can be `nullptr` if there are no sub-types. Otherwise, the
      *   array length is specified by `mSubTypeLabelsLength`.
@@ -537,6 +578,50 @@ public:
      */
     Error StopIp4AddressResolver(const AddressResolver &aResolver);
 
+    /**
+     * Starts a record querier.
+     *
+     * Initiates a continuous query for a given `mRecordType` as specified in @p aQuerier. The queried name is specified
+     * by the combination of `mFirstLabel` and `mNextLabels` (optional rest of the labels) in @p aQuerier. The
+     * `mFirstLabel` MUST be non-NULL but `mNextLabels` can be `NULL` if there are no other labels. The `mNextLabels`
+     * MUST NOT include the domain name. The reason for a separate first label is to allow it to include a dot `.`
+     * character (as allowed for service instance labels).
+     *
+     * Discovered results are reported through the `mCallback` function in @p aQuerier, providing the raw record
+     * data bytes. A removed record data is indicated with a TTL value of zero. The callback may be invoked immediately
+     * with cached information (if available) and potentially before this function returns. When cached results are
+     * used, the reported TTL value will reflect the original TTL from the last received response.
+     *
+     * Multiple querier instances can be started for the same name, provided they use different callback functions.
+     *
+     * The record querier MUST not be used for record types PTR, SRV, TXT, A, and AAAA. Otherwise, `kErrorInvalidArgs`
+     * will be returned. For these, browsers/resolvers can be used. This design is intentional to enable the
+     * implementation of the "opportunistic cache mechanism", where, depending on currently active service
+     * browsers/resolvers, the mDNS implementation will also monitor and cache related records (e.g., when a
+     * service is resolved, the address records associated with its host name are cached even if there is no active
+     * address resolver for this hostname).
+     *
+     * @param[in] aQuerier    The record querier to be started.
+     *
+     * @retval kErrorNone              Record @p aQuerier started successfully.
+     * @retval kErrorInvalidState      mDNS module is not enabled.
+     * @retval kErrorAlready           An identical querier (same name, record type, and callback) is already active.
+     * @retval kErrorInvalidArg   The `mRecordType` in @p aQuerier is invalid. MUST use browser/resolvers.
+     */
+    Error StartRecordQuerier(const RecordQuerier &aQuerier);
+
+    /**
+     * Stops a record querier.
+     *
+     * No action is performed if no matching querier with the same name and callback is currently active.
+     *
+     * @param[in] aQuerier    The record querier to be stopped.
+     *
+     * @retval kErrorNone           Querier stopped successfully.
+     * @retval kErrorInvalidStat    mDNS module is not enabled.
+     */
+    Error StopRecordQuerier(const RecordQuerier &aQuerier);
+
     /**
      * Sets the max size threshold for mDNS messages.
      *
@@ -585,6 +670,7 @@ public:
      * structure (like `mServiceType`) remain valid until the next call to any OpenThread stack's public or platform
      * API/callback.
      *
+     * @param[in]  aIterator   The iterator to use.
      * @param[out] aService    A `Service` to return the information about the next service entry.
      * @param[out] aState      An `EntryState` to return the entry state.
      *
@@ -600,6 +686,7 @@ public:
      * On success, @p aKey is populated with information about the next key. Pointers within the `Key` structure
      * (like `mName`) remain valid until the next call to any OpenThread stack's public or platform API/callback.
      *
+     * @param[in]  aIterator   The iterator to use.
      * @param[out] aKey        A `Key` to return the information about the next key entry.
      * @param[out] aState      An `EntryState` to return the entry state.
      *
@@ -609,6 +696,18 @@ public:
      */
     Error GetNextKey(Iterator &aIterator, Key &aKey, EntryState &aState) const;
 
+    /**
+     * Iterates over the local host IPv6 and IPv4 addresses.
+     *
+     * @param[in]   aIterator      The iterator to use.
+     * @param[out]  aAddress       A `LocalHostAddress` to output the next address entry.
+     *
+     * @retval kErrorNone           The @p aAddress and @p aIterator are updated successfully.
+     * @retval kErrorNotFound       Reached the end of the list.
+     * @retval kErrorInvalidArgs    Iterator is not valid.
+     */
+    Error GetNextLocalHostAddress(Iterator &aIterator, LocalHostAddress &aAddress);
+
     /**
      * Iterates over browsers.
      *
@@ -691,6 +790,24 @@ public:
      */
     Error GetNextIp4AddressResolver(Iterator &aIterator, AddressResolver &aResolver, CacheInfo &aInfo) const;
 
+    /**
+     * Iterates over record querier entries.
+     *
+     * On success, @p aQuerier is populated with information about the next querier . The `mCallback` field is always
+     * set to `nullptr` as there may be multiple active querier with different callbacks. Other pointers within the
+     * `RecordQuerier` structure remain valid until the next call to any OpenThread stack's public or platform
+     * API/callback.
+     *
+     * @param[in]  aIterator   The iterator to use
+     * @param[out] aQuerier    A `RecordQuerier` to return the information about the next querier.
+     * @param[out] aInfo       A `CacheInfo` to return additional information.
+     *
+     * @retval kErrorNone            @p aQuerier, @p aInfo, & @p aIterator are updated successfully.
+     * @retval kErrorNotFound        Reached the end of the list.
+     * @retval kErrorInvalidArg      @p aIterator is not valid.
+     */
+    Error GetNextRecordQuerier(Iterator &aIterator, RecordQuerier &aQuerier, CacheInfo &aInfo) const;
+
 #endif // OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
 
 private:
@@ -752,6 +869,12 @@ private:
         kAppendedLabels,
     };
 
+    enum AddrType : uint8_t
+    {
+        kIp4AddrType,
+        kIp6AddrType,
+    };
+
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     // Forward declarations
 
@@ -832,7 +955,9 @@ private:
     class AddressArray : public Heap::Array<Ip6::Address>
     {
     public:
+        bool IsEmpty(void) const { return (GetLength() == 0); }
         bool Matches(const Ip6::Address *aAddresses, uint16_t aNumAddresses) const;
+        bool Matches(const AddressArray &aOther) const;
         void SetFrom(const Ip6::Address *aAddresses, uint16_t aNumAddresses);
     };
 
@@ -966,10 +1091,15 @@ private:
 
         struct RecordAndType
         {
-            RecordInfo &mRecord;
+            RecordInfo *mRecord;
             uint16_t    mType;
         };
 
+        struct RecordAndTypeArray : public Array<RecordAndType, kTypeArraySize>
+        {
+            void Add(RecordInfo &aRecord, uint16_t aType);
+        };
+
         typedef void (*NameAppender)(Entry &aEntry, TxMessage &aTxMessage, Section aSection);
 
         Entry(void);
@@ -991,8 +1121,8 @@ private:
         void DetermineNextFireTime(void);
         void DetermineNextAggrTxTime(NextFireTime &aNextAggrTxTime) const;
         void ScheduleTimer(void);
-        void AnswerProbe(const AnswerInfo &aInfo, RecordAndType *aRecords, uint16_t aRecordsLength);
-        void AnswerNonProbe(const AnswerInfo &aInfo, RecordAndType *aRecords, uint16_t aRecordsLength);
+        void AnswerProbe(const AnswerInfo &aInfo, RecordAndTypeArray &aRecordAndTypes);
+        void AnswerNonProbe(const AnswerInfo &aInfo, RecordAndTypeArray &aRecordAndTypes);
         void ScheduleNsecAnswer(const AnswerInfo &aInfo);
 
         template <typename EntryType> void HandleTimer(EntryContext &aContext);
@@ -1021,6 +1151,48 @@ private:
 
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
+    void HandleLocalHostEventTimer(void) { mLocalHost.HandleEventTimer(); }
+
+    class LocalHost : public InstanceLocator
+    {
+    public:
+        explicit LocalHost(Instance &aInstance);
+
+        const char         *GetName(void) const { return mName.AsCString(); }
+        Error               SetName(const char *aName);
+        void                GenerateName(void);
+        const AddressArray &GetIp4Addresses(void) const { return mIp4Addresses; }
+        const AddressArray &GetIp6Addresses(void) const { return mIp6Addresses; }
+        void                HandleAddressEvent(const Ip6::Address &aAddress, bool aAdded, uint32_t aInfraIfIndex);
+        void                HandleAddressRemoveAll(uint32_t aInfraIfIndex);
+        void                HandleEventTimer(void);
+        void                ClearAddresses(void);
+
+    private:
+        static constexpr uint32_t kGuardTimeToProcessAddrEvents = 4; // msec
+
+        struct AddrEvent : public LinkedListEntry<AddrEvent>, public Heap::Allocatable<AddrEvent>
+        {
+            AddrEvent(const Ip6::Address &aAddress, bool aAdded);
+            bool Matches(const Ip6::Address &aAddress) const { return mAddress == aAddress; }
+            bool Matches(AddrType aType) const;
+
+            AddrEvent   *mNext;
+            Ip6::Address mAddress;
+            bool         mAdded;
+        };
+
+        using EventTimer = TimerMilliIn<Core, &Core::HandleLocalHostEventTimer>;
+
+        Heap::String          mName;
+        AddressArray          mIp4Addresses;
+        AddressArray          mIp6Addresses;
+        OwningList<AddrEvent> mAddrEvents;
+        EventTimer            mEventTimer;
+    };
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
     class HostEntry : public Entry, public LinkedListEntry<HostEntry>, public Heap::Allocatable<HostEntry>
     {
         friend class LinkedListEntry<HostEntry>;
@@ -1030,15 +1202,18 @@ private:
     public:
         HostEntry(void);
         Error Init(Instance &aInstance, const Host &aHost) { return Init(aInstance, aHost.mHostName); }
+        Error Init(Instance &aInstance, const LocalHost &aLocalHost) { return Init(aInstance, aLocalHost.GetName()); }
         Error Init(Instance &aInstance, const Key &aKey) { return Init(aInstance, aKey.mName); }
         bool  IsEmpty(void) const;
         bool  Matches(const Name &aName) const;
         bool  Matches(const Host &aHost) const;
+        bool  Matches(const LocalHost &aLocalHost) const;
         bool  Matches(const Key &aKey) const;
         bool  Matches(const Heap::String &aName) const;
         bool  Matches(State aState) const { return GetState() == aState; }
         bool  Matches(const HostEntry &aEntry) const { return (this == &aEntry); }
         void  Register(const Host &aHost, const Callback &aCallback);
+        void  Register(const LocalHost &aLocalHost, const Callback &aCallback);
         void  Register(const Key &aKey, const Callback &aCallback);
         void  Unregister(const Host &aHost);
         void  Unregister(const Key &aKey);
@@ -1054,6 +1229,15 @@ private:
 #endif
 
     private:
+        struct AddrRecord : public RecordInfo, public Heap::Allocatable<AddrRecord>
+        {
+            void Clear(void);
+            void UpdateAddresses(const Host &aHost);
+            void UpdateAddresses(const AddressArray &aAddresses);
+
+            AddressArray mAddresses;
+        };
+
         Error Init(Instance &aInstance, const char *aName);
         void  ClearHost(void);
         void  ScheduleToRemoveIfEmpty(void);
@@ -1062,18 +1246,21 @@ private:
         void  PrepareResponseRecords(EntryContext &aContext);
         void  UpdateRecordsState(const TxMessage &aResponse);
         void  DetermineNextFireTime(void);
-        void  AppendAddressRecordsTo(TxMessage &aTxMessage, Section aSection);
+        void  AppendIp6AddressRecordsTo(TxMessage &aTxMessage, Section aSection);
+        void  AppendIp4AddressRecordsTo(TxMessage &aTxMessage, Section aSection);
+        void  AppendAddressRecordsTo(TxMessage &aTxMessage, Section aSection, AddrRecord &aAddrRecord, bool aIp6);
         void  AppendKeyRecordTo(TxMessage &aTxMessage, Section aSection);
         void  AppendNsecRecordTo(TxMessage &aTxMessage, Section aSection);
         void  AppendNameTo(TxMessage &aTxMessage, Section aSection);
+        void  MarkToAppendAddrRecordsInAdditionalData(void);
 
         static void AppendEntryName(Entry &aEntry, TxMessage &aTxMessage, Section aSection);
 
-        HostEntry   *mNext;
-        Heap::String mName;
-        RecordInfo   mAddrRecord;
-        AddressArray mAddresses;
-        uint16_t     mNameOffset;
+        HostEntry           *mNext;
+        Heap::String         mName;
+        AddrRecord           mIp6AddrRecord;
+        OwnedPtr<AddrRecord> mIp4AddrRecord;
+        uint16_t             mNameOffset;
     };
 
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@@ -1354,6 +1541,7 @@ private:
         void ProcessTxtRecord(const Name &aName, const ResourceRecord &aRecord, uint16_t aRecordOffset);
         void ProcessAaaaRecord(const Name &aName, const ResourceRecord &aRecord, uint16_t aRecordOffset);
         void ProcessARecord(const Name &aName, const ResourceRecord &aRecord, uint16_t aRecordOffset);
+        void ProcessOtherRecord(const Name &aName, const ResourceRecord &aRecord, uint16_t aRecordOffset);
 
         RxMessage            *mNext;
         TimeMilli             mRxTime;
@@ -1480,12 +1668,14 @@ private:
         bool Matches(SrvCallback aCallback) const { return mSharedCallback.mSrv == aCallback; }
         bool Matches(TxtCallback aCallback) const { return mSharedCallback.mTxt == aCallback; }
         bool Matches(AddressCallback aCallback) const { return mSharedCallback.mAddress == aCallback; }
+        bool Matches(RecordCallback aCallback) const { return mSharedCallback.mRecord == aCallback; }
         bool Matches(EmptyChecker) const { return (mSharedCallback.mSrv == nullptr); }
 
         void Invoke(Instance &aInstance, const BrowseResult &aResult) const;
         void Invoke(Instance &aInstance, const SrvResult &aResult) const;
         void Invoke(Instance &aInstance, const TxtResult &aResult) const;
         void Invoke(Instance &aInstance, const AddressResult &aResult) const;
+        void Invoke(Instance &aInstance, const RecordResult &aResult) const;
 
         void ClearCallback(void) { mSharedCallback.Clear(); }
 
@@ -1496,6 +1686,7 @@ private:
             explicit SharedCallback(SrvCallback aCallback) { mSrv = aCallback; }
             explicit SharedCallback(TxtCallback aCallback) { mTxt = aCallback; }
             explicit SharedCallback(AddressCallback aCallback) { mAddress = aCallback; }
+            explicit SharedCallback(RecordCallback aCallback) { mRecord = aCallback; }
 
             void Clear(void) { mBrowse = nullptr; }
 
@@ -1503,6 +1694,7 @@ private:
             SrvCallback     mSrv;
             TxtCallback     mTxt;
             AddressCallback mAddress;
+            RecordCallback  mRecord;
         };
 
         ResultCallback *mNext;
@@ -1574,6 +1766,7 @@ private:
             kTxtCache,
             kIp6AddrCache,
             kIp4AddrCache,
+            kRecordCache,
         };
 
         void  Init(Instance &aInstance, Type aType);
@@ -1589,16 +1782,18 @@ private:
         template <typename ResultType> void InvokeCallbacks(const ResultType &aResult);
 
     private:
-        static constexpr uint32_t kMinIntervalBetweenQueries = 1000; // In msec
-        static constexpr uint32_t kNonActiveDeleteTimeout    = 7 * Time::kOneMinuteInMsec;
+        static constexpr uint32_t kMinIntervalBetweenQueries          = 1000; // In msec
+        static constexpr uint32_t kNonActiveDeleteTimeout             = 7 * Time::kOneMinuteInMsec;
+        static constexpr uint32_t kNonActiveDeleteTimeoutForAnyRecord = 1 * Time::kOneSecondInMsec;
 
         typedef OwningList<ResultCallback> CallbackList;
 
-        void SetIsActive(bool aIsActive);
-        bool ShouldQuery(TimeMilli aNow);
-        void PrepareQuery(CacheContext &aContext);
-        void ProcessExpiredRecords(TimeMilli aNow);
-        void DetermineNextInitialQueryTime(void);
+        void     SetIsActive(bool aIsActive);
+        uint32_t DetermineDeleteTimeout(void) const;
+        bool     ShouldQuery(TimeMilli aNow);
+        void     PrepareQuery(CacheContext &aContext);
+        void     ProcessExpiredRecords(TimeMilli aNow);
+        void     DetermineNextInitialQueryTime(void);
 
         ResultCallback *FindCallbackMatching(const ResultCallback &aCallback);
 
@@ -1609,7 +1804,7 @@ private:
         uint8_t      mInitalQueries;          // Number initial queries sent already.
         bool         mQueryPending : 1;       // Whether a query tx request is pending.
         bool         mLastQueryTimeValid : 1; // Whether `mLastQueryTime` is valid.
-        bool         mIsActive : 1;           // Whether there is any active resolver/browser for this entry.
+        bool         mIsActive : 1;           // Whether there is any active resolver/browser/querier for this entry.
         TimeMilli    mNextQueryTime;          // The next query tx time when `mQueryPending`.
         TimeMilli    mLastQueryTime;          // The last query tx time or the upcoming tx time of first initial query.
         TimeMilli    mDeleteTime;             // The time to delete the entry when not `mIsActive`.
@@ -1884,6 +2079,80 @@ private:
 
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
+    class RecordCache : public CacheEntry, public LinkedListEntry<RecordCache>, public Heap::Allocatable<RecordCache>
+    {
+        friend class CacheEntry;
+        friend class LinkedListEntry<RecordCache>;
+        friend class Heap::Allocatable<RecordCache>;
+
+    public:
+        bool  Matches(const Name &aFullName, uint16_t aRecordType) const;
+        bool  Matches(const RecordQuerier &aQuerier) const;
+        bool  Matches(const ExpireChecker &aExpireChecker) const;
+        Error Add(const RecordQuerier &aQuerier);
+        void  Remove(const RecordQuerier &aQuerier);
+        void  ProcessResponseRecord(const Message &aMessage, const ResourceRecord &aRecord, uint16_t aRecordOffset);
+        void  CommitNewResponseEntries(void);
+#if OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
+        void CopyInfoTo(RecordQuerier &aQuerier, CacheInfo &aInfo) const;
+#endif
+
+    private:
+        struct NewRecordEntry : public LinkedListEntry<NewRecordEntry>, public Heap::Allocatable<NewRecordEntry>
+        {
+            NewRecordEntry(const ResourceRecord &aRecord, Heap::Data &aData);
+
+            bool Matches(uint16_t aType) const;
+            bool Matches(uint16_t aType, const Heap::Data &aData) const;
+
+            NewRecordEntry *mNext;
+            bool            mCacheFlush;
+            uint16_t        mType;
+            uint32_t        mTtl;
+            Heap::Data      mData;
+        };
+
+        struct RecordEntry : public LinkedListEntry<RecordEntry>, public Heap::Allocatable<RecordEntry>
+        {
+            explicit RecordEntry(NewRecordEntry &aNewEntry);
+
+            bool     Matches(uint16_t aType) const;
+            bool     Matches(uint16_t aType, const Heap::Data &aData) const;
+            bool     Matches(const ExpireChecker &aExpireChecker) const;
+            bool     Matches(EmptyChecker aChecker) const;
+            uint32_t GetTtl(void) const { return mRecord.GetTtl(); }
+
+            RecordEntry    *mNext;
+            uint16_t        mType;
+            Heap::Data      mData;
+            CacheRecordInfo mRecord;
+        };
+
+        // Called by base class `CacheEntry`
+        void PrepareQueryQuestion(TxMessage &aQuery);
+        void UpdateRecordStateAfterQuery(TimeMilli aNow);
+        void DetermineRecordFireTime(void);
+        void ProcessExpiredRecords(TimeMilli aNow);
+        void ReportResultsTo(ResultCallback &aCallback) const;
+
+        Error Init(Instance &aInstance, const RecordQuerier &aQuerier);
+        void  CommitNewEntriesForType(uint16_t aRecordType);
+        void  AppendNameTo(TxMessage &aTxMessage, Section aSection);
+        void  PreareResultFor(uint16_t aType, const Heap::Data &aData, uint32_t aTtl, RecordResult &aResult) const;
+        void  PrepareResultAndInvokeCallbacks(const NewRecordEntry &aNewEntry);
+        void  PrepareResultAndInvokeCallbacks(const RecordEntry &aEntry);
+        void  PrepareResultAndInvokeCallbacks(uint16_t aType, const Heap::Data &aData, uint32_t aTtl);
+
+        RecordCache               *mNext;
+        Heap::String               mFirstLabel;
+        Heap::String               mNextLabels;
+        uint16_t                   mRecordType;
+        OwningList<NewRecordEntry> mNewEntries;
+        OwningList<RecordEntry>    mCommittedEntries;
+    };
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
 #if OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
 
     class EntryIterator : public Iterator, public InstanceLocator, public Heap::Allocatable<EntryIterator>
@@ -1895,11 +2164,13 @@ private:
         Error GetNextHost(Host &aHost, EntryState &aState);
         Error GetNextService(Service &aService, EntryState &aState);
         Error GetNextKey(Key &aKey, EntryState &aState);
+        Error GetNextLocalHostAddress(LocalHostAddress &aAddress);
         Error GetNextBrowser(Browser &aBrowser, CacheInfo &aInfo);
         Error GetNextSrvResolver(SrvResolver &aResolver, CacheInfo &aInfo);
         Error GetNextTxtResolver(TxtResolver &aResolver, CacheInfo &aInfo);
         Error GetNextIp6AddressResolver(AddressResolver &aResolver, CacheInfo &aInfo);
         Error GetNextIp4AddressResolver(AddressResolver &aResolver, CacheInfo &aInfo);
+        Error GetNextRecordQuerier(RecordQuerier &aQuerier, CacheInfo &aInfo);
 
     private:
         static constexpr uint16_t kArrayCapacityIncrement = 32;
@@ -1911,11 +2182,13 @@ private:
             kService,
             kHostKey,
             kServiceKey,
+            kLocalHostAddress,
             kBrowser,
             kSrvResolver,
             kTxtResolver,
             kIp6AddrResolver,
             kIp4AddrResolver,
+            kRecordQuerier,
         };
 
         explicit EntryIterator(Instance &aInstance);
@@ -1926,11 +2199,13 @@ private:
         {
             const HostEntry    *mHostEntry;
             const ServiceEntry *mServiceEntry;
+            uint16_t            mLocalHostAddrIndex;
             const BrowseCache  *mBrowseCache;
             const SrvCache     *mSrvCache;
             const TxtCache     *mTxtCache;
             const Ip6AddrCache *mIp6AddrCache;
             const Ip4AddrCache *mIp4AddrCache;
+            const RecordCache  *mRecordCache;
         };
 
         Heap::Array<const char *, kArrayCapacityIncrement> mSubTypeArray;
@@ -1951,6 +2226,9 @@ private:
     template <typename CacheType, typename BrowserResolverType>
     Error Stop(const BrowserResolverType &aBrowserOrResolver);
 
+    void      AfterInstanceInit(void);
+    void      HandleHostAddressEvent(const Ip6::Address &aAddress, bool aAdded, uint32_t aInfraIfIndex);
+    void      HandleHostAddressRemoveAll(uint32_t aInfraIfIndex);
     void      InvokeConflictCallback(const char *aName, const char *aServiceType);
     void      HandleMessage(Message &aMessage, bool aIsUnicast, const AddressInfo &aSenderAddress);
     void      AddPassiveSrvTxtCache(const char *aServiceInstance, const char *aServiceType);
@@ -1970,7 +2248,6 @@ private:
     static void     UpdateCacheFlushFlagIn(ResourceRecord &aResourceRecord,
                                            Section         aSection,
                                            bool            aIsLegacyUnicast = false);
-    static void     UpdateRecordLengthInMessage(ResourceRecord &aRecord, Message &aMessage, uint16_t aOffset);
     static void     UpdateCompressOffset(uint16_t &aOffset, uint16_t aNewOffse);
     static bool     QuestionMatches(uint16_t aQuestionRrType, uint16_t aRrType);
     static bool     RrClassIsInternetOrAny(uint16_t aRrClass);
@@ -1990,6 +2267,7 @@ private:
     bool                     mIsQuestionUnicastAllowed;
     uint16_t                 mMaxMessageSize;
     uint32_t                 mInfraIfIndex;
+    LocalHost                mLocalHost;
     OwningList<HostEntry>    mHostEntries;
     OwningList<ServiceEntry> mServiceEntries;
     OwningList<ServiceType>  mServiceTypes;
@@ -2005,6 +2283,7 @@ private:
     OwningList<TxtCache>     mTxtCacheList;
     OwningList<Ip6AddrCache> mIp6AddrCacheList;
     OwningList<Ip4AddrCache> mIp4AddrCacheList;
+    OwningList<RecordCache>  mRecordCacheList;
     TimeMilli                mNextQueryTxTime;
     CacheTimer               mCacheTimer;
     CacheTask                mCacheTask;
@@ -2040,6 +2319,11 @@ template <> inline OwningList<Core::Ip4AddrCache> &Core::GetCacheList<Core::Ip4A
     return mIp4AddrCacheList;
 }
 
+template <> inline OwningList<Core::RecordCache> &Core::GetCacheList<Core::RecordCache>(void)
+{
+    return mRecordCacheList;
+}
+
 } // namespace Multicast
 } // namespace Dns
 
diff --git a/src/core/net/nd6.cpp b/src/core/net/nd6.cpp
index 3e55126fd..febd9f39d 100644
--- a/src/core/net/nd6.cpp
+++ b/src/core/net/nd6.cpp
@@ -182,6 +182,24 @@ void RaFlagsExtOption::Init(void)
     OT_UNUSED_VARIABLE(mFlags);
 }
 
+//----------------------------------------------------------------------------------------------------------------------
+// RouteInfoOption
+
+void RecursiveDnsServerOption::Init(void)
+{
+    OT_UNUSED_VARIABLE(mReserved);
+
+    Clear();
+    SetType(kTypeRecursiveDnsServer);
+}
+
+uint8_t RecursiveDnsServerOption::OptionLengthFor(uint8_t aNumAddresses)
+{
+    uint16_t size = sizeof(RecursiveDnsServerOption) + aNumAddresses * sizeof(Address);
+
+    return ClampToUint8(DivideAndRoundUp(size, kLengthUnit));
+}
+
 //----------------------------------------------------------------------------------------------------------------------
 // RouterAdver::Header
 
@@ -314,6 +332,26 @@ exit:
     return error;
 }
 
+Error RouterAdvert::TxMessage::AppendRecursiveDnsServerOption(const Address *aAddresses,
+                                                              uint8_t        aNumAddresses,
+                                                              uint32_t       aLifetime)
+{
+    Error                     error = kErrorNone;
+    RecursiveDnsServerOption *rdnss;
+    uint8_t                   optionLength = RecursiveDnsServerOption::OptionLengthFor(aNumAddresses);
+
+    rdnss = static_cast<RecursiveDnsServerOption *>(AppendOption(Option::kLengthUnit * optionLength));
+    VerifyOrExit(rdnss != nullptr, error = kErrorNoBufs);
+
+    rdnss->Init();
+    rdnss->SetLength(optionLength);
+    rdnss->SetLifetime(aLifetime);
+    memcpy(rdnss->GetAddresses(), aAddresses, aNumAddresses * sizeof(Address));
+
+exit:
+    return error;
+}
+
 //----------------------------------------------------------------------------------------------------------------------
 // RouterSolicitHeader
 
diff --git a/src/core/net/nd6.hpp b/src/core/net/nd6.hpp
index c16421ce4..8ff0899a3 100644
--- a/src/core/net/nd6.hpp
+++ b/src/core/net/nd6.hpp
@@ -78,11 +78,12 @@ class Option
 public:
     enum Type : uint8_t
     {
-        kSourceLinkLayerAddr  = 1,  ///< Source Link Layer Address Option.
-        kTargetLinkLayerAddr  = 2,  ///< Target Link Layer Address Option.
-        kTypePrefixInfo       = 3,  ///< Prefix Information Option.
-        kTypeRouteInfo        = 24, ///< Route Information Option.
-        kTypeRaFlagsExtension = 26, ///< RA Flags Extension Option.
+        kSourceLinkLayerAddr    = 1,  ///< Source Link Layer Address Option.
+        kTargetLinkLayerAddr    = 2,  ///< Target Link Layer Address Option.
+        kTypePrefixInfo         = 3,  ///< Prefix Information Option.
+        kTypeRouteInfo          = 24, ///< Route Information Option.
+        kTypeRecursiveDnsServer = 25, ///< Recursive DNS Server (RDNSS) Option.
+        kTypeRaFlagsExtension   = 26, ///< RA Flags Extension Option.
     };
 
     static constexpr uint16_t kLengthUnit = 8; ///< The unit of length in octets.
@@ -488,6 +489,116 @@ private:
 
 static_assert(sizeof(RaFlagsExtOption) == 8, "invalid RaFlagsExtOption structure");
 
+/**
+ * Represents the Recursive DNS Server (RDNSS) Option.
+ *
+ * See section 5.1 of RFC 8106 [https://datatracker.ietf.org/doc/html/rfc8106#section-5.1].
+ */
+OT_TOOL_PACKED_BEGIN
+class RecursiveDnsServerOption : public Option, private Clearable<RecursiveDnsServerOption>
+{
+    friend class Clearable<RecursiveDnsServerOption>;
+
+public:
+    static constexpr uint16_t kMinSize = kLengthUnit;             ///< Minimum size (in bytes) of a RDNSS Option.
+    static constexpr Type     kType    = kTypeRecursiveDnsServer; ///< Route Information Option Type.
+
+    /**
+     * Initializes the option setting the type and clearing (setting to zero) all other fields.
+     */
+    void Init(void);
+
+    /**
+     * Tells whether this option is valid.
+     *
+     * @returns  A boolean indicates whether this option is valid.
+     */
+    bool IsValid(void) const { return (GetLength() > 0); }
+
+    /**
+     * Sets the Lifetime field.
+     *
+     * @param[in]  aLifetime  The lifetime in seconds.
+     */
+    void SetLifetime(uint32_t aLifetime) { mLifetime = BigEndian::HostSwap32(aLifetime); }
+
+    /**
+     * Gets the Lifetime fields
+     *
+     * @returns  The Lifetime in seconds.
+     */
+    uint32_t GetLifetime(void) const { return BigEndian::HostSwap32(mLifetime); }
+
+    /**
+     * Gets the numbers of IPv6 addresses.
+     *
+     * @returns Number of IPv6 addresses.
+     */
+    uint8_t GetNumAddresses(void) const { return IsValid() ? (GetLength() - 1) / 2 : 0; }
+
+    /**
+     * Returns a pointer to array of IPv6 addresses of DNS server.
+     *
+     * @returns A pointer to the array of IPv6 addresses.
+     */
+    const Address *GetAddresses(void) const
+    {
+        return reinterpret_cast<const Address *>(reinterpret_cast<const uint8_t *>(this) + sizeof(*this));
+    }
+
+    /**
+     * Returns a pointer to array of IPv6 addresses of DNS server.
+     *
+     * @returns A pointer to the array of IPv6 addresses.
+     */
+    Address *GetAddresses(void) { return AsNonConst(AsConst(this)->GetAddresses()); }
+
+    /**
+     * Returns the IPv6 address at a given index.
+     *
+     * Caller MUST ensure that @p aIndex is valid and smaller than `GetNumberOfAddresses()`. Otherwise the behavior
+     * of this method is undefined.
+     *
+     * @param[in] aIndex   The index.
+     *
+     * @returns The IPv6 address at @p aIndex.
+     */
+    const Address &GetAddressAt(uint8_t aIndex) const { return GetAddresses()[aIndex]; }
+
+    /**
+     * Calculates the option length for a given number of IPv6 addresses.
+     *
+     * @param[in] aNumAddresses   Number of IPv6 addresses
+     *
+     * @returns The option length (in unit of 8 octets) for @p aNumAddresses.
+     */
+    static uint8_t OptionLengthFor(uint8_t aNumAddresses);
+
+    RecursiveDnsServerOption(void) = delete;
+
+private:
+    // RDNSS Option
+    //
+    //   0                   1                   2                   3
+    //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+    //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    //  |     Type      |     Length    |           Reserved            |
+    //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    //  |                           Lifetime                            |
+    //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    //  |                                                               |
+    //  :            Addresses of IPv6 Recursive DNS Servers            :
+    //  |                                                               |
+    //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+    uint16_t mReserved;
+    uint32_t mLifetime;
+    // Followed by IPv6 Addresses of DNS servers (variable length).
+
+} OT_TOOL_PACKED_END;
+
+static_assert(sizeof(RecursiveDnsServerOption) == 8, "invalid RecursiveDnsServerOption structure");
+
 /**
  * Defines the ND6 Tx Message.
  */
@@ -811,6 +922,18 @@ public:
          */
         Error AppendRouteInfoOption(const Prefix &aPrefix, uint32_t aRouteLifetime, RoutePreference aPreference);
 
+        /**
+         * Append a Recursive DNS Server Option to the RA message.
+         *
+         * @param[in] aAddresses     A pointer to an array of IPv6 addresses.
+         * @param[in] aNumAddresses  Number of addresses in @p aAddresses array.
+         * @param[in] aLifetime      The lifetime in seconds.
+         *
+         * @retval kErrorNone    Option is appended successfully.
+         * @retval kErrorNoBufs  Insufficient available buffers to grow the message.
+         */
+        Error AppendRecursiveDnsServerOption(const Address *aAddresses, uint8_t aNumAddresses, uint32_t aLifetime);
+
         /**
          * Indicates whether or not the received RA message contains any options.
          *
diff --git a/src/core/net/nd_agent.cpp b/src/core/net/nd_agent.cpp
index 392b50c7d..d6b26042f 100644
--- a/src/core/net/nd_agent.cpp
+++ b/src/core/net/nd_agent.cpp
@@ -43,7 +43,7 @@ namespace NeighborDiscovery {
 void Agent::UpdateService(void)
 {
     Error                           error;
-    uint16_t                        rloc16 = Get<Mle::MleRouter>().GetRloc16();
+    uint16_t                        rloc16 = Get<Mle::Mle>().GetRloc16();
     NetworkData::Iterator           iterator;
     NetworkData::OnMeshPrefixConfig config;
     Lowpan::Context                 lowpanContext;
@@ -99,7 +99,7 @@ void Agent::UpdateService(void)
             uint16_t aloc16 = Mle::kAloc16NeighborDiscoveryAgentStart + lowpanContext.mContextId - 1;
 
             mAloc.InitAsThreadOrigin();
-            mAloc.GetAddress().SetToAnycastLocator(Get<Mle::MleRouter>().GetMeshLocalPrefix(), aloc16);
+            mAloc.GetAddress().SetToAnycastLocator(Get<Mle::Mle>().GetMeshLocalPrefix(), aloc16);
             mAloc.mMeshLocal = true;
             Get<ThreadNetif>().AddUnicastAddress(mAloc);
             ExitNow();
diff --git a/src/core/net/sntp_client.hpp b/src/core/net/sntp_client.hpp
index 103089fbe..21fbbd588 100644
--- a/src/core/net/sntp_client.hpp
+++ b/src/core/net/sntp_client.hpp
@@ -134,7 +134,7 @@ private:
         uint8_t GetFlags(void) const { return mFlags; }
         void    SetFlags(uint8_t aFlags) { mFlags = aFlags; }
 
-        Mode GetMode(void) const { return static_cast<Mode>((mFlags & kModeMask) >> kModeOffset); }
+        Mode GetMode(void) const { return static_cast<Mode>(ReadBits<uint8_t, kModeMask>(mFlags)); }
 
         uint8_t GetStratum(void) const { return mStratum; }
         void    SetStratum(uint8_t aStratum) { mStratum = aStratum; }
diff --git a/src/core/net/srp_client.cpp b/src/core/net/srp_client.cpp
index 121a29417..b9aba373b 100644
--- a/src/core/net/srp_client.cpp
+++ b/src/core/net/srp_client.cpp
@@ -1400,7 +1400,7 @@ Error Client::AppendServiceInstruction(Service &aService, MsgInfo &aInfo)
     SuccessOrExit(error = Dns::Name::AppendLabel(aService.GetInstanceName(), *aInfo.mMessage));
     SuccessOrExit(error = Dns::Name::AppendPointerLabel(serviceNameOffset, *aInfo.mMessage));
 
-    UpdateRecordLengthInMessage(rr, offset, *aInfo.mMessage);
+    Dns::ResourceRecord::UpdateRecordLengthInMessage(*aInfo.mMessage, offset);
     aInfo.mRecordCount++;
 
     if (aService.HasSubType() && !removing)
@@ -1430,7 +1430,7 @@ Error Client::AppendServiceInstruction(Service &aService, MsgInfo &aInfo)
             SuccessOrExit(error = aInfo.mMessage->Append(rr));
 
             SuccessOrExit(error = Dns::Name::AppendPointerLabel(instanceNameOffset, *aInfo.mMessage));
-            UpdateRecordLengthInMessage(rr, offset, *aInfo.mMessage);
+            Dns::ResourceRecord::UpdateRecordLengthInMessage(*aInfo.mMessage, offset);
             aInfo.mRecordCount++;
         }
     }
@@ -1457,7 +1457,7 @@ Error Client::AppendServiceInstruction(Service &aService, MsgInfo &aInfo)
     offset = aInfo.mMessage->GetLength();
     SuccessOrExit(error = aInfo.mMessage->Append(srv));
     SuccessOrExit(error = AppendHostName(aInfo));
-    UpdateRecordLengthInMessage(srv, offset, *aInfo.mMessage);
+    Dns::ResourceRecord::UpdateRecordLengthInMessage(*aInfo.mMessage, offset);
     aInfo.mRecordCount++;
 
     // TXT RR
@@ -1468,7 +1468,7 @@ Error Client::AppendServiceInstruction(Service &aService, MsgInfo &aInfo)
     SuccessOrExit(error = aInfo.mMessage->Append(rr));
     SuccessOrExit(
         error = Dns::TxtEntry::AppendEntries(aService.GetTxtEntries(), aService.GetNumTxtEntries(), *aInfo.mMessage));
-    UpdateRecordLengthInMessage(rr, offset, *aInfo.mMessage);
+    Dns::ResourceRecord::UpdateRecordLengthInMessage(*aInfo.mMessage, offset);
     aInfo.mRecordCount++;
 
 #if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
@@ -1733,24 +1733,12 @@ Error Client::AppendSignature(MsgInfo &aInfo)
     SuccessOrExit(error = aInfo.mMessage->Append(sig));
     SuccessOrExit(error = AppendHostName(aInfo));
     SuccessOrExit(error = aInfo.mMessage->Append(signature));
-    UpdateRecordLengthInMessage(sig, offset, *aInfo.mMessage);
+    Dns::ResourceRecord::UpdateRecordLengthInMessage(*aInfo.mMessage, offset);
 
 exit:
     return error;
 }
 
-void Client::UpdateRecordLengthInMessage(Dns::ResourceRecord &aRecord, uint16_t aOffset, Message &aMessage) const
-{
-    // This method is used to calculate an RR DATA length and update
-    // (rewrite) it in a message. This should be called immediately
-    // after all the fields in the record are written in the message.
-    // `aOffset` gives the offset in the message to the start of the
-    // record.
-
-    aRecord.SetLength(aMessage.GetLength() - aOffset - sizeof(Dns::ResourceRecord));
-    aMessage.Write(aOffset, aRecord);
-}
-
 void Client::HandleUdpReceive(Message &aMessage, const Ip6::MessageInfo &aMessageInfo)
 {
     OT_UNUSED_VARIABLE(aMessageInfo);
diff --git a/src/core/net/srp_client.hpp b/src/core/net/srp_client.hpp
index fd5a2b3e5..fd54fd6a3 100644
--- a/src/core/net/srp_client.hpp
+++ b/src/core/net/srp_client.hpp
@@ -1028,7 +1028,6 @@ private:
     Error        AppendAaaaRecord(const Ip6::Address &aAddress, MsgInfo &aInfo) const;
     Error        AppendUpdateLeaseOptRecord(MsgInfo &aInfo);
     Error        AppendSignature(MsgInfo &aInfo);
-    void         UpdateRecordLengthInMessage(Dns::ResourceRecord &aRecord, uint16_t aOffset, Message &aMessage) const;
     void         HandleUdpReceive(Message &aMessage, const Ip6::MessageInfo &aMessageInfo);
     void         ProcessResponse(Message &aMessage);
     bool         IsResponseMessageIdValid(uint16_t aId) const;
diff --git a/src/core/net/tcp6.cpp b/src/core/net/tcp6.cpp
index c5cd51606..671ad6259 100644
--- a/src/core/net/tcp6.cpp
+++ b/src/core/net/tcp6.cpp
@@ -1089,13 +1089,9 @@ void tcplp_sys_connection_lost(struct tcpcb *aTcb, uint8_t aErrNum)
 
 void tcplp_sys_on_state_change(struct tcpcb *aTcb, int aNewState)
 {
-    if (aNewState == TCP6S_CLOSED)
-    {
-        /* Re-initialize the TCB. */
-        cbuf_pop(&aTcb->recvbuf, cbuf_used_space(&aTcb->recvbuf));
-        aTcb->accepted_from = nullptr;
-        initialize_tcb(aTcb);
-    }
+    OT_UNUSED_VARIABLE(aTcb);
+    OT_UNUSED_VARIABLE(aNewState);
+
     /* Any adaptive changes to the sleep interval would go here. */
 }
 
diff --git a/src/core/net/udp6.cpp b/src/core/net/udp6.cpp
index 4295217ea..ab5eedda9 100644
--- a/src/core/net/udp6.cpp
+++ b/src/core/net/udp6.cpp
@@ -46,7 +46,14 @@ bool Udp::SocketHandle::Matches(const MessageInfo &aMessageInfo) const
     bool matches = false;
 
 #if OPENTHREAD_FTD && OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE
-    VerifyOrExit(IsBackbone() == aMessageInfo.IsHostInterface());
+    if (aMessageInfo.IsHostInterface())
+    {
+        VerifyOrExit(IsBackbone() || (GetNetifId() == kNetifUnspecified));
+    }
+    else
+    {
+        VerifyOrExit(!IsBackbone());
+    }
 #endif
 
     VerifyOrExit(GetSockName().mPort == aMessageInfo.GetSockPort());
diff --git a/src/core/radio.cmake b/src/core/radio.cmake
index a41605202..001e54b8b 100644
--- a/src/core/radio.cmake
+++ b/src/core/radio.cmake
@@ -37,6 +37,7 @@ target_compile_definitions(openthread-radio PRIVATE
 
 target_compile_options(openthread-radio PRIVATE
     ${OT_CFLAGS}
+    -Wundef
 )
 
 target_include_directories(openthread-radio PUBLIC ${OT_PUBLIC_INCLUDES} PRIVATE ${COMMON_INCLUDES})
diff --git a/src/core/radio/ble_secure.cpp b/src/core/radio/ble_secure.cpp
index 719085d7b..392b4a2ea 100644
--- a/src/core/radio/ble_secure.cpp
+++ b/src/core/radio/ble_secure.cpp
@@ -158,7 +158,7 @@ void BleSecure::Disconnect(void)
     if (mBleState == kConnected)
     {
         mBleState = kAdvertising;
-        IgnoreReturnValue(otPlatBleGapDisconnect(&GetInstance()));
+        IgnoreError(otPlatBleGapDisconnect(&GetInstance()));
     }
 
     mConnectCallback.InvokeIfSet(&GetInstance(), false, false);
@@ -186,8 +186,8 @@ Error BleSecure::SendMessage(ot::Message &aMessage)
     SuccessOrExit(error = mSendMessage->AppendBytesFromMessage(aMessage, 0, aMessage.GetLength()));
     SuccessOrExit(error = Flush());
 
-exit:
     aMessage.Free();
+exit:
     return error;
 }
 
@@ -234,17 +234,45 @@ exit:
 
 Error BleSecure::Flush(void)
 {
-    Error error = kErrorNone;
+    Error        error   = kErrorNone;
+    ot::Message *message = nullptr;
+    uint16_t     length;
 
+    VerifyOrExit(mSendMessage != nullptr);
     VerifyOrExit(IsConnected(), error = kErrorInvalidState);
-    VerifyOrExit(mSendMessage->GetLength() != 0, error = kErrorNone);
+    length = mSendMessage->GetLength();
 
+    // Split send buffer in chunks which can later be processed by mTls.Send(..)
+    while (length > kTlsDataMaxSize)
+    {
+        VerifyOrExit((message = Get<MessagePool>().Allocate(Message::kTypeBle, 0)) != nullptr, error = kErrorNoBufs);
+        SuccessOrExit(error = message->AppendBytesFromMessage(*mSendMessage, 0, kTlsDataMaxSize));
+
+        // We accept an expensive copy operation in favor of optimal buffer usage for long messages
+        mSendMessage->WriteBytesFromMessage(0, *mSendMessage, kTlsDataMaxSize, length - kTlsDataMaxSize);
+        length -= kTlsDataMaxSize;
+
+        // Should never fail since we are decreasing the length of the message
+        SuccessOrAssert(error = mSendMessage->SetLength(length));
+        mTransmitQueue.Enqueue(*message);
+        mTransmitTask.Post();
+        message = nullptr;
+    }
+
+    VerifyOrExit(length != 0, error = kErrorNone);
     mTransmitQueue.Enqueue(*mSendMessage);
     mTransmitTask.Post();
-
     mSendMessage = nullptr;
 
 exit:
+    FreeMessage(message);
+
+    if (mSendMessage != nullptr)
+    {
+        mSendMessage->Free();
+        mSendMessage = nullptr;
+    }
+
     return error;
 }
 
@@ -275,7 +303,7 @@ void BleSecure::HandleBleConnected(uint16_t aConnectionId)
 
     mBleState = kConnected;
 
-    IgnoreReturnValue(otPlatBleGattMtuGet(&GetInstance(), &mMtuSize));
+    IgnoreError(otPlatBleGattMtuGet(&GetInstance(), &mMtuSize));
 
     mConnectCallback.InvokeIfSet(&GetInstance(), IsConnected(), true);
 }
@@ -335,6 +363,8 @@ void BleSecure::HandleTlsConnectEvent(MeshCoP::Tls::ConnectEvent aEvent)
     {
         FreeMessage(mReceivedMessage);
         mReceivedMessage = nullptr;
+        FreeMessage(mSendMessage);
+        mSendMessage = nullptr;
 
         if (mTcatAgent.IsEnabled())
         {
@@ -361,7 +391,7 @@ void BleSecure::HandleTlsReceive(uint8_t *aBuf, uint16_t aLength)
     {
         SuccessOrExit(mReceivedMessage->AppendBytes(aBuf, aLength));
         mReceiveCallback.InvokeIfSet(&GetInstance(), mReceivedMessage, 0, OT_TCAT_APPLICATION_PROTOCOL_NONE, "");
-        IgnoreReturnValue(mReceivedMessage->SetLength(0));
+        IgnoreError(mReceivedMessage->SetLength(0));
     }
     else
     {
@@ -388,7 +418,7 @@ void BleSecure::HandleTlsReceive(uint8_t *aBuf, uint16_t aLength)
                 }
             }
 
-            IgnoreReturnValue(mReceivedMessage->Read(0, tlv));
+            IgnoreError(mReceivedMessage->Read(0, tlv));
 
             if (tlv.IsExtended())
             {
@@ -400,7 +430,7 @@ void BleSecure::HandleTlsReceive(uint8_t *aBuf, uint16_t aLength)
                     continue;
                 }
 
-                IgnoreReturnValue(mReceivedMessage->Read(0, extTlv));
+                IgnoreError(mReceivedMessage->Read(0, extTlv));
                 requiredBytes = extTlv.GetSize();
                 offset        = sizeof(extTlv);
             }
@@ -419,18 +449,19 @@ void BleSecure::HandleTlsReceive(uint8_t *aBuf, uint16_t aLength)
 
             if (mTcatAgent.IsEnabled())
             {
-                ot::Message *message;
-                Error        error = kErrorNone;
+                Error error = kErrorNone;
 
-                message = Get<MessagePool>().Allocate(Message::kTypeBle);
-                VerifyOrExit(message != nullptr, error = kErrorNoBufs);
+                IgnoreError(Flush());
 
-                error = mTcatAgent.HandleSingleTlv(*mReceivedMessage, *message);
-                if (message->GetLength() != 0)
+                if (mSendMessage == nullptr)
                 {
-                    IgnoreReturnValue(SendMessage(*message));
+                    mSendMessage = Get<MessagePool>().Allocate(Message::kTypeBle);
+                    VerifyOrExit(mSendMessage != nullptr, error = kErrorNoBufs);
                 }
 
+                error = mTcatAgent.HandleSingleTlv(*mReceivedMessage, *mSendMessage);
+                IgnoreError(Flush());
+
                 if (error == kErrorAbort)
                 {
                     LogInfo("Disconnecting TCAT client.");
@@ -507,7 +538,7 @@ Error BleSecure::HandleTransport(ot::Message &aMessage)
             packet.mLength = kPacketBufferSize;
         }
 
-        IgnoreReturnValue(aMessage.Read(offset, mPacketBuffer, packet.mLength));
+        IgnoreError(aMessage.Read(offset, mPacketBuffer, packet.mLength));
         packet.mValue = mPacketBuffer;
         packet.mPower = OT_BLE_DEFAULT_POWER;
 
@@ -530,7 +561,7 @@ void otPlatBleGattServerOnWriteRequest(otInstance *aInstance, uint16_t aHandle,
     OT_UNUSED_VARIABLE(aHandle); // Only a single handle is expected for RX
 
     VerifyOrExit(aPacket != nullptr);
-    IgnoreReturnValue(AsCoreType(aInstance).Get<Ble::BleSecure>().HandleBleReceive(aPacket->mValue, aPacket->mLength));
+    IgnoreError(AsCoreType(aInstance).Get<Ble::BleSecure>().HandleBleReceive(aPacket->mValue, aPacket->mLength));
 exit:
     return;
 }
@@ -547,7 +578,7 @@ void otPlatBleGapOnDisconnected(otInstance *aInstance, uint16_t aConnectionId)
 
 void otPlatBleGattOnMtuUpdate(otInstance *aInstance, uint16_t aMtu)
 {
-    IgnoreReturnValue(AsCoreType(aInstance).Get<Ble::BleSecure>().HandleBleMtuUpdate(aMtu));
+    IgnoreError(AsCoreType(aInstance).Get<Ble::BleSecure>().HandleBleMtuUpdate(aMtu));
 }
 
 #endif // OPENTHREAD_CONFIG_BLE_TCAT_ENABLE
diff --git a/src/core/radio/ble_secure.hpp b/src/core/radio/ble_secure.hpp
index 6d48482fb..978129f7f 100644
--- a/src/core/radio/ble_secure.hpp
+++ b/src/core/radio/ble_secure.hpp
@@ -287,7 +287,8 @@ private:
     static constexpr uint8_t  kInitialMtuSize   = 23; // ATT_MTU
     static constexpr uint8_t  kGattOverhead     = 3;  // BLE GATT payload fits MTU size - 3 bytes
     static constexpr uint8_t  kPacketBufferSize = OT_BLE_ATT_MTU_MAX - kGattOverhead;
-    static constexpr uint16_t kTxBleHandle      = 0; // Characteristics Handle for TX (not used)
+    static constexpr uint16_t kTxBleHandle      = 0;   // Characteristics Handle for TX (not used)
+    static constexpr uint16_t kTlsDataMaxSize   = 800; // Maximum size of data chunks sent with mTls.Send(..)
 
     static void HandleTlsConnectEvent(MeshCoP::Tls::ConnectEvent aEvent, void *aContext);
     void        HandleTlsConnectEvent(MeshCoP::Tls::ConnectEvent aEvent);
diff --git a/src/core/radio/max_power_table.hpp b/src/core/radio/max_power_table.hpp
index c480754fe..7b35b230c 100644
--- a/src/core/radio/max_power_table.hpp
+++ b/src/core/radio/max_power_table.hpp
@@ -68,7 +68,7 @@ public:
         {
             if (mPowerTable[i - Radio::kChannelMin] != OT_RADIO_POWER_INVALID)
             {
-                channelMask |= (1 << i);
+                SetBit<uint32_t>(channelMask, i);
             }
         }
 
diff --git a/src/core/radio/trel_interface.cpp b/src/core/radio/trel_interface.cpp
index 71f16f3fa..711047758 100644
--- a/src/core/radio/trel_interface.cpp
+++ b/src/core/radio/trel_interface.cpp
@@ -41,15 +41,11 @@ namespace Trel {
 
 RegisterLogModule("TrelInterface");
 
-const char Interface::kTxtRecordExtAddressKey[] = "xa";
-const char Interface::kTxtRecordExtPanIdKey[]   = "xp";
-
 Interface::Interface(Instance &aInstance)
     : InstanceLocator(aInstance)
     , mInitialized(false)
     , mEnabled(false)
     , mFiltered(false)
-    , mRegisterServiceTask(aInstance)
 {
 }
 
@@ -86,9 +82,9 @@ void Interface::Enable(void)
     VerifyOrExit(mInitialized);
 
     otPlatTrelEnable(&GetInstance(), &mUdpPort);
+    Get<PeerDiscoverer>().Start();
 
     LogInfo("Enabled interface, local port:%u", mUdpPort);
-    mRegisterServiceTask.Post();
 
 exit:
     return;
@@ -102,256 +98,14 @@ void Interface::Disable(void)
     VerifyOrExit(mInitialized);
 
     otPlatTrelDisable(&GetInstance());
-    mPeerTable.Clear();
-    LogDebg("Disabled interface");
-
-exit:
-    return;
-}
-
-Interface::Peer *Interface::FindPeer(const Mac::ExtAddress &aExtAddress)
-{
-    return mPeerTable.FindMatching(aExtAddress);
-}
-
-void Interface::NotifyPeerSocketAddressDifference(const Ip6::SockAddr &aPeerSockAddr, const Ip6::SockAddr &aRxSockAddr)
-{
-    otPlatTrelNotifyPeerSocketAddressDifference(&GetInstance(), &aPeerSockAddr, &aRxSockAddr);
-}
-
-void Interface::HandleExtAddressChange(void)
-{
-    VerifyOrExit(mInitialized && mEnabled);
-    LogDebg("Extended Address changed, re-registering DNS-SD service");
-    mRegisterServiceTask.Post();
-
-exit:
-    return;
-}
-
-void Interface::HandleExtPanIdChange(void)
-{
-    VerifyOrExit(mInitialized && mEnabled);
-    LogDebg("Extended PAN ID changed, re-registering DNS-SD service");
-    mRegisterServiceTask.Post();
-
-exit:
-    return;
-}
-
-void Interface::RegisterService(void)
-{
-    // TXT data consists of two entries: the length fields, the
-    // "key" string, "=" char, and binary representation of the MAC
-    // or Extended PAN ID values.
-    static constexpr uint8_t kTxtDataSize =
-        /* ExtAddr  */ sizeof(uint8_t) + sizeof(kTxtRecordExtAddressKey) - 1 + sizeof(char) + sizeof(Mac::ExtAddress) +
-        /* ExtPanId */ sizeof(uint8_t) + sizeof(kTxtRecordExtPanIdKey) - 1 + sizeof(char) +
-        sizeof(MeshCoP::ExtendedPanId);
-
-    uint8_t                        txtDataBuffer[kTxtDataSize];
-    MutableData<kWithUint16Length> txtData;
-    Dns::TxtEntry                  txtEntries[2];
-
-    VerifyOrExit(mInitialized && mEnabled);
-
-    txtEntries[0].Init(kTxtRecordExtAddressKey, Get<Mac::Mac>().GetExtAddress().m8, sizeof(Mac::ExtAddress));
-    txtEntries[1].Init(kTxtRecordExtPanIdKey, Get<MeshCoP::ExtendedPanIdManager>().GetExtPanId().m8,
-                       sizeof(MeshCoP::ExtendedPanId));
-
-    txtData.Init(txtDataBuffer, sizeof(txtDataBuffer));
-    SuccessOrAssert(Dns::TxtEntry::AppendEntries(txtEntries, GetArrayLength(txtEntries), txtData));
-
-    LogInfo("Registering DNS-SD service: port:%u, txt:\"%s=%s, %s=%s\"", mUdpPort, kTxtRecordExtAddressKey,
-            Get<Mac::Mac>().GetExtAddress().ToString().AsCString(), kTxtRecordExtPanIdKey,
-            Get<MeshCoP::ExtendedPanIdManager>().GetExtPanId().ToString().AsCString());
-
-    otPlatTrelRegisterService(&GetInstance(), mUdpPort, txtData.GetBytes(), static_cast<uint8_t>(txtData.GetLength()));
-
-exit:
-    return;
-}
-
-extern "C" void otPlatTrelHandleDiscoveredPeerInfo(otInstance *aInstance, const otPlatTrelPeerInfo *aInfo)
-{
-    Instance &instance = AsCoreType(aInstance);
-
-    VerifyOrExit(instance.IsInitialized());
-    instance.Get<Interface>().HandleDiscoveredPeerInfo(*static_cast<const Interface::Peer::Info *>(aInfo));
-
-exit:
-    return;
-}
-
-void Interface::HandleDiscoveredPeerInfo(const Peer::Info &aInfo)
-{
-    Peer                  *entry;
-    Mac::ExtAddress        extAddress;
-    MeshCoP::ExtendedPanId extPanId;
-    bool                   isNew = false;
-
-    VerifyOrExit(mInitialized && mEnabled);
-
-    SuccessOrExit(ParsePeerInfoTxtData(aInfo, extAddress, extPanId));
-
-    VerifyOrExit(extAddress != Get<Mac::Mac>().GetExtAddress());
-
-    if (aInfo.IsRemoved())
-    {
-        entry = FindPeer(extAddress);
-        VerifyOrExit(entry != nullptr);
-        RemovePeerEntry(*entry);
-        ExitNow();
-    }
-
-    // It is a new entry or an update to an existing entry. First
-    // check whether we have an existing entry that matches the same
-    // socket address, and remove it if it is associated with a
-    // different Extended MAC address. This ensures that we do not
-    // keep stale entries in the peer table.
-
-    entry = mPeerTable.FindMatching(aInfo.GetSockAddr());
-
-    if ((entry != nullptr) && !entry->Matches(extAddress))
-    {
-        RemovePeerEntry(*entry);
-        entry = nullptr;
-    }
-
-    if (entry == nullptr)
-    {
-        entry = mPeerTable.FindMatching(extAddress);
-    }
-
-    if (entry == nullptr)
-    {
-        entry = GetNewPeerEntry();
-        VerifyOrExit(entry != nullptr);
-
-        entry->SetExtAddress(extAddress);
-        isNew = true;
-    }
-
-    if (!isNew)
-    {
-        VerifyOrExit((entry->GetExtPanId() != extPanId) || (entry->GetSockAddr() != aInfo.GetSockAddr()));
-    }
-
-    entry->SetExtPanId(extPanId);
-    entry->SetSockAddr(aInfo.GetSockAddr());
+    Get<PeerDiscoverer>().Stop();
 
-    entry->Log(isNew ? "Added" : "Updated");
+    LogDebg("Disabled interface");
 
 exit:
     return;
 }
 
-Error Interface::ParsePeerInfoTxtData(const Peer::Info       &aInfo,
-                                      Mac::ExtAddress        &aExtAddress,
-                                      MeshCoP::ExtendedPanId &aExtPanId) const
-{
-    Error                   error;
-    Dns::TxtEntry           entry;
-    Dns::TxtEntry::Iterator iterator;
-    bool                    parsedExtAddress = false;
-    bool                    parsedExtPanId   = false;
-
-    aExtPanId.Clear();
-
-    iterator.Init(aInfo.GetTxtData(), aInfo.GetTxtLength());
-
-    while ((error = iterator.GetNextEntry(entry)) == kErrorNone)
-    {
-        // If the TXT data happens to have entries with key longer
-        // than `kMaxIterKeyLength`, `mKey` would be `nullptr` and full
-        // entry would be placed in `mValue`. We skip over such
-        // entries.
-        if (entry.mKey == nullptr)
-        {
-            continue;
-        }
-
-        if (StringMatch(entry.mKey, kTxtRecordExtAddressKey))
-        {
-            VerifyOrExit(!parsedExtAddress, error = kErrorParse);
-            VerifyOrExit(entry.mValueLength == sizeof(Mac::ExtAddress), error = kErrorParse);
-            aExtAddress.Set(entry.mValue);
-            parsedExtAddress = true;
-        }
-        else if (StringMatch(entry.mKey, kTxtRecordExtPanIdKey))
-        {
-            VerifyOrExit(!parsedExtPanId, error = kErrorParse);
-            VerifyOrExit(entry.mValueLength == sizeof(MeshCoP::ExtendedPanId), error = kErrorParse);
-            memcpy(aExtPanId.m8, entry.mValue, sizeof(MeshCoP::ExtendedPanId));
-            parsedExtPanId = true;
-        }
-
-        // Skip over and ignore any unknown keys.
-    }
-
-    VerifyOrExit(error == kErrorNotFound);
-    error = kErrorNone;
-
-    VerifyOrExit(parsedExtAddress && parsedExtPanId, error = kErrorParse);
-
-exit:
-    return error;
-}
-
-Interface::Peer *Interface::GetNewPeerEntry(void)
-{
-    Peer *peerEntry;
-
-    peerEntry = mPeerTable.PushBack();
-    VerifyOrExit(peerEntry == nullptr);
-
-    for (Peer &entry : mPeerTable)
-    {
-        if (entry.GetExtPanId() != Get<MeshCoP::ExtendedPanIdManager>().GetExtPanId())
-        {
-            ExitNow(peerEntry = &entry);
-        }
-    }
-
-    for (Peer &entry : mPeerTable)
-    {
-        // We skip over any existing entry in neighbor table (even if the
-        // entry is in invalid state).
-
-        if (Get<NeighborTable>().FindNeighbor(entry.GetExtAddress(), Neighbor::kInStateAny) != nullptr)
-        {
-            continue;
-        }
-
-#if OPENTHREAD_FTD
-        if (Get<NeighborTable>().FindRxOnlyNeighborRouter(entry.GetExtAddress()) != nullptr)
-        {
-            continue;
-        }
-#endif
-
-        ExitNow(peerEntry = &entry);
-    }
-
-exit:
-    return peerEntry;
-}
-
-void Interface::RemovePeerEntry(Peer &aEntry)
-{
-    aEntry.Log("Removing");
-
-    // Replace the entry being removed with the last entry (if not the
-    // last one already) and then pop the last entry from array.
-
-    if (&aEntry != mPeerTable.Back())
-    {
-        aEntry = *mPeerTable.Back();
-    }
-
-    mPeerTable.PopBack();
-}
-
 const Counters *Interface::GetCounters(void) const { return otPlatTrelGetCounters(&GetInstance()); }
 
 void Interface::ResetCounters(void) { otPlatTrelResetCounters(&GetInstance()); }
@@ -367,20 +121,20 @@ Error Interface::Send(const Packet &aPacket, bool aIsDiscovery)
     switch (aPacket.GetHeader().GetType())
     {
     case Header::kTypeBroadcast:
-        for (Peer &entry : mPeerTable)
+        for (const Peer &peer : Get<PeerTable>())
         {
-            if (!aIsDiscovery && (entry.GetExtPanId() != Get<MeshCoP::ExtendedPanIdManager>().GetExtPanId()))
+            if (!aIsDiscovery && (peer.GetExtPanId() != Get<MeshCoP::ExtendedPanIdManager>().GetExtPanId()))
             {
                 continue;
             }
 
-            otPlatTrelSend(&GetInstance(), aPacket.GetBuffer(), aPacket.GetLength(), &entry.mSockAddr);
+            otPlatTrelSend(&GetInstance(), aPacket.GetBuffer(), aPacket.GetLength(), &peer.mSockAddr);
         }
         break;
 
     case Header::kTypeUnicast:
     case Header::kTypeAck:
-        peerEntry = mPeerTable.FindMatching(aPacket.GetHeader().GetDestination());
+        peerEntry = Get<PeerTable>().FindMatching(aPacket.GetHeader().GetDestination());
         VerifyOrExit(peerEntry != nullptr, error = kErrorAbort);
         otPlatTrelSend(&GetInstance(), aPacket.GetBuffer(), aPacket.GetLength(), &peerEntry->mSockAddr);
         break;
@@ -417,26 +171,6 @@ exit:
     return;
 }
 
-const Interface::Peer *Interface::GetNextPeer(PeerIterator &aIterator) const
-{
-    const Peer *entry = mPeerTable.At(aIterator);
-
-    if (entry != nullptr)
-    {
-        aIterator++;
-    }
-
-    return entry;
-}
-
-void Interface::Peer::Log(const char *aAction) const
-{
-    OT_UNUSED_VARIABLE(aAction);
-
-    LogInfo("%s peer mac:%s, xpan:%s, %s", aAction, GetExtAddress().ToString().AsCString(),
-            GetExtPanId().ToString().AsCString(), GetSockAddr().ToString().AsCString());
-}
-
 } // namespace Trel
 } // namespace ot
 
diff --git a/src/core/radio/trel_interface.hpp b/src/core/radio/trel_interface.hpp
index c87e14897..9bdabbe79 100644
--- a/src/core/radio/trel_interface.hpp
+++ b/src/core/radio/trel_interface.hpp
@@ -41,15 +41,9 @@
 #include <openthread/trel.h>
 #include <openthread/platform/trel.h>
 
-#include "common/array.hpp"
 #include "common/locator.hpp"
-#include "common/tasklet.hpp"
-#include "common/time.hpp"
-#include "mac/mac_types.hpp"
-#include "net/ip6_address.hpp"
 #include "net/socket.hpp"
 #include "radio/trel_packet.hpp"
-#include "thread/mle_types.hpp"
 
 namespace ot {
 namespace Trel {
@@ -60,8 +54,6 @@ extern "C" void otPlatTrelHandleReceived(otInstance       *aInstance,
                                          uint8_t          *aBuffer,
                                          uint16_t          aLength,
                                          const otSockAddr *aSenderAddr);
-extern "C" void otPlatTrelHandleDiscoveredPeerInfo(otInstance *aInstance, const otPlatTrelPeerInfo *aInfo);
-
 /**
  * Represents a group of TREL counters.
  */
@@ -77,89 +69,8 @@ class Interface : public InstanceLocator
                                          uint8_t          *aBuffer,
                                          uint16_t          aLength,
                                          const otSockAddr *aSenderAddr);
-    friend void otPlatTrelHandleDiscoveredPeerInfo(otInstance *aInstance, const otPlatTrelPeerInfo *aInfo);
 
 public:
-    /**
-     * Represents information about a discovered TREL peer.
-     */
-    class Peer : public otTrelPeer
-    {
-        friend class Interface;
-        friend void otPlatTrelHandleDiscoveredPeerInfo(otInstance *aInstance, const otPlatTrelPeerInfo *aInfo);
-
-    public:
-        /**
-         * Returns the Extended MAC Address of the discovered TREL peer.
-         *
-         * @returns The Extended MAC Address of the TREL peer.
-         */
-        const Mac::ExtAddress &GetExtAddress(void) const { return static_cast<const Mac::ExtAddress &>(mExtAddress); }
-
-        /**
-         * Returns the Extended PAN Identifier of the discovered TREL peer.
-         *
-         * @returns The Extended PAN Identifier of the TREL peer.
-         */
-        const MeshCoP::ExtendedPanId &GetExtPanId(void) const
-        {
-            return static_cast<const MeshCoP::ExtendedPanId &>(mExtPanId);
-        }
-
-        /**
-         * Returns the IPv6 socket address of the discovered TREL peer.
-         *
-         * @returns The IPv6 socket address of the TREL peer.
-         */
-        const Ip6::SockAddr &GetSockAddr(void) const { return static_cast<const Ip6::SockAddr &>(mSockAddr); }
-
-        /**
-         * Set the IPv6 socket address of the discovered TREL peer.
-         *
-         * @param[in] aSockAddr   The IPv6 socket address.
-         */
-        void SetSockAddr(const Ip6::SockAddr &aSockAddr) { mSockAddr = aSockAddr; }
-
-        /**
-         * Indicates whether the peer matches a given Extended Address.
-         *
-         * @param[in] aExtAddress   A Extended Address to match with.
-         *
-         * @retval TRUE if the peer matches @p aExtAddress.
-         * @retval FALSE if the peer does not match @p aExtAddress.
-         */
-        bool Matches(const Mac::ExtAddress &aExtAddress) const { return GetExtAddress() == aExtAddress; }
-
-        /**
-         * Indicates whether the peer matches a given Socket Address.
-         *
-         * @param[in] aSockAddr   A Socket Address to match with.
-         *
-         * @retval TRUE if the peer matches @p aSockAddr.
-         * @retval FALSE if the peer does not match @p aSockAddr.
-         */
-        bool Matches(const Ip6::SockAddr &aSockAddr) const { return GetSockAddr() == aSockAddr; }
-
-    private:
-        class Info : public otPlatTrelPeerInfo
-        {
-        public:
-            bool                 IsRemoved(void) const { return mRemoved; }
-            const uint8_t       *GetTxtData(void) const { return mTxtData; }
-            uint16_t             GetTxtLength(void) const { return mTxtLength; }
-            const Ip6::SockAddr &GetSockAddr(void) const { return static_cast<const Ip6::SockAddr &>(mSockAddr); }
-        };
-
-        void SetExtAddress(const Mac::ExtAddress &aExtAddress) { mExtAddress = aExtAddress; }
-        void SetExtPanId(const MeshCoP::ExtendedPanId &aExtPanId) { mExtPanId = aExtPanId; }
-        void Log(const char *aAction) const;
-    };
-
-    /**
-     * Represents an iterator for iterating over TREL peer table entries.
-     */
-    typedef otTrelPeerIterator PeerIterator;
-
     /**
      * Enables or disables the TREL interface.
      *
@@ -193,29 +104,6 @@ public:
      */
     bool IsEnabled(void) const { return mEnabled; }
 
-    /**
-     * Initializes a peer table iterator.
-     *
-     * @param[in] aIterator   The iterator to initialize.
-     */
-    void InitIterator(PeerIterator &aIterator) const { aIterator = 0; }
-
-    /**
-     * Iterates over the peer table entries.
-     *
-     * @param[in] aIterator   The iterator. MUST be initialized.
-     *
-     * @returns A pointer to the next `Peer` entry or `nullptr` if no more entries in the table.
-     */
-    const Peer *GetNextPeer(PeerIterator &aIterator) const;
-
-    /**
-     * Returns the number of TREL peers.
-     *
-     * @returns  The number of TREL peers.
-     */
-    uint16_t GetNumberOfPeers(void) const { return mPeerTable.GetLength(); }
-
     /**
      * Sets the filter mode (enables/disables filtering).
      *
@@ -256,64 +144,21 @@ public:
      */
     uint16_t GetUdpPort(void) const { return mUdpPort; }
 
-    /**
-     * Finds the TREL peer associated with a given Extended Address.
-     *
-     * @param[in] aExtAddress  The extended address.
-     *
-     * @returns The peer associated with @ aExtAddress, or `nullptr` if not found.
-     */
-    Peer *FindPeer(const Mac::ExtAddress &aExtAddress);
-
-    /**
-     * Notifies platform that a TREL packet is received from a peer using a different socket address than the one
-     * reported earlier.
-     *
-     * @param[in] aPeerSockAddr   The previously reported peer sock addr.
-     * @param[in] aRxSockAddr     The address of received packet from the same peer.
-     */
-    void NotifyPeerSocketAddressDifference(const Ip6::SockAddr &aPeerSockAddr, const Ip6::SockAddr &aRxSockAddr);
-
 private:
-#if OPENTHREAD_CONFIG_TREL_PEER_TABLE_SIZE != 0
-    static constexpr uint16_t kPeerTableSize = OPENTHREAD_CONFIG_TREL_PEER_TABLE_SIZE;
-#else
-    static constexpr uint16_t kPeerTableExtraEntries = 32;
-    static constexpr uint16_t kPeerTableSize         = Mle::kMaxRouters + Mle::kMaxChildren + kPeerTableExtraEntries;
-#endif
-    static const char kTxtRecordExtAddressKey[];
-    static const char kTxtRecordExtPanIdKey[];
-
-    typedef Array<Peer, kPeerTableSize, uint16_t> PeerTable;
-
     explicit Interface(Instance &aInstance);
 
     // Methods used by `Trel::Link`.
     void  Init(void);
-    void  HandleExtAddressChange(void);
-    void  HandleExtPanIdChange(void);
     Error Send(const Packet &aPacket, bool aIsDiscovery = false);
 
     // Callbacks from `otPlatTrel`.
     void HandleReceived(uint8_t *aBuffer, uint16_t aLength, const Ip6::SockAddr &aSenderAddr);
-    void HandleDiscoveredPeerInfo(const Peer::Info &aInfo);
-
-    void  RegisterService(void);
-    Error ParsePeerInfoTxtData(const Peer::Info       &aInfo,
-                               Mac::ExtAddress        &aExtAddress,
-                               MeshCoP::ExtendedPanId &aExtPanId) const;
-    Peer *GetNewPeerEntry(void);
-    void  RemovePeerEntry(Peer &aEntry);
-
-    using RegisterServiceTask = TaskletIn<Interface, &Interface::RegisterService>;
 
-    bool                mInitialized : 1;
-    bool                mEnabled : 1;
-    bool                mFiltered : 1;
-    RegisterServiceTask mRegisterServiceTask;
-    uint16_t            mUdpPort;
-    Packet              mRxPacket;
-    PeerTable           mPeerTable;
+    bool     mInitialized : 1;
+    bool     mEnabled : 1;
+    bool     mFiltered : 1;
+    uint16_t mUdpPort;
+    Packet   mRxPacket;
 };
 
 } // namespace Trel
diff --git a/src/core/radio/trel_link.cpp b/src/core/radio/trel_link.cpp
index 10a356e3a..9d39a79da 100644
--- a/src/core/radio/trel_link.cpp
+++ b/src/core/radio/trel_link.cpp
@@ -50,6 +50,8 @@ Link::Link(Instance &aInstance)
     , mTxTasklet(aInstance)
     , mTimer(aInstance)
     , mInterface(aInstance)
+    , mPeerTable(aInstance)
+    , mPeerDiscoverer(aInstance)
 {
     ClearAllBytes(mTxFrame);
     ClearAllBytes(mRxFrame);
@@ -214,7 +216,7 @@ void Link::BeginTransmit(void)
     {
         uint16_t fcf = Mac::Frame::kTypeAck;
 
-        if (!Get<Mle::MleRouter>().IsRxOnWhenIdle())
+        if (!Get<Mle::Mle>().IsRxOnWhenIdle())
         {
             fcf |= kFcfFramePending;
         }
@@ -275,20 +277,20 @@ void Link::HandleTimer(void)
     // router/leader during a partition merge, so it is always treated
     // as a neighbor.
 
-    switch (Get<Mle::MleRouter>().GetRole())
+    switch (Get<Mle::Mle>().GetRole())
     {
     case Mle::kRoleDisabled:
         break;
 
     case Mle::kRoleDetached:
     case Mle::kRoleChild:
-        HandleTimer(Get<Mle::MleRouter>().GetParent());
+        HandleTimer(Get<Mle::Mle>().GetParent());
 
         OT_FALL_THROUGH;
 
     case Mle::kRoleRouter:
     case Mle::kRoleLeader:
-        HandleTimer(Get<Mle::MleRouter>().GetParentCandidate());
+        HandleTimer(Get<Mle::Mle>().GetParentCandidate());
         break;
     }
 }
@@ -343,7 +345,7 @@ void Link::ProcessReceivedPacket(Packet &aPacket, const Ip6::SockAddr &aSockAddr
     VerifyOrExit(aPacket.GetHeader().GetSource() != Get<Mac::Mac>().GetExtAddress());
 
     mRxPacketSenderAddr = aSockAddr;
-    mRxPacketPeer       = Get<Interface>().FindPeer(aPacket.GetHeader().GetSource());
+    mRxPacketPeer       = Get<PeerTable>().FindMatching(aPacket.GetHeader().GetSource());
 
     if (type != Header::kTypeBroadcast)
     {
@@ -408,7 +410,7 @@ void Link::CheckPeerAddrOnRxSuccess(PeerSockAddrUpdateMode aMode)
         mRxPacketPeer->SetSockAddr(mRxPacketSenderAddr);
     }
 
-    Get<Interface>().NotifyPeerSocketAddressDifference(prevSockAddr, mRxPacketSenderAddr);
+    mPeerDiscoverer.NotifyPeerSocketAddressDifference(prevSockAddr, mRxPacketSenderAddr);
 
 exit:
     mRxPacketPeer = nullptr;
@@ -495,7 +497,7 @@ void Link::HandleNotifierEvents(Events aEvents)
 {
     if (aEvents.Contains(kEventThreadExtPanIdChanged))
     {
-        mInterface.HandleExtPanIdChange();
+        mPeerDiscoverer.HandleExtPanIdChange();
     }
 }
 
diff --git a/src/core/radio/trel_link.hpp b/src/core/radio/trel_link.hpp
index f5ccf9857..f5bf793ce 100644
--- a/src/core/radio/trel_link.hpp
+++ b/src/core/radio/trel_link.hpp
@@ -47,6 +47,8 @@
 #include "mac/mac_types.hpp"
 #include "radio/trel_interface.hpp"
 #include "radio/trel_packet.hpp"
+#include "radio/trel_peer.hpp"
+#include "radio/trel_peer_discoverer.hpp"
 
 namespace ot {
 
@@ -104,7 +106,7 @@ public:
      * Notifies TREL radio link that device's extended MAC address has changed for it to update any
      * internal address/state.
      */
-    void HandleExtAddressChange(void) { mInterface.HandleExtAddressChange(); }
+    void HandleExtAddressChange(void) { mPeerDiscoverer.HandleExtAddressChange(); }
 
     /**
      * Enables the TREL radio link.
@@ -165,8 +167,6 @@ private:
     static constexpr uint32_t kAckWaitWindow   = 750; // (in msec)
     static constexpr uint16_t kFcfFramePending = 1 << 4;
 
-    typedef Interface::Peer Peer;
-
     enum State : uint8_t
     {
         kStateDisabled,
@@ -194,20 +194,22 @@ private:
     using TxTasklet    = TaskletIn<Link, &Link::HandleTxTasklet>;
     using TimeoutTimer = TimerMilliIn<Link, &Link::HandleTimer>;
 
-    State         mState;
-    uint8_t       mRxChannel;
-    Mac::PanId    mPanId;
-    uint32_t      mTxPacketNumber;
-    TxTasklet     mTxTasklet;
-    TimeoutTimer  mTimer;
-    Interface     mInterface;
-    Ip6::SockAddr mRxPacketSenderAddr;
-    Peer         *mRxPacketPeer;
-    Mac::RxFrame  mRxFrame;
-    Mac::TxFrame  mTxFrame;
-    uint8_t       mTxPacketBuffer[kMaxHeaderSize + kMtuSize];
-    uint8_t       mAckPacketBuffer[kMaxHeaderSize];
-    uint8_t       mAckFrameBuffer[k154AckFrameSize];
+    State          mState;
+    uint8_t        mRxChannel;
+    Mac::PanId     mPanId;
+    uint32_t       mTxPacketNumber;
+    TxTasklet      mTxTasklet;
+    TimeoutTimer   mTimer;
+    Interface      mInterface;
+    PeerTable      mPeerTable;
+    PeerDiscoverer mPeerDiscoverer;
+    Ip6::SockAddr  mRxPacketSenderAddr;
+    Peer          *mRxPacketPeer;
+    Mac::RxFrame   mRxFrame;
+    Mac::TxFrame   mTxFrame;
+    uint8_t        mTxPacketBuffer[kMaxHeaderSize + kMtuSize];
+    uint8_t        mAckPacketBuffer[kMaxHeaderSize];
+    uint8_t        mAckFrameBuffer[k154AckFrameSize];
 };
 
 /**
diff --git a/src/core/radio/trel_packet.hpp b/src/core/radio/trel_packet.hpp
index 11454db92..21d996a25 100644
--- a/src/core/radio/trel_packet.hpp
+++ b/src/core/radio/trel_packet.hpp
@@ -92,14 +92,14 @@ public:
      *
      * @returns TRUE if the version field is valid, FALSE otherwise.
      */
-    bool IsVersionValid(void) const { return (mControl & kVersionMask) == kVersion; }
+    bool IsVersionValid(void) const { return ReadBits<uint8_t, kVersionMask>(mControl) == kVersion; }
 
     /**
      * Gets the packet type.
      *
      * @returns The packet type.
      */
-    Type GetType(void) const { return static_cast<Type>(mControl & kTypeMask); }
+    Type GetType(void) const { return static_cast<Type>(ReadBits<uint8_t, kTypeMask>(mControl)); }
 
     /**
      * Gets the header length based on its type.
diff --git a/src/core/radio/trel_peer.cpp b/src/core/radio/trel_peer.cpp
new file mode 100644
index 000000000..6a56759c5
--- /dev/null
+++ b/src/core/radio/trel_peer.cpp
@@ -0,0 +1,269 @@
+/*
+ *    Copyright (c) 2025, The OpenThread Authors.
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without
+ *    modification, are permitted provided that the following conditions are met:
+ *    1. Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *    2. Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *    3. Neither the name of the copyright holder nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ *    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ *    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+ *    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ *    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ *    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ *   This file implements Thread Radio Encapsulation Link (TREL) peer.
+ */
+
+#include "trel_peer.hpp"
+
+#if OPENTHREAD_CONFIG_RADIO_LINK_TREL_ENABLE
+
+#include "instance/instance.hpp"
+
+namespace ot {
+namespace Trel {
+
+RegisterLogModule("TrelPeerTable");
+
+//---------------------------------------------------------------------------------------------------------------------
+// Peer
+
+void Peer::Init(Instance &aInstance)
+{
+    InstanceLocatorInit::Init(aInstance);
+
+    AsCoreType(&mExtAddress).Clear();
+    AsCoreType(&mExtPanId).Clear();
+    AsCoreType(&mSockAddr).Clear();
+
+    mState = kStateValid;
+}
+
+void Peer::Free(void)
+{
+    Log(kDeleted);
+
+#if OPENTHREAD_CONFIG_TREL_USE_HEAP_ENABLE
+    Heap::Allocatable<Peer>::Free();
+#else
+    this->~Peer();
+    Get<PeerTable>().mPool.Free(*this);
+#endif
+}
+
+void Peer::ScheduleToRemoveAfter(uint32_t aDelay)
+{
+    VerifyOrExit(IsStateValid());
+
+    mRemoveTime = TimerMilli::GetNow() + aDelay;
+    SetState(kStateRemoving);
+
+    Get<PeerTable>().mTimer.FireAtIfEarlier(mRemoveTime);
+
+    Log(kRemoving);
+    LogInfo("   after %u msec", aDelay);
+
+exit:
+    return;
+}
+
+bool Peer::Matches(const NonNeighborMatcher &aMatcher) const
+{
+    // Matches only if the peer is not a neighbor. This is used when
+    // evicting a peer to make room for a new one, where we search
+    // for and remove a non-neighbor from the list.
+
+    bool matches = false;
+
+    VerifyOrExit(aMatcher.mNeighborTable.FindNeighbor(GetExtAddress(), Neighbor::kInStateAny) == nullptr);
+#if OPENTHREAD_FTD
+    VerifyOrExit(aMatcher.mNeighborTable.FindRxOnlyNeighborRouter(GetExtAddress()) == nullptr);
+#endif
+
+    matches = true;
+
+exit:
+    return matches;
+}
+
+#if OT_SHOULD_LOG_AT(OT_LOG_LEVEL_INFO)
+
+void Peer::Log(Action aAction) const
+{
+    LogInfo("%s peer mac:%s, xpan:%s, %s", ActionToString(aAction), GetExtAddress().ToString().AsCString(),
+            GetExtPanId().ToString().AsCString(), GetSockAddr().ToString().AsCString());
+}
+
+const char *Peer::ActionToString(Action aAction)
+{
+    static const char *const kActionStrings[] = {
+        "Added",    // (0) kAdded
+        "Re-added", // (1) kReAdded,
+        "Updated",  // (2) kUpdated
+        "Removing", // (3) kRemoving
+        "Deleted",  // (4) kDeleted
+        "Evicting", // (5) kEvicting
+    };
+
+    struct EnumCheck
+    {
+        InitEnumValidatorCounter();
+        ValidateNextEnum(kAdded);
+        ValidateNextEnum(kReAdded);
+        ValidateNextEnum(kUpdated);
+        ValidateNextEnum(kRemoving);
+        ValidateNextEnum(kDeleted);
+        ValidateNextEnum(kEvicting);
+    };
+
+    return kActionStrings[aAction];
+}
+
+#endif // OT_SHOULD_LOG_AT(OT_LOG_LEVEL_INFO)
+
+//---------------------------------------------------------------------------------------------------------------------
+// PeerTable
+
+PeerTable::PeerTable(Instance &aInstance)
+    : InstanceLocator(aInstance)
+    , mTimer(aInstance)
+{
+}
+
+Peer *PeerTable::AllocatePeer(void)
+{
+    Peer *newPeer;
+
+#if OPENTHREAD_CONFIG_TREL_USE_HEAP_ENABLE
+    newPeer = Peer::Allocate();
+#else
+    newPeer = mPool.Allocate();
+#endif
+
+    return newPeer;
+}
+
+Peer *PeerTable::AllocateAndAddNewPeer(void)
+{
+    Peer *newPeer = nullptr;
+
+    do
+    {
+        newPeer = AllocatePeer();
+
+        if (newPeer != nullptr)
+        {
+            break;
+        }
+    } while (EvictPeer() == kErrorNone);
+
+    VerifyOrExit(newPeer != nullptr);
+
+    newPeer->Init(GetInstance());
+    Push(*newPeer);
+
+exit:
+    return newPeer;
+}
+
+Error PeerTable::EvictPeer(void)
+{
+    Error          error = kErrorNotFound;
+    OwnedPtr<Peer> peerToEvict;
+
+    // We first try to evict a peer already scheduled to be removed.
+    // Then try to evict a peer belonging to a different PAN. If not
+    // found, we evict a non-neighbor peer.
+
+    peerToEvict = RemoveMatching(Peer::kStateRemoving);
+
+    if (peerToEvict == nullptr)
+    {
+        peerToEvict = RemoveMatching(Peer::OtherExtPanIdMatcher(Get<MeshCoP::ExtendedPanIdManager>().GetExtPanId()));
+    }
+
+    if (peerToEvict == nullptr)
+    {
+        peerToEvict = RemoveMatching(Peer::NonNeighborMatcher(Get<NeighborTable>()));
+    }
+
+    VerifyOrExit(peerToEvict != nullptr);
+
+    peerToEvict->Log(Peer::kEvicting);
+    error = kErrorNone;
+
+exit:
+    return error;
+}
+
+void PeerTable::HandleTimer(void)
+{
+    TimeMilli    now = TimerMilli::GetNow();
+    NextFireTime nextFireTime(now);
+
+    RemoveAndFreeAllMatching(Peer::ExpireChecker(now));
+
+    for (const Peer &peer : *this)
+    {
+        if (peer.IsStateRemoving())
+        {
+            nextFireTime.UpdateIfEarlier(peer.mRemoveTime);
+        }
+    }
+
+    mTimer.FireAtIfEarlier(nextFireTime);
+}
+
+const Peer *PeerTable::GetNextPeer(PeerIterator &aIterator) const
+{
+    const Peer *entry = static_cast<const Peer *>(aIterator);
+
+    VerifyOrExit(entry != nullptr);
+
+    while (!entry->IsStateValid())
+    {
+        entry = entry->GetNext();
+        VerifyOrExit(entry != nullptr);
+    }
+
+    aIterator = entry->GetNext();
+
+exit:
+    return entry;
+}
+
+uint16_t PeerTable::GetNumberOfPeers(void) const
+{
+    uint16_t count = 0;
+
+    for (const Peer &peer : *this)
+    {
+        if (peer.IsStateValid())
+        {
+            count++;
+        }
+    }
+
+    return count;
+}
+
+} // namespace Trel
+} // namespace ot
+
+#endif // #if OPENTHREAD_CONFIG_RADIO_LINK_TREL_ENABLE
diff --git a/src/core/radio/trel_peer.hpp b/src/core/radio/trel_peer.hpp
new file mode 100644
index 000000000..16a63d40a
--- /dev/null
+++ b/src/core/radio/trel_peer.hpp
@@ -0,0 +1,275 @@
+/*
+ *  Copyright (c) 2019-2025, The OpenThread Authors.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. Neither the name of the copyright holder nor the
+ *     names of its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ *   This file includes definitions for Thread Radio Encapsulation Link (TREL) peer.
+ */
+
+#ifndef TREL_PEER_HPP_
+#define TREL_PEER_HPP_
+
+#include "openthread-core-config.h"
+
+#if OPENTHREAD_CONFIG_RADIO_LINK_TREL_ENABLE
+
+#include <openthread/trel.h>
+#include <openthread/platform/trel.h>
+
+#include "common/as_core_type.hpp"
+#include "common/heap_allocatable.hpp"
+#include "common/locator.hpp"
+#include "common/log.hpp"
+#include "common/non_copyable.hpp"
+#include "common/owning_list.hpp"
+#include "common/pool.hpp"
+#include "common/timer.hpp"
+#include "mac/mac_types.hpp"
+#include "meshcop/extended_panid.hpp"
+#include "net/socket.hpp"
+#include "thread/mle_types.hpp"
+
+namespace ot {
+
+class NeighborTable;
+
+namespace Trel {
+
+class PeerTable;
+class PeerDiscoverer;
+
+/**
+ * Represents a discovered TREL peer.
+ */
+class Peer : public InstanceLocatorInit,
+             public otTrelPeer,
+             public LinkedListEntry<Peer>,
+#if OPENTHREAD_CONFIG_TREL_USE_HEAP_ENABLE
+             public Heap::Allocatable<Peer>,
+#endif
+             private NonCopyable
+
+{
+    friend class PeerTable;
+    friend class PeerDiscoverer;
+    friend class OwnedPtr<Peer>;
+    friend class OwningList<Peer>;
+    friend class LinkedList<Peer>;
+    friend class LinkedListEntry<Peer>;
+
+public:
+    /**
+     * Returns the Extended MAC Address of the discovered TREL peer.
+     *
+     * @returns The Extended MAC Address of the TREL peer.
+     */
+    const Mac::ExtAddress &GetExtAddress(void) const { return AsCoreType(&mExtAddress); }
+
+    /**
+     * Returns the Extended PAN Identifier of the discovered TREL peer.
+     *
+     * @returns The Extended PAN Identifier of the TREL peer.
+     */
+    const MeshCoP::ExtendedPanId &GetExtPanId(void) const { return AsCoreType(&mExtPanId); }
+
+    /**
+     * Returns the IPv6 socket address of the discovered TREL peer.
+     *
+     * @returns The IPv6 socket address of the TREL peer.
+     */
+    const Ip6::SockAddr &GetSockAddr(void) const { return AsCoreType(&mSockAddr); }
+
+    /**
+     * Set the IPv6 socket address of the discovered TREL peer.
+     *
+     * @param[in] aSockAddr   The IPv6 socket address.
+     */
+    void SetSockAddr(const Ip6::SockAddr &aSockAddr) { mSockAddr = aSockAddr; }
+
+private:
+    enum State : uint8_t
+    {
+        kStateValid,
+        kStateRemoving,
+    };
+
+    enum Action : uint8_t
+    {
+        kAdded,    // Added a new peer.
+        kReAdded,  // Re-added a peer (discovered again) that was scheduled for removal.
+        kUpdated,  // Updated an existing peer.
+        kRemoving, // Scheduling a peer to be removed after delay.
+        kDeleted,  // Fully removing and deleting the peer from the table.
+        kEvicting, // Evicting the peer to make space for new one.
+    };
+
+    struct OtherExtPanIdMatcher // Matches if Ext PAN ID is different.
+    {
+        explicit OtherExtPanIdMatcher(const MeshCoP::ExtendedPanId &aExtPanId)
+            : mExtPanId(aExtPanId)
+        {
+        }
+
+        const MeshCoP::ExtendedPanId &mExtPanId;
+    };
+
+    struct NonNeighborMatcher
+    {
+        explicit NonNeighborMatcher(NeighborTable &aNeighborTable)
+            : mNeighborTable(aNeighborTable)
+        {
+        }
+
+        NeighborTable &mNeighborTable;
+    };
+
+    struct ExpireChecker // Matches if the peer is in `kStateRemoving` and already expired.
+    {
+        explicit ExpireChecker(TimeMilli aNow)
+            : mNow(aNow)
+        {
+        }
+
+        TimeMilli mNow;
+    };
+
+    void Init(Instance &aInstance);
+    void Free(void);
+    void SetState(State aState) { mState = aState; }
+    bool IsStateValid(void) const { return mState == kStateValid; }
+    bool IsStateRemoving(void) const { return mState == kStateRemoving; }
+    void SetExtAddress(const Mac::ExtAddress &aExtAddress) { mExtAddress = aExtAddress; }
+    void SetExtPanId(const MeshCoP::ExtendedPanId &aExtPanId) { mExtPanId = aExtPanId; }
+    void ScheduleToRemoveAfter(uint32_t aDelay);
+    bool Matches(const Mac::ExtAddress &aExtAddress) const { return GetExtAddress() == aExtAddress; }
+    bool Matches(const Ip6::SockAddr &aSockAddr) const { return GetSockAddr() == aSockAddr; }
+    bool Matches(State aState) const { return mState == aState; }
+    bool Matches(const OtherExtPanIdMatcher &aMatcher) const { return GetExtPanId() != aMatcher.mExtPanId; }
+    bool Matches(const NonNeighborMatcher &aMatcher) const;
+    bool Matches(const ExpireChecker &aChecker) const { return IsStateRemoving() && (aChecker.mNow >= mRemoveTime); }
+
+#if OT_SHOULD_LOG_AT(OT_LOG_LEVEL_INFO)
+    void               Log(Action aAction) const;
+    static const char *ActionToString(Action aAction);
+#else
+    void Log(Action) const {}
+#endif
+
+    Peer     *mNext;
+    State     mState;
+    TimeMilli mRemoveTime;
+};
+
+//---------------------------------------------------------------------------------------------------------------------
+
+/**
+ * Represents the TREL peer table.
+ */
+class PeerTable : public InstanceLocator, public OwningList<Peer>
+{
+    friend class Peer;
+
+public:
+    /**
+     * Represents an iterator for iterating over TREL peer table entries.
+     */
+    typedef otTrelPeerIterator PeerIterator;
+
+    /**
+     * Initializes the TREL peer table.
+     *
+     * @param[in] aInstance  The OpenThread instance.
+     */
+    explicit PeerTable(Instance &aInstance);
+
+    /**
+     * Allocates a new peer entry and adds it to the table.
+     *
+     * This method attempts to allocate a new `Peer`. If successful, the new peer is added to the peer table and
+     * becomes owned by it.
+     *
+     * If the initial allocation fail, the method will then attempt to make space by evicting an existing peer from the
+     * table. The eviction strategy prioritizes removing a peer associated with a different Extended PAN ID. If no
+     * such suitable peer is found, a non-neighbor peer will be targeted for eviction. If an existing peer is
+     * successfully evicted, allocation for the new `Peer` object is re-attempted.
+     *
+     * @returns A pointer to the newly allocated and added `Peer`, or `nullptr` if the allocation fails.
+     */
+    Peer *AllocateAndAddNewPeer(void);
+
+    /**
+     * Initializes a peer table iterator.
+     *
+     * @param[in] aIterator  The iterator to initialize.
+     */
+    void InitIterator(PeerIterator &aIterator) const { aIterator = GetHead(); }
+
+    /**
+     * Iterates over the peer table entries.
+     *
+     * @param[in] aIterator  The iterator. MUST be initialized.
+     *
+     * @returns A pointer to the next `Peer` entry or `nullptr` if no more entries in the table.
+     */
+    const Peer *GetNextPeer(PeerIterator &aIterator) const;
+
+    /**
+     * Returns the number of TREL peers.
+     *
+     * @returns  The number of TREL peers.
+     */
+    uint16_t GetNumberOfPeers(void) const;
+
+private:
+#if !OPENTHREAD_CONFIG_TREL_USE_HEAP_ENABLE
+#if OPENTHREAD_CONFIG_TREL_PEER_TABLE_SIZE != 0
+    static constexpr uint16_t PoolSize = OPENTHREAD_CONFIG_TREL_PEER_TABLE_SIZE;
+#else
+    static constexpr uint16_t kExtraEntries = 32;
+    static constexpr uint16_t PoolSize      = Mle::kMaxRouters + Mle::kMaxChildren + kExtraEntries;
+#endif
+#endif
+
+    Peer *AllocatePeer(void);
+    Error EvictPeer(void);
+    void  HandleTimer(void);
+
+    using PeerTimer = TimerMilliIn<PeerTable, &PeerTable::HandleTimer>;
+
+    PeerTimer mTimer;
+#if !OPENTHREAD_CONFIG_TREL_USE_HEAP_ENABLE
+    Pool<Peer, PoolSize> mPool;
+#endif
+};
+
+} // namespace Trel
+} // namespace ot
+
+#endif // #if OPENTHREAD_CONFIG_RADIO_LINK_TREL_ENABLE
+
+#endif // TREL_PEER_HPP_
diff --git a/src/core/radio/trel_peer_discoverer.cpp b/src/core/radio/trel_peer_discoverer.cpp
new file mode 100644
index 000000000..15b9c466f
--- /dev/null
+++ b/src/core/radio/trel_peer_discoverer.cpp
@@ -0,0 +1,273 @@
+/*
+ *    Copyright (c) 2019-2025, The OpenThread Authors.
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without
+ *    modification, are permitted provided that the following conditions are met:
+ *    1. Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *    2. Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *    3. Neither the name of the copyright holder nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ *    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ *    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+ *    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ *    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ *    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ *   This file implements Thread Radio Encapsulation Link (TREL) peer discovery.
+ */
+
+#include "trel_peer_discoverer.hpp"
+
+#if OPENTHREAD_CONFIG_RADIO_LINK_TREL_ENABLE
+
+#include "instance/instance.hpp"
+
+namespace ot {
+namespace Trel {
+
+RegisterLogModule("TrelDiscoverer");
+
+PeerDiscoverer::PeerDiscoverer(Instance &aInstance)
+    : InstanceLocator(aInstance)
+    , mIsRunning(false)
+    , mRegisterServiceTask(aInstance)
+{
+}
+
+void PeerDiscoverer::Start(void)
+{
+    VerifyOrExit(!mIsRunning);
+
+    mIsRunning = true;
+    PostRegisterServiceTask();
+
+exit:
+    return;
+}
+
+void PeerDiscoverer::Stop(void)
+{
+    VerifyOrExit(mIsRunning);
+
+    mIsRunning = false;
+    Get<PeerTable>().Clear();
+
+exit:
+    return;
+}
+
+void PeerDiscoverer::NotifyPeerSocketAddressDifference(const Ip6::SockAddr &aPeerSockAddr,
+                                                       const Ip6::SockAddr &aRxSockAddr)
+{
+    otPlatTrelNotifyPeerSocketAddressDifference(&GetInstance(), &aPeerSockAddr, &aRxSockAddr);
+}
+
+void PeerDiscoverer::PostRegisterServiceTask(void)
+{
+    if (mIsRunning)
+    {
+        mRegisterServiceTask.Post();
+    }
+}
+
+void PeerDiscoverer::RegisterService(void)
+{
+    TxtDataEncoder txtData(GetInstance());
+    uint16_t       port;
+
+    VerifyOrExit(mIsRunning);
+
+    port = Get<Interface>().GetUdpPort();
+
+    txtData.Encode();
+
+    LogInfo("Registering DNS-SD service: port:%u", port);
+    otPlatTrelRegisterService(&GetInstance(), port, txtData.GetBytes(), static_cast<uint8_t>(txtData.GetLength()));
+
+exit:
+    return;
+}
+
+extern "C" void otPlatTrelHandleDiscoveredPeerInfo(otInstance *aInstance, const otPlatTrelPeerInfo *aInfo)
+{
+    Instance &instance = AsCoreType(aInstance);
+
+    VerifyOrExit(instance.IsInitialized());
+    instance.Get<PeerDiscoverer>().HandleDiscoveredPeerInfo(*static_cast<const PeerDiscoverer::PeerInfo *>(aInfo));
+
+exit:
+    return;
+}
+
+void PeerDiscoverer::HandleDiscoveredPeerInfo(const PeerInfo &aInfo)
+{
+    Peer         *peer;
+    TxtData       txtData;
+    TxtData::Info txtInfo;
+    Peer::Action  action    = Peer::kUpdated;
+    bool          shouldLog = true;
+
+    VerifyOrExit(mIsRunning);
+
+    txtData.Init(aInfo.mTxtData, aInfo.mTxtLength);
+    SuccessOrExit(txtData.Decode(txtInfo));
+
+    VerifyOrExit(txtInfo.mExtAddress != Get<Mac::Mac>().GetExtAddress());
+
+    if (aInfo.IsRemoved())
+    {
+        peer = Get<PeerTable>().FindMatching(txtInfo.mExtAddress);
+        VerifyOrExit(peer != nullptr);
+        peer->ScheduleToRemoveAfter(kRemoveDelay);
+        ExitNow();
+    }
+
+    // It is a new entry or an update to an existing entry. First
+    // check whether we have an existing entry that matches the same
+    // socket address, and remove it if it is associated with a
+    // different Extended MAC address. This ensures that we do not
+    // keep stale entries in the peer table.
+
+    peer = Get<PeerTable>().FindMatching(aInfo.GetSockAddr());
+
+    if ((peer != nullptr) && !peer->Matches(txtInfo.mExtAddress))
+    {
+        Get<PeerTable>().RemoveMatching(aInfo.GetSockAddr());
+        peer = nullptr;
+    }
+
+    if (peer == nullptr)
+    {
+        peer = Get<PeerTable>().FindMatching(txtInfo.mExtAddress);
+    }
+
+    if (peer == nullptr)
+    {
+        peer = Get<PeerTable>().AllocateAndAddNewPeer();
+        VerifyOrExit(peer != nullptr);
+
+        peer->SetExtAddress(txtInfo.mExtAddress);
+        action = Peer::kAdded;
+    }
+    else if (!peer->IsStateValid())
+    {
+        action = Peer::kReAdded;
+    }
+    else
+    {
+        shouldLog = (peer->GetExtPanId() != txtInfo.mExtPanId) || (peer->GetSockAddr() != aInfo.GetSockAddr());
+        action    = Peer::kUpdated;
+    }
+
+    peer->SetState(Peer::kStateValid);
+    peer->SetExtPanId(txtInfo.mExtPanId);
+    peer->SetSockAddr(aInfo.GetSockAddr());
+
+    if (shouldLog)
+    {
+        peer->Log(action);
+    }
+
+exit:
+    return;
+}
+
+//----------------------------------------------------------------------------------------------------------------------
+// PeerDiscoverer::TxtData
+
+const char PeerDiscoverer::TxtData::kExtAddressKey[] = "xa";
+const char PeerDiscoverer::TxtData::kExtPanIdKey[]   = "xp";
+
+void PeerDiscoverer::TxtData::Init(const uint8_t *aData, uint16_t aLength)
+{
+    mData   = aData;
+    mLength = aLength;
+}
+
+Error PeerDiscoverer::TxtData::Decode(Info &aInfo)
+{
+    Error                   error;
+    Dns::TxtEntry           entry;
+    Dns::TxtEntry::Iterator iterator;
+    bool                    parsedExtAddress = false;
+    bool                    parsedExtPanId   = false;
+
+    aInfo.Clear();
+
+    iterator.Init(mData, mLength);
+
+    while ((error = iterator.GetNextEntry(entry)) == kErrorNone)
+    {
+        // If the TXT data happens to have entries with key longer
+        // than `kMaxIterKeyLength`, `mKey` would be `nullptr` and full
+        // entry would be placed in `mValue`. We skip over such
+        // entries.
+        if (entry.mKey == nullptr)
+        {
+            continue;
+        }
+
+        if (StringMatch(entry.mKey, kExtAddressKey))
+        {
+            VerifyOrExit(!parsedExtAddress, error = kErrorParse);
+            VerifyOrExit(entry.mValueLength >= sizeof(Mac::ExtAddress), error = kErrorParse);
+            aInfo.mExtAddress.Set(entry.mValue);
+            parsedExtAddress = true;
+        }
+        else if (StringMatch(entry.mKey, kExtPanIdKey))
+        {
+            VerifyOrExit(!parsedExtPanId, error = kErrorParse);
+            VerifyOrExit(entry.mValueLength >= sizeof(MeshCoP::ExtendedPanId), error = kErrorParse);
+            memcpy(aInfo.mExtPanId.m8, entry.mValue, sizeof(MeshCoP::ExtendedPanId));
+            parsedExtPanId = true;
+        }
+
+        // Skip over and ignore any unknown keys.
+    }
+
+    VerifyOrExit(error == kErrorNotFound);
+    error = kErrorNone;
+
+    VerifyOrExit(parsedExtAddress && parsedExtPanId, error = kErrorParse);
+
+exit:
+    return error;
+}
+
+//----------------------------------------------------------------------------------------------------------------------
+// PeerDiscoverer::TxtDataEncoder
+
+PeerDiscoverer::TxtDataEncoder::TxtDataEncoder(Instance &aInstance)
+    : InstanceLocator(aInstance)
+{
+}
+
+void PeerDiscoverer::TxtDataEncoder::Encode(void)
+{
+    Dns::TxtDataEncoder encoder(mBuffer, sizeof(mBuffer));
+
+    SuccessOrAssert(encoder.AppendEntry(kExtAddressKey, Get<Mac::Mac>().GetExtAddress()));
+    SuccessOrAssert(encoder.AppendEntry(kExtPanIdKey, Get<MeshCoP::ExtendedPanIdManager>().GetExtPanId()));
+
+    mData   = mBuffer;
+    mLength = encoder.GetLength();
+}
+
+} // namespace Trel
+} // namespace ot
+
+#endif // #if OPENTHREAD_CONFIG_RADIO_LINK_TREL_ENABLE
diff --git a/src/core/radio/trel_peer_discoverer.hpp b/src/core/radio/trel_peer_discoverer.hpp
new file mode 100644
index 000000000..9b94ee4c8
--- /dev/null
+++ b/src/core/radio/trel_peer_discoverer.hpp
@@ -0,0 +1,159 @@
+/*
+ *  Copyright (c) 2019-2025, The OpenThread Authors.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. Neither the name of the copyright holder nor the
+ *     names of its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ *   This file includes definitions for Thread Radio Encapsulation Link (TREL) peer discovery.
+ */
+
+#ifndef TREL_PEER_DISCOVERER_HPP_
+#define TREL_PEER_DISCOVERER_HPP_
+
+#include "openthread-core-config.h"
+
+#if OPENTHREAD_CONFIG_RADIO_LINK_TREL_ENABLE
+
+#include <openthread/platform/trel.h>
+
+#include "common/clearable.hpp"
+#include "common/locator.hpp"
+#include "common/tasklet.hpp"
+#include "radio/trel_peer.hpp"
+
+namespace ot {
+namespace Trel {
+
+class Link;
+
+extern "C" void otPlatTrelHandleDiscoveredPeerInfo(otInstance *aInstance, const otPlatTrelPeerInfo *aInfo);
+
+/**
+ * Represents a TREL module responsible for peer discovery and mDNS service registration.
+ */
+class PeerDiscoverer : public InstanceLocator
+{
+    friend class Link;
+    friend void otPlatTrelHandleDiscoveredPeerInfo(otInstance *aInstance, const otPlatTrelPeerInfo *aInfo);
+
+public:
+    /**
+     * Starts the peer discovery.
+     */
+    void Start(void);
+
+    /**
+     * Stops the peer discovery and clears the peer table.
+     */
+    void Stop(void);
+
+    /**
+     * Notifies that device's Extended MAC Address has changed.
+     */
+    void HandleExtAddressChange(void) { PostRegisterServiceTask(); }
+
+    /**
+     * Notifies that device's Extended PAN Identifier has changed.
+     */
+    void HandleExtPanIdChange(void) { PostRegisterServiceTask(); }
+
+    /**
+     * Notifies that a TREL packet is received from a peer using a different socket address than the one reported
+     * earlier.
+     *
+     * @param[in] aPeerSockAddr   The previously reported peer sock address.
+     * @param[in] aRxSockAddr     The address of received packet from the same peer.
+     */
+    void NotifyPeerSocketAddressDifference(const Ip6::SockAddr &aPeerSockAddr, const Ip6::SockAddr &aRxSockAddr);
+
+private:
+    static constexpr uint32_t kRemoveDelay = 7 * Time::kOneSecondInMsec;
+
+    class TxtData
+    {
+    public:
+        struct Info : public Clearable<Info>
+        {
+            Mac::ExtAddress        mExtAddress;
+            MeshCoP::ExtendedPanId mExtPanId;
+        };
+
+        void           Init(const uint8_t *aData, uint16_t aLength);
+        const uint8_t *GetBytes(void) const { return mData; }
+        uint16_t       GetLength(void) const { return mLength; }
+        Error          Decode(Info &aInfo);
+
+    protected:
+        static const char kExtAddressKey[]; // "xa"
+        static const char kExtPanIdKey[];   // "xp"
+
+        const uint8_t *mData;
+        uint16_t       mLength;
+    };
+
+    class TxtDataEncoder : public InstanceLocator, public TxtData
+    {
+    public:
+        explicit TxtDataEncoder(Instance &aInstance);
+        void Encode(void);
+
+    private:
+        // TXT data consists of two entries: `xa` for extended address
+        // and `xp` for extended PAN ID. Each entry starts with one
+        // byte for length, then the two-character key, followed by
+        // an `=` character, and then the value. This adds up to
+        // (4 + 8 [value]) = 12 bytes total per entry. The value of
+        // 32 accommodates these two entries and more.
+        static constexpr uint8_t kMaxSize = 32;
+
+        uint8_t mBuffer[kMaxSize];
+    };
+
+    struct PeerInfo : public otPlatTrelPeerInfo
+    {
+        bool                 IsRemoved(void) const { return mRemoved; }
+        const Ip6::SockAddr &GetSockAddr(void) const { return AsCoreType(&mSockAddr); }
+    };
+
+    explicit PeerDiscoverer(Instance &aInstance);
+
+    void HandleDiscoveredPeerInfo(const PeerInfo &aInfo);
+    void PostRegisterServiceTask(void);
+    void RegisterService(void);
+
+    using RegisterServiceTask = TaskletIn<PeerDiscoverer, &PeerDiscoverer::RegisterService>;
+
+    bool                mIsRunning;
+    RegisterServiceTask mRegisterServiceTask;
+};
+
+} // namespace Trel
+} // namespace ot
+
+#endif // #if OPENTHREAD_CONFIG_RADIO_LINK_TREL_ENABLE
+
+#endif // TREL_PEER_DISCOVERER_HPP_
diff --git a/src/core/thread/address_resolver.cpp b/src/core/thread/address_resolver.cpp
index 045a5a46e..eb042c5da 100644
--- a/src/core/thread/address_resolver.cpp
+++ b/src/core/thread/address_resolver.cpp
@@ -123,7 +123,7 @@ Error AddressResolver::GetNextCacheEntry(EntryInfo &aInfo, Iterator &aIterator)
         VerifyOrExit(entry->IsLastTransactionTimeValid());
 
         aInfo.mLastTransTime = entry->GetLastTransactionTime();
-        AsCoreType(&aInfo.mMeshLocalEid).SetPrefix(Get<Mle::MleRouter>().GetMeshLocalPrefix());
+        AsCoreType(&aInfo.mMeshLocalEid).SetPrefix(Get<Mle::Mle>().GetMeshLocalPrefix());
         AsCoreType(&aInfo.mMeshLocalEid).SetIid(entry->GetMeshLocalIid());
 
         ExitNow();
@@ -369,7 +369,7 @@ void AddressResolver::UpdateSnoopedCacheEntry(const Ip6::Address &aEid, uint16_t
     uint16_t    numNonEvictable = 0;
     CacheEntry *entry;
 
-    VerifyOrExit(Get<Mle::MleRouter>().IsFullThreadDevice());
+    VerifyOrExit(Get<Mle::Mle>().IsFullThreadDevice());
 
 #if OPENTHREAD_CONFIG_TMF_ALLOW_ADDRESS_RESOLUTION_USING_NET_DATA_SERVICES
     {
@@ -634,7 +634,7 @@ exit:
 #if OPENTHREAD_CONFIG_BACKBONE_ROUTER_DUA_NDPROXYING_ENABLE
     if (Get<BackboneRouter::Local>().IsPrimary() && Get<BackboneRouter::Leader>().IsDomainUnicast(aEid))
     {
-        uint16_t selfRloc16 = Get<Mle::MleRouter>().GetRloc16();
+        uint16_t selfRloc16 = Get<Mle::Mle>().GetRloc16();
 
         LogInfo("Extending %s to %s for target %s, rloc16=%04x(self)", UriToString<kUriAddressQuery>(),
                 UriToString<kUriBackboneQuery>(), aEid.ToString().AsCString(), selfRloc16);
@@ -785,7 +785,7 @@ void AddressResolver::HandleTmf<kUriAddressError>(Coap::Message &aMessage, const
 
     for (Ip6::Netif::UnicastAddress &address : Get<ThreadNetif>().GetUnicastAddresses())
     {
-        if (address.GetAddress() == target && Get<Mle::MleRouter>().GetMeshLocalEid().GetIid() != meshLocalIid)
+        if (address.GetAddress() == target && Get<Mle::Mle>().GetMeshLocalEid().GetIid() != meshLocalIid)
         {
             // Target EID matches address and Mesh Local EID differs
 #if OPENTHREAD_CONFIG_DUA_ENABLE
@@ -804,7 +804,7 @@ void AddressResolver::HandleTmf<kUriAddressError>(Coap::Message &aMessage, const
     }
 
 #if OPENTHREAD_FTD
-    meshLocalIid.ConvertToExtAddress(extAddr);
+    extAddr.SetFromIid(meshLocalIid);
 
     for (Child &child : Get<ChildTable>().Iterate(Child::kInStateValid))
     {
@@ -854,7 +854,7 @@ void AddressResolver::HandleTmf<kUriAddressQuery>(Coap::Message &aMessage, const
 
     if (Get<ThreadNetif>().HasUnicastAddress(target))
     {
-        SendAddressQueryResponse(target, Get<Mle::MleRouter>().GetMeshLocalEid().GetIid(), nullptr,
+        SendAddressQueryResponse(target, Get<Mle::Mle>().GetMeshLocalEid().GetIid(), nullptr,
                                  aMessageInfo.GetPeerAddr());
         ExitNow();
     }
@@ -903,7 +903,7 @@ void AddressResolver::SendAddressQueryResponse(const Ip6::Address             &a
 
     SuccessOrExit(error = Tlv::Append<ThreadTargetTlv>(*message, aTarget));
     SuccessOrExit(error = Tlv::Append<ThreadMeshLocalEidTlv>(*message, aMeshLocalIid));
-    SuccessOrExit(error = Tlv::Append<ThreadRloc16Tlv>(*message, Get<Mle::MleRouter>().GetRloc16()));
+    SuccessOrExit(error = Tlv::Append<ThreadRloc16Tlv>(*message, Get<Mle::Mle>().GetRloc16()));
 
     if (aLastTransactionTime != nullptr)
     {
diff --git a/src/core/thread/address_resolver.hpp b/src/core/thread/address_resolver.hpp
index 799348238..67fd84a5f 100644
--- a/src/core/thread/address_resolver.hpp
+++ b/src/core/thread/address_resolver.hpp
@@ -36,6 +36,8 @@
 
 #include "openthread-core-config.h"
 
+#include <openthread/thread_ftd.h>
+
 #include "coap/coap.hpp"
 #include "common/as_core_type.hpp"
 #include "common/linked_list.hpp"
diff --git a/src/core/thread/announce_sender.cpp b/src/core/thread/announce_sender.cpp
index 0550e2e0a..979088555 100644
--- a/src/core/thread/announce_sender.cpp
+++ b/src/core/thread/announce_sender.cpp
@@ -116,7 +116,7 @@ exit:
 
 void AnnounceSenderBase::HandleTimer(void)
 {
-    Get<Mle::MleRouter>().SendAnnounce(mChannel);
+    Get<Mle::Mle>().SendAnnounce(mChannel);
 
     // Go to the next channel in the mask. If we have reached the end
     // of the channel mask, we start over from the first channel in
@@ -206,7 +206,7 @@ void AnnounceSender::HandleRoleChanged(void)
 
     case Mle::kRoleChild:
 #if OPENTHREAD_FTD
-        if (Get<Mle::MleRouter>().IsRouterEligible() && Get<Mle::Mle>().IsRxOnWhenIdle())
+        if (Get<Mle::Mle>().IsRouterEligible() && Get<Mle::Mle>().IsRxOnWhenIdle())
         {
             break;
         }
diff --git a/src/core/thread/child.cpp b/src/core/thread/child.cpp
index 28a1b4b1d..f5d382b32 100644
--- a/src/core/thread/child.cpp
+++ b/src/core/thread/child.cpp
@@ -68,9 +68,7 @@ void Child::Info::SetFrom(const Child &aChild)
 #else
     mIsCslSynced = false;
 #endif
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
     mConnectionTime = aChild.GetConnectionTime();
-#endif
 }
 
 //---------------------------------------------------------------------------------------------------------------------
@@ -154,7 +152,7 @@ Error Child::GetMeshLocalIp6Address(Ip6::Address &aAddress) const
 
     VerifyOrExit(!mMeshLocalIid.IsUnspecified(), error = kErrorNotFound);
 
-    aAddress.SetPrefix(Get<Mle::MleRouter>().GetMeshLocalPrefix());
+    aAddress.SetPrefix(Get<Mle::Mle>().GetMeshLocalPrefix());
     aAddress.SetIid(mMeshLocalIid);
 
 exit:
@@ -190,7 +188,7 @@ Error Child::AddIp6Address(const Ip6::Address &aAddress)
 
     VerifyOrExit(!aAddress.IsUnspecified(), error = kErrorInvalidArgs);
 
-    if (Get<Mle::MleRouter>().IsMeshLocalAddress(aAddress))
+    if (Get<Mle::Mle>().IsMeshLocalAddress(aAddress))
     {
         VerifyOrExit(mMeshLocalIid.IsUnspecified(), error = kErrorAlready);
         mMeshLocalIid = aAddress.GetIid();
@@ -209,7 +207,7 @@ Error Child::RemoveIp6Address(const Ip6::Address &aAddress)
     Error         error = kErrorNotFound;
     Ip6AddrEntry *entry;
 
-    if (Get<Mle::MleRouter>().IsMeshLocalAddress(aAddress))
+    if (Get<Mle::Mle>().IsMeshLocalAddress(aAddress))
     {
         if (aAddress.GetIid() == mMeshLocalIid)
         {
@@ -253,7 +251,7 @@ bool Child::HasIp6Address(const Ip6::Address &aAddress) const
 
     VerifyOrExit(!aAddress.IsUnspecified());
 
-    if (Get<Mle::MleRouter>().IsMeshLocalAddress(aAddress))
+    if (Get<Mle::Mle>().IsMeshLocalAddress(aAddress))
     {
         hasAddress = (aAddress.GetIid() == mMeshLocalIid);
         ExitNow();
diff --git a/src/core/thread/child_supervision.cpp b/src/core/thread/child_supervision.cpp
index 427535307..4381e317f 100644
--- a/src/core/thread/child_supervision.cpp
+++ b/src/core/thread/child_supervision.cpp
@@ -182,8 +182,8 @@ void SupervisionListener::UpdateOnReceive(const Mac::Address &aSourceAddress, bo
 {
     // If listener is enabled and device is a child and it received a secure frame from its parent, restart the timer.
 
-    VerifyOrExit(mTimer.IsRunning() && aIsSecure && Get<Mle::MleRouter>().IsChild() &&
-                 (Get<NeighborTable>().FindNeighbor(aSourceAddress) == &Get<Mle::MleRouter>().GetParent()));
+    VerifyOrExit(mTimer.IsRunning() && aIsSecure && Get<Mle::Mle>().IsChild() &&
+                 (Get<NeighborTable>().FindNeighbor(aSourceAddress) == &Get<Mle::Mle>().GetParent()));
 
     RestartTimer();
 
@@ -193,7 +193,7 @@ exit:
 
 void SupervisionListener::RestartTimer(void)
 {
-    if ((mTimeout != 0) && !Get<Mle::MleRouter>().IsDisabled() && !Get<MeshForwarder>().GetRxOnWhenIdle())
+    if ((mTimeout != 0) && !Get<Mle::Mle>().IsDisabled() && !Get<MeshForwarder>().GetRxOnWhenIdle())
     {
         mTimer.Start(Time::SecToMsec(mTimeout));
     }
@@ -205,7 +205,7 @@ void SupervisionListener::RestartTimer(void)
 
 void SupervisionListener::HandleTimer(void)
 {
-    VerifyOrExit(Get<Mle::MleRouter>().IsChild() && !Get<MeshForwarder>().GetRxOnWhenIdle());
+    VerifyOrExit(Get<Mle::Mle>().IsChild() && !Get<MeshForwarder>().GetRxOnWhenIdle());
 
     LogWarn("Supervision timeout. No frame from parent in %u sec", mTimeout);
     mCounter++;
diff --git a/src/core/thread/discover_scanner.cpp b/src/core/thread/discover_scanner.cpp
index 9787b36d2..516a91d0f 100644
--- a/src/core/thread/discover_scanner.cpp
+++ b/src/core/thread/discover_scanner.cpp
@@ -322,7 +322,7 @@ void DiscoverScanner::HandleDiscoveryResponse(Mle::RxInfo &aRxInfo) const
     result.mRssi     = aRxInfo.mMessage.GetAverageRss();
     result.mLqi      = aRxInfo.mMessage.GetAverageLqi();
 
-    aRxInfo.mMessageInfo.GetPeerAddr().GetIid().ConvertToExtAddress(AsCoreType(&result.mExtAddress));
+    AsCoreType(&result.mExtAddress).SetFromIid(aRxInfo.mMessageInfo.GetPeerAddr().GetIid());
 
     for (; !offsetRange.IsEmpty(); offsetRange.AdvanceOffset(tlvInfo.GetSize()))
     {
diff --git a/src/core/thread/dua_manager.cpp b/src/core/thread/dua_manager.cpp
index 3cbf9f84a..19ea0debc 100644
--- a/src/core/thread/dua_manager.cpp
+++ b/src/core/thread/dua_manager.cpp
@@ -291,7 +291,7 @@ void DuaManager::UpdateCheckDelay(uint8_t aDelay)
 
 void DuaManager::HandleNotifierEvents(Events aEvents)
 {
-    Mle::MleRouter &mle = Get<Mle::MleRouter>();
+    Mle::Mle &mle = Get<Mle::Mle>();
 
 #if OPENTHREAD_CONFIG_DUA_ENABLE
     if (aEvents.Contains(kEventThreadNetdataChanged))
@@ -420,16 +420,16 @@ void DuaManager::UpdateTimeTickerRegistration(void)
 void DuaManager::PerformNextRegistration(void)
 {
     Error            error   = kErrorNone;
-    Mle::MleRouter  &mle     = Get<Mle::MleRouter>();
+    Mle::Mle        &mle     = Get<Mle::Mle>();
     Coap::Message   *message = nullptr;
     Tmf::MessageInfo messageInfo(GetInstance());
     Ip6::Address     dua;
 
-    VerifyOrExit(mle.IsAttached(), error = kErrorInvalidState);
-    VerifyOrExit(Get<BackboneRouter::Leader>().HasPrimary(), error = kErrorInvalidState);
+    VerifyOrExit(mle.IsAttached());
+    VerifyOrExit(Get<BackboneRouter::Leader>().HasPrimary());
 
     // Only allow one outgoing DUA.req
-    VerifyOrExit(!mIsDuaPending, error = kErrorBusy);
+    VerifyOrExit(!mIsDuaPending);
 
     // Only send DUA.req when necessary
 #if OPENTHREAD_CONFIG_DUA_ENABLE
@@ -437,10 +437,10 @@ void DuaManager::PerformNextRegistration(void)
     if (!mle.IsRouterOrLeader() && mle.IsExpectedToBecomeRouterSoon())
     {
         UpdateRegistrationDelay(mle.GetRouterRoleTransitionTimeout() + kNewRouterRegistrationDelay + 1);
-        ExitNow(error = kErrorInvalidState);
+        ExitNow();
     }
 #endif
-    VerifyOrExit(mle.IsFullThreadDevice() || mle.GetParent().IsThreadVersion1p1(), error = kErrorInvalidState);
+    VerifyOrExit(mle.IsFullThreadDevice() || mle.GetParent().IsThreadVersion1p1());
 #endif // OPENTHREAD_CONFIG_DUA_ENABLE
 
     {
@@ -453,7 +453,7 @@ void DuaManager::PerformNextRegistration(void)
 #if OPENTHREAD_FTD && OPENTHREAD_CONFIG_TMF_PROXY_DUA_ENABLE
         needReg = needReg || (!mChildDuaMask.IsEmpty() && mChildDuaMask != mChildDuaRegisteredMask);
 #endif
-        VerifyOrExit(needReg, error = kErrorNotFound);
+        VerifyOrExit(needReg);
     }
 
     // Prepare DUA.req
diff --git a/src/core/thread/energy_scan_server.hpp b/src/core/thread/energy_scan_server.hpp
index c3095b2c0..606f862ea 100644
--- a/src/core/thread/energy_scan_server.hpp
+++ b/src/core/thread/energy_scan_server.hpp
@@ -40,6 +40,7 @@
 #include "common/non_copyable.hpp"
 #include "common/notifier.hpp"
 #include "common/timer.hpp"
+#include "mac/mac.hpp"
 #include "net/ip6_address.hpp"
 #include "net/udp6.hpp"
 #include "thread/thread_tlvs.hpp"
diff --git a/src/core/thread/indirect_sender.cpp b/src/core/thread/indirect_sender.cpp
index b465c8de8..cbc56c7c5 100644
--- a/src/core/thread/indirect_sender.cpp
+++ b/src/core/thread/indirect_sender.cpp
@@ -371,7 +371,7 @@ uint16_t IndirectSender::PrepareDataFrame(Mac::TxFrame &aFrame, Child &aChild, M
 
     if (ip6Header.GetDestination().IsLinkLocalUnicast())
     {
-        Get<MeshForwarder>().GetMacDestinationAddress(ip6Header.GetDestination(), macAddrs.mDestination);
+        macAddrs.mDestination.SetExtendedFromIid(ip6Header.GetDestination().GetIid());
     }
     else
     {
@@ -516,17 +516,7 @@ void IndirectSender::HandleSentFrameToChild(const Mac::TxFrame &aFrame,
             Get<MeshForwarder>().LogMessage(MeshForwarder::kMessageTransmit, *message, txError, &macDest);
         }
 
-        if (message->GetType() == Message::kTypeIp6)
-        {
-            if (aChild.GetIndirectTxSuccess())
-            {
-                Get<MeshForwarder>().mIpCounters.mTxSuccess++;
-            }
-            else
-            {
-                Get<MeshForwarder>().mIpCounters.mTxFailure++;
-            }
-        }
+        Get<MeshForwarder>().mCounters.UpdateOnTxDone(*message, aChild.GetIndirectTxSuccess());
 
         if (message->GetIndirectTxChildMask().Has(childIndex))
         {
diff --git a/src/core/thread/key_manager.cpp b/src/core/thread/key_manager.cpp
index a9ab0b0ff..c2a49f8e1 100644
--- a/src/core/thread/key_manager.cpp
+++ b/src/core/thread/key_manager.cpp
@@ -230,7 +230,7 @@ void KeyManager::ResetFrameCounters(void)
     Router *parent;
 
     // reset parent frame counters
-    parent = &Get<Mle::MleRouter>().GetParent();
+    parent = &Get<Mle::Mle>().GetParent();
     parent->SetKeySequence(0);
     parent->GetLinkFrameCounters().Reset();
     parent->SetLinkAckFrameCounter(0);
@@ -473,7 +473,7 @@ void KeyManager::MacFrameCounterUsed(uint32_t aMacFrameCounter)
 
     if (mMacFrameCounters.Get154() >= mStoredMacFrameCounter)
     {
-        IgnoreError(Get<Mle::MleRouter>().Store());
+        IgnoreError(Get<Mle::Mle>().Store());
     }
 
 exit:
@@ -490,7 +490,7 @@ void KeyManager::IncrementTrelMacFrameCounter(void)
 
     if (mMacFrameCounters.GetTrel() >= mStoredMacFrameCounter)
     {
-        IgnoreError(Get<Mle::MleRouter>().Store());
+        IgnoreError(Get<Mle::Mle>().Store());
     }
 }
 #endif
@@ -501,7 +501,7 @@ void KeyManager::IncrementMleFrameCounter(void)
 
     if (mMleFrameCounter >= mStoredMleFrameCounter)
     {
-        IgnoreError(Get<Mle::MleRouter>().Store());
+        IgnoreError(Get<Mle::Mle>().Store());
     }
 }
 
diff --git a/src/core/thread/link_metrics.cpp b/src/core/thread/link_metrics.cpp
index 8ab38a250..f7c778aa9 100644
--- a/src/core/thread/link_metrics.cpp
+++ b/src/core/thread/link_metrics.cpp
@@ -386,7 +386,7 @@ Error Initiator::FindNeighbor(const Ip6::Address &aDestination, Neighbor *&aNeig
     aNeighbor = nullptr;
 
     VerifyOrExit(aDestination.IsLinkLocalUnicast());
-    aDestination.GetIid().ConvertToMacAddress(macAddress);
+    macAddress.SetExtendedFromIid(aDestination.GetIid());
 
     aNeighbor = Get<NeighborTable>().FindNeighbor(macAddress);
     VerifyOrExit(aNeighbor != nullptr);
diff --git a/src/core/thread/mesh_forwarder.cpp b/src/core/thread/mesh_forwarder.cpp
index 9999b36be..b4cefc8f4 100644
--- a/src/core/thread/mesh_forwarder.cpp
+++ b/src/core/thread/mesh_forwarder.cpp
@@ -40,54 +40,28 @@ namespace ot {
 
 RegisterLogModule("MeshForwarder");
 
-void ThreadLinkInfo::SetFrom(const Mac::RxFrame &aFrame)
+void MeshForwarder::Counters::UpdateOnTxDone(const Message &aMessage, bool aTxSuccess)
 {
-    Clear();
-
-    if (kErrorNone != aFrame.GetSrcPanId(mPanId))
+    if (aMessage.GetType() == Message::kTypeIp6)
     {
-        IgnoreError(aFrame.GetDstPanId(mPanId));
+        aTxSuccess ? mTxSuccess++ : mTxFailure++;
     }
+}
 
+void MeshForwarder::Counters::UpdateOnRx(const Message &aMessage)
+{
+    if (aMessage.GetType() == Message::kTypeIp6)
     {
-        Mac::PanId dstPanId;
-
-        if (kErrorNone != aFrame.GetDstPanId(dstPanId))
-        {
-            dstPanId = mPanId;
-        }
-
-        mIsDstPanIdBroadcast = (dstPanId == Mac::kPanIdBroadcast);
+        mRxSuccess++;
     }
+}
 
-    if (aFrame.GetSecurityEnabled())
-    {
-        uint8_t keyIdMode;
-
-        // MAC Frame Security was already validated at the MAC
-        // layer. As a result, `GetKeyIdMode()` will never return
-        // failure here.
-        IgnoreError(aFrame.GetKeyIdMode(keyIdMode));
-
-        mLinkSecurity = (keyIdMode == Mac::Frame::kKeyIdMode0) || (keyIdMode == Mac::Frame::kKeyIdMode1);
-    }
-    else
-    {
-        mLinkSecurity = false;
-    }
-    mChannel = aFrame.GetChannel();
-    mRss     = aFrame.GetRssi();
-    mLqi     = aFrame.GetLqi();
-#if OPENTHREAD_CONFIG_TIME_SYNC_ENABLE
-    if (aFrame.GetTimeIe() != nullptr)
+void MeshForwarder::Counters::UpdateOnDrop(const Message &aMessage)
+{
+    if (aMessage.GetType() == Message::kTypeIp6)
     {
-        mNetworkTimeOffset = aFrame.ComputeNetworkTimeOffset();
-        mTimeSyncSeq       = aFrame.ReadTimeSyncSeq();
+        mRxFailure++;
     }
-#endif
-#if OPENTHREAD_CONFIG_MULTI_RADIO
-    mRadioType = static_cast<uint8_t>(aFrame.GetRadioType());
-#endif
 }
 
 MeshForwarder::MeshForwarder(Instance &aInstance)
@@ -112,8 +86,6 @@ MeshForwarder::MeshForwarder(Instance &aInstance)
 {
     mFragTag = Random::NonCrypto::GetUint16();
 
-    ResetCounters();
-
 #if OPENTHREAD_CONFIG_TX_QUEUE_STATISTICS_ENABLE
     mTxQueueStats.Clear();
 #endif
@@ -618,9 +590,9 @@ exit:
 
 Error MeshForwarder::UpdateIp6Route(Message &aMessage)
 {
-    Mle::MleRouter &mle   = Get<Mle::MleRouter>();
-    Error           error = kErrorNone;
-    Ip6::Header     ip6Header;
+    Mle::Mle   &mle   = Get<Mle::Mle>();
+    Error       error = kErrorNone;
+    Ip6::Header ip6Header;
 
     mAddMeshHeader = false;
 
@@ -632,9 +604,13 @@ Error MeshForwarder::UpdateIp6Route(Message &aMessage)
 
     if (mle.IsDisabled() || mle.IsDetached())
     {
-        if (ip6Header.GetDestination().IsLinkLocalUnicastOrMulticast())
+        if (ip6Header.GetDestination().IsLinkLocalMulticast())
+        {
+            mMacAddrs.mDestination.SetShort(Mac::kShortAddrBroadcast);
+        }
+        else if (ip6Header.GetDestination().IsLinkLocalUnicast())
         {
-            GetMacDestinationAddress(ip6Header.GetDestination(), mMacAddrs.mDestination);
+            mMacAddrs.mDestination.SetExtendedFromIid(ip6Header.GetDestination().GetIid());
         }
         else
         {
@@ -661,7 +637,7 @@ Error MeshForwarder::UpdateIp6Route(Message &aMessage)
     }
     else if (ip6Header.GetDestination().IsLinkLocalUnicast())
     {
-        GetMacDestinationAddress(ip6Header.GetDestination(), mMacAddrs.mDestination);
+        mMacAddrs.mDestination.SetExtendedFromIid(ip6Header.GetDestination().GetIid());
     }
     else if (mle.IsMinimalEndDevice())
     {
@@ -700,7 +676,7 @@ void MeshForwarder::SetRxOnWhenIdle(bool aRxOnWhenIdle)
 
 void MeshForwarder::GetMacSourceAddress(const Ip6::Address &aIp6Addr, Mac::Address &aMacAddr)
 {
-    aIp6Addr.GetIid().ConvertToMacAddress(aMacAddr);
+    aMacAddr.SetExtendedFromIid(aIp6Addr.GetIid());
 
     if (aMacAddr.GetExtended() != Get<Mac::Mac>().GetExtAddress())
     {
@@ -708,22 +684,6 @@ void MeshForwarder::GetMacSourceAddress(const Ip6::Address &aIp6Addr, Mac::Addre
     }
 }
 
-void MeshForwarder::GetMacDestinationAddress(const Ip6::Address &aIp6Addr, Mac::Address &aMacAddr)
-{
-    if (aIp6Addr.IsMulticast())
-    {
-        aMacAddr.SetShort(Mac::kShortAddrBroadcast);
-    }
-    else if (Get<Mle::MleRouter>().IsRoutingLocator(aIp6Addr))
-    {
-        aMacAddr.SetShort(aIp6Addr.GetIid().GetLocator());
-    }
-    else
-    {
-        aIp6Addr.GetIid().ConvertToMacAddress(aMacAddr);
-    }
-}
-
 Mac::TxFrame *MeshForwarder::HandleFrameRequest(Mac::TxFrames &aTxFrames)
 {
     Mac::TxFrame *frame         = nullptr;
@@ -780,7 +740,7 @@ Mac::TxFrame *MeshForwarder::HandleFrameRequest(Mac::TxFrames &aTxFrames)
     {
         Mac::Address macDestAddr;
 
-        macDestAddr.SetShort(Get<Mle::MleRouter>().GetParent().GetRloc16());
+        macDestAddr.SetShort(Get<Mle::Mle>().GetParent().GetRloc16());
         PrepareEmptyFrame(*frame, macDestAddr, /* aAckRequest */ true);
     }
     break;
@@ -815,59 +775,57 @@ exit:
 
 void MeshForwarder::PrepareMacHeaders(Mac::TxFrame &aTxFrame, Mac::TxFrame::Info &aTxFrameInfo, const Message *aMessage)
 {
+    const Neighbor *neighbor;
+
     aTxFrameInfo.mVersion = Mac::Frame::kVersion2006;
 
+#if OPENTHREAD_CONFIG_MAC_HEADER_IE_SUPPORT
+
+#if (OPENTHREAD_FTD && OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE) || OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE || \
+    OPENTHREAD_CONFIG_MLE_LINK_METRICS_INITIATOR_ENABLE
+
     //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-    // Determine Header IE entries
+    // Determine frame version and Header IE entries
 
-#if OPENTHREAD_CONFIG_MAC_HEADER_IE_SUPPORT
+    neighbor = Get<NeighborTable>().FindNeighbor(aTxFrameInfo.mAddrs.mDestination);
 
-#if OPENTHREAD_CONFIG_TIME_SYNC_ENABLE
-    if ((aMessage != nullptr) && aMessage->IsTimeSync())
+    if (neighbor == nullptr)
     {
-        aTxFrameInfo.mAppendTimeIe = true;
-        aTxFrameInfo.mVersion      = Mac::Frame::kVersion2015;
     }
-#endif
 #if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
-    if (Get<Mac::Mac>().IsCslEnabled() &&
-        !(aMessage != nullptr && aMessage->IsMleCommand(Mle::kCommandDiscoveryRequest)))
+    else if (Get<Mac::Mac>().IsCslEnabled())
     {
         aTxFrameInfo.mAppendCslIe = true;
         aTxFrameInfo.mVersion     = Mac::Frame::kVersion2015;
     }
 #endif
-
-    aTxFrameInfo.mEmptyPayload = (aMessage == nullptr) || (aMessage->GetLength() == 0);
-
-#endif // OPENTHREAD_CONFIG_MAC_HEADER_IE_SUPPORT
-
-#if (OPENTHREAD_FTD && OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE) || \
-    OPENTHREAD_CONFIG_MLE_LINK_METRICS_INITIATOR_ENABLE
-
-    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-    // Determine frame version
-
-    if (aTxFrameInfo.mVersion == Mac::Frame::kVersion2006)
-    {
-        const Neighbor *neighbor = Get<NeighborTable>().FindNeighbor(aTxFrameInfo.mAddrs.mDestination);
-
 #if OPENTHREAD_FTD && OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE
-        if ((neighbor != nullptr) && Get<ChildTable>().Contains(*neighbor) &&
-            static_cast<const Child *>(neighbor)->IsCslSynchronized())
-        {
-            aTxFrameInfo.mVersion = Mac::Frame::kVersion2015;
-        }
+    else if ((Get<ChildTable>().Contains(*neighbor) && static_cast<const Child *>(neighbor)->IsCslSynchronized()))
+    {
+        aTxFrameInfo.mVersion = Mac::Frame::kVersion2015;
+    }
 #endif
 #if OPENTHREAD_CONFIG_MLE_LINK_METRICS_INITIATOR_ENABLE
-        if ((neighbor != nullptr) && neighbor->IsEnhAckProbingActive())
-        {
-            aTxFrameInfo.mVersion = Mac::Frame::kVersion2015;
-        }
+    else if (neighbor->IsEnhAckProbingActive())
+    {
+        aTxFrameInfo.mVersion = Mac::Frame::kVersion2015;
+    }
 #endif
+
+#endif // (OPENTHREAD_FTD && OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE) || OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
+       // || OPENTHREAD_CONFIG_MLE_LINK_METRICS_INITIATOR_ENABLE
+
+#if OPENTHREAD_CONFIG_TIME_SYNC_ENABLE
+    if ((aMessage != nullptr) && aMessage->IsTimeSync())
+    {
+        aTxFrameInfo.mAppendTimeIe = true;
+        aTxFrameInfo.mVersion      = Mac::Frame::kVersion2015;
     }
+#endif
 
-#endif // OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE || OPENTHREAD_CONFIG_MLE_LINK_METRICS_INITIATOR_ENABLE
+    aTxFrameInfo.mEmptyPayload = (aMessage == nullptr) || (aMessage->GetLength() == 0);
+
+#endif // OPENTHREAD_CONFIG_MAC_HEADER_IE_SUPPORT
 
     //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     // Prepare MAC headers
@@ -875,6 +833,7 @@ void MeshForwarder::PrepareMacHeaders(Mac::TxFrame &aTxFrame, Mac::TxFrame::Info
     aTxFrameInfo.PrepareHeadersIn(aTxFrame);
 
     OT_UNUSED_VARIABLE(aMessage);
+    OT_UNUSED_VARIABLE(neighbor);
 }
 
 // This method constructs a MAC data from from a given IPv6 message.
@@ -1163,7 +1122,7 @@ void MeshForwarder::UpdateNeighborLinkFailures(Neighbor &aNeighbor,
             (aNeighbor.GetLinkFailures() >= aFailLimit))
         {
 #if OPENTHREAD_FTD
-            Get<Mle::MleRouter>().RemoveRouterLink(static_cast<Router &>(aNeighbor));
+            Get<Mle::Mle>().RemoveRouterLink(static_cast<Router &>(aNeighbor));
 #else
             IgnoreError(Get<Mle::Mle>().BecomeDetached());
 #endif
@@ -1316,10 +1275,7 @@ void MeshForwarder::FinalizeMessageDirectTx(Message &aMessage, Error aError)
         aMessage.SetTxSuccess(false);
     }
 
-    if (aMessage.GetType() == Message::kTypeIp6)
-    {
-        aMessage.GetTxSuccess() ? mIpCounters.mTxSuccess++ : mIpCounters.mTxFailure++;
-    }
+    mCounters.UpdateOnTxDone(aMessage, aMessage.GetTxSuccess());
 
     if (aMessage.IsMleCommand(Mle::kCommandDiscoveryRequest))
     {
@@ -1485,7 +1441,7 @@ void MeshForwarder::HandleFragment(RxInfo &aRxInfo)
         uint16_t datagramSize = fragmentHeader.GetDatagramSize();
 
 #if OPENTHREAD_FTD
-        UpdateRoutes(aRxInfo);
+        UpdateEidRlocCacheAndStaleChild(aRxInfo);
 #endif
 
         SuccessOrExit(error = FrameToMessage(aRxInfo, datagramSize, message));
@@ -1500,7 +1456,7 @@ void MeshForwarder::HandleFragment(RxInfo &aRxInfo)
         VerifyOrExit(Get<Ip6::Filter>().Accept(*message), error = kErrorDrop);
 
 #if OPENTHREAD_FTD
-        SendIcmpErrorIfDstUnreach(*message, aRxInfo.mMacAddrs);
+        CheckReachabilityToSendIcmpError(*message, aRxInfo.mMacAddrs);
 #endif
 
         // Allow re-assembly of only one message at a time on a SED by clearing
@@ -1574,12 +1530,7 @@ void MeshForwarder::ClearReassemblyList(void)
     for (Message &message : mReassemblyList)
     {
         LogMessage(kMessageReassemblyDrop, message, kErrorNoFrameReceived);
-
-        if (message.GetType() == Message::kTypeIp6)
-        {
-            mIpCounters.mRxFailure++;
-        }
-
+        mCounters.UpdateOnDrop(message);
         mReassemblyList.DequeueAndFree(message);
     }
 }
@@ -1609,12 +1560,7 @@ bool MeshForwarder::UpdateReassemblyList(void)
         if (now - message.GetTimestamp() >= TimeMilli::SecToMsec(kReassemblyTimeout))
         {
             LogMessage(kMessageReassemblyDrop, message, kErrorReassemblyTimeout);
-
-            if (message.GetType() == Message::kTypeIp6)
-            {
-                mIpCounters.mRxFailure++;
-            }
-
+            mCounters.UpdateOnDrop(message);
             mReassemblyList.DequeueAndFree(message);
         }
     }
@@ -1648,7 +1594,7 @@ void MeshForwarder::HandleLowpanHc(RxInfo &aRxInfo)
     Message *message = nullptr;
 
 #if OPENTHREAD_FTD
-    UpdateRoutes(aRxInfo);
+    UpdateEidRlocCacheAndStaleChild(aRxInfo);
 #endif
 
     SuccessOrExit(error = FrameToMessage(aRxInfo, 0, message));
@@ -1658,7 +1604,7 @@ void MeshForwarder::HandleLowpanHc(RxInfo &aRxInfo)
     VerifyOrExit(Get<Ip6::Filter>().Accept(*message), error = kErrorDrop);
 
 #if OPENTHREAD_FTD
-    SendIcmpErrorIfDstUnreach(*message, aRxInfo.mMacAddrs);
+    CheckReachabilityToSendIcmpError(*message, aRxInfo.mMacAddrs);
 #endif
 
 exit:
@@ -1682,10 +1628,7 @@ Error MeshForwarder::HandleDatagram(Message &aMessage, const Mac::Address &aMacS
 
     LogMessage(kMessageReceive, aMessage, kErrorNone, &aMacSource);
 
-    if (aMessage.GetType() == Message::kTypeIp6)
-    {
-        mIpCounters.mRxSuccess++;
-    }
+    mCounters.UpdateOnRx(aMessage);
 
     aMessage.SetLoopbackToHostAllowed(true);
     aMessage.SetOrigin(Message::kOriginThreadNetif);
@@ -1733,7 +1676,7 @@ Error MeshForwarder::SendEmptyMessage(void)
     OwnedPtr<Message> messagePtr;
 
     VerifyOrExit(mEnabled && !Get<Mac::Mac>().GetRxOnWhenIdle() &&
-                     Get<Mle::MleRouter>().GetParent().IsStateValidOrRestoring(),
+                     Get<Mle::Mle>().GetParent().IsStateValidOrRestoring(),
                  error = kErrorInvalidState);
 
     messagePtr.Reset(Get<MessagePool>().Allocate(Message::kTypeMacEmptyData));
@@ -1943,7 +1886,7 @@ void MeshForwarder::LogMessage(MessageAction       aAction,
 #if (OPENTHREAD_CONFIG_MAX_FRAMES_IN_DIRECT_TX_QUEUE > 0)
     case kMessageFullQueueDrop:
 #endif
-        logLevel = kLogLevelNote;
+        // default kLogLevelInfo for dropped message
         break;
     }
 
@@ -1973,7 +1916,7 @@ void MeshForwarder::LogFrame(const char *aActionText, const Mac::Frame &aFrame,
 {
     if (aError != kErrorNone)
     {
-        LogNote("%s, aError:%s, %s", aActionText, ErrorToString(aError), aFrame.ToInfoString().AsCString());
+        LogInfo("%s, aError:%s, %s", aActionText, ErrorToString(aError), aFrame.ToInfoString().AsCString());
     }
     else
     {
@@ -1985,14 +1928,14 @@ void MeshForwarder::LogFragmentFrameDrop(Error                         aError,
                                          const RxInfo                 &aRxInfo,
                                          const Lowpan::FragmentHeader &aFragmentHeader)
 {
-    LogNote("Dropping rx frag frame, error:%s, %s, tag:%d, offset:%d, dglen:%d", ErrorToString(aError),
+    LogInfo("Dropping rx frag frame, error:%s, %s, tag:%d, offset:%d, dglen:%d", ErrorToString(aError),
             aRxInfo.ToString().AsCString(), aFragmentHeader.GetDatagramTag(), aFragmentHeader.GetDatagramOffset(),
             aFragmentHeader.GetDatagramSize());
 }
 
 void MeshForwarder::LogLowpanHcFrameDrop(Error aError, const RxInfo &aRxInfo)
 {
-    LogNote("Dropping rx lowpan HC frame, error:%s, %s", ErrorToString(aError), aRxInfo.ToString().AsCString());
+    LogInfo("Dropping rx lowpan HC frame, error:%s, %s", ErrorToString(aError), aRxInfo.ToString().AsCString());
 }
 
 MeshForwarder::RxInfo::InfoString MeshForwarder::RxInfo::ToString(void) const
diff --git a/src/core/thread/mesh_forwarder.hpp b/src/core/thread/mesh_forwarder.hpp
index 4a27db389..1ef11cc15 100644
--- a/src/core/thread/mesh_forwarder.hpp
+++ b/src/core/thread/mesh_forwarder.hpp
@@ -55,6 +55,7 @@
 #include "thread/indirect_sender.hpp"
 #include "thread/lowpan.hpp"
 #include "thread/network_data_leader.hpp"
+#include "thread/thread_link_info.hpp"
 
 namespace ot {
 
@@ -75,80 +76,6 @@ class HistoryTracker;
  * @{
  */
 
-/**
- * Represents link-specific information for messages received from the Thread radio.
- */
-class ThreadLinkInfo : public otThreadLinkInfo, public Clearable<ThreadLinkInfo>
-{
-public:
-    /**
-     * Returns the IEEE 802.15.4 Source PAN ID.
-     *
-     * @returns The IEEE 802.15.4 Source PAN ID.
-     */
-    Mac::PanId GetPanId(void) const { return mPanId; }
-
-    /**
-     * Returns the IEEE 802.15.4 Channel.
-     *
-     * @returns The IEEE 802.15.4 Channel.
-     */
-    uint8_t GetChannel(void) const { return mChannel; }
-
-    /**
-     * Returns whether the Destination PAN ID is broadcast.
-     *
-     * @retval TRUE   If Destination PAN ID is broadcast.
-     * @retval FALSE  If Destination PAN ID is not broadcast.
-     */
-    bool IsDstPanIdBroadcast(void) const { return mIsDstPanIdBroadcast; }
-
-    /**
-     * Indicates whether or not link security is enabled.
-     *
-     * @retval TRUE   If link security is enabled.
-     * @retval FALSE  If link security is not enabled.
-     */
-    bool IsLinkSecurityEnabled(void) const { return mLinkSecurity; }
-
-    /**
-     * Returns the Received Signal Strength (RSS) in dBm.
-     *
-     * @returns The Received Signal Strength (RSS) in dBm.
-     */
-    int8_t GetRss(void) const { return mRss; }
-
-    /**
-     * Returns the frame/radio Link Quality Indicator (LQI) value.
-     *
-     * @returns The Link Quality Indicator value.
-     */
-    uint8_t GetLqi(void) const { return mLqi; }
-
-#if OPENTHREAD_CONFIG_TIME_SYNC_ENABLE
-    /**
-     * Returns the Time Sync Sequence.
-     *
-     * @returns The Time Sync Sequence.
-     */
-    uint8_t GetTimeSyncSeq(void) const { return mTimeSyncSeq; }
-
-    /**
-     * Returns the time offset to the Thread network time (in microseconds).
-     *
-     * @returns The time offset to the Thread network time (in microseconds).
-     */
-    int64_t GetNetworkTimeOffset(void) const { return mNetworkTimeOffset; }
-#endif
-
-    /**
-     * Sets the `ThreadLinkInfo` from a given received frame.
-     *
-     * @param[in] aFrame  A received frame.
-     */
-    void SetFrom(const Mac::RxFrame &aFrame);
-};
-
 /**
  * Implements mesh forwarding within Thread.
  */
@@ -163,6 +90,22 @@ class MeshForwarder : public InstanceLocator, private NonCopyable
     friend class TimeTicker;
 
 public:
+    /**
+     * Represents the IPv6 message counters, tracking the number IPv6 message TX and RX that succeeded or failed.
+     */
+    class Counters : public otIpCounters, public Clearable<Counters>
+    {
+        friend class MeshForwarder;
+        friend class IndirectSender;
+
+    private:
+        Counters(void) { Clear(); }
+
+        void UpdateOnTxDone(const Message &aMessage, bool aTxSuccess);
+        void UpdateOnRx(const Message &aMessage);
+        void UpdateOnDrop(const Message &aMessage);
+    };
+
     /**
      * Initializes the object.
      *
@@ -251,30 +194,30 @@ public:
     Error EvictMessage(Message::Priority aPriority);
 
     /**
-     * Returns a reference to the send queue.
+     * Retrieves information about the send queue and the reassembly queue.
      *
-     * @returns  A reference to the send queue.
-     */
-    const PriorityQueue &GetSendQueue(void) const { return mSendQueue; }
-
-    /**
-     * Returns a reference to the reassembly queue.
+     * Provides details such as the number of messages and data buffers currently utilized by the priority send queue
+     * and the message reassembly queue.
      *
-     * @returns  A reference to the reassembly queue.
+     * @param[out] aSendQueueInfo         A `PriorityQueue::Info` to populate with info about the send queue.
+     * @param[out] aReassemblyQueueInfo   A `MessageQueue::Info` to populate with info about the reassembly queue.
      */
-    const MessageQueue &GetReassemblyQueue(void) const { return mReassemblyList; }
+    void GetQueueInfo(PriorityQueue::Info &aSendQueueInfo, MessageQueue::Info &aReassemblyQueueInfo) const
+    {
+        mSendQueue.GetInfo(aSendQueueInfo), mReassemblyList.GetInfo(aReassemblyQueueInfo);
+    }
 
     /**
      * Returns a reference to the IP level counters.
      *
      * @returns A reference to the IP level counters.
      */
-    const otIpCounters &GetCounters(void) const { return mIpCounters; }
+    const Counters &GetCounters(void) const { return mCounters; }
 
     /**
      * Resets the IP level counters.
      */
-    void ResetCounters(void) { ClearAllBytes(mIpCounters); }
+    void ResetCounters(void) { mCounters.Clear(); }
 
 #if OPENTHREAD_CONFIG_TX_QUEUE_STATISTICS_ENABLE
     /**
@@ -486,12 +429,13 @@ private:
     };
 #endif
 
-    void     SendIcmpErrorIfDstUnreach(const Message &aMessage, const Mac::Addresses &aMacAddrs);
-    Error    CheckReachability(RxInfo &aRxInfo);
-    Error    CheckReachability(uint16_t aMeshDest, const Ip6::Header &aIp6Header);
-    void     UpdateRoutes(RxInfo &aRxInfo);
+#if OPENTHREAD_FTD
+    bool  IsReachable(uint16_t aMeshDest, const Ip6::Header &aIp6Header) const;
+    void  CheckReachabilityToSendIcmpError(const Message &aMessage, const Mac::Addresses &aMacAddrs);
+    Error CheckReachabilityToSendIcmpError(RxInfo &aRxInfo);
+#endif
+    void     UpdateEidRlocCacheAndStaleChild(RxInfo &aRxInfo);
     Error    FrameToMessage(RxInfo &aRxInfo, uint16_t aDatagramSize, Message *&aMessage);
-    void     GetMacDestinationAddress(const Ip6::Address &aIp6Addr, Mac::Address &aMacAddr);
     void     GetMacSourceAddress(const Ip6::Address &aIp6Addr, Mac::Address &aMacAddr);
     Message *PrepareNextDirectTransmission(void);
     void     HandleMesh(RxInfo &aRxInfo);
@@ -641,7 +585,7 @@ private:
 
     TxTask mScheduleTransmissionTask;
 
-    otIpCounters mIpCounters;
+    Counters mCounters;
 
 #if OPENTHREAD_FTD || OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE
     IndirectSender mIndirectSender;
@@ -662,8 +606,6 @@ private:
  * @}
  */
 
-DefineCoreType(otThreadLinkInfo, ThreadLinkInfo);
-
 } // namespace ot
 
 #endif // MESH_FORWARDER_HPP_
diff --git a/src/core/thread/mesh_forwarder_ftd.cpp b/src/core/thread/mesh_forwarder_ftd.cpp
index 270a41b30..2fa63becb 100644
--- a/src/core/thread/mesh_forwarder_ftd.cpp
+++ b/src/core/thread/mesh_forwarder_ftd.cpp
@@ -389,9 +389,11 @@ exit:
 
 Error MeshForwarder::UpdateIp6RouteFtd(const Ip6::Header &aIp6Header, Message &aMessage)
 {
-    Mle::MleRouter &mle   = Get<Mle::MleRouter>();
-    Error           error = kErrorNone;
-    Neighbor       *neighbor;
+    Mle::Mle &mle   = Get<Mle::Mle>();
+    Error     error = kErrorNone;
+    Neighbor *neighbor;
+
+    mMeshDest = Mle::kInvalidRloc16;
 
     if (aMessage.GetOffset() > 0)
     {
@@ -400,6 +402,7 @@ Error MeshForwarder::UpdateIp6RouteFtd(const Ip6::Header &aIp6Header, Message &a
     else if (mle.IsRoutingLocator(aIp6Header.GetDestination()))
     {
         uint16_t rloc16 = aIp6Header.GetDestination().GetIid().GetLocator();
+
         VerifyOrExit(Mle::IsRouterIdValid(Mle::RouterIdFromRloc16(rloc16)), error = kErrorDrop);
         mMeshDest = rloc16;
     }
@@ -430,21 +433,21 @@ Error MeshForwarder::UpdateIp6RouteFtd(const Ip6::Header &aIp6Header, Message &a
     {
         mMeshDest = neighbor->GetRloc16();
     }
-    else if (Get<NetworkData::Leader>().IsOnMesh(aIp6Header.GetDestination()))
+    else if (Get<Ip6::Ip6>().IsOnLink(aIp6Header.GetDestination()))
     {
         SuccessOrExit(error = Get<AddressResolver>().Resolve(aIp6Header.GetDestination(), mMeshDest));
     }
     else
     {
-        IgnoreError(
-            Get<NetworkData::Leader>().RouteLookup(aIp6Header.GetSource(), aIp6Header.GetDestination(), mMeshDest));
+        SuccessOrExit(error = Get<NetworkData::Leader>().RouteLookup(aIp6Header.GetSource(),
+                                                                     aIp6Header.GetDestination(), mMeshDest));
     }
 
     VerifyOrExit(mMeshDest != Mle::kInvalidRloc16, error = kErrorDrop);
 
     mMeshSource = Get<Mle::Mle>().GetRloc16();
 
-    SuccessOrExit(error = CheckReachability(mMeshDest, aIp6Header));
+    VerifyOrExit(IsReachable(mMeshDest, aIp6Header), error = kErrorNoRoute);
     aMessage.SetMeshDest(mMeshDest);
     mMacAddrs.mDestination.SetShort(Get<RouterTable>().GetNextHop(mMeshDest));
 
@@ -462,9 +465,8 @@ exit:
     return error;
 }
 
-void MeshForwarder::SendIcmpErrorIfDstUnreach(const Message &aMessage, const Mac::Addresses &aMacAddrs)
+void MeshForwarder::CheckReachabilityToSendIcmpError(const Message &aMessage, const Mac::Addresses &aMacAddrs)
 {
-    Error        error;
     Ip6::Headers ip6Headers;
     Child       *child;
 
@@ -478,9 +480,7 @@ void MeshForwarder::SendIcmpErrorIfDstUnreach(const Message &aMessage, const Mac
     VerifyOrExit(!ip6Headers.GetDestinationAddress().IsMulticast() &&
                  Get<NetworkData::Leader>().IsOnMesh(ip6Headers.GetDestinationAddress()));
 
-    error = CheckReachability(aMacAddrs.mDestination.GetShort(), ip6Headers.GetIp6Header());
-
-    if (error == kErrorNoRoute)
+    if (!IsReachable(aMacAddrs.mDestination.GetShort(), ip6Headers.GetIp6Header()))
     {
         SendDestinationUnreachable(aMacAddrs.mSource.GetShort(), ip6Headers);
     }
@@ -489,8 +489,12 @@ exit:
     return;
 }
 
-Error MeshForwarder::CheckReachability(RxInfo &aRxInfo)
+Error MeshForwarder::CheckReachabilityToSendIcmpError(RxInfo &aRxInfo)
 {
+    // Checks reachability to the destination, and if not reachable,
+    // sends an ICMP6 destination unreachable error to the source.
+    // Returns `kErrorNone` if reachable, `kErrorNoRoute` otherwise.
+
     Error error;
 
     error = aRxInfo.ParseIp6Headers();
@@ -507,18 +511,17 @@ Error MeshForwarder::CheckReachability(RxInfo &aRxInfo)
         ExitNow();
     }
 
-    error = CheckReachability(aRxInfo.GetDstAddr().GetShort(), aRxInfo.mIp6Headers.GetIp6Header());
-
-    if (error == kErrorNoRoute)
+    if (!IsReachable(aRxInfo.GetDstAddr().GetShort(), aRxInfo.mIp6Headers.GetIp6Header()))
     {
         SendDestinationUnreachable(aRxInfo.GetSrcAddr().GetShort(), aRxInfo.mIp6Headers);
+        error = kErrorNoRoute;
     }
 
 exit:
     return error;
 }
 
-Error MeshForwarder::CheckReachability(uint16_t aMeshDest, const Ip6::Header &aIp6Header)
+bool MeshForwarder::IsReachable(uint16_t aMeshDest, const Ip6::Header &aIp6Header) const
 {
     bool isReachable = false;
 
@@ -552,7 +555,7 @@ Error MeshForwarder::CheckReachability(uint16_t aMeshDest, const Ip6::Header &aI
     isReachable = (Get<RouterTable>().GetNextHop(aMeshDest) != Mle::kInvalidRloc16);
 
 exit:
-    return isReachable ? kErrorNone : kErrorNoRoute;
+    return isReachable;
 }
 
 void MeshForwarder::SendDestinationUnreachable(uint16_t aMeshSource, const Ip6::Headers &aIp6Headers)
@@ -583,7 +586,7 @@ void MeshForwarder::HandleMesh(RxInfo &aRxInfo)
     aRxInfo.mMacAddrs.mSource.SetShort(meshHeader.GetSource());
     aRxInfo.mMacAddrs.mDestination.SetShort(meshHeader.GetDestination());
 
-    UpdateRoutes(aRxInfo);
+    UpdateEidRlocCacheAndStaleChild(aRxInfo);
 
     if (Get<Mle::Mle>().HasRloc16(aRxInfo.GetDstAddr().GetShort()) ||
         Get<ChildTable>().HasMinimalChild(aRxInfo.GetDstAddr().GetShort()))
@@ -608,7 +611,7 @@ void MeshForwarder::HandleMesh(RxInfo &aRxInfo)
 
         ResolveRoutingLoops(neighborMacSource.GetShort(), aRxInfo.GetDstAddr().GetShort());
 
-        SuccessOrExit(error = CheckReachability(aRxInfo));
+        SuccessOrExit(error = CheckReachabilityToSendIcmpError(aRxInfo));
 
         meshHeader.DecrementHopsLeft();
 
@@ -660,13 +663,13 @@ void MeshForwarder::ResolveRoutingLoops(uint16_t aSourceRloc16, uint16_t aDestRl
     VerifyOrExit(router != nullptr);
 
     router->SetNextHopToInvalid();
-    Get<Mle::MleRouter>().ResetAdvertiseInterval();
+    Get<Mle::Mle>().ResetAdvertiseInterval();
 
 exit:
     return;
 }
 
-void MeshForwarder::UpdateRoutes(RxInfo &aRxInfo)
+void MeshForwarder::UpdateEidRlocCacheAndStaleChild(RxInfo &aRxInfo)
 {
     Neighbor *neighbor;
 
@@ -685,12 +688,15 @@ void MeshForwarder::UpdateRoutes(RxInfo &aRxInfo)
             aRxInfo.mIp6Headers.GetSourceAddress(), aRxInfo.GetSrcAddr().GetShort(), aRxInfo.GetDstAddr().GetShort());
     }
 
+    // Detect if a former child has moved to a new parent by
+    // inspecting the received message.
+
     neighbor = Get<NeighborTable>().FindNeighbor(aRxInfo.mIp6Headers.GetSourceAddress());
     VerifyOrExit(neighbor != nullptr && !neighbor->IsFullThreadDevice());
 
     if (!Get<Mle::Mle>().HasMatchingRouterIdWith(aRxInfo.GetSrcAddr().GetShort()))
     {
-        Get<Mle::MleRouter>().RemoveNeighbor(*neighbor);
+        Get<Mle::Mle>().RemoveNeighbor(*neighbor);
     }
 
 exit:
@@ -826,7 +832,7 @@ void MeshForwarder::GetForwardFramePriority(RxInfo &aRxInfo, Message::Priority &
 exit:
     if (error != kErrorNone)
     {
-        LogNote("Failed to get forwarded frame priority, error:%s, %s", ErrorToString(error),
+        LogInfo("Failed to get forwarded frame priority, error:%s, %s", ErrorToString(error),
                 aRxInfo.ToString().AsCString());
     }
     else if (isFragment)
diff --git a/src/core/thread/mle.cpp b/src/core/thread/mle.cpp
index 9ab034f05..f6d14d852 100644
--- a/src/core/thread/mle.cpp
+++ b/src/core/thread/mle.cpp
@@ -92,6 +92,36 @@ Mle::Mle(Instance &aInstance)
     , mWedAttachState(kWedDetached)
     , mWedAttachTimer(aInstance)
 #endif
+#if OPENTHREAD_FTD
+    , mRouterEligible(true)
+    , mAddressSolicitPending(false)
+    , mAddressSolicitRejected(false)
+#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
+    , mCcmEnabled(false)
+    , mThreadVersionCheckEnabled(true)
+#endif
+    , mNetworkIdTimeout(kNetworkIdTimeout)
+    , mRouterUpgradeThreshold(kRouterUpgradeThreshold)
+    , mRouterDowngradeThreshold(kRouterDowngradeThreshold)
+    , mPreviousPartitionRouterIdSequence(0)
+    , mPreviousPartitionIdTimeout(0)
+    , mChildRouterLinks(kChildRouterLinks)
+    , mAlternateRloc16Timeout(0)
+#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
+    , mMaxChildIpAddresses(0)
+#endif
+    , mParentPriority(kParentPriorityUnspecified)
+    , mNextChildId(kMaxChildId)
+    , mPreviousPartitionIdRouter(0)
+    , mPreviousPartitionId(0)
+#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
+    , mPreferredLeaderPartitionId(0)
+#endif
+    , mAdvertiseTrickleTimer(aInstance, Mle::HandleAdvertiseTrickleTimer)
+    , mChildTable(aInstance)
+    , mRouterTable(aInstance)
+    , mRouterRoleRestorer(aInstance)
+#endif // OPENTHREAD_FTD
 {
     mParent.Init(aInstance);
     mParentCandidate.Init(aInstance);
@@ -121,6 +151,26 @@ Mle::Mle(Instance &aInstance)
 
     mMeshLocalPrefix.Clear();
     SetMeshLocalPrefix(AsCoreType(&kMeshLocalPrefixInit));
+
+#if OPENTHREAD_FTD
+
+    mDeviceMode.Set(mDeviceMode.Get() | DeviceMode::kModeFullThreadDevice | DeviceMode::kModeFullNetworkData);
+
+#if OPENTHREAD_CONFIG_MLE_DEVICE_PROPERTY_LEADER_WEIGHT_ENABLE
+    mLeaderWeight = mDeviceProperties.CalculateLeaderWeight();
+#else
+    mLeaderWeight = kDefaultLeaderWeight;
+#endif
+
+    mLeaderAloc.InitAsThreadOriginMeshLocal();
+
+    SetRouterId(kInvalidRouterId);
+
+#if OPENTHREAD_CONFIG_MLE_STEERING_DATA_SET_OOB_ENABLE
+    mSteeringData.Clear();
+#endif
+
+#endif // OPENTHREAD_FTD
 }
 
 Error Mle::Enable(void)
@@ -193,7 +243,7 @@ Error Mle::Start(StartMode aMode)
 #if OPENTHREAD_FTD
     else if (IsRouterRloc16(GetRloc16()))
     {
-        if (Get<MleRouter>().BecomeRouter(ThreadStatusTlv::kTooFewRouters) != kErrorNone)
+        if (BecomeRouter(ThreadStatusTlv::kTooFewRouters) != kErrorNone)
         {
             Attach(kAnyPartition);
         }
@@ -228,7 +278,7 @@ void Mle::Stop(StopMode aMode)
     Get<ThreadNetif>().RemoveUnicastAddress(mMeshLocalEid);
 
 #if OPENTHREAD_FTD
-    Get<MleRouter>().mRouterRoleRestorer.Stop();
+    mRouterRoleRestorer.Stop();
 #endif
 
     SetRole(kRoleDisabled);
@@ -243,9 +293,7 @@ exit:
 
 const Counters &Mle::GetCounters(void)
 {
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
     UpdateRoleTimeCounters(mRole);
-#endif
 
     return mCounters;
 }
@@ -253,16 +301,12 @@ const Counters &Mle::GetCounters(void)
 void Mle::ResetCounters(void)
 {
     ClearAllBytes(mCounters);
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
     mLastUpdatedTimestamp = Get<Uptime>().GetUptime();
-#endif
 }
 
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
-
 uint32_t Mle::GetCurrentAttachDuration(void) const
 {
-    return IsAttached() ? Uptime::MsecToSec(Get<Uptime>().GetUptime()) - mLastAttachTime : 0;
+    return IsAttached() ? Get<Uptime>().GetUptimeInSeconds() - mLastAttachTime : 0;
 }
 
 void Mle::UpdateRoleTimeCounters(DeviceRole aRole)
@@ -294,8 +338,6 @@ void Mle::UpdateRoleTimeCounters(DeviceRole aRole)
     }
 }
 
-#endif // OPENTHREAD_CONFIG_UPTIME_ENABLE
-
 void Mle::SetRole(DeviceRole aRole)
 {
     DeviceRole oldRole = mRole;
@@ -304,14 +346,12 @@ void Mle::SetRole(DeviceRole aRole)
 
     LogNote("Role %s -> %s", RoleToString(oldRole), RoleToString(mRole));
 
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
     if ((oldRole == kRoleDetached) && IsAttached())
     {
-        mLastAttachTime = Uptime::MsecToSec(Get<Uptime>().GetUptime());
+        mLastAttachTime = Get<Uptime>().GetUptimeInSeconds();
     }
 
     UpdateRoleTimeCounters(oldRole);
-#endif
 
     switch (mRole)
     {
@@ -349,6 +389,10 @@ void Mle::SetRole(DeviceRole aRole)
         mInitiallyAttachedAsSleepy = !GetDeviceMode().IsRxOnWhenIdle();
     }
 
+#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
+    Get<Mac::Mac>().SetCslCapable(IsCslSupported() && !IsRxOnWhenIdle());
+#endif
+
 exit:
     return;
 }
@@ -448,8 +492,8 @@ void Mle::Restore(void)
 #if OPENTHREAD_FTD
     else
     {
-        Get<MleRouter>().SetRouterId(RouterIdFromRloc16(GetRloc16()));
-        Get<MleRouter>().SetPreviousPartitionId(networkInfo.GetPreviousPartitionId());
+        SetRouterId(RouterIdFromRloc16(GetRloc16()));
+        SetPreviousPartitionId(networkInfo.GetPreviousPartitionId());
         Get<ChildTable>().Restore();
     }
 #endif
@@ -609,7 +653,7 @@ void Mle::Attach(AttachMode aMode)
 #if OPENTHREAD_FTD
         if (IsFullThreadDevice())
         {
-            Get<MleRouter>().StopAdvertiseTrickleTimer();
+            StopAdvertiseTrickleTimer();
         }
 #endif
     }
@@ -701,7 +745,7 @@ void Mle::SetStateDetached(void)
 #if OPENTHREAD_FTD
     if (IsLeader())
     {
-        Get<ThreadNetif>().RemoveUnicastAddress(Get<MleRouter>().mLeaderAloc);
+        Get<ThreadNetif>().RemoveUnicastAddress(mLeaderAloc);
     }
 #endif
 
@@ -718,11 +762,8 @@ void Mle::SetStateDetached(void)
     Get<MeshForwarder>().SetRxOnWhenIdle(true);
     Get<Mac::Mac>().SetBeaconEnabled(false);
 #if OPENTHREAD_FTD
-    Get<MleRouter>().ClearAlternateRloc16();
-    Get<MleRouter>().HandleDetachStart();
-#endif
-#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
-    Get<Mac::Mac>().UpdateCsl();
+    ClearAlternateRloc16();
+    HandleDetachStart();
 #endif
 }
 
@@ -731,7 +772,7 @@ void Mle::SetStateChild(uint16_t aRloc16)
 #if OPENTHREAD_FTD
     if (IsLeader())
     {
-        Get<ThreadNetif>().RemoveUnicastAddress(Get<MleRouter>().mLeaderAloc);
+        Get<ThreadNetif>().RemoveUnicastAddress(mLeaderAloc);
     }
 #endif
 
@@ -748,7 +789,7 @@ void Mle::SetStateChild(uint16_t aRloc16)
 #if OPENTHREAD_FTD
     if (IsFullThreadDevice())
     {
-        Get<MleRouter>().HandleChildStart(mAttachMode);
+        HandleChildStart(mAttachMode);
     }
 #endif
 
@@ -769,10 +810,6 @@ void Mle::SetStateChild(uint16_t aRloc16)
     }
 
     mPreviousParentRloc = mParent.GetRloc16();
-
-#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
-    Get<Mac::Mac>().UpdateCsl();
-#endif
 }
 
 void Mle::InformPreviousChannel(void)
@@ -781,7 +818,7 @@ void Mle::InformPreviousChannel(void)
     VerifyOrExit(IsChild() || IsRouter());
 
 #if OPENTHREAD_FTD
-    VerifyOrExit(!IsFullThreadDevice() || IsRouter() || !Get<MleRouter>().IsRouterRoleTransitionPending());
+    VerifyOrExit(!IsFullThreadDevice() || IsRouter() || !IsRouterRoleTransitionPending());
 #endif
 
     mAlternatePanId = Mac::kPanIdBroadcast;
@@ -852,7 +889,7 @@ Error Mle::SetDeviceMode(DeviceMode aDeviceMode)
 #if OPENTHREAD_FTD
     if (!aDeviceMode.IsFullThreadDevice())
     {
-        Get<MleRouter>().ClearAlternateRloc16();
+        ClearAlternateRloc16();
     }
 #endif
 
@@ -998,7 +1035,7 @@ void Mle::SetRloc16(uint16_t aRloc16)
     else
     {
 #if OPENTHREAD_FTD
-        Get<MleRouter>().ClearAlternateRloc16();
+        ClearAlternateRloc16();
 #endif
     }
 }
@@ -1013,7 +1050,7 @@ void Mle::SetLeaderData(uint32_t aPartitionId, uint8_t aWeighting, uint8_t aLead
     if (mLeaderData.GetPartitionId() != aPartitionId)
     {
 #if OPENTHREAD_FTD
-        Get<MleRouter>().HandlePartitionChange();
+        HandlePartitionChange();
 #endif
         Get<Notifier>().Signal(kEventThreadPartitionIdChanged);
         mCounters.mPartitionIdChanges++;
@@ -1098,11 +1135,13 @@ void Mle::SetCslTimeout(uint32_t aTimeout)
 exit:
     return;
 }
+
+bool Mle::IsCslSupported(void) const { return IsChild() && GetParent().IsThreadVersion1p2OrHigher(); }
 #endif
 
 void Mle::InitNeighbor(Neighbor &aNeighbor, const RxInfo &aRxInfo)
 {
-    aRxInfo.mMessageInfo.GetPeerAddr().GetIid().ConvertToExtAddress(aNeighbor.GetExtAddress());
+    aNeighbor.GetExtAddress().SetFromIid(aRxInfo.mMessageInfo.GetPeerAddr().GetIid());
     aNeighbor.GetLinkInfo().Clear();
     aNeighbor.GetLinkInfo().AddRss(aRxInfo.mMessage.GetAverageRss());
     aNeighbor.ResetLinkFailures();
@@ -1172,7 +1211,7 @@ void Mle::HandleNotifierEvents(Events aEvents)
 #if OPENTHREAD_FTD
         if (IsFullThreadDevice())
         {
-            Get<MleRouter>().HandleNetworkDataUpdateRouter();
+            HandleNetworkDataUpdateRouter();
         }
         else
 #endif
@@ -1217,7 +1256,7 @@ void Mle::HandleNotifierEvents(Events aEvents)
 #if OPENTHREAD_FTD
     if (aEvents.Contains(kEventSecurityPolicyChanged))
     {
-        Get<MleRouter>().HandleSecurityPolicyChanged();
+        HandleSecurityPolicyChanged();
     }
 #endif
 
@@ -1457,9 +1496,9 @@ void Mle::HandleAttachTimer(void)
     }
 
 #if OPENTHREAD_FTD
-    if (IsDetached() && Get<MleRouter>().mRouterRoleRestorer.IsActive())
+    if (IsDetached() && mRouterRoleRestorer.IsActive())
     {
-        Get<MleRouter>().mRouterRoleRestorer.HandleTimer();
+        mRouterRoleRestorer.HandleTimer();
         ExitNow();
     }
 #endif
@@ -1624,7 +1663,7 @@ uint32_t Mle::Reattach(void)
                 IgnoreError(BecomeDetached());
             }
 #if OPENTHREAD_FTD
-            else if (IsFullThreadDevice() && Get<MleRouter>().BecomeLeader(/* aCheckWeight */ false) == kErrorNone)
+            else if (IsFullThreadDevice() && BecomeLeader(/* aCheckWeight */ false) == kErrorNone)
             {
                 // do nothing
             }
@@ -2311,7 +2350,7 @@ Error Mle::ProcessMessageSecurity(Crypto::AesCcm::Mode    aMode,
         break;
     }
 
-    senderAddress->GetIid().ConvertToExtAddress(extAddress);
+    extAddress.SetFromIid(senderAddress->GetIid());
     Crypto::AesCcm::GenerateNonce(extAddress, aHeader.GetFrameCounter(), Mac::Frame::kSecurityEncMic32, nonce);
 
     keySequence = aHeader.GetKeyId();
@@ -2385,7 +2424,7 @@ void Mle::HandleUdpReceive(Message &aMessage, const Ip6::MessageInfo &aMessageIn
         {
 #if OPENTHREAD_FTD
         case kCommandDiscoveryRequest:
-            Get<MleRouter>().HandleDiscoveryRequest(rxInfo);
+            HandleDiscoveryRequest(rxInfo);
             break;
 #endif
         case kCommandDiscoveryResponse:
@@ -2416,7 +2455,7 @@ void Mle::HandleUdpReceive(Message &aMessage, const Ip6::MessageInfo &aMessageIn
     IgnoreError(aMessage.Read(aMessage.GetOffset(), command));
     aMessage.MoveOffset(sizeof(command));
 
-    aMessageInfo.GetPeerAddr().GetIid().ConvertToExtAddress(extAddr);
+    extAddr.SetFromIid(aMessageInfo.GetPeerAddr().GetIid());
     neighbor = (command == kCommandChildIdResponse) ? mNeighborTable.FindParent(extAddr)
                                                     : mNeighborTable.FindNeighbor(extAddr);
 
@@ -2548,27 +2587,27 @@ void Mle::HandleUdpReceive(Message &aMessage, const Ip6::MessageInfo &aMessageIn
 
 #if OPENTHREAD_FTD
     case kCommandLinkRequest:
-        Get<MleRouter>().HandleLinkRequest(rxInfo);
+        HandleLinkRequest(rxInfo);
         break;
 
     case kCommandLinkAccept:
-        Get<MleRouter>().HandleLinkAccept(rxInfo);
+        HandleLinkAccept(rxInfo);
         break;
 
     case kCommandLinkAcceptAndRequest:
-        Get<MleRouter>().HandleLinkAcceptAndRequest(rxInfo);
+        HandleLinkAcceptAndRequest(rxInfo);
         break;
 
     case kCommandDataRequest:
-        Get<MleRouter>().HandleDataRequest(rxInfo);
+        HandleDataRequest(rxInfo);
         break;
 
     case kCommandParentRequest:
-        Get<MleRouter>().HandleParentRequest(rxInfo);
+        HandleParentRequest(rxInfo);
         break;
 
     case kCommandChildIdRequest:
-        Get<MleRouter>().HandleChildIdRequest(rxInfo);
+        HandleChildIdRequest(rxInfo);
         break;
 #endif // OPENTHREAD_FTD
 
@@ -2719,14 +2758,14 @@ void Mle::ReestablishLinkWithNeighbor(Neighbor &aNeighbor)
 
     if (IsRouterRloc16(aNeighbor.GetRloc16()))
     {
-        Get<MleRouter>().SendLinkRequest(static_cast<Router *>(&aNeighbor));
+        SendLinkRequest(static_cast<Router *>(&aNeighbor));
     }
     else if (Get<ChildTable>().Contains(aNeighbor))
     {
         Child &child = static_cast<Child &>(aNeighbor);
 
         child.SetState(Child::kStateChildUpdateRequest);
-        IgnoreError(Get<MleRouter>().SendChildUpdateRequestToChild(child));
+        IgnoreError(SendChildUpdateRequestToChild(child));
     }
 #endif
 
@@ -2752,7 +2791,7 @@ void Mle::HandleAdvertisement(RxInfo &aRxInfo)
 #if OPENTHREAD_FTD
     if (IsFullThreadDevice())
     {
-        SuccessOrExit(error = Get<MleRouter>().HandleAdvertisementOnFtd(aRxInfo, sourceAddress, leaderData));
+        SuccessOrExit(error = HandleAdvertisementOnFtd(aRxInfo, sourceAddress, leaderData));
     }
 #endif
 
@@ -2773,7 +2812,7 @@ void Mle::HandleAdvertisement(RxInfo &aRxInfo)
             SetLeaderData(leaderData);
 
 #if OPENTHREAD_FTD
-            SuccessOrExit(error = Get<MleRouter>().ReadAndProcessRouteTlvOnFtdChild(aRxInfo, mParent.GetRouterId()));
+            SuccessOrExit(error = ReadAndProcessRouteTlvOnFtdChild(aRxInfo, mParent.GetRouterId()));
 #endif
 
             mRetrieveNewNetworkData = true;
@@ -2819,7 +2858,7 @@ void Mle::HandleDataResponse(RxInfo &aRxInfo)
 #endif
 
 #if OPENTHREAD_FTD
-    SuccessOrExit(error = Get<MleRouter>().ReadAndProcessRouteTlvOnFtdChild(aRxInfo, mParent.GetRouterId()));
+    SuccessOrExit(error = ReadAndProcessRouteTlvOnFtdChild(aRxInfo, mParent.GetRouterId()));
 #endif
 
     error = HandleLeaderData(aRxInfo);
@@ -3085,7 +3124,7 @@ void Mle::HandleParentResponse(RxInfo &aRxInfo)
 
     SuccessOrExit(error = aRxInfo.mMessage.ReadAndMatchResponseTlvWith(mParentRequestChallenge));
 
-    aRxInfo.mMessageInfo.GetPeerAddr().GetIid().ConvertToExtAddress(extAddress);
+    extAddress.SetFromIid(aRxInfo.mMessageInfo.GetPeerAddr().GetIid());
 
     if (IsChild() && mParent.GetExtAddress() == extAddress)
     {
@@ -3160,8 +3199,8 @@ void Mle::HandleParentResponse(RxInfo &aRxInfo)
         case kBetterPartition:
             VerifyOrExit(!isPartitionIdSame);
 
-            VerifyOrExit(MleRouter::ComparePartitions(connectivityTlv.IsSingleton(), leaderData,
-                                                      Get<MleRouter>().IsSingleton(), mLeaderData) > 0);
+            VerifyOrExit(Mle::ComparePartitions(connectivityTlv.IsSingleton(), leaderData, IsSingleton(), mLeaderData) >
+                         0);
             break;
 
         case kBetterParent:
@@ -3183,8 +3222,8 @@ void Mle::HandleParentResponse(RxInfo &aRxInfo)
 #if OPENTHREAD_FTD
         if (IsFullThreadDevice())
         {
-            compare = MleRouter::ComparePartitions(connectivityTlv.IsSingleton(), leaderData,
-                                                   mParentCandidate.mIsSingleton, mParentCandidate.mLeaderData);
+            compare = Mle::ComparePartitions(connectivityTlv.IsSingleton(), leaderData, mParentCandidate.mIsSingleton,
+                                             mParentCandidate.mLeaderData);
         }
 
         // Only consider partitions that are the same or better
@@ -3324,8 +3363,7 @@ void Mle::HandleChildIdResponse(RxInfo &aRxInfo)
     SetLeaderData(leaderData);
 
 #if OPENTHREAD_FTD
-    SuccessOrExit(error =
-                      Get<MleRouter>().ReadAndProcessRouteTlvOnFtdChild(aRxInfo, RouterIdFromRloc16(sourceAddress)));
+    SuccessOrExit(error = ReadAndProcessRouteTlvOnFtdChild(aRxInfo, RouterIdFromRloc16(sourceAddress)));
 #endif
 
     mParentCandidate.CopyTo(mParent);
@@ -3362,7 +3400,7 @@ void Mle::HandleChildUpdateRequest(RxInfo &aRxInfo)
 #if OPENTHREAD_FTD
     if (IsRouterOrLeader())
     {
-        Get<MleRouter>().HandleChildUpdateRequestOnParent(aRxInfo);
+        HandleChildUpdateRequestOnParent(aRxInfo);
     }
     else
 #endif
@@ -3485,7 +3523,7 @@ void Mle::HandleChildUpdateResponse(RxInfo &aRxInfo)
 #if OPENTHREAD_FTD
     if (IsRouterOrLeader())
     {
-        Get<MleRouter>().HandleChildUpdateResponseOnParent(aRxInfo);
+        HandleChildUpdateResponseOnParent(aRxInfo);
     }
     else
 #endif
@@ -4473,7 +4511,7 @@ Error Mle::DetachGracefully(DetachCallback aCallback, void *aContext)
 
     case kRoleRouter:
 #if OPENTHREAD_FTD
-        Get<MleRouter>().SendAddressRelease();
+        SendAddressRelease();
 #endif
         break;
 
@@ -4735,16 +4773,16 @@ void Mle::DelayedSender::Execute(const Schedule &aSchedule)
         ParentResponseInfo info;
 
         IgnoreError(aSchedule.Read(sizeof(Header), info));
-        Get<MleRouter>().SendParentResponse(info);
+        Get<Mle>().SendParentResponse(info);
         break;
     }
 
     case kTypeAdvertisement:
-        Get<MleRouter>().SendAdvertisement(header.mDestination);
+        Get<Mle>().SendAdvertisement(header.mDestination);
         break;
 
     case kTypeDataResponse:
-        Get<MleRouter>().SendMulticastDataResponse();
+        Get<Mle>().SendMulticastDataResponse();
         break;
 
     case kTypeLinkAccept:
@@ -4752,7 +4790,7 @@ void Mle::DelayedSender::Execute(const Schedule &aSchedule)
         LinkAcceptInfo info;
 
         IgnoreError(aSchedule.Read(sizeof(Header), info));
-        IgnoreError(Get<MleRouter>().SendLinkAccept(info));
+        IgnoreError(Get<Mle>().SendLinkAccept(info));
         break;
     }
 
@@ -4766,7 +4804,7 @@ void Mle::DelayedSender::Execute(const Schedule &aSchedule)
 
         if (router != nullptr)
         {
-            Get<MleRouter>().SendLinkRequest(router);
+            Get<Mle>().SendLinkRequest(router);
         }
 
         break;
@@ -4777,7 +4815,7 @@ void Mle::DelayedSender::Execute(const Schedule &aSchedule)
         DiscoveryResponseInfo info;
 
         IgnoreError(aSchedule.Read(sizeof(Header), info));
-        IgnoreError(Get<MleRouter>().SendDiscoveryResponse(header.mDestination, info));
+        IgnoreError(Get<Mle>().SendDiscoveryResponse(header.mDestination, info));
         break;
     }
 #endif // OPENTHREAD_FTD
@@ -5242,7 +5280,7 @@ Error Mle::TxMessage::AppendConnectivityTlv(void)
     ConnectivityTlv tlv;
 
     tlv.Init();
-    Get<MleRouter>().FillConnectivityTlv(tlv);
+    Get<Mle>().FillConnectivityTlv(tlv);
 
     return tlv.AppendTo(*this);
 }
@@ -5332,9 +5370,9 @@ Error Mle::TxMessage::AppendSteeringDataTlv(void)
     MeshCoP::SteeringData steeringData;
 
 #if OPENTHREAD_CONFIG_MLE_STEERING_DATA_SET_OOB_ENABLE
-    if (!Get<MleRouter>().mSteeringData.IsEmpty())
+    if (!Get<Mle>().mSteeringData.IsEmpty())
     {
-        steeringData = Get<MleRouter>().mSteeringData;
+        steeringData = Get<Mle>().mSteeringData;
     }
     else
 #endif
diff --git a/src/core/thread/mle.hpp b/src/core/thread/mle.hpp
index 25683c168..cb2fb9756 100644
--- a/src/core/thread/mle.hpp
+++ b/src/core/thread/mle.hpp
@@ -36,28 +36,41 @@
 
 #include "openthread-core-config.h"
 
+#include <openthread/thread_ftd.h>
+
+#include "coap/coap_message.hpp"
 #include "common/callback.hpp"
 #include "common/encoding.hpp"
 #include "common/locator.hpp"
 #include "common/log.hpp"
 #include "common/non_copyable.hpp"
 #include "common/notifier.hpp"
+#include "common/time_ticker.hpp"
 #include "common/timer.hpp"
+#include "common/trickle_timer.hpp"
 #include "crypto/aes_ccm.hpp"
 #include "mac/mac.hpp"
+#include "mac/mac_types.hpp"
 #include "mac/wakeup_tx_scheduler.hpp"
 #include "meshcop/dataset.hpp"
 #include "meshcop/joiner_router.hpp"
 #include "meshcop/meshcop.hpp"
+#include "meshcop/meshcop_tlvs.hpp"
+#include "net/icmp6.hpp"
 #include "net/udp6.hpp"
 #include "thread/child.hpp"
+#include "thread/child_table.hpp"
 #include "thread/link_metrics.hpp"
 #include "thread/link_metrics_tlvs.hpp"
+#include "thread/mle.hpp"
 #include "thread/mle_tlvs.hpp"
 #include "thread/mle_types.hpp"
 #include "thread/neighbor_table.hpp"
 #include "thread/network_data_types.hpp"
 #include "thread/router.hpp"
+#include "thread/router_table.hpp"
+#include "thread/thread_tlvs.hpp"
+#include "thread/tmf.hpp"
 
 namespace ot {
 
@@ -97,18 +110,11 @@ namespace Mle {
  * @{
  */
 
-#if OPENTHREAD_FTD
-class MleRouter;
-#endif
-
 /**
  * Implements MLE functionality required by the Thread EndDevices, Router, and Leader roles.
  */
 class Mle : public InstanceLocator, private NonCopyable
 {
-#if OPENTHREAD_FTD
-    friend class MleRouter;
-#endif
     friend class DiscoverScanner;
     friend class ot::Instance;
     friend class ot::Notifier;
@@ -117,6 +123,10 @@ class Mle : public InstanceLocator, private NonCopyable
     friend class ot::LinkMetrics::Initiator;
 #endif
     friend class ot::UnitTester;
+#if OPENTHREAD_FTD
+    friend class ot::TimeTicker;
+    friend class Tmf::Agent;
+#endif
 
 public:
     typedef otDetachGracefullyCallback DetachCallback; ///< Callback to signal end of graceful detach.
@@ -587,11 +597,11 @@ public:
     const LeaderData &GetLeaderData(void);
 
     /**
-     * Returns a reference to the send queue.
+     * Retrieves information about the MLE message queue used for delayed messages.
      *
-     * @returns A reference to the send queue.
+     * @param[out] aQueueInfo     A `MessageQueue::Info` to populate with info about the MLE queue.
      */
-    const MessageQueue &GetMessageQueue(void) const { return mDelayedSender.GetQueue(); }
+    void GetMessageQueueInfo(MessageQueue::Info &aQueryInfo) const { mDelayedSender.GetQueueInfo(aQueryInfo); }
 
     /**
      * Gets the MLE counters.
@@ -605,14 +615,12 @@ public:
      */
     void ResetCounters(void);
 
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
     /**
      * Determines the current attach duration (number of seconds since the device last attached).
      *
      * @returns Current attach duration in seconds.
      */
     uint32_t GetCurrentAttachDuration(void) const;
-#endif
 
 #if OPENTHREAD_CONFIG_MLE_PARENT_RESPONSE_CALLBACK_API_ENABLE
     /**
@@ -730,6 +738,13 @@ public:
      */
     uint64_t CalcParentCslMetric(const Mac::CslAccuracy &aCslAccuracy) const;
 
+    /**
+     * Indicates whether the device is connected to a parent which supports CSL.
+     *
+     * @retval TRUE   If parent supports CSL.
+     * @retval FALSE  If parent does not support CSL.
+     */
+    bool IsCslSupported(void) const;
 #endif // OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
 
 #if OPENTHREAD_CONFIG_WAKEUP_COORDINATOR_ENABLE
@@ -753,6 +768,408 @@ public:
                  void                  *aCallbackContext);
 #endif // OPENTHREAD_CONFIG_WAKEUP_COORDINATOR_ENABLE
 
+#if OPENTHREAD_FTD
+    /**
+     * Indicates whether or not the device is router-eligible.
+     *
+     * @retval true   If device is router-eligible.
+     * @retval false  If device is not router-eligible.
+     */
+    bool IsRouterEligible(void) const;
+
+    /**
+     * Sets whether or not the device is router-eligible.
+     *
+     * If @p aEligible is false and the device is currently operating as a router, this call will cause the device to
+     * detach and attempt to reattach as a child.
+     *
+     * @param[in]  aEligible  TRUE to configure device router-eligible, FALSE otherwise.
+     *
+     * @retval kErrorNone         Successfully set the router-eligible configuration.
+     * @retval kErrorNotCapable   The device is not capable of becoming a router.
+     */
+    Error SetRouterEligible(bool aEligible);
+
+    /**
+     * Indicates whether a node is the only router on the network.
+     *
+     * @retval TRUE   It is the only router in the network.
+     * @retval FALSE  It is a child or is not a single router in the network.
+     */
+    bool IsSingleton(void) const;
+
+    /**
+     * Generates an Address Solicit request for a Router ID.
+     *
+     * @param[in]  aStatus  The reason for requesting a Router ID.
+     *
+     * @retval kErrorNone           Successfully generated an Address Solicit message.
+     * @retval kErrorNotCapable     Device is not capable of becoming a router
+     * @retval kErrorInvalidState   Thread is not enabled
+     */
+    Error BecomeRouter(ThreadStatusTlv::Status aStatus);
+
+    /**
+     * Becomes a leader and starts a new partition.
+     *
+     * If the device is already attached, this method can be used to attempt to take over as the leader, creating a new
+     * partition. For this to work, the local leader weight must be greater than the weight of the current leader. The
+     * @p aCheckWeight can be used to ensure that this check is performed.
+     *
+     * @param[in] aCheckWeight      Check that the local leader weight is larger than the weight of the current leader.
+     *
+     * @retval kErrorNone           Successfully become a Leader and started a new partition.
+     * @retval kErrorInvalidState   Thread is not enabled.
+     * @retval kErrorNotCapable     Device is not capable of becoming a leader (not router eligible), or
+     *                              @p aCheckWeight is true and cannot override the current leader due to its local
+     *                              leader weight being same or smaller than current leader's weight.
+     */
+    Error BecomeLeader(bool aCheckWeight);
+
+#if OPENTHREAD_CONFIG_MLE_DEVICE_PROPERTY_LEADER_WEIGHT_ENABLE
+    /**
+     * Gets the device properties which are used to determine the Leader Weight.
+     *
+     * @returns The current device properties.
+     */
+    const DeviceProperties &GetDeviceProperties(void) const { return mDeviceProperties; }
+
+    /**
+     * Sets the device properties which are then used to determine and set the Leader Weight.
+     *
+     * @param[in]  aDeviceProperties    The device properties.
+     */
+    void SetDeviceProperties(const DeviceProperties &aDeviceProperties);
+#endif
+
+    /**
+     * Returns the Leader Weighting value for this Thread interface.
+     *
+     * @returns The Leader Weighting value for this Thread interface.
+     */
+    uint8_t GetLeaderWeight(void) const { return mLeaderWeight; }
+
+    /**
+     * Sets the Leader Weighting value for this Thread interface.
+     *
+     * Directly sets the Leader Weight to the new value replacing its previous value (which may have been
+     * determined from a previous call to `SetDeviceProperties()`).
+     *
+     * @param[in]  aWeight  The Leader Weighting value.
+     */
+    void SetLeaderWeight(uint8_t aWeight) { mLeaderWeight = aWeight; }
+
+#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
+
+    /**
+     * Returns the preferred Partition Id when operating in the Leader role for certification testing.
+     *
+     * @returns The preferred Partition Id value.
+     */
+    uint32_t GetPreferredLeaderPartitionId(void) const { return mPreferredLeaderPartitionId; }
+
+    /**
+     * Sets the preferred Partition Id when operating in the Leader role for certification testing.
+     *
+     * @param[in]  aPartitionId  The preferred Leader Partition Id.
+     */
+    void SetPreferredLeaderPartitionId(uint32_t aPartitionId) { mPreferredLeaderPartitionId = aPartitionId; }
+#endif
+
+    /**
+     * Sets the preferred Router Id. Upon becoming a router/leader the node
+     * attempts to use this Router Id. If the preferred Router Id is not set or if it
+     * can not be used, a randomly generated router Id is picked.
+     * This property can be set when he device role is detached or disabled.
+     *
+     * @param[in]  aRouterId             The preferred Router Id.
+     *
+     * @retval kErrorNone          Successfully set the preferred Router Id.
+     * @retval kErrorInvalidState  Could not set (role is other than detached and disabled)
+     */
+    Error SetPreferredRouterId(uint8_t aRouterId);
+
+    /**
+     * Gets the Partition Id which the device joined successfully once.
+     */
+    uint32_t GetPreviousPartitionId(void) const { return mPreviousPartitionId; }
+
+    /**
+     * Sets the Partition Id which the device joins successfully.
+     *
+     * @param[in]  aPartitionId   The Partition Id.
+     */
+    void SetPreviousPartitionId(uint32_t aPartitionId) { mPreviousPartitionId = aPartitionId; }
+
+    /**
+     * Sets the Router Id.
+     *
+     * @param[in]  aRouterId   The Router Id.
+     */
+    void SetRouterId(uint8_t aRouterId);
+
+    /**
+     * Returns the NETWORK_ID_TIMEOUT value.
+     *
+     * @returns The NETWORK_ID_TIMEOUT value.
+     */
+    uint8_t GetNetworkIdTimeout(void) const { return mNetworkIdTimeout; }
+
+    /**
+     * Sets the NETWORK_ID_TIMEOUT value.
+     *
+     * @param[in]  aTimeout  The NETWORK_ID_TIMEOUT value.
+     */
+    void SetNetworkIdTimeout(uint8_t aTimeout) { mNetworkIdTimeout = aTimeout; }
+
+    /**
+     * Returns the ROUTER_SELECTION_JITTER value.
+     *
+     * @returns The ROUTER_SELECTION_JITTER value in seconds.
+     */
+    uint8_t GetRouterSelectionJitter(void) const { return mRouterRoleTransition.GetJitter(); }
+
+    /**
+     * Sets the ROUTER_SELECTION_JITTER value.
+     *
+     * @param[in] aRouterJitter  The router selection jitter value (in seconds).
+     */
+    void SetRouterSelectionJitter(uint8_t aRouterJitter) { mRouterRoleTransition.SetJitter(aRouterJitter); }
+
+    /**
+     * Indicates whether or not router role transition (upgrade from REED or downgrade to REED) is pending.
+     *
+     * @retval TRUE    Router role transition is pending.
+     * @retval FALSE   Router role transition is not pending
+     */
+    bool IsRouterRoleTransitionPending(void) const { return mRouterRoleTransition.IsPending(); }
+
+    /**
+     * Returns the current timeout delay in seconds till router role transition (upgrade from REED or downgrade to
+     * REED).
+     *
+     * @returns The timeout in seconds till router role transition, or zero if not pending role transition.
+     */
+    uint8_t GetRouterRoleTransitionTimeout(void) const { return mRouterRoleTransition.GetTimeout(); }
+
+    /**
+     * Returns the ROUTER_UPGRADE_THRESHOLD value.
+     *
+     * @returns The ROUTER_UPGRADE_THRESHOLD value.
+     */
+    uint8_t GetRouterUpgradeThreshold(void) const { return mRouterUpgradeThreshold; }
+
+    /**
+     * Sets the ROUTER_UPGRADE_THRESHOLD value.
+     *
+     * @param[in]  aThreshold  The ROUTER_UPGRADE_THRESHOLD value.
+     */
+    void SetRouterUpgradeThreshold(uint8_t aThreshold) { mRouterUpgradeThreshold = aThreshold; }
+
+    /**
+     * Returns the ROUTER_DOWNGRADE_THRESHOLD value.
+     *
+     * @returns The ROUTER_DOWNGRADE_THRESHOLD value.
+     */
+    uint8_t GetRouterDowngradeThreshold(void) const { return mRouterDowngradeThreshold; }
+
+    /**
+     * Sets the ROUTER_DOWNGRADE_THRESHOLD value.
+     *
+     * @param[in]  aThreshold  The ROUTER_DOWNGRADE_THRESHOLD value.
+     */
+    void SetRouterDowngradeThreshold(uint8_t aThreshold) { mRouterDowngradeThreshold = aThreshold; }
+
+    /**
+     * Returns the MLE_CHILD_ROUTER_LINKS value.
+     *
+     * @returns The MLE_CHILD_ROUTER_LINKS value.
+     */
+    uint8_t GetChildRouterLinks(void) const { return mChildRouterLinks; }
+
+    /**
+     * Sets the MLE_CHILD_ROUTER_LINKS value.
+     *
+     * @param[in]  aChildRouterLinks  The MLE_CHILD_ROUTER_LINKS value.
+     *
+     * @retval kErrorNone          Successfully set the value.
+     * @retval kErrorInvalidState  Thread protocols are enabled.
+     */
+    Error SetChildRouterLinks(uint8_t aChildRouterLinks);
+
+    /**
+     * Returns if the REED is expected to become Router soon.
+     *
+     * @retval TRUE   If the REED is going to become a Router soon.
+     * @retval FALSE  If the REED is not going to become a Router soon.
+     */
+    bool IsExpectedToBecomeRouterSoon(void) const;
+
+    /**
+     * Removes a link to a neighbor.
+     *
+     * @param[in]  aNeighbor  A reference to the neighbor object.
+     */
+    void RemoveNeighbor(Neighbor &aNeighbor);
+
+    /**
+     * Invalidates a direct link to a neighboring router (due to failed link-layer acks).
+     *
+     * @param[in]  aRouter  A reference to the router object.
+     */
+    void RemoveRouterLink(Router &aRouter);
+
+    /**
+     * Indicates whether or not the given Thread partition attributes are preferred.
+     *
+     * @param[in]  aSingletonA   Whether or not the Thread Partition A has a single router.
+     * @param[in]  aLeaderDataA  A reference to Thread Partition A's Leader Data.
+     * @param[in]  aSingletonB   Whether or not the Thread Partition B has a single router.
+     * @param[in]  aLeaderDataB  A reference to Thread Partition B's Leader Data.
+     *
+     * @retval 1   If partition A is preferred.
+     * @retval 0   If partition A and B have equal preference.
+     * @retval -1  If partition B is preferred.
+     */
+    static int ComparePartitions(bool              aSingletonA,
+                                 const LeaderData &aLeaderDataA,
+                                 bool              aSingletonB,
+                                 const LeaderData &aLeaderDataB);
+
+    /**
+     * Fills an ConnectivityTlv.
+     *
+     * @param[out]  aTlv  A reference to the tlv to be filled.
+     */
+    void FillConnectivityTlv(ConnectivityTlv &aTlv);
+
+    /**
+     * Schedule tx of MLE Advertisement message (unicast) to the given neighboring router after a random delay.
+     *
+     * @param[in] aRouter  The router to send the Advertisement to.
+     *
+     */
+    void ScheduleUnicastAdvertisementTo(const Router &aRouter);
+
+#if OPENTHREAD_CONFIG_MLE_STEERING_DATA_SET_OOB_ENABLE
+    /**
+     * Sets steering data out of band
+     *
+     * @param[in]  aExtAddress  Value used to set steering data
+     *                          All zeros clears steering data
+     *                          All 0xFFs sets steering data to 0xFF
+     *                          Anything else is used to compute the bloom filter
+     */
+    void SetSteeringData(const Mac::ExtAddress *aExtAddress);
+#endif
+
+    /**
+     * Gets the assigned parent priority.
+     *
+     * @returns The assigned parent priority value, -2 means not assigned.
+     */
+    int8_t GetAssignParentPriority(void) const { return mParentPriority; }
+
+    /**
+     * Sets the parent priority.
+     *
+     * @param[in]  aParentPriority  The parent priority value.
+     *
+     * @retval kErrorNone           Successfully set the parent priority.
+     * @retval kErrorInvalidArgs    If the parent priority value is not among 1, 0, -1 and -2.
+     */
+    Error SetAssignParentPriority(int8_t aParentPriority);
+
+    /**
+     * Gets the longest MLE Timeout TLV for all active MTD children.
+     *
+     * @param[out]  aTimeout  A reference to where the information is placed.
+     *
+     * @retval kErrorNone           Successfully get the max child timeout
+     * @retval kErrorInvalidState   Not an active router
+     * @retval kErrorNotFound       NO MTD child
+     */
+    Error GetMaxChildTimeout(uint32_t &aTimeout) const;
+
+    /**
+     * Sets the callback that is called when processing an MLE Discovery Request message.
+     *
+     * @param[in]  aCallback A pointer to a function that is called to deliver MLE Discovery Request data.
+     * @param[in]  aContext  A pointer to application-specific context.
+     */
+    void SetDiscoveryRequestCallback(otThreadDiscoveryRequestCallback aCallback, void *aContext)
+    {
+        mDiscoveryRequestCallback.Set(aCallback, aContext);
+    }
+
+    /**
+     * Resets the MLE Advertisement Trickle timer interval.
+     */
+    void ResetAdvertiseInterval(void);
+
+    /**
+     * Updates the MLE Advertisement Trickle timer max interval (if timer is running).
+     *
+     * This is called when there is change in router table.
+     */
+    void UpdateAdvertiseInterval(void);
+
+#if OPENTHREAD_CONFIG_TIME_SYNC_ENABLE
+    /**
+     * Generates an MLE Time Synchronization message.
+     *
+     * @retval kErrorNone     Successfully sent an MLE Time Synchronization message.
+     * @retval kErrorNoBufs   Insufficient buffers to generate the MLE Time Synchronization message.
+     */
+    Error SendTimeSync(void);
+#endif
+
+    /**
+     * Gets the maximum number of IP addresses that each MTD child may register with this device as parent.
+     *
+     * @returns The maximum number of IP addresses that each MTD child may register with this device as parent.
+     */
+    uint8_t GetMaxChildIpAddresses(void) const;
+
+#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
+
+    /**
+     * Sets/restores the maximum number of IP addresses that each MTD child may register with this
+     * device as parent.
+     *
+     * @param[in]  aMaxIpAddresses  The maximum number of IP addresses that each MTD child may register with this
+     *                              device as parent. 0 to clear the setting and restore the default.
+     *
+     * @retval kErrorNone           Successfully set/cleared the number.
+     * @retval kErrorInvalidArgs    If exceeds the allowed maximum number.
+     */
+    Error SetMaxChildIpAddresses(uint8_t aMaxIpAddresses);
+
+    /**
+     * Sets whether the device was commissioned using CCM.
+     *
+     * @param[in]  aEnabled  TRUE if the device was commissioned using CCM, FALSE otherwise.
+     */
+    void SetCcmEnabled(bool aEnabled) { mCcmEnabled = aEnabled; }
+
+    /**
+     * Sets whether the Security Policy TLV version-threshold for routing (VR field) is enabled.
+     *
+     * @param[in]  aEnabled  TRUE to enable Security Policy TLV version-threshold for routing, FALSE otherwise.
+     */
+    void SetThreadVersionCheckEnabled(bool aEnabled) { mThreadVersionCheckEnabled = aEnabled; }
+
+    /**
+     * Gets the current Interval Max value used by Advertisement trickle timer.
+     *
+     * @returns The Interval Max of Advertisement trickle timer in milliseconds.
+     */
+    uint32_t GetAdvertisementTrickleIntervalMax(void) const { return mAdvertiseTrickleTimer.GetIntervalMax(); }
+
+#endif // OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
+
+#endif // OPENTHREAD_FTD
+
 private:
     //------------------------------------------------------------------------------------------------------------------
     // Constants
@@ -827,6 +1244,65 @@ private:
     static constexpr uint32_t kDefaultChildTimeout           = OPENTHREAD_CONFIG_MLE_CHILD_TIMEOUT_DEFAULT;
     static constexpr uint32_t kDefaultCslTimeout             = OPENTHREAD_CONFIG_CSL_TIMEOUT;
 
+#if OPENTHREAD_FTD
+    // Advertisement trickle timer constants - all times are in milliseconds.
+    static constexpr uint32_t kAdvIntervalMin                = 1000;  // I_MIN
+    static constexpr uint32_t kAdvIntervalNeighborMultiplier = 4000;  // Multiplier for I_MAX per router neighbor
+    static constexpr uint32_t kAdvIntervalMaxLowerBound      = 12000; // Lower bound for I_MAX
+    static constexpr uint32_t kAdvIntervalMaxUpperBound      = 32000; // Upper bound for I_MAX
+    static constexpr uint32_t kReedAdvIntervalMin            = 570000;
+    static constexpr uint32_t kReedAdvIntervalMax            = 630000;
+#if OPENTHREAD_CONFIG_MLE_LONG_ROUTES_ENABLE
+    static constexpr uint32_t kAdvIntervalMaxLogRoutes = 5000;
+#endif
+
+    static constexpr uint32_t kMaxUnicastAdvertisementDelay  = 1000;   // Max random delay for unciast Adv tx
+    static constexpr uint32_t kMaxNeighborAge                = 100000; // Max neighbor age on router (in msec)
+    static constexpr uint32_t kMaxNeighborAgeOnChild         = 150000; // Max neighbor age on FTD child (in msec)
+    static constexpr uint32_t kMaxLeaderToRouterTimeout      = 90000;  // (in msec)
+    static constexpr uint8_t  kMinDowngradeNeighbors         = 7;
+    static constexpr uint8_t  kNetworkIdTimeout              = 120; // (in sec)
+    static constexpr uint8_t  kRouterSelectionJitter         = 120; // (in sec)
+    static constexpr uint8_t  kRouterDowngradeThreshold      = 23;
+    static constexpr uint8_t  kRouterUpgradeThreshold        = 16;
+    static constexpr uint16_t kDiscoveryMaxJitter            = 250; // Max jitter delay Discovery Responses (in msec).
+    static constexpr uint16_t kUnsolicitedDataResponseJitter = 500; // Max delay for unsol Data Response (in msec).
+    static constexpr uint8_t  kLeaderDowngradeExtraDelay     = 10;  // Extra delay to downgrade leader (in sec).
+    static constexpr uint8_t  kDefaultLeaderWeight           = 64;
+    static constexpr uint8_t  kAlternateRloc16Timeout        = 8; // Time to use alternate RLOC16 (in sec).
+
+    // Threshold to accept a router upgrade request with reason
+    // `kBorderRouterRequest` (number of BRs acting as router in
+    // Network Data).
+    static constexpr uint8_t kRouterUpgradeBorderRouterRequestThreshold = 2;
+
+    static constexpr uint8_t kLinkRequestMinMargin    = OPENTHREAD_CONFIG_MLE_LINK_REQUEST_MARGIN_MIN;
+    static constexpr uint8_t kPartitionMergeMinMargin = OPENTHREAD_CONFIG_MLE_PARTITION_MERGE_MARGIN_MIN;
+    static constexpr uint8_t kChildRouterLinks        = OPENTHREAD_CONFIG_MLE_CHILD_ROUTER_LINKS;
+    static constexpr uint8_t kMaxChildIpAddresses     = OPENTHREAD_CONFIG_MLE_IP_ADDRS_PER_CHILD;
+
+    // Constants for gradual router link establishment (on FTD child)
+    struct GradualChildRouterLink
+    {
+        static constexpr uint8_t  kExtraChildRouterLinks   = OPENTHREAD_CONFIG_MLE_EXTRA_CHILD_ROUTER_LINKS_GRADUAL;
+        static constexpr uint32_t kWaitDurationAfterAttach = 300;   // in seconds (5 minutes)
+        static constexpr uint32_t kMinLinkRequestDelay     = 1500;  // in msec
+        static constexpr uint32_t kMaxLinkRequestDelay     = 10000; // in msec
+        static constexpr uint32_t kProbabilityPercentage   = 5;     // in percent
+    };
+
+    static constexpr uint8_t kMinCriticalChildrenCount = 6;
+
+    static constexpr uint16_t kChildSupervisionDefaultIntervalForOlderVersion =
+        OPENTHREAD_CONFIG_CHILD_SUPERVISION_OLDER_VERSION_CHILD_DEFAULT_INTERVAL;
+
+    static constexpr int8_t kParentPriorityHigh        = 1;
+    static constexpr int8_t kParentPriorityMedium      = 0;
+    static constexpr int8_t kParentPriorityLow         = -1;
+    static constexpr int8_t kParentPriorityUnspecified = -2;
+
+#endif // OPENTHREAD_FTD
+
     //------------------------------------------------------------------------------------------------------------------
     // Enumerations
 
@@ -1156,8 +1632,8 @@ private:
 #endif
         void RemoveScheduledChildUpdateRequestToParent(void);
 
-        void                HandleTimer(void);
-        const MessageQueue &GetQueue(void) const { return mSchedules; }
+        void HandleTimer(void);
+        void GetQueueInfo(MessageQueue::Info &aQueueInfo) const { mSchedules.GetInfo(aQueueInfo); }
 
     private:
         typedef Message Schedule;
@@ -1312,6 +1788,57 @@ private:
     };
 #endif // OPENTHREAD_CONFIG_PARENT_SEARCH_ENABLE
 
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+#if OPENTHREAD_FTD
+
+    class RouterRoleTransition
+    {
+    public:
+        RouterRoleTransition(void);
+
+        bool    IsPending(void) const { return (mTimeout != 0); }
+        void    StartTimeout(void);
+        void    StopTimeout(void) { mTimeout = 0; }
+        void    IncreaseTimeout(uint8_t aIncrement) { mTimeout += aIncrement; }
+        uint8_t GetTimeout(void) const { return mTimeout; }
+        bool    HandleTimeTick(void);
+        uint8_t GetJitter(void) const { return mJitter; }
+        void    SetJitter(uint8_t aJitter) { mJitter = aJitter; }
+
+    private:
+        uint8_t mTimeout;
+        uint8_t mJitter;
+    };
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+    class RouterRoleRestorer : public InstanceLocator
+    {
+        // Attempts to restore the router or leader role after an MLE
+        // restart(e.g., after a device reboot) by sending multicast
+        // Link Requests.
+
+    public:
+        RouterRoleRestorer(Instance &aInstance);
+
+        bool IsActive(void) const { return mAttempts > 0; }
+        void Start(DeviceRole aPreviousRole);
+        void Stop(void) { mAttempts = 0; }
+        void HandleTimer(void);
+
+        void               GenerateRandomChallenge(void) { mChallenge.GenerateRandom(); }
+        const TxChallenge &GetChallenge(void) const { return mChallenge; }
+
+    private:
+        void SendMulticastLinkRequest(void);
+
+        uint8_t     mAttempts;
+        TxChallenge mChallenge;
+    };
+
+#endif // OPENTHREAD_FTD
+
     //------------------------------------------------------------------------------------------------------------------
     // Methods
 
@@ -1382,9 +1909,7 @@ private:
     void InformPreviousParent(void);
 #endif
 
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
     void UpdateRoleTimeCounters(DeviceRole aRole);
-#endif
 
 #if OPENTHREAD_CONFIG_TMF_NETDATA_SERVICE_ENABLE
     ServiceAloc *FindInServiceAlocs(uint16_t aAloc16);
@@ -1449,6 +1974,83 @@ private:
     static void LogSendError(MessageType, Error) {}
 #endif
 
+#if OPENTHREAD_FTD
+    void     SetAlternateRloc16(uint16_t aRloc16);
+    void     ClearAlternateRloc16(void);
+    void     HandleDetachStart(void);
+    void     HandleChildStart(AttachMode aMode);
+    void     HandleSecurityPolicyChanged(void);
+    void     HandleLinkRequest(RxInfo &aRxInfo);
+    void     HandleLinkAccept(RxInfo &aRxInfo);
+    void     HandleLinkAcceptAndRequest(RxInfo &aRxInfo);
+    void     HandleLinkAcceptVariant(RxInfo &aRxInfo, MessageType aMessageType);
+    Error    HandleAdvertisementOnFtd(RxInfo &aRxInfo, uint16_t aSourceAddress, const LeaderData &aLeaderData);
+    void     HandleParentRequest(RxInfo &aRxInfo);
+    void     HandleChildIdRequest(RxInfo &aRxInfo);
+    void     HandleChildUpdateRequestOnParent(RxInfo &aRxInfo);
+    void     HandleChildUpdateResponseOnParent(RxInfo &aRxInfo);
+    void     HandleDataRequest(RxInfo &aRxInfo);
+    void     HandleNetworkDataUpdateRouter(void);
+    void     HandleDiscoveryRequest(RxInfo &aRxInfo);
+    void     EstablishRouterLinkOnFtdChild(Router &aRouter, RxInfo &aRxInfo, uint8_t aLinkMargin);
+    Error    ProcessRouteTlv(const RouteTlv &aRouteTlv, RxInfo &aRxInfo);
+    Error    ReadAndProcessRouteTlvOnFtdChild(RxInfo &aRxInfo, uint8_t aParentId);
+    void     StopAdvertiseTrickleTimer(void);
+    uint32_t DetermineAdvertiseIntervalMax(void) const;
+    Error    SendAddressSolicit(ThreadStatusTlv::Status aStatus);
+    void     SendAddressSolicitResponse(const Coap::Message    &aRequest,
+                                        ThreadStatusTlv::Status aResponseStatus,
+                                        const Router           *aRouter,
+                                        const Ip6::MessageInfo &aMessageInfo);
+    void     SendAddressRelease(void);
+    void     SendMulticastAdvertisement(void);
+    void     SendAdvertisement(const Ip6::Address &aDestination);
+    void     SendLinkRequest(Router *aRouter);
+    Error    SendLinkAccept(const LinkAcceptInfo &aInfo);
+    void     SendParentResponse(const ParentResponseInfo &aInfo);
+    Error    SendChildIdResponse(Child &aChild);
+    Error    SendChildUpdateRequestToChild(Child &aChild);
+    void     SendChildUpdateResponseToChild(Child                  *aChild,
+                                            const Ip6::MessageInfo &aMessageInfo,
+                                            const TlvList          &aTlvList,
+                                            const RxChallenge      &aChallenge);
+    void     SendMulticastDataResponse(void);
+    void     SendDataResponse(const Ip6::Address &aDestination,
+                              const TlvList      &aTlvList,
+                              const Message      *aRequestMessage = nullptr);
+    Error    SendDiscoveryResponse(const Ip6::Address &aDestination, const DiscoveryResponseInfo &aInfo);
+    void     SetStateRouter(uint16_t aRloc16);
+    void     SetStateLeader(uint16_t aRloc16, LeaderStartMode aStartMode);
+    void     SetStateRouterOrLeader(DeviceRole aRole, uint16_t aRloc16, LeaderStartMode aStartMode);
+    void     StopLeader(void);
+    void     SynchronizeChildNetworkData(void);
+    Error    ProcessAddressRegistrationTlv(RxInfo &aRxInfo, Child &aChild);
+    bool     HasNeighborWithGoodLinkQuality(void) const;
+    void     HandlePartitionChange(void);
+    void     SetChildStateToValid(Child &aChild);
+    bool     HasChildren(void);
+    void     RemoveChildren(void);
+    bool     ShouldDowngrade(uint8_t aNeighborId, const RouteTlv &aRouteTlv) const;
+    bool     NeighborHasComparableConnectivity(const RouteTlv &aRouteTlv, uint8_t aNeighborId) const;
+    void     HandleAdvertiseTrickleTimer(void);
+    void     HandleAddressSolicitResponse(Coap::Message *aMessage, const Ip6::MessageInfo *aMessageInfo, Error aResult);
+    void     HandleTimeTick(void);
+
+    template <Uri kUri> void HandleTmf(Coap::Message &aMessage, const Ip6::MessageInfo &aMessageInfo);
+
+#if OPENTHREAD_CONFIG_TMF_PROXY_DUA_ENABLE
+    void SignalDuaAddressEvent(const Child &aChild, const Ip6::Address &aOldDua) const;
+#endif
+
+    static bool IsMessageMleSubType(const Message &aMessage);
+    static bool IsMessageChildUpdateRequest(const Message &aMessage);
+    static void HandleAdvertiseTrickleTimer(TrickleTimer &aTimer);
+    static void HandleAddressSolicitResponse(void                *aContext,
+                                             otMessage           *aMessage,
+                                             const otMessageInfo *aMessageInfo,
+                                             otError              aResult);
+#endif // OPENTHREAD_FTD
+
     //------------------------------------------------------------------------------------------------------------------
     // Variables
 
@@ -1493,10 +2095,8 @@ private:
 #if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
     uint32_t mCslTimeout;
 #endif
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
     uint32_t mLastAttachTime;
     uint64_t mLastUpdatedTimestamp;
-#endif
     uint64_t mAlternateTimestamp;
 
     LeaderData      mLeaderData;
@@ -1532,8 +2132,60 @@ private:
     WedAttachTimer           mWedAttachTimer;
     Callback<WakeupCallback> mWakeupCallback;
 #endif
+
+#if OPENTHREAD_FTD
+
+    bool mRouterEligible : 1;
+    bool mAddressSolicitPending : 1;
+    bool mAddressSolicitRejected : 1;
+#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
+    bool mCcmEnabled : 1;
+    bool mThreadVersionCheckEnabled : 1;
+#endif
+
+    uint8_t mRouterId;
+    uint8_t mPreviousRouterId;
+    uint8_t mNetworkIdTimeout;
+    uint8_t mRouterUpgradeThreshold;
+    uint8_t mRouterDowngradeThreshold;
+    uint8_t mLeaderWeight;
+    uint8_t mPreviousPartitionRouterIdSequence;
+    uint8_t mPreviousPartitionIdTimeout;
+    uint8_t mChildRouterLinks;
+    uint8_t mAlternateRloc16Timeout;
+#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
+    uint8_t mMaxChildIpAddresses;
+#endif
+    int8_t   mParentPriority;
+    uint16_t mNextChildId;
+    uint32_t mPreviousPartitionIdRouter;
+    uint32_t mPreviousPartitionId;
+#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
+    uint32_t mPreferredLeaderPartitionId;
+#endif
+
+    TrickleTimer               mAdvertiseTrickleTimer;
+    ChildTable                 mChildTable;
+    RouterTable                mRouterTable;
+    RouterRoleRestorer         mRouterRoleRestorer;
+    RouterRoleTransition       mRouterRoleTransition;
+    Ip6::Netif::UnicastAddress mLeaderAloc;
+#if OPENTHREAD_CONFIG_MLE_DEVICE_PROPERTY_LEADER_WEIGHT_ENABLE
+    DeviceProperties mDeviceProperties;
+#endif
+#if OPENTHREAD_CONFIG_MLE_STEERING_DATA_SET_OOB_ENABLE
+    MeshCoP::SteeringData mSteeringData;
+#endif
+    Callback<otThreadDiscoveryRequestCallback> mDiscoveryRequestCallback;
+
+#endif // OPENTHREAD_FTD
 };
 
+#if OPENTHREAD_FTD
+DeclareTmfHandler(Mle, kUriAddressSolicit);
+DeclareTmfHandler(Mle, kUriAddressRelease);
+#endif
+
 } // namespace Mle
 
 /**
diff --git a/src/core/thread/mle_router.cpp b/src/core/thread/mle_ftd.cpp
similarity index 91%
rename from src/core/thread/mle_router.cpp
rename to src/core/thread/mle_ftd.cpp
index 7e23f5cfd..7161d8c12 100644
--- a/src/core/thread/mle_router.cpp
+++ b/src/core/thread/mle_ftd.cpp
@@ -30,7 +30,7 @@
  *   This file implements MLE functionality required for the Thread Router and Leader roles.
  */
 
-#include "mle_router.hpp"
+#include "mle.hpp"
 
 #if OPENTHREAD_FTD
 
@@ -41,55 +41,7 @@ namespace Mle {
 
 RegisterLogModule("Mle");
 
-MleRouter::MleRouter(Instance &aInstance)
-    : Mle(aInstance)
-    , mRouterEligible(true)
-    , mAddressSolicitPending(false)
-    , mAddressSolicitRejected(false)
-#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
-    , mCcmEnabled(false)
-    , mThreadVersionCheckEnabled(true)
-#endif
-    , mNetworkIdTimeout(kNetworkIdTimeout)
-    , mRouterUpgradeThreshold(kRouterUpgradeThreshold)
-    , mRouterDowngradeThreshold(kRouterDowngradeThreshold)
-    , mPreviousPartitionRouterIdSequence(0)
-    , mPreviousPartitionIdTimeout(0)
-    , mChildRouterLinks(kChildRouterLinks)
-    , mAlternateRloc16Timeout(0)
-#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
-    , mMaxChildIpAddresses(0)
-#endif
-    , mParentPriority(kParentPriorityUnspecified)
-    , mNextChildId(kMaxChildId)
-    , mPreviousPartitionIdRouter(0)
-    , mPreviousPartitionId(0)
-#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
-    , mPreferredLeaderPartitionId(0)
-#endif
-    , mAdvertiseTrickleTimer(aInstance, MleRouter::HandleAdvertiseTrickleTimer)
-    , mChildTable(aInstance)
-    , mRouterTable(aInstance)
-    , mRouterRoleRestorer(aInstance)
-{
-    mDeviceMode.Set(mDeviceMode.Get() | DeviceMode::kModeFullThreadDevice | DeviceMode::kModeFullNetworkData);
-
-#if OPENTHREAD_CONFIG_MLE_DEVICE_PROPERTY_LEADER_WEIGHT_ENABLE
-    mLeaderWeight = mDeviceProperties.CalculateLeaderWeight();
-#else
-    mLeaderWeight = kDefaultLeaderWeight;
-#endif
-
-    mLeaderAloc.InitAsThreadOriginMeshLocal();
-
-    SetRouterId(kInvalidRouterId);
-
-#if OPENTHREAD_CONFIG_MLE_STEERING_DATA_SET_OOB_ENABLE
-    mSteeringData.Clear();
-#endif
-}
-
-void MleRouter::SetAlternateRloc16(uint16_t aRloc16)
+void Mle::SetAlternateRloc16(uint16_t aRloc16)
 {
     VerifyOrExit(aRloc16 != Mac::kShortAddrInvalid);
 
@@ -102,7 +54,7 @@ exit:
     return;
 }
 
-void MleRouter::ClearAlternateRloc16(void)
+void Mle::ClearAlternateRloc16(void)
 {
     VerifyOrExit(Get<Mac::Mac>().GetAlternateShortAddress() != Mac::kShortAddrInvalid);
 
@@ -113,18 +65,18 @@ exit:
     mAlternateRloc16Timeout = 0;
 }
 
-void MleRouter::HandlePartitionChange(void)
+void Mle::HandlePartitionChange(void)
 {
     mPreviousPartitionId               = mLeaderData.GetPartitionId();
     mPreviousPartitionRouterIdSequence = mRouterTable.GetRouterIdSequence();
     mPreviousPartitionIdTimeout        = GetNetworkIdTimeout();
 
     Get<AddressResolver>().Clear();
-    IgnoreError(Get<Tmf::Agent>().AbortTransaction(&MleRouter::HandleAddressSolicitResponse, this));
+    IgnoreError(Get<Tmf::Agent>().AbortTransaction(&Mle::HandleAddressSolicitResponse, this));
     mRouterTable.Clear();
 }
 
-bool MleRouter::IsRouterEligible(void) const
+bool Mle::IsRouterEligible(void) const
 {
     bool                  rval      = false;
     const SecurityPolicy &secPolicy = Get<KeyManager>().GetSecurityPolicy();
@@ -161,7 +113,7 @@ exit:
     return rval;
 }
 
-Error MleRouter::SetRouterEligible(bool aEligible)
+Error Mle::SetRouterEligible(bool aEligible)
 {
     Error error = kErrorNone;
 
@@ -203,7 +155,7 @@ exit:
     return error;
 }
 
-void MleRouter::HandleSecurityPolicyChanged(void)
+void Mle::HandleSecurityPolicyChanged(void)
 {
     // If we are currently router or leader and no longer eligible to
     // be a router (due to security policy change), we start jitter
@@ -225,7 +177,7 @@ exit:
 }
 
 #if OPENTHREAD_CONFIG_MLE_DEVICE_PROPERTY_LEADER_WEIGHT_ENABLE
-void MleRouter::SetDeviceProperties(const DeviceProperties &aDeviceProperties)
+void Mle::SetDeviceProperties(const DeviceProperties &aDeviceProperties)
 {
     mDeviceProperties = aDeviceProperties;
     mDeviceProperties.ClampWeightAdjustment();
@@ -233,7 +185,7 @@ void MleRouter::SetDeviceProperties(const DeviceProperties &aDeviceProperties)
 }
 #endif
 
-Error MleRouter::BecomeRouter(ThreadStatusTlv::Status aStatus)
+Error Mle::BecomeRouter(ThreadStatusTlv::Status aStatus)
 {
     Error error = kErrorNone;
 
@@ -264,7 +216,7 @@ exit:
     return error;
 }
 
-Error MleRouter::BecomeLeader(bool aCheckWeight)
+Error Mle::BecomeLeader(bool aCheckWeight)
 {
     Error    error = kErrorNone;
     Router  *router;
@@ -321,27 +273,27 @@ exit:
     return error;
 }
 
-void MleRouter::StopLeader(void)
+void Mle::StopLeader(void)
 {
     StopAdvertiseTrickleTimer();
     Get<ThreadNetif>().UnsubscribeAllRoutersMulticast();
 }
 
-void MleRouter::HandleDetachStart(void)
+void Mle::HandleDetachStart(void)
 {
     mRouterTable.ClearNeighbors();
     StopLeader();
-    Get<TimeTicker>().UnregisterReceiver(TimeTicker::kMleRouter);
+    Get<TimeTicker>().UnregisterReceiver(TimeTicker::kMle);
 }
 
-void MleRouter::HandleChildStart(AttachMode aMode)
+void Mle::HandleChildStart(AttachMode aMode)
 {
     mAddressSolicitRejected = false;
 
     mRouterRoleTransition.StartTimeout();
 
     StopLeader();
-    Get<TimeTicker>().RegisterReceiver(TimeTicker::kMleRouter);
+    Get<TimeTicker>().RegisterReceiver(TimeTicker::kMle);
 
     if (mRouterEligible)
     {
@@ -416,18 +368,18 @@ exit:
     }
 }
 
-void MleRouter::SetStateRouter(uint16_t aRloc16)
+void Mle::SetStateRouter(uint16_t aRloc16)
 {
     // The `aStartMode` is ignored when used with `kRoleRouter`
     SetStateRouterOrLeader(kRoleRouter, aRloc16, /* aStartMode */ kStartingAsLeader);
 }
 
-void MleRouter::SetStateLeader(uint16_t aRloc16, LeaderStartMode aStartMode)
+void Mle::SetStateLeader(uint16_t aRloc16, LeaderStartMode aStartMode)
 {
     SetStateRouterOrLeader(kRoleLeader, aRloc16, aStartMode);
 }
 
-void MleRouter::SetStateRouterOrLeader(DeviceRole aRole, uint16_t aRloc16, LeaderStartMode aStartMode)
+void Mle::SetStateRouterOrLeader(DeviceRole aRole, uint16_t aRloc16, LeaderStartMode aStartMode)
 {
     if (aRole == kRoleLeader)
     {
@@ -449,7 +401,7 @@ void MleRouter::SetStateRouterOrLeader(DeviceRole aRole, uint16_t aRloc16, Leade
     Get<ThreadNetif>().SubscribeAllRoutersMulticast();
     mPreviousPartitionIdRouter = mLeaderData.GetPartitionId();
     Get<Mac::Mac>().SetBeaconEnabled(true);
-    Get<TimeTicker>().RegisterReceiver(TimeTicker::kMleRouter);
+    Get<TimeTicker>().RegisterReceiver(TimeTicker::kMle);
 
     if (aRole == kRoleLeader)
     {
@@ -470,19 +422,12 @@ void MleRouter::SetStateRouterOrLeader(DeviceRole aRole, uint16_t aRloc16, Leade
         }
     }
 
-#if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE
-    Get<Mac::Mac>().UpdateCsl();
-#endif
-
     LogNote("Partition ID 0x%lx", ToUlong(mLeaderData.GetPartitionId()));
 }
 
-void MleRouter::HandleAdvertiseTrickleTimer(TrickleTimer &aTimer)
-{
-    aTimer.Get<MleRouter>().HandleAdvertiseTrickleTimer();
-}
+void Mle::HandleAdvertiseTrickleTimer(TrickleTimer &aTimer) { aTimer.Get<Mle>().HandleAdvertiseTrickleTimer(); }
 
-void MleRouter::HandleAdvertiseTrickleTimer(void)
+void Mle::HandleAdvertiseTrickleTimer(void)
 {
     VerifyOrExit(IsRouterEligible(), mAdvertiseTrickleTimer.Stop());
 
@@ -492,9 +437,9 @@ exit:
     return;
 }
 
-void MleRouter::StopAdvertiseTrickleTimer(void) { mAdvertiseTrickleTimer.Stop(); }
+void Mle::StopAdvertiseTrickleTimer(void) { mAdvertiseTrickleTimer.Stop(); }
 
-uint32_t MleRouter::DetermineAdvertiseIntervalMax(void) const
+uint32_t Mle::DetermineAdvertiseIntervalMax(void) const
 {
     uint32_t interval;
 
@@ -511,7 +456,7 @@ uint32_t MleRouter::DetermineAdvertiseIntervalMax(void) const
     return interval;
 }
 
-void MleRouter::UpdateAdvertiseInterval(void)
+void Mle::UpdateAdvertiseInterval(void)
 {
     if (IsRouterOrLeader() && mAdvertiseTrickleTimer.IsRunning())
     {
@@ -519,7 +464,7 @@ void MleRouter::UpdateAdvertiseInterval(void)
     }
 }
 
-void MleRouter::ResetAdvertiseInterval(void)
+void Mle::ResetAdvertiseInterval(void)
 {
     VerifyOrExit(IsRouterOrLeader());
 
@@ -534,7 +479,7 @@ exit:
     return;
 }
 
-void MleRouter::SendMulticastAdvertisement(void)
+void Mle::SendMulticastAdvertisement(void)
 {
     Ip6::Address destination;
 
@@ -542,7 +487,7 @@ void MleRouter::SendMulticastAdvertisement(void)
     SendAdvertisement(destination);
 }
 
-void MleRouter::ScheduleUnicastAdvertisementTo(const Router &aRouter)
+void Mle::ScheduleUnicastAdvertisementTo(const Router &aRouter)
 {
     Ip6::Address destination;
 
@@ -551,7 +496,7 @@ void MleRouter::ScheduleUnicastAdvertisementTo(const Router &aRouter)
                                          Random::NonCrypto::GetUint32InRange(0, kMaxUnicastAdvertisementDelay));
 }
 
-void MleRouter::SendAdvertisement(const Ip6::Address &aDestination)
+void Mle::SendAdvertisement(const Ip6::Address &aDestination)
 {
     Error      error   = kErrorNone;
     TxMessage *message = nullptr;
@@ -599,7 +544,7 @@ exit:
     LogSendError(kTypeAdvertisement, error);
 }
 
-void MleRouter::SendLinkRequest(Router *aRouter)
+void Mle::SendLinkRequest(Router *aRouter)
 {
     static const uint8_t kDetachedTlvs[]      = {Tlv::kAddress16, Tlv::kRoute};
     static const uint8_t kRouterTlvs[]        = {Tlv::kLinkMargin};
@@ -681,7 +626,7 @@ exit:
     FreeMessageOnError(message, error);
 }
 
-void MleRouter::HandleLinkRequest(RxInfo &aRxInfo)
+void Mle::HandleLinkRequest(RxInfo &aRxInfo)
 {
     Error          error    = kErrorNone;
     Neighbor      *neighbor = nullptr;
@@ -711,7 +656,7 @@ void MleRouter::HandleLinkRequest(RxInfo &aRxInfo)
         ExitNow(error = kErrorParse);
     }
 
-    aRxInfo.mMessageInfo.GetPeerAddr().GetIid().ConvertToExtAddress(info.mExtAddress);
+    info.mExtAddress.SetFromIid(aRxInfo.mMessageInfo.GetPeerAddr().GetIid());
 
     info.mLinkMargin = Get<Mac::Mac>().ComputeLinkMargin(aRxInfo.mMessage.GetAverageRss());
 
@@ -720,18 +665,22 @@ void MleRouter::HandleLinkRequest(RxInfo &aRxInfo)
     case kErrorNone:
         if (IsRouterRloc16(sourceAddress))
         {
-            neighbor = mRouterTable.FindRouterByRloc16(sourceAddress);
-            VerifyOrExit(neighbor != nullptr, error = kErrorParse);
+            Router *router = mRouterTable.FindRouterByRloc16(sourceAddress);
+
+            VerifyOrExit(router != nullptr, error = kErrorParse);
 
-            if (!neighbor->IsStateValid())
+            if (!router->IsStateValid())
             {
-                InitNeighbor(*neighbor, aRxInfo);
-                neighbor->SetState(Neighbor::kStateLinkRequest);
+                InitNeighbor(*router, aRxInfo);
+                router->SetState(Neighbor::kStateLinkRequest);
+                router->ClearLinkAcceptTimeout();
             }
             else
             {
-                VerifyOrExit(neighbor->GetExtAddress() == info.mExtAddress);
+                VerifyOrExit(router->GetExtAddress() == info.mExtAddress);
             }
+
+            neighbor = router;
         }
 
         break;
@@ -788,7 +737,7 @@ exit:
     OT_UNUSED_VARIABLE(neighbor);
 }
 
-Error MleRouter::SendLinkAccept(const LinkAcceptInfo &aInfo)
+Error Mle::SendLinkAccept(const LinkAcceptInfo &aInfo)
 {
     static const uint8_t kRouterTlvs[] = {Tlv::kLinkMargin};
 
@@ -875,14 +824,11 @@ exit:
     return error;
 }
 
-void MleRouter::HandleLinkAccept(RxInfo &aRxInfo) { HandleLinkAcceptVariant(aRxInfo, kTypeLinkAccept); }
+void Mle::HandleLinkAccept(RxInfo &aRxInfo) { HandleLinkAcceptVariant(aRxInfo, kTypeLinkAccept); }
 
-void MleRouter::HandleLinkAcceptAndRequest(RxInfo &aRxInfo)
-{
-    HandleLinkAcceptVariant(aRxInfo, kTypeLinkAcceptAndRequest);
-}
+void Mle::HandleLinkAcceptAndRequest(RxInfo &aRxInfo) { HandleLinkAcceptVariant(aRxInfo, kTypeLinkAcceptAndRequest); }
 
-void MleRouter::HandleLinkAcceptVariant(RxInfo &aRxInfo, MessageType aMessageType)
+void Mle::HandleLinkAcceptVariant(RxInfo &aRxInfo, MessageType aMessageType)
 {
     // Handles "Link Accept" or "Link Accept And Request".
 
@@ -1091,7 +1037,7 @@ exit:
     LogProcessError(aMessageType, error);
 }
 
-Error MleRouter::ProcessRouteTlv(const RouteTlv &aRouteTlv, RxInfo &aRxInfo)
+Error Mle::ProcessRouteTlv(const RouteTlv &aRouteTlv, RxInfo &aRxInfo)
 {
     // This method processes `aRouteTlv` read from an MLE message.
     //
@@ -1126,7 +1072,7 @@ Error MleRouter::ProcessRouteTlv(const RouteTlv &aRouteTlv, RxInfo &aRxInfo)
     return error;
 }
 
-Error MleRouter::ReadAndProcessRouteTlvOnFtdChild(RxInfo &aRxInfo, uint8_t aParentId)
+Error Mle::ReadAndProcessRouteTlvOnFtdChild(RxInfo &aRxInfo, uint8_t aParentId)
 {
     // This method reads and processes Route TLV from message on an
     // FTD child if message contains one. It returns `kErrorNone`
@@ -1158,7 +1104,7 @@ exit:
     return error;
 }
 
-bool MleRouter::IsSingleton(void) const
+bool Mle::IsSingleton(void) const
 {
     bool isSingleton = true;
 
@@ -1169,10 +1115,10 @@ exit:
     return isSingleton;
 }
 
-int MleRouter::ComparePartitions(bool              aSingletonA,
-                                 const LeaderData &aLeaderDataA,
-                                 bool              aSingletonB,
-                                 const LeaderData &aLeaderDataB)
+int Mle::ComparePartitions(bool              aSingletonA,
+                           const LeaderData &aLeaderDataA,
+                           bool              aSingletonB,
+                           const LeaderData &aLeaderDataB)
 {
     int rval = 0;
 
@@ -1189,7 +1135,7 @@ exit:
     return rval;
 }
 
-Error MleRouter::HandleAdvertisementOnFtd(RxInfo &aRxInfo, uint16_t aSourceAddress, const LeaderData &aLeaderData)
+Error Mle::HandleAdvertisementOnFtd(RxInfo &aRxInfo, uint16_t aSourceAddress, const LeaderData &aLeaderData)
 {
     // This method processes a received MLE Advertisement message on
     // an FTD device. It is called from `Mle::HandleAdvertisement()`
@@ -1361,6 +1307,7 @@ Error MleRouter::HandleAdvertisementOnFtd(RxInfo &aRxInfo, uint16_t aSourceAddre
     {
         InitNeighbor(*router, aRxInfo);
         router->SetState(Neighbor::kStateLinkRequest);
+        router->ClearLinkAcceptTimeout();
         delay = Random::NonCrypto::GetUint32InRange(0, kMaxLinkRequestDelayOnRouter);
         mDelayedSender.ScheduleLinkRequest(*router, delay);
         ExitNow(error = kErrorNoRoute);
@@ -1379,7 +1326,7 @@ exit:
     return error;
 }
 
-void MleRouter::EstablishRouterLinkOnFtdChild(Router &aRouter, RxInfo &aRxInfo, uint8_t aLinkMargin)
+void Mle::EstablishRouterLinkOnFtdChild(Router &aRouter, RxInfo &aRxInfo, uint8_t aLinkMargin)
 {
     // Decide on an FTD child whether to establish a link with a
     // router upon receiving an advertisement from it.
@@ -1435,13 +1382,14 @@ void MleRouter::EstablishRouterLinkOnFtdChild(Router &aRouter, RxInfo &aRxInfo,
 
     InitNeighbor(aRouter, aRxInfo);
     aRouter.SetState(Neighbor::kStateLinkRequest);
+    aRouter.ClearLinkAcceptTimeout();
     mDelayedSender.ScheduleLinkRequest(aRouter, Random::NonCrypto::GetUint32InRange(minDelay, maxDelay));
 
 exit:
     return;
 }
 
-void MleRouter::HandleParentRequest(RxInfo &aRxInfo)
+void Mle::HandleParentRequest(RxInfo &aRxInfo)
 {
     Error              error = kErrorNone;
     uint16_t           version;
@@ -1476,7 +1424,7 @@ void MleRouter::HandleParentRequest(RxInfo &aRxInfo)
     // the network (because Leader would reject any further address solicit).
     // ==> Verified below when checking the scan mask.
 
-    aRxInfo.mMessageInfo.GetPeerAddr().GetIid().ConvertToExtAddress(info.mChildExtAddress);
+    info.mChildExtAddress.SetFromIid(aRxInfo.mMessageInfo.GetPeerAddr().GetIid());
 
     SuccessOrExit(error = aRxInfo.mMessage.ReadVersionTlv(version));
 
@@ -1541,7 +1489,7 @@ exit:
     LogProcessError(kTypeParentRequest, error);
 }
 
-bool MleRouter::HasNeighborWithGoodLinkQuality(void) const
+bool Mle::HasNeighborWithGoodLinkQuality(void) const
 {
     bool    haveNeighbor = true;
     uint8_t linkMargin;
@@ -1574,11 +1522,11 @@ exit:
     return haveNeighbor;
 }
 
-void MleRouter::HandleTimeTick(void)
+void Mle::HandleTimeTick(void)
 {
     bool roleTransitionTimeoutExpired = false;
 
-    VerifyOrExit(IsFullThreadDevice(), Get<TimeTicker>().UnregisterReceiver(TimeTicker::kMleRouter));
+    VerifyOrExit(IsFullThreadDevice(), Get<TimeTicker>().UnregisterReceiver(TimeTicker::kMle));
 
     if (mPreviousPartitionIdTimeout > 0)
     {
@@ -1776,6 +1724,14 @@ void MleRouter::HandleTimeTick(void)
             }
         }
 
+        if (router.IsStateLinkRequest() && !mDelayedSender.HasAnyScheduledLinkRequest(router) &&
+            !router.IsWaitingForLinkAccept())
+        {
+            LogInfo("Router 0x%04x - Failed to schedule/send Link Request", router.GetRloc16());
+            RemoveNeighbor(router);
+            continue;
+        }
+
         if (router.IsWaitingForLinkAccept() && (router.DecrementLinkAcceptTimeout() == 0))
         {
             LogInfo("Router 0x%04x - Link Accept timeout expired", router.GetRloc16());
@@ -1806,7 +1762,7 @@ exit:
     return;
 }
 
-void MleRouter::SendParentResponse(const ParentResponseInfo &aInfo)
+void Mle::SendParentResponse(const ParentResponseInfo &aInfo)
 {
     Error        error   = kErrorNone;
     TxMessage   *message = nullptr;
@@ -1852,7 +1808,7 @@ exit:
     LogSendError(kTypeParentResponse, error);
 }
 
-uint8_t MleRouter::GetMaxChildIpAddresses(void) const
+uint8_t Mle::GetMaxChildIpAddresses(void) const
 {
     uint8_t num = kMaxChildIpAddresses;
 
@@ -1867,7 +1823,7 @@ uint8_t MleRouter::GetMaxChildIpAddresses(void) const
 }
 
 #if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
-Error MleRouter::SetMaxChildIpAddresses(uint8_t aMaxIpAddresses)
+Error Mle::SetMaxChildIpAddresses(uint8_t aMaxIpAddresses)
 {
     Error error = kErrorNone;
 
@@ -1880,7 +1836,7 @@ exit:
 }
 #endif
 
-Error MleRouter::ProcessAddressRegistrationTlv(RxInfo &aRxInfo, Child &aChild)
+Error Mle::ProcessAddressRegistrationTlv(RxInfo &aRxInfo, Child &aChild)
 {
     Error       error;
     OffsetRange offsetRange;
@@ -2048,7 +2004,7 @@ exit:
 }
 
 #if OPENTHREAD_CONFIG_TMF_PROXY_DUA_ENABLE
-void MleRouter::SignalDuaAddressEvent(const Child &aChild, const Ip6::Address &aOldDua) const
+void Mle::SignalDuaAddressEvent(const Child &aChild, const Ip6::Address &aOldDua) const
 {
     DuaManager::ChildDuaAddressEvent event = DuaManager::kAddressUnchanged;
     Ip6::Address                     newDua;
@@ -2081,14 +2037,14 @@ exit:
 }
 #endif // OPENTHREAD_CONFIG_TMF_PROXY_DUA_ENABLE
 
-bool MleRouter::IsMessageMleSubType(const Message &aMessage) { return aMessage.IsSubTypeMle(); }
+bool Mle::IsMessageMleSubType(const Message &aMessage) { return aMessage.IsSubTypeMle(); }
 
-bool MleRouter::IsMessageChildUpdateRequest(const Message &aMessage)
+bool Mle::IsMessageChildUpdateRequest(const Message &aMessage)
 {
     return aMessage.IsMleCommand(kCommandChildUpdateRequest);
 }
 
-void MleRouter::HandleChildIdRequest(RxInfo &aRxInfo)
+void Mle::HandleChildIdRequest(RxInfo &aRxInfo)
 {
     Error              error = kErrorNone;
     Mac::ExtAddress    extAddr;
@@ -2109,7 +2065,7 @@ void MleRouter::HandleChildIdRequest(RxInfo &aRxInfo)
 
     VerifyOrExit(IsAttached(), error = kErrorInvalidState);
 
-    aRxInfo.mMessageInfo.GetPeerAddr().GetIid().ConvertToExtAddress(extAddr);
+    extAddr.SetFromIid(aRxInfo.mMessageInfo.GetPeerAddr().GetIid());
 
     child = mChildTable.FindChild(extAddr, Child::kInStateAnyExceptInvalid);
     VerifyOrExit(child != nullptr, error = kErrorAlready);
@@ -2249,7 +2205,7 @@ exit:
     LogProcessError(kTypeChildIdRequest, error);
 }
 
-void MleRouter::HandleChildUpdateRequestOnParent(RxInfo &aRxInfo)
+void Mle::HandleChildUpdateRequestOnParent(RxInfo &aRxInfo)
 {
     Error           error = kErrorNone;
     Mac::ExtAddress extAddr;
@@ -2282,7 +2238,7 @@ void MleRouter::HandleChildUpdateRequestOnParent(RxInfo &aRxInfo)
 
     tlvList.Add(Tlv::kSourceAddress);
 
-    aRxInfo.mMessageInfo.GetPeerAddr().GetIid().ConvertToExtAddress(extAddr);
+    extAddr.SetFromIid(aRxInfo.mMessageInfo.GetPeerAddr().GetIid());
     child = mChildTable.FindChild(extAddr, Child::kInStateAnyExceptInvalid);
 
     if (child == nullptr)
@@ -2467,7 +2423,7 @@ exit:
     LogProcessError(kTypeChildUpdateRequestOfChild, error);
 }
 
-void MleRouter::HandleChildUpdateResponseOnParent(RxInfo &aRxInfo)
+void Mle::HandleChildUpdateResponseOnParent(RxInfo &aRxInfo)
 {
     Error       error = kErrorNone;
     uint16_t    sourceAddress;
@@ -2612,7 +2568,7 @@ exit:
     LogProcessError(kTypeChildUpdateResponseOfChild, error);
 }
 
-void MleRouter::HandleDataRequest(RxInfo &aRxInfo)
+void Mle::HandleDataRequest(RxInfo &aRxInfo)
 {
     Error              error = kErrorNone;
     TlvList            tlvList;
@@ -2669,7 +2625,7 @@ exit:
     LogProcessError(kTypeDataRequest, error);
 }
 
-void MleRouter::HandleNetworkDataUpdateRouter(void)
+void Mle::HandleNetworkDataUpdateRouter(void)
 {
     uint16_t delay;
 
@@ -2691,7 +2647,7 @@ exit:
     return;
 }
 
-void MleRouter::SynchronizeChildNetworkData(void)
+void Mle::SynchronizeChildNetworkData(void)
 {
     VerifyOrExit(IsRouterOrLeader());
 
@@ -2715,7 +2671,7 @@ exit:
 }
 
 #if OPENTHREAD_CONFIG_MLE_STEERING_DATA_SET_OOB_ENABLE
-void MleRouter::SetSteeringData(const Mac::ExtAddress *aExtAddress)
+void Mle::SetSteeringData(const Mac::ExtAddress *aExtAddress)
 {
     Mac::ExtAddress nullExtAddr;
     Mac::ExtAddress allowAnyExtAddr;
@@ -2742,7 +2698,7 @@ void MleRouter::SetSteeringData(const Mac::ExtAddress *aExtAddress)
 }
 #endif // OPENTHREAD_CONFIG_MLE_STEERING_DATA_SET_OOB_ENABLE
 
-void MleRouter::HandleDiscoveryRequest(RxInfo &aRxInfo)
+void Mle::HandleDiscoveryRequest(RxInfo &aRxInfo)
 {
     Error                        error = kErrorNone;
     Tlv::ParsedInfo              tlvInfo;
@@ -2794,7 +2750,7 @@ void MleRouter::HandleDiscoveryRequest(RxInfo &aRxInfo)
         {
             otThreadDiscoveryRequestInfo info;
 
-            aRxInfo.mMessageInfo.GetPeerAddr().GetIid().ConvertToExtAddress(AsCoreType(&info.mExtAddress));
+            AsCoreType(&info.mExtAddress).SetFromIid(aRxInfo.mMessageInfo.GetPeerAddr().GetIid());
             info.mVersion  = discoveryRequestTlv.GetVersion();
             info.mIsJoiner = discoveryRequestTlv.IsJoiner();
 
@@ -2830,7 +2786,7 @@ exit:
     LogProcessError(kTypeDiscoveryRequest, error);
 }
 
-Error MleRouter::SendDiscoveryResponse(const Ip6::Address &aDestination, const DiscoveryResponseInfo &aInfo)
+Error Mle::SendDiscoveryResponse(const Ip6::Address &aDestination, const DiscoveryResponseInfo &aInfo)
 {
     Error                         error = kErrorNone;
     TxMessage                    *message;
@@ -2906,7 +2862,7 @@ exit:
     return error;
 }
 
-Error MleRouter::SendChildIdResponse(Child &aChild)
+Error Mle::SendChildIdResponse(Child &aChild)
 {
     Error        error = kErrorNone;
     Ip6::Address destination;
@@ -2998,7 +2954,7 @@ exit:
     return error;
 }
 
-Error MleRouter::SendChildUpdateRequestToChild(Child &aChild)
+Error Mle::SendChildUpdateRequestToChild(Child &aChild)
 {
     static const uint8_t kTlvs[] = {Tlv::kTimeout, Tlv::kAddressRegistration};
 
@@ -3067,10 +3023,10 @@ exit:
     return error;
 }
 
-void MleRouter::SendChildUpdateResponseToChild(Child                  *aChild,
-                                               const Ip6::MessageInfo &aMessageInfo,
-                                               const TlvList          &aTlvList,
-                                               const RxChallenge      &aChallenge)
+void Mle::SendChildUpdateResponseToChild(Child                  *aChild,
+                                         const Ip6::MessageInfo &aMessageInfo,
+                                         const TlvList          &aTlvList,
+                                         const RxChallenge      &aChallenge)
 {
     Error      error = kErrorNone;
     TxMessage *message;
@@ -3169,7 +3125,7 @@ exit:
     FreeMessageOnError(message, error);
 }
 
-void MleRouter::SendMulticastDataResponse(void)
+void Mle::SendMulticastDataResponse(void)
 {
     Ip6::Address destination;
     TlvList      tlvList;
@@ -3179,9 +3135,7 @@ void MleRouter::SendMulticastDataResponse(void)
     SendDataResponse(destination, tlvList);
 }
 
-void MleRouter::SendDataResponse(const Ip6::Address &aDestination,
-                                 const TlvList      &aTlvList,
-                                 const Message      *aRequestMessage)
+void Mle::SendDataResponse(const Ip6::Address &aDestination, const TlvList &aTlvList, const Message *aRequestMessage)
 {
     OT_UNUSED_VARIABLE(aRequestMessage);
 
@@ -3243,7 +3197,7 @@ exit:
     LogSendError(kTypeDataResponse, error);
 }
 
-void MleRouter::RemoveRouterLink(Router &aRouter)
+void Mle::RemoveRouterLink(Router &aRouter)
 {
     switch (mRole)
     {
@@ -3264,7 +3218,7 @@ void MleRouter::RemoveRouterLink(Router &aRouter)
     }
 }
 
-void MleRouter::RemoveNeighbor(Neighbor &aNeighbor)
+void Mle::RemoveNeighbor(Neighbor &aNeighbor)
 {
     VerifyOrExit(!aNeighbor.IsStateInvalid());
 
@@ -3315,7 +3269,7 @@ exit:
     return;
 }
 
-Error MleRouter::SetPreferredRouterId(uint8_t aRouterId)
+Error Mle::SetPreferredRouterId(uint8_t aRouterId)
 {
     Error error = kErrorNone;
 
@@ -3327,13 +3281,13 @@ exit:
     return error;
 }
 
-void MleRouter::SetRouterId(uint8_t aRouterId)
+void Mle::SetRouterId(uint8_t aRouterId)
 {
     mRouterId         = aRouterId;
     mPreviousRouterId = mRouterId;
 }
 
-Error MleRouter::SendAddressSolicit(ThreadStatusTlv::Status aStatus)
+Error Mle::SendAddressSolicit(ThreadStatusTlv::Status aStatus)
 {
     Error            error = kErrorNone;
     Tmf::MessageInfo messageInfo(GetInstance());
@@ -3369,7 +3323,7 @@ exit:
     return error;
 }
 
-void MleRouter::SendAddressRelease(void)
+void Mle::SendAddressRelease(void)
 {
     Error            error = kErrorNone;
     Tmf::MessageInfo messageInfo(GetInstance());
@@ -3392,18 +3346,16 @@ exit:
     LogSendError(kTypeAddressRelease, error);
 }
 
-void MleRouter::HandleAddressSolicitResponse(void                *aContext,
-                                             otMessage           *aMessage,
-                                             const otMessageInfo *aMessageInfo,
-                                             otError              aResult)
+void Mle::HandleAddressSolicitResponse(void                *aContext,
+                                       otMessage           *aMessage,
+                                       const otMessageInfo *aMessageInfo,
+                                       otError              aResult)
 {
-    static_cast<MleRouter *>(aContext)->HandleAddressSolicitResponse(AsCoapMessagePtr(aMessage),
-                                                                     AsCoreTypePtr(aMessageInfo), aResult);
+    static_cast<Mle *>(aContext)->HandleAddressSolicitResponse(AsCoapMessagePtr(aMessage), AsCoreTypePtr(aMessageInfo),
+                                                               aResult);
 }
 
-void MleRouter::HandleAddressSolicitResponse(Coap::Message          *aMessage,
-                                             const Ip6::MessageInfo *aMessageInfo,
-                                             Error                   aResult)
+void Mle::HandleAddressSolicitResponse(Coap::Message *aMessage, const Ip6::MessageInfo *aMessageInfo, Error aResult)
 {
     uint8_t             status;
     uint16_t            rloc16;
@@ -3511,7 +3463,7 @@ exit:
     InformPreviousChannel();
 }
 
-Error MleRouter::SetChildRouterLinks(uint8_t aChildRouterLinks)
+Error Mle::SetChildRouterLinks(uint8_t aChildRouterLinks)
 {
     Error error = kErrorNone;
 
@@ -3521,7 +3473,7 @@ exit:
     return error;
 }
 
-bool MleRouter::IsExpectedToBecomeRouterSoon(void) const
+bool Mle::IsExpectedToBecomeRouterSoon(void) const
 {
     static constexpr uint8_t kMaxDelay = 10;
 
@@ -3530,7 +3482,7 @@ bool MleRouter::IsExpectedToBecomeRouterSoon(void) const
             mAddressSolicitPending);
 }
 
-template <> void MleRouter::HandleTmf<kUriAddressSolicit>(Coap::Message &aMessage, const Ip6::MessageInfo &aMessageInfo)
+template <> void Mle::HandleTmf<kUriAddressSolicit>(Coap::Message &aMessage, const Ip6::MessageInfo &aMessageInfo)
 {
     Error                   error          = kErrorNone;
     ThreadStatusTlv::Status responseStatus = ThreadStatusTlv::kNoAddressAvailable;
@@ -3628,10 +3580,10 @@ exit:
     }
 }
 
-void MleRouter::SendAddressSolicitResponse(const Coap::Message    &aRequest,
-                                           ThreadStatusTlv::Status aResponseStatus,
-                                           const Router           *aRouter,
-                                           const Ip6::MessageInfo &aMessageInfo)
+void Mle::SendAddressSolicitResponse(const Coap::Message    &aRequest,
+                                     ThreadStatusTlv::Status aResponseStatus,
+                                     const Router           *aRouter,
+                                     const Ip6::MessageInfo &aMessageInfo)
 {
     Coap::Message *message = Get<Tmf::Agent>().NewPriorityResponseMessage(aRequest);
 
@@ -3680,7 +3632,7 @@ exit:
     FreeMessage(message);
 }
 
-template <> void MleRouter::HandleTmf<kUriAddressRelease>(Coap::Message &aMessage, const Ip6::MessageInfo &aMessageInfo)
+template <> void Mle::HandleTmf<kUriAddressRelease>(Coap::Message &aMessage, const Ip6::MessageInfo &aMessageInfo)
 {
     uint16_t        rloc16;
     Mac::ExtAddress extAddress;
@@ -3711,7 +3663,7 @@ exit:
     return;
 }
 
-void MleRouter::FillConnectivityTlv(ConnectivityTlv &aTlv)
+void Mle::FillConnectivityTlv(ConnectivityTlv &aTlv)
 {
     int8_t parentPriority = kParentPriorityMedium;
 
@@ -3767,7 +3719,7 @@ void MleRouter::FillConnectivityTlv(ConnectivityTlv &aTlv)
     aTlv.SetSedDatagramCount(OPENTHREAD_CONFIG_DEFAULT_SED_DATAGRAM_COUNT);
 }
 
-bool MleRouter::ShouldDowngrade(uint8_t aNeighborId, const RouteTlv &aRouteTlv) const
+bool Mle::ShouldDowngrade(uint8_t aNeighborId, const RouteTlv &aRouteTlv) const
 {
     // Determine whether all conditions are satisfied for the router
     // to downgrade after receiving info for a neighboring router
@@ -3829,7 +3781,7 @@ exit:
     return shouldDowngrade;
 }
 
-bool MleRouter::NeighborHasComparableConnectivity(const RouteTlv &aRouteTlv, uint8_t aNeighborId) const
+bool Mle::NeighborHasComparableConnectivity(const RouteTlv &aRouteTlv, uint8_t aNeighborId) const
 {
     // Check whether the neighboring router with Router ID `aNeighborId`
     // (along with its `aRouteTlv`) has as good or better-quality links
@@ -3885,7 +3837,7 @@ exit:
     return isComparable;
 }
 
-void MleRouter::SetChildStateToValid(Child &aChild)
+void Mle::SetChildStateToValid(Child &aChild)
 {
     VerifyOrExit(!aChild.IsStateValid());
 
@@ -3902,9 +3854,9 @@ exit:
     return;
 }
 
-bool MleRouter::HasChildren(void) { return mChildTable.HasChildren(Child::kInStateValidOrAttaching); }
+bool Mle::HasChildren(void) { return mChildTable.HasChildren(Child::kInStateValidOrAttaching); }
 
-void MleRouter::RemoveChildren(void)
+void Mle::RemoveChildren(void)
 {
     for (Child &child : Get<ChildTable>().Iterate(Child::kInStateValidOrRestoring))
     {
@@ -3912,7 +3864,7 @@ void MleRouter::RemoveChildren(void)
     }
 }
 
-Error MleRouter::SetAssignParentPriority(int8_t aParentPriority)
+Error Mle::SetAssignParentPriority(int8_t aParentPriority)
 {
     Error error = kErrorNone;
 
@@ -3925,7 +3877,7 @@ exit:
     return error;
 }
 
-Error MleRouter::GetMaxChildTimeout(uint32_t &aTimeout) const
+Error Mle::GetMaxChildTimeout(uint32_t &aTimeout) const
 {
     Error error = kErrorNotFound;
 
@@ -3953,7 +3905,7 @@ exit:
 }
 
 #if OPENTHREAD_CONFIG_TIME_SYNC_ENABLE
-Error MleRouter::SendTimeSync(void)
+Error Mle::SendTimeSync(void)
 {
     Error        error = kErrorNone;
     Ip6::Address destination;
@@ -3977,18 +3929,15 @@ exit:
 //----------------------------------------------------------------------------------------------------------------------
 // RouterRoleTransition
 
-MleRouter::RouterRoleTransition::RouterRoleTransition(void)
+Mle::RouterRoleTransition::RouterRoleTransition(void)
     : mTimeout(0)
     , mJitter(kRouterSelectionJitter)
 {
 }
 
-void MleRouter::RouterRoleTransition::StartTimeout(void)
-{
-    mTimeout = 1 + Random::NonCrypto::GetUint8InRange(0, mJitter);
-}
+void Mle::RouterRoleTransition::StartTimeout(void) { mTimeout = 1 + Random::NonCrypto::GetUint8InRange(0, mJitter); }
 
-bool MleRouter::RouterRoleTransition::HandleTimeTick(void)
+bool Mle::RouterRoleTransition::HandleTimeTick(void)
 {
     bool expired = false;
 
@@ -4003,13 +3952,13 @@ exit:
 //----------------------------------------------------------------------------------------------------------------------
 // RouterRoleRestorer
 
-MleRouter::RouterRoleRestorer::RouterRoleRestorer(Instance &aInstance)
+Mle::RouterRoleRestorer::RouterRoleRestorer(Instance &aInstance)
     : InstanceLocator(aInstance)
     , mAttempts(0)
 {
 }
 
-void MleRouter::RouterRoleRestorer::Start(DeviceRole aPreviousRole)
+void Mle::RouterRoleRestorer::Start(DeviceRole aPreviousRole)
 {
     // If the device was previously the leader or had more than
     // `kMinCriticalChildrenCount` children, we use more link
@@ -4020,7 +3969,7 @@ void MleRouter::RouterRoleRestorer::Start(DeviceRole aPreviousRole)
     switch (aPreviousRole)
     {
     case kRoleRouter:
-        if (Get<MleRouter>().mChildTable.GetNumChildren(Child::kInStateValidOrRestoring) < kMinCriticalChildrenCount)
+        if (Get<Mle>().mChildTable.GetNumChildren(Child::kInStateValidOrRestoring) < kMinCriticalChildrenCount)
         {
             mAttempts = kMaxTxCount;
             break;
@@ -4041,7 +3990,7 @@ void MleRouter::RouterRoleRestorer::Start(DeviceRole aPreviousRole)
     SendMulticastLinkRequest();
 }
 
-void MleRouter::RouterRoleRestorer::HandleTimer(void)
+void Mle::RouterRoleRestorer::HandleTimer(void)
 {
     if (mAttempts > 0)
     {
@@ -4051,7 +4000,7 @@ void MleRouter::RouterRoleRestorer::HandleTimer(void)
     SendMulticastLinkRequest();
 }
 
-void MleRouter::RouterRoleRestorer::SendMulticastLinkRequest(void)
+void Mle::RouterRoleRestorer::SendMulticastLinkRequest(void)
 {
     uint32_t delay;
 
@@ -4063,7 +4012,7 @@ void MleRouter::RouterRoleRestorer::SendMulticastLinkRequest(void)
         ExitNow();
     }
 
-    Get<MleRouter>().SendLinkRequest(nullptr);
+    Get<Mle>().SendLinkRequest(nullptr);
 
     delay = (mAttempts == 1) ? kLinkRequestTimeout
                              : Random::NonCrypto::GetUint32InRange(kMulticastRetxDelayMin, kMulticastRetxDelayMax);
diff --git a/src/core/thread/mle_router.hpp b/src/core/thread/mle_router.hpp
deleted file mode 100644
index a9e8ccd37..000000000
--- a/src/core/thread/mle_router.hpp
+++ /dev/null
@@ -1,742 +0,0 @@
-/*
- *  Copyright (c) 2016, The OpenThread Authors.
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *  1. Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *  2. Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- *  3. Neither the name of the copyright holder nor the
- *     names of its contributors may be used to endorse or promote products
- *     derived from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**
- * @file
- *   This file includes definitions for MLE functionality required by the Thread Router and Leader roles.
- */
-
-#ifndef MLE_ROUTER_HPP_
-#define MLE_ROUTER_HPP_
-
-#include "openthread-core-config.h"
-
-#include <openthread/thread_ftd.h>
-
-#include "coap/coap_message.hpp"
-#include "common/callback.hpp"
-#include "common/time_ticker.hpp"
-#include "common/timer.hpp"
-#include "common/trickle_timer.hpp"
-#include "mac/mac_types.hpp"
-#include "meshcop/meshcop_tlvs.hpp"
-#include "net/icmp6.hpp"
-#include "net/udp6.hpp"
-#include "thread/child.hpp"
-#include "thread/child_table.hpp"
-#include "thread/mle.hpp"
-#include "thread/mle_tlvs.hpp"
-#include "thread/router.hpp"
-#include "thread/router_table.hpp"
-#include "thread/thread_tlvs.hpp"
-#include "thread/tmf.hpp"
-
-namespace ot {
-namespace Mle {
-
-/**
- * @addtogroup core-mle-router
- *
- * @brief
- *   This module includes definitions for MLE functionality required by the Thread Router and Leader roles.
- *
- * @{
- */
-
-#if OPENTHREAD_FTD
-
-/**
- * Implements MLE functionality required by the Thread Router and Leader roles.
- */
-class MleRouter : public Mle
-{
-    friend class Mle;
-    friend class ot::Instance;
-    friend class ot::TimeTicker;
-    friend class Tmf::Agent;
-
-public:
-    /**
-     * Initializes the object.
-     *
-     * @param[in]  aInstance     A reference to the OpenThread instance.
-     */
-    explicit MleRouter(Instance &aInstance);
-
-    /**
-     * Indicates whether or not the device is router-eligible.
-     *
-     * @retval true   If device is router-eligible.
-     * @retval false  If device is not router-eligible.
-     */
-    bool IsRouterEligible(void) const;
-
-    /**
-     * Sets whether or not the device is router-eligible.
-     *
-     * If @p aEligible is false and the device is currently operating as a router, this call will cause the device to
-     * detach and attempt to reattach as a child.
-     *
-     * @param[in]  aEligible  TRUE to configure device router-eligible, FALSE otherwise.
-     *
-     * @retval kErrorNone         Successfully set the router-eligible configuration.
-     * @retval kErrorNotCapable   The device is not capable of becoming a router.
-     */
-    Error SetRouterEligible(bool aEligible);
-
-    /**
-     * Indicates whether a node is the only router on the network.
-     *
-     * @retval TRUE   It is the only router in the network.
-     * @retval FALSE  It is a child or is not a single router in the network.
-     */
-    bool IsSingleton(void) const;
-
-    /**
-     * Generates an Address Solicit request for a Router ID.
-     *
-     * @param[in]  aStatus  The reason for requesting a Router ID.
-     *
-     * @retval kErrorNone           Successfully generated an Address Solicit message.
-     * @retval kErrorNotCapable     Device is not capable of becoming a router
-     * @retval kErrorInvalidState   Thread is not enabled
-     */
-    Error BecomeRouter(ThreadStatusTlv::Status aStatus);
-
-    /**
-     * Becomes a leader and starts a new partition.
-     *
-     * If the device is already attached, this method can be used to attempt to take over as the leader, creating a new
-     * partition. For this to work, the local leader weight must be greater than the weight of the current leader. The
-     * @p aCheckWeight can be used to ensure that this check is performed.
-     *
-     * @param[in] aCheckWeight      Check that the local leader weight is larger than the weight of the current leader.
-     *
-     * @retval kErrorNone           Successfully become a Leader and started a new partition.
-     * @retval kErrorInvalidState   Thread is not enabled.
-     * @retval kErrorNotCapable     Device is not capable of becoming a leader (not router eligible), or
-     *                              @p aCheckWeight is true and cannot override the current leader due to its local
-     *                              leader weight being same or smaller than current leader's weight.
-     */
-    Error BecomeLeader(bool aCheckWeight);
-
-#if OPENTHREAD_CONFIG_MLE_DEVICE_PROPERTY_LEADER_WEIGHT_ENABLE
-    /**
-     * Gets the device properties which are used to determine the Leader Weight.
-     *
-     * @returns The current device properties.
-     */
-    const DeviceProperties &GetDeviceProperties(void) const { return mDeviceProperties; }
-
-    /**
-     * Sets the device properties which are then used to determine and set the Leader Weight.
-     *
-     * @param[in]  aDeviceProperties    The device properties.
-     */
-    void SetDeviceProperties(const DeviceProperties &aDeviceProperties);
-#endif
-
-    /**
-     * Returns the Leader Weighting value for this Thread interface.
-     *
-     * @returns The Leader Weighting value for this Thread interface.
-     */
-    uint8_t GetLeaderWeight(void) const { return mLeaderWeight; }
-
-    /**
-     * Sets the Leader Weighting value for this Thread interface.
-     *
-     * Directly sets the Leader Weight to the new value replacing its previous value (which may have been
-     * determined from a previous call to `SetDeviceProperties()`).
-     *
-     * @param[in]  aWeight  The Leader Weighting value.
-     */
-    void SetLeaderWeight(uint8_t aWeight) { mLeaderWeight = aWeight; }
-
-#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
-
-    /**
-     * Returns the preferred Partition Id when operating in the Leader role for certification testing.
-     *
-     * @returns The preferred Partition Id value.
-     */
-    uint32_t GetPreferredLeaderPartitionId(void) const { return mPreferredLeaderPartitionId; }
-
-    /**
-     * Sets the preferred Partition Id when operating in the Leader role for certification testing.
-     *
-     * @param[in]  aPartitionId  The preferred Leader Partition Id.
-     */
-    void SetPreferredLeaderPartitionId(uint32_t aPartitionId) { mPreferredLeaderPartitionId = aPartitionId; }
-#endif
-
-    /**
-     * Sets the preferred Router Id. Upon becoming a router/leader the node
-     * attempts to use this Router Id. If the preferred Router Id is not set or if it
-     * can not be used, a randomly generated router Id is picked.
-     * This property can be set when he device role is detached or disabled.
-     *
-     * @param[in]  aRouterId             The preferred Router Id.
-     *
-     * @retval kErrorNone          Successfully set the preferred Router Id.
-     * @retval kErrorInvalidState  Could not set (role is other than detached and disabled)
-     */
-    Error SetPreferredRouterId(uint8_t aRouterId);
-
-    /**
-     * Gets the Partition Id which the device joined successfully once.
-     */
-    uint32_t GetPreviousPartitionId(void) const { return mPreviousPartitionId; }
-
-    /**
-     * Sets the Partition Id which the device joins successfully.
-     *
-     * @param[in]  aPartitionId   The Partition Id.
-     */
-    void SetPreviousPartitionId(uint32_t aPartitionId) { mPreviousPartitionId = aPartitionId; }
-
-    /**
-     * Sets the Router Id.
-     *
-     * @param[in]  aRouterId   The Router Id.
-     */
-    void SetRouterId(uint8_t aRouterId);
-
-    /**
-     * Returns the NETWORK_ID_TIMEOUT value.
-     *
-     * @returns The NETWORK_ID_TIMEOUT value.
-     */
-    uint8_t GetNetworkIdTimeout(void) const { return mNetworkIdTimeout; }
-
-    /**
-     * Sets the NETWORK_ID_TIMEOUT value.
-     *
-     * @param[in]  aTimeout  The NETWORK_ID_TIMEOUT value.
-     */
-    void SetNetworkIdTimeout(uint8_t aTimeout) { mNetworkIdTimeout = aTimeout; }
-
-    /**
-     * Returns the ROUTER_SELECTION_JITTER value.
-     *
-     * @returns The ROUTER_SELECTION_JITTER value in seconds.
-     */
-    uint8_t GetRouterSelectionJitter(void) const { return mRouterRoleTransition.GetJitter(); }
-
-    /**
-     * Sets the ROUTER_SELECTION_JITTER value.
-     *
-     * @param[in] aRouterJitter  The router selection jitter value (in seconds).
-     */
-    void SetRouterSelectionJitter(uint8_t aRouterJitter) { mRouterRoleTransition.SetJitter(aRouterJitter); }
-
-    /**
-     * Indicates whether or not router role transition (upgrade from REED or downgrade to REED) is pending.
-     *
-     * @retval TRUE    Router role transition is pending.
-     * @retval FALSE   Router role transition is not pending
-     */
-    bool IsRouterRoleTransitionPending(void) const { return mRouterRoleTransition.IsPending(); }
-
-    /**
-     * Returns the current timeout delay in seconds till router role transition (upgrade from REED or downgrade to
-     * REED).
-     *
-     * @returns The timeout in seconds till router role transition, or zero if not pending role transition.
-     */
-    uint8_t GetRouterRoleTransitionTimeout(void) const { return mRouterRoleTransition.GetTimeout(); }
-
-    /**
-     * Returns the ROUTER_UPGRADE_THRESHOLD value.
-     *
-     * @returns The ROUTER_UPGRADE_THRESHOLD value.
-     */
-    uint8_t GetRouterUpgradeThreshold(void) const { return mRouterUpgradeThreshold; }
-
-    /**
-     * Sets the ROUTER_UPGRADE_THRESHOLD value.
-     *
-     * @param[in]  aThreshold  The ROUTER_UPGRADE_THRESHOLD value.
-     */
-    void SetRouterUpgradeThreshold(uint8_t aThreshold) { mRouterUpgradeThreshold = aThreshold; }
-
-    /**
-     * Returns the ROUTER_DOWNGRADE_THRESHOLD value.
-     *
-     * @returns The ROUTER_DOWNGRADE_THRESHOLD value.
-     */
-    uint8_t GetRouterDowngradeThreshold(void) const { return mRouterDowngradeThreshold; }
-
-    /**
-     * Sets the ROUTER_DOWNGRADE_THRESHOLD value.
-     *
-     * @param[in]  aThreshold  The ROUTER_DOWNGRADE_THRESHOLD value.
-     */
-    void SetRouterDowngradeThreshold(uint8_t aThreshold) { mRouterDowngradeThreshold = aThreshold; }
-
-    /**
-     * Returns the MLE_CHILD_ROUTER_LINKS value.
-     *
-     * @returns The MLE_CHILD_ROUTER_LINKS value.
-     */
-    uint8_t GetChildRouterLinks(void) const { return mChildRouterLinks; }
-
-    /**
-     * Sets the MLE_CHILD_ROUTER_LINKS value.
-     *
-     * @param[in]  aChildRouterLinks  The MLE_CHILD_ROUTER_LINKS value.
-     *
-     * @retval kErrorNone          Successfully set the value.
-     * @retval kErrorInvalidState  Thread protocols are enabled.
-     */
-    Error SetChildRouterLinks(uint8_t aChildRouterLinks);
-
-    /**
-     * Returns if the REED is expected to become Router soon.
-     *
-     * @retval TRUE   If the REED is going to become a Router soon.
-     * @retval FALSE  If the REED is not going to become a Router soon.
-     */
-    bool IsExpectedToBecomeRouterSoon(void) const;
-
-    /**
-     * Removes a link to a neighbor.
-     *
-     * @param[in]  aNeighbor  A reference to the neighbor object.
-     */
-    void RemoveNeighbor(Neighbor &aNeighbor);
-
-    /**
-     * Invalidates a direct link to a neighboring router (due to failed link-layer acks).
-     *
-     * @param[in]  aRouter  A reference to the router object.
-     */
-    void RemoveRouterLink(Router &aRouter);
-
-    /**
-     * Indicates whether or not the given Thread partition attributes are preferred.
-     *
-     * @param[in]  aSingletonA   Whether or not the Thread Partition A has a single router.
-     * @param[in]  aLeaderDataA  A reference to Thread Partition A's Leader Data.
-     * @param[in]  aSingletonB   Whether or not the Thread Partition B has a single router.
-     * @param[in]  aLeaderDataB  A reference to Thread Partition B's Leader Data.
-     *
-     * @retval 1   If partition A is preferred.
-     * @retval 0   If partition A and B have equal preference.
-     * @retval -1  If partition B is preferred.
-     */
-    static int ComparePartitions(bool              aSingletonA,
-                                 const LeaderData &aLeaderDataA,
-                                 bool              aSingletonB,
-                                 const LeaderData &aLeaderDataB);
-
-    /**
-     * Fills an ConnectivityTlv.
-     *
-     * @param[out]  aTlv  A reference to the tlv to be filled.
-     */
-    void FillConnectivityTlv(ConnectivityTlv &aTlv);
-
-    /**
-     * Schedule tx of MLE Advertisement message (unicast) to the given neighboring router after a random delay.
-     *
-     * @param[in] aRouter  The router to send the Advertisement to.
-     *
-     */
-    void ScheduleUnicastAdvertisementTo(const Router &aRouter);
-
-#if OPENTHREAD_CONFIG_MLE_STEERING_DATA_SET_OOB_ENABLE
-    /**
-     * Sets steering data out of band
-     *
-     * @param[in]  aExtAddress  Value used to set steering data
-     *                          All zeros clears steering data
-     *                          All 0xFFs sets steering data to 0xFF
-     *                          Anything else is used to compute the bloom filter
-     */
-    void SetSteeringData(const Mac::ExtAddress *aExtAddress);
-#endif
-
-    /**
-     * Gets the assigned parent priority.
-     *
-     * @returns The assigned parent priority value, -2 means not assigned.
-     */
-    int8_t GetAssignParentPriority(void) const { return mParentPriority; }
-
-    /**
-     * Sets the parent priority.
-     *
-     * @param[in]  aParentPriority  The parent priority value.
-     *
-     * @retval kErrorNone           Successfully set the parent priority.
-     * @retval kErrorInvalidArgs    If the parent priority value is not among 1, 0, -1 and -2.
-     */
-    Error SetAssignParentPriority(int8_t aParentPriority);
-
-    /**
-     * Gets the longest MLE Timeout TLV for all active MTD children.
-     *
-     * @param[out]  aTimeout  A reference to where the information is placed.
-     *
-     * @retval kErrorNone           Successfully get the max child timeout
-     * @retval kErrorInvalidState   Not an active router
-     * @retval kErrorNotFound       NO MTD child
-     */
-    Error GetMaxChildTimeout(uint32_t &aTimeout) const;
-
-    /**
-     * Sets the callback that is called when processing an MLE Discovery Request message.
-     *
-     * @param[in]  aCallback A pointer to a function that is called to deliver MLE Discovery Request data.
-     * @param[in]  aContext  A pointer to application-specific context.
-     */
-    void SetDiscoveryRequestCallback(otThreadDiscoveryRequestCallback aCallback, void *aContext)
-    {
-        mDiscoveryRequestCallback.Set(aCallback, aContext);
-    }
-
-    /**
-     * Resets the MLE Advertisement Trickle timer interval.
-     */
-    void ResetAdvertiseInterval(void);
-
-    /**
-     * Updates the MLE Advertisement Trickle timer max interval (if timer is running).
-     *
-     * This is called when there is change in router table.
-     */
-    void UpdateAdvertiseInterval(void);
-
-#if OPENTHREAD_CONFIG_TIME_SYNC_ENABLE
-    /**
-     * Generates an MLE Time Synchronization message.
-     *
-     * @retval kErrorNone     Successfully sent an MLE Time Synchronization message.
-     * @retval kErrorNoBufs   Insufficient buffers to generate the MLE Time Synchronization message.
-     */
-    Error SendTimeSync(void);
-#endif
-
-    /**
-     * Gets the maximum number of IP addresses that each MTD child may register with this device as parent.
-     *
-     * @returns The maximum number of IP addresses that each MTD child may register with this device as parent.
-     */
-    uint8_t GetMaxChildIpAddresses(void) const;
-
-#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
-
-    /**
-     * Sets/restores the maximum number of IP addresses that each MTD child may register with this
-     * device as parent.
-     *
-     * @param[in]  aMaxIpAddresses  The maximum number of IP addresses that each MTD child may register with this
-     *                              device as parent. 0 to clear the setting and restore the default.
-     *
-     * @retval kErrorNone           Successfully set/cleared the number.
-     * @retval kErrorInvalidArgs    If exceeds the allowed maximum number.
-     */
-    Error SetMaxChildIpAddresses(uint8_t aMaxIpAddresses);
-
-    /**
-     * Sets whether the device was commissioned using CCM.
-     *
-     * @param[in]  aEnabled  TRUE if the device was commissioned using CCM, FALSE otherwise.
-     */
-    void SetCcmEnabled(bool aEnabled) { mCcmEnabled = aEnabled; }
-
-    /**
-     * Sets whether the Security Policy TLV version-threshold for routing (VR field) is enabled.
-     *
-     * @param[in]  aEnabled  TRUE to enable Security Policy TLV version-threshold for routing, FALSE otherwise.
-     */
-    void SetThreadVersionCheckEnabled(bool aEnabled) { mThreadVersionCheckEnabled = aEnabled; }
-
-    /**
-     * Gets the current Interval Max value used by Advertisement trickle timer.
-     *
-     * @returns The Interval Max of Advertisement trickle timer in milliseconds.
-     */
-    uint32_t GetAdvertisementTrickleIntervalMax(void) const { return mAdvertiseTrickleTimer.GetIntervalMax(); }
-
-#endif // OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
-
-private:
-    //------------------------------------------------------------------------------------------------------------------
-    // Constants
-
-    // Advertisement trickle timer constants - all times are in milliseconds.
-    static constexpr uint32_t kAdvIntervalMin                = 1000;  // I_MIN
-    static constexpr uint32_t kAdvIntervalNeighborMultiplier = 4000;  // Multiplier for I_MAX per router neighbor
-    static constexpr uint32_t kAdvIntervalMaxLowerBound      = 12000; // Lower bound for I_MAX
-    static constexpr uint32_t kAdvIntervalMaxUpperBound      = 32000; // Upper bound for I_MAX
-    static constexpr uint32_t kReedAdvIntervalMin            = 570000;
-    static constexpr uint32_t kReedAdvIntervalMax            = 630000;
-#if OPENTHREAD_CONFIG_MLE_LONG_ROUTES_ENABLE
-    static constexpr uint32_t kAdvIntervalMaxLogRoutes = 5000;
-#endif
-
-    static constexpr uint32_t kMaxUnicastAdvertisementDelay  = 1000;   // Max random delay for unciast Adv tx
-    static constexpr uint32_t kMaxNeighborAge                = 100000; // Max neighbor age on router (in msec)
-    static constexpr uint32_t kMaxNeighborAgeOnChild         = 150000; // Max neighbor age on FTD child (in msec)
-    static constexpr uint32_t kMaxLeaderToRouterTimeout      = 90000;  // (in msec)
-    static constexpr uint8_t  kMinDowngradeNeighbors         = 7;
-    static constexpr uint8_t  kNetworkIdTimeout              = 120; // (in sec)
-    static constexpr uint8_t  kRouterSelectionJitter         = 120; // (in sec)
-    static constexpr uint8_t  kRouterDowngradeThreshold      = 23;
-    static constexpr uint8_t  kRouterUpgradeThreshold        = 16;
-    static constexpr uint16_t kDiscoveryMaxJitter            = 250; // Max jitter delay Discovery Responses (in msec).
-    static constexpr uint16_t kUnsolicitedDataResponseJitter = 500; // Max delay for unsol Data Response (in msec).
-    static constexpr uint8_t  kLeaderDowngradeExtraDelay     = 10;  // Extra delay to downgrade leader (in sec).
-    static constexpr uint8_t  kDefaultLeaderWeight           = 64;
-    static constexpr uint8_t  kAlternateRloc16Timeout        = 8; // Time to use alternate RLOC16 (in sec).
-
-    // Threshold to accept a router upgrade request with reason
-    // `kBorderRouterRequest` (number of BRs acting as router in
-    // Network Data).
-    static constexpr uint8_t kRouterUpgradeBorderRouterRequestThreshold = 2;
-
-    static constexpr uint8_t kLinkRequestMinMargin    = OPENTHREAD_CONFIG_MLE_LINK_REQUEST_MARGIN_MIN;
-    static constexpr uint8_t kPartitionMergeMinMargin = OPENTHREAD_CONFIG_MLE_PARTITION_MERGE_MARGIN_MIN;
-    static constexpr uint8_t kChildRouterLinks        = OPENTHREAD_CONFIG_MLE_CHILD_ROUTER_LINKS;
-    static constexpr uint8_t kMaxChildIpAddresses     = OPENTHREAD_CONFIG_MLE_IP_ADDRS_PER_CHILD;
-
-    // Constants for gradual router link establishment (on FTD child)
-    struct GradualChildRouterLink
-    {
-        static constexpr uint8_t  kExtraChildRouterLinks   = OPENTHREAD_CONFIG_MLE_EXTRA_CHILD_ROUTER_LINKS_GRADUAL;
-        static constexpr uint32_t kWaitDurationAfterAttach = 300;   // in seconds (5 minutes)
-        static constexpr uint32_t kMinLinkRequestDelay     = 1500;  // in msec
-        static constexpr uint32_t kMaxLinkRequestDelay     = 10000; // in msec
-        static constexpr uint32_t kProbabilityPercentage   = 5;     // in percent
-    };
-
-    static constexpr uint8_t kMinCriticalChildrenCount = 6;
-
-    static constexpr uint16_t kChildSupervisionDefaultIntervalForOlderVersion =
-        OPENTHREAD_CONFIG_CHILD_SUPERVISION_OLDER_VERSION_CHILD_DEFAULT_INTERVAL;
-
-    static constexpr int8_t kParentPriorityHigh        = 1;
-    static constexpr int8_t kParentPriorityMedium      = 0;
-    static constexpr int8_t kParentPriorityLow         = -1;
-    static constexpr int8_t kParentPriorityUnspecified = -2;
-
-    //------------------------------------------------------------------------------------------------------------------
-    // Nested types
-
-    class RouterRoleTransition
-    {
-    public:
-        RouterRoleTransition(void);
-
-        bool    IsPending(void) const { return (mTimeout != 0); }
-        void    StartTimeout(void);
-        void    StopTimeout(void) { mTimeout = 0; }
-        void    IncreaseTimeout(uint8_t aIncrement) { mTimeout += aIncrement; }
-        uint8_t GetTimeout(void) const { return mTimeout; }
-        bool    HandleTimeTick(void);
-        uint8_t GetJitter(void) const { return mJitter; }
-        void    SetJitter(uint8_t aJitter) { mJitter = aJitter; }
-
-    private:
-        uint8_t mTimeout;
-        uint8_t mJitter;
-    };
-
-    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-
-    class RouterRoleRestorer : public InstanceLocator
-    {
-        // Attempts to restore the router or leader role after an MLE
-        // restart(e.g., after a device reboot) by sending multicast
-        // Link Requests.
-
-    public:
-        RouterRoleRestorer(Instance &aInstance);
-
-        bool IsActive(void) const { return mAttempts > 0; }
-        void Start(DeviceRole aPreviousRole);
-        void Stop(void) { mAttempts = 0; }
-        void HandleTimer(void);
-
-        void               GenerateRandomChallenge(void) { mChallenge.GenerateRandom(); }
-        const TxChallenge &GetChallenge(void) const { return mChallenge; }
-
-    private:
-        void SendMulticastLinkRequest(void);
-
-        uint8_t     mAttempts;
-        TxChallenge mChallenge;
-    };
-
-    //------------------------------------------------------------------------------------------------------------------
-    // Methods
-
-    void     SetAlternateRloc16(uint16_t aRloc16);
-    void     ClearAlternateRloc16(void);
-    void     HandleDetachStart(void);
-    void     HandleChildStart(AttachMode aMode);
-    void     HandleSecurityPolicyChanged(void);
-    void     HandleLinkRequest(RxInfo &aRxInfo);
-    void     HandleLinkAccept(RxInfo &aRxInfo);
-    void     HandleLinkAcceptAndRequest(RxInfo &aRxInfo);
-    void     HandleLinkAcceptVariant(RxInfo &aRxInfo, MessageType aMessageType);
-    Error    HandleAdvertisementOnFtd(RxInfo &aRxInfo, uint16_t aSourceAddress, const LeaderData &aLeaderData);
-    void     HandleParentRequest(RxInfo &aRxInfo);
-    void     HandleChildIdRequest(RxInfo &aRxInfo);
-    void     HandleChildUpdateRequestOnParent(RxInfo &aRxInfo);
-    void     HandleChildUpdateResponseOnParent(RxInfo &aRxInfo);
-    void     HandleDataRequest(RxInfo &aRxInfo);
-    void     HandleNetworkDataUpdateRouter(void);
-    void     HandleDiscoveryRequest(RxInfo &aRxInfo);
-    void     EstablishRouterLinkOnFtdChild(Router &aRouter, RxInfo &aRxInfo, uint8_t aLinkMargin);
-    Error    ProcessRouteTlv(const RouteTlv &aRouteTlv, RxInfo &aRxInfo);
-    Error    ReadAndProcessRouteTlvOnFtdChild(RxInfo &aRxInfo, uint8_t aParentId);
-    void     StopAdvertiseTrickleTimer(void);
-    uint32_t DetermineAdvertiseIntervalMax(void) const;
-    Error    SendAddressSolicit(ThreadStatusTlv::Status aStatus);
-    void     SendAddressSolicitResponse(const Coap::Message    &aRequest,
-                                        ThreadStatusTlv::Status aResponseStatus,
-                                        const Router           *aRouter,
-                                        const Ip6::MessageInfo &aMessageInfo);
-    void     SendAddressRelease(void);
-    void     SendMulticastAdvertisement(void);
-    void     SendAdvertisement(const Ip6::Address &aDestination);
-    void     SendLinkRequest(Router *aRouter);
-    Error    SendLinkAccept(const LinkAcceptInfo &aInfo);
-    void     SendParentResponse(const ParentResponseInfo &aInfo);
-    Error    SendChildIdResponse(Child &aChild);
-    Error    SendChildUpdateRequestToChild(Child &aChild);
-    void     SendChildUpdateResponseToChild(Child                  *aChild,
-                                            const Ip6::MessageInfo &aMessageInfo,
-                                            const TlvList          &aTlvList,
-                                            const RxChallenge      &aChallenge);
-    void     SendMulticastDataResponse(void);
-    void     SendDataResponse(const Ip6::Address &aDestination,
-                              const TlvList      &aTlvList,
-                              const Message      *aRequestMessage = nullptr);
-    Error    SendDiscoveryResponse(const Ip6::Address &aDestination, const DiscoveryResponseInfo &aInfo);
-    void     SetStateRouter(uint16_t aRloc16);
-    void     SetStateLeader(uint16_t aRloc16, LeaderStartMode aStartMode);
-    void     SetStateRouterOrLeader(DeviceRole aRole, uint16_t aRloc16, LeaderStartMode aStartMode);
-    void     StopLeader(void);
-    void     SynchronizeChildNetworkData(void);
-    Error    ProcessAddressRegistrationTlv(RxInfo &aRxInfo, Child &aChild);
-    bool     HasNeighborWithGoodLinkQuality(void) const;
-    void     HandlePartitionChange(void);
-    void     SetChildStateToValid(Child &aChild);
-    bool     HasChildren(void);
-    void     RemoveChildren(void);
-    bool     ShouldDowngrade(uint8_t aNeighborId, const RouteTlv &aRouteTlv) const;
-    bool     NeighborHasComparableConnectivity(const RouteTlv &aRouteTlv, uint8_t aNeighborId) const;
-    void     HandleAdvertiseTrickleTimer(void);
-    void     HandleAddressSolicitResponse(Coap::Message *aMessage, const Ip6::MessageInfo *aMessageInfo, Error aResult);
-    void     HandleTimeTick(void);
-
-    template <Uri kUri> void HandleTmf(Coap::Message &aMessage, const Ip6::MessageInfo &aMessageInfo);
-
-#if OPENTHREAD_CONFIG_TMF_PROXY_DUA_ENABLE
-    void SignalDuaAddressEvent(const Child &aChild, const Ip6::Address &aOldDua) const;
-#endif
-
-    static bool IsMessageMleSubType(const Message &aMessage);
-    static bool IsMessageChildUpdateRequest(const Message &aMessage);
-    static void HandleAdvertiseTrickleTimer(TrickleTimer &aTimer);
-    static void HandleAddressSolicitResponse(void                *aContext,
-                                             otMessage           *aMessage,
-                                             const otMessageInfo *aMessageInfo,
-                                             otError              aResult);
-
-    //------------------------------------------------------------------------------------------------------------------
-    // Variables
-
-    bool mRouterEligible : 1;
-    bool mAddressSolicitPending : 1;
-    bool mAddressSolicitRejected : 1;
-#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
-    bool mCcmEnabled : 1;
-    bool mThreadVersionCheckEnabled : 1;
-#endif
-
-    uint8_t mRouterId;
-    uint8_t mPreviousRouterId;
-    uint8_t mNetworkIdTimeout;
-    uint8_t mRouterUpgradeThreshold;
-    uint8_t mRouterDowngradeThreshold;
-    uint8_t mLeaderWeight;
-    uint8_t mPreviousPartitionRouterIdSequence;
-    uint8_t mPreviousPartitionIdTimeout;
-    uint8_t mChildRouterLinks;
-    uint8_t mAlternateRloc16Timeout;
-#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
-    uint8_t mMaxChildIpAddresses;
-#endif
-    int8_t   mParentPriority;
-    uint16_t mNextChildId;
-    uint32_t mPreviousPartitionIdRouter;
-    uint32_t mPreviousPartitionId;
-#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE
-    uint32_t mPreferredLeaderPartitionId;
-#endif
-
-    TrickleTimer               mAdvertiseTrickleTimer;
-    ChildTable                 mChildTable;
-    RouterTable                mRouterTable;
-    RouterRoleRestorer         mRouterRoleRestorer;
-    RouterRoleTransition       mRouterRoleTransition;
-    Ip6::Netif::UnicastAddress mLeaderAloc;
-#if OPENTHREAD_CONFIG_MLE_DEVICE_PROPERTY_LEADER_WEIGHT_ENABLE
-    DeviceProperties mDeviceProperties;
-#endif
-#if OPENTHREAD_CONFIG_MLE_STEERING_DATA_SET_OOB_ENABLE
-    MeshCoP::SteeringData mSteeringData;
-#endif
-    Callback<otThreadDiscoveryRequestCallback> mDiscoveryRequestCallback;
-};
-
-DeclareTmfHandler(MleRouter, kUriAddressSolicit);
-DeclareTmfHandler(MleRouter, kUriAddressRelease);
-
-#endif // OPENTHREAD_FTD
-
-#if OPENTHREAD_MTD
-
-typedef Mle MleRouter;
-
-#endif
-
-} // namespace Mle
-
-/**
- * @}
- */
-
-} // namespace ot
-
-#endif // MLE_ROUTER_HPP_
diff --git a/src/core/thread/mlr_manager.cpp b/src/core/thread/mlr_manager.cpp
index 5027d3711..b3e9f309b 100644
--- a/src/core/thread/mlr_manager.cpp
+++ b/src/core/thread/mlr_manager.cpp
@@ -61,7 +61,7 @@ void MlrManager::HandleNotifierEvents(Events aEvents)
     }
 #endif
 
-    if (aEvents.Contains(kEventThreadRoleChanged) && Get<Mle::MleRouter>().IsChild())
+    if (aEvents.Contains(kEventThreadRoleChanged) && Get<Mle::Mle>().IsChild())
     {
         // Reregistration after re-attach
         UpdateReregistrationDelay(true);
@@ -211,9 +211,9 @@ void MlrManager::UpdateTimeTickerRegistration(void)
 
 void MlrManager::SendMlr(void)
 {
-    Error           error;
-    Mle::MleRouter &mle = Get<Mle::MleRouter>();
-    AddressArray    addresses;
+    Error        error;
+    Mle::Mle    &mle = Get<Mle::Mle>();
+    AddressArray addresses;
 
     VerifyOrExit(!mMlrPending, error = kErrorBusy);
     VerifyOrExit(mle.IsAttached(), error = kErrorInvalidState);
@@ -370,7 +370,7 @@ Error MlrManager::SendMlrMessage(const Ip6::Address   *aAddresses,
     OT_UNUSED_VARIABLE(aTimeout);
 
     Error            error   = kErrorNone;
-    Mle::MleRouter  &mle     = Get<Mle::MleRouter>();
+    Mle::Mle        &mle     = Get<Mle::Mle>();
     Coap::Message   *message = nullptr;
     Tmf::MessageInfo messageInfo(GetInstance());
     Ip6AddressesTlv  addressesTlv;
@@ -607,7 +607,7 @@ void MlrManager::Reregister(void)
 
 void MlrManager::UpdateReregistrationDelay(bool aRereg)
 {
-    Mle::MleRouter &mle = Get<Mle::MleRouter>();
+    Mle::Mle &mle = Get<Mle::Mle>();
 
     bool needSendMlr = (mle.IsFullThreadDevice() || mle.GetParent().IsThreadVersion1p1()) &&
                        Get<BackboneRouter::Leader>().HasPrimary();
diff --git a/src/core/thread/neighbor.cpp b/src/core/thread/neighbor.cpp
index 804ed4cfa..d325eb9d7 100644
--- a/src/core/thread/neighbor.cpp
+++ b/src/core/thread/neighbor.cpp
@@ -42,23 +42,19 @@ void Neighbor::SetState(State aState)
     VerifyOrExit(mState != aState);
     mState = static_cast<uint8_t>(aState);
 
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
     if (mState == kStateValid)
     {
-        mConnectionStart = Uptime::MsecToSec(Get<Uptime>().GetUptime());
+        mConnectionStart = Get<Uptime>().GetUptimeInSeconds();
     }
-#endif
 
 exit:
     return;
 }
 
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
 uint32_t Neighbor::GetConnectionTime(void) const
 {
-    return IsStateValid() ? Uptime::MsecToSec(Get<Uptime>().GetUptime()) - mConnectionStart : 0;
+    return IsStateValid() ? Get<Uptime>().GetUptimeInSeconds() - mConnectionStart : 0;
 }
-#endif
 
 bool Neighbor::AddressMatcher::Matches(const Neighbor &aNeighbor) const
 {
@@ -101,9 +97,7 @@ void Neighbor::Info::SetFrom(const Neighbor &aNeighbor)
     mFullThreadDevice = aNeighbor.IsFullThreadDevice();
     mFullNetworkData  = (aNeighbor.GetNetworkDataType() == NetworkData::kFullSet);
     mVersion          = aNeighbor.GetVersion();
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
-    mConnectionTime = aNeighbor.GetConnectionTime();
-#endif
+    mConnectionTime   = aNeighbor.GetConnectionTime();
 }
 
 void Neighbor::Init(Instance &aInstance)
diff --git a/src/core/thread/neighbor.hpp b/src/core/thread/neighbor.hpp
index ddb4fa5a2..65480acf6 100644
--- a/src/core/thread/neighbor.hpp
+++ b/src/core/thread/neighbor.hpp
@@ -597,14 +597,12 @@ public:
      */
     const Mle::TxChallenge &GetChallenge(void) const { return mValidPending.mPending.mChallenge; }
 
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
     /**
      * Returns the connection time (in seconds) of the neighbor (seconds since entering `kStateValid`).
      *
      * @returns The connection time (in seconds), zero if device is not currently in `kStateValid`.
      */
     uint32_t GetConnectionTime(void) const;
-#endif
 
 #if OPENTHREAD_CONFIG_TIME_SYNC_ENABLE
     /**
@@ -762,9 +760,7 @@ private:
     // and this neighbor is the Subject.
     LinkMetrics::Metrics mEnhAckProbingMetrics;
 #endif
-#if OPENTHREAD_CONFIG_UPTIME_ENABLE
     uint32_t mConnectionStart;
-#endif
 };
 
 DefineCoreType(otNeighborInfo, Neighbor::Info);
diff --git a/src/core/thread/neighbor_table.cpp b/src/core/thread/neighbor_table.cpp
index 97fa75d7d..fed2c695e 100644
--- a/src/core/thread/neighbor_table.cpp
+++ b/src/core/thread/neighbor_table.cpp
@@ -138,7 +138,7 @@ Neighbor *NeighborTable::FindNeighbor(const Ip6::Address &aIp6Address, Neighbor:
 
     if (aIp6Address.IsLinkLocalUnicast())
     {
-        aIp6Address.GetIid().ConvertToMacAddress(macAddress);
+        macAddress.SetExtendedFromIid(aIp6Address.GetIid());
     }
 
     if (Get<Mle::Mle>().IsRoutingLocator(aIp6Address))
diff --git a/src/core/thread/network_data.hpp b/src/core/thread/network_data.hpp
index a507fa5f1..fd1c2988d 100644
--- a/src/core/thread/network_data.hpp
+++ b/src/core/thread/network_data.hpp
@@ -48,7 +48,7 @@
 #include "common/timer.hpp"
 #include "net/udp6.hpp"
 #include "thread/lowpan.hpp"
-#include "thread/mle_router.hpp"
+#include "thread/mle.hpp"
 #include "thread/network_data_tlvs.hpp"
 #include "thread/network_data_types.hpp"
 
diff --git a/src/core/thread/network_data_leader.cpp b/src/core/thread/network_data_leader.cpp
index 9813ac6d1..82ca120e5 100644
--- a/src/core/thread/network_data_leader.cpp
+++ b/src/core/thread/network_data_leader.cpp
@@ -164,7 +164,7 @@ Error Leader::GetContext(const Ip6::Address &aAddress, Lowpan::Context &aContext
 
     aContext.mPrefix.SetLength(0);
 
-    if (Get<Mle::MleRouter>().IsMeshLocalAddress(aAddress))
+    if (Get<Mle::Mle>().IsMeshLocalAddress(aAddress))
     {
         GetContextForMeshLocalPrefix(aContext);
     }
@@ -236,7 +236,7 @@ exit:
 
 void Leader::GetContextForMeshLocalPrefix(Lowpan::Context &aContext) const
 {
-    aContext.mPrefix.Set(Get<Mle::MleRouter>().GetMeshLocalPrefix());
+    aContext.mPrefix.Set(Get<Mle::Mle>().GetMeshLocalPrefix());
     aContext.mContextId    = Mle::kMeshLocalPrefixContextId;
     aContext.mCompressFlag = true;
     aContext.mIsValid      = true;
@@ -247,7 +247,7 @@ bool Leader::IsOnMesh(const Ip6::Address &aAddress) const
     const PrefixTlv *prefixTlv = nullptr;
     bool             isOnMesh  = false;
 
-    VerifyOrExit(!Get<Mle::MleRouter>().IsMeshLocalAddress(aAddress), isOnMesh = true);
+    VerifyOrExit(!Get<Mle::Mle>().IsMeshLocalAddress(aAddress), isOnMesh = true);
 
     while ((prefixTlv = FindNextMatchingPrefixTlv(aAddress, prefixTlv)) != nullptr)
     {
@@ -484,7 +484,7 @@ Error Leader::SetNetworkData(uint8_t            aVersion,
     }
 
 #if OPENTHREAD_FTD
-    if (Get<Mle::MleRouter>().IsLeader())
+    if (Get<Mle::Mle>().IsLeader())
     {
         Get<Leader>().HandleNetworkDataRestoredAfterReset();
     }
diff --git a/src/core/thread/network_data_leader.hpp b/src/core/thread/network_data_leader.hpp
index b73e76edd..7bfde4f86 100644
--- a/src/core/thread/network_data_leader.hpp
+++ b/src/core/thread/network_data_leader.hpp
@@ -44,7 +44,7 @@
 #include "common/numeric_limits.hpp"
 #include "common/timer.hpp"
 #include "net/ip6_address.hpp"
-#include "thread/mle_router.hpp"
+#include "thread/mle.hpp"
 #include "thread/network_data.hpp"
 #include "thread/tmf.hpp"
 
diff --git a/src/core/thread/network_data_leader_ftd.cpp b/src/core/thread/network_data_leader_ftd.cpp
index f3419472e..8ec6031f1 100644
--- a/src/core/thread/network_data_leader_ftd.cpp
+++ b/src/core/thread/network_data_leader_ftd.cpp
@@ -58,7 +58,7 @@ void Leader::Start(Mle::LeaderStartMode aStartMode)
 
 void Leader::IncrementVersion(void)
 {
-    if (Get<Mle::MleRouter>().IsLeader())
+    if (Get<Mle::Mle>().IsLeader())
     {
         IncrementVersions(/* aIncludeStable */ false);
     }
@@ -66,7 +66,7 @@ void Leader::IncrementVersion(void)
 
 void Leader::IncrementVersionAndStableVersion(void)
 {
-    if (Get<Mle::MleRouter>().IsLeader())
+    if (Get<Mle::Mle>().IsLeader())
     {
         IncrementVersions(/* aIncludeStable */ true);
     }
@@ -293,7 +293,7 @@ template <> void Leader::HandleTmf<kUriCommissionerSet>(Coap::Message &aMessage,
     state = MeshCoP::StateTlv::kAccept;
 
 exit:
-    if (Get<Mle::MleRouter>().IsLeader())
+    if (Get<Mle::Mle>().IsLeader())
     {
         SendCommissioningSetResponse(aMessage, aMessageInfo, state);
     }
@@ -664,7 +664,7 @@ void Leader::CheckForNetDataGettingFull(const NetworkData &aNetworkData, uint16_
     // device. If provided, then entries matching old RLOC16 are first
     // removed, before checking if new entries from @p aNetworkData can fit.
 
-    if (!Get<Mle::MleRouter>().IsLeader())
+    if (!Get<Mle::Mle>().IsLeader())
     {
         // Create a clone of the leader's network data, and try to register
         // `aNetworkData` into the copy (as if this device itself is the
@@ -1415,7 +1415,7 @@ void Leader::HandleTimer(void)
     if (mWaitingForNetDataSync)
     {
         LogInfo("Timed out waiting for netdata on restoring leader role after reset");
-        IgnoreError(Get<Mle::MleRouter>().BecomeDetached());
+        IgnoreError(Get<Mle::Mle>().BecomeDetached());
     }
     else
     {
diff --git a/src/core/thread/network_data_local.cpp b/src/core/thread/network_data_local.cpp
index 9520d6b63..d90bbdf9f 100644
--- a/src/core/thread/network_data_local.cpp
+++ b/src/core/thread/network_data_local.cpp
@@ -152,7 +152,7 @@ exit:
 
 void Local::UpdateRloc(PrefixTlv &aPrefixTlv)
 {
-    uint16_t rloc16 = Get<Mle::MleRouter>().GetRloc16();
+    uint16_t rloc16 = Get<Mle::Mle>().GetRloc16();
 
     for (NetworkDataTlv *cur = aPrefixTlv.GetSubTlvs(); cur < aPrefixTlv.GetNext(); cur = cur->GetNext())
     {
@@ -197,7 +197,7 @@ Error Local::AddService(uint32_t           aEnterpriseNumber,
     serviceTlv->SetSubTlvsLength(sizeof(ServerTlv) + aServerData.GetLength());
 
     serverTlv = As<ServerTlv>(serviceTlv->GetSubTlvs());
-    serverTlv->Init(Get<Mle::MleRouter>().GetRloc16(), aServerData);
+    serverTlv->Init(Get<Mle::Mle>().GetRloc16(), aServerData);
 
     // According to Thread spec 1.1.1, section 5.18.6 Service TLV:
     // "The Stable flag is set if any of the included sub-TLVs have their Stable flag set."
@@ -237,7 +237,7 @@ exit:
 
 void Local::UpdateRloc(ServiceTlv &aService)
 {
-    uint16_t rloc16 = Get<Mle::MleRouter>().GetRloc16();
+    uint16_t rloc16 = Get<Mle::Mle>().GetRloc16();
 
     for (NetworkDataTlv *cur = aService.GetSubTlvs(); cur < aService.GetNext(); cur = cur->GetNext())
     {
diff --git a/src/core/thread/network_data_notifier.cpp b/src/core/thread/network_data_notifier.cpp
index f7bf8afef..99c389950 100644
--- a/src/core/thread/network_data_notifier.cpp
+++ b/src/core/thread/network_data_notifier.cpp
@@ -74,7 +74,7 @@ void Notifier::SynchronizeServerData(void)
 {
     Error error = kErrorNotFound;
 
-    VerifyOrExit(Get<Mle::MleRouter>().IsAttached() && !mWaitingForResponse);
+    VerifyOrExit(Get<Mle::Mle>().IsAttached() && !mWaitingForResponse);
 
     VerifyOrExit((mNextDelay == 0) || !mTimer.IsRunning());
 
@@ -101,7 +101,7 @@ exit:
         break;
 #if OPENTHREAD_FTD
     case kErrorInvalidState:
-        mTimer.Start(Time::SecToMsec(Get<Mle::MleRouter>().GetRouterRoleTransitionTimeout() + 1));
+        mTimer.Start(Time::SecToMsec(Get<Mle::Mle>().GetRouterRoleTransitionTimeout() + 1));
         break;
 #endif
     case kErrorNotFound:
@@ -125,7 +125,7 @@ Error Notifier::RemoveStaleChildEntries(void)
     Error error = kErrorNotFound;
     Rlocs rlocs;
 
-    VerifyOrExit(Get<Mle::MleRouter>().IsRouterOrLeader());
+    VerifyOrExit(Get<Mle::Mle>().IsRouterOrLeader());
 
     Get<Leader>().FindRlocs(kAnyBrOrServer, kAnyRole, rlocs);
 
@@ -148,13 +148,13 @@ exit:
 Error Notifier::UpdateInconsistentData(void)
 {
     Error    error      = kErrorNone;
-    uint16_t deviceRloc = Get<Mle::MleRouter>().GetRloc16();
+    uint16_t deviceRloc = Get<Mle::Mle>().GetRloc16();
 
 #if OPENTHREAD_FTD
     // Don't send this Server Data Notification if the device is going
     // to upgrade to Router.
 
-    if (Get<Mle::MleRouter>().IsExpectedToBecomeRouterSoon())
+    if (Get<Mle::Mle>().IsExpectedToBecomeRouterSoon())
     {
         ExitNow(error = kErrorInvalidState);
     }
@@ -294,12 +294,12 @@ bool Notifier::IsEligibleForRouterRoleUpgradeAsBorderRouter(void) const
     uint16_t rloc16     = Get<Mle::Mle>().GetRloc16();
     uint8_t  activeRouterCount;
 
-    VerifyOrExit(Get<Mle::MleRouter>().IsRouterEligible());
+    VerifyOrExit(Get<Mle::Mle>().IsRouterEligible());
 
     // RouterUpgradeThreshold can be explicitly set to zero in some of
     // cert tests to disallow device to become router.
 
-    VerifyOrExit(Get<Mle::MleRouter>().GetRouterUpgradeThreshold() != 0);
+    VerifyOrExit(Get<Mle::Mle>().GetRouterUpgradeThreshold() != 0);
 
     // Check that we are a border router providing IP connectivity and already
     // in the leader's network data and therefore eligible to request router
@@ -309,7 +309,7 @@ bool Notifier::IsEligibleForRouterRoleUpgradeAsBorderRouter(void) const
                  Get<Leader>().ContainsBorderRouterWithRloc(rloc16));
 
     activeRouterCount = Get<RouterTable>().GetActiveRouterCount();
-    VerifyOrExit((activeRouterCount >= Get<Mle::MleRouter>().GetRouterUpgradeThreshold()) &&
+    VerifyOrExit((activeRouterCount >= Get<Mle::Mle>().GetRouterUpgradeThreshold()) &&
                  (activeRouterCount < Mle::kMaxRouters));
 
     VerifyOrExit(Get<Leader>().CountBorderRouters(kRouterRoleOnly) < Mle::kRouterUpgradeBorderRouterRequestThreshold);
@@ -333,7 +333,7 @@ void Notifier::ScheduleRouterRoleUpgradeIfEligible(void)
 
     VerifyOrExit(!mDidRequestRouterRoleUpgrade);
 
-    VerifyOrExit(Get<Mle::MleRouter>().IsChild());
+    VerifyOrExit(Get<Mle::Mle>().IsChild());
     VerifyOrExit(IsEligibleForRouterRoleUpgradeAsBorderRouter() && (mRouterRoleUpgradeTimeout == 0));
 
     mRouterRoleUpgradeTimeout = Random::NonCrypto::GetUint8InRange(1, kRouterRoleUpgradeMaxTimeout + 1);
@@ -357,11 +357,11 @@ void Notifier::HandleTimeTick(void)
         // upgrade (note that state can change since the last time we
         // checked and registered to receive time ticks).
 
-        if (Get<Mle::MleRouter>().IsChild() && IsEligibleForRouterRoleUpgradeAsBorderRouter())
+        if (Get<Mle::Mle>().IsChild() && IsEligibleForRouterRoleUpgradeAsBorderRouter())
         {
             LogInfo("Requesting router role as BR");
             mDidRequestRouterRoleUpgrade = true;
-            IgnoreError(Get<Mle::MleRouter>().BecomeRouter(ThreadStatusTlv::kBorderRouterRequest));
+            IgnoreError(Get<Mle::Mle>().BecomeRouter(ThreadStatusTlv::kBorderRouterRequest));
         }
     }
 exit:
diff --git a/src/core/thread/network_data_service.cpp b/src/core/thread/network_data_service.cpp
index dc706ceab..ead0b05b7 100644
--- a/src/core/thread/network_data_service.cpp
+++ b/src/core/thread/network_data_service.cpp
@@ -143,7 +143,7 @@ bool Manager::IsBackboneRouterPreferredTo(const ServerTlv     &aServerTlv,
                                           const BbrServerData &aOtherServerData) const
 {
     bool     isPreferred;
-    uint16_t leaderRloc16 = Get<Mle::MleRouter>().GetLeaderRloc16();
+    uint16_t leaderRloc16 = Get<Mle::Mle>().GetLeaderRloc16();
 
     VerifyOrExit(aServerTlv.GetServer16() != leaderRloc16, isPreferred = true);
     VerifyOrExit(aOtherServerTlv.GetServer16() != leaderRloc16, isPreferred = false);
diff --git a/src/core/thread/network_data_types.cpp b/src/core/thread/network_data_types.cpp
index 7607e0b2e..b1176b0a0 100644
--- a/src/core/thread/network_data_types.cpp
+++ b/src/core/thread/network_data_types.cpp
@@ -206,7 +206,7 @@ void ExternalRouteConfig::SetFrom(Instance            &aInstance,
     SetFromTlvFlags(aHasRouteEntry.GetFlags());
     mStable              = aHasRouteTlv.IsStable();
     mRloc16              = aHasRouteEntry.GetRloc();
-    mNextHopIsThisDevice = (aHasRouteEntry.GetRloc() == aInstance.Get<Mle::MleRouter>().GetRloc16());
+    mNextHopIsThisDevice = (aHasRouteEntry.GetRloc() == aInstance.Get<Mle::Mle>().GetRloc16());
 }
 
 void ExternalRouteConfig::SetFromTlvFlags(uint8_t aFlags)
@@ -258,6 +258,7 @@ void LowpanContextInfo::SetFrom(const PrefixTlv &aPrefixTlv, const ContextTlv &a
 {
     mContextId    = aContextTlv.GetContextId();
     mCompressFlag = aContextTlv.IsCompress();
+    mStable       = aContextTlv.IsStable();
     aPrefixTlv.CopyPrefixTo(GetPrefix());
     GetPrefix().SetLength(aContextTlv.GetContextLength());
 }
diff --git a/src/core/thread/network_diagnostic.cpp b/src/core/thread/network_diagnostic.cpp
index 7f879c4bd..dcd291371 100644
--- a/src/core/thread/network_diagnostic.cpp
+++ b/src/core/thread/network_diagnostic.cpp
@@ -51,6 +51,7 @@ const char Server::kVendorAppUrl[]    = OPENTHREAD_CONFIG_NET_DIAG_VENDOR_APP_UR
 
 Server::Server(Instance &aInstance)
     : InstanceLocator(aInstance)
+    , mNonPreferredChannels(0)
 {
     static_assert(sizeof(kVendorName) <= sizeof(VendorNameTlv::StringType), "VENDOR_NAME is too long");
     static_assert(sizeof(kVendorModel) <= sizeof(VendorModelTlv::StringType), "VENDOR_MODEL is too long");
@@ -98,7 +99,7 @@ void Server::PrepareMessageInfoForDest(const Ip6::Address &aDestination, Tmf::Me
 
     if (aDestination.IsLinkLocalUnicastOrMulticast())
     {
-        aMessageInfo.SetSockAddr(Get<Mle::MleRouter>().GetLinkLocalAddress());
+        aMessageInfo.SetSockAddr(Get<Mle::Mle>().GetLinkLocalAddress());
     }
     else
     {
@@ -151,7 +152,7 @@ Error Server::AppendChildTable(Message &aMessage)
     Error    error = kErrorNone;
     uint16_t count;
 
-    VerifyOrExit(Get<Mle::MleRouter>().IsRouterOrLeader());
+    VerifyOrExit(Get<Mle::Mle>().IsRouterOrLeader());
 
     count = Min(Get<ChildTable>().GetNumChildren(Child::kInStateValid), kMaxChildEntries);
 
@@ -196,6 +197,112 @@ Error Server::AppendChildTable(Message &aMessage)
 exit:
     return error;
 }
+
+Error Server::AppendEnhancedRoute(Message &aMessage)
+{
+    Error                 error = kErrorNone;
+    Tlv                   tlv;
+    Mle::RouterIdSet      routerIdSet;
+    EnhancedRouteTlvEntry entry;
+
+    VerifyOrExit(Get<Mle::Mle>().IsRouterOrLeader());
+
+    Get<RouterTable>().GetRouterIdSet(routerIdSet);
+
+    tlv.SetType(Tlv::kEnhancedRoute);
+    tlv.SetLength(sizeof(Mle::RouterIdSet) + routerIdSet.GetNumberOfAllocatedIds() * sizeof(entry));
+
+    SuccessOrExit(error = aMessage.Append(tlv));
+    SuccessOrExit(error = aMessage.Append(routerIdSet));
+
+    for (uint8_t routerId = 0; routerId <= Mle::kMaxRouterId; routerId++)
+    {
+        if (!routerIdSet.Contains(routerId))
+        {
+            continue;
+        }
+
+        if (Get<Mle::Mle>().MatchesRouterId(routerId))
+        {
+            entry.InitAsSelf();
+        }
+        else
+        {
+            entry.InitFrom(*Get<RouterTable>().FindRouterById(routerId));
+        }
+
+        SuccessOrExit(error = aMessage.Append(entry));
+    }
+
+exit:
+    return error;
+}
+
+#if OPENTHREAD_CONFIG_BLE_TCAT_ENABLE
+Error Server::AppendChildTableAsChildTlvs(Message &aMessage)
+{
+    Error    error = kErrorNone;
+    ChildTlv childTlv;
+
+    for (Child &child : Get<ChildTable>().Iterate(Child::kInStateValid))
+    {
+        childTlv.InitFrom(child);
+
+        SuccessOrExit(error = childTlv.AppendTo(aMessage));
+    }
+
+    // Add empty TLV to indicate end of the list
+
+    childTlv.InitAsEmpty();
+    SuccessOrExit(error = childTlv.AppendTo(aMessage));
+
+exit:
+    return error;
+}
+
+Error Server::AppendRouterNeighborTlvs(Message &aMessage)
+{
+    Error             error = kErrorNone;
+    RouterNeighborTlv neighborTlv;
+
+    for (Router &router : Get<RouterTable>())
+    {
+        if (router.IsStateValid())
+        {
+            neighborTlv.InitFrom(router);
+            SuccessOrExit(error = neighborTlv.AppendTo(aMessage));
+        }
+    }
+
+    // Add empty TLV to indicate end of the list
+
+    neighborTlv.InitAsEmpty();
+    SuccessOrExit(error = neighborTlv.AppendTo(aMessage));
+
+exit:
+    return error;
+}
+
+Error Server::AppendChildTableIp6AddressList(Message &aMessage)
+{
+    Error error = kErrorNone;
+    Tlv   tlv;
+
+    for (const Child &child : Get<ChildTable>().Iterate(Child::kInStateValid))
+    {
+        SuccessOrExit(error = AppendChildIp6AddressListTlv(aMessage, child));
+    }
+
+    // Add empty TLV to indicate end of the list
+
+    tlv.SetType(Tlv::kChildIp6AddressList);
+    tlv.SetLength(0);
+    SuccessOrExit(error = aMessage.Append(tlv));
+
+exit:
+    return error;
+}
+#endif // OPENTHREAD_CONFIG_BLE_TCAT_ENABLE
 #endif // OPENTHREAD_FTD
 
 Error Server::AppendMacCounters(Message &aMessage)
@@ -240,6 +347,48 @@ exit:
     return error;
 }
 
+#if OPENTHREAD_CONFIG_BLE_TCAT_ENABLE
+Error Server::AppendRequestedTlvsForTcat(const Message &aRequest, Message &aResponse, OffsetRange &aOffsetRange)
+{
+    Error error = kErrorNone;
+
+    while (!aOffsetRange.IsEmpty())
+    {
+        uint8_t tlvType;
+
+        SuccessOrExit(error = aRequest.Read(aOffsetRange, tlvType));
+        aOffsetRange.AdvanceOffset(sizeof(uint8_t));
+
+#if OPENTHREAD_FTD
+        switch (tlvType)
+        {
+        case ChildTlv::kType:
+            SuccessOrExit(error = AppendChildTableAsChildTlvs(aResponse));
+            break;
+
+        case ChildIp6AddressListTlv::kType:
+            SuccessOrExit(error = AppendChildTableIp6AddressList(aResponse));
+            break;
+
+        case RouterNeighborTlv::kType:
+            SuccessOrExit(error = AppendRouterNeighborTlvs(aResponse));
+            break;
+
+        default:
+            SuccessOrExit(error = AppendDiagTlv(tlvType, aResponse));
+            break;
+        }
+
+#elif OPENTHREAD_MTD
+        SuccessOrExit(error = AppendDiagTlv(tlvType, aResponse));
+#endif
+    }
+
+exit:
+    return error;
+}
+#endif // OPENTHREAD_CONFIG_BLE_TCAT_ENABLE
+
 Error Server::AppendDiagTlv(uint8_t aTlvType, Message &aMessage)
 {
     Error error = kErrorNone;
@@ -251,11 +400,11 @@ Error Server::AppendDiagTlv(uint8_t aTlvType, Message &aMessage)
         break;
 
     case Tlv::kAddress16:
-        error = Tlv::Append<Address16Tlv>(aMessage, Get<Mle::MleRouter>().GetRloc16());
+        error = Tlv::Append<Address16Tlv>(aMessage, Get<Mle::Mle>().GetRloc16());
         break;
 
     case Tlv::kMode:
-        error = Tlv::Append<ModeTlv>(aMessage, Get<Mle::MleRouter>().GetDeviceMode().Get());
+        error = Tlv::Append<ModeTlv>(aMessage, Get<Mle::Mle>().GetDeviceMode().Get());
         break;
 
     case Tlv::kEui64:
@@ -272,8 +421,8 @@ Error Server::AppendDiagTlv(uint8_t aTlvType, Message &aMessage)
         break;
 
     case Tlv::kTimeout:
-        VerifyOrExit(!Get<Mle::MleRouter>().IsRxOnWhenIdle());
-        error = Tlv::Append<TimeoutTlv>(aMessage, Get<Mle::MleRouter>().GetTimeout());
+        VerifyOrExit(!Get<Mle::Mle>().IsRxOnWhenIdle());
+        error = Tlv::Append<TimeoutTlv>(aMessage, Get<Mle::Mle>().GetTimeout());
         break;
 
     case Tlv::kLeaderData:
@@ -281,7 +430,7 @@ Error Server::AppendDiagTlv(uint8_t aTlvType, Message &aMessage)
         LeaderDataTlv tlv;
 
         tlv.Init();
-        tlv.Set(Get<Mle::MleRouter>().GetLeaderData());
+        tlv.Set(Get<Mle::Mle>().GetLeaderData());
         error = tlv.AppendTo(aMessage);
         break;
     }
@@ -346,6 +495,15 @@ Error Server::AppendDiagTlv(uint8_t aTlvType, Message &aMessage)
         break;
     }
 
+    case Tlv::kNonPreferredChannels:
+    {
+        MeshCoP::ChannelMaskTlv::Value value;
+
+        MeshCoP::ChannelMaskTlv::PrepareValue(value, mNonPreferredChannels, /* aIncludeZeroPageMasks */ true);
+        error = Tlv::AppendTlv(aMessage, Tlv::kNonPreferredChannels, value.mData, value.mLength);
+        break;
+    }
+
 #if OPENTHREAD_FTD
 
     case Tlv::kConnectivity:
@@ -353,7 +511,7 @@ Error Server::AppendDiagTlv(uint8_t aTlvType, Message &aMessage)
         ConnectivityTlv tlv;
 
         tlv.Init();
-        Get<Mle::MleRouter>().FillConnectivityTlv(tlv);
+        Get<Mle::Mle>().FillConnectivityTlv(tlv);
         error = tlv.AppendTo(aMessage);
         break;
     }
@@ -368,6 +526,10 @@ Error Server::AppendDiagTlv(uint8_t aTlvType, Message &aMessage)
         break;
     }
 
+    case Tlv::kEnhancedRoute:
+        error = AppendEnhancedRoute(aMessage);
+        break;
+
     case Tlv::kChildTable:
         error = AppendChildTable(aMessage);
         break;
@@ -376,7 +538,7 @@ Error Server::AppendDiagTlv(uint8_t aTlvType, Message &aMessage)
     {
         uint32_t maxTimeout;
 
-        SuccessOrExit(Get<Mle::MleRouter>().GetMaxChildTimeout(maxTimeout));
+        SuccessOrExit(Get<Mle::Mle>().GetMaxChildTimeout(maxTimeout));
         error = Tlv::Append<MaxChildTimeoutTlv>(aMessage, maxTimeout);
         break;
     }
@@ -731,7 +893,7 @@ exit:
     return error;
 }
 
-Error Server::AppendChildIp6AddressListTlv(Coap::Message &aAnswer, const Child &aChild)
+Error Server::AppendChildIp6AddressListTlv(Message &aAnswer, const Child &aChild)
 {
     Error                       error      = kErrorNone;
     uint16_t                    numIp6Addr = aChild.GetIp6Addresses().GetLength();
@@ -839,6 +1001,10 @@ template <> void Server::HandleTmf<kUriDiagnosticReset>(Coap::Message &aMessage,
             Get<Mle::Mle>().ResetCounters();
             break;
 
+        case Tlv::kNonPreferredChannels:
+            mNonPreferredChannelsResetCallback.InvokeIfSet();
+            break;
+
         default:
             break;
         }
@@ -1000,6 +1166,51 @@ static void ParseRoute(const RouteTlv &aRouteTlv, otNetworkDiagRoute &aNetworkDi
     aNetworkDiagRoute.mIdSequence = aRouteTlv.GetRouterIdSequence();
 }
 
+static Error ParseEnhancedRoute(const Message &aMessage, uint16_t aOffset, otNetworkDiagEnhRoute &aNetworkDiagEnhRoute)
+{
+    Error            error;
+    OffsetRange      offsetRange;
+    Tlv              tlv;
+    Mle::RouterIdSet routerIdSet;
+    uint8_t          index;
+
+    SuccessOrExit(error = aMessage.Read(aOffset, tlv));
+
+    VerifyOrExit(!tlv.IsExtended(), error = kErrorParse);
+    VerifyOrExit(tlv.GetType() == Tlv::kEnhancedRoute, error = kErrorParse);
+
+    aOffset += sizeof(tlv);
+    offsetRange.Init(aOffset, tlv.GetLength());
+
+    SuccessOrExit(error = aMessage.Read(offsetRange, routerIdSet));
+    offsetRange.AdvanceOffset(sizeof(routerIdSet));
+
+    index = 0;
+
+    for (uint8_t routerId = 0; routerId <= Mle::kMaxRouterId; routerId++)
+    {
+        EnhancedRouteTlvEntry entry;
+
+        if (!routerIdSet.Contains(routerId))
+        {
+            continue;
+        }
+
+        SuccessOrExit(error = aMessage.Read(offsetRange, entry));
+        offsetRange.AdvanceOffset(sizeof(entry));
+
+        aNetworkDiagEnhRoute.mRouteData[index].mRouterId = routerId;
+        entry.Parse(aNetworkDiagEnhRoute.mRouteData[index]);
+
+        index++;
+    }
+
+    aNetworkDiagEnhRoute.mRouteCount = index;
+
+exit:
+    return error;
+}
+
 static inline void ParseMacCounters(const MacCountersTlv &aMacCountersTlv, otNetworkDiagMacCounters &aMacCounters)
 {
     aMacCounters.mIfInUnknownProtos  = aMacCountersTlv.GetIfInUnknownProtos();
@@ -1020,9 +1231,8 @@ Error Client::GetNextDiagTlv(const Coap::Message &aMessage, Iterator &aIterator,
 
     while (offset < aMessage.GetLength())
     {
-        bool     skipTlv = false;
-        uint16_t valueOffset;
-        uint16_t tlvLength;
+        bool        skipTlv = false;
+        OffsetRange valueOffsetRange;
         union
         {
             Tlv         tlv;
@@ -1034,13 +1244,11 @@ Error Client::GetNextDiagTlv(const Coap::Message &aMessage, Iterator &aIterator,
         if (tlv.IsExtended())
         {
             SuccessOrExit(error = aMessage.Read(offset, extTlv));
-            valueOffset = offset + sizeof(ExtendedTlv);
-            tlvLength   = extTlv.GetLength();
+            valueOffsetRange.Init(offset + sizeof(ExtendedTlv), extTlv.GetLength());
         }
         else
         {
-            valueOffset = offset + sizeof(Tlv);
-            tlvLength   = tlv.GetLength();
+            valueOffsetRange.Init(offset + sizeof(Tlv), tlv.GetLength());
         }
 
         VerifyOrExit(offset + tlv.GetSize() <= aMessage.GetLength(), error = kErrorParse);
@@ -1092,6 +1300,10 @@ Error Client::GetNextDiagTlv(const Coap::Message &aMessage, Iterator &aIterator,
             break;
         }
 
+        case Tlv::kEnhancedRoute:
+            SuccessOrExit(error = ParseEnhancedRoute(aMessage, offset, aTlvInfo.mData.mEnhRoute));
+            break;
+
         case Tlv::kLeaderData:
         {
             LeaderDataTlv leaderDataTlv;
@@ -1107,9 +1319,9 @@ Error Client::GetNextDiagTlv(const Coap::Message &aMessage, Iterator &aIterator,
             static_assert(sizeof(aTlvInfo.mData.mNetworkData.m8) >= NetworkData::NetworkData::kMaxSize,
                           "NetworkData array in `otNetworkDiagTlv` is too small");
 
-            VerifyOrExit(tlvLength <= NetworkData::NetworkData::kMaxSize, error = kErrorParse);
-            aTlvInfo.mData.mNetworkData.mCount = static_cast<uint8_t>(tlvLength);
-            aMessage.ReadBytes(valueOffset, aTlvInfo.mData.mNetworkData.m8, tlvLength);
+            VerifyOrExit(valueOffsetRange.GetLength() <= NetworkData::NetworkData::kMaxSize, error = kErrorParse);
+            aTlvInfo.mData.mNetworkData.mCount = static_cast<uint8_t>(valueOffsetRange.GetLength());
+            aMessage.ReadBytes(valueOffsetRange, aTlvInfo.mData.mNetworkData.m8);
             break;
 
         case Tlv::kIp6AddressList:
@@ -1118,7 +1330,7 @@ Error Client::GetNextDiagTlv(const Coap::Message &aMessage, Iterator &aIterator,
             Ip6::Address *addrEntry      = AsCoreTypePtr(&aTlvInfo.mData.mIp6AddrList.mList[0]);
             uint8_t      &addrCount      = aTlvInfo.mData.mIp6AddrList.mCount;
 
-            VerifyOrExit((tlvLength % Ip6::Address::kSize) == 0, error = kErrorParse);
+            VerifyOrExit((valueOffsetRange.GetLength() % Ip6::Address::kSize) == 0, error = kErrorParse);
 
             // `TlvInfo` has a fixed array for IPv6 addresses. If there
             // are more addresses in the message, we read and return as
@@ -1126,13 +1338,12 @@ Error Client::GetNextDiagTlv(const Coap::Message &aMessage, Iterator &aIterator,
 
             addrCount = 0;
 
-            while ((tlvLength > 0) && (addrCount < addrListLength))
+            while (!valueOffsetRange.IsEmpty() && (addrCount < addrListLength))
             {
-                SuccessOrExit(error = aMessage.Read(valueOffset, *addrEntry));
+                SuccessOrExit(error = aMessage.Read(valueOffsetRange, *addrEntry));
                 addrCount++;
                 addrEntry++;
-                valueOffset += Ip6::Address::kSize;
-                tlvLength -= Ip6::Address::kSize;
+                valueOffsetRange.AdvanceOffset(Ip6::Address::kSize);
             }
 
             break;
@@ -1172,7 +1383,7 @@ Error Client::GetNextDiagTlv(const Coap::Message &aMessage, Iterator &aIterator,
             ChildInfo *childInfo       = &aTlvInfo.mData.mChildTable.mTable[0];
             uint8_t   &childCount      = aTlvInfo.mData.mChildTable.mCount;
 
-            VerifyOrExit((tlvLength % sizeof(ChildTableEntry)) == 0, error = kErrorParse);
+            VerifyOrExit((valueOffsetRange.GetLength() % sizeof(ChildTableEntry)) == 0, error = kErrorParse);
 
             // `TlvInfo` has a fixed array Child Table entries. If there
             // are more entries in the message, we read and return as
@@ -1180,11 +1391,11 @@ Error Client::GetNextDiagTlv(const Coap::Message &aMessage, Iterator &aIterator,
 
             childCount = 0;
 
-            while ((tlvLength > 0) && (childCount < childInfoLength))
+            while (!valueOffsetRange.IsEmpty() && (childCount < childInfoLength))
             {
                 ChildTableEntry entry;
 
-                SuccessOrExit(error = aMessage.Read(valueOffset, entry));
+                SuccessOrExit(error = aMessage.Read(valueOffsetRange, entry));
 
                 childInfo->mTimeout     = entry.GetTimeout();
                 childInfo->mLinkQuality = entry.GetLinkQuality();
@@ -1193,17 +1404,17 @@ Error Client::GetNextDiagTlv(const Coap::Message &aMessage, Iterator &aIterator,
 
                 childCount++;
                 childInfo++;
-                tlvLength -= sizeof(ChildTableEntry);
-                valueOffset += sizeof(ChildTableEntry);
+                valueOffsetRange.AdvanceOffset(sizeof(ChildTableEntry));
             }
 
             break;
         }
 
         case Tlv::kChannelPages:
-            aTlvInfo.mData.mChannelPages.mCount =
-                static_cast<uint8_t>(Min(tlvLength, GetArrayLength(aTlvInfo.mData.mChannelPages.m8)));
-            aMessage.ReadBytes(valueOffset, aTlvInfo.mData.mChannelPages.m8, aTlvInfo.mData.mChannelPages.mCount);
+            aTlvInfo.mData.mChannelPages.mCount = static_cast<uint8_t>(
+                Min(valueOffsetRange.GetLength(), GetArrayLength(aTlvInfo.mData.mChannelPages.m8)));
+            aMessage.ReadBytes(valueOffsetRange.GetOffset(), aTlvInfo.mData.mChannelPages.m8,
+                               aTlvInfo.mData.mChannelPages.mCount);
             break;
 
         case Tlv::kMaxChildTimeout:
@@ -1239,6 +1450,11 @@ Error Client::GetNextDiagTlv(const Coap::Message &aMessage, Iterator &aIterator,
                               Tlv::Read<ThreadStackVersionTlv>(aMessage, offset, aTlvInfo.mData.mThreadStackVersion));
             break;
 
+        case Tlv::kNonPreferredChannels:
+            SuccessOrExit(error = MeshCoP::ChannelMaskTlv::ParseValue(aMessage, valueOffsetRange,
+                                                                      aTlvInfo.mData.mNonPreferredChannels));
+            break;
+
         default:
             // Skip unrecognized TLVs.
             skipTlv = true;
diff --git a/src/core/thread/network_diagnostic.hpp b/src/core/thread/network_diagnostic.hpp
index 23ed352f6..887150b0f 100644
--- a/src/core/thread/network_diagnostic.hpp
+++ b/src/core/thread/network_diagnostic.hpp
@@ -52,6 +52,10 @@ namespace Utils {
 class MeshDiag;
 }
 
+namespace MeshCoP {
+class TcatAgent;
+}
+
 namespace NetworkDiagnostic {
 
 /**
@@ -71,9 +75,15 @@ class Client;
 class Server : public InstanceLocator, private NonCopyable
 {
     friend class Tmf::Agent;
+    friend class MeshCoP::TcatAgent;
     friend class Client;
 
 public:
+    /**
+     * Callback function pointer to notify a reset request for `kNonPreferredChannels` TLV value.
+     */
+    typedef otThreadNonPreferredChannelsResetCallback NonPreferredChannelsResetCallback;
+
     /**
      * Initializes the Server.
      *
@@ -81,6 +91,31 @@ public:
      */
     explicit Server(Instance &aInstance);
 
+    /**
+     * Sets the non-preferred channels value for `kNonPreferredChannels` TLV.
+     *
+     * @param[in] aChannelMask   A channel mask for non-preferred channels.
+     */
+    void SetNonPreferredChannels(uint32_t aChannelMask) { mNonPreferredChannels = aChannelMask; }
+
+    /**
+     * Gets the non-preferred channel mask value for `kNonPreferredChannels` TLV.
+     *
+     * @returns The non-preferred channels as a channel mask.
+     */
+    uint32_t GetNonPreferredChannels(void) const { return mNonPreferredChannels; }
+
+    /**
+     * Sets the callback to notify when a Diagnostic Reset request is received for `kNonPreferredChannels` TLV value.
+     *
+     * @param[in] aCallback   The callback function pointer.
+     * @param[in] aContext    An arbitrary context used with @p aCallback.
+     */
+    void SetNonPreferredChannelsResetCallback(NonPreferredChannelsResetCallback aCallback, void *aContext)
+    {
+        mNonPreferredChannelsResetCallback.Set(aCallback, aContext);
+    }
+
 #if OPENTHREAD_CONFIG_NET_DIAG_VENDOR_INFO_SET_API_ENABLE
     /**
      * Returns the vendor name string.
@@ -191,6 +226,10 @@ private:
     Error AppendRequestedTlvs(const Message &aRequest, Message &aResponse);
     void  PrepareMessageInfoForDest(const Ip6::Address &aDestination, Tmf::MessageInfo &aMessageInfo) const;
 
+#if OPENTHREAD_CONFIG_BLE_TCAT_ENABLE
+    Error AppendRequestedTlvsForTcat(const Message &aRequest, Message &aResponse, OffsetRange &aOffsetRange);
+#endif
+
 #if OPENTHREAD_MTD
     void SendAnswer(const Ip6::Address &aDestination, const Message &aRequest);
 #elif OPENTHREAD_FTD
@@ -204,7 +243,14 @@ private:
     Error       AppendChildTableAsChildTlvs(Coap::Message *&aAnswer, AnswerInfo &aInfo);
     Error       AppendRouterNeighborTlvs(Coap::Message *&aAnswer, AnswerInfo &aInfo);
     Error       AppendChildTableIp6AddressList(Coap::Message *&aAnswer, AnswerInfo &aInfo);
-    Error       AppendChildIp6AddressListTlv(Coap::Message &aAnswer, const Child &aChild);
+    Error       AppendChildIp6AddressListTlv(Message &aAnswer, const Child &aChild);
+    Error       AppendEnhancedRoute(Message &aMessage);
+
+#if OPENTHREAD_CONFIG_BLE_TCAT_ENABLE
+    Error       AppendChildTableAsChildTlvs(Message &aMessage);
+    Error       AppendRouterNeighborTlvs(Message &aMessage);
+    Error       AppendChildTableIp6AddressList(Message &aMessage);
+#endif
 
     static void HandleAnswerResponse(void                *aContext,
                                      otMessage           *aMessage,
@@ -228,6 +274,8 @@ private:
 #if OPENTHREAD_FTD
     Coap::MessageQueue mAnswerQueue;
 #endif
+    uint32_t                                    mNonPreferredChannels;
+    Callback<NonPreferredChannelsResetCallback> mNonPreferredChannelsResetCallback;
 };
 
 DeclareTmfHandler(Server, kUriDiagnosticGetRequest);
diff --git a/src/core/thread/network_diagnostic_tlvs.cpp b/src/core/thread/network_diagnostic_tlvs.cpp
index 9d4fc6651..e4141547f 100644
--- a/src/core/thread/network_diagnostic_tlvs.cpp
+++ b/src/core/thread/network_diagnostic_tlvs.cpp
@@ -38,6 +38,35 @@
 namespace ot {
 namespace NetworkDiagnostic {
 
+void EnhancedRouteTlvEntry::InitFrom(const Router &aRouter)
+{
+    uint16_t data = 0;
+
+    if (aRouter.IsStateValid())
+    {
+        data |= kLinkFlag;
+        data |= (static_cast<uint16_t>(aRouter.GetLinkQualityOut()) << kLinkQualityOutOffset);
+        data |= (static_cast<uint16_t>(aRouter.GetLinkQualityIn()) << kLinkQualityInOffset);
+    }
+
+    data |= ((static_cast<uint16_t>(aRouter.GetNextHop()) & kNextHopMask) << kNextHopOffset);
+    data |= ((static_cast<uint16_t>(aRouter.GetCost()) & kCostMask) << kNextHopCostOffset);
+
+    SetRouteData(data);
+}
+
+void EnhancedRouteTlvEntry::Parse(ParseInfo &aParseInfo) const
+{
+    uint16_t data = GetRouteData();
+
+    aParseInfo.mIsSelf         = (data & kSelfFlag);
+    aParseInfo.mHasLink        = (data & kLinkFlag);
+    aParseInfo.mLinkQualityOut = static_cast<uint8_t>((data >> kLinkQualityOutOffset) & kLinkQualityMask);
+    aParseInfo.mLinkQualityIn  = static_cast<uint8_t>((data >> kLinkQualityInOffset) & kLinkQualityMask);
+    aParseInfo.mNextHop        = static_cast<uint8_t>((data >> kNextHopOffset) & kNextHopMask);
+    aParseInfo.mNextHopCost    = static_cast<uint8_t>((data >> kNextHopCostOffset) & kCostMask);
+}
+
 #if OPENTHREAD_FTD
 
 void ChildTlv::InitFrom(const Child &aChild)
diff --git a/src/core/thread/network_diagnostic_tlvs.hpp b/src/core/thread/network_diagnostic_tlvs.hpp
index 4776c798d..00376f2ee 100644
--- a/src/core/thread/network_diagnostic_tlvs.hpp
+++ b/src/core/thread/network_diagnostic_tlvs.hpp
@@ -66,35 +66,37 @@ public:
      */
     enum Type : uint8_t
     {
-        kExtMacAddress       = OT_NETWORK_DIAGNOSTIC_TLV_EXT_ADDRESS,
-        kAddress16           = OT_NETWORK_DIAGNOSTIC_TLV_SHORT_ADDRESS,
-        kMode                = OT_NETWORK_DIAGNOSTIC_TLV_MODE,
-        kTimeout             = OT_NETWORK_DIAGNOSTIC_TLV_TIMEOUT,
-        kConnectivity        = OT_NETWORK_DIAGNOSTIC_TLV_CONNECTIVITY,
-        kRoute               = OT_NETWORK_DIAGNOSTIC_TLV_ROUTE,
-        kLeaderData          = OT_NETWORK_DIAGNOSTIC_TLV_LEADER_DATA,
-        kNetworkData         = OT_NETWORK_DIAGNOSTIC_TLV_NETWORK_DATA,
-        kIp6AddressList      = OT_NETWORK_DIAGNOSTIC_TLV_IP6_ADDR_LIST,
-        kMacCounters         = OT_NETWORK_DIAGNOSTIC_TLV_MAC_COUNTERS,
-        kBatteryLevel        = OT_NETWORK_DIAGNOSTIC_TLV_BATTERY_LEVEL,
-        kSupplyVoltage       = OT_NETWORK_DIAGNOSTIC_TLV_SUPPLY_VOLTAGE,
-        kChildTable          = OT_NETWORK_DIAGNOSTIC_TLV_CHILD_TABLE,
-        kChannelPages        = OT_NETWORK_DIAGNOSTIC_TLV_CHANNEL_PAGES,
-        kTypeList            = OT_NETWORK_DIAGNOSTIC_TLV_TYPE_LIST,
-        kMaxChildTimeout     = OT_NETWORK_DIAGNOSTIC_TLV_MAX_CHILD_TIMEOUT,
-        kEui64               = OT_NETWORK_DIAGNOSTIC_TLV_EUI64,
-        kVersion             = OT_NETWORK_DIAGNOSTIC_TLV_VERSION,
-        kVendorName          = OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_NAME,
-        kVendorModel         = OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_MODEL,
-        kVendorSwVersion     = OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_SW_VERSION,
-        kThreadStackVersion  = OT_NETWORK_DIAGNOSTIC_TLV_THREAD_STACK_VERSION,
-        kChild               = OT_NETWORK_DIAGNOSTIC_TLV_CHILD,
-        kChildIp6AddressList = OT_NETWORK_DIAGNOSTIC_TLV_CHILD_IP6_ADDR_LIST,
-        kRouterNeighbor      = OT_NETWORK_DIAGNOSTIC_TLV_ROUTER_NEIGHBOR,
-        kAnswer              = OT_NETWORK_DIAGNOSTIC_TLV_ANSWER,
-        kQueryId             = OT_NETWORK_DIAGNOSTIC_TLV_QUERY_ID,
-        kMleCounters         = OT_NETWORK_DIAGNOSTIC_TLV_MLE_COUNTERS,
-        kVendorAppUrl        = OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_APP_URL,
+        kExtMacAddress        = OT_NETWORK_DIAGNOSTIC_TLV_EXT_ADDRESS,
+        kAddress16            = OT_NETWORK_DIAGNOSTIC_TLV_SHORT_ADDRESS,
+        kMode                 = OT_NETWORK_DIAGNOSTIC_TLV_MODE,
+        kTimeout              = OT_NETWORK_DIAGNOSTIC_TLV_TIMEOUT,
+        kConnectivity         = OT_NETWORK_DIAGNOSTIC_TLV_CONNECTIVITY,
+        kRoute                = OT_NETWORK_DIAGNOSTIC_TLV_ROUTE,
+        kLeaderData           = OT_NETWORK_DIAGNOSTIC_TLV_LEADER_DATA,
+        kNetworkData          = OT_NETWORK_DIAGNOSTIC_TLV_NETWORK_DATA,
+        kIp6AddressList       = OT_NETWORK_DIAGNOSTIC_TLV_IP6_ADDR_LIST,
+        kMacCounters          = OT_NETWORK_DIAGNOSTIC_TLV_MAC_COUNTERS,
+        kBatteryLevel         = OT_NETWORK_DIAGNOSTIC_TLV_BATTERY_LEVEL,
+        kSupplyVoltage        = OT_NETWORK_DIAGNOSTIC_TLV_SUPPLY_VOLTAGE,
+        kChildTable           = OT_NETWORK_DIAGNOSTIC_TLV_CHILD_TABLE,
+        kChannelPages         = OT_NETWORK_DIAGNOSTIC_TLV_CHANNEL_PAGES,
+        kTypeList             = OT_NETWORK_DIAGNOSTIC_TLV_TYPE_LIST,
+        kMaxChildTimeout      = OT_NETWORK_DIAGNOSTIC_TLV_MAX_CHILD_TIMEOUT,
+        kEui64                = OT_NETWORK_DIAGNOSTIC_TLV_EUI64,
+        kVersion              = OT_NETWORK_DIAGNOSTIC_TLV_VERSION,
+        kVendorName           = OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_NAME,
+        kVendorModel          = OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_MODEL,
+        kVendorSwVersion      = OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_SW_VERSION,
+        kThreadStackVersion   = OT_NETWORK_DIAGNOSTIC_TLV_THREAD_STACK_VERSION,
+        kChild                = OT_NETWORK_DIAGNOSTIC_TLV_CHILD,
+        kChildIp6AddressList  = OT_NETWORK_DIAGNOSTIC_TLV_CHILD_IP6_ADDR_LIST,
+        kRouterNeighbor       = OT_NETWORK_DIAGNOSTIC_TLV_ROUTER_NEIGHBOR,
+        kAnswer               = OT_NETWORK_DIAGNOSTIC_TLV_ANSWER,
+        kQueryId              = OT_NETWORK_DIAGNOSTIC_TLV_QUERY_ID,
+        kMleCounters          = OT_NETWORK_DIAGNOSTIC_TLV_MLE_COUNTERS,
+        kVendorAppUrl         = OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_APP_URL,
+        kNonPreferredChannels = OT_NETWORK_DIAGNOSTIC_TLV_NON_PREFERRED_CHANNELS,
+        kEnhancedRoute        = OT_NETWORK_DIAGNOSTIC_TLV_ENHANCED_ROUTE,
     };
 
     /**
@@ -493,7 +495,7 @@ public:
      *
      * @returns The Timeout value.
      */
-    uint8_t GetTimeout(void) const { return (GetTimeoutChildId() & kTimeoutMask) >> kTimeoutOffset; }
+    uint8_t GetTimeout(void) const { return ReadBits<uint16_t, kTimeoutMask>(GetTimeoutChildId()); }
 
     /**
      * Sets the Timeout value.
@@ -502,7 +504,7 @@ public:
      */
     void SetTimeout(uint8_t aTimeout)
     {
-        SetTimeoutChildId((GetTimeoutChildId() & ~kTimeoutMask) | ((aTimeout << kTimeoutOffset) & kTimeoutMask));
+        SetTimeoutChildId(UpdateBits<uint16_t, kTimeoutMask>(GetTimeoutChildId(), aTimeout));
     }
 
     /**
@@ -512,7 +514,7 @@ public:
      */
     LinkQuality GetLinkQuality(void) const
     {
-        return static_cast<LinkQuality>((GetTimeoutChildId() & kLqiMask) >> kLqiOffset);
+        return static_cast<LinkQuality>(ReadBits<uint16_t, kLqiMask>(GetTimeoutChildId()));
     }
 
     /**
@@ -522,7 +524,7 @@ public:
      */
     void SetLinkQuality(LinkQuality aLinkQuality)
     {
-        SetTimeoutChildId((GetTimeoutChildId() & ~kLqiMask) | ((aLinkQuality << kLqiOffset) & kLqiMask));
+        SetTimeoutChildId(UpdateBits<uint16_t, kLqiMask>(GetTimeoutChildId(), aLinkQuality));
     }
 
     /**
@@ -530,7 +532,7 @@ public:
      *
      * @returns The Child ID value.
      */
-    uint16_t GetChildId(void) const { return (GetTimeoutChildId() & kChildIdMask) >> kChildIdOffset; }
+    uint16_t GetChildId(void) const { return ReadBits<uint16_t, kChildIdMask>(GetTimeoutChildId()); }
 
     /**
      * Sets the Child ID value.
@@ -539,7 +541,7 @@ public:
      */
     void SetChildId(uint16_t aChildId)
     {
-        SetTimeoutChildId((GetTimeoutChildId() & ~kChildIdMask) | ((aChildId << kChildIdOffset) & kChildIdMask));
+        SetTimeoutChildId(UpdateBits<uint16_t, kChildIdMask>(GetTimeoutChildId(), aChildId));
     }
 
     /**
@@ -954,6 +956,59 @@ private:
 
 #endif // OPENTHREAD_FTD
 
+/**
+ * Represents an Enhanced Route TLV Entry
+ */
+OT_TOOL_PACKED_BEGIN
+class EnhancedRouteTlvEntry
+{
+public:
+    typedef otNetworkDiagEnhRouteData ParseInfo; ///< Parse entry info
+
+    /**
+     * Initializes the entry as self (associated with device itself).
+     */
+    void InitAsSelf(void) { SetRouteData(kSelfFlag); }
+
+    /**
+     * Initializes the entry from given `router`.
+     *
+     * @param[in] aRouter  Router entry to use for initialization.
+     */
+    void InitFrom(const Router &aRouter);
+
+    /**
+     * Parses the entry and populate the information in given `ParseInfo` struct.
+     *
+     * @parma[out] aParseInfo   The `ParseInfo` structure to populate.
+     */
+    void Parse(ParseInfo &aParseInfo) const;
+
+private:
+    // Format:
+    //
+    //  15  14  13   12  11  10  9   8   7   6   5   4   3   2   1   0
+    // +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
+    // | S | L | LQOut | LQIn  |     NextHop (6-bit)   | NHCost(4 bits)|
+    // +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
+
+    static constexpr uint16_t kSelfFlag             = 1 << 15;
+    static constexpr uint16_t kLinkFlag             = 1 << 14;
+    static constexpr uint8_t  kLinkQualityOutOffset = 12;
+    static constexpr uint8_t  kLinkQualityInOffset  = 10;
+    static constexpr uint8_t  kNextHopOffset        = 4;
+    static constexpr uint8_t  kNextHopCostOffset    = 0;
+
+    static constexpr uint16_t kLinkQualityMask = 0x3;
+    static constexpr uint16_t kNextHopMask     = 0x3f;
+    static constexpr uint16_t kCostMask        = 0xf;
+
+    uint16_t GetRouteData(void) const { return BigEndian::HostSwap16(mRouteData); }
+    void     SetRouteData(uint16_t aRouteData) { mRouteData = BigEndian::HostSwap16(aRouteData); }
+
+    uint16_t mRouteData;
+} OT_TOOL_PACKED_END;
+
 /**
  * Implements Answer TLV generation and parsing.
  */
diff --git a/src/core/thread/panid_query_server.cpp b/src/core/thread/panid_query_server.cpp
index 56246047a..ed871311e 100644
--- a/src/core/thread/panid_query_server.cpp
+++ b/src/core/thread/panid_query_server.cpp
@@ -84,7 +84,7 @@ void PanIdQueryServer::HandleScanResult(Mac::ActiveScanResult *aScanResult)
     {
         if (aScanResult->mPanId == mPanId)
         {
-            mChannelMask |= 1 << aScanResult->mChannel;
+            SetBit<uint32_t>(mChannelMask, aScanResult->mChannel);
         }
     }
     else if (mChannelMask != 0)
diff --git a/src/core/thread/router_table.cpp b/src/core/thread/router_table.cpp
index ce0246371..1f125e115 100644
--- a/src/core/thread/router_table.cpp
+++ b/src/core/thread/router_table.cpp
@@ -175,7 +175,7 @@ Router *RouterTable::Allocate(uint8_t aRouterId)
 
     mRouterIdSequence++;
     mRouterIdSequenceLastUpdated = TimerMilli::GetNow();
-    Get<Mle::MleRouter>().ResetAdvertiseInterval();
+    Get<Mle::Mle>().ResetAdvertiseInterval();
 
     LogNote("Allocate router id %d", aRouterId);
 
@@ -190,7 +190,7 @@ Error RouterTable::Release(uint8_t aRouterId)
 
     OT_ASSERT(aRouterId <= Mle::kMaxRouterId);
 
-    VerifyOrExit(Get<Mle::MleRouter>().IsLeader(), error = kErrorInvalidState);
+    VerifyOrExit(Get<Mle::Mle>().IsLeader(), error = kErrorInvalidState);
 
     router = FindRouterById(aRouterId);
     VerifyOrExit(router != nullptr, error = kErrorNotFound);
@@ -211,7 +211,7 @@ Error RouterTable::Release(uint8_t aRouterId)
     Get<AddressResolver>().RemoveEntriesForRouterId(aRouterId);
     Get<NetworkData::Leader>().RemoveBorderRouter(Mle::Rloc16FromRouterId(aRouterId),
                                                   NetworkData::Leader::kMatchModeRouterId);
-    Get<Mle::MleRouter>().ResetAdvertiseInterval();
+    Get<Mle::Mle>().ResetAdvertiseInterval();
 
     LogNote("Release router id %d", aRouterId);
 
@@ -237,14 +237,14 @@ void RouterTable::RemoveRouterLink(Router &aRouter)
 
             if (GetLinkCost(router) >= Mle::kMaxRouteCost)
             {
-                Get<Mle::MleRouter>().ResetAdvertiseInterval();
+                Get<Mle::Mle>().ResetAdvertiseInterval();
             }
         }
     }
 
     if (aRouter.GetNextHop() == Mle::kInvalidRouterId)
     {
-        Get<Mle::MleRouter>().ResetAdvertiseInterval();
+        Get<Mle::Mle>().ResetAdvertiseInterval();
 
         // Clear all EID-to-RLOC entries associated with the router.
         Get<AddressResolver>().RemoveEntriesForRouterId(aRouter.GetRouterId());
@@ -328,7 +328,7 @@ exit:
     return error;
 }
 
-const Router *RouterTable::GetLeader(void) const { return FindRouterById(Get<Mle::MleRouter>().GetLeaderId()); }
+const Router *RouterTable::GetLeader(void) const { return FindRouterById(Get<Mle::Mle>().GetLeaderId()); }
 
 uint32_t RouterTable::GetLeaderAge(void) const
 {
@@ -411,7 +411,7 @@ void RouterTable::GetNextHopAndPathCost(uint16_t aDestRloc16, uint16_t &aNextHop
     router  = FindRouterById(Mle::RouterIdFromRloc16(aDestRloc16));
     nextHop = (router != nullptr) ? FindNextHopOf(*router) : nullptr;
 
-    if (Get<Mle::MleRouter>().IsChild())
+    if (Get<Mle::Mle>().IsChild())
     {
         const Router &parent = Get<Mle::Mle>().GetParent();
         bool          destIsParentOrItsChild;
@@ -544,7 +544,7 @@ void RouterTable::UpdateRouterIdSet(uint8_t aRouterIdSequence, const Mle::Router
         }
     }
 
-    Get<Mle::MleRouter>().ResetAdvertiseInterval();
+    Get<Mle::Mle>().ResetAdvertiseInterval();
 
 exit:
     return;
@@ -613,7 +613,7 @@ void RouterTable::UpdateRoutes(const Mle::RouteTlv &aRouteTlv, uint8_t aNeighbor
             if (neighbor->IsStateValid() && (aRouteTlv.GetLinkQualityOut(index) == kLinkQuality0) &&
                 (neighbor->GetTwoWayLinkQuality() >= kLinkQuality2))
             {
-                Get<Mle::MleRouter>().ScheduleUnicastAdvertisementTo(*neighbor);
+                Get<Mle::Mle>().ScheduleUnicastAdvertisementTo(*neighbor);
             }
         }
 
@@ -684,7 +684,7 @@ void RouterTable::UpdateRoutes(const Mle::RouteTlv &aRouteTlv, uint8_t aNeighbor
 
         if (newCostFinite != oldCostFinite)
         {
-            Get<Mle::MleRouter>().ResetAdvertiseInterval();
+            Get<Mle::Mle>().ResetAdvertiseInterval();
             break;
         }
     }
@@ -817,7 +817,7 @@ void RouterTable::HandleTimeTick(void)
 {
     mRouterIdMap.HandleTimeTick();
 
-    VerifyOrExit(Get<Mle::MleRouter>().IsLeader());
+    VerifyOrExit(Get<Mle::Mle>().IsLeader());
 
     // Update router id sequence
     if (GetLeaderAge() >= kRouterIdSequencePeriod)
@@ -890,7 +890,7 @@ void RouterTable::HandleTableChanged(void)
     Get<Utils::HistoryTracker>().RecordRouterTableChange();
 #endif
 
-    Get<Mle::MleRouter>().UpdateAdvertiseInterval();
+    Get<Mle::Mle>().UpdateAdvertiseInterval();
 }
 
 #if OT_SHOULD_LOG_AT(OT_LOG_LEVEL_INFO)
diff --git a/src/core/thread/thread_link_info.cpp b/src/core/thread/thread_link_info.cpp
new file mode 100644
index 000000000..9b1bf921b
--- /dev/null
+++ b/src/core/thread/thread_link_info.cpp
@@ -0,0 +1,88 @@
+/*
+ *  Copyright (c) 2025, The OpenThread Authors.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. Neither the name of the copyright holder nor the
+ *     names of its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ *   This file implements `ThreadLinkInfo`
+ */
+
+#include "thread_link_info.hpp"
+
+namespace ot {
+
+void ThreadLinkInfo::SetFrom(const Mac::RxFrame &aFrame)
+{
+    Clear();
+
+    if (kErrorNone != aFrame.GetSrcPanId(mPanId))
+    {
+        IgnoreError(aFrame.GetDstPanId(mPanId));
+    }
+
+    {
+        Mac::PanId dstPanId;
+
+        if (kErrorNone != aFrame.GetDstPanId(dstPanId))
+        {
+            dstPanId = mPanId;
+        }
+
+        mIsDstPanIdBroadcast = (dstPanId == Mac::kPanIdBroadcast);
+    }
+
+    if (aFrame.GetSecurityEnabled())
+    {
+        uint8_t keyIdMode;
+
+        // MAC Frame Security was already validated at the MAC
+        // layer. As a result, `GetKeyIdMode()` will never return
+        // failure here.
+        IgnoreError(aFrame.GetKeyIdMode(keyIdMode));
+
+        mLinkSecurity = (keyIdMode == Mac::Frame::kKeyIdMode0) || (keyIdMode == Mac::Frame::kKeyIdMode1);
+    }
+    else
+    {
+        mLinkSecurity = false;
+    }
+    mChannel = aFrame.GetChannel();
+    mRss     = aFrame.GetRssi();
+    mLqi     = aFrame.GetLqi();
+#if OPENTHREAD_CONFIG_TIME_SYNC_ENABLE
+    if (aFrame.GetTimeIe() != nullptr)
+    {
+        mNetworkTimeOffset = aFrame.ComputeNetworkTimeOffset();
+        mTimeSyncSeq       = aFrame.ReadTimeSyncSeq();
+    }
+#endif
+#if OPENTHREAD_CONFIG_MULTI_RADIO
+    mRadioType = static_cast<uint8_t>(aFrame.GetRadioType());
+#endif
+}
+
+} // namespace ot
diff --git a/src/core/thread/thread_link_info.hpp b/src/core/thread/thread_link_info.hpp
new file mode 100644
index 000000000..3214b6a11
--- /dev/null
+++ b/src/core/thread/thread_link_info.hpp
@@ -0,0 +1,125 @@
+/*
+ *  Copyright (c) 2025, The OpenThread Authors.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. Neither the name of the copyright holder nor the
+ *     names of its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ *   This file includes definitions for link-specific information for messages received from the Thread radio.
+ */
+
+#ifndef THREAD_LINK_INFO_HPP_
+#define THREAD_LINK_INFO_HPP_
+
+#include "openthread-core-config.h"
+
+#include <openthread/message.h>
+
+#include "common/clearable.hpp"
+#include "mac/mac_frame.hpp"
+#include "mac/mac_types.hpp"
+
+namespace ot {
+
+/**
+ * Represents link-specific information for messages received from the Thread radio.
+ */
+class ThreadLinkInfo : public otThreadLinkInfo, public Clearable<ThreadLinkInfo>
+{
+public:
+    /**
+     * Returns the IEEE 802.15.4 Source PAN ID.
+     *
+     * @returns The IEEE 802.15.4 Source PAN ID.
+     */
+    Mac::PanId GetPanId(void) const { return mPanId; }
+
+    /**
+     * Returns the IEEE 802.15.4 Channel.
+     *
+     * @returns The IEEE 802.15.4 Channel.
+     */
+    uint8_t GetChannel(void) const { return mChannel; }
+
+    /**
+     * Returns whether the Destination PAN ID is broadcast.
+     *
+     * @retval TRUE   If Destination PAN ID is broadcast.
+     * @retval FALSE  If Destination PAN ID is not broadcast.
+     */
+    bool IsDstPanIdBroadcast(void) const { return mIsDstPanIdBroadcast; }
+
+    /**
+     * Indicates whether or not link security is enabled.
+     *
+     * @retval TRUE   If link security is enabled.
+     * @retval FALSE  If link security is not enabled.
+     */
+    bool IsLinkSecurityEnabled(void) const { return mLinkSecurity; }
+
+    /**
+     * Returns the Received Signal Strength (RSS) in dBm.
+     *
+     * @returns The Received Signal Strength (RSS) in dBm.
+     */
+    int8_t GetRss(void) const { return mRss; }
+
+    /**
+     * Returns the frame/radio Link Quality Indicator (LQI) value.
+     *
+     * @returns The Link Quality Indicator value.
+     */
+    uint8_t GetLqi(void) const { return mLqi; }
+
+#if OPENTHREAD_CONFIG_TIME_SYNC_ENABLE
+    /**
+     * Returns the Time Sync Sequence.
+     *
+     * @returns The Time Sync Sequence.
+     */
+    uint8_t GetTimeSyncSeq(void) const { return mTimeSyncSeq; }
+
+    /**
+     * Returns the time offset to the Thread network time (in microseconds).
+     *
+     * @returns The time offset to the Thread network time (in microseconds).
+     */
+    int64_t GetNetworkTimeOffset(void) const { return mNetworkTimeOffset; }
+#endif
+
+    /**
+     * Sets the `ThreadLinkInfo` from a given received frame.
+     *
+     * @param[in] aFrame  A received frame.
+     */
+    void SetFrom(const Mac::RxFrame &aFrame);
+};
+
+DefineCoreType(otThreadLinkInfo, ThreadLinkInfo);
+
+} // namespace ot
+
+#endif // THREAD_LINK_INFO_HPP_
diff --git a/src/core/thread/thread_netif.cpp b/src/core/thread/thread_netif.cpp
index 98047e2e9..11bf357ef 100644
--- a/src/core/thread/thread_netif.cpp
+++ b/src/core/thread/thread_netif.cpp
@@ -57,7 +57,7 @@ void ThreadNetif::Up(void)
     mIsUp = true;
 
     SubscribeAllNodesMulticast();
-    IgnoreError(Get<Mle::MleRouter>().Enable());
+    IgnoreError(Get<Mle::Mle>().Enable());
     IgnoreError(Get<Tmf::Agent>().Start());
 #if OPENTHREAD_CONFIG_DNSSD_SERVER_ENABLE
     IgnoreError(Get<Dns::ServiceDiscovery::Server>().Start());
@@ -88,7 +88,7 @@ void ThreadNetif::Down(void)
     Get<Dns::ServiceDiscovery::Server>().Stop();
 #endif
     IgnoreError(Get<Tmf::Agent>().Stop());
-    IgnoreError(Get<Mle::MleRouter>().Disable());
+    IgnoreError(Get<Mle::Mle>().Disable());
     RemoveAllExternalUnicastAddresses();
     UnsubscribeAllExternalMulticastAddresses();
     UnsubscribeAllRoutersMulticast();
diff --git a/src/core/thread/thread_tlvs.hpp b/src/core/thread/thread_tlvs.hpp
index 7161f2d35..c41d6db6d 100644
--- a/src/core/thread/thread_tlvs.hpp
+++ b/src/core/thread/thread_tlvs.hpp
@@ -41,7 +41,6 @@
 #include "common/tlvs.hpp"
 #include "meshcop/network_name.hpp"
 #include "net/ip6_address.hpp"
-#include "thread/mle.hpp"
 #include "thread/mle_types.hpp"
 
 namespace ot {
diff --git a/src/core/thread/time_sync_service.cpp b/src/core/thread/time_sync_service.cpp
index 8b2f4d2ad..5add0ce4f 100644
--- a/src/core/thread/time_sync_service.cpp
+++ b/src/core/thread/time_sync_service.cpp
@@ -86,7 +86,7 @@ void TimeSync::HandleTimeSyncMessage(const Message &aMessage)
 
         LogInfo("Older time sync seq received:%u. Forwarding current seq:%u", aMessage.GetTimeSyncSeq(), mTimeSyncSeq);
     }
-    else if (Get<Mle::MleRouter>().IsLeader() && timeSyncSeqDelta > 0)
+    else if (Get<Mle::Mle>().IsLeader() && timeSyncSeqDelta > 0)
     {
         // Another device is forwarding a later time sync sequence, perhaps because it merged from a different
         // partition. The leader is authoritative, so ensure all devices synchronize to the time being seeded by this
@@ -97,13 +97,13 @@ void TimeSync::HandleTimeSyncMessage(const Message &aMessage)
         LogInfo("Newer time sync seq:%u received by leader. Setting current seq to:%u and forwarding",
                 aMessage.GetTimeSyncSeq(), mTimeSyncSeq);
     }
-    else if (!Get<Mle::MleRouter>().IsLeader())
+    else if (!Get<Mle::Mle>().IsLeader())
     {
         // For all devices aside from the leader, update network time in following three cases:
         //  1. During first attach.
         //  2. Already attached, and a newer time sync sequence was received.
         //  3. During reattach or migration process.
-        if (mTimeSyncSeq == OT_TIME_SYNC_INVALID_SEQ || timeSyncSeqDelta > 0 || Get<Mle::MleRouter>().IsDetached())
+        if (mTimeSyncSeq == OT_TIME_SYNC_INVALID_SEQ || timeSyncSeqDelta > 0 || Get<Mle::Mle>().IsDetached())
         {
             // Update network time and forward it.
             mLastTimeSyncReceived = TimerMilli::GetNow();
@@ -137,8 +137,7 @@ void TimeSync::NotifyTimeSyncCallback(void) { mTimeSyncCallback.InvokeIfSet(); }
 #if OPENTHREAD_FTD
 void TimeSync::ProcessTimeSync(void)
 {
-    if (Get<Mle::MleRouter>().IsLeader() &&
-        (TimerMilli::GetNow() - mLastTimeSyncSent > Time::SecToMsec(mTimeSyncPeriod)))
+    if (Get<Mle::Mle>().IsLeader() && (TimerMilli::GetNow() - mLastTimeSyncSent > Time::SecToMsec(mTimeSyncPeriod)))
     {
         IncrementTimeSyncSeq();
         mTimeSyncRequired = true;
@@ -148,7 +147,7 @@ void TimeSync::ProcessTimeSync(void)
 
     if (mTimeSyncRequired)
     {
-        VerifyOrExit(Get<Mle::MleRouter>().SendTimeSync() == kErrorNone);
+        VerifyOrExit(Get<Mle::Mle>().SendTimeSync() == kErrorNone);
 
         mLastTimeSyncSent = TimerMilli::GetNow();
         mTimeSyncRequired = false;
@@ -168,7 +167,7 @@ void TimeSync::HandleNotifierEvents(Events aEvents)
         stateChanged = true;
     }
 
-    if (aEvents.Contains(kEventThreadPartitionIdChanged) && !Get<Mle::MleRouter>().IsLeader())
+    if (aEvents.Contains(kEventThreadPartitionIdChanged) && !Get<Mle::Mle>().IsLeader())
     {
         // Partition has changed. Accept any network time currently being seeded on the new partition
         // and don't attempt to forward the currently held network time from the previous partition.
@@ -200,7 +199,7 @@ void TimeSync::CheckAndHandleChanges(bool aTimeUpdated)
 
     mTimer.Stop();
 
-    switch (Get<Mle::MleRouter>().GetRole())
+    switch (Get<Mle::Mle>().GetRole())
     {
     case Mle::kRoleDisabled:
     case Mle::kRoleDetached:
diff --git a/src/core/thread/tmf.cpp b/src/core/thread/tmf.cpp
index 37b7f763c..9d18cf27d 100644
--- a/src/core/thread/tmf.cpp
+++ b/src/core/thread/tmf.cpp
@@ -41,18 +41,18 @@ namespace Tmf {
 //----------------------------------------------------------------------------------------------------------------------
 // MessageInfo
 
-void MessageInfo::SetSockAddrToRloc(void) { SetSockAddr(Get<Mle::MleRouter>().GetMeshLocalRloc()); }
+void MessageInfo::SetSockAddrToRloc(void) { SetSockAddr(Get<Mle::Mle>().GetMeshLocalRloc()); }
 
 void MessageInfo::SetSockAddrToRlocPeerAddrToLeaderAloc(void)
 {
     SetSockAddrToRloc();
-    Get<Mle::MleRouter>().GetLeaderAloc(GetPeerAddr());
+    Get<Mle::Mle>().GetLeaderAloc(GetPeerAddr());
 }
 
 void MessageInfo::SetSockAddrToRlocPeerAddrToLeaderRloc(void)
 {
     SetSockAddrToRloc();
-    Get<Mle::MleRouter>().GetLeaderRloc(GetPeerAddr());
+    Get<Mle::Mle>().GetLeaderRloc(GetPeerAddr());
 }
 
 void MessageInfo::SetSockAddrToRlocPeerAddrToRealmLocalAllRoutersMulticast(void)
@@ -127,8 +127,8 @@ bool Agent::HandleResource(const char *aUriPath, Message &aMessage, const Ip6::M
 #if OPENTHREAD_FTD
         Case(kUriAddressQuery, AddressResolver);
         Case(kUriAddressNotify, AddressResolver);
-        Case(kUriAddressSolicit, Mle::MleRouter);
-        Case(kUriAddressRelease, Mle::MleRouter);
+        Case(kUriAddressSolicit, Mle::Mle);
+        Case(kUriAddressRelease, Mle::Mle);
         Case(kUriActiveSet, MeshCoP::ActiveDatasetManager);
         Case(kUriActiveReplace, MeshCoP::ActiveDatasetManager);
         Case(kUriPendingSet, MeshCoP::PendingDatasetManager);
diff --git a/src/core/utils/history_tracker.cpp b/src/core/utils/history_tracker.cpp
index 9ef01aefe..87060618e 100644
--- a/src/core/utils/history_tracker.cpp
+++ b/src/core/utils/history_tracker.cpp
@@ -425,6 +425,19 @@ exit:
 
 #endif // OPENTHREAD_CONFIG_HISTORY_TRACKER_NET_DATA
 
+#if OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE && OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
+void HistoryTracker::RecordEpskcEvent(EpskcEvent aEvent)
+{
+    EpskcEvent *entry = mEpskcEventHistory.AddNewEntry();
+
+    VerifyOrExit(entry != nullptr);
+    *entry = aEvent;
+
+exit:
+    return;
+}
+#endif
+
 void HistoryTracker::HandleNotifierEvents(Events aEvents)
 {
     if (aEvents.ContainsAny(kEventThreadRoleChanged | kEventThreadRlocAdded | kEventThreadRlocRemoved |
@@ -451,7 +464,9 @@ void HistoryTracker::HandleTimer(void)
     mNeighborHistory.UpdateAgedEntries();
     mOnMeshPrefixHistory.UpdateAgedEntries();
     mExternalRouteHistory.UpdateAgedEntries();
-
+#if OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE && OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
+    mEpskcEventHistory.UpdateAgedEntries();
+#endif
     mTimer.Start(kAgeCheckPeriod);
 }
 
diff --git a/src/core/utils/history_tracker.hpp b/src/core/utils/history_tracker.hpp
index b17c587fb..c869f00ec 100644
--- a/src/core/utils/history_tracker.hpp
+++ b/src/core/utils/history_tracker.hpp
@@ -47,6 +47,7 @@
 #include "common/non_copyable.hpp"
 #include "common/notifier.hpp"
 #include "common/timer.hpp"
+#include "meshcop/border_agent.hpp"
 #include "net/netif.hpp"
 #include "net/socket.hpp"
 #include "thread/mesh_forwarder.hpp"
@@ -57,6 +58,7 @@
 #include "thread/router_table.hpp"
 
 namespace ot {
+
 namespace Utils {
 
 #ifdef OPENTHREAD_CONFIG_HISTORY_TRACKER_NET_DATA
@@ -81,6 +83,10 @@ class HistoryTracker : public InstanceLocator, private NonCopyable
 #if OPENTHREAD_FTD
     friend class ot::RouterTable;
 #endif
+#if OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE && OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
+    friend class ot::MeshCoP::BorderAgent;
+    friend class ot::MeshCoP::BorderAgent::EphemeralKeyManager;
+#endif
 
 public:
     /**
@@ -134,6 +140,9 @@ public:
     typedef otHistoryTrackerRouterInfo           RouterInfo;           ///< Router info.
     typedef otHistoryTrackerOnMeshPrefixInfo     OnMeshPrefixInfo;     ///< Network Data on mesh prefix info.
     typedef otHistoryTrackerExternalRouteInfo    ExternalRouteInfo;    ///< Network Data external route info
+#if OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE && OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
+    typedef otHistoryTrackerBorderAgentEpskcEvent EpskcEvent; ///< Border Agent ePSKc Event.
+#endif
 
     /**
      * Initializes the `HistoryTracker`.
@@ -242,6 +251,13 @@ public:
         return mExternalRouteHistory.Iterate(aIterator, aEntryAge);
     }
 
+#if OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE && OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
+    const EpskcEvent *IterateEpskcEventHistory(Iterator &aIterator, uint32_t &aEntryAge) const
+    {
+        return mEpskcEventHistory.Iterate(aIterator, aEntryAge);
+    }
+#endif
+
     /**
      * Converts a given entry age to a human-readable string.
      *
@@ -273,6 +289,7 @@ private:
     static constexpr uint16_t kRouterListSize        = OPENTHREAD_CONFIG_HISTORY_TRACKER_ROUTER_LIST_SIZE;
     static constexpr uint16_t kOnMeshPrefixListSize  = OPENTHREAD_CONFIG_HISTORY_TRACKER_ON_MESH_PREFIX_LIST_SIZE;
     static constexpr uint16_t kExternalRouteListSize = OPENTHREAD_CONFIG_HISTORY_TRACKER_EXTERNAL_ROUTE_LIST_SIZE;
+    static constexpr uint16_t kEpskcEventListSize    = OPENTHREAD_CONFIG_HISTORY_TRACKER_EPSKC_EVENT_SIZE;
 
     typedef otHistoryTrackerAddressEvent AddressEvent;
 
@@ -300,6 +317,27 @@ private:
     static constexpr NetDataEvent kNetDataEntryAdded   = OT_HISTORY_TRACKER_NET_DATA_ENTRY_ADDED;
     static constexpr NetDataEvent kNetDataEntryRemoved = OT_HISTORY_TRACKER_NET_DATA_ENTRY_REMOVED;
 
+#if OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE && OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
+#define DefineEpskcEvent(aName, aPublicEnumName) \
+    static constexpr EpskcEvent kEpskc##aName = OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_##aPublicEnumName
+
+    DefineEpskcEvent(Activated, ACTIVATED);
+    DefineEpskcEvent(Connected, CONNECTED);
+    DefineEpskcEvent(Petitioned, PETITIONED);
+    DefineEpskcEvent(RetrievedActiveDataset, RETRIEVED_ACTIVE_DATASET);
+    DefineEpskcEvent(RetrievedPendingDataset, RETRIEVED_PENDING_DATASET);
+    DefineEpskcEvent(KeepAlive, KEEP_ALIVE);
+    DefineEpskcEvent(DeactivatedLocalClose, DEACTIVATED_LOCAL_CLOSE);
+    DefineEpskcEvent(DeactivatedRemoteClose, DEACTIVATED_REMOTE_CLOSE);
+    DefineEpskcEvent(DeactivatedSessionError, DEACTIVATED_SESSION_ERROR);
+    DefineEpskcEvent(DeactivatedSessionTimeout, DEACTIVATED_SESSION_TIMEOUT);
+    DefineEpskcEvent(DeactivatedMaxAttempts, DEACTIVATED_MAX_ATTEMPTS);
+    DefineEpskcEvent(DeactivatedEpskcTimeout, DEACTIVATED_EPSKC_TIMEOUT);
+    DefineEpskcEvent(DeactivatedUnknown, DEACTIVATED_UNKNOWN);
+
+#undef DefineEpskcEvent
+#endif
+
     class Timestamp
     {
     public:
@@ -372,6 +410,7 @@ private:
         Entry       *AddNewEntry(void) { return nullptr; }
         void         AddNewEntry(const Entry &) {}
         const Entry *Iterate(Iterator &, uint32_t &) const { return nullptr; }
+        void         UpdateAgedEntries(void) {}
         void         RemoveAgedEntries(void) {}
     };
 
@@ -408,6 +447,9 @@ private:
     void RecordOnMeshPrefixEvent(NetDataEvent aEvent, const NetworkData::OnMeshPrefixConfig &aPrefix);
     void RecordExternalRouteEvent(NetDataEvent aEvent, const NetworkData::ExternalRouteConfig &aRoute);
 #endif
+#if OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE && OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
+    void RecordEpskcEvent(EpskcEvent aEvent);
+#endif
 
     using TrackerTimer = TimerMilliIn<HistoryTracker, &HistoryTracker::HandleTimer>;
 
@@ -420,6 +462,9 @@ private:
     EntryList<RouterInfo, kRouterListSize>                  mRouterHistory;
     EntryList<OnMeshPrefixInfo, kOnMeshPrefixListSize>      mOnMeshPrefixHistory;
     EntryList<ExternalRouteInfo, kExternalRouteListSize>    mExternalRouteHistory;
+#if OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE && OPENTHREAD_CONFIG_BORDER_AGENT_EPHEMERAL_KEY_ENABLE
+    EntryList<EpskcEvent, kEpskcEventListSize> mEpskcEventHistory;
+#endif
 
     TrackerTimer mTimer;
 
diff --git a/src/core/utils/jam_detector.cpp b/src/core/utils/jam_detector.cpp
index 8c317cc2c..c77dd091a 100644
--- a/src/core/utils/jam_detector.cpp
+++ b/src/core/utils/jam_detector.cpp
@@ -96,7 +96,7 @@ void JamDetector::CheckState(void)
 {
     VerifyOrExit(mEnabled);
 
-    switch (Get<Mle::MleRouter>().GetRole())
+    switch (Get<Mle::Mle>().GetRole())
     {
     case Mle::kRoleDisabled:
         VerifyOrExit(mTimer.IsRunning());
diff --git a/src/core/utils/link_metrics_manager.cpp b/src/core/utils/link_metrics_manager.cpp
index 201bf9c13..aa646894b 100644
--- a/src/core/utils/link_metrics_manager.cpp
+++ b/src/core/utils/link_metrics_manager.cpp
@@ -214,7 +214,7 @@ void LinkMetricsManager::HandleMgmtResponse(const otIp6Address *aAddress, otLink
     Subject        *subject;
     Neighbor       *neighbor;
 
-    AsCoreType(aAddress).GetIid().ConvertToExtAddress(extAddress);
+    extAddress.SetFromIid(AsCoreType(aAddress).GetIid());
     neighbor = Get<NeighborTable>().FindNeighbor(extAddress);
     VerifyOrExit(neighbor != nullptr);
 
diff --git a/src/include/common/code_utils.hpp b/src/include/common/code_utils.hpp
index 7f697a420..19f468dcb 100644
--- a/src/include/common/code_utils.hpp
+++ b/src/include/common/code_utils.hpp
@@ -109,14 +109,17 @@
  * @param[in]  aCondition  A Boolean expression to be evaluated.
  * @param[in]  aAction     An optional expression or block to execute when the assertion fails.
  */
-#define VerifyOrExit(...)                 \
-    do                                    \
-    {                                     \
-        if (!(OT_FIRST_ARG(__VA_ARGS__))) \
-        {                                 \
-            OT_SECOND_ARG(__VA_ARGS__);   \
-            goto exit;                    \
-        }                                 \
+#define VerifyOrExit(...)               \
+    do                                  \
+    {                                   \
+        if (OT_FIRST_ARG(__VA_ARGS__))  \
+        {                               \
+        }                               \
+        else                            \
+        {                               \
+            OT_SECOND_ARG(__VA_ARGS__); \
+            goto exit;                  \
+        }                               \
     } while (false)
 
 /**
diff --git a/src/lib/spinel/openthread-spinel-config.h b/src/lib/spinel/openthread-spinel-config.h
index 632fcfc42..fb99a63be 100644
--- a/src/lib/spinel/openthread-spinel-config.h
+++ b/src/lib/spinel/openthread-spinel-config.h
@@ -163,4 +163,13 @@
 #define OPENTHREAD_SPINEL_CONFIG_RCP_TX_WAIT_TIME_SECS 5
 #endif
 
+/**
+ * @def OPENTHREAD_SPINEL_CONFIG_COPROCESSOR_RESET_FAILURE_CALLBACK_ENABLE
+ *
+ * Enables Co-processor reset failure callback in Spinel driver
+ */
+#ifndef OPENTHREAD_SPINEL_CONFIG_COPROCESSOR_RESET_FAILURE_CALLBACK_ENABLE
+#define OPENTHREAD_SPINEL_CONFIG_COPROCESSOR_RESET_FAILURE_CALLBACK_ENABLE 0
+#endif
+
 #endif // OPENTHREAD_SPINEL_CONFIG_H_
diff --git a/src/lib/spinel/spinel.c b/src/lib/spinel/spinel.c
index 35988d4b1..8c4f5f4e2 100644
--- a/src/lib/spinel/spinel.c
+++ b/src/lib/spinel/spinel.c
@@ -1381,6 +1381,7 @@ const char *spinel_prop_key_to_cstr(spinel_prop_key_t prop_key)
         {SPINEL_PROP_STREAM_NET, "STREAM_NET"},
         {SPINEL_PROP_STREAM_NET_INSECURE, "STREAM_NET_INSECURE"},
         {SPINEL_PROP_STREAM_LOG, "STREAM_LOG"},
+        {SPINEL_PROP_STREAM_CLI, "STREAM_CLI"},
         {SPINEL_PROP_MESHCOP_COMMISSIONER_STATE, "MESHCOP_COMMISSIONER_STATE"},
         {SPINEL_PROP_MESHCOP_COMMISSIONER_JOINERS, "MESHCOP_COMMISSIONER_JOINERS"},
         {SPINEL_PROP_MESHCOP_COMMISSIONER_PROVISIONING_URL, "MESHCOP_COMMISSIONER_PROVISIONING_URL"},
@@ -1419,6 +1420,9 @@ const char *spinel_prop_key_to_cstr(spinel_prop_key_t prop_key)
         {SPINEL_PROP_DNSSD_SERVICE, "DNSSD_SERVICE"},
         {SPINEL_PROP_DNSSD_KEY_RECORD, "DNSSD_KEY_RECORD"},
         {SPINEL_PROP_BORDER_AGENT_MESHCOP_SERVICE_STATE, "BORDER_AGENT_MESHCOP_SERVICE_STATE"},
+        {SPINEL_PROP_BACKBONE_ROUTER_STATE, "BACKBONE_ROUTER_STATE"},
+        {SPINEL_PROP_BACKBONE_ROUTER_ENABLE, "BACKBONE_ROUTER_ENABLE"},
+        {SPINEL_PROP_BACKBONE_ROUTER_MULTICAST_LISTENER, "BACKBONE_ROUTER_MULTICAST_LISTENER"},
         {SPINEL_PROP_PARENT_RESPONSE_INFO, "PARENT_RESPONSE_INFO"},
         {SPINEL_PROP_SLAAC_ENABLED, "SLAAC_ENABLED"},
         {SPINEL_PROP_SUPPORTED_RADIO_LINKS, "SUPPORTED_RADIO_LINKS"},
diff --git a/src/lib/spinel/spinel.h b/src/lib/spinel/spinel.h
index 667437bd8..869bc78c1 100644
--- a/src/lib/spinel/spinel.h
+++ b/src/lib/spinel/spinel.h
@@ -3561,6 +3561,21 @@ enum
      */
     SPINEL_PROP_STREAM_LOG = SPINEL_PROP_STREAM__BEGIN + 4,
 
+    /// CLI Stream
+    /** Format: `U` - Set (Host to NCP) and Unsolicited Notifications (NCP to Host)
+     *
+     * This streaming property provides a bidirectional channel for interacting with the NCP's
+     * command-line interface (CLI).
+     *
+     * The host can send CLI commands to the NCP by setting this property. The NCP will then
+     * execute the commands. The NCP will send the output of the executed command (if any) back to
+     * the host via unsolicited notifications of this same property.
+     *
+     * Both the input command string (from host) and the output string (from NCP) are
+     * zero-terminated UTF-8 encoded strings.
+     */
+    SPINEL_PROP_STREAM_CLI = SPINEL_PROP_STREAM__BEGIN + 5,
+
     SPINEL_PROP_STREAM__END = 0x80,
 
     SPINEL_PROP_STREAM_EXT__BEGIN = 0x1700,
@@ -4898,6 +4913,40 @@ enum
 
     SPINEL_PROP_BORDER_AGENT__END = 0x970,
 
+    SPINEL_PROP_BACKBONE_ROUTER__BEGIN = 0x970,
+
+    /// Backbone Router State
+    /**
+     * Format: `C` - Unsolicited notifications only
+     *
+     * `C`: The Backbone Router state. The value is the same as `otBackboneRouterState`.
+     *
+     * This property is used to notify the host the state of the Backbone Router.
+     */
+    SPINEL_PROP_BACKBONE_ROUTER_STATE = SPINEL_PROP_BACKBONE_ROUTER__BEGIN + 1,
+
+    /// Enablement/Disablement of Backbone Router function.
+    /**
+     * Format: `b` - Write-Only
+     *
+     * `b`: Whether to enable or disable the Backbone Router function.
+     *
+     * Host uses this property to enable or disable the Backbone Router function on NCP.
+     */
+    SPINEL_PROP_BACKBONE_ROUTER_ENABLE = SPINEL_PROP_BACKBONE_ROUTER__BEGIN + 2,
+
+    /// BackBone Router Multicast Listener.
+    /**
+     * Format: `6` - Inserted/Removed
+     *
+     * `6`: The multicast address that is subscribed by a multicast listener.
+     *
+     * NCP uses this property to subscribe or unsubscribe a multicast listener on the host.
+     */
+    SPINEL_PROP_BACKBONE_ROUTER_MULTICAST_LISTENER = SPINEL_PROP_BACKBONE_ROUTER__BEGIN + 3,
+
+    SPINEL_PROP_BACKBONE_ROUTER__END = 0x990,
+
     SPINEL_PROP_NEST__BEGIN = 0x3BC0,
 
     SPINEL_PROP_NEST_STREAM_MFG = SPINEL_PROP_NEST__BEGIN + 0,
diff --git a/src/lib/spinel/spinel_driver.cpp b/src/lib/spinel/spinel_driver.cpp
index d88d55df9..9ef7e87a1 100644
--- a/src/lib/spinel/spinel_driver.cpp
+++ b/src/lib/spinel/spinel_driver.cpp
@@ -52,6 +52,10 @@ SpinelDriver::SpinelDriver(void)
     , mSpinelVersionMajor(-1)
     , mSpinelVersionMinor(-1)
     , mIsCoprocessorReady(false)
+#if OPENTHREAD_SPINEL_CONFIG_COPROCESSOR_RESET_FAILURE_CALLBACK_ENABLE
+    , mCoprocessorResetFailureCallback(nullptr)
+    , mCoprocessorResetFailureContext(nullptr)
+#endif
 {
     memset(mVersion, 0, sizeof(mVersion));
 
@@ -119,6 +123,15 @@ exit:
     return error;
 }
 
+#if OPENTHREAD_SPINEL_CONFIG_COPROCESSOR_RESET_FAILURE_CALLBACK_ENABLE
+void SpinelDriver::SetCoprocessorResetFailureCallback(otSpinelDriverCoprocessorResetFailureCallback aCallback,
+                                                      void                                         *aContext)
+{
+    mCoprocessorResetFailureCallback = aCallback;
+    mCoprocessorResetFailureContext  = aContext;
+}
+#endif
+
 void SpinelDriver::ResetCoprocessor(bool aSoftwareReset)
 {
     bool hardwareReset;
@@ -129,7 +142,13 @@ void SpinelDriver::ResetCoprocessor(bool aSoftwareReset)
     VerifyOrExit(!mIsCoprocessorReady, resetDone = true);
 #endif
 
-    mWaitingKey = SPINEL_PROP_LAST_STATUS;
+    // Before resetting the co-processor, mIsCoprocessorReady must be set to false.
+    // Otherwise, in some cases, the host may misinterpret the reset result.
+    // For example, if mIsCoprocessorReady is true when calling ResetCoprocessor,
+    // and the reset fails but the co-processor sends some invalid data, `WaitResponse`
+    // may mistakenly return OT_ERROR_NONE, causing the host to believe the reset succeeded.
+    mIsCoprocessorReady = false;
+    mWaitingKey         = SPINEL_PROP_LAST_STATUS;
 
     if (aSoftwareReset && (SendReset(SPINEL_RESET_STACK) == OT_ERROR_NONE) && (WaitResponse() == OT_ERROR_NONE))
     {
@@ -160,6 +179,12 @@ exit:
     if (!resetDone)
     {
         LogCrit("Failed to reset co-processor!");
+#if OPENTHREAD_SPINEL_CONFIG_COPROCESSOR_RESET_FAILURE_CALLBACK_ENABLE
+        if (mCoprocessorResetFailureCallback)
+        {
+            mCoprocessorResetFailureCallback(mCoprocessorResetFailureContext);
+        }
+#endif
         DieNow(OT_EXIT_FAILURE);
     }
 }
diff --git a/src/lib/spinel/spinel_driver.hpp b/src/lib/spinel/spinel_driver.hpp
index 076106204..8f34c7043 100644
--- a/src/lib/spinel/spinel_driver.hpp
+++ b/src/lib/spinel/spinel_driver.hpp
@@ -215,6 +215,27 @@ public:
      */
     spinel_iid_t GetIid(void) { return mIid; }
 
+#if OPENTHREAD_SPINEL_CONFIG_COPROCESSOR_RESET_FAILURE_CALLBACK_ENABLE
+    /**
+     * A callback type for handling Co-processor reset failure of spinel driver.
+     *
+     * @param[in] aContext  A pointer to the user context.
+     */
+    typedef void (*otSpinelDriverCoprocessorResetFailureCallback)(void *aContext);
+
+    /**
+     * Registers a callback to handle Co-processor reset failure of Spinel driver.
+     *
+     * This function is used to register a callback to handle Co-processor reset failure.
+     * When the Spinel driver fails to reset the Co-processor through both software and
+     * hardware resets, the user can handle the error through the callback(such as OTA).
+     *
+     * @param[in] aCallback The callback.
+     * @param[in] aContext  A pointer to the user context.
+     */
+    void SetCoprocessorResetFailureCallback(otSpinelDriverCoprocessorResetFailureCallback aCallback, void *aContext);
+#endif
+
 private:
     static constexpr uint16_t kMaxSpinelFrame    = SPINEL_FRAME_MAX_SIZE;
     static constexpr uint16_t kVersionStringSize = 128;
@@ -314,6 +335,11 @@ private:
     char mVersion[kVersionStringSize];
 
     Array<unsigned int, kCapsBufferSize> mCoprocessorCaps;
+
+#if OPENTHREAD_SPINEL_CONFIG_COPROCESSOR_RESET_FAILURE_CALLBACK_ENABLE
+    otSpinelDriverCoprocessorResetFailureCallback mCoprocessorResetFailureCallback;
+    void                                         *mCoprocessorResetFailureContext;
+#endif
 };
 
 } // namespace Spinel
diff --git a/src/ncp/CMakeLists.txt b/src/ncp/CMakeLists.txt
index 2f0a1f8e8..d88fbe293 100644
--- a/src/ncp/CMakeLists.txt
+++ b/src/ncp/CMakeLists.txt
@@ -63,6 +63,13 @@ else()
     target_compile_definitions(ot-config INTERFACE "OPENTHREAD_CONFIG_NCP_DNSSD_ENABLE=0")
 endif()
 
+option(OT_NCP_CLI_STREAM "enable NCP CLI stream ")
+if (OT_NCP_CLI_STREAM)
+    target_compile_definitions(ot-config INTERFACE "OPENTHREAD_CONFIG_NCP_CLI_STREAM_ENABLE=1")
+else()
+    target_compile_definitions(ot-config INTERFACE "OPENTHREAD_CONFIG_NCP_CLI_STREAM_ENABLE=0")
+endif()
+
 set(COMMON_NCP_SOURCES
     ${COMMON_SOURCES}
     ncp_base_ftd.cpp
diff --git a/src/ncp/changed_props_set.cpp b/src/ncp/changed_props_set.cpp
index 6706c8362..124d7d35f 100644
--- a/src/ncp/changed_props_set.cpp
+++ b/src/ncp/changed_props_set.cpp
@@ -94,8 +94,9 @@ const ChangedPropsSet::Entry ChangedPropsSet::mSupportedProps[] = {
     {SPINEL_PROP_PARENT_RESPONSE_INFO, SPINEL_STATUS_OK, true},
     {SPINEL_PROP_THREAD_MGMT_SET_PENDING_DATASET_TLVS, SPINEL_STATUS_OK, false},
 #if OPENTHREAD_FTD && OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE
-    {SPINEL_PROP_BORDER_AGENT_MESHCOP_SERVICE_STATE, SPINEL_STATUS_OK, false}
+    {SPINEL_PROP_BORDER_AGENT_MESHCOP_SERVICE_STATE, SPINEL_STATUS_OK, false},
 #endif
+    {SPINEL_PROP_BACKBONE_ROUTER_STATE, SPINEL_STATUS_OK, false},
 };
 
 uint8_t ChangedPropsSet::GetNumEntries(void) const
diff --git a/src/ncp/ftd.cmake b/src/ncp/ftd.cmake
index fbf230a4f..2b2a1c5d6 100644
--- a/src/ncp/ftd.cmake
+++ b/src/ncp/ftd.cmake
@@ -37,6 +37,7 @@ target_compile_definitions(openthread-ncp-ftd PRIVATE
 
 target_compile_options(openthread-ncp-ftd PRIVATE
     ${OT_CFLAGS}
+    -Wundef
 )
 
 target_include_directories(openthread-ncp-ftd PUBLIC ${OT_PUBLIC_INCLUDES} PRIVATE ${COMMON_INCLUDES})
@@ -49,6 +50,7 @@ target_link_libraries(openthread-ncp-ftd
         openthread-ftd
     PRIVATE
         ${OT_MBEDTLS}
+        openthread-cli-ftd
         openthread-hdlc
         openthread-spinel-ncp
         ot-config-ftd
diff --git a/src/ncp/mtd.cmake b/src/ncp/mtd.cmake
index 5bcf3783e..fb2955326 100644
--- a/src/ncp/mtd.cmake
+++ b/src/ncp/mtd.cmake
@@ -37,6 +37,7 @@ target_compile_definitions(openthread-ncp-mtd PRIVATE
 
 target_compile_options(openthread-ncp-mtd PRIVATE
     ${OT_CFLAGS}
+    -Wundef
 )
 
 target_include_directories(openthread-ncp-mtd PUBLIC ${OT_PUBLIC_INCLUDES} PRIVATE ${COMMON_INCLUDES})
@@ -49,6 +50,7 @@ target_link_libraries(openthread-ncp-mtd
         openthread-mtd
     PRIVATE
         ${OT_MBEDTLS}
+        openthread-cli-mtd
         openthread-hdlc
         openthread-spinel-ncp
         ot-config-mtd
diff --git a/src/ncp/ncp_base.cpp b/src/ncp/ncp_base.cpp
index e16b1db4c..7b7fc1658 100644
--- a/src/ncp/ncp_base.cpp
+++ b/src/ncp/ncp_base.cpp
@@ -36,6 +36,7 @@
 #include <stdlib.h>
 
 #include <openthread/border_agent.h>
+#include <openthread/cli.h>
 #include <openthread/diag.h>
 #include <openthread/icmp6.h>
 #include <openthread/link.h>
@@ -353,6 +354,9 @@ NcpBase::NcpBase(Instance *aInstance)
     IgnoreError(otSetStateChangedCallback(mInstance, &NcpBase::HandleStateChanged, this));
     otIp6SetReceiveCallback(mInstance, &NcpBase::HandleDatagramFromStack, this);
     otIp6SetReceiveFilterEnabled(mInstance, true);
+#if OPENTHREAD_CONFIG_NCP_CLI_STREAM_ENABLE
+    otCliInit(mInstance, &NcpBase::HandleCliOutput, this);
+#endif
 #if OPENTHREAD_CONFIG_TIME_SYNC_ENABLE
     otNetworkTimeSyncSetCallback(mInstance, &NcpBase::HandleTimeSyncUpdate, this);
 #endif // OPENTHREAD_CONFIG_TIME_SYNC_ENABLE
diff --git a/src/ncp/ncp_base.hpp b/src/ncp/ncp_base.hpp
index 2e9ec3e89..7f72639fc 100644
--- a/src/ncp/ncp_base.hpp
+++ b/src/ncp/ncp_base.hpp
@@ -654,6 +654,11 @@ protected:
     void        HandleDiagOutput(const char *aFormat, va_list aArguments);
 #endif
 
+#if OPENTHREAD_CONFIG_NCP_CLI_STREAM_ENABLE
+    static int HandleCliOutput(void *aContext, const char *aFormat, va_list aArguments);
+    int        HandleCliOutput(const char *aFormat, va_list aArguments);
+#endif
+
 #if OPENTHREAD_ENABLE_NCP_VENDOR_HOOK
     /**
      * Defines a vendor "command handler" hook to process vendor-specific spinel commands.
@@ -878,6 +883,15 @@ protected:
 
     otPlatDnssdState mDnssdState;
 #endif // OPENTHREAD_CONFIG_NCP_DNSSD_ENABLE && OPENTHREAD_CONFIG_PLATFORM_DNSSD_ENABLE
+
+#if OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE && OPENTHREAD_CONFIG_BACKBONE_ROUTER_MULTICAST_ROUTING_ENABLE
+    static void HandleBackboneRouterMulticastListenerEvent(void                                  *aContext,
+                                                           otBackboneRouterMulticastListenerEvent aEvent,
+                                                           const otIp6Address                    *aAddress);
+    void        HandleBackboneRouterMulticastListenerEvent(otBackboneRouterMulticastListenerEvent aEvent,
+                                                           const otIp6Address                    *aAddress);
+#endif
+
 #endif // OPENTHREAD_FTD
 
 #if OPENTHREAD_CONFIG_DIAG_ENABLE
diff --git a/src/ncp/ncp_base_dispatcher.cpp b/src/ncp/ncp_base_dispatcher.cpp
index 2e72d04b8..ef3a0b8f9 100644
--- a/src/ncp/ncp_base_dispatcher.cpp
+++ b/src/ncp/ncp_base_dispatcher.cpp
@@ -230,6 +230,9 @@ NcpBase::PropertyHandler NcpBase::FindGetPropertyHandler(spinel_prop_key_t aKey)
 #if OPENTHREAD_FTD && OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE
         OT_NCP_GET_HANDLER_ENTRY(SPINEL_PROP_BORDER_AGENT_MESHCOP_SERVICE_STATE),
 #endif
+#if OPENTHREAD_FTD && OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE
+        OT_NCP_GET_HANDLER_ENTRY(SPINEL_PROP_BACKBONE_ROUTER_STATE),
+#endif
 #endif
         OT_NCP_GET_HANDLER_ENTRY(SPINEL_PROP_UNSOL_UPDATE_FILTER),
         OT_NCP_GET_HANDLER_ENTRY(SPINEL_PROP_UNSOL_UPDATE_LIST),
@@ -487,6 +490,9 @@ NcpBase::PropertyHandler NcpBase::FindSetPropertyHandler(spinel_prop_key_t aKey)
         OT_NCP_SET_HANDLER_ENTRY(SPINEL_PROP_IPV6_ICMP_PING_OFFLOAD_MODE),
         OT_NCP_SET_HANDLER_ENTRY(SPINEL_PROP_STREAM_NET),
         OT_NCP_SET_HANDLER_ENTRY(SPINEL_PROP_STREAM_NET_INSECURE),
+#if OPENTHREAD_CONFIG_NCP_CLI_STREAM_ENABLE
+        OT_NCP_SET_HANDLER_ENTRY(SPINEL_PROP_STREAM_CLI),
+#endif
 #if OPENTHREAD_CONFIG_JOINER_ENABLE
         OT_NCP_SET_HANDLER_ENTRY(SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING),
 #endif
@@ -543,6 +549,9 @@ NcpBase::PropertyHandler NcpBase::FindSetPropertyHandler(spinel_prop_key_t aKey)
         OT_NCP_SET_HANDLER_ENTRY(SPINEL_PROP_DNSSD_STATE),
         OT_NCP_SET_HANDLER_ENTRY(SPINEL_PROP_DNSSD_REQUEST_RESULT),
 #endif
+#if OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE
+        OT_NCP_SET_HANDLER_ENTRY(SPINEL_PROP_BACKBONE_ROUTER_ENABLE),
+#endif
 #endif // OPENTHREAD_FTD
 #if OPENTHREAD_MTD || OPENTHREAD_FTD
         OT_NCP_SET_HANDLER_ENTRY(SPINEL_PROP_UNSOL_UPDATE_FILTER),
diff --git a/src/ncp/ncp_base_ftd.cpp b/src/ncp/ncp_base_ftd.cpp
index f3435989e..9996ebdfb 100644
--- a/src/ncp/ncp_base_ftd.cpp
+++ b/src/ncp/ncp_base_ftd.cpp
@@ -1666,6 +1666,64 @@ exit:
 
 #endif // OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE
 
+#if OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE
+template <> otError NcpBase::HandlePropertyGet<SPINEL_PROP_BACKBONE_ROUTER_STATE>(void)
+{
+    otBackboneRouterState state = otBackboneRouterGetState(mInstance);
+
+    return mEncoder.WriteUint8(static_cast<uint8_t>(state));
+}
+
+template <> otError NcpBase::HandlePropertySet<SPINEL_PROP_BACKBONE_ROUTER_ENABLE>(void)
+{
+    otError error = OT_ERROR_NONE;
+    bool    enable;
+
+    SuccessOrExit(error = mDecoder.ReadBool(enable));
+
+#if OPENTHREAD_CONFIG_BACKBONE_ROUTER_MULTICAST_ROUTING_ENABLE
+    if (enable)
+    {
+        otBackboneRouterSetMulticastListenerCallback(mInstance, HandleBackboneRouterMulticastListenerEvent, this);
+    }
+    else
+    {
+        otBackboneRouterSetMulticastListenerCallback(mInstance, nullptr, nullptr);
+    }
+#endif
+    otBackboneRouterSetEnabled(mInstance, enable);
+
+exit:
+    return error;
+}
+
+#if OPENTHREAD_CONFIG_BACKBONE_ROUTER_MULTICAST_ROUTING_ENABLE
+void NcpBase::HandleBackboneRouterMulticastListenerEvent(void                                  *aContext,
+                                                         otBackboneRouterMulticastListenerEvent aEvent,
+                                                         const otIp6Address                    *aAddress)
+{
+    static_cast<NcpBase *>(aContext)->HandleBackboneRouterMulticastListenerEvent(aEvent, aAddress);
+}
+
+void NcpBase::HandleBackboneRouterMulticastListenerEvent(otBackboneRouterMulticastListenerEvent aEvent,
+                                                         const otIp6Address                    *aAddress)
+{
+    uint8_t          header = SPINEL_HEADER_FLAG | SPINEL_HEADER_TX_NOTIFICATION_IID;
+    spinel_command_t cmd    = aEvent == OT_BACKBONE_ROUTER_MULTICAST_LISTENER_ADDED ? SPINEL_CMD_PROP_VALUE_INSERTED
+                                                                                    : SPINEL_CMD_PROP_VALUE_REMOVED;
+    VerifyOrExit(aAddress != nullptr);
+
+    SuccessOrExit(mEncoder.BeginFrame(header, cmd));
+    SuccessOrExit(mEncoder.WriteUintPacked(SPINEL_PROP_BACKBONE_ROUTER_MULTICAST_LISTENER));
+    SuccessOrExit(mEncoder.WriteIp6Address(*aAddress));
+    SuccessOrExit(mEncoder.EndFrame());
+
+exit:
+    return;
+}
+#endif // OPENTHREAD_CONFIG_BACKBONE_ROUTER_MULTICAST_ROUTING_ENABLE
+#endif // OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE
+
 } // namespace Ncp
 } // namespace ot
 
diff --git a/src/ncp/ncp_base_mtd.cpp b/src/ncp/ncp_base_mtd.cpp
index 0fbaf7574..728604251 100644
--- a/src/ncp/ncp_base_mtd.cpp
+++ b/src/ncp/ncp_base_mtd.cpp
@@ -41,6 +41,7 @@
 #include <openthread/channel_monitor.h>
 #endif
 #include <openthread/child_supervision.h>
+#include <openthread/cli.h>
 #include <openthread/diag.h>
 #include <openthread/icmp6.h>
 #if OPENTHREAD_CONFIG_JAM_DETECTION_ENABLE
@@ -68,6 +69,7 @@
 #include <openthread/trel.h>
 #endif
 
+#include "cli/cli_config.h"
 #include "common/code_utils.hpp"
 #include "common/debug.hpp"
 #include "common/string.hpp"
@@ -2975,6 +2977,21 @@ template <> otError NcpBase::HandlePropertySet<SPINEL_PROP_CNTR_ALL_IP_COUNTERS>
     return OT_ERROR_NONE;
 }
 
+#if OPENTHREAD_CONFIG_NCP_CLI_STREAM_ENABLE
+template <> otError NcpBase::HandlePropertySet<SPINEL_PROP_STREAM_CLI>(void)
+{
+    otError     error  = OT_ERROR_NONE;
+    const char *string = nullptr;
+
+    SuccessOrExit(error = mDecoder.ReadUtf8(string));
+
+    otCliInputLine(const_cast<char *>(string));
+
+exit:
+    return error;
+}
+#endif
+
 #if OPENTHREAD_CONFIG_MAC_FILTER_ENABLE
 
 template <> otError NcpBase::HandlePropertyGet<SPINEL_PROP_MAC_ALLOWLIST>(void)
@@ -4571,6 +4588,29 @@ exit:
 }
 #endif // OPENTHREAD_CONFIG_UDP_FORWARD_ENABLE
 
+#if OPENTHREAD_CONFIG_NCP_CLI_STREAM_ENABLE
+int NcpBase::HandleCliOutput(void *aContext, const char *aFormat, va_list aArguments)
+{
+    return static_cast<NcpBase *>(aContext)->HandleCliOutput(aFormat, aArguments);
+}
+
+int NcpBase::HandleCliOutput(const char *aFormat, va_list aArguments)
+{
+    uint8_t header = SPINEL_HEADER_FLAG | SPINEL_HEADER_IID_0;
+    char    output[OPENTHREAD_CONFIG_CLI_MAX_LINE_LENGTH];
+    int     rval;
+
+    VerifyOrExit((rval = vsnprintf(output, sizeof(output), aFormat, aArguments)) > 0);
+
+    SuccessOrExit(mEncoder.BeginFrame(header, SPINEL_CMD_PROP_VALUE_IS, SPINEL_PROP_STREAM_CLI));
+    SuccessOrExit(mEncoder.WriteUtf8(output));
+    SuccessOrExit(mEncoder.EndFrame());
+
+exit:
+    return rval;
+}
+#endif
+
 // ----------------------------------------------------------------------------
 // MARK: Pcap frame handling
 // ----------------------------------------------------------------------------
@@ -4709,6 +4749,7 @@ void NcpBase::ProcessThreadChangedFlags(void)
         {OT_CHANGED_PSKC, SPINEL_PROP_NET_PSKC},
         {OT_CHANGED_CHANNEL_MANAGER_NEW_CHANNEL, SPINEL_PROP_CHANNEL_MANAGER_NEW_CHANNEL},
         {OT_CHANGED_SUPPORTED_CHANNEL_MASK, SPINEL_PROP_PHY_CHAN_SUPPORTED},
+        {OT_CHANGED_THREAD_BACKBONE_ROUTER_STATE, SPINEL_PROP_BACKBONE_ROUTER_STATE},
     };
 
     VerifyOrExit(mThreadChangedFlags != 0);
diff --git a/src/ncp/ncp_config.h b/src/ncp/ncp_config.h
index 191858627..c60ee716f 100644
--- a/src/ncp/ncp_config.h
+++ b/src/ncp/ncp_config.h
@@ -185,6 +185,19 @@
 #define OPENTHREAD_CONFIG_NCP_DNSSD_ENABLE 0
 #endif
 
+/**
+ * @def OPENTHREAD_CONFIG_NCP_CLI_STREAM_ENABLE
+ *
+ * Define to 1 to enable the NCP CLI Stream feature.
+ *
+ * When enabled, the NCP will support sending and receiving CLI input/output
+ * data over a dedicated Spinel stream (using `SPINEL_PROP_STREAM_CLI`). This
+ * allows the host to interact with the OpenThread CLI running on the NCP.
+ */
+#ifndef OPENTHREAD_CONFIG_NCP_CLI_STREAM_ENABLE
+#define OPENTHREAD_CONFIG_NCP_CLI_STREAM_ENABLE 0
+#endif
+
 /**
  * @def OPENTHREAD_ENABLE_NCP_VENDOR_HOOK
  *
@@ -194,4 +207,13 @@
 #define OPENTHREAD_ENABLE_NCP_VENDOR_HOOK 0
 #endif
 
+/**
+ * @def OPENTHREAD_ENABLE_NCP_SPINEL_ENCRYPTER
+ *
+ * Define to 1 to enable NCP spinel encrypter.
+ */
+#ifndef OPENTHREAD_ENABLE_NCP_SPINEL_ENCRYPTER
+#define OPENTHREAD_ENABLE_NCP_SPINEL_ENCRYPTER 0
+#endif
+
 #endif // CONFIG_NCP_H_
diff --git a/src/ncp/platform/dnssd.cpp b/src/ncp/platform/dnssd.cpp
index 0bdf37c7a..af97c3e81 100644
--- a/src/ncp/platform/dnssd.cpp
+++ b/src/ncp/platform/dnssd.cpp
@@ -165,4 +165,16 @@ void otPlatDnssdStopIp4AddressResolver(otInstance *aInstance, const otPlatDnssdA
     OT_UNUSED_VARIABLE(aResolver);
 }
 
+void otPlatDnssdStartRecordQuerier(otInstance *aInstance, const otPlatDnssdRecordQuerier *aQuerier)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    OT_UNUSED_VARIABLE(aQuerier);
+}
+
+void otPlatDnssdStopRecordQuerier(otInstance *aInstance, const otPlatDnssdRecordQuerier *aQuerier)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    OT_UNUSED_VARIABLE(aQuerier);
+}
+
 #endif // OPENTHREAD_FTD && OPENTHREAD_CONFIG_NCP_DNSSD_ENABLE && OPENTHREAD_CONFIG_PLATFORM_DNSSD_ENABLE
diff --git a/src/posix/README.md b/src/posix/README.md
index ccffb3612..650db4b0b 100644
--- a/src/posix/README.md
+++ b/src/posix/README.md
@@ -118,8 +118,11 @@ To build and program the device with RCP application, complete the following ste
    b. nRF52840 Development Kit
 
    ```sh
-   # Program the image using the nrfjprog utility.
-   nrfjprog -f nrf52 --chiperase --program build/bin/ot-rcp.hex --reset
+   # Program the image using the nrfutil utility.
+   nrfutil device program --firmware build/bin/ot-rcp.hex --options chip_erase_mode=ERASE_ALL
+
+   # Reset the development kit using the nrfutil utility.
+   nrfutil device reset --reset-kind=RESET_PIN
    ```
 
    Disable the Mass Storage feature on the device, so that it does not interfere with the core RCP functionalities:
@@ -136,7 +139,7 @@ To build and program the device with RCP application, complete the following ste
 #### Run
 
 ```sh
-./build/posix/src/posix/ot-cli 'spinel+hdlc+uart:///dev/ttyACM0?uart-baudrate=115200'
+./build/posix/src/posix/ot-cli 'spinel+hdlc+uart:///dev/ttyACM0?uart-baudrate=460800'
 ```
 
 ## Daemon Mode
@@ -149,7 +152,7 @@ OpenThread Posix Daemon mode uses a unix socket as input and output, so that Ope
 # Daemon with simulation
 ./build/posix/src/posix/ot-daemon 'spinel+hdlc+forkpty://build/simulation/examples/apps/ncp/ot-rcp?forkpty-arg=1'
 # Daemon with real device
-./build/posix/src/posix/ot-daemon 'spinel+hdlc+uart:///dev/ttyACM0?uart-baudrate=115200'
+./build/posix/src/posix/ot-daemon 'spinel+hdlc+uart:///dev/ttyACM0?uart-baudrate=460800'
 # Built-in controller
 ./build/posix/src/posix/ot-ctl
 ```
diff --git a/src/posix/platform/CMakeLists.txt b/src/posix/platform/CMakeLists.txt
index 923c4e284..2b7a47da3 100644
--- a/src/posix/platform/CMakeLists.txt
+++ b/src/posix/platform/CMakeLists.txt
@@ -176,14 +176,6 @@ target_link_libraries(openthread-posix
         $<$<STREQUAL:${CMAKE_SYSTEM_NAME},Linux>:rt>
 )
 
-option(OT_TARGET_OPENWRT "enable openthread posix for OpenWRT" OFF)
-if(${CMAKE_SYSTEM_NAME} STREQUAL "Linux" AND NOT OT_TARGET_OPENWRT)
-    target_compile_definitions(ot-posix-config
-        INTERFACE "OPENTHREAD_POSIX_CONFIG_NAT64_AIL_PREFIX_ENABLE=1"
-    )
-    target_link_libraries(openthread-posix PRIVATE anl)
-endif()
-
 target_compile_definitions(openthread-posix
     PUBLIC
         ${OT_PUBLIC_DEFINES}
diff --git a/src/posix/platform/alarm.cpp b/src/posix/platform/alarm.cpp
index 3c2f7012d..770a51dab 100644
--- a/src/posix/platform/alarm.cpp
+++ b/src/posix/platform/alarm.cpp
@@ -76,6 +76,23 @@ static void microTimerHandler(int aSignal, siginfo_t *aSignalInfo, void *aUserCo
 #define OT_POSIX_CLOCK_ID CLOCK_MONOTONIC
 #endif
 
+static bool IsExpired(uint32_t aTime, uint32_t aNow)
+{
+    // Determine whether or not `aTime` is before or same as `aNow`.
+
+    uint32_t diff = aNow - aTime;
+
+    return (diff & (1U << 31)) == 0;
+}
+
+static uint32_t CalculateDuration(uint32_t aTime, uint32_t aNow)
+{
+    // Return the time duration from `aNow` to `aTime` if `aTime` is
+    // after `aNow`, otherwise return zero.
+
+    return IsExpired(aTime, aNow) ? 0 : aTime - aNow;
+}
+
 #if !OPENTHREAD_POSIX_VIRTUAL_TIME
 uint64_t otPlatTimeGet(void)
 {
@@ -128,7 +145,7 @@ void platformAlarmInit(uint32_t aSpeedUpFactor, int aRealTimeSignal)
     }
 }
 
-uint32_t otPlatAlarmMilliGetNow(void) { return (uint32_t)(platformAlarmGetNow() / OT_US_PER_MS); }
+uint32_t otPlatAlarmMilliGetNow(void) { return static_cast<uint32_t>(platformAlarmGetNow() / OT_US_PER_MS); }
 
 void otPlatAlarmMilliStartAt(otInstance *aInstance, uint32_t aT0, uint32_t aDt)
 {
@@ -197,39 +214,46 @@ void otPlatAlarmMicroStop(otInstance *aInstance)
 
 void platformAlarmUpdateTimeout(struct timeval *aTimeout)
 {
-    int64_t  remaining = INT32_MAX;
+    uint64_t remaining = INT32_MAX;
     uint64_t now       = platformAlarmGetNow();
 
     assert(aTimeout != nullptr);
 
     if (sIsMsRunning)
     {
-        remaining = (int32_t)(sMsAlarm - (uint32_t)(now / OT_US_PER_MS));
-        VerifyOrExit(remaining > 0);
-        remaining *= OT_US_PER_MS;
-        remaining -= (now % OT_US_PER_MS);
+        uint32_t nowMs        = static_cast<uint32_t>(now / OT_US_PER_MS);
+        uint32_t leftoverUsec = static_cast<uint32_t>(now % OT_US_PER_MS);
+
+        remaining = CalculateDuration(sMsAlarm, nowMs);
+
+        if (remaining > 0)
+        {
+            remaining *= OT_US_PER_MS;
+            remaining -= leftoverUsec;
+        }
     }
 
 #if OPENTHREAD_CONFIG_PLATFORM_USEC_TIMER_ENABLE
-    if (sIsUsRunning)
+    if (sIsUsRunning && (remaining > 0))
     {
-        int32_t usRemaining = (int32_t)(sUsAlarm - (uint32_t)now);
+        uint32_t usRemaining = CalculateDuration(sUsAlarm, static_cast<uint32_t>(now));
 
         if (usRemaining < remaining)
         {
             remaining = usRemaining;
         }
     }
-#endif // OPENTHREAD_CONFIG_PLATFORM_USEC_TIMER_ENABLE
+#endif
 
-exit:
-    if (remaining <= 0)
+    if (remaining == 0)
     {
         aTimeout->tv_sec  = 0;
         aTimeout->tv_usec = 0;
     }
     else
     {
+        uint64_t timeout;
+
         remaining /= sSpeedUpFactor;
 
         if (remaining == 0)
@@ -237,7 +261,9 @@ exit:
             remaining = 1;
         }
 
-        if (remaining < static_cast<int64_t>(aTimeout->tv_sec) * OT_US_PER_S + static_cast<int64_t>(aTimeout->tv_usec))
+        timeout = static_cast<uint64_t>(aTimeout->tv_sec) * OT_US_PER_S + static_cast<uint64_t>(aTimeout->tv_usec);
+
+        if (remaining < timeout)
         {
             aTimeout->tv_sec  = static_cast<time_t>(remaining / OT_US_PER_S);
             aTimeout->tv_usec = static_cast<suseconds_t>(remaining % OT_US_PER_S);
@@ -247,42 +273,29 @@ exit:
 
 void platformAlarmProcess(otInstance *aInstance)
 {
-    int32_t remaining;
-
-    if (sIsMsRunning)
+    if (sIsMsRunning && IsExpired(sMsAlarm, otPlatAlarmMilliGetNow()))
     {
-        remaining = (int32_t)(sMsAlarm - otPlatAlarmMilliGetNow());
-
-        if (remaining <= 0)
-        {
-            sIsMsRunning = false;
+        sIsMsRunning = false;
 
 #if OPENTHREAD_CONFIG_DIAG_ENABLE
-
-            if (otPlatDiagModeGet())
-            {
-                otPlatDiagAlarmFired(aInstance);
-            }
-            else
+        if (otPlatDiagModeGet())
+        {
+            otPlatDiagAlarmFired(aInstance);
+        }
+        else
 #endif
-            {
-                otPlatAlarmMilliFired(aInstance);
-            }
+        {
+            otPlatAlarmMilliFired(aInstance);
         }
     }
 
 #if OPENTHREAD_CONFIG_PLATFORM_USEC_TIMER_ENABLE
 
-    if (sIsUsRunning)
+    if (sIsUsRunning && IsExpired(sUsAlarm, otPlatAlarmMicroGetNow()))
     {
-        remaining = (int32_t)(sUsAlarm - otPlatAlarmMicroGetNow());
+        sIsUsRunning = false;
 
-        if (remaining <= 0)
-        {
-            sIsUsRunning = false;
-
-            otPlatAlarmMicroFired(aInstance);
-        }
+        otPlatAlarmMicroFired(aInstance);
     }
 
 #endif // OPENTHREAD_CONFIG_PLATFORM_USEC_TIMER_ENABLE
diff --git a/src/posix/platform/daemon.cpp b/src/posix/platform/daemon.cpp
index dad11a743..5a2a9c438 100644
--- a/src/posix/platform/daemon.cpp
+++ b/src/posix/platform/daemon.cpp
@@ -47,6 +47,7 @@
 #include "cli/cli_config.h"
 #include "common/code_utils.hpp"
 #include "posix/platform/platform-posix.h"
+#include "posix/platform/utils.hpp"
 
 #if OPENTHREAD_POSIX_CONFIG_DAEMON_ENABLE
 
diff --git a/src/posix/platform/hdlc_interface.cpp b/src/posix/platform/hdlc_interface.cpp
index 321bfbae2..8bf4043e9 100644
--- a/src/posix/platform/hdlc_interface.cpp
+++ b/src/posix/platform/hdlc_interface.cpp
@@ -465,7 +465,7 @@ int HdlcInterface::OpenFile(const Url::Url &aRadioUrl)
         const char    *value;
         speed_t        speed;
         uint8_t        stopBit  = 1;
-        uint32_t       baudrate = 115200;
+        uint32_t       baudrate = 460800;
 
         VerifyOrExit((rval = tcgetattr(fd, &tios)) == 0);
 
diff --git a/src/posix/platform/infra_if.cpp b/src/posix/platform/infra_if.cpp
index e9aed0811..89b1f7bdf 100644
--- a/src/posix/platform/infra_if.cpp
+++ b/src/posix/platform/infra_if.cpp
@@ -57,10 +57,11 @@
 #include <openthread/border_router.h>
 #include <openthread/platform/infra_if.h>
 
+#include "infra_if.hpp"
+#include "utils.hpp"
 #include "common/code_utils.hpp"
 #include "common/debug.hpp"
 #include "lib/platform/exit_code.h"
-#include "posix/platform/infra_if.hpp"
 
 bool otPlatInfraIfHasAddress(uint32_t aInfraIfIndex, const otIp6Address *aAddress)
 {
@@ -101,10 +102,11 @@ otError otPlatInfraIfSendIcmp6Nd(uint32_t            aInfraIfIndex,
 }
 #endif
 
-#if OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE && OPENTHREAD_POSIX_CONFIG_NAT64_AIL_PREFIX_ENABLE
+#if OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE
 otError otPlatInfraIfDiscoverNat64Prefix(uint32_t aInfraIfIndex)
 {
-    return ot::Posix::InfraNetif::Get().DiscoverNat64Prefix(aInfraIfIndex);
+    OT_UNUSED_VARIABLE(aInfraIfIndex);
+    return OT_ERROR_NOT_IMPLEMENTED;
 }
 #endif
 
@@ -663,145 +665,6 @@ exit:
 }
 #endif // OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE
 
-#if OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE && OPENTHREAD_POSIX_CONFIG_NAT64_AIL_PREFIX_ENABLE
-const char         InfraNetif::kWellKnownIpv4OnlyName[]   = "ipv4only.arpa";
-const otIp4Address InfraNetif::kWellKnownIpv4OnlyAddress1 = {{{192, 0, 0, 170}}};
-const otIp4Address InfraNetif::kWellKnownIpv4OnlyAddress2 = {{{192, 0, 0, 171}}};
-const uint8_t      InfraNetif::kValidNat64PrefixLength[]  = {96, 64, 56, 48, 40, 32};
-
-#ifdef __linux__
-void InfraNetif::DiscoverNat64PrefixDone(union sigval sv)
-{
-    struct gaicb    *req = (struct gaicb *)sv.sival_ptr;
-    struct addrinfo *res = (struct addrinfo *)req->ar_result;
-
-    otIp6Prefix prefix = {};
-
-    VerifyOrExit((char *)req->ar_name == kWellKnownIpv4OnlyName);
-
-    LogInfo("Handling host address response for %s", kWellKnownIpv4OnlyName);
-
-    // We extract the first valid NAT64 prefix from the address look-up response.
-    for (struct addrinfo *rp = res; rp != NULL && prefix.mLength == 0; rp = rp->ai_next)
-    {
-        struct sockaddr_in6 *ip6Addr;
-        otIp6Address         ip6Address;
-
-        if (rp->ai_family != AF_INET6)
-        {
-            continue;
-        }
-
-        ip6Addr = reinterpret_cast<sockaddr_in6 *>(rp->ai_addr);
-        memcpy(&ip6Address.mFields.m8, &ip6Addr->sin6_addr.s6_addr, OT_IP6_ADDRESS_SIZE);
-        for (uint8_t length : kValidNat64PrefixLength)
-        {
-            otIp4Address ip4Address;
-
-            otIp4ExtractFromIp6Address(length, &ip6Address, &ip4Address);
-            if (otIp4IsAddressEqual(&ip4Address, &kWellKnownIpv4OnlyAddress1) ||
-                otIp4IsAddressEqual(&ip4Address, &kWellKnownIpv4OnlyAddress2))
-            {
-                // We check that the well-known IPv4 address is present only once in the IPv6 address.
-                // In case another instance of the value is found for another prefix length, we ignore this address
-                // and search for the other well-known IPv4 address (per RFC 7050 section 3).
-                bool foundDuplicate = false;
-
-                for (uint8_t dupLength : kValidNat64PrefixLength)
-                {
-                    otIp4Address dupIp4Address;
-
-                    if (dupLength == length)
-                    {
-                        continue;
-                    }
-
-                    otIp4ExtractFromIp6Address(dupLength, &ip6Address, &dupIp4Address);
-                    if (otIp4IsAddressEqual(&dupIp4Address, &ip4Address))
-                    {
-                        foundDuplicate = true;
-                        break;
-                    }
-                }
-
-                if (!foundDuplicate)
-                {
-                    otIp6GetPrefix(&ip6Address, length, &prefix);
-                    break;
-                }
-            }
-
-            if (prefix.mLength != 0)
-            {
-                break;
-            }
-        }
-    }
-
-#if OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE
-    otPlatInfraIfDiscoverNat64PrefixDone(gInstance, Get().mInfraIfIndex, &prefix);
-#endif
-
-exit:
-    freeaddrinfo(res);
-    freeaddrinfo((struct addrinfo *)req->ar_request);
-    free(req);
-}
-#endif // #ifdef __linux__
-
-otError InfraNetif::DiscoverNat64Prefix(uint32_t aInfraIfIndex)
-{
-#ifdef __linux__
-    otError          error   = OT_ERROR_NONE;
-    struct addrinfo *hints   = nullptr;
-    struct gaicb    *reqs[1] = {nullptr};
-    struct sigevent  sig;
-    int              status;
-
-    VerifyOrExit(aInfraIfIndex == mInfraIfIndex, error = OT_ERROR_DROP);
-    hints = (struct addrinfo *)malloc(sizeof(struct addrinfo));
-    VerifyOrExit(hints != nullptr, error = OT_ERROR_NO_BUFS);
-    memset(hints, 0, sizeof(struct addrinfo));
-    hints->ai_family   = AF_INET6;
-    hints->ai_socktype = SOCK_STREAM;
-
-    reqs[0] = (struct gaicb *)malloc(sizeof(struct gaicb));
-    VerifyOrExit(reqs[0] != nullptr, error = OT_ERROR_NO_BUFS);
-    memset(reqs[0], 0, sizeof(struct gaicb));
-    reqs[0]->ar_name    = kWellKnownIpv4OnlyName;
-    reqs[0]->ar_request = hints;
-
-    memset(&sig, 0, sizeof(struct sigevent));
-    sig.sigev_notify          = SIGEV_THREAD;
-    sig.sigev_value.sival_ptr = reqs[0];
-    sig.sigev_notify_function = &InfraNetif::DiscoverNat64PrefixDone;
-
-    status = getaddrinfo_a(GAI_NOWAIT, reqs, 1, &sig);
-
-    if (status != 0)
-    {
-        LogNote("getaddrinfo_a failed: %s", gai_strerror(status));
-        ExitNow(error = OT_ERROR_FAILED);
-    }
-    LogInfo("getaddrinfo_a requested for %s", kWellKnownIpv4OnlyName);
-exit:
-    if (error != OT_ERROR_NONE)
-    {
-        if (hints)
-        {
-            freeaddrinfo(hints);
-        }
-        free(reqs[0]);
-    }
-    return error;
-#else
-    OT_UNUSED_VARIABLE(aInfraIfIndex);
-
-    return OT_ERROR_NOT_IMPLEMENTED;
-#endif // #ifdef __linux__
-}
-#endif // OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE && OPENTHREAD_POSIX_CONFIG_NAT64_AIL_PREFIX_ENABLE
-
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE
 void InfraNetif::SetInfraNetifIcmp6SocketForBorderRouting(int aIcmp6Socket)
 {
diff --git a/src/posix/platform/infra_if.hpp b/src/posix/platform/infra_if.hpp
index 88771b964..c36ff1d9a 100644
--- a/src/posix/platform/infra_if.hpp
+++ b/src/posix/platform/infra_if.hpp
@@ -161,19 +161,6 @@ public:
                         const uint8_t      *aBuffer,
                         uint16_t            aBufferLength);
 
-#if OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE && OPENTHREAD_POSIX_CONFIG_NAT64_AIL_PREFIX_ENABLE
-    /**
-     * Sends an asynchronous address lookup for the well-known host name "ipv4only.arpa"
-     * to discover the NAT64 prefix.
-     *
-     * @param[in]  aInfraIfIndex  The index of the infrastructure interface the address look-up is sent to.
-     *
-     * @retval  OT_ERROR_NONE    Successfully request address look-up.
-     * @retval  OT_ERROR_FAILED  Failed to request address look-up.
-     */
-    otError DiscoverNat64Prefix(uint32_t aInfraIfIndex);
-#endif
-
     /**
      * Gets the infrastructure network interface name.
      *
@@ -230,12 +217,6 @@ private:
     void ReceiveNetLinkMessage(void);
 #endif
 
-#if OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE && OPENTHREAD_POSIX_CONFIG_NAT64_AIL_PREFIX_ENABLE
-#ifdef __linux__
-    static void DiscoverNat64PrefixDone(union sigval sv);
-#endif // #ifdef __linux__
-#endif
-
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE
     void SetInfraNetifIcmp6SocketForBorderRouting(int aIcmp6Socket);
     void ReceiveIcmp6Message(void);
diff --git a/src/posix/platform/misc.cpp b/src/posix/platform/misc.cpp
index 7e2a82e4d..2550c122c 100644
--- a/src/posix/platform/misc.cpp
+++ b/src/posix/platform/misc.cpp
@@ -95,29 +95,3 @@ otPlatMcuPowerState otPlatGetMcuPowerState(otInstance *aInstance)
 
     return gPlatMcuPowerState;
 }
-
-int SocketWithCloseExec(int aDomain, int aType, int aProtocol, SocketBlockOption aBlockOption)
-{
-    int rval = 0;
-    int fd   = -1;
-
-#ifdef __APPLE__
-    VerifyOrExit((fd = socket(aDomain, aType, aProtocol)) != -1, perror("socket(SOCK_CLOEXEC)"));
-
-    VerifyOrExit((rval = fcntl(fd, F_GETFD, 0)) != -1, perror("fcntl(F_GETFD)"));
-    rval |= aBlockOption == kSocketNonBlock ? O_NONBLOCK | FD_CLOEXEC : FD_CLOEXEC;
-    VerifyOrExit((rval = fcntl(fd, F_SETFD, rval)) != -1, perror("fcntl(F_SETFD)"));
-#else
-    aType |= aBlockOption == kSocketNonBlock ? SOCK_CLOEXEC | SOCK_NONBLOCK : SOCK_CLOEXEC;
-    VerifyOrExit((fd = socket(aDomain, aType, aProtocol)) != -1, perror("socket(SOCK_CLOEXEC)"));
-#endif
-
-exit:
-    if (rval == -1)
-    {
-        VerifyOrDie(close(fd) == 0, OT_EXIT_ERROR_ERRNO);
-        fd = -1;
-    }
-
-    return fd;
-}
diff --git a/src/posix/platform/multicast_routing.cpp b/src/posix/platform/multicast_routing.cpp
index 35d7bffb1..07a00664e 100644
--- a/src/posix/platform/multicast_routing.cpp
+++ b/src/posix/platform/multicast_routing.cpp
@@ -48,6 +48,7 @@
 #include <openthread/backbone_router_ftd.h>
 #include <openthread/logging.h>
 
+#include "utils.hpp"
 #include "common/arg_macros.hpp"
 #include "core/common/debug.hpp"
 
diff --git a/src/posix/platform/netif.cpp b/src/posix/platform/netif.cpp
index f8524216c..1fb3fa0bc 100644
--- a/src/posix/platform/netif.cpp
+++ b/src/posix/platform/netif.cpp
@@ -72,6 +72,7 @@
 #include <fcntl.h>
 #include <ifaddrs.h>
 #ifdef __linux__
+#include <linux/if_addr.h>
 #include <linux/if_link.h>
 #include <linux/if_tun.h>
 #include <linux/netlink.h>
@@ -154,6 +155,7 @@ extern int
 #include "ip6_utils.hpp"
 #include "logger.hpp"
 #include "resolver.hpp"
+#include "utils.hpp"
 #include "common/code_utils.hpp"
 
 unsigned int gNetifIndex = 0;
@@ -432,6 +434,7 @@ static void UpdateUnicastLinux(otInstance *aInstance, const otIp6AddressInfo &aA
 {
     OT_UNUSED_VARIABLE(aInstance);
 
+    static constexpr uint8_t kLinkLocalScope = 2;
     struct
     {
         struct nlmsghdr  nh;
@@ -455,7 +458,7 @@ static void UpdateUnicastLinux(otInstance *aInstance, const otIp6AddressInfo &aA
 
     AddRtAttr(&req.nh, sizeof(req), IFA_LOCAL, aAddressInfo.mAddress, sizeof(*aAddressInfo.mAddress));
 
-    if (!aAddressInfo.mPreferred || aAddressInfo.mMeshLocal)
+    if (!aAddressInfo.mPreferred || aAddressInfo.mMeshLocal || aAddressInfo.mScope == kLinkLocalScope)
     {
         struct ifa_cacheinfo cacheinfo;
 
@@ -478,12 +481,22 @@ static void UpdateUnicastLinux(otInstance *aInstance, const otIp6AddressInfo &aA
     else
 #endif
     {
-#if OPENTHREAD_POSIX_CONFIG_NETIF_PREFIX_ROUTE_METRIC > 0
-        static constexpr uint8_t kLinkLocalScope = 2;
+        uint32_t route_metric = 0;
+        OT_UNUSED_VARIABLE(route_metric);
 
-        if (aAddressInfo.mScope > kLinkLocalScope)
+        if (aAddressInfo.mScope == kLinkLocalScope)
         {
-            AddRtAttrUint32(&req.nh, sizeof(req), IFA_RT_PRIORITY, OPENTHREAD_POSIX_CONFIG_NETIF_PREFIX_ROUTE_METRIC);
+            route_metric = OPENTHREAD_POSIX_CONFIG_NETIF_LINK_LOCAL_ROUTE_METRIC;
+        }
+        else if (aAddressInfo.mScope > kLinkLocalScope)
+        {
+            route_metric = OPENTHREAD_POSIX_CONFIG_NETIF_PREFIX_ROUTE_METRIC;
+        }
+
+#if OPENTHREAD_POSIX_CONFIG_NETIF_LINK_LOCAL_ROUTE_METRIC || OPENTHREAD_POSIX_CONFIG_NETIF_PREFIX_ROUTE_METRIC
+        if (route_metric > 0)
+        {
+            AddRtAttrUint32(&req.nh, sizeof(req), IFA_RT_PRIORITY, route_metric);
         }
 #endif
     }
@@ -1874,7 +1887,7 @@ static void mldListenerInit(void)
 {
     struct ipv6_mreq mreq6;
 
-    sMLDMonitorFd = SocketWithCloseExec(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6, kSocketNonBlock);
+    sMLDMonitorFd = ot::Posix::SocketWithCloseExec(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6, ot::Posix::kSocketNonBlock);
     VerifyOrDie(sMLDMonitorFd != -1, OT_EXIT_FAILURE);
 
     mreq6.ipv6mr_interface = gNetifIndex;
@@ -2067,7 +2080,7 @@ static void platformConfigureTunDevice(otPlatformConfig *aPlatformConfig)
     struct sockaddr_ctl addr;
     struct ctl_info     info;
 
-    sTunFd = SocketWithCloseExec(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL, kSocketNonBlock);
+    sTunFd = ot::Posix::SocketWithCloseExec(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL, ot::Posix::kSocketNonBlock);
     VerifyOrDie(sTunFd >= 0, OT_EXIT_ERROR_ERRNO);
 
     memset(&info, 0, sizeof(info));
@@ -2146,9 +2159,9 @@ static void platformConfigureTunDevice(otPlatformConfig *aPlatformConfig)
 static void platformConfigureNetLink(void)
 {
 #ifdef __linux__
-    sNetlinkFd = SocketWithCloseExec(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE, kSocketNonBlock);
+    sNetlinkFd = ot::Posix::SocketWithCloseExec(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE, ot::Posix::kSocketNonBlock);
 #elif defined(__APPLE__) || defined(__NetBSD__) || defined(__FreeBSD__)
-    sNetlinkFd = SocketWithCloseExec(PF_ROUTE, SOCK_RAW, 0, kSocketNonBlock);
+    sNetlinkFd = ot::Posix::SocketWithCloseExec(PF_ROUTE, SOCK_RAW, 0, ot::Posix::kSocketNonBlock);
 #else
 #error "!! Unknown platform !!"
 #endif
@@ -2219,7 +2232,7 @@ void platformNetifInit(otPlatformConfig *aPlatformConfig)
     (void)LogNote;
     (void)LogDebg;
 
-    sIpFd = SocketWithCloseExec(AF_INET6, SOCK_DGRAM, IPPROTO_IP, kSocketNonBlock);
+    sIpFd = ot::Posix::SocketWithCloseExec(AF_INET6, SOCK_DGRAM, IPPROTO_IP, ot::Posix::kSocketNonBlock);
     VerifyOrDie(sIpFd >= 0, OT_EXIT_ERROR_ERRNO);
 
     platformConfigureNetLink();
diff --git a/src/posix/platform/openthread-core-posix-config.h b/src/posix/platform/openthread-core-posix-config.h
index 582117494..352646a1c 100644
--- a/src/posix/platform/openthread-core-posix-config.h
+++ b/src/posix/platform/openthread-core-posix-config.h
@@ -136,12 +136,8 @@
 #define OPENTHREAD_CONFIG_CLI_UART_RX_BUFFER_SIZE 640
 #endif
 
-#ifndef OPENTHREAD_CONFIG_UPTIME_ENABLE
-#define OPENTHREAD_CONFIG_UPTIME_ENABLE !OPENTHREAD_CONFIG_MULTIPLE_INSTANCE_ENABLE
-#endif
-
 #ifndef OPENTHREAD_CONFIG_LOG_PREPEND_UPTIME
-#define OPENTHREAD_CONFIG_LOG_PREPEND_UPTIME 1
+#define OPENTHREAD_CONFIG_LOG_PREPEND_UPTIME !OPENTHREAD_CONFIG_MULTIPLE_INSTANCE_ENABLE
 #endif
 
 #ifndef OPENTHREAD_CONFIG_SRP_CLIENT_BUFFERS_MAX_SERVICES
diff --git a/src/posix/platform/openthread-posix-config.h b/src/posix/platform/openthread-posix-config.h
index 1e85bd5d0..c1955ae9a 100644
--- a/src/posix/platform/openthread-posix-config.h
+++ b/src/posix/platform/openthread-posix-config.h
@@ -140,11 +140,23 @@
 #define OPENTHREAD_POSIX_CONFIG_SECURE_SETTINGS_ENABLE 0
 #endif
 
+/**
+ * @def OPENTHREAD_POSIX_CONFIG_NETIF_LINK_LOCAL_ROUTE_METRIC
+ *
+ * This setting configures the link-local route metric on the Thread network interface.
+ * Define as 0 to use the default prefix route metric.
+ *
+ * Note: The feature works on Linux kernel v4.18+.
+ */
+#ifndef OPENTHREAD_POSIX_CONFIG_NETIF_LINK_LOCAL_ROUTE_METRIC
+#define OPENTHREAD_POSIX_CONFIG_NETIF_LINK_LOCAL_ROUTE_METRIC 0
+#endif
+
 /**
  * @def OPENTHREAD_POSIX_CONFIG_NETIF_PREFIX_ROUTE_METRIC
  *
- * This setting configures the prefix route metric on the Thread network interface.
- * Define as 0 to use use the default prefix route metric.
+ * This setting configures the non-link-local prefix route metric on the Thread network interface.
+ * Define as 0 to use the default prefix route metric.
  *
  * Note: The feature works on Linux kernel v4.18+.
  */
@@ -256,6 +268,15 @@
 #define OPENTHREAD_POSIX_CONFIG_THREAD_NETIF_DEFAULT_NAME "wpan0"
 #endif
 
+/**
+ * @def OPENTHREAD_POSIX_VIRTUAL_TIME
+ *
+ * This setting configures whether to use virtual time.
+ */
+#ifndef OPENTHREAD_POSIX_VIRTUAL_TIME
+#define OPENTHREAD_POSIX_VIRTUAL_TIME 0
+#endif
+
 #ifdef __APPLE__
 
 /**
@@ -279,17 +300,6 @@
 
 #endif // __APPLE__
 
-//---------------------------------------------------------------------------------------------------------------------
-// Removed or renamed POSIX specific configs.
-
-#ifdef OPENTHREAD_CONFIG_POSIX_APP_TREL_INTERFACE_NAME
-#error "OPENTHREAD_CONFIG_POSIX_APP_TREL_INTERFACE_NAME was removed (no longer applicable with TREL over DNS-SD)."
-#endif
-
-#ifdef OPENTHREAD_CONFIG_POSIX_TREL_USE_NETLINK_SOCKET
-#error "OPENTHREAD_CONFIG_POSIX_TREL_USE_NETLINK_SOCKET was removed (no longer applicable with TREL over DNS-SD)."
-#endif
-
 /**
  * @def OPENTHREAD_POSIX_CONFIG_TREL_UDP_PORT
  *
@@ -435,4 +445,24 @@
 #define OPENTHREAD_POSIX_CONFIG_TMP_STORAGE_ENABLE 1
 #endif
 
+/**
+ * @def OPENTHREAD_POSIX_CONFIG_RESOLV_CONF_ENABLED_INIT
+ *
+ * Define as 1 to enable reading from resolv.conf on initialization.
+ */
+#ifndef OPENTHREAD_POSIX_CONFIG_RESOLV_CONF_ENABLED_INIT
+#define OPENTHREAD_POSIX_CONFIG_RESOLV_CONF_ENABLED_INIT (!OPENTHREAD_POSIX_CONFIG_ANDROID_ENABLE)
+#endif
+
+//---------------------------------------------------------------------------------------------------------------------
+// Removed or renamed POSIX specific configs.
+
+#ifdef OPENTHREAD_CONFIG_POSIX_APP_TREL_INTERFACE_NAME
+#error "OPENTHREAD_CONFIG_POSIX_APP_TREL_INTERFACE_NAME was removed (no longer applicable with TREL over DNS-SD)."
+#endif
+
+#ifdef OPENTHREAD_CONFIG_POSIX_TREL_USE_NETLINK_SOCKET
+#error "OPENTHREAD_CONFIG_POSIX_TREL_USE_NETLINK_SOCKET was removed (no longer applicable with TREL over DNS-SD)."
+#endif
+
 #endif // OPENTHREAD_PLATFORM_POSIX_CONFIG_H_
diff --git a/src/posix/platform/platform-posix.h b/src/posix/platform/platform-posix.h
index 606dc86f0..d437b1fcf 100644
--- a/src/posix/platform/platform-posix.h
+++ b/src/posix/platform/platform-posix.h
@@ -56,15 +56,6 @@
 #include "lib/spinel/coprocessor_type.h"
 #include "lib/url/url.hpp"
 
-/**
- * @def OPENTHREAD_POSIX_VIRTUAL_TIME
- *
- * This setting configures whether to use virtual time.
- */
-#ifndef OPENTHREAD_POSIX_VIRTUAL_TIME
-#define OPENTHREAD_POSIX_VIRTUAL_TIME 0
-#endif
-
 /**
  * This is the socket name used by daemon mode.
  */
@@ -351,20 +342,6 @@ void platformTrelUpdateFdSet(otSysMainloopContext *aContext);
  */
 void platformTrelProcess(otInstance *aInstance, const otSysMainloopContext *aContext);
 
-/**
- * Creates a socket with SOCK_CLOEXEC flag set.
- *
- * @param[in]   aDomain       The communication domain.
- * @param[in]   aType         The semantics of communication.
- * @param[in]   aProtocol     The protocol to use.
- * @param[in]   aBlockOption  Whether to add nonblock flags.
- *
- * @returns The file descriptor of the created socket.
- *
- * @retval  -1  Failed to create socket.
- */
-int SocketWithCloseExec(int aDomain, int aType, int aProtocol, SocketBlockOption aBlockOption);
-
 /**
  * The name of Thread network interface.
  */
@@ -421,6 +398,15 @@ void platformSpinelManagerUpdateFdSet(otSysMainloopContext *aContext);
  */
 void platformResolverInit(void);
 
+/**
+ * Sets up platform resolver.
+ *
+ * @note This function is called after OpenThread instance is created.
+ *
+ * @param[in]   aInstance       A pointer to the OpenThread instance.
+ */
+void platformResolverSetUp(void);
+
 /**
  * Updates the file descriptor sets with file descriptors used by the resolver.
  *
@@ -435,6 +421,13 @@ void platformResolverUpdateFdSet(otSysMainloopContext *aContext);
  */
 void platformResolverProcess(const otSysMainloopContext *aContext);
 
+/**
+ * The callback for coprocessor reset failure.
+ *
+ * @param[in]  aContext  A pointer to the mainloop context.
+ */
+void platformCoprocessorResetFailed(void *aContext);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/posix/platform/radio.cpp b/src/posix/platform/radio.cpp
index ea9cd350f..3e98998ef 100644
--- a/src/posix/platform/radio.cpp
+++ b/src/posix/platform/radio.cpp
@@ -73,6 +73,10 @@ Radio::Radio(void)
 {
 }
 
+#if OPENTHREAD_SPINEL_CONFIG_COPROCESSOR_RESET_FAILURE_CALLBACK_ENABLE
+OT_TOOL_WEAK void platformCoprocessorResetFailed(void *) {}
+#endif
+
 void Radio::Init(const char *aUrl)
 {
     bool resetRadio;
@@ -107,6 +111,10 @@ void Radio::Init(const char *aUrl)
     resetRadio             = !mRadioUrl.HasParam("no-reset");
     skipCompatibilityCheck = mRadioUrl.HasParam("skip-rcp-compatibility-check");
 
+#if OPENTHREAD_SPINEL_CONFIG_COPROCESSOR_RESET_FAILURE_CALLBACK_ENABLE
+    GetSpinelDriver().SetCoprocessorResetFailureCallback(platformCoprocessorResetFailed, this);
+#endif
+
     mRadioSpinel.SetCallbacks(callbacks);
     mRadioSpinel.Init(skipCompatibilityCheck, resetRadio, &GetSpinelDriver(),
                       (skipCompatibilityCheck ? 0 : kRequiredRadioCaps), aEnableRcpTimeSync);
diff --git a/src/posix/platform/radio_url.cpp b/src/posix/platform/radio_url.cpp
index e86990bd7..aef8f5b7e 100644
--- a/src/posix/platform/radio_url.cpp
+++ b/src/posix/platform/radio_url.cpp
@@ -81,7 +81,7 @@ const char *otSysGetRadioUrlHelpString(void)
     "Parameters:\n"                                                                                  \
     "    uart-parity[=even|odd]         Uart parity config, optional.\n"                             \
     "    uart-stop[=number-of-bits]     Uart stop bit, default is 1.\n"                              \
-    "    uart-baudrate[=baudrate]       Uart baud rate, default is 115200.\n"                        \
+    "    uart-baudrate[=baudrate]       Uart baud rate, default is 460800.\n"                        \
     "    uart-flow-control              Enable flow control, disabled by default.\n"                 \
     "    uart-init-deassert             Deassert lines on init when flow control is disabled.\n"     \
     "    uart-reset                     Reset connection after hard resetting RCP(USB CDC ACM).\n"   \
diff --git a/src/posix/platform/resolver.cpp b/src/posix/platform/resolver.cpp
index 0e16e6fab..ffd74ec51 100644
--- a/src/posix/platform/resolver.cpp
+++ b/src/posix/platform/resolver.cpp
@@ -27,9 +27,11 @@
  */
 
 #include "resolver.hpp"
+#include "ip6_utils.hpp"
 
 #include "platform-posix.h"
 
+#include <openthread/border_routing.h>
 #include <openthread/logging.h>
 #include <openthread/message.h>
 #include <openthread/nat64.h>
@@ -39,6 +41,7 @@
 #include <openthread/platform/time.h>
 
 #include "common/code_utils.hpp"
+#include "common/debug.hpp"
 
 #include <arpa/inet.h>
 #include <arpa/nameser.h>
@@ -48,11 +51,14 @@
 #include <sys/socket.h>
 #include <unistd.h>
 
+#include <algorithm>
 #include <fstream>
 #include <string>
 
 #if OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE
 
+using namespace ot::Posix::Ip6Utils;
+
 namespace {
 constexpr char kResolvConfFullPath[] = "/etc/resolv.conf";
 constexpr char kNameserverItem[]     = "nameserver";
@@ -71,6 +77,15 @@ void Resolver::Init(void)
     LoadDnsServerListFromConf();
 }
 
+void Resolver::Setup(void)
+{
+    OT_ASSERT(gInstance != nullptr);
+
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE
+    otBorderRoutingSetRdnssAddrCallback(gInstance, &Resolver::BorderRoutingRdnssCallback, this);
+#endif
+}
+
 void Resolver::TryRefreshDnsServerList(void)
 {
     uint64_t now = otPlatTimeGet();
@@ -82,10 +97,19 @@ void Resolver::TryRefreshDnsServerList(void)
     }
 }
 
+bool Resolver::IsUpstreamQueryAvailable(void)
+{
+    TryRefreshDnsServerList();
+
+    return mUpstreamDnsServerCount + mRecursiveDnsServerCount > 0;
+}
+
 void Resolver::LoadDnsServerListFromConf(void)
 {
     std::string   line;
     std::ifstream fp;
+    otIp4Address  ip4Address;
+    otIp6Address  ip6Address;
 
     VerifyOrExit(mIsResolvConfEnabled);
 
@@ -95,17 +119,26 @@ void Resolver::LoadDnsServerListFromConf(void)
 
     while (fp.good() && std::getline(fp, line) && mUpstreamDnsServerCount < kMaxUpstreamServerCount)
     {
-        if (line.find(kNameserverItem, 0) == 0)
+        const char *addressString = &line.c_str()[sizeof(kNameserverItem)];
+
+        // Skip the lines that don't start with "nameserver"
+        if (line.find(kNameserverItem, 0))
         {
-            in_addr_t addr;
+            continue;
+        }
 
-            if (inet_pton(AF_INET, &line.c_str()[sizeof(kNameserverItem)], &addr) == 1)
-            {
-                LogInfo("Got nameserver #%d: %s", mUpstreamDnsServerCount, &line.c_str()[sizeof(kNameserverItem)]);
-                mUpstreamDnsServerList[mUpstreamDnsServerCount] = addr;
-                mUpstreamDnsServerCount++;
-            }
+        if (inet_pton(AF_INET, addressString, &ip4Address) == 1)
+        {
+            otIp4ToIp4MappedIp6Address(&ip4Address, &ip6Address);
+        }
+        else if (inet_pton(AF_INET6, addressString, &ip6Address) != 1)
+        {
+            continue;
         }
+
+        LogInfo("Got nameserver #%u: %s", mUpstreamDnsServerCount, addressString);
+        mUpstreamDnsServerList[mUpstreamDnsServerCount] = ip6Address;
+        mUpstreamDnsServerCount++;
     }
 
     if (mUpstreamDnsServerCount == 0)
@@ -118,40 +151,161 @@ exit:
     return;
 }
 
-void Resolver::Query(otPlatDnsUpstreamQuery *aTxn, const otMessage *aQuery)
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE
+void Resolver::BorderRoutingRdnssCallback(void *aResolver)
+{
+    static_cast<Resolver *>(aResolver)->BorderRoutingRdnssCallback();
+}
+
+void Resolver::BorderRoutingRdnssCallback(void)
+{
+    otBorderRoutingPrefixTableIterator iterator;
+    otBorderRoutingRdnssAddrEntry      entry;
+    otBorderRoutingRdnssAddrEntry      rdnssEntries[kMaxRecursiveServerCount + 1];
+    otIp6Address                       rdnssServers[kMaxRecursiveServerCount];
+    uint32_t                           numEntries = 0;
+
+    otBorderRoutingPrefixTableInitIterator(gInstance, &iterator);
+
+    while (otBorderRoutingGetNextRdnssAddrEntry(gInstance, &iterator, &entry) == OT_ERROR_NONE)
+    {
+        uint32_t i = 0;
+
+        // Check if the entry address is already in the list.
+        for (; i < numEntries; ++i)
+        {
+            if (otIp6IsAddressEqual(&entry.mAddress, &rdnssEntries[i].mAddress))
+            {
+                rdnssEntries[i].mLifetime = OT_MAX(rdnssEntries[i].mLifetime, entry.mLifetime);
+
+                break;
+            }
+        }
+
+        // If the address is not a duplicate, add the entry to the entry list.
+        if (i == numEntries)
+        {
+            rdnssEntries[numEntries++] = entry;
+
+            std::sort(rdnssEntries, rdnssEntries + numEntries,
+                      [](const otBorderRoutingRdnssAddrEntry &a, const otBorderRoutingRdnssAddrEntry &b) {
+                          bool result = false;
+
+                          if (a.mLifetime != b.mLifetime)
+                          {
+                              result = a.mLifetime > b.mLifetime;
+                          }
+                          else
+                          {
+                              // If lifetimes are equal, prefer the one with the larger numeric values
+                              for (uint8_t j = 0; j < sizeof(otIp6Address); j++)
+                              {
+                                  if (a.mAddress.mFields.m8[j] != b.mAddress.mFields.m8[j])
+                                  {
+                                      result = a.mAddress.mFields.m8[j] > b.mAddress.mFields.m8[j];
+                                      break;
+                                  }
+                              }
+                          }
+
+                          return result;
+                      });
+
+            numEntries = OT_MIN(numEntries, kMaxRecursiveServerCount);
+        }
+    }
+
+    for (uint32_t i = 0; i < numEntries; i++)
+    {
+        rdnssServers[i] = rdnssEntries[i].mAddress;
+    }
+
+    SetRecursiveDnsServerList(rdnssServers, numEntries);
+}
+#endif // OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE
+
+otError Resolver::SendQueryToServer(Transaction        *aTxn,
+                                    const otIp6Address &aServerAddress,
+                                    const char         *aPacket,
+                                    uint16_t            aLength)
 {
-    char        packet[kMaxDnsMessageSize];
-    otError     error  = OT_ERROR_NONE;
-    uint16_t    length = otMessageGetLength(aQuery);
-    sockaddr_in serverAddr;
+    otError      error = OT_ERROR_NONE;
+    otIp4Address ip4Addr;
+    sockaddr_in  serverAddr4;
+    sockaddr_in6 serverAddr6;
+
+    if (otIp4FromIp4MappedIp6Address(&aServerAddress, &ip4Addr) == OT_ERROR_NONE)
+    {
+        memcpy(&serverAddr4.sin_addr.s_addr, &ip4Addr, sizeof(otIp4Address));
+        serverAddr4.sin_family = AF_INET;
+        serverAddr4.sin_port   = htons(53);
+
+        VerifyOrExit(sendto(aTxn->mUdpFd4, aPacket, aLength, MSG_DONTWAIT, reinterpret_cast<sockaddr *>(&serverAddr4),
+                            sizeof(serverAddr4)) > 0,
+                     error = OT_ERROR_NO_ROUTE);
+    }
+    else
+    {
+        memcpy(&serverAddr6.sin6_addr, &aServerAddress, sizeof(otIp6Address));
+        serverAddr6.sin6_family = AF_INET6;
+        serverAddr6.sin6_port   = htons(53);
 
-    Transaction *txn = nullptr;
+        VerifyOrExit(sendto(aTxn->mUdpFd6, aPacket, aLength, MSG_DONTWAIT, reinterpret_cast<sockaddr *>(&serverAddr6),
+                            sizeof(serverAddr6)) > 0,
+                     error = OT_ERROR_NO_ROUTE);
+    }
+
+    LogInfo("Forwarded DNS query %p to %s", static_cast<void *>(aTxn), Ip6AddressString(&aServerAddress).AsCString());
+
+exit:
+    return error;
+}
+
+void Resolver::Query(otPlatDnsUpstreamQuery *aTxn, const otMessage *aQuery)
+{
+    char         packet[kMaxDnsMessageSize];
+    otError      error       = OT_ERROR_NONE;
+    uint16_t     length      = otMessageGetLength(aQuery);
+    uint32_t     serverCount = 0;
+    Transaction *txn         = nullptr;
 
     VerifyOrExit(length <= kMaxDnsMessageSize, error = OT_ERROR_NO_BUFS);
     VerifyOrExit(otMessageRead(aQuery, 0, &packet, sizeof(packet)) == length, error = OT_ERROR_NO_BUFS);
 
     txn = AllocateTransaction(aTxn);
     VerifyOrExit(txn != nullptr, error = OT_ERROR_NO_BUFS);
-
     TryRefreshDnsServerList();
 
-    serverAddr.sin_family = AF_INET;
-    serverAddr.sin_port   = htons(53);
-    for (int i = 0; i < mUpstreamDnsServerCount; i++)
+    for (uint32_t i = 0; i < mRecursiveDnsServerCount; i++)
+    {
+        if (SendQueryToServer(txn, mRecursiveDnsServerList[i], packet, length) == OT_ERROR_NONE)
+        {
+            serverCount++;
+        }
+    }
+
+    for (uint32_t i = 0; i < mUpstreamDnsServerCount; i++)
     {
-        serverAddr.sin_addr.s_addr = mUpstreamDnsServerList[i];
-        VerifyOrExit(
-            sendto(txn->mUdpFd, packet, length, MSG_DONTWAIT, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) > 0,
-            error = OT_ERROR_NO_ROUTE);
+        if (SendQueryToServer(txn, mUpstreamDnsServerList[i], packet, length) == OT_ERROR_NONE)
+        {
+            serverCount++;
+        }
     }
-    LogInfo("Forwarded DNS query %p to %d server(s).", static_cast<void *>(aTxn), mUpstreamDnsServerCount);
+
+    VerifyOrExit(serverCount > 0, error = OT_ERROR_NO_ROUTE);
+
+    LogInfo("Forwarded DNS query %p to %u server(s).", static_cast<void *>(aTxn), serverCount);
 
 exit:
     if (error != OT_ERROR_NONE)
     {
-        LogCrit("Failed to forward DNS query %p to server: %d", static_cast<void *>(aTxn), error);
+        LogWarn("Failed to forward DNS query %p to server: %s", static_cast<void *>(aTxn),
+                otThreadErrorToString(error));
+        if (txn != nullptr)
+        {
+            CloseTransaction(txn);
+        }
     }
-    return;
 }
 
 void Resolver::Cancel(otPlatDnsUpstreamQuery *aTxn)
@@ -168,21 +322,31 @@ void Resolver::Cancel(otPlatDnsUpstreamQuery *aTxn)
 
 Resolver::Transaction *Resolver::AllocateTransaction(otPlatDnsUpstreamQuery *aThreadTxn)
 {
-    int          fdOrError = 0;
-    Transaction *ret       = nullptr;
+    int          fd4OrError = 0;
+    int          fd6OrError = 0;
+    Transaction *ret        = nullptr;
 
     for (Transaction &txn : mUpstreamTransaction)
     {
         if (txn.mThreadTxn == nullptr)
         {
-            fdOrError = CreateUdpSocket();
-            if (fdOrError < 0)
+            fd4OrError = CreateUdpSocket(AF_INET);
+            if (fd4OrError < 0)
             {
-                LogInfo("Failed to create socket for upstream resolver: %d", fdOrError);
+                LogInfo("Failed to create socket for upstream resolver: %d", fd4OrError);
                 break;
             }
+
+            fd6OrError = CreateUdpSocket(AF_INET6);
+            if (fd6OrError < 0)
+            {
+                LogInfo("Failed to create socket for upstream resolver: %d", fd6OrError);
+                break;
+            }
+
             ret             = &txn;
-            ret->mUdpFd     = fdOrError;
+            ret->mUdpFd4    = fd4OrError;
+            ret->mUdpFd6    = fd6OrError;
             ret->mThreadTxn = aThreadTxn;
             break;
         }
@@ -191,20 +355,20 @@ Resolver::Transaction *Resolver::AllocateTransaction(otPlatDnsUpstreamQuery *aTh
     return ret;
 }
 
-void Resolver::ForwardResponse(Transaction *aTxn)
+void Resolver::ForwardResponse(otPlatDnsUpstreamQuery *aThreadTxn, int aFd)
 {
     char       response[kMaxDnsMessageSize];
     ssize_t    readSize;
     otError    error   = OT_ERROR_NONE;
     otMessage *message = nullptr;
 
-    VerifyOrExit((readSize = read(aTxn->mUdpFd, response, sizeof(response))) > 0);
+    VerifyOrExit((readSize = read(aFd, response, sizeof(response))) > 0);
 
     message = otUdpNewMessage(gInstance, nullptr);
     VerifyOrExit(message != nullptr, error = OT_ERROR_NO_BUFS);
     SuccessOrExit(error = otMessageAppend(message, response, readSize));
 
-    otPlatDnsUpstreamQueryDone(gInstance, aTxn->mThreadTxn, message);
+    otPlatDnsUpstreamQueryDone(gInstance, aThreadTxn, message);
     message = nullptr;
 
 exit:
@@ -222,22 +386,6 @@ exit:
     }
 }
 
-Resolver::Transaction *Resolver::GetTransaction(int aFd)
-{
-    Transaction *ret = nullptr;
-
-    for (Transaction &txn : mUpstreamTransaction)
-    {
-        if (txn.mThreadTxn != nullptr && txn.mUdpFd == aFd)
-        {
-            ret = &txn;
-            break;
-        }
-    }
-
-    return ret;
-}
-
 Resolver::Transaction *Resolver::GetTransaction(otPlatDnsUpstreamQuery *aThreadTxn)
 {
     Transaction *ret = nullptr;
@@ -256,10 +404,15 @@ Resolver::Transaction *Resolver::GetTransaction(otPlatDnsUpstreamQuery *aThreadT
 
 void Resolver::CloseTransaction(Transaction *aTxn)
 {
-    if (aTxn->mUdpFd >= 0)
+    if (aTxn->mUdpFd4 >= 0)
+    {
+        close(aTxn->mUdpFd4);
+        aTxn->mUdpFd4 = -1;
+    }
+    if (aTxn->mUdpFd6 >= 0)
     {
-        close(aTxn->mUdpFd);
-        aTxn->mUdpFd = -1;
+        close(aTxn->mUdpFd6);
+        aTxn->mUdpFd6 = -1;
     }
     aTxn->mThreadTxn = nullptr;
 }
@@ -270,11 +423,18 @@ void Resolver::UpdateFdSet(otSysMainloopContext &aContext)
     {
         if (txn.mThreadTxn != nullptr)
         {
-            FD_SET(txn.mUdpFd, &aContext.mReadFdSet);
-            FD_SET(txn.mUdpFd, &aContext.mErrorFdSet);
-            if (txn.mUdpFd > aContext.mMaxFd)
+            FD_SET(txn.mUdpFd4, &aContext.mReadFdSet);
+            FD_SET(txn.mUdpFd4, &aContext.mErrorFdSet);
+            FD_SET(txn.mUdpFd6, &aContext.mReadFdSet);
+            FD_SET(txn.mUdpFd6, &aContext.mErrorFdSet);
+
+            if (txn.mUdpFd6 > aContext.mMaxFd)
+            {
+                aContext.mMaxFd = txn.mUdpFd6;
+            }
+            if (txn.mUdpFd4 > aContext.mMaxFd)
             {
-                aContext.mMaxFd = txn.mUdpFd;
+                aContext.mMaxFd = txn.mUdpFd4;
             }
         }
     }
@@ -287,38 +447,42 @@ void Resolver::Process(const otSysMainloopContext &aContext)
         if (txn.mThreadTxn != nullptr)
         {
             // Note: On Linux, we can only get the error via read, so they should share the same logic.
-            if (FD_ISSET(txn.mUdpFd, &aContext.mErrorFdSet) || FD_ISSET(txn.mUdpFd, &aContext.mReadFdSet))
+            if (FD_ISSET(txn.mUdpFd4, &aContext.mErrorFdSet) || FD_ISSET(txn.mUdpFd4, &aContext.mReadFdSet))
             {
-                ForwardResponse(&txn);
+                ForwardResponse(txn.mThreadTxn, txn.mUdpFd4);
+                CloseTransaction(&txn);
+            }
+            else if (FD_ISSET(txn.mUdpFd6, &aContext.mErrorFdSet) || FD_ISSET(txn.mUdpFd6, &aContext.mReadFdSet))
+            {
+                ForwardResponse(txn.mThreadTxn, txn.mUdpFd6);
                 CloseTransaction(&txn);
             }
         }
     }
 }
 
-void Resolver::SetUpstreamDnsServers(const otIp6Address *aUpstreamDnsServers, int aNumServers)
+void Resolver::SetUpstreamDnsServers(const otIp6Address *aUpstreamDnsServers, uint32_t aNumServers)
 {
-    mUpstreamDnsServerCount = 0;
+    mUpstreamDnsServerCount = OT_MIN(aNumServers, static_cast<uint32_t>(kMaxUpstreamServerCount));
+    memcpy(mUpstreamDnsServerList, aUpstreamDnsServers, mUpstreamDnsServerCount * sizeof(otIp6Address));
 
-    for (int i = 0; i < aNumServers && i < kMaxUpstreamServerCount; ++i)
-    {
-        otIp4Address ip4Address;
+    LogInfo("Set upstream DNS server list, count: %d", mUpstreamDnsServerCount);
+}
 
-        // TODO: support DNS servers with IPv6 addresses
-        if (otIp4FromIp4MappedIp6Address(&aUpstreamDnsServers[i], &ip4Address) == OT_ERROR_NONE)
-        {
-            mUpstreamDnsServerList[mUpstreamDnsServerCount] = ip4Address.mFields.m32;
-            mUpstreamDnsServerCount++;
-        }
-    }
+void Resolver::SetRecursiveDnsServerList(const otIp6Address *aRecursiveDnsServers, uint32_t aNumServers)
+{
+    mRecursiveDnsServerCount = OT_MIN(aNumServers, static_cast<uint32_t>(kMaxRecursiveServerCount));
+    memcpy(mRecursiveDnsServerList, aRecursiveDnsServers, mRecursiveDnsServerCount * sizeof(otIp6Address));
+
+    LogInfo("Set recursive DNS server list, count: %d", mRecursiveDnsServerCount);
 }
 
-int Resolver::CreateUdpSocket(void)
+int Resolver::CreateUdpSocket(sa_family_t aFamily)
 {
     int fd = -1;
 
     VerifyOrExit(otSysGetInfraNetifName() != nullptr, LogDebg("No infra network interface available"));
-    fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+    fd = socket(aFamily, SOCK_DGRAM, IPPROTO_UDP);
     VerifyOrExit(fd >= 0, LogDebg("Failed to create the UDP socket: %s", strerror(errno)));
 #if OPENTHREAD_POSIX_CONFIG_UPSTREAM_DNS_BIND_TO_INFRA_NETIF
     if (setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, otSysGetInfraNetifName(), strlen(otSysGetInfraNetifName())) < 0)
@@ -341,8 +505,17 @@ void platformResolverProcess(const otSysMainloopContext *aContext) { gResolver.P
 
 void platformResolverUpdateFdSet(otSysMainloopContext *aContext) { gResolver.UpdateFdSet(*aContext); }
 
+void platformResolverSetUp(void) { gResolver.Setup(); }
+
 void platformResolverInit(void) { gResolver.Init(); }
 
+bool otPlatDnsIsUpstreamQueryAvailable(otInstance *aInstance)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+
+    return gResolver.IsUpstreamQueryAvailable();
+}
+
 void otPlatDnsStartUpstreamQuery(otInstance *aInstance, otPlatDnsUpstreamQuery *aTxn, const otMessage *aQuery)
 {
     OT_UNUSED_VARIABLE(aInstance);
diff --git a/src/posix/platform/resolver.hpp b/src/posix/platform/resolver.hpp
index d1d0e2cfc..8b9261951 100644
--- a/src/posix/platform/resolver.hpp
+++ b/src/posix/platform/resolver.hpp
@@ -50,12 +50,28 @@ public:
     constexpr static ssize_t kMaxDnsMessageSize           = 512;
     constexpr static ssize_t kMaxUpstreamTransactionCount = 16;
     constexpr static ssize_t kMaxUpstreamServerCount      = 3;
+    constexpr static ssize_t kMaxRecursiveServerCount     = 3;
 
     /**
      * Initialize the upstream DNS resolver.
      */
     void Init(void);
 
+    /**
+     * Sets up the upstream DNS resolver.
+     *
+     * @note This method is called after OpenThread instance is created.
+     */
+    void Setup(void);
+
+    /**
+     * Indicates whether an upstream DNS server is available for queries.
+     *
+     * @retval TRUE   An upstream DNS server is available.
+     * @retval FALSE  An upstream DNS server is not available.
+     */
+    bool IsUpstreamQueryAvailable(void);
+
     /**
      * Sends the query to the upstream.
      *
@@ -99,7 +115,16 @@ public:
      *                                 IPv6 address or an IPv4-mapped IPv6 address.
      * @param[in] aNumServers          The number of upstream DNS servers.
      */
-    void SetUpstreamDnsServers(const otIp6Address *aUpstreamDnsServers, int aNumServers);
+    void SetUpstreamDnsServers(const otIp6Address *aUpstreamDnsServers, uint32_t aNumServers);
+
+    /**
+     * Sets the list of recursive DNS servers.
+     *
+     * @param[in] aRecursiveDnsServers A pointer to the list of IPv6 recursive DNS server addresses.
+     * @param[in] aNumServers          The number of recursive DNS servers.
+     *
+     */
+    void SetRecursiveDnsServerList(const otIp6Address *aRecursiveDnsServers, uint32_t aNumServers);
 
 private:
     static constexpr uint64_t kDnsServerListNullCacheTimeoutMs = 1 * 60 * 1000;  // 1 minute
@@ -108,25 +133,36 @@ private:
     struct Transaction
     {
         otPlatDnsUpstreamQuery *mThreadTxn;
-        int                     mUdpFd;
+        int                     mUdpFd4;
+        int                     mUdpFd6;
     };
 
-    static int CreateUdpSocket(void);
+    static int CreateUdpSocket(sa_family_t aFamily);
 
-    Transaction *GetTransaction(int aFd);
     Transaction *GetTransaction(otPlatDnsUpstreamQuery *aThreadTxn);
     Transaction *AllocateTransaction(otPlatDnsUpstreamQuery *aThreadTxn);
 
-    void ForwardResponse(Transaction *aTxn);
-    void CloseTransaction(Transaction *aTxn);
-    void FinishTransaction(int aFd);
-    void TryRefreshDnsServerList(void);
-    void LoadDnsServerListFromConf(void);
-
-    bool      mIsResolvConfEnabled    = true;
-    int       mUpstreamDnsServerCount = 0;
-    in_addr_t mUpstreamDnsServerList[kMaxUpstreamServerCount];
-    uint64_t  mUpstreamDnsServerListFreshness = 0;
+    otError SendQueryToServer(Transaction        *aTxn,
+                              const otIp6Address &aServerAddress,
+                              const char         *aPacket,
+                              uint16_t            aLength);
+    void    ForwardResponse(otPlatDnsUpstreamQuery *aThreadTxn, int aFd);
+    void    CloseTransaction(Transaction *aTxn);
+    void    TryRefreshDnsServerList(void);
+    void    LoadDnsServerListFromConf(void);
+
+#if OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE
+    static void BorderRoutingRdnssCallback(void *aResolver);
+    void        BorderRoutingRdnssCallback(void);
+#endif
+
+    bool         mIsResolvConfEnabled    = OPENTHREAD_POSIX_CONFIG_RESOLV_CONF_ENABLED_INIT;
+    uint32_t     mUpstreamDnsServerCount = 0;
+    otIp6Address mUpstreamDnsServerList[kMaxUpstreamServerCount];
+    uint64_t     mUpstreamDnsServerListFreshness = 0;
+
+    uint32_t     mRecursiveDnsServerCount = 0;
+    otIp6Address mRecursiveDnsServerList[kMaxRecursiveServerCount];
 
     Transaction mUpstreamTransaction[kMaxUpstreamTransactionCount];
 };
diff --git a/src/posix/platform/system.cpp b/src/posix/platform/system.cpp
index 735c70c30..799bc4d79 100644
--- a/src/posix/platform/system.cpp
+++ b/src/posix/platform/system.cpp
@@ -237,6 +237,10 @@ void platformSetUp(otPlatformConfig *aPlatformConfig)
     platformNetifSetUp();
 #endif
 
+#if OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE
+    platformResolverSetUp();
+#endif
+
 #if OPENTHREAD_CONFIG_PLATFORM_UDP_ENABLE
     ot::Posix::Udp::Get().SetUp();
 #endif
diff --git a/src/posix/platform/trel.cpp b/src/posix/platform/trel.cpp
index 6e6f566dc..6394c0b23 100644
--- a/src/posix/platform/trel.cpp
+++ b/src/posix/platform/trel.cpp
@@ -49,6 +49,7 @@
 #include "logger.hpp"
 #include "radio_url.hpp"
 #include "system.hpp"
+#include "utils.hpp"
 #include "common/code_utils.hpp"
 
 #if OPENTHREAD_CONFIG_RADIO_LINK_TREL_ENABLE
@@ -172,7 +173,7 @@ static void PrepareSocket(uint16_t &aUdpPort)
 
     LogDebg("PrepareSocket()");
 
-    sSocket = SocketWithCloseExec(AF_INET6, SOCK_DGRAM, 0, kSocketNonBlock);
+    sSocket = ot::Posix::SocketWithCloseExec(AF_INET6, SOCK_DGRAM, 0, ot::Posix::kSocketNonBlock);
     VerifyOrDie(sSocket >= 0, OT_EXIT_ERROR_ERRNO);
 
     // Make the socket non-blocking to allow immediate tx attempt.
diff --git a/src/posix/platform/udp.cpp b/src/posix/platform/udp.cpp
index ebd2009d5..5b736e52a 100644
--- a/src/posix/platform/udp.cpp
+++ b/src/posix/platform/udp.cpp
@@ -58,6 +58,7 @@
 #include "posix/platform/ip6_utils.hpp"
 #include "posix/platform/mainloop.hpp"
 #include "posix/platform/udp.hpp"
+#include "posix/platform/utils.hpp"
 
 using namespace ot::Posix::Ip6Utils;
 
@@ -222,7 +223,7 @@ otError otPlatUdpSocket(otUdpSocket *aUdpSocket)
 
     assert(aUdpSocket->mHandle == nullptr);
 
-    fd = SocketWithCloseExec(AF_INET6, SOCK_DGRAM, IPPROTO_UDP, kSocketNonBlock);
+    fd = ot::Posix::SocketWithCloseExec(AF_INET6, SOCK_DGRAM, IPPROTO_UDP, ot::Posix::kSocketNonBlock);
     VerifyOrExit(fd >= 0, error = OT_ERROR_FAILED);
 
     aUdpSocket->mHandle = FdToHandle(fd);
diff --git a/src/posix/platform/utils.cpp b/src/posix/platform/utils.cpp
index 8183ac391..fd158df9d 100644
--- a/src/posix/platform/utils.cpp
+++ b/src/posix/platform/utils.cpp
@@ -34,16 +34,50 @@
 #include "utils.hpp"
 
 #include <errno.h>
+#include <fcntl.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <string.h>
+#include <sys/ioctl.h>
+#include <sys/select.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <unistd.h>
 
 #include <openthread/logging.h>
 
 #include "common/code_utils.hpp"
+#include "lib/platform/exit_code.h"
 
 namespace ot {
 namespace Posix {
 
+int SocketWithCloseExec(int aDomain, int aType, int aProtocol, SocketBlockOption aBlockOption)
+{
+    int rval = 0;
+    int fd   = -1;
+
+#ifdef __APPLE__
+    VerifyOrExit((fd = socket(aDomain, aType, aProtocol)) != -1, perror("socket(SOCK_CLOEXEC)"));
+
+    VerifyOrExit((rval = fcntl(fd, F_GETFD, 0)) != -1, perror("fcntl(F_GETFD)"));
+    rval |= aBlockOption == kSocketNonBlock ? O_NONBLOCK | FD_CLOEXEC : FD_CLOEXEC;
+    VerifyOrExit((rval = fcntl(fd, F_SETFD, rval)) != -1, perror("fcntl(F_SETFD)"));
+#else
+    aType |= aBlockOption == kSocketNonBlock ? SOCK_CLOEXEC | SOCK_NONBLOCK : SOCK_CLOEXEC;
+    VerifyOrExit((fd = socket(aDomain, aType, aProtocol)) != -1, perror("socket(SOCK_CLOEXEC)"));
+#endif
+
+exit:
+    if (rval == -1)
+    {
+        VerifyOrDie(close(fd) == 0, OT_EXIT_ERROR_ERRNO);
+        fd = -1;
+    }
+
+    return fd;
+}
+
 enum
 {
     kSystemCommandMaxLength = 1024, ///< Max length of a system call command.
diff --git a/src/posix/platform/utils.hpp b/src/posix/platform/utils.hpp
index 038c2f496..73c1e5298 100644
--- a/src/posix/platform/utils.hpp
+++ b/src/posix/platform/utils.hpp
@@ -34,6 +34,28 @@
 namespace ot {
 namespace Posix {
 
+/**
+ * Represents socket block/non-block options.
+ */
+enum SocketBlockOption : uint8_t
+{
+    kSocketBlock,
+    kSocketNonBlock,
+};
+
+/**
+ * Creates a socket with SOCK_CLOEXEC flag set.
+ *
+ * @param[in]   aDomain       The communication domain.
+ * @param[in]   aType         The semantics of communication.
+ * @param[in]   aProtocol     The protocol to use.
+ * @param[in]   aBlockOption  Whether to add nonblock flags.
+ *
+ * @returns The file descriptor of the created socket, or -1 if fails to create the socket.
+ * @retval  -1  Failed to create socket.
+ */
+int SocketWithCloseExec(int aDomain, int aType, int aProtocol, SocketBlockOption aBlockOption);
+
 /**
  * Formats a system command to execute.
  *
diff --git a/src/posix/platform/virtual_time.cpp b/src/posix/platform/virtual_time.cpp
index 6777456c8..567ab87f4 100644
--- a/src/posix/platform/virtual_time.cpp
+++ b/src/posix/platform/virtual_time.cpp
@@ -42,6 +42,8 @@
 #include <sys/select.h>
 #include <unistd.h>
 
+#include "utils.hpp"
+
 #if OPENTHREAD_POSIX_VIRTUAL_TIME
 
 static const int kMaxNetworkSize = 33;      ///< Well-known ID used by a simulated radio supporting promiscuous mode.
@@ -83,7 +85,7 @@ void virtualTimeInit(uint16_t aNodeId)
     sockaddr.sin_port        = htons(kBasePort + sPortOffset + aNodeId);
     sockaddr.sin_addr.s_addr = INADDR_ANY;
 
-    sSockFd = SocketWithCloseExec(AF_INET, SOCK_DGRAM, IPPROTO_UDP, kSocketBlock);
+    sSockFd = ot::Posix::SocketWithCloseExec(AF_INET, SOCK_DGRAM, IPPROTO_UDP, ot::Posix::kSocketBlock);
 
     if (sSockFd == -1)
     {
diff --git a/tests/gtest/CMakeLists.txt b/tests/gtest/CMakeLists.txt
index ccc75850d..46380cce7 100644
--- a/tests/gtest/CMakeLists.txt
+++ b/tests/gtest/CMakeLists.txt
@@ -29,19 +29,12 @@
 cmake_minimum_required(VERSION 3.14)
 project(openthread-gtest)
 
+find_package(GTest CONFIG REQUIRED COMPONENTS GTest GMock Main)
+
 # GoogleTest requires at least C++14
 set(CMAKE_CXX_STANDARD 14)
 set(CMAKE_CXX_STANDARD_REQUIRED ON)
 
-include(FetchContent)
-FetchContent_Declare(
-    googletest
-    URL https://github.com/google/googletest/archive/03597a01ee50ed33e9dfd640b249b4be3799d395.zip
-)
-# For Windows: Prevent overriding the parent project's compiler/linker settings
-set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
-FetchContent_MakeAvailable(googletest)
-
 include(GoogleTest)
 
 add_library(ot-fake-platform
@@ -62,7 +55,9 @@ add_executable(ot-ftd-gtest
 )
 target_link_libraries(ot-ftd-gtest
     ot-fake-ftd
-    GTest::gmock_main
+    GTest::gtest
+    GTest::gmock
+    GTest::gtest_main
 )
 gtest_discover_tests(ot-ftd-gtest)
 
@@ -82,7 +77,9 @@ add_executable(ot-radio-spinel-rcp-gtest
 )
 target_link_libraries(ot-radio-spinel-rcp-gtest
     ot-fake-rcp
-    GTest::gmock_main
+    GTest::gtest
+    GTest::gmock
+    GTest::gtest_main
 )
 
 gtest_discover_tests(ot-radio-spinel-rcp-gtest)
diff --git a/tests/nexus/openthread-core-nexus-config.h b/tests/nexus/openthread-core-nexus-config.h
index 88d519088..d18a2cae4 100644
--- a/tests/nexus/openthread-core-nexus-config.h
+++ b/tests/nexus/openthread-core-nexus-config.h
@@ -94,9 +94,9 @@
 #define OPENTHREAD_CONFIG_MLE_LINK_METRICS_SUBJECT_ENABLE 0
 #define OPENTHREAD_CONFIG_MLE_MAX_CHILDREN 128
 #define OPENTHREAD_CONFIG_MULTICAST_DNS_AUTO_ENABLE_ON_INFRA_IF 0
-#define OPENTHREAD_CONFIG_MULTICAST_DNS_ENABLE 0
-#define OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE 0
-#define OPENTHREAD_CONFIG_MULTICAST_DNS_PUBLIC_API_ENABLE 0
+#define OPENTHREAD_CONFIG_MULTICAST_DNS_ENABLE 1
+#define OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE 1
+#define OPENTHREAD_CONFIG_MULTICAST_DNS_PUBLIC_API_ENABLE 1
 #define OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE 0
 #define OPENTHREAD_CONFIG_NET_DIAG_VENDOR_INFO_SET_API_ENABLE OPENTHREAD_FTD
 #define OPENTHREAD_CONFIG_NET_DIAG_VENDOR_MODEL "Nexus Simulation"
diff --git a/tests/nexus/platform/nexus_misc.cpp b/tests/nexus/platform/nexus_misc.cpp
index 09919940f..dba1f55b5 100644
--- a/tests/nexus/platform/nexus_misc.cpp
+++ b/tests/nexus/platform/nexus_misc.cpp
@@ -104,6 +104,36 @@ exit:
     return error;
 }
 
+//---------------------------------------------------------------------------------------------------------------------
+// otPlatMdns
+
+OT_TOOL_WEAK otError otPlatMdnsSetListeningEnabled(otInstance *aInstance, bool aEnable, uint32_t aInfraIfIndex)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    OT_UNUSED_VARIABLE(aEnable);
+    OT_UNUSED_VARIABLE(aInfraIfIndex);
+
+    return kErrorNone;
+}
+
+OT_TOOL_WEAK void otPlatMdnsSendMulticast(otInstance *aInstance, otMessage *aMessage, uint32_t aInfraIfIndex)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    OT_UNUSED_VARIABLE(aInfraIfIndex);
+
+    AsCoreType(aMessage).Free();
+}
+
+OT_TOOL_WEAK void otPlatMdnsSendUnicast(otInstance                  *aInstance,
+                                        otMessage                   *aMessage,
+                                        const otPlatMdnsAddressInfo *aAddress)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    OT_UNUSED_VARIABLE(aAddress);
+
+    AsCoreType(aMessage).Free();
+}
+
 //---------------------------------------------------------------------------------------------------------------------
 // Misc
 
diff --git a/tests/nexus/platform/nexus_node.cpp b/tests/nexus/platform/nexus_node.cpp
index 23e4e37df..14d819bd9 100644
--- a/tests/nexus/platform/nexus_node.cpp
+++ b/tests/nexus/platform/nexus_node.cpp
@@ -40,7 +40,7 @@ void Node::Form(void)
     Get<MeshCoP::ActiveDatasetManager>().SaveLocal(datasetInfo);
 
     Get<ThreadNetif>().Up();
-    SuccessOrQuit(Get<Mle::MleRouter>().Start());
+    SuccessOrQuit(Get<Mle::Mle>().Start());
 }
 
 void Node::Join(Node &aNode, JoinMode aJoinMode)
@@ -51,7 +51,7 @@ void Node::Join(Node &aNode, JoinMode aJoinMode)
     switch (aJoinMode)
     {
     case kAsFed:
-        SuccessOrQuit(Get<Mle::MleRouter>().SetRouterEligible(false));
+        SuccessOrQuit(Get<Mle::Mle>().SetRouterEligible(false));
         OT_FALL_THROUGH;
 
     case kAsFtd:
@@ -72,7 +72,7 @@ void Node::Join(Node &aNode, JoinMode aJoinMode)
     Get<MeshCoP::ActiveDatasetManager>().SaveLocal(dataset);
 
     Get<ThreadNetif>().Up();
-    SuccessOrQuit(Get<Mle::MleRouter>().Start());
+    SuccessOrQuit(Get<Mle::Mle>().Start());
 }
 
 void Node::AllowList(Node &aNode)
diff --git a/tests/nexus/test_border_agent.cpp b/tests/nexus/test_border_agent.cpp
index 587395926..b7e4c837a 100644
--- a/tests/nexus/test_border_agent.cpp
+++ b/tests/nexus/test_border_agent.cpp
@@ -38,7 +38,10 @@ namespace Nexus {
 
 using ActiveDatasetManager = MeshCoP::ActiveDatasetManager;
 using BorderAgent          = MeshCoP::BorderAgent;
-using EphemeralKeyManager  = ot::MeshCoP::BorderAgent::EphemeralKeyManager;
+using EphemeralKeyManager  = MeshCoP::BorderAgent::EphemeralKeyManager;
+using HistoryTracker       = Utils::HistoryTracker;
+using EpskcEvent           = HistoryTracker::EpskcEvent;
+using Iterator             = HistoryTracker::Iterator;
 using ExtendedPanIdManager = MeshCoP::ExtendedPanIdManager;
 using NameData             = MeshCoP::NameData;
 using NetworkNameManager   = MeshCoP::NetworkNameManager;
@@ -85,6 +88,18 @@ void TestBorderAgent(void)
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     Log("Check Border Agent initial state");
 
+    VerifyOrQuit(node0.Get<BorderAgent>().IsEnabled());
+    VerifyOrQuit(node0.Get<BorderAgent>().IsRunning());
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    Log("Check disabling and re-enabling of Border Agent");
+
+    node0.Get<BorderAgent>().SetEnabled(false);
+    VerifyOrQuit(!node0.Get<BorderAgent>().IsEnabled());
+    VerifyOrQuit(!node0.Get<BorderAgent>().IsRunning());
+
+    node0.Get<BorderAgent>().SetEnabled(true);
+    VerifyOrQuit(node0.Get<BorderAgent>().IsEnabled());
     VerifyOrQuit(node0.Get<BorderAgent>().IsRunning());
 
     SuccessOrQuit(node0.Get<Ip6::Filter>().AddUnsecurePort(node0.Get<BorderAgent>().GetUdpPort()));
@@ -742,32 +757,460 @@ void TestBorderAgentEphemeralKey(void)
     VerifyOrQuit(node0.Get<BorderAgent>().GetCounters().mEpskcInvalidArgsErrors == 2);
 }
 
-class MeshCoPServiceTester
+EpskcEvent GetNewestEpskcEvent(Node &aNode)
+{
+    const EpskcEvent *epskcEvent = nullptr;
+    Iterator          iter;
+    uint32_t          age;
+    iter.Init();
+
+    epskcEvent = aNode.Get<HistoryTracker>().IterateEpskcEventHistory(iter, age);
+
+    VerifyOrQuit(epskcEvent != nullptr);
+    return *epskcEvent;
+}
+
+void TestHistoryTrackerBorderAgentEpskcEvent(void)
+{
+    static const char kEphemeralKey[] = "nexus1234";
+
+    static constexpr uint16_t kEphemeralKeySize = sizeof(kEphemeralKey) - 1;
+    static constexpr uint16_t kUdpPort          = 49155;
+
+    Core           nexus;
+    Node          &node0 = nexus.CreateNode();
+    Node          &node1 = nexus.CreateNode();
+    Ip6::SockAddr  sockAddr;
+    Coap::Message *message;
+    EpskcEvent     epskcEvent;
+
+    Log("------------------------------------------------------------------------------------------------------");
+    Log("TestHistoryTrackerBorderAgentEpskcEvent");
+
+    nexus.AdvanceTime(0);
+
+    // Form the topology:
+    // - node0 leader acting as Border Agent.
+    // - node1 acting as candidate
+
+    node0.Form();
+    nexus.AdvanceTime(50 * Time::kOneSecondInMsec);
+    VerifyOrQuit(node0.Get<Mle::Mle>().IsLeader());
+    sockAddr.SetAddress(node0.Get<Mle::Mle>().GetLinkLocalAddress());
+    sockAddr.SetPort(kUdpPort);
+
+    SuccessOrQuit(node1.Get<Mac::Mac>().SetPanChannel(node0.Get<Mac::Mac>().GetPanChannel()));
+    node1.Get<Mac::Mac>().SetPanId(node0.Get<Mac::Mac>().GetPanId());
+    node1.Get<ThreadNetif>().Up();
+
+    // Enable the Ephemeral Key feature.
+    node0.Get<EphemeralKeyManager>().SetEnabled(true);
+    VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetState() == EphemeralKeyManager::kStateStopped);
+
+    Log("------------------------------------------------------------------------------------------------------");
+    Log("  Check Ephemeral Key Journey 1: Epskc Mode is activated, then deactivated");
+
+    SuccessOrQuit(node0.Get<EphemeralKeyManager>().Start(kEphemeralKey, /* aTimeout */ 0, kUdpPort));
+    VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetState() == EphemeralKeyManager::kStateStarted);
+
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_ACTIVATED);
+
+    node0.Get<EphemeralKeyManager>().Stop();
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_DEACTIVATED_LOCAL_CLOSE);
+
+    Log("------------------------------------------------------------------------------------------------------");
+    Log("  Check Ephemeral Key Journey 2: Epskc Mode is activated, then deactivated after max failed connection "
+        "attempts");
+
+    SuccessOrQuit(node0.Get<EphemeralKeyManager>().Start(kEphemeralKey, /* aTimeout */ 0, kUdpPort));
+    VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetState() == EphemeralKeyManager::kStateStarted);
+    SuccessOrQuit(node0.Get<Ip6::Filter>().AddUnsecurePort(kUdpPort));
+
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_ACTIVATED);
+
+    nexus.AdvanceTime(0);
+
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().Open());
+    SuccessOrQuit(
+        node1.Get<Tmf::SecureAgent>().SetPsk(reinterpret_cast<const uint8_t *>(kEphemeralKey), kEphemeralKeySize - 2));
+
+    for (uint8_t numAttempts = 1; numAttempts < 10; numAttempts++)
+    {
+        Log("  Attempt %u to connect with the wrong key", numAttempts);
+
+        SuccessOrQuit(node1.Get<Tmf::SecureAgent>().Connect(sockAddr));
+
+        nexus.AdvanceTime(3 * Time::kOneSecondInMsec);
+
+        VerifyOrQuit(!node1.Get<Tmf::SecureAgent>().IsConnected());
+        VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetState() == EphemeralKeyManager::kStateStarted);
+    }
+
+    Log("  Attempt 10 (final attempt) to connect with the wrong key, check that ephemeral key use is stopped");
+
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().Connect(sockAddr));
+    nexus.AdvanceTime(3 * Time::kOneSecondInMsec);
+
+    VerifyOrQuit(!node1.Get<Tmf::SecureAgent>().IsConnected());
+    VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetState() == EphemeralKeyManager::kStateStopped);
+
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_DEACTIVATED_MAX_ATTEMPTS);
+
+    Log("------------------------------------------------------------------------------------------------------");
+    Log("  Check Ephemeral Key Journey 3: The session is connected successfully, then disconnected by API");
+
+    SuccessOrQuit(node0.Get<EphemeralKeyManager>().Start(kEphemeralKey, /* aTimeout */ 0, kUdpPort));
+    VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetState() == EphemeralKeyManager::kStateStarted);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_ACTIVATED);
+
+    SuccessOrQuit(
+        node1.Get<Tmf::SecureAgent>().SetPsk(reinterpret_cast<const uint8_t *>(kEphemeralKey), kEphemeralKeySize));
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().Connect(sockAddr));
+    nexus.AdvanceTime(3 * Time::kOneSecondInMsec);
+    VerifyOrQuit(node1.Get<Tmf::SecureAgent>().IsConnected());
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_CONNECTED);
+
+    node0.Get<EphemeralKeyManager>().Stop();
+    nexus.AdvanceTime(3 * Time::kOneSecondInMsec);
+
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_DEACTIVATED_LOCAL_CLOSE);
+
+    Log("------------------------------------------------------------------------------------------------------");
+    Log("  Check Ephemeral Key Journey 4: The session is connected successfully. And the candidate petitioned as an "
+        "active commissioner. The session is disconnected by the remote.");
+
+    SuccessOrQuit(node0.Get<EphemeralKeyManager>().Start(kEphemeralKey, /* aTimeout */ 0, kUdpPort));
+    VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetState() == EphemeralKeyManager::kStateStarted);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_ACTIVATED);
+
+    VerifyOrQuit(!node1.Get<Tmf::SecureAgent>().IsConnected());
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().Connect(sockAddr));
+
+    nexus.AdvanceTime(3 * Time::kOneSecondInMsec);
+    VerifyOrQuit(node1.Get<Tmf::SecureAgent>().IsConnected());
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_CONNECTED);
+
+    message = node1.Get<Tmf::SecureAgent>().NewPriorityConfirmablePostMessage(kUriCommissionerPetition);
+    VerifyOrQuit(message != nullptr);
+    SuccessOrQuit(Tlv::Append<MeshCoP::CommissionerIdTlv>(*message, "node1"));
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().SendMessage(*message));
+
+    nexus.AdvanceTime(1 * Time::kOneSecondInMsec);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_PETITIONED);
+
+    node1.Get<Tmf::SecureAgent>().Disconnect();
+    nexus.AdvanceTime(3 * Time::kOneSecondInMsec);
+
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_DEACTIVATED_REMOTE_CLOSE);
+
+    Log("------------------------------------------------------------------------------------------------------");
+    Log("  Check Ephemeral Key Journey 5: The session is connected successfully. And the active dataset is fetched. "
+        "The session is disconnected by the remote.");
+
+    SuccessOrQuit(node0.Get<EphemeralKeyManager>().Start(kEphemeralKey, /* aTimeout */ 0, kUdpPort));
+    VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetState() == EphemeralKeyManager::kStateStarted);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_ACTIVATED);
+
+    VerifyOrQuit(!node1.Get<Tmf::SecureAgent>().IsConnected());
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().Connect(sockAddr));
+
+    nexus.AdvanceTime(3 * Time::kOneSecondInMsec);
+    VerifyOrQuit(node1.Get<Tmf::SecureAgent>().IsConnected());
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_CONNECTED);
+
+    message = node1.Get<Tmf::SecureAgent>().NewPriorityConfirmablePostMessage(kUriCommissionerPetition);
+    VerifyOrQuit(message != nullptr);
+    SuccessOrQuit(Tlv::Append<MeshCoP::CommissionerIdTlv>(*message, "node1"));
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().SendMessage(*message));
+
+    nexus.AdvanceTime(1 * Time::kOneSecondInMsec);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_PETITIONED);
+
+    message = node1.Get<Tmf::SecureAgent>().NewPriorityConfirmablePostMessage(kUriActiveGet);
+    VerifyOrQuit(message != nullptr);
+    SuccessOrQuit(Tlv::Append<MeshCoP::CommissionerIdTlv>(*message, "node1"));
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().SendMessage(*message));
+
+    nexus.AdvanceTime(1 * Time::kOneSecondInMsec);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_RETRIEVED_ACTIVE_DATASET);
+
+    node1.Get<Tmf::SecureAgent>().Disconnect();
+    nexus.AdvanceTime(3 * Time::kOneSecondInMsec);
+
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_DEACTIVATED_REMOTE_CLOSE);
+
+    Log("------------------------------------------------------------------------------------------------------");
+    Log("  Check Ephemeral Key Journey 6: The session is connected successfully. And the pending dataset is fetched. "
+        "The session is disconnected by the remote.");
+
+    SuccessOrQuit(node0.Get<EphemeralKeyManager>().Start(kEphemeralKey, /* aTimeout */ 0, kUdpPort));
+    VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetState() == EphemeralKeyManager::kStateStarted);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_ACTIVATED);
+
+    VerifyOrQuit(!node1.Get<Tmf::SecureAgent>().IsConnected());
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().Connect(sockAddr));
+
+    nexus.AdvanceTime(3 * Time::kOneSecondInMsec);
+    VerifyOrQuit(node1.Get<Tmf::SecureAgent>().IsConnected());
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_CONNECTED);
+
+    message = node1.Get<Tmf::SecureAgent>().NewPriorityConfirmablePostMessage(kUriCommissionerPetition);
+    VerifyOrQuit(message != nullptr);
+    SuccessOrQuit(Tlv::Append<MeshCoP::CommissionerIdTlv>(*message, "node1"));
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().SendMessage(*message));
+
+    nexus.AdvanceTime(1 * Time::kOneSecondInMsec);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_PETITIONED);
+
+    message = node1.Get<Tmf::SecureAgent>().NewPriorityConfirmablePostMessage(kUriActiveGet);
+    VerifyOrQuit(message != nullptr);
+    SuccessOrQuit(Tlv::Append<MeshCoP::CommissionerIdTlv>(*message, "node1"));
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().SendMessage(*message));
+
+    nexus.AdvanceTime(1 * Time::kOneSecondInMsec);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_RETRIEVED_ACTIVE_DATASET);
+
+    message = node1.Get<Tmf::SecureAgent>().NewPriorityConfirmablePostMessage(kUriPendingGet);
+    VerifyOrQuit(message != nullptr);
+    SuccessOrQuit(Tlv::Append<MeshCoP::CommissionerIdTlv>(*message, "node1"));
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().SendMessage(*message));
+
+    nexus.AdvanceTime(1 * Time::kOneSecondInMsec);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_RETRIEVED_PENDING_DATASET);
+
+    node1.Get<Tmf::SecureAgent>().Disconnect();
+    nexus.AdvanceTime(3 * Time::kOneSecondInMsec);
+
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_DEACTIVATED_REMOTE_CLOSE);
+
+    Log("------------------------------------------------------------------------------------------------------");
+    Log("  Check Ephemeral Key Journey 7: The session is connected successfully. And the pending dataset is fetched. "
+        "The session is due to session timeout.");
+    SuccessOrQuit(node0.Get<EphemeralKeyManager>().Start(kEphemeralKey, /* aTimeout */ 0, kUdpPort));
+    VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetState() == EphemeralKeyManager::kStateStarted);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_ACTIVATED);
+
+    VerifyOrQuit(!node1.Get<Tmf::SecureAgent>().IsConnected());
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().Connect(sockAddr));
+
+    nexus.AdvanceTime(3 * Time::kOneSecondInMsec);
+    VerifyOrQuit(node1.Get<Tmf::SecureAgent>().IsConnected());
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_CONNECTED);
+
+    message = node1.Get<Tmf::SecureAgent>().NewPriorityConfirmablePostMessage(kUriCommissionerPetition);
+    VerifyOrQuit(message != nullptr);
+    SuccessOrQuit(Tlv::Append<MeshCoP::CommissionerIdTlv>(*message, "node1"));
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().SendMessage(*message));
+
+    nexus.AdvanceTime(1 * Time::kOneSecondInMsec);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_PETITIONED);
+
+    message = node1.Get<Tmf::SecureAgent>().NewPriorityConfirmablePostMessage(kUriActiveGet);
+    VerifyOrQuit(message != nullptr);
+    SuccessOrQuit(Tlv::Append<MeshCoP::CommissionerIdTlv>(*message, "node1"));
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().SendMessage(*message));
+
+    nexus.AdvanceTime(1 * Time::kOneSecondInMsec);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_RETRIEVED_ACTIVE_DATASET);
+
+    message = node1.Get<Tmf::SecureAgent>().NewPriorityConfirmablePostMessage(kUriPendingGet);
+    VerifyOrQuit(message != nullptr);
+    SuccessOrQuit(Tlv::Append<MeshCoP::CommissionerIdTlv>(*message, "node1"));
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().SendMessage(*message));
+
+    nexus.AdvanceTime(1 * Time::kOneSecondInMsec);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_RETRIEVED_PENDING_DATASET);
+
+    static constexpr uint32_t kKeepAliveTimeout = 50 * 1000; // Timeout to reject a commissioner (in msec)
+    nexus.AdvanceTime(kKeepAliveTimeout);                    // Wait for the session timeout
+    VerifyOrQuit(!node1.Get<Tmf::SecureAgent>().IsConnected());
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_DEACTIVATED_SESSION_TIMEOUT);
+
+    Log("------------------------------------------------------------------------------------------------------");
+    Log("  Check Ephemeral Key Journey 8: The session is connected successfully. The epskc mode is deactivated due to "
+        "timeout.");
+    SuccessOrQuit(node0.Get<EphemeralKeyManager>().Start(kEphemeralKey, /* aTimeout */ 0, kUdpPort));
+    VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetState() == EphemeralKeyManager::kStateStarted);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_ACTIVATED);
+
+    VerifyOrQuit(!node1.Get<Tmf::SecureAgent>().IsConnected());
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().Connect(sockAddr));
+
+    nexus.AdvanceTime(3 * Time::kOneSecondInMsec);
+    VerifyOrQuit(node1.Get<Tmf::SecureAgent>().IsConnected());
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_CONNECTED);
+
+    message = node1.Get<Tmf::SecureAgent>().NewPriorityConfirmablePostMessage(kUriCommissionerPetition);
+    VerifyOrQuit(message != nullptr);
+    SuccessOrQuit(Tlv::Append<MeshCoP::CommissionerIdTlv>(*message, "node1"));
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().SendMessage(*message));
+    nexus.AdvanceTime(1 * Time::kOneSecondInMsec);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_PETITIONED);
+
+    // Send a KeepAlive message every 30s until ePSKc mode timed out
+    for (uint8_t i = 0; i < EphemeralKeyManager::kDefaultTimeout / (30 * Time::kOneSecondInMsec) - 1; i++)
+    {
+        if (!node1.Get<Tmf::SecureAgent>().IsConnected())
+        {
+            break;
+        }
+        message = node1.Get<Tmf::SecureAgent>().NewPriorityConfirmablePostMessage(kUriCommissionerKeepAlive);
+        VerifyOrQuit(message != nullptr);
+        SuccessOrQuit(Tlv::Append<MeshCoP::StateTlv>(*message, MeshCoP::StateTlv::kAccept));
+        SuccessOrQuit(Tlv::Append<MeshCoP::CommissionerIdTlv>(*message, "node1"));
+        SuccessOrQuit(node1.Get<Tmf::SecureAgent>().SendMessage(*message));
+        nexus.AdvanceTime(30 * Time::kOneSecondInMsec);
+
+        epskcEvent = GetNewestEpskcEvent(node0);
+        VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_KEEP_ALIVE);
+    }
+
+    message = node1.Get<Tmf::SecureAgent>().NewPriorityConfirmablePostMessage(kUriCommissionerKeepAlive);
+    VerifyOrQuit(message != nullptr);
+    SuccessOrQuit(Tlv::Append<MeshCoP::StateTlv>(*message, MeshCoP::StateTlv::kAccept));
+    SuccessOrQuit(Tlv::Append<MeshCoP::CommissionerIdTlv>(*message, "node1"));
+    SuccessOrQuit(node1.Get<Tmf::SecureAgent>().SendMessage(*message));
+    nexus.AdvanceTime(30 * Time::kOneSecondInMsec);
+
+    VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetState() == EphemeralKeyManager::kStateStopped);
+    epskcEvent = GetNewestEpskcEvent(node0);
+    VerifyOrQuit(epskcEvent == OT_HISTORY_TRACKER_BORDER_AGENT_EPSKC_EVENT_DEACTIVATED_EPSKC_TIMEOUT);
+}
+
+//----------------------------------------------------------------------------------------------------------------------
+
+struct TxtData
 {
-public:
-    MeshCoPServiceTester(BorderAgent &aBorderAgent)
-        : mBorderAgent(aBorderAgent)
-        , mIsRunning(false)
-        , mUdpPort(0)
+    void Init(const uint8_t *aData, uint16_t aLength) { mData = aData, mLength = aLength; }
+
+    void ValidateFormat(void)
+    {
+        TxtEntry::Iterator iter;
+        TxtEntry           txtEntry;
+
+        iter.Init(mData, mLength);
+
+        while (true)
+        {
+            Error error = iter.GetNextEntry(txtEntry);
+
+            if (error == kErrorNotFound)
+            {
+                break;
+            }
+
+            SuccessOrQuit(error);
+            VerifyOrQuit(txtEntry.mKey != nullptr);
+        }
+    }
+
+    void LogAllTxtEntries(void)
+    {
+        static constexpr uint16_t kValueStringSize = 256;
+
+        char               valueString[kValueStringSize];
+        TxtEntry::Iterator iter;
+        TxtEntry           txtEntry;
+
+        Log("TXT data - length %u", mLength);
+
+        iter.Init(mData, mLength);
+
+        while (true)
+        {
+            Error        error = iter.GetNextEntry(txtEntry);
+            StringWriter writer(valueString, sizeof(valueString));
+
+            if (error == kErrorNotFound)
+            {
+                break;
+            }
+
+            SuccessOrQuit(error);
+            VerifyOrQuit(txtEntry.mKey != nullptr);
+
+            writer.AppendHexBytes(txtEntry.mValue, txtEntry.mValueLength);
+            Log("   %s -> [%s] (len:%u)", txtEntry.mKey, valueString, txtEntry.mValueLength);
+        }
+    }
+
+    bool ContainsKey(const char *aKey) const
+    {
+        TxtEntry txtEntry;
+
+        return FindTxtEntry(aKey, txtEntry);
+    }
+
+    void ValidateKey(const char *aKey, const void *aValue, uint16_t aValueLength) const
+    {
+        TxtEntry txtEntry;
+
+        VerifyOrQuit(FindTxtEntry(aKey, txtEntry));
+        VerifyOrQuit(txtEntry.mValueLength == aValueLength);
+        VerifyOrQuit(memcmp(txtEntry.mValue, aValue, aValueLength) == 0);
+    }
+
+    template <typename ObjectType> void ValidateKey(const char *aKey, const ObjectType &aObject) const
     {
+        static_assert(!TypeTraits::IsPointer<ObjectType>::kValue, "ObjectType must not be a pointer");
+
+        ValidateKey(aKey, &aObject, sizeof(aObject));
     }
 
-    void HandleMeshCoPServiceChanged(void)
+    void ValidateKey(const char *aKey, const char *aString) const { ValidateKey(aKey, aString, strlen(aString)); }
+
+    uint32_t ReadUint32Key(const char *aKey) const
     {
-        mIsRunning = mBorderAgent.IsRunning();
-        mUdpPort   = mBorderAgent.GetUdpPort();
-        SuccessOrQuit(mBorderAgent.GetMeshCoPServiceTxtData(mTxtData));
+        TxtEntry txtEntry;
+
+        VerifyOrQuit(FindTxtEntry(aKey, txtEntry));
+        VerifyOrQuit(txtEntry.mValueLength == sizeof(uint32_t));
+        return BigEndian::ReadUint32(txtEntry.mValue);
     }
 
-    bool FindTxtEntry(const char *aKey, TxtEntry &aTxtEntry)
+    bool FindTxtEntry(const char *aKey, TxtEntry &aTxtEntry) const
     {
         bool               found = false;
         TxtEntry::Iterator iter;
 
-        iter.Init(mTxtData.mData, mTxtData.mLength);
+        iter.Init(mData, mLength);
+
         while (iter.GetNextEntry(aTxtEntry) == kErrorNone)
         {
-            if (strcmp(aTxtEntry.mKey, aKey) == 0)
+            VerifyOrQuit(aTxtEntry.mKey != nullptr);
+
+            if (StringMatch(aTxtEntry.mKey, aKey))
             {
                 found = true;
                 break;
@@ -777,102 +1220,511 @@ public:
         return found;
     }
 
-    BorderAgent                       &mBorderAgent;
-    otBorderAgentMeshCoPServiceTxtData mTxtData;
-    bool                               mIsRunning;
-    uint16_t                           mUdpPort;
+    const uint8_t *mData;
+    uint16_t       mLength;
 };
 
-static void HandleMeshCoPServiceChanged(void *aContext)
+void ValidateMeshCoPTxtData(TxtData &aTxtData, Node &aNode)
 {
-    static_cast<MeshCoPServiceTester *>(aContext)->HandleMeshCoPServiceChanged();
+    // State bitmap masks and field values
+    static constexpr uint32_t kMaskConnectionMode           = 7 << 0;
+    static constexpr uint32_t kConnectionModeDisabled       = 0 << 0;
+    static constexpr uint32_t kConnectionModePskc           = 1 << 0;
+    static constexpr uint32_t kMaskThreadIfStatus           = 3 << 3;
+    static constexpr uint32_t kThreadIfStatusNotInitialized = 0 << 3;
+    static constexpr uint32_t kThreadIfStatusInitialized    = 1 << 3;
+    static constexpr uint32_t kThreadIfStatusActive         = 2 << 3;
+    static constexpr uint32_t kMaskThreadRole               = 3 << 9;
+    static constexpr uint32_t kThreadRoleDisabledOrDetached = 0 << 9;
+    static constexpr uint32_t kThreadRoleChild              = 1 << 9;
+    static constexpr uint32_t kThreadRoleRouter             = 2 << 9;
+    static constexpr uint32_t kThreadRoleLeader             = 3 << 9;
+    static constexpr uint32_t kFlagEpskcSupported           = 1 << 11;
+
+    BorderAgent::Id id;
+    uint32_t        stateBitmap;
+    uint32_t        threadIfStatus;
+    uint32_t        threadRole;
+
+    aTxtData.ValidateFormat();
+    aTxtData.LogAllTxtEntries();
+
+    SuccessOrQuit(aNode.Get<BorderAgent>().GetId(id));
+    aTxtData.ValidateKey("id", id);
+    aTxtData.ValidateKey("rv", "1");
+    aTxtData.ValidateKey("nn", aNode.Get<NetworkNameManager>().GetNetworkName().GetAsCString());
+    aTxtData.ValidateKey("xp", aNode.Get<ExtendedPanIdManager>().GetExtPanId());
+    aTxtData.ValidateKey("tv", kThreadVersionString);
+    aTxtData.ValidateKey("xa", aNode.Get<Mac::Mac>().GetExtAddress());
+
+    if (aNode.Get<Mle::Mle>().IsAttached())
+    {
+        aTxtData.ValidateKey("pt", BigEndian::HostSwap32(aNode.Get<Mle::Mle>().GetLeaderData().GetPartitionId()));
+        aTxtData.ValidateKey("at", aNode.Get<ActiveDatasetManager>().GetTimestamp());
+    }
+    else
+    {
+        VerifyOrQuit(!aTxtData.ContainsKey("pt"));
+        VerifyOrQuit(!aTxtData.ContainsKey("at"));
+    }
+
+    stateBitmap = aTxtData.ReadUint32Key("sb");
+
+    VerifyOrQuit((stateBitmap & kMaskConnectionMode) == aNode.Get<BorderAgent>().IsRunning() ? kConnectionModePskc
+                                                                                             : kConnectionModeDisabled);
+    switch (aNode.Get<Mle::Mle>().GetRole())
+    {
+    case Mle::DeviceRole::kRoleDisabled:
+        threadIfStatus = kThreadIfStatusNotInitialized;
+        threadRole     = kThreadRoleDisabledOrDetached;
+        break;
+    case Mle::DeviceRole::kRoleDetached:
+        threadIfStatus = kThreadIfStatusInitialized;
+        threadRole     = kThreadRoleDisabledOrDetached;
+        break;
+    case Mle::DeviceRole::kRoleChild:
+        threadIfStatus = kThreadIfStatusActive;
+        threadRole     = kThreadRoleChild;
+        break;
+    case Mle::DeviceRole::kRoleRouter:
+        threadIfStatus = kThreadIfStatusActive;
+        threadRole     = kThreadRoleRouter;
+        break;
+    case Mle::DeviceRole::kRoleLeader:
+        threadIfStatus = kThreadIfStatusActive;
+        threadRole     = kThreadRoleLeader;
+        break;
+    }
+
+    VerifyOrQuit((stateBitmap & kMaskThreadIfStatus) == threadIfStatus);
+    VerifyOrQuit((stateBitmap & kMaskThreadRole) == threadRole);
+
+    if (aNode.Get<BorderAgent>().Get<EphemeralKeyManager>().GetState() !=
+        BorderAgent::EphemeralKeyManager::kStateDisabled)
+    {
+        VerifyOrQuit(stateBitmap & kFlagEpskcSupported);
+    }
+    else
+    {
+        VerifyOrQuit(!(stateBitmap & kFlagEpskcSupported));
+    }
 }
 
-template <typename ObjectType> bool CheckObjectSameAsTxtEntryData(const TxtEntry &aTxtEntry, const ObjectType &aObject)
-{
-    static_assert(!TypeTraits::IsPointer<ObjectType>::kValue, "ObjectType must not be a pointer");
+//----------------------------------------------------------------------------------------------------------------------
 
-    return aTxtEntry.mValueLength == sizeof(ObjectType) && memcmp(aTxtEntry.mValue, &aObject, sizeof(ObjectType)) == 0;
+void HandleServiceChanged(void *aContext) // Callback used in `TestBorderAgentTxtDataCallback().`
+{
+    // `aContext` is a boolean `callbackInvoked`
+    VerifyOrQuit(aContext != nullptr);
+    *static_cast<bool *>(aContext) = true;
 }
 
-template <> bool CheckObjectSameAsTxtEntryData<NameData>(const TxtEntry &aTxtEntry, const NameData &aNameData)
+void ReadAndValidateMeshCoPTxtData(Node &aNode)
 {
-    return aTxtEntry.mValueLength == aNameData.GetLength() &&
-           memcmp(aTxtEntry.mValue, aNameData.GetBuffer(), aNameData.GetLength()) == 0;
+    BorderAgent::ServiceTxtData serviceTxtData;
+    TxtData                     txtData;
+
+    SuccessOrQuit(aNode.Get<BorderAgent>().PrepareServiceTxtData(serviceTxtData));
+    txtData.Init(serviceTxtData.mData, serviceTxtData.mLength);
+
+    ValidateMeshCoPTxtData(txtData, aNode);
 }
 
-void TestBorderAgentMeshCoPServiceChangedCallback(void)
+void TestBorderAgentTxtDataCallback(void)
 {
-    Core  nexus;
-    Node &node0 = nexus.CreateNode();
+    Core            nexus;
+    Node           &node0           = nexus.CreateNode();
+    bool            callbackInvoked = false;
+    BorderAgent::Id newId;
 
     Log("------------------------------------------------------------------------------------------------------");
-    Log("TestBorderAgentMeshCoPServiceChangedCallback");
+    Log("TestBorderAgentTxtDataCallback");
 
     nexus.AdvanceTime(0);
-    MeshCoPServiceTester meshCoPServiceTester(node0.Get<BorderAgent>());
-    TxtEntry             txtEntry;
 
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-    // 1. Set MeshCoP service change callback. Will get initial values.
+    // Set MeshCoP service change callback. Will get initial values.
     Log("Set MeshCoP service change callback and check initial values");
-    node0.Get<BorderAgent>().SetMeshCoPServiceChangedCallback(HandleMeshCoPServiceChanged, &meshCoPServiceTester);
+    node0.Get<BorderAgent>().SetServiceChangedCallback(HandleServiceChanged, &callbackInvoked);
     nexus.AdvanceTime(1);
 
-    // 1.1 Check the initial TXT entries
-#if OPENTHREAD_CONFIG_BORDER_AGENT_ID_ENABLE
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("id", txtEntry));
-    BorderAgent::Id id;
-    VerifyOrQuit(node0.Get<BorderAgent>().GetId(id) == kErrorNone);
-    VerifyOrQuit(CheckObjectSameAsTxtEntryData(txtEntry, id));
-#endif
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("nn", txtEntry));
-    VerifyOrQuit(CheckObjectSameAsTxtEntryData(txtEntry, node0.Get<NetworkNameManager>().GetNetworkName().GetAsData()));
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("xp", txtEntry));
-    VerifyOrQuit(CheckObjectSameAsTxtEntryData(txtEntry, node0.Get<ExtendedPanIdManager>().GetExtPanId()));
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("tv", txtEntry));
-    VerifyOrQuit(CheckObjectSameAsTxtEntryData(txtEntry, NameData(kThreadVersionString, strlen(kThreadVersionString))));
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("xa", txtEntry));
-    VerifyOrQuit(CheckObjectSameAsTxtEntryData(txtEntry, node0.Get<Mac::Mac>().GetExtAddress()));
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("sb", txtEntry));
-
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("pt", txtEntry) == false);
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("at", txtEntry) == false);
-
-    // 1.2 Check the Border Agent state
-    VerifyOrQuit(meshCoPServiceTester.mIsRunning == false);
-    VerifyOrQuit(meshCoPServiceTester.mUdpPort == 0);
-
-    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-    // 2. Join Thread network and check updated values and states.
+    // Check the initial TXT entries
+    ReadAndValidateMeshCoPTxtData(node0);
+
+    // Check the Border Agent state
+    VerifyOrQuit(!node0.Get<BorderAgent>().IsRunning());
+    VerifyOrQuit(node0.Get<BorderAgent>().GetUdpPort() == 0);
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Join Thread network and check updated values and states.
+    callbackInvoked = false;
     Log("Join Thread network and check updated Txt data and states");
     node0.Form();
     nexus.AdvanceTime(50 * Time::kOneSecondInMsec);
 
-    // 2.1 Check the initial TXT entries
-#if OPENTHREAD_CONFIG_BORDER_AGENT_ID_ENABLE
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("id", txtEntry));
-    VerifyOrQuit(node0.Get<BorderAgent>().GetId(id) == kErrorNone);
-    VerifyOrQuit(CheckObjectSameAsTxtEntryData(txtEntry, id));
-#endif
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("nn", txtEntry));
-    VerifyOrQuit(CheckObjectSameAsTxtEntryData(txtEntry, node0.Get<NetworkNameManager>().GetNetworkName().GetAsData()));
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("xp", txtEntry));
-    VerifyOrQuit(CheckObjectSameAsTxtEntryData(txtEntry, node0.Get<ExtendedPanIdManager>().GetExtPanId()));
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("tv", txtEntry));
-    VerifyOrQuit(CheckObjectSameAsTxtEntryData(txtEntry, NameData(kThreadVersionString, strlen(kThreadVersionString))));
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("xa", txtEntry));
-    VerifyOrQuit(CheckObjectSameAsTxtEntryData(txtEntry, node0.Get<Mac::Mac>().GetExtAddress()));
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("sb", txtEntry));
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("pt", txtEntry));
-    VerifyOrQuit(CheckObjectSameAsTxtEntryData(
-        txtEntry, BigEndian::HostSwap32(node0.Get<Mle::MleRouter>().GetLeaderData().GetPartitionId())));
-    VerifyOrQuit(meshCoPServiceTester.FindTxtEntry("at", txtEntry));
-    VerifyOrQuit(CheckObjectSameAsTxtEntryData(txtEntry, node0.Get<ActiveDatasetManager>().GetTimestamp()));
-
-    // 2.2 Check the Border Agent state
-    VerifyOrQuit(meshCoPServiceTester.mIsRunning == true);
-    VerifyOrQuit(meshCoPServiceTester.mUdpPort != 0);
+    VerifyOrQuit(callbackInvoked);
+    ReadAndValidateMeshCoPTxtData(node0);
+
+    VerifyOrQuit(node0.Get<BorderAgent>().IsRunning());
+    VerifyOrQuit(node0.Get<BorderAgent>().GetUdpPort() != 0);
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+    Log("Change the Border Agent ID and validate that TXT data changed and callback is invoked");
+
+    newId.GenerateRandom();
+
+    callbackInvoked = false;
+    SuccessOrQuit(node0.Get<BorderAgent>().SetId(newId));
+
+    nexus.AdvanceTime(1);
+    ReadAndValidateMeshCoPTxtData(node0);
+
+    // Validate that setting the ID to the same value as before is
+    // correctly detected and does not trigger the callback.
+
+    callbackInvoked = false;
+    SuccessOrQuit(node0.Get<BorderAgent>().SetId(newId));
+    nexus.AdvanceTime(1);
+    VerifyOrQuit(!callbackInvoked);
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    Log("Disable EphemeralKeyManager and validate that TXT data state bitmap indicates this");
+
+    callbackInvoked = false;
+    node0.Get<EphemeralKeyManager>().SetEnabled(false);
+    VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetState() == EphemeralKeyManager::kStateDisabled);
+
+    nexus.AdvanceTime(1);
+    VerifyOrQuit(callbackInvoked);
+    ReadAndValidateMeshCoPTxtData(node0);
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    Log("Disable the MLE operation and validate the TXT data state bitmap");
+
+    callbackInvoked = false;
+    SuccessOrQuit(node0.Get<Mle::Mle>().Disable());
+
+    nexus.AdvanceTime(1);
+    VerifyOrQuit(callbackInvoked);
+    ReadAndValidateMeshCoPTxtData(node0);
+}
+
+//----------------------------------------------------------------------------------------------------------------------
+
+void ValidateRegisteredServiceData(Dns::Multicast::Core::Service &aService, Node &aNode)
+{
+    TxtData txtData;
+
+    txtData.Init(aService.mTxtData, aService.mTxtDataLength);
+    ValidateMeshCoPTxtData(txtData, aNode);
+}
+
+void TestBorderAgentServiceRegisteration(void)
+{
+    static const char    kDefaultServiceBaseName[] = OPENTHREAD_CONFIG_BORDER_AGENT_MESHCOP_SERVICE_BASE_NAME;
+    static const char    kEphemeralKey[]           = "nexus1234";
+    static const uint8_t kVendorTxtData[]          = {8, 'v', 'n', '=', 'n', 'e', 'x', 'u', 's'};
+
+    static constexpr uint32_t kUdpPort      = 49155;
+    static constexpr uint32_t kInfraIfIndex = 1;
+
+    Core                             nexus;
+    Node                            &node0 = nexus.CreateNode();
+    Dns::Multicast::Core::Iterator  *iterator;
+    Dns::Multicast::Core::Service    service;
+    Dns::Multicast::Core::EntryState entryState;
+    uint16_t                         txtDataLengthWithNoVendorData;
+
+    Log("------------------------------------------------------------------------------------------------------");
+    Log("TestBorderAgentServiceRegisteration");
+
+    nexus.AdvanceTime(0);
+
+    node0.Form();
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Enable mDNS
+    SuccessOrQuit(node0.Get<Dns::Multicast::Core>().SetEnabled(true, kInfraIfIndex));
+    VerifyOrQuit(node0.Get<Dns::Multicast::Core>().IsEnabled());
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+    nexus.AdvanceTime(50 * Time::kOneSecondInMsec);
+    VerifyOrQuit(node0.Get<Mle::Mle>().IsLeader());
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+    VerifyOrQuit(node0.Get<MeshCoP::BorderAgent>().IsEnabled());
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    Log("Validate the registered mDNS MeshCop service by Border Agent");
+
+    iterator = node0.Get<Dns::Multicast::Core>().AllocateIterator();
+    VerifyOrQuit(iterator != nullptr);
+
+    SuccessOrQuit(node0.Get<Dns::Multicast::Core>().GetNextService(*iterator, service, entryState));
+
+    Log("  HostName: %s", service.mHostName);
+    Log("  ServiceInstance: %s", service.mServiceInstance);
+    Log("  ServiceType: %s", service.mServiceType);
+    Log("  Port: %u", service.mPort);
+    Log("  TTL: %lu", ToUlong(service.mTtl));
+
+    VerifyOrQuit(StringMatch(service.mServiceType, "_meshcop._udp"));
+    VerifyOrQuit(StringStartsWith(service.mServiceInstance, kDefaultServiceBaseName));
+    VerifyOrQuit(StringStartsWith(service.mHostName, "ot"));
+    VerifyOrQuit(service.mPort == node0.Get<MeshCoP::BorderAgent>().GetUdpPort());
+    VerifyOrQuit(service.mSubTypeLabelsLength == 0);
+    VerifyOrQuit(service.mTtl > 0);
+    VerifyOrQuit(service.mInfraIfIndex == kInfraIfIndex);
+    VerifyOrQuit(entryState == OT_MDNS_ENTRY_STATE_REGISTERED);
+    ValidateRegisteredServiceData(service, node0);
+
+    // Check that there is no more registered mDNS service
+    VerifyOrQuit(node0.Get<Dns::Multicast::Core>().GetNextService(*iterator, service, entryState) == kErrorNotFound);
+
+    node0.Get<Dns::Multicast::Core>().FreeIterator(*iterator);
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    Log("Enable ans start ephemeral key");
+
+    node0.Get<EphemeralKeyManager>().SetEnabled(true);
+    VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetState() == EphemeralKeyManager::kStateStopped);
+    node0.Get<EphemeralKeyManager>().SetCallback(HandleEphemeralKeyChange, &node0);
+
+    SuccessOrQuit(node0.Get<EphemeralKeyManager>().Start(kEphemeralKey, /* aTimeout */ 0, kUdpPort));
+
+    nexus.AdvanceTime(10 * Time::kOneSecondInMsec);
+
+    VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetState() == EphemeralKeyManager::kStateStarted);
+    VerifyOrQuit(node0.Get<EphemeralKeyManager>().GetUdpPort() == kUdpPort);
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    Log("Check the registered services");
+
+    iterator = node0.Get<Dns::Multicast::Core>().AllocateIterator();
+    VerifyOrQuit(iterator != nullptr);
+
+    for (uint8_t num = 2; num > 0; num--)
+    {
+        SuccessOrQuit(node0.Get<Dns::Multicast::Core>().GetNextService(*iterator, service, entryState));
+        Log("- - - - - - - - - - - - - - - - -");
+        Log("  HostName: %s", service.mHostName);
+        Log("  ServiceInstance: %s", service.mServiceInstance);
+        Log("  ServiceType: %s", service.mServiceType);
+        Log("  Port: %u", service.mPort);
+        Log("  TTL: %lu", ToUlong(service.mTtl));
+
+        VerifyOrQuit(StringStartsWith(service.mServiceInstance, kDefaultServiceBaseName));
+        VerifyOrQuit(StringStartsWith(service.mHostName, "ot"));
+        VerifyOrQuit(service.mSubTypeLabelsLength == 0);
+        VerifyOrQuit(service.mTtl > 0);
+        VerifyOrQuit(service.mInfraIfIndex == kInfraIfIndex);
+        VerifyOrQuit(entryState == OT_MDNS_ENTRY_STATE_REGISTERED);
+
+        if (StringMatch(service.mServiceType, "_meshcop._udp"))
+        {
+            VerifyOrQuit(service.mPort == node0.Get<MeshCoP::BorderAgent>().GetUdpPort());
+            ValidateRegisteredServiceData(service, node0);
+        }
+        else if (StringMatch(service.mServiceType, "_meshcop-e._udp"))
+        {
+            VerifyOrQuit(service.mPort == kUdpPort);
+            VerifyOrQuit(service.mTxtDataLength == 1);
+            VerifyOrQuit(service.mTxtData[0] == 0);
+        }
+        else
+        {
+            // Unexpected service type
+            VerifyOrQuit(false);
+        }
+    }
+
+    // Check that there is no more registered mDNS service
+    VerifyOrQuit(node0.Get<Dns::Multicast::Core>().GetNextService(*iterator, service, entryState) == kErrorNotFound);
+
+    node0.Get<Dns::Multicast::Core>().FreeIterator(*iterator);
+
+    Log("Wait for the ephemeral key to expire and validate the registered service is removed");
+
+    nexus.AdvanceTime(5 * Time::kOneMinuteInMsec);
+
+    iterator = node0.Get<Dns::Multicast::Core>().AllocateIterator();
+    VerifyOrQuit(iterator != nullptr);
+
+    SuccessOrQuit(node0.Get<Dns::Multicast::Core>().GetNextService(*iterator, service, entryState));
+    Log("  HostName: %s", service.mHostName);
+    Log("  ServiceInstance: %s", service.mServiceInstance);
+    Log("  ServiceType: %s", service.mServiceType);
+    Log("  Port: %u", service.mPort);
+    Log("  TTL: %lu", ToUlong(service.mTtl));
+
+    VerifyOrQuit(StringMatch(service.mServiceType, "_meshcop._udp"));
+    VerifyOrQuit(StringStartsWith(service.mServiceInstance, kDefaultServiceBaseName));
+    VerifyOrQuit(StringStartsWith(service.mHostName, "ot"));
+    VerifyOrQuit(service.mSubTypeLabelsLength == 0);
+    VerifyOrQuit(service.mPort == node0.Get<MeshCoP::BorderAgent>().GetUdpPort());
+    VerifyOrQuit(service.mTtl > 0);
+    VerifyOrQuit(service.mInfraIfIndex == kInfraIfIndex);
+    VerifyOrQuit(entryState == OT_MDNS_ENTRY_STATE_REGISTERED);
+    ValidateRegisteredServiceData(service, node0);
+
+    // Check that there is no more registered mDNS service
+    VerifyOrQuit(node0.Get<Dns::Multicast::Core>().GetNextService(*iterator, service, entryState) == kErrorNotFound);
+
+    node0.Get<Dns::Multicast::Core>().FreeIterator(*iterator);
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    Log("Change the base service name and validate the new service");
+
+    SuccessOrQuit(node0.Get<MeshCoP::BorderAgent>().SetServiceBaseName("OpenThreadAgent"));
+
+    nexus.AdvanceTime(30 * Time::kOneSecondInMsec);
+
+    iterator = node0.Get<Dns::Multicast::Core>().AllocateIterator();
+    VerifyOrQuit(iterator != nullptr);
+
+    SuccessOrQuit(node0.Get<Dns::Multicast::Core>().GetNextService(*iterator, service, entryState));
+    Log("  HostName: %s", service.mHostName);
+    Log("  ServiceInstance: %s", service.mServiceInstance);
+    Log("  ServiceType: %s", service.mServiceType);
+    Log("  Port: %u", service.mPort);
+    Log("  TTL: %lu", ToUlong(service.mTtl));
+
+    VerifyOrQuit(StringMatch(service.mServiceType, "_meshcop._udp"));
+    VerifyOrQuit(StringStartsWith(service.mServiceInstance, "OpenThreadAgent"));
+    VerifyOrQuit(StringStartsWith(service.mHostName, "ot"));
+    VerifyOrQuit(service.mSubTypeLabelsLength == 0);
+    VerifyOrQuit(service.mPort == node0.Get<MeshCoP::BorderAgent>().GetUdpPort());
+    VerifyOrQuit(service.mTtl > 0);
+    VerifyOrQuit(service.mInfraIfIndex == kInfraIfIndex);
+    VerifyOrQuit(entryState == OT_MDNS_ENTRY_STATE_REGISTERED);
+    ValidateRegisteredServiceData(service, node0);
+
+    // Check that there is no more registered mDNS service
+    VerifyOrQuit(node0.Get<Dns::Multicast::Core>().GetNextService(*iterator, service, entryState) == kErrorNotFound);
+
+    node0.Get<Dns::Multicast::Core>().FreeIterator(*iterator);
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    Log("Disable Border Agent and validate that registered service is removed");
+
+    node0.Get<MeshCoP::BorderAgent>().SetEnabled(false);
+    VerifyOrQuit(!node0.Get<MeshCoP::BorderAgent>().IsEnabled());
+
+    nexus.AdvanceTime(30 * Time::kOneSecondInMsec);
+
+    iterator = node0.Get<Dns::Multicast::Core>().AllocateIterator();
+    VerifyOrQuit(iterator != nullptr);
+
+    VerifyOrQuit(node0.Get<Dns::Multicast::Core>().GetNextService(*iterator, service, entryState) == kErrorNotFound);
+
+    node0.Get<Dns::Multicast::Core>().FreeIterator(*iterator);
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    Log("Re-enable Border Agent and validate that service is registered again");
+
+    node0.Get<MeshCoP::BorderAgent>().SetEnabled(true);
+    VerifyOrQuit(node0.Get<MeshCoP::BorderAgent>().IsEnabled());
+
+    nexus.AdvanceTime(30 * Time::kOneSecondInMsec);
+
+    iterator = node0.Get<Dns::Multicast::Core>().AllocateIterator();
+    VerifyOrQuit(iterator != nullptr);
+
+    SuccessOrQuit(node0.Get<Dns::Multicast::Core>().GetNextService(*iterator, service, entryState));
+    Log("  HostName: %s", service.mHostName);
+    Log("  ServiceInstance: %s", service.mServiceInstance);
+    Log("  ServiceType: %s", service.mServiceType);
+    Log("  Port: %u", service.mPort);
+    Log("  TTL: %lu", ToUlong(service.mTtl));
+
+    VerifyOrQuit(StringMatch(service.mServiceType, "_meshcop._udp"));
+    VerifyOrQuit(StringStartsWith(service.mServiceInstance, "OpenThreadAgent"));
+    VerifyOrQuit(StringStartsWith(service.mHostName, "ot"));
+    VerifyOrQuit(service.mSubTypeLabelsLength == 0);
+    VerifyOrQuit(service.mPort == node0.Get<MeshCoP::BorderAgent>().GetUdpPort());
+    VerifyOrQuit(service.mTtl > 0);
+    VerifyOrQuit(service.mInfraIfIndex == kInfraIfIndex);
+    VerifyOrQuit(entryState == OT_MDNS_ENTRY_STATE_REGISTERED);
+    ValidateRegisteredServiceData(service, node0);
+    txtDataLengthWithNoVendorData = service.mTxtDataLength;
+
+    // Check that there is no more registered mDNS service
+    VerifyOrQuit(node0.Get<Dns::Multicast::Core>().GetNextService(*iterator, service, entryState) == kErrorNotFound);
+
+    node0.Get<Dns::Multicast::Core>().FreeIterator(*iterator);
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    Log("Set vendor TXT data and validate that it is included in the registered mDNS service");
+
+    node0.Get<BorderAgent>().SetVendorTxtData(kVendorTxtData, sizeof(kVendorTxtData));
+    nexus.AdvanceTime(5 * Time::kOneSecondInMsec);
+
+    iterator = node0.Get<Dns::Multicast::Core>().AllocateIterator();
+    VerifyOrQuit(iterator != nullptr);
+
+    SuccessOrQuit(node0.Get<Dns::Multicast::Core>().GetNextService(*iterator, service, entryState));
+    Log("  HostName: %s", service.mHostName);
+    Log("  ServiceInstance: %s", service.mServiceInstance);
+    Log("  ServiceType: %s", service.mServiceType);
+    Log("  Port: %u", service.mPort);
+    Log("  TTL: %lu", ToUlong(service.mTtl));
+
+    VerifyOrQuit(StringMatch(service.mServiceType, "_meshcop._udp"));
+    VerifyOrQuit(StringStartsWith(service.mServiceInstance, "OpenThreadAgent"));
+    VerifyOrQuit(StringStartsWith(service.mHostName, "ot"));
+    VerifyOrQuit(service.mSubTypeLabelsLength == 0);
+    VerifyOrQuit(service.mPort == node0.Get<MeshCoP::BorderAgent>().GetUdpPort());
+    VerifyOrQuit(service.mTtl > 0);
+    VerifyOrQuit(service.mInfraIfIndex == kInfraIfIndex);
+    VerifyOrQuit(entryState == OT_MDNS_ENTRY_STATE_REGISTERED);
+    ValidateRegisteredServiceData(service, node0);
+
+    // Check that vendor TXT data is included at the end of
+    // the registered service TXT data.
+    VerifyOrQuit(service.mTxtDataLength > txtDataLengthWithNoVendorData);
+    VerifyOrQuit(service.mTxtDataLength > sizeof(kVendorTxtData));
+    VerifyOrQuit(!memcmp(&service.mTxtData[service.mTxtDataLength - sizeof(kVendorTxtData)], kVendorTxtData,
+                         sizeof(kVendorTxtData)));
+
+    // Check that there is no more registered mDNS service
+    VerifyOrQuit(node0.Get<Dns::Multicast::Core>().GetNextService(*iterator, service, entryState) == kErrorNotFound);
+
+    node0.Get<Dns::Multicast::Core>().FreeIterator(*iterator);
+
+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    Log("Clear vendor TXT data and validate that the registered mDNS service is updated accordingly");
+
+    node0.Get<BorderAgent>().SetVendorTxtData(nullptr, 0);
+    nexus.AdvanceTime(5 * Time::kOneSecondInMsec);
+
+    iterator = node0.Get<Dns::Multicast::Core>().AllocateIterator();
+    VerifyOrQuit(iterator != nullptr);
+
+    SuccessOrQuit(node0.Get<Dns::Multicast::Core>().GetNextService(*iterator, service, entryState));
+    Log("  HostName: %s", service.mHostName);
+    Log("  ServiceInstance: %s", service.mServiceInstance);
+    Log("  ServiceType: %s", service.mServiceType);
+    Log("  Port: %u", service.mPort);
+    Log("  TTL: %lu", ToUlong(service.mTtl));
+
+    VerifyOrQuit(StringMatch(service.mServiceType, "_meshcop._udp"));
+    VerifyOrQuit(StringStartsWith(service.mServiceInstance, "OpenThreadAgent"));
+    VerifyOrQuit(StringStartsWith(service.mHostName, "ot"));
+    VerifyOrQuit(service.mSubTypeLabelsLength == 0);
+    VerifyOrQuit(service.mPort == node0.Get<MeshCoP::BorderAgent>().GetUdpPort());
+    VerifyOrQuit(service.mTtl > 0);
+    VerifyOrQuit(service.mInfraIfIndex == kInfraIfIndex);
+    VerifyOrQuit(entryState == OT_MDNS_ENTRY_STATE_REGISTERED);
+    ValidateRegisteredServiceData(service, node0);
+    VerifyOrQuit(service.mTxtDataLength == txtDataLengthWithNoVendorData);
+
+    // Check that there is no more registered mDNS service
+    VerifyOrQuit(node0.Get<Dns::Multicast::Core>().GetNextService(*iterator, service, entryState) == kErrorNotFound);
+
+    node0.Get<Dns::Multicast::Core>().FreeIterator(*iterator);
 }
 
 } // namespace Nexus
@@ -882,7 +1734,9 @@ int main(void)
 {
     ot::Nexus::TestBorderAgent();
     ot::Nexus::TestBorderAgentEphemeralKey();
-    ot::Nexus::TestBorderAgentMeshCoPServiceChangedCallback();
+    ot::Nexus::TestHistoryTrackerBorderAgentEpskcEvent();
+    ot::Nexus::TestBorderAgentTxtDataCallback();
+    ot::Nexus::TestBorderAgentServiceRegisteration();
     printf("All tests passed\n");
     return 0;
 }
diff --git a/tests/nexus/test_dtls.cpp b/tests/nexus/test_dtls.cpp
index 6f52b0b7f..c9d85450f 100644
--- a/tests/nexus/test_dtls.cpp
+++ b/tests/nexus/test_dtls.cpp
@@ -247,12 +247,12 @@ void TestDtlsSingleSession(void)
     nexus.AdvanceTime(50 * Time::kOneSecondInMsec);
     VerifyOrQuit(node0.Get<Mle::Mle>().IsLeader());
 
-    SuccessOrQuit(node1.Get<Mle::MleRouter>().SetRouterEligible(false));
+    SuccessOrQuit(node1.Get<Mle::Mle>().SetRouterEligible(false));
     node1.Join(node0);
     nexus.AdvanceTime(20 * Time::kOneSecondInMsec);
     VerifyOrQuit(node1.Get<Mle::Mle>().IsChild());
 
-    SuccessOrQuit(node2.Get<Mle::MleRouter>().SetRouterEligible(false));
+    SuccessOrQuit(node2.Get<Mle::Mle>().SetRouterEligible(false));
     node2.Join(node0);
     nexus.AdvanceTime(20 * Time::kOneSecondInMsec);
     VerifyOrQuit(node2.Get<Mle::Mle>().IsChild());
@@ -489,12 +489,12 @@ void TestDtlsMultiSession(void)
     nexus.AdvanceTime(50 * Time::kOneSecondInMsec);
     VerifyOrQuit(node0.Get<Mle::Mle>().IsLeader());
 
-    SuccessOrQuit(node1.Get<Mle::MleRouter>().SetRouterEligible(false));
+    SuccessOrQuit(node1.Get<Mle::Mle>().SetRouterEligible(false));
     node1.Join(node0);
     nexus.AdvanceTime(20 * Time::kOneSecondInMsec);
     VerifyOrQuit(node1.Get<Mle::Mle>().IsChild());
 
-    SuccessOrQuit(node2.Get<Mle::MleRouter>().SetRouterEligible(false));
+    SuccessOrQuit(node2.Get<Mle::Mle>().SetRouterEligible(false));
     node2.Join(node0);
     nexus.AdvanceTime(20 * Time::kOneSecondInMsec);
     VerifyOrQuit(node2.Get<Mle::Mle>().IsChild());
diff --git a/tests/scripts/expect/cli-dataset.exp b/tests/scripts/expect/cli-dataset.exp
index 0b753000a..878922e9d 100755
--- a/tests/scripts/expect/cli-dataset.exp
+++ b/tests/scripts/expect/cli-dataset.exp
@@ -45,6 +45,17 @@ expect -re {Network Name: [^\r\n]+}
 expect -re {PAN ID: 0x[0-9a-f]{4}}
 expect -re {PSKc: [0-9a-f]{32}}
 expect -re {Security Policy: \d+ o?n?r?c?b?}
+send "dataset active -ns\n"
+expect -re {Active Timestamp: \d+}
+expect -re {Channel: (\d+)}
+expect -re {Channel Mask: 0x[0-9a-f]{8}}
+expect -re {Ext PAN ID: [0-9a-f]{16}}
+expect -re {Mesh Local Prefix: ([0-9a-f]{1,4}:){3}[0-9a-f]{1,4}::\/64}
+expect -re {Network Key: \[Redacted\]}
+expect -re {Network Name: [^\r\n]+}
+expect -re {PAN ID: 0x[0-9a-f]{4}}
+expect -re {PSKc: \[Redacted\]}
+expect -re {Security Policy: \d+ o?n?r?c?b?}
 send "dataset pending\n"
 expect "Error 23: NotFound"
 send "dataset init active\n"
diff --git a/tests/scripts/expect/cli-tcat-diagnostics.exp b/tests/scripts/expect/cli-tcat-diagnostics.exp
new file mode 100755
index 000000000..5b492320a
--- /dev/null
+++ b/tests/scripts/expect/cli-tcat-diagnostics.exp
@@ -0,0 +1,98 @@
+#!/usr/bin/expect -f
+#
+#  Copyright (c) 2025, The OpenThread Authors.
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions are met:
+#  1. Redistributions of source code must retain the above copyright
+#     notice, this list of conditions and the following disclaimer.
+#  2. Redistributions in binary form must reproduce the above copyright
+#     notice, this list of conditions and the following disclaimer in the
+#     documentation and/or other materials provided with the distribution.
+#  3. Neither the name of the copyright holder nor the
+#     names of its contributors may be used to endorse or promote products
+#     derived from this software without specific prior written permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+#  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+#  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+#  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+#  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+#  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+#  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+#  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+#  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+#  POSSIBILITY OF SUCH DAMAGE.
+#
+
+source "tests/scripts/expect/_common.exp"
+source "tests/scripts/expect/_multinode.exp"
+
+spawn_node 2 "cli"
+spawn_node 1 "cli"
+setup_leader
+setup_node 2
+
+switch_node 1
+
+spawn_tcat_client_for_node 1
+
+send "diagnostic_tlvs extaddr\n"
+expect_line "\tTYPE:\tRESPONSE_W_PAYLOAD"
+expect_line "\tLEN:\t10"
+expect -re {\tVALUE:\t0x0008([0-9a-fA-F]{16})}
+
+send "diagnostic_tlvs macaddr\n"
+expect_line "\tTYPE:\tRESPONSE_W_PAYLOAD"
+expect_line "\tLEN:\t4"
+expect -re {\tVALUE:\t0x0102([0-9a-fA-F]{4})}
+
+send "diagnostic_tlvs mode timeout connectivity\n"
+expect_line "\tTYPE:\tRESPONSE_W_PAYLOAD"
+expect_line "\tLEN:\t15"
+expect -re {\tVALUE:\t0x0201([0-9a-fA-F]{2})040a([0-9a-fA-F]{20})}
+
+send "diagnostic_tlvs route64 leaderdata\n"
+expect_line "\tTYPE:\tRESPONSE_W_PAYLOAD"
+expect_line "\tLEN:\t22"
+expect -re {\tVALUE:\t0x050a([0-9a-fA-F]{20})0608([0-9a-fA-F]{16})}
+
+send "diagnostic_tlvs ipaddr\n"
+expect_line "\tTYPE:\tRESPONSE_W_PAYLOAD"
+expect -re {\tLEN:\t([0-9]{2,3})}
+expect -re {\tVALUE:\t0x08([0-9a-fA-F]{33,197})}
+
+send "diagnostic_tlvs mlecounters\n"
+expect_line "\tTYPE:\tRESPONSE_W_PAYLOAD"
+expect_line "\tLEN:\t68"
+expect -re {\tVALUE:\t0x2242([0-9a-fA-F]{132})}
+
+send "diagnostic_tlvs channelpages maxchildtimeout eui64 vendorname vendormodel vendorswversion vendorappurl\n"
+expect_line "\tTYPE:\tRESPONSE_W_PAYLOAD"
+expect_line "\tLEN:\t27"
+expect_line "\tVALUE:\t0x1101001304000000f0170818b430000000000119001a001b002300"
+
+send "diagnostic_tlvs childtable\n"
+expect_line "\tTYPE:\tRESPONSE_W_PAYLOAD"
+expect_line "\tLEN:\t5"
+expect -re {\tVALUE:\t0x1003([0-9a-fA-F]{6})}
+
+send "diagnostic_tlvs child\n"
+expect_line "\tTYPE:\tRESPONSE_W_PAYLOAD"
+expect_line "\tLEN:\t47"
+expect -re {\tVALUE:\t0x1d2b([0-9a-fA-F]{86})1d00}
+
+send "diagnostic_tlvs childipv6list routerneighbor\n"
+expect_line "\tTYPE:\tRESPONSE_W_PAYLOAD"
+expect -re {\tLEN:\t([0-9]{2})}
+expect -re {\tVALUE:\t0x1e([0-9a-fA-F]{6,69})1e001f00}
+
+dispose_tcat_client 1
+
+switch_node 1
+send "tcat stop\n"
+expect_line "Done"
+
+dispose_all
diff --git a/tests/scripts/misc/test_rcp_reset.py b/tests/scripts/misc/test_rcp_reset.py
index 3b9a37b44..c17856187 100644
--- a/tests/scripts/misc/test_rcp_reset.py
+++ b/tests/scripts/misc/test_rcp_reset.py
@@ -40,7 +40,7 @@ def main():
 
     args = parser.parse_args()
 
-    stream = StreamOpen('p', f'{args.rcp} 1', False, 115200, False)
+    stream = StreamOpen('p', f'{args.rcp} 1', False, 460800, False)
     wpan_api = WpanApi(stream, 1)
 
     assert wpan_api.prop_set_value(SPINEL.PROP_PHY_ENABLED, 1) == 1
diff --git a/tests/scripts/thread-cert/border_router/internet/test_multi_border_routers.py b/tests/scripts/thread-cert/border_router/internet/test_multi_border_routers.py
index 32ef64ab3..25a8e4d35 100755
--- a/tests/scripts/thread-cert/border_router/internet/test_multi_border_routers.py
+++ b/tests/scripts/thread-cert/border_router/internet/test_multi_border_routers.py
@@ -49,10 +49,6 @@ ROUTER = 2
 BR2 = 3
 HOST = 4
 
-OMR_PREFIX = "2000:0:1111:4444::/64"
-
-NAT64_PREFIX_REFRESH_DELAY = 305
-
 NAT64_STATE_DISABLED = 'disabled'
 NAT64_STATE_NOT_RUNNING = 'not_running'
 NAT64_STATE_IDLE = 'idle'
@@ -100,8 +96,6 @@ class Nat64MultiBorderRouter(thread_cert.TestCase):
         # ensure NAT64 is enabled here.
         br1.nat64_set_enabled(True)
         self.simulator.go(config.LEADER_STARTUP_DELAY)
-        br1.bash("service bind9 stop")
-        self.simulator.go(NAT64_PREFIX_REFRESH_DELAY)
         self.assertEqual('leader', br1.get_state())
 
         router.start()
@@ -109,9 +103,7 @@ class Nat64MultiBorderRouter(thread_cert.TestCase):
         self.assertEqual('router', router.get_state())
 
         #
-        # Case 1. BR2 with an infrastructure prefix joins the network later and
-        #         it will add the infrastructure nat64 prefix to Network Data.
-        #         Note: NAT64 translator will be bypassed.
+        # Case 1. BR2 joins the network and it will not add its local nat64 prefix to Network Data.
         #
         br2.start()
         # When feature flag is enabled, NAT64 might be disabled by default. So
@@ -120,60 +112,9 @@ class Nat64MultiBorderRouter(thread_cert.TestCase):
         self.simulator.go(config.BORDER_ROUTER_STARTUP_DELAY)
         self.assertEqual('router', br2.get_state())
 
-        br2.add_prefix(OMR_PREFIX)
-        br2.register_netdata()
         self.simulator.go(10)
-
-        self.simulator.go(10)
-        self.assertNotEqual(br1.get_br_favored_nat64_prefix(), br2.get_br_favored_nat64_prefix())
         br1_local_nat64_prefix = br1.get_br_nat64_prefix()
         br2_local_nat64_prefix = br2.get_br_nat64_prefix()
-        self.assertNotEqual(br2_local_nat64_prefix, br2.get_br_favored_nat64_prefix())
-        br2_infra_nat64_prefix = br2.get_br_favored_nat64_prefix()
-
-        self.assertEqual(len(br1.get_netdata_nat64_routes()), 1)
-        nat64_prefix = br1.get_netdata_nat64_routes()[0]
-        self.assertEqual(nat64_prefix, br2_infra_nat64_prefix)
-        self.assertNotEqual(nat64_prefix, br1_local_nat64_prefix)
-        self.assertDictIncludes(br1.nat64_state, {
-            'PrefixManager': NAT64_STATE_IDLE,
-            'Translator': NAT64_STATE_NOT_RUNNING
-        })
-        self.assertDictIncludes(br2.nat64_state, {
-            'PrefixManager': NAT64_STATE_ACTIVE,
-            'Translator': NAT64_STATE_NOT_RUNNING
-        })
-
-        #
-        # Case 2. Disable NAT64 on BR2.
-        #         BR1 will add its local nat64 prefix.
-        #
-        br2.nat64_set_enabled(False)
-        self.simulator.go(10)
-
-        self.assertEqual(len(br1.get_netdata_nat64_routes()), 1)
-        nat64_prefix = br1.get_netdata_nat64_routes()[0]
-        self.assertEqual(nat64_prefix, br1_local_nat64_prefix)
-        self.assertDictIncludes(br1.nat64_state, {
-            'PrefixManager': NAT64_STATE_ACTIVE,
-            'Translator': NAT64_STATE_ACTIVE
-        })
-        self.assertDictIncludes(br2.nat64_state, {
-            'PrefixManager': NAT64_STATE_DISABLED,
-            'Translator': NAT64_STATE_DISABLED
-        })
-
-        #
-        # Case 3. Re-enables BR2 with a local prefix and it will not add
-        #         its local nat64 prefix to Network Data.
-        #
-        br2.bash("service bind9 stop")
-        self.simulator.go(5)
-        br2.nat64_set_enabled(True)
-
-        self.simulator.go(10)
-        self.assertEqual(br2_local_nat64_prefix, br2.get_br_favored_nat64_prefix())
-
         self.assertEqual(len(br1.get_netdata_nat64_routes()), 1)
         nat64_prefix = br1.get_netdata_nat64_routes()[0]
         self.assertEqual(nat64_prefix, br1_local_nat64_prefix)
@@ -188,7 +129,7 @@ class Nat64MultiBorderRouter(thread_cert.TestCase):
         })
 
         #
-        # Case 4. Disable NAT64 on BR1.
+        # Case 2. Disable NAT64 on BR1.
         #         BR1 withdraws its local prefix and BR2 advertises its local prefix.
         #
         br1.nat64_set_enabled(False)
@@ -208,7 +149,7 @@ class Nat64MultiBorderRouter(thread_cert.TestCase):
         })
 
         #
-        # Case 5. Re-enable NAT64 on BR1.
+        # Case 3. Re-enable NAT64 on BR1.
         #         NAT64 prefix in Network Data is still BR2's local prefix.
         #
         br1.nat64_set_enabled(True)
@@ -228,7 +169,7 @@ class Nat64MultiBorderRouter(thread_cert.TestCase):
         })
 
         #
-        # Case 6. Disable the routing manager should stop NAT64 prefix manager.
+        # Case 4. Disable the routing manager should stop NAT64 prefix manager.
         #
         #
         br2.disable_br()
@@ -247,7 +188,7 @@ class Nat64MultiBorderRouter(thread_cert.TestCase):
         })
 
         #
-        # Case 7. Enable the routing manager the BR should start NAT64 prefix manager if the prefix manager is enabled.
+        # Case 5. Enable the routing manager the BR should start NAT64 prefix manager if the prefix manager is enabled.
         #
         #
         br2.enable_br()
diff --git a/tests/scripts/thread-cert/border_router/internet/test_single_border_router.py b/tests/scripts/thread-cert/border_router/internet/test_single_border_router.py
index 33d010e5e..fe334fe14 100755
--- a/tests/scripts/thread-cert/border_router/internet/test_single_border_router.py
+++ b/tests/scripts/thread-cert/border_router/internet/test_single_border_router.py
@@ -123,7 +123,7 @@ class Nat64SingleBorderRouter(thread_cert.TestCase):
         # ensure NAT64 is enabled here.
         br.nat64_set_enabled(True)
         self.simulator.go(config.LEADER_STARTUP_DELAY)
-        br.bash("service bind9 stop")
+        br.bash("service bind9 stop || true")
         self.simulator.go(330)
         self.assertEqual('leader', br.get_state())
 
diff --git a/tests/scripts/thread-cert/border_router/internet/test_upstream_dns.py b/tests/scripts/thread-cert/border_router/internet/test_upstream_dns.py
index 238f32b12..e53ae8550 100755
--- a/tests/scripts/thread-cert/border_router/internet/test_upstream_dns.py
+++ b/tests/scripts/thread-cert/border_router/internet/test_upstream_dns.py
@@ -39,29 +39,23 @@ import shlex
 # a record resolved by BIND9 server.
 #
 # Topology:
-#    ----------------(eth)--------------------
-#           |                 |
-#          BR (Leader)      DNS SERVER
+#    ----------------(eth)----------------------------------
+#           |                 |                  |
+#        BR (Leader)     DNS SERVER 1       DNS SERVER 2
 #           |
 #        ROUTER
 #
 
 BR = 1
 ROUTER = 2
-DNS_SERVER = 3
+DNS_SERVER_1 = 3
+DNS_SERVER_2 = 4
 
-TEST_DOMAIN = 'test.domain'
-TEST_DOMAIN_IP6_ADDRESSES = {'2001:db8::1'}
+TEST_DOMAIN_1 = 'test.domain.resolv'
+TEST_DOMAIN_IP6_ADDRESSES_1 = {'2001:db8::1'}
 
-TEST_DOMAIN_BIND_CONF = f'''
-zone "{TEST_DOMAIN}" {{ type master; file "/etc/bind/db.test.domain"; }};
-'''
-
-TEST_DOMAIN_BIND_ZONE = f'''
-$TTL 24h
-@ IN SOA {TEST_DOMAIN} test.{TEST_DOMAIN}. ( 20230330 86400 300 604800 3600 )
-@ IN NS {TEST_DOMAIN}.
-''' + '\n'.join(f'@ IN AAAA {addr}' for addr in TEST_DOMAIN_IP6_ADDRESSES)
+TEST_DOMAIN_2 = 'test.domain.rdnss'
+TEST_DOMAIN_IP6_ADDRESSES_2 = {'2001:db8::2'}
 
 
 class UpstreamDns(thread_cert.TestCase):
@@ -77,8 +71,12 @@ class UpstreamDns(thread_cert.TestCase):
             'name': 'Router',
             'version': '1.4',
         },
-        DNS_SERVER: {
-            'name': 'DNS Server',
+        DNS_SERVER_1: {
+            'name': 'DNS Server 1',
+            'is_host': True
+        },
+        DNS_SERVER_2: {
+            'name': 'DNS Server 2',
             'is_host': True
         },
     }
@@ -86,18 +84,14 @@ class UpstreamDns(thread_cert.TestCase):
     def test(self):
         br = self.nodes[BR]
         router = self.nodes[ROUTER]
-        dns_server = self.nodes[DNS_SERVER]
+        dns_server_1 = self.nodes[DNS_SERVER_1]
+        dns_server_2 = self.nodes[DNS_SERVER_2]
 
-        self._start_dns_server(dns_server)
-        dns_server_addr = dns_server.get_ether_addrs(ipv4=True, ipv6=False)[0]
+        self._start_dns_server(dns_server_1, TEST_DOMAIN_1, TEST_DOMAIN_IP6_ADDRESSES_1)
+        self._start_dns_server(dns_server_2, TEST_DOMAIN_2, TEST_DOMAIN_IP6_ADDRESSES_2)
 
         # Disable the bind9 service on the BR otherwise bind9 may respond to Thread devices' DNS queries
-        br.bash('service bind9 stop')
-
-        # Update BR's /etc/resolv.conf and force BR to reload it
-        br.bash(shlex.join(['echo', 'nameserver ' + dns_server_addr]) + ' > /etc/resolv.conf')
-        br.stop_otbr_service()
-        br.start_otbr_service()
+        br.bash('service bind9 stop || true')
 
         br.start()
         self.simulator.go(config.LEADER_STARTUP_DELAY)
@@ -115,26 +109,45 @@ class UpstreamDns(thread_cert.TestCase):
         self.simulator.go(10)
         router.srp_client_enable_auto_start_mode()
 
-        # verify the server can forward the DNS query to upstream server.
-        self._verify_upstream_dns(br, router)
-
-    def _verify_upstream_dns(self, br, ed):
-        upstream_dns_enabled = br.dns_upstream_query_state
-        if not upstream_dns_enabled:
-            br.dns_upstream_query_state = True
+        br.dns_upstream_query_state = True
         self.assertTrue(br.dns_upstream_query_state)
 
-        resolved_names = ed.dns_resolve(TEST_DOMAIN)
-        self.assertEqual(len(resolved_names), len(TEST_DOMAIN_IP6_ADDRESSES))
-        for record in resolved_names:
-            self.assertIn(ipaddress.IPv6Address(record[0]).compressed, TEST_DOMAIN_IP6_ADDRESSES)
+        # Update BR's /etc/resolv.conf with the address of DNS server 1 and force BR to reload it
+        dns_server_addr_1 = dns_server_1.get_ether_addrs(ipv4=True, ipv6=False)[0]
+        br.bash(shlex.join(['echo', 'nameserver ' + dns_server_addr_1]) + ' > /etc/resolv.conf')
+        br.stop_otbr_service()
+        br.start_otbr_service()
+
+        # Publish RDNSS with the address of DNS server 2 through RA
+        dns_server_addr_2 = dns_server_2.get_ip6_address(config.ADDRESS_TYPE.ONLINK_ULA)[0]
+        br.start_rdnss_radvd_service(dns_server_addr_2)
+
+        self.simulator.go(10)
+        # verify the server can forward the DNS query to the two upstream servers.
+        resolved_addresses_1 = set(
+            ipaddress.IPv6Address(record[0]).compressed for record in router.dns_resolve(TEST_DOMAIN_1))
+        self.assertEqual(resolved_addresses_1, TEST_DOMAIN_IP6_ADDRESSES_1)
+
+        resolved_addresses_2 = set(
+            ipaddress.IPv6Address(record[0]).compressed for record in router.dns_resolve(TEST_DOMAIN_2))
+        self.assertEqual(resolved_addresses_2, TEST_DOMAIN_IP6_ADDRESSES_2)
+
+    def _start_dns_server(self, dns_server, test_domain, test_domain_ip6_addresses):
+        test_domain_bind_conf = f'''
+zone "{test_domain}" {{ type master; file "/etc/bind/db.test.domain"; }};
+'''
+
+        test_domain_bind_zone = f'''
+$TTL 24h
+@ IN SOA {test_domain} test.{test_domain}. ( 20230330 86400 300 604800 3600 )
+@ IN NS {test_domain}.
+''' + '\n'.join(f'@ IN AAAA {addr}' for addr in test_domain_ip6_addresses)
 
-    def _start_dns_server(self, dns_server):
         dns_server.start(start_radvd=False)
-        dns_server.bash('service bind9 stop')
+        dns_server.bash('service bind9 stop || true')
 
-        dns_server.bash(shlex.join(['echo', TEST_DOMAIN_BIND_CONF]) + ' >> /etc/bind/named.conf.local')
-        dns_server.bash(shlex.join(['echo', TEST_DOMAIN_BIND_ZONE]) + ' >> /etc/bind/db.test.domain')
+        dns_server.bash(shlex.join(['echo', test_domain_bind_conf]) + ' >> /etc/bind/named.conf.local')
+        dns_server.bash(shlex.join(['echo', test_domain_bind_zone]) + ' >> /etc/bind/db.test.domain')
 
         dns_server.bash('service bind9 start')
 
diff --git a/tests/scripts/thread-cert/border_router/internet/test_with_infrastructure_prefix.py b/tests/scripts/thread-cert/border_router/internet/test_with_infrastructure_prefix.py
index 21ab2ba54..7bb826c50 100755
--- a/tests/scripts/thread-cert/border_router/internet/test_with_infrastructure_prefix.py
+++ b/tests/scripts/thread-cert/border_router/internet/test_with_infrastructure_prefix.py
@@ -77,6 +77,9 @@ class Nat64SingleBorderRouter(thread_cert.TestCase):
     }
 
     def test(self):
+        # TODO: re-enable test when PREF64 capability is ready
+        return
+
         br = self.nodes[BR]
         router = self.nodes[ROUTER]
 
@@ -157,7 +160,7 @@ class Nat64SingleBorderRouter(thread_cert.TestCase):
         self.simulator.go(5)
 
         # Case 5 Infrastructure nat64 prefix no longer presents
-        br.bash("service bind9 stop")
+        br.bash("service bind9 stop || true")
         self.simulator.go(NAT64_PREFIX_REFRESH_DELAY)
 
         local_nat64_prefix = br.get_br_nat64_prefix()
diff --git a/tests/scripts/thread-cert/border_router/test_dnssd_server.py b/tests/scripts/thread-cert/border_router/test_dnssd_server.py
index cb0d1f8ea..82bc34beb 100755
--- a/tests/scripts/thread-cert/border_router/test_dnssd_server.py
+++ b/tests/scripts/thread-cert/border_router/test_dnssd_server.py
@@ -196,11 +196,6 @@ class TestDnssdServerOnBr(thread_cert.TestCase):
             })
 
         # check some invalid queries
-        for qtype in ['CNAME']:
-            dig_result = digger.dns_dig(server_addr, host1_full_name, qtype)
-            self._assert_dig_result_matches(dig_result, {
-                'status': 'NOTIMP',
-            })
 
         for service_name in WRONG_SERVICE_NAMES:
             dig_result = digger.dns_dig(server_addr, service_name, 'PTR')
diff --git a/tests/scripts/thread-cert/border_router/test_dnssd_server_multi_border_routers.py b/tests/scripts/thread-cert/border_router/test_dnssd_server_multi_border_routers.py
index 4741049ef..c85e680ce 100755
--- a/tests/scripts/thread-cert/border_router/test_dnssd_server_multi_border_routers.py
+++ b/tests/scripts/thread-cert/border_router/test_dnssd_server_multi_border_routers.py
@@ -278,11 +278,6 @@ class TestDnssdServerOnMultiBr(thread_cert.TestCase):
         self._verify_discovery_proxy_meshcop(br2_addr, br2.get_network_name(), host)
 
         # 4. Check some invalid queries
-        for qtype in ['CNAME']:
-            dig_result = host.dns_dig(br2_addr, host1_full_name, qtype)
-            self._assert_dig_result_matches(dig_result, {
-                'status': 'NOTIMP',
-            })
 
         for service_name in WRONG_SERVICE_NAMES:
             dig_result = host.dns_dig(br2_addr, service_name, 'PTR')
diff --git a/tests/scripts/thread-cert/border_router/test_publish_meshcop_service.py b/tests/scripts/thread-cert/border_router/test_publish_meshcop_service.py
index 7b5c8277a..daf3cbf25 100755
--- a/tests/scripts/thread-cert/border_router/test_publish_meshcop_service.py
+++ b/tests/scripts/thread-cert/border_router/test_publish_meshcop_service.py
@@ -209,7 +209,10 @@ class PublishMeshCopService(thread_cert.TestCase):
         sb_data = service_data['txt']['sb'].encode('raw_unicode_escape')
         state_bitmap = int.from_bytes(sb_data, byteorder='big')
         logging.info(bin(state_bitmap))
-        self.assertEqual((state_bitmap & 7), 1)  # connection mode = PskC
+        if br.get_ba_state() == 'Active':
+            self.assertEqual((state_bitmap & 7), 1)  # connection mode = PskC
+        else:
+            self.assertEqual((state_bitmap & 7), 0)  # connection mode = Disabled
         sb_thread_interface_status = state_bitmap >> 3 & 3
         sb_thread_role = state_bitmap >> 9 & 3
         device_role = br.get_state()
diff --git a/tests/scripts/thread-cert/command.py b/tests/scripts/thread-cert/command.py
index ed966eae9..09b7423c0 100644
--- a/tests/scripts/thread-cert/command.py
+++ b/tests/scripts/thread-cert/command.py
@@ -144,8 +144,8 @@ def check_tlv_request_tlv(command_msg, check_type, tlv_id):
 
     elif check_type == CheckType.NOT_CONTAIN:
         if tlv_request_tlv is not None:
-            assert (any(tlv_id == tlv for tlv in tlv_request_tlv.tlvs) is
-                    False), "Error: The msg contains TLV Request TLV ID: {}".format(tlv_id)
+            assert (not any(tlv_id == tlv
+                            for tlv in tlv_request_tlv.tlvs)), f"Error: The msg contains TLV Request TLV ID: {tlv_id}"
 
     elif check_type == CheckType.OPTIONAL:
         if tlv_request_tlv is not None:
diff --git a/tests/scripts/thread-cert/node.py b/tests/scripts/thread-cert/node.py
index ea0e53f69..868fa7418 100755
--- a/tests/scripts/thread-cert/node.py
+++ b/tests/scripts/thread-cert/node.py
@@ -1264,17 +1264,8 @@ class NodeImpl:
                 return service
 
     def get_srp_server_port(self):
-        """Returns the SRP server UDP port by parsing
-           the SRP Server Data in Network Data.
-        """
-
-        for service in self.get_services():
-            # TODO: for now, we are using 0xfd as the SRP service data.
-            #       May use a dedicated bit flag for SRP server.
-            if int(service[1], 16) == 0x5d:
-                # The SRP server data contains IPv6 address (16 bytes)
-                # followed by UDP port number.
-                return int(service[2][2 * 16:], 16)
+        self.send_command('srp server port')
+        return int(self._expect_result(r'\d+'))
 
     def srp_client_start(self, server_address, server_port):
         self.send_command(f'srp client start {server_address} {server_port}')
@@ -1922,6 +1913,11 @@ class NodeImpl:
         self.send_command(cmd)
         self._expect_done()
 
+    def get_ba_state(self):
+        states = [r'Disabled', r'Inactive', r'Active']
+        self.send_command('ba state')
+        return self._expect_result(states)
+
     def get_ephemeral_key_state(self):
         cmd = 'ba ephemeralkey'
         states = [r'Disabled', r'Stopped', r'Started', r'Connected', r'Accepted']
@@ -3590,6 +3586,52 @@ class NodeImpl:
             index = index + (5 if result[ins] else 1)
         return result
 
+    def dns_query(self, rrtype, first_label, next_labels, server=None, port=53):
+        """
+        Send a DNS query for a given record type and name.
+
+        Output is an array of records (as dictionary) with string keys and values.
+        [
+           {'RecordType': '25',
+           'RecordLength': '78',
+           'TTL': '7105',
+           'Section': 'answer',
+           'Name': 'ins1._IPPS._TCP.DEFAULT.SERVICE.ARPA.',
+           'RecordData': '[001900010000a0610...d45d3]'
+           }
+        ]
+        """
+        cmd = f'dns query {rrtype} {first_label} {next_labels}'
+        if server is not None:
+            cmd += f' {server} {port}'
+
+        self.send_command(cmd)
+        self.simulator.go(10)
+        output = self._expect_command_output()
+
+        # Example output:
+        # DNS query response for ins1._IPPS._TCP.DEFAULT.SERVICE.ARPA.
+        # 0)
+        #   RecordType:25, RecordLength:78, TTL:7105, Section:answer
+        #   Name:ins1._IPPS._TCP.DEFAULT.SERVICE.ARPA.
+        #   RecordData:[00190001000...cdb]
+        # Done
+
+        result = []
+        index = 1  # Skip first line
+        while (index < len(output)):
+            if (index > len(output) - 4):
+                break
+            record = {}
+            for line in output[index + 1:index + 4]:
+                for item in line.strip().split(','):
+                    k, v = item.split(':')
+                    record[k.strip()] = v.strip()
+            result.append(record)
+            index += 4
+
+        return result
+
     def set_mliid(self, mliid: str):
         cmd = f'mliid {mliid}'
         self.send_command(cmd)
@@ -4084,6 +4126,15 @@ class LinuxHost():
                 service['addresses'] = addresses
         return service or None
 
+    def _start_radvd_and_verify(self):
+        self.bash('service radvd start')
+
+        output = self.bash('service radvd status')
+        for line in output:
+            if "running" in line:
+                return
+        raise Exception("Failed to start radvd service")
+
     def start_radvd_service(self, prefix, slaac):
         self.bash("""cat >/etc/radvd.conf <<EOF
 interface eth0
@@ -4108,8 +4159,7 @@ interface eth0
 };
 EOF
 """ % (prefix, 'on' if slaac else 'off'))
-        self.bash('service radvd start')
-        self.bash('service radvd status')  # Make sure radvd service is running
+        self._start_radvd_and_verify()
 
     def start_pd_radvd_service(self, prefix):
         self.bash("""cat >/etc/radvd.conf <<EOF
@@ -4135,8 +4185,29 @@ interface wpan0
 };
 EOF
 """ % (prefix,))
-        self.bash('service radvd start')
-        self.bash('service radvd status')  # Make sure radvd service is running
+        self._start_radvd_and_verify()
+
+    def start_rdnss_radvd_service(self, dns_server_address):
+        self.bash(f"""cat >/etc/radvd.conf <<EOF
+interface eth0
+{{
+    AdvSendAdvert on;
+
+    AdvReachableTime 20;
+    AdvRetransTimer 20;
+    AdvDefaultLifetime 180;
+    MinRtrAdvInterval 120;
+    MaxRtrAdvInterval 180;
+    AdvDefaultPreference low;
+
+    RDNSS {dns_server_address}
+    {{
+        AdvRDNSSLifetime 1800;
+    }};
+}};
+EOF
+""")
+        self._start_radvd_and_verify()
 
     def stop_radvd_service(self):
         self.bash('service radvd stop')
diff --git a/tests/scripts/thread-cert/test_dnssd.py b/tests/scripts/thread-cert/test_dnssd.py
index 38c4f85ef..5642a0e1e 100755
--- a/tests/scripts/thread-cert/test_dnssd.py
+++ b/tests/scripts/thread-cert/test_dnssd.py
@@ -209,6 +209,54 @@ class TestDnssd(thread_cert.TestCase):
         service_instance = client1.dns_resolve_service('ins4', f'{SERVICE}.{DOMAIN}'.upper(), server.get_mleid(), 53)
         self._assert_service_instance_equal(service_instance, instance4_verify_info)
 
+        #---------------------------------------------------------------
+        # Query for KEY record for `ins1` service name
+
+        records = client1.dns_query(25, 'ins1', f'{SERVICE}.{DOMAIN}'.upper(), server.get_mleid(), 53)
+        self.assertEqual(len(records), 1)
+        record = records[0]
+        self.assertEqual(int(record['RecordType']), 25)
+        self.assertEqual(int(record['RecordLength']), 78)
+        self.assertTrue(int(record['TTL']) > 0)
+        self.assertEqual(record['Section'], 'answer')
+        self.assertEqual(record['Name'].lower(), 'ins1._ipps._tcp.default.service.arpa.')
+        self.assertIn('RecordData', record)
+
+        #---------------------------------------------------------------
+        # Query for SRV record for `ins1` service name
+
+        records = client1.dns_query(33, 'ins1', f'{SERVICE}.{DOMAIN}'.upper(), server.get_mleid(), 53)
+        self.assertEqual(len(records), 4)
+
+        # SRV record in answer section
+        record = records[0]
+        self.assertEqual(int(record['RecordType']), 33)
+        self.assertTrue(int(record['RecordLength']) > 0)
+        self.assertTrue(int(record['TTL']) > 0)
+        self.assertEqual(record['Section'], 'answer')
+        self.assertEqual(record['Name'].lower(), 'ins1._ipps._tcp.default.service.arpa.')
+        self.assertIn('RecordData', record)
+
+        # Other records TXT and A in additional section
+        for record in records[1:]:
+            self.assertTrue(int(record['RecordLength']) > 0)
+            self.assertIn('RecordData', record)
+            self.assertTrue(int(record['TTL']) > 0)
+            self.assertEqual(record['Section'], 'additional')
+            rrtype = int(record['RecordType'])
+            self.assertIn(rrtype, [16, 28])  # TXT and AAAA
+            if rrtype == 16:
+                self.assertEqual(record['Name'].lower(), 'ins1._ipps._tcp.default.service.arpa.')
+                self.assertEqual(record['RecordData'], '[00]')
+            else:
+                self.assertEqual(record['Name'].lower(), 'host1.default.service.arpa.')
+
+        #---------------------------------------------------------------
+        # Query for non-existing A record for `ins1` service name
+
+        records = client1.dns_query(1, 'ins1', f'{SERVICE}.{DOMAIN}'.upper(), server.get_mleid(), 53)
+        self.assertEqual(len(records), 0)
+
     def _assert_service_instance_equal(self, instance, info):
         self.assertEqual(instance['host'].lower(), info['host'].lower(), instance)
         for f in ('port', 'priority', 'weight', 'txt_data'):
diff --git a/tests/toranj/cli/cli.py b/tests/toranj/cli/cli.py
index 4bd3ecaa8..7be26e2c7 100644
--- a/tests/toranj/cli/cli.py
+++ b/tests/toranj/cli/cli.py
@@ -851,6 +851,9 @@ class Node(object):
     def br_count_peers(self):
         return self._cli_single_output('br peers count')
 
+    def br_get_multiail(self):
+        return self._cli_single_output('br multiail')
+
     #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     # trel
 
diff --git a/tests/toranj/cli/test-019-netdata-context-id.py b/tests/toranj/cli/test-019-netdata-context-id.py
index 68029da21..ca1a58fc0 100755
--- a/tests/toranj/cli/test-019-netdata-context-id.py
+++ b/tests/toranj/cli/test-019-netdata-context-id.py
@@ -107,13 +107,18 @@ def check_netdata_1():
 
 verify_within(check_netdata_1, 5)
 
+
+def parse_context_flags(context):
+    return context.split()[-1]
+
+
 contexts = netdata['contexts']
 verify(len(contexts) == 3)
 verify(any([context.startswith('fd00:1:0:0::/64') for context in contexts]))
 verify(any([context.startswith('fd00:2:0:0::/64') for context in contexts]))
 verify(any([context.startswith('fd00:3:0:0::/64') for context in contexts]))
 for context in contexts:
-    verify(context.endswith('c'))
+    verify('c' in parse_context_flags(context))
 
 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 # Remove prefix on `r3`. Validate that Context compress flag
@@ -140,9 +145,9 @@ verify(any([context.startswith('fd00:2:0:0::/64') for context in contexts]))
 verify(any([context.startswith('fd00:3:0:0::/64') for context in contexts]))
 for context in contexts:
     if context.startswith('fd00:1:0:0::/64') or context.startswith('fd00:2:0:0::/64'):
-        verify(context.endswith('c'))
+        verify('c' in parse_context_flags(context))
     else:
-        verify(context.endswith('-'))
+        verify('c' not in parse_context_flags(context))
 
 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 # Validate that the prefix context is removed within reuse delay
@@ -200,7 +205,7 @@ verify(any([context.startswith('fd00:2:0:0::/64') for context in contexts]))
 verify(any([context.startswith('fd00:3:0:0::/64') for context in contexts]))
 verify(any([context.startswith('fd00:4:0:0::/64') for context in contexts]))
 for context in contexts:
-    verify(context.endswith('c'))
+    verify('c' in parse_context_flags(context))
 
 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 # Remove prefixes on `r1` and `r2` and re-add them back quickly both
@@ -236,9 +241,9 @@ verify(any([context.startswith('fd00:3:0:0::/64') for context in contexts]))
 verify(any([context.startswith('fd00:4:0:0::/64') for context in contexts]))
 for context in contexts:
     if context.startswith('fd00:1:0:0::/64') or context.startswith('fd00:2:0:0::/64'):
-        verify(context.endswith('-'))
+        verify('c' not in parse_context_flags(context))
     else:
-        verify(context.endswith('c'))
+        verify('c' in parse_context_flags(context))
 
 # Re-add both prefixes (now from `r2`) before CID remove delay time
 # is expired.
@@ -264,7 +269,7 @@ verify(any([context.startswith('fd00:2:0:0::/64') for context in contexts]))
 verify(any([context.startswith('fd00:3:0:0::/64') for context in contexts]))
 verify(any([context.startswith('fd00:4:0:0::/64') for context in contexts]))
 for context in contexts:
-    verify(context.endswith('c'))
+    verify('c' in parse_context_flags(context))
     if context.startswith('fd00:1:0:0::/64'):
         verify(int(context.split()[1]) == cid1)
     elif context.startswith('fd00:2:0:0::/64'):
@@ -305,9 +310,9 @@ verify(any([context.startswith('fd00:3:0:0::/64') for context in contexts]))
 verify(any([context.startswith('fd00:4:0:0::/64') for context in contexts]))
 for context in contexts:
     if context.startswith('fd00:3:0:0::/64') or context.startswith('fd00:4:0:0::/64'):
-        verify(context.endswith('-'))
+        verify('c' not in parse_context_flags(context))
     else:
-        verify(context.endswith('c'))
+        verify('c' in parse_context_flags(context))
 
 # Add first one removed as route and add a new prefix.
 
@@ -333,7 +338,7 @@ verify(any([context.startswith('fd00:2:0:0::/64') for context in contexts]))
 verify(any([context.startswith('fd00:5:0:0::/64') for context in contexts]))
 
 for context in contexts:
-    verify(context.endswith('c'))
+    verify('c' in parse_context_flags(context))
     if context.startswith('fd00:5:0:0::/64'):
         verify(not int(context.split()[1]) in [cid3, cid4])
 
@@ -363,7 +368,7 @@ verify_within(check_netdata_9, 5)
 contexts = netdata['contexts']
 verify(len(contexts) == 1)
 verify(contexts[0].startswith('fd00:5:0:0::/64'))
-verify(contexts[0].endswith('c'))
+verify('c' in parse_context_flags(context))
 
 # -----------------------------------------------------------------------------------------------------------------------
 # Test finished
diff --git a/tests/toranj/cli/test-020-net-diag-vendor-info.py b/tests/toranj/cli/test-020-net-diag-vendor-info.py
index 463854a9c..86acd0371 100755
--- a/tests/toranj/cli/test-020-net-diag-vendor-info.py
+++ b/tests/toranj/cli/test-020-net-diag-vendor-info.py
@@ -70,6 +70,7 @@ VENDOR_SW_VERSION_TLV = 27
 THREAD_STACK_VERSION_TLV = 28
 MLE_COUNTERS_TLV = 34
 VENDOR_APP_URL = 35
+NON_PREFERRED_CHANNELS_TLV = 36
 
 #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 # Check setting vendor name, model, ans sw version
@@ -192,9 +193,42 @@ for line in result[1:]:
         verify(False)
 
 result = r2.cli('networkdiagnostic get', r1_rloc, MLE_COUNTERS_TLV)
-print(len(result) >= 1)
 verify(result[1].startswith("MLE Counters:"))
 
+# Test Non-preferred Channels TLV
+
+
+def verify_non_preferred_channels_query_result(mask):
+    r1.cli('networkdiagnostic nonpreferredchannels', mask)
+    result = r1.cli('networkdiagnostic nonpreferredchannels')
+    verify(len(result) == 1)
+    verify(int(result[0], 16) == mask)
+
+
+result = r1.cli('networkdiagnostic nonpreferredchannels')
+verify(len(result) == 1)
+verify(int(result[0], 16) == 0)
+
+verify_non_preferred_channels_query_result(0)
+
+mask = 1 << 26  # channel 26
+
+r1.cli('networkdiagnostic nonpreferredchannels', mask)
+result = r1.cli('networkdiagnostic nonpreferredchannels')
+verify(len(result) == 1)
+verify(int(result[0], 16) == mask)
+
+verify_non_preferred_channels_query_result(mask)
+
+mask = 0
+
+r1.cli('networkdiagnostic nonpreferredchannels', mask)
+result = r1.cli('networkdiagnostic nonpreferredchannels')
+verify(len(result) == 1)
+verify(int(result[0], 16) == mask)
+
+verify_non_preferred_channels_query_result(mask)
+
 # -----------------------------------------------------------------------------------------------------------------------
 # Test finished
 
diff --git a/tests/toranj/cli/test-023-mesh-diag.py b/tests/toranj/cli/test-023-mesh-diag.py
index 418813e43..1dfe53715 100755
--- a/tests/toranj/cli/test-023-mesh-diag.py
+++ b/tests/toranj/cli/test-023-mesh-diag.py
@@ -160,6 +160,50 @@ verify(len([line for line in neightable if line.startswith('rloc16')]) == 2)
 neightable = r3.cli('meshdiag routerneighbortable', r1_rloc)
 verify(len([line for line in neightable if line.startswith('rloc16')]) == 1)
 
+# Validate network diagnostics enhanced route TLV
+
+r1_router_id = int(r1_rloc / 1024)
+r2_router_id = int(r2_rloc / 1024)
+r3_router_id = int(r3_rloc / 1024)
+
+enh_routes = r1.cli('networkdiagnostic get', r3.get_rloc_ip_addr(), 37)
+
+verify(enh_routes[1] == 'EnhRoute:')
+verify(len(enh_routes) == 5)
+
+for line in enh_routes[2:]:
+    line = line.strip()
+    verify(line.startswith('- RouterId:'))
+    rid = int(line[11:].split()[0])
+    if (rid == r1_router_id):
+        verify('HasLink:no' in line)
+        verify(f'NextHop:{r2_router_id}' in line)
+    elif (rid == r2_router_id):
+        verify('HasLink:yes' in line)
+        verify('NextHop:na' in line)
+    elif (rid == r3_router_id):
+        verify('The queried device' in line)
+    else:
+        verify(False)
+
+enh_routes = r3.cli('networkdiagnostic get', r2.get_rloc_ip_addr(), 37)
+
+verify(enh_routes[1] == 'EnhRoute:')
+verify(len(enh_routes) == 5)
+
+for line in enh_routes[2:]:
+    line = line.strip()
+    verify(line.startswith('- RouterId:'))
+    rid = int(line[11:].split()[0])
+    if (rid == r1_router_id):
+        verify('HasLink:yes' in line)
+    elif (rid == r2_router_id):
+        verify('The queried device' in line)
+    elif (rid == r3_router_id):
+        verify('HasLink:yes' in line)
+    else:
+        verify(False)
+
 # -----------------------------------------------------------------------------------------------------------------------
 # Test finished
 
diff --git a/tests/toranj/cli/test-035-context-id-change-addr-reg.py b/tests/toranj/cli/test-035-context-id-change-addr-reg.py
index 9e7251431..8b336ba0d 100755
--- a/tests/toranj/cli/test-035-context-id-change-addr-reg.py
+++ b/tests/toranj/cli/test-035-context-id-change-addr-reg.py
@@ -86,8 +86,8 @@ time.sleep(0.5 / speedup)
 netdata = leader.get_netdata()
 contexts = netdata['contexts']
 verify(len(contexts) == 2)
-verify(any([context.startswith('fd00:1:0:0::/64 1 c') for context in contexts]))
-verify(any([context.startswith('fd00:2:0:0::/64 2 c') for context in contexts]))
+verify(any([context.startswith('fd00:1:0:0::/64 1') for context in contexts]))
+verify(any([context.startswith('fd00:2:0:0::/64 2') for context in contexts]))
 
 # Remove the first prefix.
 
@@ -105,7 +105,7 @@ time.sleep(3.5 / speedup)
 netdata = leader.get_netdata()
 contexts = netdata['contexts']
 verify(len(contexts) == 1)
-verify(any([context.startswith('fd00:2:0:0::/64 2 c') for context in contexts]))
+verify(any([context.startswith('fd00:2:0:0::/64 2') for context in contexts]))
 
 # Have `sed` attach as a child of `leader`.
 
@@ -122,7 +122,7 @@ verify(int(sed.get_child_timeout()) == 10)
 netdata = sed.get_netdata()
 contexts = netdata['contexts']
 verify(len(contexts) == 1)
-verify(any([context.startswith('fd00:2:0:0::/64 2 c') for context in contexts]))
+verify(any([context.startswith('fd00:2:0:0::/64 2') for context in contexts]))
 
 # Find the `sed` address associated with on-mesh prefix `fd00:2::`.
 
@@ -173,7 +173,7 @@ time.sleep(0.5 / speedup)
 netdata = leader.get_netdata()
 contexts = netdata['contexts']
 verify(len(contexts) == 1)
-verify(any([context.startswith('fd00:2:0:0::/64 1 c') for context in contexts]))
+verify(any([context.startswith('fd00:2:0:0::/64 1') for context in contexts]))
 
 # Make sure that child is timed out and removed on parent.
 
diff --git a/tests/toranj/cli/test-505-multi-ail-detection.py b/tests/toranj/cli/test-505-multi-ail-detection.py
new file mode 100755
index 000000000..13323dcee
--- /dev/null
+++ b/tests/toranj/cli/test-505-multi-ail-detection.py
@@ -0,0 +1,142 @@
+#!/usr/bin/env python3
+#
+#  Copyright (c) 2025, The OpenThread Authors.
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions are met:
+#  1. Redistributions of source code must retain the above copyright
+#     notice, this list of conditions and the following disclaimer.
+#  2. Redistributions in binary form must reproduce the above copyright
+#     notice, this list of conditions and the following disclaimer in the
+#     documentation and/or other materials provided with the distribution.
+#  3. Neither the name of the copyright holder nor the
+#     names of its contributors may be used to endorse or promote products
+#     derived from this software without specific prior written permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+#  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+#  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+#  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+#  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+#  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+#  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+#  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+#  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+#  POSSIBILITY OF SUCH DAMAGE.
+
+from cli import verify
+from cli import verify_within
+import cli
+import time
+
+# -----------------------------------------------------------------------------------------------------------------------
+# Test description:
+#
+# Check multi AIL detection
+#
+#   -+-       _______
+#    |       /       \
+#   br1 --- br2 --- br3
+#
+
+test_name = __file__[:-3] if __file__.endswith('.py') else __file__
+print('-' * 120)
+print('Starting \'{}\''.format(test_name))
+
+# -----------------------------------------------------------------------------------------------------------------------
+# Creating `cli.Nodes` instances
+
+speedup = 60
+cli.Node.set_time_speedup_factor(speedup)
+
+one_minute = 60
+
+br1 = cli.Node()
+br2 = cli.Node()
+br3 = cli.Node()
+
+IF_INDEX_1 = 1
+IF_INDEX_2 = 2
+
+# -----------------------------------------------------------------------------------------------------------------------
+# Form topology
+
+br1.form("multiail")
+br2.join(br1)
+br3.join(br2)
+
+verify(br1.get_state() == 'leader')
+verify(br2.get_state() == 'router')
+verify(br3.get_state() == 'router')
+
+# -----------------------------------------------------------------------------------------------------------------------
+# Test implementation
+
+# Start first border router `br1`
+
+br1.srp_server_set_addr_mode('unicast')
+br1.srp_server_auto_enable()
+
+br1.br_init(IF_INDEX_1, 1)
+br1.br_enable()
+
+time.sleep(one_minute / speedup)
+verify(br1.br_get_state() == 'running')
+verify(br1.br_get_multiail() == 'not detected')
+
+# Start `br2` and `br3` together on a different AIL
+
+br2.br_init(IF_INDEX_2, 1)
+br2.br_enable()
+
+br3.br_init(IF_INDEX_2, 1)
+br3.br_enable()
+
+time.sleep(one_minute / speedup)
+verify(br2.br_get_state() == 'running')
+verify(br3.br_get_state() == 'running')
+
+verify(br2.br_get_multiail() == 'not detected')
+verify(br3.br_get_multiail() == 'not detected')
+
+# wait for longer than 10 minutes and check that multi AIL is detected
+
+time.sleep(10.01 * one_minute / speedup)
+
+verify(br1.br_get_multiail() == 'detected')
+verify(br2.br_get_multiail() == 'detected')
+verify(br3.br_get_multiail() == 'detected')
+
+# Disable `br1`
+
+br1.br_disable()
+verify(br1.br_get_state() == 'disabled')
+
+time.sleep(9 * one_minute / speedup)
+
+verify(br2.br_get_multiail() == 'not detected')
+verify(br3.br_get_multiail() == 'not detected')
+
+# Enable `br` again, wait for a short time (before detection) and disable it
+
+br1.br_enable()
+
+time.sleep(2 * one_minute / speedup)
+verify(br1.br_get_state() == 'running')
+
+br1.br_disable()
+verify(br1.br_get_state() == 'disabled')
+
+time.sleep(10 * one_minute / speedup)
+
+verify(br2.br_get_multiail() == 'not detected')
+verify(br3.br_get_multiail() == 'not detected')
+
+# -----------------------------------------------------------------------------------------------------------------------
+# Test finished
+
+cli.Node.finalize_all_nodes()
+
+print('\'{}\' passed.'.format(test_name))
diff --git a/tests/toranj/openthread-core-toranj-config-posix.h b/tests/toranj/openthread-core-toranj-config-posix.h
index 35c007950..a61047805 100644
--- a/tests/toranj/openthread-core-toranj-config-posix.h
+++ b/tests/toranj/openthread-core-toranj-config-posix.h
@@ -66,7 +66,12 @@
 
 #define OPENTHREAD_POSIX_CONFIG_NAT64_AIL_PREFIX_ENABLE 1
 
-// Disabled explicitly on posix `toranj` to validate the build with this config
+// The following two features (`USE_HEAP`) are disabled explicitly on posix `toranj`
+// to validate the build with these config. The `toranj` build under simulation
+// platform covers the opposite configs (allows `USE_HEAP`).
+
 #define OPENTHREAD_CONFIG_BORDER_ROUTING_USE_HEAP_ENABLE 0
 
+#define OPENTHREAD_CONFIG_TREL_USE_HEAP_ENABLE 0
+
 #endif /* OPENTHREAD_CORE_TORANJ_CONFIG_POSIX_H_ */
diff --git a/tests/toranj/openthread-core-toranj-config-simulation.h b/tests/toranj/openthread-core-toranj-config-simulation.h
index c0f4dc03d..cdb4f3e6a 100644
--- a/tests/toranj/openthread-core-toranj-config-simulation.h
+++ b/tests/toranj/openthread-core-toranj-config-simulation.h
@@ -87,4 +87,6 @@
 
 #define OPENTHREAD_CONFIG_RADIO_STATS_ENABLE 0
 
+#define OPENTHREAD_CONFIG_TREL_USE_HEAP_ENABLE 1
+
 #endif /* OPENTHREAD_CORE_TORANJ_CONFIG_SIMULATION_H_ */
diff --git a/tests/toranj/start.sh b/tests/toranj/start.sh
index 5a50b3f0a..75d8062ae 100755
--- a/tests/toranj/start.sh
+++ b/tests/toranj/start.sh
@@ -208,6 +208,7 @@ if [ "$TORANJ_CLI" = 1 ]; then
     run cli/test-502-multi-br-leader-failure-recovery.py
     run cli/test-503-peer-tbr-discovery.py
     run cli/test-504-br-icmp-unreach-err.py
+    run cli/test-505-multi-ail-detection.py
     run cli/test-601-channel-manager-channel-change.py
     # Skip the "channel-select" test on a TREL only radio link, since it
     # requires energy scan which is not supported in this case.
diff --git a/tests/unit/CMakeLists.txt b/tests/unit/CMakeLists.txt
index af89d17d7..e59a16377 100644
--- a/tests/unit/CMakeLists.txt
+++ b/tests/unit/CMakeLists.txt
@@ -264,6 +264,7 @@ ot_unit_test(toolchain test_toolchain_c.c)
 ot_unit_test(trickle_timer)
 ot_unit_test(url)
 
+ot_unit_ncp_test(cli)
 ot_unit_ncp_test(dnssd)
 ot_unit_ncp_test(infra_if)
 ot_unit_ncp_test(srp_server)
diff --git a/tests/unit/test_child.cpp b/tests/unit/test_child.cpp
index 560fc9a9f..d7263cf30 100644
--- a/tests/unit/test_child.cpp
+++ b/tests/unit/test_child.cpp
@@ -78,7 +78,7 @@ void VerifyChildIp6Addresses(const Child &aChild, uint8_t aAddressListLength, co
     {
         Ip6::Address address;
 
-        if (sInstance->Get<Mle::MleRouter>().IsMeshLocalAddress(aAddressList[index]))
+        if (sInstance->Get<Mle::Mle>().IsMeshLocalAddress(aAddressList[index]))
         {
             SuccessOrQuit(aChild.GetMeshLocalIp6Address(address));
             VerifyOrQuit(address == aAddressList[index], "GetMeshLocalIp6Address() did not return expected address");
@@ -127,7 +127,7 @@ void TestChildIp6Address(void)
     numAddresses = 0;
 
     // First addresses uses the mesh local prefix (mesh-local address).
-    addresses[numAddresses] = sInstance->Get<Mle::MleRouter>().GetMeshLocalEid();
+    addresses[numAddresses] = sInstance->Get<Mle::Mle>().GetMeshLocalEid();
     addresses[numAddresses].SetIid(meshLocalIid);
 
     numAddresses++;
diff --git a/tests/unit/test_dns.cpp b/tests/unit/test_dns.cpp
index c11545dcd..0bd856706 100644
--- a/tests/unit/test_dns.cpp
+++ b/tests/unit/test_dns.cpp
@@ -1122,7 +1122,7 @@ void TestHeaderAndResourceRecords(void)
         kHeaderOffset    = 0,
         kQuestionCount   = 1,
         kAnswerCount     = 2,
-        kAdditionalCount = 5,
+        kAdditionalCount = 6,
         kTtl             = 7200,
         kTxtTtl          = 7300,
         kSrvPort         = 1234,
@@ -1146,30 +1146,34 @@ void TestHeaderAndResourceRecords(void)
     const char *kInstanceLabels[] = {kInstance1Label, kInstance2Label};
     const char *kInstanceNames[]  = {kInstance1Name, kInstance2Name};
 
-    Instance           *instance;
-    MessagePool        *messagePool;
-    Message            *message;
-    Dns::Header         header;
-    uint16_t            messageId;
-    uint16_t            headerOffset;
-    uint16_t            offset;
-    uint16_t            numRecords;
-    uint16_t            len;
-    uint16_t            serviceNameOffset;
-    uint16_t            hostNameOffset;
-    uint16_t            answerSectionOffset;
-    uint16_t            additionalSectionOffset;
-    uint16_t            index;
-    Dns::PtrRecord      ptrRecord;
-    Dns::SrvRecord      srvRecord;
-    Dns::TxtRecord      txtRecord;
-    Dns::AaaaRecord     aaaaRecord;
-    Dns::ResourceRecord record;
-    Ip6::Address        hostAddress;
-
-    Dns::Name::LabelBuffer label;
-    Dns::Name::Buffer      name;
-    uint8_t                buffer[kMaxSize];
+    Instance                   *instance;
+    MessagePool                *messagePool;
+    Message                    *message;
+    Dns::Header                 header;
+    uint16_t                    messageId;
+    uint16_t                    headerOffset;
+    uint16_t                    offset;
+    uint16_t                    numRecords;
+    uint16_t                    len;
+    uint16_t                    serviceNameOffset;
+    uint16_t                    hostNameOffset;
+    uint16_t                    answerSectionOffset;
+    uint16_t                    additionalSectionOffset;
+    uint16_t                    index;
+    Dns::PtrRecord              ptrRecord;
+    Dns::SrvRecord              srvRecord;
+    Dns::TxtRecord              txtRecord;
+    Dns::AaaaRecord             aaaaRecord;
+    Dns::NsecRecord             nsecRecord;
+    Dns::NsecRecord::TypeBitMap nsecBitmap;
+    Dns::ResourceRecord         record;
+    Ip6::Address                hostAddress;
+    Dns::Name::LabelBuffer      label;
+    Dns::Name::Buffer           name;
+    uint8_t                     buffer[kMaxSize];
+    uint8_t                    *bytes;
+    OwnedPtr<Message>           dataMsg;
+    uint16_t                    dataOffset;
 
     printf("================================================================\n");
     printf("TestHeaderAndResourceRecords()\n");
@@ -1259,6 +1263,19 @@ void TestHeaderAndResourceRecords(void)
     aaaaRecord.SetAddress(hostAddress);
     SuccessOrQuit(message->Append(aaaaRecord));
 
+    nsecRecord.Init();
+    nsecRecord.SetTtl(kTtl);
+    nsecBitmap.Clear();
+    nsecBitmap.AddType(Dns::ResourceRecord::kTypeAaaa);
+
+    SuccessOrQuit(Dns::Name::AppendPointerLabel(hostNameOffset, *message));
+    offset = message->GetLength();
+    SuccessOrQuit(message->Append(nsecRecord));
+    SuccessOrQuit(Dns::Name::AppendPointerLabel(hostNameOffset, *message));
+    SuccessOrQuit(message->AppendBytes(&nsecBitmap, nsecBitmap.GetSize()));
+    nsecRecord.SetLength(message->GetLength() - offset - sizeof(Dns::ResourceRecord));
+    message->Write(offset, nsecRecord);
+
     // Dump the entire message
 
     VerifyOrQuit(message->GetLength() < kMaxSize, "Message is too long");
@@ -1301,6 +1318,13 @@ void TestHeaderAndResourceRecords(void)
     for (const char *instanceLabel : kInstanceLabels)
     {
         SuccessOrQuit(Dns::Name::CompareName(*message, offset, kServiceName));
+
+        SuccessOrQuit(Dns::ResourceRecord::DecompressRecordData(*message, offset, dataMsg));
+        VerifyOrQuit(dataMsg != nullptr);
+        dataOffset = 0;
+        VerifyOrQuit(Dns::Name::CompareName(*dataMsg, dataOffset, kServiceName));
+        VerifyOrQuit(dataOffset == dataMsg->GetLength());
+
         SuccessOrQuit(Dns::ResourceRecord::ReadRecord(*message, offset, ptrRecord));
         VerifyOrQuit(ptrRecord.GetTtl() == kTtl, "Read PTR is incorrect");
 
@@ -1374,6 +1398,7 @@ void TestHeaderAndResourceRecords(void)
 
         // SRV record
         SuccessOrQuit(Dns::Name::CompareName(*message, offset, instanceName));
+        savedOffset = offset;
         SuccessOrQuit(Dns::ResourceRecord::ReadRecord(*message, offset, srvRecord));
         VerifyOrQuit(srvRecord.GetTtl() == kTtl);
         VerifyOrQuit(srvRecord.GetPort() == kSrvPort);
@@ -1384,8 +1409,24 @@ void TestHeaderAndResourceRecords(void)
         printf("    \"%s\" SRV %u %d %d %d %d \"%s\"\n", instanceName, srvRecord.GetTtl(), srvRecord.GetLength(),
                srvRecord.GetPort(), srvRecord.GetWeight(), srvRecord.GetPriority(), name);
 
+        // SRV record again using `DecompressRecordData()`
+        dataMsg.Free();
+        SuccessOrQuit(Dns::ResourceRecord::DecompressRecordData(*message, savedOffset, dataMsg));
+        VerifyOrQuit(dataMsg != nullptr);
+        dataOffset = 0;
+        len        = sizeof(Dns::SrvRecord) - sizeof(Dns::ResourceRecord);
+        bytes      = reinterpret_cast<uint8_t *>(&srvRecord);
+        bytes += sizeof(Dns::ResourceRecord);
+        VerifyOrQuit(dataMsg->CompareBytes(dataOffset, bytes, len));
+        dataOffset += len;
+        SuccessOrQuit(Dns::Name::CompareName(*dataMsg, dataOffset, kHostName));
+        VerifyOrQuit(dataOffset == dataMsg->GetLength());
+
         // TXT record
         SuccessOrQuit(Dns::Name::CompareName(*message, offset, instanceName));
+        dataMsg.Free();
+        SuccessOrQuit(Dns::ResourceRecord::DecompressRecordData(*message, offset, dataMsg));
+        VerifyOrQuit(dataMsg == nullptr);
         SuccessOrQuit(Dns::ResourceRecord::ReadRecord(*message, offset, txtRecord));
         VerifyOrQuit(txtRecord.GetTtl() == kTxtTtl);
         savedOffset = offset;
@@ -1405,13 +1446,34 @@ void TestHeaderAndResourceRecords(void)
         VerifyOrQuit(savedOffset == offset);
     }
 
+    // AAAA record
     SuccessOrQuit(Dns::Name::CompareName(*message, offset, kHostName));
+    dataMsg.Free();
+    SuccessOrQuit(Dns::ResourceRecord::DecompressRecordData(*message, offset, dataMsg));
+    VerifyOrQuit(dataMsg == nullptr);
     SuccessOrQuit(Dns::ResourceRecord::ReadRecord(*message, offset, aaaaRecord));
     VerifyOrQuit(aaaaRecord.GetTtl() == kTtl);
     VerifyOrQuit(aaaaRecord.GetAddress() == hostAddress);
     printf("    \"%s\" AAAA %u %d \"%s\"\n", kHostName, aaaaRecord.GetTtl(), aaaaRecord.GetLength(),
            aaaaRecord.GetAddress().ToString().AsCString());
 
+    // NSEC record
+    SuccessOrQuit(Dns::Name::CompareName(*message, offset, kHostName));
+    dataMsg.Free();
+    SuccessOrQuit(Dns::ResourceRecord::DecompressRecordData(*message, offset, dataMsg));
+    VerifyOrQuit(dataMsg != nullptr);
+    dataOffset = 0;
+    SuccessOrQuit(Dns::Name::CompareName(*dataMsg, dataOffset, kHostName));
+    VerifyOrQuit(dataMsg->CompareBytes(dataOffset, &nsecBitmap, nsecBitmap.GetSize()));
+    dataOffset += nsecBitmap.GetSize();
+    VerifyOrQuit(dataOffset == dataMsg->GetLength());
+    SuccessOrQuit(Dns::ResourceRecord::ReadRecord(*message, offset, record));
+    VerifyOrQuit(record.GetType() == Dns::ResourceRecord::kTypeNsec);
+    VerifyOrQuit(nsecBitmap.ContainsType(Dns::ResourceRecord::kTypeAaaa));
+    printf("    \"%s\" NSEC %u %d bitmap-size:%d\n", kHostName, record.GetTtl(), record.GetLength(),
+           nsecBitmap.GetSize());
+    offset += record.GetLength();
+
     VerifyOrQuit(offset == message->GetLength(), "offset is incorrect after additional section parse");
 
     // Use `ParseRecords()` to parse all records
@@ -1451,6 +1513,12 @@ void TestHeaderAndResourceRecords(void)
     SuccessOrQuit(Dns::ResourceRecord::ReadRecord(*message, offset, record));
     VerifyOrQuit(record.GetType() == Dns::ResourceRecord::kTypeAaaa);
     offset += record.GetLength();
+
+    SuccessOrQuit(Dns::ResourceRecord::FindRecord(*message, offset, numRecords, Dns::Name(kHostName)));
+    SuccessOrQuit(Dns::ResourceRecord::ReadRecord(*message, offset, record));
+    VerifyOrQuit(record.GetType() == Dns::ResourceRecord::kTypeNsec);
+    offset += record.GetLength();
+
     VerifyOrQuit(offset == message->GetLength(), "offset is incorrect after additional section parse");
 
     printf("Use FindRecord() to search for specific records:\n");
diff --git a/tests/unit/test_dns_client.cpp b/tests/unit/test_dns_client.cpp
index b8405d856..545db9d9e 100644
--- a/tests/unit/test_dns_client.cpp
+++ b/tests/unit/test_dns_client.cpp
@@ -238,8 +238,9 @@ void FinalizeTest(void)
 
 //---------------------------------------------------------------------------------------------------------------------
 
-static const char kHostName[]     = "elden";
-static const char kHostFullName[] = "elden.default.service.arpa.";
+static const char kHostName[]        = "elden";
+static const char kHostFullName[]    = "elden.default.service.arpa.";
+static const char kNonExistingName[] = "noname.nodomain.";
 
 static const char kService1Name[]      = "_srv._udp";
 static const char kService1FullName[]  = "_srv._udp.default.service.arpa.";
@@ -542,6 +543,221 @@ exit:
     return;
 }
 
+//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+static constexpr uint16_t kMaxRecords = 16;
+
+struct QueryRecordInfo
+{
+    struct Record : public Dns::Client::RecordInfo
+    {
+        static constexpr uint16_t kMaxRecordDataSize = 500;
+
+        void Init(void)
+        {
+            ClearAllBytes(*this);
+            mNameBuffer     = mName;
+            mNameBufferSize = sizeof(mName);
+            mDataBuffer     = mData;
+            mDataBufferSize = sizeof(mData);
+        }
+
+        uint8_t mData[kMaxRecordDataSize];
+        char    mName[Dns::Name::kMaxNameSize];
+    };
+
+    void Reset(void) { memset(this, 0, sizeof(*this)); };
+
+    uint16_t mCallbackCount;
+    Error    mError;
+    char     mQueryName[Dns::Name::kMaxNameSize];
+    Record   mRecords[kMaxRecords];
+    uint16_t mNumRecords;
+};
+
+static QueryRecordInfo sQueryRecordInfo;
+
+void RecordCallback(otError aError, const otDnsRecordResponse *aResponse, void *aContext)
+{
+    static constexpr uint16_t kMaxStringSize = 400;
+
+    const Dns::Client::RecordResponse &response = AsCoreType(aResponse);
+
+    Log("RecordCallback");
+    Log("   Error: %s", ErrorToString(aError));
+
+    VerifyOrQuit(aContext == sInstance);
+
+    sQueryRecordInfo.mCallbackCount++;
+    sQueryRecordInfo.mError      = aError;
+    sQueryRecordInfo.mNumRecords = 0;
+
+    SuccessOrExit(aError);
+
+    SuccessOrQuit(response.GetQueryName(sQueryRecordInfo.mQueryName, sizeof(sQueryRecordInfo.mQueryName)));
+    Log("   QueryName: %s", sQueryRecordInfo.mQueryName);
+
+    for (uint8_t index = 0; index < kMaxRecords; index++)
+    {
+        Error    error;
+        uint32_t ttl;
+
+        sQueryRecordInfo.mRecords[index].Init();
+
+        error = response.GetRecordInfo(index, sQueryRecordInfo.mRecords[index]);
+
+        if (error == kErrorNotFound)
+        {
+            sQueryRecordInfo.mNumRecords = index;
+            break;
+        }
+
+        SuccessOrQuit(error);
+    }
+
+    Log("   NumRecords: %u", sQueryRecordInfo.mNumRecords);
+
+    for (uint16_t index = 0; index < sQueryRecordInfo.mNumRecords; index++)
+    {
+        const QueryRecordInfo::Record &record = sQueryRecordInfo.mRecords[index];
+        String<kMaxStringSize>         string;
+        uint16_t                       rrType;
+
+        string.AppendHexBytes(record.mDataBuffer, record.mDataBufferSize);
+        rrType = record.mRecordType;
+
+        Log("   Record %u", index);
+        Log("      Name: %s", record.mNameBuffer);
+        Log("      Type: %u (%s)", rrType, Dns::ResourceRecord::TypeToString(rrType).AsCString());
+        Log("      Data: %s", string.AsCString());
+    }
+
+exit:
+    return;
+}
+
+void ValidateSrvRecordData(const QueryRecordInfo::Record &aRecord, const char *aFullHostName)
+{
+    // Validate that the read SRV record data contains
+    // the uncompressed host name.
+
+    Message *data   = sInstance->Get<MessagePool>().Allocate(Message::kTypeOther);
+    uint16_t offset = sizeof(Dns::SrvRecord) - sizeof(Dns::ResourceRecord);
+
+    VerifyOrQuit(data != nullptr);
+    SuccessOrQuit(data->AppendBytes(aRecord.mDataBuffer, aRecord.mRecordLength));
+
+    SuccessOrQuit(Dns::Name::CompareName(*data, offset, aFullHostName));
+    VerifyOrQuit(offset == data->GetLength());
+
+    data->Free();
+}
+
+void ValidatePtrRecordData(const QueryRecordInfo::Record &aRecord, const char *aFullInstanceName)
+{
+    // Validate that the read PTR record data contains
+    // the uncompressed service instance name.
+
+    Message *data   = sInstance->Get<MessagePool>().Allocate(Message::kTypeOther);
+    uint16_t offset = 0;
+
+    VerifyOrQuit(data != nullptr);
+    SuccessOrQuit(data->AppendBytes(aRecord.mDataBuffer, aRecord.mRecordLength));
+
+    SuccessOrQuit(Dns::Name::CompareName(*data, offset, aFullInstanceName));
+    VerifyOrQuit(offset == data->GetLength());
+
+    data->Free();
+}
+
+void ValidateSoaRecordData(const QueryRecordInfo::Record &aRecord, const char *aServerName)
+{
+    static constexpr uint32_t kSoaSerial  = 0;
+    static constexpr uint32_t kSoaRefresh = 7200;
+    static constexpr uint32_t kSoaRetry   = 3600;
+    static constexpr uint32_t kSoaExpire  = 86400;
+    static constexpr uint32_t kSoaMinimum = 10;
+
+    uint16_t          offset;
+    Message          *message;
+    Dns::Name::Buffer name;
+
+    VerifyOrQuit(StringMatch(aRecord.mNameBuffer, "default.service.arpa."));
+    VerifyOrQuit(aRecord.mRecordType == Dns::ResourceRecord::kTypeSoa);
+    VerifyOrQuit(aRecord.mTtl == 7200);
+
+    message = sInstance->Get<MessagePool>().Allocate(Message::kTypeOther);
+    VerifyOrQuit(message != nullptr);
+
+    VerifyOrQuit(aRecord.mRecordLength == aRecord.mDataBufferSize);
+    SuccessOrQuit(message->AppendBytes(aRecord.mDataBuffer, aRecord.mDataBufferSize));
+
+    // Validate the SOA record data.
+
+    offset = 0;
+
+    // MNAME field:
+    SuccessOrQuit(Dns::Name::ReadName(*message, offset, name));
+    VerifyOrQuit(StringMatch(name, aServerName, kStringCaseInsensitiveMatch));
+
+    // RNAME: must be "postmaster.default.service.arpa."
+    SuccessOrQuit(Dns::Name::ReadName(*message, offset, name));
+    SuccessOrQuit(Dns::Name::StripName(name, "default.service.arpa."));
+    VerifyOrQuit(StringMatch(name, "postmaster"));
+
+    // SERIAL
+    VerifyOrQuit(message->Compare<uint32_t>(offset, BigEndian::HostSwap32(kSoaSerial)));
+    offset += sizeof(uint32_t);
+
+    // REFRESH
+    VerifyOrQuit(message->Compare<uint32_t>(offset, BigEndian::HostSwap32(kSoaRefresh)));
+    offset += sizeof(uint32_t);
+
+    // RETRY
+    VerifyOrQuit(message->Compare<uint32_t>(offset, BigEndian::HostSwap32(kSoaRetry)));
+    offset += sizeof(uint32_t);
+
+    // EXPIRE
+    VerifyOrQuit(message->Compare<uint32_t>(offset, BigEndian::HostSwap32(kSoaExpire)));
+    offset += sizeof(uint32_t);
+
+    // MINIMUM
+    VerifyOrQuit(message->Compare<uint32_t>(offset, BigEndian::HostSwap32(kSoaMinimum)));
+    offset += sizeof(uint32_t);
+
+    VerifyOrQuit(offset == message->GetLength());
+
+    message->Free();
+}
+
+void ValidateNsRecordData(const QueryRecordInfo::Record &aRecord, const char *aServerName)
+{
+    uint16_t          offset;
+    Message          *message;
+    Dns::Name::Buffer name;
+
+    VerifyOrQuit(StringMatch(aRecord.mNameBuffer, "default.service.arpa."));
+    VerifyOrQuit(aRecord.mRecordType == Dns::ResourceRecord::kTypeNs);
+    VerifyOrQuit(aRecord.mTtl == 7200);
+
+    message = sInstance->Get<MessagePool>().Allocate(Message::kTypeOther);
+    VerifyOrQuit(message != nullptr);
+
+    VerifyOrQuit(aRecord.mRecordLength == aRecord.mDataBufferSize);
+    SuccessOrQuit(message->AppendBytes(aRecord.mDataBuffer, aRecord.mDataBufferSize));
+
+    // Validate the NS data
+
+    offset = 0;
+
+    SuccessOrQuit(Dns::Name::ReadName(*message, offset, name));
+    VerifyOrQuit(StringMatch(name, aServerName, kStringCaseInsensitiveMatch));
+
+    VerifyOrQuit(offset == message->GetLength());
+
+    message->Free();
+}
+
 //----------------------------------------------------------------------------------------------------------------------
 
 void TestDnsClient(void)
@@ -677,6 +893,16 @@ void TestDnsClient(void)
         VerifyOrQuit(addresses.Contains(sAddressInfo.mHostAddresses[index]));
     }
 
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Validate DNS Client `ResolveAddress()` for an invalid (non-existing) name
+
+    sAddressInfo.Reset();
+    Log("ResolveAddress(%s)", kNonExistingName);
+    SuccessOrQuit(dnsClient->ResolveAddress(kNonExistingName, AddressCallback, sInstance));
+    AdvanceTime(100);
+    VerifyOrQuit(sAddressInfo.mCallbackCount == 1);
+    VerifyOrQuit(sAddressInfo.mError == kErrorNotFound);
+
     //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     // Validate DNS Client `ResolveIp4Address()`
 
@@ -695,6 +921,273 @@ void TestDnsClient(void)
     VerifyOrQuit(sAddressInfo.mCallbackCount == 1);
     VerifyOrQuit(sAddressInfo.mError != kErrorNone);
 
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Validate DNS Client `QueryRecord()` for host name and KEY record
+
+    sQueryRecordInfo.Reset();
+    Log("QueryRecord(%s) for KEY RR", kHostFullName);
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeKey, kHostName, "default.service.arpa.",
+                                         RecordCallback, sInstance));
+    AdvanceTime(100);
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 1);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mRecords[0].mNameBuffer, kHostFullName));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordType == Dns::ResourceRecord::kTypeKey);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordLength == sizeof(Dns::Ecdsa256KeyRecord));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mTtl > 0);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mDataBufferSize == sizeof(Dns::Ecdsa256KeyRecord));
+    VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+
+    sQueryRecordInfo.Reset();
+    Log("QueryRecord(%s) for misc RR", kHostFullName);
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeCname, kHostName, "default.service.arpa.",
+                                         RecordCallback, sInstance));
+    AdvanceTime(100);
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 0);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Validate DNS Client `QueryRecord()` for host name and ANY record
+
+    sQueryRecordInfo.Reset();
+    Log("QueryRecord(%s) for ANY RR", kHostFullName);
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeAny, kHostName, "default.service.arpa.",
+                                         RecordCallback, sInstance));
+    AdvanceTime(100);
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 3);
+
+    for (uint8_t index = 0; index < 3; index++)
+    {
+        const QueryRecordInfo::Record &record = sQueryRecordInfo.mRecords[index];
+
+        VerifyOrQuit(StringMatch(record.mNameBuffer, kHostFullName));
+        VerifyOrQuit(MapEnum(record.mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+        VerifyOrQuit(record.mTtl > 0);
+
+        if (record.mRecordType == Dns::ResourceRecord::kTypeKey)
+        {
+            VerifyOrQuit(record.mRecordLength == sizeof(Dns::Ecdsa256KeyRecord));
+            VerifyOrQuit(record.mDataBufferSize == sizeof(Dns::Ecdsa256KeyRecord));
+        }
+        else if (record.mRecordType == Dns::ResourceRecord::kTypeAaaa)
+        {
+            VerifyOrQuit(record.mRecordLength == sizeof(Ip6::Address));
+            VerifyOrQuit(addresses.Contains(*reinterpret_cast<const Ip6::Address *>(record.mDataBuffer)));
+        }
+        else
+        {
+            // Unexpected record type.
+            VerifyOrQuit(false);
+        }
+    }
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Validate DNS Client `QueryRecord()` for service instance name and KEY record
+
+    sQueryRecordInfo.Reset();
+    Log("QueryRecord(%s) for KEY RR", kInstance1FullName);
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeKey, kInstance1Label, kService1FullName,
+                                         RecordCallback, sInstance));
+    AdvanceTime(100);
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 1);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mRecords[0].mNameBuffer, kInstance1FullName));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordType == Dns::ResourceRecord::kTypeKey);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordLength == sizeof(Dns::Ecdsa256KeyRecord));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mTtl > 0);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mDataBufferSize == sizeof(Dns::Ecdsa256KeyRecord));
+    VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+
+    sQueryRecordInfo.Reset();
+    Log("QueryRecord(%s) for misc RR", kInstance1FullName);
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeCname, kInstance1Label, kService1FullName,
+                                         RecordCallback, sInstance));
+    AdvanceTime(100);
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 0);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Validate DNS Client `QueryRecord()` for service instance name and SRV record
+
+    sQueryRecordInfo.Reset();
+    Log("QueryRecord(%s) for SRV record", kInstance1FullName);
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeSrv, kInstance1Label, kService1FullName,
+                                         RecordCallback, sInstance));
+    AdvanceTime(100);
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 4);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mRecords[0].mNameBuffer, kInstance1FullName));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordType == Dns::ResourceRecord::kTypeSrv);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordLength > 0);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mTtl > 0);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mDataBufferSize == sQueryRecordInfo.mRecords[0].mRecordLength);
+    VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+
+    ValidateSrvRecordData(sQueryRecordInfo.mRecords[0], kHostFullName);
+
+    // Validate the records in additional data (TXT and two AAAA).
+
+    for (uint8_t index = 1; index < 4; index++)
+    {
+        const QueryRecordInfo::Record &record = sQueryRecordInfo.mRecords[index];
+
+        VerifyOrQuit(record.mRecordLength > 0);
+        VerifyOrQuit(record.mTtl > 0);
+        VerifyOrQuit(record.mDataBufferSize == record.mRecordLength);
+        VerifyOrQuit(MapEnum(record.mSection) == Dns::Client::RecordInfo::kSectionAdditional);
+
+        switch (record.mRecordType)
+        {
+        case Dns::ResourceRecord::kTypeTxt:
+            VerifyOrQuit(!strcmp(record.mNameBuffer, kInstance1FullName));
+            break;
+        case Dns::ResourceRecord::kTypeAaaa:
+            VerifyOrQuit(!strcmp(record.mNameBuffer, kHostFullName));
+            VerifyOrQuit(record.mRecordLength == sizeof(Ip6::Address));
+            break;
+        default:
+            VerifyOrQuit(false);
+            break;
+        }
+    }
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Validate DNS Client `QueryRecord()` for service instance name and ANY record
+
+    sQueryRecordInfo.Reset();
+    Log("QueryRecord(%s) for ANY record", kInstance1FullName);
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeAny, kInstance1Label, kService1FullName,
+                                         RecordCallback, sInstance));
+    AdvanceTime(100);
+
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 3);
+
+    for (uint8_t index = 1; index < 3; index++)
+    {
+        const QueryRecordInfo::Record &record = sQueryRecordInfo.mRecords[index];
+
+        VerifyOrQuit(StringMatch(record.mNameBuffer, kInstance1FullName));
+        VerifyOrQuit(record.mRecordLength > 0);
+        VerifyOrQuit(record.mTtl > 0);
+        VerifyOrQuit(record.mDataBufferSize == record.mRecordLength);
+        VerifyOrQuit(MapEnum(record.mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+
+        switch (record.mRecordType)
+        {
+        case Dns::ResourceRecord::kTypeKey:
+        case Dns::ResourceRecord::kTypeTxt:
+        case Dns::ResourceRecord::kTypeSrv:
+            break;
+        default:
+            VerifyOrQuit(false);
+            break;
+        }
+    }
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Validate DNS Client `QueryRecord()` for PTR record
+
+    sQueryRecordInfo.Reset();
+    Log("QueryRecord(%s) for PTR record", kService1FullName);
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypePtr, "_srv", "_udp.default.service.arpa.",
+                                         RecordCallback, sInstance));
+    AdvanceTime(100);
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 5);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mRecords[0].mNameBuffer, kService1FullName));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordType == Dns::ResourceRecord::kTypePtr);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordLength > 0);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mTtl > 0);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mDataBufferSize == sQueryRecordInfo.mRecords[0].mRecordLength);
+    VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+
+    ValidatePtrRecordData(sQueryRecordInfo.mRecords[0], kInstance1FullName);
+
+    // Validate the records in additional data (SRV, TXT and two AAAA).
+
+    for (uint8_t index = 1; index < 5; index++)
+    {
+        const QueryRecordInfo::Record &record = sQueryRecordInfo.mRecords[index];
+
+        VerifyOrQuit(record.mRecordLength > 0);
+        VerifyOrQuit(record.mTtl > 0);
+        VerifyOrQuit(record.mDataBufferSize == record.mRecordLength);
+        VerifyOrQuit(MapEnum(record.mSection) == Dns::Client::RecordInfo::kSectionAdditional);
+
+        switch (record.mRecordType)
+        {
+        case Dns::ResourceRecord::kTypeSrv:
+            VerifyOrQuit(!strcmp(record.mNameBuffer, kInstance1FullName));
+            ValidateSrvRecordData(record, kHostFullName);
+            break;
+        case Dns::ResourceRecord::kTypeTxt:
+            VerifyOrQuit(!strcmp(record.mNameBuffer, kInstance1FullName));
+            break;
+        case Dns::ResourceRecord::kTypeAaaa:
+            VerifyOrQuit(!strcmp(record.mNameBuffer, kHostFullName));
+            VerifyOrQuit(record.mRecordLength == sizeof(Ip6::Address));
+            break;
+        default:
+            VerifyOrQuit(false);
+            break;
+        }
+    }
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Validate DNS Client `QueryRecord()` for service name and ANY record
+
+    sQueryRecordInfo.Reset();
+    Log("QueryRecord(%s) for ANY record", kInstance1FullName);
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeAny, "_srv", "_udp.default.service.arpa.",
+                                         RecordCallback, sInstance));
+    AdvanceTime(100);
+
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 1);
+
+    VerifyOrQuit(StringMatch(sQueryRecordInfo.mRecords[0].mNameBuffer, kService1FullName));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordType == Dns::ResourceRecord::kTypePtr);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordLength > 0);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mTtl > 0);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mDataBufferSize == sQueryRecordInfo.mRecords[0].mRecordLength);
+    VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Validate DNS Client `QueryRecord()` for sub-type service name and ANY record
+
+    sQueryRecordInfo.Reset();
+    Log("QueryRecord(%s) for ANY record", kService2SubTypeFullName);
+
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeAny, "_best",
+                                         "_sub._game._udp.default.service.arpa.", RecordCallback, sInstance));
+    AdvanceTime(100);
+
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 1);
+
+    VerifyOrQuit(StringMatch(sQueryRecordInfo.mRecords[0].mNameBuffer, kService2SubTypeFullName));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordType == Dns::ResourceRecord::kTypePtr);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordLength > 0);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mTtl > 0);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mDataBufferSize == sQueryRecordInfo.mRecords[0].mRecordLength);
+    VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+
     //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     // Validate DNS Client `Browse()`
 
@@ -1329,6 +1822,195 @@ void TestDnssdServerProxyCallback(void)
     Log("End of TestDnssdServerProxyCallback");
 }
 
+void TestDnssdSoaNsResponse(void)
+{
+    Srp::Server      *srpServer;
+    Srp::Client      *srpClient;
+    Dns::Client      *dnsClient;
+    Dns::Name::Buffer serverName;
+    StringWriter      writer(serverName, sizeof(serverName));
+
+    Log("--------------------------------------------------------------------------------------------");
+    Log("TestDnssdSoaNsResponse");
+
+    InitTest();
+
+    srpServer = &sInstance->Get<Srp::Server>();
+    srpClient = &sInstance->Get<Srp::Client>();
+    dnsClient = &sInstance->Get<Dns::Client>();
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Start SRP server.
+
+    SuccessOrQuit(srpServer->SetAddressMode(Srp::Server::kAddressModeUnicast));
+    VerifyOrQuit(srpServer->GetState() == Srp::Server::kStateDisabled);
+
+    srpServer->SetEnabled(true);
+    VerifyOrQuit(srpServer->GetState() != Srp::Server::kStateDisabled);
+
+    AdvanceTime(10000);
+    VerifyOrQuit(srpServer->GetState() == Srp::Server::kStateRunning);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Start SRP client.
+
+    srpClient->EnableAutoStartMode(nullptr, nullptr);
+    VerifyOrQuit(srpClient->IsAutoStartModeEnabled());
+
+    AdvanceTime(2000);
+    VerifyOrQuit(srpClient->IsRunning());
+
+    writer.Append("otDNS%s.default.service.arpa.", sInstance->Get<Mac::Mac>().GetExtAddress().ToString().AsCString());
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
+    Log("SOA Query");
+
+    for (uint8_t iter = 0; iter < 2; iter++)
+    {
+        sQueryRecordInfo.Reset();
+
+        // First iteration: Query for `default.service.arpa.` directly, and
+        // validate that we see the SOA record in the Answer section.
+        // Second iteration: Query for `myhost.default.service.arpa.`, and
+        // validate that we see the SOA record in the Authority section.
+
+        if (iter == 0)
+        {
+            Log("QueryRecord(%s) for SOA RR", "default.service.arpa.");
+            SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeSoa, "default", "service.arpa.",
+                                                 RecordCallback, sInstance));
+        }
+        else
+        {
+            Log("QueryRecord(%s) for SOA RR", "myhost.default.service.arpa.");
+            SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeSoa, "myhost", "default.service.arpa.",
+                                                 RecordCallback, sInstance));
+        }
+
+        AdvanceTime(100);
+        VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+        SuccessOrQuit(sQueryRecordInfo.mError);
+        VerifyOrQuit(sQueryRecordInfo.mNumRecords == 1);
+
+        if (iter == 0)
+        {
+            VerifyOrQuit(StringMatch(sQueryRecordInfo.mQueryName, "default.service.arpa."));
+            VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+        }
+        else
+        {
+            VerifyOrQuit(StringMatch(sQueryRecordInfo.mQueryName, "myhost.default.service.arpa."));
+            VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAuthority);
+        }
+
+        ValidateSoaRecordData(sQueryRecordInfo.mRecords[0], serverName);
+
+        AdvanceTime(1000);
+    }
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
+    Log("NS Query");
+
+    for (uint8_t iter = 0; iter < 2; iter++)
+    {
+        sQueryRecordInfo.Reset();
+
+        // First iteration: Query for `default.service.arpa.` directly and
+        // validate that we see the NS response in the Answer section. Second
+        // iteration: Query for `myhost.default.service.arpa.` and validate
+        // that we see the SOA record instead in the Authority section in
+        // the response.
+
+        if (iter == 0)
+        {
+            Log("QueryRecord(%s) for NS RR", "default.service.arpa.");
+            SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeNs, "default", "service.arpa.",
+                                                 RecordCallback, sInstance));
+        }
+        else
+        {
+            Log("QueryRecord(%s) for NS RR", "myhost.default.service.arpa.");
+            SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeNs, "myhost", "default.service.arpa.",
+                                                 RecordCallback, sInstance));
+        }
+
+        AdvanceTime(100);
+        VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+        SuccessOrQuit(sQueryRecordInfo.mError);
+        VerifyOrQuit(sQueryRecordInfo.mNumRecords == 1);
+
+        if (iter == 0)
+        {
+            VerifyOrQuit(StringMatch(sQueryRecordInfo.mQueryName, "default.service.arpa."));
+            VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+            ValidateNsRecordData(sQueryRecordInfo.mRecords[0], serverName);
+        }
+        else
+        {
+            VerifyOrQuit(StringMatch(sQueryRecordInfo.mQueryName, "myhost.default.service.arpa."));
+            VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAuthority);
+            ValidateSoaRecordData(sQueryRecordInfo.mRecords[0], serverName);
+        }
+
+        AdvanceTime(1000);
+    }
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
+
+    sQueryRecordInfo.Reset();
+
+    Log("QueryRecord(%s) for ANY RR", "default.service.arpa.");
+    SuccessOrQuit(
+        dnsClient->QueryRecord(Dns::ResourceRecord::kTypeAny, "default", "service.arpa.", RecordCallback, sInstance));
+
+    AdvanceTime(100);
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 2);
+
+    VerifyOrQuit(StringMatch(sQueryRecordInfo.mQueryName, "default.service.arpa."));
+
+    for (uint8_t index = 0; index < 2; index++)
+    {
+        QueryRecordInfo::Record &record = sQueryRecordInfo.mRecords[index];
+
+        VerifyOrQuit(MapEnum(record.mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+
+        switch (record.mRecordType)
+        {
+        case Dns::ResourceRecord::kTypeSoa:
+            ValidateSoaRecordData(record, serverName);
+            break;
+        case Dns::ResourceRecord::kTypeNs:
+            ValidateNsRecordData(record, serverName);
+            break;
+        default:
+            VerifyOrQuit(false);
+            break;
+        }
+
+        AdvanceTime(1000);
+    }
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
+
+    sAddressInfo.Reset();
+    Log("ResolveAddress(%s)", serverName);
+    SuccessOrQuit(dnsClient->ResolveAddress(serverName, AddressCallback, sInstance));
+    AdvanceTime(100);
+    VerifyOrQuit(sAddressInfo.mCallbackCount >= 1);
+    SuccessOrQuit(sAddressInfo.mError);
+    VerifyOrQuit(sAddressInfo.mHostAddresses[0] == sInstance->Get<Mle::Mle>().GetMeshLocalEid());
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Finalize OT instance and validate all heap allocations are freed.
+
+    Log("Finalizing OT instance");
+    FinalizeTest();
+
+    Log("End of TestDnssdSoaNsResponse");
+}
+
 #endif // ENABLE_DNS_TEST
 
 int main(void)
@@ -1336,6 +2018,7 @@ int main(void)
 #if ENABLE_DNS_TEST
     TestDnsClient();
     TestDnssdServerProxyCallback();
+    TestDnssdSoaNsResponse();
     printf("All tests passed\n");
 #else
     printf("DNS_CLIENT or DSNSSD_SERVER feature is not enabled\n");
diff --git a/tests/unit/test_dnssd_discovery_proxy.cpp b/tests/unit/test_dnssd_discovery_proxy.cpp
index 1c6db5f1b..8daf7dab8 100644
--- a/tests/unit/test_dnssd_discovery_proxy.cpp
+++ b/tests/unit/test_dnssd_discovery_proxy.cpp
@@ -487,6 +487,99 @@ exit:
     return;
 }
 
+//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+static constexpr uint16_t kMaxRecordDataSize = 128;
+static constexpr uint16_t kMaxRecords        = 4;
+
+struct QueryRecordInfo
+{
+    struct Record : public Dns::Client::RecordInfo
+    {
+        void Init(void)
+        {
+            ClearAllBytes(*this);
+            mNameBuffer     = mName;
+            mNameBufferSize = sizeof(mName);
+            mDataBuffer     = mData;
+            mDataBufferSize = sizeof(mData);
+        }
+
+        uint8_t mData[kMaxRecordDataSize];
+        char    mName[Dns::Name::kMaxNameSize];
+    };
+
+    void Reset(void) { memset(this, 0, sizeof(*this)); };
+
+    uint16_t mCallbackCount;
+    Error    mError;
+    char     mQueryName[Dns::Name::kMaxNameSize];
+    Record   mRecords[kMaxRecords];
+    uint16_t mNumRecords;
+};
+
+static QueryRecordInfo sQueryRecordInfo;
+
+void RecordCallback(otError aError, const otDnsRecordResponse *aResponse, void *aContext)
+{
+    static constexpr uint16_t kMaxStringSize = 400;
+
+    const Dns::Client::RecordResponse &response = AsCoreType(aResponse);
+
+    Log("RecordCallback");
+    Log("   Error: %s", ErrorToString(aError));
+
+    VerifyOrQuit(aContext == sInstance);
+
+    sQueryRecordInfo.mCallbackCount++;
+    sQueryRecordInfo.mError      = aError;
+    sQueryRecordInfo.mNumRecords = 0;
+
+    SuccessOrExit(aError);
+
+    SuccessOrQuit(response.GetQueryName(sQueryRecordInfo.mQueryName, sizeof(sQueryRecordInfo.mQueryName)));
+    Log("   QueryName: %s", sQueryRecordInfo.mQueryName);
+
+    for (uint8_t index = 0; index < kMaxRecords; index++)
+    {
+        Error    error;
+        uint32_t ttl;
+
+        sQueryRecordInfo.mRecords[index].Init();
+
+        error = response.GetRecordInfo(index, sQueryRecordInfo.mRecords[index]);
+
+        if (error == kErrorNotFound)
+        {
+            sQueryRecordInfo.mNumRecords = index;
+            break;
+        }
+
+        SuccessOrQuit(error);
+    }
+
+    Log("   NumRecords: %u", sQueryRecordInfo.mNumRecords);
+
+    for (uint16_t index = 0; index < sQueryRecordInfo.mNumRecords; index++)
+    {
+        const QueryRecordInfo::Record &record = sQueryRecordInfo.mRecords[index];
+        String<kMaxStringSize>         string;
+        uint16_t                       rrType;
+
+        string.AppendHexBytes(record.mDataBuffer, record.mDataBufferSize);
+        rrType = record.mRecordType;
+
+        Log("   Record %u", index);
+        Log("      Name: %s", record.mNameBuffer);
+        Log("      Type: %u (%s)", rrType, Dns::ResourceRecord::TypeToString(rrType).AsCString());
+        Log("      TTL: %lu", ToUlong(record.mTtl));
+        Log("      Data: %s", string.AsCString());
+    }
+
+exit:
+    return;
+}
+
 //----------------------------------------------------------------------------------------------------------------------
 // otPlatDnssd APIs
 
@@ -582,6 +675,29 @@ struct IpAddrResolverInfo : public Clearable<IpAddrResolverInfo>
     otPlatDnssdAddressCallback mCallback;
 };
 
+struct RecordQuerierInfo : public Clearable<RecordQuerierInfo>
+{
+    bool NameMatches(const char *aFirsLabel, const char *aNextLabels) const
+    {
+        return !strcmp(mFirstLabel, aFirsLabel) && !strcmp(mNextLabels, aNextLabels == nullptr ? "" : aNextLabels);
+    }
+
+    void UpdateFrom(const otPlatDnssdRecordQuerier *aQuerier)
+    {
+        mCallCount++;
+        CopyString(mFirstLabel, aQuerier->mFirstLabel);
+        CopyString(mNextLabels, aQuerier->mNextLabels);
+        mRecordType = aQuerier->mRecordType;
+        mCallback   = aQuerier->mCallback;
+    }
+
+    uint16_t                  mCallCount;
+    char                      mFirstLabel[Dns::Name::kMaxLabelSize];
+    char                      mNextLabels[Dns::Name::kMaxNameSize];
+    uint16_t                  mRecordType;
+    otPlatDnssdRecordCallback mCallback;
+};
+
 struct InvokeOnStart : public Clearable<InvokeOnStart>
 {
     // When not null, these entries are used to invoke callback
@@ -593,6 +709,7 @@ struct InvokeOnStart : public Clearable<InvokeOnStart>
     const otPlatDnssdTxtResult     *mTxtResult;
     const otPlatDnssdAddressResult *mIp6AddrResult;
     const otPlatDnssdAddressResult *mIp4AddrResult;
+    const otPlatDnssdRecordResult  *mRecordResult;
 };
 
 static BrowserInfo        sStartBrowserInfo;
@@ -605,6 +722,8 @@ static IpAddrResolverInfo sStartIp6AddrResolverInfo;
 static IpAddrResolverInfo sStopIp6AddrResolverInfo;
 static IpAddrResolverInfo sStartIp4AddrResolverInfo;
 static IpAddrResolverInfo sStopIp4AddrResolverInfo;
+static RecordQuerierInfo  sStartRecordQuerierInfo;
+static RecordQuerierInfo  sStopRecordQuerierInfo;
 
 static InvokeOnStart sInvokeOnStart;
 
@@ -620,6 +739,8 @@ void ResetPlatDnssdApiInfo(void)
     sStopIp6AddrResolverInfo.Clear();
     sStartIp4AddrResolverInfo.Clear();
     sStopIp4AddrResolverInfo.Clear();
+    sStartRecordQuerierInfo.Clear();
+    sStopRecordQuerierInfo.Clear();
     sInvokeOnStart.Clear();
 }
 
@@ -694,6 +815,26 @@ void InvokeIp4AddrResolverCallback(const otPlatDnssdAddressCallback aCallback, c
     aCallback(sInstance, &aResult);
 }
 
+void InvokeRecordQuerierCallback(const otPlatDnssdRecordCallback aCallback, const otPlatDnssdRecordResult &aResult)
+{
+    static constexpr uint16_t kMaxDataStringSize = 400;
+
+    String<kMaxDataStringSize> string;
+
+    string.AppendHexBytes(aResult.mRecordData, aResult.mRecordDataLength);
+
+    Log("Invoking record callback");
+    Log("    firstLabel     : %s", aResult.mFirstLabel);
+    Log("    nextLabels     : %s", StringNullCheck(aResult.mNextLabels));
+    Log("    recordType     : %s", Dns::ResourceRecord::TypeToString(aResult.mRecordType).AsCString());
+    Log("    ttl            : %u", aResult.mTtl);
+    Log("    if-index       : %u", aResult.mInfraIfIndex);
+    Log("    dataLength     : %u", aResult.mRecordDataLength);
+    Log("    data           : %s", string.AsCString());
+
+    aCallback(sInstance, &aResult);
+}
+
 otPlatDnssdState otPlatDnssdGetState(otInstance *aInstance)
 {
     OT_UNUSED_VARIABLE(aInstance);
@@ -856,6 +997,42 @@ void otPlatDnssdStopIp4AddressResolver(otInstance *aInstance, const otPlatDnssdA
     }
 }
 
+void otPlatDnssdStartRecordQuerier(otInstance *aInstance, const otPlatDnssdRecordQuerier *aQuerier)
+{
+    VerifyOrQuit(aQuerier != nullptr);
+
+    Log("otPlatDnssdStartRecordQuerier(%s, %s, %s)", aQuerier->mFirstLabel, StringNullCheck(aQuerier->mNextLabels),
+        Dns::ResourceRecord::TypeToString(aQuerier->mRecordType).AsCString());
+
+    VerifyOrQuit(aInstance == sInstance);
+    VerifyOrQuit(aQuerier->mInfraIfIndex == kInfraIfIndex);
+
+    sStartRecordQuerierInfo.UpdateFrom(aQuerier);
+
+    if (sInvokeOnStart.mRecordResult != nullptr)
+    {
+        InvokeRecordQuerierCallback(aQuerier->mCallback, *sInvokeOnStart.mRecordResult);
+    }
+}
+
+void otPlatDnssdStopRecordQuerier(otInstance *aInstance, const otPlatDnssdRecordQuerier *aQuerier)
+{
+    VerifyOrQuit(aQuerier != nullptr);
+
+    Log("otPlatDnssdStopRecordQuerier(\"%s, %s, %s\")", aQuerier->mFirstLabel, StringNullCheck(aQuerier->mNextLabels),
+        Dns::ResourceRecord::TypeToString(aQuerier->mRecordType).AsCString());
+
+    VerifyOrQuit(aInstance == sInstance);
+    VerifyOrQuit(aQuerier->mInfraIfIndex == kInfraIfIndex);
+
+    sStopRecordQuerierInfo.UpdateFrom(aQuerier);
+
+    if (sInvokeOnStart.mRecordResult != nullptr)
+    {
+        InvokeRecordQuerierCallback(aQuerier->mCallback, *sInvokeOnStart.mRecordResult);
+    }
+}
+
 //----------------------------------------------------------------------------------------------------------------------
 
 void TestProxyBasic(void)
@@ -863,6 +1040,21 @@ void TestProxyBasic(void)
     static constexpr uint32_t kTtl = 300;
 
     const uint8_t kTxtData[] = {3, 'A', '=', '1', 0};
+    const uint8_t kKeyData[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99};
+
+    const uint8_t kCnameData[] = {
+        10, 'p', 'r', 'o', 't', 'e', 'c', 't', 'o', 'r', 's', /* protectors */
+        5,  'l', 'o', 'c', 'a', 'l',                          /* local */
+        0,
+    };
+
+    const uint8_t kTranslatedCnameData[] = {
+        10, 'p', 'r', 'o', 't', 'e', 'c', 't', 'o', 'r', 's', /* protectors */
+        7,  'd', 'e', 'f', 'a', 'u', 'l', 't',                /* default */
+        7,  's', 'e', 'r', 'v', 'i', 'c', 'e',                /* service */
+        4,  'a', 'r', 'p', 'a',                               /* arpa */
+        0,
+    };
 
     Srp::Server                     *srpServer;
     Srp::Client                     *srpClient;
@@ -874,6 +1066,7 @@ void TestProxyBasic(void)
     Dnssd::AddressResult             ip6AddrrResult;
     Dnssd::AddressResult             ip4AddrrResult;
     Dnssd::AddressAndTtl             addressAndTtl;
+    Dnssd::RecordResult              recordResult;
     NetworkData::ExternalRouteConfig routeConfig;
     Ip6::Address                     address;
 
@@ -942,6 +1135,8 @@ void TestProxyBasic(void)
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStartBrowserInfo.ServiceTypeMatches("_avenger._udp"));
 
@@ -970,6 +1165,8 @@ void TestProxyBasic(void)
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStopBrowserInfo.ServiceTypeMatches("_avenger._udp"));
     VerifyOrQuit(sStopBrowserInfo.mCallback == sStartBrowserInfo.mCallback);
@@ -1001,6 +1198,8 @@ void TestProxyBasic(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStopSrvResolverInfo.ServiceTypeMatches("_avenger._udp"));
     VerifyOrQuit(sStopSrvResolverInfo.ServiceInstanceMatches("hulk"));
@@ -1035,6 +1234,8 @@ void TestProxyBasic(void)
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStopTxtResolverInfo.ServiceTypeMatches("_avenger._udp"));
     VerifyOrQuit(sStopTxtResolverInfo.ServiceInstanceMatches("hulk"));
@@ -1069,6 +1270,8 @@ void TestProxyBasic(void)
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 1);
     VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStopIp6AddrResolverInfo.HostNameMatches("compound"));
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallback == sStartIp6AddrResolverInfo.mCallback);
@@ -1114,6 +1317,8 @@ void TestProxyBasic(void)
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStartSrvResolverInfo.ServiceTypeMatches("_avenger._udp"));
     VerifyOrQuit(sStartSrvResolverInfo.ServiceInstanceMatches("iron.man"));
@@ -1144,6 +1349,8 @@ void TestProxyBasic(void)
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sResolveServiceInfo.mCallbackCount == 0);
 
@@ -1170,6 +1377,8 @@ void TestProxyBasic(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sResolveServiceInfo.mCallbackCount == 0);
 
@@ -1204,6 +1413,8 @@ void TestProxyBasic(void)
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sResolveServiceInfo.mCallbackCount == 0);
 
@@ -1233,6 +1444,8 @@ void TestProxyBasic(void)
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 1);
     VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStopIp6AddrResolverInfo.HostNameMatches("starktower"));
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallback == sStartIp6AddrResolverInfo.mCallback);
@@ -1273,6 +1486,8 @@ void TestProxyBasic(void)
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStartIp6AddrResolverInfo.HostNameMatches("earth"));
 
@@ -1304,6 +1519,8 @@ void TestProxyBasic(void)
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 1);
     VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStopIp6AddrResolverInfo.HostNameMatches("earth"));
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallback == sStartIp6AddrResolverInfo.mCallback);
@@ -1339,6 +1556,8 @@ void TestProxyBasic(void)
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 1);
     VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStartIp4AddrResolverInfo.HostNameMatches("shield"));
 
@@ -1370,6 +1589,8 @@ void TestProxyBasic(void)
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 1);
     VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 1);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStopIp4AddrResolverInfo.HostNameMatches("shield"));
     VerifyOrQuit(sStopIp4AddrResolverInfo.mCallback == sStartIp4AddrResolverInfo.mCallback);
@@ -1396,6 +1617,403 @@ void TestProxyBasic(void)
 
     VerifyOrQuit(sResolveAddressInfo.mHostAddresses[0] == address);
 
+    Log("--------------------------------------------------------------------------------------------");
+
+    ResetPlatDnssdApiInfo();
+    sQueryRecordInfo.Reset();
+
+    Log("QueryRecord() for KEY and hostname");
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeKey, "shield", "default.service.arpa.",
+                                         RecordCallback, sInstance));
+    AdvanceTime(10);
+
+    // Check that a record querier is started
+
+    VerifyOrQuit(sStartBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStopBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStartSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 1);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
+
+    VerifyOrQuit(sStartRecordQuerierInfo.NameMatches("shield", nullptr));
+    VerifyOrQuit(sStartRecordQuerierInfo.mRecordType == Dns::ResourceRecord::kTypeKey);
+
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 0);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
+    Log("Invoke Record Querier callback");
+
+    recordResult.mFirstLabel       = "shield";
+    recordResult.mNextLabels       = nullptr;
+    recordResult.mRecordType       = Dns::ResourceRecord::kTypeKey;
+    recordResult.mRecordData       = kKeyData;
+    recordResult.mRecordDataLength = sizeof(kKeyData);
+    recordResult.mTtl              = kTtl;
+    recordResult.mInfraIfIndex     = kInfraIfIndex;
+
+    InvokeRecordQuerierCallback(sStartRecordQuerierInfo.mCallback, recordResult);
+
+    AdvanceTime(10);
+
+    // Check that the record querier is stopped
+
+    VerifyOrQuit(sStartBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStopBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStartSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 1);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 1);
+
+    VerifyOrQuit(sStopRecordQuerierInfo.NameMatches("shield", nullptr));
+    VerifyOrQuit(sStopRecordQuerierInfo.mRecordType == Dns::ResourceRecord::kTypeKey);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallback == sStartRecordQuerierInfo.mCallback);
+
+    // Check that response is sent to client and validate it
+
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mQueryName, "shield.default.service.arpa."));
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 1);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mRecords[0].mNameBuffer, "shield.default.service.arpa."));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordType == Dns::ResourceRecord::kTypeKey);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordLength == sizeof(kKeyData));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mTtl == kTtl);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mDataBufferSize == sizeof(kKeyData));
+    VerifyOrQuit(!memcmp(sQueryRecordInfo.mRecords[0].mDataBuffer, kKeyData, sizeof(kKeyData)));
+    VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+
+    Log("--------------------------------------------------------------------------------------------");
+
+    ResetPlatDnssdApiInfo();
+    sQueryRecordInfo.Reset();
+
+    Log("QueryRecord() for KEY and service instance name");
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeKey, "iron.man",
+                                         "_avenger._udp.default.service.arpa.", RecordCallback, sInstance));
+    AdvanceTime(10);
+
+    // Check that a record querier is started
+
+    VerifyOrQuit(sStartBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStopBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStartSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 1);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
+
+    VerifyOrQuit(sStartRecordQuerierInfo.NameMatches("iron.man", "_avenger._udp"));
+    VerifyOrQuit(sStartRecordQuerierInfo.mRecordType == Dns::ResourceRecord::kTypeKey);
+
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 0);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
+    Log("Invoke Record Querier callback");
+
+    recordResult.mFirstLabel       = "iron.man";
+    recordResult.mNextLabels       = "_avenger._udp";
+    recordResult.mRecordType       = Dns::ResourceRecord::kTypeKey;
+    recordResult.mRecordData       = kKeyData;
+    recordResult.mRecordDataLength = sizeof(kKeyData);
+    recordResult.mTtl              = kTtl;
+    recordResult.mInfraIfIndex     = kInfraIfIndex;
+
+    InvokeRecordQuerierCallback(sStartRecordQuerierInfo.mCallback, recordResult);
+
+    AdvanceTime(10);
+
+    // Check that the record querier is stopped
+
+    VerifyOrQuit(sStartBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStopBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStartSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 1);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 1);
+
+    VerifyOrQuit(sStopRecordQuerierInfo.NameMatches("iron.man", "_avenger._udp"));
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallback == sStartRecordQuerierInfo.mCallback);
+    VerifyOrQuit(sStopRecordQuerierInfo.mRecordType == Dns::ResourceRecord::kTypeKey);
+
+    // Check that response is sent to client and validate it
+
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mQueryName, "iron.man._avenger._udp.default.service.arpa."));
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 1);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mRecords[0].mNameBuffer, "iron.man._avenger._udp.default.service.arpa."));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordType == Dns::ResourceRecord::kTypeKey);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordLength == sizeof(kKeyData));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mTtl == kTtl);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mDataBufferSize == sizeof(kKeyData));
+    VerifyOrQuit(!memcmp(sQueryRecordInfo.mRecords[0].mDataBuffer, kKeyData, sizeof(kKeyData)));
+    VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+
+    Log("--------------------------------------------------------------------------------------------");
+
+    ResetPlatDnssdApiInfo();
+    sQueryRecordInfo.Reset();
+
+    Log("QueryRecord() for CNAME that requires RDATA translation");
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeCname, "avengers", "default.service.arpa.",
+                                         RecordCallback, sInstance));
+    AdvanceTime(10);
+
+    // Check that a record querier is started
+
+    VerifyOrQuit(sStartBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStopBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStartSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 1);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
+
+    VerifyOrQuit(sStartRecordQuerierInfo.NameMatches("avengers", nullptr));
+
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 0);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
+    Log("Invoke Record Querier callback");
+
+    recordResult.mFirstLabel       = "avengers";
+    recordResult.mNextLabels       = nullptr;
+    recordResult.mRecordType       = Dns::ResourceRecord::kTypeCname;
+    recordResult.mRecordData       = kCnameData;
+    recordResult.mRecordDataLength = sizeof(kCnameData);
+    recordResult.mTtl              = kTtl;
+    recordResult.mInfraIfIndex     = kInfraIfIndex;
+
+    InvokeRecordQuerierCallback(sStartRecordQuerierInfo.mCallback, recordResult);
+
+    AdvanceTime(10);
+
+    // Check that the record querier is stopped
+
+    VerifyOrQuit(sStartBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStopBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStartSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 1);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 1);
+
+    VerifyOrQuit(sStopRecordQuerierInfo.NameMatches("avengers", nullptr));
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallback == sStartRecordQuerierInfo.mCallback);
+
+    // Check that response is sent to client and validate
+    // that the CNAME RDATA is correctly translated.
+
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mQueryName, "avengers.default.service.arpa."));
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 1);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mRecords[0].mNameBuffer, "avengers.default.service.arpa."));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordType == Dns::ResourceRecord::kTypeCname);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordLength == sizeof(kTranslatedCnameData));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mTtl == kTtl);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mDataBufferSize == sizeof(kTranslatedCnameData));
+    VerifyOrQuit(!memcmp(sQueryRecordInfo.mRecords[0].mDataBuffer, kTranslatedCnameData, sizeof(kTranslatedCnameData)));
+    VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+
+    Log("--------------------------------------------------------------------------------------------");
+
+    ResetPlatDnssdApiInfo();
+    sQueryRecordInfo.Reset();
+
+    Log("QueryRecord() for ANY and host name");
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeAny, "shield", "default.service.arpa.",
+                                         RecordCallback, sInstance));
+    AdvanceTime(10);
+
+    // Check that a record querier is started
+
+    VerifyOrQuit(sStartBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStopBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStartSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 1);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
+
+    VerifyOrQuit(sStartRecordQuerierInfo.NameMatches("shield", nullptr));
+    VerifyOrQuit(sStartRecordQuerierInfo.mRecordType == Dns::ResourceRecord::kTypeAny);
+
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 0);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
+    Log("Invoke Record Querier callback");
+
+    recordResult.mFirstLabel       = "shield";
+    recordResult.mNextLabels       = nullptr;
+    recordResult.mRecordType       = Dns::ResourceRecord::kTypeKey;
+    recordResult.mRecordData       = kKeyData;
+    recordResult.mRecordDataLength = sizeof(kKeyData);
+    recordResult.mTtl              = kTtl;
+    recordResult.mInfraIfIndex     = kInfraIfIndex;
+
+    InvokeRecordQuerierCallback(sStartRecordQuerierInfo.mCallback, recordResult);
+
+    AdvanceTime(10);
+
+    // Check that the record querier is stopped
+
+    VerifyOrQuit(sStartBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStopBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStartSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 1);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 1);
+
+    VerifyOrQuit(sStopRecordQuerierInfo.NameMatches("shield", nullptr));
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallback == sStartRecordQuerierInfo.mCallback);
+
+    // Check that response is sent to client and validate it
+
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mQueryName, "shield.default.service.arpa."));
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 1);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mRecords[0].mNameBuffer, "shield.default.service.arpa."));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordType == Dns::ResourceRecord::kTypeKey);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordLength == sizeof(kKeyData));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mTtl == kTtl);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mDataBufferSize == sizeof(kKeyData));
+    VerifyOrQuit(!memcmp(sQueryRecordInfo.mRecords[0].mDataBuffer, kKeyData, sizeof(kKeyData)));
+    VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+
+    Log("--------------------------------------------------------------------------------------------");
+
+    ResetPlatDnssdApiInfo();
+    sQueryRecordInfo.Reset();
+
+    Log("QueryRecord() for ANY and service instance name");
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeAny, "iron.man",
+                                         "_avenger._udp.default.service.arpa.", RecordCallback, sInstance));
+    AdvanceTime(10);
+
+    // Check that a record querier is started
+
+    VerifyOrQuit(sStartBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStopBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStartSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 1);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
+
+    VerifyOrQuit(sStartRecordQuerierInfo.NameMatches("iron.man", "_avenger._udp"));
+    VerifyOrQuit(sStartRecordQuerierInfo.mRecordType == Dns::ResourceRecord::kTypeAny);
+
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 0);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
+    Log("Invoke Record Querier callback");
+
+    recordResult.mFirstLabel       = "iron.man";
+    recordResult.mNextLabels       = "_avenger._udp";
+    recordResult.mRecordType       = Dns::ResourceRecord::kTypeKey;
+    recordResult.mRecordData       = kKeyData;
+    recordResult.mRecordDataLength = sizeof(kKeyData);
+    recordResult.mTtl              = kTtl;
+    recordResult.mInfraIfIndex     = kInfraIfIndex;
+
+    InvokeRecordQuerierCallback(sStartRecordQuerierInfo.mCallback, recordResult);
+
+    AdvanceTime(10);
+
+    // Check that the record querier is stopped
+
+    VerifyOrQuit(sStartBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStopBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStartSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopIp4AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 1);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 1);
+
+    VerifyOrQuit(sStopRecordQuerierInfo.NameMatches("iron.man", "_avenger._udp"));
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallback == sStartRecordQuerierInfo.mCallback);
+
+    // Check that response is sent to client and validate it
+
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mQueryName, "iron.man._avenger._udp.default.service.arpa."));
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 1);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mRecords[0].mNameBuffer, "iron.man._avenger._udp.default.service.arpa."));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordType == Dns::ResourceRecord::kTypeKey);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordLength == sizeof(kKeyData));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mTtl == kTtl);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mDataBufferSize == sizeof(kKeyData));
+    VerifyOrQuit(!memcmp(sQueryRecordInfo.mRecords[0].mDataBuffer, kKeyData, sizeof(kKeyData)));
+    VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
     Log("Stop DNS-SD server");
 
@@ -1480,6 +2098,8 @@ void TestProxySubtypeBrowse(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStartBrowserInfo.ServiceTypeMatches("_avenger._udp"));
     VerifyOrQuit(sStartBrowserInfo.SubTypeMatches("_god"));
@@ -1509,6 +2129,8 @@ void TestProxySubtypeBrowse(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStopBrowserInfo.ServiceTypeMatches("_avenger._udp"));
     VerifyOrQuit(sStopBrowserInfo.SubTypeMatches("_god"));
@@ -1544,6 +2166,8 @@ void TestProxySubtypeBrowse(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStopSrvResolverInfo.ServiceTypeMatches("_avenger._udp"));
     VerifyOrQuit(sStopSrvResolverInfo.ServiceInstanceMatches("thor"));
@@ -1575,6 +2199,8 @@ void TestProxySubtypeBrowse(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 1);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 1);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStopTxtResolverInfo.ServiceTypeMatches("_avenger._udp"));
     VerifyOrQuit(sStopTxtResolverInfo.ServiceInstanceMatches("thor"));
@@ -1607,6 +2233,8 @@ void TestProxySubtypeBrowse(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 1);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 1);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 1);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStopIp6AddrResolverInfo.HostNameMatches("asgard"));
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallback == sStartIp6AddrResolverInfo.mCallback);
@@ -1716,6 +2344,8 @@ void TestProxyTimeout(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStartBrowserInfo.ServiceTypeMatches("_game._ps5"));
 
@@ -1754,6 +2384,8 @@ void TestProxyTimeout(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStartBrowserInfo.ServiceTypeMatches("_avenger._udp"));
 
@@ -1780,6 +2412,8 @@ void TestProxyTimeout(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStopBrowserInfo.ServiceTypeMatches("_avenger._udp"));
 
@@ -1806,6 +2440,8 @@ void TestProxyTimeout(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStopBrowserInfo.ServiceTypeMatches("_avenger._udp"));
 
@@ -1834,6 +2470,8 @@ void TestProxyTimeout(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStartBrowserInfo.ServiceTypeMatches("_avenger._udp"));
 
@@ -1850,6 +2488,8 @@ void TestProxyTimeout(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStartBrowserInfo.ServiceTypeMatches("_game._udp"));
 
@@ -1867,6 +2507,8 @@ void TestProxyTimeout(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStartSrvResolverInfo.ServiceTypeMatches("_avenger._udp"));
     VerifyOrQuit(sStartSrvResolverInfo.ServiceInstanceMatches("wanda"));
@@ -1884,9 +2526,30 @@ void TestProxyTimeout(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 1);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStartIp6AddrResolverInfo.HostNameMatches("earth"));
 
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
+    Log("QueryRecord()");
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeKey, "iron.man",
+                                         "_avenger._udp.default.service.arpa.", RecordCallback, sInstance));
+    AdvanceTime(10);
+
+    VerifyOrQuit(sStartBrowserInfo.mCallCount == 2);
+    VerifyOrQuit(sStopBrowserInfo.mCallCount == 0);
+    VerifyOrQuit(sStartSrvResolverInfo.mCallCount == 1);
+    VerifyOrQuit(sStopSrvResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 1);
+    VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 0);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 1);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
+
+    VerifyOrQuit(sStartRecordQuerierInfo.NameMatches("iron.man", "_avenger._udp"));
+
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
     Log("Wait for timeout for all requests");
 
@@ -1911,10 +2574,13 @@ void TestProxyTimeout(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 0);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 1);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 1);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 1);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 1);
 
     VerifyOrQuit(sStopSrvResolverInfo.ServiceTypeMatches("_avenger._udp"));
     VerifyOrQuit(sStopSrvResolverInfo.ServiceInstanceMatches("wanda"));
     VerifyOrQuit(sStopIp6AddrResolverInfo.HostNameMatches("earth"));
+    VerifyOrQuit(sStopRecordQuerierInfo.NameMatches("iron.man", "_avenger._udp"));
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
     Log("Stop DNS-SD server");
@@ -2634,6 +3300,7 @@ void TestProxyInvokeCallbackFromStartApi(void)
     static constexpr uint32_t kTtl = 300;
 
     const uint8_t kTxtData[] = {3, 'A', '=', '1', 0};
+    const uint8_t kKeyData[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99};
 
     Srp::Server                   *srpServer;
     Srp::Client                   *srpClient;
@@ -2644,6 +3311,7 @@ void TestProxyInvokeCallbackFromStartApi(void)
     Dnssd::TxtResult               txtResult;
     Dnssd::AddressResult           ip6AddrrResult;
     Dnssd::AddressAndTtl           addressAndTtl[2];
+    Dnssd::RecordResult            recordResult;
 
     Log("--------------------------------------------------------------------------------------------");
     Log("TestProxyInvokeCallbackFromStartApi");
@@ -2687,6 +3355,7 @@ void TestProxyInvokeCallbackFromStartApi(void)
     sInvokeOnStart.mSrvResult     = &srvResult;
     sInvokeOnStart.mTxtResult     = &txtResult;
     sInvokeOnStart.mIp6AddrResult = &ip6AddrrResult;
+    sInvokeOnStart.mRecordResult  = &recordResult;
 
     browseResult.mServiceType     = "_guardian._glaxy";
     browseResult.mSubTypeLabel    = nullptr;
@@ -2718,6 +3387,14 @@ void TestProxyInvokeCallbackFromStartApi(void)
     ip6AddrrResult.mAddresses       = addressAndTtl;
     ip6AddrrResult.mAddressesLength = 2;
 
+    recordResult.mFirstLabel       = "drax";
+    recordResult.mNextLabels       = "_guardian._glaxy";
+    recordResult.mRecordType       = Dns::ResourceRecord::kTypeKey;
+    recordResult.mRecordData       = kKeyData;
+    recordResult.mRecordDataLength = sizeof(kKeyData);
+    recordResult.mTtl              = kTtl;
+    recordResult.mInfraIfIndex     = kInfraIfIndex;
+
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
     sBrowseInfo.Reset();
 
@@ -2736,6 +3413,8 @@ void TestProxyInvokeCallbackFromStartApi(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 1);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 1);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 1);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStartBrowserInfo.ServiceTypeMatches("_guardian._glaxy"));
     VerifyOrQuit(sStopBrowserInfo.ServiceTypeMatches("_guardian._glaxy"));
@@ -2786,6 +3465,8 @@ void TestProxyInvokeCallbackFromStartApi(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 2);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 2);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 2);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStartSrvResolverInfo.ServiceTypeMatches("_guardian._glaxy"));
     VerifyOrQuit(sStartSrvResolverInfo.ServiceInstanceMatches("mantis"));
@@ -2836,6 +3517,8 @@ void TestProxyInvokeCallbackFromStartApi(void)
     VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 2);
     VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 3);
     VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 3);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 0);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 0);
 
     VerifyOrQuit(sStartIp6AddrResolverInfo.HostNameMatches("nova"));
     VerifyOrQuit(sStopIp6AddrResolverInfo.HostNameMatches("nova"));
@@ -2854,6 +3537,46 @@ void TestProxyInvokeCallbackFromStartApi(void)
                      sResolveAddressInfo.mHostAddresses[index] == AsCoreType(&addressAndTtl[1].mAddress));
     }
 
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
+
+    sQueryRecordInfo.Reset();
+    Log("QueryRecord()");
+    SuccessOrQuit(dnsClient->QueryRecord(Dns::ResourceRecord::kTypeKey, "drax",
+                                         "_guardian._glaxy.default.service.arpa.", RecordCallback, sInstance));
+    AdvanceTime(10);
+
+    // Check that the record querier is started and then stopped
+
+    VerifyOrQuit(sStartBrowserInfo.mCallCount == 1);
+    VerifyOrQuit(sStopBrowserInfo.mCallCount == 1);
+    VerifyOrQuit(sStartSrvResolverInfo.mCallCount == 2);
+    VerifyOrQuit(sStopSrvResolverInfo.mCallCount == 2);
+    VerifyOrQuit(sStartTxtResolverInfo.mCallCount == 2);
+    VerifyOrQuit(sStopTxtResolverInfo.mCallCount == 2);
+    VerifyOrQuit(sStartIp6AddrResolverInfo.mCallCount == 3);
+    VerifyOrQuit(sStopIp6AddrResolverInfo.mCallCount == 3);
+    VerifyOrQuit(sStartRecordQuerierInfo.mCallCount == 1);
+    VerifyOrQuit(sStopRecordQuerierInfo.mCallCount == 1);
+
+    VerifyOrQuit(sStartRecordQuerierInfo.NameMatches("drax", "_guardian._glaxy"));
+    VerifyOrQuit(sStopRecordQuerierInfo.NameMatches("drax", "_guardian._glaxy"));
+
+    // Validate the query record response on client
+
+    VerifyOrQuit(sQueryRecordInfo.mCallbackCount == 1);
+    SuccessOrQuit(sQueryRecordInfo.mError);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mQueryName, "drax._guardian._glaxy.default.service.arpa."));
+    VerifyOrQuit(sQueryRecordInfo.mNumRecords == 1);
+
+    VerifyOrQuit(!strcmp(sQueryRecordInfo.mRecords[0].mNameBuffer, "drax._guardian._glaxy.default.service.arpa."));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordType == Dns::ResourceRecord::kTypeKey);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mRecordLength == sizeof(kKeyData));
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mTtl == kTtl);
+    VerifyOrQuit(sQueryRecordInfo.mRecords[0].mDataBufferSize == sizeof(kKeyData));
+    VerifyOrQuit(!memcmp(sQueryRecordInfo.mRecords[0].mDataBuffer, kKeyData, sizeof(kKeyData)));
+    VerifyOrQuit(MapEnum(sQueryRecordInfo.mRecords[0].mSection) == Dns::Client::RecordInfo::kSectionAnswer);
+
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
     Log("Stop DNS-SD server");
 
diff --git a/tests/unit/test_lowpan.cpp b/tests/unit/test_lowpan.cpp
index 992a21407..22e1e1139 100644
--- a/tests/unit/test_lowpan.cpp
+++ b/tests/unit/test_lowpan.cpp
@@ -104,7 +104,7 @@ static void Init(void)
     otMeshLocalPrefix meshLocalPrefix = {{0xfd, 0x00, 0xca, 0xfe, 0xfa, 0xce, 0x12, 0x34}};
     OffsetRange       offsetRange;
 
-    sInstance->Get<Mle::MleRouter>().SetMeshLocalPrefix(static_cast<Ip6::NetworkPrefix &>(meshLocalPrefix));
+    sInstance->Get<Mle::Mle>().SetMeshLocalPrefix(static_cast<Ip6::NetworkPrefix &>(meshLocalPrefix));
 
     // Emulate global prefixes with contextes.
     uint8_t mockNetworkData[] = {
diff --git a/tests/unit/test_mdns.cpp b/tests/unit/test_mdns.cpp
index eef4bc39c..a21205270 100644
--- a/tests/unit/test_mdns.cpp
+++ b/tests/unit/test_mdns.cpp
@@ -245,7 +245,8 @@ struct DnsRecord : public Allocatable<DnsRecord>, public LinkedListEntry<DnsReco
     {
         RecordData(void) { memset(this, 0, sizeof(*this)); }
 
-        Ip6::Address                 mIp6Address; // For AAAAA (or A)
+        Ip6::Address                 mIp6Address; // For AAAAA
+        Ip4::Address                 mIp4Address; // For A
         SrvData                      mSrv;        // For SRV
         Array<uint8_t, kMaxDataSize> mData;       // For TXT or KEY
         DnsName                      mPtrName;    // For PTR
@@ -285,6 +286,12 @@ struct DnsRecord : public Allocatable<DnsRecord>, public LinkedListEntry<DnsReco
 
         switch (mType)
         {
+        case ResourceRecord::kTypeA:
+            VerifyOrQuit(record.GetLength() == sizeof(Ip4::Address));
+            SuccessOrQuit(aMessage.Read(offset, mData.mIp4Address));
+            logStr.Append(" %s", mData.mIp4Address.ToString().AsCString());
+            break;
+
         case ResourceRecord::kTypeAaaa:
             VerifyOrQuit(record.GetLength() == sizeof(Ip6::Address));
             SuccessOrQuit(aMessage.Read(offset, mData.mIp6Address));
@@ -415,6 +422,31 @@ struct DnsRecords : public OwningList<DnsRecord>
         return contains;
     }
 
+    bool ContainsA(const DnsNameString &aFullName,
+                   const Ip4::Address  &aAddress,
+                   bool                 aCacheFlush,
+                   TtlCheckMode         aTtlCheckMode,
+                   uint32_t             aTtl = 0) const
+    {
+        bool contains = false;
+
+        for (const DnsRecord &record : *this)
+        {
+            if (record.Matches(aFullName.AsCString()) && (record.mType == ResourceRecord::kTypeA) &&
+                (record.mData.mIp4Address == aAddress))
+            {
+                VerifyOrExit(record.mClass == ResourceRecord::kClassInternet);
+                VerifyOrExit(record.mCacheFlush == aCacheFlush);
+                VerifyOrExit(record.MatchesTtl(aTtlCheckMode, aTtl));
+                contains = true;
+                ExitNow();
+            }
+        }
+
+    exit:
+        return contains;
+    }
+
     bool ContainsKey(const DnsNameString &aFullName,
                      const Data          &aKeyData,
                      bool                 aCacheFlush,
@@ -449,7 +481,8 @@ struct DnsRecords : public OwningList<DnsRecord>
         bool          contains = false;
         DnsNameString hostName;
 
-        hostName.Append("%s.local.", aService.mHostName);
+        hostName.Append("%s.local.",
+                        aService.mHostName != nullptr ? aService.mHostName : sInstance->Get<Core>().GetLocalHostName());
 
         for (const DnsRecord &record : *this)
         {
@@ -556,7 +589,7 @@ struct DnsRecords : public OwningList<DnsRecord>
     }
 };
 
-// Bit-flags used in `Validate()` with a `Service`
+// Bit-flags used in `Validate()` with a `Service` or `LocalHost`
 // to specify which records should be checked in the announce
 // message.
 
@@ -566,6 +599,8 @@ static constexpr uint8_t kCheckSrv         = (1 << 0);
 static constexpr uint8_t kCheckTxt         = (1 << 1);
 static constexpr uint8_t kCheckPtr         = (1 << 2);
 static constexpr uint8_t kCheckServicesPtr = (1 << 3);
+static constexpr uint8_t kCheckAaaa        = (1 << 4);
+static constexpr uint8_t kCheckA           = (1 << 5);
 
 enum GoodBye : bool // Used to indicate "goodbye" records (with zero TTL)
 {
@@ -581,6 +616,16 @@ enum DnsMessageType : uint8_t
     kLegacyUnicastResponse,
 };
 
+struct LocalHost
+{
+    static constexpr uint32_t kTtl      = 120;
+    static constexpr uint16_t kMaxAddrs = 16;
+
+    char                           mName[Name::kMaxNameSize];
+    Array<Ip6::Address, kMaxAddrs> mIp6Addrs;
+    Array<Ip4::Address, kMaxAddrs> mIp4Addrs;
+};
+
 struct DnsMessage : public Allocatable<DnsMessage>, public LinkedListEntry<DnsMessage>
 {
     DnsMessage       *mNext;
@@ -743,6 +788,27 @@ struct DnsMessage : public Allocatable<DnsMessage>, public LinkedListEntry<DnsMe
         }
     }
 
+    void ValidateAsProbeFor(const LocalHost &aLocalHost, bool aUnicastResponse) const
+    {
+        DnsNameString fullName;
+
+        VerifyOrQuit(mHeader.GetType() == Header::kTypeQuery);
+        VerifyOrQuit(!mHeader.IsTruncationFlagSet());
+
+        fullName.Append("%s.local.", aLocalHost.mName);
+        VerifyOrQuit(mQuestions.Contains(fullName, aUnicastResponse));
+
+        for (const Ip6::Address &ip6Addr : aLocalHost.mIp6Addrs)
+        {
+            VerifyOrQuit(mAuthRecords.ContainsAaaa(fullName, ip6Addr, !kCacheFlush, kNonZeroTtl, LocalHost::kTtl));
+        }
+
+        for (const Ip4::Address &ip4Addr : aLocalHost.mIp4Addrs)
+        {
+            VerifyOrQuit(mAuthRecords.ContainsA(fullName, ip4Addr, !kCacheFlush, kNonZeroTtl, LocalHost::kTtl));
+        }
+    }
+
     void ValidateAsProbeFor(const Core::Service &aService, bool aUnicastResponse) const
     {
         DnsNameString serviceName;
@@ -776,8 +842,7 @@ struct DnsMessage : public Allocatable<DnsMessage>, public LinkedListEntry<DnsMe
     {
         DnsNameString fullName;
         TtlCheckMode  ttlCheck;
-
-        bool cacheFlushSet = (mType == kLegacyUnicastResponse) ? !kCacheFlush : kCacheFlush;
+        bool          cacheFlushSet = (mType == kLegacyUnicastResponse) ? !kCacheFlush : kCacheFlush;
 
         ttlCheck = DetermineTtlCheckMode(mType, aIsGoodBye);
 
@@ -797,6 +862,49 @@ struct DnsMessage : public Allocatable<DnsMessage>, public LinkedListEntry<DnsMe
         }
     }
 
+    void Validate(const LocalHost   &aLocalHost,
+                  Section            aSection,
+                  AnnounceCheckFlags aCheckFlags,
+                  GoodBye            aIsGoodBye = kNotGoodBye) const
+    {
+        DnsNameString fullName;
+        TtlCheckMode  ttlCheck;
+        bool          cacheFlushSet = (mType == kLegacyUnicastResponse) ? !kCacheFlush : kCacheFlush;
+
+        ttlCheck = DetermineTtlCheckMode(mType, aIsGoodBye);
+
+        VerifyOrQuit(mHeader.GetType() == Header::kTypeResponse);
+
+        fullName.Append("%s.local.", aLocalHost.mName);
+
+        if (aCheckFlags & kCheckAaaa)
+        {
+            for (const Ip6::Address &ip6Addr : aLocalHost.mIp6Addrs)
+            {
+                VerifyOrQuit(
+                    RecordsFor(aSection).ContainsAaaa(fullName, ip6Addr, cacheFlushSet, ttlCheck, LocalHost::kTtl));
+            }
+        }
+
+        if (aCheckFlags & kCheckA)
+        {
+            for (const Ip4::Address &ip4Addr : aLocalHost.mIp4Addrs)
+            {
+                VerifyOrQuit(
+                    RecordsFor(aSection).ContainsA(fullName, ip4Addr, cacheFlushSet, ttlCheck, LocalHost::kTtl));
+            }
+        }
+
+        if (!aIsGoodBye && (aSection == kInAnswerSection))
+        {
+            bool shouldSeeAaaa = (aLocalHost.mIp6Addrs.GetLength() != 0);
+            bool shouldSeeA    = (aLocalHost.mIp4Addrs.GetLength() != 0);
+
+            VerifyOrQuit(mAdditionalRecords.ContainsNsec(fullName, ResourceRecord::kTypeAaaa) == shouldSeeAaaa);
+            VerifyOrQuit(mAdditionalRecords.ContainsNsec(fullName, ResourceRecord::kTypeA) == shouldSeeA);
+        }
+    }
+
     void Validate(const Core::Service &aService,
                   Section              aSection,
                   AnnounceCheckFlags   aCheckFlags,
@@ -937,6 +1045,25 @@ struct DnsMessage : public Allocatable<DnsMessage>, public LinkedListEntry<DnsMe
 
         VerifyOrQuit(mQuestions.Contains(ResourceRecord::kTypeAaaa, fullName));
     }
+
+    void ValidateAsQueryFor(const Core::RecordQuerier &aQuerier) const
+    {
+        DnsNameString fullName;
+
+        VerifyOrQuit(mHeader.GetType() == Header::kTypeQuery);
+        VerifyOrQuit(!mHeader.IsTruncationFlagSet());
+
+        if (aQuerier.mNextLabels == nullptr)
+        {
+            fullName.Append("%s.local.", aQuerier.mFirstLabel);
+        }
+        else
+        {
+            fullName.Append("%s.%s.local.", aQuerier.mFirstLabel, aQuerier.mNextLabels);
+        }
+
+        VerifyOrQuit(mQuestions.Contains(aQuerier.mRecordType, fullName));
+    }
 };
 
 struct RegCallback
@@ -1355,6 +1482,61 @@ static void SendHostAddrResponse(const char *aHostName,
     otPlatMdnsHandleReceive(sInstance, message, /* aIsUnicast */ false, &senderAddrInfo);
 }
 
+struct RecordData
+{
+    uint16_t       mType;
+    const uint8_t *mData;
+    uint16_t       mLength;
+    uint32_t       mTtl;
+    bool           mCacheFlush;
+};
+
+static void SendRecordResponse(const char *aName, uint16_t aNumRecords, const RecordData *aRecords)
+{
+    Message          *message;
+    Header            header;
+    ResourceRecord    rr;
+    Core::AddressInfo senderAddrInfo;
+
+    message = sInstance->Get<MessagePool>().Allocate(Message::kTypeOther);
+    VerifyOrQuit(message != nullptr);
+
+    header.Clear();
+    header.SetType(Header::kTypeResponse);
+    header.SetAnswerCount(aNumRecords);
+
+    SuccessOrQuit(message->Append(header));
+
+    Log("Sending response with %u records", aNumRecords);
+
+    for (uint16_t index = 0; index < aNumRecords; index++)
+    {
+        const RecordData &record = aRecords[index];
+
+        SuccessOrQuit(Name::AppendName(aName, *message));
+
+        rr.Init(record.mType);
+
+        if (record.mCacheFlush)
+        {
+            rr.SetClass(rr.GetClass() | kClassCacheFlushFlag);
+        }
+
+        rr.SetTtl(record.mTtl);
+        rr.SetLength(record.mLength);
+        SuccessOrQuit(message->Append(rr));
+        SuccessOrQuit(message->AppendBytes(record.mData, record.mLength));
+
+        Log("  Record %u (cache-flush:%u) for %s", record.mType, record.mCacheFlush, aName);
+    }
+
+    SuccessOrQuit(AsCoreType(&senderAddrInfo.mAddress).FromString(kDeviceIp6Address));
+    senderAddrInfo.mPort         = kMdnsPort;
+    senderAddrInfo.mInfraIfIndex = 0;
+
+    otPlatMdnsHandleReceive(sInstance, message, /* aIsUnicast */ false, &senderAddrInfo);
+}
+
 static void SendResponseWithEmptyKey(const char *aName, Section aSection)
 {
     Message          *message;
@@ -1667,6 +1849,14 @@ Core *InitTest(void)
 
     VerifyOrQuit(sInstance != nullptr);
 
+#if OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE
+    // Disable the Border Agent to prevent its attempt to
+    // register the `_meshcop._udp` service from
+    // interfering with this test.
+
+    sInstance->Get<MeshCoP::BorderAgent>().SetEnabled(false);
+#endif
+
     return &sInstance->Get<Core>();
 }
 
@@ -1674,6 +1864,7 @@ Core *InitTest(void)
 
 static const uint8_t kKey1[]         = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77};
 static const uint8_t kKey2[]         = {0x12, 0x34, 0x56};
+static const uint8_t kKey3[]         = {0xaa, 0xbb, 0xcc, 0xdd};
 static const uint8_t kTxtData1[]     = {3, 'a', '=', '1', 0};
 static const uint8_t kTxtData2[]     = {1, 'b', 0};
 static const uint8_t kEmptyTxtData[] = {0};
@@ -1982,310 +2173,168 @@ void TestHostReg(void)
 
 //---------------------------------------------------------------------------------------------------------------------
 
-void TestKeyReg(void)
+void ValidateLocalHostAddresses(Core &aMdns, const LocalHost &aLocalHost)
 {
-    Core             *mdns = InitTest();
-    Core::Key         key;
-    const DnsMessage *dnsMsg;
-    uint16_t          heapAllocations;
-
-    Log("-------------------------------------------------------------------------------------------");
-    Log("TestKeyReg");
+#if OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
 
-    AdvanceTime(1);
+    Core::Iterator                           *iterator;
+    Array<Ip6::Address, LocalHost::kMaxAddrs> ip6Addrs;
+    Array<Ip4::Address, LocalHost::kMaxAddrs> ip4Addrs;
 
-    heapAllocations = sHeapAllocatedPtrs.GetLength();
-    SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
+    iterator = aMdns.AllocateIterator();
+    VerifyOrQuit(iterator != nullptr);
 
-    // Run all tests twice. first with key for a host name, followed
-    // by key for service instance name.
+    Log("Verifying local host addresses (%u IPv6 and %u IPv4 addresses)", aLocalHost.mIp6Addrs.GetLength(),
+        aLocalHost.mIp4Addrs.GetLength());
 
-    for (uint8_t iter = 0; iter < 2; iter++)
+    while (true)
     {
-        DnsNameString fullName;
+        Error                  error;
+        Core::LocalHostAddress addr;
 
-        if (iter == 0)
+        error = aMdns.GetNextLocalHostAddress(*iterator, addr);
+
+        if (error == kErrorNotFound)
         {
-            Log("= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =");
-            Log("Registering key for 'myhost' host name");
-            key.mName        = "myhost";
-            key.mServiceType = nullptr;
+            break;
+        }
 
-            fullName.Append("%s.local.", key.mName);
+        SuccessOrQuit(error);
+
+        VerifyOrQuit(addr.mInfraIfIndex == kInfraIfIndex);
+
+        if (addr.mIsIp6)
+        {
+            SuccessOrQuit(ip6Addrs.PushBack(AsCoreType(&addr.mAddress.mIp6)));
+            Log("   %s", ip6Addrs.Back()->ToString().AsCString());
         }
         else
         {
-            Log("= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =");
-            Log("Registering key for 'mysrv._srv._udo' service name");
-
-            key.mName        = "mysrv";
-            key.mServiceType = "_srv._udp";
-
-            fullName.Append("%s.%s.local.", key.mName, key.mServiceType);
+            SuccessOrQuit(ip4Addrs.PushBack(AsCoreType(&addr.mAddress.mIp4)));
+            Log("   %s", ip4Addrs.Back()->ToString().AsCString());
         }
+    }
 
-        key.mKeyData       = kKey1;
-        key.mKeyDataLength = sizeof(kKey1);
-        key.mTtl           = 8000;
+    aMdns.FreeIterator(*iterator);
 
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Register a key record and check probes and announcements");
+    VerifyOrQuit(ip6Addrs.GetLength() == aLocalHost.mIp6Addrs.GetLength());
 
-        sDnsMessages.Clear();
+    for (const Ip6::Address &ip6Addr : ip6Addrs)
+    {
+        VerifyOrQuit(aLocalHost.mIp6Addrs.Contains(ip6Addr));
+    }
 
-        sRegCallbacks[0].Reset();
-        SuccessOrQuit(mdns->RegisterKey(key, 0, HandleSuccessCallback));
+    VerifyOrQuit(ip4Addrs.GetLength() == aLocalHost.mIp4Addrs.GetLength());
 
-        for (uint8_t probeCount = 0; probeCount < 3; probeCount++)
-        {
-            sDnsMessages.Clear();
+    for (const Ip4::Address &ip4Addr : ip4Addrs)
+    {
+        VerifyOrQuit(aLocalHost.mIp4Addrs.Contains(ip4Addr));
+    }
+#else
+    OT_UNUSED_VARIABLE(aMdns);
+    OT_UNUSED_VARIABLE(aLocalHost);
+#endif
+}
 
-            VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
-            AdvanceTime(250);
+void TestLocalHost(void)
+{
+    Core             *mdns = InitTest();
+    LocalHost         localHost;
+    Ip6::Address      ip6Address;
+    Ip4::Address      ip4Address;
+    const DnsMessage *dnsMsg;
+    uint16_t          heapAllocations;
+    DnsNameString     hostFullName;
 
-            VerifyOrQuit(!sDnsMessages.IsEmpty());
-            dnsMsg = sDnsMessages.GetHead();
-            dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 1, /* Addnl */ 0);
-            dnsMsg->ValidateAsProbeFor(key, /* aUnicastRequest */ (probeCount == 0));
-            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-        }
+    Log("-------------------------------------------------------------------------------------------");
+    Log("TestLocalHost");
 
-        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-        {
-            sDnsMessages.Clear();
+    AdvanceTime(1);
 
-            AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
-            VerifyOrQuit(sRegCallbacks[0].mWasCalled);
+    heapAllocations = sHeapAllocatedPtrs.GetLength();
 
-            VerifyOrQuit(!sDnsMessages.IsEmpty());
-            dnsMsg = sDnsMessages.GetHead();
-            dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
-            dnsMsg->Validate(key, kInAnswerSection);
-            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-        }
+    SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
 
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Send a query for KEY record and validate the response");
+    SuccessOrQuit(StringCopy(localHost.mName, mdns->GetLocalHostName()));
+    Log("Local host name is \"%s\"", localHost.mName);
 
-        AdvanceTime(2000);
+    hostFullName.Append("%s.local.", localHost.mName);
 
-        sDnsMessages.Clear();
-        SendQuery(fullName.AsCString(), ResourceRecord::kTypeKey);
+    ValidateLocalHostAddresses(*mdns, localHost);
 
-        AdvanceTime(1000);
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Add an IP6 address and IP4 address for local host, check probes and announcements");
 
-        dnsMsg = sDnsMessages.GetHead();
-        VerifyOrQuit(dnsMsg != nullptr);
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
-        dnsMsg->Validate(key, kInAnswerSection);
+    SuccessOrQuit(ip6Address.FromString("fd00:cafe::1"));
+    SuccessOrQuit(localHost.mIp6Addrs.PushBack(ip6Address));
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
 
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Send a query for ANY record and validate the response");
+    SuccessOrQuit(ip4Address.FromString("200.1.5.6"));
+    SuccessOrQuit(localHost.mIp4Addrs.PushBack(ip4Address));
+    ip6Address.SetToIp4Mapped(ip4Address);
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
 
-        AdvanceTime(2000);
+    AdvanceTime(4);
+
+    sDnsMessages.Clear();
 
+    for (uint8_t probeCount = 0; probeCount < 3; probeCount++)
+    {
         sDnsMessages.Clear();
-        SendQuery(fullName.AsCString(), ResourceRecord::kTypeAny);
 
-        AdvanceTime(1000);
+        AdvanceTime(250);
 
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-        VerifyOrQuit(dnsMsg != nullptr);
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
-        dnsMsg->Validate(key, kInAnswerSection);
-
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Send a query for non-existing record and validate the response with NSEC");
-
-        AdvanceTime(2000);
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
+        dnsMsg->ValidateAsProbeFor(localHost, /* aUnicastRequest */ (probeCount == 0));
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    }
 
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
         sDnsMessages.Clear();
-        SendQuery(fullName.AsCString(), ResourceRecord::kTypeA);
 
-        AdvanceTime(1000);
+        AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
 
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-        VerifyOrQuit(dnsMsg != nullptr);
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 1);
-        VerifyOrQuit(dnsMsg->mAdditionalRecords.ContainsNsec(fullName, ResourceRecord::kTypeKey));
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(localHost, kInAnswerSection, kCheckAaaa | kCheckA);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    }
 
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Change the TTL");
+    ValidateLocalHostAddresses(*mdns, localHost);
 
-        key.mTtl = 0; // Use default
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a query for AAAA record and validate the response");
 
-        sRegCallbacks[1].Reset();
-        sDnsMessages.Clear();
-        SuccessOrQuit(mdns->RegisterKey(key, 1, HandleSuccessCallback));
-
-        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-        {
-            AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
-            VerifyOrQuit(sRegCallbacks[1].mWasCalled);
-
-            VerifyOrQuit(!sDnsMessages.IsEmpty());
-            dnsMsg = sDnsMessages.GetHead();
-            dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
-            dnsMsg->Validate(key, kInAnswerSection);
-            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-
-            sDnsMessages.Clear();
-        }
-
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Change the key");
-
-        key.mKeyData       = kKey2;
-        key.mKeyDataLength = sizeof(kKey2);
-
-        sRegCallbacks[1].Reset();
-        sDnsMessages.Clear();
-        SuccessOrQuit(mdns->RegisterKey(key, 1, HandleSuccessCallback));
-
-        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-        {
-            AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
-            VerifyOrQuit(sRegCallbacks[1].mWasCalled);
-
-            VerifyOrQuit(!sDnsMessages.IsEmpty());
-            dnsMsg = sDnsMessages.GetHead();
-            dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
-            dnsMsg->Validate(key, kInAnswerSection);
-            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-
-            sDnsMessages.Clear();
-        }
-
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Unregister the key and validate the goodbye announces");
-
-        sDnsMessages.Clear();
-        SuccessOrQuit(mdns->UnregisterKey(key));
-
-        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-        {
-            AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
-
-            VerifyOrQuit(!sDnsMessages.IsEmpty());
-            dnsMsg = sDnsMessages.GetHead();
-            dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 0);
-            dnsMsg->Validate(key, kInAnswerSection, kGoodBye);
-            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-
-            sDnsMessages.Clear();
-        }
-    }
-
-    AdvanceTime(15000);
-    VerifyOrQuit(sDnsMessages.IsEmpty());
-
-    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
-    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
-
-    Log("End of test");
-
-    testFreeInstance(sInstance);
-}
-
-//---------------------------------------------------------------------------------------------------------------------
-
-void TestServiceReg(void)
-{
-    Core             *mdns = InitTest();
-    Core::Service     service;
-    const DnsMessage *dnsMsg;
-    uint16_t          heapAllocations;
-    DnsNameString     fullServiceName;
-    DnsNameString     fullServiceType;
-
-    Log("-------------------------------------------------------------------------------------------");
-    Log("TestServiceReg");
-
-    AdvanceTime(1);
-
-    heapAllocations = sHeapAllocatedPtrs.GetLength();
-    SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
-
-    service.mHostName            = "myhost";
-    service.mServiceInstance     = "myservice";
-    service.mServiceType         = "_srv._udp";
-    service.mSubTypeLabels       = nullptr;
-    service.mSubTypeLabelsLength = 0;
-    service.mTxtData             = kTxtData1;
-    service.mTxtDataLength       = sizeof(kTxtData1);
-    service.mPort                = 1234;
-    service.mPriority            = 1;
-    service.mWeight              = 2;
-    service.mTtl                 = 1000;
-
-    fullServiceName.Append("%s.%s.local.", service.mServiceInstance, service.mServiceType);
-    fullServiceType.Append("%s.local.", service.mServiceType);
-
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Register a `ServiceEntry`, check probes and announcements");
-
-    sDnsMessages.Clear();
-
-    sRegCallbacks[0].Reset();
-    SuccessOrQuit(mdns->RegisterService(service, 0, HandleSuccessCallback));
-
-    for (uint8_t probeCount = 0; probeCount < 3; probeCount++)
-    {
-        sDnsMessages.Clear();
-
-        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
-        AdvanceTime(250);
-
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
-        dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
-        dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ (probeCount == 0));
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-    }
-
-    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-    {
-        sDnsMessages.Clear();
-
-        AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
-        VerifyOrQuit(sRegCallbacks[0].mWasCalled);
-
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
-        dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 1);
-        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr | kCheckServicesPtr);
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-    }
-
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a query for SRV record and validate the response");
-
-    AdvanceTime(2000);
+    AdvanceTime(2000);
 
     sDnsMessages.Clear();
-    SendQuery(fullServiceName.AsCString(), ResourceRecord::kTypeSrv);
+    SendQuery(hostFullName.AsCString(), ResourceRecord::kTypeAaaa);
 
     AdvanceTime(1000);
 
     dnsMsg = sDnsMessages.GetHead();
     VerifyOrQuit(dnsMsg != nullptr);
     dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
-    dnsMsg->Validate(service, kInAnswerSection, kCheckSrv);
+    dnsMsg->Validate(localHost, kInAnswerSection, kCheckAaaa);
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a query for TXT record and validate the response");
+    Log("Send a query for A record and validate the response");
 
     AdvanceTime(2000);
 
     sDnsMessages.Clear();
-    SendQuery(fullServiceName.AsCString(), ResourceRecord::kTypeTxt);
+    SendQuery(hostFullName.AsCString(), ResourceRecord::kTypeA);
 
     AdvanceTime(1000);
 
     dnsMsg = sDnsMessages.GetHead();
     VerifyOrQuit(dnsMsg != nullptr);
     dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
-    dnsMsg->Validate(service, kInAnswerSection, kCheckTxt);
+    dnsMsg->Validate(localHost, kInAnswerSection, kCheckA);
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Send a query for ANY record and validate the response");
@@ -2293,380 +2342,365 @@ void TestServiceReg(void)
     AdvanceTime(2000);
 
     sDnsMessages.Clear();
-    SendQuery(fullServiceName.AsCString(), ResourceRecord::kTypeAny);
+    SendQuery(hostFullName.AsCString(), ResourceRecord::kTypeAny);
 
     AdvanceTime(1000);
 
     dnsMsg = sDnsMessages.GetHead();
     VerifyOrQuit(dnsMsg != nullptr);
     dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 1);
-    dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt);
+    dnsMsg->Validate(localHost, kInAnswerSection, kCheckAaaa | kCheckA);
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a query for PTR record for service type and validate the response");
+    Log("Send a query for non-existing record and validate the response with NSEC");
 
     AdvanceTime(2000);
 
     sDnsMessages.Clear();
-    SendQuery(fullServiceType.AsCString(), ResourceRecord::kTypePtr);
+    SendQuery(hostFullName.AsCString(), ResourceRecord::kTypeKey);
 
     AdvanceTime(1000);
 
     dnsMsg = sDnsMessages.GetHead();
     VerifyOrQuit(dnsMsg != nullptr);
-    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 2);
-    dnsMsg->Validate(service, kInAnswerSection, kCheckPtr);
-    dnsMsg->Validate(service, kInAdditionalSection, kCheckSrv | kCheckTxt);
+    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 1);
+    VerifyOrQuit(dnsMsg->mAdditionalRecords.ContainsNsec(hostFullName, ResourceRecord::kTypeAaaa));
+    VerifyOrQuit(dnsMsg->mAdditionalRecords.ContainsNsec(hostFullName, ResourceRecord::kTypeA));
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a query for PTR record for `services._dns-sd` and validate the response");
+    Log("Signal a new host IPv6 address is added and validate new announcements");
 
-    AdvanceTime(2000);
+    SuccessOrQuit(ip6Address.FromString("fd00:cafe::22"));
+    SuccessOrQuit(localHost.mIp6Addrs.PushBack(ip6Address));
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
 
     sDnsMessages.Clear();
-    SendQuery("_services._dns-sd._udp.local.", ResourceRecord::kTypePtr);
-
-    AdvanceTime(1000);
-
-    dnsMsg = sDnsMessages.GetHead();
-    VerifyOrQuit(dnsMsg != nullptr);
-    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 0);
-    dnsMsg->Validate(service, kInAnswerSection, kCheckServicesPtr);
-
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Update service port number and validate new announcements of SRV record");
 
-    service.mPort = 4567;
-
-    sRegCallbacks[1].Reset();
-    sDnsMessages.Clear();
-    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
+    AdvanceTime(5);
 
     for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
     {
         AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
-        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
 
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
-        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv);
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(localHost, kInAnswerSection, kCheckAaaa);
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
         sDnsMessages.Clear();
     }
 
+    ValidateLocalHostAddresses(*mdns, localHost);
+
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Update TXT data and validate new announcements of TXT record");
+    Log("Signal new host IPv6 addresses added and removed");
 
-    service.mTxtData       = nullptr;
-    service.mTxtDataLength = 0;
+    SuccessOrQuit(ip6Address.FromString("fd00:cafe::22"));
+    localHost.mIp6Addrs.Remove(ip6Address);
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ false, kInfraIfIndex);
+
+    // Add then remove the same address quickly
+    // It should not be included in the announcements.
+
+    SuccessOrQuit(ip6Address.FromString("fd00:cafe::333"));
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
+    AdvanceTime(1);
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ false, kInfraIfIndex);
+
+    SuccessOrQuit(ip6Address.FromString("fd00:cafe::4444"));
+    SuccessOrQuit(localHost.mIp6Addrs.PushBack(ip6Address));
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
+
+    Log("Validate the announcements");
 
-    sRegCallbacks[1].Reset();
     sDnsMessages.Clear();
-    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
+
+    AdvanceTime(4);
 
     for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
     {
         AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
-        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
 
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
-        dnsMsg->Validate(service, kInAnswerSection, kCheckTxt);
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(localHost, kInAnswerSection, kCheckAaaa);
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
         sDnsMessages.Clear();
     }
 
+    ValidateLocalHostAddresses(*mdns, localHost);
+
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Update both service and TXT data and validate new announcements of both records");
+    Log("Signal three new host IPv4 addresses added");
 
-    service.mTxtData       = kTxtData2;
-    service.mTxtDataLength = sizeof(kTxtData2);
-    service.mWeight        = 0;
+    SuccessOrQuit(ip4Address.FromString("200.1.5.7"));
+    SuccessOrQuit(localHost.mIp4Addrs.PushBack(ip4Address));
+    ip6Address.SetToIp4Mapped(ip4Address);
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
+
+    SuccessOrQuit(ip4Address.FromString("200.1.2.100"));
+    SuccessOrQuit(localHost.mIp4Addrs.PushBack(ip4Address));
+    ip6Address.SetToIp4Mapped(ip4Address);
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
+
+    SuccessOrQuit(ip4Address.FromString("200.1.4.0"));
+    SuccessOrQuit(localHost.mIp4Addrs.PushBack(ip4Address));
+    ip6Address.SetToIp4Mapped(ip4Address);
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
+
+    Log("Validate the announcements");
 
-    sRegCallbacks[1].Reset();
     sDnsMessages.Clear();
-    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
+
+    AdvanceTime(5);
 
     for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
     {
         AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
-        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
 
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 1);
-        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt);
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(localHost, kInAnswerSection, kCheckA);
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
         sDnsMessages.Clear();
     }
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Update service host name and validate new announcements of SRV record");
+    ValidateLocalHostAddresses(*mdns, localHost);
 
-    service.mHostName = "newhost";
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Signal removal of all host addresses and add them all back");
 
-    sRegCallbacks[1].Reset();
-    sDnsMessages.Clear();
-    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
+    otPlatMdnsHandleHostAddressRemoveAll(sInstance, kInfraIfIndex);
 
-    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    for (Ip6::Address &ip6Addr : localHost.mIp6Addrs)
     {
-        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
-        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
+        otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Addr, /* aAdded */ true, kInfraIfIndex);
+    }
 
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
-        dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
-        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv);
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-        sDnsMessages.Clear();
+    for (Ip4::Address &ip4Addr : localHost.mIp4Addrs)
+    {
+        ip6Address.SetToIp4Mapped(ip4Addr);
+        otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
     }
 
+    Log("Validate that there are no announcements");
+
+    sDnsMessages.Clear();
+
+    AdvanceTime(10 * 1000);
+    VerifyOrQuit(sDnsMessages.IsEmpty());
+
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Update TTL and validate new announcements of SRV, TXT and PTR records");
+    Log("Signal removal of all addr, add them all back with one extra IPv6 and one extra IPv4 addr");
 
-    service.mTtl = 0;
+    otPlatMdnsHandleHostAddressRemoveAll(sInstance, kInfraIfIndex);
+
+    SuccessOrQuit(ip6Address.FromString("fd00:cafe::5555"));
+    SuccessOrQuit(localHost.mIp6Addrs.PushBack(ip6Address));
+
+    for (Ip6::Address &ip6Addr : localHost.mIp6Addrs)
+    {
+        otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Addr, /* aAdded */ true, kInfraIfIndex);
+    }
+
+    SuccessOrQuit(ip4Address.FromString("200.0.64.13"));
+    SuccessOrQuit(localHost.mIp4Addrs.PushBack(ip4Address));
+
+    for (Ip4::Address &ip4Addr : localHost.mIp4Addrs)
+    {
+        ip6Address.SetToIp4Mapped(ip4Addr);
+        otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
+    }
+
+    Log("Validate the announcements");
 
-    sRegCallbacks[1].Reset();
     sDnsMessages.Clear();
-    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
+
+    AdvanceTime(5);
 
     for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
     {
         AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
-        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
 
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 3, /* Auth */ 0, /* Addnl */ 1);
-        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr);
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 8, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(localHost, kInAnswerSection, kCheckAaaa | kCheckA);
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
         sDnsMessages.Clear();
     }
 
+    AdvanceTime(10 * 1000);
+
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Unregister the service and validate the goodbye announces");
+    Log("Signal removal of all addresses and add some back");
 
-    sDnsMessages.Clear();
-    SuccessOrQuit(mdns->UnregisterService(service));
+    otPlatMdnsHandleHostAddressRemoveAll(sInstance, kInfraIfIndex);
 
-    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    for (Ip6::Address &ip6Addr : localHost.mIp6Addrs)
     {
-        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
-
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
-        dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 3, /* Auth */ 0, /* Addnl */ 0);
-        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr, kGoodBye);
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-        sDnsMessages.Clear();
+        otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Addr, /* aAdded */ true, kInfraIfIndex);
     }
 
-    AdvanceTime(15000);
-    VerifyOrQuit(sDnsMessages.IsEmpty());
+    Log("Before previous events are processed, signal removal of all addresses again");
+    Log("And add them all back without the recently added extra IPv6 and IPv4 addresses");
 
-    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
-    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
+    AdvanceTime(1);
 
-    Log("End of test");
+    otPlatMdnsHandleHostAddressRemoveAll(sInstance, kInfraIfIndex);
+    otPlatMdnsHandleHostAddressRemoveAll(sInstance, kInfraIfIndex);
 
-    testFreeInstance(sInstance);
-}
+    localHost.mIp6Addrs.PopBack();
+    localHost.mIp4Addrs.PopBack();
 
-//---------------------------------------------------------------------------------------------------------------------
+    for (Ip6::Address &ip6Addr : localHost.mIp6Addrs)
+    {
+        otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Addr, /* aAdded */ true, kInfraIfIndex);
+    }
 
-void TestUnregisterBeforeProbeFinished(void)
-{
-    const uint8_t kKey1[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77};
+    for (Ip4::Address &ip4Addr : localHost.mIp4Addrs)
+    {
+        ip6Address.SetToIp4Mapped(ip4Addr);
+        otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
+    }
 
-    Core             *mdns = InitTest();
-    Core::Host        host;
-    Core::Service     service;
-    Core::Key         key;
-    Ip6::Address      hostAddresses[3];
-    const DnsMessage *dnsMsg;
-    uint16_t          heapAllocations;
+    Log("Validate the announcements");
 
-    Log("-------------------------------------------------------------------------------------------");
-    Log("TestUnregisterBeforeProbeFinished");
+    sDnsMessages.Clear();
 
-    AdvanceTime(1);
+    AdvanceTime(5);
 
-    heapAllocations = sHeapAllocatedPtrs.GetLength();
-    SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
 
-    SuccessOrQuit(hostAddresses[0].FromString("fd00::aaaa"));
-    SuccessOrQuit(hostAddresses[1].FromString("fd00::bbbb"));
-    SuccessOrQuit(hostAddresses[2].FromString("fd00::cccc"));
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 6, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(localHost, kInAnswerSection, kCheckAaaa | kCheckA);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        sDnsMessages.Clear();
+    }
 
-    host.mHostName        = "myhost";
-    host.mAddresses       = hostAddresses;
-    host.mAddressesLength = 3;
-    host.mTtl             = 1500;
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Signal all host IPv4 addresses are removed, validate goodbye announcements");
 
-    service.mHostName            = "myhost";
-    service.mServiceInstance     = "myservice";
-    service.mServiceType         = "_srv._udp";
-    service.mSubTypeLabels       = nullptr;
-    service.mSubTypeLabelsLength = 0;
-    service.mTxtData             = kTxtData1;
-    service.mTxtDataLength       = sizeof(kTxtData1);
-    service.mPort                = 1234;
-    service.mPriority            = 1;
-    service.mWeight              = 2;
-    service.mTtl                 = 1000;
+    for (const Ip4::Address &ip4Addr : localHost.mIp4Addrs)
+    {
+        ip6Address.SetToIp4Mapped(ip4Addr);
+        otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ false, kInfraIfIndex);
+    }
 
-    key.mName          = "mysrv";
-    key.mServiceType   = "_srv._udp";
-    key.mKeyData       = kKey1;
-    key.mKeyDataLength = sizeof(kKey1);
-    key.mTtl           = 8000;
+    localHost.mIp4Addrs.Clear();
 
-    // Repeat the same test 3 times for host and service and key registration.
+    sDnsMessages.Clear();
 
-    for (uint8_t iter = 0; iter < 3; iter++)
+    AdvanceTime(5);
+
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
     {
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Register an entry, check for the first two probes");
+        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
 
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(localHost, kInAnswerSection, kCheckA, kGoodBye);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
         sDnsMessages.Clear();
+    }
 
-        sRegCallbacks[0].Reset();
+    AdvanceTime(10 * 1000);
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
-        switch (iter)
-        {
-        case 0:
-            SuccessOrQuit(mdns->RegisterHost(host, 0, HandleSuccessCallback));
-            break;
-        case 1:
-            SuccessOrQuit(mdns->RegisterService(service, 0, HandleSuccessCallback));
-            break;
-        case 2:
-            SuccessOrQuit(mdns->RegisterKey(key, 0, HandleSuccessCallback));
-            break;
-        }
+    ValidateLocalHostAddresses(*mdns, localHost);
 
-        for (uint8_t probeCount = 0; probeCount < 2; probeCount++)
-        {
-            sDnsMessages.Clear();
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Signal removal of an IPv6 host address which was not added earlier");
 
-            VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
-            AdvanceTime(250);
+    SuccessOrQuit(ip6Address.FromString("fd00:cafe::beef"));
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ false, kInfraIfIndex);
 
-            VerifyOrQuit(!sDnsMessages.IsEmpty());
-            dnsMsg = sDnsMessages.GetHead();
+    Log("Validate that there are no announcements");
 
-            switch (iter)
-            {
-            case 0:
-                dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 3, /* Addnl */ 0);
-                dnsMsg->ValidateAsProbeFor(host, /* aUnicastRequest */ (probeCount == 0));
-                break;
-            case 1:
-                dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
-                dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ (probeCount == 0));
-                break;
-            case 2:
-                dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 1, /* Addnl */ 0);
-                dnsMsg->ValidateAsProbeFor(key, /* aUnicastRequest */ (probeCount == 0));
-                break;
-            }
+    sDnsMessages.Clear();
 
-            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-        }
+    AdvanceTime(10 * 1000);
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
-        sDnsMessages.Clear();
-        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+    ValidateLocalHostAddresses(*mdns, localHost);
 
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Unregister the entry before the last probe and make sure probing stops");
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Signal remove and re-add of the same host IPv6 address quickly");
 
-        switch (iter)
-        {
-        case 0:
-            SuccessOrQuit(mdns->UnregisterHost(host));
-            break;
-        case 1:
-            SuccessOrQuit(mdns->UnregisterService(service));
-            break;
-        case 2:
-            SuccessOrQuit(mdns->UnregisterKey(key));
-            break;
-        }
+    ip6Address = localHost.mIp6Addrs[0];
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ false, kInfraIfIndex);
+    AdvanceTime(1);
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
 
-        AdvanceTime(20 * 1000);
-        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+    Log("Validate that there are no announcements");
 
-        VerifyOrQuit(sDnsMessages.IsEmpty());
-    }
+    sDnsMessages.Clear();
 
-    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
-    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
+    AdvanceTime(10 * 1000);
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
-    Log("End of test");
+    ValidateLocalHostAddresses(*mdns, localHost);
 
-    testFreeInstance(sInstance);
-}
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Validate `SetLocalHostName()`");
 
-//---------------------------------------------------------------------------------------------------------------------
+    VerifyOrQuit(mdns->SetLocalHostName("itsme") == kErrorInvalidState);
 
-void TestServiceSubTypeReg(void)
-{
-    static const char *const kSubTypes1[] = {"_s1", "_r2", "_vXy", "_last"};
-    static const char *const kSubTypes2[] = {"_vxy", "_r1", "_r2", "_zzz"};
+    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
 
-    Core             *mdns = InitTest();
-    Core::Service     service;
-    const DnsMessage *dnsMsg;
-    uint16_t          heapAllocations;
-    DnsNameString     fullServiceName;
-    DnsNameString     fullServiceType;
-    DnsNameString     fullSubServiceType;
+    SuccessOrQuit(mdns->SetLocalHostName("itsme"));
+    VerifyOrQuit(StringMatch(mdns->GetLocalHostName(), "itsme"));
 
-    Log("-------------------------------------------------------------------------------------------");
-    Log("TestServiceSubTypeReg");
+    localHost.mIp4Addrs.Clear();
+    localHost.mIp6Addrs.Clear();
 
-    AdvanceTime(1);
+    SuccessOrQuit(StringCopy(localHost.mName, mdns->GetLocalHostName()));
+    Log("Local host name is \"%s\"", localHost.mName);
+
+    hostFullName.Append("%s.local.", localHost.mName);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Re-enable mDNS module, add 4 new host IPv6 address and validate probe and announcements");
 
-    heapAllocations = sHeapAllocatedPtrs.GetLength();
     SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
 
-    service.mHostName            = "tarnished";
-    service.mServiceInstance     = "elden";
-    service.mServiceType         = "_ring._udp";
-    service.mSubTypeLabels       = kSubTypes1;
-    service.mSubTypeLabelsLength = 3;
-    service.mTxtData             = kTxtData1;
-    service.mTxtDataLength       = sizeof(kTxtData1);
-    service.mPort                = 1234;
-    service.mPriority            = 1;
-    service.mWeight              = 2;
-    service.mTtl                 = 6000;
+    SuccessOrQuit(ip6Address.FromString("fd00:beef::a"));
+    SuccessOrQuit(localHost.mIp6Addrs.PushBack(ip6Address));
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
 
-    fullServiceName.Append("%s.%s.local.", service.mServiceInstance, service.mServiceType);
-    fullServiceType.Append("%s.local.", service.mServiceType);
+    SuccessOrQuit(ip6Address.FromString("fd00:beef::b"));
+    SuccessOrQuit(localHost.mIp6Addrs.PushBack(ip6Address));
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Register a `ServiceEntry` with sub-types, check probes and announcements");
+    SuccessOrQuit(ip6Address.FromString("fd00:beef::c"));
+    SuccessOrQuit(localHost.mIp6Addrs.PushBack(ip6Address));
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
 
-    sDnsMessages.Clear();
+    SuccessOrQuit(ip6Address.FromString("fd00:beef::d"));
+    SuccessOrQuit(localHost.mIp6Addrs.PushBack(ip6Address));
+    otPlatMdnsHandleHostAddressEvent(sInstance, &ip6Address, /* aAdded */ true, kInfraIfIndex);
 
-    sRegCallbacks[0].Reset();
-    SuccessOrQuit(mdns->RegisterService(service, 0, HandleSuccessCallback));
+    AdvanceTime(4);
+
+    sDnsMessages.Clear();
 
     for (uint8_t probeCount = 0; probeCount < 3; probeCount++)
     {
         sDnsMessages.Clear();
 
-        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
         AdvanceTime(250);
 
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
-        dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ (probeCount == 0));
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 4, /* Addnl */ 0);
+        dnsMsg->ValidateAsProbeFor(localHost, /* aUnicastRequest */ (probeCount == 0));
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
     }
 
@@ -2675,306 +2709,254 @@ void TestServiceSubTypeReg(void)
         sDnsMessages.Clear();
 
         AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
-        VerifyOrQuit(sRegCallbacks[0].mWasCalled);
 
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 7, /* Auth */ 0, /* Addnl */ 1);
-        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr | kCheckServicesPtr);
-
-        for (uint16_t index = 0; index < service.mSubTypeLabelsLength; index++)
-        {
-            dnsMsg->ValidateSubType(service.mSubTypeLabels[index], service);
-        }
-
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(localHost, kInAnswerSection, kCheckAaaa | kCheckA);
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
     }
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a query for SRV record and validate the response");
-
-    AdvanceTime(2000);
-
-    sDnsMessages.Clear();
-    SendQuery(fullServiceName.AsCString(), ResourceRecord::kTypeSrv);
+    ValidateLocalHostAddresses(*mdns, localHost);
 
     AdvanceTime(1000);
 
-    dnsMsg = sDnsMessages.GetHead();
-    VerifyOrQuit(dnsMsg != nullptr);
-    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
-    dnsMsg->Validate(service, kInAnswerSection, kCheckSrv);
-
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a query for TXT record and validate the response");
 
-    AdvanceTime(2000);
+    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
+    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
 
-    sDnsMessages.Clear();
-    SendQuery(fullServiceName.AsCString(), ResourceRecord::kTypeTxt);
+    Log("End of test");
 
-    AdvanceTime(1000);
+    testFreeInstance(sInstance);
+}
 
-    dnsMsg = sDnsMessages.GetHead();
-    VerifyOrQuit(dnsMsg != nullptr);
-    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
-    dnsMsg->Validate(service, kInAnswerSection, kCheckTxt);
+//---------------------------------------------------------------------------------------------------------------------
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a query for ANY record and validate the response");
+void TestKeyReg(void)
+{
+    Core             *mdns = InitTest();
+    Core::Key         key;
+    const DnsMessage *dnsMsg;
+    uint16_t          heapAllocations;
 
-    AdvanceTime(2000);
+    Log("-------------------------------------------------------------------------------------------");
+    Log("TestKeyReg");
 
-    sDnsMessages.Clear();
-    SendQuery(fullServiceName.AsCString(), ResourceRecord::kTypeAny);
+    AdvanceTime(1);
 
-    AdvanceTime(1000);
+    heapAllocations = sHeapAllocatedPtrs.GetLength();
+    SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
 
-    dnsMsg = sDnsMessages.GetHead();
-    VerifyOrQuit(dnsMsg != nullptr);
-    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 1);
-    dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt);
+    // Run all tests twice. first with key for a host name, followed
+    // by key for service instance name.
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a query for PTR record for service type and validate the response");
+    for (uint8_t iter = 0; iter < 2; iter++)
+    {
+        DnsNameString fullName;
 
-    AdvanceTime(2000);
+        if (iter == 0)
+        {
+            Log("= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =");
+            Log("Registering key for 'myhost' host name");
+            key.mName        = "myhost";
+            key.mServiceType = nullptr;
 
-    sDnsMessages.Clear();
-    SendQuery(fullServiceType.AsCString(), ResourceRecord::kTypePtr);
+            fullName.Append("%s.local.", key.mName);
+        }
+        else
+        {
+            Log("= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =");
+            Log("Registering key for 'mysrv._srv._udo' service name");
 
-    AdvanceTime(1000);
+            key.mName        = "mysrv";
+            key.mServiceType = "_srv._udp";
 
-    dnsMsg = sDnsMessages.GetHead();
-    VerifyOrQuit(dnsMsg != nullptr);
-    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 2);
-    dnsMsg->Validate(service, kInAnswerSection, kCheckPtr);
-    dnsMsg->Validate(service, kInAdditionalSection, kCheckSrv | kCheckTxt);
+            fullName.Append("%s.%s.local.", key.mName, key.mServiceType);
+        }
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a query for PTR record for `services._dns-sd` and validate the response");
+        key.mKeyData       = kKey1;
+        key.mKeyDataLength = sizeof(kKey1);
+        key.mTtl           = 8000;
 
-    AdvanceTime(2000);
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Register a key record and check probes and announcements");
 
-    sDnsMessages.Clear();
-    SendQuery("_services._dns-sd._udp.local.", ResourceRecord::kTypePtr);
+        sDnsMessages.Clear();
 
-    AdvanceTime(1000);
+        sRegCallbacks[0].Reset();
+        SuccessOrQuit(mdns->RegisterKey(key, 0, HandleSuccessCallback));
 
-    dnsMsg = sDnsMessages.GetHead();
-    VerifyOrQuit(dnsMsg != nullptr);
-    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 0);
-    dnsMsg->Validate(service, kInAnswerSection, kCheckServicesPtr);
+        for (uint8_t probeCount = 0; probeCount < 3; probeCount++)
+        {
+            sDnsMessages.Clear();
 
-    for (uint16_t index = 0; index < service.mSubTypeLabelsLength; index++)
-    {
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Send a PTR query for sub-type `%s` and validate the response", service.mSubTypeLabels[index]);
+            VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+            AdvanceTime(250);
 
-        fullSubServiceType.Clear();
-        fullSubServiceType.Append("%s._sub.%s", service.mSubTypeLabels[index], fullServiceType.AsCString());
+            VerifyOrQuit(!sDnsMessages.IsEmpty());
+            dnsMsg = sDnsMessages.GetHead();
+            dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 1, /* Addnl */ 0);
+            dnsMsg->ValidateAsProbeFor(key, /* aUnicastRequest */ (probeCount == 0));
+            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        }
+
+        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+        {
+            sDnsMessages.Clear();
+
+            AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
+            VerifyOrQuit(sRegCallbacks[0].mWasCalled);
+
+            VerifyOrQuit(!sDnsMessages.IsEmpty());
+            dnsMsg = sDnsMessages.GetHead();
+            dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+            dnsMsg->Validate(key, kInAnswerSection);
+            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        }
+
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Send a query for KEY record and validate the response");
 
         AdvanceTime(2000);
 
         sDnsMessages.Clear();
-        SendQuery(fullSubServiceType.AsCString(), ResourceRecord::kTypePtr);
+        SendQuery(fullName.AsCString(), ResourceRecord::kTypeKey);
 
         AdvanceTime(1000);
 
         dnsMsg = sDnsMessages.GetHead();
         VerifyOrQuit(dnsMsg != nullptr);
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 2);
-        dnsMsg->ValidateSubType(service.mSubTypeLabels[index], service);
-        dnsMsg->Validate(service, kInAdditionalSection, kCheckSrv | kCheckTxt);
-    }
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(key, kInAnswerSection);
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a PTR query for non-existing sub-type and validate there is no response");
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Send a query for ANY record and validate the response");
 
-    AdvanceTime(2000);
+        AdvanceTime(2000);
 
-    fullSubServiceType.Clear();
-    fullSubServiceType.Append("_none._sub.%s", fullServiceType.AsCString());
+        sDnsMessages.Clear();
+        SendQuery(fullName.AsCString(), ResourceRecord::kTypeAny);
 
-    sDnsMessages.Clear();
-    SendQuery(fullSubServiceType.AsCString(), ResourceRecord::kTypePtr);
+        AdvanceTime(1000);
 
-    AdvanceTime(2000);
-    VerifyOrQuit(sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        VerifyOrQuit(dnsMsg != nullptr);
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(key, kInAnswerSection);
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Register a new sub-type and validate announcements of PTR record for it");
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Send a query for non-existing record and validate the response with NSEC");
 
-    service.mSubTypeLabelsLength = 4;
+        AdvanceTime(2000);
 
-    sRegCallbacks[1].Reset();
-    sDnsMessages.Clear();
-    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
+        sDnsMessages.Clear();
+        SendQuery(fullName.AsCString(), ResourceRecord::kTypeA);
 
-    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-    {
-        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
-        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
+        AdvanceTime(1000);
 
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 2);
-        dnsMsg->ValidateSubType(service.mSubTypeLabels[3], service);
-        dnsMsg->Validate(service, kInAdditionalSection, kCheckSrv | kCheckTxt);
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        VerifyOrQuit(dnsMsg != nullptr);
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 1);
+        VerifyOrQuit(dnsMsg->mAdditionalRecords.ContainsNsec(fullName, ResourceRecord::kTypeKey));
+
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Change the TTL");
+
+        key.mTtl = 0; // Use default
+
+        sRegCallbacks[1].Reset();
         sDnsMessages.Clear();
-    }
+        SuccessOrQuit(mdns->RegisterKey(key, 1, HandleSuccessCallback));
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Remove a previous sub-type and validate announcements of its removal");
+        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+        {
+            AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+            VerifyOrQuit(sRegCallbacks[1].mWasCalled);
 
-    service.mSubTypeLabels++;
-    service.mSubTypeLabelsLength = 3;
+            VerifyOrQuit(!sDnsMessages.IsEmpty());
+            dnsMsg = sDnsMessages.GetHead();
+            dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+            dnsMsg->Validate(key, kInAnswerSection);
+            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
 
-    sRegCallbacks[1].Reset();
-    sDnsMessages.Clear();
-    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
+            sDnsMessages.Clear();
+        }
 
-    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-    {
-        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
-        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Change the key");
 
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
-        dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 0);
-        dnsMsg->ValidateSubType(kSubTypes1[0], service, kGoodBye);
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        key.mKeyData       = kKey2;
+        key.mKeyDataLength = sizeof(kKey2);
+
+        sRegCallbacks[1].Reset();
         sDnsMessages.Clear();
-    }
+        SuccessOrQuit(mdns->RegisterKey(key, 1, HandleSuccessCallback));
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Update TTL and validate announcement of all records");
+        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+        {
+            AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+            VerifyOrQuit(sRegCallbacks[1].mWasCalled);
 
-    service.mTtl = 0;
+            VerifyOrQuit(!sDnsMessages.IsEmpty());
+            dnsMsg = sDnsMessages.GetHead();
+            dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+            dnsMsg->Validate(key, kInAnswerSection);
+            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
 
-    sRegCallbacks[1].Reset();
-    sDnsMessages.Clear();
-    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
+            sDnsMessages.Clear();
+        }
 
-    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-    {
-        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
-        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Unregister the key and validate the goodbye announces");
 
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
-        dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 6, /* Auth */ 0, /* Addnl */ 1);
-        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr);
+        sDnsMessages.Clear();
+        SuccessOrQuit(mdns->UnregisterKey(key));
 
-        for (uint16_t index = 0; index < service.mSubTypeLabelsLength; index++)
+        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
         {
-            dnsMsg->ValidateSubType(service.mSubTypeLabels[index], service);
-        }
+            AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
 
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-        sDnsMessages.Clear();
+            VerifyOrQuit(!sDnsMessages.IsEmpty());
+            dnsMsg = sDnsMessages.GetHead();
+            dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 0);
+            dnsMsg->Validate(key, kInAnswerSection, kGoodBye);
+            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+
+            sDnsMessages.Clear();
+        }
     }
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Add and remove sub-types at the same time and check proper announcements");
+    AdvanceTime(15000);
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
-    // Registered sub-types: _r2, _vXy, _last
-    // New sub-types list  : _vxy, _r1, _r2, _zzz
-    //
-    // Should announce removal of `_last` and addition of
-    // `_r1` and `_zzz`. The `_vxy` should match with `_vXy`.
+    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
+    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
 
-    service.mSubTypeLabels       = kSubTypes2;
-    service.mSubTypeLabelsLength = 4;
+    Log("End of test");
 
-    sRegCallbacks[1].Reset();
-    sDnsMessages.Clear();
-    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
+    testFreeInstance(sInstance);
+}
 
-    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-    {
-        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
-        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
-
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
-        dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 3, /* Auth */ 0, /* Addnl */ 2);
-
-        dnsMsg->ValidateSubType(kSubTypes1[3], service, kGoodBye);
-        dnsMsg->ValidateSubType(kSubTypes2[1], service);
-        dnsMsg->ValidateSubType(kSubTypes2[3], service);
-        dnsMsg->Validate(service, kInAdditionalSection, kCheckSrv | kCheckTxt);
-
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-        sDnsMessages.Clear();
-    }
-
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Unregister the service and validate the goodbye announces for service and its sub-types");
-
-    sDnsMessages.Clear();
-    SuccessOrQuit(mdns->UnregisterService(service));
-
-    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-    {
-        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
-
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
-        dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 7, /* Auth */ 0, /* Addnl */ 0);
-        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr, kGoodBye);
-
-        for (uint16_t index = 0; index < service.mSubTypeLabelsLength; index++)
-        {
-            dnsMsg->ValidateSubType(service.mSubTypeLabels[index], service, kGoodBye);
-        }
-
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-        sDnsMessages.Clear();
-    }
-
-    AdvanceTime(15000);
-    VerifyOrQuit(sDnsMessages.IsEmpty());
-
-    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
-    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
-
-    Log("End of test");
-
-    testFreeInstance(sInstance);
-}
+//---------------------------------------------------------------------------------------------------------------------
 
-void TestHostOrServiceAndKeyReg(void)
+void TestServiceReg(void)
 {
     Core             *mdns = InitTest();
-    Core::Host        host;
     Core::Service     service;
-    Core::Key         key;
-    Ip6::Address      hostAddresses[2];
     const DnsMessage *dnsMsg;
     uint16_t          heapAllocations;
+    DnsNameString     fullServiceName;
+    DnsNameString     fullServiceType;
 
     Log("-------------------------------------------------------------------------------------------");
-    Log("TestHostOrServiceAndKeyReg");
+    Log("TestServiceReg");
 
     AdvanceTime(1);
 
     heapAllocations = sHeapAllocatedPtrs.GetLength();
     SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
 
-    SuccessOrQuit(hostAddresses[0].FromString("fd00::1"));
-    SuccessOrQuit(hostAddresses[1].FromString("fd00::2"));
-
-    host.mHostName        = "myhost";
-    host.mAddresses       = hostAddresses;
-    host.mAddressesLength = 2;
-    host.mTtl             = 5000;
-
-    key.mKeyData       = kKey1;
-    key.mKeyDataLength = sizeof(kKey1);
-    key.mTtl           = 80000;
-
     service.mHostName            = "myhost";
     service.mServiceInstance     = "myservice";
     service.mServiceType         = "_srv._udp";
@@ -2987,38 +2969,19 @@ void TestHostOrServiceAndKeyReg(void)
     service.mWeight              = 2;
     service.mTtl                 = 1000;
 
-    // Run all test step twice, first time registering host and key,
-    // second time registering service and key.
-
-    for (uint8_t iter = 0; iter < 2; iter++)
-    {
-        if (iter == 0)
-        {
-            key.mName        = host.mHostName;
-            key.mServiceType = nullptr;
-        }
-        else
-        {
-            key.mName        = service.mServiceInstance;
-            key.mServiceType = service.mServiceType;
-        }
-
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Register a %s entry, check the first probe is sent", iter == 0 ? "host" : "service");
+    fullServiceName.Append("%s.%s.local.", service.mServiceInstance, service.mServiceType);
+    fullServiceType.Append("%s.local.", service.mServiceType);
 
-        sDnsMessages.Clear();
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Register a `ServiceEntry`, check probes and announcements");
 
-        sRegCallbacks[0].Reset();
+    sDnsMessages.Clear();
 
-        if (iter == 0)
-        {
-            SuccessOrQuit(mdns->RegisterHost(host, 0, HandleSuccessCallback));
-        }
-        else
-        {
-            SuccessOrQuit(mdns->RegisterService(service, 0, HandleSuccessCallback));
-        }
+    sRegCallbacks[0].Reset();
+    SuccessOrQuit(mdns->RegisterService(service, 0, HandleSuccessCallback));
 
+    for (uint8_t probeCount = 0; probeCount < 3; probeCount++)
+    {
         sDnsMessages.Clear();
 
         VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
@@ -3026,266 +2989,257 @@ void TestHostOrServiceAndKeyReg(void)
 
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-
         dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
+        dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ (probeCount == 0));
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    }
 
-        if (iter == 0)
-        {
-            dnsMsg->ValidateAsProbeFor(host, /* aUnicastRequest */ true);
-        }
-        else
-        {
-            dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ true);
-        }
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        sDnsMessages.Clear();
+
+        AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(sRegCallbacks[0].mWasCalled);
 
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr | kCheckServicesPtr);
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    }
 
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Register a `KeyEntry` for same name, check that probes continue");
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a query for SRV record and validate the response");
 
-        sRegCallbacks[1].Reset();
-        SuccessOrQuit(mdns->RegisterKey(key, 1, HandleSuccessCallback));
+    AdvanceTime(2000);
 
-        for (uint8_t probeCount = 1; probeCount < 3; probeCount++)
-        {
-            sDnsMessages.Clear();
+    sDnsMessages.Clear();
+    SendQuery(fullServiceName.AsCString(), ResourceRecord::kTypeSrv);
 
-            VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
-            VerifyOrQuit(!sRegCallbacks[1].mWasCalled);
+    AdvanceTime(1000);
 
-            AdvanceTime(250);
+    dnsMsg = sDnsMessages.GetHead();
+    VerifyOrQuit(dnsMsg != nullptr);
+    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+    dnsMsg->Validate(service, kInAnswerSection, kCheckSrv);
 
-            VerifyOrQuit(!sDnsMessages.IsEmpty());
-            dnsMsg = sDnsMessages.GetHead();
-            dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 3, /* Addnl */ 0);
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a query for TXT record and validate the response");
 
-            if (iter == 0)
-            {
-                dnsMsg->ValidateAsProbeFor(host, /* aUnicastRequest */ false);
-            }
-            else
-            {
-                dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ false);
-            }
+    AdvanceTime(2000);
 
-            dnsMsg->ValidateAsProbeFor(key, /* aUnicastRequest */ (probeCount == 0));
-            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-        }
+    sDnsMessages.Clear();
+    SendQuery(fullServiceName.AsCString(), ResourceRecord::kTypeTxt);
 
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Validate Announces for both entry and key");
+    AdvanceTime(1000);
 
-        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-        {
-            sDnsMessages.Clear();
+    dnsMsg = sDnsMessages.GetHead();
+    VerifyOrQuit(dnsMsg != nullptr);
+    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+    dnsMsg->Validate(service, kInAnswerSection, kCheckTxt);
 
-            AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
-            VerifyOrQuit(sRegCallbacks[0].mWasCalled);
-            VerifyOrQuit(sRegCallbacks[1].mWasCalled);
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a query for ANY record and validate the response");
 
-            VerifyOrQuit(!sDnsMessages.IsEmpty());
-            dnsMsg = sDnsMessages.GetHead();
+    AdvanceTime(2000);
 
-            if (iter == 0)
-            {
-                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 3, /* Auth */ 0, /* Addnl */ 1);
-                dnsMsg->Validate(host, kInAnswerSection);
-            }
-            else
-            {
-                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 5, /* Auth */ 0, /* Addnl */ 1);
-                dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr | kCheckServicesPtr);
-            }
+    sDnsMessages.Clear();
+    SendQuery(fullServiceName.AsCString(), ResourceRecord::kTypeAny);
 
-            dnsMsg->Validate(key, kInAnswerSection);
-            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-        }
+    AdvanceTime(1000);
 
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Unregister the entry and validate its goodbye announces");
+    dnsMsg = sDnsMessages.GetHead();
+    VerifyOrQuit(dnsMsg != nullptr);
+    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 1);
+    dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt);
 
-        sDnsMessages.Clear();
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a query for PTR record for service type and validate the response");
 
-        if (iter == 0)
-        {
-            SuccessOrQuit(mdns->UnregisterHost(host));
-        }
-        else
-        {
-            SuccessOrQuit(mdns->UnregisterService(service));
-        }
+    AdvanceTime(2000);
 
-        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-        {
-            AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+    sDnsMessages.Clear();
+    SendQuery(fullServiceType.AsCString(), ResourceRecord::kTypePtr);
 
-            VerifyOrQuit(!sDnsMessages.IsEmpty());
-            dnsMsg = sDnsMessages.GetHead();
+    AdvanceTime(1000);
 
-            if (iter == 0)
-            {
-                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 1);
-                dnsMsg->Validate(host, kInAnswerSection, kGoodBye);
-            }
-            else
-            {
-                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 3, /* Auth */ 0, /* Addnl */ 1);
-                dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr, kGoodBye);
-            }
+    dnsMsg = sDnsMessages.GetHead();
+    VerifyOrQuit(dnsMsg != nullptr);
+    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 2);
+    dnsMsg->Validate(service, kInAnswerSection, kCheckPtr);
+    dnsMsg->Validate(service, kInAdditionalSection, kCheckSrv | kCheckTxt);
 
-            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-            sDnsMessages.Clear();
-        }
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a query for PTR record for `services._dns-sd` and validate the response");
 
-        AdvanceTime(15000);
-        VerifyOrQuit(sDnsMessages.IsEmpty());
+    AdvanceTime(2000);
 
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Register the entry again, validate its announcements");
+    sDnsMessages.Clear();
+    SendQuery("_services._dns-sd._udp.local.", ResourceRecord::kTypePtr);
 
-        sDnsMessages.Clear();
+    AdvanceTime(1000);
 
-        sRegCallbacks[2].Reset();
+    dnsMsg = sDnsMessages.GetHead();
+    VerifyOrQuit(dnsMsg != nullptr);
+    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 0);
+    dnsMsg->Validate(service, kInAnswerSection, kCheckServicesPtr);
 
-        if (iter == 0)
-        {
-            SuccessOrQuit(mdns->RegisterHost(host, 2, HandleSuccessCallback));
-        }
-        else
-        {
-            SuccessOrQuit(mdns->RegisterService(service, 2, HandleSuccessCallback));
-        }
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Update service port number and validate new announcements of SRV record");
 
-        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-        {
-            sDnsMessages.Clear();
+    service.mPort = 4567;
 
-            AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
-            VerifyOrQuit(sRegCallbacks[2].mWasCalled);
+    sRegCallbacks[1].Reset();
+    sDnsMessages.Clear();
+    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
 
-            VerifyOrQuit(!sDnsMessages.IsEmpty());
-            dnsMsg = sDnsMessages.GetHead();
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
 
-            if (iter == 0)
-            {
-                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 1);
-                dnsMsg->Validate(host, kInAnswerSection);
-            }
-            else
-            {
-                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 1);
-                dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr | kCheckServicesPtr);
-            }
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        sDnsMessages.Clear();
+    }
 
-            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-        }
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Update TXT data and validate new announcements of TXT record");
 
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Unregister the key and validate its goodbye announcements");
+    service.mTxtData       = nullptr;
+    service.mTxtDataLength = 0;
+
+    sRegCallbacks[1].Reset();
+    sDnsMessages.Clear();
+    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
 
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(service, kInAnswerSection, kCheckTxt);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
         sDnsMessages.Clear();
-        SuccessOrQuit(mdns->UnregisterKey(key));
+    }
 
-        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-        {
-            AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Update both service and TXT data and validate new announcements of both records");
 
-            VerifyOrQuit(!sDnsMessages.IsEmpty());
-            dnsMsg = sDnsMessages.GetHead();
-            dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
-            dnsMsg->Validate(key, kInAnswerSection, kGoodBye);
-            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-            sDnsMessages.Clear();
-        }
+    service.mTxtData       = kTxtData2;
+    service.mTxtDataLength = sizeof(kTxtData2);
+    service.mWeight        = 0;
 
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Register the key again, validate its announcements");
+    sRegCallbacks[1].Reset();
+    sDnsMessages.Clear();
+    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
 
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
         sDnsMessages.Clear();
+    }
 
-        sRegCallbacks[3].Reset();
-        SuccessOrQuit(mdns->RegisterKey(key, 3, HandleSuccessCallback));
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Update service host name to use local host and validate new announcements of SRV record");
 
-        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-        {
-            sDnsMessages.Clear();
+    service.mHostName = nullptr;
 
-            AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
-            VerifyOrQuit(sRegCallbacks[3].mWasCalled);
+    sRegCallbacks[1].Reset();
+    sDnsMessages.Clear();
+    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
 
-            VerifyOrQuit(!sDnsMessages.IsEmpty());
-            dnsMsg = sDnsMessages.GetHead();
-            dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
-            dnsMsg->Validate(key, kInAnswerSection);
-            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-        }
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
 
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
         sDnsMessages.Clear();
-        AdvanceTime(15000);
-        VerifyOrQuit(sDnsMessages.IsEmpty());
+    }
 
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Unregister key first, validate two of its goodbye announcements");
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Update service host name and validate new announcements of SRV record");
 
-        sDnsMessages.Clear();
+    service.mHostName = "newhost";
 
-        SuccessOrQuit(mdns->UnregisterKey(key));
+    sRegCallbacks[1].Reset();
+    sDnsMessages.Clear();
+    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
 
-        for (uint8_t anncCount = 0; anncCount < 2; anncCount++)
-        {
-            sDnsMessages.Clear();
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
 
-            AdvanceTime((anncCount == 0) ? 1 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        sDnsMessages.Clear();
+    }
 
-            VerifyOrQuit(!sDnsMessages.IsEmpty());
-            dnsMsg = sDnsMessages.GetHead();
-            dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
-            dnsMsg->Validate(key, kInAnswerSection, kGoodBye);
-            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-        }
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Update TTL and validate new announcements of SRV, TXT and PTR records");
 
-        Log("Unregister entry as well");
+    service.mTtl = 0;
 
-        if (iter == 0)
-        {
-            SuccessOrQuit(mdns->UnregisterHost(host));
-        }
-        else
-        {
-            SuccessOrQuit(mdns->UnregisterService(service));
-        }
+    sRegCallbacks[1].Reset();
+    sDnsMessages.Clear();
+    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
 
-        AdvanceTime(15000);
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
 
-        for (uint16_t anncCount = 0; anncCount < 4; anncCount++)
-        {
-            dnsMsg = dnsMsg->GetNext();
-            VerifyOrQuit(dnsMsg != nullptr);
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 3, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        sDnsMessages.Clear();
+    }
 
-            if (anncCount == 2)
-            {
-                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 0);
-                dnsMsg->Validate(key, kInAnswerSection, kGoodBye);
-            }
-            else if (iter == 0)
-            {
-                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 0);
-                dnsMsg->Validate(host, kInAnswerSection, kGoodBye);
-            }
-            else
-            {
-                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 3, /* Auth */ 0, /* Addnl */ 0);
-                dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr, kGoodBye);
-            }
-        }
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Unregister the service and validate the goodbye announces");
 
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    sDnsMessages.Clear();
+    SuccessOrQuit(mdns->UnregisterService(service));
+
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
 
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 3, /* Auth */ 0, /* Addnl */ 0);
+        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr, kGoodBye);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
         sDnsMessages.Clear();
-        AdvanceTime(15000);
-        VerifyOrQuit(sDnsMessages.IsEmpty());
     }
 
+    AdvanceTime(15000);
+    VerifyOrQuit(sDnsMessages.IsEmpty());
+
     SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
     VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
 
@@ -3296,28 +3250,847 @@ void TestHostOrServiceAndKeyReg(void)
 
 //---------------------------------------------------------------------------------------------------------------------
 
-void TestQuery(void)
+void TestUnregisterBeforeProbeFinished(void)
 {
-    static const char *const kSubTypes[] = {"_s", "_r"};
+    const uint8_t kKey1[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77};
 
     Core             *mdns = InitTest();
-    Core::Host        host1;
-    Core::Host        host2;
-    Core::Service     service1;
-    Core::Service     service2;
-    Core::Service     service3;
-    Core::Key         key1;
-    Core::Key         key2;
-    Ip6::Address      host1Addresses[3];
-    Ip6::Address      host2Addresses[2];
+    Core::Host        host;
+    Core::Service     service;
+    Core::Key         key;
+    Ip6::Address      hostAddresses[3];
     const DnsMessage *dnsMsg;
     uint16_t          heapAllocations;
-    DnsNameString     host1FullName;
-    DnsNameString     host2FullName;
-    DnsNameString     service1FullName;
-    DnsNameString     service2FullName;
-    DnsNameString     service3FullName;
-    KnownAnswer       knownAnswers[2];
+
+    Log("-------------------------------------------------------------------------------------------");
+    Log("TestUnregisterBeforeProbeFinished");
+
+    AdvanceTime(1);
+
+    heapAllocations = sHeapAllocatedPtrs.GetLength();
+    SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
+
+    SuccessOrQuit(hostAddresses[0].FromString("fd00::aaaa"));
+    SuccessOrQuit(hostAddresses[1].FromString("fd00::bbbb"));
+    SuccessOrQuit(hostAddresses[2].FromString("fd00::cccc"));
+
+    host.mHostName        = "myhost";
+    host.mAddresses       = hostAddresses;
+    host.mAddressesLength = 3;
+    host.mTtl             = 1500;
+
+    service.mHostName            = "myhost";
+    service.mServiceInstance     = "myservice";
+    service.mServiceType         = "_srv._udp";
+    service.mSubTypeLabels       = nullptr;
+    service.mSubTypeLabelsLength = 0;
+    service.mTxtData             = kTxtData1;
+    service.mTxtDataLength       = sizeof(kTxtData1);
+    service.mPort                = 1234;
+    service.mPriority            = 1;
+    service.mWeight              = 2;
+    service.mTtl                 = 1000;
+
+    key.mName          = "mysrv";
+    key.mServiceType   = "_srv._udp";
+    key.mKeyData       = kKey1;
+    key.mKeyDataLength = sizeof(kKey1);
+    key.mTtl           = 8000;
+
+    // Repeat the same test 3 times for host and service and key registration.
+
+    for (uint8_t iter = 0; iter < 3; iter++)
+    {
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Register an entry, check for the first two probes");
+
+        sDnsMessages.Clear();
+
+        sRegCallbacks[0].Reset();
+
+        switch (iter)
+        {
+        case 0:
+            SuccessOrQuit(mdns->RegisterHost(host, 0, HandleSuccessCallback));
+            break;
+        case 1:
+            SuccessOrQuit(mdns->RegisterService(service, 0, HandleSuccessCallback));
+            break;
+        case 2:
+            SuccessOrQuit(mdns->RegisterKey(key, 0, HandleSuccessCallback));
+            break;
+        }
+
+        for (uint8_t probeCount = 0; probeCount < 2; probeCount++)
+        {
+            sDnsMessages.Clear();
+
+            VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+            AdvanceTime(250);
+
+            VerifyOrQuit(!sDnsMessages.IsEmpty());
+            dnsMsg = sDnsMessages.GetHead();
+
+            switch (iter)
+            {
+            case 0:
+                dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 3, /* Addnl */ 0);
+                dnsMsg->ValidateAsProbeFor(host, /* aUnicastRequest */ (probeCount == 0));
+                break;
+            case 1:
+                dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
+                dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ (probeCount == 0));
+                break;
+            case 2:
+                dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 1, /* Addnl */ 0);
+                dnsMsg->ValidateAsProbeFor(key, /* aUnicastRequest */ (probeCount == 0));
+                break;
+            }
+
+            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        }
+
+        sDnsMessages.Clear();
+        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Unregister the entry before the last probe and make sure probing stops");
+
+        switch (iter)
+        {
+        case 0:
+            SuccessOrQuit(mdns->UnregisterHost(host));
+            break;
+        case 1:
+            SuccessOrQuit(mdns->UnregisterService(service));
+            break;
+        case 2:
+            SuccessOrQuit(mdns->UnregisterKey(key));
+            break;
+        }
+
+        AdvanceTime(20 * 1000);
+        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+
+        VerifyOrQuit(sDnsMessages.IsEmpty());
+    }
+
+    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
+    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
+
+    Log("End of test");
+
+    testFreeInstance(sInstance);
+}
+
+//---------------------------------------------------------------------------------------------------------------------
+
+void TestServiceSubTypeReg(void)
+{
+    static const char *const kSubTypes1[] = {"_s1", "_r2", "_vXy", "_last"};
+    static const char *const kSubTypes2[] = {"_vxy", "_r1", "_r2", "_zzz"};
+
+    Core             *mdns = InitTest();
+    Core::Service     service;
+    const DnsMessage *dnsMsg;
+    uint16_t          heapAllocations;
+    DnsNameString     fullServiceName;
+    DnsNameString     fullServiceType;
+    DnsNameString     fullSubServiceType;
+
+    Log("-------------------------------------------------------------------------------------------");
+    Log("TestServiceSubTypeReg");
+
+    AdvanceTime(1);
+
+    heapAllocations = sHeapAllocatedPtrs.GetLength();
+    SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
+
+    service.mHostName            = "tarnished";
+    service.mServiceInstance     = "elden";
+    service.mServiceType         = "_ring._udp";
+    service.mSubTypeLabels       = kSubTypes1;
+    service.mSubTypeLabelsLength = 3;
+    service.mTxtData             = kTxtData1;
+    service.mTxtDataLength       = sizeof(kTxtData1);
+    service.mPort                = 1234;
+    service.mPriority            = 1;
+    service.mWeight              = 2;
+    service.mTtl                 = 6000;
+
+    fullServiceName.Append("%s.%s.local.", service.mServiceInstance, service.mServiceType);
+    fullServiceType.Append("%s.local.", service.mServiceType);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Register a `ServiceEntry` with sub-types, check probes and announcements");
+
+    sDnsMessages.Clear();
+
+    sRegCallbacks[0].Reset();
+    SuccessOrQuit(mdns->RegisterService(service, 0, HandleSuccessCallback));
+
+    for (uint8_t probeCount = 0; probeCount < 3; probeCount++)
+    {
+        sDnsMessages.Clear();
+
+        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+        AdvanceTime(250);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
+        dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ (probeCount == 0));
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    }
+
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        sDnsMessages.Clear();
+
+        AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(sRegCallbacks[0].mWasCalled);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 7, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr | kCheckServicesPtr);
+
+        for (uint16_t index = 0; index < service.mSubTypeLabelsLength; index++)
+        {
+            dnsMsg->ValidateSubType(service.mSubTypeLabels[index], service);
+        }
+
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    }
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a query for SRV record and validate the response");
+
+    AdvanceTime(2000);
+
+    sDnsMessages.Clear();
+    SendQuery(fullServiceName.AsCString(), ResourceRecord::kTypeSrv);
+
+    AdvanceTime(1000);
+
+    dnsMsg = sDnsMessages.GetHead();
+    VerifyOrQuit(dnsMsg != nullptr);
+    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+    dnsMsg->Validate(service, kInAnswerSection, kCheckSrv);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a query for TXT record and validate the response");
+
+    AdvanceTime(2000);
+
+    sDnsMessages.Clear();
+    SendQuery(fullServiceName.AsCString(), ResourceRecord::kTypeTxt);
+
+    AdvanceTime(1000);
+
+    dnsMsg = sDnsMessages.GetHead();
+    VerifyOrQuit(dnsMsg != nullptr);
+    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+    dnsMsg->Validate(service, kInAnswerSection, kCheckTxt);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a query for ANY record and validate the response");
+
+    AdvanceTime(2000);
+
+    sDnsMessages.Clear();
+    SendQuery(fullServiceName.AsCString(), ResourceRecord::kTypeAny);
+
+    AdvanceTime(1000);
+
+    dnsMsg = sDnsMessages.GetHead();
+    VerifyOrQuit(dnsMsg != nullptr);
+    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 1);
+    dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a query for PTR record for service type and validate the response");
+
+    AdvanceTime(2000);
+
+    sDnsMessages.Clear();
+    SendQuery(fullServiceType.AsCString(), ResourceRecord::kTypePtr);
+
+    AdvanceTime(1000);
+
+    dnsMsg = sDnsMessages.GetHead();
+    VerifyOrQuit(dnsMsg != nullptr);
+    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 2);
+    dnsMsg->Validate(service, kInAnswerSection, kCheckPtr);
+    dnsMsg->Validate(service, kInAdditionalSection, kCheckSrv | kCheckTxt);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a query for PTR record for `services._dns-sd` and validate the response");
+
+    AdvanceTime(2000);
+
+    sDnsMessages.Clear();
+    SendQuery("_services._dns-sd._udp.local.", ResourceRecord::kTypePtr);
+
+    AdvanceTime(1000);
+
+    dnsMsg = sDnsMessages.GetHead();
+    VerifyOrQuit(dnsMsg != nullptr);
+    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 0);
+    dnsMsg->Validate(service, kInAnswerSection, kCheckServicesPtr);
+
+    for (uint16_t index = 0; index < service.mSubTypeLabelsLength; index++)
+    {
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Send a PTR query for sub-type `%s` and validate the response", service.mSubTypeLabels[index]);
+
+        fullSubServiceType.Clear();
+        fullSubServiceType.Append("%s._sub.%s", service.mSubTypeLabels[index], fullServiceType.AsCString());
+
+        AdvanceTime(2000);
+
+        sDnsMessages.Clear();
+        SendQuery(fullSubServiceType.AsCString(), ResourceRecord::kTypePtr);
+
+        AdvanceTime(1000);
+
+        dnsMsg = sDnsMessages.GetHead();
+        VerifyOrQuit(dnsMsg != nullptr);
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 2);
+        dnsMsg->ValidateSubType(service.mSubTypeLabels[index], service);
+        dnsMsg->Validate(service, kInAdditionalSection, kCheckSrv | kCheckTxt);
+    }
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a PTR query for non-existing sub-type and validate there is no response");
+
+    AdvanceTime(2000);
+
+    fullSubServiceType.Clear();
+    fullSubServiceType.Append("_none._sub.%s", fullServiceType.AsCString());
+
+    sDnsMessages.Clear();
+    SendQuery(fullSubServiceType.AsCString(), ResourceRecord::kTypePtr);
+
+    AdvanceTime(2000);
+    VerifyOrQuit(sDnsMessages.IsEmpty());
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Register a new sub-type and validate announcements of PTR record for it");
+
+    service.mSubTypeLabelsLength = 4;
+
+    sRegCallbacks[1].Reset();
+    sDnsMessages.Clear();
+    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
+
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 2);
+        dnsMsg->ValidateSubType(service.mSubTypeLabels[3], service);
+        dnsMsg->Validate(service, kInAdditionalSection, kCheckSrv | kCheckTxt);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        sDnsMessages.Clear();
+    }
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Remove a previous sub-type and validate announcements of its removal");
+
+    service.mSubTypeLabels++;
+    service.mSubTypeLabelsLength = 3;
+
+    sRegCallbacks[1].Reset();
+    sDnsMessages.Clear();
+    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
+
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 0);
+        dnsMsg->ValidateSubType(kSubTypes1[0], service, kGoodBye);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        sDnsMessages.Clear();
+    }
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Update TTL and validate announcement of all records");
+
+    service.mTtl = 0;
+
+    sRegCallbacks[1].Reset();
+    sDnsMessages.Clear();
+    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
+
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 6, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr);
+
+        for (uint16_t index = 0; index < service.mSubTypeLabelsLength; index++)
+        {
+            dnsMsg->ValidateSubType(service.mSubTypeLabels[index], service);
+        }
+
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        sDnsMessages.Clear();
+    }
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Add and remove sub-types at the same time and check proper announcements");
+
+    // Registered sub-types: _r2, _vXy, _last
+    // New sub-types list  : _vxy, _r1, _r2, _zzz
+    //
+    // Should announce removal of `_last` and addition of
+    // `_r1` and `_zzz`. The `_vxy` should match with `_vXy`.
+
+    service.mSubTypeLabels       = kSubTypes2;
+    service.mSubTypeLabelsLength = 4;
+
+    sRegCallbacks[1].Reset();
+    sDnsMessages.Clear();
+    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
+
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(sRegCallbacks[1].mWasCalled);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 3, /* Auth */ 0, /* Addnl */ 2);
+
+        dnsMsg->ValidateSubType(kSubTypes1[3], service, kGoodBye);
+        dnsMsg->ValidateSubType(kSubTypes2[1], service);
+        dnsMsg->ValidateSubType(kSubTypes2[3], service);
+        dnsMsg->Validate(service, kInAdditionalSection, kCheckSrv | kCheckTxt);
+
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        sDnsMessages.Clear();
+    }
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Unregister the service and validate the goodbye announces for service and its sub-types");
+
+    sDnsMessages.Clear();
+    SuccessOrQuit(mdns->UnregisterService(service));
+
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 7, /* Auth */ 0, /* Addnl */ 0);
+        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr, kGoodBye);
+
+        for (uint16_t index = 0; index < service.mSubTypeLabelsLength; index++)
+        {
+            dnsMsg->ValidateSubType(service.mSubTypeLabels[index], service, kGoodBye);
+        }
+
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        sDnsMessages.Clear();
+    }
+
+    AdvanceTime(15000);
+    VerifyOrQuit(sDnsMessages.IsEmpty());
+
+    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
+    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
+
+    Log("End of test");
+
+    testFreeInstance(sInstance);
+}
+
+void TestHostOrServiceAndKeyReg(void)
+{
+    Core             *mdns = InitTest();
+    Core::Host        host;
+    Core::Service     service;
+    Core::Key         key;
+    Ip6::Address      hostAddresses[2];
+    const DnsMessage *dnsMsg;
+    uint16_t          heapAllocations;
+
+    Log("-------------------------------------------------------------------------------------------");
+    Log("TestHostOrServiceAndKeyReg");
+
+    AdvanceTime(1);
+
+    heapAllocations = sHeapAllocatedPtrs.GetLength();
+    SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
+
+    SuccessOrQuit(hostAddresses[0].FromString("fd00::1"));
+    SuccessOrQuit(hostAddresses[1].FromString("fd00::2"));
+
+    host.mHostName        = "myhost";
+    host.mAddresses       = hostAddresses;
+    host.mAddressesLength = 2;
+    host.mTtl             = 5000;
+
+    key.mKeyData       = kKey1;
+    key.mKeyDataLength = sizeof(kKey1);
+    key.mTtl           = 80000;
+
+    service.mHostName            = "myhost";
+    service.mServiceInstance     = "myservice";
+    service.mServiceType         = "_srv._udp";
+    service.mSubTypeLabels       = nullptr;
+    service.mSubTypeLabelsLength = 0;
+    service.mTxtData             = kTxtData1;
+    service.mTxtDataLength       = sizeof(kTxtData1);
+    service.mPort                = 1234;
+    service.mPriority            = 1;
+    service.mWeight              = 2;
+    service.mTtl                 = 1000;
+
+    // Run all test step twice, first time registering host and key,
+    // second time registering service and key.
+
+    for (uint8_t iter = 0; iter < 2; iter++)
+    {
+        if (iter == 0)
+        {
+            key.mName        = host.mHostName;
+            key.mServiceType = nullptr;
+        }
+        else
+        {
+            key.mName        = service.mServiceInstance;
+            key.mServiceType = service.mServiceType;
+        }
+
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Register a %s entry, check the first probe is sent", iter == 0 ? "host" : "service");
+
+        sDnsMessages.Clear();
+
+        sRegCallbacks[0].Reset();
+
+        if (iter == 0)
+        {
+            SuccessOrQuit(mdns->RegisterHost(host, 0, HandleSuccessCallback));
+        }
+        else
+        {
+            SuccessOrQuit(mdns->RegisterService(service, 0, HandleSuccessCallback));
+        }
+
+        sDnsMessages.Clear();
+
+        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+        AdvanceTime(250);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
+
+        if (iter == 0)
+        {
+            dnsMsg->ValidateAsProbeFor(host, /* aUnicastRequest */ true);
+        }
+        else
+        {
+            dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ true);
+        }
+
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Register a `KeyEntry` for same name, check that probes continue");
+
+        sRegCallbacks[1].Reset();
+        SuccessOrQuit(mdns->RegisterKey(key, 1, HandleSuccessCallback));
+
+        for (uint8_t probeCount = 1; probeCount < 3; probeCount++)
+        {
+            sDnsMessages.Clear();
+
+            VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+            VerifyOrQuit(!sRegCallbacks[1].mWasCalled);
+
+            AdvanceTime(250);
+
+            VerifyOrQuit(!sDnsMessages.IsEmpty());
+            dnsMsg = sDnsMessages.GetHead();
+            dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 3, /* Addnl */ 0);
+
+            if (iter == 0)
+            {
+                dnsMsg->ValidateAsProbeFor(host, /* aUnicastRequest */ false);
+            }
+            else
+            {
+                dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ false);
+            }
+
+            dnsMsg->ValidateAsProbeFor(key, /* aUnicastRequest */ (probeCount == 0));
+            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        }
+
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Validate Announces for both entry and key");
+
+        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+        {
+            sDnsMessages.Clear();
+
+            AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
+            VerifyOrQuit(sRegCallbacks[0].mWasCalled);
+            VerifyOrQuit(sRegCallbacks[1].mWasCalled);
+
+            VerifyOrQuit(!sDnsMessages.IsEmpty());
+            dnsMsg = sDnsMessages.GetHead();
+
+            if (iter == 0)
+            {
+                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 3, /* Auth */ 0, /* Addnl */ 1);
+                dnsMsg->Validate(host, kInAnswerSection);
+            }
+            else
+            {
+                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 5, /* Auth */ 0, /* Addnl */ 1);
+                dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr | kCheckServicesPtr);
+            }
+
+            dnsMsg->Validate(key, kInAnswerSection);
+            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        }
+
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Unregister the entry and validate its goodbye announces");
+
+        sDnsMessages.Clear();
+
+        if (iter == 0)
+        {
+            SuccessOrQuit(mdns->UnregisterHost(host));
+        }
+        else
+        {
+            SuccessOrQuit(mdns->UnregisterService(service));
+        }
+
+        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+        {
+            AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+
+            VerifyOrQuit(!sDnsMessages.IsEmpty());
+            dnsMsg = sDnsMessages.GetHead();
+
+            if (iter == 0)
+            {
+                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 1);
+                dnsMsg->Validate(host, kInAnswerSection, kGoodBye);
+            }
+            else
+            {
+                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 3, /* Auth */ 0, /* Addnl */ 1);
+                dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr, kGoodBye);
+            }
+
+            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+            sDnsMessages.Clear();
+        }
+
+        AdvanceTime(15000);
+        VerifyOrQuit(sDnsMessages.IsEmpty());
+
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Register the entry again, validate its announcements");
+
+        sDnsMessages.Clear();
+
+        sRegCallbacks[2].Reset();
+
+        if (iter == 0)
+        {
+            SuccessOrQuit(mdns->RegisterHost(host, 2, HandleSuccessCallback));
+        }
+        else
+        {
+            SuccessOrQuit(mdns->RegisterService(service, 2, HandleSuccessCallback));
+        }
+
+        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+        {
+            sDnsMessages.Clear();
+
+            AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
+            VerifyOrQuit(sRegCallbacks[2].mWasCalled);
+
+            VerifyOrQuit(!sDnsMessages.IsEmpty());
+            dnsMsg = sDnsMessages.GetHead();
+
+            if (iter == 0)
+            {
+                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 1);
+                dnsMsg->Validate(host, kInAnswerSection);
+            }
+            else
+            {
+                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 1);
+                dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr | kCheckServicesPtr);
+            }
+
+            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        }
+
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Unregister the key and validate its goodbye announcements");
+
+        sDnsMessages.Clear();
+        SuccessOrQuit(mdns->UnregisterKey(key));
+
+        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+        {
+            AdvanceTime((anncCount == 0) ? 0 : (1U << (anncCount - 1)) * 1000);
+
+            VerifyOrQuit(!sDnsMessages.IsEmpty());
+            dnsMsg = sDnsMessages.GetHead();
+            dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+            dnsMsg->Validate(key, kInAnswerSection, kGoodBye);
+            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+            sDnsMessages.Clear();
+        }
+
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Register the key again, validate its announcements");
+
+        sDnsMessages.Clear();
+
+        sRegCallbacks[3].Reset();
+        SuccessOrQuit(mdns->RegisterKey(key, 3, HandleSuccessCallback));
+
+        for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+        {
+            sDnsMessages.Clear();
+
+            AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
+            VerifyOrQuit(sRegCallbacks[3].mWasCalled);
+
+            VerifyOrQuit(!sDnsMessages.IsEmpty());
+            dnsMsg = sDnsMessages.GetHead();
+            dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+            dnsMsg->Validate(key, kInAnswerSection);
+            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        }
+
+        sDnsMessages.Clear();
+        AdvanceTime(15000);
+        VerifyOrQuit(sDnsMessages.IsEmpty());
+
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Unregister key first, validate two of its goodbye announcements");
+
+        sDnsMessages.Clear();
+
+        SuccessOrQuit(mdns->UnregisterKey(key));
+
+        for (uint8_t anncCount = 0; anncCount < 2; anncCount++)
+        {
+            sDnsMessages.Clear();
+
+            AdvanceTime((anncCount == 0) ? 1 : (1U << (anncCount - 1)) * 1000);
+
+            VerifyOrQuit(!sDnsMessages.IsEmpty());
+            dnsMsg = sDnsMessages.GetHead();
+            dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+            dnsMsg->Validate(key, kInAnswerSection, kGoodBye);
+            VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        }
+
+        Log("Unregister entry as well");
+
+        if (iter == 0)
+        {
+            SuccessOrQuit(mdns->UnregisterHost(host));
+        }
+        else
+        {
+            SuccessOrQuit(mdns->UnregisterService(service));
+        }
+
+        AdvanceTime(15000);
+
+        for (uint16_t anncCount = 0; anncCount < 4; anncCount++)
+        {
+            dnsMsg = dnsMsg->GetNext();
+            VerifyOrQuit(dnsMsg != nullptr);
+
+            if (anncCount == 2)
+            {
+                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 0);
+                dnsMsg->Validate(key, kInAnswerSection, kGoodBye);
+            }
+            else if (iter == 0)
+            {
+                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 0);
+                dnsMsg->Validate(host, kInAnswerSection, kGoodBye);
+            }
+            else
+            {
+                dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 3, /* Auth */ 0, /* Addnl */ 0);
+                dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr, kGoodBye);
+            }
+        }
+
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+
+        sDnsMessages.Clear();
+        AdvanceTime(15000);
+        VerifyOrQuit(sDnsMessages.IsEmpty());
+    }
+
+    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
+    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
+
+    Log("End of test");
+
+    testFreeInstance(sInstance);
+}
+
+//---------------------------------------------------------------------------------------------------------------------
+
+void TestQuery(void)
+{
+    static const char *const kSubTypes[] = {"_s", "_r"};
+
+    Core             *mdns = InitTest();
+    Core::Host        host1;
+    Core::Host        host2;
+    Core::Service     service1;
+    Core::Service     service2;
+    Core::Service     service3;
+    Core::Key         key1;
+    Core::Key         key2;
+    Ip6::Address      host1Addresses[3];
+    Ip6::Address      host2Addresses[2];
+    const DnsMessage *dnsMsg;
+    uint16_t          heapAllocations;
+    DnsNameString     host1FullName;
+    DnsNameString     host2FullName;
+    DnsNameString     service1FullName;
+    DnsNameString     service2FullName;
+    DnsNameString     service3FullName;
+    KnownAnswer       knownAnswers[2];
 
     Log("-------------------------------------------------------------------------------------------");
     Log("TestQuery");
@@ -4115,8 +4888,139 @@ void TestResponseAggregation(void)
 
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
-        dnsMsg->ValidateAsProbeFor(tcpService, /* aUnicastRequest */ (probeCount == 0));
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
+        dnsMsg->ValidateAsProbeFor(tcpService, /* aUnicastRequest */ (probeCount == 0));
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    }
+
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        sDnsMessages.Clear();
+
+        AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(sRegCallbacks[0].mWasCalled);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(tcpService, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr | kCheckServicesPtr);
+
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    }
+
+    Log("-------------------------------------------------------------------------------------------");
+    Log("Register a second `ServiceEntry`, check probes and announcements");
+
+    sDnsMessages.Clear();
+
+    sRegCallbacks[0].Reset();
+    SuccessOrQuit(mdns->RegisterService(udpService, 0, HandleSuccessCallback));
+
+    for (uint8_t probeCount = 0; probeCount < 3; probeCount++)
+    {
+        sDnsMessages.Clear();
+
+        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+        AdvanceTime(250);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
+        dnsMsg->ValidateAsProbeFor(udpService, /* aUnicastRequest */ (probeCount == 0));
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    }
+
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        sDnsMessages.Clear();
+
+        AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(sRegCallbacks[0].mWasCalled);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(udpService, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr | kCheckServicesPtr);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    }
+
+    Log("-------------------------------------------------------------------------------------------");
+    Log("Send two PTR queries back to back and validate the response is aggregated");
+
+    AdvanceTime(2000);
+
+    sDnsMessages.Clear();
+    SendQuery(fullTcpServiceType.AsCString(), ResourceRecord::kTypePtr);
+    AdvanceTime(5);
+    SendQuery(fullUdpServiceType.AsCString(), ResourceRecord::kTypePtr);
+
+    AdvanceTime(1000);
+
+    dnsMsg = sDnsMessages.GetHead();
+    VerifyOrQuit(dnsMsg != nullptr);
+    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 4);
+    dnsMsg->Validate(tcpService, kInAnswerSection, kCheckPtr);
+    dnsMsg->Validate(tcpService, kInAdditionalSection, kCheckSrv | kCheckTxt);
+    dnsMsg->Validate(udpService, kInAnswerSection, kCheckPtr);
+    dnsMsg->Validate(udpService, kInAdditionalSection, kCheckSrv | kCheckTxt);
+    VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+
+    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
+    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
+
+    Log("End of test");
+
+    testFreeInstance(sInstance);
+}
+
+//---------------------------------------------------------------------------------------------------------------------
+
+void TestQuestionUnicastDisallowed(void)
+{
+    Core             *mdns = InitTest();
+    Core::Host        host;
+    Ip6::Address      hostAddresses[1];
+    const DnsMessage *dnsMsg;
+    uint16_t          heapAllocations;
+    DnsNameString     hostFullName;
+
+    Log("-------------------------------------------------------------------------------------------");
+    Log("TestQuestionUnicastDisallowed");
+
+    AdvanceTime(1);
+
+    heapAllocations = sHeapAllocatedPtrs.GetLength();
+    SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
+
+    SuccessOrQuit(hostAddresses[0].FromString("fd00::1234"));
+
+    host.mHostName        = "myhost";
+    host.mAddresses       = hostAddresses;
+    host.mAddressesLength = 1;
+    host.mTtl             = 1500;
+
+    mdns->SetQuestionUnicastAllowed(false);
+    VerifyOrQuit(!mdns->IsQuestionUnicastAllowed());
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Register a `HostEntry`, check probes and announcements");
+
+    sDnsMessages.Clear();
+
+    sRegCallbacks[0].Reset();
+    SuccessOrQuit(mdns->RegisterHost(host, 0, HandleSuccessCallback));
+
+    for (uint8_t probeCount = 0; probeCount < 3; probeCount++)
+    {
+        sDnsMessages.Clear();
+
+        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+        AdvanceTime(250);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 1, /* Addnl */ 0);
+        dnsMsg->ValidateAsProbeFor(host, /* aUnicastRequest */ false);
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
     }
 
@@ -4129,68 +5033,171 @@ void TestResponseAggregation(void)
 
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 1);
-        dnsMsg->Validate(tcpService, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr | kCheckServicesPtr);
-
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(host, kInAnswerSection);
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
     }
 
+    sDnsMessages.Clear();
+    AdvanceTime(15000);
+    VerifyOrQuit(sDnsMessages.IsEmpty());
+
+    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
+    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
+
+    Log("End of test");
+
+    testFreeInstance(sInstance);
+}
+
+//---------------------------------------------------------------------------------------------------------------------
+
+void TestTxMessageSizeLimit(void)
+{
+    Core             *mdns = InitTest();
+    Core::Host        host;
+    Core::Service     service;
+    Core::Key         hostKey;
+    Core::Key         serviceKey;
+    Ip6::Address      hostAddresses[3];
+    uint8_t           keyData[300];
+    const DnsMessage *dnsMsg;
+    uint16_t          heapAllocations;
+    DnsNameString     hostFullName;
+    DnsNameString     serviceFullName;
+
+    memset(keyData, 1, sizeof(keyData));
+
     Log("-------------------------------------------------------------------------------------------");
-    Log("Register a second `ServiceEntry`, check probes and announcements");
+    Log("TestTxMessageSizeLimit");
+
+    AdvanceTime(1);
+
+    heapAllocations = sHeapAllocatedPtrs.GetLength();
+    SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
+
+    SuccessOrQuit(hostAddresses[0].FromString("fd00::1:aaaa"));
+    SuccessOrQuit(hostAddresses[1].FromString("fd00::1:bbbb"));
+    SuccessOrQuit(hostAddresses[2].FromString("fd00::1:cccc"));
+    host.mHostName        = "myhost";
+    host.mAddresses       = hostAddresses;
+    host.mAddressesLength = 3;
+    host.mTtl             = 1500;
+    hostFullName.Append("%s.local.", host.mHostName);
+
+    service.mHostName            = host.mHostName;
+    service.mServiceInstance     = "mysrv";
+    service.mServiceType         = "_srv._udp";
+    service.mSubTypeLabels       = nullptr;
+    service.mSubTypeLabelsLength = 0;
+    service.mTxtData             = kTxtData1;
+    service.mTxtDataLength       = sizeof(kTxtData1);
+    service.mPort                = 1111;
+    service.mPriority            = 0;
+    service.mWeight              = 0;
+    service.mTtl                 = 1500;
+    serviceFullName.Append("%s.%s.local.", service.mServiceInstance, service.mServiceType);
+
+    hostKey.mName          = host.mHostName;
+    hostKey.mServiceType   = nullptr;
+    hostKey.mKeyData       = keyData;
+    hostKey.mKeyDataLength = 300;
+    hostKey.mTtl           = 8000;
+
+    serviceKey.mName          = service.mServiceInstance;
+    serviceKey.mServiceType   = service.mServiceType;
+    serviceKey.mKeyData       = keyData;
+    serviceKey.mKeyDataLength = 300;
+    serviceKey.mTtl           = 8000;
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Set `MaxMessageSize` to 340 and use large key record data to trigger size limit behavior");
+
+    mdns->SetMaxMessageSize(340);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Register host and service and keys for each");
 
     sDnsMessages.Clear();
 
-    sRegCallbacks[0].Reset();
-    SuccessOrQuit(mdns->RegisterService(udpService, 0, HandleSuccessCallback));
+    for (RegCallback &regCallbck : sRegCallbacks)
+    {
+        regCallbck.Reset();
+    }
+
+    SuccessOrQuit(mdns->RegisterHost(host, 0, HandleSuccessCallback));
+    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
+    SuccessOrQuit(mdns->RegisterKey(hostKey, 2, HandleSuccessCallback));
+    SuccessOrQuit(mdns->RegisterKey(serviceKey, 3, HandleSuccessCallback));
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Validate probes for all entries");
+    Log("Probes for host and service should be broken into separate message due to size limit");
 
     for (uint8_t probeCount = 0; probeCount < 3; probeCount++)
     {
         sDnsMessages.Clear();
-
-        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
         AdvanceTime(250);
 
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
-        dnsMsg->ValidateAsProbeFor(udpService, /* aUnicastRequest */ (probeCount == 0));
+
+        for (uint16_t index = 0; index < 4; index++)
+        {
+            VerifyOrQuit(!sRegCallbacks[index].mWasCalled);
+        }
+
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 4, /* Addnl */ 0);
+        dnsMsg->ValidateAsProbeFor(host, /* aUnicastRequest */ (probeCount == 0));
+        dnsMsg->ValidateAsProbeFor(hostKey, /* aUnicastRequest */ (probeCount == 0));
+
+        dnsMsg = dnsMsg->GetNext();
+        VerifyOrQuit(dnsMsg != nullptr);
+
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 3, /* Addnl */ 0);
+        dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ (probeCount == 0));
+        dnsMsg->ValidateAsProbeFor(serviceKey, /* aUnicastRequest */ (probeCount == 0));
+
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
     }
 
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Validate announcements for all entries");
+    Log("Announces should also be broken into separate message due to size limit");
+
     for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
     {
         sDnsMessages.Clear();
 
         AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
-        VerifyOrQuit(sRegCallbacks[0].mWasCalled);
+
+        for (uint16_t index = 0; index < 4; index++)
+        {
+            VerifyOrQuit(sRegCallbacks[index].mWasCalled);
+        }
 
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
+
         dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 1);
-        dnsMsg->Validate(udpService, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr | kCheckServicesPtr);
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-    }
+        dnsMsg->Validate(host, kInAnswerSection);
+        dnsMsg->Validate(hostKey, kInAnswerSection);
 
-    Log("-------------------------------------------------------------------------------------------");
-    Log("Send two PTR queries back to back and validate the response is aggregated");
+        dnsMsg = dnsMsg->GetNext();
+        VerifyOrQuit(dnsMsg != nullptr);
 
-    AdvanceTime(2000);
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 4);
+        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr);
+        dnsMsg->Validate(serviceKey, kInAnswerSection);
 
-    sDnsMessages.Clear();
-    SendQuery(fullTcpServiceType.AsCString(), ResourceRecord::kTypePtr);
-    AdvanceTime(5);
-    SendQuery(fullUdpServiceType.AsCString(), ResourceRecord::kTypePtr);
+        dnsMsg = dnsMsg->GetNext();
+        VerifyOrQuit(dnsMsg != nullptr);
 
-    AdvanceTime(1000);
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 0);
+        dnsMsg->Validate(service, kInAnswerSection, kCheckServicesPtr);
 
-    dnsMsg = sDnsMessages.GetHead();
-    VerifyOrQuit(dnsMsg != nullptr);
-    dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 4);
-    dnsMsg->Validate(tcpService, kInAnswerSection, kCheckPtr);
-    dnsMsg->Validate(tcpService, kInAdditionalSection, kCheckSrv | kCheckTxt);
-    dnsMsg->Validate(udpService, kInAnswerSection, kCheckPtr);
-    dnsMsg->Validate(udpService, kInAdditionalSection, kCheckSrv | kCheckTxt);
-    VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    }
 
     SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
     VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
@@ -4202,38 +5209,112 @@ void TestResponseAggregation(void)
 
 //---------------------------------------------------------------------------------------------------------------------
 
-void TestQuestionUnicastDisallowed(void)
+void TestHostConflict(void)
 {
     Core             *mdns = InitTest();
     Core::Host        host;
-    Ip6::Address      hostAddresses[1];
+    Ip6::Address      hostAddresses[2];
     const DnsMessage *dnsMsg;
     uint16_t          heapAllocations;
     DnsNameString     hostFullName;
 
     Log("-------------------------------------------------------------------------------------------");
-    Log("TestQuestionUnicastDisallowed");
+    Log("TestHostConflict");
 
     AdvanceTime(1);
 
     heapAllocations = sHeapAllocatedPtrs.GetLength();
     SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
 
-    SuccessOrQuit(hostAddresses[0].FromString("fd00::1234"));
+    SuccessOrQuit(hostAddresses[0].FromString("fd00::1"));
+    SuccessOrQuit(hostAddresses[1].FromString("fd00::2"));
 
     host.mHostName        = "myhost";
     host.mAddresses       = hostAddresses;
-    host.mAddressesLength = 1;
+    host.mAddressesLength = 2;
     host.mTtl             = 1500;
 
-    mdns->SetQuestionUnicastAllowed(false);
-    VerifyOrQuit(!mdns->IsQuestionUnicastAllowed());
+    hostFullName.Append("%s.local.", host.mHostName);
+
+    // Run the test twice, first run send response with record in Answer section,
+    // section run in Additional Data section.
+
+    sConflictCallback.Reset();
+    mdns->SetConflictCallback(HandleConflict);
+
+    for (uint8_t iter = 0; iter < 2; iter++)
+    {
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Register a `HostEntry`, wait for first probe");
+
+        sDnsMessages.Clear();
+
+        sRegCallbacks[0].Reset();
+        SuccessOrQuit(mdns->RegisterHost(host, 0, HandleCallback));
+
+        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+        AdvanceTime(250);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
+        dnsMsg->ValidateAsProbeFor(host, /* aUnicastRequest */ true);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Send a response claiming the name with record in %s section", (iter == 0) ? "answer" : "additional");
+
+        SendResponseWithEmptyKey(hostFullName.AsCString(), (iter == 0) ? kInAnswerSection : kInAdditionalSection);
+        AdvanceTime(1);
+
+        VerifyOrQuit(sRegCallbacks[0].mWasCalled);
+        VerifyOrQuit(sRegCallbacks[0].mError == kErrorDuplicated);
+
+        VerifyOrQuit(!sConflictCallback.mWasCalled);
+
+        sDnsMessages.Clear();
+
+        SuccessOrQuit(mdns->UnregisterHost(host));
+
+        AdvanceTime(15000);
+        VerifyOrQuit(sDnsMessages.IsEmpty());
+    }
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Register a `HostEntry`, check probes and announcements");
+    Log("Register a `HostEntry` and respond to probe to trigger conflict");
+
+    sRegCallbacks[0].Reset();
+    SuccessOrQuit(mdns->RegisterHost(host, 0, HandleCallback));
+
+    VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+
+    SendResponseWithEmptyKey(hostFullName.AsCString(), kInAnswerSection);
+    AdvanceTime(1);
+
+    VerifyOrQuit(sRegCallbacks[0].mWasCalled);
+    VerifyOrQuit(sRegCallbacks[0].mError == kErrorDuplicated);
+    VerifyOrQuit(!sConflictCallback.mWasCalled);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Register the conflicted `HostEntry` again, and make sure no probes are sent");
 
+    sRegCallbacks[1].Reset();
+    sConflictCallback.Reset();
     sDnsMessages.Clear();
 
+    SuccessOrQuit(mdns->RegisterHost(host, 1, HandleCallback));
+    AdvanceTime(5000);
+
+    VerifyOrQuit(sRegCallbacks[1].mWasCalled);
+    VerifyOrQuit(sRegCallbacks[1].mError == kErrorDuplicated);
+    VerifyOrQuit(!sConflictCallback.mWasCalled);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Unregister the conflicted host and register it again immediately, make sure we see probes");
+
+    SuccessOrQuit(mdns->UnregisterHost(host));
+
+    sConflictCallback.Reset();
     sRegCallbacks[0].Reset();
     SuccessOrQuit(mdns->RegisterHost(host, 0, HandleSuccessCallback));
 
@@ -4246,8 +5327,8 @@ void TestQuestionUnicastDisallowed(void)
 
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 1, /* Addnl */ 0);
-        dnsMsg->ValidateAsProbeFor(host, /* aUnicastRequest */ false);
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
+        dnsMsg->ValidateAsProbeFor(host, /* aUnicastRequest */ (probeCount == 0));
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
     }
 
@@ -4260,14 +5341,22 @@ void TestQuestionUnicastDisallowed(void)
 
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 1);
         dnsMsg->Validate(host, kInAnswerSection);
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
     }
 
-    sDnsMessages.Clear();
-    AdvanceTime(15000);
-    VerifyOrQuit(sDnsMessages.IsEmpty());
+    VerifyOrQuit(!sConflictCallback.mWasCalled);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a response for host name and validate that conflict is detected and callback is called");
+
+    SendResponseWithEmptyKey(hostFullName.AsCString(), kInAnswerSection);
+    AdvanceTime(1);
+
+    VerifyOrQuit(sConflictCallback.mWasCalled);
+    VerifyOrQuit(StringMatch(sConflictCallback.mName.AsCString(), host.mHostName, kStringCaseInsensitiveMatch));
+    VerifyOrQuit(!sConflictCallback.mHasServiceType);
 
     SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
     VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
@@ -4279,747 +5368,859 @@ void TestQuestionUnicastDisallowed(void)
 
 //---------------------------------------------------------------------------------------------------------------------
 
-void TestTxMessageSizeLimit(void)
+void TestServiceConflict(void)
 {
     Core             *mdns = InitTest();
-    Core::Host        host;
     Core::Service     service;
-    Core::Key         hostKey;
-    Core::Key         serviceKey;
-    Ip6::Address      hostAddresses[3];
-    uint8_t           keyData[300];
     const DnsMessage *dnsMsg;
     uint16_t          heapAllocations;
-    DnsNameString     hostFullName;
-    DnsNameString     serviceFullName;
-
-    memset(keyData, 1, sizeof(keyData));
+    DnsNameString     fullServiceName;
 
     Log("-------------------------------------------------------------------------------------------");
-    Log("TestTxMessageSizeLimit");
+    Log("TestServiceConflict");
+
+    service.mHostName            = "myhost";
+    service.mServiceInstance     = "myservice";
+    service.mServiceType         = "_srv._udp";
+    service.mSubTypeLabels       = nullptr;
+    service.mSubTypeLabelsLength = 0;
+    service.mTxtData             = kTxtData1;
+    service.mTxtDataLength       = sizeof(kTxtData1);
+    service.mPort                = 1234;
+    service.mPriority            = 1;
+    service.mWeight              = 2;
+    service.mTtl                 = 1000;
+
+    fullServiceName.Append("%s.%s.local.", service.mServiceInstance, service.mServiceType);
 
     AdvanceTime(1);
 
     heapAllocations = sHeapAllocatedPtrs.GetLength();
     SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
 
-    SuccessOrQuit(hostAddresses[0].FromString("fd00::1:aaaa"));
-    SuccessOrQuit(hostAddresses[1].FromString("fd00::1:bbbb"));
-    SuccessOrQuit(hostAddresses[2].FromString("fd00::1:cccc"));
-    host.mHostName        = "myhost";
-    host.mAddresses       = hostAddresses;
-    host.mAddressesLength = 3;
-    host.mTtl             = 1500;
-    hostFullName.Append("%s.local.", host.mHostName);
+    // Run the test twice, first run send response with record in Answer section,
+    // section run in Additional Data section.
 
-    service.mHostName            = host.mHostName;
-    service.mServiceInstance     = "mysrv";
-    service.mServiceType         = "_srv._udp";
-    service.mSubTypeLabels       = nullptr;
-    service.mSubTypeLabelsLength = 0;
-    service.mTxtData             = kTxtData1;
-    service.mTxtDataLength       = sizeof(kTxtData1);
-    service.mPort                = 1111;
-    service.mPriority            = 0;
-    service.mWeight              = 0;
-    service.mTtl                 = 1500;
-    serviceFullName.Append("%s.%s.local.", service.mServiceInstance, service.mServiceType);
+    sConflictCallback.Reset();
+    mdns->SetConflictCallback(HandleConflict);
 
-    hostKey.mName          = host.mHostName;
-    hostKey.mServiceType   = nullptr;
-    hostKey.mKeyData       = keyData;
-    hostKey.mKeyDataLength = 300;
-    hostKey.mTtl           = 8000;
+    for (uint8_t iter = 0; iter < 2; iter++)
+    {
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Register a `ServiceEntry`, wait for first probe");
 
-    serviceKey.mName          = service.mServiceInstance;
-    serviceKey.mServiceType   = service.mServiceType;
-    serviceKey.mKeyData       = keyData;
-    serviceKey.mKeyDataLength = 300;
-    serviceKey.mTtl           = 8000;
+        sDnsMessages.Clear();
+
+        sRegCallbacks[0].Reset();
+        SuccessOrQuit(mdns->RegisterService(service, 0, HandleCallback));
+
+        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+        AdvanceTime(250);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
+        dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ true);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+
+        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+        Log("Send a response claiming the name with record in %s section", (iter == 0) ? "answer" : "additional");
+
+        SendResponseWithEmptyKey(fullServiceName.AsCString(), (iter == 0) ? kInAnswerSection : kInAdditionalSection);
+        AdvanceTime(1);
+
+        VerifyOrQuit(sRegCallbacks[0].mWasCalled);
+        VerifyOrQuit(sRegCallbacks[0].mError == kErrorDuplicated);
+
+        VerifyOrQuit(!sConflictCallback.mWasCalled);
+
+        sDnsMessages.Clear();
+
+        SuccessOrQuit(mdns->UnregisterService(service));
+
+        AdvanceTime(15000);
+        VerifyOrQuit(sDnsMessages.IsEmpty());
+    }
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Set `MaxMessageSize` to 340 and use large key record data to trigger size limit behavior");
+    Log("Register a `ServiceEntry` and respond to probe to trigger conflict");
 
-    mdns->SetMaxMessageSize(340);
+    sRegCallbacks[0].Reset();
+    SuccessOrQuit(mdns->RegisterService(service, 0, HandleCallback));
+
+    VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+
+    SendResponseWithEmptyKey(fullServiceName.AsCString(), kInAnswerSection);
+    AdvanceTime(1);
+
+    VerifyOrQuit(sRegCallbacks[0].mWasCalled);
+    VerifyOrQuit(sRegCallbacks[0].mError == kErrorDuplicated);
+    VerifyOrQuit(!sConflictCallback.mWasCalled);
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Register host and service and keys for each");
+    Log("Register the conflicted `ServiceEntry` again, and make sure no probes are sent");
 
+    sRegCallbacks[1].Reset();
+    sConflictCallback.Reset();
     sDnsMessages.Clear();
 
-    for (RegCallback &regCallbck : sRegCallbacks)
-    {
-        regCallbck.Reset();
-    }
+    SuccessOrQuit(mdns->RegisterService(service, 1, HandleCallback));
+    AdvanceTime(5000);
 
-    SuccessOrQuit(mdns->RegisterHost(host, 0, HandleSuccessCallback));
-    SuccessOrQuit(mdns->RegisterService(service, 1, HandleSuccessCallback));
-    SuccessOrQuit(mdns->RegisterKey(hostKey, 2, HandleSuccessCallback));
-    SuccessOrQuit(mdns->RegisterKey(serviceKey, 3, HandleSuccessCallback));
+    VerifyOrQuit(sRegCallbacks[1].mWasCalled);
+    VerifyOrQuit(sRegCallbacks[1].mError == kErrorDuplicated);
+    VerifyOrQuit(!sConflictCallback.mWasCalled);
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Validate probes for all entries");
-    Log("Probes for host and service should be broken into separate message due to size limit");
+    Log("Unregister the conflicted host and register it again immediately, make sure we see probes");
+
+    SuccessOrQuit(mdns->UnregisterService(service));
+
+    sConflictCallback.Reset();
+    sRegCallbacks[0].Reset();
+    SuccessOrQuit(mdns->RegisterService(service, 0, HandleSuccessCallback));
 
     for (uint8_t probeCount = 0; probeCount < 3; probeCount++)
     {
         sDnsMessages.Clear();
+
+        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
         AdvanceTime(250);
 
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
+        dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ (probeCount == 0));
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    }
 
-        for (uint16_t index = 0; index < 4; index++)
-        {
-            VerifyOrQuit(!sRegCallbacks[index].mWasCalled);
-        }
+    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    {
+        sDnsMessages.Clear();
 
-        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 4, /* Addnl */ 0);
-        dnsMsg->ValidateAsProbeFor(host, /* aUnicastRequest */ (probeCount == 0));
-        dnsMsg->ValidateAsProbeFor(hostKey, /* aUnicastRequest */ (probeCount == 0));
+        AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrQuit(sRegCallbacks[0].mWasCalled);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 1);
+        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr | kCheckServicesPtr);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    }
+
+    VerifyOrQuit(!sConflictCallback.mWasCalled);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a response for service name and validate that conflict is detected and callback is called");
+
+    SendResponseWithEmptyKey(fullServiceName.AsCString(), kInAnswerSection);
+    AdvanceTime(1);
+
+    VerifyOrQuit(sConflictCallback.mWasCalled);
+    VerifyOrQuit(
+        StringMatch(sConflictCallback.mName.AsCString(), service.mServiceInstance, kStringCaseInsensitiveMatch));
+    VerifyOrQuit(sConflictCallback.mHasServiceType);
+    VerifyOrQuit(
+        StringMatch(sConflictCallback.mServiceType.AsCString(), service.mServiceType, kStringCaseInsensitiveMatch));
+
+    sDnsMessages.Clear();
+    AdvanceTime(20000);
+    VerifyOrQuit(sDnsMessages.IsEmpty());
+
+    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
+    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
+
+    Log("End of test");
+
+    testFreeInstance(sInstance);
+}
+
+//=====================================================================================================================
+// Browser/Resolver tests
+
+struct BrowseCallback : public Allocatable<BrowseCallback>, public LinkedListEntry<BrowseCallback>
+{
+    BrowseCallback *mNext;
+    DnsName         mServiceType;
+    DnsName         mSubTypeLabel;
+    DnsName         mServiceInstance;
+    uint32_t        mTtl;
+    bool            mIsSubType;
+};
+
+struct SrvCallback : public Allocatable<SrvCallback>, public LinkedListEntry<SrvCallback>
+{
+    SrvCallback *mNext;
+    DnsName      mServiceInstance;
+    DnsName      mServiceType;
+    DnsName      mHostName;
+    uint16_t     mPort;
+    uint16_t     mPriority;
+    uint16_t     mWeight;
+    uint32_t     mTtl;
+};
+
+struct TxtCallback : public Allocatable<TxtCallback>, public LinkedListEntry<TxtCallback>
+{
+    static constexpr uint16_t kMaxTxtDataLength = 100;
+
+    template <uint16_t kSize> bool Matches(const uint8_t (&aData)[kSize]) const
+    {
+        return (mTxtDataLength == kSize) && (memcmp(mTxtData, aData, kSize) == 0);
+    }
+
+    TxtCallback *mNext;
+    DnsName      mServiceInstance;
+    DnsName      mServiceType;
+    uint8_t      mTxtData[kMaxTxtDataLength];
+    uint16_t     mTxtDataLength;
+    uint32_t     mTtl;
+};
+
+struct AddrCallback : public Allocatable<AddrCallback>, public LinkedListEntry<AddrCallback>
+{
+    static constexpr uint16_t kMaxNumAddrs = 16;
 
-        dnsMsg = dnsMsg->GetNext();
-        VerifyOrQuit(dnsMsg != nullptr);
+    bool Contains(const AddrAndTtl &aAddrAndTtl) const
+    {
+        bool contains = false;
 
-        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 3, /* Addnl */ 0);
-        dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ (probeCount == 0));
-        dnsMsg->ValidateAsProbeFor(serviceKey, /* aUnicastRequest */ (probeCount == 0));
+        for (uint16_t index = 0; index < mNumAddrs; index++)
+        {
+            if (mAddrAndTtls[index] == aAddrAndTtl)
+            {
+                contains = true;
+                break;
+            }
+        }
 
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        return contains;
     }
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Validate announcements for all entries");
-    Log("Announces should also be broken into separate message due to size limit");
-
-    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    bool Matches(const AddrAndTtl *aAddrAndTtls, uint16_t aNumAddrs) const
     {
-        sDnsMessages.Clear();
+        bool matches = true;
 
-        AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
+        VerifyOrExit(aNumAddrs == mNumAddrs, matches = false);
 
-        for (uint16_t index = 0; index < 4; index++)
+        for (uint16_t index = 0; index < mNumAddrs; index++)
         {
-            VerifyOrQuit(sRegCallbacks[index].mWasCalled);
+            if (!Contains(aAddrAndTtls[index]))
+            {
+                ExitNow(matches = false);
+            }
         }
 
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
-        dnsMsg = sDnsMessages.GetHead();
-
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 1);
-        dnsMsg->Validate(host, kInAnswerSection);
-        dnsMsg->Validate(hostKey, kInAnswerSection);
-
-        dnsMsg = dnsMsg->GetNext();
-        VerifyOrQuit(dnsMsg != nullptr);
-
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 4);
-        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr);
-        dnsMsg->Validate(serviceKey, kInAnswerSection);
+    exit:
+        return matches;
+    }
 
-        dnsMsg = dnsMsg->GetNext();
-        VerifyOrQuit(dnsMsg != nullptr);
+    AddrCallback *mNext;
+    DnsName       mHostName;
+    AddrAndTtl    mAddrAndTtls[kMaxNumAddrs];
+    uint16_t      mNumAddrs;
+};
 
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 0);
-        dnsMsg->Validate(service, kInAnswerSection, kCheckServicesPtr);
+struct RecordCallback : public Allocatable<RecordCallback>, public LinkedListEntry<RecordCallback>
+{
+    static constexpr uint16_t kMaxRecordDataLength = 256;
 
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    template <uint16_t kSize> bool MatchesData(const uint8_t (&aData)[kSize]) const
+    {
+        return (mRecordDataLength == kSize) && (memcmp(mRecordData, aData, kSize) == 0);
     }
 
-    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
-    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
-
-    Log("End of test");
-
-    testFreeInstance(sInstance);
-}
+    RecordCallback *mNext;
+    DnsName         mFirstLabel;
+    DnsName         mNextLabels;
+    uint16_t        mRecordType;
+    uint8_t         mRecordData[kMaxRecordDataLength];
+    uint16_t        mRecordDataLength;
+    uint32_t        mTtl;
+};
 
-//---------------------------------------------------------------------------------------------------------------------
+OwningList<BrowseCallback> sBrowseCallbacks;
+OwningList<SrvCallback>    sSrvCallbacks;
+OwningList<TxtCallback>    sTxtCallbacks;
+OwningList<AddrCallback>   sAddrCallbacks;
+OwningList<RecordCallback> sRecordCallbacks;
 
-void TestHostConflict(void)
+void HandleBrowseResult(otInstance *aInstance, const otMdnsBrowseResult *aResult)
 {
-    Core             *mdns = InitTest();
-    Core::Host        host;
-    Ip6::Address      hostAddresses[2];
-    const DnsMessage *dnsMsg;
-    uint16_t          heapAllocations;
-    DnsNameString     hostFullName;
+    BrowseCallback *entry;
 
-    Log("-------------------------------------------------------------------------------------------");
-    Log("TestHostConflict");
+    VerifyOrQuit(aInstance == sInstance);
+    VerifyOrQuit(aResult != nullptr);
+    VerifyOrQuit(aResult->mServiceType != nullptr);
+    VerifyOrQuit(aResult->mServiceInstance != nullptr);
+    VerifyOrQuit(aResult->mInfraIfIndex == kInfraIfIndex);
 
-    AdvanceTime(1);
+    Log("Browse callback: %s (subtype:%s) -> %s ttl:%lu", aResult->mServiceType,
+        aResult->mSubTypeLabel == nullptr ? "(null)" : aResult->mSubTypeLabel, aResult->mServiceInstance,
+        ToUlong(aResult->mTtl));
 
-    heapAllocations = sHeapAllocatedPtrs.GetLength();
-    SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
+    entry = BrowseCallback::Allocate();
+    VerifyOrQuit(entry != nullptr);
 
-    SuccessOrQuit(hostAddresses[0].FromString("fd00::1"));
-    SuccessOrQuit(hostAddresses[1].FromString("fd00::2"));
+    entry->mServiceType.CopyFrom(aResult->mServiceType);
+    entry->mSubTypeLabel.CopyFrom(aResult->mSubTypeLabel);
+    entry->mServiceInstance.CopyFrom(aResult->mServiceInstance);
+    entry->mTtl       = aResult->mTtl;
+    entry->mIsSubType = (aResult->mSubTypeLabel != nullptr);
 
-    host.mHostName        = "myhost";
-    host.mAddresses       = hostAddresses;
-    host.mAddressesLength = 2;
-    host.mTtl             = 1500;
+    sBrowseCallbacks.PushAfterTail(*entry);
+}
 
-    hostFullName.Append("%s.local.", host.mHostName);
+void HandleBrowseResultAlternate(otInstance *aInstance, const otMdnsBrowseResult *aResult)
+{
+    Log("Alternate browse callback is called");
+    HandleBrowseResult(aInstance, aResult);
+}
 
-    // Run the test twice, first run send response with record in Answer section,
-    // section run in Additional Data section.
+void HandleSrvResult(otInstance *aInstance, const otMdnsSrvResult *aResult)
+{
+    SrvCallback *entry;
 
-    sConflictCallback.Reset();
-    mdns->SetConflictCallback(HandleConflict);
+    VerifyOrQuit(aInstance == sInstance);
+    VerifyOrQuit(aResult != nullptr);
+    VerifyOrQuit(aResult->mServiceInstance != nullptr);
+    VerifyOrQuit(aResult->mServiceType != nullptr);
+    VerifyOrQuit(aResult->mInfraIfIndex == kInfraIfIndex);
 
-    for (uint8_t iter = 0; iter < 2; iter++)
+    if (aResult->mTtl != 0)
     {
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Register a `HostEntry`, wait for first probe");
-
-        sDnsMessages.Clear();
+        VerifyOrQuit(aResult->mHostName != nullptr);
 
-        sRegCallbacks[0].Reset();
-        SuccessOrQuit(mdns->RegisterHost(host, 0, HandleCallback));
+        Log("SRV callback: %s %s, host:%s port:%u, prio:%u, weight:%u, ttl:%lu", aResult->mServiceInstance,
+            aResult->mServiceType, aResult->mHostName, aResult->mPort, aResult->mPriority, aResult->mWeight,
+            ToUlong(aResult->mTtl));
+    }
+    else
+    {
+        Log("SRV callback: %s %s, ttl:%lu", aResult->mServiceInstance, aResult->mServiceType, ToUlong(aResult->mTtl));
+    }
 
-        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
-        AdvanceTime(250);
+    entry = SrvCallback::Allocate();
+    VerifyOrQuit(entry != nullptr);
 
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
-        dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
-        dnsMsg->ValidateAsProbeFor(host, /* aUnicastRequest */ true);
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    entry->mServiceInstance.CopyFrom(aResult->mServiceInstance);
+    entry->mServiceType.CopyFrom(aResult->mServiceType);
+    entry->mHostName.CopyFrom(aResult->mHostName);
+    entry->mPort     = aResult->mPort;
+    entry->mPriority = aResult->mPriority;
+    entry->mWeight   = aResult->mWeight;
+    entry->mTtl      = aResult->mTtl;
 
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Send a response claiming the name with record in %s section", (iter == 0) ? "answer" : "additional");
+    sSrvCallbacks.PushAfterTail(*entry);
+}
 
-        SendResponseWithEmptyKey(hostFullName.AsCString(), (iter == 0) ? kInAnswerSection : kInAdditionalSection);
-        AdvanceTime(1);
+void HandleSrvResultAlternate(otInstance *aInstance, const otMdnsSrvResult *aResult)
+{
+    Log("Alternate SRV callback is called");
+    HandleSrvResult(aInstance, aResult);
+}
 
-        VerifyOrQuit(sRegCallbacks[0].mWasCalled);
-        VerifyOrQuit(sRegCallbacks[0].mError == kErrorDuplicated);
+void HandleTxtResult(otInstance *aInstance, const otMdnsTxtResult *aResult)
+{
+    TxtCallback *entry;
 
-        VerifyOrQuit(!sConflictCallback.mWasCalled);
+    VerifyOrQuit(aInstance == sInstance);
+    VerifyOrQuit(aResult != nullptr);
+    VerifyOrQuit(aResult->mServiceInstance != nullptr);
+    VerifyOrQuit(aResult->mServiceType != nullptr);
+    VerifyOrQuit(aResult->mInfraIfIndex == kInfraIfIndex);
 
-        sDnsMessages.Clear();
+    VerifyOrQuit(aResult->mTxtDataLength <= TxtCallback::kMaxTxtDataLength);
 
-        SuccessOrQuit(mdns->UnregisterHost(host));
+    if (aResult->mTtl != 0)
+    {
+        VerifyOrQuit(aResult->mTxtData != nullptr);
 
-        AdvanceTime(15000);
-        VerifyOrQuit(sDnsMessages.IsEmpty());
+        Log("TXT callback: %s %s, len:%u, ttl:%lu", aResult->mServiceInstance, aResult->mServiceType,
+            aResult->mTxtDataLength, ToUlong(aResult->mTtl));
+    }
+    else
+    {
+        Log("TXT callback: %s %s, ttl:%lu", aResult->mServiceInstance, aResult->mServiceType, ToUlong(aResult->mTtl));
     }
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Register a `HostEntry` and respond to probe to trigger conflict");
-
-    sRegCallbacks[0].Reset();
-    SuccessOrQuit(mdns->RegisterHost(host, 0, HandleCallback));
-
-    VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+    entry = TxtCallback::Allocate();
+    VerifyOrQuit(entry != nullptr);
 
-    SendResponseWithEmptyKey(hostFullName.AsCString(), kInAnswerSection);
-    AdvanceTime(1);
+    entry->mServiceInstance.CopyFrom(aResult->mServiceInstance);
+    entry->mServiceType.CopyFrom(aResult->mServiceType);
+    entry->mTxtDataLength = aResult->mTxtDataLength;
+    memcpy(entry->mTxtData, aResult->mTxtData, aResult->mTxtDataLength);
+    entry->mTtl = aResult->mTtl;
 
-    VerifyOrQuit(sRegCallbacks[0].mWasCalled);
-    VerifyOrQuit(sRegCallbacks[0].mError == kErrorDuplicated);
-    VerifyOrQuit(!sConflictCallback.mWasCalled);
+    sTxtCallbacks.PushAfterTail(*entry);
+}
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Register the conflicted `HostEntry` again, and make sure no probes are sent");
+void HandleTxtResultAlternate(otInstance *aInstance, const otMdnsTxtResult *aResult)
+{
+    Log("Alternate TXT callback is called");
+    HandleTxtResult(aInstance, aResult);
+}
 
-    sRegCallbacks[1].Reset();
-    sConflictCallback.Reset();
-    sDnsMessages.Clear();
+void HandleAddrResult(otInstance *aInstance, const otMdnsAddressResult *aResult)
+{
+    AddrCallback *entry;
 
-    SuccessOrQuit(mdns->RegisterHost(host, 1, HandleCallback));
-    AdvanceTime(5000);
+    VerifyOrQuit(aInstance == sInstance);
+    VerifyOrQuit(aResult != nullptr);
+    VerifyOrQuit(aResult->mHostName != nullptr);
+    VerifyOrQuit(aResult->mInfraIfIndex == kInfraIfIndex);
 
-    VerifyOrQuit(sRegCallbacks[1].mWasCalled);
-    VerifyOrQuit(sRegCallbacks[1].mError == kErrorDuplicated);
-    VerifyOrQuit(!sConflictCallback.mWasCalled);
+    VerifyOrQuit(aResult->mAddressesLength <= AddrCallback::kMaxNumAddrs);
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Unregister the conflicted host and register it again immediately, make sure we see probes");
+    entry = AddrCallback::Allocate();
+    VerifyOrQuit(entry != nullptr);
 
-    SuccessOrQuit(mdns->UnregisterHost(host));
+    entry->mHostName.CopyFrom(aResult->mHostName);
+    entry->mNumAddrs = aResult->mAddressesLength;
 
-    sConflictCallback.Reset();
-    sRegCallbacks[0].Reset();
-    SuccessOrQuit(mdns->RegisterHost(host, 0, HandleSuccessCallback));
+    Log("Addr callback: %s, num:%u", aResult->mHostName, aResult->mAddressesLength);
 
-    for (uint8_t probeCount = 0; probeCount < 3; probeCount++)
+    for (uint16_t index = 0; index < aResult->mAddressesLength; index++)
     {
-        sDnsMessages.Clear();
-
-        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
-        AdvanceTime(250);
+        entry->mAddrAndTtls[index].mAddress = AsCoreType(&aResult->mAddresses[index].mAddress);
+        entry->mAddrAndTtls[index].mTtl     = aResult->mAddresses[index].mTtl;
 
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
-        dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
-        dnsMsg->ValidateAsProbeFor(host, /* aUnicastRequest */ (probeCount == 0));
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        Log(" - %s, ttl:%lu", entry->mAddrAndTtls[index].mAddress.ToString().AsCString(),
+            ToUlong(entry->mAddrAndTtls[index].mTtl));
     }
 
-    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
-    {
-        sDnsMessages.Clear();
+    sAddrCallbacks.PushAfterTail(*entry);
+}
 
-        AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
-        VerifyOrQuit(sRegCallbacks[0].mWasCalled);
+void HandleAddrResultAlternate(otInstance *aInstance, const otMdnsAddressResult *aResult)
+{
+    Log("Alternate addr callback is called");
+    HandleAddrResult(aInstance, aResult);
+}
 
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
-        dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 2, /* Auth */ 0, /* Addnl */ 1);
-        dnsMsg->Validate(host, kInAnswerSection);
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
-    }
+void HandleRecordResult(otInstance *aInstance, const otMdnsRecordResult *aResult)
+{
+    RecordCallback *entry;
 
-    VerifyOrQuit(!sConflictCallback.mWasCalled);
+    VerifyOrQuit(aInstance == sInstance);
+    VerifyOrQuit(aResult != nullptr);
+    VerifyOrQuit(aResult->mFirstLabel != nullptr);
+    VerifyOrQuit(aResult->mRecordData != nullptr);
+    VerifyOrQuit(aResult->mInfraIfIndex == kInfraIfIndex);
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a response for host name and validate that conflict is detected and callback is called");
+    VerifyOrQuit(aResult->mRecordDataLength <= RecordCallback::kMaxRecordDataLength);
 
-    SendResponseWithEmptyKey(hostFullName.AsCString(), kInAnswerSection);
-    AdvanceTime(1);
+    Log("Record callback: %s %s type:%u -> rlen:%u ttl:%lu", aResult->mFirstLabel,
+        (aResult->mNextLabels != nullptr) ? aResult->mNextLabels : "(null)", aResult->mRecordType,
+        aResult->mRecordDataLength, ToUlong(aResult->mTtl));
 
-    VerifyOrQuit(sConflictCallback.mWasCalled);
-    VerifyOrQuit(StringMatch(sConflictCallback.mName.AsCString(), host.mHostName, kStringCaseInsensitiveMatch));
-    VerifyOrQuit(!sConflictCallback.mHasServiceType);
+    entry = RecordCallback::Allocate();
+    VerifyOrQuit(entry != nullptr);
 
-    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
-    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
+    entry->mFirstLabel.CopyFrom(aResult->mFirstLabel);
+    entry->mNextLabels.CopyFrom(aResult->mNextLabels);
+    entry->mRecordType       = aResult->mRecordType;
+    entry->mRecordDataLength = aResult->mRecordDataLength;
+    memcpy(entry->mRecordData, aResult->mRecordData, aResult->mRecordDataLength);
+    entry->mTtl = aResult->mTtl;
 
-    Log("End of test");
+    sRecordCallbacks.PushAfterTail(*entry);
+}
 
-    testFreeInstance(sInstance);
+void HandleRecordResultAlternate(otInstance *aInstance, const otMdnsRecordResult *aResult)
+{
+    Log("Alternate record callback is called");
+    HandleRecordResult(aInstance, aResult);
 }
 
 //---------------------------------------------------------------------------------------------------------------------
 
-void TestServiceConflict(void)
+void TestBrowser(void)
 {
-    Core             *mdns = InitTest();
-    Core::Service     service;
-    const DnsMessage *dnsMsg;
-    uint16_t          heapAllocations;
-    DnsNameString     fullServiceName;
+    Core                 *mdns = InitTest();
+    Core::Browser         browser;
+    Core::Browser         browser2;
+    const DnsMessage     *dnsMsg;
+    const BrowseCallback *browseCallback;
+    uint16_t              heapAllocations;
 
     Log("-------------------------------------------------------------------------------------------");
-    Log("TestServiceConflict");
-
-    service.mHostName            = "myhost";
-    service.mServiceInstance     = "myservice";
-    service.mServiceType         = "_srv._udp";
-    service.mSubTypeLabels       = nullptr;
-    service.mSubTypeLabelsLength = 0;
-    service.mTxtData             = kTxtData1;
-    service.mTxtDataLength       = sizeof(kTxtData1);
-    service.mPort                = 1234;
-    service.mPriority            = 1;
-    service.mWeight              = 2;
-    service.mTtl                 = 1000;
-
-    fullServiceName.Append("%s.%s.local.", service.mServiceInstance, service.mServiceType);
+    Log("TestBrowser");
 
     AdvanceTime(1);
 
     heapAllocations = sHeapAllocatedPtrs.GetLength();
     SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
 
-    // Run the test twice, first run send response with record in Answer section,
-    // section run in Additional Data section.
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Start a browser. Validate initial queries.");
 
-    sConflictCallback.Reset();
-    mdns->SetConflictCallback(HandleConflict);
+    ClearAllBytes(browser);
 
-    for (uint8_t iter = 0; iter < 2; iter++)
-    {
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Register a `ServiceEntry`, wait for first probe");
+    browser.mServiceType  = "_srv._udp";
+    browser.mSubTypeLabel = nullptr;
+    browser.mInfraIfIndex = kInfraIfIndex;
+    browser.mCallback     = HandleBrowseResult;
 
-        sDnsMessages.Clear();
+    sDnsMessages.Clear();
+    SuccessOrQuit(mdns->StartBrowser(browser));
 
-        sRegCallbacks[0].Reset();
-        SuccessOrQuit(mdns->RegisterService(service, 0, HandleCallback));
+    for (uint8_t queryCount = 0; queryCount < kNumInitalQueries; queryCount++)
+    {
+        sDnsMessages.Clear();
 
-        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
-        AdvanceTime(250);
+        AdvanceTime((queryCount == 0) ? 125 : (1U << (queryCount - 1)) * 1000);
 
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
-        dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ true);
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 0);
+        dnsMsg->ValidateAsQueryFor(browser);
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    }
 
-        Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-        Log("Send a response claiming the name with record in %s section", (iter == 0) ? "answer" : "additional");
+    sDnsMessages.Clear();
 
-        SendResponseWithEmptyKey(fullServiceName.AsCString(), (iter == 0) ? kInAnswerSection : kInAdditionalSection);
-        AdvanceTime(1);
+    AdvanceTime(20000);
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
-        VerifyOrQuit(sRegCallbacks[0].mWasCalled);
-        VerifyOrQuit(sRegCallbacks[0].mError == kErrorDuplicated);
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a response. Validate callback result.");
 
-        VerifyOrQuit(!sConflictCallback.mWasCalled);
+    sBrowseCallbacks.Clear();
 
-        sDnsMessages.Clear();
+    SendPtrResponse("_srv._udp.local.", "mysrv._srv._udp.local.", 120, kInAnswerSection);
 
-        SuccessOrQuit(mdns->UnregisterService(service));
+    AdvanceTime(1);
 
-        AdvanceTime(15000);
-        VerifyOrQuit(sDnsMessages.IsEmpty());
-    }
+    VerifyOrQuit(!sBrowseCallbacks.IsEmpty());
+    browseCallback = sBrowseCallbacks.GetHead();
+    VerifyOrQuit(browseCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(!browseCallback->mIsSubType);
+    VerifyOrQuit(browseCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(browseCallback->mTtl == 120);
+    VerifyOrQuit(browseCallback->GetNext() == nullptr);
+
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Register a `ServiceEntry` and respond to probe to trigger conflict");
+    Log("Send another response. Validate callback result.");
 
-    sRegCallbacks[0].Reset();
-    SuccessOrQuit(mdns->RegisterService(service, 0, HandleCallback));
+    AdvanceTime(10000);
 
-    VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
+    sBrowseCallbacks.Clear();
+
+    SendPtrResponse("_srv._udp.local.", "awesome._srv._udp.local.", 500, kInAnswerSection);
 
-    SendResponseWithEmptyKey(fullServiceName.AsCString(), kInAnswerSection);
     AdvanceTime(1);
 
-    VerifyOrQuit(sRegCallbacks[0].mWasCalled);
-    VerifyOrQuit(sRegCallbacks[0].mError == kErrorDuplicated);
-    VerifyOrQuit(!sConflictCallback.mWasCalled);
+    VerifyOrQuit(!sBrowseCallbacks.IsEmpty());
+    browseCallback = sBrowseCallbacks.GetHead();
+    VerifyOrQuit(browseCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(!browseCallback->mIsSubType);
+    VerifyOrQuit(browseCallback->mServiceInstance.Matches("awesome"));
+    VerifyOrQuit(browseCallback->mTtl == 500);
+    VerifyOrQuit(browseCallback->GetNext() == nullptr);
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Register the conflicted `ServiceEntry` again, and make sure no probes are sent");
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
-    sRegCallbacks[1].Reset();
-    sConflictCallback.Reset();
-    sDnsMessages.Clear();
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Start another browser for the same service and different callback. Validate results.");
 
-    SuccessOrQuit(mdns->RegisterService(service, 1, HandleCallback));
     AdvanceTime(5000);
 
-    VerifyOrQuit(sRegCallbacks[1].mWasCalled);
-    VerifyOrQuit(sRegCallbacks[1].mError == kErrorDuplicated);
-    VerifyOrQuit(!sConflictCallback.mWasCalled);
+    browser2.mServiceType  = "_srv._udp";
+    browser2.mSubTypeLabel = nullptr;
+    browser2.mInfraIfIndex = kInfraIfIndex;
+    browser2.mCallback     = HandleBrowseResultAlternate;
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Unregister the conflicted host and register it again immediately, make sure we see probes");
+    sBrowseCallbacks.Clear();
 
-    SuccessOrQuit(mdns->UnregisterService(service));
+    SuccessOrQuit(mdns->StartBrowser(browser2));
 
-    sConflictCallback.Reset();
-    sRegCallbacks[0].Reset();
-    SuccessOrQuit(mdns->RegisterService(service, 0, HandleSuccessCallback));
+    browseCallback = sBrowseCallbacks.GetHead();
 
-    for (uint8_t probeCount = 0; probeCount < 3; probeCount++)
+    for (uint8_t iter = 0; iter < 2; iter++)
     {
-        sDnsMessages.Clear();
+        VerifyOrQuit(browseCallback != nullptr);
 
-        VerifyOrQuit(!sRegCallbacks[0].mWasCalled);
-        AdvanceTime(250);
+        VerifyOrQuit(browseCallback->mServiceType.Matches("_srv._udp"));
+        VerifyOrQuit(!browseCallback->mIsSubType);
 
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
-        dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 2, /* Addnl */ 0);
-        dnsMsg->ValidateAsProbeFor(service, /* aUnicastRequest */ (probeCount == 0));
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        if (browseCallback->mServiceInstance.Matches("awesome"))
+        {
+            VerifyOrQuit(browseCallback->mTtl == 500);
+        }
+        else if (browseCallback->mServiceInstance.Matches("mysrv"))
+        {
+            VerifyOrQuit(browseCallback->mTtl == 120);
+        }
+        else
+        {
+            VerifyOrQuit(false);
+        }
+
+        browseCallback = browseCallback->GetNext();
     }
 
-    for (uint8_t anncCount = 0; anncCount < kNumAnnounces; anncCount++)
+    VerifyOrQuit(browseCallback == nullptr);
+
+    AdvanceTime(5000);
+
+    VerifyOrQuit(sDnsMessages.IsEmpty());
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Start same browser again and check the returned error.");
+
+    sBrowseCallbacks.Clear();
+
+    VerifyOrQuit(mdns->StartBrowser(browser2) == kErrorAlready);
+
+    AdvanceTime(5000);
+
+    VerifyOrQuit(sBrowseCallbacks.IsEmpty());
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a goodbye response. Validate result callback for both browsers.");
+
+    SendPtrResponse("_srv._udp.local.", "awesome._srv._udp.local.", 0, kInAnswerSection);
+
+    AdvanceTime(1);
+
+    browseCallback = sBrowseCallbacks.GetHead();
+
+    for (uint8_t iter = 0; iter < 2; iter++)
     {
-        sDnsMessages.Clear();
+        VerifyOrQuit(browseCallback != nullptr);
 
-        AdvanceTime((anncCount == 0) ? 250 : (1U << (anncCount - 1)) * 1000);
-        VerifyOrQuit(sRegCallbacks[0].mWasCalled);
+        VerifyOrQuit(browseCallback->mServiceType.Matches("_srv._udp"));
+        VerifyOrQuit(!browseCallback->mIsSubType);
+        VerifyOrQuit(browseCallback->mServiceInstance.Matches("awesome"));
+        VerifyOrQuit(browseCallback->mTtl == 0);
 
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
-        dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastResponse, /* Q */ 0, /* Ans */ 4, /* Auth */ 0, /* Addnl */ 1);
-        dnsMsg->Validate(service, kInAnswerSection, kCheckSrv | kCheckTxt | kCheckPtr | kCheckServicesPtr);
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+        browseCallback = browseCallback->GetNext();
     }
 
-    VerifyOrQuit(!sConflictCallback.mWasCalled);
+    VerifyOrQuit(browseCallback == nullptr);
+
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a response for service name and validate that conflict is detected and callback is called");
+    Log("Send a response with no changes, validate that no callback is invoked.");
+
+    sBrowseCallbacks.Clear();
+
+    SendPtrResponse("_srv._udp.local.", "mysrv._srv._udp.local.", 120, kInAnswerSection);
 
-    SendResponseWithEmptyKey(fullServiceName.AsCString(), kInAnswerSection);
     AdvanceTime(1);
 
-    VerifyOrQuit(sConflictCallback.mWasCalled);
-    VerifyOrQuit(
-        StringMatch(sConflictCallback.mName.AsCString(), service.mServiceInstance, kStringCaseInsensitiveMatch));
-    VerifyOrQuit(sConflictCallback.mHasServiceType);
-    VerifyOrQuit(
-        StringMatch(sConflictCallback.mServiceType.AsCString(), service.mServiceType, kStringCaseInsensitiveMatch));
+    VerifyOrQuit(sBrowseCallbacks.IsEmpty());
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
-    sDnsMessages.Clear();
-    AdvanceTime(20000);
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Stop the second browser.");
+
+    sBrowseCallbacks.Clear();
+
+    SuccessOrQuit(mdns->StopBrowser(browser2));
+
+    AdvanceTime(5000);
+
+    VerifyOrQuit(sBrowseCallbacks.IsEmpty());
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
-    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
-    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Check query is sent at 80 percentage of TTL and then respond to it.");
 
-    Log("End of test");
+    // First query should be sent at 80-82% of TTL of 120 second (96.0-98.4 sec).
+    // We wait for 100 second. Note that 5 seconds already passed in the
+    // previous step.
 
-    testFreeInstance(sInstance);
-}
+    AdvanceTime(91 * 1000 - 1);
 
-//=====================================================================================================================
-// Browser/Resolver tests
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
-struct BrowseCallback : public Allocatable<BrowseCallback>, public LinkedListEntry<BrowseCallback>
-{
-    BrowseCallback *mNext;
-    DnsName         mServiceType;
-    DnsName         mSubTypeLabel;
-    DnsName         mServiceInstance;
-    uint32_t        mTtl;
-    bool            mIsSubType;
-};
+    AdvanceTime(4 * 1000 + 1);
 
-struct SrvCallback : public Allocatable<SrvCallback>, public LinkedListEntry<SrvCallback>
-{
-    SrvCallback *mNext;
-    DnsName      mServiceInstance;
-    DnsName      mServiceType;
-    DnsName      mHostName;
-    uint16_t     mPort;
-    uint16_t     mPriority;
-    uint16_t     mWeight;
-    uint32_t     mTtl;
-};
+    VerifyOrQuit(!sDnsMessages.IsEmpty());
+    dnsMsg = sDnsMessages.GetHead();
+    dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 0);
+    dnsMsg->ValidateAsQueryFor(browser);
+    VerifyOrQuit(dnsMsg->GetNext() == nullptr);
 
-struct TxtCallback : public Allocatable<TxtCallback>, public LinkedListEntry<TxtCallback>
-{
-    static constexpr uint16_t kMaxTxtDataLength = 100;
+    sDnsMessages.Clear();
+    VerifyOrQuit(sBrowseCallbacks.IsEmpty());
 
-    template <uint16_t kSize> bool Matches(const uint8_t (&aData)[kSize]) const
-    {
-        return (mTxtDataLength == kSize) && (memcmp(mTxtData, aData, kSize) == 0);
-    }
+    AdvanceTime(10);
 
-    TxtCallback *mNext;
-    DnsName      mServiceInstance;
-    DnsName      mServiceType;
-    uint8_t      mTxtData[kMaxTxtDataLength];
-    uint16_t     mTxtDataLength;
-    uint32_t     mTtl;
-};
+    SendPtrResponse("_srv._udp.local.", "mysrv._srv._udp.local.", 120, kInAnswerSection);
 
-struct AddrCallback : public Allocatable<AddrCallback>, public LinkedListEntry<AddrCallback>
-{
-    static constexpr uint16_t kMaxNumAddrs = 16;
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Check queries are sent at 80, 85, 90, 95 percentages of TTL.");
 
-    bool Contains(const AddrAndTtl &aAddrAndTtl) const
+    for (uint8_t queryCount = 0; queryCount < kNumRefreshQueries; queryCount++)
     {
-        bool contains = false;
+        if (queryCount == 0)
+        {
+            // First query is expected in 80-82% of TTL, so
+            // 80% of 120 = 96.0, 82% of 120 = 98.4
 
-        for (uint16_t index = 0; index < mNumAddrs; index++)
+            AdvanceTime(96 * 1000 - 1);
+        }
+        else
         {
-            if (mAddrAndTtls[index] == aAddrAndTtl)
-            {
-                contains = true;
-                break;
-            }
+            // Next query should happen within 3%-5% of TTL
+            // from previous query. We wait 3% of TTL here.
+            AdvanceTime(3600 - 1);
         }
 
-        return contains;
-    }
+        VerifyOrQuit(sDnsMessages.IsEmpty());
 
-    bool Matches(const AddrAndTtl *aAddrAndTtls, uint16_t aNumAddrs) const
-    {
-        bool matches = true;
+        // Wait for 2% of TTL of 120 which is 2.4 sec.
 
-        VerifyOrExit(aNumAddrs == mNumAddrs, matches = false);
+        AdvanceTime(2400 + 1);
 
-        for (uint16_t index = 0; index < mNumAddrs; index++)
-        {
-            if (!Contains(aAddrAndTtls[index]))
-            {
-                ExitNow(matches = false);
-            }
-        }
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 0);
+        dnsMsg->ValidateAsQueryFor(browser);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
 
-    exit:
-        return matches;
+        sDnsMessages.Clear();
+        VerifyOrQuit(sBrowseCallbacks.IsEmpty());
     }
 
-    AddrCallback *mNext;
-    DnsName       mHostName;
-    AddrAndTtl    mAddrAndTtls[kMaxNumAddrs];
-    uint16_t      mNumAddrs;
-};
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Check TTL timeout and callback result.");
 
-OwningList<BrowseCallback> sBrowseCallbacks;
-OwningList<SrvCallback>    sSrvCallbacks;
-OwningList<TxtCallback>    sTxtCallbacks;
-OwningList<AddrCallback>   sAddrCallbacks;
+    AdvanceTime(6 * 1000);
 
-void HandleBrowseResult(otInstance *aInstance, const otMdnsBrowseResult *aResult)
-{
-    BrowseCallback *entry;
+    VerifyOrQuit(!sBrowseCallbacks.IsEmpty());
 
-    VerifyOrQuit(aInstance == sInstance);
-    VerifyOrQuit(aResult != nullptr);
-    VerifyOrQuit(aResult->mServiceType != nullptr);
-    VerifyOrQuit(aResult->mServiceInstance != nullptr);
-    VerifyOrQuit(aResult->mInfraIfIndex == kInfraIfIndex);
+    browseCallback = sBrowseCallbacks.GetHead();
+    VerifyOrQuit(browseCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(!browseCallback->mIsSubType);
+    VerifyOrQuit(browseCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(browseCallback->mTtl == 0);
+    VerifyOrQuit(browseCallback->GetNext() == nullptr);
 
-    Log("Browse callback: %s (subtype:%s) -> %s ttl:%lu", aResult->mServiceType,
-        aResult->mSubTypeLabel == nullptr ? "(null)" : aResult->mSubTypeLabel, aResult->mServiceInstance,
-        ToUlong(aResult->mTtl));
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
 
-    entry = BrowseCallback::Allocate();
-    VerifyOrQuit(entry != nullptr);
+    sBrowseCallbacks.Clear();
+    sDnsMessages.Clear();
 
-    entry->mServiceType.CopyFrom(aResult->mServiceType);
-    entry->mSubTypeLabel.CopyFrom(aResult->mSubTypeLabel);
-    entry->mServiceInstance.CopyFrom(aResult->mServiceInstance);
-    entry->mTtl       = aResult->mTtl;
-    entry->mIsSubType = (aResult->mSubTypeLabel != nullptr);
+    AdvanceTime(200 * 1000);
 
-    sBrowseCallbacks.PushAfterTail(*entry);
-}
+    VerifyOrQuit(sBrowseCallbacks.IsEmpty());
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
-void HandleBrowseResultAlternate(otInstance *aInstance, const otMdnsBrowseResult *aResult)
-{
-    Log("Alternate browse callback is called");
-    HandleBrowseResult(aInstance, aResult);
-}
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a new response and make sure result callback is invoked");
 
-void HandleSrvResult(otInstance *aInstance, const otMdnsSrvResult *aResult)
-{
-    SrvCallback *entry;
+    SendPtrResponse("_srv._udp.local.", "great._srv._udp.local.", 200, kInAdditionalSection);
 
-    VerifyOrQuit(aInstance == sInstance);
-    VerifyOrQuit(aResult != nullptr);
-    VerifyOrQuit(aResult->mServiceInstance != nullptr);
-    VerifyOrQuit(aResult->mServiceType != nullptr);
-    VerifyOrQuit(aResult->mInfraIfIndex == kInfraIfIndex);
+    AdvanceTime(1);
 
-    if (aResult->mTtl != 0)
-    {
-        VerifyOrQuit(aResult->mHostName != nullptr);
+    browseCallback = sBrowseCallbacks.GetHead();
 
-        Log("SRV callback: %s %s, host:%s port:%u, prio:%u, weight:%u, ttl:%lu", aResult->mServiceInstance,
-            aResult->mServiceType, aResult->mHostName, aResult->mPort, aResult->mPriority, aResult->mWeight,
-            ToUlong(aResult->mTtl));
-    }
-    else
-    {
-        Log("SRV callback: %s %s, ttl:%lu", aResult->mServiceInstance, aResult->mServiceType, ToUlong(aResult->mTtl));
-    }
+    VerifyOrQuit(browseCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(!browseCallback->mIsSubType);
+    VerifyOrQuit(browseCallback->mServiceInstance.Matches("great"));
+    VerifyOrQuit(browseCallback->mTtl == 200);
+    VerifyOrQuit(browseCallback->GetNext() == nullptr);
 
-    entry = SrvCallback::Allocate();
-    VerifyOrQuit(entry != nullptr);
+    sBrowseCallbacks.Clear();
 
-    entry->mServiceInstance.CopyFrom(aResult->mServiceInstance);
-    entry->mServiceType.CopyFrom(aResult->mServiceType);
-    entry->mHostName.CopyFrom(aResult->mHostName);
-    entry->mPort     = aResult->mPort;
-    entry->mPriority = aResult->mPriority;
-    entry->mWeight   = aResult->mWeight;
-    entry->mTtl      = aResult->mTtl;
+    AdvanceTime(150 * 1000);
 
-    sSrvCallbacks.PushAfterTail(*entry);
-}
+    VerifyOrQuit(sDnsMessages.IsEmpty());
+    VerifyOrQuit(sBrowseCallbacks.IsEmpty());
 
-void HandleSrvResultAlternate(otInstance *aInstance, const otMdnsSrvResult *aResult)
-{
-    Log("Alternate SRV callback is called");
-    HandleSrvResult(aInstance, aResult);
-}
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Stop the browser. There is no active browser for this service. Ensure no queries are sent");
 
-void HandleTxtResult(otInstance *aInstance, const otMdnsTxtResult *aResult)
-{
-    TxtCallback *entry;
+    sBrowseCallbacks.Clear();
 
-    VerifyOrQuit(aInstance == sInstance);
-    VerifyOrQuit(aResult != nullptr);
-    VerifyOrQuit(aResult->mServiceInstance != nullptr);
-    VerifyOrQuit(aResult->mServiceType != nullptr);
-    VerifyOrQuit(aResult->mInfraIfIndex == kInfraIfIndex);
+    SuccessOrQuit(mdns->StopBrowser(browser));
 
-    VerifyOrQuit(aResult->mTxtDataLength <= TxtCallback::kMaxTxtDataLength);
+    AdvanceTime(100 * 1000);
 
-    if (aResult->mTtl != 0)
-    {
-        VerifyOrQuit(aResult->mTxtData != nullptr);
+    VerifyOrQuit(sBrowseCallbacks.IsEmpty());
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
-        Log("TXT callback: %s %s, len:%u, ttl:%lu", aResult->mServiceInstance, aResult->mServiceType,
-            aResult->mTxtDataLength, ToUlong(aResult->mTtl));
-    }
-    else
-    {
-        Log("TXT callback: %s %s, ttl:%lu", aResult->mServiceInstance, aResult->mServiceType, ToUlong(aResult->mTtl));
-    }
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Start browser again. Validate that initial queries are sent again");
 
-    entry = TxtCallback::Allocate();
-    VerifyOrQuit(entry != nullptr);
+    SuccessOrQuit(mdns->StartBrowser(browser));
 
-    entry->mServiceInstance.CopyFrom(aResult->mServiceInstance);
-    entry->mServiceType.CopyFrom(aResult->mServiceType);
-    entry->mTxtDataLength = aResult->mTxtDataLength;
-    memcpy(entry->mTxtData, aResult->mTxtData, aResult->mTxtDataLength);
-    entry->mTtl = aResult->mTtl;
+    AdvanceTime(125);
 
-    sTxtCallbacks.PushAfterTail(*entry);
-}
+    VerifyOrQuit(!sDnsMessages.IsEmpty());
+    dnsMsg = sDnsMessages.GetHead();
+    dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 0);
+    dnsMsg->ValidateAsQueryFor(browser);
+    VerifyOrQuit(dnsMsg->GetNext() == nullptr);
 
-void HandleTxtResultAlternate(otInstance *aInstance, const otMdnsTxtResult *aResult)
-{
-    Log("Alternate TXT callback is called");
-    HandleTxtResult(aInstance, aResult);
-}
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a response after the first initial query");
 
-void HandleAddrResult(otInstance *aInstance, const otMdnsAddressResult *aResult)
-{
-    AddrCallback *entry;
+    sDnsMessages.Clear();
 
-    VerifyOrQuit(aInstance == sInstance);
-    VerifyOrQuit(aResult != nullptr);
-    VerifyOrQuit(aResult->mHostName != nullptr);
-    VerifyOrQuit(aResult->mInfraIfIndex == kInfraIfIndex);
+    SendPtrResponse("_srv._udp.local.", "mysrv._srv._udp.local.", 120, kInAnswerSection);
 
-    VerifyOrQuit(aResult->mAddressesLength <= AddrCallback::kMaxNumAddrs);
+    AdvanceTime(1);
 
-    entry = AddrCallback::Allocate();
-    VerifyOrQuit(entry != nullptr);
+    browseCallback = sBrowseCallbacks.GetHead();
 
-    entry->mHostName.CopyFrom(aResult->mHostName);
-    entry->mNumAddrs = aResult->mAddressesLength;
+    VerifyOrQuit(browseCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(!browseCallback->mIsSubType);
+    VerifyOrQuit(browseCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(browseCallback->mTtl == 120);
+    VerifyOrQuit(browseCallback->GetNext() == nullptr);
 
-    Log("Addr callback: %s, num:%u", aResult->mHostName, aResult->mAddressesLength);
+    sBrowseCallbacks.Clear();
 
-    for (uint16_t index = 0; index < aResult->mAddressesLength; index++)
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Validate initial esquires are still sent and include known-answer");
+
+    for (uint8_t queryCount = 1; queryCount < kNumInitalQueries; queryCount++)
     {
-        entry->mAddrAndTtls[index].mAddress = AsCoreType(&aResult->mAddresses[index].mAddress);
-        entry->mAddrAndTtls[index].mTtl     = aResult->mAddresses[index].mTtl;
+        sDnsMessages.Clear();
 
-        Log(" - %s, ttl:%lu", entry->mAddrAndTtls[index].mAddress.ToString().AsCString(),
-            ToUlong(entry->mAddrAndTtls[index].mTtl));
+        AdvanceTime((1U << (queryCount - 1)) * 1000);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 0);
+        dnsMsg->ValidateAsQueryFor(browser);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
     }
 
-    sAddrCallbacks.PushAfterTail(*entry);
-}
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
 
-void HandleAddrResultAlternate(otInstance *aInstance, const otMdnsAddressResult *aResult)
-{
-    Log("Alternate addr callback is called");
-    HandleAddrResult(aInstance, aResult);
-}
+    sDnsMessages.Clear();
+    AdvanceTime(50 * 1000);
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
-//---------------------------------------------------------------------------------------------------------------------
+    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
+    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
 
-void TestBrowser(void)
+    Log("End of test");
+
+    testFreeInstance(sInstance);
+}
+
+void TestSrvResolver(void)
 {
-    Core                 *mdns = InitTest();
-    Core::Browser         browser;
-    Core::Browser         browser2;
-    const DnsMessage     *dnsMsg;
-    const BrowseCallback *browseCallback;
-    uint16_t              heapAllocations;
+    Core              *mdns = InitTest();
+    Core::SrvResolver  resolver;
+    Core::SrvResolver  resolver2;
+    const DnsMessage  *dnsMsg;
+    const SrvCallback *srvCallback;
+    uint16_t           heapAllocations;
 
     Log("-------------------------------------------------------------------------------------------");
-    Log("TestBrowser");
+    Log("TestSrvResolver");
 
     AdvanceTime(1);
 
@@ -5027,17 +6228,17 @@ void TestBrowser(void)
     SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Start a browser. Validate initial queries.");
+    Log("Start a SRV resolver. Validate initial queries.");
 
-    ClearAllBytes(browser);
+    ClearAllBytes(resolver);
 
-    browser.mServiceType  = "_srv._udp";
-    browser.mSubTypeLabel = nullptr;
-    browser.mInfraIfIndex = kInfraIfIndex;
-    browser.mCallback     = HandleBrowseResult;
+    resolver.mServiceInstance = "mysrv";
+    resolver.mServiceType     = "_srv._udp";
+    resolver.mInfraIfIndex    = kInfraIfIndex;
+    resolver.mCallback        = HandleSrvResult;
 
     sDnsMessages.Clear();
-    SuccessOrQuit(mdns->StartBrowser(browser));
+    SuccessOrQuit(mdns->StartSrvResolver(resolver));
 
     for (uint8_t queryCount = 0; queryCount < kNumInitalQueries; queryCount++)
     {
@@ -5048,168 +6249,197 @@ void TestBrowser(void)
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
         dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 0);
-        dnsMsg->ValidateAsQueryFor(browser);
+        dnsMsg->ValidateAsQueryFor(resolver);
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
     }
 
     sDnsMessages.Clear();
 
-    AdvanceTime(20000);
+    AdvanceTime(20 * 1000);
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Send a response. Validate callback result.");
 
-    sBrowseCallbacks.Clear();
+    sSrvCallbacks.Clear();
 
-    SendPtrResponse("_srv._udp.local.", "mysrv._srv._udp.local.", 120, kInAnswerSection);
+    SendSrvResponse("mysrv._srv._udp.local.", "myhost.local.", 1234, 0, 1, 120, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sBrowseCallbacks.IsEmpty());
-    browseCallback = sBrowseCallbacks.GetHead();
-    VerifyOrQuit(browseCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(!browseCallback->mIsSubType);
-    VerifyOrQuit(browseCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(browseCallback->mTtl == 120);
-    VerifyOrQuit(browseCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
+    srvCallback = sSrvCallbacks.GetHead();
+    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(srvCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(srvCallback->mPort == 1234);
+    VerifyOrQuit(srvCallback->mPriority == 0);
+    VerifyOrQuit(srvCallback->mWeight == 1);
+    VerifyOrQuit(srvCallback->mTtl == 120);
+    VerifyOrQuit(srvCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send another response. Validate callback result.");
+    Log("Send an updated response changing host name. Validate callback result.");
 
-    AdvanceTime(10000);
+    AdvanceTime(1000);
 
-    sBrowseCallbacks.Clear();
+    sSrvCallbacks.Clear();
 
-    SendPtrResponse("_srv._udp.local.", "awesome._srv._udp.local.", 500, kInAnswerSection);
+    SendSrvResponse("mysrv._srv._udp.local.", "myhost2.local.", 1234, 0, 1, 120, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sBrowseCallbacks.IsEmpty());
-    browseCallback = sBrowseCallbacks.GetHead();
-    VerifyOrQuit(browseCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(!browseCallback->mIsSubType);
-    VerifyOrQuit(browseCallback->mServiceInstance.Matches("awesome"));
-    VerifyOrQuit(browseCallback->mTtl == 500);
-    VerifyOrQuit(browseCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
+    srvCallback = sSrvCallbacks.GetHead();
+    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(srvCallback->mHostName.Matches("myhost2"));
+    VerifyOrQuit(srvCallback->mPort == 1234);
+    VerifyOrQuit(srvCallback->mPriority == 0);
+    VerifyOrQuit(srvCallback->mWeight == 1);
+    VerifyOrQuit(srvCallback->mTtl == 120);
+    VerifyOrQuit(srvCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Start another browser for the same service and different callback. Validate results.");
+    Log("Send an updated response changing port. Validate callback result.");
 
-    AdvanceTime(5000);
+    AdvanceTime(1000);
 
-    browser2.mServiceType  = "_srv._udp";
-    browser2.mSubTypeLabel = nullptr;
-    browser2.mInfraIfIndex = kInfraIfIndex;
-    browser2.mCallback     = HandleBrowseResultAlternate;
+    sSrvCallbacks.Clear();
 
-    sBrowseCallbacks.Clear();
+    SendSrvResponse("mysrv._srv._udp.local.", "myhost2.local.", 4567, 0, 1, 120, kInAnswerSection);
 
-    SuccessOrQuit(mdns->StartBrowser(browser2));
+    AdvanceTime(1);
 
-    browseCallback = sBrowseCallbacks.GetHead();
+    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
+    srvCallback = sSrvCallbacks.GetHead();
+    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(srvCallback->mHostName.Matches("myhost2"));
+    VerifyOrQuit(srvCallback->mPort == 4567);
+    VerifyOrQuit(srvCallback->mPriority == 0);
+    VerifyOrQuit(srvCallback->mWeight == 1);
+    VerifyOrQuit(srvCallback->mTtl == 120);
+    VerifyOrQuit(srvCallback->GetNext() == nullptr);
 
-    for (uint8_t iter = 0; iter < 2; iter++)
-    {
-        VerifyOrQuit(browseCallback != nullptr);
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
-        VerifyOrQuit(browseCallback->mServiceType.Matches("_srv._udp"));
-        VerifyOrQuit(!browseCallback->mIsSubType);
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send an updated response changing TTL. Validate callback result.");
 
-        if (browseCallback->mServiceInstance.Matches("awesome"))
-        {
-            VerifyOrQuit(browseCallback->mTtl == 500);
-        }
-        else if (browseCallback->mServiceInstance.Matches("mysrv"))
-        {
-            VerifyOrQuit(browseCallback->mTtl == 120);
-        }
-        else
-        {
-            VerifyOrQuit(false);
-        }
+    AdvanceTime(1000);
 
-        browseCallback = browseCallback->GetNext();
-    }
+    sSrvCallbacks.Clear();
 
-    VerifyOrQuit(browseCallback == nullptr);
+    SendSrvResponse("mysrv._srv._udp.local.", "myhost2.local.", 4567, 0, 1, 0, kInAnswerSection);
 
-    AdvanceTime(5000);
+    AdvanceTime(1);
+
+    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
+    srvCallback = sSrvCallbacks.GetHead();
+    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(srvCallback->mHostName.Matches(""));
+    VerifyOrQuit(srvCallback->mPort == 4567);
+    VerifyOrQuit(srvCallback->mPriority == 0);
+    VerifyOrQuit(srvCallback->mWeight == 1);
+    VerifyOrQuit(srvCallback->mTtl == 0);
+    VerifyOrQuit(srvCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Start same browser again and check the returned error.");
-
-    sBrowseCallbacks.Clear();
+    Log("Send an updated response changing a bunch of things. Validate callback result.");
 
-    VerifyOrQuit(mdns->StartBrowser(browser2) == kErrorAlready);
+    AdvanceTime(1000);
 
-    AdvanceTime(5000);
+    sSrvCallbacks.Clear();
 
-    VerifyOrQuit(sBrowseCallbacks.IsEmpty());
+    SendSrvResponse("mysrv._srv._udp.local.", "myhost.local.", 1234, 2, 3, 120, kInAnswerSection);
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a goodbye response. Validate result callback for both browsers.");
+    AdvanceTime(1);
 
-    SendPtrResponse("_srv._udp.local.", "awesome._srv._udp.local.", 0, kInAnswerSection);
+    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
+    srvCallback = sSrvCallbacks.GetHead();
+    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(srvCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(srvCallback->mPort == 1234);
+    VerifyOrQuit(srvCallback->mPriority == 2);
+    VerifyOrQuit(srvCallback->mWeight == 3);
+    VerifyOrQuit(srvCallback->mTtl == 120);
+    VerifyOrQuit(srvCallback->GetNext() == nullptr);
 
-    AdvanceTime(1);
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
-    browseCallback = sBrowseCallbacks.GetHead();
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a response with no changes. Validate callback is not invoked.");
 
-    for (uint8_t iter = 0; iter < 2; iter++)
-    {
-        VerifyOrQuit(browseCallback != nullptr);
+    AdvanceTime(1000);
 
-        VerifyOrQuit(browseCallback->mServiceType.Matches("_srv._udp"));
-        VerifyOrQuit(!browseCallback->mIsSubType);
-        VerifyOrQuit(browseCallback->mServiceInstance.Matches("awesome"));
-        VerifyOrQuit(browseCallback->mTtl == 0);
+    sSrvCallbacks.Clear();
 
-        browseCallback = browseCallback->GetNext();
-    }
+    SendSrvResponse("mysrv._srv._udp.local.", "myhost.local.", 1234, 2, 3, 120, kInAnswerSection);
 
-    VerifyOrQuit(browseCallback == nullptr);
+    AdvanceTime(1);
 
+    VerifyOrQuit(sSrvCallbacks.IsEmpty());
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a response with no changes, validate that no callback is invoked.");
+    Log("Start another resolver for the same service and different callback. Validate results.");
 
-    sBrowseCallbacks.Clear();
+    ClearAllBytes(resolver2);
 
-    SendPtrResponse("_srv._udp.local.", "mysrv._srv._udp.local.", 120, kInAnswerSection);
+    resolver2.mServiceInstance = "mysrv";
+    resolver2.mServiceType     = "_srv._udp";
+    resolver2.mInfraIfIndex    = kInfraIfIndex;
+    resolver2.mCallback        = HandleSrvResultAlternate;
+
+    sSrvCallbacks.Clear();
+
+    SuccessOrQuit(mdns->StartSrvResolver(resolver2));
 
     AdvanceTime(1);
 
-    VerifyOrQuit(sBrowseCallbacks.IsEmpty());
+    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
+    srvCallback = sSrvCallbacks.GetHead();
+    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(srvCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(srvCallback->mPort == 1234);
+    VerifyOrQuit(srvCallback->mPriority == 2);
+    VerifyOrQuit(srvCallback->mWeight == 3);
+    VerifyOrQuit(srvCallback->mTtl == 120);
+    VerifyOrQuit(srvCallback->GetNext() == nullptr);
+
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Stop the second browser.");
+    Log("Start same resolver again and check the returned error.");
 
-    sBrowseCallbacks.Clear();
+    sSrvCallbacks.Clear();
 
-    SuccessOrQuit(mdns->StopBrowser(browser2));
+    VerifyOrQuit(mdns->StartSrvResolver(resolver2) == kErrorAlready);
 
     AdvanceTime(5000);
 
-    VerifyOrQuit(sBrowseCallbacks.IsEmpty());
-    VerifyOrQuit(sDnsMessages.IsEmpty());
+    VerifyOrQuit(sSrvCallbacks.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Check query is sent at 80 percentage of TTL and then respond to it.");
 
+    SendSrvResponse("mysrv._srv._udp.local.", "myhost.local.", 1234, 2, 3, 120, kInAnswerSection);
+
     // First query should be sent at 80-82% of TTL of 120 second (96.0-98.4 sec).
     // We wait for 100 second. Note that 5 seconds already passed in the
     // previous step.
 
-    AdvanceTime(91 * 1000 - 1);
+    AdvanceTime(96 * 1000 - 1);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
@@ -5218,15 +6448,15 @@ void TestBrowser(void)
     VerifyOrQuit(!sDnsMessages.IsEmpty());
     dnsMsg = sDnsMessages.GetHead();
     dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 0);
-    dnsMsg->ValidateAsQueryFor(browser);
+    dnsMsg->ValidateAsQueryFor(resolver);
     VerifyOrQuit(dnsMsg->GetNext() == nullptr);
 
     sDnsMessages.Clear();
-    VerifyOrQuit(sBrowseCallbacks.IsEmpty());
+    VerifyOrQuit(sSrvCallbacks.IsEmpty());
 
     AdvanceTime(10);
 
-    SendPtrResponse("_srv._udp.local.", "mysrv._srv._udp.local.", 120, kInAnswerSection);
+    SendSrvResponse("mysrv._srv._udp.local.", "myhost.local.", 1234, 2, 3, 120, kInAnswerSection);
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Check queries are sent at 80, 85, 90, 95 percentages of TTL.");
@@ -5256,11 +6486,11 @@ void TestBrowser(void)
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
         dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 0);
-        dnsMsg->ValidateAsQueryFor(browser);
+        dnsMsg->ValidateAsQueryFor(resolver);
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
 
         sDnsMessages.Clear();
-        VerifyOrQuit(sBrowseCallbacks.IsEmpty());
+        VerifyOrQuit(sSrvCallbacks.IsEmpty());
     }
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
@@ -5268,112 +6498,142 @@ void TestBrowser(void)
 
     AdvanceTime(6 * 1000);
 
-    VerifyOrQuit(!sBrowseCallbacks.IsEmpty());
+    srvCallback = sSrvCallbacks.GetHead();
 
-    browseCallback = sBrowseCallbacks.GetHead();
-    VerifyOrQuit(browseCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(!browseCallback->mIsSubType);
-    VerifyOrQuit(browseCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(browseCallback->mTtl == 0);
-    VerifyOrQuit(browseCallback->GetNext() == nullptr);
+    for (uint8_t iter = 0; iter < 2; iter++)
+    {
+        VerifyOrQuit(srvCallback != nullptr);
+        VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
+        VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
+        VerifyOrQuit(srvCallback->mTtl == 0);
+        srvCallback = srvCallback->GetNext();
+    }
+
+    VerifyOrQuit(srvCallback == nullptr);
+
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
 
-    sBrowseCallbacks.Clear();
+    sSrvCallbacks.Clear();
     sDnsMessages.Clear();
 
     AdvanceTime(200 * 1000);
 
-    VerifyOrQuit(sBrowseCallbacks.IsEmpty());
+    VerifyOrQuit(sSrvCallbacks.IsEmpty());
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a new response and make sure result callback is invoked");
+    Log("Stop the second resolver");
 
-    SendPtrResponse("_srv._udp.local.", "great._srv._udp.local.", 200, kInAdditionalSection);
+    sSrvCallbacks.Clear();
 
-    AdvanceTime(1);
+    SuccessOrQuit(mdns->StopSrvResolver(resolver2));
 
-    browseCallback = sBrowseCallbacks.GetHead();
+    AdvanceTime(100 * 1000);
 
-    VerifyOrQuit(browseCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(!browseCallback->mIsSubType);
-    VerifyOrQuit(browseCallback->mServiceInstance.Matches("great"));
-    VerifyOrQuit(browseCallback->mTtl == 200);
-    VerifyOrQuit(browseCallback->GetNext() == nullptr);
+    VerifyOrQuit(sSrvCallbacks.IsEmpty());
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
-    sBrowseCallbacks.Clear();
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a new response and make sure result callback is invoked");
 
-    AdvanceTime(150 * 1000);
+    SendSrvResponse("mysrv._srv._udp.local.", "myhost.local.", 1234, 2, 3, 120, kInAnswerSection);
+
+    AdvanceTime(1);
+
+    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
+    srvCallback = sSrvCallbacks.GetHead();
+    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(srvCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(srvCallback->mPort == 1234);
+    VerifyOrQuit(srvCallback->mPriority == 2);
+    VerifyOrQuit(srvCallback->mWeight == 3);
+    VerifyOrQuit(srvCallback->mTtl == 120);
+    VerifyOrQuit(srvCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
-    VerifyOrQuit(sBrowseCallbacks.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Stop the browser. There is no active browser for this service. Ensure no queries are sent");
+    Log("Stop the resolver. There is no active resolver. Ensure no queries are sent");
 
-    sBrowseCallbacks.Clear();
+    sSrvCallbacks.Clear();
 
-    SuccessOrQuit(mdns->StopBrowser(browser));
+    SuccessOrQuit(mdns->StopSrvResolver(resolver));
 
-    AdvanceTime(100 * 1000);
+    AdvanceTime(20 * 1000);
 
-    VerifyOrQuit(sBrowseCallbacks.IsEmpty());
+    VerifyOrQuit(sSrvCallbacks.IsEmpty());
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Start browser again. Validate that initial queries are sent again");
+    Log("Restart the resolver with more than half of TTL remaining.");
+    Log("Ensure cached entry is reported in the result callback and no queries are sent.");
 
-    SuccessOrQuit(mdns->StartBrowser(browser));
+    SuccessOrQuit(mdns->StartSrvResolver(resolver));
 
-    AdvanceTime(125);
+    AdvanceTime(1);
 
-    VerifyOrQuit(!sDnsMessages.IsEmpty());
-    dnsMsg = sDnsMessages.GetHead();
-    dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 0);
-    dnsMsg->ValidateAsQueryFor(browser);
-    VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
+    srvCallback = sSrvCallbacks.GetHead();
+    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(srvCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(srvCallback->mPort == 1234);
+    VerifyOrQuit(srvCallback->mPriority == 2);
+    VerifyOrQuit(srvCallback->mWeight == 3);
+    VerifyOrQuit(srvCallback->mTtl == 120);
+    VerifyOrQuit(srvCallback->GetNext() == nullptr);
+
+    VerifyOrQuit(sDnsMessages.IsEmpty());
+
+    AdvanceTime(20 * 1000);
+
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a response after the first initial query");
+    Log("Stop and start the resolver again after less than half TTL remaining.");
+    Log("Ensure cached entry is still reported in the result callback but queries should be sent");
 
-    sDnsMessages.Clear();
+    sSrvCallbacks.Clear();
 
-    SendPtrResponse("_srv._udp.local.", "mysrv._srv._udp.local.", 120, kInAnswerSection);
+    SuccessOrQuit(mdns->StopSrvResolver(resolver));
 
-    AdvanceTime(1);
+    AdvanceTime(25 * 1000);
 
-    browseCallback = sBrowseCallbacks.GetHead();
+    SuccessOrQuit(mdns->StartSrvResolver(resolver));
 
-    VerifyOrQuit(browseCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(!browseCallback->mIsSubType);
-    VerifyOrQuit(browseCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(browseCallback->mTtl == 120);
-    VerifyOrQuit(browseCallback->GetNext() == nullptr);
+    AdvanceTime(1);
 
-    sBrowseCallbacks.Clear();
+    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
+    srvCallback = sSrvCallbacks.GetHead();
+    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(srvCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(srvCallback->mPort == 1234);
+    VerifyOrQuit(srvCallback->mPriority == 2);
+    VerifyOrQuit(srvCallback->mWeight == 3);
+    VerifyOrQuit(srvCallback->mTtl == 120);
+    VerifyOrQuit(srvCallback->GetNext() == nullptr);
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Validate initial esquires are still sent and include known-answer");
+    sSrvCallbacks.Clear();
 
-    for (uint8_t queryCount = 1; queryCount < kNumInitalQueries; queryCount++)
-    {
-        sDnsMessages.Clear();
+    AdvanceTime(15 * 1000);
 
-        AdvanceTime((1U << (queryCount - 1)) * 1000);
+    dnsMsg = sDnsMessages.GetHead();
 
-        VerifyOrQuit(!sDnsMessages.IsEmpty());
-        dnsMsg = sDnsMessages.GetHead();
-        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 1, /* Auth */ 0, /* Addnl */ 0);
-        dnsMsg->ValidateAsQueryFor(browser);
-        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    for (uint8_t queryCount = 0; queryCount < kNumInitalQueries; queryCount++)
+    {
+        VerifyOrQuit(dnsMsg != nullptr);
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 0);
+        dnsMsg->ValidateAsQueryFor(resolver);
+        dnsMsg = dnsMsg->GetNext();
     }
 
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    VerifyOrQuit(dnsMsg == nullptr);
 
-    sDnsMessages.Clear();
-    AdvanceTime(50 * 1000);
-    VerifyOrQuit(sDnsMessages.IsEmpty());
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
 
     SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
     VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
@@ -5383,17 +6643,17 @@ void TestBrowser(void)
     testFreeInstance(sInstance);
 }
 
-void TestSrvResolver(void)
+void TestTxtResolver(void)
 {
     Core              *mdns = InitTest();
-    Core::SrvResolver  resolver;
-    Core::SrvResolver  resolver2;
+    Core::TxtResolver  resolver;
+    Core::TxtResolver  resolver2;
     const DnsMessage  *dnsMsg;
-    const SrvCallback *srvCallback;
+    const TxtCallback *txtCallback;
     uint16_t           heapAllocations;
 
     Log("-------------------------------------------------------------------------------------------");
-    Log("TestSrvResolver");
+    Log("TestTxtResolver");
 
     AdvanceTime(1);
 
@@ -5401,17 +6661,17 @@ void TestSrvResolver(void)
     SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Start a SRV resolver. Validate initial queries.");
+    Log("Start a TXT resolver. Validate initial queries.");
 
     ClearAllBytes(resolver);
 
     resolver.mServiceInstance = "mysrv";
     resolver.mServiceType     = "_srv._udp";
     resolver.mInfraIfIndex    = kInfraIfIndex;
-    resolver.mCallback        = HandleSrvResult;
+    resolver.mCallback        = HandleTxtResult;
 
     sDnsMessages.Clear();
-    SuccessOrQuit(mdns->StartSrvResolver(resolver));
+    SuccessOrQuit(mdns->StartTxtResolver(resolver));
 
     for (uint8_t queryCount = 0; queryCount < kNumInitalQueries; queryCount++)
     {
@@ -5434,118 +6694,122 @@ void TestSrvResolver(void)
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Send a response. Validate callback result.");
 
-    sSrvCallbacks.Clear();
+    sTxtCallbacks.Clear();
+
+    SendTxtResponse("mysrv._srv._udp.local.", kTxtData1, sizeof(kTxtData1), 120, kInAnswerSection);
+
+    AdvanceTime(1);
+
+    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
+    txtCallback = sTxtCallbacks.GetHead();
+    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(txtCallback->Matches(kTxtData1));
+    VerifyOrQuit(txtCallback->mTtl == 120);
+    VerifyOrQuit(txtCallback->GetNext() == nullptr);
+
+    VerifyOrQuit(sDnsMessages.IsEmpty());
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send an updated response changing TXT data. Validate callback result.");
+
+    AdvanceTime(1000);
 
-    SendSrvResponse("mysrv._srv._udp.local.", "myhost.local.", 1234, 0, 1, 120, kInAnswerSection);
+    sTxtCallbacks.Clear();
+
+    SendTxtResponse("mysrv._srv._udp.local.", kTxtData2, sizeof(kTxtData2), 120, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
-    srvCallback = sSrvCallbacks.GetHead();
-    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(srvCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(srvCallback->mPort == 1234);
-    VerifyOrQuit(srvCallback->mPriority == 0);
-    VerifyOrQuit(srvCallback->mWeight == 1);
-    VerifyOrQuit(srvCallback->mTtl == 120);
-    VerifyOrQuit(srvCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
+    txtCallback = sTxtCallbacks.GetHead();
+    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(txtCallback->Matches(kTxtData2));
+    VerifyOrQuit(txtCallback->mTtl == 120);
+    VerifyOrQuit(txtCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send an updated response changing host name. Validate callback result.");
+    Log("Send an updated response changing TXT data to empty. Validate callback result.");
 
     AdvanceTime(1000);
 
-    sSrvCallbacks.Clear();
+    sTxtCallbacks.Clear();
 
-    SendSrvResponse("mysrv._srv._udp.local.", "myhost2.local.", 1234, 0, 1, 120, kInAnswerSection);
+    SendTxtResponse("mysrv._srv._udp.local.", kEmptyTxtData, sizeof(kEmptyTxtData), 120, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
-    srvCallback = sSrvCallbacks.GetHead();
-    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(srvCallback->mHostName.Matches("myhost2"));
-    VerifyOrQuit(srvCallback->mPort == 1234);
-    VerifyOrQuit(srvCallback->mPriority == 0);
-    VerifyOrQuit(srvCallback->mWeight == 1);
-    VerifyOrQuit(srvCallback->mTtl == 120);
-    VerifyOrQuit(srvCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
+    txtCallback = sTxtCallbacks.GetHead();
+    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(txtCallback->Matches(kEmptyTxtData));
+    VerifyOrQuit(txtCallback->mTtl == 120);
+    VerifyOrQuit(txtCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send an updated response changing port. Validate callback result.");
+    Log("Send an updated response changing TTL. Validate callback result.");
 
     AdvanceTime(1000);
 
-    sSrvCallbacks.Clear();
+    sTxtCallbacks.Clear();
 
-    SendSrvResponse("mysrv._srv._udp.local.", "myhost2.local.", 4567, 0, 1, 120, kInAnswerSection);
+    SendTxtResponse("mysrv._srv._udp.local.", kEmptyTxtData, sizeof(kEmptyTxtData), 500, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
-    srvCallback = sSrvCallbacks.GetHead();
-    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(srvCallback->mHostName.Matches("myhost2"));
-    VerifyOrQuit(srvCallback->mPort == 4567);
-    VerifyOrQuit(srvCallback->mPriority == 0);
-    VerifyOrQuit(srvCallback->mWeight == 1);
-    VerifyOrQuit(srvCallback->mTtl == 120);
-    VerifyOrQuit(srvCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
+    txtCallback = sTxtCallbacks.GetHead();
+    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(txtCallback->Matches(kEmptyTxtData));
+    VerifyOrQuit(txtCallback->mTtl == 500);
+    VerifyOrQuit(txtCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send an updated response changing TTL. Validate callback result.");
+    Log("Send an updated response with zero TTL. Validate callback result.");
 
     AdvanceTime(1000);
 
-    sSrvCallbacks.Clear();
+    sTxtCallbacks.Clear();
 
-    SendSrvResponse("mysrv._srv._udp.local.", "myhost2.local.", 4567, 0, 1, 0, kInAnswerSection);
+    SendTxtResponse("mysrv._srv._udp.local.", kEmptyTxtData, sizeof(kEmptyTxtData), 0, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
-    srvCallback = sSrvCallbacks.GetHead();
-    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(srvCallback->mHostName.Matches(""));
-    VerifyOrQuit(srvCallback->mPort == 4567);
-    VerifyOrQuit(srvCallback->mPriority == 0);
-    VerifyOrQuit(srvCallback->mWeight == 1);
-    VerifyOrQuit(srvCallback->mTtl == 0);
-    VerifyOrQuit(srvCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
+    txtCallback = sTxtCallbacks.GetHead();
+    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(txtCallback->mTtl == 0);
+    VerifyOrQuit(txtCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send an updated response changing a bunch of things. Validate callback result.");
-
-    AdvanceTime(1000);
+    Log("Send an updated response. Validate callback result.");
 
-    sSrvCallbacks.Clear();
+    sTxtCallbacks.Clear();
+    AdvanceTime(100 * 1000);
 
-    SendSrvResponse("mysrv._srv._udp.local.", "myhost.local.", 1234, 2, 3, 120, kInAnswerSection);
+    SendTxtResponse("mysrv._srv._udp.local.", kTxtData1, sizeof(kTxtData1), 120, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
-    srvCallback = sSrvCallbacks.GetHead();
-    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(srvCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(srvCallback->mPort == 1234);
-    VerifyOrQuit(srvCallback->mPriority == 2);
-    VerifyOrQuit(srvCallback->mWeight == 3);
-    VerifyOrQuit(srvCallback->mTtl == 120);
-    VerifyOrQuit(srvCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
+    txtCallback = sTxtCallbacks.GetHead();
+    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(txtCallback->Matches(kTxtData1));
+    VerifyOrQuit(txtCallback->mTtl == 120);
+    VerifyOrQuit(txtCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
@@ -5554,59 +6818,52 @@ void TestSrvResolver(void)
 
     AdvanceTime(1000);
 
-    sSrvCallbacks.Clear();
+    sTxtCallbacks.Clear();
 
-    SendSrvResponse("mysrv._srv._udp.local.", "myhost.local.", 1234, 2, 3, 120, kInAnswerSection);
+    SendTxtResponse("mysrv._srv._udp.local.", kTxtData1, sizeof(kTxtData1), 120, kInAnswerSection);
 
-    AdvanceTime(1);
+    AdvanceTime(100);
 
-    VerifyOrQuit(sSrvCallbacks.IsEmpty());
+    VerifyOrQuit(sTxtCallbacks.IsEmpty());
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Start another resolver for the same service and different callback. Validate results.");
 
-    ClearAllBytes(resolver2);
-
     resolver2.mServiceInstance = "mysrv";
     resolver2.mServiceType     = "_srv._udp";
     resolver2.mInfraIfIndex    = kInfraIfIndex;
-    resolver2.mCallback        = HandleSrvResultAlternate;
+    resolver2.mCallback        = HandleTxtResultAlternate;
 
-    sSrvCallbacks.Clear();
+    sTxtCallbacks.Clear();
 
-    SuccessOrQuit(mdns->StartSrvResolver(resolver2));
+    SuccessOrQuit(mdns->StartTxtResolver(resolver2));
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
-    srvCallback = sSrvCallbacks.GetHead();
-    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(srvCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(srvCallback->mPort == 1234);
-    VerifyOrQuit(srvCallback->mPriority == 2);
-    VerifyOrQuit(srvCallback->mWeight == 3);
-    VerifyOrQuit(srvCallback->mTtl == 120);
-    VerifyOrQuit(srvCallback->GetNext() == nullptr);
-
-    VerifyOrQuit(sDnsMessages.IsEmpty());
+    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
+    txtCallback = sTxtCallbacks.GetHead();
+    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(txtCallback->Matches(kTxtData1));
+    VerifyOrQuit(txtCallback->mTtl == 120);
+    VerifyOrQuit(txtCallback->GetNext() == nullptr);
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Start same resolver again and check the returned error.");
 
-    sSrvCallbacks.Clear();
+    sTxtCallbacks.Clear();
 
-    VerifyOrQuit(mdns->StartSrvResolver(resolver2) == kErrorAlready);
+    VerifyOrQuit(mdns->StartTxtResolver(resolver2) == kErrorAlready);
 
     AdvanceTime(5000);
 
-    VerifyOrQuit(sSrvCallbacks.IsEmpty());
+    VerifyOrQuit(sTxtCallbacks.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Check query is sent at 80 percentage of TTL and then respond to it.");
 
-    SendSrvResponse("mysrv._srv._udp.local.", "myhost.local.", 1234, 2, 3, 120, kInAnswerSection);
+    SendTxtResponse("mysrv._srv._udp.local.", kTxtData1, sizeof(kTxtData1), 120, kInAnswerSection);
 
     // First query should be sent at 80-82% of TTL of 120 second (96.0-98.4 sec).
     // We wait for 100 second. Note that 5 seconds already passed in the
@@ -5625,11 +6882,11 @@ void TestSrvResolver(void)
     VerifyOrQuit(dnsMsg->GetNext() == nullptr);
 
     sDnsMessages.Clear();
-    VerifyOrQuit(sSrvCallbacks.IsEmpty());
+    VerifyOrQuit(sTxtCallbacks.IsEmpty());
 
     AdvanceTime(10);
 
-    SendSrvResponse("mysrv._srv._udp.local.", "myhost.local.", 1234, 2, 3, 120, kInAnswerSection);
+    SendTxtResponse("mysrv._srv._udp.local.", kTxtData1, sizeof(kTxtData1), 120, kInAnswerSection);
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Check queries are sent at 80, 85, 90, 95 percentages of TTL.");
@@ -5663,7 +6920,7 @@ void TestSrvResolver(void)
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
 
         sDnsMessages.Clear();
-        VerifyOrQuit(sSrvCallbacks.IsEmpty());
+        VerifyOrQuit(sTxtCallbacks.IsEmpty());
     }
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
@@ -5671,93 +6928,87 @@ void TestSrvResolver(void)
 
     AdvanceTime(6 * 1000);
 
-    srvCallback = sSrvCallbacks.GetHead();
+    txtCallback = sTxtCallbacks.GetHead();
 
     for (uint8_t iter = 0; iter < 2; iter++)
     {
-        VerifyOrQuit(srvCallback != nullptr);
-        VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
-        VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
-        VerifyOrQuit(srvCallback->mTtl == 0);
-        srvCallback = srvCallback->GetNext();
+        VerifyOrQuit(txtCallback != nullptr);
+        VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
+        VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
+        VerifyOrQuit(txtCallback->mTtl == 0);
+        txtCallback = txtCallback->GetNext();
     }
 
-    VerifyOrQuit(srvCallback == nullptr);
+    VerifyOrQuit(txtCallback == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
 
-    sSrvCallbacks.Clear();
+    sTxtCallbacks.Clear();
     sDnsMessages.Clear();
 
     AdvanceTime(200 * 1000);
 
-    VerifyOrQuit(sSrvCallbacks.IsEmpty());
+    VerifyOrQuit(sTxtCallbacks.IsEmpty());
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Stop the second resolver");
 
-    sSrvCallbacks.Clear();
+    sTxtCallbacks.Clear();
 
-    SuccessOrQuit(mdns->StopSrvResolver(resolver2));
+    SuccessOrQuit(mdns->StopTxtResolver(resolver2));
 
     AdvanceTime(100 * 1000);
 
-    VerifyOrQuit(sSrvCallbacks.IsEmpty());
+    VerifyOrQuit(sTxtCallbacks.IsEmpty());
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Send a new response and make sure result callback is invoked");
 
-    SendSrvResponse("mysrv._srv._udp.local.", "myhost.local.", 1234, 2, 3, 120, kInAnswerSection);
+    SendTxtResponse("mysrv._srv._udp.local.", kTxtData1, sizeof(kTxtData1), 120, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
-    srvCallback = sSrvCallbacks.GetHead();
-    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(srvCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(srvCallback->mPort == 1234);
-    VerifyOrQuit(srvCallback->mPriority == 2);
-    VerifyOrQuit(srvCallback->mWeight == 3);
-    VerifyOrQuit(srvCallback->mTtl == 120);
-    VerifyOrQuit(srvCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
+    txtCallback = sTxtCallbacks.GetHead();
+    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(txtCallback->Matches(kTxtData1));
+    VerifyOrQuit(txtCallback->mTtl == 120);
+    VerifyOrQuit(txtCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Stop the resolver. There is no active resolver. Ensure no queries are sent");
 
-    sSrvCallbacks.Clear();
+    sTxtCallbacks.Clear();
 
-    SuccessOrQuit(mdns->StopSrvResolver(resolver));
+    SuccessOrQuit(mdns->StopTxtResolver(resolver));
 
     AdvanceTime(20 * 1000);
 
-    VerifyOrQuit(sSrvCallbacks.IsEmpty());
+    VerifyOrQuit(sTxtCallbacks.IsEmpty());
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Restart the resolver with more than half of TTL remaining.");
     Log("Ensure cached entry is reported in the result callback and no queries are sent.");
 
-    SuccessOrQuit(mdns->StartSrvResolver(resolver));
+    SuccessOrQuit(mdns->StartTxtResolver(resolver));
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
-    srvCallback = sSrvCallbacks.GetHead();
-    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(srvCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(srvCallback->mPort == 1234);
-    VerifyOrQuit(srvCallback->mPriority == 2);
-    VerifyOrQuit(srvCallback->mWeight == 3);
-    VerifyOrQuit(srvCallback->mTtl == 120);
-    VerifyOrQuit(srvCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
+    txtCallback = sTxtCallbacks.GetHead();
+    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(txtCallback->Matches(kTxtData1));
+    VerifyOrQuit(txtCallback->mTtl == 120);
+    VerifyOrQuit(txtCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
@@ -5769,28 +7020,25 @@ void TestSrvResolver(void)
     Log("Stop and start the resolver again after less than half TTL remaining.");
     Log("Ensure cached entry is still reported in the result callback but queries should be sent");
 
-    sSrvCallbacks.Clear();
+    sTxtCallbacks.Clear();
 
-    SuccessOrQuit(mdns->StopSrvResolver(resolver));
+    SuccessOrQuit(mdns->StopTxtResolver(resolver));
 
     AdvanceTime(25 * 1000);
 
-    SuccessOrQuit(mdns->StartSrvResolver(resolver));
+    SuccessOrQuit(mdns->StartTxtResolver(resolver));
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sSrvCallbacks.IsEmpty());
-    srvCallback = sSrvCallbacks.GetHead();
-    VerifyOrQuit(srvCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(srvCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(srvCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(srvCallback->mPort == 1234);
-    VerifyOrQuit(srvCallback->mPriority == 2);
-    VerifyOrQuit(srvCallback->mWeight == 3);
-    VerifyOrQuit(srvCallback->mTtl == 120);
-    VerifyOrQuit(srvCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
+    txtCallback = sTxtCallbacks.GetHead();
+    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
+    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
+    VerifyOrQuit(txtCallback->Matches(kTxtData1));
+    VerifyOrQuit(txtCallback->mTtl == 120);
+    VerifyOrQuit(txtCallback->GetNext() == nullptr);
 
-    sSrvCallbacks.Clear();
+    sTxtCallbacks.Clear();
 
     AdvanceTime(15 * 1000);
 
@@ -5816,17 +7064,18 @@ void TestSrvResolver(void)
     testFreeInstance(sInstance);
 }
 
-void TestTxtResolver(void)
+void TestIp6AddrResolver(void)
 {
-    Core              *mdns = InitTest();
-    Core::TxtResolver  resolver;
-    Core::TxtResolver  resolver2;
-    const DnsMessage  *dnsMsg;
-    const TxtCallback *txtCallback;
-    uint16_t           heapAllocations;
+    Core                 *mdns = InitTest();
+    Core::AddressResolver resolver;
+    Core::AddressResolver resolver2;
+    AddrAndTtl            addrs[5];
+    const DnsMessage     *dnsMsg;
+    const AddrCallback   *addrCallback;
+    uint16_t              heapAllocations;
 
     Log("-------------------------------------------------------------------------------------------");
-    Log("TestTxtResolver");
+    Log("TestIp6AddrResolver");
 
     AdvanceTime(1);
 
@@ -5834,17 +7083,16 @@ void TestTxtResolver(void)
     SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Start a TXT resolver. Validate initial queries.");
+    Log("Start an IPv6 address resolver. Validate initial queries.");
 
     ClearAllBytes(resolver);
 
-    resolver.mServiceInstance = "mysrv";
-    resolver.mServiceType     = "_srv._udp";
-    resolver.mInfraIfIndex    = kInfraIfIndex;
-    resolver.mCallback        = HandleTxtResult;
+    resolver.mHostName     = "myhost";
+    resolver.mInfraIfIndex = kInfraIfIndex;
+    resolver.mCallback     = HandleAddrResult;
 
     sDnsMessages.Clear();
-    SuccessOrQuit(mdns->StartTxtResolver(resolver));
+    SuccessOrQuit(mdns->StartIp6AddressResolver(resolver));
 
     for (uint8_t queryCount = 0; queryCount < kNumInitalQueries; queryCount++)
     {
@@ -5867,176 +7115,249 @@ void TestTxtResolver(void)
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Send a response. Validate callback result.");
 
-    sTxtCallbacks.Clear();
+    sAddrCallbacks.Clear();
 
-    SendTxtResponse("mysrv._srv._udp.local.", kTxtData1, sizeof(kTxtData1), 120, kInAnswerSection);
+    SuccessOrQuit(addrs[0].mAddress.FromString("fd00::1"));
+    addrs[0].mTtl = 120;
+
+    SendHostAddrResponse("myhost.local.", addrs, 1, /* aCachFlush */ true, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
-    txtCallback = sTxtCallbacks.GetHead();
-    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(txtCallback->Matches(kTxtData1));
-    VerifyOrQuit(txtCallback->mTtl == 120);
-    VerifyOrQuit(txtCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
+    addrCallback = sAddrCallbacks.GetHead();
+    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(addrCallback->Matches(addrs, 1));
+    VerifyOrQuit(addrCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send an updated response changing TXT data. Validate callback result.");
+    Log("Send an updated response adding a new address. Validate callback result.");
+
+    SuccessOrQuit(addrs[1].mAddress.FromString("fd00::2"));
+    addrs[1].mTtl = 120;
 
     AdvanceTime(1000);
 
-    sTxtCallbacks.Clear();
+    sAddrCallbacks.Clear();
 
-    SendTxtResponse("mysrv._srv._udp.local.", kTxtData2, sizeof(kTxtData2), 120, kInAnswerSection);
+    SendHostAddrResponse("myhost.local.", addrs, 2, /* aCachFlush */ true, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
-    txtCallback = sTxtCallbacks.GetHead();
-    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(txtCallback->Matches(kTxtData2));
-    VerifyOrQuit(txtCallback->mTtl == 120);
-    VerifyOrQuit(txtCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
+    addrCallback = sAddrCallbacks.GetHead();
+    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(addrCallback->Matches(addrs, 2));
+    VerifyOrQuit(addrCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send an updated response changing TXT data to empty. Validate callback result.");
+    Log("Send an updated response adding and removing addresses. Validate callback result.");
+
+    SuccessOrQuit(addrs[0].mAddress.FromString("fd00::2"));
+    SuccessOrQuit(addrs[1].mAddress.FromString("fd00::aa"));
+    SuccessOrQuit(addrs[2].mAddress.FromString("fe80::bb"));
+    addrs[0].mTtl = 120;
+    addrs[1].mTtl = 120;
+    addrs[2].mTtl = 120;
 
     AdvanceTime(1000);
 
-    sTxtCallbacks.Clear();
+    sAddrCallbacks.Clear();
 
-    SendTxtResponse("mysrv._srv._udp.local.", kEmptyTxtData, sizeof(kEmptyTxtData), 120, kInAnswerSection);
+    SendHostAddrResponse("myhost.local.", addrs, 3, /* aCachFlush */ true, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
-    txtCallback = sTxtCallbacks.GetHead();
-    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(txtCallback->Matches(kEmptyTxtData));
-    VerifyOrQuit(txtCallback->mTtl == 120);
-    VerifyOrQuit(txtCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
+    addrCallback = sAddrCallbacks.GetHead();
+    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(addrCallback->Matches(addrs, 3));
+    VerifyOrQuit(addrCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send an updated response changing TTL. Validate callback result.");
+    Log("Send a response without cache flush adding an address. Validate callback result.");
+
+    SuccessOrQuit(addrs[3].mAddress.FromString("fd00::3"));
+    addrs[3].mTtl = 500;
 
     AdvanceTime(1000);
 
-    sTxtCallbacks.Clear();
+    sAddrCallbacks.Clear();
 
-    SendTxtResponse("mysrv._srv._udp.local.", kEmptyTxtData, sizeof(kEmptyTxtData), 500, kInAnswerSection);
+    SendHostAddrResponse("myhost.local.", &addrs[3], 1, /* aCachFlush */ false, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
-    txtCallback = sTxtCallbacks.GetHead();
-    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(txtCallback->Matches(kEmptyTxtData));
-    VerifyOrQuit(txtCallback->mTtl == 500);
-    VerifyOrQuit(txtCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
+    addrCallback = sAddrCallbacks.GetHead();
+    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(addrCallback->Matches(addrs, 4));
+    VerifyOrQuit(addrCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send an updated response with zero TTL. Validate callback result.");
+    Log("Send a response without cache flush with existing addresses. Validate that callback is not called.");
 
     AdvanceTime(1000);
 
-    sTxtCallbacks.Clear();
+    sAddrCallbacks.Clear();
 
-    SendTxtResponse("mysrv._srv._udp.local.", kEmptyTxtData, sizeof(kEmptyTxtData), 0, kInAnswerSection);
+    SendHostAddrResponse("myhost.local.", &addrs[2], 2, /* aCachFlush */ false, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
-    txtCallback = sTxtCallbacks.GetHead();
-    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(txtCallback->mTtl == 0);
-    VerifyOrQuit(txtCallback->GetNext() == nullptr);
+    VerifyOrQuit(sAddrCallbacks.IsEmpty());
+    VerifyOrQuit(sDnsMessages.IsEmpty());
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a response without no changes to the list. Validate that callback is not called");
+
+    AdvanceTime(1000);
 
+    sAddrCallbacks.Clear();
+
+    SendHostAddrResponse("myhost.local.", addrs, 4, /* aCachFlush */ true, kInAdditionalSection);
+
+    AdvanceTime(1);
+
+    VerifyOrQuit(sAddrCallbacks.IsEmpty());
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send an updated response. Validate callback result.");
+    Log("Send a response without cache flush updating TTL of existing address. Validate callback result.");
 
-    sTxtCallbacks.Clear();
-    AdvanceTime(100 * 1000);
+    addrs[3].mTtl = 200;
 
-    SendTxtResponse("mysrv._srv._udp.local.", kTxtData1, sizeof(kTxtData1), 120, kInAnswerSection);
+    AdvanceTime(1000);
+
+    sAddrCallbacks.Clear();
+
+    SendHostAddrResponse("myhost.local.", &addrs[3], 1, /* aCachFlush */ false, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
-    txtCallback = sTxtCallbacks.GetHead();
-    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(txtCallback->Matches(kTxtData1));
-    VerifyOrQuit(txtCallback->mTtl == 120);
-    VerifyOrQuit(txtCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
+    addrCallback = sAddrCallbacks.GetHead();
+    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(addrCallback->Matches(addrs, 4));
+    VerifyOrQuit(addrCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a response with no changes. Validate callback is not invoked.");
+    Log("Send a response without cache flush removing an address (zero TTL). Validate callback result.");
+
+    addrs[3].mTtl = 0;
 
     AdvanceTime(1000);
 
-    sTxtCallbacks.Clear();
+    sAddrCallbacks.Clear();
 
-    SendTxtResponse("mysrv._srv._udp.local.", kTxtData1, sizeof(kTxtData1), 120, kInAnswerSection);
+    SendHostAddrResponse("myhost.local.", &addrs[3], 1, /* aCachFlush */ false, kInAnswerSection);
 
-    AdvanceTime(100);
+    AdvanceTime(1);
+
+    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
+    addrCallback = sAddrCallbacks.GetHead();
+    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(addrCallback->Matches(addrs, 3));
+    VerifyOrQuit(addrCallback->GetNext() == nullptr);
 
-    VerifyOrQuit(sTxtCallbacks.IsEmpty());
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Start another resolver for the same service and different callback. Validate results.");
+    Log("Send a response with cache flush removing all addresses. Validate callback result.");
 
-    resolver2.mServiceInstance = "mysrv";
-    resolver2.mServiceType     = "_srv._udp";
-    resolver2.mInfraIfIndex    = kInfraIfIndex;
-    resolver2.mCallback        = HandleTxtResultAlternate;
+    addrs[0].mTtl = 0;
 
-    sTxtCallbacks.Clear();
+    AdvanceTime(1000);
 
-    SuccessOrQuit(mdns->StartTxtResolver(resolver2));
+    sAddrCallbacks.Clear();
+
+    SendHostAddrResponse("myhost.local.", addrs, 1, /* aCachFlush */ true, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
-    txtCallback = sTxtCallbacks.GetHead();
-    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(txtCallback->Matches(kTxtData1));
-    VerifyOrQuit(txtCallback->mTtl == 120);
-    VerifyOrQuit(txtCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
+    addrCallback = sAddrCallbacks.GetHead();
+    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(addrCallback->Matches(addrs, 0));
+    VerifyOrQuit(addrCallback->GetNext() == nullptr);
+
+    VerifyOrQuit(sDnsMessages.IsEmpty());
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Send a response with addresses with different TTL. Validate callback result");
+
+    SuccessOrQuit(addrs[0].mAddress.FromString("fd00::00"));
+    SuccessOrQuit(addrs[1].mAddress.FromString("fd00::11"));
+    SuccessOrQuit(addrs[2].mAddress.FromString("fe80::22"));
+    SuccessOrQuit(addrs[3].mAddress.FromString("fe80::33"));
+    addrs[0].mTtl = 120;
+    addrs[1].mTtl = 800;
+    addrs[2].mTtl = 2000;
+    addrs[3].mTtl = 8000;
+
+    AdvanceTime(5 * 1000);
+
+    sAddrCallbacks.Clear();
+
+    SendHostAddrResponse("myhost.local.", addrs, 4, /* aCachFlush */ true, kInAnswerSection);
+
+    AdvanceTime(1);
+
+    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
+    addrCallback = sAddrCallbacks.GetHead();
+    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(addrCallback->Matches(addrs, 4));
+    VerifyOrQuit(addrCallback->GetNext() == nullptr);
+
+    VerifyOrQuit(sDnsMessages.IsEmpty());
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Start another resolver for the same host and different callback. Validate results.");
+
+    resolver2.mHostName     = "myhost";
+    resolver2.mInfraIfIndex = kInfraIfIndex;
+    resolver2.mCallback     = HandleAddrResultAlternate;
+
+    sAddrCallbacks.Clear();
+
+    SuccessOrQuit(mdns->StartIp6AddressResolver(resolver2));
+
+    AdvanceTime(1);
+
+    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
+    addrCallback = sAddrCallbacks.GetHead();
+    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(addrCallback->Matches(addrs, 4));
+    VerifyOrQuit(addrCallback->GetNext() == nullptr);
+
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Start same resolver again and check the returned error.");
 
-    sTxtCallbacks.Clear();
+    sAddrCallbacks.Clear();
 
-    VerifyOrQuit(mdns->StartTxtResolver(resolver2) == kErrorAlready);
+    VerifyOrQuit(mdns->StartIp6AddressResolver(resolver2) == kErrorAlready);
 
     AdvanceTime(5000);
 
-    VerifyOrQuit(sTxtCallbacks.IsEmpty());
+    VerifyOrQuit(sAddrCallbacks.IsEmpty());
+    sDnsMessages.Clear();
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Check query is sent at 80 percentage of TTL and then respond to it.");
 
-    SendTxtResponse("mysrv._srv._udp.local.", kTxtData1, sizeof(kTxtData1), 120, kInAnswerSection);
+    SendHostAddrResponse("myhost.local.", addrs, 4, /* aCachFlush */ true, kInAnswerSection);
 
     // First query should be sent at 80-82% of TTL of 120 second (96.0-98.4 sec).
     // We wait for 100 second. Note that 5 seconds already passed in the
@@ -6055,11 +7376,11 @@ void TestTxtResolver(void)
     VerifyOrQuit(dnsMsg->GetNext() == nullptr);
 
     sDnsMessages.Clear();
-    VerifyOrQuit(sTxtCallbacks.IsEmpty());
+    VerifyOrQuit(sAddrCallbacks.IsEmpty());
 
     AdvanceTime(10);
 
-    SendTxtResponse("mysrv._srv._udp.local.", kTxtData1, sizeof(kTxtData1), 120, kInAnswerSection);
+    SendHostAddrResponse("myhost.local.", addrs, 4, /* aCachFlush */ true, kInAnswerSection);
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Check queries are sent at 80, 85, 90, 95 percentages of TTL.");
@@ -6093,95 +7414,111 @@ void TestTxtResolver(void)
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
 
         sDnsMessages.Clear();
-        VerifyOrQuit(sTxtCallbacks.IsEmpty());
+        VerifyOrQuit(sAddrCallbacks.IsEmpty());
     }
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Check TTL timeout and callback result.");
+    Log("Check TTL timeout of first address (TTL 120) and callback result.");
 
     AdvanceTime(6 * 1000);
 
-    txtCallback = sTxtCallbacks.GetHead();
+    addrCallback = sAddrCallbacks.GetHead();
 
     for (uint8_t iter = 0; iter < 2; iter++)
     {
-        VerifyOrQuit(txtCallback != nullptr);
-        VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
-        VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
-        VerifyOrQuit(txtCallback->mTtl == 0);
-        txtCallback = txtCallback->GetNext();
+        VerifyOrQuit(addrCallback != nullptr);
+        VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
+        VerifyOrQuit(addrCallback->Matches(&addrs[1], 3));
+        addrCallback = addrCallback->GetNext();
     }
 
-    VerifyOrQuit(txtCallback == nullptr);
+    VerifyOrQuit(addrCallback == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Check TTL timeout of next address (TTL 800) and callback result.");
 
-    sTxtCallbacks.Clear();
+    sAddrCallbacks.Clear();
+
+    AdvanceTime((800 - 120) * 1000);
+
+    addrCallback = sAddrCallbacks.GetHead();
+
+    for (uint8_t iter = 0; iter < 2; iter++)
+    {
+        VerifyOrQuit(addrCallback != nullptr);
+        VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
+        VerifyOrQuit(addrCallback->Matches(&addrs[2], 2));
+        addrCallback = addrCallback->GetNext();
+    }
+
+    VerifyOrQuit(addrCallback == nullptr);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+
+    sAddrCallbacks.Clear();
     sDnsMessages.Clear();
 
     AdvanceTime(200 * 1000);
 
-    VerifyOrQuit(sTxtCallbacks.IsEmpty());
+    VerifyOrQuit(sAddrCallbacks.IsEmpty());
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Stop the second resolver");
 
-    sTxtCallbacks.Clear();
+    sAddrCallbacks.Clear();
 
-    SuccessOrQuit(mdns->StopTxtResolver(resolver2));
+    SuccessOrQuit(mdns->StopIp6AddressResolver(resolver2));
 
     AdvanceTime(100 * 1000);
 
-    VerifyOrQuit(sTxtCallbacks.IsEmpty());
+    VerifyOrQuit(sAddrCallbacks.IsEmpty());
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Send a new response and make sure result callback is invoked");
 
-    SendTxtResponse("mysrv._srv._udp.local.", kTxtData1, sizeof(kTxtData1), 120, kInAnswerSection);
+    sAddrCallbacks.Clear();
+
+    SendHostAddrResponse("myhost.local.", addrs, 1, /* aCachFlush */ true, kInAnswerSection);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
-    txtCallback = sTxtCallbacks.GetHead();
-    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(txtCallback->Matches(kTxtData1));
-    VerifyOrQuit(txtCallback->mTtl == 120);
-    VerifyOrQuit(txtCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
+    addrCallback = sAddrCallbacks.GetHead();
+    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(addrCallback->Matches(addrs, 1));
+    VerifyOrQuit(addrCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Stop the resolver. There is no active resolver. Ensure no queries are sent");
 
-    sTxtCallbacks.Clear();
+    sAddrCallbacks.Clear();
 
-    SuccessOrQuit(mdns->StopTxtResolver(resolver));
+    SuccessOrQuit(mdns->StopIp6AddressResolver(resolver));
 
     AdvanceTime(20 * 1000);
 
-    VerifyOrQuit(sTxtCallbacks.IsEmpty());
+    VerifyOrQuit(sAddrCallbacks.IsEmpty());
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Restart the resolver with more than half of TTL remaining.");
     Log("Ensure cached entry is reported in the result callback and no queries are sent.");
 
-    SuccessOrQuit(mdns->StartTxtResolver(resolver));
+    SuccessOrQuit(mdns->StartIp6AddressResolver(resolver));
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
-    txtCallback = sTxtCallbacks.GetHead();
-    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(txtCallback->Matches(kTxtData1));
-    VerifyOrQuit(txtCallback->mTtl == 120);
-    VerifyOrQuit(txtCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
+    addrCallback = sAddrCallbacks.GetHead();
+    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(addrCallback->Matches(addrs, 1));
+    VerifyOrQuit(addrCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
@@ -6193,25 +7530,23 @@ void TestTxtResolver(void)
     Log("Stop and start the resolver again after less than half TTL remaining.");
     Log("Ensure cached entry is still reported in the result callback but queries should be sent");
 
-    sTxtCallbacks.Clear();
+    sAddrCallbacks.Clear();
 
-    SuccessOrQuit(mdns->StopTxtResolver(resolver));
+    SuccessOrQuit(mdns->StopIp6AddressResolver(resolver));
 
     AdvanceTime(25 * 1000);
 
-    SuccessOrQuit(mdns->StartTxtResolver(resolver));
+    SuccessOrQuit(mdns->StartIp6AddressResolver(resolver));
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sTxtCallbacks.IsEmpty());
-    txtCallback = sTxtCallbacks.GetHead();
-    VerifyOrQuit(txtCallback->mServiceInstance.Matches("mysrv"));
-    VerifyOrQuit(txtCallback->mServiceType.Matches("_srv._udp"));
-    VerifyOrQuit(txtCallback->Matches(kTxtData1));
-    VerifyOrQuit(txtCallback->mTtl == 120);
-    VerifyOrQuit(txtCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
+    addrCallback = sAddrCallbacks.GetHead();
+    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
+    VerifyOrQuit(addrCallback->Matches(addrs, 1));
+    VerifyOrQuit(addrCallback->GetNext() == nullptr);
 
-    sTxtCallbacks.Clear();
+    sAddrCallbacks.Clear();
 
     AdvanceTime(15 * 1000);
 
@@ -6237,18 +7572,22 @@ void TestTxtResolver(void)
     testFreeInstance(sInstance);
 }
 
-void TestIp6AddrResolver(void)
+void TestRecordQuerier(void)
 {
+    static constexpr uint8_t kMaxResponseRecords = 4;
+
     Core                 *mdns = InitTest();
-    Core::AddressResolver resolver;
-    Core::AddressResolver resolver2;
-    AddrAndTtl            addrs[5];
+    Core::RecordQuerier   querier;
+    Core::RecordQuerier   querier2;
+    Core::Iterator       *iterator;
+    Core::CacheInfo       cacheInfo;
     const DnsMessage     *dnsMsg;
-    const AddrCallback   *addrCallback;
+    const RecordCallback *recordCallback;
     uint16_t              heapAllocations;
+    RecordData            records[kMaxResponseRecords];
 
     Log("-------------------------------------------------------------------------------------------");
-    Log("TestIp6AddrResolver");
+    Log("TestRecordQuerier");
 
     AdvanceTime(1);
 
@@ -6256,16 +7595,18 @@ void TestIp6AddrResolver(void)
     SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Start an IPv6 address resolver. Validate initial queries.");
+    Log("Start a record querier. Validate initial queries.");
 
-    ClearAllBytes(resolver);
+    ClearAllBytes(querier);
 
-    resolver.mHostName     = "myhost";
-    resolver.mInfraIfIndex = kInfraIfIndex;
-    resolver.mCallback     = HandleAddrResult;
+    querier.mFirstLabel   = "mysrv";
+    querier.mNextLabels   = "_srv._udp";
+    querier.mRecordType   = ResourceRecord::kTypeKey;
+    querier.mInfraIfIndex = kInfraIfIndex;
+    querier.mCallback     = HandleRecordResult;
 
     sDnsMessages.Clear();
-    SuccessOrQuit(mdns->StartIp6AddressResolver(resolver));
+    SuccessOrQuit(mdns->StartRecordQuerier(querier));
 
     for (uint8_t queryCount = 0; queryCount < kNumInitalQueries; queryCount++)
     {
@@ -6276,7 +7617,7 @@ void TestIp6AddrResolver(void)
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
         dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 0);
-        dnsMsg->ValidateAsQueryFor(resolver);
+        dnsMsg->ValidateAsQueryFor(querier);
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
     }
 
@@ -6288,250 +7629,292 @@ void TestIp6AddrResolver(void)
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Send a response. Validate callback result.");
 
-    sAddrCallbacks.Clear();
-
-    SuccessOrQuit(addrs[0].mAddress.FromString("fd00::1"));
-    addrs[0].mTtl = 120;
+    records[0].mType       = ResourceRecord::kTypeKey;
+    records[0].mData       = kKey1;
+    records[0].mLength     = sizeof(kKey1);
+    records[0].mTtl        = 120;
+    records[0].mCacheFlush = false;
 
-    SendHostAddrResponse("myhost.local.", addrs, 1, /* aCachFlush */ true, kInAnswerSection);
+    sRecordCallbacks.Clear();
+    SendRecordResponse("mysrv._srv._udp.local.", 1, records);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
-    addrCallback = sAddrCallbacks.GetHead();
-    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(addrCallback->Matches(addrs, 1));
-    VerifyOrQuit(addrCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sRecordCallbacks.IsEmpty());
+    recordCallback = sRecordCallbacks.GetHead();
+    VerifyOrQuit(recordCallback->mFirstLabel.Matches("mysrv"));
+    VerifyOrQuit(recordCallback->mNextLabels.Matches("_srv._udp"));
+    VerifyOrQuit(recordCallback->mRecordType == ResourceRecord::kTypeKey);
+    VerifyOrQuit(recordCallback->MatchesData(kKey1));
+    VerifyOrQuit(recordCallback->mTtl == 120);
+    VerifyOrQuit(recordCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send an updated response adding a new address. Validate callback result.");
-
-    SuccessOrQuit(addrs[1].mAddress.FromString("fd00::2"));
-    addrs[1].mTtl = 120;
-
-    AdvanceTime(1000);
+    Log("Send a second response (without cache-flush). Validate callback result.");
 
-    sAddrCallbacks.Clear();
+    records[0].mType       = ResourceRecord::kTypeKey;
+    records[0].mData       = kKey2;
+    records[0].mLength     = sizeof(kKey2);
+    records[0].mTtl        = 120;
+    records[0].mCacheFlush = false;
 
-    SendHostAddrResponse("myhost.local.", addrs, 2, /* aCachFlush */ true, kInAnswerSection);
+    sRecordCallbacks.Clear();
+    SendRecordResponse("mysrv._srv._udp.local.", 1, records);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
-    addrCallback = sAddrCallbacks.GetHead();
-    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(addrCallback->Matches(addrs, 2));
-    VerifyOrQuit(addrCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sRecordCallbacks.IsEmpty());
+    recordCallback = sRecordCallbacks.GetHead();
+    VerifyOrQuit(recordCallback->mFirstLabel.Matches("mysrv"));
+    VerifyOrQuit(recordCallback->mNextLabels.Matches("_srv._udp"));
+    VerifyOrQuit(recordCallback->mRecordType == ResourceRecord::kTypeKey);
+    VerifyOrQuit(recordCallback->MatchesData(kKey2));
+    VerifyOrQuit(recordCallback->mTtl == 120);
+    VerifyOrQuit(recordCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send an updated response adding and removing addresses. Validate callback result.");
+    Log("Start another record querier for the same name and record type with different callback.");
 
-    SuccessOrQuit(addrs[0].mAddress.FromString("fd00::2"));
-    SuccessOrQuit(addrs[1].mAddress.FromString("fd00::aa"));
-    SuccessOrQuit(addrs[2].mAddress.FromString("fe80::bb"));
-    addrs[0].mTtl = 120;
-    addrs[1].mTtl = 120;
-    addrs[2].mTtl = 120;
+    ClearAllBytes(querier2);
 
-    AdvanceTime(1000);
+    querier2.mFirstLabel   = "mysrv";
+    querier2.mNextLabels   = "_srv._udp";
+    querier2.mRecordType   = ResourceRecord::kTypeKey;
+    querier2.mInfraIfIndex = kInfraIfIndex;
+    querier2.mCallback     = HandleRecordResultAlternate;
 
-    sAddrCallbacks.Clear();
+    sRecordCallbacks.Clear();
 
-    SendHostAddrResponse("myhost.local.", addrs, 3, /* aCachFlush */ true, kInAnswerSection);
+    SuccessOrQuit(mdns->StartRecordQuerier(querier2));
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
-    addrCallback = sAddrCallbacks.GetHead();
-    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(addrCallback->Matches(addrs, 3));
-    VerifyOrQuit(addrCallback->GetNext() == nullptr);
-
-    VerifyOrQuit(sDnsMessages.IsEmpty());
-
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a response without cache flush adding an address. Validate callback result.");
-
-    SuccessOrQuit(addrs[3].mAddress.FromString("fd00::3"));
-    addrs[3].mTtl = 500;
-
-    AdvanceTime(1000);
-
-    sAddrCallbacks.Clear();
+    Log("Validate callback result from cache for the new querier");
 
-    SendHostAddrResponse("myhost.local.", &addrs[3], 1, /* aCachFlush */ false, kInAnswerSection);
+    VerifyOrQuit(!sRecordCallbacks.IsEmpty());
+    recordCallback = sRecordCallbacks.GetHead();
 
-    AdvanceTime(1);
+    for (uint8_t num = 2; num > 0; num--)
+    {
+        VerifyOrQuit(recordCallback->mFirstLabel.Matches("mysrv"));
+        VerifyOrQuit(recordCallback->mNextLabels.Matches("_srv._udp"));
+        VerifyOrQuit(recordCallback->mRecordType == ResourceRecord::kTypeKey);
+        VerifyOrQuit(recordCallback->MatchesData(kKey2) || recordCallback->MatchesData(kKey1));
+        VerifyOrQuit(recordCallback->mTtl == 120);
+        recordCallback = recordCallback->GetNext();
+    }
 
-    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
-    addrCallback = sAddrCallbacks.GetHead();
-    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(addrCallback->Matches(addrs, 4));
-    VerifyOrQuit(addrCallback->GetNext() == nullptr);
+    VerifyOrQuit(recordCallback == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a response without cache flush with existing addresses. Validate that callback is not called.");
-
-    AdvanceTime(1000);
-
-    sAddrCallbacks.Clear();
-
-    SendHostAddrResponse("myhost.local.", &addrs[2], 2, /* aCachFlush */ false, kInAnswerSection);
-
-    AdvanceTime(1);
+    Log("Stop the second querier.");
 
-    VerifyOrQuit(sAddrCallbacks.IsEmpty());
-    VerifyOrQuit(sDnsMessages.IsEmpty());
+    SuccessOrQuit(mdns->StopRecordQuerier(querier2));
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a response without no changes to the list. Validate that callback is not called");
+    Log("Send a response (without cache-flush) with one previous record and a new record.");
 
-    AdvanceTime(1000);
+    records[0].mType       = ResourceRecord::kTypeKey;
+    records[0].mData       = kKey1;
+    records[0].mLength     = sizeof(kKey1);
+    records[0].mTtl        = 120;
+    records[0].mCacheFlush = false;
 
-    sAddrCallbacks.Clear();
+    records[1].mType       = ResourceRecord::kTypeKey;
+    records[1].mData       = kKey3;
+    records[1].mLength     = sizeof(kKey3);
+    records[1].mTtl        = 120;
+    records[1].mCacheFlush = false;
 
-    SendHostAddrResponse("myhost.local.", addrs, 4, /* aCachFlush */ true, kInAdditionalSection);
+    sRecordCallbacks.Clear();
+    SendRecordResponse("mysrv._srv._udp.local.", 2, records);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(sAddrCallbacks.IsEmpty());
-    VerifyOrQuit(sDnsMessages.IsEmpty());
-
-    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a response without cache flush updating TTL of existing address. Validate callback result.");
-
-    addrs[3].mTtl = 200;
-
-    AdvanceTime(1000);
-
-    sAddrCallbacks.Clear();
+    // Only key3 (which is new) should be reported.
 
-    SendHostAddrResponse("myhost.local.", &addrs[3], 1, /* aCachFlush */ false, kInAnswerSection);
-
-    AdvanceTime(1);
-
-    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
-    addrCallback = sAddrCallbacks.GetHead();
-    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(addrCallback->Matches(addrs, 4));
-    VerifyOrQuit(addrCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sRecordCallbacks.IsEmpty());
+    recordCallback = sRecordCallbacks.GetHead();
+    VerifyOrQuit(recordCallback->mFirstLabel.Matches("mysrv"));
+    VerifyOrQuit(recordCallback->mNextLabels.Matches("_srv._udp"));
+    VerifyOrQuit(recordCallback->mRecordType == ResourceRecord::kTypeKey);
+    VerifyOrQuit(recordCallback->MatchesData(kKey3));
+    VerifyOrQuit(recordCallback->mTtl == 120);
+    VerifyOrQuit(recordCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
+    AdvanceTime(5000);
+
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a response without cache flush removing an address (zero TTL). Validate callback result.");
+    Log("Send a response with one record, `key3` (cached-flush) and an extra record of different type");
 
-    addrs[3].mTtl = 0;
+    records[0].mType       = ResourceRecord::kTypeKey;
+    records[0].mData       = kKey3;
+    records[0].mLength     = sizeof(kKey3);
+    records[0].mTtl        = 120;
+    records[0].mCacheFlush = true;
 
-    AdvanceTime(1000);
+    // The second record is of type TXT, which should be ignored
+    // because it doesn't match the `RecordQuerier`. We intentionally
+    // use `kKey2` as record data to validate that the record type
+    // (TXT) and not just is indeed checked by the mDNS module.
 
-    sAddrCallbacks.Clear();
+    records[1].mType       = ResourceRecord::kTypeTxt;
+    records[1].mData       = kKey2;
+    records[1].mLength     = sizeof(kKey2);
+    records[1].mTtl        = 120;
+    records[1].mCacheFlush = true;
 
-    SendHostAddrResponse("myhost.local.", &addrs[3], 1, /* aCachFlush */ false, kInAnswerSection);
+    sRecordCallbacks.Clear();
+    SendRecordResponse("mysrv._srv._udp.local.", 2, records);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
-    addrCallback = sAddrCallbacks.GetHead();
-    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(addrCallback->Matches(addrs, 3));
-    VerifyOrQuit(addrCallback->GetNext() == nullptr);
-
-    VerifyOrQuit(sDnsMessages.IsEmpty());
-
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a response with cache flush removing all addresses. Validate callback result.");
-
-    addrs[0].mTtl = 0;
-
-    AdvanceTime(1000);
-
-    sAddrCallbacks.Clear();
-
-    SendHostAddrResponse("myhost.local.", addrs, 1, /* aCachFlush */ true, kInAnswerSection);
-
-    AdvanceTime(1);
+    Log("Validate callback result indicating the two other two keys are removed.");
 
-    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
-    addrCallback = sAddrCallbacks.GetHead();
-    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(addrCallback->Matches(addrs, 0));
-    VerifyOrQuit(addrCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sRecordCallbacks.IsEmpty());
+    recordCallback = sRecordCallbacks.GetHead();
+
+    for (uint8_t num = 2; num > 0; num--)
+    {
+        VerifyOrQuit(recordCallback->mFirstLabel.Matches("mysrv"));
+        VerifyOrQuit(recordCallback->mNextLabels.Matches("_srv._udp"));
+        VerifyOrQuit(recordCallback->mRecordType == ResourceRecord::kTypeKey);
+        VerifyOrQuit(recordCallback->MatchesData(kKey1) || recordCallback->MatchesData(kKey2));
+        VerifyOrQuit(recordCallback->mTtl == 0);
+        recordCallback = recordCallback->GetNext();
+    }
+
+    VerifyOrQuit(recordCallback == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
+    AdvanceTime(500);
+
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a response with addresses with different TTL. Validate callback result");
+    Log("Send a response removing key3 and other keys.");
 
-    SuccessOrQuit(addrs[0].mAddress.FromString("fd00::00"));
-    SuccessOrQuit(addrs[1].mAddress.FromString("fd00::11"));
-    SuccessOrQuit(addrs[2].mAddress.FromString("fe80::22"));
-    SuccessOrQuit(addrs[3].mAddress.FromString("fe80::33"));
-    addrs[0].mTtl = 120;
-    addrs[1].mTtl = 800;
-    addrs[2].mTtl = 2000;
-    addrs[3].mTtl = 8000;
+    records[0].mType       = ResourceRecord::kTypeKey;
+    records[0].mData       = kKey1;
+    records[0].mLength     = sizeof(kKey1);
+    records[0].mTtl        = 0;
+    records[0].mCacheFlush = false;
 
-    AdvanceTime(5 * 1000);
+    records[1].mType       = ResourceRecord::kTypeKey;
+    records[1].mData       = kKey2;
+    records[1].mLength     = sizeof(kKey2);
+    records[1].mTtl        = 0;
+    records[1].mCacheFlush = false;
 
-    sAddrCallbacks.Clear();
+    records[2].mType       = ResourceRecord::kTypeKey;
+    records[2].mData       = kKey3;
+    records[2].mLength     = sizeof(kKey3);
+    records[2].mTtl        = 0;
+    records[2].mCacheFlush = false;
 
-    SendHostAddrResponse("myhost.local.", addrs, 4, /* aCachFlush */ true, kInAnswerSection);
+    sRecordCallbacks.Clear();
+    SendRecordResponse("mysrv._srv._udp.local.", 3, records);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
-    addrCallback = sAddrCallbacks.GetHead();
-    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(addrCallback->Matches(addrs, 4));
-    VerifyOrQuit(addrCallback->GetNext() == nullptr);
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Validate callback result indicating key3 is now removed.");
+
+    VerifyOrQuit(!sRecordCallbacks.IsEmpty());
+    recordCallback = sRecordCallbacks.GetHead();
+    VerifyOrQuit(recordCallback->mFirstLabel.Matches("mysrv"));
+    VerifyOrQuit(recordCallback->mNextLabels.Matches("_srv._udp"));
+    VerifyOrQuit(recordCallback->mRecordType == ResourceRecord::kTypeKey);
+    VerifyOrQuit(recordCallback->MatchesData(kKey3));
+    VerifyOrQuit(recordCallback->mTtl == 0);
+    VerifyOrQuit(recordCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Start another resolver for the same host and different callback. Validate results.");
+    Log("Send a response adding two keys");
 
-    resolver2.mHostName     = "myhost";
-    resolver2.mInfraIfIndex = kInfraIfIndex;
-    resolver2.mCallback     = HandleAddrResultAlternate;
+    records[0].mType       = ResourceRecord::kTypeKey;
+    records[0].mData       = kKey1;
+    records[0].mLength     = sizeof(kKey1);
+    records[0].mTtl        = 500;
+    records[0].mCacheFlush = true;
 
-    sAddrCallbacks.Clear();
+    records[1].mType       = ResourceRecord::kTypeKey;
+    records[1].mData       = kKey2;
+    records[1].mLength     = sizeof(kKey2);
+    records[1].mTtl        = 500;
+    records[1].mCacheFlush = true;
 
-    SuccessOrQuit(mdns->StartIp6AddressResolver(resolver2));
+    sRecordCallbacks.Clear();
+    SendRecordResponse("mysrv._srv._udp.local.", 2, records);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
-    addrCallback = sAddrCallbacks.GetHead();
-    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(addrCallback->Matches(addrs, 4));
-    VerifyOrQuit(addrCallback->GetNext() == nullptr);
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Validate callback results");
+
+    VerifyOrQuit(!sRecordCallbacks.IsEmpty());
+    recordCallback = sRecordCallbacks.GetHead();
+
+    for (uint8_t num = 2; num > 0; num--)
+    {
+        VerifyOrQuit(recordCallback->mFirstLabel.Matches("mysrv"));
+        VerifyOrQuit(recordCallback->mNextLabels.Matches("_srv._udp"));
+        VerifyOrQuit(recordCallback->mRecordType == ResourceRecord::kTypeKey);
+        VerifyOrQuit(recordCallback->MatchesData(kKey1) || recordCallback->MatchesData(kKey2));
+        VerifyOrQuit(recordCallback->mTtl == 500);
+        recordCallback = recordCallback->GetNext();
+    }
+
+    VerifyOrQuit(recordCallback == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
+    AdvanceTime(5000);
+
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Start same resolver again and check the returned error.");
+    Log("Send a response changing the TTL for key1");
 
-    sAddrCallbacks.Clear();
+    records[0].mType       = ResourceRecord::kTypeKey;
+    records[0].mData       = kKey1;
+    records[0].mLength     = sizeof(kKey1);
+    records[0].mTtl        = 120;
+    records[0].mCacheFlush = false;
 
-    VerifyOrQuit(mdns->StartIp6AddressResolver(resolver2) == kErrorAlready);
+    sRecordCallbacks.Clear();
+    SendRecordResponse("mysrv._srv._udp.local.", 1, records);
 
-    AdvanceTime(5000);
+    AdvanceTime(1);
 
-    VerifyOrQuit(sAddrCallbacks.IsEmpty());
-    sDnsMessages.Clear();
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Validate callback results indicating key1 TTL change");
+
+    VerifyOrQuit(!sRecordCallbacks.IsEmpty());
+    recordCallback = sRecordCallbacks.GetHead();
+    VerifyOrQuit(recordCallback->mFirstLabel.Matches("mysrv"));
+    VerifyOrQuit(recordCallback->mNextLabels.Matches("_srv._udp"));
+    VerifyOrQuit(recordCallback->mRecordType == ResourceRecord::kTypeKey);
+    VerifyOrQuit(recordCallback->MatchesData(kKey1));
+    VerifyOrQuit(recordCallback->mTtl == 120);
+    VerifyOrQuit(recordCallback->GetNext() == nullptr);
+
+    VerifyOrQuit(sDnsMessages.IsEmpty());
+
+    sRecordCallbacks.Clear();
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Check query is sent at 80 percentage of TTL and then respond to it.");
 
-    SendHostAddrResponse("myhost.local.", addrs, 4, /* aCachFlush */ true, kInAnswerSection);
-
     // First query should be sent at 80-82% of TTL of 120 second (96.0-98.4 sec).
     // We wait for 100 second. Note that 5 seconds already passed in the
     // previous step.
@@ -6545,15 +7928,15 @@ void TestIp6AddrResolver(void)
     VerifyOrQuit(!sDnsMessages.IsEmpty());
     dnsMsg = sDnsMessages.GetHead();
     dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 0);
-    dnsMsg->ValidateAsQueryFor(resolver);
+    dnsMsg->ValidateAsQueryFor(querier);
     VerifyOrQuit(dnsMsg->GetNext() == nullptr);
 
     sDnsMessages.Clear();
-    VerifyOrQuit(sAddrCallbacks.IsEmpty());
+    VerifyOrQuit(sRecordCallbacks.IsEmpty());
 
     AdvanceTime(10);
 
-    SendHostAddrResponse("myhost.local.", addrs, 4, /* aCachFlush */ true, kInAnswerSection);
+    SendRecordResponse("mysrv._srv._udp.local.", 1, records);
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
     Log("Check queries are sent at 80, 85, 90, 95 percentages of TTL.");
@@ -6583,157 +7966,385 @@ void TestIp6AddrResolver(void)
         VerifyOrQuit(!sDnsMessages.IsEmpty());
         dnsMsg = sDnsMessages.GetHead();
         dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 0);
-        dnsMsg->ValidateAsQueryFor(resolver);
+        dnsMsg->ValidateAsQueryFor(querier);
         VerifyOrQuit(dnsMsg->GetNext() == nullptr);
 
         sDnsMessages.Clear();
-        VerifyOrQuit(sAddrCallbacks.IsEmpty());
+        VerifyOrQuit(sRecordCallbacks.IsEmpty());
     }
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Check TTL timeout of first address (TTL 120) and callback result.");
+    Log("Check TTL timeout and callback result.");
 
     AdvanceTime(6 * 1000);
 
-    addrCallback = sAddrCallbacks.GetHead();
+    VerifyOrQuit(!sRecordCallbacks.IsEmpty());
+    recordCallback = sRecordCallbacks.GetHead();
+    VerifyOrQuit(recordCallback->mFirstLabel.Matches("mysrv"));
+    VerifyOrQuit(recordCallback->mNextLabels.Matches("_srv._udp"));
+    VerifyOrQuit(recordCallback->mRecordType == ResourceRecord::kTypeKey);
+    VerifyOrQuit(recordCallback->MatchesData(kKey1));
+    VerifyOrQuit(recordCallback->mTtl == 0);
+    VerifyOrQuit(recordCallback->GetNext() == nullptr);
 
-    for (uint8_t iter = 0; iter < 2; iter++)
-    {
-        VerifyOrQuit(addrCallback != nullptr);
-        VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
-        VerifyOrQuit(addrCallback->Matches(&addrs[1], 3));
-        addrCallback = addrCallback->GetNext();
-    }
+    VerifyOrQuit(sDnsMessages.IsEmpty());
 
-    VerifyOrQuit(addrCallback == nullptr);
+#if OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Check the list of `RecordQueier` entries and the cache-info");
+
+    iterator = mdns->AllocateIterator();
+    VerifyOrQuit(iterator != nullptr);
+
+    SuccessOrQuit(mdns->GetNextRecordQuerier(*iterator, querier2, cacheInfo));
+    VerifyOrQuit(querier2.mRecordType == ResourceRecord::kTypeKey);
+    VerifyOrQuit(StringMatch(querier2.mFirstLabel, "mysrv", kStringCaseInsensitiveMatch));
+    VerifyOrQuit(StringMatch(querier2.mNextLabels, "_srv._udp", kStringCaseInsensitiveMatch));
+
+    VerifyOrQuit(cacheInfo.mIsActive);
+    VerifyOrQuit(cacheInfo.mHasCachedResults);
+
+    VerifyOrQuit(mdns->GetNextRecordQuerier(*iterator, querier2, cacheInfo) == kErrorNotFound);
+
+    mdns->FreeIterator(*iterator);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Stop the record querier");
+
+    SuccessOrQuit(mdns->StopRecordQuerier(querier));
+
+    sDnsMessages.Clear();
+
+    AdvanceTime(10);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Check the list of `RecordQueier` entries and cache-info after stop (no longer active)");
+
+    iterator = mdns->AllocateIterator();
+    VerifyOrQuit(iterator != nullptr);
+
+    SuccessOrQuit(mdns->GetNextRecordQuerier(*iterator, querier2, cacheInfo));
+    VerifyOrQuit(querier2.mRecordType == ResourceRecord::kTypeKey);
+    VerifyOrQuit(StringMatch(querier2.mFirstLabel, "mysrv", kStringCaseInsensitiveMatch));
+    VerifyOrQuit(StringMatch(querier2.mNextLabels, "_srv._udp", kStringCaseInsensitiveMatch));
+
+    VerifyOrQuit(!cacheInfo.mIsActive);
+    VerifyOrQuit(cacheInfo.mHasCachedResults);
+
+    VerifyOrQuit(mdns->GetNextRecordQuerier(*iterator, querier2, cacheInfo) == kErrorNotFound);
+
+    mdns->FreeIterator(*iterator);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Check the `RecordQuerier` is correctly removed after 'remove timeout' of 7 minutes");
 
+    AdvanceTime(7 * 60 * 1000);
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
+    iterator = mdns->AllocateIterator();
+    VerifyOrQuit(iterator != nullptr);
+
+    VerifyOrQuit(mdns->GetNextRecordQuerier(*iterator, querier2, cacheInfo) == kErrorNotFound);
+
+    mdns->FreeIterator(*iterator);
+
+#endif // OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
+
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Check TTL timeout of next address (TTL 800) and callback result.");
 
-    sAddrCallbacks.Clear();
+    SuccessOrQuit(mdns->SetEnabled(false, kInfraIfIndex));
+    VerifyOrQuit(sHeapAllocatedPtrs.GetLength() <= heapAllocations);
 
-    AdvanceTime((800 - 120) * 1000);
+    Log("End of test");
 
-    addrCallback = sAddrCallbacks.GetHead();
+    testFreeInstance(sInstance);
+}
 
-    for (uint8_t iter = 0; iter < 2; iter++)
-    {
-        VerifyOrQuit(addrCallback != nullptr);
-        VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
-        VerifyOrQuit(addrCallback->Matches(&addrs[2], 2));
-        addrCallback = addrCallback->GetNext();
-    }
+void TestRecordQuerierForAny(void)
+{
+    static constexpr uint8_t kMaxResponseRecords = 6;
 
-    VerifyOrQuit(addrCallback == nullptr);
+    Core                 *mdns = InitTest();
+    Core::RecordQuerier   querier;
+    Core::RecordQuerier   querier2;
+    Core::Iterator       *iterator;
+    Core::CacheInfo       cacheInfo;
+    const DnsMessage     *dnsMsg;
+    const RecordCallback *recordCallback;
+    uint16_t              heapAllocations;
+    RecordData            records[kMaxResponseRecords];
+
+    Log("-------------------------------------------------------------------------------------------");
+    Log("TestRecordQuerierForAny");
+
+    AdvanceTime(1);
+
+    heapAllocations = sHeapAllocatedPtrs.GetLength();
+    SuccessOrQuit(mdns->SetEnabled(true, kInfraIfIndex));
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Start a record querier for ANY record type. Validate initial queries.");
+
+    ClearAllBytes(querier);
+
+    querier.mFirstLabel   = "mysrv";
+    querier.mNextLabels   = "_srv._udp";
+    querier.mRecordType   = ResourceRecord::kTypeAny;
+    querier.mInfraIfIndex = kInfraIfIndex;
+    querier.mCallback     = HandleRecordResult;
 
-    sAddrCallbacks.Clear();
     sDnsMessages.Clear();
+    SuccessOrQuit(mdns->StartRecordQuerier(querier));
 
-    AdvanceTime(200 * 1000);
+    for (uint8_t queryCount = 0; queryCount < kNumInitalQueries; queryCount++)
+    {
+        sDnsMessages.Clear();
 
-    VerifyOrQuit(sAddrCallbacks.IsEmpty());
+        AdvanceTime((queryCount == 0) ? 125 : (1U << (queryCount - 1)) * 1000);
+
+        VerifyOrQuit(!sDnsMessages.IsEmpty());
+        dnsMsg = sDnsMessages.GetHead();
+        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 0);
+        dnsMsg->ValidateAsQueryFor(querier);
+        VerifyOrQuit(dnsMsg->GetNext() == nullptr);
+    }
+
+    sDnsMessages.Clear();
+
+    AdvanceTime(20 * 1000);
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Stop the second resolver");
+    Log("Send a response. Validate callback result.");
 
-    sAddrCallbacks.Clear();
+    records[0].mType       = ResourceRecord::kTypeKey;
+    records[0].mData       = kKey1;
+    records[0].mLength     = sizeof(kKey1);
+    records[0].mTtl        = 120;
+    records[0].mCacheFlush = false;
 
-    SuccessOrQuit(mdns->StopIp6AddressResolver(resolver2));
+    sRecordCallbacks.Clear();
+    SendRecordResponse("mysrv._srv._udp.local.", 1, records);
 
-    AdvanceTime(100 * 1000);
+    AdvanceTime(1);
+
+    VerifyOrQuit(!sRecordCallbacks.IsEmpty());
+    recordCallback = sRecordCallbacks.GetHead();
+    VerifyOrQuit(recordCallback->mFirstLabel.Matches("mysrv"));
+    VerifyOrQuit(recordCallback->mNextLabels.Matches("_srv._udp"));
+    VerifyOrQuit(recordCallback->mRecordType == ResourceRecord::kTypeKey);
+    VerifyOrQuit(recordCallback->MatchesData(kKey1));
+    VerifyOrQuit(recordCallback->mTtl == 120);
+    VerifyOrQuit(recordCallback->GetNext() == nullptr);
 
-    VerifyOrQuit(sAddrCallbacks.IsEmpty());
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Send a new response and make sure result callback is invoked");
+    Log("Send a second response for a different record type. Validate callback result.");
 
-    sAddrCallbacks.Clear();
+    records[0].mType       = ResourceRecord::kTypeTxt;
+    records[0].mData       = kKey2;
+    records[0].mLength     = sizeof(kKey2);
+    records[0].mTtl        = 400;
+    records[0].mCacheFlush = true;
 
-    SendHostAddrResponse("myhost.local.", addrs, 1, /* aCachFlush */ true, kInAnswerSection);
+    sRecordCallbacks.Clear();
+    SendRecordResponse("mysrv._srv._udp.local.", 1, records);
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
-    addrCallback = sAddrCallbacks.GetHead();
-    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(addrCallback->Matches(addrs, 1));
-    VerifyOrQuit(addrCallback->GetNext() == nullptr);
+    VerifyOrQuit(!sRecordCallbacks.IsEmpty());
+    recordCallback = sRecordCallbacks.GetHead();
+    VerifyOrQuit(recordCallback->mFirstLabel.Matches("mysrv"));
+    VerifyOrQuit(recordCallback->mNextLabels.Matches("_srv._udp"));
+    VerifyOrQuit(recordCallback->mRecordType == ResourceRecord::kTypeTxt);
+    VerifyOrQuit(recordCallback->MatchesData(kKey2));
+    VerifyOrQuit(recordCallback->mTtl == 400);
+    VerifyOrQuit(recordCallback->GetNext() == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Stop the resolver. There is no active resolver. Ensure no queries are sent");
+    Log("Send a response with multiple record of different types");
 
-    sAddrCallbacks.Clear();
+    records[0].mType       = ResourceRecord::kTypeKey;
+    records[0].mData       = kKey1;
+    records[0].mLength     = sizeof(kKey1);
+    records[0].mTtl        = 200;
+    records[0].mCacheFlush = false;
 
-    SuccessOrQuit(mdns->StopIp6AddressResolver(resolver));
+    records[1].mType       = ResourceRecord::kTypeTxt;
+    records[1].mData       = kKey2;
+    records[1].mLength     = sizeof(kKey2);
+    records[1].mTtl        = 300;
+    records[1].mCacheFlush = true;
 
-    AdvanceTime(20 * 1000);
+    records[2].mType       = ResourceRecord::kTypeKey;
+    records[2].mData       = kKey2;
+    records[2].mLength     = sizeof(kKey2);
+    records[2].mTtl        = 200;
+    records[2].mCacheFlush = false;
 
-    VerifyOrQuit(sAddrCallbacks.IsEmpty());
+    records[3].mType       = ResourceRecord::kTypeKey;
+    records[3].mData       = kKey3;
+    records[3].mLength     = sizeof(kKey3);
+    records[3].mTtl        = 200;
+    records[3].mCacheFlush = false;
+
+    sRecordCallbacks.Clear();
+    SendRecordResponse("mysrv._srv._udp.local.", 4, records);
+
+    AdvanceTime(1);
+
+    VerifyOrQuit(!sRecordCallbacks.IsEmpty());
+    recordCallback = sRecordCallbacks.GetHead();
+
+    for (uint8_t num = 4; num > 0; num--)
+    {
+        VerifyOrQuit(recordCallback != nullptr);
+        VerifyOrQuit(recordCallback->mFirstLabel.Matches("mysrv"));
+        VerifyOrQuit(recordCallback->mNextLabels.Matches("_srv._udp"));
+
+        if (recordCallback->mRecordType == ResourceRecord::kTypeTxt)
+        {
+            VerifyOrQuit(recordCallback->MatchesData(kKey2));
+            VerifyOrQuit(recordCallback->mTtl == 300);
+        }
+        else if (recordCallback->mRecordType == ResourceRecord::kTypeKey)
+        {
+            VerifyOrQuit(recordCallback->mTtl == 200);
+            VerifyOrQuit(recordCallback->MatchesData(kKey1) || recordCallback->MatchesData(kKey2) ||
+                         recordCallback->MatchesData(kKey3));
+        }
+        else
+        {
+            VerifyOrQuit(false);
+        }
+
+        recordCallback = recordCallback->GetNext();
+    }
+
+    VerifyOrQuit(recordCallback == nullptr);
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Restart the resolver with more than half of TTL remaining.");
-    Log("Ensure cached entry is reported in the result callback and no queries are sent.");
+    Log("Start another record querier for the same name with different callback.");
 
-    SuccessOrQuit(mdns->StartIp6AddressResolver(resolver));
+    ClearAllBytes(querier2);
+
+    querier2.mFirstLabel   = "mysrv";
+    querier2.mNextLabels   = "_srv._udp";
+    querier2.mRecordType   = ResourceRecord::kTypeAny;
+    querier2.mInfraIfIndex = kInfraIfIndex;
+    querier2.mCallback     = HandleRecordResultAlternate;
+
+    sRecordCallbacks.Clear();
+    SuccessOrQuit(mdns->StartRecordQuerier(querier2));
 
     AdvanceTime(1);
 
-    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
-    addrCallback = sAddrCallbacks.GetHead();
-    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(addrCallback->Matches(addrs, 1));
-    VerifyOrQuit(addrCallback->GetNext() == nullptr);
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Validate callback result from cache for the new querier");
 
-    VerifyOrQuit(sDnsMessages.IsEmpty());
+    VerifyOrQuit(!sRecordCallbacks.IsEmpty());
+    recordCallback = sRecordCallbacks.GetHead();
 
-    AdvanceTime(20 * 1000);
+    for (uint8_t num = 4; num > 0; num--)
+    {
+        VerifyOrQuit(recordCallback != nullptr);
+        VerifyOrQuit(recordCallback->mFirstLabel.Matches("mysrv"));
+        VerifyOrQuit(recordCallback->mNextLabels.Matches("_srv._udp"));
+
+        if (recordCallback->mRecordType == ResourceRecord::kTypeTxt)
+        {
+            VerifyOrQuit(recordCallback->MatchesData(kKey2));
+            VerifyOrQuit(recordCallback->mTtl == 300);
+        }
+        else if (recordCallback->mRecordType == ResourceRecord::kTypeKey)
+        {
+            VerifyOrQuit(recordCallback->mTtl == 200);
+            VerifyOrQuit(recordCallback->MatchesData(kKey1) || recordCallback->MatchesData(kKey2) ||
+                         recordCallback->MatchesData(kKey3));
+        }
+        else
+        {
+            VerifyOrQuit(false);
+        }
+
+        recordCallback = recordCallback->GetNext();
+    }
+
+    VerifyOrQuit(recordCallback == nullptr);
 
     VerifyOrQuit(sDnsMessages.IsEmpty());
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-    Log("Stop and start the resolver again after less than half TTL remaining.");
-    Log("Ensure cached entry is still reported in the result callback but queries should be sent");
+    Log("Stop the second querier.");
 
-    sAddrCallbacks.Clear();
+    SuccessOrQuit(mdns->StopRecordQuerier(querier2));
 
-    SuccessOrQuit(mdns->StopIp6AddressResolver(resolver));
+#if OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
 
-    AdvanceTime(25 * 1000);
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Check the list of `RecordQueier` entries and the cache-info");
 
-    SuccessOrQuit(mdns->StartIp6AddressResolver(resolver));
+    iterator = mdns->AllocateIterator();
+    VerifyOrQuit(iterator != nullptr);
 
-    AdvanceTime(1);
+    SuccessOrQuit(mdns->GetNextRecordQuerier(*iterator, querier2, cacheInfo));
+    VerifyOrQuit(querier2.mRecordType == ResourceRecord::kTypeAny);
+    VerifyOrQuit(StringMatch(querier2.mFirstLabel, "mysrv", kStringCaseInsensitiveMatch));
+    VerifyOrQuit(StringMatch(querier2.mNextLabels, "_srv._udp", kStringCaseInsensitiveMatch));
 
-    VerifyOrQuit(!sAddrCallbacks.IsEmpty());
-    addrCallback = sAddrCallbacks.GetHead();
-    VerifyOrQuit(addrCallback->mHostName.Matches("myhost"));
-    VerifyOrQuit(addrCallback->Matches(addrs, 1));
-    VerifyOrQuit(addrCallback->GetNext() == nullptr);
+    VerifyOrQuit(cacheInfo.mIsActive);
+    VerifyOrQuit(cacheInfo.mHasCachedResults);
 
-    sAddrCallbacks.Clear();
+    VerifyOrQuit(mdns->GetNextRecordQuerier(*iterator, querier2, cacheInfo) == kErrorNotFound);
 
-    AdvanceTime(15 * 1000);
+    mdns->FreeIterator(*iterator);
 
-    dnsMsg = sDnsMessages.GetHead();
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Stop the record querier");
 
-    for (uint8_t queryCount = 0; queryCount < kNumInitalQueries; queryCount++)
-    {
-        VerifyOrQuit(dnsMsg != nullptr);
-        dnsMsg->ValidateHeader(kMulticastQuery, /* Q */ 1, /* Ans */ 0, /* Auth */ 0, /* Addnl */ 0);
-        dnsMsg->ValidateAsQueryFor(resolver);
-        dnsMsg = dnsMsg->GetNext();
-    }
+    SuccessOrQuit(mdns->StopRecordQuerier(querier));
 
-    VerifyOrQuit(dnsMsg == nullptr);
+    sDnsMessages.Clear();
+
+    AdvanceTime(10);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Check the list of `RecordQueier` entries and cache-info after stop (no longer active)");
+
+    iterator = mdns->AllocateIterator();
+    VerifyOrQuit(iterator != nullptr);
+
+    SuccessOrQuit(mdns->GetNextRecordQuerier(*iterator, querier2, cacheInfo));
+    VerifyOrQuit(querier2.mRecordType == ResourceRecord::kTypeAny);
+    VerifyOrQuit(StringMatch(querier2.mFirstLabel, "mysrv", kStringCaseInsensitiveMatch));
+    VerifyOrQuit(StringMatch(querier2.mNextLabels, "_srv._udp", kStringCaseInsensitiveMatch));
+
+    VerifyOrQuit(!cacheInfo.mIsActive);
+    VerifyOrQuit(cacheInfo.mHasCachedResults);
+
+    VerifyOrQuit(mdns->GetNextRecordQuerier(*iterator, querier2, cacheInfo) == kErrorNotFound);
+
+    mdns->FreeIterator(*iterator);
+
+    Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+    Log("Check the `RecordQuerier` is correctly removed after 'remove timeout' of 1 minutes");
+
+    AdvanceTime(1 * 60 * 1000);
+    VerifyOrQuit(sDnsMessages.IsEmpty());
+
+    iterator = mdns->AllocateIterator();
+    VerifyOrQuit(iterator != nullptr);
+
+    VerifyOrQuit(mdns->GetNextRecordQuerier(*iterator, querier2, cacheInfo) == kErrorNotFound);
+
+    mdns->FreeIterator(*iterator);
+
+#endif // OPENTHREAD_CONFIG_MULTICAST_DNS_ENTRY_ITERATION_API_ENABLE
 
     Log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
 
@@ -7269,6 +8880,7 @@ int main(void)
 {
 #if OPENTHREAD_CONFIG_MULTICAST_DNS_ENABLE
     ot::Dns::Multicast::TestHostReg();
+    ot::Dns::Multicast::TestLocalHost();
     ot::Dns::Multicast::TestKeyReg();
     ot::Dns::Multicast::TestServiceReg();
     ot::Dns::Multicast::TestUnregisterBeforeProbeFinished();
@@ -7286,6 +8898,8 @@ int main(void)
     ot::Dns::Multicast::TestSrvResolver();
     ot::Dns::Multicast::TestTxtResolver();
     ot::Dns::Multicast::TestIp6AddrResolver();
+    ot::Dns::Multicast::TestRecordQuerier();
+    ot::Dns::Multicast::TestRecordQuerierForAny();
     ot::Dns::Multicast::TestPassiveCache();
     ot::Dns::Multicast::TestLegacyUnicastResponse();
 
diff --git a/tests/unit/test_ncp_cli.cpp b/tests/unit/test_ncp_cli.cpp
new file mode 100644
index 000000000..a2ca06d45
--- /dev/null
+++ b/tests/unit/test_ncp_cli.cpp
@@ -0,0 +1,104 @@
+/*
+ *  Copyright (c) 2025, The OpenThread Authors.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. Neither the name of the copyright holder nor the
+ *     names of its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdio.h>
+
+#include "test_platform.h"
+#include "test_util.h"
+#include "common/code_utils.hpp"
+#include "lib/spinel/spinel_buffer.hpp"
+#include "lib/spinel/spinel_encoder.hpp"
+#include "ncp/ncp_base.hpp"
+
+#if OPENTHREAD_CONFIG_NCP_CLI_STREAM_ENABLE
+
+namespace ot {
+
+constexpr uint16_t kMaxSpinelBufferSize = 2048;
+
+static otError GenerateSpinelCliCommandFrame(const char *aCommand, uint8_t *aBuf, uint16_t &aLen)
+{
+    otError         error = OT_ERROR_NONE;
+    uint8_t         buf[kMaxSpinelBufferSize];
+    Spinel::Buffer  ncpBuffer(buf, kMaxSpinelBufferSize);
+    Spinel::Encoder encoder(ncpBuffer);
+
+    uint8_t header = SPINEL_HEADER_FLAG | 0 /* Iid */ | 1 /* Tid */;
+    SuccessOrExit(error = encoder.BeginFrame(header, SPINEL_CMD_PROP_VALUE_SET, SPINEL_PROP_STREAM_CLI));
+    SuccessOrExit(error = encoder.WriteUtf8(aCommand));
+    SuccessOrExit(error = encoder.EndFrame());
+
+    SuccessOrExit(ncpBuffer.OutFrameBegin());
+    aLen = ncpBuffer.OutFrameGetLength();
+    VerifyOrExit(ncpBuffer.OutFrameRead(aLen, aBuf) == aLen, error = OT_ERROR_FAILED);
+
+exit:
+    return error;
+}
+
+void TestNcpCliCommand(void)
+{
+    Instance    *instance = static_cast<Instance *>(testInitInstance());
+    Ncp::NcpBase ncpBase(instance);
+
+    uint8_t  recvBuf[kMaxSpinelBufferSize];
+    uint16_t recvLen;
+
+    {
+        // Test IPv6 interface bring up
+        constexpr char cliCommand[] = "ifconfig up";
+
+        SuccessOrQuit(GenerateSpinelCliCommandFrame(cliCommand, recvBuf, recvLen));
+        ncpBase.HandleReceive(recvBuf, recvLen);
+        VerifyOrQuit(otIp6IsEnabled(instance) == true);
+    }
+
+    {
+        // Test Thread network name set
+        constexpr char cliCommand[] = "networkname Test";
+
+        SuccessOrQuit(GenerateSpinelCliCommandFrame(cliCommand, recvBuf, recvLen));
+        ncpBase.HandleReceive(recvBuf, recvLen);
+        VerifyOrQuit(strcmp(otThreadGetNetworkName(instance), "Test") == 0);
+    }
+
+    printf("Test Ncp Cli Command passed.\n");
+}
+
+} // namespace ot
+
+#endif // OPENTHREAD_CONFIG_NCP_CLI_STREAM_ENABLE
+
+int main(void)
+{
+#if OPENTHREAD_CONFIG_NCP_CLI_STREAM_ENABLE
+    ot::TestNcpCliCommand();
+#endif
+    printf("All tests passed\n");
+    return 0;
+}
diff --git a/tests/unit/test_platform.cpp b/tests/unit/test_platform.cpp
index f5a246f22..ebe2e821c 100644
--- a/tests/unit/test_platform.cpp
+++ b/tests/unit/test_platform.cpp
@@ -700,6 +700,13 @@ otError otPlatUdpLeaveMulticastGroup(otUdpSocket        *aUdpSocket,
 #endif // OPENTHREAD_CONFIG_PLATFORM_UDP_ENABLE
 
 #if OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE
+bool otPlatDnsIsUpstreamQueryAvailable(otInstance *aInstance)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+
+    return true;
+}
+
 void otPlatDnsStartUpstreamQuery(otInstance *aInstance, otPlatDnsUpstreamQuery *aTxn, const otMessage *aQuery)
 {
     OT_UNUSED_VARIABLE(aInstance);
@@ -963,6 +970,18 @@ OT_TOOL_WEAK void otPlatDnssdStopIp4AddressResolver(otInstance *aInstance, const
     OT_UNUSED_VARIABLE(aResolver);
 }
 
+OT_TOOL_WEAK void otPlatDnssdStartRecordQuerier(otInstance *aInstance, const otPlatDnssdRecordQuerier *aQuerier)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    OT_UNUSED_VARIABLE(aQuerier);
+}
+
+OT_TOOL_WEAK void otPlatDnssdStopRecordQuerier(otInstance *aInstance, const otPlatDnssdRecordQuerier *aQuerier)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    OT_UNUSED_VARIABLE(aQuerier);
+}
+
 #endif // OPENTHREAD_CONFIG_PLATFORM_DNSSD_ENABLE
 
 #if OPENTHREAD_CONFIG_PLATFORM_LOG_CRASH_DUMP_ENABLE
diff --git a/tests/unit/test_routing_manager.cpp b/tests/unit/test_routing_manager.cpp
index 50b3b3dc2..8f3f028c3 100644
--- a/tests/unit/test_routing_manager.cpp
+++ b/tests/unit/test_routing_manager.cpp
@@ -612,6 +612,22 @@ void LogRouterAdvert(const Icmp6Packet &aPacket)
             break;
         }
 
+        case Ip6::Nd::Option::kTypeRecursiveDnsServer:
+        {
+            const Ip6::Nd::RecursiveDnsServerOption &rdnss =
+                static_cast<const Ip6::Nd::RecursiveDnsServerOption &>(option);
+
+            VerifyOrQuit(rdnss.IsValid());
+
+            for (uint8_t index = 0; index < rdnss.GetNumAddresses(); index++)
+            {
+                Log("     RDNSS - %s, lifetime:%u", rdnss.GetAddressAt(index).ToString().AsCString(),
+                    rdnss.GetLifetime());
+            }
+
+            break;
+        }
+
         default:
             VerifyOrQuit(false, "Bad option type in RA msg");
         }
@@ -693,7 +709,7 @@ Ip6::Address AddressFromString(const char *aString)
     return address;
 }
 
-void VerifyOmrPrefixInNetData(const Ip6::Prefix &aOmrPrefix, bool aDefaultRoute)
+void VerifyOmrPrefixInNetData(const Ip6::Prefix &aOmrPrefix, bool aDefaultRoute, RoutePreference *aPreference = nullptr)
 {
     otNetworkDataIterator           iterator = OT_NETWORK_DATA_ITERATOR_INIT;
     NetworkData::OnMeshPrefixConfig prefixConfig;
@@ -708,6 +724,11 @@ void VerifyOmrPrefixInNetData(const Ip6::Prefix &aOmrPrefix, bool aDefaultRoute)
     VerifyOrQuit(prefixConfig.mOnMesh == true);
     VerifyOrQuit(prefixConfig.mDefaultRoute == aDefaultRoute);
 
+    if (aPreference != nullptr)
+    {
+        VerifyOrQuit(prefixConfig.mPreference == *aPreference);
+    }
+
     VerifyOrQuit(otNetDataGetNextOnMeshPrefix(sInstance, &iterator, &prefixConfig) == kErrorNotFound);
 }
 
@@ -847,11 +868,32 @@ struct RaFlags : public Clearable<RaFlags>
     bool mSnacRouterFlag;
 };
 
+struct Rdnss
+{
+    template <uint16_t kNumAddrs> static Rdnss Create(uint32_t aLifetime, const Ip6::Address (&aAddresses)[kNumAddrs])
+    {
+        return Rdnss(aLifetime, aAddresses, kNumAddrs);
+    }
+
+    Rdnss(uint32_t aLifetime, const Ip6::Address *aAddresses, uint8_t aNumAddresses)
+        : mLifetime(aLifetime)
+        , mAddresses(aAddresses)
+        , mNumAddresses(aNumAddresses)
+    {
+    }
+
+    uint32_t            mLifetime;
+    const Ip6::Address *mAddresses;
+    uint8_t             mNumAddresses;
+};
+
 void BuildRouterAdvert(Ip6::Nd::RouterAdvert::TxMessage &aRaMsg,
                        const Pio                        *aPios,
                        uint16_t                          aNumPios,
                        const Rio                        *aRios,
                        uint16_t                          aNumRios,
+                       const Rdnss                      *aRdnsses,
+                       uint16_t                          aNumRdnsses,
                        const DefaultRoute               &aDefaultRoute,
                        const RaFlags                    &aRaFlags)
 {
@@ -886,6 +928,12 @@ void BuildRouterAdvert(Ip6::Nd::RouterAdvert::TxMessage &aRaMsg,
     {
         SuccessOrQuit(aRaMsg.AppendRouteInfoOption(aRios->mPrefix, aRios->mValidLifetime, aRios->mPreference));
     }
+
+    for (; aNumRdnsses > 0; aRdnsses++, aNumRdnsses--)
+    {
+        SuccessOrQuit(
+            aRaMsg.AppendRecursiveDnsServerOption(aRdnsses->mAddresses, aRdnsses->mNumAddresses, aRdnsses->mLifetime));
+    }
 }
 
 void SendRouterAdvert(const Ip6::Address &aRouterAddress,
@@ -893,13 +941,15 @@ void SendRouterAdvert(const Ip6::Address &aRouterAddress,
                       uint16_t            aNumPios,
                       const Rio          *aRios,
                       uint16_t            aNumRios,
+                      const Rdnss        *aRdnsses,
+                      uint16_t            aNumRdnsses,
                       const DefaultRoute &aDefaultRoute,
                       const RaFlags      &aRaFlags)
 {
     Ip6::Nd::RouterAdvert::TxMessage raMsg;
     Icmp6Packet                      packet;
 
-    BuildRouterAdvert(raMsg, aPios, aNumPios, aRios, aNumRios, aDefaultRoute, aRaFlags);
+    BuildRouterAdvert(raMsg, aPios, aNumPios, aRios, aNumRios, aRdnsses, aNumRdnsses, aDefaultRoute, aRaFlags);
     raMsg.GetAsPacket(packet);
 
     SendRouterAdvert(aRouterAddress, packet);
@@ -914,7 +964,7 @@ void SendRouterAdvert(const Ip6::Address &aRouterAddress,
                       const DefaultRoute &aDefaultRoute = DefaultRoute(0, NetworkData::kRoutePreferenceMedium),
                       const RaFlags      &aRaFlags      = RaFlags())
 {
-    SendRouterAdvert(aRouterAddress, aPios, kNumPios, aRios, kNumRios, aDefaultRoute, aRaFlags);
+    SendRouterAdvert(aRouterAddress, aPios, kNumPios, aRios, kNumRios, nullptr, 0, aDefaultRoute, aRaFlags);
 }
 
 template <uint16_t kNumPios>
@@ -923,7 +973,7 @@ void SendRouterAdvert(const Ip6::Address &aRouterAddress,
                       const DefaultRoute &aDefaultRoute = DefaultRoute(0, NetworkData::kRoutePreferenceMedium),
                       const RaFlags      &aRaFlags      = RaFlags())
 {
-    SendRouterAdvert(aRouterAddress, aPios, kNumPios, nullptr, 0, aDefaultRoute, aRaFlags);
+    SendRouterAdvert(aRouterAddress, aPios, kNumPios, nullptr, 0, nullptr, 0, aDefaultRoute, aRaFlags);
 }
 
 template <uint16_t kNumRios>
@@ -932,20 +982,33 @@ void SendRouterAdvert(const Ip6::Address &aRouterAddress,
                       const DefaultRoute &aDefaultRoute = DefaultRoute(0, NetworkData::kRoutePreferenceMedium),
                       const RaFlags      &aRaFlags      = RaFlags())
 {
-    SendRouterAdvert(aRouterAddress, nullptr, 0, aRios, kNumRios, aDefaultRoute, aRaFlags);
+    SendRouterAdvert(aRouterAddress, nullptr, 0, aRios, kNumRios, nullptr, 0, aDefaultRoute, aRaFlags);
+}
+
+void SendRouterAdvert(const Ip6::Address &aRouterAddress, const Rdnss &aRdnss)
+{
+    SendRouterAdvert(aRouterAddress, nullptr, 0, nullptr, 0, &aRdnss, 1,
+                     DefaultRoute(0, NetworkData::kRoutePreferenceMedium), RaFlags());
+}
+
+template <uint16_t kNumRdnsses>
+void SendRouterAdvert(const Ip6::Address &aRouterAddress, const Rdnss (&aRdnsses)[kNumRdnsses])
+{
+    SendRouterAdvert(aRouterAddress, nullptr, 0, nullptr, 0, aRdnsses, kNumRdnsses,
+                     DefaultRoute(0, NetworkData::kRoutePreferenceMedium), RaFlags());
 }
 
 void SendRouterAdvert(const Ip6::Address &aRouterAddress,
                       const DefaultRoute &aDefaultRoute,
                       const RaFlags      &aRaFlags = RaFlags())
 {
-    SendRouterAdvert(aRouterAddress, nullptr, 0, nullptr, 0, aDefaultRoute, aRaFlags);
+    SendRouterAdvert(aRouterAddress, nullptr, 0, nullptr, 0, nullptr, 0, aDefaultRoute, aRaFlags);
 }
 
 void SendRouterAdvert(const Ip6::Address &aRouterAddress, const RaFlags &aRaFlags)
 {
-    SendRouterAdvert(aRouterAddress, nullptr, 0, nullptr, 0, DefaultRoute(0, NetworkData::kRoutePreferenceMedium),
-                     aRaFlags);
+    SendRouterAdvert(aRouterAddress, nullptr, 0, nullptr, 0, nullptr, 0,
+                     DefaultRoute(0, NetworkData::kRoutePreferenceMedium), aRaFlags);
 }
 
 template <uint16_t kNumPios> void SendRouterAdvertToBorderRoutingProcessIcmp6Ra(const Pio (&aPios)[kNumPios])
@@ -953,8 +1016,8 @@ template <uint16_t kNumPios> void SendRouterAdvertToBorderRoutingProcessIcmp6Ra(
     Ip6::Nd::RouterAdvert::TxMessage raMsg;
     Icmp6Packet                      packet;
 
-    BuildRouterAdvert(raMsg, aPios, kNumPios, nullptr, 0, DefaultRoute(0, NetworkData::kRoutePreferenceMedium),
-                      RaFlags());
+    BuildRouterAdvert(raMsg, aPios, kNumPios, nullptr, 0, nullptr, 0,
+                      DefaultRoute(0, NetworkData::kRoutePreferenceMedium), RaFlags());
     raMsg.GetAsPacket(packet);
 
     otPlatBorderRoutingProcessIcmp6Ra(sInstance, packet.GetBytes(), packet.GetLength());
@@ -1080,6 +1143,66 @@ void VerifyPrefixTable(const OnLinkPrefix *aOnLinkPrefixes,
 
 void VerifyPrefixTableIsEmpty(void) { VerifyPrefixTable(nullptr, 0, nullptr, 0); }
 
+struct RdnssAddress
+{
+    RdnssAddress(const Ip6::Address &aAddress, uint32_t aLifetime, const Ip6::Address &aRouterAddress)
+        : mAddress(aAddress)
+        , mLifetime(aLifetime)
+        , mRouterAddress(aRouterAddress)
+    {
+    }
+
+    const Ip6::Address &mAddress;
+    uint32_t            mLifetime;
+    const Ip6::Address &mRouterAddress;
+};
+
+template <uint16_t kNumAddrs> void VerifyRdnssAddressTable(const RdnssAddress (&aRdnssAddresses)[kNumAddrs])
+{
+    VerifyRdnssAddressTable(aRdnssAddresses, kNumAddrs);
+}
+
+void VerifyRdnssAddressTable(const RdnssAddress *aRdnssAddresses, uint16_t aNumAddrs)
+{
+    BorderRouter::RoutingManager::PrefixTableIterator iter;
+    BorderRouter::RoutingManager::RdnssAddrEntry      entry;
+    uint16_t                                          count = 0;
+
+    Log("VerifyRdnssAddressTable()");
+
+    sInstance->Get<BorderRouter::RoutingManager>().InitPrefixTableIterator(iter);
+
+    while (sInstance->Get<BorderRouter::RoutingManager>().GetNextRdnssAddrEntry(iter, entry) == kErrorNone)
+    {
+        bool didFind = false;
+
+        Log("   address:%s, lifetime:%u, router:%s, age:%u", AsCoreType(&entry.mAddress).ToString().AsCString(),
+            entry.mLifetime, AsCoreType(&entry.mRouter.mAddress).ToString().AsCString(),
+            entry.mMsecSinceLastUpdate / 1000);
+
+        count++;
+
+        for (uint16_t index = 0; index < aNumAddrs; index++)
+        {
+            const RdnssAddress &rndssAddress = aRdnssAddresses[index];
+
+            if ((rndssAddress.mAddress == AsCoreType(&entry.mAddress)) &&
+                (AsCoreType(&entry.mRouter.mAddress) == rndssAddress.mRouterAddress))
+            {
+                VerifyOrQuit(entry.mLifetime == rndssAddress.mLifetime);
+                didFind = true;
+                break;
+            }
+        }
+
+        VerifyOrQuit(didFind);
+    }
+
+    VerifyOrQuit(count == aNumAddrs);
+}
+
+void VerifyRdnssAddressTableIsEmpty(void) { VerifyRdnssAddressTable(nullptr, 0); }
+
 struct InfraRouter
 {
     InfraRouter(const Ip6::Address &aAddress,
@@ -1507,6 +1630,274 @@ void TestOmrSelection(void)
     FinalizeTest();
 }
 
+void TestOmrConfig(void)
+{
+    using OmrConfig = BorderRouter::RoutingManager::OmrConfig;
+
+    static constexpr OmrConfig kOmrConfigAuto     = BorderRouter::RoutingManager::kOmrConfigAuto;
+    static constexpr OmrConfig kOmrConfigCustom   = BorderRouter::RoutingManager::kOmrConfigCustom;
+    static constexpr OmrConfig kOmrConfigDisabled = BorderRouter::RoutingManager::kOmrConfigDisabled;
+
+    Ip6::Prefix     localOmr;
+    RoutePreference preference;
+    Ip6::Prefix     prefix;
+    Ip6::Prefix     customPrefix = PrefixFromString("2000:0000:1111:4444::", 64);
+    uint16_t        heapAllocations;
+    OmrConfig       omrConfig;
+
+    Log("--------------------------------------------------------------------------------------------");
+    Log("TestOmrConfig");
+
+    InitTest();
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Start Routing Manager. Check emitted RS and RA messages.
+
+    sRsEmitted   = false;
+    sRaValidated = false;
+    sExpectedPio = kPioAdvertisingLocalOnLink;
+    sExpectedRios.Clear();
+
+    heapAllocations = sHeapAllocatedPtrs.GetLength();
+
+    SuccessOrQuit(sInstance->Get<BorderRouter::RoutingManager>().SetEnabled(true));
+
+    omrConfig = sInstance->Get<BorderRouter::RoutingManager>().GetOmrConfig(nullptr, nullptr);
+    VerifyOrQuit(omrConfig == kOmrConfigAuto);
+
+    SuccessOrQuit(sInstance->Get<BorderRouter::RoutingManager>().GetOmrPrefix(localOmr));
+
+    Log("Local OMR prefix is %s", localOmr.ToString().AsCString());
+
+    sExpectedRios.Add(localOmr);
+
+    AdvanceTime(30000);
+
+    VerifyOrQuit(sRsEmitted);
+    VerifyOrQuit(sRaValidated);
+    VerifyOrQuit(sExpectedRios.SawAll());
+    VerifyOrQuit(sExpectedRios[0].mLifetime == kRioValidLifetime);
+    VerifyOrQuit(sExpectedRios[0].mPreference == NetworkData::kRoutePreferenceMedium);
+
+    VerifyOmrPrefixInNetData(localOmr, /* aDefaultRoute */ false);
+    VerifyExternalRouteInNetData(kUlaRoute, kWithAdvPioFlagSet);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Update OMR config to disable it
+
+    preference = NetworkData::kRoutePreferenceMedium;
+    SuccessOrQuit(sInstance->Get<BorderRouter::RoutingManager>().SetOmrConfig(kOmrConfigDisabled, nullptr, preference));
+
+    omrConfig = sInstance->Get<BorderRouter::RoutingManager>().GetOmrConfig(nullptr, nullptr);
+    VerifyOrQuit(omrConfig == kOmrConfigDisabled);
+
+    AdvanceTime(100);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Make sure BR emits RA with the new OMR prefix now, and deprecates the old OMR prefix.
+
+    sRaValidated = false;
+    sExpectedPio = kPioAdvertisingLocalOnLink;
+    sExpectedRios.Clear();
+    sExpectedRios.Add(localOmr);
+
+    AdvanceTime(20 * 1000);
+
+    VerifyOrQuit(sRaValidated);
+    VerifyOrQuit(sExpectedRios.SawAll());
+    VerifyOrQuit(sExpectedRios[0].mLifetime <= kRioDeprecatingLifetime);
+    VerifyOrQuit(sExpectedRios[0].mPreference == NetworkData::kRoutePreferenceLow);
+
+    // Check Network Data. We should now see no OMR prefix in the Network Data.
+
+    VerifyNoOmrPrefixInNetData();
+    VerifyExternalRouteInNetData(kUlaRoute, kWithAdvPioFlagSet);
+
+    SuccessOrQuit(sInstance->Get<BorderRouter::RoutingManager>().GetFavoredOmrPrefix(prefix, preference));
+    VerifyOrQuit(prefix.GetLength() == 0);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Update OMR config back `kOmrConfigAuto` mode.
+
+    preference = NetworkData::kRoutePreferenceMedium;
+    SuccessOrQuit(sInstance->Get<BorderRouter::RoutingManager>().SetOmrConfig(kOmrConfigAuto, nullptr, preference));
+
+    omrConfig = sInstance->Get<BorderRouter::RoutingManager>().GetOmrConfig(nullptr, nullptr);
+    VerifyOrQuit(omrConfig == kOmrConfigAuto);
+
+    AdvanceTime(100);
+
+    sRaValidated = false;
+    sExpectedPio = kPioAdvertisingLocalOnLink;
+    sExpectedRios.Clear();
+    sExpectedRios.Add(localOmr);
+
+    AdvanceTime(30 * 1000);
+
+    VerifyOrQuit(sRaValidated);
+    VerifyOrQuit(sExpectedRios.SawAll());
+    VerifyOrQuit(sExpectedRios[0].mLifetime == kRioValidLifetime);
+    VerifyOrQuit(sExpectedRios[0].mPreference == NetworkData::kRoutePreferenceMedium);
+
+    VerifyOmrPrefixInNetData(localOmr, /* aDefaultRoute */ false);
+    VerifyExternalRouteInNetData(kUlaRoute, kWithAdvPioFlagSet);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Update OMR config to `kOmrConfigCustom` mode to use a custom prefix
+
+    preference = NetworkData::kRoutePreferenceMedium;
+    SuccessOrQuit(
+        sInstance->Get<BorderRouter::RoutingManager>().SetOmrConfig(kOmrConfigCustom, &customPrefix, preference));
+
+    omrConfig = sInstance->Get<BorderRouter::RoutingManager>().GetOmrConfig(&prefix, &preference);
+    VerifyOrQuit(omrConfig == kOmrConfigCustom);
+    VerifyOrQuit(prefix == customPrefix);
+    VerifyOrQuit(preference == NetworkData::kRoutePreferenceMedium);
+
+    AdvanceTime(100);
+
+    sRaValidated = false;
+    sExpectedPio = kPioAdvertisingLocalOnLink;
+    sExpectedRios.Clear();
+    sExpectedRios.Add(customPrefix);
+    sExpectedRios.Add(localOmr);
+
+    AdvanceTime(60 * 1000);
+
+    VerifyOrQuit(sRaValidated);
+    VerifyOrQuit(sExpectedRios.SawAll());
+    VerifyOrQuit(sExpectedRios[0].mLifetime == kRioValidLifetime);
+    VerifyOrQuit(sExpectedRios[0].mPreference == NetworkData::kRoutePreferenceMedium);
+    VerifyOrQuit(sExpectedRios[1].mLifetime <= kRioDeprecatingLifetime);
+    VerifyOrQuit(sExpectedRios[1].mPreference == NetworkData::kRoutePreferenceLow);
+
+    VerifyOmrPrefixInNetData(customPrefix, /* aDefaultRoute */ false, &preference);
+    VerifyExternalRouteInNetData(kUlaRoute, kWithAdvPioFlagSet);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Update the custom prefix preference value to high.
+
+    preference = NetworkData::kRoutePreferenceHigh;
+    SuccessOrQuit(
+        sInstance->Get<BorderRouter::RoutingManager>().SetOmrConfig(kOmrConfigCustom, &customPrefix, preference));
+
+    omrConfig = sInstance->Get<BorderRouter::RoutingManager>().GetOmrConfig(&prefix, &preference);
+    VerifyOrQuit(omrConfig == kOmrConfigCustom);
+    VerifyOrQuit(prefix == customPrefix);
+    VerifyOrQuit(preference == NetworkData::kRoutePreferenceHigh);
+
+    AdvanceTime(100);
+
+    sRaValidated = false;
+    sExpectedPio = kPioAdvertisingLocalOnLink;
+    sExpectedRios.Clear();
+    sExpectedRios.Add(customPrefix);
+    sExpectedRios.Add(localOmr);
+
+    AdvanceTime(60 * 1000);
+
+    VerifyOrQuit(sRaValidated);
+    VerifyOrQuit(sExpectedRios.SawAll());
+    VerifyOrQuit(sExpectedRios[0].mLifetime == kRioValidLifetime);
+    VerifyOrQuit(sExpectedRios[0].mPreference == NetworkData::kRoutePreferenceMedium);
+    VerifyOrQuit(sExpectedRios[1].mLifetime <= kRioDeprecatingLifetime);
+    VerifyOrQuit(sExpectedRios[1].mPreference == NetworkData::kRoutePreferenceLow);
+
+    VerifyOmrPrefixInNetData(customPrefix, /* aDefaultRoute */ false, &preference);
+    VerifyExternalRouteInNetData(kUlaRoute, kWithAdvPioFlagSet);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Wait for previous local OMR to be fully deprecated and validate that is no
+    // longer seen in the emitted RA.
+
+    AdvanceTime(350 * 1000);
+
+    sRaValidated = false;
+    sExpectedPio = kPioAdvertisingLocalOnLink;
+    sExpectedRios.Add(customPrefix);
+
+    AdvanceTime(200 * 1000);
+
+    VerifyOrQuit(sRaValidated);
+    VerifyOrQuit(sExpectedRios.SawAll());
+
+    VerifyOmrPrefixInNetData(customPrefix, /* aDefaultRoute */ false, &preference);
+
+    SuccessOrQuit(sInstance->Get<BorderRouter::RoutingManager>().GetFavoredOmrPrefix(prefix, preference));
+    VerifyOrQuit(prefix == customPrefix);
+    VerifyOrQuit(preference == NetworkData::kRoutePreferenceHigh);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Switch back to `kOmrConfigDiable` mode. Check that custom prefix is
+    // removed from Network Data and we see it deprecating in emitted RAs.
+
+    SuccessOrQuit(sInstance->Get<BorderRouter::RoutingManager>().SetOmrConfig(kOmrConfigDisabled, nullptr, preference));
+
+    omrConfig = sInstance->Get<BorderRouter::RoutingManager>().GetOmrConfig(nullptr, nullptr);
+    VerifyOrQuit(omrConfig == kOmrConfigDisabled);
+
+    AdvanceTime(100);
+
+    sRaValidated = false;
+    sExpectedPio = kPioAdvertisingLocalOnLink;
+    sExpectedRios.Clear();
+    sExpectedRios.Add(customPrefix);
+
+    AdvanceTime(60 * 1000);
+
+    VerifyOrQuit(sRaValidated);
+    VerifyOrQuit(sExpectedRios.SawAll());
+    VerifyOrQuit(sExpectedRios[0].mLifetime <= kRioDeprecatingLifetime);
+    VerifyOrQuit(sExpectedRios[0].mPreference == NetworkData::kRoutePreferenceLow);
+
+    VerifyNoOmrPrefixInNetData();
+    VerifyExternalRouteInNetData(kUlaRoute, kWithAdvPioFlagSet);
+
+    SuccessOrQuit(sInstance->Get<BorderRouter::RoutingManager>().GetFavoredOmrPrefix(prefix, preference));
+    VerifyOrQuit(prefix.GetLength() == 0);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Switch back to `kOmrConfigAuto` mode.
+
+    SuccessOrQuit(sInstance->Get<BorderRouter::RoutingManager>().SetOmrConfig(kOmrConfigAuto, nullptr, preference));
+
+    omrConfig = sInstance->Get<BorderRouter::RoutingManager>().GetOmrConfig(nullptr, nullptr);
+    VerifyOrQuit(omrConfig == kOmrConfigAuto);
+
+    AdvanceTime(100);
+
+    sRaValidated = false;
+    sExpectedPio = kPioAdvertisingLocalOnLink;
+    sExpectedRios.Clear();
+    sExpectedRios.Add(localOmr);
+    sExpectedRios.Add(customPrefix);
+
+    AdvanceTime(60 * 1000);
+
+    VerifyOrQuit(sRaValidated);
+    VerifyOrQuit(sExpectedRios.SawAll());
+    VerifyOrQuit(sExpectedRios[0].mLifetime == kRioValidLifetime);
+    VerifyOrQuit(sExpectedRios[0].mPreference == NetworkData::kRoutePreferenceMedium);
+    VerifyOrQuit(sExpectedRios[1].mLifetime <= kRioDeprecatingLifetime);
+    VerifyOrQuit(sExpectedRios[1].mPreference == NetworkData::kRoutePreferenceLow);
+
+    preference = NetworkData::kRoutePreferenceLow;
+    VerifyOmrPrefixInNetData(localOmr, /* aDefaultRoute */ false, &preference);
+    VerifyExternalRouteInNetData(kUlaRoute, kWithAdvPioFlagSet);
+
+    SuccessOrQuit(sInstance->Get<BorderRouter::RoutingManager>().GetFavoredOmrPrefix(prefix, preference));
+    VerifyOrQuit(prefix == localOmr);
+    VerifyOrQuit(preference == NetworkData::kRoutePreferenceLow);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+    SuccessOrQuit(sInstance->Get<BorderRouter::RoutingManager>().SetEnabled(false));
+    VerifyOrQuit(heapAllocations == sHeapAllocatedPtrs.GetLength());
+
+    Log("End of TestOmrConfig");
+    FinalizeTest();
+}
+
 void TestDefaultRoute(void)
 {
     Ip6::Prefix                     localOnLink;
@@ -4347,6 +4738,246 @@ void TestBorderRoutingProcessPlatfromGeneratedNd(void)
 }
 #endif // OPENTHREAD_CONFIG_BORDER_ROUTING_DHCP6_PD_ENABLE
 
+static void HandleRdnssChanged(void *aContext)
+{
+    VerifyOrQuit(aContext != nullptr);
+    *static_cast<bool *>(aContext) = true;
+}
+
+void TestRdnss(void)
+{
+    Ip6::Address rdnssAddr1     = AddressFromString("fd77::1");
+    Ip6::Address rdnssAddr2     = AddressFromString("fd77::2");
+    Ip6::Address rdnssAddr3     = AddressFromString("fd77::3");
+    Ip6::Address rdnssAddr4     = AddressFromString("fd77::4");
+    Ip6::Address routerAddressA = AddressFromString("fd00::aaaa");
+    Ip6::Address routerAddressB = AddressFromString("fd00::bbbb");
+    Ip6::Prefix  localOnLink;
+    Ip6::Prefix  localOmr;
+    bool         rdnssCallbackCalled = false;
+
+    uint16_t heapAllocations;
+
+    Log("--------------------------------------------------------------------------------------------");
+    Log("TestRdnss");
+
+    InitTest();
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Start Routing Manager. Check emitted RS and RA messages.
+
+    sRsEmitted   = false;
+    sRaValidated = false;
+    sExpectedPio = kPioAdvertisingLocalOnLink;
+    sExpectedRios.Clear();
+
+    heapAllocations = sHeapAllocatedPtrs.GetLength();
+
+    SuccessOrQuit(sInstance->Get<BorderRouter::RoutingManager>().SetEnabled(true));
+
+    SuccessOrQuit(sInstance->Get<BorderRouter::RoutingManager>().GetOnLinkPrefix(localOnLink));
+    SuccessOrQuit(sInstance->Get<BorderRouter::RoutingManager>().GetOmrPrefix(localOmr));
+
+    Log("Local on-link prefix is %s", localOnLink.ToString().AsCString());
+    Log("Local OMR prefix is %s", localOmr.ToString().AsCString());
+
+    sExpectedRios.Add(localOmr);
+
+    AdvanceTime(30000);
+
+    VerifyOrQuit(sRsEmitted);
+    VerifyOrQuit(sRaValidated);
+    VerifyOrQuit(sExpectedRios.SawAll());
+    Log("Received RA was validated");
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Set the RDNSS callback on Routing Manager
+
+    rdnssCallbackCalled = false;
+    sInstance->Get<BorderRouter::RoutingManager>().SetRdnssAddrCallback(HandleRdnssChanged, &rdnssCallbackCalled);
+
+    VerifyOrQuit(!rdnssCallbackCalled);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Check Network Data to include the local OMR and ULA prefix.
+
+    VerifyOmrPrefixInNetData(localOmr, /* aDefaultRoute */ false);
+    VerifyExternalRouteInNetData(kUlaRoute, kWithAdvPioFlagSet);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Send RA from router A advertising an RDNS address. Ensure
+    // that the RDNSS callback is called and new advertised address
+    // is present in the RDNSS table.
+
+    VerifyRdnssAddressTableIsEmpty();
+
+    rdnssCallbackCalled = false;
+    SendRouterAdvert(routerAddressA, {Rdnss::Create(300, {rdnssAddr1})});
+
+    AdvanceTime(1);
+
+    VerifyOrQuit(rdnssCallbackCalled);
+    VerifyRdnssAddressTable({RdnssAddress(rdnssAddr1, 300, routerAddressA)});
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Send same RA again from router A, ensure there is no callback
+    // as there is no change in table.
+
+    rdnssCallbackCalled = false;
+
+    AdvanceTime(15 * 1000);
+    VerifyOrQuit(!rdnssCallbackCalled);
+    VerifyRdnssAddressTable({RdnssAddress(rdnssAddr1, 300, routerAddressA)});
+
+    SendRouterAdvert(routerAddressA, {Rdnss::Create(300, {rdnssAddr1})});
+    AdvanceTime(1);
+
+    VerifyOrQuit(!rdnssCallbackCalled);
+    VerifyRdnssAddressTable({RdnssAddress(rdnssAddr1, 300, routerAddressA)});
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Send an RA from router A, now adding a different RDNSS address.
+    // Ensure callback is invoked and we see the new address in the
+    // table.
+
+    rdnssCallbackCalled = false;
+
+    SendRouterAdvert(routerAddressA, {Rdnss::Create(600, {rdnssAddr2})});
+    AdvanceTime(1);
+
+    VerifyOrQuit(rdnssCallbackCalled);
+    VerifyRdnssAddressTable(
+        {RdnssAddress(rdnssAddr1, 300, routerAddressA), RdnssAddress(rdnssAddr2, 600, routerAddressA)});
+
+    AdvanceTime(20 * 1000);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Send RA from router B, adding a new different RDNSS address.
+    // Ensure callback is invoked and validate RDNSS address table.
+
+    rdnssCallbackCalled = false;
+
+    SendRouterAdvert(routerAddressB, {Rdnss::Create(0xffffffff, {rdnssAddr3})});
+    AdvanceTime(1);
+
+    VerifyOrQuit(rdnssCallbackCalled);
+    VerifyRdnssAddressTable({RdnssAddress(rdnssAddr1, 300, routerAddressA),
+                             RdnssAddress(rdnssAddr2, 600, routerAddressA),
+                             RdnssAddress(rdnssAddr3, 0xffffffff, routerAddressB)});
+
+    AdvanceTime(10 * 1000);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Send an RA from router A with two RDNSS options changing the
+    // lifetimes of the two addresses. Ensure the callback is not invoked
+    // (since there are no changes to the address table), but we should
+    // see the new lifetimes reflected in the RDNSS address table.
+
+    rdnssCallbackCalled = false;
+
+    SendRouterAdvert(routerAddressA, {Rdnss::Create(400, {rdnssAddr2}), Rdnss::Create(800, {rdnssAddr1})});
+    AdvanceTime(1);
+
+    VerifyOrQuit(!rdnssCallbackCalled);
+    VerifyRdnssAddressTable({RdnssAddress(rdnssAddr1, 800, routerAddressA),
+                             RdnssAddress(rdnssAddr2, 400, routerAddressA),
+                             RdnssAddress(rdnssAddr3, 0xffffffff, routerAddressB)});
+
+    AdvanceTime(30 * 1000);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Send RA from router B, removing a previous RDNSS address
+    // and one that it never advertised. Ensure callback is
+    // invoked and validate RDNSS address table is updated
+    // correctly.
+
+    rdnssCallbackCalled = false;
+
+    SendRouterAdvert(routerAddressB, {Rdnss::Create(0, {rdnssAddr3, rdnssAddr4, rdnssAddr3})});
+    AdvanceTime(1);
+
+    VerifyOrQuit(rdnssCallbackCalled);
+    VerifyRdnssAddressTable(
+        {RdnssAddress(rdnssAddr1, 800, routerAddressA), RdnssAddress(rdnssAddr2, 400, routerAddressA)});
+
+    AdvanceTime(30 * 1000);
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Send RA from router A, advertising a short lifetime.
+
+    rdnssCallbackCalled = false;
+
+    SendRouterAdvert(routerAddressA, {Rdnss::Create(32, {rdnssAddr1, rdnssAddr2})});
+    AdvanceTime(1);
+
+    VerifyOrQuit(!rdnssCallbackCalled);
+    VerifyRdnssAddressTable(
+        {RdnssAddress(rdnssAddr1, 32, routerAddressA), RdnssAddress(rdnssAddr2, 32, routerAddressA)});
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Wait for the expiration time (based on lifetime) and ensure
+    // callback is invoked and the addresses are removed from
+    // the table.
+
+    AdvanceTime(32 * 1000 - 10);
+
+    VerifyOrQuit(!rdnssCallbackCalled);
+
+    AdvanceTime(15);
+    VerifyOrQuit(rdnssCallbackCalled);
+    VerifyRdnssAddressTableIsEmpty();
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Send an RA from router B, adding an RDNSS address with infinite
+    // lifetime.
+
+    rdnssCallbackCalled = false;
+
+    SendRouterAdvert(routerAddressB, {Rdnss::Create(0xffffffff, {rdnssAddr3})});
+    AdvanceTime(1);
+
+    VerifyOrQuit(rdnssCallbackCalled);
+    VerifyRdnssAddressTable({RdnssAddress(rdnssAddr3, 0xffffffff, routerAddressB)});
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Disallow responding to NS message.
+
+    // Wait for longer than "reachable" timeout to ensure the router B
+    // is fully removed (deemed unreachable). Validate that its
+    // RNDSS address is also removed and RDNSS callback is invoked.
+
+    rdnssCallbackCalled = false;
+    sRespondToNs        = false;
+
+    AdvanceTime(250 * 1000);
+
+    VerifyOrQuit(rdnssCallbackCalled);
+    VerifyRdnssAddressTableIsEmpty();
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    // Send an RA from router A with one RDNNS address. Validate
+    // that it is removed when `RoutingManager` is stopped.
+
+    rdnssCallbackCalled = false;
+    SendRouterAdvert(routerAddressA, {Rdnss::Create(300, {rdnssAddr1})});
+    AdvanceTime(1);
+
+    VerifyOrQuit(rdnssCallbackCalled);
+    VerifyRdnssAddressTable({RdnssAddress(rdnssAddr1, 300, routerAddressA)});
+
+    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+    SuccessOrQuit(sInstance->Get<BorderRouter::RoutingManager>().SetEnabled(false));
+
+    VerifyRdnssAddressTableIsEmpty();
+
+    VerifyOrQuit(heapAllocations == sHeapAllocatedPtrs.GetLength());
+
+    Log("End of TestRdnss");
+
+    FinalizeTest();
+}
+
 #endif // OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE
 
 } // namespace ot
@@ -4356,6 +4987,7 @@ int main(void)
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE
     ot::TestSamePrefixesFromMultipleRouters();
     ot::TestOmrSelection();
+    ot::TestOmrConfig();
     ot::TestDefaultRoute();
     ot::TestAdvNonUlaRoute();
     ot::TestFavoredOnLinkPrefix();
@@ -4381,6 +5013,7 @@ int main(void)
 #if OPENTHREAD_CONFIG_BORDER_ROUTING_DHCP6_PD_ENABLE
     ot::TestBorderRoutingProcessPlatfromGeneratedNd();
 #endif
+    ot::TestRdnss();
 
     printf("All tests passed\n");
 #else
diff --git a/tests/unit/test_srp_adv_proxy.cpp b/tests/unit/test_srp_adv_proxy.cpp
index dec83df65..cbd03cfe5 100644
--- a/tests/unit/test_srp_adv_proxy.cpp
+++ b/tests/unit/test_srp_adv_proxy.cpp
@@ -543,6 +543,13 @@ void InitTest(void)
     SuccessOrQuit(otIp6SetEnabled(sInstance, true));
     SuccessOrQuit(otThreadSetEnabled(sInstance, true));
 
+#if OPENTHREAD_CONFIG_BORDER_AGENT_ENABLE
+    // Disable the Border Agent to prevent its attempt to
+    // register the `_meshcop._udp` service from
+    // interfering with this test.
+    sInstance->Get<MeshCoP::BorderAgent>().SetEnabled(false);
+#endif
+
     // Configure the `Dnssd` module to use `otPlatDnssd` APIs.
 
     sInstance->Get<Dnssd>().SetUseNativeMdns(false);
diff --git a/tests/unit/test_url.cpp b/tests/unit/test_url.cpp
index a7ff34d50..63c2e88cf 100644
--- a/tests/unit/test_url.cpp
+++ b/tests/unit/test_url.cpp
@@ -36,13 +36,13 @@ namespace Url {
 
 void TestSimple(void)
 {
-    char url[] = "spinel:///dev/ttyUSB0?baudrate=115200";
+    char url[] = "spinel:///dev/ttyUSB0?baudrate=460800";
     Url  args;
 
     VerifyOrQuit(!args.Init(url));
 
     VerifyOrQuit(!strcmp(args.GetPath(), "/dev/ttyUSB0"));
-    VerifyOrQuit(!strcmp(args.GetValue("baudrate"), "115200"));
+    VerifyOrQuit(!strcmp(args.GetValue("baudrate"), "460800"));
     VerifyOrQuit(args.GetValue("not-exists") == nullptr);
     VerifyOrQuit(args.GetValue("last-value-wrong-position", url) == nullptr);
     VerifyOrQuit(args.GetValue("last-value-before-url", url - 1) == nullptr);
@@ -67,7 +67,7 @@ void TestSimpleNoQueryString(void)
 
 void TestEmptyValue(void)
 {
-    char        url[] = "spinel:///dev/ttyUSB0?rtscts&baudrate=115200&verbose&verbose&verbose";
+    char        url[] = "spinel:///dev/ttyUSB0?rtscts&baudrate=460800&verbose&verbose&verbose";
     Url         args;
     const char *arg = nullptr;
 
@@ -85,12 +85,12 @@ void TestEmptyValue(void)
 
 void TestMultipleProtocols(void)
 {
-    char url[] = "spinel+spi:///dev/ttyUSB0?baudrate=115200";
+    char url[] = "spinel+spi:///dev/ttyUSB0?baudrate=460800";
     Url  args;
 
     VerifyOrQuit(!args.Init(url));
     VerifyOrQuit(!strcmp(args.GetPath(), "/dev/ttyUSB0"));
-    VerifyOrQuit(!strcmp(args.GetValue("baudrate"), "115200"));
+    VerifyOrQuit(!strcmp(args.GetValue("baudrate"), "460800"));
 
     printf("PASS %s\r\n", __func__);
 }
diff --git a/third_party/tcplp/bsdtcp/tcp_subr.c b/third_party/tcplp/bsdtcp/tcp_subr.c
index 78f2a5942..46d089675 100644
--- a/third_party/tcplp/bsdtcp/tcp_subr.c
+++ b/third_party/tcplp/bsdtcp/tcp_subr.c
@@ -49,6 +49,8 @@
 
 #include "tcp_const.h"
 
+static void reinitialize_tcb(struct tcpcb* tp);
+
 /*
  * samkumar: This is rewritten to have the host network stack to generate the
  * ISN with appropriate randomness.
@@ -145,6 +147,15 @@ void initialize_tcb(struct tcpcb* tp) {
 	tcp_sack_init(tp);
 }
 
+/* Re-initialize the TCB. */
+static void reinitialize_tcb(struct tcpcb* tp)
+{
+	uint32_t ntraversed;
+	lbuf_pop(&tp->sendbuf, lbuf_used_space(&tp->sendbuf), &ntraversed);
+	cbuf_pop(&tp->recvbuf, cbuf_used_space(&tp->recvbuf));
+	tp->accepted_from = NULL;
+	initialize_tcb(tp);
+}
 
 /*
  * samkumar: Most of this function was no longer needed. It did things like
@@ -165,6 +176,8 @@ tcp_discardcb(struct tcpcb *tp)
 		CC_ALGO(tp)->cb_destroy(tp->ccv);
 
 	tcp_free_sackholes(tp);
+
+	reinitialize_tcb(tp);
 }
 
 
@@ -352,7 +365,7 @@ struct tcpcb *
 tcp_drop(struct tcpcb *tp, int errnum)
 {
 	if (TCPS_HAVERCVDSYN(tp->t_state)) {
-		tcp_state_change(tp, TCPS_CLOSED);
+		tcp_state_change(tp, TCP6S_CLOSED);
 		(void) tcplp_output(tp);
 	}
 	if (errnum == ETIMEDOUT && tp->t_softerror)
diff --git a/third_party/tcplp/bsdtcp/tcp_usrreq.c b/third_party/tcplp/bsdtcp/tcp_usrreq.c
index 079e6da1d..032496921 100644
--- a/third_party/tcplp/bsdtcp/tcp_usrreq.c
+++ b/third_party/tcplp/bsdtcp/tcp_usrreq.c
@@ -522,7 +522,7 @@ tcp_usr_abort(struct tcpcb* tp)
 	if (tp->t_state != TCP6S_TIME_WAIT &&
 		tp->t_state != TCP6S_CLOSED) {
 		tcp_drop(tp, ECONNABORTED);
-	} else if (tp->t_state == TCPS_TIME_WAIT) { // samkumar: I added this clause
+	} else if (tp->t_state == TCP6S_TIME_WAIT) { // samkumar: I added this clause
 		tp = tcp_close_tcb(tp);
 		tcplp_sys_connection_lost(tp, CONN_LOST_NORMAL);
 	}
diff --git a/tools/cp-caps/README.md b/tools/cp-caps/README.md
index c6a5c761e..f1977434e 100644
--- a/tools/cp-caps/README.md
+++ b/tools/cp-caps/README.md
@@ -43,7 +43,8 @@ $ git submodule update --init
 $ ./script/bootstrap
 $ ./script/build nrf52840 UART_trans -DOT_DIAGNOSTIC=ON -DOT_CSL_RECEIVER=ON -DOT_LINK_METRICS_INITIATOR=ON -DOT_LINK_METRICS_SUBJECT=ON -DOT_WAKEUP_COORDINATOR=ON
 $ arm-none-eabi-objcopy -O ihex build/bin/ot-cli-ftd ot-cli-ftd.hex
-$ nrfjprog -f nrf52 --chiperase --program ot-cli-ftd.hex --reset
+$ nrfutil device program --firmware ot-cli-ftd.hex --options chip_erase_mode=ERASE_ALL
+$ nrfutil device reset --reset-kind=RESET_PIN
 ```
 
 ## Test Commands
diff --git a/tools/otci/README.md b/tools/otci/README.md
index b6c45dcf0..0261b2136 100644
--- a/tools/otci/README.md
+++ b/tools/otci/README.md
@@ -1,6 +1,6 @@
 # OpenThread Control Interface
 
-The OpenThread Control Interface (OTCI) is a library which provides uniform python interfaces to connect and control various kinds of devices running OpenThread.
+The OpenThread Control Interface (OTCI) is a library which provides uniform Python interfaces to connect and control various kinds of devices running OpenThread.
 
 ## Supported device types
 
@@ -22,7 +22,7 @@ node1 = otci.connect_otbr_ssh("192.168.1.101")
 # Connect to an OpenThread CLI device via Serial
 node2 = otci.connect_cli_serial("/dev/ttyACM0"))
 
-# Start node1 to become Leader
+# Start node1 and wait for it to become the Leader
 node1.dataset_init_buffer()
 node1.dataset_set_buffer(network_name='test', network_key='00112233445566778899aabbccddeeff', panid=0xface, channel=11)
 node1.dataset_commit_buffer('active')
@@ -32,7 +32,7 @@ node1.thread_start()
 node1.wait(5)
 assert node1.get_state() == "leader"
 
-# Start Commissioner on node1
+# Start the Commissioner role on node1
 node1.commissioner_start()
 node1.wait(3)
 
@@ -42,11 +42,11 @@ node1.commissioner_add_joiner("TEST123",eui64='*')
 node2.ifconfig_up()
 node2.set_router_selection_jitter(1)
 
-# Start Joiner on node2 to join the network
+# Start the Joiner role on node2 and wait for it to join the network
 node2.joiner_start("TEST123")
 node2.wait(10, expect_line="Join success")
 
-# Wait for node 2 to become Router
+# Wait for node 2 to become a Router
 node2.thread_start()
 node2.wait(5)
 assert node2.get_state() == "router"
diff --git a/tools/otci/otci/__init__.py b/tools/otci/otci/__init__.py
index eed56c615..68f9a8bb7 100644
--- a/tools/otci/otci/__init__.py
+++ b/tools/otci/otci/__init__.py
@@ -28,17 +28,19 @@
 #
 
 from . import errors
-from .constants import THREAD_VERSION_1_1, THREAD_VERSION_1_2
+from .constants import THREAD_VERSION_1_1, THREAD_VERSION_1_2, THREAD_VERSION_1_3, THREAD_VERSION_1_4
 from .command_handlers import OTCommandHandler
+from .connectors import OtCliHandler
 from .otci import OTCI
-from .otci import \
-    connect_cli_sim, \
-    connect_cli_serial, \
-    connect_ncp_sim, \
-    connect_cmd_handler, \
-    connect_otbr_ssh, \
-    connect_otbr_adb_tcp, \
-    connect_otbr_adb_usb
+from .otci import (
+    connect_cli_sim,
+    connect_cli_serial,
+    connect_ncp_sim,
+    connect_cmd_handler,
+    connect_otbr_ssh,
+    connect_otbr_adb_tcp,
+    connect_otbr_adb_usb,
+)
 
 from .types import Rloc16, ChildId, NetifIdentifier
 
@@ -55,10 +57,13 @@ _connectors = [
 __all__ = [
     'OTCI',
     'OTCommandHandler',
+    'OTCliHandler',
     'errors',
     'Rloc16',
     'ChildId',
     'NetifIdentifier',
     'THREAD_VERSION_1_1',
     'THREAD_VERSION_1_2',
+    'THREAD_VERSION_1_3',
+    'THREAD_VERSION_1_4',
 ] + _connectors
diff --git a/tools/otci/otci/command_handlers.py b/tools/otci/otci/command_handlers.py
index e9cf989f4..30242b6cb 100644
--- a/tools/otci/otci/command_handlers.py
+++ b/tools/otci/otci/command_handlers.py
@@ -84,34 +84,38 @@ class OTCommandHandler(ABC):
     def shell(self, cmd: str, timeout: float) -> List[str]:
         raise NotImplementedError("shell command is not supported on %s" % self.__class__.__name__)
 
+    @classmethod
+    def set_filter(cls, filter: re.Pattern[str]):
+        return
+
 
 class OtCliCommandRunner(OTCommandHandler):
     __PATTERN_COMMAND_DONE_OR_ERROR = re.compile(
         r'(Done|Error|Error \d+:.*|.*: command not found)$')  # "Error" for spinel-cli.py
 
-    __PATTERN_LOG_LINE = re.compile(r'((\[(NONE|CRIT|WARN|NOTE|INFO|DEBG)\])'
+    __pattern_log_line = re.compile(r'((\[(NONE|CRIT|WARN|NOTE|INFO|DEBG)\])'
                                     r'|(-.*-+: )'  # e.g. -CLI-----:
                                     r'|(\[[DINWC\-]\] (?=[\w\-]{14}:)\w+-*:)'  # e.g. [I] Mac-----------:
                                     r')')
     """regex used to filter logs"""
 
-    assert __PATTERN_LOG_LINE.match('[I] ChannelMonitor: debug log')
-    assert __PATTERN_LOG_LINE.match('[I] Mac-----------: info log')
-    assert __PATTERN_LOG_LINE.match('[N] MeshForwarder-: note    log')
-    assert __PATTERN_LOG_LINE.match('[W] Notifier------: warn log')
-    assert __PATTERN_LOG_LINE.match('[C] Mle-----------: critical log')
-    assert __PATTERN_LOG_LINE.match('[-] Settings------: none log')
-    assert not __PATTERN_LOG_LINE.match('[-] Settings-----: none log')  # not enough `-` after module name
+    assert __pattern_log_line.match('[I] ChannelMonitor: debug log')
+    assert __pattern_log_line.match('[I] Mac-----------: info log')
+    assert __pattern_log_line.match('[N] MeshForwarder-: note    log')
+    assert __pattern_log_line.match('[W] Notifier------: warn log')
+    assert __pattern_log_line.match('[C] Mle-----------: critical log')
+    assert __pattern_log_line.match('[-] Settings------: none log')
+    assert not __pattern_log_line.match('[-] Settings-----: none log')  # not enough `-` after module name
 
-    __ASYNC_COMMANDS = {'scan', 'ping', 'discover'}
+    __ASYNC_COMMANDS = {'scan', 'ping', 'discover', 'networkdiagnostic get'}
 
-    def __init__(self, otcli: OtCliHandler, is_spinel_cli=False):
+    def __init__(self, otcli: OtCliHandler, is_spinel_cli: bool = False):
         self.__otcli: OtCliHandler = otcli
         self.__is_spinel_cli = is_spinel_cli
         self.__expect_command_echoback = not self.__is_spinel_cli
         self.__line_read_callback = None
 
-        self.__pending_lines = queue.Queue()
+        self.__pending_lines: queue.Queue[str] = queue.Queue()
         self.__should_close = threading.Event()
         self.__otcli_reader = threading.Thread(target=self.__otcli_read_routine, daemon=True)
         self.__otcli_reader.start()
@@ -119,7 +123,7 @@ class OtCliCommandRunner(OTCommandHandler):
     def __repr__(self):
         return repr(self.__otcli)
 
-    def execute_command(self, cmd, timeout=10) -> List[str]:
+    def execute_command(self, cmd: str, timeout: float = 10) -> List[str]:
         assert not self.__should_close.is_set(), "OT CLI is already closed."
         self.__otcli.writeline(cmd)
 
@@ -134,16 +138,17 @@ class OtCliCommandRunner(OTCommandHandler):
 
         output = self.__expect_line(timeout,
                                     OtCliCommandRunner.__PATTERN_COMMAND_DONE_OR_ERROR,
-                                    asynchronous=cmd.split()[0] in OtCliCommandRunner.__ASYNC_COMMANDS)
+                                    asynchronous=any(cmd.startswith(x) for x in OtCliCommandRunner.__ASYNC_COMMANDS))
+
         return output
 
-    def execute_platform_command(self, cmd, timeout=10) -> List[str]:
+    def execute_platform_command(self, cmd: str, timeout: float = 10) -> List[str]:
         raise NotImplementedError(f'Platform command is not supported on {self.__class__.__name__}')
 
     def wait(self, duration: float) -> List[str]:
         self.__otcli.wait(duration)
 
-        output = []
+        output: List[str] = []
         try:
             while True:
                 line = self.__pending_lines.get_nowait()
@@ -162,12 +167,27 @@ class OtCliCommandRunner(OTCommandHandler):
     def set_line_read_callback(self, callback: Optional[Callable[[str], Any]]):
         self.__line_read_callback = callback
 
+    @classmethod
+    def set_filter(cls, filter: re.Pattern[str]):
+        """Set a different filter for the read routine that still matches the original filter"""
+        assert filter.match('[I] ChannelMonitor: debug log')
+        assert filter.match('[I] Mac-----------: info log')
+        assert filter.match('[N] MeshForwarder-: note    log')
+        assert filter.match('[W] Notifier------: warn log')
+        assert filter.match('[C] Mle-----------: critical log')
+        assert filter.match('[-] Settings------: none log')
+        assert not filter.match('[-] Settings-----: none log')  # not enough `-` after module name
+        cls.__pattern_log_line = filter
+
     #
     # Private methods
     #
 
-    def __expect_line(self, timeout: float, expect_line: Union[str, Pattern], asynchronous=False) -> List[str]:
-        output = []
+    def __expect_line(self,
+                      timeout: float,
+                      expect_line: Union[str, Pattern[str]],
+                      asynchronous: bool = False) -> List[str]:
+        output: List[str] = []
 
         if not asynchronous:
             while True:
@@ -213,6 +233,8 @@ class OtCliCommandRunner(OTCommandHandler):
             if line is None:
                 break
 
+            line = line.rstrip()
+
             if line.startswith('> '):
                 line = line[2:]
 
@@ -221,13 +243,15 @@ class OtCliCommandRunner(OTCommandHandler):
 
             logging.debug('%s: %s', self.__otcli, line)
 
-            if not OtCliCommandRunner.__PATTERN_LOG_LINE.match(line):
+            if not OtCliCommandRunner.__pattern_log_line.match(line):
+                if line:
+                    logging.info('%s: %s', self.__otcli, line)
                 self.__pending_lines.put(line)
 
 
 class OtbrSshCommandRunner(OTCommandHandler):
 
-    def __init__(self, host, port, username, password, sudo):
+    def __init__(self, host: str, port: int, username: str, password: str, sudo: bool):
         import paramiko
 
         self.__host = host
@@ -272,16 +296,16 @@ class OtbrSshCommandRunner(OTCommandHandler):
 
         return output
 
-    def execute_platform_command(self, cmd, timeout=10) -> List[str]:
+    def execute_platform_command(self, cmd: str, timeout: float = 10) -> List[str]:
         if self.__sudo:
             cmd = 'sudo ' + cmd
 
         return self.shell(cmd, timeout=timeout)
 
     def shell(self, cmd: str, timeout: float) -> List[str]:
-        cmd_in, cmd_out, cmd_err = self.__ssh.exec_command(cmd, timeout=int(timeout), bufsize=1024)
-        errput = [l.rstrip('\r\n') for l in cmd_err.readlines()]
-        output = [l.rstrip('\r\n') for l in cmd_out.readlines()]
+        _, cmd_out, cmd_err = self.__ssh.exec_command(cmd, timeout=int(timeout), bufsize=1024)
+        errput = [line.rstrip('\r\n') for line in cmd_err.readlines()]
+        output = [line.rstrip('\r\n') for line in cmd_out.readlines()]
 
         if errput:
             raise CommandError(cmd, errput)
diff --git a/tools/otci/otci/connectors.py b/tools/otci/otci/connectors.py
index 55477e1be..571640210 100644
--- a/tools/otci/otci/connectors.py
+++ b/tools/otci/otci/connectors.py
@@ -30,7 +30,7 @@ import logging
 import subprocess
 import time
 from abc import abstractmethod, ABC
-from typing import Optional
+from typing import Any, Optional
 
 
 class OtCliHandler(ABC):
@@ -72,7 +72,7 @@ class Simulator(ABC):
 class OtCliPopen(OtCliHandler):
     """Connector for OT CLI process (a Popen instance)."""
 
-    def __init__(self, proc: subprocess.Popen, nodeid: int, simulator: Simulator):
+    def __init__(self, proc: subprocess.Popen[Any], nodeid: int, simulator: Optional[Simulator]):
         self.__otcli_proc = proc
         self.__nodeid = nodeid
         self.__simulator = simulator
@@ -108,7 +108,7 @@ class OtCliPopen(OtCliHandler):
 class OtCliSim(OtCliPopen):
     """Connector for OT CLI Simulation instances."""
 
-    def __init__(self, executable: str, nodeid: int, simulator: Simulator):
+    def __init__(self, executable: str, nodeid: int, simulator: Optional[Simulator]):
         logging.info('%s: executable=%s', self.__class__.__name__, executable)
 
         proc = subprocess.Popen(args=[executable, str(nodeid)],
@@ -123,7 +123,7 @@ class OtCliSim(OtCliPopen):
 class OtNcpSim(OtCliPopen):
     """Connector for OT NCP Simulation instances."""
 
-    def __init__(self, executable: str, nodeid: int, simulator: Simulator):
+    def __init__(self, executable: str, nodeid: int, simulator: Optional[Simulator]):
         logging.info('%s: executable=%s', self.__class__.__name__, executable)
 
         proc = subprocess.Popen(args=f'spinel-cli.py -p "{executable}" -n {nodeid} 2>&1',
@@ -138,12 +138,13 @@ class OtNcpSim(OtCliPopen):
 class OtCliSerial(OtCliHandler):
     """Connector for OT CLI SOC devices via Serial."""
 
-    def __init__(self, dev: str, baudrate: int):
+    def __init__(self, dev: str, baudrate: int, timeout: float = 0.1):
         self.__dev = dev
         self.__baudrate = baudrate
 
         import serial
-        self.__serial = serial.Serial(self.__dev, self.__baudrate, timeout=0.1, exclusive=True)
+        self.__serial = serial.Serial(self.__dev, self.__baudrate, timeout=timeout, exclusive=True)
+        self.writeline('\r\n')
         self.__linebuffer = b''
 
     def __repr__(self):
@@ -164,7 +165,7 @@ class OtCliSerial(OtCliHandler):
         return None
 
     def writeline(self, s: str):
-        self.__serial.write((s + '\n').encode('utf-8'))
+        self.__serial.write((s + '\r\n').encode('utf-8'))
 
     def wait(self, duration: float):
         time.sleep(duration)
diff --git a/tools/otci/otci/constants.py b/tools/otci/otci/constants.py
index 4bf13c4cb..96948f29a 100644
--- a/tools/otci/otci/constants.py
+++ b/tools/otci/otci/constants.py
@@ -30,3 +30,5 @@
 # Thread versions
 THREAD_VERSION_1_1 = 2
 THREAD_VERSION_1_2 = 3
+THREAD_VERSION_1_3 = 4
+THREAD_VERSION_1_4 = 5
diff --git a/tools/otci/otci/errors.py b/tools/otci/otci/errors.py
index dc8fd59a3..63a915a60 100644
--- a/tools/otci/otci/errors.py
+++ b/tools/otci/otci/errors.py
@@ -26,7 +26,9 @@
 #  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 #  POSSIBILITY OF SUCH DAMAGE.
 #
-from typing import List
+
+import re
+from typing import Collection, List, Pattern, Union
 
 
 class OTCIError(Exception):
@@ -37,15 +39,26 @@ class OTCIError(Exception):
 class ExpectLineTimeoutError(OTCIError):
     """OTCI failed to find an expected line before timeout."""
 
-    def __init__(self, line):
+    def __init__(self, line: Union[str, Pattern[str], Collection[str]]):
         super(ExpectLineTimeoutError, self).__init__("Expected line %r, but timed out" % line)
 
 
 class CommandError(OTCIError):
     """OTCI failed to execute a command."""
 
+    __COMMAND_OUTPUT_ERROR_PATTERN = re.compile(r'Error (\d+): (.*)')
+
     def __init__(self, cmd: str, output: List[str]):
         self.__output = output
+
+        for line in output:
+            m = self.__COMMAND_OUTPUT_ERROR_PATTERN.match(line)
+            if not m:
+                continue
+            code, msg = m.groups()
+            self.code, self.msg = int(code), str(msg)
+            break
+
         super(CommandError, self).__init__("Command error while executing %r:\n%s\n" % (cmd, '\n'.join(output)))
 
     def error(self) -> str:
diff --git a/tools/otci/otci/otci.py b/tools/otci/otci/otci.py
index bc6ac8408..d62885180 100644
--- a/tools/otci/otci/otci.py
+++ b/tools/otci/otci/otci.py
@@ -26,19 +26,21 @@
 #  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 #  POSSIBILITY OF SUCH DAMAGE.
 #
+import functools
 import ipaddress
 import logging
 import re
 from collections import Counter
-from typing import Callable, List, Collection, Union, Tuple, Optional, Dict, Pattern, Any
+from typing import Callable, List, Literal, Collection, Union, Tuple, Optional, Dict, Pattern, Any
 
 from . import connectors
-from .command_handlers import OTCommandHandler, OtCliCommandRunner, OtbrSshCommandRunner, OtbrAdbTcpCommandRunner, OtbrAdbUsbCommandRunner
+from .command_handlers import OTCommandHandler, OtCliCommandRunner, OtbrSshCommandRunner, OtbrAdbTcpCommandRunner
+from .command_handlers import OtbrAdbUsbCommandRunner
 from .connectors import Simulator
 from .errors import UnexpectedCommandOutput, ExpectLineTimeoutError, CommandError, InvalidArgumentsError
-from .types import ChildId, Rloc16, Ip6Addr, ThreadState, PartitionId, DeviceMode, RouterId, SecurityPolicy, Ip6Prefix, \
-    RouterTableEntry, NetifIdentifier
-from .utils import match_line, constant_property
+from .types import ChildId, Rloc16, Ip4Addr, Ip6Addr, ThreadState, PartitionId, DeviceMode, RouterId, SecurityPolicy, Ip6Prefix
+from .types import RouterTableEntry, NetifIdentifier
+from .utils import match_line, constant_property, bits_set
 
 
 class OTCI(object):
@@ -64,7 +66,10 @@ class OTCI(object):
         """Gets the string representation of the OTCI instance."""
         return repr(self.__otcmd)
 
-    def wait(self, duration: float, expect_line: Optional[Union[str, Pattern, Collection[Any]]] = None):
+    def set_filter(self, filter: re.Pattern[str]):
+        self.__otcmd.set_filter(filter)
+
+    def wait(self, duration: float, expect_line: Optional[Union[str, Pattern[str], Collection[str]]] = None):
         """Wait for a given duration.
 
         :param duration: The duration (in seconds) wait for.
@@ -96,21 +101,27 @@ class OTCI(object):
                         cmd: str,
                         timeout: float = 10,
                         silent: bool = False,
-                        already_is_ok: bool = True) -> List[str]:
+                        already_is_ok: bool = True,
+                        ignore_result: bool = False) -> List[str]:
         for i in range(self.__exec_command_retry + 1):
             try:
-                return self.__execute_command(cmd, timeout, silent, already_is_ok=already_is_ok)
-            except Exception:
+                return self.__execute_command(cmd,
+                                              timeout,
+                                              silent,
+                                              already_is_ok=already_is_ok,
+                                              ignore_result=ignore_result)
+            except Exception as e:
                 self.wait(2)
                 if i == self.__exec_command_retry:
-                    raise
+                    raise e from None
         assert False
 
     def __execute_command(self,
                           cmd: str,
                           timeout: float = 10,
                           silent: bool = False,
-                          already_is_ok: bool = True) -> List[str]:
+                          already_is_ok: bool = True,
+                          ignore_result: bool = False) -> List[str]:
         """Execute the OpenThread CLI command.
 
         :param cmd: The command to execute.
@@ -127,7 +138,7 @@ class OTCI(object):
             for line in output:
                 self.log('info', '%s', line)
 
-        if cmd in ('reset', 'factoryreset'):
+        if cmd in ('reset', 'factoryreset') or ignore_result:
             return output
 
         if output[-1] == 'Done' or (already_is_ok and output[-1] == 'Error 24: Already'):
@@ -166,11 +177,11 @@ class OTCI(object):
             self.log('info', '%s', line)
         return output
 
-    def set_logger(self, logger: logging.Logger):
+    def set_logger(self, logger: Optional[logging.Logger]):
         """Set the logger for the OTCI instance, or None to disable logging."""
         self.__logger = logger
 
-    def log(self, level, fmt, *args, **kwargs):
+    def log(self, level: str, fmt: str, *args: Any, **kwargs: Any):
         if self.__logger is not None:
             getattr(self.__logger, level)('(%s) ' + fmt, repr(self), *args, **kwargs)
 
@@ -183,7 +194,10 @@ class OTCI(object):
     #
     @constant_property
     def version(self):
-        """Returns the firmware version. (e.g. "OPENTHREAD/20191113-01411-gb2d66e424-dirty; SIMULATION; Nov 14 2020 14:24:38")"""
+        """Returns the firmware version.
+
+        (e.g. "OPENTHREAD/20191113-01411-gb2d66e424-dirty; SIMULATION; Nov 14 2020 14:24:38")
+        """
         return self.__parse_str(self.execute_command('version'))
 
     @constant_property
@@ -197,9 +211,31 @@ class OTCI(object):
         try:
             return self.__parse_int(self.execute_command('version api'))
         except ValueError:
-            # If the device does not have `version api` command, it will print the firmware version, which would lead to ValueError.
+            # If the device does not have `version api` command, it will print the firmware version,
+            # which would lead to ValueError.
             return 0
 
+    #
+    # Vendor operations
+    #
+    def get_vendor_name(self) -> str:
+        return self.__parse_str(self.execute_command('vendor name'))
+
+    def set_vendor_name(self, name: str):
+        self.execute_command(f'vendor name {name}')
+
+    def get_vendor_model(self) -> str:
+        return self.__parse_str(self.execute_command('vendor model'))
+
+    def set_vendor_model(self, model: str):
+        self.execute_command(f'vendor model {model}')
+
+    def get_vendor_sw_version(self) -> str:
+        return self.__parse_str(self.execute_command('vendor swversion'))
+
+    def set_vendor_sw_version(self, version: str):
+        self.execute_command(f'vendor swversion {version}')
+
     #
     # Basic device operations
     #
@@ -235,32 +271,39 @@ class OTCI(object):
     # Network Operations
     #
     _PING_STATISTICS_PATTERN = re.compile(
-        r'^(?P<transmitted>\d+) packets transmitted, (?P<received>\d+) packets received.(?: Packet loss = (?P<loss>\d+\.\d+)%.)?(?: Round-trip min/avg/max = (?P<min>\d+)/(?P<avg>\d+\.\d+)/(?P<max>\d+) ms.)?$'
-    )
+        r'^(?P<transmitted>\d+) packets transmitted, (?P<received>\d+) packets received.' +
+        r'(?: Packet loss = (?P<loss>\d+\.\d+)%.)?' +
+        r'(?: Round-trip min/avg/max = (?P<min>\d+)/(?P<avg>\d+\.\d+)/(?P<max>\d+) ms.)?$')
 
     def ping(self,
-             ip: Union[str, Ip6Addr],
+             dst: Union[str, Ip6Addr],
+             src: Union[str, Ip6Addr] = "",
              size: int = 8,
              count: int = 1,
              interval: float = 1,
              hoplimit: int = 64,
-             timeout: float = 3) -> Dict:
+             timeout: float = 3) -> Dict[str, Union[int, float, Dict[str, Union[int, float]]]]:
         """Send an ICMPv6 Echo Request.
-        The default arguments are consistent with https://github.com/openthread/openthread/blob/main/src/core/utils/ping_sender.hpp.
+        The default arguments are consistent with
+            https://github.com/openthread/openthread/blob/main/src/core/utils/ping_sender.hpp.
 
-        :param ip: The target IPv6 address to ping.
+        :param dst: The target IPv6 address to ping.
+        :param src: The source IPv6 address of the echo request.
         :param size: The number of data bytes in the payload. Default is 8.
         :param count: The number of ICMPv6 Echo Requests to be sent. Default is 1.
-        :param interval: The interval between two consecutive ICMPv6 Echo Requests in seconds. The value may have fractional form, for example 0.5. Default is 1.
-        :param hoplimit: The hoplimit of ICMPv6 Echo Request to be sent. Default is 64. See OPENTHREAD_CONFIG_IP6_HOP_LIMIT_DEFAULT in src/core/config/ip6.h.
-        :param timeout: The maximum duration in seconds for the ping command to wait after the final echo request is sent. Default is 3.
+        :param interval: The interval between two consecutive ICMPv6 Echo Requests in seconds. The value may have
+                         fractional form, for example 0.5. Default is 1.
+        :param hoplimit: The hoplimit of ICMPv6 Echo Request to be sent. Default is 64. See
+                         OPENTHREAD_CONFIG_IP6_HOP_LIMIT_DEFAULT in src/core/config/ip6.h.
+        :param timeout: The maximum duration in seconds for the ping command to wait after the final echo request is
+                        sent. Default is 3.
         """
-        cmd = f'ping {ip} {size} {count} {interval} {hoplimit} {timeout}'
+        cmd = f'ping {"" if not src else "-I %s" % src} {dst} {size} {count} {interval} {hoplimit} {timeout}'
 
         timeout_allowance = 3
         lines = self.execute_command(cmd, timeout=(count - 1) * interval + timeout + timeout_allowance)
 
-        statistics = {}
+        statistics: Dict[str, Union[int, float, Dict[str, Union[int, float]]]] = {}
         for line in lines:
             m = OTCI._PING_STATISTICS_PATTERN.match(line)
             if m is not None:
@@ -297,7 +340,7 @@ class OTCI(object):
         if len(output) < 2:
             raise UnexpectedCommandOutput(output)
 
-        networks = []
+        networks: List[Dict[str, Union[str, bool, int]]] = []
         for line in output[2:]:
             fields = line.strip().split('|')
 
@@ -333,7 +376,7 @@ class OTCI(object):
         if len(output) < 2:
             raise UnexpectedCommandOutput(output)
 
-        channels = {}
+        channels: Dict[int, int] = {}
         for line in output[2:]:
             fields = line.strip().split('|')
 
@@ -350,8 +393,6 @@ class OTCI(object):
         """Instruct an Rx-Off-When-Idle device to send a Empty Data mac frame to its parent."""
         self.execute_command('mac send emptydata')
 
-    # TODO: discover
-    # TODO: dns resolve <hostname> [DNS server IP] [DNS server port]
     # TODO: fake /a/an <dst-ipaddr> <target> <meshLocalIid>
     # TODO: sntp query
 
@@ -401,7 +442,7 @@ class OTCI(object):
         """Get the Thread Extended PAN ID value."""
         return self.__parse_extpanid(self.execute_command('extpanid'))
 
-    def set_channel(self, ch):
+    def set_channel(self, ch: int):
         """Set the IEEE 802.15.4 Channel value."""
         self.execute_command('channel %d' % ch)
 
@@ -421,11 +462,11 @@ class OTCI(object):
         """Get the IEEE 802.15.4 PAN ID value."""
         return self.__parse_int(self.execute_command('panid'), 16)
 
-    def set_panid(self, panid):
+    def set_panid(self, panid: int):
         """Get the IEEE 802.15.4 PAN ID value."""
         self.execute_command('panid %d' % panid)
 
-    def set_network_name(self, name):
+    def set_network_name(self, name: str):
         """Set network name."""
         self.execute_command('networkname %s' % self.__escape_escapable(name))
 
@@ -461,7 +502,7 @@ class OTCI(object):
 
     def get_cca_threshold(self) -> int:
         """Get the CCA threshold in dBm measured at antenna connector per IEEE 802.15.4 - 2015 section 10.1.4."""
-        output = self.execute_command(f'ccathreshold')
+        output = self.execute_command('ccathreshold')
         val = self.__parse_str(output)
         if not val.endswith(' dBm'):
             raise UnexpectedCommandOutput(output)
@@ -496,6 +537,11 @@ class OTCI(object):
         """Set the transmit power in dBm."""
         self.execute_command(f'txpower {val}')
 
+    def set_ml_iid(self, ml_iid: str):
+        """Set the Mesh Local IID."""
+        self.__validate_iid(ml_iid)
+        self.execute_command(f'mliid {ml_iid}')
+
     # TODO: fem
     # TODO: fem lnagain
     # TODO: fem lnagain <LNA gain>
@@ -531,6 +577,10 @@ class OTCI(object):
     def is_singleton(self) -> bool:
         return self.__parse_values(self.execute_command('singleton'), true=True, false=False)
 
+    def disable_tvcheck(self):
+        """Disable the version check when upgrading to router."""
+        self.execute_command('tvcheck disable')
+
     #
     # RCP related utilities
     #
@@ -592,7 +642,7 @@ class OTCI(object):
 
     def get_leader_data(self) -> Dict[str, int]:
         """Get the Thread Leader Data."""
-        data = {}
+        data: Dict[str, int] = {}
         output = self.execute_command('leaderdata')
 
         try:
@@ -612,7 +662,7 @@ class OTCI(object):
         """Get the ROUTER_SELECTION_JITTER value."""
         return self.__parse_int(self.execute_command('routerselectionjitter'))
 
-    def set_router_selection_jitter(self, jitter):
+    def set_router_selection_jitter(self, jitter: int):
         """Set the ROUTER_SELECTION_JITTER value."""
         self.execute_command(f'routerselectionjitter {jitter}')
 
@@ -683,7 +733,7 @@ class OTCI(object):
 
         headers = self.__split_table_row(output[0])
 
-        table = {}
+        table: Dict[RouterId, RouterTableEntry] = {}
         for line in output[2:]:
             line = line.strip()
             if not line:
@@ -693,7 +743,9 @@ class OTCI(object):
             if len(fields) != len(headers):
                 raise UnexpectedCommandOutput(output)
 
-            col = lambda colname: self.__get_table_col(colname, headers, fields)
+            def col(col_name: str):
+                return self.__get_table_col(col_name, headers, fields)
+
             id = col('ID')
 
             table[RouterId(id)] = router = RouterTableEntry({
@@ -711,19 +763,20 @@ class OTCI(object):
                 router['link'] = int(col('Link'))
             else:
                 # support older version of OT which does not output `Link` field
-                router['link'] = self.get_router_info(router['id'], silent=True)['link']
+                router['link'] = self.get_router_info(RouterId(id), silent=True)['link']
 
         return table
 
     def get_router_info(self, id: int, silent: bool = False) -> RouterTableEntry:
         cmd = f'router {id}'
-        info = {}
         output = self.execute_command(cmd, silent=silent)
         items = [line.strip().split(': ') for line in output]
 
         headers = [h for h, _ in items]
         fields = [f for _, f in items]
-        col = lambda colname: self.__get_table_col(colname, headers, fields)
+
+        def col(col_name: str) -> str:
+            return self.__get_table_col(col_name, headers, fields)
 
         return RouterTableEntry({
             'id': RouterId(id),
@@ -737,7 +790,7 @@ class OTCI(object):
     # Router utilities: Child management
     #
 
-    def get_child_table(self) -> Dict[ChildId, Dict[str, Any]]:
+    def get_child_table(self) -> Dict[ChildId, Dict[str, Union[ChildId, Rloc16, int, str]]]:
         """Get the table of attached children."""
         output = self.execute_command('child table')
         if len(output) < 2:
@@ -754,14 +807,16 @@ class OTCI(object):
 
         headers = self.__split_table_row(output[0])
 
-        table = {}
+        table: Dict[ChildId, Dict[str, Union[ChildId, Rloc16, int, str]]] = {}
         for line in output[2:]:
             line = line.strip()
             if not line:
                 continue
 
             fields = self.__split_table_row(line)
-            col = lambda colname: self.__get_table_col(colname, headers, fields)
+
+            def col(col_name: str):
+                return self.__get_table_col(col_name, headers, fields)
 
             id = int(col("ID"))
             r, d, n = int(col("R")), int(col("D")), int(col("N"))
@@ -776,7 +831,7 @@ class OTCI(object):
             mode = DeviceMode(
                 f'{"r" if r else ""}{"d" if d else ""}{"n" if n else ""}{"-" if r == d == n == 0 else ""}')
 
-            child = {
+            child: Dict[str, Union[ChildId, Rloc16, int, str]] = {
                 'id': ChildId(id),
                 'rloc16': Rloc16(col('RLOC16'), 16),
                 'timeout': int(col('Timeout')),
@@ -809,10 +864,25 @@ class OTCI(object):
 
     _IPV6_SERVER_PORT_PATTERN = re.compile(r'\[(.*)\]:(\d+)')
 
-    def dns_get_config(self):
-        """Get DNS client query config."""
+    def dns_get_config(self) -> Dict[str, Union[Tuple[Ip6Addr, int], int, bool, str]]:
+        """Get DNS client query config.
+        """
         output = self.execute_command('dns config')
-        config = {}
+        config: Dict[str, Union[Tuple[Ip6Addr, int], int, bool, str]] = {}
+
+        #
+        # Example output:
+        # > dns config
+        # Server: [fd00:0:0:0:0:0:0:1]:1234
+        # ResponseTimeout: 5000 ms
+        # MaxTxAttempts: 2
+        # RecursionDesired: no
+        # ServiceMode: srv_txt_opt
+        # Nat64Mode: allow
+        # TransportProtocol: udp
+        # Done
+        #
+
         for line in output:
             k, v = line.split(': ')
             if k == 'Server':
@@ -826,29 +896,50 @@ class OTCI(object):
                 config['max_tx_attempts'] = int(v)
             elif k == 'RecursionDesired':
                 config['recursion_desired'] = (v == 'yes')
+            elif k == 'ServiceMode':
+                config['service_mode'] = v
+            elif k == 'Nat64Mode':
+                config['nat64_mode'] = (v == 'allow')
+            elif k == 'TransportProtocol':
+                config['transport_protocol'] = v
             else:
                 logging.warning("dns config ignored: %s", line)
 
         return config
 
+    @staticmethod
+    def __add_with_default(l: list[str], var: Optional[Any], default: str = '0'):
+        if var is not None:
+            if isinstance(var, bool):
+                l += ['1' if var else '0']
+            else:
+                l += [f'{var}']
+        elif bool(l):
+            l += [default]
+
     def dns_set_config(self,
-                       server: Tuple[Union[str, ipaddress.IPv6Address], int],
+                       server: Union[Tuple[Union[str, ipaddress.IPv6Address], int], Tuple[()]],
                        response_timeout: Optional[int] = None,
                        max_tx_attempts: Optional[int] = None,
-                       recursion_desired: Optional[bool] = None):
+                       recursion_desired: Optional[bool] = None,
+                       service_mode: Optional[str] = None,
+                       transport_protocol: Optional[str] = None):
         """Set DNS client query config."""
-        cmd = f'dns config {str(server[0])} {server[1]}'
-        if response_timeout is not None:
-            cmd += f' {response_timeout}'
-
-        assert max_tx_attempts is None or response_timeout is not None, "must specify `response_timeout` if `max_tx_attempts` is specified."
-        if max_tx_attempts is not None:
-            cmd += f' {max_tx_attempts}'
-
-        assert recursion_desired is None or max_tx_attempts is not None, 'must specify `max_tx_attempts` if `recursion_desired` is specified.'
-        if recursion_desired is not None:
-            cmd += f' {1 if recursion_desired else 0}'
+        # working backwards so we can set defaults when required
+        cmd_parts: List[str] = []
+        self.__add_with_default(cmd_parts, transport_protocol)
+        self.__add_with_default(cmd_parts, service_mode)
+        self.__add_with_default(cmd_parts, recursion_desired)
+        self.__add_with_default(cmd_parts, max_tx_attempts)
+        self.__add_with_default(cmd_parts, response_timeout)
+        if server:
+            self.__add_with_default(cmd_parts, server[1] or None)
+            self.__add_with_default(cmd_parts, server[0] or '::', '::')
+        else:
+            self.__add_with_default(cmd_parts, None)
+            self.__add_with_default(cmd_parts, None, '::')
 
+        cmd = f'dns config {" ".join(cmd_parts[::-1])}'
         self.execute_command(cmd)
 
     def dns_get_compression(self) -> bool:
@@ -863,15 +954,35 @@ class OTCI(object):
         """Disable DNS compression mode."""
         self.execute_command('dns compression disable')
 
-    def dns_browse(self, service: str) -> List[Dict]:
+    def dns_browse(self,
+                   service: str,
+                   server: Optional[Union[Tuple[Union[str, ipaddress.IPv6Address], int], Tuple[()]]] = None,
+                   response_timeout: Optional[int] = None,
+                   max_tx_attempts: Optional[int] = None,
+                   recursion_desired: Optional[bool] = None) -> List[Dict[str, Any]]:
         """Browse DNS service instances."""
-        cmd = f'dns browse {service}'
+
+        cmd_parts: List[str] = []
+        self.__add_with_default(cmd_parts, recursion_desired)
+        self.__add_with_default(cmd_parts, max_tx_attempts)
+        self.__add_with_default(cmd_parts, response_timeout)
+        if server:
+            self.__add_with_default(cmd_parts, server[1] or None)
+            self.__add_with_default(cmd_parts, server[0] or '::', '::')
+        else:
+            self.__add_with_default(cmd_parts, None)
+            self.__add_with_default(cmd_parts, None, '::')
+
+        if cmd_parts:
+            cmd = f'dns browse {service} {" ".join(cmd_parts)}'
+        else:
+            cmd = f'dns browse {service}'
         output = '\n'.join(self.execute_command(cmd, 30.0))
 
-        result = []
+        result: List[Dict[str, Union[str, int, Ip6Addr, Dict[str, Union[bytes, bool]]]]] = []
         for ins, port, priority, weight, srv_ttl, hostname, address, aaaa_ttl, txt_data, txt_ttl in re.findall(
-                r'(.*?)\s+Port:(\d+), Priority:(\d+), Weight:(\d+), TTL:(\d+)\s*Host:(\S+)\s+HostAddress:(\S+) TTL:(\d+)\s+TXT:(\[.*?\]) TTL:(\d+)',
-                output):
+                r'(.*?)\s+Port:(\d+), Priority:(\d+), Weight:(\d+), TTL:(\d+)\s*Host:(\S+)\s+HostAddress:(\S+) ' +
+                r'TTL:(\d+)\s+TXT:(\[.*?\]) TTL:(\d+)', output):
             result.append({
                 'instance': ins,
                 'service': service,
@@ -888,10 +999,13 @@ class OTCI(object):
 
         return result
 
-    def dns_resolve(self, hostname: str) -> List[Dict]:
+    def dns_resolve(self,
+                    hostname: str,
+                    ip_address: str = '',
+                    ignore_result: bool = False) -> List[Dict[str, Union[Ip6Addr, int]]]:
         """Resolve a DNS host name."""
-        cmd = f'dns resolve {hostname}'
-        output = self.execute_command(cmd, 30.0)
+        cmd = 'dns resolve ' + ' '.join([x for x in [hostname, ip_address] if x])
+        output = self.execute_command(cmd, 30.0, ignore_result=ignore_result)
         dns_resp = output[0]
         addrs = dns_resp.strip().split(' - ')[1].split(' ')
         ips = [Ip6Addr(item.strip()) for item in addrs[::2]]
@@ -902,15 +1016,39 @@ class OTCI(object):
             'ttl': ttl,
         } for ip, ttl in zip(ips, ttls)]
 
-    def dns_resolve_service(self, instance: str, service: str) -> Dict:
-        """Resolves aservice instance."""
+    def dns_resolve_service(self,
+                            instance: str,
+                            service: str,
+                            server: Optional[Tuple[Union[str, ipaddress.IPv6Address], int]] = None,
+                            response_timeout: Optional[int] = None,
+                            max_tx_attempts: Optional[int] = None,
+                            recursion_desired: Optional[bool] = None,
+                            ignore_result: bool = False) -> Dict[str, Any]:
+        """Resolves a service instance."""
+
+        cmd_parts: List[str] = []
+        self.__add_with_default(cmd_parts, recursion_desired)
+        self.__add_with_default(cmd_parts, max_tx_attempts)
+        self.__add_with_default(cmd_parts, response_timeout)
+        if server:
+            self.__add_with_default(cmd_parts, server[1] or None)
+            self.__add_with_default(cmd_parts, server[0] or '::')
+        else:
+            self.__add_with_default(cmd_parts, None)
+            self.__add_with_default(cmd_parts, None, '::')
+
         instance = self.__escape_escapable(instance)
-        cmd = f'dns service {instance} {service}'
-        output = self.execute_command(cmd, 30.0)
+
+        if cmd_parts:
+            cmd = f'dns service {instance} {service} {" ".join(cmd_parts[::-1])}'
+        else:
+            cmd = f'dns service {instance} {service}'
+
+        output = self.execute_command(cmd, 30.0, ignore_result=ignore_result)
 
         m = re.match(
-            r'.*Port:(\d+), Priority:(\d+), Weight:(\d+), TTL:(\d+)\s+Host:(.*?)\s+HostAddress:(\S+) TTL:(\d+)\s+TXT:(\[.*?\]) TTL:(\d+)',
-            '\t'.join(output))
+            r'.*Port:(\d+), Priority:(\d+), Weight:(\d+), TTL:(\d+)\s+Host:(.*?)\s+HostAddress:(\S+) ' +
+            r'TTL:(\d+)\s+TXT:(\[.*?\]) TTL:(\d+)', '\t'.join(output))
         if m:
             port, priority, weight, srv_ttl, hostname, address, aaaa_ttl, txt_data, txt_ttl = m.groups()
             return {
@@ -929,6 +1067,23 @@ class OTCI(object):
         else:
             raise CommandError(cmd, output)
 
+    def dns_resolve4(self,
+                     hostname: str,
+                     ip_address: str = '',
+                     ignore_result: bool = False) -> List[Dict[str, Union[Ip4Addr, int]]]:
+        """Resolve a DNS host name."""
+        cmd = 'dns resolve4 ' + ' '.join([x for x in [hostname, ip_address] if x])
+        output = self.execute_command(cmd, 30.0, ignore_result=ignore_result)
+        dns_resp = output[0]
+        addrs = dns_resp.strip().split(' - ')[1].split(' ')
+        ips = [Ip4Addr(item.strip()) for item in addrs[::2]]
+        ttls = [int(item.split('TTL:')[1]) for item in addrs[1::2]]
+
+        return [{
+            'address': ip,
+            'ttl': ttl,
+        } for ip, ttl in zip(ips, ttls)]
+
     #
     # SRP server & client utilities
     #
@@ -945,6 +1100,22 @@ class OTCI(object):
         """Disable SRP server."""
         self.execute_command('srp server disable')
 
+    def srp_server_get_addressmode(self):
+        """Get the SRP server address mode."""
+        return self.__parse_str(self.execute_command(f'srp server addrmode'))
+
+    def srp_server_set_addressmode(self, mode: Literal['unicast', 'anycast']):
+        """Set the SRP server address mode."""
+        self.execute_command(f'srp server addrmode {mode}')
+
+    def srp_server_get_sequence_number(self) -> int:
+        """Set SRP server sequence number."""
+        return self.__parse_int(self.execute_command(f'srp server seqnum'))
+
+    def srp_server_set_sequence_number(self, seq: int):
+        """Set SRP server sequence number."""
+        self.execute_command(f'srp server seqnum {seq}')
+
     def srp_server_get_domain(self) -> str:
         """Get the SRP server domain."""
         return self.__parse_str(self.execute_command('srp server domain'))
@@ -953,18 +1124,18 @@ class OTCI(object):
         """Set the SRP server domain."""
         self.execute_command(f'srp server domain {domain}')
 
-    def srp_server_get_hosts(self) -> List[Dict]:
+    def srp_server_get_hosts(self) -> List[Dict[str, Any]]:
         """Get SRP server registered hosts."""
         return self.__parse_srp_server_hosts(self.execute_command('srp server host'))
 
-    def srp_server_get_services(self) -> List[Dict]:
+    def srp_server_get_services(self) -> List[Dict[str, Any]]:
         """Get SRP server registered services."""
         output = self.execute_command('srp server service')
         return self.__parse_srp_server_services(output)
 
-    def __parse_srp_server_hosts(self, output: List[str]) -> List[Dict]:
-        result = []
-        info = None
+    def __parse_srp_server_hosts(self, output: List[str]) -> List[Dict[str, Any]]:
+        result: List[Dict[str, Any]] = []
+        info: Optional[Dict[str, Any]] = None
         for line in output:
             if not line.startswith(' '):
                 info = {'host': line}
@@ -989,9 +1160,9 @@ class OTCI(object):
 
         return result
 
-    def __parse_srp_server_services(self, output: List[str]) -> List[Dict]:
-        result = []
-        info = None
+    def __parse_srp_server_services(self, output: List[str]) -> List[Dict[str, Any]]:
+        result: List[Dict[str, Any]] = []
+        info: Optional[Dict[str, Any]] = None
         for line in output:
             if not line.startswith(' '):
                 info = {'instance': line}
@@ -1027,7 +1198,7 @@ class OTCI(object):
     def __parse_srp_server_service_txt(self, txt: str) -> Dict[str, Union[bytes, bool]]:
         # example value: [txt11=76616c3131, txt12=76616c3132]
         assert txt.startswith('[') and txt.endswith(']')
-        txt_dict = {}
+        txt_dict: Dict[str, Union[bytes, bool]] = {}
         for entry in txt[1:-1].split(', '):
             if not entry:
                 continue
@@ -1042,9 +1213,9 @@ class OTCI(object):
 
         return txt_dict
 
-    def srp_server_get_lease(self) -> Tuple[int, int, int, int]:
+    def srp_server_get_lease(self) -> Tuple[int, ...]:
         """Get SRP server LEASE & KEY-LEASE range (in seconds)."""
-        lines = self.execute_command(f'srp server lease')
+        lines = self.execute_command('srp server lease')
         return tuple([int(line.split(':')[1].strip()) for line in lines])
 
     def srp_server_set_lease(self, min_lease: int, max_lease: int, min_key_lease: int, max_key_lease: int):
@@ -1091,14 +1262,14 @@ class OTCI(object):
         """Set SRP client host name."""
         self.execute_command(f'srp client host name {name}')
 
-    def srp_client_get_host(self) -> Dict:
+    def srp_client_get_host(self) -> Dict[str, Union[str, List[Ip6Addr]]]:
         """Get SRP client host."""
         output = self.__parse_str(self.execute_command('srp client host'))
         return self.__parse_srp_client_host(output)
 
     _SRP_CLIENT_HOST_PATTERN = re.compile(r'name:("(.*)"|(\(null\))), state:(\S+), addrs:\[(.*)\]')
 
-    def __parse_srp_client_host(self, line: str) -> Dict:
+    def __parse_srp_client_host(self, line: str) -> Dict[str, Union[str, List[Ip6Addr]]]:
         m = re.match(OTCI._SRP_CLIENT_HOST_PATTERN, line)
         if not m:
             raise UnexpectedCommandOutput([line])
@@ -1127,7 +1298,7 @@ class OTCI(object):
         """Get SRP client host state."""
         return self.__parse_str(self.execute_command('srp client host state'))
 
-    def srp_client_remove_host(self, remove_key_lease=False):
+    def srp_client_remove_host(self, remove_key_lease: bool = False):
         """Remove SRP client host."""
         cmd = 'srp client host remove'
         if remove_key_lease:
@@ -1135,7 +1306,11 @@ class OTCI(object):
 
         self.execute_command(cmd)
 
-    def srp_client_get_services(self) -> List[Dict]:
+    def srp_client_clear_host(self):
+        """Clear SRP client host without notifying the SRP server."""
+        self.execute_command('srp client host clear')
+
+    def srp_client_get_services(self) -> List[Dict[str, Union[str, int]]]:
         """Get SRP client services."""
         output = self.execute_command('srp client service')
         return [self.__parse_srp_client_service(line) for line in output]
@@ -1143,7 +1318,7 @@ class OTCI(object):
     _SRP_CLIENT_SERVICE_PATTERN = re.compile(
         r'instance:"(.*)", name:"(.*)", state:(\S+), port:(\d+), priority:(\d+), weight:(\d+)')
 
-    def __parse_srp_client_service(self, line: str) -> Dict:
+    def __parse_srp_client_service(self, line: str) -> Dict[str, Union[str, int]]:
         # e.g. instance:"ins2", name:"_meshcop._udp", state:ToAdd, port:2000, priority:2, weight:2
         m = OTCI._SRP_CLIENT_SERVICE_PATTERN.match(line)
         if m is None:
@@ -1225,18 +1400,18 @@ class OTCI(object):
         fields = [x.strip() for x in fields[1:-1]]
         return fields
 
-    def __get_table_col(self, colname: str, headers: List[str], fields: List[str]) -> str:
-        return fields[headers.index(colname)]
+    def __get_table_col(self, col_name: str, headers: List[str], fields: List[str]) -> str:
+        return fields[headers.index(col_name)]
 
     def get_child_list(self) -> List[ChildId]:
         """Get attached Child IDs."""
-        line = self.__parse_str(self.execute_command(f'child list'))
+        line = self.__parse_str(self.execute_command('child list'))
         return [ChildId(id) for id in line.strip().split()]
 
-    def get_child_info(self, child: Union[ChildId, Rloc16]) -> Dict[str, Any]:
+    def get_child_info(self, child: Union[ChildId, Rloc16]) -> Dict[str, Union[int, str]]:
         output = self.execute_command(f'child {child}')
 
-        info = {}
+        info: Dict[str, Union[int, str]] = {}
 
         for line in output:
             k, v = line.split(': ')
@@ -1270,7 +1445,7 @@ class OTCI(object):
         """
         output = self.execute_command('childip')
 
-        ipaddrs = {}
+        ipaddrs: Dict[Rloc16, List[Ip6Addr]] = {}
 
         for line in output:
             rloc16, ip = line.split(': ')
@@ -1299,11 +1474,11 @@ class OTCI(object):
         """Get the maximum number of IP addresses that each MTD child may register with this device as parent."""
         self.execute_command(f'childip max {val}')
 
-    def get_child_timeout(self):
+    def get_child_timeout(self) -> int:
         """Get the Thread Child Timeout value."""
         return self.__parse_int(self.execute_command('childtimeout'))
 
-    def set_child_timeout(self, timeout):
+    def set_child_timeout(self, timeout: int):
         """Set the Thread Child Timeout value."""
         self.execute_command('childtimeout %d' % timeout)
 
@@ -1352,14 +1527,16 @@ class OTCI(object):
 
         headers = self.__split_table_row(output[0])
 
-        table = {}
+        table: Dict[Rloc16, Dict[str, Any]] = {}
         for line in output[2:]:
             line = line.strip()
             if not line:
                 continue
 
             fields = self.__split_table_row(line)
-            col = lambda colname: self.__get_table_col(colname, headers, fields)
+
+            def col(col_name: str) -> str:
+                return self.__get_table_col(col_name, headers, fields)
 
             role = col('Role')
             is_router = role == 'R'
@@ -1396,9 +1573,30 @@ class OTCI(object):
         self.execute_command(f'pollperiod {poll_period}')
 
     # TODO: csl
-    # TODO: csl channel <channel>
-    # TODO: csl period <period>
-    # TODO: csl timeout <timeout>
+
+    def get_csl_period(self) -> int:
+        """Get the CSL period
+
+        Returns:
+            int: csl period [us] (multiple of 160us)
+        """
+        return self.__parse_int(self.execute_command("csl period"))
+
+    def set_csl_period(self, period: int):
+        """Set the CSL timeout
+
+        Args:
+            period (int): csl period [us] in multiples of 160us
+        """
+        self.execute_command(f"csl period {period}")
+
+    def set_csl_timeout(self, timeout: int):
+        """Set the CSL timeout
+
+        Args:
+            timeout (int): csl timeout [s]
+        """
+        self.execute_command(f"csl timeout {timeout}")
 
     _CSL_PERIOD_PATTERN = re.compile(r'(\d+)us')
     _CSL_TIMEOUT_PATTERN = re.compile(r'(\d+)s')
@@ -1407,19 +1605,19 @@ class OTCI(object):
         """Get the CSL configuration."""
         output = self.execute_command('csl')
 
-        cfg = {}
+        cfg: Dict[str, int] = {}
         for line in output:
             k, v = line.split(': ')
-            if k == 'Channel':
-                cfg['channel'] = int(v)
-            elif k == 'Timeout':
+            if k == 'channel':
+                cfg[k] = int(v)
+            elif k == 'timeout':
                 matched = OTCI._CSL_TIMEOUT_PATTERN.match(v)
                 assert matched is not None
-                cfg['timeout'] = int(matched.group(1))
-            elif k == 'Period':
+                cfg[k] = int(matched.group(1))
+            elif k == 'period':
                 matched = OTCI._CSL_PERIOD_PATTERN.match(v)
                 assert matched is not None
-                cfg['period'] = int(matched.group(1))
+                cfg[k] = int(matched.group(1))
             else:
                 logging.warning("Ignore unknown CSL parameter: %s: %s", k, v)
 
@@ -1464,11 +1662,21 @@ class OTCI(object):
     # Time Sync utilities
     # TODO: networktime
     # TODO: networktime <timesyncperiod> <xtalthreshold>
-    # TODO: delaytimermin
-    # TODO: delaytimermin <delaytimermin>
+
+    def get_minimal_delay_timer(self) -> int:
+        """Get the minimal delay timer (in seconds).
+
+        Returns:
+            int: minimal delay timer in seconds
+        """
+        return self.__parse_int(self.execute_command('delaytimermin'))
+
+    def set_minimal_delay_timer(self, timer: int):
+        """Set the minimal delay timer (in seconds)."""
+        return self.execute_command(f'delaytimermin {timer}')
 
     #
-    # Commissioniner operations
+    # Commissioner operations
     #
 
     def commissioner_start(self):
@@ -1479,7 +1687,7 @@ class OTCI(object):
         """Stop the Commissioner role."""
         self.execute_command('commissioner stop')
 
-    def get_commissioiner_state(self) -> str:
+    def get_commissioner_state(self) -> str:
         """Get current Commissioner state (active or petitioning or disabled)."""
         return self.__parse_str(self.execute_command('commissioner state'))
 
@@ -1487,7 +1695,11 @@ class OTCI(object):
         """Get current commissioner session id."""
         return self.__parse_int(self.execute_command('commissioner sessionid'))
 
-    def commissioner_add_joiner(self, pskd, eui64=None, discerner=None, timeout=None):
+    def commissioner_add_joiner(self,
+                                pskd: str,
+                                eui64: Optional[str] = None,
+                                discerner: Optional[str] = None,
+                                timeout: Optional[int] = None):
         """Add a Joiner entry.
 
         :param pskd: Pre-Shared Key for the Joiner.
@@ -1508,7 +1720,7 @@ class OTCI(object):
 
         self.execute_command(cmd)
 
-    def commissioner_remove_jointer(self, eui64=None, discerner=None):
+    def commissioner_remove_joiner(self, eui64: Optional[str] = None, discerner: Optional[str] = None):
         if (eui64 is not None) == (discerner is not None):
             raise InvalidArgumentsError("Please specify eui64 or discerner, but not both.")
 
@@ -1520,11 +1732,66 @@ class OTCI(object):
     def set_commissioner_provisioning_url(self, url: str):
         self.execute_command(f'commissioner provisioningurl {url}')
 
-    # TODO: commissioner announce
-    # TODO: commissioner energy
-    # TODO: commissioner mgmtget
-    # TODO: commissioner mgmtset
-    # TODO: commissioner panid
+    def commissioner_announce(self, channel_mask: int, count: int, period: int, destination: str | Ip6Addr):
+        """Send an MLE Discovery Request to the specified destination."""
+        self.execute_command(f'commissioner announce {channel_mask} {count} {period} {destination}')
+
+    def commissioner_energy_scan(self, channel_mask: int, count: int, period: int, duration: int,
+                                 destination: str | Ip6Addr) -> Dict[int, List[int]]:
+        """Perform an energy scan on the specified channels."""
+        ch_count = len(list(bits_set(channel_mask)))
+        self.execute_command(f'commissioner energy {channel_mask} {count} {period} {duration} {destination}')
+        output = self.__otcmd.wait(ch_count * count * (period + duration + 999) / 1000 + 1)
+
+        if len(output) > 1:
+            raise UnexpectedCommandOutput(output)
+
+        _mask, _energies = output[0].split(": ")[1].split(" ", 1)
+        channels = [b for b in bits_set(int(_mask, 16))]
+        energies = [int(e) for e in _energies.split(" ")]
+        return {ch: energies[idx::len(channels)] for (idx, ch) in enumerate(channels)}
+
+    def commissioner_mgmt_get(self,
+                              named_tlvs: Optional[Tuple[str, ...]] = None,
+                              hex_tlvs: Optional[Tuple[int, ...]] = None):
+        """Send a MGMT_GET request."""
+        _cmd: List[str] = ['commissioner', 'mgmtget']
+
+        if named_tlvs:
+            _cmd += named_tlvs
+
+        if hex_tlvs:
+            _cmd += [self.__detect_binary_cmd(), "".join(f"{x:02x}" for x in hex_tlvs)]
+
+        self.execute_command(' '.join(_cmd))
+
+    def commissioner_mgmt_set(self,
+                              locator: Optional[str] = None,
+                              session_id: Optional[int] = None,
+                              steering_data: Optional[str] = None,
+                              joiner_udp_port: Optional[int] = None,
+                              tlvs: Optional[str] = None):
+        """Send a MGMT_SET request."""
+        _names = ['locator', 'sessionid', 'steeringdata', 'joinerudpport', self.__detect_binary_cmd()]
+        _tlvs: List[Union[int, str, None]] = [locator, session_id, steering_data, joiner_udp_port, tlvs]
+        _cmd = [x for x in zip(_names, _tlvs) if x[1] is not None]
+
+        if not _cmd:
+            # Nothing to do
+            return
+
+        self.execute_command(f'commissioner mgmtset {" ".join([f"{k} {v}" for k, v in _cmd])}')
+
+    def commissioner_panid_query(self, panid: int, channel_mask: int, destination: str | Ip6Addr) -> List[int]:
+        """Perform a PAN ID query on the specified channels."""
+        self.execute_command(f'commissioner panid {panid} {channel_mask} {destination}')
+        output = self.__otcmd.wait(len(list(bits_set(channel_mask))))
+        if output:
+            masks = [int(line.split(": ")[1].split(", ", 1)[1], 16) for line in output]
+            conflict_mask = functools.reduce(lambda x, y: x | y, masks)
+            return [b for b in bits_set(conflict_mask)]
+        else:
+            return []
 
     #
     # Joiner operations
@@ -1547,7 +1814,7 @@ class OTCI(object):
 
     def get_joiner_port(self) -> int:
         """Get the Joiner port."""
-        return self.__parse_int(self.execute_command(f'joinerport'))
+        return self.__parse_int(self.execute_command('joinerport'))
 
     def set_joiner_port(self, port: int):
         """Set the Joiner port."""
@@ -1558,24 +1825,40 @@ class OTCI(object):
     #
     # Network Data utilities
     #
+    def get_mesh_local_prefix(self) -> Ip6Prefix:
+        """Set the Mesh Local Prefix."""
+        return self.__parse_prefix(self.execute_command('prefix meshlocal'))
+
+    def set_mesh_local_prefix(self, prefix: str):
+        """Set the Mesh Local Prefix."""
+        self.execute_command(f'prefix meshlocal {prefix}')
+
     def get_local_prefixes(self) -> List[Tuple[Ip6Prefix, str, str, Rloc16]]:
         """Get prefixes from local Network Data."""
         output = self.execute_command('prefix')
         return self.__parse_prefixes(output)
 
+    def __parse_prefix(self, output: List[str]) -> Ip6Prefix:
+        if len(output) != 1:
+            raise UnexpectedCommandOutput(output)
+        try:
+            return Ip6Prefix(str(ipaddress.IPv6Network(output[0])))
+        except ValueError:
+            raise UnexpectedCommandOutput(output)
+
     def __parse_prefixes(self, output: List[str]) -> List[Tuple[Ip6Prefix, str, str, Rloc16]]:
-        prefixes = []
+        prefixes: List[Tuple[Ip6Prefix, str, str, Rloc16]] = []
 
         for line in output:
             if line.startswith('- '):
                 line = line[2:]
 
             prefix, flags, prf, rloc16 = line.split()[:4]
-            prefixes.append((Ip6Prefix(prefix), flags, prf, Rloc16(rloc16, 16)))
+            prefixes.append((self.__parse_prefix([prefix]), flags, prf, Rloc16(rloc16, 16)))
 
         return prefixes
 
-    def add_prefix(self, prefix: str, flags='paosr', prf='med'):
+    def add_prefix(self, prefix: str, flags: str = 'paosr', prf: str = 'med'):
         """Add a valid prefix to the Network Data."""
         self.execute_command(f'prefix add {prefix} {flags} {prf}')
 
@@ -1586,14 +1869,23 @@ class OTCI(object):
     def register_network_data(self):
         self.execute_command('netdata register')
 
-    def get_network_data(self) -> Dict[str, List]:
+    def network_data_public_prefix(self, prefix: str, flags: str = 'paos', preference: str = 'med'):
+        self.execute_command(f'netdata publish prefix {prefix} {flags} {preference}')
+
+    def network_data_unpublish_prefix(self, prefix: str):
+        self.execute_command(f'netdata unpublish {prefix}')
+
+    def network_data_unpublish_dnssrp(self):
+        self.execute_command('netdata unpublish dnssrp')
+
+    def get_network_data(self) -> Dict[str, List[Any]]:
         output = self.execute_command('netdata show')
 
-        netdata = {}
+        netdata: Dict[str, List[Any]] = {}
         if output.pop(0) != 'Prefixes:':
             raise UnexpectedCommandOutput(output)
 
-        prefixes_output = []
+        prefixes_output: List[str] = []
         while True:
             line = output.pop(0)
             if line == 'Routes:':
@@ -1603,7 +1895,7 @@ class OTCI(object):
 
         netdata['prefixes'] = self.__parse_prefixes(prefixes_output)
 
-        routes_output = []
+        routes_output: List[str] = []
         while True:
             line = output.pop(0)
             if line == 'Services:':
@@ -1613,7 +1905,7 @@ class OTCI(object):
 
         netdata['routes'] = self.__parse_routes(routes_output)
 
-        services_output = []
+        services_output: List[str] = []
         while True:
             line = output.pop(0)
             if line == 'Contexts:':
@@ -1641,7 +1933,7 @@ class OTCI(object):
         return network_data['services']
 
     def __parse_services(self, output: List[str]) -> List[Tuple[int, bytes, bytes, bool, Rloc16]]:
-        services = []
+        services: List[Tuple[int, bytes, bytes, bool, Rloc16]] = []
         for line in output:
             line = line.split()
 
@@ -1662,7 +1954,7 @@ class OTCI(object):
 
     def get_network_data_bytes(self) -> bytes:
         """Get the raw Network Data."""
-        hexstr = self.__parse_str(self.execute_command('netdata show -x'))
+        hexstr = self.__parse_str(self.execute_command(f'netdata show {self.__detect_binary_cmd()}'))
         return bytes(int(hexstr[i:i + 2], 16) for i in range(0, len(hexstr), 2))
 
     def get_local_routes(self) -> List[Tuple[str, bool, str, Rloc16]]:
@@ -1670,7 +1962,7 @@ class OTCI(object):
         return self.__parse_routes(self.execute_command('route'))
 
     def __parse_routes(self, output: List[str]) -> List[Tuple[str, bool, str, Rloc16]]:
-        routes = []
+        routes: List[Tuple[str, bool, str, Rloc16]] = []
         for line in output:
             line = line.split()
             if len(line) == 4:
@@ -1685,7 +1977,7 @@ class OTCI(object):
 
         return routes
 
-    def add_route(self, prefix: str, stable=True, prf='med'):
+    def add_route(self, prefix: str, stable: bool = True, prf: str = 'med'):
         """Add a valid external route to the Network Data."""
         cmd = f'route add {prefix}'
         if stable:
@@ -1709,11 +2001,11 @@ class OTCI(object):
         server_data = self.__validate_hex_or_bytes(server_data)
         self.execute_command(f'service add {enterprise_number} {service_data} {server_data}')
 
-    def remove_service(self, enterprise_number, service_data):
+    def remove_service(self, enterprise_number: int, service_data: Union[str, bytes]):
         """Remove service from Network Data.
 
         enterpriseNumber: IANA enterprise number
-        serviceData: hext-encoded binary service data
+        serviceData: hex-encoded binary service data
         """
         service_data = self.__validate_hex_or_bytes(service_data)
         self.execute_command(f'service remove {enterprise_number} {service_data}')
@@ -1722,23 +2014,23 @@ class OTCI(object):
     # Dataset management
     #
 
-    def dataset_init_buffer(self, get_active_dataset=False, get_pending_dataset=False):
+    def dataset_init_buffer(self, get_active_dataset: bool = False, get_pending_dataset: bool = False):
         """Initialize operational dataset buffer."""
         if get_active_dataset and get_pending_dataset:
             raise InvalidArgumentsError("Can not specify both `get_active_dataset` and `get_pending_dataset`.")
 
         if get_active_dataset:
-            self.execute_command(f'dataset init active')
+            self.execute_command('dataset init active')
         elif get_pending_dataset:
-            self.execute_command(f'dataset init pending')
+            self.execute_command('dataset init pending')
         else:
-            self.execute_command(f'dataset init new')
+            self.execute_command('dataset init new')
 
     def dataset_commit_buffer(self, dataset: str):
         if dataset in ('active', 'pending'):
             cmd = f'dataset commit {dataset}'
         else:
-            raise InvalidArgumentsError(f'Unkonwn dataset: {dataset}')
+            raise InvalidArgumentsError(f'Unknown dataset: {dataset}')
 
         self.execute_command(cmd)
 
@@ -1752,7 +2044,7 @@ class OTCI(object):
         elif dataset == 'buffer':
             cmd = 'dataset'
         else:
-            raise InvalidArgumentsError(f'Unkonwn dataset: {dataset}')
+            raise InvalidArgumentsError(f'Unknown dataset: {dataset}')
 
         output = self.execute_command(cmd)
         return self.__parse_dataset(output)
@@ -1772,7 +2064,7 @@ class OTCI(object):
         # PSKc: 167d89fd169e439ca0b8266de248090f
         # Security Policy: 672 onrc 0
 
-        dataset = {}
+        dataset: Dict[str, Any] = {}
 
         for line in output:
             line = line.split(': ')
@@ -1799,7 +2091,7 @@ class OTCI(object):
             elif key == 'PSKc':
                 dataset['pskc'] = val
             elif key == 'Security Policy':
-                rotation_time, flags, version_threshold = val.split(' ')
+                rotation_time, flags, _ = val.split(' ')  # Third value `version_threshold` is unused
                 rotation_time = int(rotation_time)
                 dataset['security_policy'] = SecurityPolicy(rotation_time, flags)
             else:
@@ -1809,9 +2101,9 @@ class OTCI(object):
 
     def get_dataset_bytes(self, dataset: str) -> bytes:
         if dataset in ('active', 'pending'):
-            cmd = f'dataset {dataset} -x'
+            cmd = f'dataset {dataset} {self.__detect_binary_cmd()}'
         else:
-            raise InvalidArgumentsError(f'Unkonwn dataset: {dataset}')
+            raise InvalidArgumentsError(f'Unknown dataset: {dataset}')
 
         hexstr = self.__parse_str(self.execute_command(cmd))
         return self.__hex_to_bytes(hexstr)
@@ -1820,7 +2112,7 @@ class OTCI(object):
         if dataset in ('active', 'pending'):
             cmd = f'dataset set {dataset} {self.__bytes_to_hex(data)}'
         else:
-            raise InvalidArgumentsError(f'Unkonwn dataset: {dataset}')
+            raise InvalidArgumentsError(f'Unknown dataset: {dataset}')
 
         self.execute_command(cmd)
 
@@ -1840,7 +2132,7 @@ class OTCI(object):
                            network_name: Optional[str] = None,
                            panid: Optional[int] = None,
                            pskc: Optional[str] = None,
-                           security_policy: Optional[tuple] = None,
+                           security_policy: Optional[tuple[int, str]] = None,
                            pending_timestamp: Optional[int] = None):
         if active_timestamp is not None:
             self.execute_command(f'dataset activetimestamp {active_timestamp}')
@@ -1852,7 +2144,7 @@ class OTCI(object):
             self.execute_command(f'dataset wakeupchannel {wakeupchannel}')
 
         if channel_mask is not None:
-            self.execute_command(f'dataset channelmask {channel_mask}')
+            self.execute_command(f'dataset channelmask {channel_mask:#08x}')
 
         if extpanid is not None:
             self.execute_command(f'dataset extpanid {extpanid}')
@@ -1868,7 +2160,7 @@ class OTCI(object):
             self.execute_command(f'dataset networkname {self.__escape_escapable(network_name)}')
 
         if panid is not None:
-            self.execute_command(f'dataset panid {panid}')
+            self.execute_command(f'dataset panid {panid:#04x}')
 
         if pskc is not None:
             self.execute_command(f'dataset pskc {pskc}')
@@ -1880,8 +2172,39 @@ class OTCI(object):
         if pending_timestamp is not None:
             self.execute_command(f'dataset pendingtimestamp {pending_timestamp}')
 
-    # TODO: dataset mgmtgetcommand
-    # TODO: dataset mgmtsetcommand
+    def dataset_mgmt_get_command(self,
+                                 dataset: str,
+                                 address: Optional[str | Ip6Addr] = None,
+                                 named_tlvs: Optional[List[Tuple[str, str]]] = None,
+                                 hex_tlvs: Optional[Tuple[int, ...]] = None):
+        _cmd: List[str] = ['dataset', 'mgmtgetcommand', dataset]
+
+        if address is not None:
+            _cmd += ['address', str(address)]
+
+        if named_tlvs is not None:
+            # flatten the list of tuples
+            _cmd += [item for sublist in named_tlvs for item in sublist]
+
+        if hex_tlvs is not None:
+            _cmd += [self.__detect_binary_cmd(), ''.join([f'{tlv:02x}' for tlv in hex_tlvs])]
+
+        self.execute_command(' '.join(_cmd))
+
+    def dataset_mgmt_set_command(self,
+                                 dataset: str,
+                                 named_tlvs: Optional[List[Tuple[str, Any]]] = None,
+                                 hex_tlvs: Optional[str] = None):
+        _cmd = ['dataset', 'mgmtsetcommand', dataset]
+
+        if named_tlvs is not None:
+            _cmd += list(sum(named_tlvs, ()))
+
+        if hex_tlvs is not None:
+            _cmd += [self.__detect_binary_cmd(), hex_tlvs]
+
+        self.execute_command(' '.join(_cmd))
+
     # TODO: dataset set <active|pending> <dataset>
 
     #
@@ -1908,7 +2231,8 @@ class OTCI(object):
     def clear_allowlist(self):
         self.execute_command('macfilter addr clear')
 
-    def set_allowlist(self, allowlist: Collection[Union[str, Tuple[str, int]]]):
+    def set_allowlist(self, allowlist: Optional[Collection[Union[str, Tuple[str, int]]]]):
+        """Add addresses to the allowlist"""
         self.clear_allowlist()
 
         if allowlist is None:
@@ -1922,10 +2246,34 @@ class OTCI(object):
                     addr, rssi = item[0], item[1]
                     self.add_allowlist(addr, rssi)
 
-    # TODO: denylist
+    def enable_denylist(self):
+        self.execute_command(f'macfilter addr {self.__detect_denylist_cmd()}')
+
+    disable_denylist = disable_allowlist
+    add_denylist = add_allowlist
+    remove_denylist = remove_allowlist
+    clear_denylist = clear_allowlist
+
+    def set_denylist(self, denylist: Optional[Collection[Union[str, Tuple[str, int]]]]):
+        """Add addresses to the denylist"""
+        self.clear_denylist()
+
+        if denylist is None:
+            self.disable_denylist()
+        else:
+            self.enable_denylist()
+            for item in denylist:
+                if isinstance(item, str):
+                    self.add_denylist(item)
+                else:
+                    addr, rssi = item[0], item[1]
+                    self.add_denylist(addr, rssi)
+
     # TODO: macfilter rss
     # TODO: macfilter rss add <extaddr> <rss>
-    # TODO: macfilter rss add-lqi <extaddr> <lqi>
+    def set_filter_rss_add_lqi(self, extaddr: str, lqi: int):
+        self.execute_command(f'macfilter addr rss add-lqi {extaddr} {lqi}')
+
     # TODO: macfilter rss remove <extaddr>
     # TODO: macfilter rss clear
 
@@ -1935,21 +2283,30 @@ class OTCI(object):
         else:
             return '\x77\x68\x69\x74\x65\x6c\x69\x73\x74'
 
+    def __detect_denylist_cmd(self):
+        if self.api_version >= 28:
+            return 'denylist'
+        else:
+            return '\x62\x6c\x61\x63\x6b\x6c\x69\x73\x74'
+
     def __detect_networkkey_cmd(self) -> str:
         return 'networkkey' if self.api_version >= 126 else 'masterkey'
 
+    def __detect_binary_cmd(self) -> str:
+        return '-x' if self.api_version >= 28 else 'binary'
+
     #
     # Unicast Addresses management
     #
-    def add_ipaddr(self, ip: Union[str, ipaddress.IPv6Address]):
+    def add_ipaddr(self, ip: Union[str, Ip6Addr]):
         """Add an IPv6 address to the Thread interface."""
         self.execute_command(f'ipaddr add {ip}')
 
-    def del_ipaddr(self, ip: Union[str, ipaddress.IPv6Address]):
+    def del_ipaddr(self, ip: Union[str, Ip6Addr]):
         """Delete an IPv6 address from the Thread interface."""
         self.execute_command(f'ipaddr del {ip}')
 
-    def get_ipaddrs(self) -> Tuple[Ip6Addr]:
+    def get_ipaddrs(self) -> Tuple[Ip6Addr, ...]:
         """Get all IPv6 addresses assigned to the Thread interface."""
         return tuple(map(Ip6Addr, self.execute_command('ipaddr')))
 
@@ -1973,19 +2330,19 @@ class OTCI(object):
     # Multicast Addresses management
     #
 
-    def add_ipmaddr(self, ip: Union[str, ipaddress.IPv6Address]):
+    def add_ipmaddr(self, ip: Union[str, Ip6Addr]):
         """Subscribe the Thread interface to the IPv6 multicast address."""
-        self.execute_command(f'ipmaddr add {ip}')
+        self.execute_command(f'ipmaddr add {ip}', already_is_ok=True)
 
-    def del_ipmaddr(self, ip: Union[str, ipaddress.IPv6Address]):
+    def del_ipmaddr(self, ip: Union[str, Ip6Addr]):
         """Unsubscribe the Thread interface to the IPv6 multicast address."""
-        self.execute_command(f'ipmaddr del {ip}')
+        self.execute_command(f'ipmaddr del {ip}', already_is_ok=True)
 
-    def get_ipmaddrs(self) -> Tuple[Ip6Addr]:
+    def get_ipmaddrs(self) -> Tuple[Ip6Addr, ...]:
         """Get all IPv6 multicast addresses subscribed to the Thread interface."""
         return tuple(map(Ip6Addr, self.execute_command('ipmaddr')))
 
-    def has_ipmaddr(self, ip: Union[str, ipaddress.IPv6Address]):
+    def has_ipmaddr(self, ip: Union[str, Ip6Addr]):
         """Check if a IPv6 multicast address was subscribed by the Thread interface."""
         return ip in self.get_ipmaddrs()
 
@@ -1997,16 +2354,75 @@ class OTCI(object):
         """Get Realm Local All Thread Nodes Multicast Address"""
         return self.__parse_ip6addr(self.execute_command('ipmaddr rlatn'))
 
+    #
+    # CCM features
+    #
+    def enable_ccm(self):
+        """Enable Child Care Mode (CCM) for the Thread interface."""
+        self.execute_command('ccm enable')
+
+    def disable_ccm(self):
+        """Disable Child Care Mode (CCM) for the Thread interface."""
+        self.execute_command('ccm disable')
+
+    #
+    # Border Router utilities
+    #
+    def get_br_omr_prefix(self,
+                          type: Optional[Literal["local", "favored"]] = None) -> Dict[str, Tuple[Ip6Prefix, str]]:
+        """Get the Border Router On-Mesh Prefix."""
+        prefixes: Dict[str, Tuple[Ip6Prefix, str]] = {}
+        types = ('local', 'favored')
+        cmd = 'br omrprefix'
+        if type is not None:
+            if type not in types:
+                raise InvalidArgumentsError(f"Unknown type: {type}")
+            cmd += f' {type}'
+
+        output = self.execute_command(cmd)
+
+        rex = re.compile(r'(?:(Local|Favored): )?([a-f0-9:]+/[0-9]{1,3})(?: prf:([a-z]{3,4}))?')
+        for idx, line in enumerate(output):
+            matched = rex.match(line)
+            if matched is None:
+                raise UnexpectedCommandOutput(output)
+
+            prefix = Ip6Prefix(matched.group(2))
+            prf = matched.group(3) or 'med'
+            prefixes[(matched.group(1) or types[idx]).lower()] = (prefix, prf)
+
+        return prefixes
+
+    def br_get_onlink_prefix(self) -> Ip6Prefix:
+        """Get the On-Mesh Prefix."""
+        return self.__parse_prefix(self.execute_command('br onlinkprefix'))
+
+    def br_disable(self):
+        """Disable the Border Router."""
+        self.execute_command('br disable')
+
     #
     # Backbone Router Utilities
     #
 
     # TODO: bbr mgmt ...
+    def set_bbr_dua_response_status(self, status: int, mliid: Optional[str] = None):
+        """Set Backbone Router Data Unicast Address Response status/coap-code.
+
+        Only for testing/reference devices
+        """
+        _mliid = mliid if mliid is not None else ""
+        self.execute_command(f'bbr mgmt dua {status} {_mliid}')
+
+    def set_bbr_mlr_response_status(self, status: int):
+        """Set Backbone Router Multicast Listener Response status."""
+        self.execute_command(f'bbr mgmt mlr response {status}')
 
     def enable_backbone_router(self):
         """Enable Backbone Router Service for Thread 1.2 FTD.
 
-        SRV_DATA.ntf would be triggered for attached device if there is no Backbone Router Service in Thread Network Data.
+        SRV_DATA.ntf would be triggered for attached device if there is no Backbone Router Service in
+        Thread Network Data.
         """
         self.execute_command('bbr enable')
 
@@ -2021,7 +2437,7 @@ class OTCI(object):
         """Get local Backbone state (Disabled or Primary or Secondary) for Thread 1.2 FTD."""
         return self.__parse_str(self.execute_command('bbr state'))
 
-    def get_primary_backbone_router_info(self) -> Optional[dict]:
+    def get_primary_backbone_router_info(self) -> Optional[Dict[str, int]]:
         """Show current Primary Backbone Router information for Thread 1.2 device."""
         output = self.execute_command('bbr')
 
@@ -2042,7 +2458,7 @@ class OTCI(object):
         # delay:    120 secs
         # timeout:  300 secs
 
-        dataset = {}
+        dataset: Dict[str, int] = {}
 
         for line in output[1:]:
             key, val = line.split(':')
@@ -2071,7 +2487,7 @@ class OTCI(object):
         """
         self.execute_command('bbr register')
 
-    def get_backbone_router_config(self) -> dict:
+    def get_backbone_router_config(self) -> Dict[str, int]:
         """Show local Backbone Router configuration for Thread 1.2 FTD."""
         output = self.execute_command('bbr config')
         # Example output:
@@ -2079,7 +2495,7 @@ class OTCI(object):
         # delay:    120 secs
         # timeout:  300 secs
 
-        config = {}
+        config: Dict[str, int] = {}
 
         for line in output:
             key, val = line.split(':')
@@ -2101,7 +2517,8 @@ class OTCI(object):
                                    timeout: Optional[int] = None):
         """Configure local Backbone Router configuration for Thread 1.2 FTD.
 
-        Call register_backbone_router_dataset() to explicitly register Backbone Router service to Leader for Secondary Backbone Router.
+        Call register_backbone_router_dataset() to explicitly register Backbone Router service to Leader for
+        Secondary Backbone Router.
         """
         if seqno is None and delay is None and timeout is None:
             raise InvalidArgumentsError("Please specify seqno or delay or timeout")
@@ -2128,7 +2545,7 @@ class OTCI(object):
 
     def backbone_router_get_multicast_listeners(self) -> List[Tuple[Ip6Addr, int]]:
         """Get Backbone Router Multicast Listeners."""
-        listeners = []
+        listeners: List[Tuple[Ip6Addr, int]] = []
         for line in self.execute_command('bbr mgmt mlr listener'):
             ip, timeout = line.split()
             listeners.append((Ip6Addr(ip), int(timeout)))
@@ -2147,9 +2564,23 @@ class OTCI(object):
         """Set the Thread Domain Name for Thread 1.2 device."""
         self.execute_command('domainname %s' % self.__escape_escapable(name))
 
-    # TODO: dua iid
-    # TODO: dua iid <iid>
-    # TODO: dua iid clear
+    def get_dua_iid(self) -> str:
+        """Get the DUA IID for Thread 1.2 device."""
+        raw_iid = self.execute_command('dua iid')
+        if raw_iid:
+            return self.__parse_iid(raw_iid)
+        else:
+            return ''
+
+    def set_dua_iid(self, iid: str):
+        """Set the DUA IID for Thread 1.2 device."""
+        self.__validate_iid(iid)
+        self.execute_command(f'dua iid {iid}')
+
+    def clear_dua_iid(self):
+        """Clear the DUA IID for Thread 1.2 device."""
+        self.execute_command('dua iid clear')
+
     # TODO: mlr reg <ipaddr> ... [timeout]
 
     #
@@ -2211,7 +2642,6 @@ class OTCI(object):
 
         status = ''
         report_received = False
-        ret = False
 
         for line in output:
             if 'Received Link Metrics Management Response from' in line:
@@ -2235,7 +2665,7 @@ class OTCI(object):
         # Done
         #
 
-        results = {}
+        results: Dict[str, int] = {}
         report_received = False
 
         for line in output:
@@ -2247,7 +2677,8 @@ class OTCI(object):
                 # link metrics info after executing the `linkmetrics request` command. This case is
                 # used to skip these Enhanced-ACK related link metrics info.
                 #
-                # Received Link Metrics data in Enh Ack from neighbor, short address:0x3400 , extended address:c6a24d6514cf9178
+                # Received Link Metrics data in Enh Ack from neighbor, short address:0x3400 ,
+                #                                                      extended address:c6a24d6514cf9178
                 # - LQI: 224 (Exponential Moving Average)
                 # - Margin: 0 (dB) (Exponential Moving Average)
                 #
@@ -2276,7 +2707,7 @@ class OTCI(object):
         return results
 
     def __parse_numbers(self, line: str) -> List[int]:
-        values = re.findall("\-?\d+", line)
+        values = re.findall(r"-?\d+", line)
         return list(map(int, values))
 
     def __valid_flags(self, flags: str, flags_set: str):
@@ -2302,13 +2733,13 @@ class OTCI(object):
     # Device performance related information
     #
 
-    def get_message_buffer_info(self) -> dict:
+    def get_message_buffer_info(self) -> Dict[str, Union[int, Tuple[int, ...]]]:
         """Get the current message buffer information."""
         output = self.execute_command('bufferinfo')
 
-        info = {}
+        info: Dict[str, Union[int, Tuple[int, ...]]] = {}
 
-        def _parse_val(val):
+        def _parse_val(val: str):
             vals = val.split()
             return int(vals[0]) if len(vals) == 1 else tuple(map(int, vals))
 
@@ -2324,11 +2755,11 @@ class OTCI(object):
         """Get the supported counter names."""
         return tuple(self.execute_command('counters'))
 
-    def get_counter(self, name: str) -> Counter:
+    def get_counter(self, name: str) -> Counter[str]:
         """Reset the counter value."""
         output = self.execute_command(f'counters {name}')
 
-        counter = Counter()
+        counter: Counter[str] = Counter()
         for line in output:
             k, v = line.strip().split(': ')
             counter[k] = int(v)
@@ -2342,7 +2773,7 @@ class OTCI(object):
     def get_eidcache(self) -> Dict[Ip6Addr, Rloc16]:
         """Get the EID-to-RLOC cache entries."""
         output = self.execute_command('eidcache')
-        cache = {}
+        cache: Dict[Ip6Addr, Rloc16] = {}
 
         for line in output:
             ip, rloc16, _ = line.split(" ", 2)
@@ -2363,7 +2794,7 @@ class OTCI(object):
         """Opens the example socket."""
         self.execute_command('udp close')
 
-    def udp_bind(self, ip: str, port: int, netif: NetifIdentifier = NetifIdentifier.THERAD):
+    def udp_bind(self, ip: str, port: int, netif: NetifIdentifier = NetifIdentifier.THREAD):
         """Assigns a name (i.e. IPv6 address and port) to the example socket.
 
         :param ip: the IPv6 address or the unspecified IPv6 address (::).
@@ -2390,12 +2821,15 @@ class OTCI(object):
                  port: Optional[int] = None,
                  text: Optional[str] = None,
                  random_bytes: Optional[int] = None,
-                 hex: Optional[str] = None):
+                 hex: Optional[str] = None,
+                 return_result: bool = True):
         """Send a few bytes over UDP.
 
         ip: the IPv6 destination address.
         port: the UDP destination port.
-        type: the type of the message: _ -t: text payload in the value, same as without specifying the type. _ -s: autogenerated payload with specified length indicated in the value.
+        type: the type of the message:
+            _ -t: text payload in the value, same as without specifying the type.
+            _ -s: auto-generated payload with specified length indicated in the value.
         * -x: binary data in hexadecimal representation in the value.
         """
         if (ip is None) != (port is None):
@@ -2417,7 +2851,7 @@ class OTCI(object):
             self.__validate_hex(hex)
             cmd += f' -x {hex}'
 
-        self.execute_command(cmd)
+        self.execute_command(cmd, ignore_result=not return_result)
 
     def udp_get_link_security(self) -> bool:
         """Gets whether the link security is enabled or disabled."""
@@ -2437,7 +2871,7 @@ class OTCI(object):
         if len(output) < 2:
             raise UnexpectedCommandOutput(output)
 
-        socks = []
+        socks: List[Tuple[Tuple[Ip6Addr, int], Tuple[Ip6Addr, int]]] = []
         for line in output[2:]:
             _, sock_addr, peer_addr = line.strip().split('|')[:3]
             sock_addr = self.__parse_socket_addr(sock_addr.strip())
@@ -2502,7 +2936,8 @@ class OTCI(object):
         self.execute_command(f'coap resource {path}')
 
     def coap_test_set_resource_content(self, content: str):
-        """Sets the content sent by the test resource. If a CoAP client is observing the resource, a notification is sent to that client."""
+        """Sets the content sent by the test resource. If a CoAP client is observing the resource, a notification is
+           sent to that client."""
         self.execute_command(f'coap set {content}')
 
     # TODO: coap observe <address> <uri-path> [type]
@@ -2513,6 +2948,10 @@ class OTCI(object):
     #
     # Diag Utilities
     #
+    def diag(self):
+        """Get the current status of the diagnostics module."""
+        return self.__parse_str(self.execute_command('diag'))
+
     def diag_start(self):
         """Start diagnostics mode."""
         self.execute_command('diag start')
@@ -2527,8 +2966,7 @@ class OTCI(object):
 
     def diag_get_channel(self) -> int:
         """Get the IEEE 802.15.4 Channel value for diagnostics module."""
-        line = self.__parse_str(self.execute_command('diag channel'))
-        return int(line)
+        return self.__parse_int(self.execute_command('diag channel'))
 
     def diag_set_power(self, power: int):
         """Set the tx power value(dBm) for diagnostics module."""
@@ -2536,8 +2974,7 @@ class OTCI(object):
 
     def diag_get_power(self) -> int:
         """Get the tx power value(dBm) for diagnostics module."""
-        line = self.__parse_str(self.execute_command('diag power'))
-        return int(line)
+        return self.__parse_int(self.execute_command('diag power'))
 
     def diag_cw_start(self):
         """Start transmitting continuous carrier wave."""
@@ -2616,7 +3053,7 @@ class OTCI(object):
         """Set radio to receive mode."""
         self.execute_command('diag radio receive')
 
-    def diag_radio_receive_number(self, number: int):
+    def diag_radio_receive_number(self, number: int) -> List[Dict[str, Union[int, str]]]:
         """Set radio to receive mode and receive specified number of packets."""
         #
         # The `diag radio receive <number> [lpr]` command example:
@@ -2635,7 +3072,7 @@ class OTCI(object):
         if len(output) != number:
             raise UnexpectedCommandOutput(output)
 
-        result = []
+        result: List[Dict[str, Union[int, str]]] = []
 
         for line in output:
             data = line.split(',')
@@ -2687,7 +3124,7 @@ class OTCI(object):
         if len(output) < 7:
             raise UnexpectedCommandOutput(output)
 
-        result = {}
+        result: Dict[str, int] = {}
 
         result['received_packets'] = int(output[0].split(":")[1])
         result['sent_success_packets'] = int(output[1].split(":")[1])
@@ -2696,11 +3133,11 @@ class OTCI(object):
         result['sent_error_invalid_state_packets'] = int(output[4].split(":")[1])
         result['sent_error_others_packets'] = int(output[5].split(":")[1])
 
-        values = re.findall("\-?\d+", output[6])
+        values = re.findall(r"-?\d+", output[6])
         result['first_received_packet_rssi'] = int(values[0])
         result['first_received_packet_lqi'] = int(values[1])
 
-        values = re.findall("\-?\d+", output[7])
+        values = re.findall(r"-?\d+", output[7])
         result['last_received_packet_rssi'] = int(values[0])
         result['last_received_packet_lqi'] = int(values[1])
 
@@ -2748,7 +3185,7 @@ class OTCI(object):
         # |      26 |    26 |        1600 |        1500 |          334455 |
         # Done
         #
-        result = []
+        result: List[Dict[str, Union[int, bytes]]] = []
         output = self.execute_command(f'diag powersettings')
 
         if len(output) < 3:
@@ -2781,7 +3218,7 @@ class OTCI(object):
         # RawPowerSetting: 223344
         # Done
         #
-        result = {}
+        result: Dict[str, Union[int, bytes]] = {}
         output = self.execute_command(f'diag powersettings {channel}')
 
         if len(output) != 4:
@@ -2816,7 +3253,7 @@ class OTCI(object):
         """Check whether the the given command is supported by the device."""
         output = self.__otcmd.execute_command(command, timeout=10)
 
-        if re.match("Error \d+: \w*", output[-1]):
+        if re.match(r"Error \d+: \w*", output[-1]):
             return False
 
         return True
@@ -2834,7 +3271,7 @@ class OTCI(object):
                        network_name: Optional[str] = None,
                        panid: Optional[int] = None,
                        pskc: Optional[str] = None,
-                       security_policy: Optional[tuple] = None,
+                       security_policy: Optional[tuple[int, str]] = None,
                        pending_timestamp: Optional[int] = None,
                        wakeup_channel: Optional[int] = None) -> bytes:
         """Creates a new Operational Dataset with given parameters."""
@@ -2855,7 +3292,7 @@ class OTCI(object):
         self.thread_stop()
         self.ifconfig_down()
 
-    def wait_for(self, command: str, expect_line: Optional[Union[str, Pattern, Collection[Any]]], timeout: float = 60):
+    def wait_for(self, command: str, expect_line: Union[str, Pattern[str], Collection[str]], timeout: float = 60):
         """Wait for the expected output by periodically executing the given command."""
         success = False
 
@@ -2874,10 +3311,77 @@ class OTCI(object):
     #
     # Other TODOs
     #
-    # TODO: netstat
-    # TODO: networkdiagnostic get <addr> <type> ..
-    # TODO: networkdiagnostic reset <addr> <type> ..
-    # TODO: parent
+
+    def get_network_diagnostics(self, addr: Union[str, Ip6Addr],
+                                tlvs: list[int]) -> Dict[str, Union[str, Dict[str, str]]]:
+        """Get the network diagnostic information."""
+        args = [str(addr)] + list(map(str, tlvs))
+        output = self.execute_command(f'networkdiagnostic get {" ".join(args)}')
+        # line 0 is the hex representation of the diagnostics
+        # below that is the human readable/parsed format
+        result: Dict[str, Union[str, Dict[str, str]]] = {}
+        diag: Optional[Union[str, Dict[str, str]]] = None
+        for line in output[1:]:
+            if not line.startswith(' '):
+                k, v = line.split(': ', 1)
+                diag = v or {}
+                result[line.split(': ', 1)[0]] = diag
+            else:
+                assert diag is not None and isinstance(diag, dict)
+                k, v = line.strip().split(': ')
+                diag[k] = v
+        return result
+
+    def get_network_diagnostics_bytes(self, addr: Union[str, Ip6Addr], tlvs: list[int]) -> str:
+        """Get the network diagnostic information."""
+        args = [str(addr)] + list(map(str, tlvs))
+        output = self.execute_command(f'networkdiagnostic get {" ".join(args)}')
+        # line 0 is the hex representation of the diagnostics
+        # below that is the human readable/parsed format
+        return output[0].split(': ')[1]
+
+    def reset_network_diagnostics(self, addr: Union[str, Ip6Addr], type: list[int]):
+        """Reset the network diagnostic information."""
+        self.execute_command(f'networkdiagnostic reset {addr} {" ".join(map(str, type))}')
+
+    def get_network_diagnostics_non_preferred_channels(self) -> int:
+        """Get the non-preferred channels in the network diagnostics."""
+        return self.__parse_int(self.execute_command('networkdiagnostic nonpreferredchannels'), 16)
+
+    def set_network_diagnostics_non_preferred_channels(self, channels: int):
+        """Set the non-preferred channels in the network diagnostics."""
+        self.execute_command(f'networkdiagnostic nonpreferredchannels {channels}')
+
+    __PARENT_KEY_MAP = {
+        'Ext Addr': 'extaddr',
+        'Rloc': 'rloc16',
+        'Link Quality In': 'lq_in',
+        'Link Quality Out': 'lq_out',
+        'Age': 'age',
+        'Version': 'version',
+        'CSL clock accuracy': 'csl_clock_accuracy',
+        'CSL uncertainty': 'csl_uncertainty',
+    }
+
+    def get_parent(self) -> Dict[str, Union[int, str]]:
+        """Get the diagnostic information for a Thread Router as parent."""
+        data: Dict[str, Union[int, str]] = {}
+        output = self.execute_command('parent')
+
+        try:
+            for line in output:
+                k, v = line.split(': ')
+                if OTCI.__PARENT_KEY_MAP[k] == 'extaddr':
+                    data[OTCI.__PARENT_KEY_MAP[k]] = v
+                elif OTCI.__PARENT_KEY_MAP[k] == 'rloc16':
+                    data[OTCI.__PARENT_KEY_MAP[k]] = Rloc16(v, 16)
+                else:
+                    data[OTCI.__PARENT_KEY_MAP[k]] = int(v, base=0)
+        except KeyError:
+            raise UnexpectedCommandOutput(output)
+
+        return data
+
     # TODO: pskc [-p] <key>|<passphrase>
     #
 
@@ -2946,10 +3450,11 @@ class OTCI(object):
         length_option = f'-l {length}' if length else ''
         format_option = '-f k'
 
-        cmd = f'iperf3 {version_option} {client_option} {udp_option} {bitrate_option} {interval_option} {time_option} {length_option} {format_option}'
+        cmd = (f'iperf3 {version_option} {client_option} {udp_option} {bitrate_option} {interval_option} ' +
+               f'{time_option} {length_option} {format_option}')
         output = self.execute_platform_command(cmd, timeout=transmit_time + wait_time)
 
-        results = {}
+        results: Dict[str, Any] = {}
         for line in output:
             fields = line.split()
             if len(fields) != 13:
@@ -3004,7 +3509,7 @@ class OTCI(object):
         return results
 
     def __parse_iperf3_report(self, line: str) -> Dict[str, Any]:
-        results = {}
+        results: Dict[str, Any] = {}
         fields = line.split()
         format_unit = 1000
 
@@ -3040,7 +3545,7 @@ class OTCI(object):
     def __parse_ip6addr_list(self, output: List[str]) -> List[Ip6Addr]:
         return [Ip6Addr(line) for line in output]
 
-    def __parse_int(self, output: List[str], base=10) -> int:
+    def __parse_int(self, output: List[str], base: int = 10) -> int:
         if len(output) != 1:
             raise UnexpectedCommandOutput(output)
 
@@ -3076,6 +3581,7 @@ class OTCI(object):
     __parse_extpanid = __parse_hex64b
     __parse_eui64 = __parse_hex64b
     __parse_joiner_id = __parse_hex64b
+    __parse_iid = __parse_hex64b
 
     def __validate_hex64b(self, extaddr: str):
         if len(extaddr) != 16:
@@ -3092,11 +3598,12 @@ class OTCI(object):
 
     __validate_extaddr = __validate_hex64b
     __validate_extpanid = __validate_hex64b
+    __validate_iid = __validate_hex64b
 
     def __parse_Enabled_or_Disabled(self, output: List[str]) -> bool:
         return self.__parse_values(output, Enabled=True, Disabled=False)
 
-    def __parse_values(self, output: List[str], **vals) -> Any:
+    def __parse_values(self, output: List[str], **vals: Any) -> Any:
         val = self.__parse_str(output)
         if val not in vals:
             raise UnexpectedCommandOutput(output)
@@ -3106,9 +3613,11 @@ class OTCI(object):
     def __validate_hex_or_bytes(self, data: Union[str, bytes]) -> str:
         if isinstance(data, bytes):
             return ''.join('%02x' % c for c in data)
-        else:
+        elif isinstance(data, str):
             self.__validate_hex(data)
             return data
+        else:
+            raise TypeError(f"Type {type(data)} is not supported.")
 
     def __hex_to_bytes(self, hexstr: str) -> bytes:
         self.__validate_hex(hexstr)
@@ -3152,35 +3661,39 @@ class OTCI(object):
         return arg_name + ' ' if arg_value is not None and arg_value else ''
 
 
-def connect_cli_sim(executable: str, nodeid: int, simulator: Optional[Simulator] = None) -> OTCI:
+def connect_cli_sim(executable: str, nodeid: int, simulator: Optional[Simulator]) -> OTCI:
     cli_handler = connectors.OtCliSim(executable, nodeid, simulator=simulator)
     cmd_handler = OtCliCommandRunner(cli_handler)
     return OTCI(cmd_handler)
 
 
-def connect_cli_serial(dev: str, baudrate=115200) -> OTCI:
+def connect_cli_serial(dev: str, baudrate: int = 115200) -> OTCI:
     cli_handler = connectors.OtCliSerial(dev, baudrate)
     cmd_handler = OtCliCommandRunner(cli_handler)
     return OTCI(cmd_handler)
 
 
-def connect_ncp_sim(executable: str, nodeid: int, simulator: Optional[Simulator] = None) -> OTCI:
+def connect_ncp_sim(executable: str, nodeid: int, simulator: Optional[Simulator]) -> OTCI:
     ncp_handler = connectors.OtNcpSim(executable, nodeid, simulator=simulator)
     cmd_handler = OtCliCommandRunner(ncp_handler, is_spinel_cli=True)
     return OTCI(cmd_handler)
 
 
-def connect_otbr_ssh(host: str, port: int = 22, username='pi', password='raspberry', sudo=True):
+def connect_otbr_ssh(host: str,
+                     port: int = 22,
+                     username: str = 'pi',
+                     password: str = 'raspberry',
+                     sudo: bool = True) -> OTCI:
     cmd_handler = OtbrSshCommandRunner(host, port, username, password, sudo=sudo)
     return OTCI(cmd_handler)
 
 
-def connect_otbr_adb_tcp(host: str, port: int = 5555, adb_key: Optional[str] = None):
+def connect_otbr_adb_tcp(host: str, port: int = 5555, adb_key: Optional[str] = None) -> OTCI:
     cmd_handler = OtbrAdbTcpCommandRunner(host, port, adb_key)
     return OTCI(cmd_handler)
 
 
-def connect_otbr_adb_usb(serial: str, adb_key: Optional[str] = None):
+def connect_otbr_adb_usb(serial: str, adb_key: Optional[str] = None) -> OTCI:
     cmd_handler = OtbrAdbUsbCommandRunner(serial, adb_key)
     return OTCI(cmd_handler)
 
diff --git a/tools/otci/otci/types.py b/tools/otci/otci/types.py
index d1e9d11f5..2654dadea 100644
--- a/tools/otci/otci/types.py
+++ b/tools/otci/otci/types.py
@@ -56,7 +56,7 @@ class PartitionId(int):
 class NetifIdentifier(IntEnum):
     """Represents a network interface identifier."""
     UNSPECIFIED = 0
-    THERAD = 1
+    THREAD = 1
     BACKBONE = 2
 
 
@@ -127,6 +127,22 @@ class Ip6Prefix(ipaddress.IPv6Network):
         return super().__hash__()
 
 
+class Ip4Addr(ipaddress.IPv4Address):
+    """Represents an IPv4 address."""
+
+    def __eq__(self, other):
+        if isinstance(other, str):
+            other = ipaddress.IPv4Address(other)
+
+        return super().__eq__(other)
+
+    def __repr__(self):
+        return self.compressed
+
+    def __hash__(self):
+        return super().__hash__()
+
+
 SecurityPolicy = namedtuple('SecurityPolicy', ['rotation_time', 'flags'])
 """Represents a Security Policy configuration."""
 
diff --git a/tools/otci/otci/utils.py b/tools/otci/otci/utils.py
index b5952b58c..2d942fc49 100644
--- a/tools/otci/otci/utils.py
+++ b/tools/otci/otci/utils.py
@@ -27,10 +27,10 @@
 #  POSSIBILITY OF SUCH DAMAGE.
 #
 import functools
-from typing import Union, Collection, Any, Pattern
+from typing import Any, Callable, Collection, Generator, Pattern, Union
 
 
-def match_line(line: str, expect_line: Union[str, Pattern, Collection[Any]]) -> bool:
+def match_line(line: str, expect_line: Union[str, Pattern[Any], Collection[Any]]) -> bool:
     """Checks if a line is expected (matched by one of the given patterns)."""
     if isinstance(expect_line, Pattern):
         match = expect_line.match(line) is not None
@@ -42,12 +42,12 @@ def match_line(line: str, expect_line: Union[str, Pattern, Collection[Any]]) ->
     return match
 
 
-def cached(func):
+def cached(func: Callable[[Any], Any]):
     """Decorator cached makes the function to cache its result and return it in duplicate calls."""
-    prop_name = '__cached_' + func.__name__
+    prop_name = str('__cached_' + func.__name__)
 
     @functools.wraps(func)
-    def _cached_func(self):
+    def _cached_func(self: Any):
         try:
             return getattr(self, prop_name)
         except AttributeError:
@@ -58,6 +58,16 @@ def cached(func):
     return _cached_func
 
 
-def constant_property(func):
+def constant_property(func: Callable[[Any], Any]) -> property:
     """A constant property is a property that only evaluated once."""
     return property(cached(func))
+
+
+def bits_set(number: int) -> Generator[int, int, None]:
+    """Find all occurrences of a pattern in a string."""
+    idx = 0
+    while number != 0:
+        if number & 1:
+            yield idx
+        number >>= 1
+        idx += 1
diff --git a/tools/otci/tests/test_otci.py b/tools/otci/tests/test_otci.py
index d065867aa..19b75271a 100644
--- a/tools/otci/tests/test_otci.py
+++ b/tools/otci/tests/test_otci.py
@@ -33,6 +33,8 @@ import os
 import subprocess
 import unittest
 
+from typing import cast, Dict
+
 import otci
 from otci import OTCI
 from otci.errors import CommandError
@@ -60,9 +62,9 @@ class TestOTCI(unittest.TestCase):
             self.skipTest('not for virtual device')
 
         if os.getenv('OTBR_SSH'):
-            node = otci.connect_otbr_ssh(os.getenv('OTBR_SSH'))
+            node = otci.connect_otbr_ssh(os.getenv('OTBR_SSH', ''))
         elif os.getenv('OT_CLI_SERIAL'):
-            node = otci.connect_cli_serial(os.getenv('OT_CLI_SERIAL'))
+            node = otci.connect_cli_serial(os.getenv('OT_CLI_SERIAL', ''))
         else:
             self.fail("Please set OT_CLI_SERIAL or OTBR_SSH to test the real device.")
 
@@ -85,10 +87,10 @@ class TestOTCI(unittest.TestCase):
             sim = None
 
         if os.getenv('OT_CLI'):
-            executable = os.getenv('OT_CLI')
+            executable = os.getenv('OT_CLI', '')
             connector = otci.connect_cli_sim
         elif os.getenv('OT_NCP'):
-            executable = os.getenv('OT_NCP')
+            executable = os.getenv('OT_NCP', '')
             connector = otci.connect_ncp_sim
         else:
             self.fail("Please set OT_CLI to test virtual device")
@@ -109,7 +111,7 @@ class TestOTCI(unittest.TestCase):
 
         self._test_otci_multi_nodes(node1, node2, node3, node4)
 
-    def _test_otci_single_node(self, leader):
+    def _test_otci_single_node(self, leader: OTCI):
         logging.info('leader version: %r', leader.version)
         logging.info('leader thread version: %r', leader.thread_version)
         logging.info('API version: %r', leader.api_version)
@@ -129,6 +131,15 @@ class TestOTCI(unittest.TestCase):
         self.assertFalse(leader.get_router_eligible())
         leader.enable_router_eligible()
 
+        leader.set_mesh_local_prefix('fd00:dba::/64')
+        self.assertEqual('fd00:dba::/64', leader.get_mesh_local_prefix())
+        leader.set_mesh_local_prefix(TEST_MESH_LOCAL_PREFIX + '/64')
+        leader.set_ml_iid('b1a5ed57a71571c5')
+        leader.set_dua_iid('ad4a011dad4a011d')
+        self.assertEqual('ad4a011dad4a011d', leader.get_dua_iid())
+        leader.clear_dua_iid()
+        self.assertEqual('', leader.get_dua_iid())
+
         self.assertFalse(leader.get_ifconfig_state())
         # ifconfig up
         leader.ifconfig_up()
@@ -196,6 +207,15 @@ class TestOTCI(unittest.TestCase):
         leader.set_allowlist([leader.get_extaddr()])
         leader.disable_allowlist()
 
+        leader.enable_denylist()
+        leader.add_denylist(leader.get_extaddr())
+        leader.remove_denylist(leader.get_extaddr())
+        leader.set_denylist([leader.get_extaddr()])
+        leader.disable_denylist()
+
+        leader.enable_ccm()
+        leader.disable_ccm()
+
         self.assertEqual([], leader.backbone_router_get_multicast_listeners())
 
         leader.add_ipmaddr('ff04::1')
@@ -253,7 +273,11 @@ class TestOTCI(unittest.TestCase):
 
         logging.info("CSL config: %r", leader.get_csl_config())
         leader.config_csl(channel=13, period=16000, timeout=200)
-        logging.info("CSL config: %r", leader.get_csl_config())
+        cfg = leader.get_csl_config()
+        logging.info("CSL config: %r", cfg)
+        self.assertEqual(13, cfg['channel'])
+        self.assertEqual(16000, cfg['period'])
+        self.assertEqual(200, cfg['timeout'])
 
         logging.info("EID-to-RLOC cache: %r", leader.get_eidcache())
 
@@ -305,7 +329,7 @@ class TestOTCI(unittest.TestCase):
         leader.wait(1)
         leader.coap_stop()
 
-        for netif in (NetifIdentifier.THERAD, NetifIdentifier.UNSPECIFIED, NetifIdentifier.BACKBONE):
+        for netif in (NetifIdentifier.THREAD, NetifIdentifier.UNSPECIFIED, NetifIdentifier.BACKBONE):
             leader.udp_open()
             leader.udp_bind("::", 1234, netif=netif)
             leader.udp_send(leader.get_ipaddr_rloc(), 1234, text='hello')
@@ -329,6 +353,16 @@ class TestOTCI(unittest.TestCase):
         logging.info('dataset active -x: %r', leader.get_dataset_bytes('active'))
         logging.info('dataset pending -x: %r', leader.get_dataset_bytes('pending'))
 
+        leader.set_vendor_name('OpenThread')
+        self.assertEqual('OpenThread', leader.get_vendor_name())
+        leader.set_vendor_model('some_model')
+        self.assertEqual('some_model', leader.get_vendor_model())
+        leader.set_vendor_sw_version('1.0.0')
+        self.assertEqual('1.0.0', leader.get_vendor_sw_version())
+
+        leader.set_minimal_delay_timer(1)
+        self.assertEqual(1, leader.get_minimal_delay_timer())
+
         # Test SRP server & client
         self._test_otci_srp(leader, leader)
 
@@ -353,7 +387,10 @@ class TestOTCI(unittest.TestCase):
                 'server': (server.get_ipaddr_rloc(), 53),
                 'response_timeout': 10000,
                 'max_tx_attempts': 4,
-                'recursion_desired': False
+                'recursion_desired': False,
+                'service_mode': 'srv_txt_opt',
+                'transport_protocol': 'udp',
+                'nat64_mode': True
             }, client.dns_get_config())
 
         self.assertTrue(client.dns_get_compression())
@@ -377,6 +414,11 @@ class TestOTCI(unittest.TestCase):
         server.srp_server_set_domain('default.service.arpa.')
         self.assertEqual('default.service.arpa.', server.srp_server_get_domain())
 
+        server.srp_server_set_sequence_number(0x55)
+        self.assertEqual(0x55, server.srp_server_get_sequence_number())
+        server.srp_server_set_addressmode('unicast')
+        self.assertEqual('unicast', server.srp_server_get_addressmode())
+
         default_leases = server.srp_server_get_lease()
         self.assertEqual(default_leases, (30, 97200, 30, 680400))
         server.srp_server_set_lease(1801, 7201, 86401, 1209601)
@@ -506,8 +548,9 @@ class TestOTCI(unittest.TestCase):
         self.assertEqual('Removed', client.srp_client_get_host()['state'])
         self.assertEqual([], server.srp_server_get_hosts())
         self.assertEqual([], server.srp_server_get_services())
+        client.srp_client_clear_host()
 
-    def _test_otci_example(self, node1, node2):
+    def _test_otci_example(self, node1: OTCI, node2: OTCI):
         node1.dataset_init_buffer()
         node1.dataset_set_buffer(network_name='test',
                                  network_key='00112233445566778899aabbccddeeff',
@@ -534,7 +577,7 @@ class TestOTCI(unittest.TestCase):
         node2.wait(10)
         assert node2.get_state() == "router"
 
-    def _test_otci_multi_nodes(self, leader, commissioner, child1, child2):
+    def _test_otci_multi_nodes(self, leader: OTCI, commissioner: OTCI, child1: OTCI, child2: OTCI):
         self.assertFalse(leader.get_ifconfig_state())
 
         # ifconfig up
@@ -589,15 +632,17 @@ class TestOTCI(unittest.TestCase):
             statistics = commissioner.ping(dst_ip, size=10, count=10, interval=2, hoplimit=3)
             self.assertEqual(statistics['transmitted_packets'], 10)
             self.assertEqual(statistics['received_packets'], 10)
-            self.assertAlmostEqual(statistics['packet_loss'], 0.0, delta=1e-9)
-            rtt = statistics['round_trip_time']
+            self.assertAlmostEqual(cast(float, statistics['packet_loss']), 0.0, delta=1e-9)
+            rtt: Dict[str, float] = cast(Dict[str, float], statistics['round_trip_time'])
             self.assertTrue(rtt['min'] - 1e-9 <= rtt['avg'] <= rtt['max'] + 1e-9)
             commissioner.wait(1)
 
-        self.assertEqual('disabled', commissioner.get_commissioiner_state())
+        self.assertEqual('disabled', commissioner.get_commissioner_state())
         commissioner.commissioner_start()
         commissioner.wait(5)
-        self.assertEqual('active', commissioner.get_commissioiner_state())
+        self.assertEqual('active', commissioner.get_commissioner_state())
+
+        logging.info('commissioner.commissioner_get_session_id() = %d', commissioner.get_commissioner_session_id())
 
         logging.info('commissioner.get_network_id_timeout() = %d', commissioner.get_network_id_timeout())
         commissioner.set_network_id_timeout(60)
@@ -706,10 +751,30 @@ class TestOTCI(unittest.TestCase):
         statistics = commissioner.ping("ff02::1", size=1, count=10, interval=1, hoplimit=255)
         self.assertEqual(statistics['transmitted_packets'], 10)
         self.assertEqual(statistics['received_packets'], 20)
-        rtt = statistics['round_trip_time']
+        rtt: Dict[str, float] = cast(Dict[str, float], statistics['round_trip_time'])
         self.assertTrue(rtt['min'] - 1e-9 <= rtt['avg'] <= rtt['max'] + 1e-9)
 
+        ed_report = commissioner.commissioner_energy_scan(3 << commissioner.get_channel(), 4, 32, 1000,
+                                                          child1.get_ipaddr_rloc())
+        comm_chan = commissioner.get_channel()
+        self.assertEqual({comm_chan: [-30, -30, -30, -30], comm_chan + 1: [-30, -30, -30, -30]}, ed_report)
+
+        commissioner.commissioner_announce(TEST_CHANNEL_MASK, 1, 32, child1.get_ipaddr_rloc())
+
+        conflicts = commissioner.commissioner_panid_query(TEST_PANID, TEST_CHANNEL_MASK, child1.get_ipaddr_rloc())
+        self.assertEqual([22], conflicts)
+
+        parent = child1.get_parent()
+        self.assertEqual(parent['extaddr'], commissioner.get_extaddr())
+        self.assertEqual(parent['rloc16'], commissioner.get_rloc16())
+
+        diags = commissioner.get_network_diagnostics(child1.get_ipaddr_rloc(), [0, 1])
+        self.assertEqual({'Ext Address': f'{child1.get_extaddr()}', 'Rloc16': str(child1.get_rloc16())}, diags)
+        diags = commissioner.get_network_diagnostics_bytes(child2.get_ipaddr_rloc(), [0, 1])
+        self.assertEqual('0008' + child2.get_extaddr() + '0102' + f'{child2.get_rloc16():04x}', diags)
+
         # Shutdown
+        commissioner.commissioner_stop()
         leader.thread_stop()
         logging.info("node state: %s", leader.get_state())
         leader.ifconfig_down()
@@ -718,7 +783,7 @@ class TestOTCI(unittest.TestCase):
         leader.close()
 
 
-def _setup_default_network(node):
+def _setup_default_network(node: OTCI):
     node.dataset_clear_buffer()
     node.dataset_set_buffer(
         active_timestamp=1,
diff --git a/tools/tcat_ble_client/cli/base_commands.py b/tools/tcat_ble_client/cli/base_commands.py
index 0286dc522..2305365d5 100644
--- a/tools/tcat_ble_client/cli/base_commands.py
+++ b/tools/tcat_ble_client/cli/base_commands.py
@@ -33,6 +33,7 @@ from ble.ble_stream import BleStream
 from ble.ble_stream_secure import BleStreamSecure
 from ble import ble_scanner
 from tlv.tlv import TLV
+from tlv.diagnostic_tlv import DiagnosticTLVType
 from tlv.tcat_tlv import TcatTLVType
 from cli.command import Command, CommandResultNone, CommandResultTLV
 from dataset.dataset import ThreadDataset
@@ -386,6 +387,31 @@ class ScanCommand(Command):
         return CommandResultNone()
 
 
+class DiagnosticTlvsCommand(BleCommand):
+
+    def get_log_string(self) -> str:
+        return 'Retrieving diagnostic information.'
+
+    def get_help_string(self) -> str:
+        return 'Get diagnostic TLVs from the TCAT device.'
+
+    def prepare_data(self, args, context):
+        num_args = DiagnosticTLVType.names_to_numbers(args)
+        try:
+            if not num_args:
+                raise ValueError()
+            vals = [int(x) for x in num_args]
+            tlvs = bytes(vals)
+        except ValueError:
+            print('Please provide a list of diagnostic TLV types as names or numbers')
+            print('TLV Types:')
+            for key, value in DiagnosticTLVType.get_dict().items():
+                print(f'{key} = {value},')
+            raise DataNotPrepared()
+
+        return TLV(TcatTLVType.GET_DIAGNOSTIC_TLVS.value, tlvs).to_bytes()
+
+
 class ThreadStartCommand(BleCommand):
 
     def get_log_string(self) -> str:
diff --git a/tools/tcat_ble_client/cli/cli.py b/tools/tcat_ble_client/cli/cli.py
index 7137890cf..9d73411a5 100644
--- a/tools/tcat_ble_client/cli/cli.py
+++ b/tools/tcat_ble_client/cli/cli.py
@@ -32,7 +32,8 @@ from ble.ble_stream_secure import BleStreamSecure
 from cli.base_commands import (DisconnectCommand, HelpCommand, HelloCommand, CommissionCommand, DecommissionCommand,
                                ExtractDatasetCommand, GetCommissionerCertificate, GetDeviceIdCommand, GetPskdHash,
                                GetExtPanIDCommand, GetNetworkNameCommand, GetProvisioningUrlCommand, PingCommand,
-                               GetRandomNumberChallenge, ThreadStateCommand, ScanCommand, PresentHash)
+                               GetRandomNumberChallenge, ThreadStateCommand, ScanCommand, PresentHash,
+                               DiagnosticTlvsCommand)
 from .tlv_commands import TlvCommand
 from cli.dataset_commands import (DatasetCommand)
 from dataset.dataset import ThreadDataset
@@ -65,6 +66,7 @@ class CLI:
             'peer_pskd_hash': GetPskdHash(),
             'tlv': TlvCommand(),
             'get_comm_cert': GetCommissionerCertificate(),
+            'diagnostic_tlvs': DiagnosticTlvsCommand()
         }
         self._context = {
             'ble_sstream': ble_sstream,
diff --git a/tools/tcat_ble_client/tlv/diagnostic_tlv.py b/tools/tcat_ble_client/tlv/diagnostic_tlv.py
new file mode 100644
index 000000000..0b8ea89be
--- /dev/null
+++ b/tools/tcat_ble_client/tlv/diagnostic_tlv.py
@@ -0,0 +1,71 @@
+"""
+  Copyright (c) 2025, The OpenThread Authors.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+  1. Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+  3. Neither the name of the copyright holder nor the
+     names of its contributors may be used to endorse or promote products
+     derived from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE.
+"""
+
+
+class DiagnosticTLVType:
+
+    def __init__(self):
+        self._tlv_dict = {
+            'extaddr': '0',
+            'macaddr': '1',
+            'mode': '2',
+            'timeout': '3',
+            'connectivity': '4',
+            'route64': '5',
+            'leaderdata': '6',
+            'networkdata': '7',
+            'ipaddr': '8',
+            'maccounters': '9',
+            'batterylevel': '14',
+            'supplyvoltage': '15',
+            'childtable': '16',
+            'channelpages': '17',
+            'maxchildtimeout': '19',
+            'eui64': '23',
+            'version': '24',
+            'vendorname': '25',
+            'vendormodel': '26',
+            'vendorswversion': '27',
+            'threadstackversion': '28',
+            'child': '29',
+            'childipv6list': '30',
+            'routerneighbor': '31',
+            'mlecounters': '34',
+            'vendorappurl': '35',
+            'channeldenylist': '36'
+        }
+
+    @staticmethod
+    def names_to_numbers(args):
+        res = DiagnosticTLVType()
+        return [x if x not in res._tlv_dict else res._tlv_dict[x] for x in args]
+
+    @staticmethod
+    def get_dict():
+        res = DiagnosticTLVType()
+        return res._tlv_dict
diff --git a/tools/tcat_ble_client/tlv/tcat_tlv.py b/tools/tcat_ble_client/tlv/tcat_tlv.py
index 8a001d51e..e78e23c96 100644
--- a/tools/tcat_ble_client/tlv/tcat_tlv.py
+++ b/tools/tcat_ble_client/tlv/tcat_tlv.py
@@ -45,6 +45,7 @@ class TcatTLVType(Enum):
     ACTIVE_DATASET = 0x20
     GET_COMMISSIONER_CERTIFICATE = 0x25
     GET_ACTIVE_DATASET = 0x40
+    GET_DIAGNOSTIC_TLVS = 0x26
     DECOMMISSION = 0x60
     APPLICATION = 0x82
     THREAD_START = 0x27
```

