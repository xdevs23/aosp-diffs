```diff
diff --git a/.bazelrc b/.bazelrc
new file mode 100644
index 0000000..8141639
--- /dev/null
+++ b/.bazelrc
@@ -0,0 +1,16 @@
+# Copyright 2022 The RE2 Authors.  All Rights Reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+
+# Abseil requires C++14 at minimum.
+# Previously, the flag was set via `BAZEL_CXXOPTS`. On macOS, we also had to set
+# `BAZEL_USE_CPP_ONLY_TOOLCHAIN` since Bazel wouldn't respect the former without
+# the latter. However, the latter stopped Bazel from using Xcode and `-framework
+# Foundation`, which CCTZ (vendored into Abseil) requires.
+build --enable_platform_specific_config
+build:linux --cxxopt=-std=c++14
+build:macos --cxxopt=-std=c++14
+build:windows --cxxopt=/std:c++14
+
+# Print test logs for failed tests.
+test --test_output=errors
diff --git a/kokoro/bazel.sh b/.github/bazel.sh
similarity index 57%
rename from kokoro/bazel.sh
rename to .github/bazel.sh
index 6f25982..7295ec6 100755
--- a/kokoro/bazel.sh
+++ b/.github/bazel.sh
@@ -1,11 +1,9 @@
 #!/bin/bash
 set -eux
 
-cd git/re2
-
 bazel clean
-bazel build --compilation_mode=dbg -- //...
-bazel test  --compilation_mode=dbg --test_output=errors -- //... \
+bazel build --compilation_mode=dbg -- //:all
+bazel test  --compilation_mode=dbg -- //:all \
   -//:dfa_test \
   -//:exhaustive1_test \
   -//:exhaustive2_test \
@@ -14,8 +12,8 @@ bazel test  --compilation_mode=dbg --test_output=errors -- //... \
   -//:random_test
 
 bazel clean
-bazel build --compilation_mode=opt -- //...
-bazel test  --compilation_mode=opt --test_output=errors -- //... \
+bazel build --compilation_mode=opt -- //:all
+bazel test  --compilation_mode=opt -- //:all \
   -//:dfa_test \
   -//:exhaustive1_test \
   -//:exhaustive2_test \
diff --git a/.github/cmake.sh b/.github/cmake.sh
new file mode 100755
index 0000000..782334e
--- /dev/null
+++ b/.github/cmake.sh
@@ -0,0 +1,12 @@
+#!/bin/bash
+set -eux
+
+cmake . -D CMAKE_BUILD_TYPE=Debug -D RE2_BUILD_TESTING=ON "$@"
+cmake --build . --config Debug --clean-first
+ctest -C Debug --output-on-failure -E 'dfa|exhaustive|random'
+
+cmake . -D CMAKE_BUILD_TYPE=Release -D RE2_BUILD_TESTING=ON "$@"
+cmake --build . --config Release --clean-first
+ctest -C Release --output-on-failure -E 'dfa|exhaustive|random'
+
+exit 0
diff --git a/.github/workflows/ci-bazel.yml b/.github/workflows/ci-bazel.yml
new file mode 100644
index 0000000..1508533
--- /dev/null
+++ b/.github/workflows/ci-bazel.yml
@@ -0,0 +1,17 @@
+name: CI (Bazel)
+on:
+  push:
+    branches: [main]
+jobs:
+  build:
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [macos-latest, ubuntu-latest, windows-latest]
+    env:
+      BAZELISK_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+    steps:
+      - uses: actions/checkout@v3
+      - run: .github/bazel.sh
+        shell: bash
diff --git a/.github/workflows/ci-cmake.yml b/.github/workflows/ci-cmake.yml
new file mode 100644
index 0000000..cd73561
--- /dev/null
+++ b/.github/workflows/ci-cmake.yml
@@ -0,0 +1,56 @@
+name: CI (CMake)
+on:
+  push:
+    branches: [main]
+jobs:
+  # GitHub Actions doesn't provide GCC 13, so we use a Docker container instead.
+  # (Also, the Benchmark package on Ubuntu 22.04 LTS is problematic whereas this
+  # Docker container is based on Debian bookworm and so it has a newer version.)
+  build-linux:
+    runs-on: ubuntu-latest
+    container: gcc:13
+    strategy:
+      fail-fast: false
+    steps:
+      - uses: actions/checkout@v3
+      - name: Install CMake
+        run: |
+          apt update -y
+          apt install -y cmake
+        shell: bash
+      - name: Install Abseil, GoogleTest and Benchmark
+        run: |
+          apt update -y
+          apt install -y libabsl-dev libgtest-dev libbenchmark-dev
+        shell: bash
+      - run: .github/cmake.sh
+        shell: bash
+  build-macos:
+    runs-on: macos-latest
+    strategy:
+      fail-fast: false
+    steps:
+      - uses: actions/checkout@v3
+      - name: Install Abseil, GoogleTest and Benchmark
+        run: |
+          brew update
+          brew install abseil googletest google-benchmark
+        shell: bash
+      - run: .github/cmake.sh -D RE2_BUILD_FRAMEWORK=ON
+        shell: bash
+  build-windows:
+    runs-on: windows-latest
+    strategy:
+      fail-fast: false
+    steps:
+      - uses: actions/checkout@v3
+      - name: Install Abseil, GoogleTest and Benchmark
+        run: |
+          # TODO: Remove this in September 2023, which is when the default triplet for
+          # vcpkg libraries will change from x86-windows to the detected host triplet.
+          export VCPKG_DEFAULT_TRIPLET=x64-windows
+          vcpkg update
+          vcpkg install abseil gtest benchmark
+        shell: bash
+      - run: .github/cmake.sh -D CMAKE_TOOLCHAIN_FILE=C:/vcpkg/scripts/buildsystems/vcpkg.cmake
+        shell: bash
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
new file mode 100644
index 0000000..4067c61
--- /dev/null
+++ b/.github/workflows/ci.yml
@@ -0,0 +1,89 @@
+name: CI
+on:
+  push:
+    branches: [main]
+jobs:
+  build-appleclang:
+    runs-on: macos-latest
+    strategy:
+      fail-fast: false
+      matrix:
+        ver: [17, 20]
+    env:
+      CC: clang
+      CXX: clang++
+      # Unlike GCC and upstream Clang, AppleClang still defaults to `-std=c++98`
+      # for some reason. Also, the macOS image on GitHub Actions provides wildly
+      # numbered Xcode versions. Thus, rather than varying the compiler version,
+      # we set the `-std` flag explicitly in order to vary the language version.
+      # (The other two flags are the default provided for CXXFLAGS in Makefile.)
+      CXXFLAGS: -O3 -g -std=c++${{ matrix.ver }}
+    steps:
+      - uses: actions/checkout@v3
+      - name: Install Abseil, GoogleTest and Benchmark
+        run: |
+          brew update
+          brew install abseil googletest google-benchmark
+        shell: bash
+      - run: make && make test
+        shell: bash
+  build-clang:
+    runs-on: ubuntu-latest
+    strategy:
+      fail-fast: false
+      matrix:
+        ver: [14, 15, 16]
+    env:
+      CC: clang-${{ matrix.ver }}
+      CXX: clang++-${{ matrix.ver }}
+    steps:
+      - uses: actions/checkout@v3
+      - name: Install Clang ${{ matrix.ver }}
+        run: |
+          wget https://apt.llvm.org/llvm.sh
+          chmod +x ./llvm.sh
+          sudo ./llvm.sh ${{ matrix.ver }}
+        shell: bash
+      - name: Install Abseil, GoogleTest and Benchmark
+        run: |
+          sudo apt update -y
+          sudo apt install -y libabsl-dev libgtest-dev libbenchmark-dev
+        shell: bash
+      - run: make && make test
+        shell: bash
+  build-gcc:
+    runs-on: ubuntu-latest
+    strategy:
+      fail-fast: false
+      matrix:
+        ver: [11, 12]
+    env:
+      CC: gcc-${{ matrix.ver }}
+      CXX: g++-${{ matrix.ver }}
+    steps:
+      - uses: actions/checkout@v3
+      - name: Install Abseil, GoogleTest and Benchmark
+        run: |
+          sudo apt update -y
+          sudo apt install -y libabsl-dev libgtest-dev libbenchmark-dev
+        shell: bash
+      - run: make && make test
+        shell: bash
+  # GitHub Actions doesn't provide GCC 13, so we use a Docker container instead.
+  build-gcc-13:
+    runs-on: ubuntu-latest
+    container: gcc:13
+    strategy:
+      fail-fast: false
+    env:
+      CC: gcc
+      CXX: g++
+    steps:
+      - uses: actions/checkout@v3
+      - name: Install Abseil, GoogleTest and Benchmark
+        run: |
+          apt update -y
+          apt install -y libabsl-dev libgtest-dev libbenchmark-dev
+        shell: bash
+      - run: make && make test
+        shell: bash
diff --git a/.github/workflows/pr.yml b/.github/workflows/pr.yml
new file mode 100644
index 0000000..860da62
--- /dev/null
+++ b/.github/workflows/pr.yml
@@ -0,0 +1,26 @@
+name: PR
+on:
+  pull_request_target:
+    branches: [main]
+    types: [opened]
+jobs:
+  close:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/github-script@v6
+        with:
+          script: |
+            const fs = require('fs');
+            console.log(await github.rest.issues.createComment({
+              owner: context.repo.owner,
+              repo: context.repo.repo,
+              issue_number: context.issue.number,
+              body: fs.readFileSync('CONTRIBUTING.md', { encoding: 'utf8', }),
+            }));
+            console.log(await github.rest.pulls.update({
+              owner: context.repo.owner,
+              repo: context.repo.repo,
+              pull_number: context.issue.number,
+              state: 'closed',
+            }));
diff --git a/.github/workflows/python.yml b/.github/workflows/python.yml
new file mode 100644
index 0000000..808832f
--- /dev/null
+++ b/.github/workflows/python.yml
@@ -0,0 +1,185 @@
+name: Python
+on:
+  workflow_dispatch:
+    inputs:
+      build:
+        required: true
+        type: number
+jobs:
+  bdist_wheel-linux:
+    name: Linux ${{ matrix.os }}, ${{ matrix.arch.name }}, Python ${{ matrix.ver }}
+    runs-on: ${{ matrix.arch.runs-on }}
+    container:
+      image: quay.io/pypa/${{ matrix.os }}_${{ matrix.arch.python-name }}
+      options: --init
+    strategy:
+      fail-fast: false
+      matrix:
+        arch:
+          - { name: X64,   python-name: x86_64,  runs-on: [ubuntu-latest]             }
+          - { name: ARM64, python-name: aarch64, runs-on: [self-hosted, linux, arm64] }
+        os: [manylinux2014, manylinux_2_28]
+        ver: ['3.7', '3.8', '3.9', '3.10', '3.11']
+    env:
+      BAZELISK_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+    steps:
+      - uses: actions/checkout@v3
+      # TODO(junyer): Use `v2` whenever a new release is tagged.
+      - uses: bazelbuild/setup-bazelisk@6244971d4f7ba9aca943c2f3ede2bbd813fcca51
+      - name: Prepare Python ${{ matrix.ver }} environment
+        run: |
+          ln -sf /usr/local/bin/python${{ matrix.ver }} /usr/local/bin/python
+          ln -sf /usr/local/bin/python${{ matrix.ver }} /usr/local/bin/python3
+          python -m pip install --upgrade pip
+          python -m pip install --upgrade wheel auditwheel
+          python -m pip install --upgrade absl-py
+        shell: bash
+      - name: Build wheel
+        run: |
+          python setup.py bdist_wheel
+          python -m auditwheel repair --wheel-dir=. dist/*
+        shell: bash
+        working-directory: python
+      - name: Test wheel
+        run: |
+          python -m pip install google_re2-*.whl
+          python re2_test.py
+        shell: bash
+        working-directory: python
+      - uses: actions/upload-artifact@v3
+        with:
+          name: ${{ hashFiles('python/google_re2-*.whl') }}
+          path: python/google_re2-*.whl
+          retention-days: 1
+  bdist_wheel-macos:
+    name: macOS ${{ matrix.os }}, ${{ matrix.arch.name }}, Python ${{ matrix.ver }}
+    runs-on: macos-${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        arch:
+          - { name: X64,   bazel-name: x86_64, python-name: x86_64 }
+          - { name: ARM64, bazel-name: arm64,  python-name: arm64  }
+        os: [11, 12]
+        ver: ['3.7', '3.8', '3.9', '3.10', '3.11']
+    env:
+      BAZELISK_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+      BAZEL_CPU: darwin_${{ matrix.arch.bazel-name }}
+      # Stop macOS from reporting the system version as 10.x.
+      # Otherwise, Python refuses to install the built wheel!
+      SYSTEM_VERSION_COMPAT: 0
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-python@v4
+        with:
+          python-version: ${{ matrix.ver }}
+      - name: Prepare Python ${{ matrix.ver }} environment
+        run: |
+          python -m pip install --upgrade pip
+          python -m pip install --upgrade wheel delocate
+          python -m pip install --upgrade absl-py
+        shell: bash
+      - name: Build wheel
+        run: |
+          python setup.py bdist_wheel \
+            --plat-name=macosx-${{ matrix.os }}.0-${{ matrix.arch.python-name }}
+          python -m delocate.cmd.delocate_wheel --wheel-dir=. dist/*
+        shell: bash
+        working-directory: python
+      - if: matrix.arch.name == runner.arch
+        name: Test wheel
+        run: |
+          python -m pip install google_re2-*.whl
+          python re2_test.py
+        shell: bash
+        working-directory: python
+      - uses: actions/upload-artifact@v3
+        with:
+          name: ${{ hashFiles('python/google_re2-*.whl') }}
+          path: python/google_re2-*.whl
+          retention-days: 1
+  bdist_wheel-windows:
+    name: Windows, ${{ matrix.arch.name }}, Python ${{ matrix.ver }}
+    runs-on: windows-latest
+    strategy:
+      fail-fast: false
+      matrix:
+        arch:
+          - { name: X64,   bazel-name: x64,   python-name: amd64 }
+          # FIXME: Compiling succeeds, but linking fails with an error like
+          # "LINK : fatal error LNK1104: cannot open file 'python311.lib'".
+          # Maybe we will need GitHub-hosted runners for Windows on ARM64?!
+          # - { name: ARM64, bazel-name: arm64, python-name: arm64 }
+        ver: ['3.7', '3.8', '3.9', '3.10', '3.11']
+    env:
+      BAZELISK_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+      BAZEL_CPU: ${{ matrix.arch.bazel-name }}_windows
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-python@v4
+        with:
+          python-version: ${{ matrix.ver }}
+      - name: Prepare Python ${{ matrix.ver }} environment
+        run: |
+          python -m pip install --upgrade pip
+          python -m pip install --upgrade wheel
+          python -m pip install --upgrade absl-py
+        shell: bash
+      - name: Build wheel
+        run: |
+          python setup.py bdist_wheel \
+            --plat-name=win_${{ matrix.arch.python-name }}
+          cp dist/* .
+        shell: bash
+        working-directory: python
+      - if: matrix.arch.name == runner.arch
+        name: Test wheel
+        run: |
+          python -m pip install google_re2-*.whl
+          python re2_test.py
+        shell: bash
+        working-directory: python
+      - uses: actions/upload-artifact@v3
+        with:
+          name: ${{ hashFiles('python/google_re2-*.whl') }}
+          path: python/google_re2-*.whl
+          retention-days: 1
+  publish:
+    needs:
+      - bdist_wheel-linux
+      - bdist_wheel-macos
+      - bdist_wheel-windows
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-python@v4
+        with:
+          python-version: '3.x'
+      - name: Prepare Python 3.x environment
+        run: |
+          python -m pip install --upgrade pip
+          python -m pip install --upgrade wheel
+        shell: bash
+      - if: inputs.build == 1
+        name: Build source
+        run: |
+          python setup.py sdist
+        shell: bash
+        working-directory: python
+      - uses: actions/download-artifact@v3
+        with:
+          path: python
+      - name: Set build number to ${{ inputs.build }}
+        run: |
+          mkdir -p dist
+          for WHL in */google_re2-*.whl; do
+            python -m wheel unpack ${WHL}
+            python -m wheel pack --dest-dir=dist --build-number=${{ inputs.build }} google_re2-*
+            rm -rf google_re2-*
+          done
+        shell: bash
+        working-directory: python
+      - uses: pypa/gh-action-pypi-publish@release/v1
+        with:
+          password: ${{ secrets.PYPI_API_TOKEN }}
+          packages_dir: python/dist
diff --git a/.travis.yml b/.travis.yml
deleted file mode 100644
index 0ddc4a9..0000000
--- a/.travis.yml
+++ /dev/null
@@ -1,170 +0,0 @@
-language: cpp
-sudo: false
-dist: trusty
-script:
-  - make
-  - make test
-matrix:
-  include:
-
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-          packages:
-            - g++-4.8
-      env:
-         - MATRIX_EVAL="CC=gcc-4.8 CXX=g++-4.8"
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-          packages:
-            - g++-4.9
-      env:
-         - MATRIX_EVAL="CC=gcc-4.9 CXX=g++-4.9"
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-          packages:
-            - g++-5
-      env:
-         - MATRIX_EVAL="CC=gcc-5 CXX=g++-5"
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-          packages:
-            - g++-6
-      env:
-        - MATRIX_EVAL="CC=gcc-6 CXX=g++-6"
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-          packages:
-            - g++-7
-      env:
-        - MATRIX_EVAL="CC=gcc-7 CXX=g++-7"
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-          packages:
-            - g++-8
-      env:
-        - MATRIX_EVAL="CC=gcc-8 CXX=g++-8"
-
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-            - llvm-toolchain-precise-3.5
-          packages:
-            - clang-3.5
-      env:
-        - MATRIX_EVAL="CC=clang-3.5 CXX=clang++-3.5"
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-            - llvm-toolchain-precise-3.6
-          packages:
-            - clang-3.6
-      env:
-        - MATRIX_EVAL="CC=clang-3.6 CXX=clang++-3.6"
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-            - llvm-toolchain-precise-3.7
-          packages:
-            - clang-3.7
-      env:
-        - MATRIX_EVAL="CC=clang-3.7 CXX=clang++-3.7"
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-            - llvm-toolchain-precise-3.8
-          packages:
-            - clang-3.8
-      env:
-        - MATRIX_EVAL="CC=clang-3.8 CXX=clang++-3.8"
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-            - llvm-toolchain-precise-3.9
-          packages:
-            - clang-3.9
-      env:
-        - MATRIX_EVAL="CC=clang-3.9 CXX=clang++-3.9"
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-            - llvm-toolchain-trusty-4.0
-          packages:
-            - clang-4.0
-      env:
-        - MATRIX_EVAL="CC=clang-4.0 CXX=clang++-4.0"
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-            - llvm-toolchain-trusty-5.0
-          packages:
-            - clang-5.0
-      env:
-        - MATRIX_EVAL="CC=clang-5.0 CXX=clang++-5.0"
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-            - sourceline: 'deb https://apt.llvm.org/trusty/ llvm-toolchain-trusty-6.0 main'
-              key_url: 'https://apt.llvm.org/llvm-snapshot.gpg.key'
-          packages:
-            - clang-6.0
-      env:
-        - MATRIX_EVAL="CC=clang-6.0 CXX=clang++-6.0"
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-            - sourceline: 'deb https://apt.llvm.org/trusty/ llvm-toolchain-trusty-7 main'
-              key_url: 'https://apt.llvm.org/llvm-snapshot.gpg.key'
-          packages:
-            - clang-7
-      env:
-        - MATRIX_EVAL="CC=clang-7 CXX=clang++-7"
-    - os: linux
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-            - sourceline: 'deb https://apt.llvm.org/trusty/ llvm-toolchain-trusty-8 main'
-              key_url: 'https://apt.llvm.org/llvm-snapshot.gpg.key'
-          packages:
-            - clang-8
-      env:
-        - MATRIX_EVAL="CC=clang-8 CXX=clang++-8"
-
-before_install:
-  - eval "${MATRIX_EVAL}"
diff --git a/Android.bp b/Android.bp
index c782321..746d488 100644
--- a/Android.bp
+++ b/Android.bp
@@ -22,6 +22,7 @@ cc_library_static {
     srcs: [
         "util/rune.cc",
         "util/strutil.cc",
+        "re2/bitmap256.cc",
         "re2/bitstate.cc",
         "re2/compile.cc",
         "re2/dfa.cc",
@@ -38,7 +39,6 @@ cc_library_static {
         "re2/regexp.cc",
         "re2/set.cc",
         "re2/simplify.cc",
-        "re2/stringpiece.cc",
         "re2/tostring.cc",
         "re2/unicode_casefold.cc",
         "re2/unicode_groups.cc",
@@ -48,6 +48,12 @@ cc_library_static {
         "-Wno-missing-field-initializers",
     ],
     export_include_dirs: ["."],
+    static_libs: [
+        "absl_strings",
+        "absl_container_flat_hash_map",
+        "absl_container_flat_hash_set",
+        "absl_synchronization",
+    ],
     visibility: [
         "//external/grpc-grpc:__subpackages__",
         "//external/kythe:__subpackages__",
@@ -55,11 +61,7 @@ cc_library_static {
     min_sdk_version: "apex_inherit",
 }
 
-// This test uses a minimal fork of GTest that is incompatible with Android
-// testing infrastructure, so it is currently a cc_binary rather than a cc_test.
-// It can be run directly and should produce a pass/fail result:
-// out/host/linux-x86/bin/regex_re2_test
-cc_binary_host {
+cc_test_host {
     name: "regex_re2_test",
     srcs: [
         "re2/testing/backtrack.cc",
@@ -83,13 +85,16 @@ cc_binary_host {
         "re2/testing/string_generator_test.cc",
         "re2/testing/tester.cc",
         "util/pcre.cc",
-        "util/test.cc",
     ],
     cflags: [
         "-Wno-unused-parameter",
         "-Wno-missing-field-initializers",
     ],
     static_libs: [
+        "absl_flags_flag",
+        "absl_strings",
+        "absl_strings_str_format",
+        "absl_types_optional",
         "libregex_re2",
     ],
 }
diff --git a/BUILD b/BUILD
deleted file mode 100644
index 30ce320..0000000
--- a/BUILD
+++ /dev/null
@@ -1,239 +0,0 @@
-# Copyright 2009 The RE2 Authors.  All Rights Reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-# Bazel (http://bazel.io/) BUILD file for RE2.
-
-licenses(["notice"])
-
-exports_files(["LICENSE"])
-
-config_setting(
-    name = "darwin",
-    values = {"cpu": "darwin"},
-)
-
-config_setting(
-    name = "windows",
-    values = {"cpu": "x64_windows"},
-)
-
-config_setting(
-    name = "windows_msvc",
-    values = {"cpu": "x64_windows_msvc"},
-)
-
-cc_library(
-    name = "re2",
-    srcs = [
-        "re2/bitmap256.h",
-        "re2/bitstate.cc",
-        "re2/compile.cc",
-        "re2/dfa.cc",
-        "re2/filtered_re2.cc",
-        "re2/mimics_pcre.cc",
-        "re2/nfa.cc",
-        "re2/onepass.cc",
-        "re2/parse.cc",
-        "re2/perl_groups.cc",
-        "re2/prefilter.cc",
-        "re2/prefilter.h",
-        "re2/prefilter_tree.cc",
-        "re2/prefilter_tree.h",
-        "re2/prog.cc",
-        "re2/prog.h",
-        "re2/re2.cc",
-        "re2/regexp.cc",
-        "re2/regexp.h",
-        "re2/set.cc",
-        "re2/simplify.cc",
-        "re2/stringpiece.cc",
-        "re2/tostring.cc",
-        "re2/unicode_casefold.cc",
-        "re2/unicode_casefold.h",
-        "re2/unicode_groups.cc",
-        "re2/unicode_groups.h",
-        "re2/walker-inl.h",
-        "util/flags.h",
-        "util/logging.h",
-        "util/mix.h",
-        "util/mutex.h",
-        "util/pod_array.h",
-        "util/rune.cc",
-        "util/sparse_array.h",
-        "util/sparse_set.h",
-        "util/strutil.cc",
-        "util/strutil.h",
-        "util/utf.h",
-        "util/util.h",
-    ],
-    hdrs = [
-        "re2/filtered_re2.h",
-        "re2/re2.h",
-        "re2/set.h",
-        "re2/stringpiece.h",
-    ],
-    copts = select({
-        ":windows": [],
-        ":windows_msvc": [],
-        "//conditions:default": ["-pthread"],
-    }),
-    linkopts = select({
-        # Darwin doesn't need `-pthread' when linking and it appears that
-        # older versions of Clang will warn about the unused command line
-        # argument, so just don't pass it.
-        ":darwin": [],
-        ":windows": [],
-        ":windows_msvc": [],
-        "//conditions:default": ["-pthread"],
-    }),
-    visibility = ["//visibility:public"],
-)
-
-cc_library(
-    name = "testing",
-    testonly = 1,
-    srcs = [
-        "re2/testing/backtrack.cc",
-        "re2/testing/dump.cc",
-        "re2/testing/exhaustive_tester.cc",
-        "re2/testing/null_walker.cc",
-        "re2/testing/regexp_generator.cc",
-        "re2/testing/string_generator.cc",
-        "re2/testing/tester.cc",
-        "util/pcre.cc",
-    ],
-    hdrs = [
-        "re2/testing/exhaustive_tester.h",
-        "re2/testing/regexp_generator.h",
-        "re2/testing/string_generator.h",
-        "re2/testing/tester.h",
-        "util/benchmark.h",
-        "util/pcre.h",
-        "util/test.h",
-    ],
-    deps = [":re2"],
-)
-
-cc_library(
-    name = "test",
-    testonly = 1,
-    srcs = ["util/test.cc"],
-    deps = [":testing"],
-)
-
-load(":re2_test.bzl", "re2_test")
-
-re2_test(
-    "charclass_test",
-    size = "small",
-)
-
-re2_test(
-    "compile_test",
-    size = "small",
-)
-
-re2_test(
-    "filtered_re2_test",
-    size = "small",
-)
-
-re2_test(
-    "mimics_pcre_test",
-    size = "small",
-)
-
-re2_test(
-    "parse_test",
-    size = "small",
-)
-
-re2_test(
-    "possible_match_test",
-    size = "small",
-)
-
-re2_test(
-    "re2_arg_test",
-    size = "small",
-)
-
-re2_test(
-    "re2_test",
-    size = "small",
-)
-
-re2_test(
-    "regexp_test",
-    size = "small",
-)
-
-re2_test(
-    "required_prefix_test",
-    size = "small",
-)
-
-re2_test(
-    "search_test",
-    size = "small",
-)
-
-re2_test(
-    "set_test",
-    size = "small",
-)
-
-re2_test(
-    "simplify_test",
-    size = "small",
-)
-
-re2_test(
-    "string_generator_test",
-    size = "small",
-)
-
-re2_test(
-    "dfa_test",
-    size = "large",
-)
-
-re2_test(
-    "exhaustive1_test",
-    size = "large",
-)
-
-re2_test(
-    "exhaustive2_test",
-    size = "large",
-)
-
-re2_test(
-    "exhaustive3_test",
-    size = "large",
-)
-
-re2_test(
-    "exhaustive_test",
-    size = "large",
-)
-
-re2_test(
-    "random_test",
-    size = "large",
-)
-
-cc_library(
-    name = "benchmark",
-    testonly = 1,
-    srcs = ["util/benchmark.cc"],
-    deps = [":testing"],
-)
-
-cc_binary(
-    name = "regexp_benchmark",
-    testonly = 1,
-    srcs = ["re2/testing/regexp_benchmark.cc"],
-    deps = [":benchmark"],
-)
diff --git a/BUILD.bazel b/BUILD.bazel
new file mode 100644
index 0000000..3f6dafe
--- /dev/null
+++ b/BUILD.bazel
@@ -0,0 +1,280 @@
+# Copyright 2009 The RE2 Authors.  All Rights Reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+
+# Bazel (http://bazel.io/) BUILD file for RE2.
+
+licenses(["notice"])
+
+exports_files(["LICENSE"])
+
+cc_library(
+    name = "re2",
+    srcs = [
+        "re2/bitmap256.cc",
+        "re2/bitmap256.h",
+        "re2/bitstate.cc",
+        "re2/compile.cc",
+        "re2/dfa.cc",
+        "re2/filtered_re2.cc",
+        "re2/mimics_pcre.cc",
+        "re2/nfa.cc",
+        "re2/onepass.cc",
+        "re2/parse.cc",
+        "re2/perl_groups.cc",
+        "re2/pod_array.h",
+        "re2/prefilter.cc",
+        "re2/prefilter.h",
+        "re2/prefilter_tree.cc",
+        "re2/prefilter_tree.h",
+        "re2/prog.cc",
+        "re2/prog.h",
+        "re2/re2.cc",
+        "re2/regexp.cc",
+        "re2/regexp.h",
+        "re2/set.cc",
+        "re2/simplify.cc",
+        "re2/sparse_array.h",
+        "re2/sparse_set.h",
+        "re2/tostring.cc",
+        "re2/unicode_casefold.cc",
+        "re2/unicode_casefold.h",
+        "re2/unicode_groups.cc",
+        "re2/unicode_groups.h",
+        "re2/walker-inl.h",
+        "util/logging.h",
+        "util/rune.cc",
+        "util/strutil.cc",
+        "util/strutil.h",
+        "util/utf.h",
+    ],
+    hdrs = [
+        "re2/filtered_re2.h",
+        "re2/re2.h",
+        "re2/set.h",
+        "re2/stringpiece.h",
+    ],
+    copts = select({
+        "@platforms//os:wasi": [],
+        "@platforms//os:windows": [],
+        "//conditions:default": ["-pthread"],
+    }),
+    linkopts = select({
+        # macOS doesn't need `-pthread' when linking and it appears that
+        # older versions of Clang will warn about the unused command line
+        # argument, so just don't pass it.
+        "@platforms//os:macos": [],
+        "@platforms//os:wasi": [],
+        "@platforms//os:windows": [],
+        "//conditions:default": ["-pthread"],
+    }),
+    visibility = ["//visibility:public"],
+    deps = [
+        "@com_google_absl//absl/base",
+        "@com_google_absl//absl/base:core_headers",
+        "@com_google_absl//absl/container:fixed_array",
+        "@com_google_absl//absl/container:flat_hash_map",
+        "@com_google_absl//absl/container:flat_hash_set",
+        "@com_google_absl//absl/container:inlined_vector",
+        "@com_google_absl//absl/strings",
+        "@com_google_absl//absl/strings:str_format",
+        "@com_google_absl//absl/synchronization",
+        "@com_google_absl//absl/types:optional",
+        "@com_google_absl//absl/types:span",
+    ],
+)
+
+cc_library(
+    name = "testing",
+    testonly = 1,
+    srcs = [
+        "re2/testing/backtrack.cc",
+        "re2/testing/dump.cc",
+        "re2/testing/exhaustive_tester.cc",
+        "re2/testing/null_walker.cc",
+        "re2/testing/regexp_generator.cc",
+        "re2/testing/string_generator.cc",
+        "re2/testing/tester.cc",
+        "util/pcre.cc",
+    ],
+    hdrs = [
+        "re2/testing/exhaustive_tester.h",
+        "re2/testing/regexp_generator.h",
+        "re2/testing/string_generator.h",
+        "re2/testing/tester.h",
+        "util/malloc_counter.h",
+        "util/pcre.h",
+    ],
+    deps = [
+        ":re2",
+        "@com_google_absl//absl/flags:flag",
+        "@com_google_googletest//:gtest",
+    ],
+)
+
+cc_library(
+    name = "test",
+    testonly = 1,
+    srcs = [],
+    deps = [
+        ":testing",
+        "@com_google_googletest//:gtest_main",
+    ],
+)
+
+cc_test(
+    name = "charclass_test",
+    size = "small",
+    srcs = ["re2/testing/charclass_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "compile_test",
+    size = "small",
+    srcs = ["re2/testing/compile_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "filtered_re2_test",
+    size = "small",
+    srcs = ["re2/testing/filtered_re2_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "mimics_pcre_test",
+    size = "small",
+    srcs = ["re2/testing/mimics_pcre_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "parse_test",
+    size = "small",
+    srcs = ["re2/testing/parse_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "possible_match_test",
+    size = "small",
+    srcs = ["re2/testing/possible_match_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "re2_arg_test",
+    size = "small",
+    srcs = ["re2/testing/re2_arg_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "re2_test",
+    size = "small",
+    srcs = ["re2/testing/re2_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "regexp_test",
+    size = "small",
+    srcs = ["re2/testing/regexp_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "required_prefix_test",
+    size = "small",
+    srcs = ["re2/testing/required_prefix_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "search_test",
+    size = "small",
+    srcs = ["re2/testing/search_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "set_test",
+    size = "small",
+    srcs = ["re2/testing/set_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "simplify_test",
+    size = "small",
+    srcs = ["re2/testing/simplify_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "string_generator_test",
+    size = "small",
+    srcs = ["re2/testing/string_generator_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "dfa_test",
+    size = "large",
+    srcs = ["re2/testing/dfa_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "exhaustive1_test",
+    size = "large",
+    srcs = ["re2/testing/exhaustive1_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "exhaustive2_test",
+    size = "large",
+    srcs = ["re2/testing/exhaustive2_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "exhaustive3_test",
+    size = "large",
+    srcs = ["re2/testing/exhaustive3_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "exhaustive_test",
+    size = "large",
+    srcs = ["re2/testing/exhaustive_test.cc"],
+    deps = [":test"],
+)
+
+cc_test(
+    name = "random_test",
+    size = "large",
+    srcs = ["re2/testing/random_test.cc"],
+    deps = [":test"],
+)
+
+cc_library(
+    name = "benchmark",
+    testonly = 1,
+    srcs = [],
+    deps = [
+        ":testing",
+        "@com_github_google_benchmark//:benchmark_main",
+    ],
+)
+
+cc_binary(
+    name = "regexp_benchmark",
+    testonly = 1,
+    srcs = ["re2/testing/regexp_benchmark.cc"],
+    deps = [":benchmark"],
+)
diff --git a/CMakeLists.txt b/CMakeLists.txt
index f87c4ff..5312252 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -2,33 +2,42 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
-# Old enough to support Ubuntu Trusty.
-cmake_minimum_required(VERSION 2.8.12)
-
-if(POLICY CMP0048)
-  cmake_policy(SET CMP0048 NEW)
-endif()
+# Old enough to support Ubuntu Bionic,
+# but just the MAJOR.MINOR components.
+cmake_minimum_required(VERSION 3.10)
 
 project(RE2 CXX)
+include(CMakePackageConfigHelpers)
 include(CTest)
+include(GNUInstallDirs)
 
 option(BUILD_SHARED_LIBS "build shared libraries" OFF)
-option(USEPCRE "use PCRE in tests and benchmarks" OFF)
+option(RE2_USE_ICU "build against ICU for full Unicode properties support" OFF)
+
+# For historical reasons, this is just "USEPCRE", not "RE2_USE_PCRE".
+option(USEPCRE "build against PCRE for testing and benchmarking" OFF)
+
+# See https://groups.google.com/g/re2-dev/c/P6_NM0YIWvA for details.
+# This has no effect unless RE2 is being built for an Apple platform
+# such as macOS or iOS.
+option(RE2_BUILD_FRAMEWORK "build RE2 as a framework" OFF)
 
 # CMake seems to have no way to enable/disable testing per subproject,
 # so we provide an option similar to BUILD_TESTING, but just for RE2.
-option(RE2_BUILD_TESTING "enable testing for RE2" ON)
+option(RE2_BUILD_TESTING "enable testing for RE2" OFF)
+
+# The pkg-config Requires: field.
+set(REQUIRES)
+
+# ABI version
+# http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html
+set(SONAME 11)
 
 set(EXTRA_TARGET_LINK_LIBRARIES)
 
 if(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
-  if(MSVC_VERSION LESS 1900)
-    message(FATAL_ERROR "you need Visual Studio 2015 or later")
-  endif()
-  if(BUILD_SHARED_LIBS)
-    # See http://www.kitware.com/blog/home/post/939 for details.
-    cmake_minimum_required(VERSION 3.4)
-    set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)
+  if(MSVC_VERSION LESS 1920)
+    message(FATAL_ERROR "you need Visual Studio 2019 or later")
   endif()
   # CMake defaults to /W3, but some users like /W4 (or /Wall) and /WX,
   # so we disable various warnings that aren't particularly helpful.
@@ -36,19 +45,47 @@ if(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
   # Without a byte order mark (BOM), Visual Studio assumes that the source
   # file is encoded using the current user code page, so we specify UTF-8.
   add_compile_options(/utf-8)
-elseif(CYGWIN OR MINGW)
-  # See https://stackoverflow.com/questions/38139631 for details.
-  add_compile_options(-std=gnu++11)
-elseif(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
-  add_compile_options(-std=c++11)
 endif()
 
 if(WIN32)
   add_definitions(-DUNICODE -D_UNICODE -DSTRICT -DNOMINMAX)
   add_definitions(-D_CRT_SECURE_NO_WARNINGS -D_SCL_SECURE_NO_WARNINGS)
-elseif(UNIX)
-  add_compile_options(-pthread)
-  list(APPEND EXTRA_TARGET_LINK_LIBRARIES -pthread)
+endif()
+
+if(UNIX)
+  set(THREADS_PREFER_PTHREAD_FLAG ON)
+  find_package(Threads REQUIRED)
+endif()
+
+set(ABSL_DEPS
+    absl_base
+    absl_core_headers
+    absl_fixed_array
+    absl_flags
+    absl_flat_hash_map
+    absl_flat_hash_set
+    absl_inlined_vector
+    absl_optional
+    absl_span
+    absl_str_format
+    absl_strings
+    absl_synchronization
+    )
+
+# If a top-level project has called add_directory(abseil-cpp) already (possibly
+# indirectly), let that take precedence over any copy of Abseil that might have
+# been installed on the system. And likewise for ICU, GoogleTest and Benchmark.
+if(NOT TARGET absl::base)
+  find_package(absl REQUIRED)
+endif()
+list(APPEND REQUIRES ${ABSL_DEPS})
+
+if(RE2_USE_ICU)
+  if(NOT TARGET ICU::uc)
+    find_package(ICU REQUIRED COMPONENTS uc)
+  endif()
+  add_definitions(-DRE2_USE_ICU)
+  list(APPEND REQUIRES icu-uc)
 endif()
 
 if(USEPCRE)
@@ -56,9 +93,14 @@ if(USEPCRE)
   list(APPEND EXTRA_TARGET_LINK_LIBRARIES pcre)
 endif()
 
-include_directories(${CMAKE_CURRENT_SOURCE_DIR})
+# TODO(junyer): Use string(JOIN " " ...) whenever CMake 3.12 (or newer) becomes
+# the minimum required: that will make this hack slightly less filthy. For now,
+# CMake does the same thing as string(CONCAT ...), basically, if we don't quote
+# ${REQUIRES}, so quote it despite prevailing style.
+string(REPLACE ";" " " REQUIRES "${REQUIRES}")
 
 set(RE2_SOURCES
+    re2/bitmap256.cc
     re2/bitstate.cc
     re2/compile.cc
     re2/dfa.cc
@@ -75,7 +117,6 @@ set(RE2_SOURCES
     re2/regexp.cc
     re2/set.cc
     re2/simplify.cc
-    re2/stringpiece.cc
     re2/tostring.cc
     re2/unicode_casefold.cc
     re2/unicode_groups.cc
@@ -83,9 +124,55 @@ set(RE2_SOURCES
     util/strutil.cc
     )
 
+set(RE2_HEADERS
+    re2/filtered_re2.h
+    re2/re2.h
+    re2/set.h
+    re2/stringpiece.h
+    )
+
 add_library(re2 ${RE2_SOURCES})
+target_compile_features(re2 PUBLIC cxx_std_14)
+target_include_directories(re2 PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>)
+# CMake gives "set_target_properties called with incorrect number of arguments."
+# errors if we don't quote ${RE2_HEADERS}, so quote it despite prevailing style.
+set_target_properties(re2 PROPERTIES PUBLIC_HEADER "${RE2_HEADERS}")
+set_target_properties(re2 PROPERTIES SOVERSION ${SONAME} VERSION ${SONAME}.0.0)
+add_library(re2::re2 ALIAS re2)
+
+if(CMAKE_CXX_COMPILER_ID MATCHES "MSVC" AND BUILD_SHARED_LIBS)
+  set_target_properties(re2 PROPERTIES
+                        WINDOWS_EXPORT_ALL_SYMBOLS ON)
+endif()
+
+if(APPLE AND RE2_BUILD_FRAMEWORK)
+  set_target_properties(re2 PROPERTIES
+                        FRAMEWORK TRUE
+                        FRAMEWORK_VERSION A
+                        MACOSX_FRAMEWORK_IDENTIFIER com.googlesource.code.re2)
+endif()
+
+if(UNIX)
+  target_link_libraries(re2 PUBLIC Threads::Threads)
+endif()
+
+foreach(dep ${ABSL_DEPS})
+  string(REGEX REPLACE "^absl_" "absl::" dep ${dep})
+  target_link_libraries(re2 PUBLIC ${dep})
+endforeach()
+
+if(RE2_USE_ICU)
+  target_link_libraries(re2 PUBLIC ICU::uc)
+endif()
 
 if(RE2_BUILD_TESTING)
+  if(NOT TARGET GTest::gtest)
+    find_package(GTest REQUIRED)
+  endif()
+  if(NOT TARGET benchmark::benchmark)
+    find_package(benchmark REQUIRED)
+  endif()
+
   set(TESTING_SOURCES
       re2/testing/backtrack.cc
       re2/testing/dump.cc
@@ -97,7 +184,9 @@ if(RE2_BUILD_TESTING)
       util/pcre.cc
       )
 
-  add_library(testing STATIC ${TESTING_SOURCES})
+  add_library(testing ${TESTING_SOURCES})
+  target_compile_features(testing PUBLIC cxx_std_14)
+  target_link_libraries(testing PUBLIC re2 GTest::gtest)
 
   set(TEST_TARGETS
       charclass_test
@@ -128,23 +217,45 @@ if(RE2_BUILD_TESTING)
       )
 
   foreach(target ${TEST_TARGETS})
-    add_executable(${target} re2/testing/${target}.cc util/test.cc)
-    target_link_libraries(${target} testing re2 ${EXTRA_TARGET_LINK_LIBRARIES})
+    add_executable(${target} re2/testing/${target}.cc)
+    target_compile_features(${target} PUBLIC cxx_std_14)
+    target_link_libraries(${target} PUBLIC testing GTest::gtest_main ${EXTRA_TARGET_LINK_LIBRARIES})
     add_test(NAME ${target} COMMAND ${target})
-  endforeach(target)
+  endforeach()
 
   foreach(target ${BENCHMARK_TARGETS})
-    add_executable(${target} re2/testing/${target}.cc util/benchmark.cc)
-    target_link_libraries(${target} testing re2 ${EXTRA_TARGET_LINK_LIBRARIES})
-  endforeach(target)
+    add_executable(${target} re2/testing/${target}.cc)
+    target_compile_features(${target} PUBLIC cxx_std_14)
+    target_link_libraries(${target} PUBLIC testing benchmark::benchmark_main ${EXTRA_TARGET_LINK_LIBRARIES})
+  endforeach()
 endif()
 
-set(RE2_HEADERS
-    re2/filtered_re2.h
-    re2/re2.h
-    re2/set.h
-    re2/stringpiece.h
-    )
+install(TARGETS re2
+        EXPORT re2Targets
+        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
+        FRAMEWORK DESTINATION ${CMAKE_INSTALL_LIBDIR}
+        PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/re2
+        INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
+install(EXPORT re2Targets
+        DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/re2
+        NAMESPACE re2::)
+
+configure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/re2Config.cmake.in
+                              ${CMAKE_CURRENT_BINARY_DIR}/re2Config.cmake
+                              INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/re2)
+write_basic_package_version_file(${CMAKE_CURRENT_BINARY_DIR}/re2ConfigVersion.cmake
+                                 VERSION ${SONAME}.0.0
+                                 COMPATIBILITY SameMajorVersion)
+
+install(FILES ${CMAKE_CURRENT_BINARY_DIR}/re2Config.cmake
+              ${CMAKE_CURRENT_BINARY_DIR}/re2ConfigVersion.cmake
+        DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/re2)
+
+configure_file(${CMAKE_CURRENT_SOURCE_DIR}/re2.pc.in
+               ${CMAKE_CURRENT_BINARY_DIR}/re2.pc
+               @ONLY)
 
-install(FILES ${RE2_HEADERS} DESTINATION include/re2)
-install(TARGETS re2 ARCHIVE DESTINATION lib LIBRARY DESTINATION lib RUNTIME DESTINATION bin)
+install(FILES ${CMAKE_CURRENT_BINARY_DIR}/re2.pc
+        DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 3af2b0a..882b0e2 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,2 +1,2 @@
 RE2 uses Gerrit instead of GitHub pull requests.
-See the [Contributing](https://github.com/google/re2/wiki/Contribute) wiki page.
+See the [Contribute](https://github.com/google/re2/wiki/Contribute) wiki page.
diff --git a/METADATA b/METADATA
index 94f3d16..9924ef4 100644
--- a/METADATA
+++ b/METADATA
@@ -1,15 +1,19 @@
+# This project was upgraded with external_updater.
+# Usage: tools/external_updater/updater.sh update external/regex-re2
+# For more info, check https://cs.android.com/android/platform/superproject/main/+/main:tools/external_updater/README.md
+
 name: "regex-re22"
 description: "RE2 is a fast, safe, thread-friendly alternative to backtracking regular expression engines like those used in PCRE, Perl, and Python. It is a C++ library."
 third_party {
   license_type: NOTICE
   last_upgrade_date {
-    year: 2019
-    month: 2
-    day: 20
+    year: 2025
+    month: 5
+    day: 13
   }
   identifier {
     type: "Git"
     value: "https://github.com/google/re2"
-    version: "79ef3b2d31f06493f687ef9e947d9632bad54b9b"
+    version: "2023-06-01"
   }
 }
diff --git a/Makefile b/Makefile
index f001f06..705d7fa 100644
--- a/Makefile
+++ b/Makefile
@@ -2,12 +2,32 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
+# Build against Abseil.
+ABSL_DEPS=\
+	absl_base\
+	absl_core_headers\
+	absl_fixed_array\
+	absl_flags\
+	absl_flat_hash_map\
+	absl_flat_hash_set\
+	absl_inlined_vector\
+	absl_optional\
+	absl_span\
+	absl_str_format\
+	absl_strings\
+	absl_synchronization\
+
+CCABSL=$(shell pkg-config $(ABSL_DEPS) --cflags)
+# GCC barfs on `-Wl` whereas Clang doesn't mind, but it's unclear what
+# causes it to manifest on Ubuntu 22.04 LTS, so filter it out for now.
+LDABSL=$(shell pkg-config $(ABSL_DEPS) --libs | sed -e 's/-Wl / /g')
+
 # To build against ICU for full Unicode properties support,
 # uncomment the next two lines:
 # CCICU=$(shell pkg-config icu-uc --cflags) -DRE2_USE_ICU
 # LDICU=$(shell pkg-config icu-uc --libs)
 
-# To build against PCRE for testing or benchmarking,
+# To build against PCRE for testing and benchmarking,
 # uncomment the next two lines:
 # CCPCRE=-I/usr/local/include -DUSEPCRE
 # LDPCRE=-L/usr/local/lib -lpcre
@@ -17,8 +37,8 @@ CXX?=g++
 CXXFLAGS?=-O3 -g
 LDFLAGS?=
 # required
-RE2_CXXFLAGS?=-std=c++11 -pthread -Wall -Wextra -Wno-unused-parameter -Wno-missing-field-initializers -I. $(CCICU) $(CCPCRE)
-RE2_LDFLAGS?=-pthread $(LDICU) $(LDPCRE)
+RE2_CXXFLAGS?=-pthread -Wall -Wextra -Wno-unused-parameter -Wno-missing-field-initializers -I. $(CCABSL) $(CCICU) $(CCPCRE)
+RE2_LDFLAGS?=-pthread $(LDABSL) $(LDICU) $(LDPCRE)
 AR?=ar
 ARFLAGS?=rsc
 NM?=nm
@@ -42,9 +62,15 @@ else
 SED_INPLACE=sed -i
 endif
 
+# The pkg-config Requires: field.
+REQUIRES=$(ABSL_DEPS)
+ifdef LDICU
+REQUIRES+=icu-uc
+endif
+
 # ABI version
 # http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html
-SONAME=0
+SONAME=11
 
 # To rebuild the Tables generated by Perl and Python scripts (requires Internet
 # access for Unicode data), uncomment the following line:
@@ -55,7 +81,7 @@ ifeq ($(shell uname),Darwin)
 SOEXT=dylib
 SOEXTVER=$(SONAME).$(SOEXT)
 SOEXTVER00=$(SONAME).0.0.$(SOEXT)
-MAKE_SHARED_LIBRARY=$(CXX) -dynamiclib -Wl,-install_name,$(libdir)/libre2.$(SOEXTVER),-exported_symbols_list,libre2.symbols.darwin $(RE2_LDFLAGS) $(LDFLAGS)
+MAKE_SHARED_LIBRARY=$(CXX) -dynamiclib -Wl,-compatibility_version,$(SONAME),-current_version,$(SONAME).0.0,-install_name,$(libdir)/libre2.$(SOEXTVER),-exported_symbols_list,libre2.symbols.darwin $(RE2_LDFLAGS) $(LDFLAGS)
 else ifeq ($(shell uname),SunOS)
 SOEXT=so
 SOEXTVER=$(SOEXT).$(SONAME)
@@ -68,6 +94,7 @@ SOEXTVER00=$(SOEXT).$(SONAME).0.0
 MAKE_SHARED_LIBRARY=$(CXX) -shared -Wl,-soname,libre2.$(SOEXTVER),--version-script,libre2.symbols $(RE2_LDFLAGS) $(LDFLAGS)
 endif
 
+.PHONY: all
 all: obj/libre2.a obj/so/libre2.$(SOEXT)
 
 INSTALL_HFILES=\
@@ -77,27 +104,22 @@ INSTALL_HFILES=\
 	re2/stringpiece.h\
 
 HFILES=\
-	util/benchmark.h\
-	util/flags.h\
 	util/logging.h\
-	util/mix.h\
-	util/mutex.h\
+	util/malloc_counter.h\
 	util/pcre.h\
-	util/pod_array.h\
-	util/sparse_array.h\
-	util/sparse_set.h\
 	util/strutil.h\
-	util/test.h\
 	util/utf.h\
-	util/util.h\
 	re2/bitmap256.h\
 	re2/filtered_re2.h\
+	re2/pod_array.h\
 	re2/prefilter.h\
 	re2/prefilter_tree.h\
 	re2/prog.h\
 	re2/re2.h\
 	re2/regexp.h\
 	re2/set.h\
+	re2/sparse_array.h\
+	re2/sparse_set.h\
 	re2/stringpiece.h\
 	re2/testing/exhaustive_tester.h\
 	re2/testing/regexp_generator.h\
@@ -110,6 +132,7 @@ HFILES=\
 OFILES=\
 	obj/util/rune.o\
 	obj/util/strutil.o\
+	obj/re2/bitmap256.o\
 	obj/re2/bitstate.o\
 	obj/re2/compile.o\
 	obj/re2/dfa.o\
@@ -126,7 +149,6 @@ OFILES=\
 	obj/re2/regexp.o\
 	obj/re2/set.o\
 	obj/re2/simplify.o\
-	obj/re2/stringpiece.o\
 	obj/re2/tostring.o\
 	obj/re2/unicode_casefold.o\
 	obj/re2/unicode_groups.o\
@@ -175,156 +197,192 @@ DTESTOFILES=$(patsubst obj/%,obj/dbg/%,$(TESTOFILES))
 DTESTS=$(patsubst obj/%,obj/dbg/%,$(TESTS))
 DBIGTESTS=$(patsubst obj/%,obj/dbg/%,$(BIGTESTS))
 
+.PRECIOUS: obj/%.o
 obj/%.o: %.cc $(HFILES)
 	@mkdir -p $$(dirname $@)
 	$(CXX) -c -o $@ $(CPPFLAGS) $(RE2_CXXFLAGS) $(CXXFLAGS) -DNDEBUG $*.cc
 
+.PRECIOUS: obj/dbg/%.o
 obj/dbg/%.o: %.cc $(HFILES)
 	@mkdir -p $$(dirname $@)
 	$(CXX) -c -o $@ $(CPPFLAGS) $(RE2_CXXFLAGS) $(CXXFLAGS) $*.cc
 
+.PRECIOUS: obj/so/%.o
 obj/so/%.o: %.cc $(HFILES)
 	@mkdir -p $$(dirname $@)
 	$(CXX) -c -o $@ -fPIC $(CPPFLAGS) $(RE2_CXXFLAGS) $(CXXFLAGS) -DNDEBUG $*.cc
 
+.PRECIOUS: obj/libre2.a
 obj/libre2.a: $(OFILES)
 	@mkdir -p obj
 	$(AR) $(ARFLAGS) obj/libre2.a $(OFILES)
 
+.PRECIOUS: obj/dbg/libre2.a
 obj/dbg/libre2.a: $(DOFILES)
 	@mkdir -p obj/dbg
 	$(AR) $(ARFLAGS) obj/dbg/libre2.a $(DOFILES)
 
-obj/so/libre2.$(SOEXT): $(SOFILES)
+.PRECIOUS: obj/so/libre2.$(SOEXT)
+obj/so/libre2.$(SOEXT): $(SOFILES) libre2.symbols libre2.symbols.darwin
 	@mkdir -p obj/so
 	$(MAKE_SHARED_LIBRARY) -o obj/so/libre2.$(SOEXTVER) $(SOFILES)
 	ln -sf libre2.$(SOEXTVER) $@
 
-obj/dbg/test/%: obj/dbg/libre2.a obj/dbg/re2/testing/%.o $(DTESTOFILES) obj/dbg/util/test.o
+.PRECIOUS: obj/dbg/test/%
+obj/dbg/test/%: obj/dbg/libre2.a obj/dbg/re2/testing/%.o $(DTESTOFILES)
 	@mkdir -p obj/dbg/test
-	$(CXX) -o $@ obj/dbg/re2/testing/$*.o $(DTESTOFILES) obj/dbg/util/test.o obj/dbg/libre2.a $(RE2_LDFLAGS) $(LDFLAGS)
+	$(CXX) -o $@ obj/dbg/re2/testing/$*.o $(DTESTOFILES) -lgtest -lgtest_main obj/dbg/libre2.a $(RE2_LDFLAGS) $(LDFLAGS)
 
-obj/test/%: obj/libre2.a obj/re2/testing/%.o $(TESTOFILES) obj/util/test.o
+.PRECIOUS: obj/test/%
+obj/test/%: obj/libre2.a obj/re2/testing/%.o $(TESTOFILES)
 	@mkdir -p obj/test
-	$(CXX) -o $@ obj/re2/testing/$*.o $(TESTOFILES) obj/util/test.o obj/libre2.a $(RE2_LDFLAGS) $(LDFLAGS)
+	$(CXX) -o $@ obj/re2/testing/$*.o $(TESTOFILES) -lgtest -lgtest_main obj/libre2.a $(RE2_LDFLAGS) $(LDFLAGS)
 
 # Test the shared lib, falling back to the static lib for private symbols
-obj/so/test/%: obj/so/libre2.$(SOEXT) obj/libre2.a obj/re2/testing/%.o $(TESTOFILES) obj/util/test.o
+.PRECIOUS: obj/so/test/%
+obj/so/test/%: obj/so/libre2.$(SOEXT) obj/libre2.a obj/re2/testing/%.o $(TESTOFILES)
 	@mkdir -p obj/so/test
-	$(CXX) -o $@ obj/re2/testing/$*.o $(TESTOFILES) obj/util/test.o -Lobj/so -lre2 obj/libre2.a $(RE2_LDFLAGS) $(LDFLAGS)
+	$(CXX) -o $@ obj/re2/testing/$*.o $(TESTOFILES) -lgtest -lgtest_main -Lobj/so -lre2 obj/libre2.a $(RE2_LDFLAGS) $(LDFLAGS)
 
-obj/test/regexp_benchmark: obj/libre2.a obj/re2/testing/regexp_benchmark.o $(TESTOFILES) obj/util/benchmark.o
+obj/test/regexp_benchmark: obj/libre2.a obj/re2/testing/regexp_benchmark.o $(TESTOFILES)
 	@mkdir -p obj/test
-	$(CXX) -o $@ obj/re2/testing/regexp_benchmark.o $(TESTOFILES) obj/util/benchmark.o obj/libre2.a $(RE2_LDFLAGS) $(LDFLAGS)
+	$(CXX) -o $@ obj/re2/testing/regexp_benchmark.o $(TESTOFILES) -lgtest -lbenchmark -lbenchmark_main obj/libre2.a $(RE2_LDFLAGS) $(LDFLAGS)
 
 # re2_fuzzer is a target for fuzzers like libFuzzer and AFL. This fake fuzzing
 # is simply a way to check that the target builds and then to run it against a
 # fixed set of inputs. To perform real fuzzing, refer to the documentation for
 # libFuzzer (llvm.org/docs/LibFuzzer.html) and AFL (lcamtuf.coredump.cx/afl/).
+obj/test/re2_fuzzer: CXXFLAGS:=-I./re2/fuzzing/compiler-rt/include $(CXXFLAGS)
 obj/test/re2_fuzzer: obj/libre2.a obj/re2/fuzzing/re2_fuzzer.o obj/util/fuzz.o
 	@mkdir -p obj/test
 	$(CXX) -o $@ obj/re2/fuzzing/re2_fuzzer.o obj/util/fuzz.o obj/libre2.a $(RE2_LDFLAGS) $(LDFLAGS)
 
 ifdef REBUILD_TABLES
+.PRECIOUS: re2/perl_groups.cc
 re2/perl_groups.cc: re2/make_perl_groups.pl
 	perl $< > $@
 
-re2/unicode_%.cc: re2/make_unicode_%.py
-	python $< > $@
-
-.PRECIOUS: re2/perl_groups.cc re2/unicode_casefold.cc re2/unicode_groups.cc
+.PRECIOUS: re2/unicode_%.cc
+re2/unicode_%.cc: re2/make_unicode_%.py re2/unicode.py
+	python3 $< > $@
 endif
 
+.PHONY: distclean
 distclean: clean
 	rm -f re2/perl_groups.cc re2/unicode_casefold.cc re2/unicode_groups.cc
 
+.PHONY: clean
 clean:
 	rm -rf obj
 	rm -f re2/*.pyc
 
+.PHONY: testofiles
 testofiles: $(TESTOFILES)
 
+.PHONY: test
 test: $(DTESTS) $(TESTS) $(STESTS) debug-test static-test shared-test
 
+.PHONY: debug-test
 debug-test: $(DTESTS)
 	@./runtests $(DTESTS)
 
+.PHONY: static-test
 static-test: $(TESTS)
 	@./runtests $(TESTS)
 
+.PHONY: shared-test
 shared-test: $(STESTS)
 	@./runtests -shared-library-path obj/so $(STESTS)
 
+.PHONY: debug-bigtest
 debug-bigtest: $(DTESTS) $(DBIGTESTS)
 	@./runtests $(DTESTS) $(DBIGTESTS)
 
+.PHONY: static-bigtest
 static-bigtest: $(TESTS) $(BIGTESTS)
 	@./runtests $(TESTS) $(BIGTESTS)
 
+.PHONY: shared-bigtest
 shared-bigtest: $(STESTS) $(SBIGTESTS)
 	@./runtests -shared-library-path obj/so $(STESTS) $(SBIGTESTS)
 
+.PHONY: benchmark
 benchmark: obj/test/regexp_benchmark
 
+.PHONY: fuzz
 fuzz: obj/test/re2_fuzzer
 
-install: obj/libre2.a obj/so/libre2.$(SOEXT)
-	mkdir -p $(DESTDIR)$(includedir)/re2 $(DESTDIR)$(libdir)/pkgconfig
-	$(INSTALL_DATA) $(INSTALL_HFILES) $(DESTDIR)$(includedir)/re2
+.PHONY: install
+install: static-install shared-install
+
+.PHONY: static
+static: obj/libre2.a
+
+.PHONY: static-install
+static-install: obj/libre2.a common-install
 	$(INSTALL) obj/libre2.a $(DESTDIR)$(libdir)/libre2.a
+
+.PHONY: shared
+shared: obj/so/libre2.$(SOEXT)
+
+.PHONY: shared-install
+shared-install: obj/so/libre2.$(SOEXT) common-install
 	$(INSTALL) obj/so/libre2.$(SOEXT) $(DESTDIR)$(libdir)/libre2.$(SOEXTVER00)
 	ln -sf libre2.$(SOEXTVER00) $(DESTDIR)$(libdir)/libre2.$(SOEXTVER)
 	ln -sf libre2.$(SOEXTVER00) $(DESTDIR)$(libdir)/libre2.$(SOEXT)
-	$(INSTALL_DATA) re2.pc $(DESTDIR)$(libdir)/pkgconfig/re2.pc
-	$(SED_INPLACE) -e "s#@prefix@#${prefix}#" $(DESTDIR)$(libdir)/pkgconfig/re2.pc
-	$(SED_INPLACE) -e "s#@exec_prefix@#${exec_prefix}#" $(DESTDIR)$(libdir)/pkgconfig/re2.pc
-	$(SED_INPLACE) -e "s#@includedir@#${includedir}#" $(DESTDIR)$(libdir)/pkgconfig/re2.pc
-	$(SED_INPLACE) -e "s#@libdir@#${libdir}#" $(DESTDIR)$(libdir)/pkgconfig/re2.pc
 
+.PHONY: common-install
+common-install:
+	mkdir -p $(DESTDIR)$(includedir)/re2 $(DESTDIR)$(libdir)/pkgconfig
+	$(INSTALL_DATA) $(INSTALL_HFILES) $(DESTDIR)$(includedir)/re2
+	$(INSTALL_DATA) re2.pc.in $(DESTDIR)$(libdir)/pkgconfig/re2.pc
+	$(SED_INPLACE) -e "s#@CMAKE_INSTALL_FULL_INCLUDEDIR@#$(includedir)#" $(DESTDIR)$(libdir)/pkgconfig/re2.pc
+	$(SED_INPLACE) -e "s#@CMAKE_INSTALL_FULL_LIBDIR@#$(libdir)#" $(DESTDIR)$(libdir)/pkgconfig/re2.pc
+	$(SED_INPLACE) -e "s#@REQUIRES@#$(REQUIRES)#" $(DESTDIR)$(libdir)/pkgconfig/re2.pc
+	$(SED_INPLACE) -e "s#@SONAME@#$(SONAME)#" $(DESTDIR)$(libdir)/pkgconfig/re2.pc
+
+.PHONY: testinstall
 testinstall: static-testinstall shared-testinstall
 	@echo
 	@echo Install tests passed.
 	@echo
 
-static-testinstall: CXXFLAGS:=-std=c++11 -pthread -I$(DESTDIR)$(includedir) $(CXXFLAGS)
-static-testinstall: LDFLAGS:=-pthread -L$(DESTDIR)$(libdir) -l:libre2.a $(LDICU) $(LDFLAGS)
+.PHONY: static-testinstall
 static-testinstall:
-	@mkdir -p obj
-	@cp testinstall.cc obj
 ifeq ($(shell uname),Darwin)
 	@echo Skipping test for libre2.a on Darwin.
 else ifeq ($(shell uname),SunOS)
 	@echo Skipping test for libre2.a on SunOS.
 else
-	(cd obj && $(CXX) testinstall.cc -o testinstall $(CXXFLAGS) $(LDFLAGS))
-	obj/testinstall
+	@mkdir -p obj
+	@cp testinstall.cc obj/static-testinstall.cc
+	(cd obj && export PKG_CONFIG_PATH=$(DESTDIR)$(libdir)/pkgconfig; \
+	  $(CXX) static-testinstall.cc -o static-testinstall $(CXXFLAGS) $(LDFLAGS) \
+	  $$(pkg-config re2 --cflags --libs | sed -e 's/-lre2/-l:libre2.a/'))
+	obj/static-testinstall
 endif
 
-shared-testinstall: CXXFLAGS:=-std=c++11 -pthread -I$(DESTDIR)$(includedir) $(CXXFLAGS)
-shared-testinstall: LDFLAGS:=-pthread -L$(DESTDIR)$(libdir) -lre2 $(LDICU) $(LDFLAGS)
+.PHONY: shared-testinstall
 shared-testinstall:
 	@mkdir -p obj
-	@cp testinstall.cc obj
-	(cd obj && $(CXX) testinstall.cc -o testinstall $(CXXFLAGS) $(LDFLAGS))
+	@cp testinstall.cc obj/shared-testinstall.cc
+	(cd obj && export PKG_CONFIG_PATH=$(DESTDIR)$(libdir)/pkgconfig; \
+	  $(CXX) shared-testinstall.cc -o shared-testinstall $(CXXFLAGS) $(LDFLAGS) \
+	  $$(pkg-config re2 --cflags --libs))
 ifeq ($(shell uname),Darwin)
-	DYLD_LIBRARY_PATH="$(DESTDIR)$(libdir):$(DYLD_LIBRARY_PATH)" obj/testinstall
+	DYLD_LIBRARY_PATH="$(DESTDIR)$(libdir):$(DYLD_LIBRARY_PATH)" obj/shared-testinstall
 else
-	LD_LIBRARY_PATH="$(DESTDIR)$(libdir):$(LD_LIBRARY_PATH)" obj/testinstall
+	LD_LIBRARY_PATH="$(DESTDIR)$(libdir):$(LD_LIBRARY_PATH)" obj/shared-testinstall
 endif
 
+.PHONY: benchlog
 benchlog: obj/test/regexp_benchmark
 	(echo '==BENCHMARK==' `hostname` `date`; \
 	  (uname -a; $(CXX) --version; git rev-parse --short HEAD; file obj/test/regexp_benchmark) | sed 's/^/# /'; \
 	  echo; \
 	  ./obj/test/regexp_benchmark 'PCRE|RE2') | tee -a benchlog.$$(hostname | sed 's/\..*//')
 
-# Keep gmake from deleting intermediate files it creates.
-# This makes repeated builds faster and preserves debug info on OS X.
-
-.PRECIOUS: obj/%.o obj/dbg/%.o obj/so/%.o obj/libre2.a \
-	obj/dbg/libre2.a obj/so/libre2.a \
-	obj/test/% obj/so/test/% obj/dbg/test/%
-
+.PHONY: log
 log:
 	$(MAKE) clean
 	$(MAKE) CXXFLAGS="$(CXXFLAGS) -DLOGGING=1" \
@@ -340,6 +398,3 @@ log:
 	echo '#' RE2 basic search tests built by make $@ >re2-search.txt
 	echo '#' $$(date) >>re2-search.txt
 	obj/test/search_test |grep -v '^PASS$$' >>re2-search.txt
-
-x: x.cc obj/libre2.a
-	g++ -I. -o x x.cc obj/libre2.a
diff --git a/README b/README
index d1ef431..469d6f3 100644
--- a/README
+++ b/README
@@ -10,6 +10,11 @@ make test
 make install
 make testinstall
 
+Building RE2 requires Abseil (https://github.com/abseil/abseil-cpp)
+to be installed on your system. Building the testing for RE2 requires
+GoogleTest (https://github.com/google/googletest) and Benchmark
+(https://github.com/google/benchmark) to be installed as well.
+
 There is a fair amount of documentation (including code snippets) in
 the re2.h header file.
 
@@ -27,12 +32,16 @@ under the BSD-style license found in the LICENSE file.
 
 RE2's native language is C++.
 
+The Python wrapper is at https://github.com/google/re2/tree/abseil/python
+and on PyPI (https://pypi.org/project/google-re2/).
+
 A C wrapper is at https://github.com/marcomaggi/cre2/.
+A D wrapper is at https://github.com/ShigekiKarita/re2d/ and on DUB (code.dlang.org).
 An Erlang wrapper is at https://github.com/dukesoferl/re2/ and on Hex (hex.pm).
 An Inferno wrapper is at https://github.com/powerman/inferno-re2/.
 A Node.js wrapper is at https://github.com/uhop/node-re2/ and on NPM (npmjs.com).
 An OCaml wrapper is at https://github.com/janestreet/re2/ and on OPAM (opam.ocaml.org).
 A Perl wrapper is at https://github.com/dgl/re-engine-RE2/ and on CPAN (cpan.org).
-A Python wrapper is at https://github.com/facebook/pyre2/ and on PyPI (pypi.org).
-An R wrapper is at https://github.com/qinwf/re2r/ and on CRAN (cran.r-project.org).
+An R wrapper is at https://github.com/girishji/re2/ and on CRAN (cran.r-project.org).
 A Ruby wrapper is at https://github.com/mudge/re2/ and on RubyGems (rubygems.org).
+A WebAssembly wrapper is at https://github.com/google/re2-wasm/ and on NPM (npmjs.com).
diff --git a/SECURITY.md b/SECURITY.md
new file mode 100644
index 0000000..39ba0e9
--- /dev/null
+++ b/SECURITY.md
@@ -0,0 +1,4 @@
+To report a security issue, please use https://g.co/vulnz. We use
+https://g.co/vulnz for our intake, and do coordination and disclosure here on
+GitHub (including using GitHub Security Advisory). The Google Security Team will
+respond within 5 working days of your report on https://g.co/vulnz.
diff --git a/WORKSPACE b/WORKSPACE
deleted file mode 100644
index de481fe..0000000
--- a/WORKSPACE
+++ /dev/null
@@ -1,6 +0,0 @@
-# Copyright 2009 The RE2 Authors.  All Rights Reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-# Bazel (http://bazel.io/) WORKSPACE file for RE2.
-workspace(name = "com_googlesource_code_re2")
diff --git a/WORKSPACE.bazel b/WORKSPACE.bazel
new file mode 100644
index 0000000..c89e979
--- /dev/null
+++ b/WORKSPACE.bazel
@@ -0,0 +1,62 @@
+# Copyright 2009 The RE2 Authors.  All Rights Reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+
+# Bazel (http://bazel.io/) WORKSPACE file for RE2.
+
+workspace(name = "com_googlesource_code_re2")
+
+load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
+
+http_archive(
+    name = "com_google_absl",
+    strip_prefix = "abseil-cpp-master",
+    urls = ["https://github.com/abseil/abseil-cpp/archive/master.zip"],
+)
+
+http_archive(
+    name = "bazel_skylib",
+    strip_prefix = "bazel-skylib-main",
+    urls = ["https://github.com/bazelbuild/bazel-skylib/archive/main.zip"],
+)
+
+http_archive(
+    name = "com_github_google_benchmark",
+    strip_prefix = "benchmark-main",
+    urls = ["https://github.com/google/benchmark/archive/main.zip"],
+)
+
+http_archive(
+    name = "com_google_googletest",
+    strip_prefix = "googletest-main",
+    urls = ["https://github.com/google/googletest/archive/main.zip"],
+)
+
+http_archive(
+    name = "rules_python",
+    strip_prefix = "rules_python-main",
+    urls = ["https://github.com/bazelbuild/rules_python/archive/main.zip"],
+)
+
+http_archive(
+    name = "io_abseil_py",
+    strip_prefix = "abseil-py-main",
+    urls = ["https://github.com/abseil/abseil-py/archive/main.zip"],
+)
+
+http_archive(
+    name = "pybind11_bazel",
+    strip_prefix = "pybind11_bazel-master",
+    urls = ["https://github.com/pybind/pybind11_bazel/archive/master.zip"],
+)
+
+http_archive(
+    name = "pybind11",
+    build_file = "@pybind11_bazel//:pybind11.BUILD",
+    strip_prefix = "pybind11-master",
+    urls = ["https://github.com/pybind/pybind11/archive/master.zip"],
+)
+
+load("@pybind11_bazel//:python_configure.bzl", "python_configure")
+
+python_configure(name = "local_config_python")
diff --git a/app/BUILD.bazel b/app/BUILD.bazel
new file mode 100644
index 0000000..01ff8d4
--- /dev/null
+++ b/app/BUILD.bazel
@@ -0,0 +1,19 @@
+# Copyright 2009 The RE2 Authors.  All Rights Reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+
+# Bazel (http://bazel.io/) BUILD file for RE2 app.
+
+cc_binary(
+    name = "_re2.js",
+    srcs = ["_re2.cc"],
+    linkopts = [
+        "--bind",
+        "-sENVIRONMENT=web",
+        "-sMODULARIZE=1",
+        "-sEXPORT_ES6=1",
+        "-sEXPORT_NAME=loadModule",
+        "-sUSE_PTHREADS=0",
+    ],
+    deps = ["//:re2"],
+)
diff --git a/app/_re2.cc b/app/_re2.cc
new file mode 100644
index 0000000..a63313e
--- /dev/null
+++ b/app/_re2.cc
@@ -0,0 +1,94 @@
+// Copyright 2022 The RE2 Authors.  All Rights Reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+#include <memory>
+#include <string>
+
+#include <emscripten/bind.h>
+#include "re2/prog.h"
+#include "re2/re2.h"
+#include "re2/regexp.h"
+
+namespace re2_app {
+
+struct Info {
+  std::string pattern;
+  std::string error;
+  std::string prefix;
+  bool prefix_foldcase = false;
+  std::string accel_prefix;
+  bool accel_prefix_foldcase = false;
+  int num_captures;
+  bool is_one_pass;
+  bool can_bit_state;
+  std::string bytecode;
+  std::string bytemap;
+};
+
+Info GetInfo(const std::string& pattern) {
+  Info info;
+  info.pattern = pattern;
+
+  RE2::Options options;
+  re2::RegexpStatus status;
+  re2::Regexp* regexp = re2::Regexp::Parse(
+      pattern, static_cast<re2::Regexp::ParseFlags>(options.ParseFlags()),
+      &status);
+  if (regexp == nullptr) {
+    info.error = "failed to parse pattern: " + status.Text();
+    return info;
+  }
+
+  std::string prefix;
+  bool prefix_foldcase;
+  re2::Regexp* suffix;
+  if (regexp->RequiredPrefix(&prefix, &prefix_foldcase, &suffix)) {
+    info.prefix = prefix;
+    info.prefix_foldcase = prefix_foldcase;
+  } else {
+    suffix = regexp->Incref();
+  }
+
+  std::unique_ptr<re2::Prog> prog(suffix->CompileToProg(options.max_mem()));
+  if (prog == nullptr) {
+    info.error = "failed to compile forward Prog";
+    suffix->Decref();
+    regexp->Decref();
+    return info;
+  }
+
+  if (regexp->RequiredPrefixForAccel(&prefix, &prefix_foldcase)) {
+    info.accel_prefix = prefix;
+    info.accel_prefix_foldcase = prefix_foldcase;
+  }
+
+  info.num_captures = suffix->NumCaptures();
+  info.is_one_pass = prog->IsOnePass();
+  info.can_bit_state = prog->CanBitState();
+  info.bytecode = prog->Dump();
+  info.bytemap = prog->DumpByteMap();
+
+  suffix->Decref();
+  regexp->Decref();
+  return info;
+}
+
+EMSCRIPTEN_BINDINGS(_re2) {
+  emscripten::value_object<Info>("Info")
+      .field("pattern", &Info::pattern)
+      .field("error", &Info::error)
+      .field("prefix", &Info::prefix)
+      .field("prefix_foldcase", &Info::prefix_foldcase)
+      .field("accel_prefix", &Info::accel_prefix)
+      .field("accel_prefix_foldcase", &Info::accel_prefix_foldcase)
+      .field("num_captures", &Info::num_captures)
+      .field("is_one_pass", &Info::is_one_pass)
+      .field("can_bit_state", &Info::can_bit_state)
+      .field("bytecode", &Info::bytecode)
+      .field("bytemap", &Info::bytemap);
+
+  emscripten::function("getInfo", &GetInfo);
+}
+
+}  // namespace re2_app
diff --git a/app/_re2.d.ts b/app/_re2.d.ts
new file mode 100644
index 0000000..dff5e49
--- /dev/null
+++ b/app/_re2.d.ts
@@ -0,0 +1,23 @@
+// Copyright 2022 The RE2 Authors.  All Rights Reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+export type Info = {
+  pattern: ArrayBuffer|Uint8Array|Uint8ClampedArray|Int8Array|string,
+  error: ArrayBuffer|Uint8Array|Uint8ClampedArray|Int8Array|string,
+  prefix: ArrayBuffer|Uint8Array|Uint8ClampedArray|Int8Array|string,
+  prefix_foldcase: boolean,
+  accel_prefix: ArrayBuffer|Uint8Array|Uint8ClampedArray|Int8Array|string,
+  accel_prefix_foldcase: boolean,
+  num_captures: number,
+  is_one_pass: boolean,
+  can_bit_state: boolean,
+  bytecode: ArrayBuffer|Uint8Array|Uint8ClampedArray|Int8Array|string,
+  bytemap: ArrayBuffer|Uint8Array|Uint8ClampedArray|Int8Array|string,
+};
+
+export interface MainModule {
+  getInfo(pattern: ArrayBuffer|Uint8Array|Uint8ClampedArray|Int8Array|string): Info;
+}
+
+export default function loadModule(): Promise<MainModule>;
diff --git a/app/app.ts b/app/app.ts
new file mode 100644
index 0000000..4b9e7bd
--- /dev/null
+++ b/app/app.ts
@@ -0,0 +1,111 @@
+// Copyright 2022 The RE2 Authors.  All Rights Reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+import {css, html, LitElement, render} from 'lit';
+import {customElement} from 'lit/decorators.js';
+
+import /*default*/ loadModule from './_re2';
+import {Info, MainModule} from './_re2';
+
+var _re2: MainModule;
+loadModule().then((module: MainModule) => {
+  _re2 = module;
+  render(html`<title>re2-dev</title><re2-dev></re2-dev>`, document.body);
+});
+
+@customElement('re2-dev')
+export class RE2Dev extends LitElement {
+  private _pattern: string = '';
+  private _info: Info|null = null;
+
+  constructor() {
+    super();
+    this._pattern = decodeURIComponent(window.location.hash.slice(1));
+    this._info = this._pattern ? _re2.getInfo(this._pattern) : null;
+    this.requestUpdate();
+  }
+
+  private _onChange = (e: Event) => {
+    this._pattern = (e.target as HTMLInputElement).value;
+    this._info = this._pattern ? _re2.getInfo(this._pattern) : null;
+    this.requestUpdate();
+    window.location.hash = '#' + encodeURIComponent(this._pattern);
+  };
+
+  static override styles = css`
+.code {
+  font-family: monospace;
+  white-space: pre-line;
+}
+`;
+
+  override render() {
+    var fragments = [];
+    fragments.push(html`
+<div>
+  <input type="text" size="48" @change=${this._onChange} .value=${this._pattern}>
+</div>
+`);
+
+    if (this._info === null) {
+      return html`${fragments}`;
+    }
+
+    if (this._info.error) {
+      fragments.push(html`
+<br>
+<div>
+  error:
+  <span class="code">${this._info.error}</span>
+</div>
+`);
+      return html`${fragments}`;
+    }
+
+    fragments.push(html`
+<br>
+<div>
+  pattern:
+  <span class="code">${this._info.pattern}</span>
+  <br>
+  prefix:
+  <span class="code">${this._info.prefix}</span>
+  
+  _foldcase:
+  <span class="code">${this._info.prefix_foldcase}</span>
+  <br>
+  accel_prefix:
+  <span class="code">${this._info.accel_prefix}</span>
+  
+  _foldcase:
+  <span class="code">${this._info.accel_prefix_foldcase}</span>
+  <br>
+  num_captures:
+  <span class="code">${this._info.num_captures}</span>
+  <br>
+  is_one_pass:
+  <span class="code">${this._info.is_one_pass}</span>
+  <br>
+  can_bit_state:
+  <span class="code">${this._info.can_bit_state}</span>
+  <br>
+  <br>
+  bytecode:
+  <br>
+  <span class="code">${this._info.bytecode}</span>
+  <br>
+  bytemap:
+  <br>
+  <span class="code">${this._info.bytemap}</span>
+</div>
+`);
+    return html`${fragments}`;
+  }
+}
+
+declare global {
+  interface HTMLElementTagNameMap {
+    're2-dev': RE2Dev;
+  }
+}
diff --git a/app/build.sh b/app/build.sh
new file mode 100755
index 0000000..c272bf5
--- /dev/null
+++ b/app/build.sh
@@ -0,0 +1,50 @@
+#!/bin/bash
+set -eux
+
+SRCDIR=$(readlink --canonicalize $(dirname $0))
+DSTDIR=$(mktemp --directory --tmpdir $(basename $0).XXXXXXXXXX)
+
+BAZEL=/tmp/bazel
+BAZELISK_RELEASE=v1.16.0
+
+if [[ ${UID} -ne 0 ]]; then
+  if [[ -d deploy ]]; then
+    echo -e '\033[1;31m' "** The ${PWD}/deploy directory exists! Refusing to clobber it! **" '\033[0m'
+    exit 1
+  fi
+  mkdir deploy
+  sudo docker run -i -t --pull always --rm -v ${SRCDIR}/..:/src -v ${PWD}:/dst emscripten/emsdk /src/app/$(basename $0)
+  ls -l deploy
+else
+  wget -O ${BAZEL} https://github.com/bazelbuild/bazelisk/releases/download/${BAZELISK_RELEASE}/bazelisk-linux-amd64
+  chmod +x ${BAZEL}
+
+  cd ${SRCDIR}
+  # Emscripten doesn't support `-fstack-protector`.
+  AR=emar CC=emcc \
+    ${BAZEL} build --compilation_mode=opt \
+    --copt=-fno-stack-protector \
+    -- :all
+  # Bazel doesn't retain the `_re2.wasm` artifact;
+  # we have to redo the link command to obtain it.
+  pushd ..
+  emcc @bazel-bin/app/_re2.js-2.params
+  cd bazel-bin/app
+  cp _re2.js _re2.wasm ${DSTDIR}
+  popd
+  # Clean up the sundry Bazel output directories.
+  ${BAZEL} clean --expunge
+  cp app.ts index.html _re2.d.ts ${DSTDIR}
+  cp package.json rollup.config.js tsconfig.json ${DSTDIR}
+
+  cd ${DSTDIR}
+  npm install
+  npx tsc
+  npx rollup -c rollup.config.js -d deploy
+  mv deploy/* /dst/deploy
+fi
+
+cd ${SRCDIR}
+rm -rf ${DSTDIR}
+
+exit 0
diff --git a/app/index.html b/app/index.html
new file mode 100644
index 0000000..d229e56
--- /dev/null
+++ b/app/index.html
@@ -0,0 +1,5 @@
+<!DOCTYPE html>
+<meta charset="utf-8">
+<meta name="viewport" content="width=device-width, initial-scale=1">
+<style>:root { color-scheme: dark light; }</style>
+<script type="module" src="app.js"></script>
diff --git a/app/package.json b/app/package.json
new file mode 100644
index 0000000..e702789
--- /dev/null
+++ b/app/package.json
@@ -0,0 +1,14 @@
+{
+  "dependencies": {
+    "lit": "*"
+  },
+  "devDependencies": {
+    "@rollup/plugin-node-resolve": "*",
+    "@rollup/plugin-terser": "*",
+    "@web/rollup-plugin-html": "*",
+    "@web/rollup-plugin-import-meta-assets": "*",
+    "rollup": "~2",
+    "tslib": "*",
+    "typescript": "*"
+  }
+}
diff --git a/app/rollup.config.js b/app/rollup.config.js
new file mode 100644
index 0000000..3a20e66
--- /dev/null
+++ b/app/rollup.config.js
@@ -0,0 +1,28 @@
+// Copyright 2022 The RE2 Authors.  All Rights Reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+import nodeResolve from '@rollup/plugin-node-resolve';
+import terser from '@rollup/plugin-terser';
+import html from '@web/rollup-plugin-html';
+import {importMetaAssets} from '@web/rollup-plugin-import-meta-assets';
+
+export default {
+  input: 'index.html',
+  output: {
+    entryFileNames: '[hash].js',
+    chunkFileNames: '[hash].js',
+    assetFileNames: '[hash][extname]',
+    format: 'es',
+  },
+  preserveEntrySignatures: false,
+  plugins:
+      [
+        html({
+          minify: true,
+        }),
+        nodeResolve(),
+        terser(),
+        importMetaAssets(),
+      ],
+};
diff --git a/app/tsconfig.json b/app/tsconfig.json
new file mode 100644
index 0000000..86cc302
--- /dev/null
+++ b/app/tsconfig.json
@@ -0,0 +1,17 @@
+{
+  "compilerOptions": {
+    "target": "esnext",
+    "module": "esnext",
+    "moduleResolution": "node",
+    "noEmitOnError": true,
+    "lib": ["esnext", "dom"],
+    "strict": true,
+    "esModuleInterop": false,
+    "allowSyntheticDefaultImports": true,
+    "experimentalDecorators": true,
+    "importHelpers": true,
+    "sourceMap": true,
+    "inlineSources": true,
+    "incremental": true
+  }
+}
diff --git a/doc/README.xkcd b/doc/README.xkcd
deleted file mode 100644
index b50a579..0000000
--- a/doc/README.xkcd
+++ /dev/null
@@ -1 +0,0 @@
-xkcd.png is a cropped version of http://xkcd.com/208/
diff --git a/doc/mksyntaxgo b/doc/mksyntaxgo
index caad9b6..d30d281 100755
--- a/doc/mksyntaxgo
+++ b/doc/mksyntaxgo
@@ -15,7 +15,7 @@ sam -d $out <<'!'
 ,s/\n\n\n+/\n\n/g
 ,x/(^.*	.*\n)+/ | awk -F'	' '{printf("  %-14s %s\n", $1, $2)}'
 1,2c
-// Copyright 2012 The Go Authors.  All rights reserved.
+// Copyright 2012 The Go Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
@@ -33,6 +33,7 @@ Parts of the syntax can be disabled by passing alternate flags to Parse.
 
 .
 $a
+Unicode character classes are those in unicode.Categories and unicode.Scripts.
 */
 package syntax
 .
diff --git a/doc/syntax.html b/doc/syntax.html
index aa08b11..eed4fd2 100644
--- a/doc/syntax.html
+++ b/doc/syntax.html
@@ -47,6 +47,10 @@
 <tr><td><code><font color=#808080>x{-n}</font></code></td><td>( <code>x{n}?</code>)  <font size=-2>VIM</font></td></tr>
 <tr><td><code><font color=#808080>x=</font></code></td><td>( <code>x?</code>)  <font size=-2>VIM</font></td></tr>
 <tr><td></td></tr>
+<tr><td colspan=2>Implementation restriction: The counting forms <code>x{n,m}</code>, <code>x{n,}</code>, and <code>x{n}</code></td></tr>
+<tr><td colspan=2>reject forms that create a minimum or maximum repetition count above 1000.</td></tr>
+<tr><td colspan=2>Unlimited repetitions are not subject to this restriction.</td></tr>
+<tr><td></td></tr>
 <tr><td colspan=2><b>Possessive repetitions:</b></td></tr>
 <tr><td><code><font color=#808080>x*+</font></code></td><td>zero or more <code>x</code>, possessive </td></tr>
 <tr><td><code><font color=#808080>x++</font></code></td><td>one or more <code>x</code>, possessive </td></tr>
@@ -56,10 +60,10 @@
 <tr><td><code><font color=#808080>x{n}+</font></code></td><td>exactly <code>n</code> <code>x</code>, possessive </td></tr>
 <tr><td></td></tr>
 <tr><td colspan=2><b>Grouping:</b></td></tr>
-<tr><td><code>(re)</code></td><td>numbered capturing group</td></tr>
-<tr><td><code>(?P&lt;name&gt;re)</code></td><td>named &amp; numbered capturing group</td></tr>
-<tr><td><code><font color=#808080>(?&lt;name&gt;re)</font></code></td><td>named &amp; numbered capturing group </td></tr>
-<tr><td><code><font color=#808080>(?'name're)</font></code></td><td>named &amp; numbered capturing group </td></tr>
+<tr><td><code>(re)</code></td><td>numbered capturing group (submatch)</td></tr>
+<tr><td><code>(?P&lt;name&gt;re)</code></td><td>named &amp; numbered capturing group (submatch)</td></tr>
+<tr><td><code><font color=#808080>(?&lt;name&gt;re)</font></code></td><td>named &amp; numbered capturing group (submatch) </td></tr>
+<tr><td><code><font color=#808080>(?'name're)</font></code></td><td>named &amp; numbered capturing group (submatch) </td></tr>
 <tr><td><code>(?:re)</code></td><td>non-capturing group</td></tr>
 <tr><td><code>(?flags)</code></td><td>set flags within current group; non-capturing</td></tr>
 <tr><td><code>(?flags:re)</code></td><td>set flags during re; non-capturing</td></tr>
@@ -80,8 +84,8 @@
 <tr><td><code>^</code></td><td>at beginning of text or line (<code>m</code>=true)</td></tr>
 <tr><td><code>$</code></td><td>at end of text (like <code>\z</code> not <code>\Z</code>) or line (<code>m</code>=true)</td></tr>
 <tr><td><code>\A</code></td><td>at beginning of text</td></tr>
-<tr><td><code>\b</code></td><td>at word boundary (<code>\w</code> on one side and <code>\W</code>, <code>\A</code>, or <code>\z</code> on the other)</td></tr>
-<tr><td><code>\B</code></td><td>not a word boundary</td></tr>
+<tr><td><code>\b</code></td><td>at ASCII word boundary (<code>\w</code> on one side and <code>\W</code>, <code>\A</code>, or <code>\z</code> on the other)</td></tr>
+<tr><td><code>\B</code></td><td>not at ASCII word boundary</td></tr>
 <tr><td><code><font color=#808080>\G</font></code></td><td>at beginning of subtext being searched  <font size=-2>PCRE</font></td></tr>
 <tr><td><code><font color=#808080>\G</font></code></td><td>at end of last match  <font size=-2>PERL</font></td></tr>
 <tr><td><code><font color=#808080>\Z</font></code></td><td>at end of text, or before newline at end of text </td></tr>
@@ -166,7 +170,7 @@
 <tr><td><code>[\p{Name}]</code></td><td>named Unicode property inside character class ( <code>\p{Name}</code>)</td></tr>
 <tr><td><code>[^\p{Name}]</code></td><td>named Unicode property inside negated character class ( <code>\P{Name}</code>)</td></tr>
 <tr><td></td></tr>
-<tr><td colspan=2><b>Perl character classes:</b></td></tr>
+<tr><td colspan=2><b>Perl character classes (all ASCII-only):</b></td></tr>
 <tr><td><code>\d</code></td><td>digits ( <code>[0-9]</code>)</td></tr>
 <tr><td><code>\D</code></td><td>not digits ( <code>[^0-9]</code>)</td></tr>
 <tr><td><code>\s</code></td><td>whitespace ( <code>[\t\n\f\r ]</code>)</td></tr>
@@ -237,105 +241,169 @@
 <tr><td><code>Zs</code></td><td>space separator</td></tr>
 <tr><td></td></tr>
 <tr><td colspan=2><b>Unicode character class names--scripts:</b></td></tr>
-<tr><td><code>Arabic</code></td><td>Arabic</td></tr>
-<tr><td><code>Armenian</code></td><td>Armenian</td></tr>
-<tr><td><code>Balinese</code></td><td>Balinese</td></tr>
-<tr><td><code>Bamum</code></td><td>Bamum</td></tr>
-<tr><td><code>Batak</code></td><td>Batak</td></tr>
-<tr><td><code>Bengali</code></td><td>Bengali</td></tr>
-<tr><td><code>Bopomofo</code></td><td>Bopomofo</td></tr>
-<tr><td><code>Brahmi</code></td><td>Brahmi</td></tr>
-<tr><td><code>Braille</code></td><td>Braille</td></tr>
-<tr><td><code>Buginese</code></td><td>Buginese</td></tr>
-<tr><td><code>Buhid</code></td><td>Buhid</td></tr>
-<tr><td><code>Canadian_Aboriginal</code></td><td>Canadian Aboriginal</td></tr>
-<tr><td><code>Carian</code></td><td>Carian</td></tr>
-<tr><td><code>Chakma</code></td><td>Chakma</td></tr>
-<tr><td><code>Cham</code></td><td>Cham</td></tr>
-<tr><td><code>Cherokee</code></td><td>Cherokee</td></tr>
-<tr><td><code>Common</code></td><td>characters not specific to one script</td></tr>
-<tr><td><code>Coptic</code></td><td>Coptic</td></tr>
-<tr><td><code>Cuneiform</code></td><td>Cuneiform</td></tr>
-<tr><td><code>Cypriot</code></td><td>Cypriot</td></tr>
-<tr><td><code>Cyrillic</code></td><td>Cyrillic</td></tr>
-<tr><td><code>Deseret</code></td><td>Deseret</td></tr>
-<tr><td><code>Devanagari</code></td><td>Devanagari</td></tr>
-<tr><td><code>Egyptian_Hieroglyphs</code></td><td>Egyptian Hieroglyphs</td></tr>
-<tr><td><code>Ethiopic</code></td><td>Ethiopic</td></tr>
-<tr><td><code>Georgian</code></td><td>Georgian</td></tr>
-<tr><td><code>Glagolitic</code></td><td>Glagolitic</td></tr>
-<tr><td><code>Gothic</code></td><td>Gothic</td></tr>
-<tr><td><code>Greek</code></td><td>Greek</td></tr>
-<tr><td><code>Gujarati</code></td><td>Gujarati</td></tr>
-<tr><td><code>Gurmukhi</code></td><td>Gurmukhi</td></tr>
-<tr><td><code>Han</code></td><td>Han</td></tr>
-<tr><td><code>Hangul</code></td><td>Hangul</td></tr>
-<tr><td><code>Hanunoo</code></td><td>Hanunoo</td></tr>
-<tr><td><code>Hebrew</code></td><td>Hebrew</td></tr>
-<tr><td><code>Hiragana</code></td><td>Hiragana</td></tr>
-<tr><td><code>Imperial_Aramaic</code></td><td>Imperial Aramaic</td></tr>
-<tr><td><code>Inherited</code></td><td>inherit script from previous character</td></tr>
-<tr><td><code>Inscriptional_Pahlavi</code></td><td>Inscriptional Pahlavi</td></tr>
-<tr><td><code>Inscriptional_Parthian</code></td><td>Inscriptional Parthian</td></tr>
-<tr><td><code>Javanese</code></td><td>Javanese</td></tr>
-<tr><td><code>Kaithi</code></td><td>Kaithi</td></tr>
-<tr><td><code>Kannada</code></td><td>Kannada</td></tr>
-<tr><td><code>Katakana</code></td><td>Katakana</td></tr>
-<tr><td><code>Kayah_Li</code></td><td>Kayah Li</td></tr>
-<tr><td><code>Kharoshthi</code></td><td>Kharoshthi</td></tr>
-<tr><td><code>Khmer</code></td><td>Khmer</td></tr>
-<tr><td><code>Lao</code></td><td>Lao</td></tr>
-<tr><td><code>Latin</code></td><td>Latin</td></tr>
-<tr><td><code>Lepcha</code></td><td>Lepcha</td></tr>
-<tr><td><code>Limbu</code></td><td>Limbu</td></tr>
-<tr><td><code>Linear_B</code></td><td>Linear B</td></tr>
-<tr><td><code>Lycian</code></td><td>Lycian</td></tr>
-<tr><td><code>Lydian</code></td><td>Lydian</td></tr>
-<tr><td><code>Malayalam</code></td><td>Malayalam</td></tr>
-<tr><td><code>Mandaic</code></td><td>Mandaic</td></tr>
-<tr><td><code>Meetei_Mayek</code></td><td>Meetei Mayek</td></tr>
-<tr><td><code>Meroitic_Cursive</code></td><td>Meroitic Cursive</td></tr>
-<tr><td><code>Meroitic_Hieroglyphs</code></td><td>Meroitic Hieroglyphs</td></tr>
-<tr><td><code>Miao</code></td><td>Miao</td></tr>
-<tr><td><code>Mongolian</code></td><td>Mongolian</td></tr>
-<tr><td><code>Myanmar</code></td><td>Myanmar</td></tr>
-<tr><td><code>New_Tai_Lue</code></td><td>New Tai Lue (aka Simplified Tai Lue)</td></tr>
-<tr><td><code>Nko</code></td><td>Nko</td></tr>
-<tr><td><code>Ogham</code></td><td>Ogham</td></tr>
-<tr><td><code>Ol_Chiki</code></td><td>Ol Chiki</td></tr>
-<tr><td><code>Old_Italic</code></td><td>Old Italic</td></tr>
-<tr><td><code>Old_Persian</code></td><td>Old Persian</td></tr>
-<tr><td><code>Old_South_Arabian</code></td><td>Old South Arabian</td></tr>
-<tr><td><code>Old_Turkic</code></td><td>Old Turkic</td></tr>
-<tr><td><code>Oriya</code></td><td>Oriya</td></tr>
-<tr><td><code>Osmanya</code></td><td>Osmanya</td></tr>
-<tr><td><code>Phags_Pa</code></td><td>'Phags Pa</td></tr>
-<tr><td><code>Phoenician</code></td><td>Phoenician</td></tr>
-<tr><td><code>Rejang</code></td><td>Rejang</td></tr>
-<tr><td><code>Runic</code></td><td>Runic</td></tr>
-<tr><td><code>Saurashtra</code></td><td>Saurashtra</td></tr>
-<tr><td><code>Sharada</code></td><td>Sharada</td></tr>
-<tr><td><code>Shavian</code></td><td>Shavian</td></tr>
-<tr><td><code>Sinhala</code></td><td>Sinhala</td></tr>
-<tr><td><code>Sora_Sompeng</code></td><td>Sora Sompeng</td></tr>
-<tr><td><code>Sundanese</code></td><td>Sundanese</td></tr>
-<tr><td><code>Syloti_Nagri</code></td><td>Syloti Nagri</td></tr>
-<tr><td><code>Syriac</code></td><td>Syriac</td></tr>
-<tr><td><code>Tagalog</code></td><td>Tagalog</td></tr>
-<tr><td><code>Tagbanwa</code></td><td>Tagbanwa</td></tr>
-<tr><td><code>Tai_Le</code></td><td>Tai Le</td></tr>
-<tr><td><code>Tai_Tham</code></td><td>Tai Tham</td></tr>
-<tr><td><code>Tai_Viet</code></td><td>Tai Viet</td></tr>
-<tr><td><code>Takri</code></td><td>Takri</td></tr>
-<tr><td><code>Tamil</code></td><td>Tamil</td></tr>
-<tr><td><code>Telugu</code></td><td>Telugu</td></tr>
-<tr><td><code>Thaana</code></td><td>Thaana</td></tr>
-<tr><td><code>Thai</code></td><td>Thai</td></tr>
-<tr><td><code>Tibetan</code></td><td>Tibetan</td></tr>
-<tr><td><code>Tifinagh</code></td><td>Tifinagh</td></tr>
-<tr><td><code>Ugaritic</code></td><td>Ugaritic</td></tr>
-<tr><td><code>Vai</code></td><td>Vai</td></tr>
-<tr><td><code>Yi</code></td><td>Yi</td></tr>
+<tr><td colspan=2>Adlam</td></tr>
+<tr><td colspan=2>Ahom</td></tr>
+<tr><td colspan=2>Anatolian_Hieroglyphs</td></tr>
+<tr><td colspan=2>Arabic</td></tr>
+<tr><td colspan=2>Armenian</td></tr>
+<tr><td colspan=2>Avestan</td></tr>
+<tr><td colspan=2>Balinese</td></tr>
+<tr><td colspan=2>Bamum</td></tr>
+<tr><td colspan=2>Bassa_Vah</td></tr>
+<tr><td colspan=2>Batak</td></tr>
+<tr><td colspan=2>Bengali</td></tr>
+<tr><td colspan=2>Bhaiksuki</td></tr>
+<tr><td colspan=2>Bopomofo</td></tr>
+<tr><td colspan=2>Brahmi</td></tr>
+<tr><td colspan=2>Braille</td></tr>
+<tr><td colspan=2>Buginese</td></tr>
+<tr><td colspan=2>Buhid</td></tr>
+<tr><td colspan=2>Canadian_Aboriginal</td></tr>
+<tr><td colspan=2>Carian</td></tr>
+<tr><td colspan=2>Caucasian_Albanian</td></tr>
+<tr><td colspan=2>Chakma</td></tr>
+<tr><td colspan=2>Cham</td></tr>
+<tr><td colspan=2>Cherokee</td></tr>
+<tr><td colspan=2>Chorasmian</td></tr>
+<tr><td colspan=2>Common</td></tr>
+<tr><td colspan=2>Coptic</td></tr>
+<tr><td colspan=2>Cuneiform</td></tr>
+<tr><td colspan=2>Cypriot</td></tr>
+<tr><td colspan=2>Cypro_Minoan</td></tr>
+<tr><td colspan=2>Cyrillic</td></tr>
+<tr><td colspan=2>Deseret</td></tr>
+<tr><td colspan=2>Devanagari</td></tr>
+<tr><td colspan=2>Dives_Akuru</td></tr>
+<tr><td colspan=2>Dogra</td></tr>
+<tr><td colspan=2>Duployan</td></tr>
+<tr><td colspan=2>Egyptian_Hieroglyphs</td></tr>
+<tr><td colspan=2>Elbasan</td></tr>
+<tr><td colspan=2>Elymaic</td></tr>
+<tr><td colspan=2>Ethiopic</td></tr>
+<tr><td colspan=2>Georgian</td></tr>
+<tr><td colspan=2>Glagolitic</td></tr>
+<tr><td colspan=2>Gothic</td></tr>
+<tr><td colspan=2>Grantha</td></tr>
+<tr><td colspan=2>Greek</td></tr>
+<tr><td colspan=2>Gujarati</td></tr>
+<tr><td colspan=2>Gunjala_Gondi</td></tr>
+<tr><td colspan=2>Gurmukhi</td></tr>
+<tr><td colspan=2>Han</td></tr>
+<tr><td colspan=2>Hangul</td></tr>
+<tr><td colspan=2>Hanifi_Rohingya</td></tr>
+<tr><td colspan=2>Hanunoo</td></tr>
+<tr><td colspan=2>Hatran</td></tr>
+<tr><td colspan=2>Hebrew</td></tr>
+<tr><td colspan=2>Hiragana</td></tr>
+<tr><td colspan=2>Imperial_Aramaic</td></tr>
+<tr><td colspan=2>Inherited</td></tr>
+<tr><td colspan=2>Inscriptional_Pahlavi</td></tr>
+<tr><td colspan=2>Inscriptional_Parthian</td></tr>
+<tr><td colspan=2>Javanese</td></tr>
+<tr><td colspan=2>Kaithi</td></tr>
+<tr><td colspan=2>Kannada</td></tr>
+<tr><td colspan=2>Katakana</td></tr>
+<tr><td colspan=2>Kawi</td></tr>
+<tr><td colspan=2>Kayah_Li</td></tr>
+<tr><td colspan=2>Kharoshthi</td></tr>
+<tr><td colspan=2>Khitan_Small_Script</td></tr>
+<tr><td colspan=2>Khmer</td></tr>
+<tr><td colspan=2>Khojki</td></tr>
+<tr><td colspan=2>Khudawadi</td></tr>
+<tr><td colspan=2>Lao</td></tr>
+<tr><td colspan=2>Latin</td></tr>
+<tr><td colspan=2>Lepcha</td></tr>
+<tr><td colspan=2>Limbu</td></tr>
+<tr><td colspan=2>Linear_A</td></tr>
+<tr><td colspan=2>Linear_B</td></tr>
+<tr><td colspan=2>Lisu</td></tr>
+<tr><td colspan=2>Lycian</td></tr>
+<tr><td colspan=2>Lydian</td></tr>
+<tr><td colspan=2>Mahajani</td></tr>
+<tr><td colspan=2>Makasar</td></tr>
+<tr><td colspan=2>Malayalam</td></tr>
+<tr><td colspan=2>Mandaic</td></tr>
+<tr><td colspan=2>Manichaean</td></tr>
+<tr><td colspan=2>Marchen</td></tr>
+<tr><td colspan=2>Masaram_Gondi</td></tr>
+<tr><td colspan=2>Medefaidrin</td></tr>
+<tr><td colspan=2>Meetei_Mayek</td></tr>
+<tr><td colspan=2>Mende_Kikakui</td></tr>
+<tr><td colspan=2>Meroitic_Cursive</td></tr>
+<tr><td colspan=2>Meroitic_Hieroglyphs</td></tr>
+<tr><td colspan=2>Miao</td></tr>
+<tr><td colspan=2>Modi</td></tr>
+<tr><td colspan=2>Mongolian</td></tr>
+<tr><td colspan=2>Mro</td></tr>
+<tr><td colspan=2>Multani</td></tr>
+<tr><td colspan=2>Myanmar</td></tr>
+<tr><td colspan=2>Nabataean</td></tr>
+<tr><td colspan=2>Nag_Mundari</td></tr>
+<tr><td colspan=2>Nandinagari</td></tr>
+<tr><td colspan=2>New_Tai_Lue</td></tr>
+<tr><td colspan=2>Newa</td></tr>
+<tr><td colspan=2>Nko</td></tr>
+<tr><td colspan=2>Nushu</td></tr>
+<tr><td colspan=2>Nyiakeng_Puachue_Hmong</td></tr>
+<tr><td colspan=2>Ogham</td></tr>
+<tr><td colspan=2>Ol_Chiki</td></tr>
+<tr><td colspan=2>Old_Hungarian</td></tr>
+<tr><td colspan=2>Old_Italic</td></tr>
+<tr><td colspan=2>Old_North_Arabian</td></tr>
+<tr><td colspan=2>Old_Permic</td></tr>
+<tr><td colspan=2>Old_Persian</td></tr>
+<tr><td colspan=2>Old_Sogdian</td></tr>
+<tr><td colspan=2>Old_South_Arabian</td></tr>
+<tr><td colspan=2>Old_Turkic</td></tr>
+<tr><td colspan=2>Old_Uyghur</td></tr>
+<tr><td colspan=2>Oriya</td></tr>
+<tr><td colspan=2>Osage</td></tr>
+<tr><td colspan=2>Osmanya</td></tr>
+<tr><td colspan=2>Pahawh_Hmong</td></tr>
+<tr><td colspan=2>Palmyrene</td></tr>
+<tr><td colspan=2>Pau_Cin_Hau</td></tr>
+<tr><td colspan=2>Phags_Pa</td></tr>
+<tr><td colspan=2>Phoenician</td></tr>
+<tr><td colspan=2>Psalter_Pahlavi</td></tr>
+<tr><td colspan=2>Rejang</td></tr>
+<tr><td colspan=2>Runic</td></tr>
+<tr><td colspan=2>Samaritan</td></tr>
+<tr><td colspan=2>Saurashtra</td></tr>
+<tr><td colspan=2>Sharada</td></tr>
+<tr><td colspan=2>Shavian</td></tr>
+<tr><td colspan=2>Siddham</td></tr>
+<tr><td colspan=2>SignWriting</td></tr>
+<tr><td colspan=2>Sinhala</td></tr>
+<tr><td colspan=2>Sogdian</td></tr>
+<tr><td colspan=2>Sora_Sompeng</td></tr>
+<tr><td colspan=2>Soyombo</td></tr>
+<tr><td colspan=2>Sundanese</td></tr>
+<tr><td colspan=2>Syloti_Nagri</td></tr>
+<tr><td colspan=2>Syriac</td></tr>
+<tr><td colspan=2>Tagalog</td></tr>
+<tr><td colspan=2>Tagbanwa</td></tr>
+<tr><td colspan=2>Tai_Le</td></tr>
+<tr><td colspan=2>Tai_Tham</td></tr>
+<tr><td colspan=2>Tai_Viet</td></tr>
+<tr><td colspan=2>Takri</td></tr>
+<tr><td colspan=2>Tamil</td></tr>
+<tr><td colspan=2>Tangsa</td></tr>
+<tr><td colspan=2>Tangut</td></tr>
+<tr><td colspan=2>Telugu</td></tr>
+<tr><td colspan=2>Thaana</td></tr>
+<tr><td colspan=2>Thai</td></tr>
+<tr><td colspan=2>Tibetan</td></tr>
+<tr><td colspan=2>Tifinagh</td></tr>
+<tr><td colspan=2>Tirhuta</td></tr>
+<tr><td colspan=2>Toto</td></tr>
+<tr><td colspan=2>Ugaritic</td></tr>
+<tr><td colspan=2>Vai</td></tr>
+<tr><td colspan=2>Vithkuqi</td></tr>
+<tr><td colspan=2>Wancho</td></tr>
+<tr><td colspan=2>Warang_Citi</td></tr>
+<tr><td colspan=2>Yezidi</td></tr>
+<tr><td colspan=2>Yi</td></tr>
+<tr><td colspan=2>Zanabazar_Square</td></tr>
 <tr><td></td></tr>
 <tr><td colspan=2><b>Vim character classes:</b></td></tr>
 <tr><td><code><font color=#808080>\i</font></code></td><td>identifier character  <font size=-2>VIM</font></td></tr>
diff --git a/doc/syntax.txt b/doc/syntax.txt
index c87494e..5bb2067 100644
--- a/doc/syntax.txt
+++ b/doc/syntax.txt
@@ -253,17 +253,21 @@ Caucasian_Albanian
 Chakma
 Cham
 Cherokee
+Chorasmian
 Common
 Coptic
 Cuneiform
 Cypriot
+Cypro_Minoan
 Cyrillic
 Deseret
 Devanagari
+Dives_Akuru
 Dogra
 Duployan
 Egyptian_Hieroglyphs
 Elbasan
+Elymaic
 Ethiopic
 Georgian
 Glagolitic
@@ -288,8 +292,10 @@ Javanese
 Kaithi
 Kannada
 Katakana
+Kawi
 Kayah_Li
 Kharoshthi
+Khitan_Small_Script
 Khmer
 Khojki
 Khudawadi
@@ -321,10 +327,13 @@ Mro
 Multani
 Myanmar
 Nabataean
+Nag_Mundari
+Nandinagari
 New_Tai_Lue
 Newa
 Nko
 Nushu
+Nyiakeng_Puachue_Hmong
 Ogham
 Ol_Chiki
 Old_Hungarian
@@ -335,6 +344,7 @@ Old_Persian
 Old_Sogdian
 Old_South_Arabian
 Old_Turkic
+Old_Uyghur
 Oriya
 Osage
 Osmanya
@@ -366,6 +376,7 @@ Tai_Tham
 Tai_Viet
 Takri
 Tamil
+Tangsa
 Tangut
 Telugu
 Thaana
@@ -373,9 +384,13 @@ Thai
 Tibetan
 Tifinagh
 Tirhuta
+Toto
 Ugaritic
 Vai
+Vithkuqi
+Wancho
 Warang_Citi
+Yezidi
 Yi
 Zanabazar_Square
 
diff --git a/doc/xkcd.png b/doc/xkcd.png
deleted file mode 100644
index 6249e8e..0000000
Binary files a/doc/xkcd.png and /dev/null differ
diff --git a/kokoro/cmake.sh b/kokoro/cmake.sh
deleted file mode 100755
index 999fbfe..0000000
--- a/kokoro/cmake.sh
+++ /dev/null
@@ -1,25 +0,0 @@
-#!/bin/bash
-set -eux
-
-cd git/re2
-
-case "${KOKORO_JOB_NAME}" in
-  */windows-*)
-    CMAKE_G_A_FLAGS=('-G' 'Visual Studio 14 2015' '-A' 'x64')
-    ;;
-  *)
-    CMAKE_G_A_FLAGS=()
-    # Work around a bug in older versions of bash. :/
-    set +u
-    ;;
-esac
-
-cmake -D CMAKE_BUILD_TYPE=Debug "${CMAKE_G_A_FLAGS[@]}" .
-cmake --build . --config Debug --clean-first
-ctest -C Debug --output-on-failure -E 'dfa|exhaustive|random'
-
-cmake -D CMAKE_BUILD_TYPE=Release "${CMAKE_G_A_FLAGS[@]}" .
-cmake --build . --config Release --clean-first
-ctest -C Release --output-on-failure -E 'dfa|exhaustive|random'
-
-exit 0
diff --git a/kokoro/macos-bazel.cfg b/kokoro/macos-bazel.cfg
deleted file mode 100644
index 7901981..0000000
--- a/kokoro/macos-bazel.cfg
+++ /dev/null
@@ -1 +0,0 @@
-build_file: "re2/kokoro/macos-bazel.sh"
diff --git a/kokoro/macos-bazel.sh b/kokoro/macos-bazel.sh
deleted file mode 100755
index e43c852..0000000
--- a/kokoro/macos-bazel.sh
+++ /dev/null
@@ -1,4 +0,0 @@
-#!/bin/bash
-set -eux
-bash git/re2/kokoro/bazel.sh
-exit $?
diff --git a/kokoro/macos-cmake.cfg b/kokoro/macos-cmake.cfg
deleted file mode 100644
index 5c459e7..0000000
--- a/kokoro/macos-cmake.cfg
+++ /dev/null
@@ -1 +0,0 @@
-build_file: "re2/kokoro/macos-cmake.sh"
diff --git a/kokoro/macos-cmake.sh b/kokoro/macos-cmake.sh
deleted file mode 100755
index ef4b7dc..0000000
--- a/kokoro/macos-cmake.sh
+++ /dev/null
@@ -1,4 +0,0 @@
-#!/bin/bash
-set -eux
-bash git/re2/kokoro/cmake.sh
-exit $?
diff --git a/kokoro/ubuntu-bazel.cfg b/kokoro/ubuntu-bazel.cfg
deleted file mode 100644
index 884d14f..0000000
--- a/kokoro/ubuntu-bazel.cfg
+++ /dev/null
@@ -1 +0,0 @@
-build_file: "re2/kokoro/ubuntu-bazel.sh"
diff --git a/kokoro/ubuntu-bazel.sh b/kokoro/ubuntu-bazel.sh
deleted file mode 100755
index e43c852..0000000
--- a/kokoro/ubuntu-bazel.sh
+++ /dev/null
@@ -1,4 +0,0 @@
-#!/bin/bash
-set -eux
-bash git/re2/kokoro/bazel.sh
-exit $?
diff --git a/kokoro/windows-bazel.bat b/kokoro/windows-bazel.bat
deleted file mode 100755
index 283f8d2..0000000
--- a/kokoro/windows-bazel.bat
+++ /dev/null
@@ -1,2 +0,0 @@
-bash git/re2/kokoro/bazel.sh
-EXIT /B %ERRORLEVEL%
diff --git a/kokoro/windows-bazel.cfg b/kokoro/windows-bazel.cfg
deleted file mode 100644
index 18b1ed7..0000000
--- a/kokoro/windows-bazel.cfg
+++ /dev/null
@@ -1 +0,0 @@
-build_file: "re2/kokoro/windows-bazel.bat"
diff --git a/kokoro/windows-cmake.bat b/kokoro/windows-cmake.bat
deleted file mode 100755
index 77a4db9..0000000
--- a/kokoro/windows-cmake.bat
+++ /dev/null
@@ -1,2 +0,0 @@
-bash git/re2/kokoro/cmake.sh
-EXIT /B %ERRORLEVEL%
diff --git a/kokoro/windows-cmake.cfg b/kokoro/windows-cmake.cfg
deleted file mode 100644
index 4453eb6..0000000
--- a/kokoro/windows-cmake.cfg
+++ /dev/null
@@ -1 +0,0 @@
-build_file: "re2/kokoro/windows-cmake.bat"
diff --git a/libre2.symbols b/libre2.symbols
index 8308b64..93b71b4 100644
--- a/libre2.symbols
+++ b/libre2.symbols
@@ -11,6 +11,9 @@
 		# re2::FilteredRE2*
 		_ZN3re211FilteredRE2*;
 		_ZNK3re211FilteredRE2*;
+		# re2::re2_internal*
+		_ZN3re212re2_internal*;
+		_ZNK3re212re2_internal*;
 	local:
 		*;
 };
diff --git a/libre2.symbols.darwin b/libre2.symbols.darwin
index 31e8c52..41ac96f 100644
--- a/libre2.symbols.darwin
+++ b/libre2.symbols.darwin
@@ -10,3 +10,6 @@ __ZN3re2ls*
 # re2::FilteredRE2*
 __ZN3re211FilteredRE2*
 __ZNK3re211FilteredRE2*
+# re2::re2_internal*
+__ZN3re212re2_internal*
+__ZNK3re212re2_internal*
diff --git a/python/BUILD.bazel b/python/BUILD.bazel
new file mode 100644
index 0000000..73547c7
--- /dev/null
+++ b/python/BUILD.bazel
@@ -0,0 +1,36 @@
+# Copyright 2009 The RE2 Authors.  All Rights Reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+
+# Bazel (http://bazel.io/) BUILD file for RE2 Python.
+
+load("@pybind11_bazel//:build_defs.bzl", "pybind_extension")
+load("@rules_python//python:defs.bzl", "py_library", "py_test")
+
+pybind_extension(
+    name = "_re2",
+    srcs = ["_re2.cc"],
+    deps = [
+        "//:re2",
+        "@com_google_absl//absl/strings",
+    ],
+)
+
+py_library(
+    name = "re2",
+    srcs = ["re2.py"],
+    data = [":_re2.so"],
+    imports = ["."],
+    visibility = ["//visibility:public"],
+)
+
+py_test(
+    name = "re2_test",
+    size = "small",
+    srcs = ["re2_test.py"],
+    deps = [
+        ":re2",
+        "@io_abseil_py//absl/testing:absltest",
+        "@io_abseil_py//absl/testing:parameterized",
+    ],
+)
diff --git a/python/LICENSE b/python/LICENSE
new file mode 120000
index 0000000..ea5b606
--- /dev/null
+++ b/python/LICENSE
@@ -0,0 +1 @@
+../LICENSE
\ No newline at end of file
diff --git a/python/README b/python/README
new file mode 100644
index 0000000..782378f
--- /dev/null
+++ b/python/README
@@ -0,0 +1 @@
+Building requires Python 3 and pybind11 to be installed on your system.
diff --git a/python/_re2.cc b/python/_re2.cc
new file mode 100644
index 0000000..8564f8a
--- /dev/null
+++ b/python/_re2.cc
@@ -0,0 +1,338 @@
+// Copyright 2019 The RE2 Authors.  All Rights Reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+#include <memory>
+#include <string>
+#include <tuple>
+#include <utility>
+#include <vector>
+
+#include <pybind11/pybind11.h>
+#include <pybind11/stl.h>
+#include "absl/strings/string_view.h"
+#include "re2/filtered_re2.h"
+#include "re2/re2.h"
+#include "re2/set.h"
+
+#ifdef _WIN32
+#include <basetsd.h>
+#define ssize_t SSIZE_T
+#endif
+
+namespace re2_python {
+
+// This is conventional.
+namespace py = pybind11;
+
+// In terms of the pybind11 API, a py::buffer is merely a py::object that
+// supports the buffer interface/protocol and you must explicitly request
+// a py::buffer_info in order to access the actual bytes. Under the hood,
+// the py::buffer_info manages a reference count to the py::buffer, so it
+// must be constructed and subsequently destructed while holding the GIL.
+static inline absl::string_view FromBytes(const py::buffer_info& bytes) {
+  char* data = reinterpret_cast<char*>(bytes.ptr);
+  ssize_t size = bytes.size;
+  return absl::string_view(data, size);
+}
+
+static inline int OneCharLen(const char* ptr) {
+  return "\1\1\1\1\1\1\1\1\1\1\1\1\2\2\3\4"[(*ptr & 0xFF) >> 4];
+}
+
+// Helper function for when Python encodes str to bytes and then needs to
+// convert str offsets to bytes offsets. Assumes that text is valid UTF-8.
+ssize_t CharLenToBytes(py::buffer buffer, ssize_t pos, ssize_t len) {
+  auto bytes = buffer.request();
+  auto text = FromBytes(bytes);
+  auto ptr = text.data() + pos;
+  auto end = text.data() + text.size();
+  while (ptr < end && len > 0) {
+    ptr += OneCharLen(ptr);
+    --len;
+  }
+  return ptr - (text.data() + pos);
+}
+
+// Helper function for when Python decodes bytes to str and then needs to
+// convert bytes offsets to str offsets. Assumes that text is valid UTF-8.
+ssize_t BytesToCharLen(py::buffer buffer, ssize_t pos, ssize_t endpos) {
+  auto bytes = buffer.request();
+  auto text = FromBytes(bytes);
+  auto ptr = text.data() + pos;
+  auto end = text.data() + endpos;
+  ssize_t len = 0;
+  while (ptr < end) {
+    ptr += OneCharLen(ptr);
+    ++len;
+  }
+  return len;
+}
+
+std::unique_ptr<RE2> RE2InitShim(py::buffer buffer,
+                                 const RE2::Options& options) {
+  auto bytes = buffer.request();
+  auto pattern = FromBytes(bytes);
+  return std::make_unique<RE2>(pattern, options);
+}
+
+py::bytes RE2ErrorShim(const RE2& self) {
+  // Return std::string as bytes. That is, without decoding to str.
+  return self.error();
+}
+
+std::vector<std::pair<py::bytes, int>> RE2NamedCapturingGroupsShim(
+    const RE2& self) {
+  const int num_groups = self.NumberOfCapturingGroups();
+  std::vector<std::pair<py::bytes, int>> groups;
+  groups.reserve(num_groups);
+  for (const auto& it : self.NamedCapturingGroups()) {
+    groups.emplace_back(it.first, it.second);
+  }
+  return groups;
+}
+
+std::vector<int> RE2ProgramFanoutShim(const RE2& self) {
+  std::vector<int> histogram;
+  self.ProgramFanout(&histogram);
+  return histogram;
+}
+
+std::vector<int> RE2ReverseProgramFanoutShim(const RE2& self) {
+  std::vector<int> histogram;
+  self.ReverseProgramFanout(&histogram);
+  return histogram;
+}
+
+std::tuple<bool, py::bytes, py::bytes> RE2PossibleMatchRangeShim(
+    const RE2& self, int maxlen) {
+  std::string min, max;
+  // Return std::string as bytes. That is, without decoding to str.
+  return {self.PossibleMatchRange(&min, &max, maxlen), min, max};
+}
+
+std::vector<std::pair<ssize_t, ssize_t>> RE2MatchShim(const RE2& self,
+                                                      RE2::Anchor anchor,
+                                                      py::buffer buffer,
+                                                      ssize_t pos,
+                                                      ssize_t endpos) {
+  auto bytes = buffer.request();
+  auto text = FromBytes(bytes);
+  const int num_groups = self.NumberOfCapturingGroups() + 1;  // need $0
+  std::vector<absl::string_view> groups;
+  groups.resize(num_groups);
+  py::gil_scoped_release release_gil;
+  if (!self.Match(text, pos, endpos, anchor, groups.data(), groups.size())) {
+    // Ensure that groups are null before converting to spans!
+    for (auto& it : groups) {
+      it = absl::string_view();
+    }
+  }
+  std::vector<std::pair<ssize_t, ssize_t>> spans;
+  spans.reserve(num_groups);
+  for (const auto& it : groups) {
+    if (it.data() == NULL) {
+      spans.emplace_back(-1, -1);
+    } else {
+      spans.emplace_back(it.data() - text.data(),
+                         it.data() - text.data() + it.size());
+    }
+  }
+  return spans;
+}
+
+py::bytes RE2QuoteMetaShim(py::buffer buffer) {
+  auto bytes = buffer.request();
+  auto pattern = FromBytes(bytes);
+  // Return std::string as bytes. That is, without decoding to str.
+  return RE2::QuoteMeta(pattern);
+}
+
+class Set {
+ public:
+  Set(RE2::Anchor anchor, const RE2::Options& options)
+      : set_(options, anchor) {}
+
+  ~Set() = default;
+
+  // Not copyable or movable.
+  Set(const Set&) = delete;
+  Set& operator=(const Set&) = delete;
+
+  int Add(py::buffer buffer) {
+    auto bytes = buffer.request();
+    auto pattern = FromBytes(bytes);
+    int index = set_.Add(pattern, /*error=*/NULL);  // -1 on error
+    return index;
+  }
+
+  bool Compile() {
+    // Compiling can fail.
+    return set_.Compile();
+  }
+
+  std::vector<int> Match(py::buffer buffer) const {
+    auto bytes = buffer.request();
+    auto text = FromBytes(bytes);
+    std::vector<int> matches;
+    py::gil_scoped_release release_gil;
+    set_.Match(text, &matches);
+    return matches;
+  }
+
+ private:
+  RE2::Set set_;
+};
+
+class Filter {
+ public:
+  Filter() = default;
+  ~Filter() = default;
+
+  // Not copyable or movable.
+  Filter(const Filter&) = delete;
+  Filter& operator=(const Filter&) = delete;
+
+  int Add(py::buffer buffer, const RE2::Options& options) {
+    auto bytes = buffer.request();
+    auto pattern = FromBytes(bytes);
+    int index = -1;  // not clobbered on error
+    filter_.Add(pattern, options, &index);
+    return index;
+  }
+
+  bool Compile() {
+    std::vector<std::string> atoms;
+    filter_.Compile(&atoms);
+    RE2::Options options;
+    options.set_literal(true);
+    options.set_case_sensitive(false);
+    set_ = std::make_unique<RE2::Set>(options, RE2::UNANCHORED);
+    for (int i = 0; i < static_cast<int>(atoms.size()); ++i) {
+      if (set_->Add(atoms[i], /*error=*/NULL) != i) {
+        // Should never happen: the atom is a literal!
+        py::pybind11_fail("set_->Add() failed");
+      }
+    }
+    // Compiling can fail.
+    return set_->Compile();
+  }
+
+  std::vector<int> Match(py::buffer buffer, bool potential) const {
+    auto bytes = buffer.request();
+    auto text = FromBytes(bytes);
+    std::vector<int> atoms;
+    py::gil_scoped_release release_gil;
+    set_->Match(text, &atoms);
+    std::vector<int> matches;
+    if (potential) {
+      filter_.AllPotentials(atoms, &matches);
+    } else {
+      filter_.AllMatches(text, atoms, &matches);
+    }
+    return matches;
+  }
+
+  const RE2& GetRE2(int index) const {
+    return filter_.GetRE2(index);
+  }
+
+ private:
+  re2::FilteredRE2 filter_;
+  std::unique_ptr<RE2::Set> set_;
+};
+
+PYBIND11_MODULE(_re2, module) {
+  module.def("CharLenToBytes", &CharLenToBytes);
+  module.def("BytesToCharLen", &BytesToCharLen);
+
+  // CLASSES
+  //     class RE2
+  //         enum Anchor
+  //         class Options
+  //             enum Encoding
+  //     class Set
+  //     class Filter
+  py::class_<RE2> re2(module, "RE2");
+  py::enum_<RE2::Anchor> anchor(re2, "Anchor");
+  py::class_<RE2::Options> options(re2, "Options");
+  py::enum_<RE2::Options::Encoding> encoding(options, "Encoding");
+  py::class_<Set> set(module, "Set");
+  py::class_<Filter> filter(module, "Filter");
+
+  anchor.value("UNANCHORED", RE2::Anchor::UNANCHORED);
+  anchor.value("ANCHOR_START", RE2::Anchor::ANCHOR_START);
+  anchor.value("ANCHOR_BOTH", RE2::Anchor::ANCHOR_BOTH);
+
+  encoding.value("UTF8", RE2::Options::Encoding::EncodingUTF8);
+  encoding.value("LATIN1", RE2::Options::Encoding::EncodingLatin1);
+
+  options.def(py::init<>())
+      .def_property("max_mem",                          //
+                    &RE2::Options::max_mem,             //
+                    &RE2::Options::set_max_mem)         //
+      .def_property("encoding",                         //
+                    &RE2::Options::encoding,            //
+                    &RE2::Options::set_encoding)        //
+      .def_property("posix_syntax",                     //
+                    &RE2::Options::posix_syntax,        //
+                    &RE2::Options::set_posix_syntax)    //
+      .def_property("longest_match",                    //
+                    &RE2::Options::longest_match,       //
+                    &RE2::Options::set_longest_match)   //
+      .def_property("log_errors",                       //
+                    &RE2::Options::log_errors,          //
+                    &RE2::Options::set_log_errors)      //
+      .def_property("literal",                          //
+                    &RE2::Options::literal,             //
+                    &RE2::Options::set_literal)         //
+      .def_property("never_nl",                         //
+                    &RE2::Options::never_nl,            //
+                    &RE2::Options::set_never_nl)        //
+      .def_property("dot_nl",                           //
+                    &RE2::Options::dot_nl,              //
+                    &RE2::Options::set_dot_nl)          //
+      .def_property("never_capture",                    //
+                    &RE2::Options::never_capture,       //
+                    &RE2::Options::set_never_capture)   //
+      .def_property("case_sensitive",                   //
+                    &RE2::Options::case_sensitive,      //
+                    &RE2::Options::set_case_sensitive)  //
+      .def_property("perl_classes",                     //
+                    &RE2::Options::perl_classes,        //
+                    &RE2::Options::set_perl_classes)    //
+      .def_property("word_boundary",                    //
+                    &RE2::Options::word_boundary,       //
+                    &RE2::Options::set_word_boundary)   //
+      .def_property("one_line",                         //
+                    &RE2::Options::one_line,            //
+                    &RE2::Options::set_one_line);       //
+
+  re2.def(py::init(&RE2InitShim))
+      .def("ok", &RE2::ok)
+      .def("error", &RE2ErrorShim)
+      .def("options", &RE2::options)
+      .def("NumberOfCapturingGroups", &RE2::NumberOfCapturingGroups)
+      .def("NamedCapturingGroups", &RE2NamedCapturingGroupsShim)
+      .def("ProgramSize", &RE2::ProgramSize)
+      .def("ReverseProgramSize", &RE2::ReverseProgramSize)
+      .def("ProgramFanout", &RE2ProgramFanoutShim)
+      .def("ReverseProgramFanout", &RE2ReverseProgramFanoutShim)
+      .def("PossibleMatchRange", &RE2PossibleMatchRangeShim)
+      .def("Match", &RE2MatchShim)
+      .def_static("QuoteMeta", &RE2QuoteMetaShim);
+
+  set.def(py::init<RE2::Anchor, const RE2::Options&>())
+      .def("Add", &Set::Add)
+      .def("Compile", &Set::Compile)
+      .def("Match", &Set::Match);
+
+  filter.def(py::init<>())
+      .def("Add", &Filter::Add)
+      .def("Compile", &Filter::Compile)
+      .def("Match", &Filter::Match)
+      .def("GetRE2", &Filter::GetRE2,
+           py::return_value_policy::reference_internal);
+}
+
+}  // namespace re2_python
diff --git a/python/re2.py b/python/re2.py
new file mode 100644
index 0000000..8a6d985
--- /dev/null
+++ b/python/re2.py
@@ -0,0 +1,582 @@
+# Copyright 2019 The RE2 Authors.  All Rights Reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+r"""A drop-in replacement for the re module.
+
+It uses RE2 under the hood, of course, so various PCRE features
+(e.g. backreferences, look-around assertions) are not supported.
+See https://github.com/google/re2/wiki/Syntax for the canonical
+reference, but known syntactic "gotchas" relative to Python are:
+
+  * PCRE supports \Z and \z; RE2 supports \z; Python supports \z,
+    but calls it \Z. You must rewrite \Z to \z in pattern strings.
+
+Known differences between this module's API and the re module's API:
+
+  * The error class does not provide any error information as attributes.
+  * The Options class replaces the re module's flags with RE2's options as
+    gettable/settable properties. Please see re2.h for their documentation.
+  * The pattern string and the input string do not have to be the same type.
+    Any str will be encoded to UTF-8.
+  * The pattern string cannot be str if the options specify Latin-1 encoding.
+
+This module's LRU cache contains a maximum of 128 regular expression objects.
+Each regular expression object's underlying RE2 object uses a maximum of 8MiB
+of memory (by default). Hence, this module's LRU cache uses a maximum of 1GiB
+of memory (by default), but in most cases, it should use much less than that.
+"""
+
+import codecs
+import functools
+import itertools
+
+import _re2
+
+
+class error(Exception):
+  pass
+
+
+class Options(_re2.RE2.Options):
+
+  __slots__ = ()
+
+  NAMES = (
+      'max_mem',
+      'encoding',
+      'posix_syntax',
+      'longest_match',
+      'log_errors',
+      'literal',
+      'never_nl',
+      'dot_nl',
+      'never_capture',
+      'case_sensitive',
+      'perl_classes',
+      'word_boundary',
+      'one_line',
+  )
+
+
+def compile(pattern, options=None):
+  if isinstance(pattern, _Regexp):
+    if options:
+      raise error('pattern is already compiled, so '
+                  'options may not be specified')
+    pattern = pattern._pattern
+  options = options or Options()
+  values = tuple(getattr(options, name) for name in Options.NAMES)
+  return _Regexp._make(pattern, values)
+
+
+def search(pattern, text, options=None):
+  return compile(pattern, options=options).search(text)
+
+
+def match(pattern, text, options=None):
+  return compile(pattern, options=options).match(text)
+
+
+def fullmatch(pattern, text, options=None):
+  return compile(pattern, options=options).fullmatch(text)
+
+
+def finditer(pattern, text, options=None):
+  return compile(pattern, options=options).finditer(text)
+
+
+def findall(pattern, text, options=None):
+  return compile(pattern, options=options).findall(text)
+
+
+def split(pattern, text, maxsplit=0, options=None):
+  return compile(pattern, options=options).split(text, maxsplit)
+
+
+def subn(pattern, repl, text, count=0, options=None):
+  return compile(pattern, options=options).subn(repl, text, count)
+
+
+def sub(pattern, repl, text, count=0, options=None):
+  return compile(pattern, options=options).sub(repl, text, count)
+
+
+def _encode(t):
+  return t.encode(encoding='utf-8')
+
+
+def _decode(b):
+  return b.decode(encoding='utf-8')
+
+
+def escape(pattern):
+  if isinstance(pattern, str):
+    encoded_pattern = _encode(pattern)
+    escaped = _re2.RE2.QuoteMeta(encoded_pattern)
+    decoded_escaped = _decode(escaped)
+    return decoded_escaped
+  else:
+    escaped = _re2.RE2.QuoteMeta(pattern)
+    return escaped
+
+
+def purge():
+  return _Regexp._make.cache_clear()
+
+
+_Anchor = _re2.RE2.Anchor
+_NULL_SPAN = (-1, -1)
+
+
+class _Regexp(object):
+
+  __slots__ = ('_pattern', '_regexp')
+
+  @classmethod
+  @functools.lru_cache(typed=True)
+  def _make(cls, pattern, values):
+    options = Options()
+    for name, value in zip(Options.NAMES, values):
+      setattr(options, name, value)
+    return cls(pattern, options)
+
+  def __init__(self, pattern, options):
+    self._pattern = pattern
+    if isinstance(self._pattern, str):
+      if options.encoding == Options.Encoding.LATIN1:
+        raise error('string type of pattern is str, but '
+                    'encoding specified in options is LATIN1')
+      encoded_pattern = _encode(self._pattern)
+      self._regexp = _re2.RE2(encoded_pattern, options)
+    else:
+      self._regexp = _re2.RE2(self._pattern, options)
+    if not self._regexp.ok():
+      raise error(self._regexp.error())
+
+  def __getstate__(self):
+    options = {name: getattr(self.options, name) for name in Options.NAMES}
+    return self._pattern, options
+
+  def __setstate__(self, state):
+    pattern, options = state
+    values = tuple(options[name] for name in Options.NAMES)
+    other = _Regexp._make(pattern, values)
+    self._pattern = other._pattern
+    self._regexp = other._regexp
+
+  def _match(self, anchor, text, pos=None, endpos=None):
+    pos = 0 if pos is None else max(0, min(pos, len(text)))
+    endpos = len(text) if endpos is None else max(0, min(endpos, len(text)))
+    if pos > endpos:
+      return
+    if isinstance(text, str):
+      encoded_text = _encode(text)
+      encoded_pos = _re2.CharLenToBytes(encoded_text, 0, pos)
+      if endpos == len(text):
+        # This is the common case.
+        encoded_endpos = len(encoded_text)
+      else:
+        encoded_endpos = encoded_pos + _re2.CharLenToBytes(
+            encoded_text, encoded_pos, endpos - pos)
+      decoded_offsets = {0: 0}
+      last_offset = 0
+      while True:
+        spans = self._regexp.Match(anchor, encoded_text, encoded_pos,
+                                   encoded_endpos)
+        if spans[0] == _NULL_SPAN:
+          break
+
+        # This algorithm is linear in the length of encoded_text. Specifically,
+        # no matter how many groups there are for a given regular expression or
+        # how many iterations through the loop there are for a given generator,
+        # this algorithm uses a single, straightforward pass over encoded_text.
+        offsets = sorted(set(itertools.chain(*spans)))
+        if offsets[0] == -1:
+          offsets = offsets[1:]
+        # Discard the rest of the items because they are useless now - and we
+        # could accumulate one item per str offset in the pathological case!
+        decoded_offsets = {last_offset: decoded_offsets[last_offset]}
+        for offset in offsets:
+          decoded_offsets[offset] = (
+              decoded_offsets[last_offset] +
+              _re2.BytesToCharLen(encoded_text, last_offset, offset))
+          last_offset = offset
+
+        def decode(span):
+          if span == _NULL_SPAN:
+            return span
+          return decoded_offsets[span[0]], decoded_offsets[span[1]]
+
+        decoded_spans = [decode(span) for span in spans]
+        yield _Match(self, text, pos, endpos, decoded_spans)
+        if encoded_pos == encoded_endpos:
+          break
+        elif encoded_pos == spans[0][1]:
+          # We matched the empty string at encoded_pos and would be stuck, so
+          # in order to make forward progress, increment the str offset.
+          encoded_pos += _re2.CharLenToBytes(encoded_text, encoded_pos, 1)
+        else:
+          encoded_pos = spans[0][1]
+    else:
+      while True:
+        spans = self._regexp.Match(anchor, text, pos, endpos)
+        if spans[0] == _NULL_SPAN:
+          break
+        yield _Match(self, text, pos, endpos, spans)
+        if pos == endpos:
+          break
+        elif pos == spans[0][1]:
+          # We matched the empty string at pos and would be stuck, so in order
+          # to make forward progress, increment the bytes offset.
+          pos += 1
+        else:
+          pos = spans[0][1]
+
+  def search(self, text, pos=None, endpos=None):
+    return next(self._match(_Anchor.UNANCHORED, text, pos, endpos), None)
+
+  def match(self, text, pos=None, endpos=None):
+    return next(self._match(_Anchor.ANCHOR_START, text, pos, endpos), None)
+
+  def fullmatch(self, text, pos=None, endpos=None):
+    return next(self._match(_Anchor.ANCHOR_BOTH, text, pos, endpos), None)
+
+  def finditer(self, text, pos=None, endpos=None):
+    return self._match(_Anchor.UNANCHORED, text, pos, endpos)
+
+  def findall(self, text, pos=None, endpos=None):
+    empty = type(text)()
+    items = []
+    for match in self.finditer(text, pos, endpos):
+      if not self.groups:
+        item = match.group()
+      elif self.groups == 1:
+        item = match.groups(default=empty)[0]
+      else:
+        item = match.groups(default=empty)
+      items.append(item)
+    return items
+
+  def _split(self, cb, text, maxsplit=0):
+    if maxsplit < 0:
+      return [text], 0
+    elif maxsplit > 0:
+      matchiter = itertools.islice(self.finditer(text), maxsplit)
+    else:
+      matchiter = self.finditer(text)
+    pieces = []
+    end = 0
+    numsplit = 0
+    for match in matchiter:
+      pieces.append(text[end:match.start()])
+      pieces.extend(cb(match))
+      end = match.end()
+      numsplit += 1
+    pieces.append(text[end:])
+    return pieces, numsplit
+
+  def split(self, text, maxsplit=0):
+    cb = lambda match: [match[group] for group in range(1, self.groups + 1)]
+    pieces, _ = self._split(cb, text, maxsplit)
+    return pieces
+
+  def subn(self, repl, text, count=0):
+    cb = lambda match: [repl(match) if callable(repl) else match.expand(repl)]
+    empty = type(text)()
+    pieces, numsplit = self._split(cb, text, count)
+    joined_pieces = empty.join(pieces)
+    return joined_pieces, numsplit
+
+  def sub(self, repl, text, count=0):
+    joined_pieces, _ = self.subn(repl, text, count)
+    return joined_pieces
+
+  @property
+  def pattern(self):
+    return self._pattern
+
+  @property
+  def options(self):
+    return self._regexp.options()
+
+  @property
+  def groups(self):
+    return self._regexp.NumberOfCapturingGroups()
+
+  @property
+  def groupindex(self):
+    groups = self._regexp.NamedCapturingGroups()
+    if isinstance(self._pattern, str):
+      decoded_groups = [(_decode(group), index) for group, index in groups]
+      return dict(decoded_groups)
+    else:
+      return dict(groups)
+
+  @property
+  def programsize(self):
+    return self._regexp.ProgramSize()
+
+  @property
+  def reverseprogramsize(self):
+    return self._regexp.ReverseProgramSize()
+
+  @property
+  def programfanout(self):
+    return self._regexp.ProgramFanout()
+
+  @property
+  def reverseprogramfanout(self):
+    return self._regexp.ReverseProgramFanout()
+
+  def possiblematchrange(self, maxlen):
+    ok, min, max = self._regexp.PossibleMatchRange(maxlen)
+    if not ok:
+      raise error('failed to compute match range')
+    return min, max
+
+
+class _Match(object):
+
+  __slots__ = ('_regexp', '_text', '_pos', '_endpos', '_spans')
+
+  def __init__(self, regexp, text, pos, endpos, spans):
+    self._regexp = regexp
+    self._text = text
+    self._pos = pos
+    self._endpos = endpos
+    self._spans = spans
+
+  # Python prioritises three-digit octal numbers over group escapes.
+  # For example, \100 should not be handled the same way as \g<10>0.
+  _OCTAL_RE = compile('\\\\[0-7][0-7][0-7]')
+
+  # Python supports \1 through \99 (inclusive) and \g<...> syntax.
+  _GROUP_RE = compile('\\\\[1-9][0-9]?|\\\\g<\\w+>')
+
+  @classmethod
+  @functools.lru_cache(typed=True)
+  def _split(cls, template):
+    if isinstance(template, str):
+      backslash = '\\'
+    else:
+      backslash = b'\\'
+    empty = type(template)()
+    pieces = [empty]
+    index = template.find(backslash)
+    while index != -1:
+      piece, template = template[:index], template[index:]
+      pieces[-1] += piece
+      octal_match = cls._OCTAL_RE.match(template)
+      group_match = cls._GROUP_RE.match(template)
+      if (not octal_match) and group_match:
+        index = group_match.end()
+        piece, template = template[:index], template[index:]
+        pieces.extend((piece, empty))
+      else:
+        # 2 isn't enough for \o, \x, \N, \u and \U escapes, but none of those
+        # should contain backslashes, so break them here and then fix them at
+        # the beginning of the next loop iteration or right before returning.
+        index = 2
+        piece, template = template[:index], template[index:]
+        pieces[-1] += piece
+      index = template.find(backslash)
+    pieces[-1] += template
+    return pieces
+
+  def expand(self, template):
+    if isinstance(template, str):
+      unescape = codecs.unicode_escape_decode
+    else:
+      unescape = codecs.escape_decode
+    empty = type(template)()
+    # Make a copy so that we don't clobber the cached pieces!
+    pieces = list(self._split(template))
+    for index, piece in enumerate(pieces):
+      if not index % 2:
+        pieces[index], _ = unescape(piece)
+      else:
+        if len(piece) <= 3:  # \1 through \99 (inclusive)
+          group = int(piece[1:])
+        else:  # \g<...>
+          group = piece[3:-1]
+          try:
+            group = int(group)
+          except ValueError:
+            pass
+        pieces[index] = self.__getitem__(group) or empty
+    joined_pieces = empty.join(pieces)
+    return joined_pieces
+
+  def __getitem__(self, group):
+    if not isinstance(group, int):
+      try:
+        group = self._regexp.groupindex[group]
+      except KeyError:
+        raise IndexError('bad group name')
+    if not 0 <= group <= self._regexp.groups:
+      raise IndexError('bad group index')
+    span = self._spans[group]
+    if span == _NULL_SPAN:
+      return None
+    return self._text[span[0]:span[1]]
+
+  def group(self, *groups):
+    if not groups:
+      groups = (0,)
+    items = (self.__getitem__(group) for group in groups)
+    return next(items) if len(groups) == 1 else tuple(items)
+
+  def groups(self, default=None):
+    items = []
+    for group in range(1, self._regexp.groups + 1):
+      item = self.__getitem__(group)
+      items.append(default if item is None else item)
+    return tuple(items)
+
+  def groupdict(self, default=None):
+    items = []
+    for group, index in self._regexp.groupindex.items():
+      item = self.__getitem__(index)
+      items.append((group, default) if item is None else (group, item))
+    return dict(items)
+
+  def start(self, group=0):
+    if not 0 <= group <= self._regexp.groups:
+      raise IndexError('bad group index')
+    return self._spans[group][0]
+
+  def end(self, group=0):
+    if not 0 <= group <= self._regexp.groups:
+      raise IndexError('bad group index')
+    return self._spans[group][1]
+
+  def span(self, group=0):
+    if not 0 <= group <= self._regexp.groups:
+      raise IndexError('bad group index')
+    return self._spans[group]
+
+  @property
+  def re(self):
+    return self._regexp
+
+  @property
+  def string(self):
+    return self._text
+
+  @property
+  def pos(self):
+    return self._pos
+
+  @property
+  def endpos(self):
+    return self._endpos
+
+  @property
+  def lastindex(self):
+    max_end = -1
+    max_group = None
+    # We look for the rightmost right parenthesis by keeping the first group
+    # that ends at max_end because that is the leftmost/outermost group when
+    # there are nested groups!
+    for group in range(1, self._regexp.groups + 1):
+      end = self._spans[group][1]
+      if max_end < end:
+        max_end = end
+        max_group = group
+    return max_group
+
+  @property
+  def lastgroup(self):
+    max_group = self.lastindex
+    if not max_group:
+      return None
+    for group, index in self._regexp.groupindex.items():
+      if max_group == index:
+        return group
+    return None
+
+
+class Set(object):
+  """A Pythonic wrapper around RE2::Set."""
+
+  __slots__ = ('_set')
+
+  def __init__(self, anchor, options=None):
+    options = options or Options()
+    self._set = _re2.Set(anchor, options)
+
+  @classmethod
+  def SearchSet(cls, options=None):
+    return cls(_Anchor.UNANCHORED, options=options)
+
+  @classmethod
+  def MatchSet(cls, options=None):
+    return cls(_Anchor.ANCHOR_START, options=options)
+
+  @classmethod
+  def FullMatchSet(cls, options=None):
+    return cls(_Anchor.ANCHOR_BOTH, options=options)
+
+  def Add(self, pattern):
+    if isinstance(pattern, str):
+      encoded_pattern = _encode(pattern)
+      index = self._set.Add(encoded_pattern)
+    else:
+      index = self._set.Add(pattern)
+    if index == -1:
+      raise error('failed to add %r to Set' % pattern)
+    return index
+
+  def Compile(self):
+    if not self._set.Compile():
+      raise error('failed to compile Set')
+
+  def Match(self, text):
+    if isinstance(text, str):
+      encoded_text = _encode(text)
+      matches = self._set.Match(encoded_text)
+    else:
+      matches = self._set.Match(text)
+    return matches or None
+
+
+class Filter(object):
+  """A Pythonic wrapper around FilteredRE2."""
+
+  __slots__ = ('_filter', '_patterns')
+
+  def __init__(self):
+    self._filter = _re2.Filter()
+    self._patterns = []
+
+  def Add(self, pattern, options=None):
+    options = options or Options()
+    if isinstance(pattern, str):
+      encoded_pattern = _encode(pattern)
+      index = self._filter.Add(encoded_pattern, options)
+    else:
+      index = self._filter.Add(pattern, options)
+    if index == -1:
+      raise error('failed to add %r to Filter' % pattern)
+    self._patterns.append(pattern)
+    return index
+
+  def Compile(self):
+    if not self._filter.Compile():
+      raise error('failed to compile Filter')
+
+  def Match(self, text, potential=False):
+    if isinstance(text, str):
+      encoded_text = _encode(text)
+      matches = self._filter.Match(encoded_text, potential)
+    else:
+      matches = self._filter.Match(text, potential)
+    return matches or None
+
+  def re(self, index):
+    if not 0 <= index < len(self._patterns):
+      raise IndexError('bad index')
+    proxy = object.__new__(_Regexp)
+    proxy._pattern = self._patterns[index]
+    proxy._regexp = self._filter.GetRE2(index)
+    return proxy
diff --git a/python/re2_test.py b/python/re2_test.py
new file mode 100644
index 0000000..86aa9ae
--- /dev/null
+++ b/python/re2_test.py
@@ -0,0 +1,482 @@
+# Copyright 2019 The RE2 Authors.  All Rights Reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+"""Tests for google3.third_party.re2.python.re2."""
+
+import collections
+import pickle
+import re
+
+from absl.testing import absltest
+from absl.testing import parameterized
+import re2
+
+
+class OptionsTest(parameterized.TestCase):
+
+  @parameterized.parameters(*re2.Options.NAMES)
+  def test_option(self, name):
+    options = re2.Options()
+    value = getattr(options, name)
+    if isinstance(value, re2.Options.Encoding):
+      value = next(v for v in type(value).__members__.values() if v != value)
+    elif isinstance(value, bool):
+      value = not value
+    elif isinstance(value, int):
+      value = value + 1
+    else:
+      raise TypeError('option {!r}: {!r} {!r}'.format(name, type(value), value))
+    setattr(options, name, value)
+    self.assertEqual(value, getattr(options, name))
+
+
+class Re2CompileTest(parameterized.TestCase):
+  """Contains tests that apply to the re2 module only.
+
+  We disagree with Python on the string types of group names,
+  so there is no point attempting to verify consistency.
+  """
+
+  @parameterized.parameters(
+      (u'(foo*)(?P<bar>qux+)', 2, [(u'bar', 2)]),
+      (b'(foo*)(?P<bar>qux+)', 2, [(b'bar', 2)]),
+      (u'(foo*)(?P<>qux+)', 2, [(u'', 2)]),
+  )
+  def test_compile(self, pattern, expected_groups, expected_groupindex):
+    regexp = re2.compile(pattern)
+    self.assertIs(regexp, re2.compile(pattern))  # cached
+    self.assertIs(regexp, re2.compile(regexp))  # cached
+    with self.assertRaisesRegex(re2.error,
+                                ('pattern is already compiled, so '
+                                 'options may not be specified')):
+      options = re2.Options()
+      options.log_errors = not options.log_errors
+      re2.compile(regexp, options=options)
+    self.assertIsNotNone(regexp.options)
+    self.assertEqual(expected_groups, regexp.groups)
+    self.assertDictEqual(dict(expected_groupindex), regexp.groupindex)
+
+  def test_compile_with_options(self):
+    options = re2.Options()
+    options.max_mem = 100
+    with self.assertRaisesRegex(re2.error, 'pattern too large'):
+      re2.compile('.{1000}', options=options)
+
+  def test_programsize_reverseprogramsize(self):
+    regexp = re2.compile('a+b')
+    self.assertEqual(7, regexp.programsize)
+    self.assertEqual(7, regexp.reverseprogramsize)
+
+  def test_programfanout_reverseprogramfanout(self):
+    regexp = re2.compile('a+b')
+    self.assertListEqual([1, 1], regexp.programfanout)
+    self.assertListEqual([3], regexp.reverseprogramfanout)
+
+  @parameterized.parameters(
+      (u'abc', 0, None),
+      (b'abc', 0, None),
+      (u'abc', 10, (b'abc', b'abc')),
+      (b'abc', 10, (b'abc', b'abc')),
+      (u'ab*c', 10, (b'ab', b'ac')),
+      (b'ab*c', 10, (b'ab', b'ac')),
+      (u'ab+c', 10, (b'abb', b'abc')),
+      (b'ab+c', 10, (b'abb', b'abc')),
+      (u'ab?c', 10, (b'abc', b'ac')),
+      (b'ab?c', 10, (b'abc', b'ac')),
+      (u'.*', 10, (b'', b'\xf4\xbf\xbf\xc0')),
+      (b'.*', 10, None),
+      (u'\\C*', 10, None),
+      (b'\\C*', 10, None),
+  )
+  def test_possiblematchrange(self, pattern, maxlen, expected_min_max):
+    # For brevity, the string type of pattern determines the encoding.
+    # It would otherwise be possible to have bytes with UTF8, but as per
+    # the module docstring, it isn't permitted to have str with LATIN1.
+    options = re2.Options()
+    if isinstance(pattern, str):
+      options.encoding = re2.Options.Encoding.UTF8
+    else:
+      options.encoding = re2.Options.Encoding.LATIN1
+    regexp = re2.compile(pattern, options=options)
+    if expected_min_max:
+      self.assertEqual(expected_min_max, regexp.possiblematchrange(maxlen))
+    else:
+      with self.assertRaisesRegex(re2.error, 'failed to compute match range'):
+        regexp.possiblematchrange(maxlen)
+
+
+Params = collections.namedtuple(
+    'Params', ('pattern', 'text', 'spans', 'search', 'match', 'fullmatch'))
+
+PARAMS = [
+    Params(u'\\d+', u'Hello, world.', None, False, False, False),
+    Params(b'\\d+', b'Hello, world.', None, False, False, False),
+    Params(u'\\s+', u'Hello, world.', [(6, 7)], True, False, False),
+    Params(b'\\s+', b'Hello, world.', [(6, 7)], True, False, False),
+    Params(u'\\w+', u'Hello, world.', [(0, 5)], True, True, False),
+    Params(b'\\w+', b'Hello, world.', [(0, 5)], True, True, False),
+    Params(u'(\\d+)?', u'Hello, world.', [(0, 0), (-1, -1)], True, True, False),
+    Params(b'(\\d+)?', b'Hello, world.', [(0, 0), (-1, -1)], True, True, False),
+    Params(u'youtube(_device|_md|_gaia|_multiday|_multiday_gaia)?',
+           u'youtube_ads', [(0, 7), (-1, -1)], True, True, False),
+    Params(b'youtube(_device|_md|_gaia|_multiday|_multiday_gaia)?',
+           b'youtube_ads', [(0, 7), (-1, -1)], True, True, False),
+]
+
+
+def upper(match):
+  return match.group().upper()
+
+
+class ReRegexpTest(parameterized.TestCase):
+  """Contains tests that apply to the re and re2 modules."""
+
+  MODULE = re
+
+  @parameterized.parameters((p.pattern,) for p in PARAMS)
+  def test_pickle(self, pattern):
+    regexp = self.MODULE.compile(pattern)
+    rick = pickle.loads(pickle.dumps(regexp))
+    self.assertEqual(regexp.pattern, rick.pattern)
+
+  @parameterized.parameters(
+      (p.pattern, p.text, (p.spans if p.search else None)) for p in PARAMS)
+  def test_search(self, pattern, text, expected_spans):
+    match = self.MODULE.search(pattern, text)
+    if expected_spans is None:
+      self.assertIsNone(match)
+    else:
+      spans = [match.span(group) for group in range(match.re.groups + 1)]
+      self.assertListEqual(expected_spans, spans)
+
+  def test_search_with_pos_and_endpos(self):
+    regexp = self.MODULE.compile(u'.+')  # empty string NOT allowed
+    text = u'I \u2665 RE2!'
+    # Note that len(text) is the position of the empty string at the end of
+    # text, so range() stops at len(text) + 1 in order to include len(text).
+    for pos in range(len(text) + 1):
+      for endpos in range(pos, len(text) + 1):
+        match = regexp.search(text, pos=pos, endpos=endpos)
+        if pos == endpos:
+          self.assertIsNone(match)
+        else:
+          self.assertEqual(pos, match.pos)
+          self.assertEqual(endpos, match.endpos)
+          self.assertEqual(pos, match.start())
+          self.assertEqual(endpos, match.end())
+          self.assertTupleEqual((pos, endpos), match.span())
+
+  def test_search_with_bogus_pos_and_endpos(self):
+    regexp = self.MODULE.compile(u'.*')  # empty string allowed
+    text = u'I \u2665 RE2!'
+
+    match = regexp.search(text, pos=-100)
+    self.assertEqual(0, match.pos)
+    match = regexp.search(text, pos=100)
+    self.assertEqual(8, match.pos)
+
+    match = regexp.search(text, endpos=-100)
+    self.assertEqual(0, match.endpos)
+    match = regexp.search(text, endpos=100)
+    self.assertEqual(8, match.endpos)
+
+    match = regexp.search(text, pos=100, endpos=-100)
+    self.assertIsNone(match)
+
+  @parameterized.parameters(
+      (p.pattern, p.text, (p.spans if p.match else None)) for p in PARAMS)
+  def test_match(self, pattern, text, expected_spans):
+    match = self.MODULE.match(pattern, text)
+    if expected_spans is None:
+      self.assertIsNone(match)
+    else:
+      spans = [match.span(group) for group in range(match.re.groups + 1)]
+      self.assertListEqual(expected_spans, spans)
+
+  @parameterized.parameters(
+      (p.pattern, p.text, (p.spans if p.fullmatch else None)) for p in PARAMS)
+  def test_fullmatch(self, pattern, text, expected_spans):
+    match = self.MODULE.fullmatch(pattern, text)
+    if expected_spans is None:
+      self.assertIsNone(match)
+    else:
+      spans = [match.span(group) for group in range(match.re.groups + 1)]
+      self.assertListEqual(expected_spans, spans)
+
+  @parameterized.parameters(
+      (u'', u'', [(0, 0)]),
+      (b'', b'', [(0, 0)]),
+      (u'', u'x', [(0, 0), (1, 1)]),
+      (b'', b'x', [(0, 0), (1, 1)]),
+      (u'', u'xy', [(0, 0), (1, 1), (2, 2)]),
+      (b'', b'xy', [(0, 0), (1, 1), (2, 2)]),
+      (u'.', u'xy', [(0, 1), (1, 2)]),
+      (b'.', b'xy', [(0, 1), (1, 2)]),
+      (u'x', u'xy', [(0, 1)]),
+      (b'x', b'xy', [(0, 1)]),
+      (u'y', u'xy', [(1, 2)]),
+      (b'y', b'xy', [(1, 2)]),
+      (u'z', u'xy', []),
+      (b'z', b'xy', []),
+      (u'\\w*', u'Hello, world.', [(0, 5), (5, 5), (6, 6), (7, 12), (12, 12),
+                                   (13, 13)]),
+      (b'\\w*', b'Hello, world.', [(0, 5), (5, 5), (6, 6), (7, 12), (12, 12),
+                                   (13, 13)]),
+  )
+  def test_finditer(self, pattern, text, expected_matches):
+    matches = [match.span() for match in self.MODULE.finditer(pattern, text)]
+    self.assertListEqual(expected_matches, matches)
+
+  @parameterized.parameters(
+      (u'\\w\\w+', u'Hello, world.', [u'Hello', u'world']),
+      (b'\\w\\w+', b'Hello, world.', [b'Hello', b'world']),
+      (u'(\\w)\\w+', u'Hello, world.', [u'H', u'w']),
+      (b'(\\w)\\w+', b'Hello, world.', [b'H', b'w']),
+      (u'(\\w)(\\w+)', u'Hello, world.', [(u'H', u'ello'), (u'w', u'orld')]),
+      (b'(\\w)(\\w+)', b'Hello, world.', [(b'H', b'ello'), (b'w', b'orld')]),
+      (u'(\\w)(\\w+)?', u'Hello, w.', [(u'H', u'ello'), (u'w', u'')]),
+      (b'(\\w)(\\w+)?', b'Hello, w.', [(b'H', b'ello'), (b'w', b'')]),
+  )
+  def test_findall(self, pattern, text, expected_matches):
+    matches = self.MODULE.findall(pattern, text)
+    self.assertListEqual(expected_matches, matches)
+
+  @parameterized.parameters(
+      (u'\\W+', u'Hello, world.', -1, [u'Hello, world.']),
+      (b'\\W+', b'Hello, world.', -1, [b'Hello, world.']),
+      (u'\\W+', u'Hello, world.', 0, [u'Hello', u'world', u'']),
+      (b'\\W+', b'Hello, world.', 0, [b'Hello', b'world', b'']),
+      (u'\\W+', u'Hello, world.', 1, [u'Hello', u'world.']),
+      (b'\\W+', b'Hello, world.', 1, [b'Hello', b'world.']),
+      (u'(\\W+)', u'Hello, world.', -1, [u'Hello, world.']),
+      (b'(\\W+)', b'Hello, world.', -1, [b'Hello, world.']),
+      (u'(\\W+)', u'Hello, world.', 0, [u'Hello', u', ', u'world', u'.', u'']),
+      (b'(\\W+)', b'Hello, world.', 0, [b'Hello', b', ', b'world', b'.', b'']),
+      (u'(\\W+)', u'Hello, world.', 1, [u'Hello', u', ', u'world.']),
+      (b'(\\W+)', b'Hello, world.', 1, [b'Hello', b', ', b'world.']),
+  )
+  def test_split(self, pattern, text, maxsplit, expected_pieces):
+    pieces = self.MODULE.split(pattern, text, maxsplit)
+    self.assertListEqual(expected_pieces, pieces)
+
+  @parameterized.parameters(
+      (u'\\w+', upper, u'Hello, world.', -1, u'Hello, world.', 0),
+      (b'\\w+', upper, b'Hello, world.', -1, b'Hello, world.', 0),
+      (u'\\w+', upper, u'Hello, world.', 0, u'HELLO, WORLD.', 2),
+      (b'\\w+', upper, b'Hello, world.', 0, b'HELLO, WORLD.', 2),
+      (u'\\w+', upper, u'Hello, world.', 1, u'HELLO, world.', 1),
+      (b'\\w+', upper, b'Hello, world.', 1, b'HELLO, world.', 1),
+      (u'\\w+', u'MEEP', u'Hello, world.', -1, u'Hello, world.', 0),
+      (b'\\w+', b'MEEP', b'Hello, world.', -1, b'Hello, world.', 0),
+      (u'\\w+', u'MEEP', u'Hello, world.', 0, u'MEEP, MEEP.', 2),
+      (b'\\w+', b'MEEP', b'Hello, world.', 0, b'MEEP, MEEP.', 2),
+      (u'\\w+', u'MEEP', u'Hello, world.', 1, u'MEEP, world.', 1),
+      (b'\\w+', b'MEEP', b'Hello, world.', 1, b'MEEP, world.', 1),
+      (u'\\\\', u'\\\\\\\\', u'Hello,\\world.', 0, u'Hello,\\\\world.', 1),
+      (b'\\\\', b'\\\\\\\\', b'Hello,\\world.', 0, b'Hello,\\\\world.', 1),
+  )
+  def test_subn_sub(self, pattern, repl, text, count, expected_joined_pieces,
+                    expected_numsplit):
+    joined_pieces, numsplit = self.MODULE.subn(pattern, repl, text, count)
+    self.assertEqual(expected_joined_pieces, joined_pieces)
+    self.assertEqual(expected_numsplit, numsplit)
+
+    joined_pieces = self.MODULE.sub(pattern, repl, text, count)
+    self.assertEqual(expected_joined_pieces, joined_pieces)
+
+
+class Re2RegexpTest(ReRegexpTest):
+  """Contains tests that apply to the re2 module only."""
+
+  MODULE = re2
+
+  def test_compile_with_latin1_encoding(self):
+    options = re2.Options()
+    options.encoding = re2.Options.Encoding.LATIN1
+    with self.assertRaisesRegex(re2.error,
+                                ('string type of pattern is str, but '
+                                 'encoding specified in options is LATIN1')):
+      re2.compile(u'.?', options=options)
+
+    # ... whereas this is fine, of course.
+    re2.compile(b'.?', options=options)
+
+  @parameterized.parameters(
+      (u'\\p{Lo}', u'\u0ca0_\u0ca0', [(0, 1), (2, 3)]),
+      (b'\\p{Lo}', b'\xe0\xb2\xa0_\xe0\xb2\xa0', [(0, 3), (4, 7)]),
+  )
+  def test_finditer_with_utf8(self, pattern, text, expected_matches):
+    matches = [match.span() for match in self.MODULE.finditer(pattern, text)]
+    self.assertListEqual(expected_matches, matches)
+
+  def test_purge(self):
+    re2.compile('Goodbye, world.')
+    self.assertGreater(re2._Regexp._make.cache_info().currsize, 0)
+    re2.purge()
+    self.assertEqual(re2._Regexp._make.cache_info().currsize, 0)
+
+
+class Re2EscapeTest(parameterized.TestCase):
+  """Contains tests that apply to the re2 module only.
+
+  We disagree with Python on the escaping of some characters,
+  so there is no point attempting to verify consistency.
+  """
+
+  @parameterized.parameters(
+      (u'a*b+c?', u'a\\*b\\+c\\?'),
+      (b'a*b+c?', b'a\\*b\\+c\\?'),
+  )
+  def test_escape(self, pattern, expected_escaped):
+    escaped = re2.escape(pattern)
+    self.assertEqual(expected_escaped, escaped)
+
+
+class ReMatchTest(parameterized.TestCase):
+  """Contains tests that apply to the re and re2 modules."""
+
+  MODULE = re
+
+  def test_expand(self):
+    pattern = u'(?P<S>[\u2600-\u26ff]+).*?(?P<P>[^\\s\\w]+)'
+    text = u'I \u2665 RE2!\n'
+    match = self.MODULE.search(pattern, text)
+
+    self.assertEqual(u'\u2665\n!', match.expand(u'\\1\\n\\2'))
+    self.assertEqual(u'\u2665\n!', match.expand(u'\\g<1>\\n\\g<2>'))
+    self.assertEqual(u'\u2665\n!', match.expand(u'\\g<S>\\n\\g<P>'))
+    self.assertEqual(u'\\1\\2\n\u2665!', match.expand(u'\\\\1\\\\2\\n\\1\\2'))
+
+  def test_expand_with_octal(self):
+    pattern = u'()()()()()()()()()(\\w+)'
+    text = u'Hello, world.'
+    match = self.MODULE.search(pattern, text)
+
+    self.assertEqual(u'Hello\n', match.expand(u'\\g<0>\\n'))
+    self.assertEqual(u'Hello\n', match.expand(u'\\g<10>\\n'))
+
+    self.assertEqual(u'\x00\n', match.expand(u'\\0\\n'))
+    self.assertEqual(u'\x00\n', match.expand(u'\\00\\n'))
+    self.assertEqual(u'\x00\n', match.expand(u'\\000\\n'))
+    self.assertEqual(u'\x000\n', match.expand(u'\\0000\\n'))
+
+    self.assertEqual(u'\n', match.expand(u'\\1\\n'))
+    self.assertEqual(u'Hello\n', match.expand(u'\\10\\n'))
+    self.assertEqual(u'@\n', match.expand(u'\\100\\n'))
+    self.assertEqual(u'@0\n', match.expand(u'\\1000\\n'))
+
+  def test_getitem_group_groups_groupdict(self):
+    pattern = u'(?P<S>[\u2600-\u26ff]+).*?(?P<P>[^\\s\\w]+)'
+    text = u'Hello, world.\nI \u2665 RE2!\nGoodbye, world.\n'
+    match = self.MODULE.search(pattern, text)
+
+    self.assertEqual(u'\u2665 RE2!', match[0])
+    self.assertEqual(u'\u2665', match[1])
+    self.assertEqual(u'!', match[2])
+    self.assertEqual(u'\u2665', match[u'S'])
+    self.assertEqual(u'!', match[u'P'])
+
+    self.assertEqual(u'\u2665 RE2!', match.group())
+    self.assertEqual(u'\u2665 RE2!', match.group(0))
+    self.assertEqual(u'\u2665', match.group(1))
+    self.assertEqual(u'!', match.group(2))
+    self.assertEqual(u'\u2665', match.group(u'S'))
+    self.assertEqual(u'!', match.group(u'P'))
+
+    self.assertTupleEqual((u'\u2665', u'!'), match.group(1, 2))
+    self.assertTupleEqual((u'\u2665', u'!'), match.group(u'S', u'P'))
+    self.assertTupleEqual((u'\u2665', u'!'), match.groups())
+    self.assertDictEqual({u'S': u'\u2665', u'P': u'!'}, match.groupdict())
+
+  def test_bogus_group_start_end_and_span(self):
+    pattern = u'(?P<S>[\u2600-\u26ff]+).*?(?P<P>[^\\s\\w]+)'
+    text = u'I \u2665 RE2!\n'
+    match = self.MODULE.search(pattern, text)
+
+    self.assertRaises(IndexError, match.group, -1)
+    self.assertRaises(IndexError, match.group, 3)
+    self.assertRaises(IndexError, match.group, 'X')
+
+    self.assertRaises(IndexError, match.start, -1)
+    self.assertRaises(IndexError, match.start, 3)
+
+    self.assertRaises(IndexError, match.end, -1)
+    self.assertRaises(IndexError, match.end, 3)
+
+    self.assertRaises(IndexError, match.span, -1)
+    self.assertRaises(IndexError, match.span, 3)
+
+  @parameterized.parameters(
+      (u'((a)(b))((c)(d))', u'foo bar qux', None, None),
+      (u'(?P<one>(a)(b))((c)(d))', u'foo abcd qux', 4, None),
+      (u'(?P<one>(a)(b))(?P<four>(c)(d))', u'foo abcd qux', 4, 'four'),
+  )
+  def test_lastindex_lastgroup(self, pattern, text, expected_lastindex,
+                               expected_lastgroup):
+    match = self.MODULE.search(pattern, text)
+    if expected_lastindex is None:
+      self.assertIsNone(match)
+    else:
+      self.assertEqual(expected_lastindex, match.lastindex)
+      self.assertEqual(expected_lastgroup, match.lastgroup)
+
+
+class Re2MatchTest(ReMatchTest):
+  """Contains tests that apply to the re2 module only."""
+
+  MODULE = re2
+
+
+class SetTest(absltest.TestCase):
+
+  def test_search(self):
+    s = re2.Set.SearchSet()
+    self.assertEqual(0, s.Add('\\d+'))
+    self.assertEqual(1, s.Add('\\s+'))
+    self.assertEqual(2, s.Add('\\w+'))
+    self.assertRaises(re2.error, s.Add, '(MEEP')
+    s.Compile()
+    self.assertItemsEqual([1, 2], s.Match('Hello, world.'))
+
+  def test_match(self):
+    s = re2.Set.MatchSet()
+    self.assertEqual(0, s.Add('\\d+'))
+    self.assertEqual(1, s.Add('\\s+'))
+    self.assertEqual(2, s.Add('\\w+'))
+    self.assertRaises(re2.error, s.Add, '(MEEP')
+    s.Compile()
+    self.assertItemsEqual([2], s.Match('Hello, world.'))
+
+  def test_fullmatch(self):
+    s = re2.Set.FullMatchSet()
+    self.assertEqual(0, s.Add('\\d+'))
+    self.assertEqual(1, s.Add('\\s+'))
+    self.assertEqual(2, s.Add('\\w+'))
+    self.assertRaises(re2.error, s.Add, '(MEEP')
+    s.Compile()
+    self.assertIsNone(s.Match('Hello, world.'))
+
+
+class FilterTest(absltest.TestCase):
+
+  def test_match(self):
+    f = re2.Filter()
+    self.assertEqual(0, f.Add('Hello, \\w+\\.'))
+    self.assertEqual(1, f.Add('\\w+, world\\.'))
+    self.assertEqual(2, f.Add('Goodbye, \\w+\\.'))
+    self.assertRaises(re2.error, f.Add, '(MEEP')
+    f.Compile()
+    self.assertItemsEqual([0, 1], f.Match('Hello, world.', potential=True))
+    self.assertItemsEqual([0, 1], f.Match('HELLO, WORLD.', potential=True))
+    self.assertItemsEqual([0, 1], f.Match('Hello, world.'))
+    self.assertIsNone(f.Match('HELLO, WORLD.'))
+
+    self.assertRaises(IndexError, f.re, -1)
+    self.assertRaises(IndexError, f.re, 3)
+    self.assertEqual('Goodbye, \\w+\\.', f.re(2).pattern)
+    # Verify whether the underlying RE2 object is usable.
+    self.assertEqual(0, f.re(2).groups)
+
+
+if __name__ == '__main__':
+  absltest.main()
diff --git a/python/setup.py b/python/setup.py
new file mode 100644
index 0000000..b0cbd5b
--- /dev/null
+++ b/python/setup.py
@@ -0,0 +1,105 @@
+# Copyright 2019 The RE2 Authors.  All Rights Reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+
+import os
+import setuptools
+import setuptools.command.build_ext
+import shutil
+import sys
+
+long_description = r"""A drop-in replacement for the re module.
+
+It uses RE2 under the hood, of course, so various PCRE features
+(e.g. backreferences, look-around assertions) are not supported.
+See https://github.com/google/re2/wiki/Syntax for the canonical
+reference, but known syntactic "gotchas" relative to Python are:
+
+  * PCRE supports \Z and \z; RE2 supports \z; Python supports \z,
+    but calls it \Z. You must rewrite \Z to \z in pattern strings.
+
+Known differences between this module's API and the re module's API:
+
+  * The error class does not provide any error information as attributes.
+  * The Options class replaces the re module's flags with RE2's options as
+    gettable/settable properties. Please see re2.h for their documentation.
+  * The pattern string and the input string do not have to be the same type.
+    Any str will be encoded to UTF-8.
+  * The pattern string cannot be str if the options specify Latin-1 encoding.
+
+Known issues with regard to building the C++ extension:
+
+  * Building requires RE2 to be installed on your system.
+    On Debian, for example, install the libre2-dev package.
+  * Building requires pybind11 to be installed on your system OR venv.
+    On Debian, for example, install the pybind11-dev package.
+    For a venv, install the pybind11 package from PyPI.
+  * Building on macOS is known to work, but has been known to fail.
+    For example, the system Python may not know which compiler flags
+    to set when building bindings for software installed by Homebrew;
+    see https://docs.brew.sh/Homebrew-and-Python#brewed-python-modules.
+  * Building on Windows has not been tested yet and will probably fail.
+"""
+
+
+class BuildExt(setuptools.command.build_ext.build_ext):
+
+  def build_extension(self, ext):
+    if 'GITHUB_ACTIONS' not in os.environ:
+      return super().build_extension(ext)
+
+    # For @pybind11_bazel's `python_configure()`.
+    os.environ['PYTHON_BIN_PATH'] = sys.executable
+
+    cmd = ['bazel', 'clean', '--expunge']
+    self.spawn(cmd)
+
+    cmd = ['bazel', 'build']
+    if 'BAZEL_CPU' in os.environ:
+      cmd.append(f'--cpu={os.environ["BAZEL_CPU"].lower()}')
+    cmd += ['--compilation_mode=opt', '--', ':all']
+    self.spawn(cmd)
+
+    # This ensures that f'_re2.{importlib.machinery.EXTENSION_SUFFIXES[0]}'
+    # is the filename in the destination directory, which is what's needed.
+    shutil.copyfile('../bazel-bin/python/_re2.so',
+                    self.get_ext_fullpath(ext.name))
+
+
+def include_dirs():
+  try:
+    import pybind11
+    yield pybind11.get_include()
+  except ModuleNotFoundError:
+    pass
+
+
+ext_module = setuptools.Extension(
+    name='_re2',
+    sources=['_re2.cc'],
+    include_dirs=list(include_dirs()),
+    libraries=['re2'],
+    extra_compile_args=['-fvisibility=hidden'],
+)
+
+setuptools.setup(
+    name='google-re2',
+    version='1.0',
+    description='RE2 Python bindings',
+    long_description=long_description,
+    long_description_content_type='text/plain',
+    author='The RE2 Authors',
+    author_email='re2-dev@googlegroups.com',
+    url='https://github.com/google/re2',
+    py_modules=['re2'],
+    ext_modules=[ext_module],
+    classifiers=[
+        'Development Status :: 5 - Production/Stable',
+        'Intended Audience :: Developers',
+        'License :: OSI Approved :: BSD License',
+        'Programming Language :: C++',
+        'Programming Language :: Python :: 3.7',
+    ],
+    cmdclass={'build_ext': BuildExt},
+    python_requires='~=3.7',
+)
diff --git a/re2.pc b/re2.pc
deleted file mode 100644
index d66cf51..0000000
--- a/re2.pc
+++ /dev/null
@@ -1,10 +0,0 @@
-prefix=@prefix@
-exec_prefix=@exec_prefix@
-includedir=@includedir@
-libdir=@libdir@
-
-Name: re2
-Description: RE2 is a fast, safe, thread-friendly regular expression engine.
-Version: 0.0.0
-Cflags: -std=c++11 -pthread -I${includedir}
-Libs: -pthread -L${libdir} -lre2
diff --git a/re2.pc.in b/re2.pc.in
new file mode 100644
index 0000000..c6182d8
--- /dev/null
+++ b/re2.pc.in
@@ -0,0 +1,9 @@
+includedir=@CMAKE_INSTALL_FULL_INCLUDEDIR@
+libdir=@CMAKE_INSTALL_FULL_LIBDIR@
+
+Name: re2
+Description: RE2 is a fast, safe, thread-friendly regular expression engine.
+Requires: @REQUIRES@
+Version: @SONAME@.0.0
+Cflags: -pthread -I${includedir}
+Libs: -pthread -L${libdir} -lre2
diff --git a/re2/bitmap256.cc b/re2/bitmap256.cc
new file mode 100644
index 0000000..f6fbca3
--- /dev/null
+++ b/re2/bitmap256.cc
@@ -0,0 +1,44 @@
+// Copyright 2023 The RE2 Authors.  All Rights Reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+#include "re2/bitmap256.h"
+
+#include <stdint.h>
+
+#include "absl/base/macros.h"
+#include "util/logging.h"
+
+namespace re2 {
+
+int Bitmap256::FindNextSetBit(int c) const {
+  DCHECK_GE(c, 0);
+  DCHECK_LE(c, 255);
+
+  // Check the word that contains the bit. Mask out any lower bits.
+  int i = c / 64;
+  uint64_t word = words_[i] & (~uint64_t{0} << (c % 64));
+  if (word != 0)
+    return (i * 64) + FindLSBSet(word);
+
+  // Check any following words.
+  i++;
+  switch (i) {
+    case 1:
+      if (words_[1] != 0)
+        return (1 * 64) + FindLSBSet(words_[1]);
+      ABSL_FALLTHROUGH_INTENDED;
+    case 2:
+      if (words_[2] != 0)
+        return (2 * 64) + FindLSBSet(words_[2]);
+      ABSL_FALLTHROUGH_INTENDED;
+    case 3:
+      if (words_[3] != 0)
+        return (3 * 64) + FindLSBSet(words_[3]);
+      ABSL_FALLTHROUGH_INTENDED;
+    default:
+      return -1;
+  }
+}
+
+}  // namespace re2
diff --git a/re2/bitmap256.h b/re2/bitmap256.h
index 1abae99..293b31d 100644
--- a/re2/bitmap256.h
+++ b/re2/bitmap256.h
@@ -11,7 +11,6 @@
 #include <stdint.h>
 #include <string.h>
 
-#include "util/util.h"
 #include "util/logging.h"
 
 namespace re2 {
@@ -19,6 +18,11 @@ namespace re2 {
 class Bitmap256 {
  public:
   Bitmap256() {
+    Clear();
+  }
+
+  // Clears all of the bits.
+  void Clear() {
     memset(words_, 0, sizeof words_);
   }
 
@@ -27,7 +31,7 @@ class Bitmap256 {
     DCHECK_GE(c, 0);
     DCHECK_LE(c, 255);
 
-    return (words_[c / 64] & (1ULL << (c % 64))) != 0;
+    return (words_[c / 64] & (uint64_t{1} << (c % 64))) != 0;
   }
 
   // Sets the bit with index c.
@@ -35,7 +39,7 @@ class Bitmap256 {
     DCHECK_GE(c, 0);
     DCHECK_LE(c, 255);
 
-    words_[c / 64] |= (1ULL << (c % 64));
+    words_[c / 64] |= (uint64_t{1} << (c % 64));
   }
 
   // Finds the next non-zero bit with index >= c.
@@ -46,7 +50,6 @@ class Bitmap256 {
   // Finds the least significant non-zero bit in n.
   static int FindLSBSet(uint64_t n) {
     DCHECK_NE(n, 0);
-
 #if defined(__GNUC__)
     return __builtin_ctzll(n);
 #elif defined(_MSC_VER) && defined(_M_X64)
@@ -78,36 +81,6 @@ class Bitmap256 {
   uint64_t words_[4];
 };
 
-int Bitmap256::FindNextSetBit(int c) const {
-  DCHECK_GE(c, 0);
-  DCHECK_LE(c, 255);
-
-  // Check the word that contains the bit. Mask out any lower bits.
-  int i = c / 64;
-  uint64_t word = words_[i] & (~0ULL << (c % 64));
-  if (word != 0)
-    return (i * 64) + FindLSBSet(word);
-
-  // Check any following words.
-  i++;
-  switch (i) {
-    case 1:
-      if (words_[1] != 0)
-        return (1 * 64) + FindLSBSet(words_[1]);
-      FALLTHROUGH_INTENDED;
-    case 2:
-      if (words_[2] != 0)
-        return (2 * 64) + FindLSBSet(words_[2]);
-      FALLTHROUGH_INTENDED;
-    case 3:
-      if (words_[3] != 0)
-        return (3 * 64) + FindLSBSet(words_[3]);
-      FALLTHROUGH_INTENDED;
-    default:
-      return -1;
-  }
-}
-
 }  // namespace re2
 
 #endif  // RE2_BITMAP256_H_
diff --git a/re2/bitstate.cc b/re2/bitstate.cc
index 6e1b44c..38a0b87 100644
--- a/re2/bitstate.cc
+++ b/re2/bitstate.cc
@@ -5,10 +5,10 @@
 // Tested by search_test.cc, exhaustive_test.cc, tester.cc
 
 // Prog::SearchBitState is a regular expression search with submatch
-// tracking for small regular expressions and texts.  Like
-// testing/backtrack.cc, it allocates a bit vector with (length of
-// text) * (length of prog) bits, to make sure it never explores the
-// same (character position, instruction) state multiple times.  This
+// tracking for small regular expressions and texts.  Similarly to
+// testing/backtrack.cc, it allocates a bitmap with (count of
+// lists) * (length of text) bits to make sure it never explores the
+// same (instruction list, character position) multiple times.  This
 // limits the search to run in time linear in the length of the text.
 //
 // Unlike testing/backtrack.cc, SearchBitState is not recursive
@@ -20,10 +20,11 @@
 #include <stddef.h>
 #include <stdint.h>
 #include <string.h>
+#include <limits>
 #include <utility>
 
 #include "util/logging.h"
-#include "util/pod_array.h"
+#include "re2/pod_array.h"
 #include "re2/prog.h"
 #include "re2/regexp.h"
 
@@ -31,7 +32,7 @@ namespace re2 {
 
 struct Job {
   int id;
-  int arg;
+  int rle;  // run length encoding
   const char* p;
 };
 
@@ -41,32 +42,34 @@ class BitState {
 
   // The usual Search prototype.
   // Can only call Search once per BitState.
-  bool Search(const StringPiece& text, const StringPiece& context,
-              bool anchored, bool longest,
-              StringPiece* submatch, int nsubmatch);
+  bool Search(absl::string_view text, absl::string_view context, bool anchored,
+              bool longest, absl::string_view* submatch, int nsubmatch);
 
  private:
   inline bool ShouldVisit(int id, const char* p);
-  void Push(int id, const char* p, int arg);
+  void Push(int id, const char* p);
   void GrowStack();
   bool TrySearch(int id, const char* p);
 
   // Search parameters
-  Prog* prog_;              // program being run
-  StringPiece text_;        // text being searched
-  StringPiece context_;     // greater context of text being searched
-  bool anchored_;           // whether search is anchored at text.begin()
-  bool longest_;            // whether search wants leftmost-longest match
-  bool endmatch_;           // whether match must end at text.end()
-  StringPiece* submatch_;   // submatches to fill in
-  int nsubmatch_;           //   # of submatches to fill in
+  Prog* prog_;                   // program being run
+  absl::string_view text_;       // text being searched
+  absl::string_view context_;    // greater context of text being searched
+  bool anchored_;                // whether search is anchored at text.begin()
+  bool longest_;                 // whether search wants leftmost-longest match
+  bool endmatch_;                // whether match must end at text.end()
+  absl::string_view* submatch_;  // submatches to fill in
+  int nsubmatch_;                //   # of submatches to fill in
 
   // Search state
-  static const int VisitedBits = 32;
-  PODArray<uint32_t> visited_;  // bitmap: (Inst*, char*) pairs visited
+  static constexpr int kVisitedBits = 64;
+  PODArray<uint64_t> visited_;  // bitmap: (list ID, char*) pairs visited
   PODArray<const char*> cap_;   // capture registers
   PODArray<Job> job_;           // stack of text positions to explore
   int njob_;                    // stack size
+
+  BitState(const BitState&) = delete;
+  BitState& operator=(const BitState&) = delete;
 };
 
 BitState::BitState(Prog* prog)
@@ -79,15 +82,16 @@ BitState::BitState(Prog* prog)
     njob_(0) {
 }
 
-// Should the search visit the pair ip, p?
+// Given id, which *must* be a list head, we can look up its list ID.
+// Then the question is: Should the search visit the (list ID, p) pair?
 // If so, remember that it was visited so that the next time,
 // we don't repeat the visit.
 bool BitState::ShouldVisit(int id, const char* p) {
-  int n = id * static_cast<int>(text_.size()+1) +
-          static_cast<int>(p-text_.begin());
-  if (visited_[n/VisitedBits] & (1 << (n & (VisitedBits-1))))
+  int n = prog_->list_heads()[id] * static_cast<int>(text_.size()+1) +
+          static_cast<int>(p-text_.data());
+  if (visited_[n/kVisitedBits] & (uint64_t{1} << (n & (kVisitedBits-1))))
     return false;
-  visited_[n/VisitedBits] |= 1 << (n & (VisitedBits-1));
+  visited_[n/kVisitedBits] |= uint64_t{1} << (n & (kVisitedBits-1));
   return true;
 }
 
@@ -98,8 +102,8 @@ void BitState::GrowStack() {
   job_ = std::move(tmp);
 }
 
-// Push the triple (id, p, arg) onto the stack, growing it if necessary.
-void BitState::Push(int id, const char* p, int arg) {
+// Push (id, p) onto the stack, growing it if necessary.
+void BitState::Push(int id, const char* p) {
   if (njob_ >= job_.size()) {
     GrowStack();
     if (njob_ >= job_.size()) {
@@ -109,93 +113,81 @@ void BitState::Push(int id, const char* p, int arg) {
       return;
     }
   }
-  int op = prog_->inst(id)->opcode();
-  if (op == kInstFail)
-    return;
-
-  // Only check ShouldVisit when arg == 0.
-  // When arg > 0, we are continuing a previous visit.
-  if (arg == 0 && !ShouldVisit(id, p))
-    return;
-
-  Job* j = &job_[njob_++];
-  j->id = id;
-  j->p = p;
-  j->arg = arg;
+
+  // If id < 0, it's undoing a Capture,
+  // so we mustn't interfere with that.
+  if (id >= 0 && njob_ > 0) {
+    Job* top = &job_[njob_-1];
+    if (id == top->id &&
+        p == top->p + top->rle + 1 &&
+        top->rle < std::numeric_limits<int>::max()) {
+      ++top->rle;
+      return;
+    }
+  }
+
+  Job* top = &job_[njob_++];
+  top->id = id;
+  top->rle = 0;
+  top->p = p;
 }
 
 // Try a search from instruction id0 in state p0.
 // Return whether it succeeded.
 bool BitState::TrySearch(int id0, const char* p0) {
   bool matched = false;
-  bool inaltmatch = false;
-  const char* end = text_.end();
+  const char* end = text_.data() + text_.size();
   njob_ = 0;
-  Push(id0, p0, 0);
+  // Push() no longer checks ShouldVisit(),
+  // so we must perform the check ourselves.
+  if (ShouldVisit(id0, p0))
+    Push(id0, p0);
   while (njob_ > 0) {
     // Pop job off stack.
     --njob_;
     int id = job_[njob_].id;
+    int& rle = job_[njob_].rle;
     const char* p = job_[njob_].p;
-    int arg = job_[njob_].arg;
-
-    // Optimization: rather than push and pop,
-    // code that is going to Push and continue
-    // the loop simply updates ip, p, and arg
-    // and jumps to CheckAndLoop.  We have to
-    // do the ShouldVisit check that Push
-    // would have, but we avoid the stack
-    // manipulation.
-    if (0) {
-    Next:
-      // If the Match of a non-greedy AltMatch failed,
-      // we stop ourselves from trying the ByteRange,
-      // which would steer us off the short circuit.
-      if (prog_->inst(id)->last() || inaltmatch)
-        continue;
-      id++;
-
-    CheckAndLoop:
-      if (!ShouldVisit(id, p))
-        continue;
+
+    if (id < 0) {
+      // Undo the Capture.
+      cap_[prog_->inst(-id)->cap()] = p;
+      continue;
+    }
+
+    if (rle > 0) {
+      p += rle;
+      // Revivify job on stack.
+      --rle;
+      ++njob_;
     }
 
-    // Visit ip, p.
+  Loop:
+    // Visit id, p.
     Prog::Inst* ip = prog_->inst(id);
     switch (ip->opcode()) {
       default:
-        LOG(DFATAL) << "Unexpected opcode: " << ip->opcode() << " arg " << arg;
+        LOG(DFATAL) << "Unexpected opcode: " << ip->opcode();
         return false;
 
       case kInstFail:
-        continue;
+        break;
 
       case kInstAltMatch:
-        switch (arg) {
-          case 0:
-            inaltmatch = true;
-            Push(id, p, 1);  // come back when we're done
-
-            // One opcode is ByteRange; the other leads to Match
-            // (possibly via Nop or Capture).
-            if (ip->greedy(prog_)) {
-              // out1 is the match
-              Push(ip->out1(), p, 0);
-              id = ip->out1();
-              p = end;
-              goto CheckAndLoop;
-            }
-            // out is the match - non-greedy
-            Push(ip->out(), end, 0);
-            id = ip->out();
-            goto CheckAndLoop;
-
-          case 1:
-            inaltmatch = false;
-            continue;
+        if (ip->greedy(prog_)) {
+          // out1 is the Match instruction.
+          id = ip->out1();
+          p = end;
+          goto Loop;
         }
-        LOG(DFATAL) << "Bad arg in kInstAltMatch: " << arg;
-        continue;
+        if (longest_) {
+          // ip must be non-greedy...
+          // out is the Match instruction.
+          id = ip->out();
+          p = end;
+          goto Loop;
+        }
+        goto Next;
 
       case kInstByteRange: {
         int c = -1;
@@ -204,54 +196,50 @@ bool BitState::TrySearch(int id0, const char* p0) {
         if (!ip->Matches(c))
           goto Next;
 
-        if (!ip->last())
-          Push(id+1, p, 0);  // try the next when we're done
+        if (ip->hint() != 0)
+          Push(id+ip->hint(), p);  // try the next when we're done
         id = ip->out();
         p++;
         goto CheckAndLoop;
       }
 
       case kInstCapture:
-        switch (arg) {
-          case 0:
-            if (!ip->last())
-              Push(id+1, p, 0);  // try the next when we're done
-
-            if (0 <= ip->cap() && ip->cap() < cap_.size()) {
-              // Capture p to register, but save old value.
-              Push(id, cap_[ip->cap()], 1);  // come back when we're done
-              cap_[ip->cap()] = p;
-            }
-
-            // Continue on.
-            id = ip->out();
-            goto CheckAndLoop;
-
-          case 1:
-            // Finished ip->out(); restore the old value.
-            cap_[ip->cap()] = p;
-            continue;
+        if (!ip->last())
+          Push(id+1, p);  // try the next when we're done
+
+        if (0 <= ip->cap() && ip->cap() < cap_.size()) {
+          // Capture p to register, but save old value first.
+          Push(-id, cap_[ip->cap()]);  // undo when we're done
+          cap_[ip->cap()] = p;
         }
-        LOG(DFATAL) << "Bad arg in kInstCapture: " << arg;
-        continue;
+
+        id = ip->out();
+        goto CheckAndLoop;
 
       case kInstEmptyWidth:
         if (ip->empty() & ~Prog::EmptyFlags(context_, p))
           goto Next;
 
         if (!ip->last())
-          Push(id+1, p, 0);  // try the next when we're done
+          Push(id+1, p);  // try the next when we're done
         id = ip->out();
         goto CheckAndLoop;
 
       case kInstNop:
         if (!ip->last())
-          Push(id+1, p, 0);  // try the next when we're done
+          Push(id+1, p);  // try the next when we're done
         id = ip->out();
-        goto CheckAndLoop;
+
+      CheckAndLoop:
+        // Sanity check: id is the head of its list, which must
+        // be the case if id-1 is the last of *its* list. :)
+        DCHECK(id == 0 || prog_->inst(id-1)->last());
+        if (ShouldVisit(id, p))
+          goto Loop;
+        break;
 
       case kInstMatch: {
-        if (endmatch_ && p != text_.end())
+        if (endmatch_ && p != end)
           goto Next;
 
         // We found a match.  If the caller doesn't care
@@ -265,11 +253,11 @@ bool BitState::TrySearch(int id0, const char* p0) {
         matched = true;
         cap_[1] = p;
         if (submatch_[0].data() == NULL ||
-            (longest_ && p > submatch_[0].end())) {
+            (longest_ && p > submatch_[0].data() + submatch_[0].size())) {
           for (int i = 0; i < nsubmatch_; i++)
-            submatch_[i] =
-                StringPiece(cap_[2 * i],
-                            static_cast<size_t>(cap_[2 * i + 1] - cap_[2 * i]));
+            submatch_[i] = absl::string_view(
+                cap_[2 * i],
+                static_cast<size_t>(cap_[2 * i + 1] - cap_[2 * i]));
         }
 
         // If going for first match, we're done.
@@ -277,11 +265,18 @@ bool BitState::TrySearch(int id0, const char* p0) {
           return true;
 
         // If we used the entire text, no longer match is possible.
-        if (p == text_.end())
+        if (p == end)
           return true;
 
         // Otherwise, continue on in hope of a longer match.
-        goto Next;
+        // Note the absence of the ShouldVisit() check here
+        // due to execution remaining in the same list.
+      Next:
+        if (!ip->last()) {
+          id++;
+          goto Loop;
+        }
+        break;
       }
     }
   }
@@ -289,17 +284,17 @@ bool BitState::TrySearch(int id0, const char* p0) {
 }
 
 // Search text (within context) for prog_.
-bool BitState::Search(const StringPiece& text, const StringPiece& context,
-                      bool anchored, bool longest,
-                      StringPiece* submatch, int nsubmatch) {
+bool BitState::Search(absl::string_view text, absl::string_view context,
+                      bool anchored, bool longest, absl::string_view* submatch,
+                      int nsubmatch) {
   // Search parameters.
   text_ = text;
   context_ = context;
-  if (context_.begin() == NULL)
+  if (context_.data() == NULL)
     context_ = text;
-  if (prog_->anchor_start() && context_.begin() != text.begin())
+  if (prog_->anchor_start() && BeginPtr(context_) != BeginPtr(text))
     return false;
-  if (prog_->anchor_end() && context_.end() != text.end())
+  if (prog_->anchor_end() && EndPtr(context_) != EndPtr(text))
     return false;
   anchored_ = anchored || prog_->anchor_start();
   longest_ = longest || prog_->anchor_end();
@@ -307,12 +302,12 @@ bool BitState::Search(const StringPiece& text, const StringPiece& context,
   submatch_ = submatch;
   nsubmatch_ = nsubmatch;
   for (int i = 0; i < nsubmatch_; i++)
-    submatch_[i] = StringPiece();
+    submatch_[i] = absl::string_view();
 
   // Allocate scratch space.
-  int nvisited = prog_->size() * static_cast<int>(text.size()+1);
-  nvisited = (nvisited + VisitedBits-1) / VisitedBits;
-  visited_ = PODArray<uint32_t>(nvisited);
+  int nvisited = prog_->list_count() * static_cast<int>(text.size()+1);
+  nvisited = (nvisited + kVisitedBits-1) / kVisitedBits;
+  visited_ = PODArray<uint64_t>(nvisited);
   memset(visited_.data(), 0, nvisited*sizeof visited_[0]);
 
   int ncap = 2*nsubmatch;
@@ -321,13 +316,13 @@ bool BitState::Search(const StringPiece& text, const StringPiece& context,
   cap_ = PODArray<const char*>(ncap);
   memset(cap_.data(), 0, ncap*sizeof cap_[0]);
 
-  // When sizeof(Job) == 16, we start with a nice round 4KiB. :)
-  job_ = PODArray<Job>(256);
+  // When sizeof(Job) == 16, we start with a nice round 1KiB. :)
+  job_ = PODArray<Job>(64);
 
   // Anchored search must start at text.begin().
   if (anchored_) {
-    cap_[0] = text.begin();
-    return TrySearch(prog_->start(), text.begin());
+    cap_[0] = text.data();
+    return TrySearch(prog_->start(), text.data());
   }
 
   // Unanchored search, starting from each possible text position.
@@ -336,33 +331,34 @@ bool BitState::Search(const StringPiece& text, const StringPiece& context,
   // This looks like it's quadratic in the size of the text,
   // but we are not clearing visited_ between calls to TrySearch,
   // so no work is duplicated and it ends up still being linear.
-  for (const char* p = text.begin(); p <= text.end(); p++) {
-    // Try to use memchr to find the first byte quickly.
-    int fb = prog_->first_byte();
-    if (fb >= 0 && p < text.end() && (p[0] & 0xFF) != fb) {
-      p = reinterpret_cast<const char*>(memchr(p, fb, text.end() - p));
+  const char* etext = text.data() + text.size();
+  for (const char* p = text.data(); p <= etext; p++) {
+    // Try to use prefix accel (e.g. memchr) to skip ahead.
+    if (p < etext && prog_->can_prefix_accel()) {
+      p = reinterpret_cast<const char*>(prog_->PrefixAccel(p, etext - p));
       if (p == NULL)
-        p = text.end();
+        p = etext;
     }
 
     cap_[0] = p;
     if (TrySearch(prog_->start(), p))  // Match must be leftmost; done.
       return true;
+    // Avoid invoking undefined behavior (arithmetic on a null pointer)
+    // by simply not continuing the loop.
+    if (p == NULL)
+      break;
   }
   return false;
 }
 
 // Bit-state search.
-bool Prog::SearchBitState(const StringPiece& text,
-                          const StringPiece& context,
-                          Anchor anchor,
-                          MatchKind kind,
-                          StringPiece* match,
-                          int nmatch) {
+bool Prog::SearchBitState(absl::string_view text, absl::string_view context,
+                          Anchor anchor, MatchKind kind,
+                          absl::string_view* match, int nmatch) {
   // If full match, we ask for an anchored longest match
   // and then check that match[0] == text.
   // So make sure match[0] exists.
-  StringPiece sp0;
+  absl::string_view sp0;
   if (kind == kFullMatch) {
     anchor = kAnchored;
     if (nmatch < 1) {
@@ -377,7 +373,7 @@ bool Prog::SearchBitState(const StringPiece& text,
   bool longest = kind != kFirstMatch;
   if (!b.Search(text, context, anchored, longest, match, nmatch))
     return false;
-  if (kind == kFullMatch && match[0].end() != text.end())
+  if (kind == kFullMatch && EndPtr(match[0]) != EndPtr(text))
     return false;
   return true;
 }
diff --git a/re2/compile.cc b/re2/compile.cc
index 3f8e0cc..aa79887 100644
--- a/re2/compile.cc
+++ b/re2/compile.cc
@@ -10,12 +10,13 @@
 
 #include <stdint.h>
 #include <string.h>
-#include <unordered_map>
 #include <utility>
 
+#include "absl/base/macros.h"
+#include "absl/container/flat_hash_map.h"
 #include "util/logging.h"
-#include "util/pod_array.h"
 #include "util/utf.h"
+#include "re2/pod_array.h"
 #include "re2/prog.h"
 #include "re2/re2.h"
 #include "re2/regexp.h"
@@ -30,92 +31,60 @@ namespace re2 {
 // See http://swtch.com/~rsc/regexp/regexp1.html for inspiration.
 //
 // Because the out and out1 fields in Inst are no longer pointers,
-// we can't use pointers directly here either.  Instead, p refers
-// to inst_[p>>1].out (p&1 == 0) or inst_[p>>1].out1 (p&1 == 1).
-// p == 0 represents the NULL list.  This is okay because instruction #0
+// we can't use pointers directly here either.  Instead, head refers
+// to inst_[head>>1].out (head&1 == 0) or inst_[head>>1].out1 (head&1 == 1).
+// head == 0 represents the NULL list.  This is okay because instruction #0
 // is always the fail instruction, which never appears on a list.
-
 struct PatchList {
-  uint32_t p;
-
   // Returns patch list containing just p.
-  static PatchList Mk(uint32_t p);
+  static PatchList Mk(uint32_t p) {
+    return {p, p};
+  }
 
-  // Patches all the entries on l to have value v.
+  // Patches all the entries on l to have value p.
   // Caller must not ever use patch list again.
-  static void Patch(Prog::Inst *inst0, PatchList l, uint32_t v);
-
-  // Deref returns the next pointer pointed at by p.
-  static PatchList Deref(Prog::Inst *inst0, PatchList l);
-
-  // Appends two patch lists and returns result.
-  static PatchList Append(Prog::Inst *inst0, PatchList l1, PatchList l2);
-};
-
-static PatchList nullPatchList = { 0 };
-
-// Returns patch list containing just p.
-PatchList PatchList::Mk(uint32_t p) {
-  PatchList l;
-  l.p = p;
-  return l;
-}
-
-// Returns the next pointer pointed at by l.
-PatchList PatchList::Deref(Prog::Inst* inst0, PatchList l) {
-  Prog::Inst* ip = &inst0[l.p>>1];
-  if (l.p&1)
-    l.p = ip->out1();
-  else
-    l.p = ip->out();
-  return l;
-}
-
-// Patches all the entries on l to have value v.
-void PatchList::Patch(Prog::Inst *inst0, PatchList l, uint32_t val) {
-  while (l.p != 0) {
-    Prog::Inst* ip = &inst0[l.p>>1];
-    if (l.p&1) {
-      l.p = ip->out1();
-      ip->out1_ = val;
-    } else {
-      l.p = ip->out();
-      ip->set_out(val);
+  static void Patch(Prog::Inst* inst0, PatchList l, uint32_t p) {
+    while (l.head != 0) {
+      Prog::Inst* ip = &inst0[l.head>>1];
+      if (l.head&1) {
+        l.head = ip->out1();
+        ip->out1_ = p;
+      } else {
+        l.head = ip->out();
+        ip->set_out(p);
+      }
     }
   }
-}
 
-// Appends two patch lists and returns result.
-PatchList PatchList::Append(Prog::Inst* inst0, PatchList l1, PatchList l2) {
-  if (l1.p == 0)
-    return l2;
-  if (l2.p == 0)
-    return l1;
-
-  PatchList l = l1;
-  for (;;) {
-    PatchList next = PatchList::Deref(inst0, l);
-    if (next.p == 0)
-      break;
-    l = next;
+  // Appends two patch lists and returns result.
+  static PatchList Append(Prog::Inst* inst0, PatchList l1, PatchList l2) {
+    if (l1.head == 0)
+      return l2;
+    if (l2.head == 0)
+      return l1;
+    Prog::Inst* ip = &inst0[l1.tail>>1];
+    if (l1.tail&1)
+      ip->out1_ = l2.head;
+    else
+      ip->set_out(l2.head);
+    return {l1.head, l2.tail};
   }
 
-  Prog::Inst* ip = &inst0[l.p>>1];
-  if (l.p&1)
-    ip->out1_ = l2.p;
-  else
-    ip->set_out(l2.p);
+  uint32_t head;
+  uint32_t tail;  // for constant-time append
+};
 
-  return l1;
-}
+static const PatchList kNullPatchList = {0, 0};
 
 // Compiled program fragment.
 struct Frag {
   uint32_t begin;
   PatchList end;
+  bool nullable;
 
-  Frag() : begin(0) { end.p = 0; }  // needed so Frag can go in vector
-  Frag(uint32_t begin, PatchList end) : begin(begin), end(end) {}
+  Frag() : begin(0), end(kNullPatchList), nullable(false) {}
+  Frag(uint32_t begin, PatchList end, bool nullable)
+      : begin(begin), end(end), nullable(nullable) {}
 };
 
 // Input encodings.
@@ -212,8 +181,8 @@ class Compiler : public Regexp::Walker<Frag> {
   int AddSuffixRecursive(int root, int id);
 
   // Finds the trie node for the given suffix. Returns a Frag in order to
-  // distinguish between pointing at the root node directly (end.p == 0)
-  // and pointing at an Alt's out1 or out (end.p&1 == 1 or 0, respectively).
+  // distinguish between pointing at the root node directly (end.head == 0)
+  // and pointing at an Alt's out1 or out (end.head&1 == 1 or 0, respectively).
   Frag FindByteRange(int root, int id);
 
   // Compares two ByteRanges and returns true iff they are equal.
@@ -225,8 +194,8 @@ class Compiler : public Regexp::Walker<Frag> {
   // Single rune.
   Frag Literal(Rune r, bool foldcase);
 
-  void Setup(Regexp::ParseFlags, int64_t, RE2::Anchor);
-  Prog* Finish();
+  void Setup(Regexp::ParseFlags flags, int64_t max_mem, RE2::Anchor anchor);
+  Prog* Finish(Regexp* re);
 
   // Returns .* where dot = any byte
   Frag DotStar();
@@ -243,7 +212,7 @@ class Compiler : public Regexp::Walker<Frag> {
 
   int64_t max_mem_;    // Total memory budget.
 
-  std::unordered_map<uint64_t, int> rune_cache_;
+  absl::flat_hash_map<uint64_t, int> rune_cache_;
   Frag rune_range_;
 
   RE2::Anchor anchor_;  // anchor mode for RE2::Set
@@ -298,7 +267,7 @@ int Compiler::AllocInst(int n) {
 
 // Returns an unmatchable fragment.
 Frag Compiler::NoMatch() {
-  return Frag(0, nullPatchList);
+  return Frag();
 }
 
 // Is a an unmatchable fragment?
@@ -314,7 +283,7 @@ Frag Compiler::Cat(Frag a, Frag b) {
   // Elide no-op.
   Prog::Inst* begin = &inst_[a.begin];
   if (begin->opcode() == kInstNop &&
-      a.end.p == (a.begin << 1) &&
+      a.end.head == (a.begin << 1) &&
       begin->out() == 0) {
     // in case refs to a somewhere
     PatchList::Patch(inst_.data(), a.end, b.begin);
@@ -324,11 +293,11 @@ Frag Compiler::Cat(Frag a, Frag b) {
   // To run backward over string, reverse all concatenations.
   if (reversed_) {
     PatchList::Patch(inst_.data(), b.end, a.begin);
-    return Frag(b.begin, a.end);
+    return Frag(b.begin, a.end, b.nullable && a.nullable);
   }
 
   PatchList::Patch(inst_.data(), a.end, b.begin);
-  return Frag(a.begin, b.end);
+  return Frag(a.begin, b.end, a.nullable && b.nullable);
 }
 
 // Given fragments for a and b, returns fragment for a|b.
@@ -344,7 +313,8 @@ Frag Compiler::Alt(Frag a, Frag b) {
     return NoMatch();
 
   inst_[id].InitAlt(a.begin, b.begin);
-  return Frag(id, PatchList::Append(inst_.data(), a.end, b.end));
+  return Frag(id, PatchList::Append(inst_.data(), a.end, b.end),
+              a.nullable || b.nullable);
 }
 
 // When capturing submatches in like-Perl mode, a kOpAlt Inst
@@ -354,27 +324,44 @@ Frag Compiler::Alt(Frag a, Frag b) {
 // then the operator is greedy.  If out1_ is the repetition
 // (and out_ moves forward), then the operator is non-greedy.
 
-// Given a fragment a, returns a fragment for a* or a*? (if nongreedy)
-Frag Compiler::Star(Frag a, bool nongreedy) {
+// Given a fragment for a, returns a fragment for a+ or a+? (if nongreedy)
+Frag Compiler::Plus(Frag a, bool nongreedy) {
   int id = AllocInst(1);
   if (id < 0)
     return NoMatch();
-  inst_[id].InitAlt(0, 0);
-  PatchList::Patch(inst_.data(), a.end, id);
+  PatchList pl;
   if (nongreedy) {
-    inst_[id].out1_ = a.begin;
-    return Frag(id, PatchList::Mk(id << 1));
+    inst_[id].InitAlt(0, a.begin);
+    pl = PatchList::Mk(id << 1);
   } else {
-    inst_[id].set_out(a.begin);
-    return Frag(id, PatchList::Mk((id << 1) | 1));
+    inst_[id].InitAlt(a.begin, 0);
+    pl = PatchList::Mk((id << 1) | 1);
   }
+  PatchList::Patch(inst_.data(), a.end, id);
+  return Frag(a.begin, pl, a.nullable);
 }
 
-// Given a fragment for a, returns a fragment for a+ or a+? (if nongreedy)
-Frag Compiler::Plus(Frag a, bool nongreedy) {
-  // a+ is just a* with a different entry point.
-  Frag f = Star(a, nongreedy);
-  return Frag(a.begin, f.end);
+// Given a fragment for a, returns a fragment for a* or a*? (if nongreedy)
+Frag Compiler::Star(Frag a, bool nongreedy) {
+  // When the subexpression is nullable, one Alt isn't enough to guarantee
+  // correct priority ordering within the transitive closure. The simplest
+  // solution is to handle it as (a+)? instead, which adds the second Alt.
+  if (a.nullable)
+    return Quest(Plus(a, nongreedy), nongreedy);
+
+  int id = AllocInst(1);
+  if (id < 0)
+    return NoMatch();
+  PatchList pl;
+  if (nongreedy) {
+    inst_[id].InitAlt(0, a.begin);
+    pl = PatchList::Mk(id << 1);
+  } else {
+    inst_[id].InitAlt(a.begin, 0);
+    pl = PatchList::Mk((id << 1) | 1);
+  }
+  PatchList::Patch(inst_.data(), a.end, id);
+  return Frag(id, pl, true);
 }
 
 // Given a fragment for a, returns a fragment for a? or a?? (if nongreedy)
@@ -392,7 +379,7 @@ Frag Compiler::Quest(Frag a, bool nongreedy) {
     inst_[id].InitAlt(a.begin, 0);
     pl = PatchList::Mk((id << 1) | 1);
   }
-  return Frag(id, PatchList::Append(inst_.data(), pl, a.end));
+  return Frag(id, PatchList::Append(inst_.data(), pl, a.end), true);
 }
 
 // Returns a fragment for the byte range lo-hi.
@@ -401,7 +388,7 @@ Frag Compiler::ByteRange(int lo, int hi, bool foldcase) {
   if (id < 0)
     return NoMatch();
   inst_[id].InitByteRange(lo, hi, foldcase, 0);
-  return Frag(id, PatchList::Mk(id << 1));
+  return Frag(id, PatchList::Mk(id << 1), false);
 }
 
 // Returns a no-op fragment.  Sometimes unavoidable.
@@ -410,7 +397,7 @@ Frag Compiler::Nop() {
   if (id < 0)
     return NoMatch();
   inst_[id].InitNop(0);
-  return Frag(id, PatchList::Mk(id << 1));
+  return Frag(id, PatchList::Mk(id << 1), true);
 }
 
 // Returns a fragment that signals a match.
@@ -419,7 +406,7 @@ Frag Compiler::Match(int32_t match_id) {
   if (id < 0)
     return NoMatch();
   inst_[id].InitMatch(match_id);
-  return Frag(id, nullPatchList);
+  return Frag(id, kNullPatchList, false);
 }
 
 // Returns a fragment matching a particular empty-width op (like ^ or $)
@@ -428,7 +415,7 @@ Frag Compiler::EmptyWidth(EmptyOp empty) {
   if (id < 0)
     return NoMatch();
   inst_[id].InitEmptyWidth(empty, 0);
-  return Frag(id, PatchList::Mk(id << 1));
+  return Frag(id, PatchList::Mk(id << 1), true);
 }
 
 // Given a fragment a, returns a fragment with capturing parens around a.
@@ -442,7 +429,7 @@ Frag Compiler::Capture(Frag a, int n) {
   inst_[id+1].InitCapture(2*n+1, 0);
   PatchList::Patch(inst_.data(), a.end, id+1);
 
-  return Frag(id, PatchList::Mk((id+1) << 1));
+  return Frag(id, PatchList::Mk((id+1) << 1), a.nullable);
 }
 
 // A Rune is a name for a Unicode code point.
@@ -467,7 +454,7 @@ static int MaxRune(int len) {
 void Compiler::BeginRange() {
   rune_cache_.clear();
   rune_range_.begin = 0;
-  rune_range_.end = nullPatchList;
+  rune_range_.end = kNullPatchList;
 }
 
 int Compiler::UncachedRuneByteSuffix(uint8_t lo, uint8_t hi, bool foldcase,
@@ -492,7 +479,7 @@ static uint64_t MakeRuneCacheKey(uint8_t lo, uint8_t hi, bool foldcase,
 int Compiler::CachedRuneByteSuffix(uint8_t lo, uint8_t hi, bool foldcase,
                                    int next) {
   uint64_t key = MakeRuneCacheKey(lo, hi, foldcase, next);
-  std::unordered_map<uint64_t, int>::const_iterator it = rune_cache_.find(key);
+  absl::flat_hash_map<uint64_t, int>::const_iterator it = rune_cache_.find(key);
   if (it != rune_cache_.end())
     return it->second;
   int id = UncachedRuneByteSuffix(lo, hi, foldcase, next);
@@ -548,9 +535,9 @@ int Compiler::AddSuffixRecursive(int root, int id) {
   }
 
   int br;
-  if (f.end.p == 0)
+  if (f.end.head == 0)
     br = root;
-  else if (f.end.p&1)
+  else if (f.end.head&1)
     br = inst_[f.begin].out1();
   else
     br = inst_[f.begin].out();
@@ -566,9 +553,9 @@ int Compiler::AddSuffixRecursive(int root, int id) {
     // Ensure that the parent points to the clone, not to the original.
     // Note that this could leave the head unreachable except via the cache.
     br = byterange;
-    if (f.end.p == 0)
+    if (f.end.head == 0)
       root = br;
-    else if (f.end.p&1)
+    else if (f.end.head&1)
       inst_[f.begin].out1_ = br;
     else
       inst_[f.begin].set_out(br);
@@ -601,7 +588,7 @@ bool Compiler::ByteRangeEqual(int id1, int id2) {
 Frag Compiler::FindByteRange(int root, int id) {
   if (inst_[root].opcode() == kInstByteRange) {
     if (ByteRangeEqual(root, id))
-      return Frag(root, nullPatchList);
+      return Frag(root, kNullPatchList, false);
     else
       return NoMatch();
   }
@@ -609,7 +596,7 @@ Frag Compiler::FindByteRange(int root, int id) {
   while (inst_[root].opcode() == kInstAlt) {
     int out1 = inst_[root].out1();
     if (ByteRangeEqual(out1, id))
-      return Frag(root, PatchList::Mk((root << 1) | 1));
+      return Frag(root, PatchList::Mk((root << 1) | 1), false);
 
     // CharClass is a sorted list of ranges, so if out1 of the root Alt wasn't
     // what we're looking for, then we can stop immediately. Unfortunately, we
@@ -621,7 +608,7 @@ Frag Compiler::FindByteRange(int root, int id) {
     if (inst_[out].opcode() == kInstAlt)
       root = out;
     else if (ByteRangeEqual(out, id))
-      return Frag(root, PatchList::Mk(root << 1));
+      return Frag(root, PatchList::Mk(root << 1), false);
     else
       return NoMatch();
   }
@@ -662,48 +649,43 @@ void Compiler::AddRuneRangeLatin1(Rune lo, Rune hi, bool foldcase) {
                                    static_cast<uint8_t>(hi), foldcase, 0));
 }
 
-// Table describing how to make a UTF-8 matching machine
-// for the rune range 80-10FFFF (Runeself-Runemax).
-// This range happens frequently enough (for example /./ and /[^a-z]/)
-// and the rune_cache_ map is slow enough that this is worth
-// special handling.  Makes compilation of a small expression
-// with a dot in it about 10% faster.
-// The * in the comments below mark whole sequences.
-static struct ByteRangeProg {
-  int next;
-  int lo;
-  int hi;
-} prog_80_10ffff[] = {
-  // Two-byte
-  { -1, 0x80, 0xBF, },  // 0:  80-BF
-  {  0, 0xC2, 0xDF, },  // 1:  C2-DF 80-BF*
-
-  // Three-byte
-  {  0, 0xA0, 0xBF, },  // 2:  A0-BF 80-BF
-  {  2, 0xE0, 0xE0, },  // 3:  E0 A0-BF 80-BF*
-  {  0, 0x80, 0xBF, },  // 4:  80-BF 80-BF
-  {  4, 0xE1, 0xEF, },  // 5:  E1-EF 80-BF 80-BF*
-
-  // Four-byte
-  {  4, 0x90, 0xBF, },  // 6:  90-BF 80-BF 80-BF
-  {  6, 0xF0, 0xF0, },  // 7:  F0 90-BF 80-BF 80-BF*
-  {  4, 0x80, 0xBF, },  // 8:  80-BF 80-BF 80-BF
-  {  8, 0xF1, 0xF3, },  // 9: F1-F3 80-BF 80-BF 80-BF*
-  {  4, 0x80, 0x8F, },  // 10: 80-8F 80-BF 80-BF
-  { 10, 0xF4, 0xF4, },  // 11: F4 80-8F 80-BF 80-BF*
-};
-
 void Compiler::Add_80_10ffff() {
-  int inst[arraysize(prog_80_10ffff)] = { 0 }; // does not need to be initialized; silences gcc warning
-  for (int i = 0; i < arraysize(prog_80_10ffff); i++) {
-    const ByteRangeProg& p = prog_80_10ffff[i];
-    int next = 0;
-    if (p.next >= 0)
-      next = inst[p.next];
-    inst[i] = UncachedRuneByteSuffix(static_cast<uint8_t>(p.lo),
-                                     static_cast<uint8_t>(p.hi), false, next);
-    if ((p.lo & 0xC0) != 0x80)
-      AddSuffix(inst[i]);
+  // The 80-10FFFF (Runeself-Runemax) rune range occurs frequently enough
+  // (for example, for /./ and /[^a-z]/) that it is worth simplifying: by
+  // permitting overlong encodings in E0 and F0 sequences and code points
+  // over 10FFFF in F4 sequences, the size of the bytecode and the number
+  // of equivalence classes are reduced significantly.
+  int id;
+  if (reversed_) {
+    // Prefix factoring matters, but we don't have to handle it here
+    // because the rune range trie logic takes care of that already.
+    id = UncachedRuneByteSuffix(0xC2, 0xDF, false, 0);
+    id = UncachedRuneByteSuffix(0x80, 0xBF, false, id);
+    AddSuffix(id);
+
+    id = UncachedRuneByteSuffix(0xE0, 0xEF, false, 0);
+    id = UncachedRuneByteSuffix(0x80, 0xBF, false, id);
+    id = UncachedRuneByteSuffix(0x80, 0xBF, false, id);
+    AddSuffix(id);
+
+    id = UncachedRuneByteSuffix(0xF0, 0xF4, false, 0);
+    id = UncachedRuneByteSuffix(0x80, 0xBF, false, id);
+    id = UncachedRuneByteSuffix(0x80, 0xBF, false, id);
+    id = UncachedRuneByteSuffix(0x80, 0xBF, false, id);
+    AddSuffix(id);
+  } else {
+    // Suffix factoring matters - and we do have to handle it here.
+    int cont1 = UncachedRuneByteSuffix(0x80, 0xBF, false, 0);
+    id = UncachedRuneByteSuffix(0xC2, 0xDF, false, cont1);
+    AddSuffix(id);
+
+    int cont2 = UncachedRuneByteSuffix(0x80, 0xBF, false, cont1);
+    id = UncachedRuneByteSuffix(0xE0, 0xEF, false, cont2);
+    AddSuffix(id);
+
+    int cont3 = UncachedRuneByteSuffix(0x80, 0xBF, false, cont2);
+    id = UncachedRuneByteSuffix(0xF0, 0xF4, false, cont3);
+    AddSuffix(id);
   }
 }
 
@@ -711,9 +693,8 @@ void Compiler::AddRuneRangeUTF8(Rune lo, Rune hi, bool foldcase) {
   if (lo > hi)
     return;
 
-  // Pick off 80-10FFFF as a common special case
-  // that can bypass the slow rune_cache_.
-  if (lo == 0x80 && hi == 0x10ffff && !reversed_) {
+  // Pick off 80-10FFFF as a common special case.
+  if (lo == 0x80 && hi == 0x10ffff) {
     Add_80_10ffff();
     return;
   }
@@ -809,8 +790,8 @@ void Compiler::AddRuneRangeUTF8(Rune lo, Rune hi, bool foldcase) {
 // Should not be called.
 Frag Compiler::Copy(Frag arg) {
   // We're using WalkExponential; there should be no copying.
-  LOG(DFATAL) << "Compiler::Copy called!";
   failed_ = true;
+  LOG(DFATAL) << "Compiler::Copy called!";
   return NoMatch();
 }
 
@@ -936,8 +917,8 @@ Frag Compiler::PostVisit(Regexp* re, Frag, Frag, Frag* child_frags,
       CharClass* cc = re->cc();
       if (cc->empty()) {
         // This can't happen.
-        LOG(DFATAL) << "No ranges in char class";
         failed_ = true;
+        LOG(DFATAL) << "No ranges in char class";
         return NoMatch();
       }
 
@@ -994,8 +975,8 @@ Frag Compiler::PostVisit(Regexp* re, Frag, Frag, Frag* child_frags,
     case kRegexpNoWordBoundary:
       return EmptyWidth(kEmptyNonWordBoundary);
   }
-  LOG(DFATAL) << "Missing case in Compiler: " << re->op();
   failed_ = true;
+  LOG(DFATAL) << "Missing case in Compiler: " << re->op();
   return NoMatch();
 }
 
@@ -1095,8 +1076,6 @@ static bool IsAnchorEnd(Regexp** pre, int depth) {
 
 void Compiler::Setup(Regexp::ParseFlags flags, int64_t max_mem,
                      RE2::Anchor anchor) {
-  prog_->set_flags(flags);
-
   if (flags & Regexp::Latin1)
     encoding_ = kEncodingLatin1;
   max_mem_ = max_mem;
@@ -1117,14 +1096,11 @@ void Compiler::Setup(Regexp::ParseFlags flags, int64_t max_mem,
     // on the program.)
     if (m >= 1<<24)
       m = 1<<24;
-
     // Inst imposes its own limit (currently bigger than 2^24 but be safe).
     if (m > Prog::Inst::kMaxInst)
       m = Prog::Inst::kMaxInst;
-
     max_ninst_ = static_cast<int>(m);
   }
-
   anchor_ = anchor;
 }
 
@@ -1178,10 +1154,10 @@ Prog* Compiler::Compile(Regexp* re, bool reversed, int64_t max_mem) {
   c.prog_->set_start_unanchored(all.begin);
 
   // Hand ownership of prog_ to caller.
-  return c.Finish();
+  return c.Finish(re);
 }
 
-Prog* Compiler::Finish() {
+Prog* Compiler::Finish(Regexp* re) {
   if (failed_)
     return NULL;
 
@@ -1198,11 +1174,21 @@ Prog* Compiler::Finish() {
   prog_->Flatten();
   prog_->ComputeByteMap();
 
+  if (!prog_->reversed()) {
+    std::string prefix;
+    bool prefix_foldcase;
+    if (re->RequiredPrefixForAccel(&prefix, &prefix_foldcase))
+      prog_->ConfigurePrefixAccel(prefix, prefix_foldcase);
+  }
+
   // Record remaining memory for DFA.
   if (max_mem_ <= 0) {
     prog_->set_dfa_mem(1<<20);
   } else {
-    int64_t m = max_mem_ - sizeof(Prog) - prog_->size_*sizeof(Prog::Inst);
+    int64_t m = max_mem_ - sizeof(Prog);
+    m -= prog_->size_*sizeof(Prog::Inst);  // account for inst_
+    if (prog_->CanBitState())
+      m -= prog_->size_*sizeof(uint16_t);  // account for list_heads_
     if (m < 0)
       m = 0;
     prog_->set_dfa_mem(m);
@@ -1251,14 +1237,14 @@ Prog* Compiler::CompileSet(Regexp* re, RE2::Anchor anchor, int64_t max_mem) {
   c.prog_->set_start(all.begin);
   c.prog_->set_start_unanchored(all.begin);
 
-  Prog* prog = c.Finish();
+  Prog* prog = c.Finish(re);
   if (prog == NULL)
     return NULL;
 
   // Make sure DFA has enough memory to operate,
   // since we're not going to fall back to the NFA.
   bool dfa_failed = false;
-  StringPiece sp = "hello, world";
+  absl::string_view sp = "hello, world";
   prog->SearchDFA(sp, sp, Prog::kAnchored, Prog::kManyMatch,
                   NULL, &dfa_failed, NULL);
   if (dfa_failed) {
diff --git a/re2/dfa.cc b/re2/dfa.cc
index 89b9b77..a177596 100644
--- a/re2/dfa.cc
+++ b/re2/dfa.cc
@@ -28,22 +28,25 @@
 #include <algorithm>
 #include <atomic>
 #include <deque>
-#include <mutex>
 #include <new>
 #include <string>
-#include <unordered_map>
-#include <unordered_set>
 #include <utility>
 #include <vector>
 
+#include "absl/base/call_once.h"
+#include "absl/base/macros.h"
+#include "absl/base/thread_annotations.h"
+#include "absl/container/flat_hash_map.h"
+#include "absl/container/flat_hash_set.h"
+#include "absl/strings/str_format.h"
+#include "absl/synchronization/mutex.h"
+#include "absl/types/span.h"
 #include "util/logging.h"
-#include "util/mix.h"
-#include "util/mutex.h"
-#include "util/pod_array.h"
-#include "util/sparse_set.h"
 #include "util/strutil.h"
+#include "re2/pod_array.h"
 #include "re2/prog.h"
-#include "re2/stringpiece.h"
+#include "re2/re2.h"
+#include "re2/sparse_set.h"
 
 // Silence "zero-sized array in struct/union" warning for DFA::State::next_.
 #ifdef _MSC_VER
@@ -52,20 +55,13 @@
 
 namespace re2 {
 
-#if !defined(__linux__)  /* only Linux seems to have memrchr */
-static void* memrchr(const void* s, int c, size_t n) {
-  const unsigned char* p = (const unsigned char*)s;
-  for (p += n; n > 0; n--)
-    if (*--p == c)
-      return (void*)p;
-
-  return NULL;
-}
-#endif
-
 // Controls whether the DFA should bail out early if the NFA would be faster.
 static bool dfa_should_bail_when_slow = true;
 
+void Prog::TESTING_ONLY_set_dfa_should_bail_when_slow(bool b) {
+  dfa_should_bail_when_slow = b;
+}
+
 // Changing this to true compiles in prints that trace execution of the DFA.
 // Generates a lot of output -- only useful for debugging.
 static const bool ExtraDebug = false;
@@ -94,9 +90,9 @@ class DFA {
   //   returning the leftmost end of the match instead of the rightmost one.
   // If the DFA cannot complete the search (for example, if it is out of
   //   memory), it sets *failed and returns false.
-  bool Search(const StringPiece& text, const StringPiece& context,
-              bool anchored, bool want_earliest_match, bool run_forward,
-              bool* failed, const char** ep, SparseSet* matches);
+  bool Search(absl::string_view text, absl::string_view context, bool anchored,
+              bool want_earliest_match, bool run_forward, bool* failed,
+              const char** ep, SparseSet* matches);
 
   // Builds out all states for the entire DFA.
   // If cb is not empty, it receives one callback per state built.
@@ -106,7 +102,7 @@ class DFA {
 
   // Computes min and max for matching strings.  Won't return strings
   // bigger than maxlen.
-  bool PossibleMatchRange(string* min, string* max, int maxlen);
+  bool PossibleMatchRange(std::string* min, std::string* max, int maxlen);
 
   // These data structures are logically private, but C++ makes it too
   // difficult to mark them as such.
@@ -119,7 +115,18 @@ class DFA {
   // byte c, the next state should be s->next_[c].
   struct State {
     inline bool IsMatch() const { return (flag_ & kFlagMatch) != 0; }
-    void SaveMatch(std::vector<int>* v);
+
+    template <typename H>
+    friend H AbslHashValue(H h, const State& a) {
+      const absl::Span<const int> ainst(a.inst_, a.ninst_);
+      return H::combine(std::move(h), a.flag_, ainst);
+    }
+
+    friend bool operator==(const State& a, const State& b) {
+      const absl::Span<const int> ainst(a.inst_, a.ninst_);
+      const absl::Span<const int> binst(b.inst_, b.ninst_);
+      return &a == &b || (a.flag_ == b.flag_ && ainst == binst);
+    }
 
     int* inst_;         // Instruction pointers in the state.
     int ninst_;         // # of inst_ pointers.
@@ -131,11 +138,11 @@ class DFA {
 // (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70932)
 #if !defined(__clang__) && defined(__GNUC__) && __GNUC__ == 6 && __GNUC_MINOR__ >= 1
     std::atomic<State*> next_[0];   // Outgoing arrows from State,
+                                    // one per input byte class
 #else
     std::atomic<State*> next_[];    // Outgoing arrows from State,
+                                    // one per input byte class
 #endif
-
-                        // one per input byte class
   };
 
   enum {
@@ -150,11 +157,7 @@ class DFA {
   struct StateHash {
     size_t operator()(const State* a) const {
       DCHECK(a != NULL);
-      HashMix mix(a->flag_);
-      for (int i = 0; i < a->ninst_; i++)
-        mix.Mix(a->inst_[i]);
-      mix.Mix(0);
-      return mix.get();
+      return absl::Hash<State>()(*a);
     }
   };
 
@@ -162,27 +165,15 @@ class DFA {
     bool operator()(const State* a, const State* b) const {
       DCHECK(a != NULL);
       DCHECK(b != NULL);
-      if (a == b)
-        return true;
-      if (a->flag_ != b->flag_)
-        return false;
-      if (a->ninst_ != b->ninst_)
-        return false;
-      for (int i = 0; i < a->ninst_; i++)
-        if (a->inst_[i] != b->inst_[i])
-          return false;
-      return true;
+      return *a == *b;
     }
   };
 
-  typedef std::unordered_set<State*, StateHash, StateEqual> StateSet;
+  typedef absl::flat_hash_set<State*, StateHash, StateEqual> StateSet;
 
  private:
-  // Special "first_byte" values for a state.  (Values >= 0 denote actual bytes.)
-  enum {
-    kFbUnknown = -1,   // No analysis has been performed.
-    kFbNone = -2,      // The first-byte trick cannot be used.
-  };
+  // Make it easier to swap in a scalable reader-writer mutex.
+  using CacheMutex = absl::Mutex;
 
   enum {
     // Indices into start_ for unanchored searches.
@@ -241,34 +232,35 @@ class DFA {
   void AddToQueue(Workq* q, int id, uint32_t flag);
 
   // For debugging, returns a text representation of State.
-  static string DumpState(State* state);
+  static std::string DumpState(State* state);
 
   // For debugging, returns a text representation of a Workq.
-  static string DumpWorkq(Workq* q);
+  static std::string DumpWorkq(Workq* q);
 
   // Search parameters
   struct SearchParams {
-    SearchParams(const StringPiece& text, const StringPiece& context,
+    SearchParams(absl::string_view text, absl::string_view context,
                  RWLocker* cache_lock)
-      : text(text), context(context),
+      : text(text),
+        context(context),
         anchored(false),
+        can_prefix_accel(false),
         want_earliest_match(false),
         run_forward(false),
         start(NULL),
-        first_byte(kFbUnknown),
         cache_lock(cache_lock),
         failed(false),
         ep(NULL),
-        matches(NULL) { }
+        matches(NULL) {}
 
-    StringPiece text;
-    StringPiece context;
+    absl::string_view text;
+    absl::string_view context;
     bool anchored;
+    bool can_prefix_accel;
     bool want_earliest_match;
     bool run_forward;
     State* start;
-    int first_byte;
-    RWLocker *cache_lock;
+    RWLocker* cache_lock;
     bool failed;     // "out" parameter: whether search gave up
     const char* ep;  // "out" parameter: end pointer for match
     SparseSet* matches;
@@ -279,15 +271,13 @@ class DFA {
   };
 
   // Before each search, the parameters to Search are analyzed by
-  // AnalyzeSearch to determine the state in which to start and the
-  // "first_byte" for that state, if any.
+  // AnalyzeSearch to determine the state in which to start.
   struct StartInfo {
-    StartInfo() : start(NULL), first_byte(kFbUnknown) {}
-    State* start;
-    std::atomic<int> first_byte;
+    StartInfo() : start(NULL) {}
+    std::atomic<State*> start;
   };
 
-  // Fills in params->start and params->first_byte using
+  // Fills in params->start and params->can_prefix_accel using
   // the other search parameters.  Returns true on success,
   // false on failure.
   // cache_mutex_.r <= L < mutex_
@@ -298,10 +288,10 @@ class DFA {
   // The generic search loop, inlined to create specialized versions.
   // cache_mutex_.r <= L < mutex_
   // Might unlock and relock cache_mutex_ via params->cache_lock.
-  inline bool InlinedSearchLoop(SearchParams* params,
-                                bool have_first_byte,
-                                bool want_earliest_match,
-                                bool run_forward);
+  template <bool can_prefix_accel,
+            bool want_earliest_match,
+            bool run_forward>
+  inline bool InlinedSearchLoop(SearchParams* params);
 
   // The specialized versions of InlinedSearchLoop.  The three letters
   // at the ends of the name denote the true/false values used as the
@@ -323,13 +313,6 @@ class DFA {
   // Might unlock and relock cache_mutex_ via params->cache_lock.
   bool FastSearchLoop(SearchParams* params);
 
-  // For debugging, a slow search loop that calls InlinedSearchLoop
-  // directly -- because the booleans passed are not constants, the
-  // loop is not specialized like the SearchFFF etc. versions, so it
-  // runs much more slowly.  Useful only for debugging.
-  // cache_mutex_.r <= L < mutex_
-  // Might unlock and relock cache_mutex_ via params->cache_lock.
-  bool SlowSearchLoop(SearchParams* params);
 
   // Looks up bytes in bytemap_ but handles case c == kByteEndText too.
   int ByteMap(int c) {
@@ -343,7 +326,7 @@ class DFA {
   Prog::MatchKind kind_;    // The kind of DFA.
   bool init_failed_;        // initialization failed (out of memory)
 
-  Mutex mutex_;  // mutex_ >= cache_mutex_.r
+  absl::Mutex mutex_;  // mutex_ >= cache_mutex_.r
 
   // Scratch areas, protected by mutex_.
   Workq* q0_;             // Two pre-allocated work queues.
@@ -356,11 +339,14 @@ class DFA {
   // while holding cache_mutex_ for writing, to avoid interrupting other
   // readers.  Any State* pointers are only valid while cache_mutex_
   // is held.
-  Mutex cache_mutex_;
+  CacheMutex cache_mutex_;
   int64_t mem_budget_;     // Total memory budget for all States.
   int64_t state_budget_;   // Amount of memory remaining for new States.
   StateSet state_cache_;   // All States computed so far.
   StartInfo start_[kMaxStart];
+
+  DFA(const DFA&) = delete;
+  DFA& operator=(const DFA&) = delete;
 };
 
 // Shorthand for casting to uint8_t*.
@@ -443,7 +429,7 @@ DFA::DFA(Prog* prog, Prog::MatchKind kind, int64_t max_mem)
     q1_(NULL),
     mem_budget_(max_mem) {
   if (ExtraDebug)
-    fprintf(stderr, "\nkind %d\n%s\n", (int)kind_, prog_->DumpUnanchored().c_str());
+    absl::FPrintF(stderr, "\nkind %d\n%s\n", kind_, prog_->DumpUnanchored());
   int nmark = 0;
   if (kind_ == Prog::kLongestMatch)
     nmark = prog_->size();
@@ -505,15 +491,15 @@ DFA::~DFA() {
 // Debugging printouts
 
 // For debugging, returns a string representation of the work queue.
-string DFA::DumpWorkq(Workq* q) {
-  string s;
+std::string DFA::DumpWorkq(Workq* q) {
+  std::string s;
   const char* sep = "";
   for (Workq::iterator it = q->begin(); it != q->end(); ++it) {
     if (q->is_mark(*it)) {
-      StringAppendF(&s, "|");
+      s += "|";
       sep = "";
     } else {
-      StringAppendF(&s, "%s%d", sep, *it);
+      s += absl::StrFormat("%s%d", sep, *it);
       sep = ",";
     }
   }
@@ -521,29 +507,29 @@ string DFA::DumpWorkq(Workq* q) {
 }
 
 // For debugging, returns a string representation of the state.
-string DFA::DumpState(State* state) {
+std::string DFA::DumpState(State* state) {
   if (state == NULL)
     return "_";
   if (state == DeadState)
     return "X";
   if (state == FullMatchState)
     return "*";
-  string s;
+  std::string s;
   const char* sep = "";
-  StringAppendF(&s, "(%p)", state);
+  s += absl::StrFormat("(%p)", state);
   for (int i = 0; i < state->ninst_; i++) {
     if (state->inst_[i] == Mark) {
-      StringAppendF(&s, "|");
+      s += "|";
       sep = "";
     } else if (state->inst_[i] == MatchSep) {
-      StringAppendF(&s, "||");
+      s += "||";
       sep = "";
     } else {
-      StringAppendF(&s, "%s%d", sep, state->inst_[i]);
+      s += absl::StrFormat("%s%d", sep, state->inst_[i]);
       sep = ",";
     }
   }
-  StringAppendF(&s, " flag=%#x", state->flag_);
+  s += absl::StrFormat(" flag=%#x", state->flag_);
   return s;
 }
 
@@ -611,16 +597,35 @@ DFA::State* DFA::WorkqToCachedState(Workq* q, Workq* mq, uint32_t flag) {
   //mutex_.AssertHeld();
 
   // Construct array of instruction ids for the new state.
-  // Only ByteRange, EmptyWidth, and Match instructions are useful to keep:
-  // those are the only operators with any effect in
-  // RunWorkqOnEmptyString or RunWorkqOnByte.
-  int* inst = new int[q->size()];
+  // In some cases, kInstAltMatch may trigger an upgrade to FullMatchState.
+  // Otherwise, "compress" q down to list heads for storage; StateToWorkq()
+  // will "decompress" it for computation by exploring from each list head.
+  //
+  // Historically, only kInstByteRange, kInstEmptyWidth and kInstMatch were
+  // useful to keep, but it turned out that kInstAlt was necessary to keep:
+  //
+  // > [*] kInstAlt would seem useless to record in a state, since
+  // > we've already followed both its arrows and saved all the
+  // > interesting states we can reach from there.  The problem
+  // > is that one of the empty-width instructions might lead
+  // > back to the same kInstAlt (if an empty-width operator is starred),
+  // > producing a different evaluation order depending on whether
+  // > we keep the kInstAlt to begin with.  Sigh.
+  // > A specific case that this affects is /(^|a)+/ matching "a".
+  // > If we don't save the kInstAlt, we will match the whole "a" (0,1)
+  // > but in fact the correct leftmost-first match is the leading "" (0,0).
+  //
+  // Recall that flattening transformed the Prog from "tree" form to "list"
+  // form: in the former, kInstAlt existed explicitly... and abundantly; in
+  // the latter, it's implied between the instructions that compose a list.
+  // Thus, because the information wasn't lost, the bug doesn't remanifest.
+  PODArray<int> inst(q->size());
   int n = 0;
   uint32_t needflags = 0;  // flags needed by kInstEmptyWidth instructions
   bool sawmatch = false;   // whether queue contains guaranteed kInstMatch
   bool sawmark = false;    // whether queue contains a Mark
   if (ExtraDebug)
-    fprintf(stderr, "WorkqToCachedState %s [%#x]", DumpWorkq(q).c_str(), flag);
+    absl::FPrintF(stderr, "WorkqToCachedState %s [%#x]", DumpWorkq(q), flag);
   for (Workq::iterator it = q->begin(); it != q->end(); ++it) {
     int id = *it;
     if (sawmatch && (kind_ == Prog::kFirstMatch || q->is_mark(id)))
@@ -644,12 +649,11 @@ DFA::State* DFA::WorkqToCachedState(Workq* q, Workq* mq, uint32_t flag) {
              (it == q->begin() && ip->greedy(prog_))) &&
             (kind_ != Prog::kLongestMatch || !sawmark) &&
             (flag & kFlagMatch)) {
-          delete[] inst;
           if (ExtraDebug)
-            fprintf(stderr, " -> FullMatchState\n");
+            absl::FPrintF(stderr, " -> FullMatchState\n");
           return FullMatchState;
         }
-        FALLTHROUGH_INTENDED;
+        ABSL_FALLTHROUGH_INTENDED;
       default:
         // Record iff id is the head of its list, which must
         // be the case if id-1 is the last of *its* list. :)
@@ -691,9 +695,8 @@ DFA::State* DFA::WorkqToCachedState(Workq* q, Workq* mq, uint32_t flag) {
   // the execution loop can stop early.  This is only okay
   // if the state is *not* a matching state.
   if (n == 0 && flag == 0) {
-    delete[] inst;
     if (ExtraDebug)
-      fprintf(stderr, " -> DeadState\n");
+      absl::FPrintF(stderr, " -> DeadState\n");
     return DeadState;
   }
 
@@ -701,7 +704,7 @@ DFA::State* DFA::WorkqToCachedState(Workq* q, Workq* mq, uint32_t flag) {
   // unordered state sets separated by Marks.  Sort each set
   // to canonicalize, to reduce the number of distinct sets stored.
   if (kind_ == Prog::kLongestMatch) {
-    int* ip = inst;
+    int* ip = inst.data();
     int* ep = ip + n;
     while (ip < ep) {
       int* markp = ip;
@@ -714,6 +717,15 @@ DFA::State* DFA::WorkqToCachedState(Workq* q, Workq* mq, uint32_t flag) {
     }
   }
 
+  // If we're in many match mode, canonicalize for similar reasons:
+  // we have an unordered set of states (i.e. we don't have Marks)
+  // and sorting will reduce the number of distinct sets stored.
+  if (kind_ == Prog::kManyMatch) {
+    int* ip = inst.data();
+    int* ep = ip + n;
+    std::sort(ip, ep);
+  }
+
   // Append MatchSep and the match IDs in mq if necessary.
   if (mq != NULL) {
     inst[n++] = MatchSep;
@@ -728,8 +740,7 @@ DFA::State* DFA::WorkqToCachedState(Workq* q, Workq* mq, uint32_t flag) {
   // Save the needed empty-width flags in the top bits for use later.
   flag |= needflags << kFlagNeedShift;
 
-  State* state = CachedState(inst, n, flag);
-  delete[] inst;
+  State* state = CachedState(inst.data(), n, flag);
   return state;
 }
 
@@ -749,25 +760,29 @@ DFA::State* DFA::CachedState(int* inst, int ninst, uint32_t flag) {
   StateSet::iterator it = state_cache_.find(&state);
   if (it != state_cache_.end()) {
     if (ExtraDebug)
-      fprintf(stderr, " -cached-> %s\n", DumpState(*it).c_str());
+      absl::FPrintF(stderr, " -cached-> %s\n", DumpState(*it));
     return *it;
   }
 
   // Must have enough memory for new state.
   // In addition to what we're going to allocate,
-  // the state cache hash table seems to incur about 40 bytes per
-  // State*, empirically.
-  const int kStateCacheOverhead = 40;
+  // the state cache hash table seems to incur about 18 bytes per
+  // State*. Worst case for non-small sets is it being half full, where each
+  // value present takes up 1 byte hash sample plus the pointer itself.
+  const int kStateCacheOverhead = 18;
   int nnext = prog_->bytemap_range() + 1;  // + 1 for kByteEndText slot
-  int mem = sizeof(State) + nnext*sizeof(std::atomic<State*>) +
-            ninst*sizeof(int);
-  if (mem_budget_ < mem + kStateCacheOverhead) {
+  int mem = sizeof(State) + nnext*sizeof(std::atomic<State*>);
+  int instmem = ninst*sizeof(int);
+  if (mem_budget_ < mem + instmem + kStateCacheOverhead) {
     mem_budget_ = -1;
     return NULL;
   }
-  mem_budget_ -= mem + kStateCacheOverhead;
+  mem_budget_ -= mem + instmem + kStateCacheOverhead;
 
   // Allocate new state along with room for next_ and inst_.
+  // inst_ is stored separately since it's colder; this also
+  // means that the States for a given DFA are the same size
+  // class, so the allocator can hopefully pack them better.
   char* space = std::allocator<char>().allocate(mem);
   State* s = new (space) State;
   (void) new (s->next_) std::atomic<State*>[nnext];
@@ -775,12 +790,13 @@ DFA::State* DFA::CachedState(int* inst, int ninst, uint32_t flag) {
   // (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64658)
   for (int i = 0; i < nnext; i++)
     (void) new (s->next_ + i) std::atomic<State*>(NULL);
-  s->inst_ = new (s->next_ + nnext) int[ninst];
-  memmove(s->inst_, inst, ninst*sizeof s->inst_[0]);
+  s->inst_ = std::allocator<int>().allocate(ninst);
+  (void) new (s->inst_) int[ninst];
+  memmove(s->inst_, inst, instmem);
   s->ninst_ = ninst;
   s->flag_ = flag;
   if (ExtraDebug)
-    fprintf(stderr, " -> %s\n", DumpState(s).c_str());
+    absl::FPrintF(stderr, " -> %s\n", DumpState(s));
 
   // Put state in cache and return it.
   state_cache_.insert(s);
@@ -794,12 +810,12 @@ void DFA::ClearCache() {
   while (begin != end) {
     StateSet::iterator tmp = begin;
     ++begin;
+    // Deallocate the instruction array, which is stored separately as above.
+    std::allocator<int>().deallocate((*tmp)->inst_, (*tmp)->ninst_);
     // Deallocate the blob of memory that we allocated in DFA::CachedState().
     // We recompute mem in order to benefit from sized delete where possible.
-    int ninst = (*tmp)->ninst_;
     int nnext = prog_->bytemap_range() + 1;  // + 1 for kByteEndText slot
-    int mem = sizeof(State) + nnext*sizeof(std::atomic<State*>) +
-              ninst*sizeof(int);
+    int mem = sizeof(State) + nnext*sizeof(std::atomic<State*>);
     std::allocator<char>().deallocate(reinterpret_cast<char*>(*tmp), mem);
   }
   state_cache_.clear();
@@ -963,8 +979,21 @@ void DFA::RunWorkqOnByte(Workq* oldq, Workq* newq,
         break;
 
       case kInstByteRange:   // can follow if c is in range
-        if (ip->Matches(c))
-          AddToQueue(newq, ip->out(), flag);
+        if (!ip->Matches(c))
+          break;
+        AddToQueue(newq, ip->out(), flag);
+        if (ip->hint() != 0) {
+          // We have a hint, but we must cancel out the
+          // increment that will occur after the break.
+          i += ip->hint() - 1;
+        } else {
+          // We have no hint, so we must find the end
+          // of the current list and then skip to it.
+          Prog::Inst* ip0 = ip;
+          while (!ip->last())
+            ++ip;
+          i += ip - ip0;
+        }
         break;
 
       case kInstMatch:
@@ -981,8 +1010,8 @@ void DFA::RunWorkqOnByte(Workq* oldq, Workq* newq,
   }
 
   if (ExtraDebug)
-    fprintf(stderr, "%s on %d[%#x] -> %s [%d]\n", DumpWorkq(oldq).c_str(),
-            c, flag, DumpWorkq(newq).c_str(), *ismatch);
+    absl::FPrintF(stderr, "%s on %d[%#x] -> %s [%d]\n",
+                  DumpWorkq(oldq), c, flag, DumpWorkq(newq), *ismatch);
 }
 
 // Processes input byte c in state, returning new state.
@@ -990,7 +1019,7 @@ void DFA::RunWorkqOnByte(Workq* oldq, Workq* newq,
 DFA::State* DFA::RunStateOnByteUnlocked(State* state, int c) {
   // Keep only one RunStateOnByte going
   // even if the DFA is being run by multiple threads.
-  MutexLock l(&mutex_);
+  absl::MutexLock l(&mutex_);
   return RunStateOnByte(state, c);
 }
 
@@ -1109,7 +1138,7 @@ DFA::State* DFA::RunStateOnByte(State* state, int c) {
 
 class DFA::RWLocker {
  public:
-  explicit RWLocker(Mutex* mu);
+  explicit RWLocker(CacheMutex* mu);
   ~RWLocker();
 
   // If the lock is only held for reading right now,
@@ -1119,20 +1148,20 @@ class DFA::RWLocker {
   void LockForWriting();
 
  private:
-  Mutex* mu_;
+  CacheMutex* mu_;
   bool writing_;
 
   RWLocker(const RWLocker&) = delete;
   RWLocker& operator=(const RWLocker&) = delete;
 };
 
-DFA::RWLocker::RWLocker(Mutex* mu) : mu_(mu), writing_(false) {
+DFA::RWLocker::RWLocker(CacheMutex* mu) : mu_(mu), writing_(false) {
   mu_->ReaderLock();
 }
 
-// This function is marked as NO_THREAD_SAFETY_ANALYSIS because the annotations
-// does not support lock upgrade.
-void DFA::RWLocker::LockForWriting() NO_THREAD_SAFETY_ANALYSIS {
+// This function is marked as ABSL_NO_THREAD_SAFETY_ANALYSIS because
+// the annotations don't support lock upgrade.
+void DFA::RWLocker::LockForWriting() ABSL_NO_THREAD_SAFETY_ANALYSIS {
   if (!writing_) {
     mu_->ReaderUnlock();
     mu_->WriterLock();
@@ -1163,11 +1192,14 @@ void DFA::ResetCache(RWLocker* cache_lock) {
   // Re-acquire the cache_mutex_ for writing (exclusive use).
   cache_lock->LockForWriting();
 
+  hooks::GetDFAStateCacheResetHook()({
+      state_budget_,
+      state_cache_.size(),
+  });
+
   // Clear the cache, reset the memory budget.
-  for (int i = 0; i < kMaxStart; i++) {
-    start_[i].start = NULL;
-    start_[i].first_byte.store(kFbUnknown, std::memory_order_relaxed);
-  }
+  for (int i = 0; i < kMaxStart; i++)
+    start_[i].start.store(NULL, std::memory_order_relaxed);
   ClearCache();
   mem_budget_ = state_budget_;
 }
@@ -1239,7 +1271,7 @@ DFA::StateSaver::~StateSaver() {
 DFA::State* DFA::StateSaver::Restore() {
   if (is_special_)
     return special_;
-  MutexLock l(&dfa_->mutex_);
+  absl::MutexLock l(&dfa_->mutex_);
   State* s = dfa_->CachedState(inst_, ninst_, flag_);
   if (s == NULL)
     LOG(DFATAL) << "StateSaver failed to restore state.";
@@ -1282,8 +1314,7 @@ DFA::State* DFA::StateSaver::Restore() {
 // situation, the DFA can do better than executing the simple loop.
 // Instead, it can call memchr to search very quickly for the byte c.
 // Whether the start state has this property is determined during a
-// pre-compilation pass, and if so, the byte b is passed to the search
-// loop as the "first_byte" argument, along with a boolean "have_first_byte".
+// pre-compilation pass and the "can_prefix_accel" argument is set.
 //
 // Fourth, the desired behavior is to search for the leftmost-best match
 // (approximately, the same one that Perl would find), which is not
@@ -1315,15 +1346,16 @@ DFA::State* DFA::StateSaver::Restore() {
 // The bools are equal to the same-named variables in params, but
 // making them function arguments lets the inliner specialize
 // this function to each combination (see two paragraphs above).
-inline bool DFA::InlinedSearchLoop(SearchParams* params,
-                                   bool have_first_byte,
-                                   bool want_earliest_match,
-                                   bool run_forward) {
+template <bool can_prefix_accel,
+          bool want_earliest_match,
+          bool run_forward>
+inline bool DFA::InlinedSearchLoop(SearchParams* params) {
   State* start = params->start;
-  const uint8_t* bp = BytePtr(params->text.begin());  // start of text
-  const uint8_t* p = bp;                              // text scanning point
-  const uint8_t* ep = BytePtr(params->text.end());    // end of text
-  const uint8_t* resetp = NULL;                       // p at last cache reset
+  const uint8_t* bp = BytePtr(params->text.data());  // start of text
+  const uint8_t* p = bp;                             // text scanning point
+  const uint8_t* ep = BytePtr(params->text.data() +
+                              params->text.size());  // end of text
+  const uint8_t* resetp = NULL;                      // p at last cache reset
   if (!run_forward) {
     using std::swap;
     swap(p, ep);
@@ -1335,13 +1367,13 @@ inline bool DFA::InlinedSearchLoop(SearchParams* params,
 
   State* s = start;
   if (ExtraDebug)
-    fprintf(stderr, "@stx: %s\n", DumpState(s).c_str());
+    absl::FPrintF(stderr, "@stx: %s\n", DumpState(s));
 
   if (s->IsMatch()) {
     matched = true;
     lastmatch = p;
     if (ExtraDebug)
-      fprintf(stderr, "match @stx! [%s]\n", DumpState(s).c_str());
+      absl::FPrintF(stderr, "match @stx! [%s]\n", DumpState(s));
     if (params->matches != NULL && kind_ == Prog::kManyMatch) {
       for (int i = s->ninst_ - 1; i >= 0; i--) {
         int id = s->inst_[i];
@@ -1358,25 +1390,16 @@ inline bool DFA::InlinedSearchLoop(SearchParams* params,
 
   while (p != ep) {
     if (ExtraDebug)
-      fprintf(stderr, "@%td: %s\n",
-              p - bp, DumpState(s).c_str());
-
-    if (have_first_byte && s == start) {
-      // In start state, only way out is to find first_byte,
-      // so use optimized assembly in memchr to skip ahead.
-      // If first_byte isn't found, we can skip to the end
-      // of the string.
-      if (run_forward) {
-        if ((p = BytePtr(memchr(p, params->first_byte, ep - p))) == NULL) {
-          p = ep;
-          break;
-        }
-      } else {
-        if ((p = BytePtr(memrchr(ep, params->first_byte, p - ep))) == NULL) {
-          p = ep;
-          break;
-        }
-        p++;
+      absl::FPrintF(stderr, "@%d: %s\n", p - bp, DumpState(s));
+
+    if (can_prefix_accel && s == start) {
+      // In start state, only way out is to find the prefix,
+      // so we use prefix accel (e.g. memchr) to skip ahead.
+      // If not found, we can skip to the end of the string.
+      p = BytePtr(prog_->PrefixAccel(p, ep - p));
+      if (p == NULL) {
+        p = ep;
+        break;
       }
     }
 
@@ -1415,9 +1438,11 @@ inline bool DFA::InlinedSearchLoop(SearchParams* params,
         // byte runs at about 0.2 MB/s, while the NFA (nfa.cc) can do the
         // same at about 2 MB/s.  Unless we're processing an average
         // of 10 bytes per state computation, fail so that RE2 can
-        // fall back to the NFA.
+        // fall back to the NFA.  However, RE2::Set cannot fall back,
+        // so we just have to keep on keeping on in that case.
         if (dfa_should_bail_when_slow && resetp != NULL &&
-            static_cast<size_t>(p - resetp) < 10*state_cache_.size()) {
+            static_cast<size_t>(p - resetp) < 10*state_cache_.size() &&
+            kind_ != Prog::kManyMatch) {
           params->failed = true;
           return false;
         }
@@ -1465,8 +1490,7 @@ inline bool DFA::InlinedSearchLoop(SearchParams* params,
       else
         lastmatch = p + 1;
       if (ExtraDebug)
-        fprintf(stderr, "match @%td! [%s]\n",
-                lastmatch - bp, DumpState(s).c_str());
+        absl::FPrintF(stderr, "match @%d! [%s]\n", lastmatch - bp, DumpState(s));
       if (params->matches != NULL && kind_ == Prog::kManyMatch) {
         for (int i = s->ninst_ - 1; i >= 0; i--) {
           int id = s->inst_[i];
@@ -1485,19 +1509,19 @@ inline bool DFA::InlinedSearchLoop(SearchParams* params,
   // Process one more byte to see if it triggers a match.
   // (Remember, matches are delayed one byte.)
   if (ExtraDebug)
-    fprintf(stderr, "@etx: %s\n", DumpState(s).c_str());
+    absl::FPrintF(stderr, "@etx: %s\n", DumpState(s));
 
   int lastbyte;
   if (run_forward) {
-    if (params->text.end() == params->context.end())
+    if (EndPtr(params->text) == EndPtr(params->context))
       lastbyte = kByteEndText;
     else
-      lastbyte = params->text.end()[0] & 0xFF;
+      lastbyte = EndPtr(params->text)[0] & 0xFF;
   } else {
-    if (params->text.begin() == params->context.begin())
+    if (BeginPtr(params->text) == BeginPtr(params->context))
       lastbyte = kByteEndText;
     else
-      lastbyte = params->text.begin()[-1] & 0xFF;
+      lastbyte = BeginPtr(params->text)[-1] & 0xFF;
   }
 
   State* ns = s->next_[ByteMap(lastbyte)].load(std::memory_order_acquire);
@@ -1533,7 +1557,7 @@ inline bool DFA::InlinedSearchLoop(SearchParams* params,
     matched = true;
     lastmatch = p;
     if (ExtraDebug)
-      fprintf(stderr, "match @etx! [%s]\n", DumpState(s).c_str());
+      absl::FPrintF(stderr, "match @etx! [%s]\n", DumpState(s));
     if (params->matches != NULL && kind_ == Prog::kManyMatch) {
       for (int i = s->ninst_ - 1; i >= 0; i--) {
         int id = s->inst_[i];
@@ -1550,36 +1574,28 @@ inline bool DFA::InlinedSearchLoop(SearchParams* params,
 
 // Inline specializations of the general loop.
 bool DFA::SearchFFF(SearchParams* params) {
-  return InlinedSearchLoop(params, 0, 0, 0);
+  return InlinedSearchLoop<false, false, false>(params);
 }
 bool DFA::SearchFFT(SearchParams* params) {
-  return InlinedSearchLoop(params, 0, 0, 1);
+  return InlinedSearchLoop<false, false, true>(params);
 }
 bool DFA::SearchFTF(SearchParams* params) {
-  return InlinedSearchLoop(params, 0, 1, 0);
+  return InlinedSearchLoop<false, true, false>(params);
 }
 bool DFA::SearchFTT(SearchParams* params) {
-  return InlinedSearchLoop(params, 0, 1, 1);
+  return InlinedSearchLoop<false, true, true>(params);
 }
 bool DFA::SearchTFF(SearchParams* params) {
-  return InlinedSearchLoop(params, 1, 0, 0);
+  return InlinedSearchLoop<true, false, false>(params);
 }
 bool DFA::SearchTFT(SearchParams* params) {
-  return InlinedSearchLoop(params, 1, 0, 1);
+  return InlinedSearchLoop<true, false, true>(params);
 }
 bool DFA::SearchTTF(SearchParams* params) {
-  return InlinedSearchLoop(params, 1, 1, 0);
+  return InlinedSearchLoop<true, true, false>(params);
 }
 bool DFA::SearchTTT(SearchParams* params) {
-  return InlinedSearchLoop(params, 1, 1, 1);
-}
-
-// For debugging, calls the general code directly.
-bool DFA::SlowSearchLoop(SearchParams* params) {
-  return InlinedSearchLoop(params,
-                           params->first_byte >= 0,
-                           params->want_earliest_match,
-                           params->run_forward);
+  return InlinedSearchLoop<true, true, true>(params);
 }
 
 // For performance, calls the appropriate specialized version
@@ -1598,8 +1614,7 @@ bool DFA::FastSearchLoop(SearchParams* params) {
     &DFA::SearchTTT,
   };
 
-  bool have_first_byte = params->first_byte >= 0;
-  int index = 4 * have_first_byte +
+  int index = 4 * params->can_prefix_accel +
               2 * params->want_earliest_match +
               1 * params->run_forward;
   return (this->*Searches[index])(params);
@@ -1633,11 +1648,11 @@ bool DFA::FastSearchLoop(SearchParams* params) {
 // state for the DFA search loop.  Fills in params and returns true on success.
 // Returns false on failure.
 bool DFA::AnalyzeSearch(SearchParams* params) {
-  const StringPiece& text = params->text;
-  const StringPiece& context = params->context;
+  absl::string_view text = params->text;
+  absl::string_view context = params->context;
 
   // Sanity check: make sure that text lies within context.
-  if (text.begin() < context.begin() || text.end() > context.end()) {
+  if (BeginPtr(text) < BeginPtr(context) || EndPtr(text) > EndPtr(context)) {
     LOG(DFATAL) << "context does not contain text";
     params->start = DeadState;
     return true;
@@ -1647,13 +1662,13 @@ bool DFA::AnalyzeSearch(SearchParams* params) {
   int start;
   uint32_t flags;
   if (params->run_forward) {
-    if (text.begin() == context.begin()) {
+    if (BeginPtr(text) == BeginPtr(context)) {
       start = kStartBeginText;
       flags = kEmptyBeginText|kEmptyBeginLine;
-    } else if (text.begin()[-1] == '\n') {
+    } else if (BeginPtr(text)[-1] == '\n') {
       start = kStartBeginLine;
       flags = kEmptyBeginLine;
-    } else if (Prog::IsWordChar(text.begin()[-1] & 0xFF)) {
+    } else if (Prog::IsWordChar(BeginPtr(text)[-1] & 0xFF)) {
       start = kStartAfterWordChar;
       flags = kFlagLastWord;
     } else {
@@ -1661,13 +1676,13 @@ bool DFA::AnalyzeSearch(SearchParams* params) {
       flags = 0;
     }
   } else {
-    if (text.end() == context.end()) {
+    if (EndPtr(text) == EndPtr(context)) {
       start = kStartBeginText;
       flags = kEmptyBeginText|kEmptyBeginLine;
-    } else if (text.end()[0] == '\n') {
+    } else if (EndPtr(text)[0] == '\n') {
       start = kStartBeginLine;
       flags = kEmptyBeginLine;
-    } else if (Prog::IsWordChar(text.end()[0] & 0xFF)) {
+    } else if (Prog::IsWordChar(EndPtr(text)[0] & 0xFF)) {
       start = kStartAfterWordChar;
       flags = kFlagLastWord;
     } else {
@@ -1685,19 +1700,28 @@ bool DFA::AnalyzeSearch(SearchParams* params) {
   if (!AnalyzeSearchHelper(params, info, flags)) {
     ResetCache(params->cache_lock);
     if (!AnalyzeSearchHelper(params, info, flags)) {
-      LOG(DFATAL) << "Failed to analyze start state.";
       params->failed = true;
+      LOG(DFATAL) << "Failed to analyze start state.";
       return false;
     }
   }
 
-  if (ExtraDebug)
-    fprintf(stderr, "anchored=%d fwd=%d flags=%#x state=%s first_byte=%d\n",
-            params->anchored, params->run_forward, flags,
-            DumpState(info->start).c_str(), info->first_byte.load());
+  params->start = info->start.load(std::memory_order_acquire);
+
+  // Even if we could prefix accel, we cannot do so when anchored and,
+  // less obviously, we cannot do so when we are going to need flags.
+  // This trick works only when there is a single byte that leads to a
+  // different state!
+  if (prog_->can_prefix_accel() &&
+      !params->anchored &&
+      params->start > SpecialStateMax &&
+      params->start->flag_ >> kFlagNeedShift == 0)
+    params->can_prefix_accel = true;
 
-  params->start = info->start;
-  params->first_byte = info->first_byte.load(std::memory_order_acquire);
+  if (ExtraDebug)
+    absl::FPrintF(stderr, "anchored=%d fwd=%d flags=%#x state=%s can_prefix_accel=%d\n",
+                  params->anchored, params->run_forward, flags,
+                  DumpState(params->start), params->can_prefix_accel);
 
   return true;
 }
@@ -1706,59 +1730,32 @@ bool DFA::AnalyzeSearch(SearchParams* params) {
 bool DFA::AnalyzeSearchHelper(SearchParams* params, StartInfo* info,
                               uint32_t flags) {
   // Quick check.
-  int fb = info->first_byte.load(std::memory_order_acquire);
-  if (fb != kFbUnknown)
+  State* start = info->start.load(std::memory_order_acquire);
+  if (start != NULL)
     return true;
 
-  MutexLock l(&mutex_);
-  fb = info->first_byte.load(std::memory_order_relaxed);
-  if (fb != kFbUnknown)
+  absl::MutexLock l(&mutex_);
+  start = info->start.load(std::memory_order_relaxed);
+  if (start != NULL)
     return true;
 
   q0_->clear();
   AddToQueue(q0_,
              params->anchored ? prog_->start() : prog_->start_unanchored(),
              flags);
-  info->start = WorkqToCachedState(q0_, NULL, flags);
-  if (info->start == NULL)
+  start = WorkqToCachedState(q0_, NULL, flags);
+  if (start == NULL)
     return false;
 
-  if (info->start == DeadState) {
-    // Synchronize with "quick check" above.
-    info->first_byte.store(kFbNone, std::memory_order_release);
-    return true;
-  }
-
-  if (info->start == FullMatchState) {
-    // Synchronize with "quick check" above.
-    info->first_byte.store(kFbNone, std::memory_order_release);  // will be ignored
-    return true;
-  }
-
-  // Even if we have a first_byte, we cannot use it when anchored and,
-  // less obviously, we cannot use it when we are going to need flags.
-  // This trick works only when there is a single byte that leads to a
-  // different state!
-  int first_byte = prog_->first_byte();
-  if (first_byte == -1 ||
-      params->anchored ||
-      info->start->flag_ >> kFlagNeedShift != 0)
-    first_byte = kFbNone;
-
   // Synchronize with "quick check" above.
-  info->first_byte.store(first_byte, std::memory_order_release);
+  info->start.store(start, std::memory_order_release);
   return true;
 }
 
 // The actual DFA search: calls AnalyzeSearch and then FastSearchLoop.
-bool DFA::Search(const StringPiece& text,
-                 const StringPiece& context,
-                 bool anchored,
-                 bool want_earliest_match,
-                 bool run_forward,
-                 bool* failed,
-                 const char** epp,
-                 SparseSet* matches) {
+bool DFA::Search(absl::string_view text, absl::string_view context,
+                 bool anchored, bool want_earliest_match, bool run_forward,
+                 bool* failed, const char** epp, SparseSet* matches) {
   *epp = NULL;
   if (!ok()) {
     *failed = true;
@@ -1767,10 +1764,9 @@ bool DFA::Search(const StringPiece& text,
   *failed = false;
 
   if (ExtraDebug) {
-    fprintf(stderr, "\nprogram:\n%s\n", prog_->DumpUnanchored().c_str());
-    fprintf(stderr, "text %s anchored=%d earliest=%d fwd=%d kind %d\n",
-            string(text).c_str(), anchored, want_earliest_match,
-            run_forward, kind_);
+    absl::FPrintF(stderr, "\nprogram:\n%s\n", prog_->DumpUnanchored());
+    absl::FPrintF(stderr, "text %s anchored=%d earliest=%d fwd=%d kind %d\n",
+                  text, anchored, want_earliest_match, run_forward, kind_);
   }
 
   RWLocker l(&cache_mutex_);
@@ -1788,13 +1784,13 @@ bool DFA::Search(const StringPiece& text,
     return false;
   if (params.start == FullMatchState) {
     if (run_forward == want_earliest_match)
-      *epp = text.begin();
+      *epp = text.data();
     else
-      *epp = text.end();
+      *epp = text.data() + text.size();
     return true;
   }
   if (ExtraDebug)
-    fprintf(stderr, "start %s\n", DumpState(params.start).c_str());
+    absl::FPrintF(stderr, "start %s\n", DumpState(params.start));
   bool ret = FastSearchLoop(&params);
   if (params.failed) {
     *failed = true;
@@ -1813,17 +1809,17 @@ DFA* Prog::GetDFA(MatchKind kind) {
   // "longest match" DFA, because RE2 never does reverse
   // "first match" searches.
   if (kind == kFirstMatch) {
-    std::call_once(dfa_first_once_, [](Prog* prog) {
+    absl::call_once(dfa_first_once_, [](Prog* prog) {
       prog->dfa_first_ = new DFA(prog, kFirstMatch, prog->dfa_mem_ / 2);
     }, this);
     return dfa_first_;
   } else if (kind == kManyMatch) {
-    std::call_once(dfa_first_once_, [](Prog* prog) {
+    absl::call_once(dfa_first_once_, [](Prog* prog) {
       prog->dfa_first_ = new DFA(prog, kManyMatch, prog->dfa_mem_);
     }, this);
     return dfa_first_;
   } else {
-    std::call_once(dfa_longest_once_, [](Prog* prog) {
+    absl::call_once(dfa_longest_once_, [](Prog* prog) {
       if (!prog->reversed_)
         prog->dfa_longest_ = new DFA(prog, kLongestMatch, prog->dfa_mem_ / 2);
       else
@@ -1847,23 +1843,22 @@ void Prog::DeleteDFA(DFA* dfa) {
 //
 // This is the only external interface (class DFA only exists in this file).
 //
-bool Prog::SearchDFA(const StringPiece& text, const StringPiece& const_context,
-                     Anchor anchor, MatchKind kind, StringPiece* match0,
+bool Prog::SearchDFA(absl::string_view text, absl::string_view context,
+                     Anchor anchor, MatchKind kind, absl::string_view* match0,
                      bool* failed, SparseSet* matches) {
   *failed = false;
 
-  StringPiece context = const_context;
-  if (context.begin() == NULL)
+  if (context.data() == NULL)
     context = text;
-  bool carat = anchor_start();
+  bool caret = anchor_start();
   bool dollar = anchor_end();
   if (reversed_) {
     using std::swap;
-    swap(carat, dollar);
+    swap(caret, dollar);
   }
-  if (carat && context.begin() != text.begin())
+  if (caret && BeginPtr(context) != BeginPtr(text))
     return false;
-  if (dollar && context.end() != text.end())
+  if (dollar && EndPtr(context) != EndPtr(text))
     return false;
 
   // Handle full match by running an anchored longest match
@@ -1896,11 +1891,15 @@ bool Prog::SearchDFA(const StringPiece& text, const StringPiece& const_context,
   bool matched = dfa->Search(text, context, anchored,
                              want_earliest_match, !reversed_,
                              failed, &ep, matches);
-  if (*failed)
+  if (*failed) {
+    hooks::GetDFASearchFailureHook()({
+        // Nothing yet...
+    });
     return false;
+  }
   if (!matched)
     return false;
-  if (endmatch && ep != (reversed_ ? text.begin() : text.end()))
+  if (endmatch && ep != (reversed_ ? text.data() : text.data() + text.size()))
     return false;
 
   // If caller cares, record the boundary of the match.
@@ -1908,10 +1907,11 @@ bool Prog::SearchDFA(const StringPiece& text, const StringPiece& const_context,
   // as the beginning.
   if (match0) {
     if (reversed_)
-      *match0 = StringPiece(ep, static_cast<size_t>(text.end() - ep));
+      *match0 =
+          absl::string_view(ep, static_cast<size_t>(text.data() + text.size() - ep));
     else
       *match0 =
-          StringPiece(text.begin(), static_cast<size_t>(ep - text.begin()));
+          absl::string_view(text.data(), static_cast<size_t>(ep - text.data()));
   }
   return true;
 }
@@ -1924,7 +1924,7 @@ int DFA::BuildAllStates(const Prog::DFAStateCallback& cb) {
   // Pick out start state for unanchored search
   // at beginning of text.
   RWLocker l(&cache_mutex_);
-  SearchParams params(StringPiece(), StringPiece(), &l);
+  SearchParams params(absl::string_view(), absl::string_view(), &l);
   params.anchored = false;
   if (!AnalyzeSearch(&params) ||
       params.start == NULL ||
@@ -1934,7 +1934,7 @@ int DFA::BuildAllStates(const Prog::DFAStateCallback& cb) {
   // Add start state to work queue.
   // Note that any State* that we handle here must point into the cache,
   // so we can simply depend on pointer-as-a-number hashing and equality.
-  std::unordered_map<State*, int> m;
+  absl::flat_hash_map<State*, int> m;
   std::deque<State*> q;
   m.emplace(params.start, static_cast<int>(m.size()));
   q.push_back(params.start);
@@ -1989,13 +1989,9 @@ int Prog::BuildEntireDFA(MatchKind kind, const DFAStateCallback& cb) {
   return GetDFA(kind)->BuildAllStates(cb);
 }
 
-void Prog::TEST_dfa_should_bail_when_slow(bool b) {
-  dfa_should_bail_when_slow = b;
-}
-
 // Computes min and max for matching string.
 // Won't return strings bigger than maxlen.
-bool DFA::PossibleMatchRange(string* min, string* max, int maxlen) {
+bool DFA::PossibleMatchRange(std::string* min, std::string* max, int maxlen) {
   if (!ok())
     return false;
 
@@ -2012,11 +2008,11 @@ bool DFA::PossibleMatchRange(string* min, string* max, int maxlen) {
   // Also note that previously_visited_states[UnseenStatePtr] will, in the STL
   // tradition, implicitly insert a '0' value at first use. We take advantage
   // of that property below.
-  std::unordered_map<State*, int> previously_visited_states;
+  absl::flat_hash_map<State*, int> previously_visited_states;
 
   // Pick out start state for anchored search at beginning of text.
   RWLocker l(&cache_mutex_);
-  SearchParams params(StringPiece(), StringPiece(), &l);
+  SearchParams params(absl::string_view(), absl::string_view(), &l);
   params.anchored = true;
   if (!AnalyzeSearch(&params))
     return false;
@@ -2056,7 +2052,7 @@ bool DFA::PossibleMatchRange(string* min, string* max, int maxlen) {
   // Build minimum prefix.
   State* s = params.start;
   min->clear();
-  MutexLock lock(&mutex_);
+  absl::MutexLock lock(&mutex_);
   for (int i = 0; i < maxlen; i++) {
     if (previously_visited_states[s] > kMaxEltRepetitions)
       break;
@@ -2132,7 +2128,7 @@ bool DFA::PossibleMatchRange(string* min, string* max, int maxlen) {
 }
 
 // PossibleMatchRange for a Prog.
-bool Prog::PossibleMatchRange(string* min, string* max, int maxlen) {
+bool Prog::PossibleMatchRange(std::string* min, std::string* max, int maxlen) {
   // Have to use dfa_longest_ to get all strings for full matches.
   // For example, (a|aa) never matches aa in first-match mode.
   return GetDFA(kLongestMatch)->PossibleMatchRange(min, max, maxlen);
diff --git a/re2/filtered_re2.cc b/re2/filtered_re2.cc
index 12f638a..49cf686 100644
--- a/re2/filtered_re2.cc
+++ b/re2/filtered_re2.cc
@@ -6,8 +6,8 @@
 
 #include <stddef.h>
 #include <string>
+#include <utility>
 
-#include "util/util.h"
 #include "util/logging.h"
 #include "re2/prefilter.h"
 #include "re2/prefilter_tree.h"
@@ -27,10 +27,25 @@ FilteredRE2::FilteredRE2(int min_atom_len)
 FilteredRE2::~FilteredRE2() {
   for (size_t i = 0; i < re2_vec_.size(); i++)
     delete re2_vec_[i];
-  delete prefilter_tree_;
 }
 
-RE2::ErrorCode FilteredRE2::Add(const StringPiece& pattern,
+FilteredRE2::FilteredRE2(FilteredRE2&& other)
+    : re2_vec_(std::move(other.re2_vec_)),
+      compiled_(other.compiled_),
+      prefilter_tree_(std::move(other.prefilter_tree_)) {
+  other.re2_vec_.clear();
+  other.re2_vec_.shrink_to_fit();
+  other.compiled_ = false;
+  other.prefilter_tree_.reset(new PrefilterTree());
+}
+
+FilteredRE2& FilteredRE2::operator=(FilteredRE2&& other) {
+  this->~FilteredRE2();
+  (void) new (this) FilteredRE2(std::move(other));
+  return *this;
+}
+
+RE2::ErrorCode FilteredRE2::Add(absl::string_view pattern,
                                 const RE2::Options& options, int* id) {
   RE2* re = new RE2(pattern, options);
   RE2::ErrorCode code = re->error_code();
@@ -38,7 +53,7 @@ RE2::ErrorCode FilteredRE2::Add(const StringPiece& pattern,
   if (!re->ok()) {
     if (options.log_errors()) {
       LOG(ERROR) << "Couldn't compile regular expression, skipping: "
-                 << re << " due to error " << re->error();
+                 << pattern << " due to error " << re->error();
     }
     delete re;
   } else {
@@ -49,7 +64,7 @@ RE2::ErrorCode FilteredRE2::Add(const StringPiece& pattern,
   return code;
 }
 
-void FilteredRE2::Compile(std::vector<string>* atoms) {
+void FilteredRE2::Compile(std::vector<std::string>* atoms) {
   if (compiled_) {
     LOG(ERROR) << "Compile called already.";
     return;
@@ -69,14 +84,14 @@ void FilteredRE2::Compile(std::vector<string>* atoms) {
   compiled_ = true;
 }
 
-int FilteredRE2::SlowFirstMatch(const StringPiece& text) const {
+int FilteredRE2::SlowFirstMatch(absl::string_view text) const {
   for (size_t i = 0; i < re2_vec_.size(); i++)
     if (RE2::PartialMatch(text, *re2_vec_[i]))
       return static_cast<int>(i);
   return -1;
 }
 
-int FilteredRE2::FirstMatch(const StringPiece& text,
+int FilteredRE2::FirstMatch(absl::string_view text,
                             const std::vector<int>& atoms) const {
   if (!compiled_) {
     LOG(DFATAL) << "FirstMatch called before Compile.";
@@ -90,10 +105,9 @@ int FilteredRE2::FirstMatch(const StringPiece& text,
   return -1;
 }
 
-bool FilteredRE2::AllMatches(
-    const StringPiece& text,
-    const std::vector<int>& atoms,
-    std::vector<int>* matching_regexps) const {
+bool FilteredRE2::AllMatches(absl::string_view text,
+                             const std::vector<int>& atoms,
+                             std::vector<int>* matching_regexps) const {
   matching_regexps->clear();
   std::vector<int> regexps;
   prefilter_tree_->RegexpsGivenStrings(atoms, &regexps);
@@ -103,9 +117,8 @@ bool FilteredRE2::AllMatches(
   return !matching_regexps->empty();
 }
 
-void FilteredRE2::AllPotentials(
-    const std::vector<int>& atoms,
-    std::vector<int>* potential_regexps) const {
+void FilteredRE2::AllPotentials(const std::vector<int>& atoms,
+                                std::vector<int>* potential_regexps) const {
   prefilter_tree_->RegexpsGivenStrings(atoms, potential_regexps);
 }
 
diff --git a/re2/filtered_re2.h b/re2/filtered_re2.h
index b1317cc..a9abd69 100644
--- a/re2/filtered_re2.h
+++ b/re2/filtered_re2.h
@@ -10,20 +10,22 @@
 // number of regexps that need to be actually searched.
 //
 // By design, it does not include a string matching engine. This is to
-// allow the user of the class to use their favorite string match
+// allow the user of the class to use their favorite string matching
 // engine. The overall flow is: Add all the regexps using Add, then
-// Compile the FilteredRE2. The compile returns strings that need to
-// be matched. Note that all returned strings are lowercase. For
-// applying regexps to a search text, the caller does the string
-// matching using the strings returned. When doing the string match,
-// note that the caller has to do that on lower cased version of the
-// search text. Then call FirstMatch or AllMatches with a vector of
-// indices of strings that were found in the text to get the actual
-// regexp matches.
-
+// Compile the FilteredRE2. Compile returns strings that need to be
+// matched. Note that the returned strings are lowercased and distinct.
+// For applying regexps to a search text, the caller does the string
+// matching using the returned strings. When doing the string match,
+// note that the caller has to do that in a case-insensitive way or
+// on a lowercased version of the search text. Then call FirstMatch
+// or AllMatches with a vector of indices of strings that were found
+// in the text to get the actual regexp matches.
+
+#include <memory>
 #include <string>
 #include <vector>
 
+#include "absl/strings/string_view.h"
 #include "re2/re2.h"
 
 namespace re2 {
@@ -36,36 +38,43 @@ class FilteredRE2 {
   explicit FilteredRE2(int min_atom_len);
   ~FilteredRE2();
 
+  // Not copyable.
+  FilteredRE2(const FilteredRE2&) = delete;
+  FilteredRE2& operator=(const FilteredRE2&) = delete;
+  // Movable.
+  FilteredRE2(FilteredRE2&& other);
+  FilteredRE2& operator=(FilteredRE2&& other);
+
   // Uses RE2 constructor to create a RE2 object (re). Returns
   // re->error_code(). If error_code is other than NoError, then re is
   // deleted and not added to re2_vec_.
-  RE2::ErrorCode Add(const StringPiece& pattern,
+  RE2::ErrorCode Add(absl::string_view pattern,
                      const RE2::Options& options,
-                     int *id);
+                     int* id);
 
   // Prepares the regexps added by Add for filtering.  Returns a set
   // of strings that the caller should check for in candidate texts.
-  // The returned strings are lowercased. When doing string matching,
-  // the search text should be lowercased first to find matching
-  // strings from the set of strings returned by Compile.  Call after
+  // The returned strings are lowercased and distinct. When doing
+  // string matching, it should be performed in a case-insensitive
+  // way or the search text should be lowercased first.  Call after
   // all Add calls are done.
-  void Compile(std::vector<string>* strings_to_match);
+  void Compile(std::vector<std::string>* strings_to_match);
 
   // Returns the index of the first matching regexp.
   // Returns -1 on no match. Can be called prior to Compile.
   // Does not do any filtering: simply tries to Match the
   // regexps in a loop.
-  int SlowFirstMatch(const StringPiece& text) const;
+  int SlowFirstMatch(absl::string_view text) const;
 
   // Returns the index of the first matching regexp.
   // Returns -1 on no match. Compile has to be called before
   // calling this.
-  int FirstMatch(const StringPiece& text,
+  int FirstMatch(absl::string_view text,
                  const std::vector<int>& atoms) const;
 
   // Returns the indices of all matching regexps, after first clearing
   // matched_regexps.
-  bool AllMatches(const StringPiece& text,
+  bool AllMatches(absl::string_view text,
                   const std::vector<int>& atoms,
                   std::vector<int>* matching_regexps) const;
 
@@ -80,11 +89,10 @@ class FilteredRE2 {
   // The number of regexps added.
   int NumRegexps() const { return static_cast<int>(re2_vec_.size()); }
 
- private:
-
-  // Get the individual RE2 objects. Useful for testing.
-  RE2* GetRE2(int regexpid) const { return re2_vec_[regexpid]; }
+  // Get the individual RE2 objects.
+  const RE2& GetRE2(int regexpid) const { return *re2_vec_[regexpid]; }
 
+ private:
   // Print prefilter.
   void PrintPrefilter(int regexpid);
 
@@ -99,10 +107,7 @@ class FilteredRE2 {
   bool compiled_;
 
   // An AND-OR tree of string atoms used for filtering regexps.
-  PrefilterTree* prefilter_tree_;
-
-  FilteredRE2(const FilteredRE2&) = delete;
-  FilteredRE2& operator=(const FilteredRE2&) = delete;
+  std::unique_ptr<PrefilterTree> prefilter_tree_;
 };
 
 }  // namespace re2
diff --git a/re2/fuzzing/compiler-rt/LICENSE b/re2/fuzzing/compiler-rt/LICENSE
new file mode 100644
index 0000000..f9dc506
--- /dev/null
+++ b/re2/fuzzing/compiler-rt/LICENSE
@@ -0,0 +1,219 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+    1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+    2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+    3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+    4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+    5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+    6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+    7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+    8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+    9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+    END OF TERMS AND CONDITIONS
+
+    APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+    Copyright [yyyy] [name of copyright owner]
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+
+--- LLVM Exceptions to the Apache 2.0 License ----
+
+As an exception, if, as a result of your compiling your source code, portions
+of this Software are embedded into an Object form of such source code, you
+may redistribute such embedded portions in such Object form without complying
+with the conditions of Sections 4(a), 4(b) and 4(d) of the License.
+
+In addition, if you combine or link compiled forms of this Software with
+software that is licensed under the GPLv2 ("Combined Software") and if a
+court of competent jurisdiction determines that the patent provision (Section
+3), the indemnity provision (Section 9) or other Section of the License
+conflicts with the conditions of the GPLv2, you may retroactively and
+prospectively choose to deem waived or otherwise exclude such Section(s) of
+the License, but only in their entirety and only with respect to the Combined
+Software.
+
diff --git a/re2/fuzzing/compiler-rt/include/fuzzer/FuzzedDataProvider.h b/re2/fuzzing/compiler-rt/include/fuzzer/FuzzedDataProvider.h
new file mode 100644
index 0000000..71cb427
--- /dev/null
+++ b/re2/fuzzing/compiler-rt/include/fuzzer/FuzzedDataProvider.h
@@ -0,0 +1,397 @@
+//===- FuzzedDataProvider.h - Utility header for fuzz targets ---*- C++ -* ===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+// A single header library providing an utility class to break up an array of
+// bytes. Whenever run on the same input, provides the same output, as long as
+// its methods are called in the same order, with the same arguments.
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_FUZZER_FUZZED_DATA_PROVIDER_H_
+#define LLVM_FUZZER_FUZZED_DATA_PROVIDER_H_
+
+#include <algorithm>
+#include <array>
+#include <climits>
+#include <cstddef>
+#include <cstdint>
+#include <cstring>
+#include <initializer_list>
+#include <limits>
+#include <string>
+#include <type_traits>
+#include <utility>
+#include <vector>
+
+// In addition to the comments below, the API is also briefly documented at
+// https://github.com/google/fuzzing/blob/master/docs/split-inputs.md#fuzzed-data-provider
+class FuzzedDataProvider {
+ public:
+  // |data| is an array of length |size| that the FuzzedDataProvider wraps to
+  // provide more granular access. |data| must outlive the FuzzedDataProvider.
+  FuzzedDataProvider(const uint8_t *data, size_t size)
+      : data_ptr_(data), remaining_bytes_(size) {}
+  ~FuzzedDataProvider() = default;
+
+  // See the implementation below (after the class definition) for more verbose
+  // comments for each of the methods.
+
+  // Methods returning std::vector of bytes. These are the most popular choice
+  // when splitting fuzzing input into pieces, as every piece is put into a
+  // separate buffer (i.e. ASan would catch any under-/overflow) and the memory
+  // will be released automatically.
+  template <typename T> std::vector<T> ConsumeBytes(size_t num_bytes);
+  template <typename T>
+  std::vector<T> ConsumeBytesWithTerminator(size_t num_bytes, T terminator = 0);
+  template <typename T> std::vector<T> ConsumeRemainingBytes();
+
+  // Methods returning strings. Use only when you need a std::string or a null
+  // terminated C-string. Otherwise, prefer the methods returning std::vector.
+  std::string ConsumeBytesAsString(size_t num_bytes);
+  std::string ConsumeRandomLengthString(size_t max_length);
+  std::string ConsumeRandomLengthString();
+  std::string ConsumeRemainingBytesAsString();
+
+  // Methods returning integer values.
+  template <typename T> T ConsumeIntegral();
+  template <typename T> T ConsumeIntegralInRange(T min, T max);
+
+  // Methods returning floating point values.
+  template <typename T> T ConsumeFloatingPoint();
+  template <typename T> T ConsumeFloatingPointInRange(T min, T max);
+
+  // 0 <= return value <= 1.
+  template <typename T> T ConsumeProbability();
+
+  bool ConsumeBool();
+
+  // Returns a value chosen from the given enum.
+  template <typename T> T ConsumeEnum();
+
+  // Returns a value from the given array.
+  template <typename T, size_t size> T PickValueInArray(const T (&array)[size]);
+  template <typename T, size_t size>
+  T PickValueInArray(const std::array<T, size> &array);
+  template <typename T> T PickValueInArray(std::initializer_list<const T> list);
+
+  // Writes data to the given destination and returns number of bytes written.
+  size_t ConsumeData(void *destination, size_t num_bytes);
+
+  // Reports the remaining bytes available for fuzzed input.
+  size_t remaining_bytes() { return remaining_bytes_; }
+
+ private:
+  FuzzedDataProvider(const FuzzedDataProvider &) = delete;
+  FuzzedDataProvider &operator=(const FuzzedDataProvider &) = delete;
+
+  void CopyAndAdvance(void *destination, size_t num_bytes);
+
+  void Advance(size_t num_bytes);
+
+  template <typename T>
+  std::vector<T> ConsumeBytes(size_t size, size_t num_bytes);
+
+  template <typename TS, typename TU> TS ConvertUnsignedToSigned(TU value);
+
+  const uint8_t *data_ptr_;
+  size_t remaining_bytes_;
+};
+
+// Returns a std::vector containing |num_bytes| of input data. If fewer than
+// |num_bytes| of data remain, returns a shorter std::vector containing all
+// of the data that's left. Can be used with any byte sized type, such as
+// char, unsigned char, uint8_t, etc.
+template <typename T>
+std::vector<T> FuzzedDataProvider::ConsumeBytes(size_t num_bytes) {
+  num_bytes = std::min(num_bytes, remaining_bytes_);
+  return ConsumeBytes<T>(num_bytes, num_bytes);
+}
+
+// Similar to |ConsumeBytes|, but also appends the terminator value at the end
+// of the resulting vector. Useful, when a mutable null-terminated C-string is
+// needed, for example. But that is a rare case. Better avoid it, if possible,
+// and prefer using |ConsumeBytes| or |ConsumeBytesAsString| methods.
+template <typename T>
+std::vector<T> FuzzedDataProvider::ConsumeBytesWithTerminator(size_t num_bytes,
+                                                              T terminator) {
+  num_bytes = std::min(num_bytes, remaining_bytes_);
+  std::vector<T> result = ConsumeBytes<T>(num_bytes + 1, num_bytes);
+  result.back() = terminator;
+  return result;
+}
+
+// Returns a std::vector containing all remaining bytes of the input data.
+template <typename T>
+std::vector<T> FuzzedDataProvider::ConsumeRemainingBytes() {
+  return ConsumeBytes<T>(remaining_bytes_);
+}
+
+// Returns a std::string containing |num_bytes| of input data. Using this and
+// |.c_str()| on the resulting string is the best way to get an immutable
+// null-terminated C string. If fewer than |num_bytes| of data remain, returns
+// a shorter std::string containing all of the data that's left.
+inline std::string FuzzedDataProvider::ConsumeBytesAsString(size_t num_bytes) {
+  static_assert(sizeof(std::string::value_type) == sizeof(uint8_t),
+                "ConsumeBytesAsString cannot convert the data to a string.");
+
+  num_bytes = std::min(num_bytes, remaining_bytes_);
+  std::string result(
+      reinterpret_cast<const std::string::value_type *>(data_ptr_), num_bytes);
+  Advance(num_bytes);
+  return result;
+}
+
+// Returns a std::string of length from 0 to |max_length|. When it runs out of
+// input data, returns what remains of the input. Designed to be more stable
+// with respect to a fuzzer inserting characters than just picking a random
+// length and then consuming that many bytes with |ConsumeBytes|.
+inline std::string
+FuzzedDataProvider::ConsumeRandomLengthString(size_t max_length) {
+  // Reads bytes from the start of |data_ptr_|. Maps "\\" to "\", and maps "\"
+  // followed by anything else to the end of the string. As a result of this
+  // logic, a fuzzer can insert characters into the string, and the string
+  // will be lengthened to include those new characters, resulting in a more
+  // stable fuzzer than picking the length of a string independently from
+  // picking its contents.
+  std::string result;
+
+  // Reserve the anticipated capaticity to prevent several reallocations.
+  result.reserve(std::min(max_length, remaining_bytes_));
+  for (size_t i = 0; i < max_length && remaining_bytes_ != 0; ++i) {
+    char next = ConvertUnsignedToSigned<char>(data_ptr_[0]);
+    Advance(1);
+    if (next == '\\' && remaining_bytes_ != 0) {
+      next = ConvertUnsignedToSigned<char>(data_ptr_[0]);
+      Advance(1);
+      if (next != '\\')
+        break;
+    }
+    result += next;
+  }
+
+  result.shrink_to_fit();
+  return result;
+}
+
+// Returns a std::string of length from 0 to |remaining_bytes_|.
+inline std::string FuzzedDataProvider::ConsumeRandomLengthString() {
+  return ConsumeRandomLengthString(remaining_bytes_);
+}
+
+// Returns a std::string containing all remaining bytes of the input data.
+// Prefer using |ConsumeRemainingBytes| unless you actually need a std::string
+// object.
+inline std::string FuzzedDataProvider::ConsumeRemainingBytesAsString() {
+  return ConsumeBytesAsString(remaining_bytes_);
+}
+
+// Returns a number in the range [Type's min, Type's max]. The value might
+// not be uniformly distributed in the given range. If there's no input data
+// left, always returns |min|.
+template <typename T> T FuzzedDataProvider::ConsumeIntegral() {
+  return ConsumeIntegralInRange(std::numeric_limits<T>::min(),
+                                std::numeric_limits<T>::max());
+}
+
+// Returns a number in the range [min, max] by consuming bytes from the
+// input data. The value might not be uniformly distributed in the given
+// range. If there's no input data left, always returns |min|. |min| must
+// be less than or equal to |max|.
+template <typename T>
+T FuzzedDataProvider::ConsumeIntegralInRange(T min, T max) {
+  static_assert(std::is_integral<T>::value, "An integral type is required.");
+  static_assert(sizeof(T) <= sizeof(uint64_t), "Unsupported integral type.");
+
+  if (min > max)
+    abort();
+
+  // Use the biggest type possible to hold the range and the result.
+  uint64_t range = static_cast<uint64_t>(max) - min;
+  uint64_t result = 0;
+  size_t offset = 0;
+
+  while (offset < sizeof(T) * CHAR_BIT && (range >> offset) > 0 &&
+         remaining_bytes_ != 0) {
+    // Pull bytes off the end of the seed data. Experimentally, this seems to
+    // allow the fuzzer to more easily explore the input space. This makes
+    // sense, since it works by modifying inputs that caused new code to run,
+    // and this data is often used to encode length of data read by
+    // |ConsumeBytes|. Separating out read lengths makes it easier modify the
+    // contents of the data that is actually read.
+    --remaining_bytes_;
+    result = (result << CHAR_BIT) | data_ptr_[remaining_bytes_];
+    offset += CHAR_BIT;
+  }
+
+  // Avoid division by 0, in case |range + 1| results in overflow.
+  if (range != std::numeric_limits<decltype(range)>::max())
+    result = result % (range + 1);
+
+  return static_cast<T>(min + result);
+}
+
+// Returns a floating point value in the range [Type's lowest, Type's max] by
+// consuming bytes from the input data. If there's no input data left, always
+// returns approximately 0.
+template <typename T> T FuzzedDataProvider::ConsumeFloatingPoint() {
+  return ConsumeFloatingPointInRange<T>(std::numeric_limits<T>::lowest(),
+                                        std::numeric_limits<T>::max());
+}
+
+// Returns a floating point value in the given range by consuming bytes from
+// the input data. If there's no input data left, returns |min|. Note that
+// |min| must be less than or equal to |max|.
+template <typename T>
+T FuzzedDataProvider::ConsumeFloatingPointInRange(T min, T max) {
+  if (min > max)
+    abort();
+
+  T range = .0;
+  T result = min;
+  constexpr T zero(.0);
+  if (max > zero && min < zero && max > min + std::numeric_limits<T>::max()) {
+    // The diff |max - min| would overflow the given floating point type. Use
+    // the half of the diff as the range and consume a bool to decide whether
+    // the result is in the first of the second part of the diff.
+    range = (max / 2.0) - (min / 2.0);
+    if (ConsumeBool()) {
+      result += range;
+    }
+  } else {
+    range = max - min;
+  }
+
+  return result + range * ConsumeProbability<T>();
+}
+
+// Returns a floating point number in the range [0.0, 1.0]. If there's no
+// input data left, always returns 0.
+template <typename T> T FuzzedDataProvider::ConsumeProbability() {
+  static_assert(std::is_floating_point<T>::value,
+                "A floating point type is required.");
+
+  // Use different integral types for different floating point types in order
+  // to provide better density of the resulting values.
+  using IntegralType =
+      typename std::conditional<(sizeof(T) <= sizeof(uint32_t)), uint32_t,
+                                uint64_t>::type;
+
+  T result = static_cast<T>(ConsumeIntegral<IntegralType>());
+  result /= static_cast<T>(std::numeric_limits<IntegralType>::max());
+  return result;
+}
+
+// Reads one byte and returns a bool, or false when no data remains.
+inline bool FuzzedDataProvider::ConsumeBool() {
+  return 1 & ConsumeIntegral<uint8_t>();
+}
+
+// Returns an enum value. The enum must start at 0 and be contiguous. It must
+// also contain |kMaxValue| aliased to its largest (inclusive) value. Such as:
+// enum class Foo { SomeValue, OtherValue, kMaxValue = OtherValue };
+template <typename T> T FuzzedDataProvider::ConsumeEnum() {
+  static_assert(std::is_enum<T>::value, "|T| must be an enum type.");
+  return static_cast<T>(
+      ConsumeIntegralInRange<uint32_t>(0, static_cast<uint32_t>(T::kMaxValue)));
+}
+
+// Returns a copy of the value selected from the given fixed-size |array|.
+template <typename T, size_t size>
+T FuzzedDataProvider::PickValueInArray(const T (&array)[size]) {
+  static_assert(size > 0, "The array must be non empty.");
+  return array[ConsumeIntegralInRange<size_t>(0, size - 1)];
+}
+
+template <typename T, size_t size>
+T FuzzedDataProvider::PickValueInArray(const std::array<T, size> &array) {
+  static_assert(size > 0, "The array must be non empty.");
+  return array[ConsumeIntegralInRange<size_t>(0, size - 1)];
+}
+
+template <typename T>
+T FuzzedDataProvider::PickValueInArray(std::initializer_list<const T> list) {
+  // TODO(Dor1s): switch to static_assert once C++14 is allowed.
+  if (!list.size())
+    abort();
+
+  return *(list.begin() + ConsumeIntegralInRange<size_t>(0, list.size() - 1));
+}
+
+// Writes |num_bytes| of input data to the given destination pointer. If there
+// is not enough data left, writes all remaining bytes. Return value is the
+// number of bytes written.
+// In general, it's better to avoid using this function, but it may be useful
+// in cases when it's necessary to fill a certain buffer or object with
+// fuzzing data.
+inline size_t FuzzedDataProvider::ConsumeData(void *destination,
+                                              size_t num_bytes) {
+  num_bytes = std::min(num_bytes, remaining_bytes_);
+  CopyAndAdvance(destination, num_bytes);
+  return num_bytes;
+}
+
+// Private methods.
+inline void FuzzedDataProvider::CopyAndAdvance(void *destination,
+                                               size_t num_bytes) {
+  std::memcpy(destination, data_ptr_, num_bytes);
+  Advance(num_bytes);
+}
+
+inline void FuzzedDataProvider::Advance(size_t num_bytes) {
+  if (num_bytes > remaining_bytes_)
+    abort();
+
+  data_ptr_ += num_bytes;
+  remaining_bytes_ -= num_bytes;
+}
+
+template <typename T>
+std::vector<T> FuzzedDataProvider::ConsumeBytes(size_t size, size_t num_bytes) {
+  static_assert(sizeof(T) == sizeof(uint8_t), "Incompatible data type.");
+
+  // The point of using the size-based constructor below is to increase the
+  // odds of having a vector object with capacity being equal to the length.
+  // That part is always implementation specific, but at least both libc++ and
+  // libstdc++ allocate the requested number of bytes in that constructor,
+  // which seems to be a natural choice for other implementations as well.
+  // To increase the odds even more, we also call |shrink_to_fit| below.
+  std::vector<T> result(size);
+  if (size == 0) {
+    if (num_bytes != 0)
+      abort();
+    return result;
+  }
+
+  CopyAndAdvance(result.data(), num_bytes);
+
+  // Even though |shrink_to_fit| is also implementation specific, we expect it
+  // to provide an additional assurance in case vector's constructor allocated
+  // a buffer which is larger than the actual amount of data we put inside it.
+  result.shrink_to_fit();
+  return result;
+}
+
+template <typename TS, typename TU>
+TS FuzzedDataProvider::ConvertUnsignedToSigned(TU value) {
+  static_assert(sizeof(TS) == sizeof(TU), "Incompatible data types.");
+  static_assert(!std::numeric_limits<TU>::is_signed,
+                "Source type must be unsigned.");
+
+  // TODO(Dor1s): change to `if constexpr` once C++17 becomes mainstream.
+  if (std::numeric_limits<TS>::is_modulo)
+    return static_cast<TS>(value);
+
+  // Avoid using implementation-defined unsigned to signed conversions.
+  // To learn more, see https://stackoverflow.com/questions/13150449.
+  if (value <= std::numeric_limits<TS>::max()) {
+    return static_cast<TS>(value);
+  } else {
+    constexpr auto TS_min = std::numeric_limits<TS>::min();
+    return TS_min + static_cast<TS>(value - TS_min);
+  }
+}
+
+#endif // LLVM_FUZZER_FUZZED_DATA_PROVIDER_H_
diff --git a/re2/fuzzing/re2_fuzzer.cc b/re2/fuzzing/re2_fuzzer.cc
index 83971a1..b42db55 100644
--- a/re2/fuzzing/re2_fuzzer.cc
+++ b/re2/fuzzing/re2_fuzzer.cc
@@ -2,27 +2,159 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
+#include <fuzzer/FuzzedDataProvider.h>
 #include <stddef.h>
 #include <stdint.h>
-#include <map>
-#include <memory>
-#include <queue>
+#include <algorithm>
 #include <string>
+#include <vector>
 
-#include "re2/prefilter.h"
+#include "re2/filtered_re2.h"
 #include "re2/re2.h"
-
-using re2::StringPiece;
-using std::string;
+#include "re2/regexp.h"
+#include "re2/set.h"
+#include "re2/walker-inl.h"
 
 // NOT static, NOT signed.
 uint8_t dummy = 0;
 
-void Test(StringPiece pattern, const RE2::Options& options, StringPiece text) {
+// Walks kRegexpConcat and kRegexpAlternate subexpressions
+// to determine their maximum length.
+class SubexpressionWalker : public re2::Regexp::Walker<int> {
+ public:
+  SubexpressionWalker() = default;
+  ~SubexpressionWalker() override = default;
+
+  int PostVisit(re2::Regexp* re, int parent_arg, int pre_arg,
+                int* child_args, int nchild_args) override {
+    switch (re->op()) {
+      case re2::kRegexpConcat:
+      case re2::kRegexpAlternate: {
+        int max = nchild_args;
+        for (int i = 0; i < nchild_args; i++)
+          max = std::max(max, child_args[i]);
+        return max;
+      }
+
+      default:
+        break;
+    }
+    return -1;
+  }
+
+  // Should never be called: we use Walk(), not WalkExponential().
+  int ShortVisit(re2::Regexp* re, int parent_arg) override {
+    return parent_arg;
+  }
+
+ private:
+  SubexpressionWalker(const SubexpressionWalker&) = delete;
+  SubexpressionWalker& operator=(const SubexpressionWalker&) = delete;
+};
+
+// Walks substrings (i.e. kRegexpLiteralString subexpressions)
+// to determine their maximum length... in runes, but avoiding
+// overheads due to UTF-8 encoding is worthwhile when fuzzing.
+class SubstringWalker : public re2::Regexp::Walker<int> {
+ public:
+  SubstringWalker() = default;
+  ~SubstringWalker() override = default;
+
+  int PostVisit(re2::Regexp* re, int parent_arg, int pre_arg,
+                int* child_args, int nchild_args) override {
+    switch (re->op()) {
+      case re2::kRegexpConcat:
+      case re2::kRegexpAlternate:
+      case re2::kRegexpStar:
+      case re2::kRegexpPlus:
+      case re2::kRegexpQuest:
+      case re2::kRegexpRepeat:
+      case re2::kRegexpCapture: {
+        int max = -1;
+        for (int i = 0; i < nchild_args; i++)
+          max = std::max(max, child_args[i]);
+        return max;
+      }
+
+      case re2::kRegexpLiteralString:
+        return re->nrunes();
+
+      default:
+        break;
+    }
+    return -1;
+  }
+
+  // Should never be called: we use Walk(), not WalkExponential().
+  int ShortVisit(re2::Regexp* re, int parent_arg) override {
+    return parent_arg;
+  }
+
+ private:
+  SubstringWalker(const SubstringWalker&) = delete;
+  SubstringWalker& operator=(const SubstringWalker&) = delete;
+};
+
+void TestOneInput(absl::string_view pattern, const RE2::Options& options,
+                  RE2::Anchor anchor, absl::string_view text) {
+  // Crudely limit the use of ., \p, \P, \d, \D, \s, \S, \w and \W.
+  // Otherwise, we will waste time on inputs that have long runs of various
+  // character classes. The fuzzer has shown itself to be easily capable of
+  // generating such patterns that fall within the other limits, but result
+  // in timeouts nonetheless. The marginal cost is high - even more so when
+  // counted repetition is involved - whereas the marginal benefit is zero.
+  // Crudely limit the use of 'k', 'K', 's' and 'S' too because they become
+  // three-element character classes when case-insensitive and using UTF-8.
+  // TODO(junyer): Handle [:isalnum:] et al. when they start to cause pain.
+  int char_class = 0;
+  int backslash_p = 0;  // very expensive, so handle specially
+  for (size_t i = 0; i < pattern.size(); i++) {
+    if (pattern[i] == '.' ||
+        pattern[i] == 'k' || pattern[i] == 'K' ||
+        pattern[i] == 's' || pattern[i] == 'S')
+      char_class++;
+    if (pattern[i] != '\\')
+      continue;
+    i++;
+    if (i >= pattern.size())
+      break;
+    if (pattern[i] == 'p' || pattern[i] == 'P' ||
+        pattern[i] == 'd' || pattern[i] == 'D' ||
+        pattern[i] == 's' || pattern[i] == 'S' ||
+        pattern[i] == 'w' || pattern[i] == 'W')
+      char_class++;
+    if (pattern[i] == 'p' || pattern[i] == 'P')
+      backslash_p++;
+  }
+  if (char_class > 9)
+    return;
+  if (backslash_p > 1)
+    return;
+
+  // Iterate just once when fuzzing. Otherwise, we easily get bogged down
+  // and coverage is unlikely to improve despite significant expense.
+  RE2::FUZZING_ONLY_set_maximum_global_replace_count(1);
+  // The default is 1000. Even 100 turned out to be too generous
+  // for fuzzing, empirically speaking, so let's try 10 instead.
+  re2::Regexp::FUZZING_ONLY_set_maximum_repeat_count(10);
+
   RE2 re(pattern, options);
   if (!re.ok())
     return;
 
+  // Don't waste time fuzzing programs with large subexpressions.
+  // They can cause bug reports due to fuzzer timeouts. And they
+  // aren't interesting for fuzzing purposes.
+  if (SubexpressionWalker().Walk(re.Regexp(), -1) > 9)
+    return;
+
+  // Don't waste time fuzzing programs with large substrings.
+  // They can cause bug reports due to fuzzer timeouts when they
+  // are repetitions (e.g. hundreds of NUL bytes) and matching is
+  // unanchored. And they aren't interesting for fuzzing purposes.
+  if (SubstringWalker().Walk(re.Regexp(), -1) > 9)
+    return;
+
   // Don't waste time fuzzing high-size programs.
   // They can cause bug reports due to fuzzer timeouts.
   int size = re.ProgramSize();
@@ -34,7 +166,7 @@ void Test(StringPiece pattern, const RE2::Options& options, StringPiece text) {
 
   // Don't waste time fuzzing high-fanout programs.
   // They can cause bug reports due to fuzzer timeouts.
-  std::map<int, int> histogram;
+  std::vector<int> histogram;
   int fanout = re.ProgramFanout(&histogram);
   if (fanout > 9)
     return;
@@ -42,31 +174,9 @@ void Test(StringPiece pattern, const RE2::Options& options, StringPiece text) {
   if (rfanout > 9)
     return;
 
-  // Don't waste time fuzzing programs with large substrings.
-  // They can cause bug reports due to fuzzer timeouts when they
-  // are repetitions (e.g. hundreds of NUL bytes) and matching is
-  // unanchored. And they aren't interesting for fuzzing purposes.
-  std::unique_ptr<re2::Prefilter> prefilter(re2::Prefilter::FromRE2(&re));
-  if (prefilter == nullptr)
-    return;
-  std::queue<re2::Prefilter*> nodes;
-  nodes.push(prefilter.get());
-  while (!nodes.empty()) {
-    re2::Prefilter* node = nodes.front();
-    nodes.pop();
-    if (node->op() == re2::Prefilter::ATOM) {
-      if (node->atom().size() > 9)
-        return;
-    } else if (node->op() == re2::Prefilter::AND ||
-               node->op() == re2::Prefilter::OR) {
-      for (re2::Prefilter* sub : *node->subs())
-        nodes.push(sub);
-    }
-  }
-
   if (re.NumberOfCapturingGroups() == 0) {
     // Avoid early return due to too many arguments.
-    StringPiece sp = text;
+    absl::string_view sp = text;
     RE2::FullMatch(sp, re);
     RE2::PartialMatch(sp, re);
     RE2::Consume(&sp, re);
@@ -75,7 +185,7 @@ void Test(StringPiece pattern, const RE2::Options& options, StringPiece text) {
   } else {
     // Okay, we have at least one capturing group...
     // Try conversion for variously typed arguments.
-    StringPiece sp = text;
+    absl::string_view sp = text;
     short s;
     RE2::FullMatch(sp, re, &s);
     long l;
@@ -87,83 +197,85 @@ void Test(StringPiece pattern, const RE2::Options& options, StringPiece text) {
     RE2::FindAndConsume(&sp, re, &d);
   }
 
-  string s = string(text);
+  std::string s = std::string(text);
   RE2::Replace(&s, re, "");
-  s = string(text);  // Reset.
+  s = std::string(text);  // Reset.
   RE2::GlobalReplace(&s, re, "");
 
-  string min, max;
+  std::string min, max;
   re.PossibleMatchRange(&min, &max, /*maxlen=*/9);
 
   // Exercise some other API functionality.
   dummy += re.NamedCapturingGroups().size();
   dummy += re.CapturingGroupNames().size();
   dummy += RE2::QuoteMeta(pattern).size();
+
+  RE2::Set set(options, anchor);
+  int index = set.Add(pattern, /*error=*/NULL);  // -1 on error
+  if (index != -1 && set.Compile()) {
+    std::vector<int> matches;
+    set.Match(text, &matches);
+  }
+
+  re2::FilteredRE2 filter;
+  index = -1;  // not clobbered on error
+  filter.Add(pattern, options, &index);
+  if (index != -1) {
+    std::vector<std::string> atoms;
+    filter.Compile(&atoms);
+    // Pretend that all atoms match, which
+    // triggers the AND-OR tree maximally.
+    std::vector<int> matched_atoms;
+    matched_atoms.reserve(atoms.size());
+    for (size_t i = 0; i < atoms.size(); ++i)
+      matched_atoms.push_back(static_cast<int>(i));
+    std::vector<int> matches;
+    filter.AllMatches(text, matched_atoms, &matches);
+  }
 }
 
 // Entry point for libFuzzer.
 extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
-  if (size == 0 || size > 999)
+  // An input larger than 4 KiB probably isn't interesting. (This limit
+  // allows for fdp.ConsumeRandomLengthString()'s backslash behaviour.)
+  if (size == 0 || size > 4096)
     return 0;
 
-  // Crudely limit the use of ., \p, \P, \d, \D, \s, \S, \w and \W.
-  // Otherwise, we will waste time on inputs that have long runs of various
-  // character classes. The fuzzer has shown itself to be easily capable of
-  // generating such patterns that fall within the other limits, but result
-  // in timeouts nonetheless. The marginal cost is high - even more so when
-  // counted repetition is involved - whereas the marginal benefit is zero.
-  // TODO(junyer): Handle [:isalnum:] et al. when they start to cause pain.
-  int cc = 0;
-  for (size_t i = 0; i < size; i++) {
-    if (data[i] == '.')
-      cc++;
-    if (data[i] != '\\')
-      continue;
-    i++;
-    if (i >= size)
-      break;
-    if (data[i] == 'p' || data[i] == 'P' ||
-        data[i] == 'd' || data[i] == 'D' ||
-        data[i] == 's' || data[i] == 'S' ||
-        data[i] == 'w' || data[i] == 'W')
-      cc++;
-  }
-  if (cc > 9)
-    return 0;
-
-  // The one-at-a-time hash by Bob Jenkins.
-  uint32_t hash = 0;
-  for (size_t i = 0; i < size; i++) {
-    hash += data[i];
-    hash += (hash << 10);
-    hash ^= (hash >> 6);
-  }
-  hash += (hash << 3);
-  hash ^= (hash >> 11);
-  hash += (hash << 15);
+  FuzzedDataProvider fdp(data, size);
 
+  // The convention here is that fdp.ConsumeBool() returning false sets
+  // the default value whereas returning true sets the alternate value:
+  // most options default to false and so can be set directly; encoding
+  // defaults to UTF-8; case_sensitive defaults to true. We do NOT want
+  // to log errors. max_mem is 64 MiB because we can afford to use more
+  // RAM in exchange for (hopefully) faster fuzzing.
   RE2::Options options;
+  options.set_encoding(fdp.ConsumeBool() ? RE2::Options::EncodingLatin1
+                                         : RE2::Options::EncodingUTF8);
+  options.set_posix_syntax(fdp.ConsumeBool());
+  options.set_longest_match(fdp.ConsumeBool());
   options.set_log_errors(false);
   options.set_max_mem(64 << 20);
-  options.set_encoding(hash & 1 ? RE2::Options::EncodingLatin1
-                                : RE2::Options::EncodingUTF8);
-  options.set_posix_syntax(hash & 2);
-  options.set_longest_match(hash & 4);
-  options.set_literal(hash & 8);
-  options.set_never_nl(hash & 16);
-  options.set_dot_nl(hash & 32);
-  options.set_never_capture(hash & 64);
-  options.set_case_sensitive(hash & 128);
-  options.set_perl_classes(hash & 256);
-  options.set_word_boundary(hash & 512);
-  options.set_one_line(hash & 1024);
-
-  const char* ptr = reinterpret_cast<const char*>(data);
-  int len = static_cast<int>(size);
-
-  StringPiece pattern(ptr, len);
-  StringPiece text(ptr, len);
-  Test(pattern, options, text);
+  options.set_literal(fdp.ConsumeBool());
+  options.set_never_nl(fdp.ConsumeBool());
+  options.set_dot_nl(fdp.ConsumeBool());
+  options.set_never_capture(fdp.ConsumeBool());
+  options.set_case_sensitive(!fdp.ConsumeBool());
+  options.set_perl_classes(fdp.ConsumeBool());
+  options.set_word_boundary(fdp.ConsumeBool());
+  options.set_one_line(fdp.ConsumeBool());
+
+  // ConsumeEnum<RE2::Anchor>() would require RE2::Anchor to specify
+  // kMaxValue, so just use PickValueInArray<RE2::Anchor>() instead.
+  RE2::Anchor anchor = fdp.PickValueInArray<RE2::Anchor>({
+      RE2::UNANCHORED,
+      RE2::ANCHOR_START,
+      RE2::ANCHOR_BOTH,
+  });
+
+  std::string pattern = fdp.ConsumeRandomLengthString(999);
+  std::string text = fdp.ConsumeRandomLengthString(999);
 
+  TestOneInput(pattern, options, anchor, text);
   return 0;
 }
diff --git a/re2/make_perl_groups.pl b/re2/make_perl_groups.pl
index d9fcdaf..ed0d509 100755
--- a/re2/make_perl_groups.pl
+++ b/re2/make_perl_groups.pl
@@ -76,7 +76,7 @@ sub PrintClass($$@) {
   } else {
     $negname =~ y/a-z/A-Z/;
   }
-  return "{ \"$escname\", +1, code$cnum, $n }", "{ \"$negname\", -1, code$cnum, $n }";
+  return "{ \"$escname\", +1, code$cnum, $n, 0, 0 }", "{ \"$negname\", -1, code$cnum, $n, 0, 0 }";
 }
 
 my $cnum = 0;
diff --git a/re2/make_unicode_casefold.py b/re2/make_unicode_casefold.py
index d215eb1..803adbd 100755
--- a/re2/make_unicode_casefold.py
+++ b/re2/make_unicode_casefold.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/python3
 # coding=utf-8
 #
 # Copyright 2008 The RE2 Authors.  All Rights Reserved.
@@ -9,6 +9,10 @@
 
 """Generate C++ table for Unicode case folding."""
 
+from __future__ import absolute_import
+from __future__ import division
+from __future__ import print_function
+
 import sys
 import unicode
 
@@ -57,8 +61,8 @@ def _AddDelta(a, delta):
       return a+1
     else:
       return a-1
-  print >>sys.stderr, "Bad Delta: ", delta
-  raise "Bad Delta"
+  print("Bad Delta:", delta, file=sys.stderr)
+  raise unicode.Error("Bad Delta")
 
 def _MakeRanges(pairs):
   """Turn a list like [(65,97), (66, 98), ..., (90,122)]
@@ -122,7 +126,7 @@ def main():
       foldpairs.append([c[i-1], c[i]])
 
   lowerpairs = []
-  for lower, group in lowergroups.iteritems():
+  for lower, group in lowergroups.items():
     for g in group:
       if g != lower:
         lowerpairs.append([g, lower])
@@ -130,18 +134,18 @@ def main():
   def printpairs(name, foldpairs):
     foldpairs.sort()
     foldranges = _MakeRanges(foldpairs)
-    print "// %d groups, %d pairs, %d ranges" % (len(casegroups), len(foldpairs), len(foldranges))
-    print "const CaseFold unicode_%s[] = {" % (name,)
+    print("// %d groups, %d pairs, %d ranges" % (len(casegroups), len(foldpairs), len(foldranges)))
+    print("const CaseFold unicode_%s[] = {" % (name,))
     for lo, hi, delta in foldranges:
-      print "\t{ %d, %d, %s }," % (lo, hi, delta)
-    print "};"
-    print "const int num_unicode_%s = %d;" % (name, len(foldranges),)
-    print ""
+      print("\t{ %d, %d, %s }," % (lo, hi, delta))
+    print("};")
+    print("const int num_unicode_%s = %d;" % (name, len(foldranges)))
+    print("")
 
-  print _header
+  print(_header)
   printpairs("casefold", foldpairs)
   printpairs("tolower", lowerpairs)
-  print _trailer
+  print(_trailer)
 
 if __name__ == '__main__':
   main()
diff --git a/re2/make_unicode_groups.py b/re2/make_unicode_groups.py
index e97d47e..cbe822a 100755
--- a/re2/make_unicode_groups.py
+++ b/re2/make_unicode_groups.py
@@ -1,10 +1,14 @@
-#!/usr/bin/python
+#!/usr/bin/python3
 # Copyright 2008 The RE2 Authors.  All Rights Reserved.
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
 """Generate C++ tables for Unicode Script and Category groups."""
 
+from __future__ import absolute_import
+from __future__ import division
+from __future__ import print_function
+
 import sys
 import unicode
 
@@ -41,17 +45,17 @@ def MakeRanges(codes):
 
 def PrintRanges(type, name, ranges):
   """Print the ranges as an array of type named name."""
-  print "static const %s %s[] = {" % (type, name,)
+  print("static const %s %s[] = {" % (type, name))
   for lo, hi in ranges:
-    print "\t{ %d, %d }," % (lo, hi)
-  print "};"
+    print("\t{ %d, %d }," % (lo, hi))
+  print("};")
 
 # def PrintCodes(type, name, codes):
 #   """Print the codes as an array of type named name."""
-#   print "static %s %s[] = {" % (type, name,)
+#   print("static %s %s[] = {" % (type, name))
 #   for c in codes:
-#     print "\t%d," % (c,)
-#   print "};"
+#     print("\t%d," % (c,))
+#   print("};")
 
 def PrintGroup(name, codes):
   """Print the data structures for the group of codes.
@@ -92,20 +96,22 @@ def PrintGroup(name, codes):
   return ugroup
 
 def main():
-  print _header
+  categories = unicode.Categories()
+  scripts = unicode.Scripts()
+  print(_header)
   ugroups = []
-  for name, codes in unicode.Categories().iteritems():
-    ugroups.append(PrintGroup(name, codes))
-  for name, codes in unicode.Scripts().iteritems():
-    ugroups.append(PrintGroup(name, codes))
-  print "// %d 16-bit ranges, %d 32-bit ranges" % (n16, n32)
-  print "const UGroup unicode_groups[] = {";
+  for name in sorted(categories):
+    ugroups.append(PrintGroup(name, categories[name]))
+  for name in sorted(scripts):
+    ugroups.append(PrintGroup(name, scripts[name]))
+  print("// %d 16-bit ranges, %d 32-bit ranges" % (n16, n32))
+  print("const UGroup unicode_groups[] = {")
   ugroups.sort()
   for ug in ugroups:
-    print "\t%s," % (ug,)
-  print "};"
-  print "const int num_unicode_groups = %d;" % (len(ugroups),)
-  print _trailer
+    print("\t%s," % (ug,))
+  print("};")
+  print("const int num_unicode_groups = %d;" % (len(ugroups),))
+  print(_trailer)
 
 if __name__ == '__main__':
   main()
diff --git a/re2/mimics_pcre.cc b/re2/mimics_pcre.cc
index ad197be..ac0c69d 100644
--- a/re2/mimics_pcre.cc
+++ b/re2/mimics_pcre.cc
@@ -22,7 +22,6 @@
 //
 // Regexp::MimicsPCRE checks for any of these conditions.
 
-#include "util/util.h"
 #include "util/logging.h"
 #include "re2/regexp.h"
 #include "re2/walker-inl.h"
@@ -38,14 +37,21 @@ static bool CanBeEmptyString(Regexp *re);
 class PCREWalker : public Regexp::Walker<bool> {
  public:
   PCREWalker() {}
-  bool PostVisit(Regexp* re, bool parent_arg, bool pre_arg, bool* child_args,
-                 int nchild_args);
 
-  bool ShortVisit(Regexp* re, bool a) {
-    // Should never be called: we use Walk not WalkExponential.
-    LOG(DFATAL) << "EmptyStringWalker::ShortVisit called";
+  virtual bool PostVisit(Regexp* re, bool parent_arg, bool pre_arg,
+                         bool* child_args, int nchild_args);
+
+  virtual bool ShortVisit(Regexp* re, bool a) {
+    // Should never be called: we use Walk(), not WalkExponential().
+#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+    LOG(DFATAL) << "PCREWalker::ShortVisit called";
+#endif
     return a;
   }
+
+ private:
+  PCREWalker(const PCREWalker&) = delete;
+  PCREWalker& operator=(const PCREWalker&) = delete;
 };
 
 // Called after visiting each of re's children and accumulating
@@ -114,13 +120,16 @@ bool Regexp::MimicsPCRE() {
 
 class EmptyStringWalker : public Regexp::Walker<bool> {
  public:
-  EmptyStringWalker() { }
-  bool PostVisit(Regexp* re, bool parent_arg, bool pre_arg,
-                 bool* child_args, int nchild_args);
+  EmptyStringWalker() {}
+
+  virtual bool PostVisit(Regexp* re, bool parent_arg, bool pre_arg,
+                         bool* child_args, int nchild_args);
 
-  bool ShortVisit(Regexp* re, bool a) {
-    // Should never be called: we use Walk not WalkExponential.
+  virtual bool ShortVisit(Regexp* re, bool a) {
+    // Should never be called: we use Walk(), not WalkExponential().
+#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
     LOG(DFATAL) << "EmptyStringWalker::ShortVisit called";
+#endif
     return a;
   }
 
diff --git a/re2/nfa.cc b/re2/nfa.cc
index 04d4c6f..a655884 100644
--- a/re2/nfa.cc
+++ b/re2/nfa.cc
@@ -27,17 +27,18 @@
 #include <stdio.h>
 #include <string.h>
 #include <algorithm>
+#include <deque>
 #include <string>
 #include <utility>
 #include <vector>
 
+#include "absl/strings/str_format.h"
+#include "util/logging.h"
+#include "re2/pod_array.h"
 #include "re2/prog.h"
 #include "re2/regexp.h"
-#include "util/logging.h"
-#include "util/pod_array.h"
-#include "util/sparse_array.h"
-#include "util/sparse_set.h"
-#include "util/strutil.h"
+#include "re2/sparse_array.h"
+#include "re2/sparse_set.h"
 
 namespace re2 {
 
@@ -59,9 +60,8 @@ class NFA {
   // Submatch[0] is the entire match.  When there is a choice in
   // which text matches each subexpression, the submatch boundaries
   // are chosen to match what a backtracking implementation would choose.
-  bool Search(const StringPiece& text, const StringPiece& context,
-              bool anchored, bool longest,
-              StringPiece* submatch, int nsubmatch);
+  bool Search(absl::string_view text, absl::string_view context, bool anchored,
+              bool longest, absl::string_view* submatch, int nsubmatch);
 
  private:
   struct Thread {
@@ -91,7 +91,7 @@ class NFA {
   // Enqueues only the ByteRange instructions that match byte c.
   // context is used (with p) for evaluating empty-width specials.
   // p is the current input position, and t0 is the current thread.
-  void AddToThreadq(Threadq* q, int id0, int c, const StringPiece& context,
+  void AddToThreadq(Threadq* q, int id0, int c, absl::string_view context,
                     const char* p, Thread* t0);
 
   // Run runq on byte c, appending new states to nextq.
@@ -101,24 +101,27 @@ class NFA {
   // p-1 will be used when processing Match instructions.
   // Frees all the threads on runq.
   // If there is a shortcut to the end, returns that shortcut.
-  int Step(Threadq* runq, Threadq* nextq, int c, const StringPiece& context,
+  int Step(Threadq* runq, Threadq* nextq, int c, absl::string_view context,
            const char* p);
 
   // Returns text version of capture information, for debugging.
-  string FormatCapture(const char** capture);
+  std::string FormatCapture(const char** capture);
 
-  inline void CopyCapture(const char** dst, const char** src);
+  void CopyCapture(const char** dst, const char** src) {
+    memmove(dst, src, ncapture_*sizeof src[0]);
+  }
 
   Prog* prog_;                // underlying program
   int start_;                 // start instruction in program
   int ncapture_;              // number of submatches to track
   bool longest_;              // whether searching for longest match
   bool endmatch_;             // whether match must end at text.end()
-  const char* btext_;         // beginning of text being matched (for FormatSubmatch)
-  const char* etext_;         // end of text being matched (for endmatch_)
+  const char* btext_;         // beginning of text (for FormatSubmatch)
+  const char* etext_;         // end of text (for endmatch_)
   Threadq q0_, q1_;           // pre-allocated for Search.
   PODArray<AddState> stack_;  // pre-allocated for AddToThreadq
-  Thread* free_threads_;      // free list
+  std::deque<Thread> arena_;  // thread arena
+  Thread* freelist_;          // thread freelist
   const char** match_;        // best match so far
   bool matched_;              // any match so far?
 
@@ -141,31 +144,30 @@ NFA::NFA(Prog* prog) {
                prog_->inst_count(kInstEmptyWidth) +
                prog_->inst_count(kInstNop) + 1;  // + 1 for start inst
   stack_ = PODArray<AddState>(nstack);
-  free_threads_ = NULL;
+  freelist_ = NULL;
   match_ = NULL;
   matched_ = false;
 }
 
 NFA::~NFA() {
   delete[] match_;
-  Thread* next;
-  for (Thread* t = free_threads_; t; t = next) {
-    next = t->next;
-    delete[] t->capture;
-    delete t;
-  }
+  for (const Thread& t : arena_)
+    delete[] t.capture;
 }
 
 NFA::Thread* NFA::AllocThread() {
-  Thread* t = free_threads_;
-  if (t == NULL) {
-    t = new Thread;
+  Thread* t = freelist_;
+  if (t != NULL) {
+    freelist_ = t->next;
     t->ref = 1;
-    t->capture = new const char*[ncapture_];
+    // We don't need to touch t->capture because
+    // the caller will immediately overwrite it.
     return t;
   }
-  free_threads_ = t->next;
+  arena_.emplace_back();
+  t = &arena_.back();
   t->ref = 1;
+  t->capture = new const char*[ncapture_];
   return t;
 }
 
@@ -176,28 +178,20 @@ NFA::Thread* NFA::Incref(Thread* t) {
 }
 
 void NFA::Decref(Thread* t) {
-  if (t == NULL)
-    return;
+  DCHECK(t != NULL);
   t->ref--;
   if (t->ref > 0)
     return;
   DCHECK_EQ(t->ref, 0);
-  t->next = free_threads_;
-  free_threads_ = t;
-}
-
-void NFA::CopyCapture(const char** dst, const char** src) {
-  for (int i = 0; i < ncapture_; i+=2) {
-    dst[i] = src[i];
-    dst[i+1] = src[i+1];
-  }
+  t->next = freelist_;
+  freelist_ = t;
 }
 
 // Follows all empty arrows from id0 and enqueues all the states reached.
 // Enqueues only the ByteRange instructions that match byte c.
 // context is used (with p) for evaluating empty-width specials.
 // p is the current input position, and t0 is the current thread.
-void NFA::AddToThreadq(Threadq* q, int id0, int c, const StringPiece& context,
+void NFA::AddToThreadq(Threadq* q, int id0, int c, absl::string_view context,
                        const char* p, Thread* t0) {
   if (id0 == 0)
     return;
@@ -230,7 +224,7 @@ void NFA::AddToThreadq(Threadq* q, int id0, int c, const StringPiece& context,
       continue;
     if (q->has_index(id)) {
       if (ExtraDebug)
-        fprintf(stderr, "  [%d%s]\n", id, FormatCapture(t0->capture).c_str());
+        absl::FPrintF(stderr, "  [%d%s]\n", id, FormatCapture(t0->capture));
       continue;
     }
 
@@ -288,14 +282,24 @@ void NFA::AddToThreadq(Threadq* q, int id0, int c, const StringPiece& context,
     case kInstByteRange:
       if (!ip->Matches(c))
         goto Next;
-      FALLTHROUGH_INTENDED;
+
+      // Save state; will pick up at next byte.
+      t = Incref(t0);
+      *tp = t;
+      if (ExtraDebug)
+        absl::FPrintF(stderr, " + %d%s\n", id, FormatCapture(t0->capture));
+
+      if (ip->hint() == 0)
+        break;
+      a = {id+ip->hint(), NULL};
+      goto Loop;
 
     case kInstMatch:
       // Save state; will pick up at next byte.
       t = Incref(t0);
       *tp = t;
       if (ExtraDebug)
-        fprintf(stderr, " + %d%s\n", id, FormatCapture(t0->capture).c_str());
+        absl::FPrintF(stderr, " ! %d%s\n", id, FormatCapture(t0->capture));
 
     Next:
       if (ip->last())
@@ -323,7 +327,7 @@ void NFA::AddToThreadq(Threadq* q, int id0, int c, const StringPiece& context,
 // p-1 will be used when processing Match instructions.
 // Frees all the threads on runq.
 // If there is a shortcut to the end, returns that shortcut.
-int NFA::Step(Threadq* runq, Threadq* nextq, int c, const StringPiece& context,
+int NFA::Step(Threadq* runq, Threadq* nextq, int c, absl::string_view context,
               const char* p) {
   nextq->clear();
 
@@ -362,8 +366,10 @@ int NFA::Step(Threadq* runq, Threadq* nextq, int c, const StringPiece& context,
           matched_ = true;
 
           Decref(t);
-          for (++i; i != runq->end(); ++i)
-            Decref(i->value());
+          for (++i; i != runq->end(); ++i) {
+            if (i->value() != NULL)
+              Decref(i->value());
+          }
           runq->clear();
           if (ip->greedy(prog_))
             return ip->out1();
@@ -372,10 +378,15 @@ int NFA::Step(Threadq* runq, Threadq* nextq, int c, const StringPiece& context,
         break;
 
       case kInstMatch: {
-        // Avoid invoking undefined behavior when p happens
-        // to be null - and p-1 would be meaningless anyway.
-        if (p == NULL)
+        // Avoid invoking undefined behavior (arithmetic on a null pointer)
+        // by storing p instead of p-1. (What would the latter even mean?!)
+        // This complements the special case in NFA::Search().
+        if (p == NULL) {
+          CopyCapture(match_, t->capture);
+          match_[1] = p;
+          matched_ = true;
           break;
+        }
 
         if (endmatch_ && p-1 != etext_)
           break;
@@ -401,8 +412,10 @@ int NFA::Step(Threadq* runq, Threadq* nextq, int c, const StringPiece& context,
           // worse than the one we just found: don't run the
           // rest of the current Threadq.
           Decref(t);
-          for (++i; i != runq->end(); ++i)
-            Decref(i->value());
+          for (++i; i != runq->end(); ++i) {
+            if (i->value() != NULL)
+              Decref(i->value());
+          }
           runq->clear();
           return 0;
         }
@@ -415,47 +428,45 @@ int NFA::Step(Threadq* runq, Threadq* nextq, int c, const StringPiece& context,
   return 0;
 }
 
-string NFA::FormatCapture(const char** capture) {
-  string s;
-
+std::string NFA::FormatCapture(const char** capture) {
+  std::string s;
   for (int i = 0; i < ncapture_; i+=2) {
     if (capture[i] == NULL)
-      StringAppendF(&s, "(?,?)");
+      s += "(?,?)";
     else if (capture[i+1] == NULL)
-      StringAppendF(&s, "(%d,?)", (int)(capture[i] - btext_));
+      s += absl::StrFormat("(%d,?)",
+                           capture[i] - btext_);
     else
-      StringAppendF(&s, "(%d,%d)",
-                    (int)(capture[i] - btext_),
-                    (int)(capture[i+1] - btext_));
+      s += absl::StrFormat("(%d,%d)",
+                           capture[i] - btext_,
+                           capture[i+1] - btext_);
   }
   return s;
 }
 
-bool NFA::Search(const StringPiece& text, const StringPiece& const_context,
-            bool anchored, bool longest,
-            StringPiece* submatch, int nsubmatch) {
+bool NFA::Search(absl::string_view text, absl::string_view context,
+                 bool anchored, bool longest, absl::string_view* submatch,
+                 int nsubmatch) {
   if (start_ == 0)
     return false;
 
-  StringPiece context = const_context;
-  if (context.begin() == NULL)
+  if (context.data() == NULL)
     context = text;
 
   // Sanity check: make sure that text lies within context.
-  if (text.begin() < context.begin() || text.end() > context.end()) {
+  if (BeginPtr(text) < BeginPtr(context) || EndPtr(text) > EndPtr(context)) {
     LOG(DFATAL) << "context does not contain text";
     return false;
   }
 
-  if (prog_->anchor_start() && context.begin() != text.begin())
+  if (prog_->anchor_start() && BeginPtr(context) != BeginPtr(text))
     return false;
-  if (prog_->anchor_end() && context.end() != text.end())
+  if (prog_->anchor_end() && EndPtr(context) != EndPtr(text))
     return false;
   anchored |= prog_->anchor_start();
   if (prog_->anchor_end()) {
     longest = true;
     endmatch_ = true;
-    etext_ = text.end();
   }
 
   if (nsubmatch < 0) {
@@ -475,52 +486,54 @@ bool NFA::Search(const StringPiece& text, const StringPiece& const_context,
   }
 
   match_ = new const char*[ncapture_];
+  memset(match_, 0, ncapture_*sizeof match_[0]);
   matched_ = false;
 
   // For debugging prints.
-  btext_ = context.begin();
+  btext_ = context.data();
+  // For convenience.
+  etext_ = text.data() + text.size();
 
   if (ExtraDebug)
-    fprintf(stderr, "NFA::Search %s (context: %s) anchored=%d longest=%d\n",
-            string(text).c_str(), string(context).c_str(), anchored, longest);
+    absl::FPrintF(stderr, "NFA::Search %s (context: %s) anchored=%d longest=%d\n",
+                  text, context, anchored, longest);
 
   // Set up search.
   Threadq* runq = &q0_;
   Threadq* nextq = &q1_;
   runq->clear();
   nextq->clear();
-  memset(&match_[0], 0, ncapture_*sizeof match_[0]);
 
   // Loop over the text, stepping the machine.
-  for (const char* p = text.begin();; p++) {
+  for (const char* p = text.data();; p++) {
     if (ExtraDebug) {
       int c = 0;
-      if (p == context.begin())
+      if (p == btext_)
         c = '^';
-      else if (p > text.end())
+      else if (p > etext_)
         c = '$';
-      else if (p < text.end())
+      else if (p < etext_)
         c = p[0] & 0xFF;
 
-      fprintf(stderr, "%c:", c);
+      absl::FPrintF(stderr, "%c:", c);
       for (Threadq::iterator i = runq->begin(); i != runq->end(); ++i) {
         Thread* t = i->value();
         if (t == NULL)
           continue;
-        fprintf(stderr, " %d%s", i->index(), FormatCapture(t->capture).c_str());
+        absl::FPrintF(stderr, " %d%s", i->index(), FormatCapture(t->capture));
       }
-      fprintf(stderr, "\n");
+      absl::FPrintF(stderr, "\n");
     }
 
     // This is a no-op the first time around the loop because runq is empty.
-    int id = Step(runq, nextq, p < text.end() ? p[0] & 0xFF : -1, context, p);
+    int id = Step(runq, nextq, p < etext_ ? p[0] & 0xFF : -1, context, p);
     DCHECK_EQ(runq->size(), 0);
     using std::swap;
     swap(nextq, runq);
     nextq->clear();
     if (id != 0) {
       // We're done: full match ahead.
-      p = text.end();
+      p = etext_;
       for (;;) {
         Prog::Inst* ip = prog_->inst(id);
         switch (ip->opcode()) {
@@ -548,30 +561,28 @@ bool NFA::Search(const StringPiece& text, const StringPiece& const_context,
       break;
     }
 
-    if (p > text.end())
+    if (p > etext_)
       break;
 
     // Start a new thread if there have not been any matches.
     // (No point in starting a new thread if there have been
     // matches, since it would be to the right of the match
     // we already found.)
-    if (!matched_ && (!anchored || p == text.begin())) {
-      // If there's a required first byte for an unanchored search
-      // and we're not in the middle of any possible matches,
-      // use memchr to search for the byte quickly.
-      int fb = prog_->first_byte();
+    if (!matched_ && (!anchored || p == text.data())) {
+      // Try to use prefix accel (e.g. memchr) to skip ahead.
+      // The search must be unanchored and there must be zero
+      // possible matches already.
       if (!anchored && runq->size() == 0 &&
-          fb >= 0 && p < text.end() && (p[0] & 0xFF) != fb) {
-        p = reinterpret_cast<const char*>(memchr(p, fb, text.end() - p));
-        if (p == NULL) {
-          p = text.end();
-        }
+          p < etext_ && prog_->can_prefix_accel()) {
+        p = reinterpret_cast<const char*>(prog_->PrefixAccel(p, etext_ - p));
+        if (p == NULL)
+          p = etext_;
       }
 
       Thread* t = AllocThread();
       CopyCapture(t->capture, match_);
       t->capture[0] = p;
-      AddToThreadq(runq, start_, p < text.end() ? p[0] & 0xFF : -1, context, p,
+      AddToThreadq(runq, start_, p < etext_ ? p[0] & 0xFF : -1, context, p,
                    t);
       Decref(t);
     }
@@ -579,97 +590,50 @@ bool NFA::Search(const StringPiece& text, const StringPiece& const_context,
     // If all the threads have died, stop early.
     if (runq->size() == 0) {
       if (ExtraDebug)
-        fprintf(stderr, "dead\n");
+        absl::FPrintF(stderr, "dead\n");
+      break;
+    }
+
+    // Avoid invoking undefined behavior (arithmetic on a null pointer)
+    // by simply not continuing the loop.
+    // This complements the special case in NFA::Step().
+    if (p == NULL) {
+      (void) Step(runq, nextq, -1, context, p);
+      DCHECK_EQ(runq->size(), 0);
+      using std::swap;
+      swap(nextq, runq);
+      nextq->clear();
       break;
     }
   }
 
-  for (Threadq::iterator i = runq->begin(); i != runq->end(); ++i)
-    Decref(i->value());
+  for (Threadq::iterator i = runq->begin(); i != runq->end(); ++i) {
+    if (i->value() != NULL)
+      Decref(i->value());
+  }
 
   if (matched_) {
     for (int i = 0; i < nsubmatch; i++)
-      submatch[i] =
-          StringPiece(match_[2 * i],
-                      static_cast<size_t>(match_[2 * i + 1] - match_[2 * i]));
+      submatch[i] = absl::string_view(
+          match_[2 * i],
+          static_cast<size_t>(match_[2 * i + 1] - match_[2 * i]));
     if (ExtraDebug)
-      fprintf(stderr, "match (%td,%td)\n",
-              match_[0] - btext_, match_[1] - btext_);
+      absl::FPrintF(stderr, "match (%d,%d)\n",
+                    match_[0] - btext_,
+                    match_[1] - btext_);
     return true;
   }
   return false;
 }
 
-// Computes whether all successful matches have a common first byte,
-// and if so, returns that byte.  If not, returns -1.
-int Prog::ComputeFirstByte() {
-  int b = -1;
-  SparseSet q(size());
-  q.insert(start());
-  for (SparseSet::iterator it = q.begin(); it != q.end(); ++it) {
-    int id = *it;
-    Prog::Inst* ip = inst(id);
-    switch (ip->opcode()) {
-      default:
-        LOG(DFATAL) << "unhandled " << ip->opcode() << " in ComputeFirstByte";
-        break;
-
-      case kInstMatch:
-        // The empty string matches: no first byte.
-        return -1;
-
-      case kInstByteRange:
-        if (!ip->last())
-          q.insert(id+1);
-
-        // Must match only a single byte
-        if (ip->lo() != ip->hi())
-          return -1;
-        if (ip->foldcase() && 'a' <= ip->lo() && ip->lo() <= 'z')
-          return -1;
-        // If we haven't seen any bytes yet, record it;
-        // otherwise must match the one we saw before.
-        if (b == -1)
-          b = ip->lo();
-        else if (b != ip->lo())
-          return -1;
-        break;
-
-      case kInstNop:
-      case kInstCapture:
-      case kInstEmptyWidth:
-        if (!ip->last())
-          q.insert(id+1);
-
-        // Continue on.
-        // Ignore ip->empty() flags for kInstEmptyWidth
-        // in order to be as conservative as possible
-        // (assume all possible empty-width flags are true).
-        if (ip->out())
-          q.insert(ip->out());
-        break;
-
-      case kInstAltMatch:
-        DCHECK(!ip->last());
-        q.insert(id+1);
-        break;
-
-      case kInstFail:
-        break;
-    }
-  }
-  return b;
-}
-
-bool
-Prog::SearchNFA(const StringPiece& text, const StringPiece& context,
-                Anchor anchor, MatchKind kind,
-                StringPiece* match, int nmatch) {
+bool Prog::SearchNFA(absl::string_view text, absl::string_view context,
+                     Anchor anchor, MatchKind kind, absl::string_view* match,
+                     int nmatch) {
   if (ExtraDebug)
     Dump();
 
   NFA nfa(this);
-  StringPiece sp;
+  absl::string_view sp;
   if (kind == kFullMatch) {
     anchor = kAnchored;
     if (nmatch == 0) {
@@ -679,7 +643,7 @@ Prog::SearchNFA(const StringPiece& text, const StringPiece& context,
   }
   if (!nfa.Search(text, context, anchor == kAnchored, kind != kFirstMatch, match, nmatch))
     return false;
-  if (kind == kFullMatch && match[0].end() != text.end())
+  if (kind == kFullMatch && EndPtr(match[0]) != EndPtr(text))
     return false;
   return true;
 }
diff --git a/re2/onepass.cc b/re2/onepass.cc
index 7d39290..7931cf9 100644
--- a/re2/onepass.cc
+++ b/re2/onepass.cc
@@ -57,14 +57,14 @@
 #include <string>
 #include <vector>
 
-#include "util/util.h"
+#include "absl/container/fixed_array.h"
+#include "absl/container/inlined_vector.h"
+#include "absl/strings/str_format.h"
 #include "util/logging.h"
-#include "util/pod_array.h"
-#include "util/sparse_set.h"
-#include "util/strutil.h"
 #include "util/utf.h"
+#include "re2/pod_array.h"
 #include "re2/prog.h"
-#include "re2/stringpiece.h"
+#include "re2/sparse_set.h"
 
 // Silence "zero-sized array in struct/union" warning for OneState::action.
 #ifdef _MSC_VER
@@ -189,7 +189,7 @@ void OnePass_Checks() {
                 "kMaxCap disagrees with kMaxOnePassCapture");
 }
 
-static bool Satisfy(uint32_t cond, const StringPiece& context, const char* p) {
+static bool Satisfy(uint32_t cond, absl::string_view context, const char* p) {
   uint32_t satisfied = Prog::EmptyFlags(context, p);
   if (cond & kEmptyAllFlags & ~satisfied)
     return false;
@@ -211,10 +211,9 @@ static inline OneState* IndexToNode(uint8_t* nodes, int statesize,
   return reinterpret_cast<OneState*>(nodes + statesize*nodeindex);
 }
 
-bool Prog::SearchOnePass(const StringPiece& text,
-                         const StringPiece& const_context,
+bool Prog::SearchOnePass(absl::string_view text, absl::string_view context,
                          Anchor anchor, MatchKind kind,
-                         StringPiece* match, int nmatch) {
+                         absl::string_view* match, int nmatch) {
   if (anchor != kAnchored && kind != kFullMatch) {
     LOG(DFATAL) << "Cannot use SearchOnePass for unanchored matches.";
     return false;
@@ -234,23 +233,22 @@ bool Prog::SearchOnePass(const StringPiece& text,
   for (int i = 0; i < ncap; i++)
     matchcap[i] = NULL;
 
-  StringPiece context = const_context;
-  if (context.begin() == NULL)
+  if (context.data() == NULL)
     context = text;
-  if (anchor_start() && context.begin() != text.begin())
+  if (anchor_start() && BeginPtr(context) != BeginPtr(text))
     return false;
-  if (anchor_end() && context.end() != text.end())
+  if (anchor_end() && EndPtr(context) != EndPtr(text))
     return false;
   if (anchor_end())
     kind = kFullMatch;
 
-  uint8_t* nodes = onepass_nodes_;
+  uint8_t* nodes = onepass_nodes_.data();
   int statesize = sizeof(OneState) + bytemap_range()*sizeof(uint32_t);
   // start() is always mapped to the zeroth OneState.
   OneState* state = IndexToNode(nodes, statesize, 0);
   uint8_t* bytemap = bytemap_;
-  const char* bp = text.begin();
-  const char* ep = text.end();
+  const char* bp = text.data();
+  const char* ep = text.data() + text.size();
   const char* p;
   bool matched = false;
   matchcap[0] = bp;
@@ -339,13 +337,12 @@ done:
   if (!matched)
     return false;
   for (int i = 0; i < nmatch; i++)
-    match[i] =
-        StringPiece(matchcap[2 * i],
-                    static_cast<size_t>(matchcap[2 * i + 1] - matchcap[2 * i]));
+    match[i] = absl::string_view(
+        matchcap[2 * i],
+        static_cast<size_t>(matchcap[2 * i + 1] - matchcap[2 * i]));
   return true;
 }
 
-
 // Analysis to determine whether a given regexp program is one-pass.
 
 // If ip is not on workq, adds ip to work queue and returns true.
@@ -383,7 +380,7 @@ struct InstCond {
 // Constructs and saves corresponding one-pass NFA on success.
 bool Prog::IsOnePass() {
   if (did_onepass_)
-    return onepass_nodes_ != NULL;
+    return onepass_nodes_.data() != NULL;
   did_onepass_ = true;
 
   if (start() == 0)  // no match
@@ -404,16 +401,17 @@ bool Prog::IsOnePass() {
   int stacksize = inst_count(kInstCapture) +
                   inst_count(kInstEmptyWidth) +
                   inst_count(kInstNop) + 1;  // + 1 for start inst
-  PODArray<InstCond> stack(stacksize);
+  absl::FixedArray<InstCond, 64> stack_storage(stacksize);
+  InstCond* stack = stack_storage.data();
 
   int size = this->size();
-  PODArray<int> nodebyid(size);  // indexed by ip
-  memset(nodebyid.data(), 0xFF, size*sizeof nodebyid[0]);
+  absl::FixedArray<int, 128> nodebyid_storage(size, -1);  // indexed by ip
+  int* nodebyid = nodebyid_storage.data();
 
   // Originally, nodes was a uint8_t[maxnodes*statesize], but that was
   // unnecessarily optimistic: why allocate a large amount of memory
   // upfront for a large program when it is unlikely to be one-pass?
-  std::vector<uint8_t> nodes;
+  absl::InlinedVector<uint8_t, 2048> nodes;
 
   Instq tovisit(size), workq(size);
   AddQ(&tovisit, start());
@@ -462,7 +460,7 @@ bool Prog::IsOnePass() {
           if (nextindex == -1) {
             if (nalloc >= maxnodes) {
               if (ExtraDebug)
-                LOG(ERROR) << StringPrintf(
+                LOG(ERROR) << absl::StrFormat(
                     "Not OnePass: hit node limit %d >= %d", nalloc, maxnodes);
               goto fail;
             }
@@ -487,7 +485,7 @@ bool Prog::IsOnePass() {
               node->action[b] = newact;
             } else if (act != newact) {
               if (ExtraDebug)
-                LOG(ERROR) << StringPrintf(
+                LOG(ERROR) << absl::StrFormat(
                     "Not OnePass: conflict on byte %#x at state %d", c, *it);
               goto fail;
             }
@@ -508,7 +506,7 @@ bool Prog::IsOnePass() {
                 node->action[b] = newact;
               } else if (act != newact) {
                 if (ExtraDebug)
-                  LOG(ERROR) << StringPrintf(
+                  LOG(ERROR) << absl::StrFormat(
                       "Not OnePass: conflict on byte %#x at state %d", c, *it);
                 goto fail;
               }
@@ -549,8 +547,8 @@ bool Prog::IsOnePass() {
           // If already on work queue, (1) is violated: bail out.
           if (!AddQ(&workq, ip->out())) {
             if (ExtraDebug)
-              LOG(ERROR) << StringPrintf(
-                  "Not OnePass: multiple paths %d -> %d\n", *it, ip->out());
+              LOG(ERROR) << absl::StrFormat(
+                  "Not OnePass: multiple paths %d -> %d", *it, ip->out());
             goto fail;
           }
           id = ip->out();
@@ -560,8 +558,8 @@ bool Prog::IsOnePass() {
           if (matched) {
             // (3) is violated
             if (ExtraDebug)
-              LOG(ERROR) << StringPrintf(
-                  "Not OnePass: multiple matches from %d\n", *it);
+              LOG(ERROR) << absl::StrFormat(
+                  "Not OnePass: multiple matches from %d", *it);
             goto fail;
           }
           matched = true;
@@ -590,30 +588,30 @@ bool Prog::IsOnePass() {
       if (nodebyid[i] != -1)
         idmap[nodebyid[i]] = i;
 
-    string dump;
+    std::string dump;
     for (Instq::iterator it = tovisit.begin(); it != tovisit.end(); ++it) {
       int id = *it;
       int nodeindex = nodebyid[id];
       if (nodeindex == -1)
         continue;
       OneState* node = IndexToNode(nodes.data(), statesize, nodeindex);
-      StringAppendF(&dump, "node %d id=%d: matchcond=%#x\n",
-                    nodeindex, id, node->matchcond);
+      dump += absl::StrFormat("node %d id=%d: matchcond=%#x\n",
+                              nodeindex, id, node->matchcond);
       for (int i = 0; i < bytemap_range_; i++) {
         if ((node->action[i] & kImpossible) == kImpossible)
           continue;
-        StringAppendF(&dump, "  %d cond %#x -> %d id=%d\n",
-                      i, node->action[i] & 0xFFFF,
-                      node->action[i] >> kIndexShift,
-                      idmap[node->action[i] >> kIndexShift]);
+        dump += absl::StrFormat("  %d cond %#x -> %d id=%d\n",
+                                i, node->action[i] & 0xFFFF,
+                                node->action[i] >> kIndexShift,
+                                idmap[node->action[i] >> kIndexShift]);
       }
     }
     LOG(ERROR) << "nodes:\n" << dump;
   }
 
   dfa_mem_ -= nalloc*statesize;
-  onepass_nodes_ = new uint8_t[nalloc*statesize];
-  memmove(onepass_nodes_, nodes.data(), nalloc*statesize);
+  onepass_nodes_ = PODArray<uint8_t>(nalloc*statesize);
+  memmove(onepass_nodes_.data(), nodes.data(), nalloc*statesize);
   return true;
 
 fail:
diff --git a/re2/parse.cc b/re2/parse.cc
index c8dea7e..67a4857 100644
--- a/re2/parse.cc
+++ b/re2/parse.cc
@@ -25,13 +25,11 @@
 #include <string>
 #include <vector>
 
-#include "util/util.h"
+#include "absl/base/macros.h"
 #include "util/logging.h"
-#include "util/pod_array.h"
-#include "util/strutil.h"
 #include "util/utf.h"
+#include "re2/pod_array.h"
 #include "re2/regexp.h"
-#include "re2/stringpiece.h"
 #include "re2/unicode_casefold.h"
 #include "re2/unicode_groups.h"
 #include "re2/walker-inl.h"
@@ -44,12 +42,12 @@
 
 namespace re2 {
 
-// Reduce the maximum repeat count by an order of magnitude when fuzzing.
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-static const int kMaxRepeat = 100;
-#else
-static const int kMaxRepeat = 1000;
-#endif
+// Controls the maximum repeat count permitted by the parser.
+static int maximum_repeat_count = 1000;
+
+void Regexp::FUZZING_ONLY_set_maximum_repeat_count(int i) {
+  maximum_repeat_count = i;
+}
 
 // Regular expression parse state.
 // The list of parsed regexps so far is maintained as a vector of
@@ -70,7 +68,7 @@ static const int kMaxRepeat = 1000;
 
 class Regexp::ParseState {
  public:
-  ParseState(ParseFlags flags, const StringPiece& whole_regexp,
+  ParseState(ParseFlags flags, absl::string_view whole_regexp,
              RegexpStatus* status);
   ~ParseState();
 
@@ -93,7 +91,7 @@ class Regexp::ParseState {
   bool PushSimpleOp(RegexpOp op);
 
   // Pushes a ^ onto the stack.
-  bool PushCarat();
+  bool PushCaret();
 
   // Pushes a \b (word == true) or \B (word == false) onto the stack.
   bool PushWordBoundary(bool word);
@@ -107,18 +105,18 @@ class Regexp::ParseState {
   // Pushes a repeat operator regexp onto the stack.
   // A valid argument for the operator must already be on the stack.
   // s is the name of the operator, for use in error messages.
-  bool PushRepeatOp(RegexpOp op, const StringPiece& s, bool nongreedy);
+  bool PushRepeatOp(RegexpOp op, absl::string_view s, bool nongreedy);
 
   // Pushes a repetition regexp onto the stack.
   // A valid argument for the operator must already be on the stack.
-  bool PushRepetition(int min, int max, const StringPiece& s, bool nongreedy);
+  bool PushRepetition(int min, int max, absl::string_view s, bool nongreedy);
 
   // Checks whether a particular regexp op is a marker.
   bool IsMarker(RegexpOp op);
 
   // Processes a left parenthesis in the input.
   // Pushes a marker onto the stack.
-  bool DoLeftParen(const StringPiece& name);
+  bool DoLeftParen(absl::string_view name);
   bool DoLeftParenNoCapture();
 
   // Processes a vertical bar in the input.
@@ -142,24 +140,23 @@ class Regexp::ParseState {
 
   // Parse a character class into *out_re.
   // Removes parsed text from s.
-  bool ParseCharClass(StringPiece* s, Regexp** out_re,
+  bool ParseCharClass(absl::string_view* s, Regexp** out_re,
                       RegexpStatus* status);
 
   // Parse a character class character into *rp.
   // Removes parsed text from s.
-  bool ParseCCCharacter(StringPiece* s, Rune *rp,
-                        const StringPiece& whole_class,
+  bool ParseCCCharacter(absl::string_view* s, Rune* rp,
+                        absl::string_view whole_class,
                         RegexpStatus* status);
 
   // Parse a character class range into rr.
   // Removes parsed text from s.
-  bool ParseCCRange(StringPiece* s, RuneRange* rr,
-                    const StringPiece& whole_class,
+  bool ParseCCRange(absl::string_view* s, RuneRange* rr,
+                    absl::string_view whole_class,
                     RegexpStatus* status);
 
   // Parse a Perl flag set or non-capturing group from s.
-  bool ParsePerlFlags(StringPiece* s);
-
+  bool ParsePerlFlags(absl::string_view* s);
 
   // Finishes the current concatenation,
   // collapsing it into a single regexp on the stack.
@@ -177,7 +174,7 @@ class Regexp::ParseState {
 
 private:
   ParseFlags flags_;
-  StringPiece whole_regexp_;
+  absl::string_view whole_regexp_;
   RegexpStatus* status_;
   Regexp* stacktop_;
   int ncap_;  // number of capturing parens seen
@@ -192,7 +189,7 @@ const RegexpOp kLeftParen = static_cast<RegexpOp>(kMaxRegexpOp+1);
 const RegexpOp kVerticalBar = static_cast<RegexpOp>(kMaxRegexpOp+2);
 
 Regexp::ParseState::ParseState(ParseFlags flags,
-                               const StringPiece& whole_regexp,
+                               absl::string_view whole_regexp,
                                RegexpStatus* status)
   : flags_(flags), whole_regexp_(whole_regexp),
     status_(status), stacktop_(NULL), ncap_(0) {
@@ -269,7 +266,7 @@ bool Regexp::ParseState::PushRegexp(Regexp* re) {
 // Searches the case folding tables and returns the CaseFold* that contains r.
 // If there isn't one, returns the CaseFold* with smallest f->lo bigger than r.
 // If there isn't one, returns NULL.
-const CaseFold* LookupCaseFold(const CaseFold *f, int n, Rune r) {
+const CaseFold* LookupCaseFold(const CaseFold* f, int n, Rune r) {
   const CaseFold* ef = f + n;
 
   // Binary search for entry containing r.
@@ -297,7 +294,7 @@ const CaseFold* LookupCaseFold(const CaseFold *f, int n, Rune r) {
 }
 
 // Returns the result of applying the fold f to the rune r.
-Rune ApplyFold(const CaseFold *f, Rune r) {
+Rune ApplyFold(const CaseFold* f, Rune r) {
   switch (f->delta) {
     default:
       return r + f->delta;
@@ -305,7 +302,7 @@ Rune ApplyFold(const CaseFold *f, Rune r) {
     case EvenOddSkip:  // even <-> odd but only applies to every other
       if ((r - f->lo) % 2)
         return r;
-      FALLTHROUGH_INTENDED;
+      ABSL_FALLTHROUGH_INTENDED;
     case EvenOdd:  // even <-> odd
       if (r%2 == 0)
         return r + 1;
@@ -314,7 +311,7 @@ Rune ApplyFold(const CaseFold *f, Rune r) {
     case OddEvenSkip:  // odd <-> even but only applies to every other
       if ((r - f->lo) % 2)
         return r;
-      FALLTHROUGH_INTENDED;
+      ABSL_FALLTHROUGH_INTENDED;
     case OddEven:  // odd <-> even
       if (r%2 == 1)
         return r + 1;
@@ -423,7 +420,7 @@ bool Regexp::ParseState::PushLiteral(Rune r) {
 }
 
 // Pushes a ^ onto the stack.
-bool Regexp::ParseState::PushCarat() {
+bool Regexp::ParseState::PushCaret() {
   if (flags_ & OneLine) {
     return PushSimpleOp(kRegexpBeginText);
   }
@@ -472,7 +469,7 @@ bool Regexp::ParseState::PushSimpleOp(RegexpOp op) {
 // Pushes a repeat operator regexp onto the stack.
 // A valid argument for the operator must already be on the stack.
 // The char c is the name of the operator, for use in error messages.
-bool Regexp::ParseState::PushRepeatOp(RegexpOp op, const StringPiece& s,
+bool Regexp::ParseState::PushRepeatOp(RegexpOp op, absl::string_view s,
                                       bool nongreedy) {
   if (stacktop_ == NULL || IsMarker(stacktop_->op())) {
     status_->set_code(kRegexpRepeatArgument);
@@ -556,18 +553,20 @@ int RepetitionWalker::PostVisit(Regexp* re, int parent_arg, int pre_arg,
 }
 
 int RepetitionWalker::ShortVisit(Regexp* re, int parent_arg) {
-  // This should never be called, since we use Walk and not
-  // WalkExponential.
+  // Should never be called: we use Walk(), not WalkExponential().
+#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
   LOG(DFATAL) << "RepetitionWalker::ShortVisit called";
+#endif
   return 0;
 }
 
 // Pushes a repetition regexp onto the stack.
 // A valid argument for the operator must already be on the stack.
-bool Regexp::ParseState::PushRepetition(int min, int max,
-                                        const StringPiece& s,
+bool Regexp::ParseState::PushRepetition(int min, int max, absl::string_view s,
                                         bool nongreedy) {
-  if ((max != -1 && max < min) || min > kMaxRepeat || max > kMaxRepeat) {
+  if ((max != -1 && max < min) ||
+      min > maximum_repeat_count ||
+      max > maximum_repeat_count) {
     status_->set_code(kRegexpRepeatSize);
     status_->set_error_arg(s);
     return false;
@@ -590,7 +589,7 @@ bool Regexp::ParseState::PushRepetition(int min, int max,
   stacktop_ = re;
   if (min >= 2 || max >= 2) {
     RepetitionWalker w;
-    if (w.Walk(stacktop_, kMaxRepeat) == 0) {
+    if (w.Walk(stacktop_, maximum_repeat_count) == 0) {
       status_->set_code(kRegexpRepeatSize);
       status_->set_error_arg(s);
       return false;
@@ -606,11 +605,11 @@ bool Regexp::ParseState::IsMarker(RegexpOp op) {
 
 // Processes a left parenthesis in the input.
 // Pushes a marker onto the stack.
-bool Regexp::ParseState::DoLeftParen(const StringPiece& name) {
+bool Regexp::ParseState::DoLeftParen(absl::string_view name) {
   Regexp* re = new Regexp(kLeftParen, flags_);
   re->cap_ = ++ncap_;
   if (name.data() != NULL)
-    re->name_ = new string(name);
+    re->name_ = new std::string(name);
   return PushRegexp(re);
 }
 
@@ -684,7 +683,7 @@ bool Regexp::ParseState::DoRightParen() {
   if ((r1 = stacktop_) == NULL ||
       (r2 = r1->down_) == NULL ||
       r2->op() != kLeftParen) {
-    status_->set_code(kRegexpMissingParen);
+    status_->set_code(kRegexpUnexpectedParen);
     status_->set_error_arg(whole_regexp_);
     return false;
   }
@@ -771,8 +770,8 @@ Regexp* Regexp::RemoveLeadingRegexp(Regexp* re) {
 // Returns the leading string that re starts with.
 // The returned Rune* points into a piece of re,
 // so it must not be used after the caller calls re->Decref().
-Rune* Regexp::LeadingString(Regexp* re, int *nrune,
-                            Regexp::ParseFlags *flags) {
+Rune* Regexp::LeadingString(Regexp* re, int* nrune,
+                            Regexp::ParseFlags* flags) {
   while (re->op() == kRegexpConcat && re->nsub() > 0)
     re = re->sub()[0];
 
@@ -801,9 +800,9 @@ void Regexp::RemoveLeadingString(Regexp* re, int n) {
   // limit on the size of a concatenation, so we should never
   // see more than two here.
   Regexp* stk[4];
-  int d = 0;
+  size_t d = 0;
   while (re->op() == kRegexpConcat) {
-    if (d < arraysize(stk))
+    if (d < ABSL_ARRAYSIZE(stk))
       stk[d++] = re;
     re = re->sub()[0];
   }
@@ -832,8 +831,8 @@ void Regexp::RemoveLeadingString(Regexp* re, int n) {
   }
 
   // If re is now empty, concatenations might simplify too.
-  while (d-- > 0) {
-    re = stk[d];
+  while (d > 0) {
+    re = stk[--d];
     Regexp** sub = re->sub();
     if (sub[0]->op() == kRegexpEmptyMatch) {
       sub[0]->Decref();
@@ -1322,15 +1321,15 @@ bool Regexp::ParseState::MaybeConcatString(int r, ParseFlags flags) {
 
 // Parses a decimal integer, storing it in *np.
 // Sets *s to span the remainder of the string.
-static bool ParseInteger(StringPiece* s, int* np) {
-  if (s->size() == 0 || !isdigit((*s)[0] & 0xFF))
+static bool ParseInteger(absl::string_view* s, int* np) {
+  if (s->empty() || !isdigit((*s)[0] & 0xFF))
     return false;
   // Disallow leading zeros.
   if (s->size() >= 2 && (*s)[0] == '0' && isdigit((*s)[1] & 0xFF))
     return false;
   int n = 0;
   int c;
-  while (s->size() > 0 && isdigit(c = (*s)[0] & 0xFF)) {
+  while (!s->empty() && isdigit(c = (*s)[0] & 0xFF)) {
     // Avoid overflow.
     if (n >= 100000000)
       return false;
@@ -1348,20 +1347,20 @@ static bool ParseInteger(StringPiece* s, int* np) {
 // sets *hi to -1 to signify this.
 // {,2} is NOT a valid suffix.
 // The Maybe in the name signifies that the regexp parse
-// doesn't fail even if ParseRepetition does, so the StringPiece
+// doesn't fail even if ParseRepetition does, so the string_view
 // s must NOT be edited unless MaybeParseRepetition returns true.
-static bool MaybeParseRepetition(StringPiece* sp, int* lo, int* hi) {
-  StringPiece s = *sp;
-  if (s.size() == 0 || s[0] != '{')
+static bool MaybeParseRepetition(absl::string_view* sp, int* lo, int* hi) {
+  absl::string_view s = *sp;
+  if (s.empty() || s[0] != '{')
     return false;
   s.remove_prefix(1);  // '{'
   if (!ParseInteger(&s, lo))
     return false;
-  if (s.size() == 0)
+  if (s.empty())
     return false;
   if (s[0] == ',') {
     s.remove_prefix(1);  // ','
-    if (s.size() == 0)
+    if (s.empty())
       return false;
     if (s[0] == '}') {
       // {2,} means at least 2
@@ -1375,19 +1374,20 @@ static bool MaybeParseRepetition(StringPiece* sp, int* lo, int* hi) {
     // {2} means exactly two
     *hi = *lo;
   }
-  if (s.size() == 0 || s[0] != '}')
+  if (s.empty() || s[0] != '}')
     return false;
   s.remove_prefix(1);  // '}'
   *sp = s;
   return true;
 }
 
-// Removes the next Rune from the StringPiece and stores it in *r.
+// Removes the next Rune from the string_view and stores it in *r.
 // Returns number of bytes removed from sp.
 // Behaves as though there is a terminating NUL at the end of sp.
 // Argument order is backwards from usual Google style
 // but consistent with chartorune.
-static int StringPieceToRune(Rune *r, StringPiece *sp, RegexpStatus* status) {
+static int StringViewToRune(Rune* r, absl::string_view* sp,
+                            RegexpStatus* status) {
   // fullrune() takes int, not size_t. However, it just looks
   // at the leading byte and treats any length >= 4 the same.
   if (fullrune(sp->data(), static_cast<int>(std::min(size_t{4}, sp->size())))) {
@@ -1406,18 +1406,20 @@ static int StringPieceToRune(Rune *r, StringPiece *sp, RegexpStatus* status) {
     }
   }
 
-  status->set_code(kRegexpBadUTF8);
-  status->set_error_arg(StringPiece());
+  if (status != NULL) {
+    status->set_code(kRegexpBadUTF8);
+    status->set_error_arg(absl::string_view());
+  }
   return -1;
 }
 
-// Return whether name is valid UTF-8.
-// If not, set status to kRegexpBadUTF8.
-static bool IsValidUTF8(const StringPiece& s, RegexpStatus* status) {
-  StringPiece t = s;
+// Returns whether name is valid UTF-8.
+// If not, sets status to kRegexpBadUTF8.
+static bool IsValidUTF8(absl::string_view s, RegexpStatus* status) {
+  absl::string_view t = s;
   Rune r;
-  while (t.size() > 0) {
-    if (StringPieceToRune(&r, &t, status) < 0)
+  while (!t.empty()) {
+    if (StringViewToRune(&r, &t, status) < 0)
       return false;
   }
   return true;
@@ -1445,23 +1447,23 @@ static int UnHex(int c) {
 // Parse an escape sequence (e.g., \n, \{).
 // Sets *s to span the remainder of the string.
 // Sets *rp to the named character.
-static bool ParseEscape(StringPiece* s, Rune* rp,
+static bool ParseEscape(absl::string_view* s, Rune* rp,
                         RegexpStatus* status, int rune_max) {
-  const char* begin = s->begin();
-  if (s->size() < 1 || (*s)[0] != '\\') {
+  const char* begin = s->data();
+  if (s->empty() || (*s)[0] != '\\') {
     // Should not happen - caller always checks.
     status->set_code(kRegexpInternalError);
-    status->set_error_arg(StringPiece());
+    status->set_error_arg(absl::string_view());
     return false;
   }
-  if (s->size() < 2) {
+  if (s->size() == 1) {
     status->set_code(kRegexpTrailingBackslash);
-    status->set_error_arg(StringPiece());
+    status->set_error_arg(absl::string_view());
     return false;
   }
   Rune c, c1;
   s->remove_prefix(1);  // backslash
-  if (StringPieceToRune(&c, s, status) < 0)
+  if (StringViewToRune(&c, s, status) < 0)
     return false;
   int code;
   switch (c) {
@@ -1485,16 +1487,16 @@ static bool ParseEscape(StringPiece* s, Rune* rp,
     case '6':
     case '7':
       // Single non-zero octal digit is a backreference; not supported.
-      if (s->size() == 0 || (*s)[0] < '0' || (*s)[0] > '7')
+      if (s->empty() || (*s)[0] < '0' || (*s)[0] > '7')
         goto BadEscape;
-      FALLTHROUGH_INTENDED;
+      ABSL_FALLTHROUGH_INTENDED;
     case '0':
       // consume up to three octal digits; already have one.
       code = c - '0';
-      if (s->size() > 0 && '0' <= (c = (*s)[0]) && c <= '7') {
+      if (!s->empty() && '0' <= (c = (*s)[0]) && c <= '7') {
         code = code * 8 + c - '0';
         s->remove_prefix(1);  // digit
-        if (s->size() > 0) {
+        if (!s->empty()) {
           c = (*s)[0];
           if ('0' <= c && c <= '7') {
             code = code * 8 + c - '0';
@@ -1509,9 +1511,9 @@ static bool ParseEscape(StringPiece* s, Rune* rp,
 
     // Hexadecimal escapes
     case 'x':
-      if (s->size() == 0)
+      if (s->empty())
         goto BadEscape;
-      if (StringPieceToRune(&c, s, status) < 0)
+      if (StringViewToRune(&c, s, status) < 0)
         return false;
       if (c == '{') {
         // Any number of digits in braces.
@@ -1520,7 +1522,7 @@ static bool ParseEscape(StringPiece* s, Rune* rp,
         // Perl accepts any text at all; it ignores all text
         // after the first non-hex digit.  We require only hex digits,
         // and at least one.
-        if (StringPieceToRune(&c, s, status) < 0)
+        if (StringViewToRune(&c, s, status) < 0)
           return false;
         int nhex = 0;
         code = 0;
@@ -1529,9 +1531,9 @@ static bool ParseEscape(StringPiece* s, Rune* rp,
           code = code * 16 + UnHex(c);
           if (code > rune_max)
             goto BadEscape;
-          if (s->size() == 0)
+          if (s->empty())
             goto BadEscape;
-          if (StringPieceToRune(&c, s, status) < 0)
+          if (StringViewToRune(&c, s, status) < 0)
             return false;
         }
         if (c != '}' || nhex == 0)
@@ -1540,9 +1542,9 @@ static bool ParseEscape(StringPiece* s, Rune* rp,
         return true;
       }
       // Easy case: two hex digits.
-      if (s->size() == 0)
+      if (s->empty())
         goto BadEscape;
-      if (StringPieceToRune(&c1, s, status) < 0)
+      if (StringViewToRune(&c1, s, status) < 0)
         return false;
       if (!IsHex(c) || !IsHex(c1))
         goto BadEscape;
@@ -1584,13 +1586,11 @@ static bool ParseEscape(StringPiece* s, Rune* rp,
     //   return true;
   }
 
-  LOG(DFATAL) << "Not reached in ParseEscape.";
-
 BadEscape:
   // Unrecognized escape sequence.
   status->set_code(kRegexpBadEscape);
   status->set_error_arg(
-      StringPiece(begin, static_cast<size_t>(s->begin() - begin)));
+      absl::string_view(begin, static_cast<size_t>(s->data() - begin)));
   return false;
 }
 
@@ -1618,21 +1618,21 @@ void CharClassBuilder::AddRangeFlags(
 }
 
 // Look for a group with the given name.
-static const UGroup* LookupGroup(const StringPiece& name,
-                                 const UGroup *groups, int ngroups) {
+static const UGroup* LookupGroup(absl::string_view name,
+                                 const UGroup* groups, int ngroups) {
   // Simple name lookup.
   for (int i = 0; i < ngroups; i++)
-    if (StringPiece(groups[i].name) == name)
+    if (absl::string_view(groups[i].name) == name)
       return &groups[i];
   return NULL;
 }
 
 // Look for a POSIX group with the given name (e.g., "[:^alpha:]")
-static const UGroup* LookupPosixGroup(const StringPiece& name) {
+static const UGroup* LookupPosixGroup(absl::string_view name) {
   return LookupGroup(name, posix_groups, num_posix_groups);
 }
 
-static const UGroup* LookupPerlGroup(const StringPiece& name) {
+static const UGroup* LookupPerlGroup(absl::string_view name) {
   return LookupGroup(name, perl_groups, num_perl_groups);
 }
 
@@ -1643,16 +1643,16 @@ static URange32 any32[] = { { 65536, Runemax } };
 static UGroup anygroup = { "Any", +1, any16, 1, any32, 1 };
 
 // Look for a Unicode group with the given name (e.g., "Han")
-static const UGroup* LookupUnicodeGroup(const StringPiece& name) {
+static const UGroup* LookupUnicodeGroup(absl::string_view name) {
   // Special case: "Any" means any.
-  if (name == StringPiece("Any"))
+  if (name == absl::string_view("Any"))
     return &anygroup;
   return LookupGroup(name, unicode_groups, num_unicode_groups);
 }
 #endif
 
 // Add a UGroup or its negation to the character class.
-static void AddUGroup(CharClassBuilder *cc, const UGroup *g, int sign,
+static void AddUGroup(CharClassBuilder* cc, const UGroup* g, int sign,
                       Regexp::ParseFlags parse_flags) {
   if (sign == +1) {
     for (int i = 0; i < g->nr16; i++) {
@@ -1702,16 +1702,17 @@ static void AddUGroup(CharClassBuilder *cc, const UGroup *g, int sign,
 // not the Perl empty-string classes (\b \B \A \Z \z).
 // On success, sets *s to span the remainder of the string
 // and returns the corresponding UGroup.
-// The StringPiece must *NOT* be edited unless the call succeeds.
-const UGroup* MaybeParsePerlCCEscape(StringPiece* s, Regexp::ParseFlags parse_flags) {
+// The string_view must *NOT* be edited unless the call succeeds.
+const UGroup* MaybeParsePerlCCEscape(absl::string_view* s,
+                                     Regexp::ParseFlags parse_flags) {
   if (!(parse_flags & Regexp::PerlClasses))
     return NULL;
   if (s->size() < 2 || (*s)[0] != '\\')
     return NULL;
-  // Could use StringPieceToRune, but there aren't
+  // Could use StringViewToRune, but there aren't
   // any non-ASCII Perl group names.
-  StringPiece name(s->begin(), 2);
-  const UGroup *g = LookupPerlGroup(name);
+  absl::string_view name(s->data(), 2);
+  const UGroup* g = LookupPerlGroup(name);
   if (g == NULL)
     return NULL;
   s->remove_prefix(name.size());
@@ -1726,9 +1727,9 @@ enum ParseStatus {
 
 // Maybe parses a Unicode character group like \p{Han} or \P{Han}
 // (the latter is a negated group).
-ParseStatus ParseUnicodeGroup(StringPiece* s, Regexp::ParseFlags parse_flags,
-                              CharClassBuilder *cc,
-                              RegexpStatus* status) {
+ParseStatus ParseUnicodeGroup(absl::string_view* s,
+                              Regexp::ParseFlags parse_flags,
+                              CharClassBuilder* cc, RegexpStatus* status) {
   // Decide whether to parse.
   if (!(parse_flags & Regexp::UnicodeGroups))
     return kParseNothing;
@@ -1742,43 +1743,43 @@ ParseStatus ParseUnicodeGroup(StringPiece* s, Regexp::ParseFlags parse_flags,
   int sign = +1;  // -1 = negated char class
   if (c == 'P')
     sign = -sign;
-  StringPiece seq = *s;  // \p{Han} or \pL
-  StringPiece name;  // Han or L
+  absl::string_view seq = *s;  // \p{Han} or \pL
+  absl::string_view name;  // Han or L
   s->remove_prefix(2);  // '\\', 'p'
 
-  if (!StringPieceToRune(&c, s, status))
+  if (!StringViewToRune(&c, s, status))
     return kParseError;
   if (c != '{') {
     // Name is the bit of string we just skipped over for c.
-    const char* p = seq.begin() + 2;
-    name = StringPiece(p, static_cast<size_t>(s->begin() - p));
+    const char* p = seq.data() + 2;
+    name = absl::string_view(p, static_cast<size_t>(s->data() - p));
   } else {
     // Name is in braces. Look for closing }
     size_t end = s->find('}', 0);
-    if (end == StringPiece::npos) {
+    if (end == absl::string_view::npos) {
       if (!IsValidUTF8(seq, status))
         return kParseError;
       status->set_code(kRegexpBadCharRange);
       status->set_error_arg(seq);
       return kParseError;
     }
-    name = StringPiece(s->begin(), end);  // without '}'
+    name = absl::string_view(s->data(), end);  // without '}'
     s->remove_prefix(end + 1);  // with '}'
     if (!IsValidUTF8(name, status))
       return kParseError;
   }
 
   // Chop seq where s now begins.
-  seq = StringPiece(seq.begin(), static_cast<size_t>(s->begin() - seq.begin()));
+  seq = absl::string_view(seq.data(), static_cast<size_t>(s->data() - seq.data()));
 
-  if (name.size() > 0 && name[0] == '^') {
+  if (!name.empty() && name[0] == '^') {
     sign = -sign;
     name.remove_prefix(1);  // '^'
   }
 
 #if !defined(RE2_USE_ICU)
   // Look up the group in the RE2 Unicode data.
-  const UGroup *g = LookupUnicodeGroup(name);
+  const UGroup* g = LookupUnicodeGroup(name);
   if (g == NULL) {
     status->set_code(kRegexpBadCharRange);
     status->set_error_arg(seq);
@@ -1790,7 +1791,7 @@ ParseStatus ParseUnicodeGroup(StringPiece* s, Regexp::ParseFlags parse_flags,
   // Look up the group in the ICU Unicode data. Because ICU provides full
   // Unicode properties support, this could be more than a lookup by name.
   ::icu::UnicodeString ustr = ::icu::UnicodeString::fromUTF8(
-      string("\\p{") + string(name) + string("}"));
+      std::string("\\p{") + std::string(name) + std::string("}"));
   UErrorCode uerr = U_ZERO_ERROR;
   ::icu::UnicodeSet uset(ustr, uerr);
   if (U_FAILURE(uerr)) {
@@ -1801,14 +1802,13 @@ ParseStatus ParseUnicodeGroup(StringPiece* s, Regexp::ParseFlags parse_flags,
 
   // Convert the UnicodeSet to a URange32 and UGroup that we can add.
   int nr = uset.getRangeCount();
-  URange32* r = new URange32[nr];
+  PODArray<URange32> r(nr);
   for (int i = 0; i < nr; i++) {
     r[i].lo = uset.getRangeStart(i);
     r[i].hi = uset.getRangeEnd(i);
   }
-  UGroup g = {"", +1, 0, 0, r, nr};
+  UGroup g = {"", +1, 0, 0, r.data(), nr};
   AddUGroup(cc, &g, sign, parse_flags);
-  delete[] r;
 #endif
 
   return kParseOk;
@@ -1817,9 +1817,9 @@ ParseStatus ParseUnicodeGroup(StringPiece* s, Regexp::ParseFlags parse_flags,
 // Parses a character class name like [:alnum:].
 // Sets *s to span the remainder of the string.
 // Adds the ranges corresponding to the class to ranges.
-static ParseStatus ParseCCName(StringPiece* s, Regexp::ParseFlags parse_flags,
-                               CharClassBuilder *cc,
-                               RegexpStatus* status) {
+static ParseStatus ParseCCName(absl::string_view* s,
+                               Regexp::ParseFlags parse_flags,
+                               CharClassBuilder* cc, RegexpStatus* status) {
   // Check begins with [:
   const char* p = s->data();
   const char* ep = s->data() + s->size();
@@ -1837,9 +1837,9 @@ static ParseStatus ParseCCName(StringPiece* s, Regexp::ParseFlags parse_flags,
 
   // Got it.  Check that it's valid.
   q += 2;
-  StringPiece name(p, static_cast<size_t>(q - p));
+  absl::string_view name(p, static_cast<size_t>(q - p));
 
-  const UGroup *g = LookupPosixGroup(name);
+  const UGroup* g = LookupPosixGroup(name);
   if (g == NULL) {
     status->set_code(kRegexpBadCharRange);
     status->set_error_arg(name);
@@ -1855,10 +1855,10 @@ static ParseStatus ParseCCName(StringPiece* s, Regexp::ParseFlags parse_flags,
 // There are fewer special characters here than in the rest of the regexp.
 // Sets *s to span the remainder of the string.
 // Sets *rp to the character.
-bool Regexp::ParseState::ParseCCCharacter(StringPiece* s, Rune *rp,
-                                          const StringPiece& whole_class,
+bool Regexp::ParseState::ParseCCCharacter(absl::string_view* s, Rune* rp,
+                                          absl::string_view whole_class,
                                           RegexpStatus* status) {
-  if (s->size() == 0) {
+  if (s->empty()) {
     status->set_code(kRegexpMissingBracket);
     status->set_error_arg(whole_class);
     return false;
@@ -1866,11 +1866,11 @@ bool Regexp::ParseState::ParseCCCharacter(StringPiece* s, Rune *rp,
 
   // Allow regular escape sequences even though
   // many need not be escaped in this context.
-  if (s->size() >= 1 && (*s)[0] == '\\')
+  if ((*s)[0] == '\\')
     return ParseEscape(s, rp, status, rune_max_);
 
   // Otherwise take the next rune.
-  return StringPieceToRune(rp, s, status) >= 0;
+  return StringViewToRune(rp, s, status) >= 0;
 }
 
 // Parses a character class character, or, if the character
@@ -1878,10 +1878,10 @@ bool Regexp::ParseState::ParseCCCharacter(StringPiece* s, Rune *rp,
 // For single characters, rr->lo == rr->hi.
 // Sets *s to span the remainder of the string.
 // Sets *rp to the character.
-bool Regexp::ParseState::ParseCCRange(StringPiece* s, RuneRange* rr,
-                                      const StringPiece& whole_class,
+bool Regexp::ParseState::ParseCCRange(absl::string_view* s, RuneRange* rr,
+                                      absl::string_view whole_class,
                                       RegexpStatus* status) {
-  StringPiece os = *s;
+  absl::string_view os = *s;
   if (!ParseCCCharacter(s, &rr->lo, whole_class, status))
     return false;
   // [a-] means (a|-), so check for final ].
@@ -1891,8 +1891,8 @@ bool Regexp::ParseState::ParseCCRange(StringPiece* s, RuneRange* rr,
       return false;
     if (rr->hi < rr->lo) {
       status->set_code(kRegexpBadCharRange);
-      status->set_error_arg(
-          StringPiece(os.data(), static_cast<size_t>(s->data() - os.data())));
+      status->set_error_arg(absl::string_view(
+          os.data(), static_cast<size_t>(s->data() - os.data())));
       return false;
     }
   } else {
@@ -1904,21 +1904,20 @@ bool Regexp::ParseState::ParseCCRange(StringPiece* s, RuneRange* rr,
 // Parses a possibly-negated character class expression like [^abx-z[:digit:]].
 // Sets *s to span the remainder of the string.
 // Sets *out_re to the regexp for the class.
-bool Regexp::ParseState::ParseCharClass(StringPiece* s,
-                                        Regexp** out_re,
+bool Regexp::ParseState::ParseCharClass(absl::string_view* s, Regexp** out_re,
                                         RegexpStatus* status) {
-  StringPiece whole_class = *s;
-  if (s->size() == 0 || (*s)[0] != '[') {
+  absl::string_view whole_class = *s;
+  if (s->empty() || (*s)[0] != '[') {
     // Caller checked this.
     status->set_code(kRegexpInternalError);
-    status->set_error_arg(StringPiece());
+    status->set_error_arg(absl::string_view());
     return false;
   }
   bool negated = false;
   Regexp* re = new Regexp(kRegexpCharClass, flags_ & ~FoldCase);
   re->ccb_ = new CharClassBuilder;
   s->remove_prefix(1);  // '['
-  if (s->size() > 0 && (*s)[0] == '^') {
+  if (!s->empty() && (*s)[0] == '^') {
     s->remove_prefix(1);  // '^'
     negated = true;
     if (!(flags_ & ClassNL) || (flags_ & NeverNL)) {
@@ -1928,21 +1927,21 @@ bool Regexp::ParseState::ParseCharClass(StringPiece* s,
     }
   }
   bool first = true;  // ] is okay as first char in class
-  while (s->size() > 0 && ((*s)[0] != ']' || first)) {
+  while (!s->empty() && ((*s)[0] != ']' || first)) {
     // - is only okay unescaped as first or last in class.
     // Except that Perl allows - anywhere.
     if ((*s)[0] == '-' && !first && !(flags_&PerlX) &&
         (s->size() == 1 || (*s)[1] != ']')) {
-      StringPiece t = *s;
+      absl::string_view t = *s;
       t.remove_prefix(1);  // '-'
       Rune r;
-      int n = StringPieceToRune(&r, &t, status);
+      int n = StringViewToRune(&r, &t, status);
       if (n < 0) {
         re->Decref();
         return false;
       }
       status->set_code(kRegexpBadCharRange);
-      status->set_error_arg(StringPiece(s->data(), 1+n));
+      status->set_error_arg(absl::string_view(s->data(), 1+n));
       re->Decref();
       return false;
     }
@@ -1977,7 +1976,7 @@ bool Regexp::ParseState::ParseCharClass(StringPiece* s,
     }
 
     // Look for Perl character class symbols (extension).
-    const UGroup *g = MaybeParsePerlCCEscape(s, flags_);
+    const UGroup* g = MaybeParsePerlCCEscape(s, flags_);
     if (g != NULL) {
       AddUGroup(re->ccb_, g, g->sign, flags_);
       continue;
@@ -1996,7 +1995,7 @@ bool Regexp::ParseState::ParseCharClass(StringPiece* s,
     // in the flags.
     re->ccb_->AddRangeFlags(rr.lo, rr.hi, flags_ | Regexp::ClassNL);
   }
-  if (s->size() == 0) {
+  if (s->empty()) {
     status->set_code(kRegexpMissingBracket);
     status->set_error_arg(whole_class);
     re->Decref();
@@ -2011,19 +2010,34 @@ bool Regexp::ParseState::ParseCharClass(StringPiece* s,
   return true;
 }
 
-// Is this a valid capture name?  [A-Za-z0-9_]+
-// PCRE limits names to 32 bytes.
-// Python rejects names starting with digits.
-// We don't enforce either of those.
-static bool IsValidCaptureName(const StringPiece& name) {
-  if (name.size() == 0)
+// Returns whether name is a valid capture name.
+static bool IsValidCaptureName(absl::string_view name) {
+  if (name.empty())
     return false;
-  for (size_t i = 0; i < name.size(); i++) {
-    int c = name[i];
-    if (('0' <= c && c <= '9') ||
-        ('a' <= c && c <= 'z') ||
-        ('A' <= c && c <= 'Z') ||
-        c == '_')
+
+  // Historically, we effectively used [0-9A-Za-z_]+ to validate; that
+  // followed Python 2 except for not restricting the first character.
+  // As of Python 3, Unicode characters beyond ASCII are also allowed;
+  // accordingly, we permit the Lu, Ll, Lt, Lm, Lo, Nl, Mn, Mc, Nd and
+  // Pc categories, but again without restricting the first character.
+  // Also, Unicode normalization (e.g. NFKC) isn't performed: Python 3
+  // performs it for identifiers, but seemingly not for capture names;
+  // if they start doing that for capture names, we won't follow suit.
+  static const CharClass* const cc = []() {
+    CharClassBuilder ccb;
+    for (absl::string_view group :
+         {"Lu", "Ll", "Lt", "Lm", "Lo", "Nl", "Mn", "Mc", "Nd", "Pc"})
+      AddUGroup(&ccb, LookupGroup(group, unicode_groups, num_unicode_groups),
+                +1, Regexp::NoParseFlags);
+    return ccb.GetCharClass();
+  }();
+
+  absl::string_view t = name;
+  Rune r;
+  while (!t.empty()) {
+    if (StringViewToRune(&r, &t, NULL) < 0)
+      return false;
+    if (cc->Contains(r))
       continue;
     return false;
   }
@@ -2035,13 +2049,13 @@ static bool IsValidCaptureName(const StringPiece& name) {
 // The caller must check that s begins with "(?".
 // Returns true on success.  If the Perl flag is not
 // well-formed or not supported, sets status_ and returns false.
-bool Regexp::ParseState::ParsePerlFlags(StringPiece* s) {
-  StringPiece t = *s;
+bool Regexp::ParseState::ParsePerlFlags(absl::string_view* s) {
+  absl::string_view t = *s;
 
   // Caller is supposed to check this.
   if (!(flags_ & PerlX) || t.size() < 2 || t[0] != '(' || t[1] != '?') {
-    LOG(DFATAL) << "Bad call to ParseState::ParsePerlFlags";
     status_->set_code(kRegexpInternalError);
+    LOG(DFATAL) << "Bad call to ParseState::ParsePerlFlags";
     return false;
   }
 
@@ -2065,7 +2079,7 @@ bool Regexp::ParseState::ParsePerlFlags(StringPiece* s) {
   if (t.size() > 2 && t[0] == 'P' && t[1] == '<') {
     // Pull out name.
     size_t end = t.find('>', 2);
-    if (end == StringPiece::npos) {
+    if (end == absl::string_view::npos) {
       if (!IsValidUTF8(*s, status_))
         return false;
       status_->set_code(kRegexpBadNamedCapture);
@@ -2074,8 +2088,8 @@ bool Regexp::ParseState::ParsePerlFlags(StringPiece* s) {
     }
 
     // t is "P<name>...", t[end] == '>'
-    StringPiece capture(t.begin()-2, end+3);  // "(?P<name>"
-    StringPiece name(t.begin()+2, end-2);     // "name"
+    absl::string_view capture(t.data()-2, end+3);  // "(?P<name>"
+    absl::string_view name(t.data()+2, end-2);     // "name"
     if (!IsValidUTF8(name, status_))
       return false;
     if (!IsValidCaptureName(name)) {
@@ -2089,7 +2103,8 @@ bool Regexp::ParseState::ParsePerlFlags(StringPiece* s) {
       return false;
     }
 
-    s->remove_prefix(static_cast<size_t>(capture.end() - s->begin()));
+    s->remove_prefix(
+        static_cast<size_t>(capture.data() + capture.size() - s->data()));
     return true;
   }
 
@@ -2098,9 +2113,9 @@ bool Regexp::ParseState::ParsePerlFlags(StringPiece* s) {
   int nflags = flags_;
   Rune c;
   for (bool done = false; !done; ) {
-    if (t.size() == 0)
+    if (t.empty())
       goto BadPerlOp;
-    if (StringPieceToRune(&c, &t, status_) < 0)
+    if (StringViewToRune(&c, &t, status_) < 0)
       return false;
     switch (c) {
       default:
@@ -2173,7 +2188,7 @@ bool Regexp::ParseState::ParsePerlFlags(StringPiece* s) {
 BadPerlOp:
   status_->set_code(kRegexpBadPerlOp);
   status_->set_error_arg(
-      StringPiece(s->begin(), static_cast<size_t>(t.begin() - s->begin())));
+      absl::string_view(s->data(), static_cast<size_t>(t.data() - s->data())));
   return false;
 }
 
@@ -2181,7 +2196,7 @@ BadPerlOp:
 // into UTF8 encoding in string.
 // Can't use EncodingUtils::EncodeLatin1AsUTF8 because it is
 // deprecated and because it rejects code points 0x80-0x9F.
-void ConvertLatin1ToUTF8(const StringPiece& latin1, string* utf) {
+void ConvertLatin1ToUTF8(absl::string_view latin1, std::string* utf) {
   char buf[UTFmax];
 
   utf->clear();
@@ -2196,7 +2211,7 @@ void ConvertLatin1ToUTF8(const StringPiece& latin1, string* utf) {
 // returning the corresponding Regexp tree.
 // The caller must Decref the return value when done with it.
 // Returns NULL on error.
-Regexp* Regexp::Parse(const StringPiece& s, ParseFlags global_flags,
+Regexp* Regexp::Parse(absl::string_view s, ParseFlags global_flags,
                       RegexpStatus* status) {
   // Make status non-NULL (easier on everyone else).
   RegexpStatus xstatus;
@@ -2204,11 +2219,11 @@ Regexp* Regexp::Parse(const StringPiece& s, ParseFlags global_flags,
     status = &xstatus;
 
   ParseState ps(global_flags, s, status);
-  StringPiece t = s;
+  absl::string_view t = s;
 
   // Convert regexp to UTF-8 (easier on the rest of the parser).
   if (global_flags & Latin1) {
-    string* tmp = new string;
+    std::string* tmp = new std::string;
     ConvertLatin1ToUTF8(t, tmp);
     status->set_tmp(tmp);
     t = *tmp;
@@ -2216,9 +2231,9 @@ Regexp* Regexp::Parse(const StringPiece& s, ParseFlags global_flags,
 
   if (global_flags & Literal) {
     // Special parse loop for literal string.
-    while (t.size() > 0) {
+    while (!t.empty()) {
       Rune r;
-      if (StringPieceToRune(&r, &t, status) < 0)
+      if (StringViewToRune(&r, &t, status) < 0)
         return NULL;
       if (!ps.PushLiteral(r))
         return NULL;
@@ -2226,13 +2241,13 @@ Regexp* Regexp::Parse(const StringPiece& s, ParseFlags global_flags,
     return ps.DoFinish();
   }
 
-  StringPiece lastunary = StringPiece();
-  while (t.size() > 0) {
-    StringPiece isunary = StringPiece();
+  absl::string_view lastunary = absl::string_view();
+  while (!t.empty()) {
+    absl::string_view isunary = absl::string_view();
     switch (t[0]) {
       default: {
         Rune r;
-        if (StringPieceToRune(&r, &t, status) < 0)
+        if (StringViewToRune(&r, &t, status) < 0)
           return NULL;
         if (!ps.PushLiteral(r))
           return NULL;
@@ -2251,7 +2266,7 @@ Regexp* Regexp::Parse(const StringPiece& s, ParseFlags global_flags,
           if (!ps.DoLeftParenNoCapture())
             return NULL;
         } else {
-          if (!ps.DoLeftParen(StringPiece()))
+          if (!ps.DoLeftParen(absl::string_view()))
             return NULL;
         }
         t.remove_prefix(1);  // '('
@@ -2270,7 +2285,7 @@ Regexp* Regexp::Parse(const StringPiece& s, ParseFlags global_flags,
         break;
 
       case '^':  // Beginning of line.
-        if (!ps.PushCarat())
+        if (!ps.PushCaret())
           return NULL;
         t.remove_prefix(1);  // '^'
         break;
@@ -2307,27 +2322,27 @@ Regexp* Regexp::Parse(const StringPiece& s, ParseFlags global_flags,
         op = kRegexpQuest;
         goto Rep;
       Rep:
-        StringPiece opstr = t;
+        absl::string_view opstr = t;
         bool nongreedy = false;
         t.remove_prefix(1);  // '*' or '+' or '?'
         if (ps.flags() & PerlX) {
-          if (t.size() > 0 && t[0] == '?') {
+          if (!t.empty() && t[0] == '?') {
             nongreedy = true;
             t.remove_prefix(1);  // '?'
           }
-          if (lastunary.size() > 0) {
+          if (!lastunary.empty()) {
             // In Perl it is not allowed to stack repetition operators:
             //   a** is a syntax error, not a double-star.
             // (and a++ means something else entirely, which we don't support!)
             status->set_code(kRegexpRepeatOp);
-            status->set_error_arg(StringPiece(
-                lastunary.begin(),
-                static_cast<size_t>(t.begin() - lastunary.begin())));
+            status->set_error_arg(absl::string_view(
+                lastunary.data(),
+                static_cast<size_t>(t.data() - lastunary.data())));
             return NULL;
           }
         }
-        opstr = StringPiece(opstr.data(),
-                            static_cast<size_t>(t.data() - opstr.data()));
+        opstr = absl::string_view(opstr.data(),
+                                  static_cast<size_t>(t.data() - opstr.data()));
         if (!ps.PushRepeatOp(op, opstr, nongreedy))
           return NULL;
         isunary = opstr;
@@ -2336,7 +2351,7 @@ Regexp* Regexp::Parse(const StringPiece& s, ParseFlags global_flags,
 
       case '{': {  // Counted repetition.
         int lo, hi;
-        StringPiece opstr = t;
+        absl::string_view opstr = t;
         if (!MaybeParseRepetition(&t, &lo, &hi)) {
           // Treat like a literal.
           if (!ps.PushLiteral('{'))
@@ -2346,21 +2361,21 @@ Regexp* Regexp::Parse(const StringPiece& s, ParseFlags global_flags,
         }
         bool nongreedy = false;
         if (ps.flags() & PerlX) {
-          if (t.size() > 0 && t[0] == '?') {
+          if (!t.empty() && t[0] == '?') {
             nongreedy = true;
             t.remove_prefix(1);  // '?'
           }
-          if (lastunary.size() > 0) {
+          if (!lastunary.empty()) {
             // Not allowed to stack repetition operators.
             status->set_code(kRegexpRepeatOp);
-            status->set_error_arg(StringPiece(
-                lastunary.begin(),
-                static_cast<size_t>(t.begin() - lastunary.begin())));
+            status->set_error_arg(absl::string_view(
+                lastunary.data(),
+                static_cast<size_t>(t.data() - lastunary.data())));
             return NULL;
           }
         }
-        opstr = StringPiece(opstr.data(),
-                            static_cast<size_t>(t.data() - opstr.data()));
+        opstr = absl::string_view(opstr.data(),
+                                  static_cast<size_t>(t.data() - opstr.data()));
         if (!ps.PushRepetition(lo, hi, opstr, nongreedy))
           return NULL;
         isunary = opstr;
@@ -2404,13 +2419,13 @@ Regexp* Regexp::Parse(const StringPiece& s, ParseFlags global_flags,
 
           if (t[1] == 'Q') {  // \Q ... \E: the ... is always literals
             t.remove_prefix(2);  // '\\', 'Q'
-            while (t.size() > 0) {
+            while (!t.empty()) {
               if (t.size() >= 2 && t[0] == '\\' && t[1] == 'E') {
                 t.remove_prefix(2);  // '\\', 'E'
                 break;
               }
               Rune r;
-              if (StringPieceToRune(&r, &t, status) < 0)
+              if (StringViewToRune(&r, &t, status) < 0)
                 return NULL;
               if (!ps.PushLiteral(r))
                 return NULL;
@@ -2436,7 +2451,7 @@ Regexp* Regexp::Parse(const StringPiece& s, ParseFlags global_flags,
           }
         }
 
-        const UGroup *g = MaybeParsePerlCCEscape(&t, ps.flags());
+        const UGroup* g = MaybeParsePerlCCEscape(&t, ps.flags());
         if (g != NULL) {
           Regexp* re = new Regexp(kRegexpCharClass, ps.flags() & ~FoldCase);
           re->ccb_ = new CharClassBuilder;
diff --git a/re2/perl_groups.cc b/re2/perl_groups.cc
index 422b388..4687444 100644
--- a/re2/perl_groups.cc
+++ b/re2/perl_groups.cc
@@ -20,12 +20,12 @@ static const URange16 code3[] = {  /* \w */
 	{ 0x61, 0x7a },
 };
 const UGroup perl_groups[] = {
-	{ "\\d", +1, code1, 1 },
-	{ "\\D", -1, code1, 1 },
-	{ "\\s", +1, code2, 3 },
-	{ "\\S", -1, code2, 3 },
-	{ "\\w", +1, code3, 4 },
-	{ "\\W", -1, code3, 4 },
+	{ "\\d", +1, code1, 1, 0, 0 },
+	{ "\\D", -1, code1, 1, 0, 0 },
+	{ "\\s", +1, code2, 3, 0, 0 },
+	{ "\\S", -1, code2, 3, 0, 0 },
+	{ "\\w", +1, code3, 4, 0, 0 },
+	{ "\\W", -1, code3, 4, 0, 0 },
 };
 const int num_perl_groups = 6;
 static const URange16 code4[] = {  /* [:alnum:] */
@@ -85,34 +85,34 @@ static const URange16 code17[] = {  /* [:xdigit:] */
 	{ 0x61, 0x66 },
 };
 const UGroup posix_groups[] = {
-	{ "[:alnum:]", +1, code4, 3 },
-	{ "[:^alnum:]", -1, code4, 3 },
-	{ "[:alpha:]", +1, code5, 2 },
-	{ "[:^alpha:]", -1, code5, 2 },
-	{ "[:ascii:]", +1, code6, 1 },
-	{ "[:^ascii:]", -1, code6, 1 },
-	{ "[:blank:]", +1, code7, 2 },
-	{ "[:^blank:]", -1, code7, 2 },
-	{ "[:cntrl:]", +1, code8, 2 },
-	{ "[:^cntrl:]", -1, code8, 2 },
-	{ "[:digit:]", +1, code9, 1 },
-	{ "[:^digit:]", -1, code9, 1 },
-	{ "[:graph:]", +1, code10, 1 },
-	{ "[:^graph:]", -1, code10, 1 },
-	{ "[:lower:]", +1, code11, 1 },
-	{ "[:^lower:]", -1, code11, 1 },
-	{ "[:print:]", +1, code12, 1 },
-	{ "[:^print:]", -1, code12, 1 },
-	{ "[:punct:]", +1, code13, 4 },
-	{ "[:^punct:]", -1, code13, 4 },
-	{ "[:space:]", +1, code14, 2 },
-	{ "[:^space:]", -1, code14, 2 },
-	{ "[:upper:]", +1, code15, 1 },
-	{ "[:^upper:]", -1, code15, 1 },
-	{ "[:word:]", +1, code16, 4 },
-	{ "[:^word:]", -1, code16, 4 },
-	{ "[:xdigit:]", +1, code17, 3 },
-	{ "[:^xdigit:]", -1, code17, 3 },
+	{ "[:alnum:]", +1, code4, 3, 0, 0 },
+	{ "[:^alnum:]", -1, code4, 3, 0, 0 },
+	{ "[:alpha:]", +1, code5, 2, 0, 0 },
+	{ "[:^alpha:]", -1, code5, 2, 0, 0 },
+	{ "[:ascii:]", +1, code6, 1, 0, 0 },
+	{ "[:^ascii:]", -1, code6, 1, 0, 0 },
+	{ "[:blank:]", +1, code7, 2, 0, 0 },
+	{ "[:^blank:]", -1, code7, 2, 0, 0 },
+	{ "[:cntrl:]", +1, code8, 2, 0, 0 },
+	{ "[:^cntrl:]", -1, code8, 2, 0, 0 },
+	{ "[:digit:]", +1, code9, 1, 0, 0 },
+	{ "[:^digit:]", -1, code9, 1, 0, 0 },
+	{ "[:graph:]", +1, code10, 1, 0, 0 },
+	{ "[:^graph:]", -1, code10, 1, 0, 0 },
+	{ "[:lower:]", +1, code11, 1, 0, 0 },
+	{ "[:^lower:]", -1, code11, 1, 0, 0 },
+	{ "[:print:]", +1, code12, 1, 0, 0 },
+	{ "[:^print:]", -1, code12, 1, 0, 0 },
+	{ "[:punct:]", +1, code13, 4, 0, 0 },
+	{ "[:^punct:]", -1, code13, 4, 0, 0 },
+	{ "[:space:]", +1, code14, 2, 0, 0 },
+	{ "[:^space:]", -1, code14, 2, 0, 0 },
+	{ "[:upper:]", +1, code15, 1, 0, 0 },
+	{ "[:^upper:]", -1, code15, 1, 0, 0 },
+	{ "[:word:]", +1, code16, 4, 0, 0 },
+	{ "[:^word:]", -1, code16, 4, 0, 0 },
+	{ "[:xdigit:]", +1, code17, 3, 0, 0 },
+	{ "[:^xdigit:]", -1, code17, 3, 0, 0 },
 };
 const int num_posix_groups = 28;
 
diff --git a/util/pod_array.h b/re2/pod_array.h
similarity index 84%
rename from util/pod_array.h
rename to re2/pod_array.h
index eaf492d..f234e97 100644
--- a/util/pod_array.h
+++ b/re2/pod_array.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-#ifndef UTIL_POD_ARRAY_H_
-#define UTIL_POD_ARRAY_H_
+#ifndef RE2_POD_ARRAY_H_
+#define RE2_POD_ARRAY_H_
 
 #include <memory>
 #include <type_traits>
@@ -13,7 +13,7 @@ namespace re2 {
 template <typename T>
 class PODArray {
  public:
-  static_assert(std::is_pod<T>::value,
+  static_assert(std::is_trivial<T>::value && std::is_standard_layout<T>::value,
                 "T must be POD");
 
   PODArray()
@@ -52,4 +52,4 @@ class PODArray {
 
 }  // namespace re2
 
-#endif  // UTIL_POD_ARRAY_H_
+#endif  // RE2_POD_ARRAY_H_
diff --git a/re2/prefilter.cc b/re2/prefilter.cc
index b657357..3c7886f 100644
--- a/re2/prefilter.cc
+++ b/re2/prefilter.cc
@@ -7,11 +7,11 @@
 #include <stddef.h>
 #include <stdint.h>
 #include <string>
+#include <utility>
 #include <vector>
 
-#include "util/util.h"
+#include "absl/strings/str_format.h"
 #include "util/logging.h"
-#include "util/strutil.h"
 #include "util/utf.h"
 #include "re2/re2.h"
 #include "re2/unicode_casefold.h"
@@ -21,9 +21,6 @@ namespace re2 {
 
 static const bool ExtraDebug = false;
 
-typedef std::set<string>::iterator SSIter;
-typedef std::set<string>::const_iterator ConstSSIter;
-
 // Initializes a Prefilter, allocating subs_ as necessary.
 Prefilter::Prefilter(Op op) {
   op_ = op;
@@ -140,35 +137,41 @@ Prefilter* Prefilter::Or(Prefilter* a, Prefilter* b) {
   return AndOr(OR, a, b);
 }
 
-static void SimplifyStringSet(std::set<string> *ss) {
+void Prefilter::SimplifyStringSet(SSet* ss) {
   // Now make sure that the strings aren't redundant.  For example, if
   // we know "ab" is a required string, then it doesn't help at all to
   // know that "abc" is also a required string, so delete "abc". This
   // is because, when we are performing a string search to filter
-  // regexps, matching ab will already allow this regexp to be a
-  // candidate for match, so further matching abc is redundant.
-
-  for (SSIter i = ss->begin(); i != ss->end(); ++i) {
+  // regexps, matching "ab" will already allow this regexp to be a
+  // candidate for match, so further matching "abc" is redundant.
+  // Note that we must ignore "" because find() would find it at the
+  // start of everything and thus we would end up erasing everything.
+  //
+  // The SSet sorts strings by length, then lexicographically. Note that
+  // smaller strings appear first and all strings must be unique. These
+  // observations let us skip string comparisons when possible.
+  SSIter i = ss->begin();
+  if (i != ss->end() && i->empty()) {
+    ++i;
+  }
+  for (; i != ss->end(); ++i) {
     SSIter j = i;
     ++j;
     while (j != ss->end()) {
-      // Increment j early so that we can erase the element it points to.
-      SSIter old_j = j;
+      if (j->size() > i->size() && j->find(*i) != std::string::npos) {
+        j = ss->erase(j);
+        continue;
+      }
       ++j;
-      if (old_j->find(*i) != string::npos)
-        ss->erase(old_j);
     }
   }
 }
 
-Prefilter* Prefilter::OrStrings(std::set<string>* ss) {
+Prefilter* Prefilter::OrStrings(SSet* ss) {
+  Prefilter* or_prefilter = new Prefilter(NONE);
   SimplifyStringSet(ss);
-  Prefilter* or_prefilter = NULL;
-  if (!ss->empty()) {
-    or_prefilter = new Prefilter(NONE);
-    for (SSIter i = ss->begin(); i != ss->end(); ++i)
-      or_prefilter = Or(or_prefilter, FromString(*i));
-  }
+  for (SSIter i = ss->begin(); i != ss->end(); ++i)
+    or_prefilter = Or(or_prefilter, FromString(*i));
   return or_prefilter;
 }
 
@@ -191,7 +194,7 @@ static Rune ToLowerRuneLatin1(Rune r) {
   return r;
 }
 
-Prefilter* Prefilter::FromString(const string& str) {
+Prefilter* Prefilter::FromString(const std::string& str) {
   Prefilter* m = new Prefilter(Prefilter::ATOM);
   m->atom_ = str;
   return m;
@@ -221,19 +224,19 @@ class Prefilter::Info {
   static Info* AnyMatch();
 
   // Format Info as a string.
-  string ToString();
+  std::string ToString();
 
   // Caller takes ownership of the Prefilter.
   Prefilter* TakeMatch();
 
-  std::set<string>& exact() { return exact_; }
+  SSet& exact() { return exact_; }
 
   bool is_exact() const { return is_exact_; }
 
   class Walker;
 
  private:
-  std::set<string> exact_;
+  SSet exact_;
 
   // When is_exact_ is true, the strings that match
   // are placed in exact_. When it is no longer an exact
@@ -268,13 +271,11 @@ Prefilter* Prefilter::Info::TakeMatch() {
 }
 
 // Format a Info in string form.
-string Prefilter::Info::ToString() {
+std::string Prefilter::Info::ToString() {
   if (is_exact_) {
     int n = 0;
-    string s;
-    for (std::set<string>::iterator i = exact_.begin();
-         i != exact_.end();
-         ++i) {
+    std::string s;
+    for (SSIter i = exact_.begin(); i != exact_.end(); ++i) {
       if (n++ > 0)
         s += ",";
       s += *i;
@@ -288,18 +289,7 @@ string Prefilter::Info::ToString() {
   return "";
 }
 
-// Add the strings from src to dst.
-static void CopyIn(const std::set<string>& src,
-                   std::set<string>* dst) {
-  for (ConstSSIter i = src.begin(); i != src.end(); ++i)
-    dst->insert(*i);
-}
-
-// Add the cross-product of a and b to dst.
-// (For each string i in a and j in b, add i+j.)
-static void CrossProduct(const std::set<string>& a,
-                         const std::set<string>& b,
-                         std::set<string>* dst) {
+void Prefilter::CrossProduct(const SSet& a, const SSet& b, SSet* dst) {
   for (ConstSSIter i = a.begin(); i != a.end(); ++i)
     for (ConstSSIter j = b.begin(); j != b.end(); ++j)
       dst->insert(*i + *j);
@@ -345,8 +335,14 @@ Prefilter::Info* Prefilter::Info::Alt(Info* a, Info* b) {
   Info *ab = new Info();
 
   if (a->is_exact_ && b->is_exact_) {
-    CopyIn(a->exact_, &ab->exact_);
-    CopyIn(b->exact_, &ab->exact_);
+    // Avoid string copies by moving the larger exact_ set into
+    // ab directly, then merge in the smaller set.
+    if (a->exact_.size() < b->exact_.size()) {
+      using std::swap;
+      swap(a, b);
+    }
+    ab->exact_ = std::move(a->exact_);
+    ab->exact_.insert(b->exact_.begin(), b->exact_.end());
     ab->is_exact_ = true;
   } else {
     // Either a or b has is_exact_ = false. If the other
@@ -390,15 +386,15 @@ Prefilter::Info* Prefilter::Info::Plus(Info *a) {
   return ab;
 }
 
-static string RuneToString(Rune r) {
+static std::string RuneToString(Rune r) {
   char buf[UTFmax];
   int n = runetochar(buf, &r);
-  return string(buf, n);
+  return std::string(buf, n);
 }
 
-static string RuneToStringLatin1(Rune r) {
+static std::string RuneToStringLatin1(Rune r) {
   char c = r & 0xff;
-  return string(&c, 1);
+  return std::string(&c, 1);
 }
 
 // Constructs Info for literal rune.
@@ -534,8 +530,8 @@ Prefilter::Info* Prefilter::Info::Walker::PostVisit(
   switch (re->op()) {
     default:
     case kRegexpRepeat:
-      LOG(DFATAL) << "Bad regexp op " << re->op();
       info = EmptyString();
+      LOG(DFATAL) << "Bad regexp op " << re->op();
       break;
 
     case kRegexpNoMatch:
@@ -650,23 +646,24 @@ Prefilter* Prefilter::FromRegexp(Regexp* re) {
     return NULL;
 
   Regexp* simple = re->Simplify();
-  Prefilter::Info *info = BuildInfo(simple);
+  if (simple == NULL)
+    return NULL;
 
+  Prefilter::Info* info = BuildInfo(simple);
   simple->Decref();
   if (info == NULL)
     return NULL;
 
   Prefilter* m = info->TakeMatch();
-
   delete info;
   return m;
 }
 
-string Prefilter::DebugString() const {
+std::string Prefilter::DebugString() const {
   switch (op_) {
     default:
       LOG(DFATAL) << "Bad op in Prefilter::DebugString: " << op_;
-      return StringPrintf("op%d", op_);
+      return absl::StrFormat("op%d", op_);
     case NONE:
       return "*no-matches*";
     case ATOM:
@@ -674,7 +671,7 @@ string Prefilter::DebugString() const {
     case ALL:
       return "";
     case AND: {
-      string s = "";
+      std::string s = "";
       for (size_t i = 0; i < subs_->size(); i++) {
         if (i > 0)
           s += " ";
@@ -684,7 +681,7 @@ string Prefilter::DebugString() const {
       return s;
     }
     case OR: {
-      string s = "(";
+      std::string s = "(";
       for (size_t i = 0; i < subs_->size(); i++) {
         if (i > 0)
           s += "|";
diff --git a/re2/prefilter.h b/re2/prefilter.h
index ead09e1..b2545e1 100644
--- a/re2/prefilter.h
+++ b/re2/prefilter.h
@@ -13,7 +13,6 @@
 #include <string>
 #include <vector>
 
-#include "util/util.h"
 #include "util/logging.h"
 
 namespace re2 {
@@ -37,7 +36,7 @@ class Prefilter {
   ~Prefilter();
 
   Op op() { return op_; }
-  const string& atom() const { return atom_; }
+  const std::string& atom() const { return atom_; }
   void set_unique_id(int id) { unique_id_ = id; }
   int unique_id() const { return unique_id_; }
 
@@ -57,11 +56,24 @@ class Prefilter {
   static Prefilter* FromRE2(const RE2* re2);
 
   // Returns a readable debug string of the prefilter.
-  string DebugString() const;
+  std::string DebugString() const;
 
  private:
+  // A comparator used to store exact strings. We compare by length,
+  // then lexicographically. This ordering makes it easier to reduce the
+  // set of strings in SimplifyStringSet.
+  struct LengthThenLex {
+    bool operator()(const std::string& a, const std::string& b) const {
+       return (a.size() < b.size()) || (a.size() == b.size() && a < b);
+    }
+  };
+
   class Info;
 
+  using SSet = std::set<std::string, LengthThenLex>;
+  using SSIter = SSet::iterator;
+  using ConstSSIter = SSet::const_iterator;
+
   // Combines two prefilters together to create an AND. The passed
   // Prefilters will be part of the returned Prefilter or deleted.
   static Prefilter* And(Prefilter* a, Prefilter* b);
@@ -75,14 +87,23 @@ class Prefilter {
 
   static Prefilter* FromRegexp(Regexp* a);
 
-  static Prefilter* FromString(const string& str);
+  static Prefilter* FromString(const std::string& str);
 
-  static Prefilter* OrStrings(std::set<string>* ss);
+  static Prefilter* OrStrings(SSet* ss);
 
   static Info* BuildInfo(Regexp* re);
 
   Prefilter* Simplify();
 
+  // Removes redundant strings from the set. A string is redundant if
+  // any of the other strings appear as a substring. The empty string
+  // is a special case, which is ignored.
+  static void SimplifyStringSet(SSet* ss);
+
+  // Adds the cross-product of a and b to dst.
+  // (For each string i in a and j in b, add i+j.)
+  static void CrossProduct(const SSet& a, const SSet& b, SSet* dst);
+
   // Kind of Prefilter.
   Op op_;
 
@@ -90,7 +111,7 @@ class Prefilter {
   std::vector<Prefilter*>* subs_;
 
   // Actual string to match in leaf node.
-  string atom_;
+  std::string atom_;
 
   // If different prefilters have the same string atom, or if they are
   // structurally the same (e.g., OR of same atom strings) they are
diff --git a/re2/prefilter_tree.cc b/re2/prefilter_tree.cc
index a07de40..41f65a3 100644
--- a/re2/prefilter_tree.cc
+++ b/re2/prefilter_tree.cc
@@ -6,16 +6,15 @@
 
 #include <stddef.h>
 #include <algorithm>
+#include <cmath>
 #include <map>
 #include <memory>
-#include <set>
 #include <string>
 #include <utility>
 #include <vector>
 
-#include "util/util.h"
+#include "absl/strings/str_format.h"
 #include "util/logging.h"
-#include "util/strutil.h"
 #include "re2/prefilter.h"
 #include "re2/re2.h"
 
@@ -36,9 +35,6 @@ PrefilterTree::PrefilterTree(int min_atom_len)
 PrefilterTree::~PrefilterTree() {
   for (size_t i = 0; i < prefilter_vec_.size(); i++)
     delete prefilter_vec_[i];
-
-  for (size_t i = 0; i < entries_.size(); i++)
-    delete entries_[i].parents;
 }
 
 void PrefilterTree::Add(Prefilter* prefilter) {
@@ -54,7 +50,7 @@ void PrefilterTree::Add(Prefilter* prefilter) {
   prefilter_vec_.push_back(prefilter);
 }
 
-void PrefilterTree::Compile(std::vector<string>* atom_vec) {
+void PrefilterTree::Compile(std::vector<std::string>* atom_vec) {
   if (compiled_) {
     LOG(DFATAL) << "Compile called already.";
     return;
@@ -67,62 +63,30 @@ void PrefilterTree::Compile(std::vector<string>* atom_vec) {
 
   compiled_ = true;
 
-  // TODO(junyer): Use std::unordered_set<Prefilter*> instead?
   NodeMap nodes;
   AssignUniqueIds(&nodes, atom_vec);
-
-  // Identify nodes that are too common among prefilters and are
-  // triggering too many parents. Then get rid of them if possible.
-  // Note that getting rid of a prefilter node simply means they are
-  // no longer necessary for their parent to trigger; that is, we do
-  // not miss out on any regexps triggering by getting rid of a
-  // prefilter node.
-  for (size_t i = 0; i < entries_.size(); i++) {
-    StdIntMap* parents = entries_[i].parents;
-    if (parents->size() > 8) {
-      // This one triggers too many things. If all the parents are AND
-      // nodes and have other things guarding them, then get rid of
-      // this trigger. TODO(vsri): Adjust the threshold appropriately,
-      // make it a function of total number of nodes?
-      bool have_other_guard = true;
-      for (StdIntMap::iterator it = parents->begin();
-           it != parents->end(); ++it) {
-        have_other_guard = have_other_guard &&
-            (entries_[it->first].propagate_up_at_count > 1);
-      }
-
-      if (have_other_guard) {
-        for (StdIntMap::iterator it = parents->begin();
-             it != parents->end(); ++it)
-          entries_[it->first].propagate_up_at_count -= 1;
-
-        parents->clear();  // Forget the parents
-      }
-    }
-  }
-
   if (ExtraDebug)
     PrintDebugInfo(&nodes);
 }
 
 Prefilter* PrefilterTree::CanonicalNode(NodeMap* nodes, Prefilter* node) {
-  string node_string = NodeString(node);
-  std::map<string, Prefilter*>::iterator iter = nodes->find(node_string);
+  std::string node_string = NodeString(node);
+  NodeMap::iterator iter = nodes->find(node_string);
   if (iter == nodes->end())
     return NULL;
   return (*iter).second;
 }
 
-string PrefilterTree::NodeString(Prefilter* node) const {
+std::string PrefilterTree::NodeString(Prefilter* node) const {
   // Adding the operation disambiguates AND/OR/atom nodes.
-  string s = StringPrintf("%d", node->op()) + ":";
+  std::string s = absl::StrFormat("%d", node->op()) + ":";
   if (node->op() == Prefilter::ATOM) {
     s += node->atom();
   } else {
     for (size_t i = 0; i < node->subs()->size(); i++) {
       if (i > 0)
         s += ',';
-      s += StringPrintf("%d", (*node->subs())[i]->unique_id());
+      s += absl::StrFormat("%d", (*node->subs())[i]->unique_id());
     }
   }
   return s;
@@ -166,7 +130,7 @@ bool PrefilterTree::KeepNode(Prefilter* node) const {
 }
 
 void PrefilterTree::AssignUniqueIds(NodeMap* nodes,
-                                    std::vector<string>* atom_vec) {
+                                    std::vector<std::string>* atom_vec) {
   atom_vec->clear();
 
   // Build vector of all filter nodes, sorted topologically
@@ -217,65 +181,42 @@ void PrefilterTree::AssignUniqueIds(NodeMap* nodes,
       node->set_unique_id(canonical->unique_id());
     }
   }
-  entries_.resize(nodes->size());
-
-  // Create parent StdIntMap for the entries.
-  for (int i = static_cast<int>(v.size()) - 1; i >= 0; i--) {
-    Prefilter* prefilter = v[i];
-    if (prefilter == NULL)
-      continue;
-
-    if (CanonicalNode(nodes, prefilter) != prefilter)
-      continue;
-
-    Entry* entry = &entries_[prefilter->unique_id()];
-    entry->parents = new StdIntMap();
-  }
+  entries_.resize(unique_id);
 
   // Fill the entries.
   for (int i = static_cast<int>(v.size()) - 1; i >= 0; i--) {
     Prefilter* prefilter = v[i];
     if (prefilter == NULL)
       continue;
-
     if (CanonicalNode(nodes, prefilter) != prefilter)
       continue;
-
-    Entry* entry = &entries_[prefilter->unique_id()];
-
+    int id = prefilter->unique_id();
     switch (prefilter->op()) {
       default:
-      case Prefilter::ALL:
         LOG(DFATAL) << "Unexpected op: " << prefilter->op();
         return;
 
       case Prefilter::ATOM:
-        entry->propagate_up_at_count = 1;
+        entries_[id].propagate_up_at_count = 1;
         break;
 
       case Prefilter::OR:
       case Prefilter::AND: {
-        std::set<int> uniq_child;
+        // For each child, we append our id to the child's list of
+        // parent ids... unless we happen to have done so already.
+        // The number of appends is the number of unique children,
+        // which allows correct upward propagation from AND nodes.
+        int up_count = 0;
         for (size_t j = 0; j < prefilter->subs()->size(); j++) {
-          Prefilter* child = (*prefilter->subs())[j];
-          Prefilter* canonical = CanonicalNode(nodes, child);
-          if (canonical == NULL) {
-            LOG(DFATAL) << "Null canonical node";
-            return;
-          }
-          int child_id = canonical->unique_id();
-          uniq_child.insert(child_id);
-          // To the child, we want to add to parent indices.
-          Entry* child_entry = &entries_[child_id];
-          if (child_entry->parents->find(prefilter->unique_id()) ==
-              child_entry->parents->end()) {
-            (*child_entry->parents)[prefilter->unique_id()] = 1;
+          int child_id = (*prefilter->subs())[j]->unique_id();
+          std::vector<int>& parents = entries_[child_id].parents;
+          if (parents.empty() || parents.back() != id) {
+            parents.push_back(id);
+            up_count++;
           }
         }
-        entry->propagate_up_at_count = prefilter->op() == Prefilter::AND
-                                           ? static_cast<int>(uniq_child.size())
-                                           : 1;
-
+        entries_[id].propagate_up_at_count =
+            prefilter->op() == Prefilter::AND ? up_count : 1;
         break;
       }
     }
@@ -290,6 +231,52 @@ void PrefilterTree::AssignUniqueIds(NodeMap* nodes,
     Entry* entry = &entries_[id];
     entry->regexps.push_back(static_cast<int>(i));
   }
+
+  // Lastly, using probability-based heuristics, we identify nodes
+  // that trigger too many parents and then we try to prune edges.
+  // We use logarithms below to avoid the likelihood of underflow.
+  double log_num_regexps = std::log(prefilter_vec_.size() - unfiltered_.size());
+  // Hoisted this above the loop so that we don't thrash the heap.
+  std::vector<std::pair<size_t, int>> entries_by_num_edges;
+  for (int i = static_cast<int>(v.size()) - 1; i >= 0; i--) {
+    Prefilter* prefilter = v[i];
+    // Pruning applies only to AND nodes because it "just" reduces
+    // precision; applied to OR nodes, it would break correctness.
+    if (prefilter == NULL || prefilter->op() != Prefilter::AND)
+      continue;
+    if (CanonicalNode(nodes, prefilter) != prefilter)
+      continue;
+    int id = prefilter->unique_id();
+
+    // Sort the current node's children by the numbers of parents.
+    entries_by_num_edges.clear();
+    for (size_t j = 0; j < prefilter->subs()->size(); j++) {
+      int child_id = (*prefilter->subs())[j]->unique_id();
+      const std::vector<int>& parents = entries_[child_id].parents;
+      entries_by_num_edges.emplace_back(parents.size(), child_id);
+    }
+    std::stable_sort(entries_by_num_edges.begin(), entries_by_num_edges.end());
+
+    // A running estimate of how many regexps will be triggered by
+    // pruning the remaining children's edges to the current node.
+    // Our nominal target is one, so the threshold is log(1) == 0;
+    // pruning occurs iff the child has more than nine edges left.
+    double log_num_triggered = log_num_regexps;
+    for (const auto& pair : entries_by_num_edges) {
+      int child_id = pair.second;
+      std::vector<int>& parents = entries_[child_id].parents;
+      if (log_num_triggered > 0.) {
+        log_num_triggered += std::log(parents.size());
+        log_num_triggered -= log_num_regexps;
+      } else if (parents.size() > 9) {
+        auto it = std::find(parents.begin(), parents.end(), id);
+        if (it != parents.end()) {
+          parents.erase(it);
+          entries_[id].propagate_up_at_count--;
+        }
+      }
+    }
+  }
 }
 
 // Functions for triggering during search.
@@ -336,10 +323,7 @@ void PrefilterTree::PropagateMatch(const std::vector<int>& atom_ids,
       regexps->set(entry.regexps[i], 1);
     int c;
     // Pass trigger up to parents.
-    for (StdIntMap::iterator it = entry.parents->begin();
-         it != entry.parents->end();
-         ++it) {
-      int j = it->first;
+    for (int j : entry.parents) {
       const Entry& parent = entries_[j];
       // Delay until all the children have succeeded.
       if (parent.propagate_up_at_count > 1) {
@@ -369,23 +353,22 @@ void PrefilterTree::PrintDebugInfo(NodeMap* nodes) {
   LOG(ERROR) << "#Unique Nodes: " << entries_.size();
 
   for (size_t i = 0; i < entries_.size(); i++) {
-    StdIntMap* parents = entries_[i].parents;
+    const std::vector<int>& parents = entries_[i].parents;
     const std::vector<int>& regexps = entries_[i].regexps;
     LOG(ERROR) << "EntryId: " << i
-               << " N: " << parents->size() << " R: " << regexps.size();
-    for (StdIntMap::iterator it = parents->begin(); it != parents->end(); ++it)
-      LOG(ERROR) << it->first;
+               << " N: " << parents.size() << " R: " << regexps.size();
+    for (int parent : parents)
+      LOG(ERROR) << parent;
   }
   LOG(ERROR) << "Map:";
-  for (std::map<string, Prefilter*>::const_iterator iter = nodes->begin();
+  for (NodeMap::const_iterator iter = nodes->begin();
        iter != nodes->end(); ++iter)
     LOG(ERROR) << "NodeId: " << (*iter).second->unique_id()
                << " Str: " << (*iter).first;
 }
 
-string PrefilterTree::DebugNodeString(Prefilter* node) const {
-  string node_string = "";
-
+std::string PrefilterTree::DebugNodeString(Prefilter* node) const {
+  std::string node_string = "";
   if (node->op() == Prefilter::ATOM) {
     DCHECK(!node->atom().empty());
     node_string += node->atom();
@@ -396,7 +379,7 @@ string PrefilterTree::DebugNodeString(Prefilter* node) const {
     for (size_t i = 0; i < node->subs()->size(); i++) {
       if (i > 0)
         node_string += ',';
-      node_string += StringPrintf("%d", (*node->subs())[i]->unique_id());
+      node_string += absl::StrFormat("%d", (*node->subs())[i]->unique_id());
       node_string += ":";
       node_string += DebugNodeString((*node->subs())[i]);
     }
diff --git a/re2/prefilter_tree.h b/re2/prefilter_tree.h
index f81e134..3eb8056 100644
--- a/re2/prefilter_tree.h
+++ b/re2/prefilter_tree.h
@@ -7,7 +7,7 @@
 
 // The PrefilterTree class is used to form an AND-OR tree of strings
 // that would trigger each regexp. The 'prefilter' of each regexp is
-// added tp PrefilterTree, and then PrefilterTree is used to find all
+// added to PrefilterTree, and then PrefilterTree is used to find all
 // the unique strings across the prefilters. During search, by using
 // matches from a string matching engine, PrefilterTree deduces the
 // set of regexps that are to be triggered. The 'string matching
@@ -20,9 +20,8 @@
 #include <string>
 #include <vector>
 
-#include "util/util.h"
-#include "util/sparse_array.h"
 #include "re2/prefilter.h"
+#include "re2/sparse_array.h"
 
 namespace re2 {
 
@@ -43,7 +42,7 @@ class PrefilterTree {
   // The caller should use the returned set of strings to do string matching.
   // Each time a string matches, the corresponding index then has to be
   // and passed to RegexpsGivenStrings below.
-  void Compile(std::vector<string>* atom_vec);
+  void Compile(std::vector<std::string>* atom_vec);
 
   // Given the indices of the atoms that matched, returns the indexes
   // of regexps that should be searched.  The matched_atoms should
@@ -59,8 +58,9 @@ class PrefilterTree {
 
  private:
   typedef SparseArray<int> IntMap;
-  typedef std::map<int, int> StdIntMap;
-  typedef std::map<string, Prefilter*> NodeMap;
+  // TODO(junyer): Use absl::flat_hash_set<Prefilter*> instead?
+  // It should be trivial to get rid of the stringification...
+  typedef std::map<std::string, Prefilter*> NodeMap;
 
   // Each unique node has a corresponding Entry that helps in
   // passing the matching trigger information along the tree.
@@ -77,7 +77,7 @@ class PrefilterTree {
     // are two different nodes, but they share the atom 'def'. So when
     // 'def' matches, it triggers two parents, corresponding to the two
     // different OR nodes.
-    StdIntMap* parents;
+    std::vector<int> parents;
 
     // When this node is ready to trigger the parent, what are the
     // regexps that are triggered.
@@ -90,7 +90,7 @@ class PrefilterTree {
   // This function assigns unique ids to various parts of the
   // prefilter, by looking at if these nodes are already in the
   // PrefilterTree.
-  void AssignUniqueIds(NodeMap* nodes, std::vector<string>* atom_vec);
+  void AssignUniqueIds(NodeMap* nodes, std::vector<std::string>* atom_vec);
 
   // Given the matching atoms, find the regexps to be triggered.
   void PropagateMatch(const std::vector<int>& atom_ids,
@@ -102,10 +102,10 @@ class PrefilterTree {
 
   // A string that uniquely identifies the node. Assumes that the
   // children of node has already been assigned unique ids.
-  string NodeString(Prefilter* node) const;
+  std::string NodeString(Prefilter* node) const;
 
   // Recursively constructs a readable prefilter string.
-  string DebugNodeString(Prefilter* node) const;
+  std::string DebugNodeString(Prefilter* node) const;
 
   // Used for debugging.
   void PrintDebugInfo(NodeMap* nodes);
diff --git a/re2/prog.cc b/re2/prog.cc
index fa03af9..6cadcfa 100644
--- a/re2/prog.cc
+++ b/re2/prog.cc
@@ -7,17 +7,22 @@
 
 #include "re2/prog.h"
 
+#if defined(__AVX2__)
+#include <immintrin.h>
+#ifdef _MSC_VER
+#include <intrin.h>
+#endif
+#endif
 #include <stdint.h>
 #include <string.h>
 #include <algorithm>
 #include <memory>
 #include <utility>
 
-#include "util/util.h"
+#include "absl/base/macros.h"
+#include "absl/strings/str_format.h"
 #include "util/logging.h"
-#include "util/strutil.h"
 #include "re2/bitmap256.h"
-#include "re2/stringpiece.h"
 
 namespace re2 {
 
@@ -34,7 +39,7 @@ void Prog::Inst::InitByteRange(int lo, int hi, int foldcase, uint32_t out) {
   set_out_opcode(out, kInstByteRange);
   lo_ = lo & 0xFF;
   hi_ = hi & 0xFF;
-  foldcase_ = foldcase & 0xFF;
+  hint_foldcase_ = foldcase&1;
 }
 
 void Prog::Inst::InitCapture(int cap, uint32_t out) {
@@ -65,37 +70,37 @@ void Prog::Inst::InitFail() {
   set_opcode(kInstFail);
 }
 
-string Prog::Inst::Dump() {
+std::string Prog::Inst::Dump() {
   switch (opcode()) {
     default:
-      return StringPrintf("opcode %d", static_cast<int>(opcode()));
+      return absl::StrFormat("opcode %d", static_cast<int>(opcode()));
 
     case kInstAlt:
-      return StringPrintf("alt -> %d | %d", out(), out1_);
+      return absl::StrFormat("alt -> %d | %d", out(), out1_);
 
     case kInstAltMatch:
-      return StringPrintf("altmatch -> %d | %d", out(), out1_);
+      return absl::StrFormat("altmatch -> %d | %d", out(), out1_);
 
     case kInstByteRange:
-      return StringPrintf("byte%s [%02x-%02x] -> %d",
-                          foldcase_ ? "/i" : "",
-                          lo_, hi_, out());
+      return absl::StrFormat("byte%s [%02x-%02x] %d -> %d",
+                             foldcase() ? "/i" : "",
+                             lo_, hi_, hint(), out());
 
     case kInstCapture:
-      return StringPrintf("capture %d -> %d", cap_, out());
+      return absl::StrFormat("capture %d -> %d", cap_, out());
 
     case kInstEmptyWidth:
-      return StringPrintf("emptywidth %#x -> %d",
-                          static_cast<int>(empty_), out());
+      return absl::StrFormat("emptywidth %#x -> %d",
+                             static_cast<int>(empty_), out());
 
     case kInstMatch:
-      return StringPrintf("match! %d", match_id());
+      return absl::StrFormat("match! %d", match_id());
 
     case kInstNop:
-      return StringPrintf("nop -> %d", out());
+      return absl::StrFormat("nop -> %d", out());
 
     case kInstFail:
-      return StringPrintf("fail");
+      return absl::StrFormat("fail");
   }
 }
 
@@ -109,10 +114,10 @@ Prog::Prog()
     start_unanchored_(0),
     size_(0),
     bytemap_range_(0),
-    first_byte_(-1),
-    flags_(0),
+    prefix_foldcase_(false),
+    prefix_size_(0),
     list_count_(0),
-    onepass_nodes_(NULL),
+    bit_state_text_max_size_(0),
     dfa_mem_(0),
     dfa_first_(NULL),
     dfa_longest_(NULL) {
@@ -121,7 +126,8 @@ Prog::Prog()
 Prog::~Prog() {
   DeleteDFA(dfa_longest_);
   DeleteDFA(dfa_first_);
-  delete[] onepass_nodes_;
+  if (prefix_foldcase_)
+    delete[] prefix_dfa_;
 }
 
 typedef SparseSet Workq;
@@ -131,12 +137,12 @@ static inline void AddToQueue(Workq* q, int id) {
     q->insert(id);
 }
 
-static string ProgToString(Prog* prog, Workq* q) {
-  string s;
+static std::string ProgToString(Prog* prog, Workq* q) {
+  std::string s;
   for (Workq::iterator i = q->begin(); i != q->end(); ++i) {
     int id = *i;
     Prog::Inst* ip = prog->inst(id);
-    StringAppendF(&s, "%d. %s\n", id, ip->Dump().c_str());
+    s += absl::StrFormat("%d. %s\n", id, ip->Dump());
     AddToQueue(q, ip->out());
     if (ip->opcode() == kInstAlt || ip->opcode() == kInstAltMatch)
       AddToQueue(q, ip->out1());
@@ -144,19 +150,19 @@ static string ProgToString(Prog* prog, Workq* q) {
   return s;
 }
 
-static string FlattenedProgToString(Prog* prog, int start) {
-  string s;
+static std::string FlattenedProgToString(Prog* prog, int start) {
+  std::string s;
   for (int id = start; id < prog->size(); id++) {
     Prog::Inst* ip = prog->inst(id);
     if (ip->last())
-      StringAppendF(&s, "%d. %s\n", id, ip->Dump().c_str());
+      s += absl::StrFormat("%d. %s\n", id, ip->Dump());
     else
-      StringAppendF(&s, "%d+ %s\n", id, ip->Dump().c_str());
+      s += absl::StrFormat("%d+ %s\n", id, ip->Dump());
   }
   return s;
 }
 
-string Prog::Dump() {
+std::string Prog::Dump() {
   if (did_flatten_)
     return FlattenedProgToString(this, start_);
 
@@ -165,7 +171,7 @@ string Prog::Dump() {
   return ProgToString(this, &q);
 }
 
-string Prog::DumpUnanchored() {
+std::string Prog::DumpUnanchored() {
   if (did_flatten_)
     return FlattenedProgToString(this, start_unanchored_);
 
@@ -174,27 +180,44 @@ string Prog::DumpUnanchored() {
   return ProgToString(this, &q);
 }
 
-string Prog::DumpByteMap() {
-  string map;
+std::string Prog::DumpByteMap() {
+  std::string map;
   for (int c = 0; c < 256; c++) {
     int b = bytemap_[c];
     int lo = c;
     while (c < 256-1 && bytemap_[c+1] == b)
       c++;
     int hi = c;
-    StringAppendF(&map, "[%02x-%02x] -> %d\n", lo, hi, b);
+    map += absl::StrFormat("[%02x-%02x] -> %d\n", lo, hi, b);
   }
   return map;
 }
 
-int Prog::first_byte() {
-  std::call_once(first_byte_once_, [](Prog* prog) {
-    prog->first_byte_ = prog->ComputeFirstByte();
-  }, this);
-  return first_byte_;
-}
+// Is ip a guaranteed match at end of text, perhaps after some capturing?
+static bool IsMatch(Prog* prog, Prog::Inst* ip) {
+  for (;;) {
+    switch (ip->opcode()) {
+      default:
+        LOG(DFATAL) << "Unexpected opcode in IsMatch: " << ip->opcode();
+        return false;
 
-static bool IsMatch(Prog*, Prog::Inst*);
+      case kInstAlt:
+      case kInstAltMatch:
+      case kInstByteRange:
+      case kInstFail:
+      case kInstEmptyWidth:
+        return false;
+
+      case kInstCapture:
+      case kInstNop:
+        ip = prog->inst(ip->out());
+        break;
+
+      case kInstMatch:
+        return true;
+    }
+  }
+}
 
 // Peep-hole optimizer.
 void Prog::Optimize() {
@@ -260,54 +283,28 @@ void Prog::Optimize() {
   }
 }
 
-// Is ip a guaranteed match at end of text, perhaps after some capturing?
-static bool IsMatch(Prog* prog, Prog::Inst* ip) {
-  for (;;) {
-    switch (ip->opcode()) {
-      default:
-        LOG(DFATAL) << "Unexpected opcode in IsMatch: " << ip->opcode();
-        return false;
-
-      case kInstAlt:
-      case kInstAltMatch:
-      case kInstByteRange:
-      case kInstFail:
-      case kInstEmptyWidth:
-        return false;
-
-      case kInstCapture:
-      case kInstNop:
-        ip = prog->inst(ip->out());
-        break;
-
-      case kInstMatch:
-        return true;
-    }
-  }
-}
-
-uint32_t Prog::EmptyFlags(const StringPiece& text, const char* p) {
+uint32_t Prog::EmptyFlags(absl::string_view text, const char* p) {
   int flags = 0;
 
   // ^ and \A
-  if (p == text.begin())
+  if (p == text.data())
     flags |= kEmptyBeginText | kEmptyBeginLine;
   else if (p[-1] == '\n')
     flags |= kEmptyBeginLine;
 
   // $ and \z
-  if (p == text.end())
+  if (p == text.data() + text.size())
     flags |= kEmptyEndText | kEmptyEndLine;
-  else if (p < text.end() && p[0] == '\n')
+  else if (p < text.data() + text.size() && p[0] == '\n')
     flags |= kEmptyEndLine;
 
   // \b and \B
-  if (p == text.begin() && p == text.end()) {
+  if (p == text.data() && p == text.data() + text.size()) {
     // no word boundary here
-  } else if (p == text.begin()) {
+  } else if (p == text.data()) {
     if (IsWordChar(p[0]))
       flags |= kEmptyWordBoundary;
-  } else if (p == text.end()) {
+  } else if (p == text.data() + text.size()) {
     if (IsWordChar(p[-1]))
       flags |= kEmptyWordBoundary;
   } else {
@@ -343,7 +340,6 @@ class ByteMapBuilder {
     // This will avoid problems during the second phase,
     // in which we assign byte classes numbered from 0.
     splits_.Set(255);
-    colors_.resize(256);
     colors_[255] = 256;
     nextcolor_ = 257;
   }
@@ -356,7 +352,7 @@ class ByteMapBuilder {
   int Recolor(int oldcolor);
 
   Bitmap256 splits_;
-  std::vector<int> colors_;
+  int colors_[256];
   int nextcolor_;
   std::vector<std::pair<int, int>> colormap_;
   std::vector<std::pair<int, int>> ranges_;
@@ -470,8 +466,11 @@ void Prog::ComputeByteMap() {
           foldlo = 'a';
         if (foldhi > 'z')
           foldhi = 'z';
-        if (foldlo <= foldhi)
-          builder.Mark(foldlo + 'A' - 'a', foldhi + 'A' - 'a');
+        if (foldlo <= foldhi) {
+          foldlo += 'A' - 'a';
+          foldhi += 'A' - 'a';
+          builder.Mark(foldlo, foldhi);
+        }
       }
       // If this Inst is not the last Inst in its list AND the next Inst is
       // also a ByteRange AND the Insts have the same out, defer the merge.
@@ -511,7 +510,7 @@ void Prog::ComputeByteMap() {
 
   builder.Build(bytemap_, &bytemap_range_);
 
-  if (0) {  // For debugging, use trivial bytemap.
+  if ((0)) {  // For debugging, use trivial bytemap.
     LOG(ERROR) << "Using trivial bytemap.";
     for (int i = 0; i < 256; i++)
       bytemap_[i] = static_cast<uint8_t>(i);
@@ -593,6 +592,9 @@ void Prog::Flatten() {
     flatmap[i->value()] = static_cast<int>(flat.size());
     EmitList(i->index(), &rootmap, &flat, &reachable, &stk);
     flat.back().set_last();
+    // We have the bounds of the "list", so this is the
+    // most convenient point at which to compute hints.
+    ComputeHints(&flat, flatmap[i->value()], static_cast<int>(flat.size()));
   }
 
   list_count_ = static_cast<int>(flatmap.size());
@@ -608,10 +610,13 @@ void Prog::Flatten() {
     inst_count_[ip->opcode()]++;
   }
 
-  int total = 0;
+#if !defined(NDEBUG)
+  // Address a `-Wunused-but-set-variable' warning from Clang 13.x.
+  size_t total = 0;
   for (int i = 0; i < kNumInst; i++)
     total += inst_count_[i];
-  DCHECK_EQ(total, static_cast<int>(flat.size()));
+  CHECK_EQ(total, flat.size());
+#endif
 
   // Remap start_unanchored and start.
   if (start_unanchored() == 0) {
@@ -627,7 +632,22 @@ void Prog::Flatten() {
   // Finally, replace the old instructions with the new instructions.
   size_ = static_cast<int>(flat.size());
   inst_ = PODArray<Inst>(size_);
-  memmove(inst_.data(), flat.data(), size_*sizeof(inst_[0]));
+  memmove(inst_.data(), flat.data(), size_*sizeof inst_[0]);
+
+  // Populate the list heads for BitState.
+  // 512 instructions limits the memory footprint to 1KiB.
+  if (size_ <= 512) {
+    list_heads_ = PODArray<uint16_t>(size_);
+    // 0xFF makes it more obvious if we try to look up a non-head.
+    memset(list_heads_.data(), 0xFF, size_*sizeof list_heads_[0]);
+    for (int i = 0; i < list_count_; ++i)
+      list_heads_[flatmap[i]] = i;
+  }
+
+  // BitState allocates a bitmap of size list_count_ * (text.size()+1)
+  // for tracking pairs of possibilities that it has already explored.
+  const size_t kBitStateBitmapMaxSize = 256*1024;  // max size in bits
+  bit_state_text_max_size_ = kBitStateBitmapMaxSize / list_count_ - 1;
 }
 
 void Prog::MarkSuccessors(SparseArray<int>* rootmap,
@@ -792,7 +812,7 @@ void Prog::EmitList(int root, SparseArray<int>* rootmap,
         flat->back().set_opcode(kInstAltMatch);
         flat->back().set_out(static_cast<int>(flat->size()));
         flat->back().out1_ = static_cast<uint32_t>(flat->size())+1;
-        FALLTHROUGH_INTENDED;
+        ABSL_FALLTHROUGH_INTENDED;
 
       case kInstAlt:
         stk->push_back(ip->out1());
@@ -820,4 +840,335 @@ void Prog::EmitList(int root, SparseArray<int>* rootmap,
   }
 }
 
+// For each ByteRange instruction in [begin, end), computes a hint to execution
+// engines: the delta to the next instruction (in flat) worth exploring iff the
+// current instruction matched.
+//
+// Implements a coloring algorithm related to ByteMapBuilder, but in this case,
+// colors are instructions and recoloring ranges precisely identifies conflicts
+// between instructions. Iterating backwards over [begin, end) is guaranteed to
+// identify the nearest conflict (if any) with only linear complexity.
+void Prog::ComputeHints(std::vector<Inst>* flat, int begin, int end) {
+  Bitmap256 splits;
+  int colors[256];
+
+  bool dirty = false;
+  for (int id = end; id >= begin; --id) {
+    if (id == end ||
+        (*flat)[id].opcode() != kInstByteRange) {
+      if (dirty) {
+        dirty = false;
+        splits.Clear();
+      }
+      splits.Set(255);
+      colors[255] = id;
+      // At this point, the [0-255] range is colored with id.
+      // Thus, hints cannot point beyond id; and if id == end,
+      // hints that would have pointed to id will be 0 instead.
+      continue;
+    }
+    dirty = true;
+
+    // We recolor the [lo-hi] range with id. Note that first ratchets backwards
+    // from end to the nearest conflict (if any) during recoloring.
+    int first = end;
+    auto Recolor = [&](int lo, int hi) {
+      // Like ByteMapBuilder, we split at lo-1 and at hi.
+      --lo;
+
+      if (0 <= lo && !splits.Test(lo)) {
+        splits.Set(lo);
+        int next = splits.FindNextSetBit(lo+1);
+        colors[lo] = colors[next];
+      }
+      if (!splits.Test(hi)) {
+        splits.Set(hi);
+        int next = splits.FindNextSetBit(hi+1);
+        colors[hi] = colors[next];
+      }
+
+      int c = lo+1;
+      while (c < 256) {
+        int next = splits.FindNextSetBit(c);
+        // Ratchet backwards...
+        first = std::min(first, colors[next]);
+        // Recolor with id - because it's the new nearest conflict!
+        colors[next] = id;
+        if (next == hi)
+          break;
+        c = next+1;
+      }
+    };
+
+    Inst* ip = &(*flat)[id];
+    int lo = ip->lo();
+    int hi = ip->hi();
+    Recolor(lo, hi);
+    if (ip->foldcase() && lo <= 'z' && hi >= 'a') {
+      int foldlo = lo;
+      int foldhi = hi;
+      if (foldlo < 'a')
+        foldlo = 'a';
+      if (foldhi > 'z')
+        foldhi = 'z';
+      if (foldlo <= foldhi) {
+        foldlo += 'A' - 'a';
+        foldhi += 'A' - 'a';
+        Recolor(foldlo, foldhi);
+      }
+    }
+
+    if (first != end) {
+      uint16_t hint = static_cast<uint16_t>(std::min(first - id, 32767));
+      ip->hint_foldcase_ |= hint<<1;
+    }
+  }
+}
+
+// The final state will always be this, which frees up a register for the hot
+// loop and thus avoids the spilling that can occur when building with Clang.
+static const size_t kShiftDFAFinal = 9;
+
+// This function takes the prefix as std::string (i.e. not const std::string&
+// as normal) because it's going to clobber it, so a temporary is convenient.
+static uint64_t* BuildShiftDFA(std::string prefix) {
+  // This constant is for convenience now and also for correctness later when
+  // we clobber the prefix, but still need to know how long it was initially.
+  const size_t size = prefix.size();
+
+  // Construct the NFA.
+  // The table is indexed by input byte; each element is a bitfield of states
+  // reachable by the input byte. Given a bitfield of the current states, the
+  // bitfield of states reachable from those is - for this specific purpose -
+  // always ((ncurr << 1) | 1). Intersecting the reachability bitfields gives
+  // the bitfield of the next states reached by stepping over the input byte.
+  // Credits for this technique: the Hyperscan paper by Geoff Langdale et al.
+  uint16_t nfa[256]{};
+  for (size_t i = 0; i < size; ++i) {
+    uint8_t b = prefix[i];
+    nfa[b] |= 1 << (i+1);
+  }
+  // This is the `\C*?` for unanchored search.
+  for (int b = 0; b < 256; ++b)
+    nfa[b] |= 1;
+
+  // This maps from DFA state to NFA states; the reverse mapping is used when
+  // recording transitions and gets implemented with plain old linear search.
+  // The "Shift DFA" technique limits this to ten states when using uint64_t;
+  // to allow for the initial state, we use at most nine bytes of the prefix.
+  // That same limit is also why uint16_t is sufficient for the NFA bitfield.
+  uint16_t states[kShiftDFAFinal+1]{};
+  states[0] = 1;
+  for (size_t dcurr = 0; dcurr < size; ++dcurr) {
+    uint8_t b = prefix[dcurr];
+    uint16_t ncurr = states[dcurr];
+    uint16_t nnext = nfa[b] & ((ncurr << 1) | 1);
+    size_t dnext = dcurr+1;
+    if (dnext == size)
+      dnext = kShiftDFAFinal;
+    states[dnext] = nnext;
+  }
+
+  // Sort and unique the bytes of the prefix to avoid repeating work while we
+  // record transitions. This clobbers the prefix, but it's no longer needed.
+  std::sort(prefix.begin(), prefix.end());
+  prefix.erase(std::unique(prefix.begin(), prefix.end()), prefix.end());
+
+  // Construct the DFA.
+  // The table is indexed by input byte; each element is effectively a packed
+  // array of uint6_t; each array value will be multiplied by six in order to
+  // avoid having to do so later in the hot loop as well as masking/shifting.
+  // Credits for this technique: "Shift-based DFAs" on GitHub by Per Vognsen.
+  uint64_t* dfa = new uint64_t[256]{};
+  // Record a transition from each state for each of the bytes of the prefix.
+  // Note that all other input bytes go back to the initial state by default.
+  for (size_t dcurr = 0; dcurr < size; ++dcurr) {
+    for (uint8_t b : prefix) {
+      uint16_t ncurr = states[dcurr];
+      uint16_t nnext = nfa[b] & ((ncurr << 1) | 1);
+      size_t dnext = 0;
+      while (states[dnext] != nnext)
+        ++dnext;
+      dfa[b] |= static_cast<uint64_t>(dnext * 6) << (dcurr * 6);
+      // Convert ASCII letters to uppercase and record the extra transitions.
+      // Note that ASCII letters are guaranteed to be lowercase at this point
+      // because that's how the parser normalises them. #FunFact: 'k' and 's'
+      // match U+212A and U+017F, respectively, so they won't occur here when
+      // using UTF-8 encoding because the parser will emit character classes.
+      if ('a' <= b && b <= 'z') {
+        b -= 'a' - 'A';
+        dfa[b] |= static_cast<uint64_t>(dnext * 6) << (dcurr * 6);
+      }
+    }
+  }
+  // This lets the final state "saturate", which will matter for performance:
+  // in the hot loop, we check for a match only at the end of each iteration,
+  // so we must keep signalling the match until we get around to checking it.
+  for (int b = 0; b < 256; ++b)
+    dfa[b] |= static_cast<uint64_t>(kShiftDFAFinal * 6) << (kShiftDFAFinal * 6);
+
+  return dfa;
+}
+
+void Prog::ConfigurePrefixAccel(const std::string& prefix,
+                                bool prefix_foldcase) {
+  prefix_foldcase_ = prefix_foldcase;
+  prefix_size_ = prefix.size();
+  if (prefix_foldcase_) {
+    // Use PrefixAccel_ShiftDFA().
+    // ... and no more than nine bytes of the prefix. (See above for details.)
+    prefix_size_ = std::min(prefix_size_, kShiftDFAFinal);
+    prefix_dfa_ = BuildShiftDFA(prefix.substr(0, prefix_size_));
+  } else if (prefix_size_ != 1) {
+    // Use PrefixAccel_FrontAndBack().
+    prefix_front_ = prefix.front();
+    prefix_back_ = prefix.back();
+  } else {
+    // Use memchr(3).
+    prefix_front_ = prefix.front();
+  }
+}
+
+const void* Prog::PrefixAccel_ShiftDFA(const void* data, size_t size) {
+  if (size < prefix_size_)
+    return NULL;
+
+  uint64_t curr = 0;
+
+  // At the time of writing, rough benchmarks on a Broadwell machine showed
+  // that this unroll factor (i.e. eight) achieves a speedup factor of two.
+  if (size >= 8) {
+    const uint8_t* p = reinterpret_cast<const uint8_t*>(data);
+    const uint8_t* endp = p + (size&~7);
+    do {
+      uint8_t b0 = p[0];
+      uint8_t b1 = p[1];
+      uint8_t b2 = p[2];
+      uint8_t b3 = p[3];
+      uint8_t b4 = p[4];
+      uint8_t b5 = p[5];
+      uint8_t b6 = p[6];
+      uint8_t b7 = p[7];
+
+      uint64_t next0 = prefix_dfa_[b0];
+      uint64_t next1 = prefix_dfa_[b1];
+      uint64_t next2 = prefix_dfa_[b2];
+      uint64_t next3 = prefix_dfa_[b3];
+      uint64_t next4 = prefix_dfa_[b4];
+      uint64_t next5 = prefix_dfa_[b5];
+      uint64_t next6 = prefix_dfa_[b6];
+      uint64_t next7 = prefix_dfa_[b7];
+
+      uint64_t curr0 = next0 >> (curr  & 63);
+      uint64_t curr1 = next1 >> (curr0 & 63);
+      uint64_t curr2 = next2 >> (curr1 & 63);
+      uint64_t curr3 = next3 >> (curr2 & 63);
+      uint64_t curr4 = next4 >> (curr3 & 63);
+      uint64_t curr5 = next5 >> (curr4 & 63);
+      uint64_t curr6 = next6 >> (curr5 & 63);
+      uint64_t curr7 = next7 >> (curr6 & 63);
+
+      if ((curr7 & 63) == kShiftDFAFinal * 6) {
+        // At the time of writing, using the same masking subexpressions from
+        // the preceding lines caused Clang to clutter the hot loop computing
+        // them - even though they aren't actually needed for shifting! Hence
+        // these rewritten conditions, which achieve a speedup factor of two.
+        if (((curr7-curr0) & 63) == 0) return p+1-prefix_size_;
+        if (((curr7-curr1) & 63) == 0) return p+2-prefix_size_;
+        if (((curr7-curr2) & 63) == 0) return p+3-prefix_size_;
+        if (((curr7-curr3) & 63) == 0) return p+4-prefix_size_;
+        if (((curr7-curr4) & 63) == 0) return p+5-prefix_size_;
+        if (((curr7-curr5) & 63) == 0) return p+6-prefix_size_;
+        if (((curr7-curr6) & 63) == 0) return p+7-prefix_size_;
+        if (((curr7-curr7) & 63) == 0) return p+8-prefix_size_;
+      }
+
+      curr = curr7;
+      p += 8;
+    } while (p != endp);
+    data = p;
+    size = size&7;
+  }
+
+  const uint8_t* p = reinterpret_cast<const uint8_t*>(data);
+  const uint8_t* endp = p + size;
+  while (p != endp) {
+    uint8_t b = *p++;
+    uint64_t next = prefix_dfa_[b];
+    curr = next >> (curr & 63);
+    if ((curr & 63) == kShiftDFAFinal * 6)
+      return p-prefix_size_;
+  }
+  return NULL;
+}
+
+#if defined(__AVX2__)
+// Finds the least significant non-zero bit in n.
+static int FindLSBSet(uint32_t n) {
+  DCHECK_NE(n, 0);
+#if defined(__GNUC__)
+  return __builtin_ctz(n);
+#elif defined(_MSC_VER) && (defined(_M_X64) || defined(_M_IX86))
+  unsigned long c;
+  _BitScanForward(&c, n);
+  return static_cast<int>(c);
+#else
+  int c = 31;
+  for (int shift = 1 << 4; shift != 0; shift >>= 1) {
+    uint32_t word = n << shift;
+    if (word != 0) {
+      n = word;
+      c -= shift;
+    }
+  }
+  return c;
+#endif
+}
+#endif
+
+const void* Prog::PrefixAccel_FrontAndBack(const void* data, size_t size) {
+  DCHECK_GE(prefix_size_, 2);
+  if (size < prefix_size_)
+    return NULL;
+  // Don't bother searching the last prefix_size_-1 bytes for prefix_front_.
+  // This also means that probing for prefix_back_ doesn't go out of bounds.
+  size -= prefix_size_-1;
+
+#if defined(__AVX2__)
+  // Use AVX2 to look for prefix_front_ and prefix_back_ 32 bytes at a time.
+  if (size >= sizeof(__m256i)) {
+    const __m256i* fp = reinterpret_cast<const __m256i*>(
+        reinterpret_cast<const char*>(data));
+    const __m256i* bp = reinterpret_cast<const __m256i*>(
+        reinterpret_cast<const char*>(data) + prefix_size_-1);
+    const __m256i* endfp = fp + size/sizeof(__m256i);
+    const __m256i f_set1 = _mm256_set1_epi8(prefix_front_);
+    const __m256i b_set1 = _mm256_set1_epi8(prefix_back_);
+    do {
+      const __m256i f_loadu = _mm256_loadu_si256(fp++);
+      const __m256i b_loadu = _mm256_loadu_si256(bp++);
+      const __m256i f_cmpeq = _mm256_cmpeq_epi8(f_set1, f_loadu);
+      const __m256i b_cmpeq = _mm256_cmpeq_epi8(b_set1, b_loadu);
+      const int fb_testz = _mm256_testz_si256(f_cmpeq, b_cmpeq);
+      if (fb_testz == 0) {  // ZF: 1 means zero, 0 means non-zero.
+        const __m256i fb_and = _mm256_and_si256(f_cmpeq, b_cmpeq);
+        const int fb_movemask = _mm256_movemask_epi8(fb_and);
+        const int fb_ctz = FindLSBSet(fb_movemask);
+        return reinterpret_cast<const char*>(fp-1) + fb_ctz;
+      }
+    } while (fp != endfp);
+    data = fp;
+    size = size%sizeof(__m256i);
+  }
+#endif
+
+  const char* p0 = reinterpret_cast<const char*>(data);
+  for (const char* p = p0;; p++) {
+    DCHECK_GE(size, static_cast<size_t>(p-p0));
+    p = reinterpret_cast<const char*>(memchr(p, prefix_front_, size - (p-p0)));
+    if (p == NULL || p[prefix_size_-1] == prefix_back_)
+      return p;
+  }
+}
+
 }  // namespace re2
diff --git a/re2/prog.h b/re2/prog.h
index 268ab9d..41923f3 100644
--- a/re2/prog.h
+++ b/re2/prog.h
@@ -11,17 +11,17 @@
 
 #include <stdint.h>
 #include <functional>
-#include <mutex>
 #include <string>
 #include <vector>
 #include <type_traits>
 
-#include "util/util.h"
+#include "absl/base/call_once.h"
+#include "absl/strings/string_view.h"
 #include "util/logging.h"
-#include "util/pod_array.h"
-#include "util/sparse_array.h"
-#include "util/sparse_set.h"
+#include "re2/pod_array.h"
 #include "re2/re2.h"
+#include "re2/sparse_array.h"
+#include "re2/sparse_set.h"
 
 namespace re2 {
 
@@ -86,7 +86,8 @@ class Prog {
     int cap()       { DCHECK_EQ(opcode(), kInstCapture); return cap_; }
     int lo()        { DCHECK_EQ(opcode(), kInstByteRange); return lo_; }
     int hi()        { DCHECK_EQ(opcode(), kInstByteRange); return hi_; }
-    int foldcase()  { DCHECK_EQ(opcode(), kInstByteRange); return foldcase_; }
+    int foldcase()  { DCHECK_EQ(opcode(), kInstByteRange); return hint_foldcase_&1; }
+    int hint()      { DCHECK_EQ(opcode(), kInstByteRange); return hint_foldcase_>>1; }
     int match_id()  { DCHECK_EQ(opcode(), kInstMatch); return match_id_; }
     EmptyOp empty() { DCHECK_EQ(opcode(), kInstEmptyWidth); return empty_; }
 
@@ -100,13 +101,13 @@ class Prog {
     // Does this inst (an kInstByteRange) match c?
     inline bool Matches(int c) {
       DCHECK_EQ(opcode(), kInstByteRange);
-      if (foldcase_ && 'A' <= c && c <= 'Z')
+      if (foldcase() && 'A' <= c && c <= 'Z')
         c += 'a' - 'A';
       return lo_ <= c && c <= hi_;
     }
 
     // Returns string representation for debugging.
-    string Dump();
+    std::string Dump();
 
     // Maximum instruction id.
     // (Must fit in out_opcode_. PatchList/last steal another bit.)
@@ -129,25 +130,31 @@ class Prog {
       out_opcode_ = (out<<4) | (last()<<3) | opcode;
     }
 
-    uint32_t out_opcode_;   // 28 bits: out, 1 bit: last, 3 (low) bits: opcode
-    union {                 // additional instruction arguments:
-      uint32_t out1_;       // opcode == kInstAlt
-                            //   alternate next instruction
-
-      int32_t cap_;         // opcode == kInstCapture
-                            //   Index of capture register (holds text
-                            //   position recorded by capturing parentheses).
-                            //   For \n (the submatch for the nth parentheses),
-                            //   the left parenthesis captures into register 2*n
-                            //   and the right one captures into register 2*n+1.
-
-      int32_t match_id_;    // opcode == kInstMatch
-                            //   Match ID to identify this match (for re2::Set).
-
-      struct {              // opcode == kInstByteRange
-        uint8_t lo_;        //   byte range is lo_-hi_ inclusive
-        uint8_t hi_;        //
-        uint8_t foldcase_;  //   convert A-Z to a-z before checking range.
+    uint32_t out_opcode_;  // 28 bits: out, 1 bit: last, 3 (low) bits: opcode
+    union {                // additional instruction arguments:
+      uint32_t out1_;      // opcode == kInstAlt
+                           //   alternate next instruction
+
+      int32_t cap_;        // opcode == kInstCapture
+                           //   Index of capture register (holds text
+                           //   position recorded by capturing parentheses).
+                           //   For \n (the submatch for the nth parentheses),
+                           //   the left parenthesis captures into register 2*n
+                           //   and the right one captures into register 2*n+1.
+
+      int32_t match_id_;   // opcode == kInstMatch
+                           //   Match ID to identify this match (for re2::Set).
+
+      struct {             // opcode == kInstByteRange
+        uint8_t lo_;       //   byte range is lo_-hi_ inclusive
+        uint8_t hi_;       //
+        uint16_t hint_foldcase_;  // 15 bits: hint, 1 (low) bit: foldcase
+                           //   hint to execution engines: the delta to the
+                           //   next instruction (in the current list) worth
+                           //   exploring iff this instruction matched; 0
+                           //   means there are no remaining possibilities,
+                           //   which is most likely for character classes.
+                           //   foldcase: A-Z -> a-z before checking range.
       };
 
       EmptyOp empty_;       // opcode == kInstEmptyWidth
@@ -191,36 +198,58 @@ class Prog {
 
   Inst *inst(int id) { return &inst_[id]; }
   int start() { return start_; }
-  int start_unanchored() { return start_unanchored_; }
   void set_start(int start) { start_ = start; }
+  int start_unanchored() { return start_unanchored_; }
   void set_start_unanchored(int start) { start_unanchored_ = start; }
   int size() { return size_; }
   bool reversed() { return reversed_; }
   void set_reversed(bool reversed) { reversed_ = reversed; }
   int list_count() { return list_count_; }
   int inst_count(InstOp op) { return inst_count_[op]; }
-  void set_dfa_mem(int64_t dfa_mem) { dfa_mem_ = dfa_mem; }
+  uint16_t* list_heads() { return list_heads_.data(); }
+  size_t bit_state_text_max_size() { return bit_state_text_max_size_; }
   int64_t dfa_mem() { return dfa_mem_; }
-  int flags() { return flags_; }
-  void set_flags(int flags) { flags_ = flags; }
+  void set_dfa_mem(int64_t dfa_mem) { dfa_mem_ = dfa_mem; }
   bool anchor_start() { return anchor_start_; }
   void set_anchor_start(bool b) { anchor_start_ = b; }
   bool anchor_end() { return anchor_end_; }
   void set_anchor_end(bool b) { anchor_end_ = b; }
   int bytemap_range() { return bytemap_range_; }
   const uint8_t* bytemap() { return bytemap_; }
+  bool can_prefix_accel() { return prefix_size_ != 0; }
+
+  // Accelerates to the first likely occurrence of the prefix.
+  // Returns a pointer to the first byte or NULL if not found.
+  const void* PrefixAccel(const void* data, size_t size) {
+    DCHECK(can_prefix_accel());
+    if (prefix_foldcase_) {
+      return PrefixAccel_ShiftDFA(data, size);
+    } else if (prefix_size_ != 1) {
+      return PrefixAccel_FrontAndBack(data, size);
+    } else {
+      return memchr(data, prefix_front_, size);
+    }
+  }
+
+  // Configures prefix accel using the analysis performed during compilation.
+  void ConfigurePrefixAccel(const std::string& prefix, bool prefix_foldcase);
+
+  // An implementation of prefix accel that uses prefix_dfa_ to perform
+  // case-insensitive search.
+  const void* PrefixAccel_ShiftDFA(const void* data, size_t size);
 
-  // Lazily computed.
-  int first_byte();
+  // An implementation of prefix accel that looks for prefix_front_ and
+  // prefix_back_ to return fewer false positives than memchr(3) alone.
+  const void* PrefixAccel_FrontAndBack(const void* data, size_t size);
 
   // Returns string representation of program for debugging.
-  string Dump();
-  string DumpUnanchored();
-  string DumpByteMap();
+  std::string Dump();
+  std::string DumpUnanchored();
+  std::string DumpByteMap();
 
   // Returns the set of kEmpty flags that are in effect at
   // position p within context.
-  static uint32_t EmptyFlags(const StringPiece& context, const char* p);
+  static uint32_t EmptyFlags(absl::string_view context, const char* p);
 
   // Returns whether byte c is a word character: ASCII only.
   // Used by the implementation of \b and \B.
@@ -245,15 +274,15 @@ class Prog {
   // If a particular submatch is not matched during the regexp match,
   // it is set to NULL.
   //
-  // Matching text == StringPiece(NULL, 0) is treated as any other empty
+  // Matching text == absl::string_view() is treated as any other empty
   // string, but note that on return, it will not be possible to distinguish
   // submatches that matched that empty string from submatches that didn't
   // match anything.  Either way, match[i] == NULL.
 
   // Search using NFA: can find submatches but kind of slow.
-  bool SearchNFA(const StringPiece& text, const StringPiece& context,
-                 Anchor anchor, MatchKind kind,
-                 StringPiece* match, int nmatch);
+  bool SearchNFA(absl::string_view text, absl::string_view context,
+                 Anchor anchor, MatchKind kind, absl::string_view* match,
+                 int nmatch);
 
   // Search using DFA: much faster than NFA but only finds
   // end of match and can use a lot more memory.
@@ -261,8 +290,8 @@ class Prog {
   // If the DFA runs out of memory, sets *failed to true and returns false.
   // If matches != NULL and kind == kManyMatch and there is a match,
   // SearchDFA fills matches with the match IDs of the final matching state.
-  bool SearchDFA(const StringPiece& text, const StringPiece& context,
-                 Anchor anchor, MatchKind kind, StringPiece* match0,
+  bool SearchDFA(absl::string_view text, absl::string_view context,
+                 Anchor anchor, MatchKind kind, absl::string_view* match0,
                  bool* failed, SparseSet* matches);
 
   // The callback issued after building each DFA state with BuildEntireDFA().
@@ -282,17 +311,9 @@ class Prog {
   // FOR TESTING OR EXPERIMENTAL PURPOSES ONLY.
   int BuildEntireDFA(MatchKind kind, const DFAStateCallback& cb);
 
-  // Controls whether the DFA should bail out early if the NFA would be faster.
-  // FOR TESTING ONLY.
-  static void TEST_dfa_should_bail_when_slow(bool b);
-
   // Compute bytemap.
   void ComputeByteMap();
 
-  // Computes whether all matches must begin with the same first
-  // byte, and if so, returns that byte.  If not, returns -1.
-  int ComputeFirstByte();
-
   // Run peep-hole optimizer on program.
   void Optimize();
 
@@ -300,15 +321,16 @@ class Prog {
   // but much faster than NFA (competitive with PCRE)
   // for those expressions.
   bool IsOnePass();
-  bool SearchOnePass(const StringPiece& text, const StringPiece& context,
-                     Anchor anchor, MatchKind kind,
-                     StringPiece* match, int nmatch);
+  bool SearchOnePass(absl::string_view text, absl::string_view context,
+                     Anchor anchor, MatchKind kind, absl::string_view* match,
+                     int nmatch);
 
   // Bit-state backtracking.  Fast on small cases but uses memory
-  // proportional to the product of the program size and the text size.
-  bool SearchBitState(const StringPiece& text, const StringPiece& context,
-                      Anchor anchor, MatchKind kind,
-                      StringPiece* match, int nmatch);
+  // proportional to the product of the list count and the text size.
+  bool CanBitState() { return list_heads_.data() != NULL; }
+  bool SearchBitState(absl::string_view text, absl::string_view context,
+                      Anchor anchor, MatchKind kind, absl::string_view* match,
+                      int nmatch);
 
   static const int kMaxOnePassCapture = 5;  // $0 through $4
 
@@ -318,10 +340,9 @@ class Prog {
   // It is also recursive, so can't use in production (will overflow stacks).
   // The name "Unsafe" here is supposed to be a flag that
   // you should not be using this function.
-  bool UnsafeSearchBacktrack(const StringPiece& text,
-                             const StringPiece& context,
+  bool UnsafeSearchBacktrack(absl::string_view text, absl::string_view context,
                              Anchor anchor, MatchKind kind,
-                             StringPiece* match, int nmatch);
+                             absl::string_view* match, int nmatch);
 
   // Computes range for any strings matching regexp. The min and max can in
   // some cases be arbitrarily precise, so the caller gets to specify the
@@ -337,9 +358,8 @@ class Prog {
   // do not compile down to infinite repetitions.
   //
   // Returns true on success, false on error.
-  bool PossibleMatchRange(string* min, string* max, int maxlen);
+  bool PossibleMatchRange(std::string* min, std::string* max, int maxlen);
 
-  // EXPERIMENTAL! SUBJECT TO CHANGE!
   // Outputs the program fanout into the given sparse array.
   void Fanout(SparseArray<int>* fanout);
 
@@ -374,6 +394,13 @@ class Prog {
                 std::vector<Inst>* flat,
                 SparseSet* reachable, std::vector<int>* stk);
 
+  // Computes hints for ByteRange instructions in [begin, end).
+  void ComputeHints(std::vector<Inst>* flat, int begin, int end);
+
+  // Controls whether the DFA should bail out early if the NFA would be faster.
+  // FOR TESTING ONLY.
+  static void TESTING_ONLY_set_dfa_should_bail_when_slow(bool b);
+
  private:
   friend class Compiler;
 
@@ -390,14 +417,25 @@ class Prog {
   int start_unanchored_;    // unanchored entry point for program
   int size_;                // number of instructions
   int bytemap_range_;       // bytemap_[x] < bytemap_range_
-  int first_byte_;          // required first byte for match, or -1 if none
-  int flags_;               // regexp parse flags
 
-  int list_count_;            // count of lists (see above)
-  int inst_count_[kNumInst];  // count of instructions by opcode
+  bool prefix_foldcase_;    // whether prefix is case-insensitive
+  size_t prefix_size_;      // size of prefix (0 if no prefix)
+  union {
+    uint64_t* prefix_dfa_;  // "Shift DFA" for prefix
+    struct {
+      int prefix_front_;    // first byte of prefix
+      int prefix_back_;     // last byte of prefix
+    };
+  };
 
-  PODArray<Inst> inst_;     // pointer to instruction array
-  uint8_t* onepass_nodes_;  // data for OnePass nodes
+  int list_count_;                  // count of lists (see above)
+  int inst_count_[kNumInst];        // count of instructions by opcode
+  PODArray<uint16_t> list_heads_;   // sparse array enumerating list heads
+                                    // not populated if size_ is overly large
+  size_t bit_state_text_max_size_;  // upper bound (inclusive) on text.size()
+
+  PODArray<Inst> inst_;              // pointer to instruction array
+  PODArray<uint8_t> onepass_nodes_;  // data for OnePass nodes
 
   int64_t dfa_mem_;         // Maximum memory for DFAs.
   DFA* dfa_first_;          // DFA cached for kFirstMatch/kManyMatch
@@ -405,14 +443,24 @@ class Prog {
 
   uint8_t bytemap_[256];    // map from input bytes to byte classes
 
-  std::once_flag first_byte_once_;
-  std::once_flag dfa_first_once_;
-  std::once_flag dfa_longest_once_;
+  absl::once_flag dfa_first_once_;
+  absl::once_flag dfa_longest_once_;
 
   Prog(const Prog&) = delete;
   Prog& operator=(const Prog&) = delete;
 };
 
+// std::string_view in MSVC has iterators that aren't just pointers and
+// that don't allow comparisons between different objects - not even if
+// those objects are views into the same string! Thus, we provide these
+// conversion functions for convenience.
+static inline const char* BeginPtr(absl::string_view s) {
+  return s.data();
+}
+static inline const char* EndPtr(absl::string_view s) {
+  return s.data() + s.size();
+}
+
 }  // namespace re2
 
 #endif  // RE2_PROG_H_
diff --git a/re2/re2.cc b/re2/re2.cc
index 1529807..c0011e9 100644
--- a/re2/re2.cc
+++ b/re2/re2.cc
@@ -12,26 +12,38 @@
 #include <assert.h>
 #include <ctype.h>
 #include <errno.h>
+#ifdef _MSC_VER
+#include <intrin.h>
+#endif
 #include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
 #include <algorithm>
+#include <atomic>
 #include <iterator>
-#include <mutex>
 #include <string>
 #include <utility>
 #include <vector>
 
-#include "util/util.h"
+#include "absl/base/macros.h"
+#include "absl/container/fixed_array.h"
+#include "absl/strings/str_format.h"
 #include "util/logging.h"
-#include "util/sparse_array.h"
 #include "util/strutil.h"
 #include "util/utf.h"
 #include "re2/prog.h"
 #include "re2/regexp.h"
+#include "re2/sparse_array.h"
 
 namespace re2 {
 
+// Controls the maximum count permitted by GlobalReplace(); -1 is unlimited.
+static int maximum_global_replace_count = -1;
+
+void RE2::FUZZING_ONLY_set_maximum_global_replace_count(int i) {
+  maximum_global_replace_count = i;
+}
+
 // Maximum number of args we can set
 static const int kMaxArgs = 16;
 static const int kVecSize = 1+kMaxArgs;
@@ -39,11 +51,11 @@ static const int kVecSize = 1+kMaxArgs;
 const int RE2::Options::kDefaultMaxMem;  // initialized in re2.h
 
 RE2::Options::Options(RE2::CannedOptions opt)
-  : encoding_(opt == RE2::Latin1 ? EncodingLatin1 : EncodingUTF8),
+  : max_mem_(kDefaultMaxMem),
+    encoding_(opt == RE2::Latin1 ? EncodingLatin1 : EncodingUTF8),
     posix_syntax_(opt == RE2::POSIX),
     longest_match_(opt == RE2::POSIX),
     log_errors_(opt != RE2::Quiet),
-    max_mem_(kDefaultMaxMem),
     literal_(false),
     never_nl_(false),
     dot_nl_(false),
@@ -54,11 +66,30 @@ RE2::Options::Options(RE2::CannedOptions opt)
     one_line_(false) {
 }
 
-// static empty objects for use as const references.
-// To avoid global constructors, allocated in RE2::Init().
-static const string* empty_string;
-static const std::map<string, int>* empty_named_groups;
-static const std::map<int, string>* empty_group_names;
+// Empty objects for use as const references.
+// Statically allocating the storage and then
+// lazily constructing the objects (in a once
+// in RE2::Init()) avoids global constructors
+// and the false positives (thanks, Valgrind)
+// about memory leaks at program termination.
+struct EmptyStorage {
+  std::string empty_string;
+  std::map<std::string, int> empty_named_groups;
+  std::map<int, std::string> empty_group_names;
+};
+alignas(EmptyStorage) static char empty_storage[sizeof(EmptyStorage)];
+
+static inline std::string* empty_string() {
+  return &reinterpret_cast<EmptyStorage*>(empty_storage)->empty_string;
+}
+
+static inline std::map<std::string, int>* empty_named_groups() {
+  return &reinterpret_cast<EmptyStorage*>(empty_storage)->empty_named_groups;
+}
+
+static inline std::map<int, std::string>* empty_group_names() {
+  return &reinterpret_cast<EmptyStorage*>(empty_storage)->empty_group_names;
+}
 
 // Converts from Regexp error code to RE2 error code.
 // Maybe some day they will diverge.  In any event, this
@@ -79,6 +110,8 @@ static RE2::ErrorCode RegexpErrorToRE2(re2::RegexpStatusCode code) {
       return RE2::ErrorMissingBracket;
     case re2::kRegexpMissingParen:
       return RE2::ErrorMissingParen;
+    case re2::kRegexpUnexpectedParen:
+      return RE2::ErrorUnexpectedParen;
     case re2::kRegexpTrailingBackslash:
       return RE2::ErrorTrailingBackslash;
     case re2::kRegexpRepeatArgument:
@@ -97,10 +130,10 @@ static RE2::ErrorCode RegexpErrorToRE2(re2::RegexpStatusCode code) {
   return RE2::ErrorInternal;
 }
 
-static string trunc(const StringPiece& pattern) {
+static std::string trunc(absl::string_view pattern) {
   if (pattern.size() < 100)
-    return string(pattern);
-  return string(pattern.substr(0, 100)) + "...";
+    return std::string(pattern);
+  return std::string(pattern.substr(0, 100)) + "...";
 }
 
 
@@ -108,15 +141,15 @@ RE2::RE2(const char* pattern) {
   Init(pattern, DefaultOptions);
 }
 
-RE2::RE2(const string& pattern) {
+RE2::RE2(const std::string& pattern) {
   Init(pattern, DefaultOptions);
 }
 
-RE2::RE2(const StringPiece& pattern) {
+RE2::RE2(absl::string_view pattern) {
   Init(pattern, DefaultOptions);
 }
 
-RE2::RE2(const StringPiece& pattern, const Options& options) {
+RE2::RE2(absl::string_view pattern, const Options& options) {
   Init(pattern, options);
 }
 
@@ -164,47 +197,56 @@ int RE2::Options::ParseFlags() const {
   return flags;
 }
 
-void RE2::Init(const StringPiece& pattern, const Options& options) {
-  static std::once_flag empty_once;
-  std::call_once(empty_once, []() {
-    empty_string = new string;
-    empty_named_groups = new std::map<string, int>;
-    empty_group_names = new std::map<int, string>;
+void RE2::Init(absl::string_view pattern, const Options& options) {
+  static absl::once_flag empty_once;
+  absl::call_once(empty_once, []() {
+    (void) new (empty_storage) EmptyStorage;
   });
 
-  pattern_ = string(pattern);
+  pattern_ = new std::string(pattern);
   options_.Copy(options);
   entire_regexp_ = NULL;
   suffix_regexp_ = NULL;
-  prog_ = NULL;
+  error_ = empty_string();
+  error_arg_ = empty_string();
+
   num_captures_ = -1;
-  rprog_ = NULL;
-  error_ = empty_string;
   error_code_ = NoError;
+  longest_match_ = options_.longest_match();
+  is_one_pass_ = false;
+  prefix_foldcase_ = false;
+  prefix_.clear();
+  prog_ = NULL;
+
+  rprog_ = NULL;
   named_groups_ = NULL;
   group_names_ = NULL;
 
   RegexpStatus status;
   entire_regexp_ = Regexp::Parse(
-    pattern_,
+    *pattern_,
     static_cast<Regexp::ParseFlags>(options_.ParseFlags()),
     &status);
   if (entire_regexp_ == NULL) {
     if (options_.log_errors()) {
-      LOG(ERROR) << "Error parsing '" << trunc(pattern_) << "': "
+      LOG(ERROR) << "Error parsing '" << trunc(*pattern_) << "': "
                  << status.Text();
     }
-    error_ = new string(status.Text());
+    error_ = new std::string(status.Text());
     error_code_ = RegexpErrorToRE2(status.code());
-    error_arg_ = string(status.error_arg());
+    error_arg_ = new std::string(status.error_arg());
     return;
   }
 
+  bool foldcase;
   re2::Regexp* suffix;
-  if (entire_regexp_->RequiredPrefix(&prefix_, &prefix_foldcase_, &suffix))
+  if (entire_regexp_->RequiredPrefix(&prefix_, &foldcase, &suffix)) {
+    prefix_foldcase_ = foldcase;
     suffix_regexp_ = suffix;
-  else
+  }
+  else {
     suffix_regexp_ = entire_regexp_->Incref();
+  }
 
   // Two thirds of the memory goes to the forward Prog,
   // one third to the reverse prog, because the forward
@@ -212,15 +254,15 @@ void RE2::Init(const StringPiece& pattern, const Options& options) {
   prog_ = suffix_regexp_->CompileToProg(options_.max_mem()*2/3);
   if (prog_ == NULL) {
     if (options_.log_errors())
-      LOG(ERROR) << "Error compiling '" << trunc(pattern_) << "'";
-    error_ = new string("pattern too large - compile failed");
+      LOG(ERROR) << "Error compiling '" << trunc(*pattern_) << "'";
+    error_ = new std::string("pattern too large - compile failed");
     error_code_ = RE2::ErrorPatternTooLarge;
     return;
   }
 
   // We used to compute this lazily, but it's used during the
   // typical control flow for a match call, so we now compute
-  // it eagerly, which avoids the overhead of std::once_flag.
+  // it eagerly, which avoids the overhead of absl::once_flag.
   num_captures_ = suffix_regexp_->NumCaptures();
 
   // Could delay this until the first match call that
@@ -233,32 +275,39 @@ void RE2::Init(const StringPiece& pattern, const Options& options) {
 
 // Returns rprog_, computing it if needed.
 re2::Prog* RE2::ReverseProg() const {
-  std::call_once(rprog_once_, [](const RE2* re) {
+  absl::call_once(rprog_once_, [](const RE2* re) {
     re->rprog_ =
         re->suffix_regexp_->CompileToReverseProg(re->options_.max_mem() / 3);
     if (re->rprog_ == NULL) {
       if (re->options_.log_errors())
-        LOG(ERROR) << "Error reverse compiling '" << trunc(re->pattern_) << "'";
-      re->error_ = new string("pattern too large - reverse compile failed");
-      re->error_code_ = RE2::ErrorPatternTooLarge;
+        LOG(ERROR) << "Error reverse compiling '" << trunc(*re->pattern_)
+                   << "'";
+      // We no longer touch error_ and error_code_ because failing to compile
+      // the reverse Prog is not a showstopper: falling back to NFA execution
+      // is fine. More importantly, an RE2 object is supposed to be logically
+      // immutable: whatever ok() would have returned after Init() completed,
+      // it should continue to return that no matter what ReverseProg() does.
     }
   }, this);
   return rprog_;
 }
 
 RE2::~RE2() {
+  if (group_names_ != empty_group_names())
+    delete group_names_;
+  if (named_groups_ != empty_named_groups())
+    delete named_groups_;
+  delete rprog_;
+  delete prog_;
+  if (error_arg_ != empty_string())
+    delete error_arg_;
+  if (error_ != empty_string())
+    delete error_;
   if (suffix_regexp_)
     suffix_regexp_->Decref();
   if (entire_regexp_)
     entire_regexp_->Decref();
-  delete prog_;
-  delete rprog_;
-  if (error_ != empty_string)
-    delete error_;
-  if (named_groups_ != NULL && named_groups_ != empty_named_groups)
-    delete named_groups_;
-  if (group_names_ != NULL &&  group_names_ != empty_group_names)
-    delete group_names_;
+  delete pattern_;
 }
 
 int RE2::ProgramSize() const {
@@ -276,28 +325,54 @@ int RE2::ReverseProgramSize() const {
   return prog->size();
 }
 
-static int Fanout(Prog* prog, std::map<int, int>* histogram) {
+// Finds the most significant non-zero bit in n.
+static int FindMSBSet(uint32_t n) {
+  DCHECK_NE(n, 0);
+#if defined(__GNUC__)
+  return 31 ^ __builtin_clz(n);
+#elif defined(_MSC_VER) && (defined(_M_X64) || defined(_M_IX86))
+  unsigned long c;
+  _BitScanReverse(&c, n);
+  return static_cast<int>(c);
+#else
+  int c = 0;
+  for (int shift = 1 << 4; shift != 0; shift >>= 1) {
+    uint32_t word = n >> shift;
+    if (word != 0) {
+      n = word;
+      c += shift;
+    }
+  }
+  return c;
+#endif
+}
+
+static int Fanout(Prog* prog, std::vector<int>* histogram) {
   SparseArray<int> fanout(prog->size());
   prog->Fanout(&fanout);
-  histogram->clear();
+  int data[32] = {};
+  int size = 0;
   for (SparseArray<int>::iterator i = fanout.begin(); i != fanout.end(); ++i) {
-    // TODO(junyer): Optimise this?
-    int bucket = 0;
-    while (1 << bucket < i->value()) {
-      bucket++;
-    }
-    (*histogram)[bucket]++;
+    if (i->value() == 0)
+      continue;
+    uint32_t value = i->value();
+    int bucket = FindMSBSet(value);
+    bucket += value & (value-1) ? 1 : 0;
+    ++data[bucket];
+    size = std::max(size, bucket+1);
   }
-  return histogram->rbegin()->first;
+  if (histogram != NULL)
+    histogram->assign(data, data+size);
+  return size-1;
 }
 
-int RE2::ProgramFanout(std::map<int, int>* histogram) const {
+int RE2::ProgramFanout(std::vector<int>* histogram) const {
   if (prog_ == NULL)
     return -1;
   return Fanout(prog_, histogram);
 }
 
-int RE2::ReverseProgramFanout(std::map<int, int>* histogram) const {
+int RE2::ReverseProgramFanout(std::vector<int>* histogram) const {
   if (prog_ == NULL)
     return -1;
   Prog* prog = ReverseProg();
@@ -307,40 +382,40 @@ int RE2::ReverseProgramFanout(std::map<int, int>* histogram) const {
 }
 
 // Returns named_groups_, computing it if needed.
-const std::map<string, int>& RE2::NamedCapturingGroups() const {
-  std::call_once(named_groups_once_, [](const RE2* re) {
+const std::map<std::string, int>& RE2::NamedCapturingGroups() const {
+  absl::call_once(named_groups_once_, [](const RE2* re) {
     if (re->suffix_regexp_ != NULL)
       re->named_groups_ = re->suffix_regexp_->NamedCaptures();
     if (re->named_groups_ == NULL)
-      re->named_groups_ = empty_named_groups;
+      re->named_groups_ = empty_named_groups();
   }, this);
   return *named_groups_;
 }
 
 // Returns group_names_, computing it if needed.
-const std::map<int, string>& RE2::CapturingGroupNames() const {
-  std::call_once(group_names_once_, [](const RE2* re) {
+const std::map<int, std::string>& RE2::CapturingGroupNames() const {
+  absl::call_once(group_names_once_, [](const RE2* re) {
     if (re->suffix_regexp_ != NULL)
       re->group_names_ = re->suffix_regexp_->CaptureNames();
     if (re->group_names_ == NULL)
-      re->group_names_ = empty_group_names;
+      re->group_names_ = empty_group_names();
   }, this);
   return *group_names_;
 }
 
 /***** Convenience interfaces *****/
 
-bool RE2::FullMatchN(const StringPiece& text, const RE2& re,
+bool RE2::FullMatchN(absl::string_view text, const RE2& re,
                      const Arg* const args[], int n) {
   return re.DoMatch(text, ANCHOR_BOTH, NULL, args, n);
 }
 
-bool RE2::PartialMatchN(const StringPiece& text, const RE2& re,
+bool RE2::PartialMatchN(absl::string_view text, const RE2& re,
                         const Arg* const args[], int n) {
   return re.DoMatch(text, UNANCHORED, NULL, args, n);
 }
 
-bool RE2::ConsumeN(StringPiece* input, const RE2& re,
+bool RE2::ConsumeN(absl::string_view* input, const RE2& re,
                    const Arg* const args[], int n) {
   size_t consumed;
   if (re.DoMatch(*input, ANCHOR_START, &consumed, args, n)) {
@@ -351,7 +426,7 @@ bool RE2::ConsumeN(StringPiece* input, const RE2& re,
   }
 }
 
-bool RE2::FindAndConsumeN(StringPiece* input, const RE2& re,
+bool RE2::FindAndConsumeN(absl::string_view* input, const RE2& re,
                           const Arg* const args[], int n) {
   size_t consumed;
   if (re.DoMatch(*input, UNANCHORED, &consumed, args, n)) {
@@ -362,59 +437,59 @@ bool RE2::FindAndConsumeN(StringPiece* input, const RE2& re,
   }
 }
 
-bool RE2::Replace(string* str,
+bool RE2::Replace(std::string* str,
                   const RE2& re,
-                  const StringPiece& rewrite) {
-  StringPiece vec[kVecSize];
+                  absl::string_view rewrite) {
+  absl::string_view vec[kVecSize];
   int nvec = 1 + MaxSubmatch(rewrite);
-  if (nvec > arraysize(vec))
+  if (nvec > 1 + re.NumberOfCapturingGroups())
+    return false;
+  if (nvec > static_cast<int>(ABSL_ARRAYSIZE(vec)))
     return false;
   if (!re.Match(*str, 0, str->size(), UNANCHORED, vec, nvec))
     return false;
 
-  string s;
+  std::string s;
   if (!re.Rewrite(&s, rewrite, vec, nvec))
     return false;
 
-  assert(vec[0].begin() >= str->data());
-  assert(vec[0].end() <= str->data()+str->size());
+  assert(vec[0].data() >= str->data());
+  assert(vec[0].data() + vec[0].size() <= str->data() + str->size());
   str->replace(vec[0].data() - str->data(), vec[0].size(), s);
   return true;
 }
 
-int RE2::GlobalReplace(string* str,
+int RE2::GlobalReplace(std::string* str,
                        const RE2& re,
-                       const StringPiece& rewrite) {
-  StringPiece vec[kVecSize];
+                       absl::string_view rewrite) {
+  absl::string_view vec[kVecSize];
   int nvec = 1 + MaxSubmatch(rewrite);
-  if (nvec > arraysize(vec))
+  if (nvec > 1 + re.NumberOfCapturingGroups())
+    return false;
+  if (nvec > static_cast<int>(ABSL_ARRAYSIZE(vec)))
     return false;
 
   const char* p = str->data();
   const char* ep = p + str->size();
   const char* lastend = NULL;
-  string out;
+  std::string out;
   int count = 0;
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-  // Iterate just once when fuzzing. Otherwise, we easily get bogged down
-  // and coverage is unlikely to improve despite significant expense.
-  while (p == str->data()) {
-#else
   while (p <= ep) {
-#endif
+    if (maximum_global_replace_count != -1 &&
+        count >= maximum_global_replace_count)
+      break;
     if (!re.Match(*str, static_cast<size_t>(p - str->data()),
                   str->size(), UNANCHORED, vec, nvec))
       break;
-    if (p < vec[0].begin())
-      out.append(p, vec[0].begin() - p);
-    if (vec[0].begin() == lastend && vec[0].size() == 0) {
+    if (p < vec[0].data())
+      out.append(p, vec[0].data() - p);
+    if (vec[0].data() == lastend && vec[0].empty()) {
       // Disallow empty match at end of last match: skip ahead.
       //
-      // fullrune() takes int, not size_t. However, it just looks
+      // fullrune() takes int, not ptrdiff_t. However, it just looks
       // at the leading byte and treats any length >= 4 the same.
       if (re.options().encoding() == RE2::Options::EncodingUTF8 &&
-          fullrune(p, static_cast<int>(std::min(static_cast<ptrdiff_t>(4),
-                                                ep - p)))) {
+          fullrune(p, static_cast<int>(std::min(ptrdiff_t{4}, ep - p)))) {
         // re is in UTF-8 mode and there is enough left of str
         // to allow us to advance by up to UTFmax bytes.
         Rune r;
@@ -439,7 +514,7 @@ int RE2::GlobalReplace(string* str,
       continue;
     }
     re.Rewrite(&out, rewrite, vec, nvec);
-    p = vec[0].end();
+    p = vec[0].data() + vec[0].size();
     lastend = p;
     count++;
   }
@@ -454,15 +529,16 @@ int RE2::GlobalReplace(string* str,
   return count;
 }
 
-bool RE2::Extract(const StringPiece& text,
+bool RE2::Extract(absl::string_view text,
                   const RE2& re,
-                  const StringPiece& rewrite,
-                  string* out) {
-  StringPiece vec[kVecSize];
+                  absl::string_view rewrite,
+                  std::string* out) {
+  absl::string_view vec[kVecSize];
   int nvec = 1 + MaxSubmatch(rewrite);
-  if (nvec > arraysize(vec))
+  if (nvec > 1 + re.NumberOfCapturingGroups())
+    return false;
+  if (nvec > static_cast<int>(ABSL_ARRAYSIZE(vec)))
     return false;
-
   if (!re.Match(text, 0, text.size(), UNANCHORED, vec, nvec))
     return false;
 
@@ -470,8 +546,8 @@ bool RE2::Extract(const StringPiece& text,
   return re.Rewrite(out, rewrite, vec, nvec);
 }
 
-string RE2::QuoteMeta(const StringPiece& unquoted) {
-  string result;
+std::string RE2::QuoteMeta(absl::string_view unquoted) {
+  std::string result;
   result.reserve(unquoted.size() << 1);
 
   // Escape any ascii character not in [A-Za-z_0-9].
@@ -508,7 +584,8 @@ string RE2::QuoteMeta(const StringPiece& unquoted) {
   return result;
 }
 
-bool RE2::PossibleMatchRange(string* min, string* max, int maxlen) const {
+bool RE2::PossibleMatchRange(std::string* min, std::string* max,
+                             int maxlen) const {
   if (prog_ == NULL)
     return false;
 
@@ -529,7 +606,7 @@ bool RE2::PossibleMatchRange(string* min, string* max, int maxlen) const {
   }
 
   // Add to prefix min max using PossibleMatchRange on regexp.
-  string dmin, dmax;
+  std::string dmin, dmax;
   maxlen -= n;
   if (maxlen > 0 && prog_->PossibleMatchRange(&dmin, &dmax, maxlen)) {
     min->append(dmin);
@@ -568,11 +645,11 @@ static int ascii_strcasecmp(const char* a, const char* b, size_t len) {
 
 /***** Actual matching and rewriting code *****/
 
-bool RE2::Match(const StringPiece& text,
+bool RE2::Match(absl::string_view text,
                 size_t startpos,
                 size_t endpos,
                 Anchor re_anchor,
-                StringPiece* submatch,
+                absl::string_view* submatch,
                 int nsubmatch) const {
   if (!ok()) {
     if (options_.log_errors())
@@ -589,7 +666,7 @@ bool RE2::Match(const StringPiece& text,
     return false;
   }
 
-  StringPiece subtext = text;
+  absl::string_view subtext = text;
   subtext.remove_prefix(startpos);
   subtext.remove_suffix(text.size() - endpos);
 
@@ -597,8 +674,8 @@ bool RE2::Match(const StringPiece& text,
 
   // Don't ask for the location if we won't use it.
   // SearchDFA can do extra optimizations in that case.
-  StringPiece match;
-  StringPiece* matchp = &match;
+  absl::string_view match;
+  absl::string_view* matchp = &match;
   if (nsubmatch == 0)
     matchp = NULL;
 
@@ -609,6 +686,8 @@ bool RE2::Match(const StringPiece& text,
   // If the regexp is anchored explicitly, must not be in middle of text.
   if (prog_->anchor_start() && startpos != 0)
     return false;
+  if (prog_->anchor_end() && endpos != text.size())
+    return false;
 
   // If the regexp is anchored explicitly, update re_anchor
   // so that we can potentially fall into a faster case below.
@@ -639,55 +718,89 @@ bool RE2::Match(const StringPiece& text,
   }
 
   Prog::Anchor anchor = Prog::kUnanchored;
-  Prog::MatchKind kind = Prog::kFirstMatch;
-  if (options_.longest_match())
-    kind = Prog::kLongestMatch;
-  bool skipped_test = false;
+  Prog::MatchKind kind =
+      longest_match_ ? Prog::kLongestMatch : Prog::kFirstMatch;
 
-  bool can_one_pass = (is_one_pass_ && ncap <= Prog::kMaxOnePassCapture);
-
-  // SearchBitState allocates a bit vector of size prog_->size() * text.size().
-  // It also allocates a stack of 3-word structures which could potentially
-  // grow as large as prog_->size() * text.size() but in practice is much
-  // smaller.
-  // Conditions for using SearchBitState:
-  const int MaxBitStateProg = 500;   // prog_->size() <= Max.
-  const int MaxBitStateVector = 256*1024;  // bit vector size <= Max (bits)
-  bool can_bit_state = prog_->size() <= MaxBitStateProg;
-  size_t bit_state_text_max = MaxBitStateVector / prog_->size();
+  bool can_one_pass = is_one_pass_ && ncap <= Prog::kMaxOnePassCapture;
+  bool can_bit_state = prog_->CanBitState();
+  size_t bit_state_text_max_size = prog_->bit_state_text_max_size();
 
+#ifdef RE2_HAVE_THREAD_LOCAL
+  hooks::context = this;
+#endif
   bool dfa_failed = false;
+  bool skipped_test = false;
   switch (re_anchor) {
     default:
+      LOG(DFATAL) << "Unexpected re_anchor value: " << re_anchor;
+      return false;
+
     case UNANCHORED: {
+      if (prog_->anchor_end()) {
+        // This is a very special case: we don't need the forward DFA because
+        // we already know where the match must end! Instead, the reverse DFA
+        // can say whether there is a match and (optionally) where it starts.
+        Prog* prog = ReverseProg();
+        if (prog == NULL) {
+          // Fall back to NFA below.
+          skipped_test = true;
+          break;
+        }
+        if (!prog->SearchDFA(subtext, text, Prog::kAnchored,
+                             Prog::kLongestMatch, matchp, &dfa_failed, NULL)) {
+          if (dfa_failed) {
+            if (options_.log_errors())
+              LOG(ERROR) << "DFA out of memory: "
+                         << "pattern length " << pattern_->size() << ", "
+                         << "program size " << prog->size() << ", "
+                         << "list count " << prog->list_count() << ", "
+                         << "bytemap range " << prog->bytemap_range();
+            // Fall back to NFA below.
+            skipped_test = true;
+            break;
+          }
+          return false;
+        }
+        if (matchp == NULL)  // Matched.  Don't care where.
+          return true;
+        break;
+      }
+
       if (!prog_->SearchDFA(subtext, text, anchor, kind,
                             matchp, &dfa_failed, NULL)) {
         if (dfa_failed) {
           if (options_.log_errors())
-            LOG(ERROR) << "DFA out of memory: size " << prog_->size() << ", "
-                       << "bytemap range " << prog_->bytemap_range() << ", "
-                       << "list count " << prog_->list_count();
+            LOG(ERROR) << "DFA out of memory: "
+                       << "pattern length " << pattern_->size() << ", "
+                       << "program size " << prog_->size() << ", "
+                       << "list count " << prog_->list_count() << ", "
+                       << "bytemap range " << prog_->bytemap_range();
           // Fall back to NFA below.
           skipped_test = true;
           break;
         }
         return false;
       }
-      if (matchp == NULL)  // Matched.  Don't care where
+      if (matchp == NULL)  // Matched.  Don't care where.
         return true;
-      // SearchDFA set match[0].end() but didn't know where the
-      // match started.  Run the regexp backward from match[0].end()
+      // SearchDFA set match.end() but didn't know where the
+      // match started.  Run the regexp backward from match.end()
       // to find the longest possible match -- that's where it started.
       Prog* prog = ReverseProg();
-      if (prog == NULL)
-        return false;
+      if (prog == NULL) {
+        // Fall back to NFA below.
+        skipped_test = true;
+        break;
+      }
       if (!prog->SearchDFA(match, text, Prog::kAnchored,
                            Prog::kLongestMatch, &match, &dfa_failed, NULL)) {
         if (dfa_failed) {
           if (options_.log_errors())
-            LOG(ERROR) << "DFA out of memory: size " << prog->size() << ", "
-                       << "bytemap range " << prog->bytemap_range() << ", "
-                       << "list count " << prog->list_count();
+            LOG(ERROR) << "DFA out of memory: "
+                       << "pattern length " << pattern_->size() << ", "
+                       << "program size " << prog->size() << ", "
+                       << "list count " << prog->list_count() << ", "
+                       << "bytemap range " << prog->bytemap_range();
           // Fall back to NFA below.
           skipped_test = true;
           break;
@@ -713,11 +826,12 @@ bool RE2::Match(const StringPiece& text,
       // it doesn't have the shared state and occasional mutex that
       // the DFA does.
       if (can_one_pass && text.size() <= 4096 &&
-          (ncap > 1 || text.size() <= 8)) {
+          (ncap > 1 || text.size() <= 16)) {
         skipped_test = true;
         break;
       }
-      if (can_bit_state && text.size() <= bit_state_text_max && ncap > 1) {
+      if (can_bit_state && text.size() <= bit_state_text_max_size &&
+          ncap > 1) {
         skipped_test = true;
         break;
       }
@@ -725,9 +839,11 @@ bool RE2::Match(const StringPiece& text,
                             &match, &dfa_failed, NULL)) {
         if (dfa_failed) {
           if (options_.log_errors())
-            LOG(ERROR) << "DFA out of memory: size " << prog_->size() << ", "
-                       << "bytemap range " << prog_->bytemap_range() << ", "
-                       << "list count " << prog_->list_count();
+            LOG(ERROR) << "DFA out of memory: "
+                       << "pattern length " << pattern_->size() << ", "
+                       << "program size " << prog_->size() << ", "
+                       << "list count " << prog_->list_count() << ", "
+                       << "bytemap range " << prog_->bytemap_range();
           // Fall back to NFA below.
           skipped_test = true;
           break;
@@ -742,7 +858,7 @@ bool RE2::Match(const StringPiece& text,
     if (ncap == 1)
       submatch[0] = match;
   } else {
-    StringPiece subtext1;
+    absl::string_view subtext1;
     if (skipped_test) {
       // DFA ran out of memory or was skipped:
       // need to search in entire original text.
@@ -762,7 +878,7 @@ bool RE2::Match(const StringPiece& text,
           LOG(ERROR) << "SearchOnePass inconsistency";
         return false;
       }
-    } else if (can_bit_state && subtext1.size() <= bit_state_text_max) {
+    } else if (can_bit_state && subtext1.size() <= bit_state_text_max_size) {
       if (!prog_->SearchBitState(subtext1, text, anchor,
                                  kind, submatch, ncap)) {
         if (!skipped_test && options_.log_errors())
@@ -780,17 +896,17 @@ bool RE2::Match(const StringPiece& text,
 
   // Adjust overall match for required prefix that we stripped off.
   if (prefixlen > 0 && nsubmatch > 0)
-    submatch[0] = StringPiece(submatch[0].data() - prefixlen,
-                              submatch[0].size() + prefixlen);
+    submatch[0] = absl::string_view(submatch[0].data() - prefixlen,
+                                    submatch[0].size() + prefixlen);
 
   // Zero submatches that don't exist in the regexp.
   for (int i = ncap; i < nsubmatch; i++)
-    submatch[i] = StringPiece();
+    submatch[i] = absl::string_view();
   return true;
 }
 
-// Internal matcher - like Match() but takes Args not StringPieces.
-bool RE2::DoMatch(const StringPiece& text,
+// Internal matcher - like Match() but takes Args not string_views.
+bool RE2::DoMatch(absl::string_view text,
                   Anchor re_anchor,
                   size_t* consumed,
                   const Arg* const* args,
@@ -813,48 +929,37 @@ bool RE2::DoMatch(const StringPiece& text,
   else
     nvec = n+1;
 
-  StringPiece* vec;
-  StringPiece stkvec[kVecSize];
-  StringPiece* heapvec = NULL;
-
-  if (nvec <= arraysize(stkvec)) {
-    vec = stkvec;
-  } else {
-    vec = new StringPiece[nvec];
-    heapvec = vec;
-  }
+  absl::FixedArray<absl::string_view, kVecSize> vec_storage(nvec);
+  absl::string_view* vec = vec_storage.data();
 
   if (!Match(text, 0, text.size(), re_anchor, vec, nvec)) {
-    delete[] heapvec;
     return false;
   }
 
   if (consumed != NULL)
-    *consumed = static_cast<size_t>(vec[0].end() - text.begin());
+    *consumed = static_cast<size_t>(EndPtr(vec[0]) - BeginPtr(text));
 
   if (n == 0 || args == NULL) {
     // We are not interested in results
-    delete[] heapvec;
     return true;
   }
 
   // If we got here, we must have matched the whole pattern.
   for (int i = 0; i < n; i++) {
-    const StringPiece& s = vec[i+1];
+    absl::string_view s = vec[i+1];
     if (!args[i]->Parse(s.data(), s.size())) {
       // TODO: Should we indicate what the error was?
-      delete[] heapvec;
       return false;
     }
   }
 
-  delete[] heapvec;
   return true;
 }
 
 // Checks that the rewrite string is well-formed with respect to this
 // regular expression.
-bool RE2::CheckRewriteString(const StringPiece& rewrite, string* error) const {
+bool RE2::CheckRewriteString(absl::string_view rewrite,
+                             std::string* error) const {
   int max_token = -1;
   for (const char *s = rewrite.data(), *end = s + rewrite.size();
        s < end; s++) {
@@ -882,9 +987,10 @@ bool RE2::CheckRewriteString(const StringPiece& rewrite, string* error) const {
   }
 
   if (max_token > NumberOfCapturingGroups()) {
-    SStringPrintf(error, "Rewrite schema requests %d matches, "
-                  "but the regexp only has %d parenthesized subexpressions.",
-                  max_token, NumberOfCapturingGroups());
+    *error = absl::StrFormat(
+        "Rewrite schema requests %d matches, but the regexp only has %d "
+        "parenthesized subexpressions.",
+        max_token, NumberOfCapturingGroups());
     return false;
   }
   return true;
@@ -892,7 +998,7 @@ bool RE2::CheckRewriteString(const StringPiece& rewrite, string* error) const {
 
 // Returns the maximum submatch needed for the rewrite to be done by Replace().
 // E.g. if rewrite == "foo \\2,\\1", returns 2.
-int RE2::MaxSubmatch(const StringPiece& rewrite) {
+int RE2::MaxSubmatch(absl::string_view rewrite) {
   int max = 0;
   for (const char *s = rewrite.data(), *end = s + rewrite.size();
        s < end; s++) {
@@ -911,9 +1017,9 @@ int RE2::MaxSubmatch(const StringPiece& rewrite) {
 
 // Append the "rewrite" string, with backslash subsitutions from "vec",
 // to string "out".
-bool RE2::Rewrite(string* out,
-                  const StringPiece& rewrite,
-                  const StringPiece* vec,
+bool RE2::Rewrite(std::string* out,
+                  absl::string_view rewrite,
+                  const absl::string_view* vec,
                   int veclen) const {
   for (const char *s = rewrite.data(), *end = s + rewrite.size();
        s < end; s++) {
@@ -927,13 +1033,13 @@ bool RE2::Rewrite(string* out,
       int n = (c - '0');
       if (n >= veclen) {
         if (options_.log_errors()) {
-          LOG(ERROR) << "requested group " << n
-                     << " in regexp " << rewrite.data();
+          LOG(ERROR) << "invalid substitution \\" << n
+                     << " from " << veclen << " groups";
         }
         return false;
       }
-      StringPiece snip = vec[n];
-      if (snip.size() > 0)
+      absl::string_view snip = vec[n];
+      if (!snip.empty())
         out->append(snip.data(), snip.size());
     } else if (c == '\\') {
       out->push_back('\\');
@@ -948,41 +1054,49 @@ bool RE2::Rewrite(string* out,
 
 /***** Parsers for various types *****/
 
-bool RE2::Arg::parse_null(const char* str, size_t n, void* dest) {
+namespace re2_internal {
+
+template <>
+bool Parse(const char* str, size_t n, void* dest) {
   // We fail if somebody asked us to store into a non-NULL void* pointer
   return (dest == NULL);
 }
 
-bool RE2::Arg::parse_string(const char* str, size_t n, void* dest) {
+template <>
+bool Parse(const char* str, size_t n, std::string* dest) {
   if (dest == NULL) return true;
-  reinterpret_cast<string*>(dest)->assign(str, n);
+  dest->assign(str, n);
   return true;
 }
 
-bool RE2::Arg::parse_stringpiece(const char* str, size_t n, void* dest) {
+template <>
+bool Parse(const char* str, size_t n, absl::string_view* dest) {
   if (dest == NULL) return true;
-  *(reinterpret_cast<StringPiece*>(dest)) = StringPiece(str, n);
+  *dest = absl::string_view(str, n);
   return true;
 }
 
-bool RE2::Arg::parse_char(const char* str, size_t n, void* dest) {
+template <>
+bool Parse(const char* str, size_t n, char* dest) {
   if (n != 1) return false;
   if (dest == NULL) return true;
-  *(reinterpret_cast<char*>(dest)) = str[0];
+  *dest = str[0];
   return true;
 }
 
-bool RE2::Arg::parse_schar(const char* str, size_t n, void* dest) {
+template <>
+bool Parse(const char* str, size_t n, signed char* dest) {
   if (n != 1) return false;
   if (dest == NULL) return true;
-  *(reinterpret_cast<signed char*>(dest)) = str[0];
+  *dest = str[0];
   return true;
 }
 
-bool RE2::Arg::parse_uchar(const char* str, size_t n, void* dest) {
+template <>
+bool Parse(const char* str, size_t n, unsigned char* dest) {
   if (n != 1) return false;
   if (dest == NULL) return true;
-  *(reinterpret_cast<unsigned char*>(dest)) = str[0];
+  *dest = str[0];
   return true;
 }
 
@@ -1046,10 +1160,40 @@ static const char* TerminateNumber(char* buf, size_t nbuf, const char* str,
   return buf;
 }
 
-bool RE2::Arg::parse_long_radix(const char* str,
-                                size_t n,
-                                void* dest,
-                                int radix) {
+template <>
+bool Parse(const char* str, size_t n, float* dest) {
+  if (n == 0) return false;
+  static const int kMaxLength = 200;
+  char buf[kMaxLength+1];
+  str = TerminateNumber(buf, sizeof buf, str, &n, true);
+  char* end;
+  errno = 0;
+  float r = strtof(str, &end);
+  if (end != str + n) return false;   // Leftover junk
+  if (errno) return false;
+  if (dest == NULL) return true;
+  *dest = r;
+  return true;
+}
+
+template <>
+bool Parse(const char* str, size_t n, double* dest) {
+  if (n == 0) return false;
+  static const int kMaxLength = 200;
+  char buf[kMaxLength+1];
+  str = TerminateNumber(buf, sizeof buf, str, &n, true);
+  char* end;
+  errno = 0;
+  double r = strtod(str, &end);
+  if (end != str + n) return false;   // Leftover junk
+  if (errno) return false;
+  if (dest == NULL) return true;
+  *dest = r;
+  return true;
+}
+
+template <>
+bool Parse(const char* str, size_t n, long* dest, int radix) {
   if (n == 0) return false;
   char buf[kMaxNumberLength+1];
   str = TerminateNumber(buf, sizeof buf, str, &n, false);
@@ -1059,14 +1203,12 @@ bool RE2::Arg::parse_long_radix(const char* str,
   if (end != str + n) return false;   // Leftover junk
   if (errno) return false;
   if (dest == NULL) return true;
-  *(reinterpret_cast<long*>(dest)) = r;
+  *dest = r;
   return true;
 }
 
-bool RE2::Arg::parse_ulong_radix(const char* str,
-                                 size_t n,
-                                 void* dest,
-                                 int radix) {
+template <>
+bool Parse(const char* str, size_t n, unsigned long* dest, int radix) {
   if (n == 0) return false;
   char buf[kMaxNumberLength+1];
   str = TerminateNumber(buf, sizeof buf, str, &n, false);
@@ -1082,62 +1224,52 @@ bool RE2::Arg::parse_ulong_radix(const char* str,
   if (end != str + n) return false;   // Leftover junk
   if (errno) return false;
   if (dest == NULL) return true;
-  *(reinterpret_cast<unsigned long*>(dest)) = r;
+  *dest = r;
   return true;
 }
 
-bool RE2::Arg::parse_short_radix(const char* str,
-                                 size_t n,
-                                 void* dest,
-                                 int radix) {
+template <>
+bool Parse(const char* str, size_t n, short* dest, int radix) {
   long r;
-  if (!parse_long_radix(str, n, &r, radix)) return false;  // Could not parse
-  if ((short)r != r) return false;                         // Out of range
+  if (!Parse(str, n, &r, radix)) return false;  // Could not parse
+  if ((short)r != r) return false;              // Out of range
   if (dest == NULL) return true;
-  *(reinterpret_cast<short*>(dest)) = (short)r;
+  *dest = (short)r;
   return true;
 }
 
-bool RE2::Arg::parse_ushort_radix(const char* str,
-                                  size_t n,
-                                  void* dest,
-                                  int radix) {
+template <>
+bool Parse(const char* str, size_t n, unsigned short* dest, int radix) {
   unsigned long r;
-  if (!parse_ulong_radix(str, n, &r, radix)) return false;  // Could not parse
-  if ((unsigned short)r != r) return false;                 // Out of range
+  if (!Parse(str, n, &r, radix)) return false;  // Could not parse
+  if ((unsigned short)r != r) return false;     // Out of range
   if (dest == NULL) return true;
-  *(reinterpret_cast<unsigned short*>(dest)) = (unsigned short)r;
+  *dest = (unsigned short)r;
   return true;
 }
 
-bool RE2::Arg::parse_int_radix(const char* str,
-                               size_t n,
-                               void* dest,
-                               int radix) {
+template <>
+bool Parse(const char* str, size_t n, int* dest, int radix) {
   long r;
-  if (!parse_long_radix(str, n, &r, radix)) return false;  // Could not parse
-  if ((int)r != r) return false;                           // Out of range
+  if (!Parse(str, n, &r, radix)) return false;  // Could not parse
+  if ((int)r != r) return false;                // Out of range
   if (dest == NULL) return true;
-  *(reinterpret_cast<int*>(dest)) = (int)r;
+  *dest = (int)r;
   return true;
 }
 
-bool RE2::Arg::parse_uint_radix(const char* str,
-                                size_t n,
-                                void* dest,
-                                int radix) {
+template <>
+bool Parse(const char* str, size_t n, unsigned int* dest, int radix) {
   unsigned long r;
-  if (!parse_ulong_radix(str, n, &r, radix)) return false;  // Could not parse
-  if ((unsigned int)r != r) return false;                   // Out of range
+  if (!Parse(str, n, &r, radix)) return false;  // Could not parse
+  if ((unsigned int)r != r) return false;       // Out of range
   if (dest == NULL) return true;
-  *(reinterpret_cast<unsigned int*>(dest)) = (unsigned int)r;
+  *dest = (unsigned int)r;
   return true;
 }
 
-bool RE2::Arg::parse_longlong_radix(const char* str,
-                                    size_t n,
-                                    void* dest,
-                                    int radix) {
+template <>
+bool Parse(const char* str, size_t n, long long* dest, int radix) {
   if (n == 0) return false;
   char buf[kMaxNumberLength+1];
   str = TerminateNumber(buf, sizeof buf, str, &n, false);
@@ -1147,14 +1279,12 @@ bool RE2::Arg::parse_longlong_radix(const char* str,
   if (end != str + n) return false;   // Leftover junk
   if (errno) return false;
   if (dest == NULL) return true;
-  *(reinterpret_cast<long long*>(dest)) = r;
+  *dest = r;
   return true;
 }
 
-bool RE2::Arg::parse_ulonglong_radix(const char* str,
-                                     size_t n,
-                                     void* dest,
-                                     int radix) {
+template <>
+bool Parse(const char* str, size_t n, unsigned long long* dest, int radix) {
   if (n == 0) return false;
   char buf[kMaxNumberLength+1];
   str = TerminateNumber(buf, sizeof buf, str, &n, false);
@@ -1169,67 +1299,47 @@ bool RE2::Arg::parse_ulonglong_radix(const char* str,
   if (end != str + n) return false;   // Leftover junk
   if (errno) return false;
   if (dest == NULL) return true;
-  *(reinterpret_cast<unsigned long long*>(dest)) = r;
+  *dest = r;
   return true;
 }
 
-static bool parse_double_float(const char* str, size_t n, bool isfloat,
-                               void* dest) {
-  if (n == 0) return false;
-  static const int kMaxLength = 200;
-  char buf[kMaxLength+1];
-  str = TerminateNumber(buf, sizeof buf, str, &n, true);
-  char* end;
-  errno = 0;
-  double r;
-  if (isfloat) {
-    r = strtof(str, &end);
-  } else {
-    r = strtod(str, &end);
-  }
-  if (end != str + n) return false;   // Leftover junk
-  if (errno) return false;
-  if (dest == NULL) return true;
-  if (isfloat) {
-    *(reinterpret_cast<float*>(dest)) = (float)r;
-  } else {
-    *(reinterpret_cast<double*>(dest)) = r;
-  }
-  return true;
-}
+}  // namespace re2_internal
 
-bool RE2::Arg::parse_double(const char* str, size_t n, void* dest) {
-  return parse_double_float(str, n, false, dest);
-}
+namespace hooks {
 
-bool RE2::Arg::parse_float(const char* str, size_t n, void* dest) {
-  return parse_double_float(str, n, true, dest);
-}
+#ifdef RE2_HAVE_THREAD_LOCAL
+thread_local const RE2* context = NULL;
+#endif
 
-#define DEFINE_INTEGER_PARSER(name)                                            \
-  bool RE2::Arg::parse_##name(const char* str, size_t n, void* dest) {         \
-    return parse_##name##_radix(str, n, dest, 10);                             \
-  }                                                                            \
-  bool RE2::Arg::parse_##name##_hex(const char* str, size_t n, void* dest) {   \
-    return parse_##name##_radix(str, n, dest, 16);                             \
-  }                                                                            \
-  bool RE2::Arg::parse_##name##_octal(const char* str, size_t n, void* dest) { \
-    return parse_##name##_radix(str, n, dest, 8);                              \
-  }                                                                            \
-  bool RE2::Arg::parse_##name##_cradix(const char* str, size_t n,              \
-                                       void* dest) {                           \
-    return parse_##name##_radix(str, n, dest, 0);                              \
-  }
+template <typename T>
+union Hook {
+  void Store(T* cb) { cb_.store(cb, std::memory_order_release); }
+  T* Load() const { return cb_.load(std::memory_order_acquire); }
+
+#if !defined(__clang__) && defined(_MSC_VER)
+  // Citing https://github.com/protocolbuffers/protobuf/pull/4777 as precedent,
+  // this is a gross hack to make std::atomic<T*> constant-initialized on MSVC.
+  static_assert(ATOMIC_POINTER_LOCK_FREE == 2,
+                "std::atomic<T*> must be always lock-free");
+  T* cb_for_constinit_;
+#endif
+
+  std::atomic<T*> cb_;
+};
+
+template <typename T>
+static void DoNothing(const T&) {}
+
+#define DEFINE_HOOK(type, name)                                       \
+  static Hook<type##Callback> name##_hook = {{&DoNothing<type>}};     \
+  void Set##type##Hook(type##Callback* cb) { name##_hook.Store(cb); } \
+  type##Callback* Get##type##Hook() { return name##_hook.Load(); }
+
+DEFINE_HOOK(DFAStateCacheReset, dfa_state_cache_reset)
+DEFINE_HOOK(DFASearchFailure, dfa_search_failure)
 
-DEFINE_INTEGER_PARSER(short);
-DEFINE_INTEGER_PARSER(ushort);
-DEFINE_INTEGER_PARSER(int);
-DEFINE_INTEGER_PARSER(uint);
-DEFINE_INTEGER_PARSER(long);
-DEFINE_INTEGER_PARSER(ulong);
-DEFINE_INTEGER_PARSER(longlong);
-DEFINE_INTEGER_PARSER(ulonglong);
+#undef DEFINE_HOOK
 
-#undef DEFINE_INTEGER_PARSER
+}  // namespace hooks
 
 }  // namespace re2
diff --git a/re2/re2.h b/re2/re2.h
index 216347d..5ac5c46 100644
--- a/re2/re2.h
+++ b/re2/re2.h
@@ -30,6 +30,19 @@
 //   "(?i)hello"           -- (?i) turns on case-insensitive matching
 //   "/\\*(.*?)\\*/"       -- .*? matches . minimum no. of times possible
 //
+// The double backslashes are needed when writing C++ string literals.
+// However, they should NOT be used when writing C++11 raw string literals:
+//
+//   R"(hello (\w+) world)"  -- \w matches a "word" character
+//   R"(version (\d+))"      -- \d matches a digit
+//   R"(hello\s+world)"      -- \s matches any whitespace character
+//   R"(\b(\w+)\b)"          -- \b matches non-empty string at word boundary
+//   R"((?i)hello)"          -- (?i) turns on case-insensitive matching
+//   R"(/\*(.*?)\*/)"        -- .*? matches . minimum no. of times possible
+//
+// When using UTF-8 encoding, case-insensitive matching will perform
+// simple case folding, not full case folding.
+//
 // -----------------------------------------------------------------------
 // MATCHING INTERFACE:
 //
@@ -53,23 +66,23 @@
 //    CHECK(RE2::FullMatch(latin1_string, RE2(latin1_pattern, RE2::Latin1)));
 //
 // -----------------------------------------------------------------------
-// MATCHING WITH SUBSTRING EXTRACTION:
+// SUBMATCH EXTRACTION:
 //
-// You can supply extra pointer arguments to extract matched substrings.
+// You can supply extra pointer arguments to extract submatches.
 // On match failure, none of the pointees will have been modified.
-// On match success, the substrings will be converted (as necessary) and
+// On match success, the submatches will be converted (as necessary) and
 // their values will be assigned to their pointees until all conversions
 // have succeeded or one conversion has failed.
 // On conversion failure, the pointees will be in an indeterminate state
 // because the caller has no way of knowing which conversion failed.
-// However, conversion cannot fail for types like string and StringPiece
-// that do not inspect the substring contents. Hence, in the common case
+// However, conversion cannot fail for types like string and string_view
+// that do not inspect the submatch contents. Hence, in the common case
 // where all of the pointees are of such types, failure is always due to
 // match failure and thus none of the pointees will have been modified.
 //
 // Example: extracts "ruby" into "s" and 1234 into "i"
 //    int i;
-//    string s;
+//    std::string s;
 //    CHECK(RE2::FullMatch("ruby:1234", "(\\w+):(\\d+)", &s, &i));
 //
 // Example: fails because string cannot be stored in integer
@@ -87,10 +100,10 @@
 // Example: integer overflow causes failure
 //    CHECK(!RE2::FullMatch("ruby:1234567891234", "\\w+:(\\d+)", &i));
 //
-// NOTE(rsc): Asking for substrings slows successful matches quite a bit.
+// NOTE(rsc): Asking for submatches slows successful matches quite a bit.
 // This may get a little faster in the future, but right now is slower
 // than PCRE.  On the other hand, failed matches run *very* fast (faster
-// than PCRE), as do matches without substring extraction.
+// than PCRE), as do matches without submatch extraction.
 //
 // -----------------------------------------------------------------------
 // PARTIAL MATCHES
@@ -127,14 +140,14 @@
 //
 // The "Consume" operation may be useful if you want to repeatedly
 // match regular expressions at the front of a string and skip over
-// them as they match.  This requires use of the "StringPiece" type,
+// them as they match.  This requires use of the string_view type,
 // which represents a sub-range of a real string.
 //
 // Example: read lines of the form "var = value" from a string.
-//      string contents = ...;          // Fill string somehow
-//      StringPiece input(contents);    // Wrap a StringPiece around it
+//      std::string contents = ...;         // Fill string somehow
+//      absl::string_view input(contents);  // Wrap a string_view around it
 //
-//      string var;
+//      std::string var;
 //      int value;
 //      while (RE2::Consume(&input, "(\\w+) = (\\d+)\n", &var, &value)) {
 //        ...;
@@ -193,9 +206,17 @@
 #include <stdint.h>
 #include <algorithm>
 #include <map>
-#include <mutex>
 #include <string>
+#include <type_traits>
+#include <vector>
 
+#if defined(__APPLE__)
+#include <TargetConditionals.h>
+#endif
+
+#include "absl/base/call_once.h"
+#include "absl/strings/string_view.h"
+#include "absl/types/optional.h"
 #include "re2/stringpiece.h"
 
 namespace re2 {
@@ -205,9 +226,6 @@ class Regexp;
 
 namespace re2 {
 
-// TODO(junyer): Get rid of this.
-using std::string;
-
 // Interface for regular expression matching.  Also corresponds to a
 // pre-compiled regular expression.  An "RE2" object is safe for
 // concurrent use by multiple threads.
@@ -232,6 +250,7 @@ class RE2 {
     ErrorBadCharRange,       // bad character class range
     ErrorMissingBracket,     // missing closing ]
     ErrorMissingParen,       // missing closing )
+    ErrorUnexpectedParen,    // unexpected closing )
     ErrorTrailingBackslash,  // trailing \ at end of regexp
     ErrorRepeatArgument,     // repeat argument missing, e.g. "*"
     ErrorRepeatSize,         // bad repetition argument
@@ -254,28 +273,40 @@ class RE2 {
     Quiet // do not log about regexp parse errors
   };
 
-  // Need to have the const char* and const string& forms for implicit
+  // Need to have the const char* and const std::string& forms for implicit
   // conversions when passing string literals to FullMatch and PartialMatch.
-  // Otherwise the StringPiece form would be sufficient.
-#ifndef SWIG
+  // Otherwise the absl::string_view form would be sufficient.
   RE2(const char* pattern);
-  RE2(const string& pattern);
-#endif
-  RE2(const StringPiece& pattern);
-  RE2(const StringPiece& pattern, const Options& options);
+  RE2(const std::string& pattern);
+  RE2(absl::string_view pattern);
+  RE2(absl::string_view pattern, const Options& options);
   ~RE2();
 
+  // Not copyable.
+  // RE2 objects are expensive. You should probably use std::shared_ptr<RE2>
+  // instead. If you really must copy, RE2(first.pattern(), first.options())
+  // effectively does so: it produces a second object that mimics the first.
+  RE2(const RE2&) = delete;
+  RE2& operator=(const RE2&) = delete;
+  // Not movable.
+  // RE2 objects are thread-safe and logically immutable. You should probably
+  // use std::unique_ptr<RE2> instead. Otherwise, consider std::deque<RE2> if
+  // direct emplacement into a container is desired. If you really must move,
+  // be prepared to submit a design document along with your feature request.
+  RE2(RE2&&) = delete;
+  RE2& operator=(RE2&&) = delete;
+
   // Returns whether RE2 was created properly.
   bool ok() const { return error_code() == NoError; }
 
   // The string specification for this RE2.  E.g.
   //   RE2 re("ab*c?d+");
   //   re.pattern();    // "ab*c?d+"
-  const string& pattern() const { return pattern_; }
+  const std::string& pattern() const { return *pattern_; }
 
   // If RE2 could not be created properly, returns an error string.
   // Else returns the empty string.
-  const string& error() const { return *error_; }
+  const std::string& error() const { return *error_; }
 
   // If RE2 could not be created properly, returns an error code.
   // Else returns RE2::NoError (== 0).
@@ -283,18 +314,18 @@ class RE2 {
 
   // If RE2 could not be created properly, returns the offending
   // portion of the regexp.
-  const string& error_arg() const { return error_arg_; }
+  const std::string& error_arg() const { return *error_arg_; }
 
   // Returns the program size, a very approximate measure of a regexp's "cost".
   // Larger numbers are more expensive than smaller numbers.
   int ProgramSize() const;
   int ReverseProgramSize() const;
 
-  // EXPERIMENTAL! SUBJECT TO CHANGE!
-  // Outputs the program fanout as a histogram bucketed by powers of 2.
+  // If histogram is not null, outputs the program fanout
+  // as a histogram bucketed by powers of 2.
   // Returns the number of the largest non-empty bucket.
-  int ProgramFanout(std::map<int, int>* histogram) const;
-  int ReverseProgramFanout(std::map<int, int>* histogram) const;
+  int ProgramFanout(std::vector<int>* histogram) const;
+  int ReverseProgramFanout(std::vector<int>* histogram) const;
 
   // Returns the underlying Regexp; not for general use.
   // Returns entire_regexp_ so that callers don't need
@@ -307,16 +338,15 @@ class RE2 {
   // the functions whose names are the prefix before the 'N'. It is sometimes
   // useful to invoke them directly, but the syntax is awkward, so the 'N'-less
   // versions should be preferred.
-  static bool FullMatchN(const StringPiece& text, const RE2& re,
-                         const Arg* const args[], int argc);
-  static bool PartialMatchN(const StringPiece& text, const RE2& re,
-                            const Arg* const args[], int argc);
-  static bool ConsumeN(StringPiece* input, const RE2& re,
-                       const Arg* const args[], int argc);
-  static bool FindAndConsumeN(StringPiece* input, const RE2& re,
-                              const Arg* const args[], int argc);
-
-#ifndef SWIG
+  static bool FullMatchN(absl::string_view text, const RE2& re,
+                         const Arg* const args[], int n);
+  static bool PartialMatchN(absl::string_view text, const RE2& re,
+                            const Arg* const args[], int n);
+  static bool ConsumeN(absl::string_view* input, const RE2& re,
+                       const Arg* const args[], int n);
+  static bool FindAndConsumeN(absl::string_view* input, const RE2& re,
+                              const Arg* const args[], int n);
+
  private:
   template <typename F, typename SP>
   static inline bool Apply(F f, SP sp, const RE2& re) {
@@ -326,8 +356,8 @@ class RE2 {
   template <typename F, typename SP, typename... A>
   static inline bool Apply(F f, SP sp, const RE2& re, const A&... a) {
     const Arg* const args[] = {&a...};
-    const int argc = sizeof...(a);
-    return f(sp, re, args, argc);
+    const int n = sizeof...(a);
+    return f(sp, re, args, n);
   }
 
  public:
@@ -341,23 +371,23 @@ class RE2 {
   // Matches "text" against "re".  If pointer arguments are
   // supplied, copies matched sub-patterns into them.
   //
-  // You can pass in a "const char*" or a "string" for "text".
-  // You can pass in a "const char*" or a "string" or a "RE2" for "re".
+  // You can pass in a "const char*" or a "std::string" for "text".
+  // You can pass in a "const char*" or a "std::string" or a "RE2" for "re".
   //
   // The provided pointer arguments can be pointers to any scalar numeric
   // type, or one of:
-  //    string          (matched piece is copied to string)
-  //    StringPiece     (StringPiece is mutated to point to matched piece)
-  //    T               (where "bool T::ParseFrom(const char*, size_t)" exists)
-  //    (void*)NULL     (the corresponding matched sub-pattern is not copied)
+  //    std::string        (matched piece is copied to string)
+  //    absl::string_view  (string_view is mutated to point to matched piece)
+  //    T                  ("bool T::ParseFrom(const char*, size_t)" must exist)
+  //    (void*)NULL        (the corresponding matched sub-pattern is not copied)
   //
   // Returns true iff all of the following conditions are satisfied:
-  //   a. "text" matches "re" exactly
-  //   b. The number of matched sub-patterns is >= number of supplied pointers
+  //   a. "text" matches "re" fully - from the beginning to the end of "text".
+  //   b. The number of matched sub-patterns is >= number of supplied pointers.
   //   c. The "i"th argument has a suitable type for holding the
   //      string captured as the "i"th sub-pattern.  If you pass in
   //      NULL for the "i"th argument, or pass fewer arguments than
-  //      number of sub-patterns, "i"th captured sub-pattern is
+  //      number of sub-patterns, the "i"th captured sub-pattern is
   //      ignored.
   //
   // CAVEAT: An optional sub-pattern that does not exist in the
@@ -367,22 +397,41 @@ class RE2 {
   //    int number;
   //    RE2::FullMatch("abc", "[a-z]+(\\d+)?", &number);
   template <typename... A>
-  static bool FullMatch(const StringPiece& text, const RE2& re, A&&... a) {
+  static bool FullMatch(absl::string_view text, const RE2& re, A&&... a) {
     return Apply(FullMatchN, text, re, Arg(std::forward<A>(a))...);
   }
 
-  // Exactly like FullMatch(), except that "re" is allowed to match
-  // a substring of "text".
+  // Like FullMatch(), except that "re" is allowed to match a substring
+  // of "text".
+  //
+  // Returns true iff all of the following conditions are satisfied:
+  //   a. "text" matches "re" partially - for some substring of "text".
+  //   b. The number of matched sub-patterns is >= number of supplied pointers.
+  //   c. The "i"th argument has a suitable type for holding the
+  //      string captured as the "i"th sub-pattern.  If you pass in
+  //      NULL for the "i"th argument, or pass fewer arguments than
+  //      number of sub-patterns, the "i"th captured sub-pattern is
+  //      ignored.
   template <typename... A>
-  static bool PartialMatch(const StringPiece& text, const RE2& re, A&&... a) {
+  static bool PartialMatch(absl::string_view text, const RE2& re, A&&... a) {
     return Apply(PartialMatchN, text, re, Arg(std::forward<A>(a))...);
   }
 
   // Like FullMatch() and PartialMatch(), except that "re" has to match
   // a prefix of the text, and "input" is advanced past the matched
-  // text.  Note: "input" is modified iff this routine returns true.
+  // text.  Note: "input" is modified iff this routine returns true
+  // and "re" matched a non-empty substring of "input".
+  //
+  // Returns true iff all of the following conditions are satisfied:
+  //   a. "input" matches "re" partially - for some prefix of "input".
+  //   b. The number of matched sub-patterns is >= number of supplied pointers.
+  //   c. The "i"th argument has a suitable type for holding the
+  //      string captured as the "i"th sub-pattern.  If you pass in
+  //      NULL for the "i"th argument, or pass fewer arguments than
+  //      number of sub-patterns, the "i"th captured sub-pattern is
+  //      ignored.
   template <typename... A>
-  static bool Consume(StringPiece* input, const RE2& re, A&&... a) {
+  static bool Consume(absl::string_view* input, const RE2& re, A&&... a) {
     return Apply(ConsumeN, input, re, Arg(std::forward<A>(a))...);
   }
 
@@ -390,11 +439,19 @@ class RE2 {
   // the text.  That is, "re" need not start its match at the beginning
   // of "input".  For example, "FindAndConsume(s, "(\\w+)", &word)" finds
   // the next word in "s" and stores it in "word".
+  //
+  // Returns true iff all of the following conditions are satisfied:
+  //   a. "input" matches "re" partially - for some substring of "input".
+  //   b. The number of matched sub-patterns is >= number of supplied pointers.
+  //   c. The "i"th argument has a suitable type for holding the
+  //      string captured as the "i"th sub-pattern.  If you pass in
+  //      NULL for the "i"th argument, or pass fewer arguments than
+  //      number of sub-patterns, the "i"th captured sub-pattern is
+  //      ignored.
   template <typename... A>
-  static bool FindAndConsume(StringPiece* input, const RE2& re, A&&... a) {
+  static bool FindAndConsume(absl::string_view* input, const RE2& re, A&&... a) {
     return Apply(FindAndConsumeN, input, re, Arg(std::forward<A>(a))...);
   }
-#endif
 
   // Replace the first match of "re" in "str" with "rewrite".
   // Within "rewrite", backslash-escaped digits (\1 to \9) can be
@@ -402,21 +459,21 @@ class RE2 {
   // from the pattern.  \0 in "rewrite" refers to the entire matching
   // text.  E.g.,
   //
-  //   string s = "yabba dabba doo";
+  //   std::string s = "yabba dabba doo";
   //   CHECK(RE2::Replace(&s, "b+", "d"));
   //
   // will leave "s" containing "yada dabba doo"
   //
   // Returns true if the pattern matches and a replacement occurs,
   // false otherwise.
-  static bool Replace(string* str,
+  static bool Replace(std::string* str,
                       const RE2& re,
-                      const StringPiece& rewrite);
+                      absl::string_view rewrite);
 
   // Like Replace(), except replaces successive non-overlapping occurrences
   // of the pattern in the string with the rewrite. E.g.
   //
-  //   string s = "yabba dabba doo";
+  //   std::string s = "yabba dabba doo";
   //   CHECK(RE2::GlobalReplace(&s, "b+", "d"));
   //
   // will leave "s" containing "yada dada doo"
@@ -426,9 +483,9 @@ class RE2 {
   // replacing "ana" within "banana" makes only one replacement, not two.
   //
   // Returns the number of replacements made.
-  static int GlobalReplace(string* str,
+  static int GlobalReplace(std::string* str,
                            const RE2& re,
-                           const StringPiece& rewrite);
+                           absl::string_view rewrite);
 
   // Like Replace, except that if the pattern matches, "rewrite"
   // is copied into "out" with substitutions.  The non-matching
@@ -438,18 +495,18 @@ class RE2 {
   // successfully;  if no match occurs, the string is left unaffected.
   //
   // REQUIRES: "text" must not alias any part of "*out".
-  static bool Extract(const StringPiece& text,
+  static bool Extract(absl::string_view text,
                       const RE2& re,
-                      const StringPiece& rewrite,
-                      string* out);
+                      absl::string_view rewrite,
+                      std::string* out);
 
   // Escapes all potentially meaningful regexp characters in
   // 'unquoted'.  The returned string, used as a regular expression,
-  // will exactly match the original string.  For example,
+  // will match exactly the original string.  For example,
   //           1.5-2.0?
   // may become:
   //           1\.5\-2\.0\?
-  static string QuoteMeta(const StringPiece& unquoted);
+  static std::string QuoteMeta(absl::string_view unquoted);
 
   // Computes range for any strings matching regexp. The min and max can in
   // some cases be arbitrarily precise, so the caller gets to specify the
@@ -465,7 +522,8 @@ class RE2 {
   // do not compile down to infinite repetitions.
   //
   // Returns true on success, false on error.
-  bool PossibleMatchRange(string* min, string* max, int maxlen) const;
+  bool PossibleMatchRange(std::string* min, std::string* max,
+                          int maxlen) const;
 
   // Generic matching interface
 
@@ -485,12 +543,12 @@ class RE2 {
   // The map records the index of the leftmost group
   // with the given name.
   // Only valid until the re is deleted.
-  const std::map<string, int>& NamedCapturingGroups() const;
+  const std::map<std::string, int>& NamedCapturingGroups() const;
 
   // Return a map from capturing indices to names.
   // The map has no entries for unnamed groups.
   // Only valid until the re is deleted.
-  const std::map<int, string>& CapturingGroupNames() const;
+  const std::map<int, std::string>& CapturingGroupNames() const;
 
   // General matching routine.
   // Match against text starting at offset startpos
@@ -509,15 +567,15 @@ class RE2 {
   // Doesn't make sense to use nsubmatch > 1 + NumberOfCapturingGroups(),
   // but will be handled correctly.
   //
-  // Passing text == StringPiece(NULL, 0) will be handled like any other
+  // Passing text == absl::string_view() will be handled like any other
   // empty string, but note that on return, it will not be possible to tell
   // whether submatch i matched the empty string or did not match:
   // either way, submatch[i].data() == NULL.
-  bool Match(const StringPiece& text,
+  bool Match(absl::string_view text,
              size_t startpos,
              size_t endpos,
              Anchor re_anchor,
-             StringPiece* submatch,
+             absl::string_view* submatch,
              int nsubmatch) const;
 
   // Check that the given rewrite string is suitable for use with this
@@ -528,20 +586,21 @@ class RE2 {
   //     '\' followed by anything other than a digit or '\'.
   // A true return value guarantees that Replace() and Extract() won't
   // fail because of a bad rewrite string.
-  bool CheckRewriteString(const StringPiece& rewrite, string* error) const;
+  bool CheckRewriteString(absl::string_view rewrite,
+                          std::string* error) const;
 
   // Returns the maximum submatch needed for the rewrite to be done by
   // Replace(). E.g. if rewrite == "foo \\2,\\1", returns 2.
-  static int MaxSubmatch(const StringPiece& rewrite);
+  static int MaxSubmatch(absl::string_view rewrite);
 
-  // Append the "rewrite" string, with backslash subsitutions from "vec",
+  // Append the "rewrite" string, with backslash substitutions from "vec",
   // to string "out".
   // Returns true on success.  This method can fail because of a malformed
   // rewrite string.  CheckRewriteString guarantees that the rewrite will
   // be sucessful.
-  bool Rewrite(string* out,
-               const StringPiece& rewrite,
-               const StringPiece* vec,
+  bool Rewrite(std::string* out,
+               absl::string_view rewrite,
+               const absl::string_view* vec,
                int veclen) const;
 
   // Constructor options
@@ -606,11 +665,11 @@ class RE2 {
     };
 
     Options() :
+      max_mem_(kDefaultMaxMem),
       encoding_(EncodingUTF8),
       posix_syntax_(false),
       longest_match_(false),
       log_errors_(true),
-      max_mem_(kDefaultMaxMem),
       literal_(false),
       never_nl_(false),
       dot_nl_(false),
@@ -623,20 +682,12 @@ class RE2 {
 
     /*implicit*/ Options(CannedOptions);
 
+    int64_t max_mem() const { return max_mem_; }
+    void set_max_mem(int64_t m) { max_mem_ = m; }
+
     Encoding encoding() const { return encoding_; }
     void set_encoding(Encoding encoding) { encoding_ = encoding; }
 
-    // Legacy interface to encoding.
-    // TODO(rsc): Remove once clients have been converted.
-    bool utf8() const { return encoding_ == EncodingUTF8; }
-    void set_utf8(bool b) {
-      if (b) {
-        encoding_ = EncodingUTF8;
-      } else {
-        encoding_ = EncodingLatin1;
-      }
-    }
-
     bool posix_syntax() const { return posix_syntax_; }
     void set_posix_syntax(bool b) { posix_syntax_ = b; }
 
@@ -646,9 +697,6 @@ class RE2 {
     bool log_errors() const { return log_errors_; }
     void set_log_errors(bool b) { log_errors_ = b; }
 
-    int64_t max_mem() const { return max_mem_; }
-    void set_max_mem(int64_t m) { max_mem_ = m; }
-
     bool literal() const { return literal_; }
     void set_literal(bool b) { literal_ = b; }
 
@@ -680,11 +728,11 @@ class RE2 {
     int ParseFlags() const;
 
    private:
+    int64_t max_mem_;
     Encoding encoding_;
     bool posix_syntax_;
     bool longest_match_;
     bool log_errors_;
-    int64_t max_mem_;
     bool literal_;
     bool never_nl_;
     bool dot_nl_;
@@ -699,37 +747,21 @@ class RE2 {
   const Options& options() const { return options_; }
 
   // Argument converters; see below.
-  static inline Arg CRadix(short* x);
-  static inline Arg CRadix(unsigned short* x);
-  static inline Arg CRadix(int* x);
-  static inline Arg CRadix(unsigned int* x);
-  static inline Arg CRadix(long* x);
-  static inline Arg CRadix(unsigned long* x);
-  static inline Arg CRadix(long long* x);
-  static inline Arg CRadix(unsigned long long* x);
-
-  static inline Arg Hex(short* x);
-  static inline Arg Hex(unsigned short* x);
-  static inline Arg Hex(int* x);
-  static inline Arg Hex(unsigned int* x);
-  static inline Arg Hex(long* x);
-  static inline Arg Hex(unsigned long* x);
-  static inline Arg Hex(long long* x);
-  static inline Arg Hex(unsigned long long* x);
-
-  static inline Arg Octal(short* x);
-  static inline Arg Octal(unsigned short* x);
-  static inline Arg Octal(int* x);
-  static inline Arg Octal(unsigned int* x);
-  static inline Arg Octal(long* x);
-  static inline Arg Octal(unsigned long* x);
-  static inline Arg Octal(long long* x);
-  static inline Arg Octal(unsigned long long* x);
+  template <typename T>
+  static Arg CRadix(T* ptr);
+  template <typename T>
+  static Arg Hex(T* ptr);
+  template <typename T>
+  static Arg Octal(T* ptr);
+
+  // Controls the maximum count permitted by GlobalReplace(); -1 is unlimited.
+  // FOR FUZZING ONLY.
+  static void FUZZING_ONLY_set_maximum_global_replace_count(int i);
 
  private:
-  void Init(const StringPiece& pattern, const Options& options);
+  void Init(absl::string_view pattern, const Options& options);
 
-  bool DoMatch(const StringPiece& text,
+  bool DoMatch(absl::string_view text,
                Anchor re_anchor,
                size_t* consumed,
                const Arg* const args[],
@@ -737,170 +769,201 @@ class RE2 {
 
   re2::Prog* ReverseProg() const;
 
-  string        pattern_;          // string regular expression
-  Options       options_;          // option flags
-  string        prefix_;           // required prefix (before regexp_)
-  bool          prefix_foldcase_;  // prefix is ASCII case-insensitive
-  re2::Regexp*  entire_regexp_;    // parsed regular expression
-  re2::Regexp*  suffix_regexp_;    // parsed regular expression, prefix removed
-  re2::Prog*    prog_;             // compiled program for regexp
-  int           num_captures_;     // Number of capturing groups
-  bool          is_one_pass_;      // can use prog_->SearchOnePass?
-
-  mutable re2::Prog*     rprog_;         // reverse program for regexp
-  mutable const string*  error_;         // Error indicator
-                                         // (or points to empty string)
-  mutable ErrorCode      error_code_;    // Error code
-  mutable string         error_arg_;     // Fragment of regexp showing error
-
+  // First cache line is relatively cold fields.
+  const std::string* pattern_;    // string regular expression
+  Options options_;               // option flags
+  re2::Regexp* entire_regexp_;    // parsed regular expression
+  re2::Regexp* suffix_regexp_;    // parsed regular expression, prefix_ removed
+  const std::string* error_;      // error indicator (or points to empty string)
+  const std::string* error_arg_;  // fragment of regexp showing error (or ditto)
+
+  // Second cache line is relatively hot fields.
+  // These are ordered oddly to pack everything.
+  int num_captures_;              // number of capturing groups
+  ErrorCode error_code_ : 29;     // error code (29 bits is more than enough)
+  bool longest_match_ : 1;        // cached copy of options_.longest_match()
+  bool is_one_pass_ : 1;          // can use prog_->SearchOnePass?
+  bool prefix_foldcase_ : 1;      // prefix_ is ASCII case-insensitive
+  std::string prefix_;            // required prefix (before suffix_regexp_)
+  re2::Prog* prog_;               // compiled program for regexp
+
+  // Reverse Prog for DFA execution only
+  mutable re2::Prog* rprog_;
   // Map from capture names to indices
-  mutable const std::map<string, int>* named_groups_;
-
+  mutable const std::map<std::string, int>* named_groups_;
   // Map from capture indices to names
-  mutable const std::map<int, string>* group_names_;
-
-  // Onces for lazy computations.
-  mutable std::once_flag rprog_once_;
-  mutable std::once_flag named_groups_once_;
-  mutable std::once_flag group_names_once_;
+  mutable const std::map<int, std::string>* group_names_;
 
-  RE2(const RE2&) = delete;
-  RE2& operator=(const RE2&) = delete;
+  mutable absl::once_flag rprog_once_;
+  mutable absl::once_flag named_groups_once_;
+  mutable absl::once_flag group_names_once_;
 };
 
 /***** Implementation details *****/
 
-// Hex/Octal/Binary?
+namespace re2_internal {
+
+// Types for which the 3-ary Parse() function template has specializations.
+template <typename T> struct Parse3ary : public std::false_type {};
+template <> struct Parse3ary<void> : public std::true_type {};
+template <> struct Parse3ary<std::string> : public std::true_type {};
+template <> struct Parse3ary<absl::string_view> : public std::true_type {};
+template <> struct Parse3ary<char> : public std::true_type {};
+template <> struct Parse3ary<signed char> : public std::true_type {};
+template <> struct Parse3ary<unsigned char> : public std::true_type {};
+template <> struct Parse3ary<float> : public std::true_type {};
+template <> struct Parse3ary<double> : public std::true_type {};
+
+template <typename T>
+bool Parse(const char* str, size_t n, T* dest);
+
+// Types for which the 4-ary Parse() function template has specializations.
+template <typename T> struct Parse4ary : public std::false_type {};
+template <> struct Parse4ary<long> : public std::true_type {};
+template <> struct Parse4ary<unsigned long> : public std::true_type {};
+template <> struct Parse4ary<short> : public std::true_type {};
+template <> struct Parse4ary<unsigned short> : public std::true_type {};
+template <> struct Parse4ary<int> : public std::true_type {};
+template <> struct Parse4ary<unsigned int> : public std::true_type {};
+template <> struct Parse4ary<long long> : public std::true_type {};
+template <> struct Parse4ary<unsigned long long> : public std::true_type {};
+
+template <typename T>
+bool Parse(const char* str, size_t n, T* dest, int radix);
+
+// Support absl::optional<T> for all T with a stock parser.
+template <typename T> struct Parse3ary<absl::optional<T>> : public Parse3ary<T> {};
+template <typename T> struct Parse4ary<absl::optional<T>> : public Parse4ary<T> {};
+
+template <typename T>
+bool Parse(const char* str, size_t n, absl::optional<T>* dest) {
+  if (str == NULL) {
+    if (dest != NULL)
+      dest->reset();
+    return true;
+  }
+  T tmp;
+  if (Parse(str, n, &tmp)) {
+    if (dest != NULL)
+      dest->emplace(std::move(tmp));
+    return true;
+  }
+  return false;
+}
 
-// Special class for parsing into objects that define a ParseFrom() method
-template <class T>
-class _RE2_MatchObject {
- public:
-  static inline bool Parse(const char* str, size_t n, void* dest) {
-    if (dest == NULL) return true;
-    T* object = reinterpret_cast<T*>(dest);
-    return object->ParseFrom(str, n);
+template <typename T>
+bool Parse(const char* str, size_t n, absl::optional<T>* dest, int radix) {
+  if (str == NULL) {
+    if (dest != NULL)
+      dest->reset();
+    return true;
   }
-};
+  T tmp;
+  if (Parse(str, n, &tmp, radix)) {
+    if (dest != NULL)
+      dest->emplace(std::move(tmp));
+    return true;
+  }
+  return false;
+}
+
+}  // namespace re2_internal
 
 class RE2::Arg {
+ private:
+  template <typename T>
+  using CanParse3ary = typename std::enable_if<
+      re2_internal::Parse3ary<T>::value,
+      int>::type;
+
+  template <typename T>
+  using CanParse4ary = typename std::enable_if<
+      re2_internal::Parse4ary<T>::value,
+      int>::type;
+
+#if !defined(_MSC_VER)
+  template <typename T>
+  using CanParseFrom = typename std::enable_if<
+      std::is_member_function_pointer<
+          decltype(static_cast<bool (T::*)(const char*, size_t)>(
+              &T::ParseFrom))>::value,
+      int>::type;
+#endif
+
  public:
-  // Empty constructor so we can declare arrays of RE2::Arg
-  Arg();
+  Arg() : Arg(nullptr) {}
+  Arg(std::nullptr_t ptr) : arg_(ptr), parser_(DoNothing) {}
 
-  // Constructor specially designed for NULL arguments
-  Arg(void*);
-  Arg(std::nullptr_t);
+  template <typename T, CanParse3ary<T> = 0>
+  Arg(T* ptr) : arg_(ptr), parser_(DoParse3ary<T>) {}
 
-  typedef bool (*Parser)(const char* str, size_t n, void* dest);
+  template <typename T, CanParse4ary<T> = 0>
+  Arg(T* ptr) : arg_(ptr), parser_(DoParse4ary<T>) {}
 
-// Type-specific parsers
-#define MAKE_PARSER(type, name)            \
-  Arg(type* p) : arg_(p), parser_(name) {} \
-  Arg(type* p, Parser parser) : arg_(p), parser_(parser) {}
-
-  MAKE_PARSER(char,               parse_char)
-  MAKE_PARSER(signed char,        parse_schar)
-  MAKE_PARSER(unsigned char,      parse_uchar)
-  MAKE_PARSER(float,              parse_float)
-  MAKE_PARSER(double,             parse_double)
-  MAKE_PARSER(string,             parse_string)
-  MAKE_PARSER(StringPiece,        parse_stringpiece)
-
-  MAKE_PARSER(short,              parse_short)
-  MAKE_PARSER(unsigned short,     parse_ushort)
-  MAKE_PARSER(int,                parse_int)
-  MAKE_PARSER(unsigned int,       parse_uint)
-  MAKE_PARSER(long,               parse_long)
-  MAKE_PARSER(unsigned long,      parse_ulong)
-  MAKE_PARSER(long long,          parse_longlong)
-  MAKE_PARSER(unsigned long long, parse_ulonglong)
-
-#undef MAKE_PARSER
-
-  // Generic constructor templates
-  template <class T> Arg(T* p)
-      : arg_(p), parser_(_RE2_MatchObject<T>::Parse) { }
-  template <class T> Arg(T* p, Parser parser)
-      : arg_(p), parser_(parser) { }
-
-  // Parse the data
-  bool Parse(const char* str, size_t n) const;
+#if !defined(_MSC_VER)
+  template <typename T, CanParseFrom<T> = 0>
+  Arg(T* ptr) : arg_(ptr), parser_(DoParseFrom<T>) {}
+#endif
 
- private:
-  void*         arg_;
-  Parser        parser_;
+  typedef bool (*Parser)(const char* str, size_t n, void* dest);
 
-  static bool parse_null          (const char* str, size_t n, void* dest);
-  static bool parse_char          (const char* str, size_t n, void* dest);
-  static bool parse_schar         (const char* str, size_t n, void* dest);
-  static bool parse_uchar         (const char* str, size_t n, void* dest);
-  static bool parse_float         (const char* str, size_t n, void* dest);
-  static bool parse_double        (const char* str, size_t n, void* dest);
-  static bool parse_string        (const char* str, size_t n, void* dest);
-  static bool parse_stringpiece   (const char* str, size_t n, void* dest);
-
-#define DECLARE_INTEGER_PARSER(name)                                       \
- private:                                                                  \
-  static bool parse_##name(const char* str, size_t n, void* dest);         \
-  static bool parse_##name##_radix(const char* str, size_t n, void* dest,  \
-                                   int radix);                             \
-                                                                           \
- public:                                                                   \
-  static bool parse_##name##_hex(const char* str, size_t n, void* dest);   \
-  static bool parse_##name##_octal(const char* str, size_t n, void* dest); \
-  static bool parse_##name##_cradix(const char* str, size_t n, void* dest);
-
-  DECLARE_INTEGER_PARSER(short)
-  DECLARE_INTEGER_PARSER(ushort)
-  DECLARE_INTEGER_PARSER(int)
-  DECLARE_INTEGER_PARSER(uint)
-  DECLARE_INTEGER_PARSER(long)
-  DECLARE_INTEGER_PARSER(ulong)
-  DECLARE_INTEGER_PARSER(longlong)
-  DECLARE_INTEGER_PARSER(ulonglong)
-
-#undef DECLARE_INTEGER_PARSER
+  template <typename T>
+  Arg(T* ptr, Parser parser) : arg_(ptr), parser_(parser) {}
 
-};
+  bool Parse(const char* str, size_t n) const {
+    return (*parser_)(str, n, arg_);
+  }
 
-inline RE2::Arg::Arg() : arg_(NULL), parser_(parse_null) { }
-inline RE2::Arg::Arg(void* p) : arg_(p), parser_(parse_null) { }
-inline RE2::Arg::Arg(std::nullptr_t p) : arg_(p), parser_(parse_null) { }
+ private:
+  static bool DoNothing(const char* /*str*/, size_t /*n*/, void* /*dest*/) {
+    return true;
+  }
 
-inline bool RE2::Arg::Parse(const char* str, size_t n) const {
-  return (*parser_)(str, n, arg_);
-}
+  template <typename T>
+  static bool DoParse3ary(const char* str, size_t n, void* dest) {
+    return re2_internal::Parse(str, n, reinterpret_cast<T*>(dest));
+  }
 
-// This part of the parser, appropriate only for ints, deals with bases
-#define MAKE_INTEGER_PARSER(type, name)                    \
-  inline RE2::Arg RE2::Hex(type* ptr) {                    \
-    return RE2::Arg(ptr, RE2::Arg::parse_##name##_hex);    \
-  }                                                        \
-  inline RE2::Arg RE2::Octal(type* ptr) {                  \
-    return RE2::Arg(ptr, RE2::Arg::parse_##name##_octal);  \
-  }                                                        \
-  inline RE2::Arg RE2::CRadix(type* ptr) {                 \
-    return RE2::Arg(ptr, RE2::Arg::parse_##name##_cradix); \
+  template <typename T>
+  static bool DoParse4ary(const char* str, size_t n, void* dest) {
+    return re2_internal::Parse(str, n, reinterpret_cast<T*>(dest), 10);
   }
 
-MAKE_INTEGER_PARSER(short,              short)
-MAKE_INTEGER_PARSER(unsigned short,     ushort)
-MAKE_INTEGER_PARSER(int,                int)
-MAKE_INTEGER_PARSER(unsigned int,       uint)
-MAKE_INTEGER_PARSER(long,               long)
-MAKE_INTEGER_PARSER(unsigned long,      ulong)
-MAKE_INTEGER_PARSER(long long,          longlong)
-MAKE_INTEGER_PARSER(unsigned long long, ulonglong)
+#if !defined(_MSC_VER)
+  template <typename T>
+  static bool DoParseFrom(const char* str, size_t n, void* dest) {
+    if (dest == NULL) return true;
+    return reinterpret_cast<T*>(dest)->ParseFrom(str, n);
+  }
+#endif
+
+  void*         arg_;
+  Parser        parser_;
+};
+
+template <typename T>
+inline RE2::Arg RE2::CRadix(T* ptr) {
+  return RE2::Arg(ptr, [](const char* str, size_t n, void* dest) -> bool {
+    return re2_internal::Parse(str, n, reinterpret_cast<T*>(dest), 0);
+  });
+}
 
-#undef MAKE_INTEGER_PARSER
+template <typename T>
+inline RE2::Arg RE2::Hex(T* ptr) {
+  return RE2::Arg(ptr, [](const char* str, size_t n, void* dest) -> bool {
+    return re2_internal::Parse(str, n, reinterpret_cast<T*>(dest), 16);
+  });
+}
 
-#ifndef SWIG
+template <typename T>
+inline RE2::Arg RE2::Octal(T* ptr) {
+  return RE2::Arg(ptr, [](const char* str, size_t n, void* dest) -> bool {
+    return re2_internal::Parse(str, n, reinterpret_cast<T*>(dest), 8);
+  });
+}
 
 // Silence warnings about missing initializers for members of LazyRE2.
-// Note that we test for Clang first because it defines __GNUC__ as well.
-#if defined(__clang__)
-#elif defined(__GNUC__) && __GNUC__ >= 6
+#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 6
 #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
 #endif
 
@@ -930,7 +993,7 @@ class LazyRE2 {
 
   // Named accessor/initializer:
   RE2* get() const {
-    std::call_once(once_, &LazyRE2::Init, this);
+    absl::call_once(once_, &LazyRE2::Init, this);
     return ptr_;
   }
 
@@ -940,7 +1003,7 @@ class LazyRE2 {
   NoArg barrier_against_excess_initializers_;
 
   mutable RE2* ptr_;
-  mutable std::once_flag once_;
+  mutable absl::once_flag once_;
 
  private:
   static void Init(const LazyRE2* lazy_re2) {
@@ -949,7 +1012,54 @@ class LazyRE2 {
 
   void operator=(const LazyRE2&);  // disallowed
 };
-#endif  // SWIG
+
+namespace hooks {
+
+// Most platforms support thread_local. Older versions of iOS don't support
+// thread_local, but for the sake of brevity, we lump together all versions
+// of Apple platforms that aren't macOS. If an iOS application really needs
+// the context pointee someday, we can get more specific then...
+//
+// As per https://github.com/google/re2/issues/325, thread_local support in
+// MinGW seems to be buggy. (FWIW, Abseil folks also avoid it.)
+#define RE2_HAVE_THREAD_LOCAL
+#if (defined(__APPLE__) && !(defined(TARGET_OS_OSX) && TARGET_OS_OSX)) || defined(__MINGW32__)
+#undef RE2_HAVE_THREAD_LOCAL
+#endif
+
+// A hook must not make any assumptions regarding the lifetime of the context
+// pointee beyond the current invocation of the hook. Pointers and references
+// obtained via the context pointee should be considered invalidated when the
+// hook returns. Hence, any data about the context pointee (e.g. its pattern)
+// would have to be copied in order for it to be kept for an indefinite time.
+//
+// A hook must not use RE2 for matching. Control flow reentering RE2::Match()
+// could result in infinite mutual recursion. To discourage that possibility,
+// RE2 will not maintain the context pointer correctly when used in that way.
+#ifdef RE2_HAVE_THREAD_LOCAL
+extern thread_local const RE2* context;
+#endif
+
+struct DFAStateCacheReset {
+  int64_t state_budget;
+  size_t state_cache_size;
+};
+
+struct DFASearchFailure {
+  // Nothing yet...
+};
+
+#define DECLARE_HOOK(type)                  \
+  using type##Callback = void(const type&); \
+  void Set##type##Hook(type##Callback* cb); \
+  type##Callback* Get##type##Hook();
+
+DECLARE_HOOK(DFAStateCacheReset)
+DECLARE_HOOK(DFASearchFailure)
+
+#undef DECLARE_HOOK
+
+}  // namespace hooks
 
 }  // namespace re2
 
diff --git a/re2/regexp.cc b/re2/regexp.cc
index 7cfbbcb..3cfb5ae 100644
--- a/re2/regexp.cc
+++ b/re2/regexp.cc
@@ -12,15 +12,15 @@
 #include <string.h>
 #include <algorithm>
 #include <map>
-#include <mutex>
 #include <string>
 #include <vector>
 
-#include "util/util.h"
+#include "absl/base/call_once.h"
+#include "absl/base/macros.h"
+#include "absl/synchronization/mutex.h"
 #include "util/logging.h"
-#include "util/mutex.h"
 #include "util/utf.h"
-#include "re2/stringpiece.h"
+#include "re2/pod_array.h"
 #include "re2/walker-inl.h"
 
 namespace re2 {
@@ -73,35 +73,45 @@ bool Regexp::QuickDestroy() {
   return false;
 }
 
-// Lazily allocated.
-static Mutex* ref_mutex;
-static std::map<Regexp*, int>* ref_map;
+// Similar to EmptyStorage in re2.cc.
+struct RefStorage {
+  absl::Mutex ref_mutex;
+  std::map<Regexp*, int> ref_map;
+};
+alignas(RefStorage) static char ref_storage[sizeof(RefStorage)];
+
+static inline absl::Mutex* ref_mutex() {
+  return &reinterpret_cast<RefStorage*>(ref_storage)->ref_mutex;
+}
+
+static inline std::map<Regexp*, int>* ref_map() {
+  return &reinterpret_cast<RefStorage*>(ref_storage)->ref_map;
+}
 
 int Regexp::Ref() {
   if (ref_ < kMaxRef)
     return ref_;
 
-  MutexLock l(ref_mutex);
-  return (*ref_map)[this];
+  absl::MutexLock l(ref_mutex());
+  return (*ref_map())[this];
 }
 
 // Increments reference count, returns object as convenience.
 Regexp* Regexp::Incref() {
   if (ref_ >= kMaxRef-1) {
-    static std::once_flag ref_once;
-    std::call_once(ref_once, []() {
-      ref_mutex = new Mutex;
-      ref_map = new std::map<Regexp*, int>;
+    static absl::once_flag ref_once;
+    absl::call_once(ref_once, []() {
+      (void) new (ref_storage) RefStorage;
     });
 
     // Store ref count in overflow map.
-    MutexLock l(ref_mutex);
+    absl::MutexLock l(ref_mutex());
     if (ref_ == kMaxRef) {
       // already overflowed
-      (*ref_map)[this]++;
+      (*ref_map())[this]++;
     } else {
       // overflowing now
-      (*ref_map)[this] = kMaxRef;
+      (*ref_map())[this] = kMaxRef;
       ref_ = kMaxRef;
     }
     return this;
@@ -115,13 +125,13 @@ Regexp* Regexp::Incref() {
 void Regexp::Decref() {
   if (ref_ == kMaxRef) {
     // Ref count is stored in overflow map.
-    MutexLock l(ref_mutex);
-    int r = (*ref_map)[this] - 1;
+    absl::MutexLock l(ref_mutex());
+    int r = (*ref_map())[this] - 1;
     if (r < kMaxRef) {
       ref_ = static_cast<uint16_t>(r);
-      ref_map->erase(this);
+      ref_map()->erase(this);
     } else {
-      (*ref_map)[this] = r;
+      (*ref_map())[this] = r;
     }
     return;
   }
@@ -243,16 +253,15 @@ Regexp* Regexp::ConcatOrAlternate(RegexpOp op, Regexp** sub, int nsub,
       return new Regexp(kRegexpEmptyMatch, flags);
   }
 
-  Regexp** subcopy = NULL;
+  PODArray<Regexp*> subcopy;
   if (op == kRegexpAlternate && can_factor) {
     // Going to edit sub; make a copy so we don't step on caller.
-    subcopy = new Regexp*[nsub];
-    memmove(subcopy, sub, nsub * sizeof sub[0]);
-    sub = subcopy;
+    subcopy = PODArray<Regexp*>(nsub);
+    memmove(subcopy.data(), sub, nsub * sizeof sub[0]);
+    sub = subcopy.data();
     nsub = FactorAlternation(sub, nsub, flags);
     if (nsub == 1) {
       Regexp* re = sub[0];
-      delete[] subcopy;
       return re;
     }
   }
@@ -269,7 +278,6 @@ Regexp* Regexp::ConcatOrAlternate(RegexpOp op, Regexp** sub, int nsub,
     subs[nbigsub - 1] = ConcatOrAlternate(op, sub+(nbigsub-1)*kMaxNsub,
                                           nsub - (nbigsub-1)*kMaxNsub, flags,
                                           false);
-    delete[] subcopy;
     return re;
   }
 
@@ -278,8 +286,6 @@ Regexp* Regexp::ConcatOrAlternate(RegexpOp op, Regexp** sub, int nsub,
   Regexp** subs = re->sub();
   for (int i = 0; i < nsub; i++)
     subs[i] = sub[i];
-
-  delete[] subcopy;
   return re;
 }
 
@@ -501,6 +507,7 @@ static const char *kErrorStrings[] = {
   "invalid character class range",
   "missing ]",
   "missing )",
+  "unexpected )",
   "trailing \\",
   "no argument for repetition operator",
   "invalid repetition size",
@@ -510,16 +517,16 @@ static const char *kErrorStrings[] = {
   "invalid named capture group",
 };
 
-string RegexpStatus::CodeText(enum RegexpStatusCode code) {
-  if (code < 0 || code >= arraysize(kErrorStrings))
+std::string RegexpStatus::CodeText(enum RegexpStatusCode code) {
+  if (code < 0 || code >= ABSL_ARRAYSIZE(kErrorStrings))
     code = kRegexpInternalError;
   return kErrorStrings[code];
 }
 
-string RegexpStatus::Text() const {
+std::string RegexpStatus::Text() const {
   if (error_arg_.empty())
     return CodeText(code_);
-  string s;
+  std::string s;
   s.append(CodeText(code_));
   s.append(": ");
   s.append(error_arg_.data(), error_arg_.size());
@@ -544,9 +551,12 @@ class NumCapturesWalker : public Regexp::Walker<Ignored> {
       ncapture_++;
     return ignored;
   }
+
   virtual Ignored ShortVisit(Regexp* re, Ignored ignored) {
-    // Should never be called: we use Walk not WalkExponential.
+    // Should never be called: we use Walk(), not WalkExponential().
+#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
     LOG(DFATAL) << "NumCapturesWalker::ShortVisit called";
+#endif
     return ignored;
   }
 
@@ -569,41 +579,42 @@ class NamedCapturesWalker : public Regexp::Walker<Ignored> {
   NamedCapturesWalker() : map_(NULL) {}
   ~NamedCapturesWalker() { delete map_; }
 
-  std::map<string, int>* TakeMap() {
-    std::map<string, int>* m = map_;
+  std::map<std::string, int>* TakeMap() {
+    std::map<std::string, int>* m = map_;
     map_ = NULL;
     return m;
   }
 
-  Ignored PreVisit(Regexp* re, Ignored ignored, bool* stop) {
+  virtual Ignored PreVisit(Regexp* re, Ignored ignored, bool* stop) {
     if (re->op() == kRegexpCapture && re->name() != NULL) {
       // Allocate map once we find a name.
       if (map_ == NULL)
-        map_ = new std::map<string, int>;
+        map_ = new std::map<std::string, int>;
 
       // Record first occurrence of each name.
       // (The rule is that if you have the same name
       // multiple times, only the leftmost one counts.)
-      if (map_->find(*re->name()) == map_->end())
-        (*map_)[*re->name()] = re->cap();
+      map_->insert({*re->name(), re->cap()});
     }
     return ignored;
   }
 
   virtual Ignored ShortVisit(Regexp* re, Ignored ignored) {
-    // Should never be called: we use Walk not WalkExponential.
+    // Should never be called: we use Walk(), not WalkExponential().
+#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
     LOG(DFATAL) << "NamedCapturesWalker::ShortVisit called";
+#endif
     return ignored;
   }
 
  private:
-  std::map<string, int>* map_;
+  std::map<std::string, int>* map_;
 
   NamedCapturesWalker(const NamedCapturesWalker&) = delete;
   NamedCapturesWalker& operator=(const NamedCapturesWalker&) = delete;
 };
 
-std::map<string, int>* Regexp::NamedCaptures() {
+std::map<std::string, int>* Regexp::NamedCaptures() {
   NamedCapturesWalker w;
   w.Walk(this, 0);
   return w.TakeMap();
@@ -615,17 +626,17 @@ class CaptureNamesWalker : public Regexp::Walker<Ignored> {
   CaptureNamesWalker() : map_(NULL) {}
   ~CaptureNamesWalker() { delete map_; }
 
-  std::map<int, string>* TakeMap() {
-    std::map<int, string>* m = map_;
+  std::map<int, std::string>* TakeMap() {
+    std::map<int, std::string>* m = map_;
     map_ = NULL;
     return m;
   }
 
-  Ignored PreVisit(Regexp* re, Ignored ignored, bool* stop) {
+  virtual Ignored PreVisit(Regexp* re, Ignored ignored, bool* stop) {
     if (re->op() == kRegexpCapture && re->name() != NULL) {
       // Allocate map once we find a name.
       if (map_ == NULL)
-        map_ = new std::map<int, string>;
+        map_ = new std::map<int, std::string>;
 
       (*map_)[re->cap()] = *re->name();
     }
@@ -633,95 +644,109 @@ class CaptureNamesWalker : public Regexp::Walker<Ignored> {
   }
 
   virtual Ignored ShortVisit(Regexp* re, Ignored ignored) {
-    // Should never be called: we use Walk not WalkExponential.
+    // Should never be called: we use Walk(), not WalkExponential().
+#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
     LOG(DFATAL) << "CaptureNamesWalker::ShortVisit called";
+#endif
     return ignored;
   }
 
  private:
-  std::map<int, string>* map_;
+  std::map<int, std::string>* map_;
 
   CaptureNamesWalker(const CaptureNamesWalker&) = delete;
   CaptureNamesWalker& operator=(const CaptureNamesWalker&) = delete;
 };
 
-std::map<int, string>* Regexp::CaptureNames() {
+std::map<int, std::string>* Regexp::CaptureNames() {
   CaptureNamesWalker w;
   w.Walk(this, 0);
   return w.TakeMap();
 }
 
+void ConvertRunesToBytes(bool latin1, Rune* runes, int nrunes,
+                         std::string* bytes) {
+  if (latin1) {
+    bytes->resize(nrunes);
+    for (int i = 0; i < nrunes; i++)
+      (*bytes)[i] = static_cast<char>(runes[i]);
+  } else {
+    bytes->resize(nrunes * UTFmax);  // worst case
+    char* p = &(*bytes)[0];
+    for (int i = 0; i < nrunes; i++)
+      p += runetochar(p, &runes[i]);
+    bytes->resize(p - &(*bytes)[0]);
+    bytes->shrink_to_fit();
+  }
+}
+
 // Determines whether regexp matches must be anchored
 // with a fixed string prefix.  If so, returns the prefix and
 // the regexp that remains after the prefix.  The prefix might
 // be ASCII case-insensitive.
-bool Regexp::RequiredPrefix(string* prefix, bool* foldcase, Regexp** suffix) {
+bool Regexp::RequiredPrefix(std::string* prefix, bool* foldcase,
+                            Regexp** suffix) {
+  prefix->clear();
+  *foldcase = false;
+  *suffix = NULL;
+
   // No need for a walker: the regexp must be of the form
   // 1. some number of ^ anchors
   // 2. a literal char or string
   // 3. the rest
-  prefix->clear();
-  *foldcase = false;
-  *suffix = NULL;
   if (op_ != kRegexpConcat)
     return false;
-
-  // Some number of anchors, then a literal or concatenation.
   int i = 0;
-  Regexp** sub = this->sub();
-  while (i < nsub_ && sub[i]->op_ == kRegexpBeginText)
+  while (i < nsub_ && sub()[i]->op_ == kRegexpBeginText)
     i++;
   if (i == 0 || i >= nsub_)
     return false;
-
-  Regexp* re = sub[i];
-  switch (re->op_) {
-    default:
-      return false;
-
-    case kRegexpLiteralString:
-      // Convert to string in proper encoding.
-      if (re->parse_flags() & Latin1) {
-        prefix->resize(re->nrunes_);
-        for (int j = 0; j < re->nrunes_; j++)
-          (*prefix)[j] = static_cast<char>(re->runes_[j]);
-      } else {
-        // Convert to UTF-8 in place.
-        // Assume worst-case space and then trim.
-        prefix->resize(re->nrunes_ * UTFmax);
-        char *p = &(*prefix)[0];
-        for (int j = 0; j < re->nrunes_; j++) {
-          Rune r = re->runes_[j];
-          if (r < Runeself)
-            *p++ = static_cast<char>(r);
-          else
-            p += runetochar(p, &r);
-        }
-        prefix->resize(p - &(*prefix)[0]);
-      }
-      break;
-
-    case kRegexpLiteral:
-      if ((re->parse_flags() & Latin1) || re->rune_ < Runeself) {
-        prefix->append(1, static_cast<char>(re->rune_));
-      } else {
-        char buf[UTFmax];
-        prefix->append(buf, runetochar(buf, &re->rune_));
-      }
-      break;
-  }
-  *foldcase = (sub[i]->parse_flags() & FoldCase) != 0;
+  Regexp* re = sub()[i];
+  if (re->op_ != kRegexpLiteral &&
+      re->op_ != kRegexpLiteralString)
+    return false;
   i++;
-
-  // The rest.
   if (i < nsub_) {
     for (int j = i; j < nsub_; j++)
-      sub[j]->Incref();
-    re = Concat(sub + i, nsub_ - i, parse_flags());
+      sub()[j]->Incref();
+    *suffix = Concat(sub() + i, nsub_ - i, parse_flags());
   } else {
-    re = new Regexp(kRegexpEmptyMatch, parse_flags());
+    *suffix = new Regexp(kRegexpEmptyMatch, parse_flags());
   }
-  *suffix = re;
+
+  bool latin1 = (re->parse_flags() & Latin1) != 0;
+  Rune* runes = re->op_ == kRegexpLiteral ? &re->rune_ : re->runes_;
+  int nrunes = re->op_ == kRegexpLiteral ? 1 : re->nrunes_;
+  ConvertRunesToBytes(latin1, runes, nrunes, prefix);
+  *foldcase = (re->parse_flags() & FoldCase) != 0;
+  return true;
+}
+
+// Determines whether regexp matches must be unanchored
+// with a fixed string prefix.  If so, returns the prefix.
+// The prefix might be ASCII case-insensitive.
+bool Regexp::RequiredPrefixForAccel(std::string* prefix, bool* foldcase) {
+  prefix->clear();
+  *foldcase = false;
+
+  // No need for a walker: the regexp must either begin with or be
+  // a literal char or string. We "see through" capturing groups,
+  // but make no effort to glue multiple prefix fragments together.
+  Regexp* re = op_ == kRegexpConcat && nsub_ > 0 ? sub()[0] : this;
+  while (re->op_ == kRegexpCapture) {
+    re = re->sub()[0];
+    if (re->op_ == kRegexpConcat && re->nsub_ > 0)
+      re = re->sub()[0];
+  }
+  if (re->op_ != kRegexpLiteral &&
+      re->op_ != kRegexpLiteralString)
+    return false;
+
+  bool latin1 = (re->parse_flags() & Latin1) != 0;
+  Rune* runes = re->op_ == kRegexpLiteral ? &re->rune_ : re->runes_;
+  int nrunes = re->op_ == kRegexpLiteral ? 1 : re->nrunes_;
+  ConvertRunesToBytes(latin1, runes, nrunes, prefix);
+  *foldcase = (re->parse_flags() & FoldCase) != 0;
   return true;
 }
 
@@ -902,7 +927,7 @@ void CharClassBuilder::Negate() {
 // The ranges are allocated in the same block as the header,
 // necessitating a special allocator and Delete method.
 
-CharClass* CharClass::New(int maxranges) {
+CharClass* CharClass::New(size_t maxranges) {
   CharClass* cc;
   uint8_t* data = new uint8_t[sizeof *cc + maxranges*sizeof cc->ranges_[0]];
   cc = reinterpret_cast<CharClass*>(data);
@@ -919,7 +944,7 @@ void CharClass::Delete() {
 }
 
 CharClass* CharClass::Negate() {
-  CharClass* cc = CharClass::New(nranges_+1);
+  CharClass* cc = CharClass::New(static_cast<size_t>(nranges_+1));
   cc->folds_ascii_ = folds_ascii_;
   cc->nrunes_ = Runemax + 1 - nrunes_;
   int n = 0;
@@ -938,7 +963,7 @@ CharClass* CharClass::Negate() {
   return cc;
 }
 
-bool CharClass::Contains(Rune r) {
+bool CharClass::Contains(Rune r) const {
   RuneRange* rr = ranges_;
   int n = nranges_;
   while (n > 0) {
@@ -956,7 +981,7 @@ bool CharClass::Contains(Rune r) {
 }
 
 CharClass* CharClassBuilder::GetCharClass() {
-  CharClass* cc = CharClass::New(static_cast<int>(ranges_.size()));
+  CharClass* cc = CharClass::New(ranges_.size());
   int n = 0;
   for (iterator it = begin(); it != end(); ++it)
     cc->ranges_[n++] = *it;
diff --git a/re2/regexp.h b/re2/regexp.h
index 2ca96cd..df49894 100644
--- a/re2/regexp.h
+++ b/re2/regexp.h
@@ -86,15 +86,15 @@
 // form accessible to clients, so that client code can analyze the
 // parsed regular expressions.
 
+#include <stddef.h>
 #include <stdint.h>
 #include <map>
 #include <set>
 #include <string>
 
-#include "util/util.h"
+#include "absl/strings/string_view.h"
 #include "util/logging.h"
 #include "util/utf.h"
-#include "re2/stringpiece.h"
 
 namespace re2 {
 
@@ -177,6 +177,7 @@ enum RegexpStatusCode {
   kRegexpBadCharRange,       // bad character class range
   kRegexpMissingBracket,     // missing closing ]
   kRegexpMissingParen,       // missing closing )
+  kRegexpUnexpectedParen,    // unexpected closing )
   kRegexpTrailingBackslash,  // at end of regexp
   kRegexpRepeatArgument,     // repeat argument missing, e.g. "*"
   kRegexpRepeatSize,         // bad repetition argument
@@ -193,10 +194,10 @@ class RegexpStatus {
   ~RegexpStatus() { delete tmp_; }
 
   void set_code(RegexpStatusCode code) { code_ = code; }
-  void set_error_arg(const StringPiece& error_arg) { error_arg_ = error_arg; }
-  void set_tmp(string* tmp) { delete tmp_; tmp_ = tmp; }
+  void set_error_arg(absl::string_view error_arg) { error_arg_ = error_arg; }
+  void set_tmp(std::string* tmp) { delete tmp_; tmp_ = tmp; }
   RegexpStatusCode code() const { return code_; }
-  const StringPiece& error_arg() const { return error_arg_; }
+  absl::string_view error_arg() const { return error_arg_; }
   bool ok() const { return code() == kRegexpSuccess; }
 
   // Copies state from status.
@@ -204,16 +205,16 @@ class RegexpStatus {
 
   // Returns text equivalent of code, e.g.:
   //   "Bad character class"
-  static string CodeText(RegexpStatusCode code);
+  static std::string CodeText(RegexpStatusCode code);
 
   // Returns text describing error, e.g.:
   //   "Bad character class: [z-a]"
-  string Text() const;
+  std::string Text() const;
 
  private:
-  RegexpStatusCode code_;  // Kind of error
-  StringPiece error_arg_;       // Piece of regexp containing syntax error.
-  string* tmp_;                 // Temporary storage, possibly where error_arg_ is.
+  RegexpStatusCode code_;        // Kind of error.
+  absl::string_view error_arg_;  // Piece of regexp containing syntax error.
+  std::string* tmp_;             // Temporary storage, possibly for error_arg_.
 
   RegexpStatus(const RegexpStatus&) = delete;
   RegexpStatus& operator=(const RegexpStatus&) = delete;
@@ -252,13 +253,13 @@ class CharClass {
   bool full() { return nrunes_ == Runemax+1; }
   bool FoldsASCII() { return folds_ascii_; }
 
-  bool Contains(Rune r);
+  bool Contains(Rune r) const;
   CharClass* Negate();
 
  private:
   CharClass();  // not implemented
   ~CharClass();  // not implemented
-  static CharClass* New(int maxranges);
+  static CharClass* New(size_t maxranges);
 
   friend class CharClassBuilder;
 
@@ -336,7 +337,7 @@ class Regexp {
   Rune rune() { DCHECK_EQ(op_, kRegexpLiteral); return rune_; }
   CharClass* cc() { DCHECK_EQ(op_, kRegexpCharClass); return cc_; }
   int cap() { DCHECK_EQ(op_, kRegexpCapture); return cap_; }
-  const string* name() { DCHECK_EQ(op_, kRegexpCapture); return name_; }
+  const std::string* name() { DCHECK_EQ(op_, kRegexpCapture); return name_; }
   Rune* runes() { DCHECK_EQ(op_, kRegexpLiteralString); return runes_; }
   int nrunes() { DCHECK_EQ(op_, kRegexpLiteralString); return nrunes_; }
   int match_id() { DCHECK_EQ(op_, kRegexpHaveMatch); return match_id_; }
@@ -350,7 +351,7 @@ class Regexp {
   // Parses string s to produce regular expression, returned.
   // Caller must release return value with re->Decref().
   // On failure, sets *status (if status != NULL) and returns NULL.
-  static Regexp* Parse(const StringPiece& s, ParseFlags flags,
+  static Regexp* Parse(absl::string_view s, ParseFlags flags,
                        RegexpStatus* status);
 
   // Returns a _new_ simplified version of the current regexp.
@@ -367,9 +368,8 @@ class Regexp {
   // Parses the regexp src and then simplifies it and sets *dst to the
   // string representation of the simplified form.  Returns true on success.
   // Returns false and sets *status (if status != NULL) on parse error.
-  static bool SimplifyRegexp(const StringPiece& src, ParseFlags flags,
-                             string* dst,
-                             RegexpStatus* status);
+  static bool SimplifyRegexp(absl::string_view src, ParseFlags flags,
+                             std::string* dst, RegexpStatus* status);
 
   // Returns the number of capturing groups in the regexp.
   int NumCaptures();
@@ -378,16 +378,16 @@ class Regexp {
   // Returns a map from names to capturing group indices,
   // or NULL if the regexp contains no named capture groups.
   // The caller is responsible for deleting the map.
-  std::map<string, int>* NamedCaptures();
+  std::map<std::string, int>* NamedCaptures();
 
   // Returns a map from capturing group indices to capturing group
   // names or NULL if the regexp contains no named capture groups. The
   // caller is responsible for deleting the map.
-  std::map<int, string>* CaptureNames();
+  std::map<int, std::string>* CaptureNames();
 
   // Returns a string representation of the current regexp,
   // using as few parentheses as possible.
-  string ToString();
+  std::string ToString();
 
   // Convenience functions.  They consume the passed reference,
   // so in many cases you should use, e.g., Plus(re->Incref(), flags).
@@ -409,7 +409,7 @@ class Regexp {
 
   // Debugging function.  Returns string format for regexp
   // that makes structure clear.  Does NOT use regexp syntax.
-  string Dump();
+  std::string Dump();
 
   // Helper traversal class, defined fully in walker-inl.h.
   template<typename T> class Walker;
@@ -438,7 +438,19 @@ class Regexp {
   // follows it.
   // Callers should expect *prefix, *foldcase and *suffix to be "zeroed"
   // regardless of the return value.
-  bool RequiredPrefix(string* prefix, bool* foldcase, Regexp** suffix);
+  bool RequiredPrefix(std::string* prefix, bool* foldcase,
+                      Regexp** suffix);
+
+  // Whether every match of this regexp must be unanchored and
+  // begin with a non-empty fixed string (perhaps after ASCII
+  // case-folding).  If so, returns the prefix.
+  // Callers should expect *prefix and *foldcase to be "zeroed"
+  // regardless of the return value.
+  bool RequiredPrefixForAccel(std::string* prefix, bool* foldcase);
+
+  // Controls the maximum repeat count permitted by the parser.
+  // FOR FUZZING ONLY.
+  static void FUZZING_ONLY_set_maximum_repeat_count(int i);
 
  private:
   // Constructor allocates vectors as appropriate for operator.
@@ -454,7 +466,7 @@ class Regexp {
   class ParseState;
 
   friend class ParseState;
-  friend bool ParseCharClass(StringPiece* s, Regexp** out_re,
+  friend bool ParseCharClass(absl::string_view* s, Regexp** out_re,
                              RegexpStatus* status);
 
   // Helper for testing [sic].
@@ -564,7 +576,7 @@ class Regexp {
     };
     struct {  // Capture
       int cap_;
-      string* name_;
+      std::string* name_;
     };
     struct {  // LiteralString
       int nrunes_;
diff --git a/re2/set.cc b/re2/set.cc
index 2572d50..b9c918e 100644
--- a/re2/set.cc
+++ b/re2/set.cc
@@ -7,33 +7,50 @@
 #include <stddef.h>
 #include <algorithm>
 #include <memory>
+#include <utility>
 
-#include "util/util.h"
 #include "util/logging.h"
-#include "util/pod_array.h"
-#include "re2/stringpiece.h"
+#include "re2/pod_array.h"
 #include "re2/prog.h"
 #include "re2/re2.h"
 #include "re2/regexp.h"
 
 namespace re2 {
 
-RE2::Set::Set(const RE2::Options& options, RE2::Anchor anchor) {
-  options_.Copy(options);
+RE2::Set::Set(const RE2::Options& options, RE2::Anchor anchor)
+    : options_(options),
+      anchor_(anchor),
+      compiled_(false),
+      size_(0) {
   options_.set_never_capture(true);  // might unblock some optimisations
-  anchor_ = anchor;
-  prog_ = NULL;
-  compiled_ = false;
-  size_ = 0;
 }
 
 RE2::Set::~Set() {
   for (size_t i = 0; i < elem_.size(); i++)
     elem_[i].second->Decref();
-  delete prog_;
 }
 
-int RE2::Set::Add(const StringPiece& pattern, string* error) {
+RE2::Set::Set(Set&& other)
+    : options_(other.options_),
+      anchor_(other.anchor_),
+      elem_(std::move(other.elem_)),
+      compiled_(other.compiled_),
+      size_(other.size_),
+      prog_(std::move(other.prog_)) {
+  other.elem_.clear();
+  other.elem_.shrink_to_fit();
+  other.compiled_ = false;
+  other.size_ = 0;
+  other.prog_.reset();
+}
+
+RE2::Set& RE2::Set::operator=(Set&& other) {
+  this->~Set();
+  (void) new (this) Set(std::move(other));
+  return *this;
+}
+
+int RE2::Set::Add(absl::string_view pattern, std::string* error) {
   if (compiled_) {
     LOG(DFATAL) << "RE2::Set::Add() called after compiling";
     return -1;
@@ -68,7 +85,7 @@ int RE2::Set::Add(const StringPiece& pattern, string* error) {
     sub[1] = m;
     re = re2::Regexp::Concat(sub, 2, pf);
   }
-  elem_.emplace_back(string(pattern), re);
+  elem_.emplace_back(std::string(pattern), re);
   return n;
 }
 
@@ -97,23 +114,26 @@ bool RE2::Set::Compile() {
     options_.ParseFlags());
   re2::Regexp* re = re2::Regexp::Alternate(sub.data(), size_, pf);
 
-  prog_ = Prog::CompileSet(re, anchor_, options_.max_mem());
+  prog_.reset(Prog::CompileSet(re, anchor_, options_.max_mem()));
   re->Decref();
-  return prog_ != NULL;
+  return prog_ != nullptr;
 }
 
-bool RE2::Set::Match(const StringPiece& text, std::vector<int>* v) const {
+bool RE2::Set::Match(absl::string_view text, std::vector<int>* v) const {
   return Match(text, v, NULL);
 }
 
-bool RE2::Set::Match(const StringPiece& text, std::vector<int>* v,
+bool RE2::Set::Match(absl::string_view text, std::vector<int>* v,
                      ErrorInfo* error_info) const {
   if (!compiled_) {
-    LOG(DFATAL) << "RE2::Set::Match() called before compiling";
     if (error_info != NULL)
       error_info->kind = kNotCompiled;
+    LOG(DFATAL) << "RE2::Set::Match() called before compiling";
     return false;
   }
+#ifdef RE2_HAVE_THREAD_LOCAL
+  hooks::context = NULL;
+#endif
   bool dfa_failed = false;
   std::unique_ptr<SparseSet> matches;
   if (v != NULL) {
@@ -124,9 +144,10 @@ bool RE2::Set::Match(const StringPiece& text, std::vector<int>* v,
                               NULL, &dfa_failed, matches.get());
   if (dfa_failed) {
     if (options_.log_errors())
-      LOG(ERROR) << "DFA out of memory: size " << prog_->size() << ", "
-                 << "bytemap range " << prog_->bytemap_range() << ", "
-                 << "list count " << prog_->list_count();
+      LOG(ERROR) << "DFA out of memory: "
+                 << "program size " << prog_->size() << ", "
+                 << "list count " << prog_->list_count() << ", "
+                 << "bytemap range " << prog_->bytemap_range();
     if (error_info != NULL)
       error_info->kind = kOutOfMemory;
     return false;
@@ -138,9 +159,9 @@ bool RE2::Set::Match(const StringPiece& text, std::vector<int>* v,
   }
   if (v != NULL) {
     if (matches->empty()) {
-      LOG(DFATAL) << "RE2::Set::Match() matched, but no matches returned?!";
       if (error_info != NULL)
         error_info->kind = kInconsistent;
+      LOG(DFATAL) << "RE2::Set::Match() matched, but no matches returned?!";
       return false;
     }
     v->assign(matches->begin(), matches->end());
diff --git a/re2/set.h b/re2/set.h
index a8c2caa..3fe419b 100644
--- a/re2/set.h
+++ b/re2/set.h
@@ -5,10 +5,12 @@
 #ifndef RE2_SET_H_
 #define RE2_SET_H_
 
+#include <memory>
 #include <string>
 #include <utility>
 #include <vector>
 
+#include "absl/strings/string_view.h"
 #include "re2/re2.h"
 
 namespace re2 {
@@ -36,13 +38,20 @@ class RE2::Set {
   Set(const RE2::Options& options, RE2::Anchor anchor);
   ~Set();
 
+  // Not copyable.
+  Set(const Set&) = delete;
+  Set& operator=(const Set&) = delete;
+  // Movable.
+  Set(Set&& other);
+  Set& operator=(Set&& other);
+
   // Adds pattern to the set using the options passed to the constructor.
   // Returns the index that will identify the regexp in the output of Match(),
   // or -1 if the regexp cannot be parsed.
   // Indices are assigned in sequential order starting from 0.
   // Errors do not increment the index; if error is not NULL, *error will hold
   // the error message from the parser.
-  int Add(const StringPiece& pattern, string* error);
+  int Add(absl::string_view pattern, std::string* error);
 
   // Compiles the set in preparation for matching.
   // Returns false if the compiler runs out of memory.
@@ -53,26 +62,23 @@ class RE2::Set {
   // Returns true if text matches at least one of the regexps in the set.
   // Fills v (if not NULL) with the indices of the matching regexps.
   // Callers must not expect v to be sorted.
-  bool Match(const StringPiece& text, std::vector<int>* v) const;
+  bool Match(absl::string_view text, std::vector<int>* v) const;
 
   // As above, but populates error_info (if not NULL) when none of the regexps
   // in the set matched. This can inform callers when DFA execution fails, for
   // example, because they might wish to handle that case differently.
-  bool Match(const StringPiece& text, std::vector<int>* v,
+  bool Match(absl::string_view text, std::vector<int>* v,
              ErrorInfo* error_info) const;
 
  private:
-  typedef std::pair<string, re2::Regexp*> Elem;
+  typedef std::pair<std::string, re2::Regexp*> Elem;
 
   RE2::Options options_;
   RE2::Anchor anchor_;
   std::vector<Elem> elem_;
-  re2::Prog* prog_;
   bool compiled_;
   int size_;
-
-  Set(const Set&) = delete;
-  Set& operator=(const Set&) = delete;
+  std::unique_ptr<re2::Prog> prog_;
 };
 
 }  // namespace re2
diff --git a/re2/simplify.cc b/re2/simplify.cc
index 7cc0419..8cd10cf 100644
--- a/re2/simplify.cc
+++ b/re2/simplify.cc
@@ -8,10 +8,9 @@
 
 #include <string>
 
-#include "util/util.h"
 #include "util/logging.h"
-#include "util/pod_array.h"
 #include "util/utf.h"
+#include "re2/pod_array.h"
 #include "re2/regexp.h"
 #include "re2/walker-inl.h"
 
@@ -20,17 +19,14 @@ namespace re2 {
 // Parses the regexp src and then simplifies it and sets *dst to the
 // string representation of the simplified form.  Returns true on success.
 // Returns false and sets *error (if error != NULL) on error.
-bool Regexp::SimplifyRegexp(const StringPiece& src, ParseFlags flags,
-                            string* dst,
-                            RegexpStatus* status) {
+bool Regexp::SimplifyRegexp(absl::string_view src, ParseFlags flags,
+                            std::string* dst, RegexpStatus* status) {
   Regexp* re = Parse(src, flags, status);
   if (re == NULL)
     return false;
   Regexp* sre = re->Simplify();
   re->Decref();
   if (sre == NULL) {
-    // Should not happen, since Simplify never fails.
-    LOG(ERROR) << "Simplify failed on " << src;
     if (status) {
       status->set_code(kRegexpInternalError);
       status->set_error_arg(src);
@@ -181,10 +177,20 @@ Regexp* Regexp::Simplify() {
   CoalesceWalker cw;
   Regexp* cre = cw.Walk(this, NULL);
   if (cre == NULL)
-    return cre;
+    return NULL;
+  if (cw.stopped_early()) {
+    cre->Decref();
+    return NULL;
+  }
   SimplifyWalker sw;
   Regexp* sre = sw.Walk(cre, NULL);
   cre->Decref();
+  if (sre == NULL)
+    return NULL;
+  if (sw.stopped_early()) {
+    sre->Decref();
+    return NULL;
+  }
   return sre;
 }
 
@@ -213,9 +219,10 @@ Regexp* CoalesceWalker::Copy(Regexp* re) {
 }
 
 Regexp* CoalesceWalker::ShortVisit(Regexp* re, Regexp* parent_arg) {
-  // This should never be called, since we use Walk and not
-  // WalkExponential.
+  // Should never be called: we use Walk(), not WalkExponential().
+#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
   LOG(DFATAL) << "CoalesceWalker::ShortVisit called";
+#endif
   return re->Incref();
 }
 
@@ -363,8 +370,8 @@ void CoalesceWalker::DoCoalesce(Regexp** r1ptr, Regexp** r2ptr) {
       break;
 
     default:
-      LOG(DFATAL) << "DoCoalesce failed: r1->op() is " << r1->op();
       nre->Decref();
+      LOG(DFATAL) << "DoCoalesce failed: r1->op() is " << r1->op();
       return;
   }
 
@@ -424,8 +431,8 @@ void CoalesceWalker::DoCoalesce(Regexp** r1ptr, Regexp** r2ptr) {
     }
 
     default:
-      LOG(DFATAL) << "DoCoalesce failed: r2->op() is " << r2->op();
       nre->Decref();
+      LOG(DFATAL) << "DoCoalesce failed: r2->op() is " << r2->op();
       return;
   }
 
@@ -438,9 +445,10 @@ Regexp* SimplifyWalker::Copy(Regexp* re) {
 }
 
 Regexp* SimplifyWalker::ShortVisit(Regexp* re, Regexp* parent_arg) {
-  // This should never be called, since we use Walk and not
-  // WalkExponential.
+  // Should never be called: we use Walk(), not WalkExponential().
+#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
   LOG(DFATAL) << "SimplifyWalker::ShortVisit called";
+#endif
   return re->Incref();
 }
 
diff --git a/util/sparse_array.h b/re2/sparse_array.h
similarity index 99%
rename from util/sparse_array.h
rename to re2/sparse_array.h
index c81c9f3..09ffe08 100644
--- a/util/sparse_array.h
+++ b/re2/sparse_array.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-#ifndef UTIL_SPARSE_ARRAY_H_
-#define UTIL_SPARSE_ARRAY_H_
+#ifndef RE2_SPARSE_ARRAY_H_
+#define RE2_SPARSE_ARRAY_H_
 
 // DESCRIPTION
 //
@@ -102,7 +102,7 @@
 #include <memory>
 #include <utility>
 
-#include "util/pod_array.h"
+#include "re2/pod_array.h"
 
 namespace re2 {
 
@@ -389,4 +389,4 @@ template<typename Value> bool SparseArray<Value>::less(const IndexValue& a,
 
 }  // namespace re2
 
-#endif  // UTIL_SPARSE_ARRAY_H_
+#endif  // RE2_SPARSE_ARRAY_H_
diff --git a/util/sparse_set.h b/re2/sparse_set.h
similarity index 98%
rename from util/sparse_set.h
rename to re2/sparse_set.h
index 0d5ad51..06ed88d 100644
--- a/util/sparse_set.h
+++ b/re2/sparse_set.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-#ifndef UTIL_SPARSE_SET_H_
-#define UTIL_SPARSE_SET_H_
+#ifndef RE2_SPARSE_SET_H_
+#define RE2_SPARSE_SET_H_
 
 // DESCRIPTION
 //
@@ -61,7 +61,7 @@
 #include <memory>
 #include <utility>
 
-#include "util/pod_array.h"
+#include "re2/pod_array.h"
 
 namespace re2 {
 
@@ -261,4 +261,4 @@ typedef SparseSetT<void> SparseSet;
 
 }  // namespace re2
 
-#endif  // UTIL_SPARSE_SET_H_
+#endif  // RE2_SPARSE_SET_H_
diff --git a/re2/stringpiece.cc b/re2/stringpiece.cc
deleted file mode 100644
index ef2e287..0000000
--- a/re2/stringpiece.cc
+++ /dev/null
@@ -1,65 +0,0 @@
-// Copyright 2004 The RE2 Authors.  All Rights Reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-#include "re2/stringpiece.h"
-
-#include <ostream>
-
-#include "util/util.h"
-
-namespace re2 {
-
-const StringPiece::size_type StringPiece::npos;  // initialized in stringpiece.h
-
-StringPiece::size_type StringPiece::copy(char* buf, size_type n,
-                                         size_type pos) const {
-  size_type ret = std::min(size_ - pos, n);
-  memcpy(buf, data_ + pos, ret);
-  return ret;
-}
-
-StringPiece StringPiece::substr(size_type pos, size_type n) const {
-  if (pos > size_) pos = size_;
-  if (n > size_ - pos) n = size_ - pos;
-  return StringPiece(data_ + pos, n);
-}
-
-StringPiece::size_type StringPiece::find(const StringPiece& s,
-                                         size_type pos) const {
-  if (pos > size_) return npos;
-  const_pointer result = std::search(data_ + pos, data_ + size_,
-                                     s.data_, s.data_ + s.size_);
-  size_type xpos = result - data_;
-  return xpos + s.size_ <= size_ ? xpos : npos;
-}
-
-StringPiece::size_type StringPiece::find(char c, size_type pos) const {
-  if (size_ <= 0 || pos >= size_) return npos;
-  const_pointer result = std::find(data_ + pos, data_ + size_, c);
-  return result != data_ + size_ ? result - data_ : npos;
-}
-
-StringPiece::size_type StringPiece::rfind(const StringPiece& s,
-                                          size_type pos) const {
-  if (size_ < s.size_) return npos;
-  if (s.size_ == 0) return std::min(size_, pos);
-  const_pointer last = data_ + std::min(size_ - s.size_, pos) + s.size_;
-  const_pointer result = std::find_end(data_, last, s.data_, s.data_ + s.size_);
-  return result != last ? result - data_ : npos;
-}
-
-StringPiece::size_type StringPiece::rfind(char c, size_type pos) const {
-  if (size_ <= 0) return npos;
-  for (size_t i = std::min(pos + 1, size_); i != 0;) {
-    if (data_[--i] == c) return i;
-  }
-  return npos;
-}
-
-std::ostream& operator<<(std::ostream& o, const StringPiece& p) {
-  o.write(p.data(), p.size());
-  return o;
-}
-
-}  // namespace re2
diff --git a/re2/stringpiece.h b/re2/stringpiece.h
index 1d9c2d3..6d11d16 100644
--- a/re2/stringpiece.h
+++ b/re2/stringpiece.h
@@ -1,209 +1,23 @@
-// Copyright 2001-2010 The RE2 Authors.  All Rights Reserved.
+// Copyright 2022 The RE2 Authors.  All Rights Reserved.
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
 #ifndef RE2_STRINGPIECE_H_
 #define RE2_STRINGPIECE_H_
 
-// A string-like object that points to a sized piece of memory.
-//
-// Functions or methods may use const StringPiece& parameters to accept either
-// a "const char*" or a "string" value that will be implicitly converted to
-// a StringPiece.  The implicit conversion means that it is often appropriate
-// to include this .h file in other files rather than forward-declaring
-// StringPiece as would be appropriate for most other Google classes.
-//
-// Systematic usage of StringPiece is encouraged as it will reduce unnecessary
-// conversions from "const char*" to "string" and back again.
-//
-//
-// Arghh!  I wish C++ literals were "string".
-
-// Doing this simplifies the logic below.
-#ifndef __has_include
-#define __has_include(x) 0
-#endif
-
-#include <stddef.h>
-#include <string.h>
-#include <algorithm>
-#include <iosfwd>
-#include <iterator>
-#include <string>
-#if __has_include(<string_view>) && __cplusplus >= 201703L
-#include <string_view>
-#endif
+#include "absl/strings/string_view.h"
 
 namespace re2 {
 
-class StringPiece {
- public:
-  typedef std::char_traits<char> traits_type;
-  typedef char value_type;
-  typedef char* pointer;
-  typedef const char* const_pointer;
-  typedef char& reference;
-  typedef const char& const_reference;
-  typedef const char* const_iterator;
-  typedef const_iterator iterator;
-  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
-  typedef const_reverse_iterator reverse_iterator;
-  typedef size_t size_type;
-  typedef ptrdiff_t difference_type;
-  static const size_type npos = static_cast<size_type>(-1);
-
-  // We provide non-explicit singleton constructors so users can pass
-  // in a "const char*" or a "string" wherever a "StringPiece" is
-  // expected.
-  StringPiece()
-      : data_(NULL), size_(0) {}
-#if __has_include(<string_view>) && __cplusplus >= 201703L
-  StringPiece(const std::string_view& str)
-      : data_(str.data()), size_(str.size()) {}
-#endif
-  StringPiece(const std::string& str)
-      : data_(str.data()), size_(str.size()) {}
-  StringPiece(const char* str)
-      : data_(str), size_(str == NULL ? 0 : strlen(str)) {}
-  StringPiece(const char* str, size_type len)
-      : data_(str), size_(len) {}
-
-  const_iterator begin() const { return data_; }
-  const_iterator end() const { return data_ + size_; }
-  const_reverse_iterator rbegin() const {
-    return const_reverse_iterator(data_ + size_);
-  }
-  const_reverse_iterator rend() const {
-    return const_reverse_iterator(data_);
-  }
-
-  size_type size() const { return size_; }
-  size_type length() const { return size_; }
-  bool empty() const { return size_ == 0; }
-
-  const_reference operator[](size_type i) const { return data_[i]; }
-  const_pointer data() const { return data_; }
-
-  void remove_prefix(size_type n) {
-    data_ += n;
-    size_ -= n;
-  }
-
-  void remove_suffix(size_type n) {
-    size_ -= n;
-  }
-
-  void set(const char* str) {
-    data_ = str;
-    size_ = str == NULL ? 0 : strlen(str);
-  }
-
-  void set(const char* str, size_type len) {
-    data_ = str;
-    size_ = len;
-  }
-
-  // Converts to `std::basic_string`.
-  template <typename A>
-  explicit operator std::basic_string<char, traits_type, A>() const {
-    if (!data_) return {};
-    return std::basic_string<char, traits_type, A>(data_, size_);
-  }
-
-  std::string as_string() const {
-    return std::string(data_, size_);
-  }
-
-  // We also define ToString() here, since many other string-like
-  // interfaces name the routine that converts to a C++ string
-  // "ToString", and it's confusing to have the method that does that
-  // for a StringPiece be called "as_string()".  We also leave the
-  // "as_string()" method defined here for existing code.
-  std::string ToString() const {
-    return std::string(data_, size_);
-  }
-
-  void CopyToString(std::string* target) const {
-    target->assign(data_, size_);
-  }
-
-  void AppendToString(std::string* target) const {
-    target->append(data_, size_);
-  }
-
-  size_type copy(char* buf, size_type n, size_type pos = 0) const;
-  StringPiece substr(size_type pos = 0, size_type n = npos) const;
-
-  int compare(const StringPiece& x) const {
-    size_type min_size = std::min(size(), x.size());
-    if (min_size > 0) {
-      int r = memcmp(data(), x.data(), min_size);
-      if (r < 0) return -1;
-      if (r > 0) return 1;
-    }
-    if (size() < x.size()) return -1;
-    if (size() > x.size()) return 1;
-    return 0;
-  }
-
-  // Does "this" start with "x"?
-  bool starts_with(const StringPiece& x) const {
-    return x.empty() ||
-           (size() >= x.size() && memcmp(data(), x.data(), x.size()) == 0);
-  }
-
-  // Does "this" end with "x"?
-  bool ends_with(const StringPiece& x) const {
-    return x.empty() ||
-           (size() >= x.size() &&
-            memcmp(data() + (size() - x.size()), x.data(), x.size()) == 0);
-  }
-
-  bool contains(const StringPiece& s) const {
-    return find(s) != npos;
-  }
-
-  size_type find(const StringPiece& s, size_type pos = 0) const;
-  size_type find(char c, size_type pos = 0) const;
-  size_type rfind(const StringPiece& s, size_type pos = npos) const;
-  size_type rfind(char c, size_type pos = npos) const;
-
- private:
-  const_pointer data_;
-  size_type size_;
-};
-
-inline bool operator==(const StringPiece& x, const StringPiece& y) {
-  StringPiece::size_type len = x.size();
-  if (len != y.size()) return false;
-  return x.data() == y.data() || len == 0 ||
-         memcmp(x.data(), y.data(), len) == 0;
-}
-
-inline bool operator!=(const StringPiece& x, const StringPiece& y) {
-  return !(x == y);
-}
-
-inline bool operator<(const StringPiece& x, const StringPiece& y) {
-  StringPiece::size_type min_size = std::min(x.size(), y.size());
-  int r = min_size == 0 ? 0 : memcmp(x.data(), y.data(), min_size);
-  return (r < 0) || (r == 0 && x.size() < y.size());
-}
-
-inline bool operator>(const StringPiece& x, const StringPiece& y) {
-  return y < x;
-}
-
-inline bool operator<=(const StringPiece& x, const StringPiece& y) {
-  return !(x > y);
-}
-
-inline bool operator>=(const StringPiece& x, const StringPiece& y) {
-  return !(x < y);
-}
-
-// Allow StringPiece to be logged.
-std::ostream& operator<<(std::ostream& o, const StringPiece& p);
+// RE2 has two versions: "sans Abseil" in the main branch; and "avec Abseil" in
+// the abseil branch. This has led to a diamond dependency problem for projects
+// like Envoy: as per https://github.com/google/re2/issues/388, GoogleTest took
+// a dependency on RE2 avec Abseil, but other things depend on RE2 sans Abseil.
+// To resolve this conflict until both versions can migrate to std::string_view
+// (C++17), those other things must be able to #include "re2/stringpiece.h" and
+// use re2::StringPiece. (This is a hack, obviously, but it beats telling every
+// project in this situation that they have to perform source transformations.)
+using StringPiece = absl::string_view;
 
 }  // namespace re2
 
diff --git a/re2/testing/backtrack.cc b/re2/testing/backtrack.cc
index d535dd4..90071bb 100644
--- a/re2/testing/backtrack.cc
+++ b/re2/testing/backtrack.cc
@@ -27,8 +27,9 @@
 #include <stdint.h>
 #include <string.h>
 
-#include "util/util.h"
+#include "absl/base/macros.h"
 #include "util/logging.h"
+#include "re2/pod_array.h"
 #include "re2/prog.h"
 #include "re2/regexp.h"
 
@@ -53,11 +54,9 @@ namespace re2 {
 class Backtracker {
  public:
   explicit Backtracker(Prog* prog);
-  ~Backtracker();
 
-  bool Search(const StringPiece& text, const StringPiece& context,
-              bool anchored, bool longest,
-              StringPiece* submatch, int nsubmatch);
+  bool Search(absl::string_view text, absl::string_view context, bool anchored,
+              bool longest, absl::string_view* submatch, int nsubmatch);
 
  private:
   // Explores from instruction id at string position p looking for a match.
@@ -69,19 +68,21 @@ class Backtracker {
   bool Try(int id, const char* p);
 
   // Search parameters
-  Prog* prog_;              // program being run
-  StringPiece text_;        // text being searched
-  StringPiece context_;     // greater context of text being searched
-  bool anchored_;           // whether search is anchored at text.begin()
-  bool longest_;            // whether search wants leftmost-longest match
-  bool endmatch_;           // whether search must end at text.end()
-  StringPiece *submatch_;   // submatches to fill in
-  int nsubmatch_;           //   # of submatches to fill in
+  Prog* prog_;                   // program being run
+  absl::string_view text_;       // text being searched
+  absl::string_view context_;    // greater context of text being searched
+  bool anchored_;                // whether search is anchored at text.begin()
+  bool longest_;                 // whether search wants leftmost-longest match
+  bool endmatch_;                // whether search must end at text.end()
+  absl::string_view* submatch_;  // submatches to fill in
+  int nsubmatch_;                // # of submatches to fill in
 
   // Search state
-  const char* cap_[64];     // capture registers
-  uint32_t *visited_;       // bitmap: (Inst*, char*) pairs already backtracked
-  size_t nvisited_;         //   # of words in bitmap
+  const char* cap_[64];         // capture registers
+  PODArray<uint32_t> visited_;  // bitmap: (Inst*, char*) pairs visited
+
+  Backtracker(const Backtracker&) = delete;
+  Backtracker& operator=(const Backtracker&) = delete;
 };
 
 Backtracker::Backtracker(Prog* prog)
@@ -90,64 +91,62 @@ Backtracker::Backtracker(Prog* prog)
     longest_(false),
     endmatch_(false),
     submatch_(NULL),
-    nsubmatch_(0),
-    visited_(NULL),
-    nvisited_(0) {
-}
-
-Backtracker::~Backtracker() {
-  delete[] visited_;
+    nsubmatch_(0) {
 }
 
 // Runs a backtracking search.
-bool Backtracker::Search(const StringPiece& text, const StringPiece& context,
+bool Backtracker::Search(absl::string_view text, absl::string_view context,
                          bool anchored, bool longest,
-                         StringPiece* submatch, int nsubmatch) {
+                         absl::string_view* submatch, int nsubmatch) {
   text_ = text;
   context_ = context;
-  if (context_.begin() == NULL)
+  if (context_.data() == NULL)
     context_ = text;
-  if (prog_->anchor_start() && text.begin() > context_.begin())
+  if (prog_->anchor_start() && BeginPtr(text) > BeginPtr(context_))
     return false;
-  if (prog_->anchor_end() && text.end() < context_.end())
+  if (prog_->anchor_end() && EndPtr(text) < EndPtr(context_))
     return false;
   anchored_ = anchored | prog_->anchor_start();
   longest_ = longest | prog_->anchor_end();
   endmatch_ = prog_->anchor_end();
   submatch_ = submatch;
   nsubmatch_ = nsubmatch;
-  CHECK(2*nsubmatch_ < arraysize(cap_));
+  CHECK_LT(2*nsubmatch_, static_cast<int>(ABSL_ARRAYSIZE(cap_)));
   memset(cap_, 0, sizeof cap_);
 
   // We use submatch_[0] for our own bookkeeping,
   // so it had better exist.
-  StringPiece sp0;
+  absl::string_view sp0;
   if (nsubmatch < 1) {
     submatch_ = &sp0;
     nsubmatch_ = 1;
   }
-  submatch_[0] = StringPiece();
+  submatch_[0] = absl::string_view();
 
   // Allocate new visited_ bitmap -- size is proportional
   // to text, so have to reallocate on each call to Search.
-  delete[] visited_;
-  nvisited_ = (prog_->size()*(text.size()+1) + 31)/32;
-  visited_ = new uint32_t[nvisited_];
-  memset(visited_, 0, nvisited_*sizeof visited_[0]);
+  int nvisited = prog_->size() * static_cast<int>(text.size()+1);
+  nvisited = (nvisited + 31) / 32;
+  visited_ = PODArray<uint32_t>(nvisited);
+  memset(visited_.data(), 0, nvisited*sizeof visited_[0]);
 
   // Anchored search must start at text.begin().
   if (anchored_) {
-    cap_[0] = text.begin();
-    return Visit(prog_->start(), text.begin());
+    cap_[0] = text.data();
+    return Visit(prog_->start(), text.data());
   }
 
   // Unanchored search, starting from each possible text position.
   // Notice that we have to try the empty string at the end of
   // the text, so the loop condition is p <= text.end(), not p < text.end().
-  for (const char* p = text.begin(); p <= text.end(); p++) {
+  for (const char* p = text.data(); p <= text.data() + text.size(); p++) {
     cap_[0] = p;
     if (Visit(prog_->start(), p))  // Match must be leftmost; done.
       return true;
+    // Avoid invoking undefined behavior (arithmetic on a null pointer)
+    // by simply not continuing the loop.
+    if (p == NULL)
+      break;
   }
   return false;
 }
@@ -158,9 +157,10 @@ bool Backtracker::Visit(int id, const char* p) {
   // Check bitmap.  If we've already explored from here,
   // either it didn't match or it did but we're hoping for a better match.
   // Either way, don't go down that road again.
-  CHECK(p <= text_.end());
-  size_t n = id*(text_.size()+1) + (p - text_.begin());
-  CHECK_LT(n/32, nvisited_);
+  CHECK(p <= text_.data() + text_.size());
+  int n = id * static_cast<int>(text_.size()+1) +
+          static_cast<int>(p-text_.data());
+  CHECK_LT(n/32, visited_.size());
   if (visited_[n/32] & (1 << (n&31)))
     return false;
   visited_[n/32] |= 1 << (n&31);
@@ -182,7 +182,7 @@ bool Backtracker::Try(int id, const char* p) {
   // Pick out byte at current position.  If at end of string,
   // have to explore in hope of finishing a match.  Use impossible byte -1.
   int c = -1;
-  if (p < text_.end())
+  if (p < text_.data() + text_.size())
     c = *p & 0xFF;
 
   Prog::Inst* ip = prog_->inst(id);
@@ -201,7 +201,8 @@ bool Backtracker::Try(int id, const char* p) {
       return false;
 
     case kInstCapture:
-      if (0 <= ip->cap() && ip->cap() < arraysize(cap_)) {
+      if (0 <= ip->cap() &&
+          ip->cap() < static_cast<int>(ABSL_ARRAYSIZE(cap_))) {
         // Capture p to register, but save old value.
         const char* q = cap_[ip->cap()];
         cap_[ip->cap()] = p;
@@ -223,13 +224,14 @@ bool Backtracker::Try(int id, const char* p) {
     case kInstMatch:
       // We found a match.  If it's the best so far, record the
       // parameters in the caller's submatch_ array.
-      if (endmatch_ && p != context_.end())
+      if (endmatch_ && p != context_.data() + context_.size())
         return false;
       cap_[1] = p;
-      if (submatch_[0].data() == NULL ||           // First match so far ...
-          (longest_ && p > submatch_[0].end())) {  // ... or better match
+      if (submatch_[0].data() == NULL ||
+          (longest_ && p > submatch_[0].data() + submatch_[0].size())) {
+        // First match so far - or better match.
         for (int i = 0; i < nsubmatch_; i++)
-          submatch_[i] = StringPiece(
+          submatch_[i] = absl::string_view(
               cap_[2 * i], static_cast<size_t>(cap_[2 * i + 1] - cap_[2 * i]));
       }
       return true;
@@ -240,16 +242,14 @@ bool Backtracker::Try(int id, const char* p) {
 }
 
 // Runs a backtracking search.
-bool Prog::UnsafeSearchBacktrack(const StringPiece& text,
-                                 const StringPiece& context,
-                                 Anchor anchor,
-                                 MatchKind kind,
-                                 StringPiece* match,
+bool Prog::UnsafeSearchBacktrack(absl::string_view text,
+                                 absl::string_view context, Anchor anchor,
+                                 MatchKind kind, absl::string_view* match,
                                  int nmatch) {
   // If full match, we ask for an anchored longest match
   // and then check that match[0] == text.
   // So make sure match[0] exists.
-  StringPiece sp0;
+  absl::string_view sp0;
   if (kind == kFullMatch) {
     anchor = kAnchored;
     if (nmatch < 1) {
@@ -264,7 +264,7 @@ bool Prog::UnsafeSearchBacktrack(const StringPiece& text,
   bool longest = kind != kFirstMatch;
   if (!b.Search(text, context, anchored, longest, match, nmatch))
     return false;
-  if (kind == kFullMatch && match[0].end() != text.end())
+  if (kind == kFullMatch && EndPtr(match[0]) != EndPtr(text))
     return false;
   return true;
 }
diff --git a/re2/testing/charclass_test.cc b/re2/testing/charclass_test.cc
index 7e0169c..ad95d6c 100644
--- a/re2/testing/charclass_test.cc
+++ b/re2/testing/charclass_test.cc
@@ -6,7 +6,9 @@
 
 #include <stdio.h>
 
-#include "util/test.h"
+#include "absl/base/macros.h"
+#include "absl/strings/str_format.h"
+#include "gtest/gtest.h"
 #include "util/utf.h"
 #include "re2/regexp.h"
 
@@ -85,28 +87,28 @@ static CCTest tests[] = {
     { {-1} } },
 };
 
-template<class CharClass>
+template <typename CharClass>
 static void Broke(const char *desc, const CCTest* t, CharClass* cc) {
   if (t == NULL) {
-    printf("\t%s:", desc);
+    absl::PrintF("\t%s:", desc);
   } else {
-    printf("\n");
-    printf("CharClass added: [%s]", desc);
+    absl::PrintF("\n");
+    absl::PrintF("CharClass added: [%s]", desc);
     for (int k = 0; t->add[k].lo >= 0; k++)
-      printf(" %d-%d", t->add[k].lo, t->add[k].hi);
-    printf("\n");
+      absl::PrintF(" %d-%d", t->add[k].lo, t->add[k].hi);
+    absl::PrintF("\n");
     if (t->remove >= 0)
-      printf("Removed > %d\n", t->remove);
-    printf("\twant:");
+      absl::PrintF("Removed > %d\n", t->remove);
+    absl::PrintF("\twant:");
     for (int k = 0; t->final[k].lo >= 0; k++)
-      printf(" %d-%d", t->final[k].lo, t->final[k].hi);
-    printf("\n");
-    printf("\thave:");
+      absl::PrintF(" %d-%d", t->final[k].lo, t->final[k].hi);
+    absl::PrintF("\n");
+    absl::PrintF("\thave:");
   }
 
   for (typename CharClass::iterator it = cc->begin(); it != cc->end(); ++it)
-    printf(" %d-%d", it->lo, it->hi);
-  printf("\n");
+    absl::PrintF(" %d-%d", it->lo, it->hi);
+  absl::PrintF("\n");
 }
 
 bool ShouldContain(CCTest *t, int x) {
@@ -136,7 +138,7 @@ void Delete(CharClassBuilder* cc) {
   delete cc;
 }
 
-template<class CharClass>
+template <typename CharClass>
 bool CorrectCC(CharClass *cc, CCTest *t, const char *desc) {
   typename CharClass::iterator it = cc->begin();
   int size = 0;
@@ -155,7 +157,7 @@ bool CorrectCC(CharClass *cc, CCTest *t, const char *desc) {
   }
   if (cc->size() != size) {
     Broke(desc, t, cc);
-    printf("wrong size: want %d have %d\n", size, cc->size());
+    absl::PrintF("wrong size: want %d have %d\n", size, cc->size());
     return false;
   }
 
@@ -164,8 +166,8 @@ bool CorrectCC(CharClass *cc, CCTest *t, const char *desc) {
       j = Runemax;
     if (ShouldContain(t, j) != cc->Contains(j)) {
       Broke(desc, t, cc);
-      printf("want contains(%d)=%d, got %d\n",
-             j, ShouldContain(t, j), cc->Contains(j));
+      absl::PrintF("want contains(%d)=%d, got %d\n",
+                   j, ShouldContain(t, j), cc->Contains(j));
       return false;
     }
   }
@@ -177,16 +179,16 @@ bool CorrectCC(CharClass *cc, CCTest *t, const char *desc) {
     if (ShouldContain(t, j) == ncc->Contains(j)) {
       Broke(desc, t, cc);
       Broke("ncc", NULL, ncc);
-      printf("want ncc contains(%d)!=%d, got %d\n",
-             j, ShouldContain(t, j), ncc->Contains(j));
+      absl::PrintF("want ncc contains(%d)!=%d, got %d\n",
+                   j, ShouldContain(t, j), ncc->Contains(j));
       Delete(ncc);
       return false;
     }
     if (ncc->size() != Runemax+1 - cc->size()) {
       Broke(desc, t, cc);
       Broke("ncc", NULL, ncc);
-      printf("ncc size should be %d is %d\n",
-             Runemax+1 - cc->size(), ncc->size());
+      absl::PrintF("ncc size should be %d is %d\n",
+                   Runemax+1 - cc->size(), ncc->size());
       Delete(ncc);
       return false;
     }
@@ -197,7 +199,7 @@ bool CorrectCC(CharClass *cc, CCTest *t, const char *desc) {
 
 TEST(TestCharClassBuilder, Adds) {
   int nfail = 0;
-  for (int i = 0; i < arraysize(tests); i++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(tests); i++) {
     CharClassBuilder ccb;
     CCTest* t = &tests[i];
     for (int j = 0; t->add[j].lo >= 0; j++)
diff --git a/re2/testing/compile_test.cc b/re2/testing/compile_test.cc
index d89d80f..f6899d3 100644
--- a/re2/testing/compile_test.cc
+++ b/re2/testing/compile_test.cc
@@ -6,7 +6,8 @@
 
 #include <string>
 
-#include "util/test.h"
+#include "absl/base/macros.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
 #include "re2/regexp.h"
 #include "re2/prog.h"
@@ -26,94 +27,108 @@ struct Test {
 
 static Test tests[] = {
   { "a",
-    "3. byte [61-61] -> 4\n"
+    "3. byte [61-61] 0 -> 4\n"
     "4. match! 0\n" },
   { "ab",
-    "3. byte [61-61] -> 4\n"
-    "4. byte [62-62] -> 5\n"
+    "3. byte [61-61] 0 -> 4\n"
+    "4. byte [62-62] 0 -> 5\n"
     "5. match! 0\n" },
   { "a|c",
-    "3+ byte [61-61] -> 5\n"
-    "4. byte [63-63] -> 5\n"
+    "3+ byte [61-61] 0 -> 5\n"
+    "4. byte [63-63] 0 -> 5\n"
     "5. match! 0\n" },
   { "a|b",
-    "3. byte [61-62] -> 4\n"
+    "3. byte [61-62] 0 -> 4\n"
     "4. match! 0\n" },
   { "[ab]",
-    "3. byte [61-62] -> 4\n"
+    "3. byte [61-62] 0 -> 4\n"
     "4. match! 0\n" },
   { "a+",
-    "3. byte [61-61] -> 4\n"
+    "3. byte [61-61] 0 -> 4\n"
     "4+ nop -> 3\n"
     "5. match! 0\n" },
   { "a+?",
-    "3. byte [61-61] -> 4\n"
+    "3. byte [61-61] 0 -> 4\n"
     "4+ match! 0\n"
     "5. nop -> 3\n" },
   { "a*",
-    "3+ byte [61-61] -> 3\n"
+    "3+ byte [61-61] 1 -> 3\n"
     "4. match! 0\n" },
   { "a*?",
     "3+ match! 0\n"
-    "4. byte [61-61] -> 3\n" },
+    "4. byte [61-61] 0 -> 3\n" },
   { "a?",
-    "3+ byte [61-61] -> 5\n"
+    "3+ byte [61-61] 1 -> 5\n"
     "4. nop -> 5\n"
     "5. match! 0\n" },
   { "a??",
     "3+ nop -> 5\n"
-    "4. byte [61-61] -> 5\n"
+    "4. byte [61-61] 0 -> 5\n"
     "5. match! 0\n" },
   { "a{4}",
-    "3. byte [61-61] -> 4\n"
-    "4. byte [61-61] -> 5\n"
-    "5. byte [61-61] -> 6\n"
-    "6. byte [61-61] -> 7\n"
+    "3. byte [61-61] 0 -> 4\n"
+    "4. byte [61-61] 0 -> 5\n"
+    "5. byte [61-61] 0 -> 6\n"
+    "6. byte [61-61] 0 -> 7\n"
     "7. match! 0\n" },
   { "(a)",
     "3. capture 2 -> 4\n"
-    "4. byte [61-61] -> 5\n"
+    "4. byte [61-61] 0 -> 5\n"
     "5. capture 3 -> 6\n"
     "6. match! 0\n" },
   { "(?:a)",
-    "3. byte [61-61] -> 4\n"
+    "3. byte [61-61] 0 -> 4\n"
     "4. match! 0\n" },
   { "",
     "3. match! 0\n" },
   { ".",
-    "3+ byte [00-09] -> 5\n"
-    "4. byte [0b-ff] -> 5\n"
+    "3+ byte [00-09] 0 -> 5\n"
+    "4. byte [0b-ff] 0 -> 5\n"
     "5. match! 0\n" },
   { "[^ab]",
-    "3+ byte [00-09] -> 6\n"
-    "4+ byte [0b-60] -> 6\n"
-    "5. byte [63-ff] -> 6\n"
+    "3+ byte [00-09] 0 -> 6\n"
+    "4+ byte [0b-60] 0 -> 6\n"
+    "5. byte [63-ff] 0 -> 6\n"
     "6. match! 0\n" },
   { "[Aa]",
-    "3. byte/i [61-61] -> 4\n"
+    "3. byte/i [61-61] 0 -> 4\n"
     "4. match! 0\n" },
   { "\\C+",
-    "3. byte [00-ff] -> 4\n"
+    "3. byte [00-ff] 0 -> 4\n"
     "4+ altmatch -> 5 | 6\n"
     "5+ nop -> 3\n"
     "6. match! 0\n" },
   { "\\C*",
     "3+ altmatch -> 4 | 5\n"
-    "4+ byte [00-ff] -> 3\n"
+    "4+ byte [00-ff] 1 -> 3\n"
     "5. match! 0\n" },
   { "\\C?",
-    "3+ byte [00-ff] -> 5\n"
+    "3+ byte [00-ff] 1 -> 5\n"
     "4. nop -> 5\n"
     "5. match! 0\n" },
   // Issue 20992936
   { "[[-`]",
-    "3. byte [5b-60] -> 4\n"
+    "3. byte [5b-60] 0 -> 4\n"
     "4. match! 0\n" },
+  // Issue 310
+  { "(?:|a)*",
+    "3+ nop -> 7\n"
+    "4. nop -> 9\n"
+    "5+ nop -> 7\n"
+    "6. nop -> 9\n"
+    "7+ nop -> 5\n"
+    "8. byte [61-61] 0 -> 5\n"
+    "9. match! 0\n" },
+  { "(?:|a)+",
+    "3+ nop -> 5\n"
+    "4. byte [61-61] 0 -> 5\n"
+    "5+ nop -> 3\n"
+    "6. match! 0\n" },
 };
 
 TEST(TestRegexpCompileToProg, Simple) {
   int failed = 0;
-  for (int i = 0; i < arraysize(tests); i++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(tests); i++) {
     const re2::Test& t = tests[i];
     Regexp* re = Regexp::Parse(t.regexp, Regexp::PerlX|Regexp::Latin1, NULL);
     if (re == NULL) {
@@ -129,7 +144,7 @@ TEST(TestRegexpCompileToProg, Simple) {
       continue;
     }
     ASSERT_TRUE(re->CompileToProg(1) == NULL);
-    string s = prog->Dump();
+    std::string s = prog->Dump();
     if (s != t.code) {
       LOG(ERROR) << "Incorrect compiled code for: " << t.regexp;
       LOG(ERROR) << "Want:\n" << t.code;
@@ -142,15 +157,24 @@ TEST(TestRegexpCompileToProg, Simple) {
   EXPECT_EQ(failed, 0);
 }
 
-static void DumpByteMap(StringPiece pattern, Regexp::ParseFlags flags,
-                        string* bytemap) {
+static void DumpByteMap(absl::string_view pattern, Regexp::ParseFlags flags,
+                        std::string* bytemap) {
   Regexp* re = Regexp::Parse(pattern, flags, NULL);
   EXPECT_TRUE(re != NULL);
 
-  Prog* prog = re->CompileToProg(0);
-  EXPECT_TRUE(prog != NULL);
-  *bytemap = prog->DumpByteMap();
-  delete prog;
+  {
+    Prog* prog = re->CompileToProg(0);
+    EXPECT_TRUE(prog != NULL);
+    *bytemap = prog->DumpByteMap();
+    delete prog;
+  }
+
+  {
+    Prog* prog = re->CompileToReverseProg(0);
+    EXPECT_TRUE(prog != NULL);
+    EXPECT_EQ(*bytemap, prog->DumpByteMap());
+    delete prog;
+  }
 
   re->Decref();
 }
@@ -158,7 +182,7 @@ static void DumpByteMap(StringPiece pattern, Regexp::ParseFlags flags,
 TEST(TestCompile, Latin1Ranges) {
   // The distinct byte ranges involved in the Latin-1 dot ([^\n]).
 
-  string bytemap;
+  std::string bytemap;
 
   DumpByteMap(".", Regexp::PerlX|Regexp::Latin1, &bytemap);
   EXPECT_EQ("[00-09] -> 0\n"
@@ -168,7 +192,7 @@ TEST(TestCompile, Latin1Ranges) {
 }
 
 TEST(TestCompile, OtherByteMapTests) {
-  string bytemap;
+  std::string bytemap;
 
   // Test that "absent" ranges are mapped to the same byte class.
   DumpByteMap("[0-9A-Fa-f]+", Regexp::PerlX|Regexp::Latin1, &bytemap);
@@ -207,22 +231,17 @@ TEST(TestCompile, UTF8Ranges) {
   // Once, erroneously split between 0x3f and 0x40 because it is
   // a 6-bit boundary.
 
-  string bytemap;
+  std::string bytemap;
 
   DumpByteMap(".", Regexp::PerlX, &bytemap);
   EXPECT_EQ("[00-09] -> 0\n"
             "[0a-0a] -> 1\n"
             "[0b-7f] -> 0\n"
-            "[80-8f] -> 2\n"
-            "[90-9f] -> 3\n"
-            "[a0-bf] -> 4\n"
+            "[80-bf] -> 2\n"
             "[c0-c1] -> 1\n"
-            "[c2-df] -> 5\n"
-            "[e0-e0] -> 6\n"
-            "[e1-ef] -> 7\n"
-            "[f0-f0] -> 8\n"
-            "[f1-f3] -> 9\n"
-            "[f4-f4] -> 10\n"
+            "[c2-df] -> 3\n"
+            "[e0-ef] -> 4\n"
+            "[f0-f4] -> 5\n"
             "[f5-ff] -> 1\n",
             bytemap);
 }
@@ -232,15 +251,15 @@ TEST(TestCompile, InsufficientMemory) {
       "^(?P<name1>[^\\s]+)\\s+(?P<name2>[^\\s]+)\\s+(?P<name3>.+)$",
       Regexp::LikePerl, NULL);
   EXPECT_TRUE(re != NULL);
-  Prog* prog = re->CompileToProg(920);
+  Prog* prog = re->CompileToProg(850);
   // If the memory budget has been exhausted, compilation should fail
   // and return NULL instead of trying to do anything with NoMatch().
   EXPECT_TRUE(prog == NULL);
   re->Decref();
 }
 
-static void Dump(StringPiece pattern, Regexp::ParseFlags flags,
-                 string* forward, string* reverse) {
+static void Dump(absl::string_view pattern, Regexp::ParseFlags flags,
+                 std::string* forward, std::string* reverse) {
   Regexp* re = Regexp::Parse(pattern, flags, NULL);
   EXPECT_TRUE(re != NULL);
 
@@ -265,54 +284,56 @@ TEST(TestCompile, Bug26705922) {
   // Bug in the compiler caused inefficient bytecode to be generated for Unicode
   // groups: common suffixes were cached, but common prefixes were not factored.
 
-  string forward, reverse;
+  std::string forward, reverse;
 
   Dump("[\\x{10000}\\x{10010}]", Regexp::LikePerl, &forward, &reverse);
-  EXPECT_EQ("3. byte [f0-f0] -> 4\n"
-            "4. byte [90-90] -> 5\n"
-            "5. byte [80-80] -> 6\n"
-            "6+ byte [80-80] -> 8\n"
-            "7. byte [90-90] -> 8\n"
+  EXPECT_EQ("3. byte [f0-f0] 0 -> 4\n"
+            "4. byte [90-90] 0 -> 5\n"
+            "5. byte [80-80] 0 -> 6\n"
+            "6+ byte [80-80] 0 -> 8\n"
+            "7. byte [90-90] 0 -> 8\n"
             "8. match! 0\n",
             forward);
-  EXPECT_EQ("3+ byte [80-80] -> 5\n"
-            "4. byte [90-90] -> 5\n"
-            "5. byte [80-80] -> 6\n"
-            "6. byte [90-90] -> 7\n"
-            "7. byte [f0-f0] -> 8\n"
+  EXPECT_EQ("3+ byte [80-80] 0 -> 5\n"
+            "4. byte [90-90] 0 -> 5\n"
+            "5. byte [80-80] 0 -> 6\n"
+            "6. byte [90-90] 0 -> 7\n"
+            "7. byte [f0-f0] 0 -> 8\n"
             "8. match! 0\n",
             reverse);
 
   Dump("[\\x{8000}-\\x{10FFF}]", Regexp::LikePerl, &forward, &reverse);
-  EXPECT_EQ("3+ byte [e8-ef] -> 5\n"
-            "4. byte [f0-f0] -> 8\n"
-            "5. byte [80-bf] -> 6\n"
-            "6. byte [80-bf] -> 7\n"
+  EXPECT_EQ("3+ byte [e8-ef] 0 -> 5\n"
+            "4. byte [f0-f0] 0 -> 8\n"
+            "5. byte [80-bf] 0 -> 6\n"
+            "6. byte [80-bf] 0 -> 7\n"
             "7. match! 0\n"
-            "8. byte [90-90] -> 5\n",
+            "8. byte [90-90] 0 -> 5\n",
             forward);
-  EXPECT_EQ("3. byte [80-bf] -> 4\n"
-            "4. byte [80-bf] -> 5\n"
-            "5+ byte [e8-ef] -> 7\n"
-            "6. byte [90-90] -> 8\n"
+  EXPECT_EQ("3. byte [80-bf] 0 -> 4\n"
+            "4. byte [80-bf] 0 -> 5\n"
+            "5+ byte [e8-ef] 0 -> 7\n"
+            "6. byte [90-90] 0 -> 8\n"
             "7. match! 0\n"
-            "8. byte [f0-f0] -> 7\n",
+            "8. byte [f0-f0] 0 -> 7\n",
             reverse);
 
-  Dump("[\\x{80}-\\x{10FFFF}]", Regexp::LikePerl, NULL, &reverse);
-  EXPECT_EQ("3. byte [80-bf] -> 4\n"
-            "4+ byte [c2-df] -> 7\n"
-            "5+ byte [a0-bf] -> 8\n"
-            "6. byte [80-bf] -> 9\n"
+  Dump("[\\x{80}-\\x{10FFFF}]", Regexp::LikePerl, &forward, &reverse);
+  EXPECT_EQ("3+ byte [c2-df] 0 -> 6\n"
+            "4+ byte [e0-ef] 0 -> 8\n"
+            "5. byte [f0-f4] 0 -> 9\n"
+            "6. byte [80-bf] 0 -> 7\n"
             "7. match! 0\n"
-            "8. byte [e0-e0] -> 7\n"
-            "9+ byte [e1-ef] -> 7\n"
-            "10+ byte [90-bf] -> 13\n"
-            "11+ byte [80-bf] -> 14\n"
-            "12. byte [80-8f] -> 15\n"
-            "13. byte [f0-f0] -> 7\n"
-            "14. byte [f1-f3] -> 7\n"
-            "15. byte [f4-f4] -> 7\n",
+            "8. byte [80-bf] 0 -> 6\n"
+            "9. byte [80-bf] 0 -> 8\n",
+            forward);
+  EXPECT_EQ("3. byte [80-bf] 0 -> 4\n"
+            "4+ byte [c2-df] 0 -> 6\n"
+            "5. byte [80-bf] 0 -> 7\n"
+            "6. match! 0\n"
+            "7+ byte [e0-ef] 0 -> 6\n"
+            "8. byte [80-bf] 0 -> 9\n"
+            "9. byte [f0-f4] 0 -> 6\n",
             reverse);
 }
 
@@ -320,77 +341,87 @@ TEST(TestCompile, Bug35237384) {
   // Bug in the compiler caused inefficient bytecode to be generated for
   // nested nullable subexpressions.
 
-  string forward;
+  std::string forward;
 
   Dump("a**{3,}", Regexp::Latin1|Regexp::NeverCapture, &forward, NULL);
-  EXPECT_EQ("3+ byte [61-61] -> 3\n"
+  EXPECT_EQ("3+ byte [61-61] 1 -> 3\n"
             "4. nop -> 5\n"
-            "5+ byte [61-61] -> 5\n"
+            "5+ byte [61-61] 1 -> 5\n"
             "6. nop -> 7\n"
-            "7+ byte [61-61] -> 7\n"
+            "7+ byte [61-61] 1 -> 7\n"
             "8. match! 0\n",
             forward);
 
   Dump("(a*|b*)*{3,}", Regexp::Latin1|Regexp::NeverCapture, &forward, NULL);
-  EXPECT_EQ("3+ nop -> 6\n"
-            "4+ nop -> 8\n"
-            "5. nop -> 21\n"
-            "6+ byte [61-61] -> 6\n"
-            "7. nop -> 3\n"
-            "8+ byte [62-62] -> 8\n"
-            "9. nop -> 3\n"
-            "10+ byte [61-61] -> 10\n"
-            "11. nop -> 21\n"
-            "12+ byte [62-62] -> 12\n"
-            "13. nop -> 21\n"
-            "14+ byte [61-61] -> 14\n"
-            "15. nop -> 18\n"
-            "16+ byte [62-62] -> 16\n"
-            "17. nop -> 18\n"
-            "18+ nop -> 14\n"
-            "19+ nop -> 16\n"
-            "20. match! 0\n"
-            "21+ nop -> 10\n"
-            "22+ nop -> 12\n"
-            "23. nop -> 18\n",
+  EXPECT_EQ("3+ nop -> 28\n"
+            "4. nop -> 30\n"
+            "5+ byte [61-61] 1 -> 5\n"
+            "6. nop -> 32\n"
+            "7+ byte [61-61] 1 -> 7\n"
+            "8. nop -> 26\n"
+            "9+ byte [61-61] 1 -> 9\n"
+            "10. nop -> 20\n"
+            "11+ byte [62-62] 1 -> 11\n"
+            "12. nop -> 20\n"
+            "13+ byte [62-62] 1 -> 13\n"
+            "14. nop -> 26\n"
+            "15+ byte [62-62] 1 -> 15\n"
+            "16. nop -> 32\n"
+            "17+ nop -> 9\n"
+            "18. nop -> 11\n"
+            "19. match! 0\n"
+            "20+ nop -> 17\n"
+            "21. nop -> 19\n"
+            "22+ nop -> 7\n"
+            "23. nop -> 13\n"
+            "24+ nop -> 17\n"
+            "25. nop -> 19\n"
+            "26+ nop -> 22\n"
+            "27. nop -> 24\n"
+            "28+ nop -> 5\n"
+            "29. nop -> 15\n"
+            "30+ nop -> 22\n"
+            "31. nop -> 24\n"
+            "32+ nop -> 28\n"
+            "33. nop -> 30\n",
       forward);
 
   Dump("((|S.+)+|(|S.+)+|){2}", Regexp::Latin1|Regexp::NeverCapture, &forward, NULL);
   EXPECT_EQ("3+ nop -> 36\n"
             "4+ nop -> 31\n"
             "5. nop -> 33\n"
-            "6+ byte [00-09] -> 8\n"
-            "7. byte [0b-ff] -> 8\n"
+            "6+ byte [00-09] 0 -> 8\n"
+            "7. byte [0b-ff] 0 -> 8\n"
             "8+ nop -> 6\n"
             "9+ nop -> 29\n"
             "10. nop -> 28\n"
-            "11+ byte [00-09] -> 13\n"
-            "12. byte [0b-ff] -> 13\n"
+            "11+ byte [00-09] 0 -> 13\n"
+            "12. byte [0b-ff] 0 -> 13\n"
             "13+ nop -> 11\n"
             "14+ nop -> 26\n"
             "15. nop -> 28\n"
-            "16+ byte [00-09] -> 18\n"
-            "17. byte [0b-ff] -> 18\n"
+            "16+ byte [00-09] 0 -> 18\n"
+            "17. byte [0b-ff] 0 -> 18\n"
             "18+ nop -> 16\n"
             "19+ nop -> 36\n"
             "20. nop -> 33\n"
-            "21+ byte [00-09] -> 23\n"
-            "22. byte [0b-ff] -> 23\n"
+            "21+ byte [00-09] 0 -> 23\n"
+            "22. byte [0b-ff] 0 -> 23\n"
             "23+ nop -> 21\n"
             "24+ nop -> 31\n"
             "25. nop -> 33\n"
             "26+ nop -> 28\n"
-            "27. byte [53-53] -> 11\n"
+            "27. byte [53-53] 0 -> 11\n"
             "28. match! 0\n"
             "29+ nop -> 28\n"
-            "30. byte [53-53] -> 6\n"
+            "30. byte [53-53] 0 -> 6\n"
             "31+ nop -> 33\n"
-            "32. byte [53-53] -> 21\n"
+            "32. byte [53-53] 0 -> 21\n"
             "33+ nop -> 29\n"
             "34+ nop -> 26\n"
             "35. nop -> 28\n"
             "36+ nop -> 33\n"
-            "37. byte [53-53] -> 16\n",
+            "37. byte [53-53] 0 -> 16\n",
       forward);
 }
 
diff --git a/re2/testing/dfa_test.cc b/re2/testing/dfa_test.cc
index eb44b4a..b0759f7 100644
--- a/re2/testing/dfa_test.cc
+++ b/re2/testing/dfa_test.cc
@@ -7,9 +7,12 @@
 #include <thread>
 #include <vector>
 
-#include "util/test.h"
+#include "absl/base/macros.h"
+#include "absl/flags/flag.h"
+#include "absl/strings/str_format.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
-#include "util/strutil.h"
+#include "util/malloc_counter.h"
 #include "re2/prog.h"
 #include "re2/re2.h"
 #include "re2/regexp.h"
@@ -18,12 +21,26 @@
 
 static const bool UsingMallocCounter = false;
 
-DEFINE_int32(size, 8, "log2(number of DFA nodes)");
-DEFINE_int32(repeat, 2, "Repetition count.");
-DEFINE_int32(threads, 4, "number of threads");
+ABSL_FLAG(int, size, 8, "log2(number of DFA nodes)");
+ABSL_FLAG(int, repeat, 2, "Repetition count.");
+ABSL_FLAG(int, threads, 4, "number of threads");
 
 namespace re2 {
 
+static int state_cache_resets = 0;
+static int search_failures = 0;
+
+struct SetHooks {
+  SetHooks() {
+    hooks::SetDFAStateCacheResetHook([](const hooks::DFAStateCacheReset&) {
+      ++state_cache_resets;
+    });
+    hooks::SetDFASearchFailureHook([](const hooks::DFASearchFailure&) {
+      ++search_failures;
+    });
+  }
+} set_hooks;
+
 // Check that multithreaded access to DFA class works.
 
 // Helper function: builds entire DFA for prog.
@@ -33,8 +50,8 @@ static void DoBuild(Prog* prog) {
 
 TEST(Multithreaded, BuildEntireDFA) {
   // Create regexp with 2^FLAGS_size states in DFA.
-  string s = "a";
-  for (int i = 0; i < FLAGS_size; i++)
+  std::string s = "a";
+  for (int i = 0; i < absl::GetFlag(FLAGS_size); i++)
     s += "[ab]";
   s += "b";
   Regexp* re = Regexp::Parse(s, Regexp::LikePerl, NULL);
@@ -52,14 +69,14 @@ TEST(Multithreaded, BuildEntireDFA) {
   }
 
   // Build the DFA simultaneously in a bunch of threads.
-  for (int i = 0; i < FLAGS_repeat; i++) {
+  for (int i = 0; i < absl::GetFlag(FLAGS_repeat); i++) {
     Prog* prog = re->CompileToProg(0);
     ASSERT_TRUE(prog != NULL);
 
     std::vector<std::thread> threads;
-    for (int j = 0; j < FLAGS_threads; j++)
+    for (int j = 0; j < absl::GetFlag(FLAGS_threads); j++)
       threads.emplace_back(DoBuild, prog);
-    for (int j = 0; j < FLAGS_threads; j++)
+    for (int j = 0; j < absl::GetFlag(FLAGS_threads); j++)
       threads[j].join();
 
     // One more compile, to make sure everything is okay.
@@ -106,44 +123,6 @@ TEST(SingleThreaded, BuildEntireDFA) {
   re->Decref();
 }
 
-// Generates and returns a string over binary alphabet {0,1} that contains
-// all possible binary sequences of length n as subsequences.  The obvious
-// brute force method would generate a string of length n * 2^n, but this
-// generates a string of length n + 2^n - 1 called a De Bruijn cycle.
-// See Knuth, The Art of Computer Programming, Vol 2, Exercise 3.2.2 #17.
-// Such a string is useful for testing a DFA.  If you have a DFA
-// where distinct last n bytes implies distinct states, then running on a
-// DeBruijn string causes the DFA to need to create a new state at every
-// position in the input, never reusing any states until it gets to the
-// end of the string.  This is the worst possible case for DFA execution.
-static string DeBruijnString(int n) {
-  CHECK_LT(n, static_cast<int>(8*sizeof(int)));
-  CHECK_GT(n, 0);
-
-  std::vector<bool> did(size_t{1}<<n);
-  for (int i = 0; i < 1<<n; i++)
-    did[i] = false;
-
-  string s;
-  for (int i = 0; i < n-1; i++)
-    s.append("0");
-  int bits = 0;
-  int mask = (1<<n) - 1;
-  for (int i = 0; i < (1<<n); i++) {
-    bits <<= 1;
-    bits &= mask;
-    if (!did[bits|1]) {
-      bits |= 1;
-      s.append("1");
-    } else {
-      s.append("0");
-    }
-    CHECK(!did[bits]);
-    did[bits] = true;
-  }
-  return s;
-}
-
 // Test that the DFA gets the right result even if it runs
 // out of memory during a search.  The regular expression
 // 0[01]{n}$ matches a binary string of 0s and 1s only if
@@ -165,7 +144,9 @@ TEST(SingleThreaded, SearchDFA) {
   // NFA implementation instead.  (The DFA loses its speed advantage
   // if it can't get a good cache hit rate.)
   // Tell the DFA to trudge along instead.
-  Prog::TEST_dfa_should_bail_when_slow(false);
+  Prog::TESTING_ONLY_set_dfa_should_bail_when_slow(false);
+  state_cache_resets = 0;
+  search_failures = 0;
 
   // Choice of n is mostly arbitrary, except that:
   //   * making n too big makes the test run for too long.
@@ -174,14 +155,14 @@ TEST(SingleThreaded, SearchDFA) {
   // Empirically, n = 18 is a good compromise between the two.
   const int n = 18;
 
-  Regexp* re = Regexp::Parse(StringPrintf("0[01]{%d}$", n),
+  Regexp* re = Regexp::Parse(absl::StrFormat("0[01]{%d}$", n),
                              Regexp::LikePerl, NULL);
   ASSERT_TRUE(re != NULL);
 
   // The De Bruijn string for n ends with a 1 followed by n 0s in a row,
   // which is not a match for 0[01]{n}$.  Adding one more 0 is a match.
-  string no_match = DeBruijnString(n);
-  string match = no_match + "0";
+  std::string no_match = DeBruijnString(n);
+  std::string match = no_match + "0";
 
   int64_t usage;
   int64_t peak_usage;
@@ -192,12 +173,14 @@ TEST(SingleThreaded, SearchDFA) {
     for (int i = 0; i < 10; i++) {
       bool matched = false;
       bool failed = false;
-      matched = prog->SearchDFA(match, StringPiece(), Prog::kUnanchored,
-                                Prog::kFirstMatch, NULL, &failed, NULL);
+      matched =
+          prog->SearchDFA(match, absl::string_view(), Prog::kUnanchored,
+                          Prog::kFirstMatch, NULL, &failed, NULL);
       ASSERT_FALSE(failed);
       ASSERT_TRUE(matched);
-      matched = prog->SearchDFA(no_match, StringPiece(), Prog::kUnanchored,
-                                Prog::kFirstMatch, NULL, &failed, NULL);
+      matched =
+          prog->SearchDFA(no_match, absl::string_view(), Prog::kUnanchored,
+                          Prog::kFirstMatch, NULL, &failed, NULL);
       ASSERT_FALSE(failed);
       ASSERT_FALSE(matched);
     }
@@ -214,37 +197,43 @@ TEST(SingleThreaded, SearchDFA) {
   re->Decref();
 
   // Reset to original behaviour.
-  Prog::TEST_dfa_should_bail_when_slow(true);
+  Prog::TESTING_ONLY_set_dfa_should_bail_when_slow(true);
+  ASSERT_GT(state_cache_resets, 0);
+  ASSERT_EQ(search_failures, 0);
 }
 
 // Helper function: searches for match, which should match,
 // and no_match, which should not.
-static void DoSearch(Prog* prog, const StringPiece& match,
-                     const StringPiece& no_match) {
+static void DoSearch(Prog* prog, absl::string_view match,
+                     absl::string_view no_match) {
   for (int i = 0; i < 2; i++) {
     bool matched = false;
     bool failed = false;
-    matched = prog->SearchDFA(match, StringPiece(), Prog::kUnanchored,
-                              Prog::kFirstMatch, NULL, &failed, NULL);
+    matched =
+        prog->SearchDFA(match, absl::string_view(), Prog::kUnanchored,
+                        Prog::kFirstMatch, NULL, &failed, NULL);
     ASSERT_FALSE(failed);
     ASSERT_TRUE(matched);
-    matched = prog->SearchDFA(no_match, StringPiece(), Prog::kUnanchored,
-                              Prog::kFirstMatch, NULL, &failed, NULL);
+    matched =
+        prog->SearchDFA(no_match, absl::string_view(), Prog::kUnanchored,
+                        Prog::kFirstMatch, NULL, &failed, NULL);
     ASSERT_FALSE(failed);
     ASSERT_FALSE(matched);
   }
 }
 
 TEST(Multithreaded, SearchDFA) {
-  Prog::TEST_dfa_should_bail_when_slow(false);
+  Prog::TESTING_ONLY_set_dfa_should_bail_when_slow(false);
+  state_cache_resets = 0;
+  search_failures = 0;
 
   // Same as single-threaded test above.
   const int n = 18;
-  Regexp* re = Regexp::Parse(StringPrintf("0[01]{%d}$", n),
+  Regexp* re = Regexp::Parse(absl::StrFormat("0[01]{%d}$", n),
                              Regexp::LikePerl, NULL);
   ASSERT_TRUE(re != NULL);
-  string no_match = DeBruijnString(n);
-  string match = no_match + "0";
+  std::string no_match = DeBruijnString(n);
+  std::string match = no_match + "0";
 
   // Check that single-threaded code works.
   {
@@ -259,14 +248,14 @@ TEST(Multithreaded, SearchDFA) {
 
   // Run the search simultaneously in a bunch of threads.
   // Reuse same flags for Multithreaded.BuildDFA above.
-  for (int i = 0; i < FLAGS_repeat; i++) {
+  for (int i = 0; i < absl::GetFlag(FLAGS_repeat); i++) {
     Prog* prog = re->CompileToProg(1<<n);
     ASSERT_TRUE(prog != NULL);
 
     std::vector<std::thread> threads;
-    for (int j = 0; j < FLAGS_threads; j++)
+    for (int j = 0; j < absl::GetFlag(FLAGS_threads); j++)
       threads.emplace_back(DoSearch, prog, match, no_match);
-    for (int j = 0; j < FLAGS_threads; j++)
+    for (int j = 0; j < absl::GetFlag(FLAGS_threads); j++)
       threads[j].join();
 
     delete prog;
@@ -275,7 +264,9 @@ TEST(Multithreaded, SearchDFA) {
   re->Decref();
 
   // Reset to original behaviour.
-  Prog::TEST_dfa_should_bail_when_slow(true);
+  Prog::TESTING_ONLY_set_dfa_should_bail_when_slow(true);
+  ASSERT_GT(state_cache_resets, 0);
+  ASSERT_EQ(search_failures, 0);
 }
 
 struct ReverseTest {
@@ -295,15 +286,16 @@ ReverseTest reverse_tests[] = {
 
 TEST(DFA, ReverseMatch) {
   int nfail = 0;
-  for (int i = 0; i < arraysize(reverse_tests); i++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(reverse_tests); i++) {
     const ReverseTest& t = reverse_tests[i];
     Regexp* re = Regexp::Parse(t.regexp, Regexp::LikePerl, NULL);
     ASSERT_TRUE(re != NULL);
     Prog* prog = re->CompileToReverseProg(0);
     ASSERT_TRUE(prog != NULL);
     bool failed = false;
-    bool matched = prog->SearchDFA(t.text, StringPiece(), Prog::kUnanchored,
-                                   Prog::kFirstMatch, NULL, &failed, NULL);
+    bool matched =
+        prog->SearchDFA(t.text, absl::string_view(), Prog::kUnanchored,
+                        Prog::kFirstMatch, NULL, &failed, NULL);
     if (matched != t.match) {
       LOG(ERROR) << t.regexp << " on " << t.text << ": want " << t.match;
       nfail++;
@@ -350,22 +342,22 @@ CallbackTest callback_tests[] = {
 
 TEST(DFA, Callback) {
   int nfail = 0;
-  for (int i = 0; i < arraysize(callback_tests); i++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(callback_tests); i++) {
     const CallbackTest& t = callback_tests[i];
     Regexp* re = Regexp::Parse(t.regexp, Regexp::LikePerl, NULL);
     ASSERT_TRUE(re != NULL);
     Prog* prog = re->CompileToProg(0);
     ASSERT_TRUE(prog != NULL);
-    string dump;
+    std::string dump;
     prog->BuildEntireDFA(Prog::kLongestMatch, [&](const int* next, bool match) {
       ASSERT_TRUE(next != NULL);
       if (!dump.empty())
-        StringAppendF(&dump, " ");
-      StringAppendF(&dump, match ? "[[" : "[");
+        dump += " ";
+      dump += match ? "[[" : "[";
       for (int b = 0; b < prog->bytemap_range() + 1; b++)
-        StringAppendF(&dump, "%d,", next[b]);
+        dump += absl::StrFormat("%d,", next[b]);
       dump.pop_back();
-      StringAppendF(&dump, match ? "]]" : "]");
+      dump += match ? "]]" : "]";
     });
     if (dump != t.dump) {
       LOG(ERROR) << t.regexp << " bytemap:\n" << prog->DumpByteMap();
diff --git a/re2/testing/dump.cc b/re2/testing/dump.cc
index b60bf24..5cddd23 100644
--- a/re2/testing/dump.cc
+++ b/re2/testing/dump.cc
@@ -18,16 +18,13 @@
 
 #include <string>
 
-#include "util/test.h"
+#include "absl/base/macros.h"
+#include "absl/strings/str_format.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
-#include "util/strutil.h"
 #include "util/utf.h"
-#include "re2/stringpiece.h"
 #include "re2/regexp.h"
 
-// Cause a link error if this file is used outside of testing.
-DECLARE_string(test_tmpdir);
-
 namespace re2 {
 
 static const char* kOpcodeNames[] = {
@@ -57,9 +54,9 @@ static const char* kOpcodeNames[] = {
 
 // Create string representation of regexp with explicit structure.
 // Nothing pretty, just for testing.
-static void DumpRegexpAppending(Regexp* re, string* s) {
-  if (re->op() < 0 || re->op() >= arraysize(kOpcodeNames)) {
-    StringAppendF(s, "op%d", re->op());
+static void DumpRegexpAppending(Regexp* re, std::string* s) {
+  if (re->op() < 0 || re->op() >= ABSL_ARRAYSIZE(kOpcodeNames)) {
+    *s += absl::StrFormat("op%d", re->op());
   } else {
     switch (re->op()) {
       default:
@@ -132,19 +129,19 @@ static void DumpRegexpAppending(Regexp* re, string* s) {
       DumpRegexpAppending(re->sub()[0], s);
       break;
     case kRegexpRepeat:
-      s->append(StringPrintf("%d,%d ", re->min(), re->max()));
+      s->append(absl::StrFormat("%d,%d ", re->min(), re->max()));
       DumpRegexpAppending(re->sub()[0], s);
       break;
     case kRegexpCharClass: {
-      string sep;
+      std::string sep;
       for (CharClass::iterator it = re->cc()->begin();
            it != re->cc()->end(); ++it) {
         RuneRange rr = *it;
         s->append(sep);
         if (rr.lo == rr.hi)
-          s->append(StringPrintf("%#x", rr.lo));
+          s->append(absl::StrFormat("%#x", rr.lo));
         else
-          s->append(StringPrintf("%#x-%#x", rr.lo, rr.hi));
+          s->append(absl::StrFormat("%#x-%#x", rr.lo, rr.hi));
         sep = " ";
       }
       break;
@@ -153,15 +150,12 @@ static void DumpRegexpAppending(Regexp* re, string* s) {
   s->append("}");
 }
 
-string Regexp::Dump() {
-  string s;
-
-  // Make sure being called from a unit test.
-  if (FLAGS_test_tmpdir.empty()) {
-    LOG(ERROR) << "Cannot use except for testing.";
-    return s;
-  }
+std::string Regexp::Dump() {
+  // Make sure that we are being called from a unit test.
+  // Should cause a link error if used outside of testing.
+  CHECK(!::testing::TempDir().empty());
 
+  std::string s;
   DumpRegexpAppending(this, &s);
   return s;
 }
diff --git a/re2/testing/exhaustive1_test.cc b/re2/testing/exhaustive1_test.cc
index 29c5def..9337989 100644
--- a/re2/testing/exhaustive1_test.cc
+++ b/re2/testing/exhaustive1_test.cc
@@ -7,16 +7,14 @@
 #include <string>
 #include <vector>
 
-#include "util/test.h"
+#include "gtest/gtest.h"
 #include "re2/testing/exhaustive_tester.h"
 
-DECLARE_string(regexp_engines);
-
 namespace re2 {
 
 // Test simple repetition operators
 TEST(Repetition, Simple) {
-  std::vector<string> ops = Split(" ",
+  std::vector<std::string> ops = Split(" ",
     "%s{0} %s{0,} %s{1} %s{1,} %s{0,1} %s{0,2} "
     "%s{1,2} %s{2} %s{2,} %s{3,4} %s{4,5} "
     "%s* %s+ %s? %s*? %s+? %s??");
@@ -28,17 +26,14 @@ TEST(Repetition, Simple) {
 
 // Test capturing parens -- (a) -- inside repetition operators
 TEST(Repetition, Capturing) {
-  std::vector<string> ops = Split(" ",
+  std::vector<std::string> ops = Split(" ",
     "%s{0} %s{0,} %s{1} %s{1,} %s{0,1} %s{0,2} "
     "%s{1,2} %s{2} %s{2,} %s{3,4} %s{4,5} "
     "%s* %s+ %s? %s*? %s+? %s??");
   ExhaustiveTest(3, 2, Split(" ", "a (a) b"), ops,
                  7, Explode("ab"), "(?:%s)", "");
-
-  // This would be a great test, but it runs forever when PCRE is enabled.
-  if (FLAGS_regexp_engines.find("PCRE") == string::npos)
-    ExhaustiveTest(3, 2, Split(" ", "a (a)"), ops,
-                   50, Explode("a"), "(?:%s)", "");
+  ExhaustiveTest(3, 2, Split(" ", "a (a)"), ops,
+                 50, Explode("a"), "(?:%s)", "");
 }
 
 }  // namespace re2
diff --git a/re2/testing/exhaustive2_test.cc b/re2/testing/exhaustive2_test.cc
index ba38a6e..14f629d 100644
--- a/re2/testing/exhaustive2_test.cc
+++ b/re2/testing/exhaustive2_test.cc
@@ -9,8 +9,7 @@
 #include <string>
 #include <vector>
 
-#include "util/test.h"
-#include "re2/re2.h"
+#include "gtest/gtest.h"
 #include "re2/testing/exhaustive_tester.h"
 
 namespace re2 {
@@ -24,8 +23,8 @@ TEST(EmptyString, Exhaustive) {
 
 // Test escaped versions of regexp syntax.
 TEST(Punctuation, Literals) {
-  std::vector<string> alphabet = Explode("()*+?{}[]\\^$.");
-  std::vector<string> escaped = alphabet;
+  std::vector<std::string> alphabet = Explode("()*+?{}[]\\^$.");
+  std::vector<std::string> escaped = alphabet;
   for (size_t i = 0; i < escaped.size(); i++)
     escaped[i] = "\\" + escaped[i];
   ExhaustiveTest(1, 1, escaped, RegexpGenerator::EgrepOps(),
@@ -63,7 +62,7 @@ TEST(LineEnds, Exhaustive) {
 // provides a mechanism, and RE2 could add new syntax if needed.
 //
 // TEST(Newlines, Exhaustive) {
-//   std::vector<string> empty_vector;
+//   std::vector<std::string> empty_vector;
 //   ExhaustiveTest(1, 1, Split(" ", "\\n . a [^a]"),
 //                  RegexpGenerator::EgrepOps(),
 //                  4, Explode("a\n"), "");
diff --git a/re2/testing/exhaustive3_test.cc b/re2/testing/exhaustive3_test.cc
index cf09e18..de703c0 100644
--- a/re2/testing/exhaustive3_test.cc
+++ b/re2/testing/exhaustive3_test.cc
@@ -9,7 +9,7 @@
 #include <string>
 #include <vector>
 
-#include "util/test.h"
+#include "gtest/gtest.h"
 #include "util/utf.h"
 #include "re2/testing/exhaustive_tester.h"
 
@@ -17,7 +17,7 @@ namespace re2 {
 
 // Test simple character classes by themselves.
 TEST(CharacterClasses, Exhaustive) {
-  std::vector<string> atoms = Split(" ",
+  std::vector<std::string> atoms = Split(" ",
     "[a] [b] [ab] [^bc] [b-d] [^b-d] []a] [-a] [a-] [^-a] [a-b-c] a b .");
   ExhaustiveTest(2, 1, atoms, RegexpGenerator::EgrepOps(),
                  5, Explode("ab"), "", "");
@@ -25,25 +25,25 @@ TEST(CharacterClasses, Exhaustive) {
 
 // Test simple character classes inside a___b (for example, a[a]b).
 TEST(CharacterClasses, ExhaustiveAB) {
-  std::vector<string> atoms = Split(" ",
+  std::vector<std::string> atoms = Split(" ",
     "[a] [b] [ab] [^bc] [b-d] [^b-d] []a] [-a] [a-] [^-a] [a-b-c] a b .");
   ExhaustiveTest(2, 1, atoms, RegexpGenerator::EgrepOps(),
                  5, Explode("ab"), "a%sb", "");
 }
 
 // Returns UTF8 for Rune r
-static string UTF8(Rune r) {
+static std::string UTF8(Rune r) {
   char buf[UTFmax+1];
   buf[runetochar(buf, &r)] = 0;
-  return string(buf);
+  return std::string(buf);
 }
 
 // Returns a vector of "interesting" UTF8 characters.
 // Unicode is now too big to just return all of them,
 // so UTF8Characters return a set likely to be good test cases.
-static const std::vector<string>& InterestingUTF8() {
+static const std::vector<std::string>& InterestingUTF8() {
   static bool init;
-  static std::vector<string> v;
+  static std::vector<std::string> v;
 
   if (init)
     return v;
@@ -70,12 +70,12 @@ static const std::vector<string>& InterestingUTF8() {
 
 // Test interesting UTF-8 characters against character classes.
 TEST(InterestingUTF8, SingleOps) {
-  std::vector<string> atoms = Split(" ",
+  std::vector<std::string> atoms = Split(" ",
     ". ^ $ \\a \\f \\n \\r \\t \\v \\d \\D \\s \\S \\w \\W \\b \\B "
     "[[:alnum:]] [[:alpha:]] [[:blank:]] [[:cntrl:]] [[:digit:]] "
     "[[:graph:]] [[:lower:]] [[:print:]] [[:punct:]] [[:space:]] "
     "[[:upper:]] [[:xdigit:]] [\\s\\S] [\\d\\D] [^\\w\\W] [^\\d\\D]");
-  std::vector<string> ops;  // no ops
+  std::vector<std::string> ops;  // no ops
   ExhaustiveTest(1, 0, atoms, ops,
                  1, InterestingUTF8(), "", "");
 }
@@ -83,13 +83,13 @@ TEST(InterestingUTF8, SingleOps) {
 // Test interesting UTF-8 characters against character classes,
 // but wrap everything inside AB.
 TEST(InterestingUTF8, AB) {
-  std::vector<string> atoms = Split(" ",
+  std::vector<std::string> atoms = Split(" ",
     ". ^ $ \\a \\f \\n \\r \\t \\v \\d \\D \\s \\S \\w \\W \\b \\B "
     "[[:alnum:]] [[:alpha:]] [[:blank:]] [[:cntrl:]] [[:digit:]] "
     "[[:graph:]] [[:lower:]] [[:print:]] [[:punct:]] [[:space:]] "
     "[[:upper:]] [[:xdigit:]] [\\s\\S] [\\d\\D] [^\\w\\W] [^\\d\\D]");
-  std::vector<string> ops;  // no ops
-  std::vector<string> alpha = InterestingUTF8();
+  std::vector<std::string> ops;  // no ops
+  std::vector<std::string> alpha = InterestingUTF8();
   for (size_t i = 0; i < alpha.size(); i++)
     alpha[i] = "a" + alpha[i] + "b";
   ExhaustiveTest(1, 0, atoms, ops,
diff --git a/re2/testing/exhaustive_test.cc b/re2/testing/exhaustive_test.cc
index 514fd90..5e586f1 100644
--- a/re2/testing/exhaustive_test.cc
+++ b/re2/testing/exhaustive_test.cc
@@ -4,7 +4,7 @@
 
 // Exhaustive testing of regular expression matching.
 
-#include "util/test.h"
+#include "gtest/gtest.h"
 #include "re2/testing/exhaustive_tester.h"
 
 namespace re2 {
diff --git a/re2/testing/exhaustive_tester.cc b/re2/testing/exhaustive_tester.cc
index 4f6335f..a57f700 100644
--- a/re2/testing/exhaustive_tester.cc
+++ b/re2/testing/exhaustive_tester.cc
@@ -13,9 +13,11 @@
 
 #include <stdio.h>
 
-#include "util/test.h"
+#include "absl/base/macros.h"
+#include "absl/flags/flag.h"
+#include "absl/strings/str_format.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
-#include "util/strutil.h"
 #include "re2/testing/exhaustive_tester.h"
 #include "re2/testing/tester.h"
 
@@ -24,15 +26,15 @@
 #define LOGGING 0
 #endif
 
-DEFINE_bool(show_regexps, false, "show regexps during testing");
+ABSL_FLAG(bool, show_regexps, false, "show regexps during testing");
 
-DEFINE_int32(max_bad_regexp_inputs, 1,
-             "Stop testing a regular expression after finding this many "
-             "strings that break it.");
+ABSL_FLAG(int, max_bad_regexp_inputs, 1,
+          "Stop testing a regular expression after finding this many "
+          "strings that break it.");
 
 namespace re2 {
 
-static char* escape(const StringPiece& sp) {
+static char* escape(absl::string_view sp) {
   static char buf[512];
   char* p = buf;
   *p++ = '\"';
@@ -54,33 +56,38 @@ static char* escape(const StringPiece& sp) {
   return buf;
 }
 
-static void PrintResult(const RE2& re, const StringPiece& input, RE2::Anchor anchor, StringPiece *m, int n) {
+static void PrintResult(const RE2& re, absl::string_view input,
+                        RE2::Anchor anchor, absl::string_view* m, int n) {
   if (!re.Match(input, 0, input.size(), anchor, m, n)) {
-    printf("-");
+    absl::PrintF("-");
     return;
   }
   for (int i = 0; i < n; i++) {
     if (i > 0)
-      printf(" ");
-    if (m[i].begin() == NULL)
-      printf("-");
+      absl::PrintF(" ");
+    if (m[i].data() == NULL)
+      absl::PrintF("-");
     else
-      printf("%td-%td",
-             m[i].begin() - input.begin(), m[i].end() - input.begin());
+      absl::PrintF("%d-%d",
+                   BeginPtr(m[i]) - BeginPtr(input),
+                   EndPtr(m[i]) - BeginPtr(input));
   }
 }
 
 // Processes a single generated regexp.
 // Compiles it using Regexp interface and PCRE, and then
 // checks that NFA, DFA, and PCRE all return the same results.
-void ExhaustiveTester::HandleRegexp(const string& const_regexp) {
+void ExhaustiveTester::HandleRegexp(const std::string& const_regexp) {
   regexps_++;
-  string regexp = const_regexp;
-  if (!topwrapper_.empty())
-    regexp = StringPrintf(topwrapper_.c_str(), regexp.c_str());
+  std::string regexp = const_regexp;
+  if (!topwrapper_.empty()) {
+    auto fmt = absl::ParsedFormat<'s'>::New(topwrapper_);
+    CHECK(fmt != nullptr);
+    regexp = absl::StrFormat(*fmt, regexp);
+  }
 
-  if (FLAGS_show_regexps) {
-    printf("\r%s", regexp.c_str());
+  if (absl::GetFlag(FLAGS_show_regexps)) {
+    absl::PrintF("\r%s", regexp);
     fflush(stdout);
   }
 
@@ -90,32 +97,32 @@ void ExhaustiveTester::HandleRegexp(const string& const_regexp) {
     if (randomstrings_)
       LOG(ERROR) << "Cannot log with random strings.";
     if (regexps_ == 1) {  // first
-      printf("strings\n");
+      absl::PrintF("strings\n");
       strgen_.Reset();
       while (strgen_.HasNext())
-        printf("%s\n", escape(strgen_.Next()));
-      printf("regexps\n");
+        absl::PrintF("%s\n", escape(strgen_.Next()));
+      absl::PrintF("regexps\n");
     }
-    printf("%s\n", escape(regexp));
+    absl::PrintF("%s\n", escape(regexp));
 
     RE2 re(regexp);
     RE2::Options longest;
     longest.set_longest_match(true);
     RE2 relongest(regexp, longest);
     int ngroup = re.NumberOfCapturingGroups()+1;
-    StringPiece* group = new StringPiece[ngroup];
+    absl::string_view* group = new absl::string_view[ngroup];
 
     strgen_.Reset();
     while (strgen_.HasNext()) {
-      StringPiece input = strgen_.Next();
+      absl::string_view input = strgen_.Next();
       PrintResult(re, input, RE2::ANCHOR_BOTH, group, ngroup);
-      printf(";");
+      absl::PrintF(";");
       PrintResult(re, input, RE2::UNANCHORED, group, ngroup);
-      printf(";");
+      absl::PrintF(";");
       PrintResult(relongest, input, RE2::ANCHOR_BOTH, group, ngroup);
-      printf(";");
+      absl::PrintF(";");
       PrintResult(relongest, input, RE2::UNANCHORED, group, ngroup);
-      printf("\n");
+      absl::PrintF("\n");
     }
     delete[] group;
     return;
@@ -134,7 +141,7 @@ void ExhaustiveTester::HandleRegexp(const string& const_regexp) {
     tests_++;
     if (!tester.TestInput(strgen_.Next())) {
       failures_++;
-      if (++bad_inputs >= FLAGS_max_bad_regexp_inputs)
+      if (++bad_inputs >= absl::GetFlag(FLAGS_max_bad_regexp_inputs))
         break;
     }
   }
@@ -142,12 +149,12 @@ void ExhaustiveTester::HandleRegexp(const string& const_regexp) {
 
 // Runs an exhaustive test on the given parameters.
 void ExhaustiveTest(int maxatoms, int maxops,
-                    const std::vector<string>& alphabet,
-                    const std::vector<string>& ops,
+                    const std::vector<std::string>& alphabet,
+                    const std::vector<std::string>& ops,
                     int maxstrlen,
-                    const std::vector<string>& stralphabet,
-                    const string& wrapper,
-                    const string& topwrapper) {
+                    const std::vector<std::string>& stralphabet,
+                    const std::string& wrapper,
+                    const std::string& topwrapper) {
   if (RE2_DEBUG_MODE) {
     if (maxatoms > 1)
       maxatoms--;
@@ -161,20 +168,20 @@ void ExhaustiveTest(int maxatoms, int maxops,
                      topwrapper);
   t.Generate();
   if (!LOGGING) {
-    printf("%d regexps, %d tests, %d failures [%d/%d str]\n",
-           t.regexps(), t.tests(), t.failures(), maxstrlen, (int)stralphabet.size());
+    absl::PrintF("%d regexps, %d tests, %d failures [%d/%d str]\n",
+                 t.regexps(), t.tests(), t.failures(), maxstrlen, stralphabet.size());
   }
   EXPECT_EQ(0, t.failures());
 }
 
 // Runs an exhaustive test using the given parameters and
 // the basic egrep operators.
-void EgrepTest(int maxatoms, int maxops, const string& alphabet,
-               int maxstrlen, const string& stralphabet,
-               const string& wrapper) {
+void EgrepTest(int maxatoms, int maxops, const std::string& alphabet,
+               int maxstrlen, const std::string& stralphabet,
+               const std::string& wrapper) {
   const char* tops[] = { "", "^(?:%s)", "(?:%s)$", "^(?:%s)$" };
 
-  for (int i = 0; i < arraysize(tops); i++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(tops); i++) {
     ExhaustiveTest(maxatoms, maxops,
                    Split("", alphabet),
                    RegexpGenerator::EgrepOps(),
diff --git a/re2/testing/exhaustive_tester.h b/re2/testing/exhaustive_tester.h
index 769d8b5..906be0c 100644
--- a/re2/testing/exhaustive_tester.h
+++ b/re2/testing/exhaustive_tester.h
@@ -9,7 +9,6 @@
 #include <string>
 #include <vector>
 
-#include "util/util.h"
 #include "re2/testing/regexp_generator.h"
 #include "re2/testing/string_generator.h"
 
@@ -42,12 +41,12 @@ class ExhaustiveTester : public RegexpGenerator {
  public:
   ExhaustiveTester(int maxatoms,
                    int maxops,
-                   const std::vector<string>& alphabet,
-                   const std::vector<string>& ops,
+                   const std::vector<std::string>& alphabet,
+                   const std::vector<std::string>& ops,
                    int maxstrlen,
-                   const std::vector<string>& stralphabet,
-                   const string& wrapper,
-                   const string& topwrapper)
+                   const std::vector<std::string>& stralphabet,
+                   const std::string& wrapper,
+                   const std::string& topwrapper)
     : RegexpGenerator(maxatoms, maxops, alphabet, ops),
       strgen_(maxstrlen, stralphabet),
       wrapper_(wrapper),
@@ -60,7 +59,7 @@ class ExhaustiveTester : public RegexpGenerator {
   int failures() { return failures_; }
 
   // Needed for RegexpGenerator interface.
-  void HandleRegexp(const string& regexp);
+  void HandleRegexp(const std::string& regexp);
 
   // Causes testing to generate random input strings.
   void RandomStrings(int32_t seed, int32_t count) {
@@ -71,8 +70,8 @@ class ExhaustiveTester : public RegexpGenerator {
 
  private:
   StringGenerator strgen_;
-  string wrapper_;      // Regexp wrapper - either empty or has one %s.
-  string topwrapper_;   // Regexp top-level wrapper.
+  std::string wrapper_;      // Regexp wrapper - either empty or has one %s.
+  std::string topwrapper_;   // Regexp top-level wrapper.
   int regexps_;   // Number of HandleRegexp calls
   int tests_;     // Number of regexp tests.
   int failures_;  // Number of tests failed.
@@ -87,18 +86,18 @@ class ExhaustiveTester : public RegexpGenerator {
 
 // Runs an exhaustive test on the given parameters.
 void ExhaustiveTest(int maxatoms, int maxops,
-                    const std::vector<string>& alphabet,
-                    const std::vector<string>& ops,
+                    const std::vector<std::string>& alphabet,
+                    const std::vector<std::string>& ops,
                     int maxstrlen,
-                    const std::vector<string>& stralphabet,
-                    const string& wrapper,
-                    const string& topwrapper);
+                    const std::vector<std::string>& stralphabet,
+                    const std::string& wrapper,
+                    const std::string& topwrapper);
 
 // Runs an exhaustive test using the given parameters and
 // the basic egrep operators.
-void EgrepTest(int maxatoms, int maxops, const string& alphabet,
-               int maxstrlen, const string& stralphabet,
-               const string& wrapper);
+void EgrepTest(int maxatoms, int maxops, const std::string& alphabet,
+               int maxstrlen, const std::string& stralphabet,
+               const std::string& wrapper);
 
 }  // namespace re2
 
diff --git a/re2/testing/filtered_re2_test.cc b/re2/testing/filtered_re2_test.cc
index 867eac6..a8d2dfc 100644
--- a/re2/testing/filtered_re2_test.cc
+++ b/re2/testing/filtered_re2_test.cc
@@ -7,8 +7,10 @@
 #include <memory>
 #include <string>
 #include <vector>
+#include <utility>
 
-#include "util/test.h"
+#include "absl/base/macros.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
 #include "re2/filtered_re2.h"
 #include "re2/re2.h"
@@ -19,7 +21,7 @@ struct FilterTestVars {
   FilterTestVars() {}
   explicit FilterTestVars(int min_atom_len) : f(min_atom_len) {}
 
-  std::vector<string> atoms;
+  std::vector<std::string> atoms;
   std::vector<int> atom_indices;
   std::vector<int> matches;
   RE2::Options opts;
@@ -105,12 +107,13 @@ AtomTest atom_tests[] = {
     // substring in an OR are removed; that is, only the shortest
     // substring is kept.
     "SubstrAtomRemovesSuperStrInOr", {
-      "(abc123|abc|ghi789|abc1234).*[x-z]+",
+      "(abc123|abc|defxyz|ghi789|abc1234|xyz).*[x-z]+",
       "abcd..yyy..yyyzzz",
       "mnmnpp[a-z]+PPP"
     }, {
       "abc",
       "ghi789",
+      "xyz",
       "abcd",
       "yyy",
       "yyyzzz",
@@ -144,9 +147,9 @@ AtomTest atom_tests[] = {
 };
 
 void AddRegexpsAndCompile(const char* regexps[],
-                          int n,
+                          size_t n,
                           struct FilterTestVars* v) {
-  for (int i = 0; i < n; i++) {
+  for (size_t i = 0; i < n; i++) {
     int id;
     v->f.Add(regexps[i], v->opts, &id);
   }
@@ -154,18 +157,18 @@ void AddRegexpsAndCompile(const char* regexps[],
 }
 
 bool CheckExpectedAtoms(const char* atoms[],
-                        int n,
+                        size_t n,
                         const char* testname,
                         struct FilterTestVars* v) {
-  std::vector<string> expected;
-  for (int i = 0; i < n; i++)
+  std::vector<std::string> expected;
+  for (size_t i = 0; i < n; i++)
     expected.push_back(atoms[i]);
 
   bool pass = expected.size() == v->atoms.size();
 
   std::sort(v->atoms.begin(), v->atoms.end());
   std::sort(expected.begin(), expected.end());
-  for (int i = 0; pass && i < n; i++)
+  for (size_t i = 0; pass && i < n; i++)
       pass = pass && expected[i] == v->atoms[i];
 
   if (!pass) {
@@ -183,14 +186,14 @@ bool CheckExpectedAtoms(const char* atoms[],
 
 TEST(FilteredRE2Test, AtomTests) {
   int nfail = 0;
-  for (int i = 0; i < arraysize(atom_tests); i++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(atom_tests); i++) {
     FilterTestVars v;
     AtomTest* t = &atom_tests[i];
-    int natom, nregexp;
-    for (nregexp = 0; nregexp < arraysize(t->regexps); nregexp++)
+    size_t nregexp, natom;
+    for (nregexp = 0; nregexp < ABSL_ARRAYSIZE(t->regexps); nregexp++)
       if (t->regexps[nregexp] == NULL)
         break;
-    for (natom = 0; natom < arraysize(t->atoms); natom++)
+    for (natom = 0; natom < ABSL_ARRAYSIZE(t->atoms); natom++)
       if (t->atoms[natom] == NULL)
         break;
     AddRegexpsAndCompile(t->regexps, nregexp, &v);
@@ -200,8 +203,8 @@ TEST(FilteredRE2Test, AtomTests) {
   EXPECT_EQ(0, nfail);
 }
 
-void FindAtomIndices(const std::vector<string>& atoms,
-                     const std::vector<string>& matched_atoms,
+void FindAtomIndices(const std::vector<std::string>& atoms,
+                     const std::vector<std::string>& matched_atoms,
                      std::vector<int>* atom_indices) {
   atom_indices->clear();
   for (size_t i = 0; i < matched_atoms.size(); i++) {
@@ -220,13 +223,13 @@ TEST(FilteredRE2Test, MatchEmptyPattern) {
   // We are using the regexps used in one of the atom tests
   // for this test. Adding the EXPECT here to make sure
   // the index we use for the test is for the correct test.
-  EXPECT_EQ("CheckEmptyPattern", string(t->testname));
-  int nregexp;
-  for (nregexp = 0; nregexp < arraysize(t->regexps); nregexp++)
+  EXPECT_EQ("CheckEmptyPattern", std::string(t->testname));
+  size_t nregexp;
+  for (nregexp = 0; nregexp < ABSL_ARRAYSIZE(t->regexps); nregexp++)
     if (t->regexps[nregexp] == NULL)
       break;
   AddRegexpsAndCompile(t->regexps, nregexp, &v);
-  string text = "0123";
+  std::string text = "0123";
   std::vector<int> atom_ids;
   std::vector<int> matching_regexps;
   EXPECT_EQ(0, v.f.FirstMatch(text, atom_ids));
@@ -237,17 +240,17 @@ TEST(FilteredRE2Test, MatchTests) {
   AtomTest* t = &atom_tests[2];
   // We are using the regexps used in one of the atom tests
   // for this test.
-  EXPECT_EQ("SubstrAtomRemovesSuperStrInOr", string(t->testname));
-  int nregexp;
-  for (nregexp = 0; nregexp < arraysize(t->regexps); nregexp++)
+  EXPECT_EQ("SubstrAtomRemovesSuperStrInOr", std::string(t->testname));
+  size_t nregexp;
+  for (nregexp = 0; nregexp < ABSL_ARRAYSIZE(t->regexps); nregexp++)
     if (t->regexps[nregexp] == NULL)
       break;
   AddRegexpsAndCompile(t->regexps, nregexp, &v);
 
-  string text = "abc121212xyz";
+  std::string text = "abc121212xyz";
   // atoms = abc
   std::vector<int> atom_ids;
-  std::vector<string> atoms;
+  std::vector<std::string> atoms;
   atoms.push_back("abc");
   FindAtomIndices(v.atoms, atoms, &atom_ids);
   std::vector<int> matching_regexps;
@@ -277,4 +280,63 @@ TEST(FilteredRE2Test, MatchTests) {
   EXPECT_EQ(2, matching_regexps.size());
 }
 
+TEST(FilteredRE2Test, EmptyStringInStringSetBug) {
+  // Bug due to find() finding "" at the start of everything in a string
+  // set and thus SimplifyStringSet() would end up erasing everything.
+  // In order to test this, we have to keep PrefilterTree from discarding
+  // the OR entirely, so we have to make the minimum atom length zero.
+
+  FilterTestVars v(0);  // override the minimum atom length
+  const char* regexps[] = {"-R.+(|ADD=;AA){12}}"};
+  const char* atoms[] = {"", "-r", "add=;aa", "}"};
+  AddRegexpsAndCompile(regexps, ABSL_ARRAYSIZE(regexps), &v);
+  EXPECT_TRUE(CheckExpectedAtoms(atoms, ABSL_ARRAYSIZE(atoms),
+                                 "EmptyStringInStringSetBug", &v));
+}
+
+TEST(FilteredRE2Test, MoveSemantics) {
+  FilterTestVars v1;
+  int id;
+  v1.f.Add("foo\\d+", v1.opts, &id);
+  EXPECT_EQ(0, id);
+  v1.f.Compile(&v1.atoms);
+  EXPECT_EQ(1, v1.atoms.size());
+  EXPECT_EQ("foo", v1.atoms[0]);
+  v1.f.AllMatches("abc foo1 xyz", {0}, &v1.matches);
+  EXPECT_EQ(1, v1.matches.size());
+  EXPECT_EQ(0, v1.matches[0]);
+  v1.f.AllMatches("abc bar2 xyz", {0}, &v1.matches);
+  EXPECT_EQ(0, v1.matches.size());
+
+  // The moved-to object should do what the moved-from object did.
+  FilterTestVars v2;
+  v2.f = std::move(v1.f);
+  v2.f.AllMatches("abc foo1 xyz", {0}, &v2.matches);
+  EXPECT_EQ(1, v2.matches.size());
+  EXPECT_EQ(0, v2.matches[0]);
+  v2.f.AllMatches("abc bar2 xyz", {0}, &v2.matches);
+  EXPECT_EQ(0, v2.matches.size());
+
+  // The moved-from object should have been reset and be reusable.
+  v1.f.Add("bar\\d+", v1.opts, &id);
+  EXPECT_EQ(0, id);
+  v1.f.Compile(&v1.atoms);
+  EXPECT_EQ(1, v1.atoms.size());
+  EXPECT_EQ("bar", v1.atoms[0]);
+  v1.f.AllMatches("abc foo1 xyz", {0}, &v1.matches);
+  EXPECT_EQ(0, v1.matches.size());
+  v1.f.AllMatches("abc bar2 xyz", {0}, &v1.matches);
+  EXPECT_EQ(1, v1.matches.size());
+  EXPECT_EQ(0, v1.matches[0]);
+
+  // Verify that "overwriting" works and also doesn't leak memory.
+  // (The latter will need a leak detector such as LeakSanitizer.)
+  v1.f = std::move(v2.f);
+  v1.f.AllMatches("abc foo1 xyz", {0}, &v1.matches);
+  EXPECT_EQ(1, v1.matches.size());
+  EXPECT_EQ(0, v1.matches[0]);
+  v1.f.AllMatches("abc bar2 xyz", {0}, &v1.matches);
+  EXPECT_EQ(0, v1.matches.size());
+}
+
 }  //  namespace re2
diff --git a/re2/testing/mimics_pcre_test.cc b/re2/testing/mimics_pcre_test.cc
index 2dbbfa1..829659d 100644
--- a/re2/testing/mimics_pcre_test.cc
+++ b/re2/testing/mimics_pcre_test.cc
@@ -2,7 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-#include "util/test.h"
+#include "absl/base/macros.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
 #include "re2/prog.h"
 #include "re2/regexp.h"
@@ -58,9 +59,9 @@ static PCRETest tests[] = {
 };
 
 TEST(MimicsPCRE, SimpleTests) {
-  for (int i = 0; i < arraysize(tests); i++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(tests); i++) {
     const PCRETest& t = tests[i];
-    for (int j = 0; j < 2; j++) {
+    for (size_t j = 0; j < 2; j++) {
       Regexp::ParseFlags flags = Regexp::LikePerl;
       if (j == 0)
         flags = flags | Regexp::Latin1;
@@ -68,7 +69,7 @@ TEST(MimicsPCRE, SimpleTests) {
       ASSERT_TRUE(re != NULL) << " " << t.regexp;
       ASSERT_EQ(t.should_match, re->MimicsPCRE())
         << " " << t.regexp << " "
-        << (j==0 ? "latin1" : "utf");
+        << (j == 0 ? "latin1" : "utf");
       re->Decref();
     }
   }
diff --git a/re2/testing/null_walker.cc b/re2/testing/null_walker.cc
index 77fa723..745364b 100644
--- a/re2/testing/null_walker.cc
+++ b/re2/testing/null_walker.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-#include "util/test.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
 #include "re2/regexp.h"
 #include "re2/walker-inl.h"
@@ -13,13 +13,16 @@ namespace re2 {
 
 class NullWalker : public Regexp::Walker<bool> {
  public:
-  NullWalker() { }
-  bool PostVisit(Regexp* re, bool parent_arg, bool pre_arg,
-                 bool* child_args, int nchild_args);
+  NullWalker() {}
 
-  bool ShortVisit(Regexp* re, bool a) {
-    // Should never be called: we use Walk not WalkExponential.
+  virtual bool PostVisit(Regexp* re, bool parent_arg, bool pre_arg,
+                         bool* child_args, int nchild_args);
+
+  virtual bool ShortVisit(Regexp* re, bool a) {
+    // Should never be called: we use Walk(), not WalkExponential().
+#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
     LOG(DFATAL) << "NullWalker::ShortVisit called";
+#endif
     return a;
   }
 
diff --git a/re2/testing/parse_test.cc b/re2/testing/parse_test.cc
index d2b04fc..9d39544 100644
--- a/re2/testing/parse_test.cc
+++ b/re2/testing/parse_test.cc
@@ -6,7 +6,8 @@
 
 #include <string>
 
-#include "util/test.h"
+#include "absl/base/macros.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
 #include "re2/regexp.h"
 
@@ -164,6 +165,7 @@ static Test tests[] = {
 
   // Test named captures
   { "(?P<name>a)", "cap{name:lit{a}}" },
+  { "(?P<>a)", "cap{:lit{a}}" },
 
   // Case-folded literals
   { "[Aa]", "litfold{a}" },
@@ -217,6 +219,10 @@ static Test tests[] = {
     Regexp::PerlClasses | Regexp::NeverNL },
   { "\\S", "cc{0-0x8 0xb 0xe-0x1f 0x21-0x10ffff}",
     Regexp::PerlClasses | Regexp::NeverNL | Regexp::FoldCase },
+
+  // Bug in Regexp::ToString() that emitted [^], which
+  // would (obviously) fail to parse when fed back in.
+  { "[\\s\\S]", "cc{0-0x10ffff}" },
 };
 
 bool RegexpEqualTestingOnly(Regexp* a, Regexp* b) {
@@ -224,7 +230,7 @@ bool RegexpEqualTestingOnly(Regexp* a, Regexp* b) {
 }
 
 void TestParse(const Test* tests, int ntests, Regexp::ParseFlags flags,
-               const string& title) {
+               const std::string& title) {
   Regexp** re = new Regexp*[ntests];
   for (int i = 0; i < ntests; i++) {
     RegexpStatus status;
@@ -235,14 +241,16 @@ void TestParse(const Test* tests, int ntests, Regexp::ParseFlags flags,
     re[i] = Regexp::Parse(tests[i].regexp, f, &status);
     ASSERT_TRUE(re[i] != NULL)
       << " " << tests[i].regexp << " " << status.Text();
-    string s = re[i]->Dump();
-    EXPECT_EQ(string(tests[i].parse), s) << "Regexp: " << tests[i].regexp
-      << "\nparse: " << string(tests[i].parse) << " s: " << s << " flag=" << f;
+    std::string s = re[i]->Dump();
+    EXPECT_EQ(std::string(tests[i].parse), s)
+        << "Regexp: " << tests[i].regexp
+        << "\nparse: " << std::string(tests[i].parse)
+        << " s: " << s << " flag=" << f;
   }
 
   for (int i = 0; i < ntests; i++) {
     for (int j = 0; j < ntests; j++) {
-      EXPECT_EQ(string(tests[i].parse) == string(tests[j].parse),
+      EXPECT_EQ(std::string(tests[i].parse) == std::string(tests[j].parse),
                 RegexpEqualTestingOnly(re[i], re[j]))
         << "Regexp: " << tests[i].regexp << " " << tests[j].regexp;
     }
@@ -255,7 +263,7 @@ void TestParse(const Test* tests, int ntests, Regexp::ParseFlags flags,
 
 // Test that regexps parse to expected structures.
 TEST(TestParse, SimpleRegexps) {
-  TestParse(tests, arraysize(tests), kTestFlags, "simple");
+  TestParse(tests, ABSL_ARRAYSIZE(tests), kTestFlags, "simple");
 }
 
 Test foldcase_tests[] = {
@@ -272,7 +280,7 @@ Test foldcase_tests[] = {
 
 // Test that parsing with FoldCase works.
 TEST(TestParse, FoldCase) {
-  TestParse(foldcase_tests, arraysize(foldcase_tests), Regexp::FoldCase, "foldcase");
+  TestParse(foldcase_tests, ABSL_ARRAYSIZE(foldcase_tests), Regexp::FoldCase, "foldcase");
 }
 
 Test literal_tests[] = {
@@ -281,7 +289,7 @@ Test literal_tests[] = {
 
 // Test that parsing with Literal works.
 TEST(TestParse, Literal) {
-  TestParse(literal_tests, arraysize(literal_tests), Regexp::Literal, "literal");
+  TestParse(literal_tests, ABSL_ARRAYSIZE(literal_tests), Regexp::Literal, "literal");
 }
 
 Test matchnl_tests[] = {
@@ -294,7 +302,7 @@ Test matchnl_tests[] = {
 // Test that parsing with MatchNL works.
 // (Also tested above during simple cases.)
 TEST(TestParse, MatchNL) {
-  TestParse(matchnl_tests, arraysize(matchnl_tests), Regexp::MatchNL, "with MatchNL");
+  TestParse(matchnl_tests, ABSL_ARRAYSIZE(matchnl_tests), Regexp::MatchNL, "with MatchNL");
 }
 
 Test nomatchnl_tests[] = {
@@ -306,7 +314,7 @@ Test nomatchnl_tests[] = {
 
 // Test that parsing without MatchNL works.
 TEST(TestParse, NoMatchNL) {
-  TestParse(nomatchnl_tests, arraysize(nomatchnl_tests), Regexp::NoParseFlags, "without MatchNL");
+  TestParse(nomatchnl_tests, ABSL_ARRAYSIZE(nomatchnl_tests), Regexp::NoParseFlags, "without MatchNL");
 }
 
 Test prefix_tests[] = {
@@ -350,7 +358,7 @@ Test prefix_tests[] = {
 
 // Test that prefix factoring works.
 TEST(TestParse, Prefix) {
-  TestParse(prefix_tests, arraysize(prefix_tests), Regexp::PerlX, "prefix");
+  TestParse(prefix_tests, ABSL_ARRAYSIZE(prefix_tests), Regexp::PerlX, "prefix");
 }
 
 Test nested_tests[] = {
@@ -366,7 +374,7 @@ Test nested_tests[] = {
 
 // Test that nested repetition works.
 TEST(TestParse, Nested) {
-  TestParse(nested_tests, arraysize(nested_tests), Regexp::PerlX, "nested");
+  TestParse(nested_tests, ABSL_ARRAYSIZE(nested_tests), Regexp::PerlX, "nested");
 }
 
 // Invalid regular expressions
@@ -421,20 +429,20 @@ const char* only_posix[] = {
 
 // Test that parser rejects bad regexps.
 TEST(TestParse, InvalidRegexps) {
-  for (int i = 0; i < arraysize(badtests); i++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(badtests); i++) {
     ASSERT_TRUE(Regexp::Parse(badtests[i], Regexp::PerlX, NULL) == NULL)
       << " " << badtests[i];
     ASSERT_TRUE(Regexp::Parse(badtests[i], Regexp::NoParseFlags, NULL) == NULL)
       << " " << badtests[i];
   }
-  for (int i = 0; i < arraysize(only_posix); i++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(only_posix); i++) {
     ASSERT_TRUE(Regexp::Parse(only_posix[i], Regexp::PerlX, NULL) == NULL)
       << " " << only_posix[i];
     Regexp* re = Regexp::Parse(only_posix[i], Regexp::NoParseFlags, NULL);
     ASSERT_TRUE(re != NULL) << " " << only_posix[i];
     re->Decref();
   }
-  for (int i = 0; i < arraysize(only_perl); i++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(only_perl); i++) {
     ASSERT_TRUE(Regexp::Parse(only_perl[i], Regexp::NoParseFlags, NULL) == NULL)
       << " " << only_perl[i];
     Regexp* re = Regexp::Parse(only_perl[i], Regexp::PerlX, NULL);
@@ -445,7 +453,7 @@ TEST(TestParse, InvalidRegexps) {
 
 // Test that ToString produces original regexp or equivalent one.
 TEST(TestToString, EquivalentParse) {
-  for (int i = 0; i < arraysize(tests); i++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(tests); i++) {
     RegexpStatus status;
     Regexp::ParseFlags f = kTestFlags;
     if (tests[i].flags != 0) {
@@ -453,9 +461,12 @@ TEST(TestToString, EquivalentParse) {
     }
     Regexp* re = Regexp::Parse(tests[i].regexp, f, &status);
     ASSERT_TRUE(re != NULL) << " " << tests[i].regexp << " " << status.Text();
-    string s = re->Dump();
-    EXPECT_EQ(string(tests[i].parse), s) << " " << tests[i].regexp << " " << string(tests[i].parse) << " " << s;
-    string t = re->ToString();
+    std::string s = re->Dump();
+    EXPECT_EQ(std::string(tests[i].parse), s)
+        << "Regexp: " << tests[i].regexp
+        << "\nparse: " << std::string(tests[i].parse)
+        << " s: " << s << " flag=" << f;
+    std::string t = re->ToString();
     if (t != tests[i].regexp) {
       // If ToString didn't return the original regexp,
       // it must have found one with fewer parens.
@@ -468,8 +479,8 @@ TEST(TestToString, EquivalentParse) {
       // Test that if we parse the new regexp we get the same structure.
       Regexp* nre = Regexp::Parse(t, Regexp::MatchNL | Regexp::PerlX, &status);
       ASSERT_TRUE(nre != NULL) << " reparse " << t << " " << status.Text();
-      string ss = nre->Dump();
-      string tt = nre->ToString();
+      std::string ss = nre->Dump();
+      std::string tt = nre->ToString();
       if (s != ss || t != tt)
         LOG(INFO) << "ToString(" << tests[i].regexp << ") = " << t;
       EXPECT_EQ(s, ss);
diff --git a/re2/testing/possible_match_test.cc b/re2/testing/possible_match_test.cc
index f43a78b..fe199c6 100644
--- a/re2/testing/possible_match_test.cc
+++ b/re2/testing/possible_match_test.cc
@@ -6,9 +6,10 @@
 #include <string>
 #include <vector>
 
-#include "util/test.h"
+#include "absl/base/macros.h"
+#include "absl/strings/escaping.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
-#include "util/strutil.h"
 #include "re2/prog.h"
 #include "re2/re2.h"
 #include "re2/regexp.h"
@@ -21,8 +22,8 @@ namespace re2 {
 // Test that C++ strings are compared as uint8s, not int8s.
 // PossibleMatchRange doesn't depend on this, but callers probably will.
 TEST(CplusplusStrings, EightBit) {
-  string s = "\x70";
-  string t = "\xA0";
+  std::string s = "\x70";
+  std::string t = "\xA0";
   EXPECT_LT(s, t);
 }
 
@@ -107,12 +108,12 @@ static PrefixTest tests[] = {
 };
 
 TEST(PossibleMatchRange, HandWritten) {
-  for (int i = 0; i < arraysize(tests); i++) {
-    for (int j = 0; j < 2; j++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(tests); i++) {
+    for (size_t j = 0; j < 2; j++) {
       const PrefixTest& t = tests[i];
-      string min, max;
+      std::string min, max;
       if (j == 0) {
-        LOG(INFO) << "Checking regexp=" << CEscape(t.regexp);
+        LOG(INFO) << "Checking regexp=" << absl::CEscape(t.regexp);
         Regexp* re = Regexp::Parse(t.regexp, Regexp::LikePerl, NULL);
         ASSERT_TRUE(re != NULL);
         Prog* prog = re->CompileToProg(0);
@@ -132,7 +133,7 @@ TEST(PossibleMatchRange, HandWritten) {
 
 // Test cases where PossibleMatchRange should return false.
 TEST(PossibleMatchRange, Failures) {
-  string min, max;
+  std::string min, max;
 
   // Fails because no room to write max.
   EXPECT_FALSE(RE2("abc").PossibleMatchRange(&min, &max, 0));
@@ -142,26 +143,26 @@ TEST(PossibleMatchRange, Failures) {
   // are no valid UTF-8 strings beginning with byte 0xFF.
   EXPECT_FALSE(RE2("[\\s\\S]+", RE2::Latin1).
                PossibleMatchRange(&min, &max, 10))
-      << "min=" << CEscape(min) << ", max=" << CEscape(max);
+      << "min=" << absl::CEscape(min) << ", max=" << absl::CEscape(max);
   EXPECT_FALSE(RE2("[\\0-\xFF]+", RE2::Latin1).
                PossibleMatchRange(&min, &max, 10))
-      << "min=" << CEscape(min) << ", max=" << CEscape(max);
+      << "min=" << absl::CEscape(min) << ", max=" << absl::CEscape(max);
   EXPECT_FALSE(RE2(".+hello", RE2::Latin1).
                PossibleMatchRange(&min, &max, 10))
-      << "min=" << CEscape(min) << ", max=" << CEscape(max);
+      << "min=" << absl::CEscape(min) << ", max=" << absl::CEscape(max);
   EXPECT_FALSE(RE2(".*hello", RE2::Latin1).
                PossibleMatchRange(&min, &max, 10))
-      << "min=" << CEscape(min) << ", max=" << CEscape(max);
+      << "min=" << absl::CEscape(min) << ", max=" << absl::CEscape(max);
   EXPECT_FALSE(RE2(".*", RE2::Latin1).
                PossibleMatchRange(&min, &max, 10))
-      << "min=" << CEscape(min) << ", max=" << CEscape(max);
+      << "min=" << absl::CEscape(min) << ", max=" << absl::CEscape(max);
   EXPECT_FALSE(RE2("\\C*").
                PossibleMatchRange(&min, &max, 10))
-      << "min=" << CEscape(min) << ", max=" << CEscape(max);
+      << "min=" << absl::CEscape(min) << ", max=" << absl::CEscape(max);
 
   // Fails because it's a malformed regexp.
   EXPECT_FALSE(RE2("*hello").PossibleMatchRange(&min, &max, 10))
-      << "min=" << CEscape(min) << ", max=" << CEscape(max);
+      << "min=" << absl::CEscape(min) << ", max=" << absl::CEscape(max);
 }
 
 // Exhaustive test: generate all regexps within parameters,
@@ -172,10 +173,10 @@ class PossibleMatchTester : public RegexpGenerator {
  public:
   PossibleMatchTester(int maxatoms,
                       int maxops,
-                      const std::vector<string>& alphabet,
-                      const std::vector<string>& ops,
+                      const std::vector<std::string>& alphabet,
+                      const std::vector<std::string>& ops,
                       int maxstrlen,
-                      const std::vector<string>& stralphabet)
+                      const std::vector<std::string>& stralphabet)
     : RegexpGenerator(maxatoms, maxops, alphabet, ops),
       strgen_(maxstrlen, stralphabet),
       regexps_(0), tests_(0) { }
@@ -184,7 +185,7 @@ class PossibleMatchTester : public RegexpGenerator {
   int tests()    { return tests_; }
 
   // Needed for RegexpGenerator interface.
-  void HandleRegexp(const string& regexp);
+  void HandleRegexp(const std::string& regexp);
 
  private:
   StringGenerator strgen_;
@@ -198,27 +199,27 @@ class PossibleMatchTester : public RegexpGenerator {
 
 // Processes a single generated regexp.
 // Checks that all accepted strings agree with the prefix range.
-void PossibleMatchTester::HandleRegexp(const string& regexp) {
+void PossibleMatchTester::HandleRegexp(const std::string& regexp) {
   regexps_++;
 
-  VLOG(3) << CEscape(regexp);
+  VLOG(3) << absl::CEscape(regexp);
 
   RE2 re(regexp, RE2::Latin1);
   ASSERT_EQ(re.error(), "");
 
-  string min, max;
+  std::string min, max;
   if(!re.PossibleMatchRange(&min, &max, 10)) {
     // There's no good max for "\\C*".  Can't use strcmp
     // because sometimes it gets embedded in more
     // complicated expressions.
     if(strstr(regexp.c_str(), "\\C*"))
       return;
-    LOG(QFATAL) << "PossibleMatchRange failed on: " << CEscape(regexp);
+    LOG(QFATAL) << "PossibleMatchRange failed on: " << absl::CEscape(regexp);
   }
 
   strgen_.Reset();
   while (strgen_.HasNext()) {
-    const StringPiece& s = strgen_.Next();
+    absl::string_view s = strgen_.Next();
     tests_++;
     if (!RE2::FullMatch(s, re))
       continue;
diff --git a/re2/testing/random_test.cc b/re2/testing/random_test.cc
index bd0842f..d076b39 100644
--- a/re2/testing/random_test.cc
+++ b/re2/testing/random_test.cc
@@ -8,13 +8,15 @@
 #include <string>
 #include <vector>
 
-#include "util/test.h"
+#include "absl/flags/flag.h"
+#include "absl/strings/str_format.h"
+#include "gtest/gtest.h"
 #include "re2/testing/exhaustive_tester.h"
 
-DEFINE_int32(regexpseed, 404, "Random regexp seed.");
-DEFINE_int32(regexpcount, 100, "How many random regexps to generate.");
-DEFINE_int32(stringseed, 200, "Random string seed.");
-DEFINE_int32(stringcount, 100, "How many random strings to generate.");
+ABSL_FLAG(int, regexpseed, 404, "Random regexp seed.");
+ABSL_FLAG(int, regexpcount, 100, "How many random regexps to generate.");
+ABSL_FLAG(int, stringseed, 200, "Random string seed.");
+ABSL_FLAG(int, stringcount, 100, "How many random strings to generate.");
 
 namespace re2 {
 
@@ -22,11 +24,11 @@ namespace re2 {
 // (Always uses the same random seeds for reproducibility.
 // Can give different seeds on command line.)
 static void RandomTest(int maxatoms, int maxops,
-                       const std::vector<string>& alphabet,
-                       const std::vector<string>& ops,
+                       const std::vector<std::string>& alphabet,
+                       const std::vector<std::string>& ops,
                        int maxstrlen,
-                       const std::vector<string>& stralphabet,
-                       const string& wrapper) {
+                       const std::vector<std::string>& stralphabet,
+                       const std::string& wrapper) {
   // Limit to smaller test cases in debug mode,
   // because everything is so much slower.
   if (RE2_DEBUG_MODE) {
@@ -37,10 +39,12 @@ static void RandomTest(int maxatoms, int maxops,
 
   ExhaustiveTester t(maxatoms, maxops, alphabet, ops,
                      maxstrlen, stralphabet, wrapper, "");
-  t.RandomStrings(FLAGS_stringseed, FLAGS_stringcount);
-  t.GenerateRandom(FLAGS_regexpseed, FLAGS_regexpcount);
-  printf("%d regexps, %d tests, %d failures [%d/%d str]\n",
-         t.regexps(), t.tests(), t.failures(), maxstrlen, (int)stralphabet.size());
+  t.RandomStrings(absl::GetFlag(FLAGS_stringseed),
+                  absl::GetFlag(FLAGS_stringcount));
+  t.GenerateRandom(absl::GetFlag(FLAGS_regexpseed),
+                   absl::GetFlag(FLAGS_regexpcount));
+  absl::PrintF("%d regexps, %d tests, %d failures [%d/%d str]\n",
+               t.regexps(), t.tests(), t.failures(), maxstrlen, stralphabet.size());
   EXPECT_EQ(0, t.failures());
 }
 
@@ -79,7 +83,7 @@ TEST(Random, BigEgrepCaptures) {
 // character classes like \d.  (Adding larger character classes would
 // make for too many possibilities.)
 TEST(Random, Complicated) {
-  std::vector<string> ops = Split(" ",
+  std::vector<std::string> ops = Split(" ",
     "%s%s %s|%s %s* %s*? %s+ %s+? %s? %s?? "
     "%s{0} %s{0,} %s{1} %s{1,} %s{0,1} %s{0,2} %s{1,2} "
     "%s{2} %s{2,} %s{3,4} %s{4,5}");
@@ -87,13 +91,12 @@ TEST(Random, Complicated) {
   // Use (?:\b) and (?:\B) instead of \b and \B,
   // because PCRE rejects \b* but accepts (?:\b)*.
   // Ditto ^ and $.
-  std::vector<string> atoms = Split(" ",
+  std::vector<std::string> atoms = Split(" ",
     ". (?:^) (?:$) \\a \\f \\n \\r \\t \\v "
     "\\d \\D \\s \\S \\w \\W (?:\\b) (?:\\B) "
     "a (a) b c - \\\\");
-  std::vector<string> alphabet = Explode("abc123\001\002\003\t\r\n\v\f\a");
+  std::vector<std::string> alphabet = Explode("abc123\001\002\003\t\r\n\v\f\a");
   RandomTest(10, 10, atoms, ops, 20, alphabet, "");
 }
 
 }  // namespace re2
-
diff --git a/re2/testing/re2_arg_test.cc b/re2/testing/re2_arg_test.cc
index 7a38de7..4b00be3 100644
--- a/re2/testing/re2_arg_test.cc
+++ b/re2/testing/re2_arg_test.cc
@@ -10,7 +10,9 @@
 #include <stdint.h>
 #include <string.h>
 
-#include "util/test.h"
+#include "absl/base/macros.h"
+#include "gtest/gtest.h"
+#include "util/logging.h"
 #include "re2/re2.h"
 
 namespace re2 {
@@ -86,7 +88,7 @@ const SuccessTable kSuccessTable[] = {
 { "18446744073709551616", 0,    { false, false, false, false, false, false }},
 };
 
-const int kNumStrings = arraysize(kSuccessTable);
+const int kNumStrings = ABSL_ARRAYSIZE(kSuccessTable);
 
 // It's ugly to use a macro, but we apparently can't use the EXPECT_EQ
 // macro outside of a TEST block and this seems to be the only way to
@@ -132,4 +134,50 @@ TEST(RE2ArgTest, Uint64Test) {
   PARSE_FOR_TYPE(uint64_t, 5);
 }
 
+TEST(RE2ArgTest, ParseFromTest) {
+#if !defined(_MSC_VER)
+  struct {
+    bool ParseFrom(const char* str, size_t n) {
+      LOG(INFO) << "str = " << str << ", n = " << n;
+      return true;
+    }
+  } obj1;
+  RE2::Arg arg1(&obj1);
+  EXPECT_TRUE(arg1.Parse("one", 3));
+
+  struct {
+    bool ParseFrom(const char* str, size_t n) {
+      LOG(INFO) << "str = " << str << ", n = " << n;
+      return false;
+    }
+    // Ensure that RE2::Arg works even with overloaded ParseFrom().
+    void ParseFrom(const char* str) {}
+  } obj2;
+  RE2::Arg arg2(&obj2);
+  EXPECT_FALSE(arg2.Parse("two", 3));
+#endif
+}
+
+TEST(RE2ArgTest, OptionalDoubleTest) {
+  absl::optional<double> opt;
+  RE2::Arg arg(&opt);
+  EXPECT_TRUE(arg.Parse(NULL, 0));
+  EXPECT_FALSE(opt.has_value());
+  EXPECT_FALSE(arg.Parse("", 0));
+  EXPECT_TRUE(arg.Parse("28.30", 5));
+  EXPECT_TRUE(opt.has_value());
+  EXPECT_EQ(*opt, 28.30);
+}
+
+TEST(RE2ArgTest, OptionalIntWithCRadixTest) {
+  absl::optional<int> opt;
+  RE2::Arg arg = RE2::CRadix(&opt);
+  EXPECT_TRUE(arg.Parse(NULL, 0));
+  EXPECT_FALSE(opt.has_value());
+  EXPECT_FALSE(arg.Parse("", 0));
+  EXPECT_TRUE(arg.Parse("0xb0e", 5));
+  EXPECT_TRUE(opt.has_value());
+  EXPECT_EQ(*opt, 2830);
+}
+
 }  // namespace re2
diff --git a/re2/testing/re2_test.cc b/re2/testing/re2_test.cc
index cae956c..151525f 100644
--- a/re2/testing/re2_test.cc
+++ b/re2/testing/re2_test.cc
@@ -12,14 +12,16 @@
 #include <map>
 #include <string>
 #include <utility>
+#include <vector>
 #if !defined(_MSC_VER) && !defined(__CYGWIN__) && !defined(__MINGW32__)
 #include <sys/mman.h>
 #include <unistd.h>  /* for sysconf */
 #endif
 
-#include "util/test.h"
+#include "absl/base/macros.h"
+#include "absl/strings/str_format.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
-#include "util/strutil.h"
 #include "re2/re2.h"
 #include "re2/regexp.h"
 
@@ -176,10 +178,10 @@ TEST(RE2, Replace) {
   };
 
   for (const ReplaceTest* t = tests; t->original != NULL; t++) {
-    string one(t->original);
+    std::string one(t->original);
     ASSERT_TRUE(RE2::Replace(&one, t->regexp, t->rewrite));
     ASSERT_EQ(one, t->single);
-    string all(t->original);
+    std::string all(t->original);
     ASSERT_EQ(RE2::GlobalReplace(&all, t->regexp, t->rewrite), t->greplace_count)
       << "Got: " << all;
     ASSERT_EQ(all, t->global);
@@ -188,7 +190,7 @@ TEST(RE2, Replace) {
 
 static void TestCheckRewriteString(const char* regexp, const char* rewrite,
                               bool expect_ok) {
-  string error;
+  std::string error;
   RE2 exp(regexp);
   bool actual_ok = exp.CheckRewriteString(rewrite, &error);
   EXPECT_EQ(expect_ok, actual_ok) << " for " << rewrite << " error: " << error;
@@ -211,7 +213,7 @@ TEST(CheckRewriteString, all) {
 }
 
 TEST(RE2, Extract) {
-  string s;
+  std::string s;
 
   ASSERT_TRUE(RE2::Extract("boris@kremvax.ru", "(.*)@([^.]*)", "\\2!\\1", &s));
   ASSERT_EQ(s, "kremvax!boris");
@@ -223,12 +225,21 @@ TEST(RE2, Extract) {
   ASSERT_EQ(s, "'foo'");
 }
 
+TEST(RE2, MaxSubmatchTooLarge) {
+  std::string s;
+  ASSERT_FALSE(RE2::Extract("foo", "f(o+)", "\\1\\2", &s));
+  s = "foo";
+  ASSERT_FALSE(RE2::Replace(&s, "f(o+)", "\\1\\2"));
+  s = "foo";
+  ASSERT_FALSE(RE2::GlobalReplace(&s, "f(o+)", "\\1\\2"));
+}
+
 TEST(RE2, Consume) {
   RE2 r("\\s*(\\w+)");    // matches a word, possibly proceeded by whitespace
-  string word;
+  std::string word;
 
-  string s("   aaa b!@#$@#$cccc");
-  StringPiece input(s);
+  std::string s("   aaa b!@#$@#$cccc");
+  absl::string_view input(s);
 
   ASSERT_TRUE(RE2::Consume(&input, r, &word));
   ASSERT_EQ(word, "aaa") << " input: " << input;
@@ -238,8 +249,8 @@ TEST(RE2, Consume) {
 }
 
 TEST(RE2, ConsumeN) {
-  const string s(" one two three 4");
-  StringPiece input(s);
+  const std::string s(" one two three 4");
+  absl::string_view input(s);
 
   RE2::Arg argv[2];
   const RE2::Arg* const args[2] = { &argv[0], &argv[1] };
@@ -248,7 +259,7 @@ TEST(RE2, ConsumeN) {
   EXPECT_TRUE(RE2::ConsumeN(&input, "\\s*(\\w+)", args, 0));  // Skips "one".
 
   // 1 arg
-  string word;
+  std::string word;
   argv[0] = &word;
   EXPECT_TRUE(RE2::ConsumeN(&input, "\\s*(\\w+)", args, 1));
   EXPECT_EQ("two", word);
@@ -263,10 +274,10 @@ TEST(RE2, ConsumeN) {
 
 TEST(RE2, FindAndConsume) {
   RE2 r("(\\w+)");      // matches a word
-  string word;
+  std::string word;
 
-  string s("   aaa b!@#$@#$cccc");
-  StringPiece input(s);
+  std::string s("   aaa b!@#$@#$cccc");
+  absl::string_view input(s);
 
   ASSERT_TRUE(RE2::FindAndConsume(&input, r, &word));
   ASSERT_EQ(word, "aaa");
@@ -285,8 +296,8 @@ TEST(RE2, FindAndConsume) {
 }
 
 TEST(RE2, FindAndConsumeN) {
-  const string s(" one two three 4");
-  StringPiece input(s);
+  const std::string s(" one two three 4");
+  absl::string_view input(s);
 
   RE2::Arg argv[2];
   const RE2::Arg* const args[2] = { &argv[0], &argv[1] };
@@ -295,7 +306,7 @@ TEST(RE2, FindAndConsumeN) {
   EXPECT_TRUE(RE2::FindAndConsumeN(&input, "(\\w+)", args, 0));  // Skips "one".
 
   // 1 arg
-  string word;
+  std::string word;
   argv[0] = &word;
   EXPECT_TRUE(RE2::FindAndConsumeN(&input, "(\\w+)", args, 1));
   EXPECT_EQ("two", word);
@@ -310,9 +321,9 @@ TEST(RE2, FindAndConsumeN) {
 
 TEST(RE2, MatchNumberPeculiarity) {
   RE2 r("(foo)|(bar)|(baz)");
-  string word1;
-  string word2;
-  string word3;
+  std::string word1;
+  std::string word2;
+  std::string word3;
 
   ASSERT_TRUE(RE2::PartialMatch("foo", r, &word1, &word2, &word3));
   ASSERT_EQ(word1, "foo");
@@ -328,30 +339,30 @@ TEST(RE2, MatchNumberPeculiarity) {
   ASSERT_EQ(word3, "baz");
   ASSERT_FALSE(RE2::PartialMatch("f", r, &word1, &word2, &word3));
 
-  string a;
+  std::string a;
   ASSERT_TRUE(RE2::FullMatch("hello", "(foo)|hello", &a));
   ASSERT_EQ(a, "");
 }
 
 TEST(RE2, Match) {
   RE2 re("((\\w+):([0-9]+))");   // extracts host and port
-  StringPiece group[4];
+  absl::string_view group[4];
 
   // No match.
-  StringPiece s = "zyzzyva";
+  absl::string_view s = "zyzzyva";
   ASSERT_FALSE(
-      re.Match(s, 0, s.size(), RE2::UNANCHORED, group, arraysize(group)));
+      re.Match(s, 0, s.size(), RE2::UNANCHORED, group, ABSL_ARRAYSIZE(group)));
 
   // Matches and extracts.
   s = "a chrisr:9000 here";
   ASSERT_TRUE(
-      re.Match(s, 0, s.size(), RE2::UNANCHORED, group, arraysize(group)));
+      re.Match(s, 0, s.size(), RE2::UNANCHORED, group, ABSL_ARRAYSIZE(group)));
   ASSERT_EQ(group[0], "chrisr:9000");
   ASSERT_EQ(group[1], "chrisr:9000");
   ASSERT_EQ(group[2], "chrisr");
   ASSERT_EQ(group[3], "9000");
 
-  string all, host;
+  std::string all, host;
   int port;
   ASSERT_TRUE(RE2::PartialMatch("a chrisr:9000 here", re, &all, &host, &port));
   ASSERT_EQ(all, "chrisr:9000");
@@ -361,7 +372,7 @@ TEST(RE2, Match) {
 
 static void TestRecursion(int size, const char* pattern) {
   // Fill up a string repeating the pattern given
-  string domain;
+  std::string domain;
   domain.resize(size);
   size_t patlen = strlen(pattern);
   for (int i = 0; i < size; i++) {
@@ -374,9 +385,9 @@ static void TestRecursion(int size, const char* pattern) {
 
 // A meta-quoted string, interpreted as a pattern, should always match
 // the original unquoted string.
-static void TestQuoteMeta(const string& unquoted,
+static void TestQuoteMeta(const std::string& unquoted,
                           const RE2::Options& options = RE2::DefaultOptions) {
-  string quoted = RE2::QuoteMeta(unquoted);
+  std::string quoted = RE2::QuoteMeta(unquoted);
   RE2 re(quoted, options);
   EXPECT_TRUE(RE2::FullMatch(unquoted, re))
       << "Unquoted='" << unquoted << "', quoted='" << quoted << "'.";
@@ -385,9 +396,9 @@ static void TestQuoteMeta(const string& unquoted,
 // A meta-quoted string, interpreted as a pattern, should always match
 // the original unquoted string.
 static void NegativeTestQuoteMeta(
-    const string& unquoted, const string& should_not_match,
+    const std::string& unquoted, const std::string& should_not_match,
     const RE2::Options& options = RE2::DefaultOptions) {
-  string quoted = RE2::QuoteMeta(unquoted);
+  std::string quoted = RE2::QuoteMeta(unquoted);
   RE2 re(quoted, options);
   EXPECT_FALSE(RE2::FullMatch(should_not_match, re))
       << "Unquoted='" << unquoted << "', quoted='" << quoted << "'.";
@@ -440,7 +451,7 @@ TEST(QuoteMeta, UTF8) {
 }
 
 TEST(QuoteMeta, HasNull) {
-  string has_null;
+  std::string has_null;
 
   // string with one null character
   has_null += '\0';
@@ -473,40 +484,39 @@ TEST(ProgramFanout, BigProgram) {
   RE2 re100("(?:(?:(?:(?:(?:.)?){100})*)+)");
   RE2 re1000("(?:(?:(?:(?:(?:.)?){1000})*)+)");
 
-  std::map<int, int> histogram;
+  std::vector<int> histogram;
 
-  // 3 is the largest non-empty bucket and has 1 element.
+  // 3 is the largest non-empty bucket and has 2 element.
   ASSERT_EQ(3, re1.ProgramFanout(&histogram));
-  ASSERT_EQ(1, histogram[3]);
+  ASSERT_EQ(2, histogram[3]);
 
-  // 7 is the largest non-empty bucket and has 10 elements.
-  ASSERT_EQ(7, re10.ProgramFanout(&histogram));
-  ASSERT_EQ(10, histogram[7]);
+  // 6 is the largest non-empty bucket and has 11 elements.
+  ASSERT_EQ(6, re10.ProgramFanout(&histogram));
+  ASSERT_EQ(11, histogram[6]);
 
-  // 10 is the largest non-empty bucket and has 100 elements.
-  ASSERT_EQ(10, re100.ProgramFanout(&histogram));
-  ASSERT_EQ(100, histogram[10]);
+  // 9 is the largest non-empty bucket and has 101 elements.
+  ASSERT_EQ(9, re100.ProgramFanout(&histogram));
+  ASSERT_EQ(101, histogram[9]);
 
-  // 13 is the largest non-empty bucket and has 1000 elements.
+  // 13 is the largest non-empty bucket and has 1001 elements.
   ASSERT_EQ(13, re1000.ProgramFanout(&histogram));
-  ASSERT_EQ(1000, histogram[13]);
+  ASSERT_EQ(1001, histogram[13]);
 
-  // 2 is the largest non-empty bucket and has 3 elements.
-  // This differs from the others due to how reverse `.' works.
+  // 2 is the largest non-empty bucket and has 2 element.
   ASSERT_EQ(2, re1.ReverseProgramFanout(&histogram));
-  ASSERT_EQ(3, histogram[2]);
+  ASSERT_EQ(2, histogram[2]);
 
-  // 5 is the largest non-empty bucket and has 10 elements.
+  // 5 is the largest non-empty bucket and has 11 elements.
   ASSERT_EQ(5, re10.ReverseProgramFanout(&histogram));
-  ASSERT_EQ(10, histogram[5]);
+  ASSERT_EQ(11, histogram[5]);
 
-  // 9 is the largest non-empty bucket and has 100 elements.
+  // 9 is the largest non-empty bucket and has 101 elements.
   ASSERT_EQ(9, re100.ReverseProgramFanout(&histogram));
-  ASSERT_EQ(100, histogram[9]);
+  ASSERT_EQ(101, histogram[9]);
 
-  // 12 is the largest non-empty bucket and has 1000 elements.
+  // 12 is the largest non-empty bucket and has 1001 elements.
   ASSERT_EQ(12, re1000.ReverseProgramFanout(&histogram));
-  ASSERT_EQ(1000, histogram[12]);
+  ASSERT_EQ(1001, histogram[12]);
 }
 
 // Issue 956519: handling empty character sets was
@@ -519,7 +529,7 @@ TEST(EmptyCharset, Fuzz) {
     "[^\\D\\d]",
     "[^\\D[:digit:]]"
   };
-  for (int i = 0; i < arraysize(empties); i++)
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(empties); i++)
     ASSERT_FALSE(RE2(empties[i]).Match("abc", 0, 3, RE2::UNANCHORED, NULL, 0));
 }
 
@@ -533,8 +543,8 @@ TEST(EmptyCharset, BitstateAssumptions) {
     "((((()))))" "([^\\S\\s]|[^\\S\\s])?",
     "((((()))))" "(([^\\S\\s]|[^\\S\\s])|)"
   };
-  StringPiece group[6];
-  for (int i = 0; i < arraysize(nop_empties); i++)
+  absl::string_view group[6];
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(nop_empties); i++)
     ASSERT_TRUE(RE2(nop_empties[i]).Match("", 0, 0, RE2::UNANCHORED, group, 6));
 }
 
@@ -543,14 +553,14 @@ TEST(Capture, NamedGroups) {
   {
     RE2 re("(hello world)");
     ASSERT_EQ(re.NumberOfCapturingGroups(), 1);
-    const std::map<string, int>& m = re.NamedCapturingGroups();
+    const std::map<std::string, int>& m = re.NamedCapturingGroups();
     ASSERT_EQ(m.size(), 0);
   }
 
   {
     RE2 re("(?P<A>expr(?P<B>expr)(?P<C>expr))((expr)(?P<D>expr))");
     ASSERT_EQ(re.NumberOfCapturingGroups(), 6);
-    const std::map<string, int>& m = re.NamedCapturingGroups();
+    const std::map<std::string, int>& m = re.NamedCapturingGroups();
     ASSERT_EQ(m.size(), 4);
     ASSERT_EQ(m.find("A")->second, 1);
     ASSERT_EQ(m.find("B")->second, 2);
@@ -563,7 +573,7 @@ TEST(RE2, CapturedGroupTest) {
   RE2 re("directions from (?P<S>.*) to (?P<D>.*)");
   int num_groups = re.NumberOfCapturingGroups();
   EXPECT_EQ(2, num_groups);
-  string args[4];
+  std::string args[4];
   RE2::Arg arg0(&args[0]);
   RE2::Arg arg1(&args[1]);
   RE2::Arg arg2(&args[2]);
@@ -572,7 +582,7 @@ TEST(RE2, CapturedGroupTest) {
   const RE2::Arg* const matches[4] = {&arg0, &arg1, &arg2, &arg3};
   EXPECT_TRUE(RE2::FullMatchN("directions from mountain view to san jose",
                               re, matches, num_groups));
-  const std::map<string, int>& named_groups = re.NamedCapturingGroups();
+  const std::map<std::string, int>& named_groups = re.NamedCapturingGroups();
   EXPECT_TRUE(named_groups.find("S") != named_groups.end());
   EXPECT_TRUE(named_groups.find("D") != named_groups.end());
 
@@ -619,7 +629,7 @@ TEST(RE2, PartialMatchN) {
   EXPECT_FALSE(RE2::PartialMatchN("three", "(\\d+)", args, 1));
 
   // Multi-arg
-  string s;
+  std::string s;
   argv[1] = &s;
   EXPECT_TRUE(RE2::PartialMatchN("answer: 42:life", "(\\d+):(\\w+)", args, 2));
   EXPECT_EQ(42, i);
@@ -662,16 +672,16 @@ TEST(RE2, FullMatchIntegerArg) {
 }
 
 TEST(RE2, FullMatchStringArg) {
-  string s;
-  // String-arg
+  std::string s;
+  // string-arg
   ASSERT_TRUE(RE2::FullMatch("hello", "h(.*)o", &s));
-  ASSERT_EQ(s, string("ell"));
+  ASSERT_EQ(s, std::string("ell"));
 }
 
-TEST(RE2, FullMatchStringPieceArg) {
+TEST(RE2, FullMatchStringViewArg) {
   int i;
-  // StringPiece-arg
-  StringPiece sp;
+  absl::string_view sp;
+  // string_view-arg
   ASSERT_TRUE(RE2::FullMatch("ruby:1234", "(\\w+):(\\d+)", &sp, &i));
   ASSERT_EQ(sp.size(), 4);
   ASSERT_TRUE(memcmp(sp.data(), "ruby", 4) == 0);
@@ -680,10 +690,10 @@ TEST(RE2, FullMatchStringPieceArg) {
 
 TEST(RE2, FullMatchMultiArg) {
   int i;
-  string s;
+  std::string s;
   // Multi-arg
   ASSERT_TRUE(RE2::FullMatch("ruby:1234", "(\\w+):(\\d+)", &s, &i));
-  ASSERT_EQ(s, string("ruby"));
+  ASSERT_EQ(s, std::string("ruby"));
   ASSERT_EQ(i, 1234);
 }
 
@@ -703,7 +713,7 @@ TEST(RE2, FullMatchN) {
   EXPECT_FALSE(RE2::FullMatchN("three", "(\\d+)", args, 1));
 
   // Multi-arg
-  string s;
+  std::string s;
   argv[1] = &s;
   EXPECT_TRUE(RE2::FullMatchN("42:life", "(\\d+):(\\w+)", args, 2));
   EXPECT_EQ(42, i);
@@ -713,27 +723,27 @@ TEST(RE2, FullMatchN) {
 
 TEST(RE2, FullMatchIgnoredArg) {
   int i;
-  string s;
+  std::string s;
 
   // Old-school NULL should be ignored.
   ASSERT_TRUE(
       RE2::FullMatch("ruby:1234", "(\\w+)(:)(\\d+)", &s, (void*)NULL, &i));
-  ASSERT_EQ(s, string("ruby"));
+  ASSERT_EQ(s, std::string("ruby"));
   ASSERT_EQ(i, 1234);
 
   // C++11 nullptr should also be ignored.
   ASSERT_TRUE(RE2::FullMatch("rubz:1235", "(\\w+)(:)(\\d+)", &s, nullptr, &i));
-  ASSERT_EQ(s, string("rubz"));
+  ASSERT_EQ(s, std::string("rubz"));
   ASSERT_EQ(i, 1235);
 }
 
 TEST(RE2, FullMatchTypedNullArg) {
-  string s;
+  std::string s;
 
   // Ignore non-void* NULL arg
   ASSERT_TRUE(RE2::FullMatch("hello", "he(.*)lo", (char*)NULL));
-  ASSERT_TRUE(RE2::FullMatch("hello", "h(.*)o", (string*)NULL));
-  ASSERT_TRUE(RE2::FullMatch("hello", "h(.*)o", (StringPiece*)NULL));
+  ASSERT_TRUE(RE2::FullMatch("hello", "h(.*)o", (std::string*)NULL));
+  ASSERT_TRUE(RE2::FullMatch("hello", "h(.*)o", (absl::string_view*)NULL));
   ASSERT_TRUE(RE2::FullMatch("1234", "(.*)", (int*)NULL));
   ASSERT_TRUE(RE2::FullMatch("1234567890123456", "(.*)", (long long*)NULL));
   ASSERT_TRUE(RE2::FullMatch("123.4567890123456", "(.*)", (double*)NULL));
@@ -768,14 +778,15 @@ TEST(RE2, NULTerminated) {
   v[pagesize - 1] = '1';
 
   x = 0;
-  ASSERT_TRUE(RE2::FullMatch(StringPiece(v + pagesize - 1, 1), "(.*)", &x));
+  ASSERT_TRUE(
+      RE2::FullMatch(absl::string_view(v + pagesize - 1, 1), "(.*)", &x));
   ASSERT_EQ(x, 1);
 #endif
 }
 
 TEST(RE2, FullMatchTypeTests) {
   // Type tests
-  string zeros(1000, '0');
+  std::string zeros(1000, '0');
   {
     char c;
     ASSERT_TRUE(RE2::FullMatch("Hello", "(H)ello", &c));
@@ -837,7 +848,7 @@ TEST(RE2, FullMatchTypeTests) {
     int64_t v;
     static const int64_t max = INT64_C(0x7fffffffffffffff);
     static const int64_t min = -max - 1;
-    string str;
+    std::string str;
 
     ASSERT_TRUE(RE2::FullMatch("100",  "(-?\\d+)", &v)); ASSERT_EQ(v, 100);
     ASSERT_TRUE(RE2::FullMatch("-100", "(-?\\d+)", &v)); ASSERT_EQ(v, -100);
@@ -862,7 +873,7 @@ TEST(RE2, FullMatchTypeTests) {
     uint64_t v;
     int64_t v2;
     static const uint64_t max = UINT64_C(0xffffffffffffffff);
-    string str;
+    std::string str;
 
     ASSERT_TRUE(RE2::FullMatch("100",  "(-?\\d+)", &v));  ASSERT_EQ(v, 100);
     ASSERT_TRUE(RE2::FullMatch("-100", "(-?\\d+)", &v2)); ASSERT_EQ(v2, -100);
@@ -877,7 +888,7 @@ TEST(RE2, FullMatchTypeTests) {
 }
 
 TEST(RE2, FloatingPointFullMatchTypes) {
-  string zeros(1000, '0');
+  std::string zeros(1000, '0');
   {
     float v;
     ASSERT_TRUE(RE2::FullMatch("100",   "(.*)", &v)); ASSERT_EQ(v, 100);
@@ -905,10 +916,10 @@ TEST(RE2, FloatingPointFullMatchTypes) {
     // implementation of strtof(3). And apparently MSVC too. Sigh.
 #if !defined(_MSC_VER) && !defined(__CYGWIN__) && !defined(__MINGW32__)
     ASSERT_TRUE(RE2::FullMatch("0.1", "(.*)", &v));
-    ASSERT_EQ(v, 0.1f) << StringPrintf("%.8g != %.8g", v, 0.1f);
+    ASSERT_EQ(v, 0.1f) << absl::StrFormat("%.8g != %.8g", v, 0.1f);
     ASSERT_TRUE(RE2::FullMatch("6700000000081920.1", "(.*)", &v));
     ASSERT_EQ(v, 6700000000081920.1f)
-      << StringPrintf("%.8g != %.8g", v, 6700000000081920.1f);
+      << absl::StrFormat("%.8g != %.8g", v, 6700000000081920.1f);
 #endif
   }
   {
@@ -920,10 +931,10 @@ TEST(RE2, FloatingPointFullMatchTypes) {
     ASSERT_EQ(v, double(1e23));
 
     ASSERT_TRUE(RE2::FullMatch("0.1", "(.*)", &v));
-    ASSERT_EQ(v, 0.1) << StringPrintf("%.17g != %.17g", v, 0.1);
+    ASSERT_EQ(v, 0.1) << absl::StrFormat("%.17g != %.17g", v, 0.1);
     ASSERT_TRUE(RE2::FullMatch("1.00000005960464485", "(.*)", &v));
     ASSERT_EQ(v, 1.0000000596046448)
-      << StringPrintf("%.17g != %.17g", v, 1.0000000596046448);
+      << absl::StrFormat("%.17g != %.17g", v, 1.0000000596046448);
   }
 }
 
@@ -1056,7 +1067,7 @@ TEST(RE2, FullMatchArgCount) {
 TEST(RE2, Accessors) {
   // Check the pattern() accessor
   {
-    const string kPattern = "http://([^/]+)/.*";
+    const std::string kPattern = "http://([^/]+)/.*";
     const RE2 re(kPattern);
     ASSERT_EQ(kPattern, re.pattern());
   }
@@ -1094,13 +1105,13 @@ TEST(RE2, UTF8) {
 
   // Check that '.' matches one byte or UTF-8 character
   // according to the mode.
-  string s;
+  std::string s;
   RE2 re_test3("(.)", RE2::Latin1);
   ASSERT_TRUE(RE2::PartialMatch(utf8_string, re_test3, &s));
-  ASSERT_EQ(s, string("\xe6"));
+  ASSERT_EQ(s, std::string("\xe6"));
   RE2 re_test4("(.)");
   ASSERT_TRUE(RE2::PartialMatch(utf8_string, re_test4, &s));
-  ASSERT_EQ(s, string("\xe6\x97\xa5"));
+  ASSERT_EQ(s, std::string("\xe6\x97\xa5"));
 
   // Check that string matches itself in either mode
   RE2 re_test5(utf8_string, RE2::Latin1);
@@ -1121,7 +1132,7 @@ TEST(RE2, UngreedyUTF8) {
   {
     // This code always worked.
     const char* pattern = "\\w+X";
-    const string target = "a aX";
+    const std::string target = "a aX";
     RE2 match_sentence(pattern, RE2::Latin1);
     RE2 match_sentence_re(pattern);
 
@@ -1130,7 +1141,7 @@ TEST(RE2, UngreedyUTF8) {
   }
   {
     const char* pattern = "(?U)\\w+X";
-    const string target = "a aX";
+    const std::string target = "a aX";
     RE2 match_sentence(pattern, RE2::Latin1);
     ASSERT_EQ(match_sentence.error(), "");
     RE2 match_sentence_re(pattern);
@@ -1185,7 +1196,7 @@ TEST(RE2, NoCrash) {
   {
     RE2 re(".{512}x", RE2::Quiet);
     ASSERT_TRUE(re.ok());
-    string s;
+    std::string s;
     s.append(515, 'c');
     s.append("x");
     ASSERT_TRUE(RE2::PartialMatch(s, re));
@@ -1210,7 +1221,7 @@ TEST(RE2, BigCountedRepetition) {
 
   RE2 re(".{512}x", opt);
   ASSERT_TRUE(re.ok());
-  string s;
+  std::string s;
   s.append(515, 'c');
   s.append("x");
   ASSERT_TRUE(RE2::PartialMatch(s, re));
@@ -1221,8 +1232,8 @@ TEST(RE2, DeepRecursion) {
   // segmentation violation due to stack overflow before pcre was
   // patched.
   // Again, a PCRE legacy test.  RE2 doesn't recurse.
-  string comment("x*");
-  string a(131072, 'a');
+  std::string comment("x*");
+  std::string a(131072, 'a');
   comment += a;
   comment += "*x";
   RE2 re("((?:\\s|xx.*\n|x[*](?:\n|.)*?[*]x)*)");
@@ -1232,35 +1243,34 @@ TEST(RE2, DeepRecursion) {
 // Suggested by Josh Hyman.  Failed when SearchOnePass was
 // not implementing case-folding.
 TEST(CaseInsensitive, MatchAndConsume) {
-  string result;
-  string text = "A fish named *Wanda*";
-  StringPiece sp(text);
-
-  EXPECT_TRUE(RE2::PartialMatch(sp, "(?i)([wand]{5})", &result));
+  std::string text = "A fish named *Wanda*";
+  absl::string_view sp(text);
+  absl::string_view result;
+  EXPECT_TRUE(RE2::PartialMatch(text, "(?i)([wand]{5})", &result));
   EXPECT_TRUE(RE2::FindAndConsume(&sp, "(?i)([wand]{5})", &result));
 }
 
-// RE2 should permit implicit conversions from string, StringPiece, const char*,
+// RE2 should permit implicit conversions from string, string_view, const char*,
 // and C string literals.
 TEST(RE2, ImplicitConversions) {
-  string re_string(".");
-  StringPiece re_stringpiece(".");
-  const char* re_cstring = ".";
+  std::string re_string(".");
+  absl::string_view re_string_view(".");
+  const char* re_c_string = ".";
   EXPECT_TRUE(RE2::PartialMatch("e", re_string));
-  EXPECT_TRUE(RE2::PartialMatch("e", re_stringpiece));
-  EXPECT_TRUE(RE2::PartialMatch("e", re_cstring));
+  EXPECT_TRUE(RE2::PartialMatch("e", re_string_view));
+  EXPECT_TRUE(RE2::PartialMatch("e", re_c_string));
   EXPECT_TRUE(RE2::PartialMatch("e", "."));
 }
 
 // Bugs introduced by 8622304
 TEST(RE2, CL8622304) {
   // reported by ingow
-  string dir;
+  std::string dir;
   EXPECT_TRUE(RE2::FullMatch("D", "([^\\\\])"));  // ok
   EXPECT_TRUE(RE2::FullMatch("D", "([^\\\\])", &dir));  // fails
 
   // reported by jacobsa
-  string key, val;
+  std::string key, val;
   EXPECT_TRUE(RE2::PartialMatch("bar:1,0x2F,030,4,5;baz:true;fooby:false,true",
               "(\\w+)(?::((?:[^;\\\\]|\\\\.)*))?;?",
               &key,
@@ -1269,38 +1279,43 @@ TEST(RE2, CL8622304) {
   EXPECT_EQ(val, "1,0x2F,030,4,5");
 }
 
-
 // Check that RE2 returns correct regexp pieces on error.
 // In particular, make sure it returns whole runes
 // and that it always reports invalid UTF-8.
 // Also check that Perl error flag piece is big enough.
 static struct ErrorTest {
   const char *regexp;
-  const char *error;
+  RE2::ErrorCode error_code;
+  const char *error_arg;
 } error_tests[] = {
-  { "ab\\cd", "\\" },
-  { "ef\\x01", "\\x0" },
-  { "gh\\x101", "\\x1" },
-  { "ij\\x1", "\\x1" },
-  { "kl\\x", "\\x" },
-  { "uv\\x{0000}", "\\x{0000" },
-  { "wx\\p{ABC", "\\p{ABC" },
-  { "yz(?smiUX:abc)", "(?smiUX" },   // used to return (?s but the error is X
-  { "aa(?smi", "(?sm" },
-  { "bb[abc", "[abc" },
-
-  { "mn\\x1\377", "" },  // no argument string returned for invalid UTF-8
-  { "op\377qr", "" },
-  { "st\\x{00000\377", "" },
-  { "zz\\p{\377}", "" },
-  { "zz\\x{00\377}", "" },
-  { "zz(?P<name\377>abc)", "" },
+  { "ab\\cd", RE2::ErrorBadEscape, "\\" },
+  { "ef\\x01", RE2::ErrorBadEscape, "\\x0" },
+  { "gh\\x101", RE2::ErrorBadEscape, "\\x1" },
+  { "ij\\x1", RE2::ErrorBadEscape, "\\x1" },
+  { "kl\\x", RE2::ErrorBadEscape, "\\x" },
+  { "uv\\x{0000}", RE2::ErrorBadEscape, "\\x{0000" },
+  { "wx\\p{ABC", RE2::ErrorBadCharRange, "\\p{ABC" },
+  // used to return (?s but the error is X
+  { "yz(?smiUX:abc)", RE2::ErrorBadPerlOp, "(?smiUX" },
+  { "aa(?smi", RE2::ErrorBadPerlOp, "(?sm" },
+  { "bb[abc", RE2::ErrorMissingBracket, "[abc" },
+  { "abc(def", RE2::ErrorMissingParen, "abc(def" },
+  { "abc)def", RE2::ErrorUnexpectedParen, "abc)def" },
+
+  // no argument string returned for invalid UTF-8
+  { "mn\\x1\377", RE2::ErrorBadUTF8, "" },
+  { "op\377qr", RE2::ErrorBadUTF8, "" },
+  { "st\\x{00000\377", RE2::ErrorBadUTF8, "" },
+  { "zz\\p{\377}", RE2::ErrorBadUTF8, "" },
+  { "zz\\x{00\377}", RE2::ErrorBadUTF8, "" },
+  { "zz(?P<name\377>abc)", RE2::ErrorBadUTF8, "" },
 };
-TEST(RE2, ErrorArgs) {
-  for (int i = 0; i < arraysize(error_tests); i++) {
+TEST(RE2, ErrorCodeAndArg) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(error_tests); i++) {
     RE2 re(error_tests[i].regexp, RE2::Quiet);
     EXPECT_FALSE(re.ok());
-    EXPECT_EQ(re.error_arg(), error_tests[i].error) << re.error();
+    EXPECT_EQ(re.error_code(), error_tests[i].error_code) << re.error();
+    EXPECT_EQ(re.error_arg(), error_tests[i].error_arg) << re.error();
   }
 }
 
@@ -1319,13 +1334,13 @@ static struct NeverTest {
 TEST(RE2, NeverNewline) {
   RE2::Options opt;
   opt.set_never_nl(true);
-  for (int i = 0; i < arraysize(never_tests); i++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(never_tests); i++) {
     const NeverTest& t = never_tests[i];
     RE2 re(t.regexp, opt);
     if (t.match == NULL) {
       EXPECT_FALSE(re.PartialMatch(t.text, re));
     } else {
-      StringPiece m;
+      absl::string_view m;
       EXPECT_TRUE(re.PartialMatch(t.text, re, &m));
       EXPECT_EQ(m, t.match);
     }
@@ -1358,14 +1373,14 @@ TEST(RE2, BitstateCaptureBug) {
   RE2::Options opt;
   opt.set_max_mem(20000);
   RE2 re("(_________$)", opt);
-  StringPiece s = "xxxxxxxxxxxxxxxxxxxxxxxxxx_________x";
+  absl::string_view s = "xxxxxxxxxxxxxxxxxxxxxxxxxx_________x";
   EXPECT_FALSE(re.Match(s, 0, s.size(), RE2::UNANCHORED, NULL, 0));
 }
 
 // C++ version of bug 609710.
 TEST(RE2, UnicodeClasses) {
-  const string str = "ABCDEFGHI";
-  string a, b, c;
+  const std::string str = "ABCDEFGHI";
+  std::string a, b, c;
 
   EXPECT_TRUE(RE2::FullMatch("A", "\\p{L}"));
   EXPECT_TRUE(RE2::FullMatch("A", "\\p{Lu}"));
@@ -1437,10 +1452,10 @@ TEST(RE2, NullVsEmptyString) {
   RE2 re(".*");
   EXPECT_TRUE(re.ok());
 
-  StringPiece null;
+  absl::string_view null;
   EXPECT_TRUE(RE2::FullMatch(null, re));
 
-  StringPiece empty("");
+  absl::string_view empty("");
   EXPECT_TRUE(RE2::FullMatch(empty, re));
 }
 
@@ -1452,45 +1467,40 @@ TEST(RE2, NullVsEmptyStringSubmatches) {
   EXPECT_TRUE(re.ok());
 
   // matches[0] is overall match, [1] is (), [2] is (foo), [3] is nonexistent.
-  StringPiece matches[4];
+  absl::string_view matches[4];
 
-  for (int i = 0; i < arraysize(matches); i++)
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(matches); i++)
     matches[i] = "bar";
 
-  StringPiece null;
+  absl::string_view null;
   EXPECT_TRUE(re.Match(null, 0, null.size(), RE2::UNANCHORED,
-                       matches, arraysize(matches)));
-  for (int i = 0; i < arraysize(matches); i++) {
-    EXPECT_TRUE(matches[i] == StringPiece());
+                       matches, ABSL_ARRAYSIZE(matches)));
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(matches); i++) {
     EXPECT_TRUE(matches[i].data() == NULL);  // always null
-    EXPECT_TRUE(matches[i] == "");
+    EXPECT_TRUE(matches[i].empty());
   }
 
-  for (int i = 0; i < arraysize(matches); i++)
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(matches); i++)
     matches[i] = "bar";
 
-  StringPiece empty("");
+  absl::string_view empty("");
   EXPECT_TRUE(re.Match(empty, 0, empty.size(), RE2::UNANCHORED,
-                       matches, arraysize(matches)));
-  EXPECT_TRUE(matches[0] == StringPiece());
+                       matches, ABSL_ARRAYSIZE(matches)));
   EXPECT_TRUE(matches[0].data() != NULL);  // empty, not null
-  EXPECT_TRUE(matches[0] == "");
-  EXPECT_TRUE(matches[1] == StringPiece());
+  EXPECT_TRUE(matches[0].empty());
   EXPECT_TRUE(matches[1].data() != NULL);  // empty, not null
-  EXPECT_TRUE(matches[1] == "");
-  EXPECT_TRUE(matches[2] == StringPiece());
+  EXPECT_TRUE(matches[1].empty());
   EXPECT_TRUE(matches[2].data() == NULL);
-  EXPECT_TRUE(matches[2] == "");
-  EXPECT_TRUE(matches[3] == StringPiece());
+  EXPECT_TRUE(matches[2].empty());
   EXPECT_TRUE(matches[3].data() == NULL);
-  EXPECT_TRUE(matches[3] == "");
+  EXPECT_TRUE(matches[3].empty());
 }
 
 // Issue 1816809
 TEST(RE2, Bug1816809) {
   RE2 re("(((((llx((-3)|(4)))(;(llx((-3)|(4))))*))))");
-  StringPiece piece("llx-3;llx4");
-  string x;
+  absl::string_view piece("llx-3;llx4");
+  std::string x;
   EXPECT_TRUE(RE2::Consume(&piece, re, &x));
 }
 
@@ -1507,8 +1517,8 @@ TEST(RE2, CapturingGroupNames) {
   //      12    3        45   6         7
   RE2 re("((abc)(?P<G2>)|((e+)(?P<G2>.*)(?P<G1>u+)))");
   EXPECT_TRUE(re.ok());
-  const std::map<int, string>& have = re.CapturingGroupNames();
-  std::map<int, string> want;
+  const std::map<int, std::string>& have = re.CapturingGroupNames();
+  std::map<int, std::string> want;
   want[3] = "G2";
   want[6] = "G2";
   want[7] = "G1";
@@ -1582,7 +1592,7 @@ TEST(RE2, Bug18523943) {
 
   RE2 re((const char*)b, opt);
   ASSERT_TRUE(re.ok());
-  string s1;
+  std::string s1;
   ASSERT_TRUE(RE2::PartialMatch((const char*)a, re, &s1));
 }
 
@@ -1606,8 +1616,8 @@ TEST(RE2, Bug26356109) {
   RE2 re("a\\C*?c|a\\C*?b");
   ASSERT_TRUE(re.ok());
 
-  string s = "abc";
-  StringPiece m;
+  std::string s = "abc";
+  absl::string_view m;
 
   ASSERT_TRUE(re.Match(s, 0, s.size(), RE2::UNANCHORED, &m, 1));
   ASSERT_EQ(m, s) << " (UNANCHORED) got m='" << m << "', want '" << s << "'";
@@ -1620,7 +1630,7 @@ TEST(RE2, Issue104) {
   // RE2::GlobalReplace always advanced by one byte when the empty string was
   // matched, which would clobber any rune that is longer than one byte.
 
-  string s = "bc";
+  std::string s = "bc";
   ASSERT_EQ(3, RE2::GlobalReplace(&s, "a*", "d"));
   ASSERT_EQ("dbdcd", s);
 
@@ -1633,4 +1643,19 @@ TEST(RE2, Issue104) {
   ASSERT_EQ("", s);
 }
 
+TEST(RE2, Issue310) {
+  // (?:|a)* matched more text than (?:|a)+ did.
+
+  std::string s = "aaa";
+  absl::string_view m;
+
+  RE2 star("(?:|a)*");
+  ASSERT_TRUE(star.Match(s, 0, s.size(), RE2::UNANCHORED, &m, 1));
+  ASSERT_EQ(m, "") << " got m='" << m << "', want ''";
+
+  RE2 plus("(?:|a)+");
+  ASSERT_TRUE(plus.Match(s, 0, s.size(), RE2::UNANCHORED, &m, 1));
+  ASSERT_EQ(m, "") << " got m='" << m << "', want ''";
+}
+
 }  // namespace re2
diff --git a/re2/testing/regexp_benchmark.cc b/re2/testing/regexp_benchmark.cc
index 8b82e0b..5352b31 100644
--- a/re2/testing/regexp_benchmark.cc
+++ b/re2/testing/regexp_benchmark.cc
@@ -8,16 +8,20 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string>
+#include <thread>
 #include <utility>
 
-#include "util/test.h"
+#include "absl/container/flat_hash_map.h"
+#include "absl/flags/flag.h"
+#include "absl/strings/str_format.h"
+#include "absl/synchronization/mutex.h"
+#include "benchmark/benchmark.h"
 #include "util/logging.h"
-#include "util/strutil.h"
+#include "util/malloc_counter.h"
 #include "re2/prog.h"
 #include "re2/re2.h"
 #include "re2/regexp.h"
 #include "util/pcre.h"
-#include "util/benchmark.h"
 
 namespace re2 {
 void Test();
@@ -34,8 +38,9 @@ void Test() {
   Prog* prog = re->CompileToProg(0);
   CHECK(prog);
   CHECK(prog->IsOnePass());
+  CHECK(prog->CanBitState());
   const char* text = "650-253-0001";
-  StringPiece sp[4];
+  absl::string_view sp[4];
   CHECK(prog->SearchOnePass(text, text, Prog::kAnchored, Prog::kFullMatch, sp, 4));
   CHECK_EQ(sp[0], "650-253-0001");
   CHECK_EQ(sp[1], "650");
@@ -55,18 +60,22 @@ void MemoryUsage() {
     CHECK(re);
     // Can't pass mc.HeapGrowth() and mc.PeakHeapGrowth() to LOG(INFO) directly,
     // because LOG(INFO) might do a big allocation before they get evaluated.
-    fprintf(stderr, "Regexp: %7lld bytes (peak=%lld)\n", mc.HeapGrowth(), mc.PeakHeapGrowth());
+    absl::FPrintF(stderr, "Regexp: %7d bytes (peak=%d)\n",
+                  mc.HeapGrowth(), mc.PeakHeapGrowth());
     mc.Reset();
 
     Prog* prog = re->CompileToProg(0);
     CHECK(prog);
     CHECK(prog->IsOnePass());
-    fprintf(stderr, "Prog:   %7lld bytes (peak=%lld)\n", mc.HeapGrowth(), mc.PeakHeapGrowth());
+    CHECK(prog->CanBitState());
+    absl::FPrintF(stderr, "Prog:   %7d bytes (peak=%d)\n",
+                  mc.HeapGrowth(), mc.PeakHeapGrowth());
     mc.Reset();
 
-    StringPiece sp[4];
+    absl::string_view sp[4];
     CHECK(prog->SearchOnePass(text, text, Prog::kAnchored, Prog::kFullMatch, sp, 4));
-    fprintf(stderr, "Search: %7lld bytes (peak=%lld)\n", mc.HeapGrowth(), mc.PeakHeapGrowth());
+    absl::FPrintF(stderr, "Search: %7d bytes (peak=%d)\n",
+                  mc.HeapGrowth(), mc.PeakHeapGrowth());
     delete prog;
     re->Decref();
   }
@@ -75,18 +84,22 @@ void MemoryUsage() {
     MallocCounter mc(MallocCounter::THIS_THREAD_ONLY);
 
     PCRE re(regexp, PCRE::UTF8);
-    fprintf(stderr, "RE:     %7lld bytes (peak=%lld)\n", mc.HeapGrowth(), mc.PeakHeapGrowth());
+    absl::FPrintF(stderr, "RE:     %7d bytes (peak=%d)\n",
+                  mc.HeapGrowth(), mc.PeakHeapGrowth());
     PCRE::FullMatch(text, re);
-    fprintf(stderr, "RE:     %7lld bytes (peak=%lld)\n", mc.HeapGrowth(), mc.PeakHeapGrowth());
+    absl::FPrintF(stderr, "RE:     %7d bytes (peak=%d)\n",
+                  mc.HeapGrowth(), mc.PeakHeapGrowth());
   }
 
   {
     MallocCounter mc(MallocCounter::THIS_THREAD_ONLY);
 
     PCRE* re = new PCRE(regexp, PCRE::UTF8);
-    fprintf(stderr, "PCRE*:  %7lld bytes (peak=%lld)\n", mc.HeapGrowth(), mc.PeakHeapGrowth());
+    absl::FPrintF(stderr, "PCRE*:  %7d bytes (peak=%d)\n",
+                  mc.HeapGrowth(), mc.PeakHeapGrowth());
     PCRE::FullMatch(text, *re);
-    fprintf(stderr, "PCRE*:  %7lld bytes (peak=%lld)\n", mc.HeapGrowth(), mc.PeakHeapGrowth());
+    absl::FPrintF(stderr, "PCRE*:  %7d bytes (peak=%d)\n",
+                  mc.HeapGrowth(), mc.PeakHeapGrowth());
     delete re;
   }
 
@@ -94,42 +107,43 @@ void MemoryUsage() {
     MallocCounter mc(MallocCounter::THIS_THREAD_ONLY);
 
     RE2 re(regexp);
-    fprintf(stderr, "RE2:    %7lld bytes (peak=%lld)\n", mc.HeapGrowth(), mc.PeakHeapGrowth());
+    absl::FPrintF(stderr, "RE2:    %7d bytes (peak=%d)\n",
+                  mc.HeapGrowth(), mc.PeakHeapGrowth());
     RE2::FullMatch(text, re);
-    fprintf(stderr, "RE2:    %7lld bytes (peak=%lld)\n", mc.HeapGrowth(), mc.PeakHeapGrowth());
+    absl::FPrintF(stderr, "RE2:    %7d bytes (peak=%d)\n",
+                  mc.HeapGrowth(), mc.PeakHeapGrowth());
   }
 
-  fprintf(stderr, "sizeof: PCRE=%zd RE2=%zd Prog=%zd Inst=%zd\n",
-          sizeof(PCRE), sizeof(RE2), sizeof(Prog), sizeof(Prog::Inst));
+  absl::FPrintF(stderr, "sizeof: PCRE=%d RE2=%d Prog=%d Inst=%d\n",
+                sizeof(PCRE), sizeof(RE2), sizeof(Prog), sizeof(Prog::Inst));
+}
+
+int NumCPUs() {
+  return static_cast<int>(std::thread::hardware_concurrency());
 }
 
 // Regular expression implementation wrappers.
 // Defined at bottom of file, but they are repetitive
 // and not interesting.
 
-typedef void SearchImpl(int iters, const char* regexp, const StringPiece& text,
-             Prog::Anchor anchor, bool expect_match);
+typedef void SearchImpl(benchmark::State& state, const char* regexp,
+                        absl::string_view text, Prog::Anchor anchor,
+                        bool expect_match);
 
-SearchImpl SearchDFA, SearchNFA, SearchOnePass, SearchBitState,
-           SearchPCRE, SearchRE2,
-           SearchCachedDFA, SearchCachedNFA, SearchCachedOnePass, SearchCachedBitState,
-           SearchCachedPCRE, SearchCachedRE2;
+SearchImpl SearchDFA, SearchNFA, SearchOnePass, SearchBitState, SearchPCRE,
+    SearchRE2, SearchCachedDFA, SearchCachedNFA, SearchCachedOnePass,
+    SearchCachedBitState, SearchCachedPCRE, SearchCachedRE2;
 
-typedef void ParseImpl(int iters, const char* regexp, const StringPiece& text);
+typedef void ParseImpl(benchmark::State& state, const char* regexp,
+                       absl::string_view text);
 
-ParseImpl Parse1NFA, Parse1OnePass, Parse1BitState,
-          Parse1PCRE, Parse1RE2,
-          Parse1Backtrack,
-          Parse1CachedNFA, Parse1CachedOnePass, Parse1CachedBitState,
-          Parse1CachedPCRE, Parse1CachedRE2,
-          Parse1CachedBacktrack;
+ParseImpl Parse1NFA, Parse1OnePass, Parse1BitState, Parse1PCRE, Parse1RE2,
+    Parse1Backtrack, Parse1CachedNFA, Parse1CachedOnePass, Parse1CachedBitState,
+    Parse1CachedPCRE, Parse1CachedRE2, Parse1CachedBacktrack;
 
-ParseImpl Parse3NFA, Parse3OnePass, Parse3BitState,
-          Parse3PCRE, Parse3RE2,
-          Parse3Backtrack,
-          Parse3CachedNFA, Parse3CachedOnePass, Parse3CachedBitState,
-          Parse3CachedPCRE, Parse3CachedRE2,
-          Parse3CachedBacktrack;
+ParseImpl Parse3NFA, Parse3OnePass, Parse3BitState, Parse3PCRE, Parse3RE2,
+    Parse3Backtrack, Parse3CachedNFA, Parse3CachedOnePass, Parse3CachedBitState,
+    Parse3CachedPCRE, Parse3CachedRE2, Parse3CachedBacktrack;
 
 ParseImpl SearchParse2CachedPCRE, SearchParse2CachedRE2;
 
@@ -139,35 +153,38 @@ ParseImpl SearchParse1CachedPCRE, SearchParse1CachedRE2;
 
 // Generate random text that won't contain the search string,
 // to test worst-case search behavior.
-void MakeText(string* text, int nbytes) {
-  srand(1);
-  text->resize(nbytes);
-  for (int i = 0; i < nbytes; i++) {
-    // Generate a one-byte rune that isn't a control character (e.g. '\n').
-    // Clipping to 0x20 introduces some bias, but we don't need uniformity.
-    int byte = rand() & 0x7F;
-    if (byte < 0x20)
-      byte = 0x20;
-    (*text)[i] = byte;
-  }
+std::string RandomText(int64_t nbytes) {
+  static const std::string* const text = []() {
+    std::string* text = new std::string;
+    srand(1);
+    text->resize(16<<20);
+    for (int64_t i = 0; i < 16<<20; i++) {
+      // Generate a one-byte rune that isn't a control character (e.g. '\n').
+      // Clipping to 0x20 introduces some bias, but we don't need uniformity.
+      int byte = rand() & 0x7F;
+      if (byte < 0x20)
+        byte = 0x20;
+      (*text)[i] = byte;
+    }
+    return text;
+  }();
+  CHECK_LE(nbytes, 16<<20);
+  return text->substr(0, nbytes);
 }
 
 // Makes text of size nbytes, then calls run to search
 // the text for regexp iters times.
-void Search(int iters, int nbytes, const char* regexp, SearchImpl* search) {
-  StopBenchmarkTiming();
-  string s;
-  MakeText(&s, nbytes);
-  BenchmarkMemoryUsage();
-  StartBenchmarkTiming();
-  search(iters, regexp, s, Prog::kUnanchored, false);
-  SetBenchmarkBytesProcessed(static_cast<int64_t>(iters)*nbytes);
-}
-
-// These two are easy because they start with an A,
-// giving the search loop something to memchr for.
+void Search(benchmark::State& state, const char* regexp, SearchImpl* search) {
+  std::string s = RandomText(state.range(0));
+  search(state, regexp, s, Prog::kUnanchored, false);
+  state.SetBytesProcessed(state.iterations() * state.range(0));
+}
+
+// These three are easy because they have prefixes,
+// giving the search loop something to prefix accel.
 #define EASY0      "ABCDEFGHIJKLMNOPQRSTUVWXYZ$"
 #define EASY1      "A[AB]B[BC]C[CD]D[DE]E[EF]F[FG]G[GH]H[HI]I[IJ]J$"
+#define EASY2      "(?i)" EASY0
 
 // This is a little harder, since it starts with a character class
 // and thus can't be memchr'ed.  Could look for ABC and work backward,
@@ -187,10 +204,10 @@ void Search(int iters, int nbytes, const char* regexp, SearchImpl* search) {
 #define PARENS     "([ -~])*(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)" \
                    "(N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)$"
 
-void Search_Easy0_CachedDFA(int i, int n)     { Search(i, n, EASY0, SearchCachedDFA); }
-void Search_Easy0_CachedNFA(int i, int n)     { Search(i, n, EASY0, SearchCachedNFA); }
-void Search_Easy0_CachedPCRE(int i, int n)    { Search(i, n, EASY0, SearchCachedPCRE); }
-void Search_Easy0_CachedRE2(int i, int n)     { Search(i, n, EASY0, SearchCachedRE2); }
+void Search_Easy0_CachedDFA(benchmark::State& state)     { Search(state, EASY0, SearchCachedDFA); }
+void Search_Easy0_CachedNFA(benchmark::State& state)     { Search(state, EASY0, SearchCachedNFA); }
+void Search_Easy0_CachedPCRE(benchmark::State& state)    { Search(state, EASY0, SearchCachedPCRE); }
+void Search_Easy0_CachedRE2(benchmark::State& state)     { Search(state, EASY0, SearchCachedRE2); }
 
 BENCHMARK_RANGE(Search_Easy0_CachedDFA,     8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_Easy0_CachedNFA,     8, 256<<10)->ThreadRange(1, NumCPUs());
@@ -199,10 +216,10 @@ BENCHMARK_RANGE(Search_Easy0_CachedPCRE,    8, 16<<20)->ThreadRange(1, NumCPUs()
 #endif
 BENCHMARK_RANGE(Search_Easy0_CachedRE2,     8, 16<<20)->ThreadRange(1, NumCPUs());
 
-void Search_Easy1_CachedDFA(int i, int n)     { Search(i, n, EASY1, SearchCachedDFA); }
-void Search_Easy1_CachedNFA(int i, int n)     { Search(i, n, EASY1, SearchCachedNFA); }
-void Search_Easy1_CachedPCRE(int i, int n)    { Search(i, n, EASY1, SearchCachedPCRE); }
-void Search_Easy1_CachedRE2(int i, int n)     { Search(i, n, EASY1, SearchCachedRE2); }
+void Search_Easy1_CachedDFA(benchmark::State& state)     { Search(state, EASY1, SearchCachedDFA); }
+void Search_Easy1_CachedNFA(benchmark::State& state)     { Search(state, EASY1, SearchCachedNFA); }
+void Search_Easy1_CachedPCRE(benchmark::State& state)    { Search(state, EASY1, SearchCachedPCRE); }
+void Search_Easy1_CachedRE2(benchmark::State& state)     { Search(state, EASY1, SearchCachedRE2); }
 
 BENCHMARK_RANGE(Search_Easy1_CachedDFA,     8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_Easy1_CachedNFA,     8, 256<<10)->ThreadRange(1, NumCPUs());
@@ -211,10 +228,22 @@ BENCHMARK_RANGE(Search_Easy1_CachedPCRE,    8, 16<<20)->ThreadRange(1, NumCPUs()
 #endif
 BENCHMARK_RANGE(Search_Easy1_CachedRE2,     8, 16<<20)->ThreadRange(1, NumCPUs());
 
-void Search_Medium_CachedDFA(int i, int n)     { Search(i, n, MEDIUM, SearchCachedDFA); }
-void Search_Medium_CachedNFA(int i, int n)     { Search(i, n, MEDIUM, SearchCachedNFA); }
-void Search_Medium_CachedPCRE(int i, int n)    { Search(i, n, MEDIUM, SearchCachedPCRE); }
-void Search_Medium_CachedRE2(int i, int n)     { Search(i, n, MEDIUM, SearchCachedRE2); }
+void Search_Easy2_CachedDFA(benchmark::State& state)     { Search(state, EASY2, SearchCachedDFA); }
+void Search_Easy2_CachedNFA(benchmark::State& state)     { Search(state, EASY2, SearchCachedNFA); }
+void Search_Easy2_CachedPCRE(benchmark::State& state)    { Search(state, EASY2, SearchCachedPCRE); }
+void Search_Easy2_CachedRE2(benchmark::State& state)     { Search(state, EASY2, SearchCachedRE2); }
+
+BENCHMARK_RANGE(Search_Easy2_CachedDFA,     8, 16<<20)->ThreadRange(1, NumCPUs());
+BENCHMARK_RANGE(Search_Easy2_CachedNFA,     8, 256<<10)->ThreadRange(1, NumCPUs());
+#ifdef USEPCRE
+BENCHMARK_RANGE(Search_Easy2_CachedPCRE,    8, 16<<20)->ThreadRange(1, NumCPUs());
+#endif
+BENCHMARK_RANGE(Search_Easy2_CachedRE2,     8, 16<<20)->ThreadRange(1, NumCPUs());
+
+void Search_Medium_CachedDFA(benchmark::State& state)     { Search(state, MEDIUM, SearchCachedDFA); }
+void Search_Medium_CachedNFA(benchmark::State& state)     { Search(state, MEDIUM, SearchCachedNFA); }
+void Search_Medium_CachedPCRE(benchmark::State& state)    { Search(state, MEDIUM, SearchCachedPCRE); }
+void Search_Medium_CachedRE2(benchmark::State& state)     { Search(state, MEDIUM, SearchCachedRE2); }
 
 BENCHMARK_RANGE(Search_Medium_CachedDFA,     8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_Medium_CachedNFA,     8, 256<<10)->ThreadRange(1, NumCPUs());
@@ -223,10 +252,10 @@ BENCHMARK_RANGE(Search_Medium_CachedPCRE,    8, 256<<10)->ThreadRange(1, NumCPUs
 #endif
 BENCHMARK_RANGE(Search_Medium_CachedRE2,     8, 16<<20)->ThreadRange(1, NumCPUs());
 
-void Search_Hard_CachedDFA(int i, int n)     { Search(i, n, HARD, SearchCachedDFA); }
-void Search_Hard_CachedNFA(int i, int n)     { Search(i, n, HARD, SearchCachedNFA); }
-void Search_Hard_CachedPCRE(int i, int n)    { Search(i, n, HARD, SearchCachedPCRE); }
-void Search_Hard_CachedRE2(int i, int n)     { Search(i, n, HARD, SearchCachedRE2); }
+void Search_Hard_CachedDFA(benchmark::State& state)     { Search(state, HARD, SearchCachedDFA); }
+void Search_Hard_CachedNFA(benchmark::State& state)     { Search(state, HARD, SearchCachedNFA); }
+void Search_Hard_CachedPCRE(benchmark::State& state)    { Search(state, HARD, SearchCachedPCRE); }
+void Search_Hard_CachedRE2(benchmark::State& state)     { Search(state, HARD, SearchCachedRE2); }
 
 BENCHMARK_RANGE(Search_Hard_CachedDFA,     8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_Hard_CachedNFA,     8, 256<<10)->ThreadRange(1, NumCPUs());
@@ -235,10 +264,10 @@ BENCHMARK_RANGE(Search_Hard_CachedPCRE,    8, 4<<10)->ThreadRange(1, NumCPUs());
 #endif
 BENCHMARK_RANGE(Search_Hard_CachedRE2,     8, 16<<20)->ThreadRange(1, NumCPUs());
 
-void Search_Fanout_CachedDFA(int i, int n)     { Search(i, n, FANOUT, SearchCachedDFA); }
-void Search_Fanout_CachedNFA(int i, int n)     { Search(i, n, FANOUT, SearchCachedNFA); }
-void Search_Fanout_CachedPCRE(int i, int n)    { Search(i, n, FANOUT, SearchCachedPCRE); }
-void Search_Fanout_CachedRE2(int i, int n)     { Search(i, n, FANOUT, SearchCachedRE2); }
+void Search_Fanout_CachedDFA(benchmark::State& state)     { Search(state, FANOUT, SearchCachedDFA); }
+void Search_Fanout_CachedNFA(benchmark::State& state)     { Search(state, FANOUT, SearchCachedNFA); }
+void Search_Fanout_CachedPCRE(benchmark::State& state)    { Search(state, FANOUT, SearchCachedPCRE); }
+void Search_Fanout_CachedRE2(benchmark::State& state)     { Search(state, FANOUT, SearchCachedRE2); }
 
 BENCHMARK_RANGE(Search_Fanout_CachedDFA,     8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_Fanout_CachedNFA,     8, 256<<10)->ThreadRange(1, NumCPUs());
@@ -247,10 +276,10 @@ BENCHMARK_RANGE(Search_Fanout_CachedPCRE,    8, 4<<10)->ThreadRange(1, NumCPUs()
 #endif
 BENCHMARK_RANGE(Search_Fanout_CachedRE2,     8, 16<<20)->ThreadRange(1, NumCPUs());
 
-void Search_Parens_CachedDFA(int i, int n)     { Search(i, n, PARENS, SearchCachedDFA); }
-void Search_Parens_CachedNFA(int i, int n)     { Search(i, n, PARENS, SearchCachedNFA); }
-void Search_Parens_CachedPCRE(int i, int n)    { Search(i, n, PARENS, SearchCachedPCRE); }
-void Search_Parens_CachedRE2(int i, int n)     { Search(i, n, PARENS, SearchCachedRE2); }
+void Search_Parens_CachedDFA(benchmark::State& state)     { Search(state, PARENS, SearchCachedDFA); }
+void Search_Parens_CachedNFA(benchmark::State& state)     { Search(state, PARENS, SearchCachedNFA); }
+void Search_Parens_CachedPCRE(benchmark::State& state)    { Search(state, PARENS, SearchCachedPCRE); }
+void Search_Parens_CachedRE2(benchmark::State& state)     { Search(state, PARENS, SearchCachedRE2); }
 
 BENCHMARK_RANGE(Search_Parens_CachedDFA,     8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_Parens_CachedNFA,     8, 256<<10)->ThreadRange(1, NumCPUs());
@@ -259,24 +288,20 @@ BENCHMARK_RANGE(Search_Parens_CachedPCRE,    8, 8)->ThreadRange(1, NumCPUs());
 #endif
 BENCHMARK_RANGE(Search_Parens_CachedRE2,     8, 16<<20)->ThreadRange(1, NumCPUs());
 
-void SearchBigFixed(int iters, int nbytes, SearchImpl* search) {
-  StopBenchmarkTiming();
-  string s;
-  s.append(nbytes/2, 'x');
-  string regexp = "^" + s + ".*$";
-  string t;
-  MakeText(&t, nbytes/2);
+void SearchBigFixed(benchmark::State& state, SearchImpl* search) {
+  std::string s;
+  s.append(state.range(0)/2, 'x');
+  std::string regexp = "^" + s + ".*$";
+  std::string t = RandomText(state.range(0)/2);
   s += t;
-  BenchmarkMemoryUsage();
-  StartBenchmarkTiming();
-  search(iters, regexp.c_str(), s, Prog::kUnanchored, true);
-  SetBenchmarkBytesProcessed(static_cast<int64_t>(iters)*nbytes);
+  search(state, regexp.c_str(), s, Prog::kUnanchored, true);
+  state.SetBytesProcessed(state.iterations() * state.range(0));
 }
 
-void Search_BigFixed_CachedDFA(int i, int n)     { SearchBigFixed(i, n, SearchCachedDFA); }
-void Search_BigFixed_CachedNFA(int i, int n)     { SearchBigFixed(i, n, SearchCachedNFA); }
-void Search_BigFixed_CachedPCRE(int i, int n)    { SearchBigFixed(i, n, SearchCachedPCRE); }
-void Search_BigFixed_CachedRE2(int i, int n)     { SearchBigFixed(i, n, SearchCachedRE2); }
+void Search_BigFixed_CachedDFA(benchmark::State& state)     { SearchBigFixed(state, SearchCachedDFA); }
+void Search_BigFixed_CachedNFA(benchmark::State& state)     { SearchBigFixed(state, SearchCachedNFA); }
+void Search_BigFixed_CachedPCRE(benchmark::State& state)    { SearchBigFixed(state, SearchCachedPCRE); }
+void Search_BigFixed_CachedRE2(benchmark::State& state)     { SearchBigFixed(state, SearchCachedRE2); }
 
 BENCHMARK_RANGE(Search_BigFixed_CachedDFA,     8, 1<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_BigFixed_CachedNFA,     8, 32<<10)->ThreadRange(1, NumCPUs());
@@ -287,43 +312,37 @@ BENCHMARK_RANGE(Search_BigFixed_CachedRE2,     8, 1<<20)->ThreadRange(1, NumCPUs
 
 // Benchmark: FindAndConsume
 
-void FindAndConsume(int iters, int nbytes) {
-  StopBenchmarkTiming();
-  string s;
-  MakeText(&s, nbytes);
+void FindAndConsume(benchmark::State& state) {
+  std::string s = RandomText(state.range(0));
   s.append("Hello World");
-  StartBenchmarkTiming();
   RE2 re("((Hello World))");
-  for (int i = 0; i < iters; i++) {
-    StringPiece t = s;
-    StringPiece u;
+  for (auto _ : state) {
+    absl::string_view t = s;
+    absl::string_view u;
     CHECK(RE2::FindAndConsume(&t, re, &u));
     CHECK_EQ(u, "Hello World");
   }
-  SetBenchmarkBytesProcessed(static_cast<int64_t>(iters)*nbytes);
+  state.SetBytesProcessed(state.iterations() * state.range(0));
 }
 
 BENCHMARK_RANGE(FindAndConsume, 8, 16<<20)->ThreadRange(1, NumCPUs());
 
 // Benchmark: successful anchored search.
 
-void SearchSuccess(int iters, int nbytes, const char* regexp, SearchImpl* search) {
-  StopBenchmarkTiming();
-  string s;
-  MakeText(&s, nbytes);
-  BenchmarkMemoryUsage();
-  StartBenchmarkTiming();
-  search(iters, regexp, s, Prog::kAnchored, true);
-  SetBenchmarkBytesProcessed(static_cast<int64_t>(iters)*nbytes);
+void SearchSuccess(benchmark::State& state, const char* regexp,
+                   SearchImpl* search) {
+  std::string s = RandomText(state.range(0));
+  search(state, regexp, s, Prog::kAnchored, true);
+  state.SetBytesProcessed(state.iterations() * state.range(0));
 }
 
 // Unambiguous search (RE2 can use OnePass).
 
-void Search_Success_DFA(int i, int n)     { SearchSuccess(i, n, ".*$", SearchDFA); }
-void Search_Success_NFA(int i, int n)     { SearchSuccess(i, n, ".*$", SearchNFA); }
-void Search_Success_PCRE(int i, int n)    { SearchSuccess(i, n, ".*$", SearchPCRE); }
-void Search_Success_RE2(int i, int n)     { SearchSuccess(i, n, ".*$", SearchRE2); }
-void Search_Success_OnePass(int i, int n) { SearchSuccess(i, n, ".*$", SearchOnePass); }
+void Search_Success_DFA(benchmark::State& state)     { SearchSuccess(state, ".*$", SearchDFA); }
+void Search_Success_NFA(benchmark::State& state)     { SearchSuccess(state, ".*$", SearchNFA); }
+void Search_Success_PCRE(benchmark::State& state)    { SearchSuccess(state, ".*$", SearchPCRE); }
+void Search_Success_RE2(benchmark::State& state)     { SearchSuccess(state, ".*$", SearchRE2); }
+void Search_Success_OnePass(benchmark::State& state) { SearchSuccess(state, ".*$", SearchOnePass); }
 
 BENCHMARK_RANGE(Search_Success_DFA,     8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_Success_NFA,     8, 16<<20)->ThreadRange(1, NumCPUs());
@@ -333,11 +352,11 @@ BENCHMARK_RANGE(Search_Success_PCRE,    8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_Success_RE2,     8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_Success_OnePass, 8, 2<<20)->ThreadRange(1, NumCPUs());
 
-void Search_Success_CachedDFA(int i, int n)     { SearchSuccess(i, n, ".*$", SearchCachedDFA); }
-void Search_Success_CachedNFA(int i, int n)     { SearchSuccess(i, n, ".*$", SearchCachedNFA); }
-void Search_Success_CachedPCRE(int i, int n)    { SearchSuccess(i, n, ".*$", SearchCachedPCRE); }
-void Search_Success_CachedRE2(int i, int n)     { SearchSuccess(i, n, ".*$", SearchCachedRE2); }
-void Search_Success_CachedOnePass(int i, int n) { SearchSuccess(i, n, ".*$", SearchCachedOnePass); }
+void Search_Success_CachedDFA(benchmark::State& state)     { SearchSuccess(state, ".*$", SearchCachedDFA); }
+void Search_Success_CachedNFA(benchmark::State& state)     { SearchSuccess(state, ".*$", SearchCachedNFA); }
+void Search_Success_CachedPCRE(benchmark::State& state)    { SearchSuccess(state, ".*$", SearchCachedPCRE); }
+void Search_Success_CachedRE2(benchmark::State& state)     { SearchSuccess(state, ".*$", SearchCachedRE2); }
+void Search_Success_CachedOnePass(benchmark::State& state) { SearchSuccess(state, ".*$", SearchCachedOnePass); }
 
 BENCHMARK_RANGE(Search_Success_CachedDFA,     8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_Success_CachedNFA,     8, 16<<20)->ThreadRange(1, NumCPUs());
@@ -350,11 +369,11 @@ BENCHMARK_RANGE(Search_Success_CachedOnePass, 8, 2<<20)->ThreadRange(1, NumCPUs(
 // Ambiguous search (RE2 cannot use OnePass).
 // Used to be ".*.$", but that is coalesced to ".+$" these days.
 
-void Search_Success1_DFA(int i, int n)      { SearchSuccess(i, n, ".*\\C$", SearchDFA); }
-void Search_Success1_NFA(int i, int n)      { SearchSuccess(i, n, ".*\\C$", SearchNFA); }
-void Search_Success1_PCRE(int i, int n)     { SearchSuccess(i, n, ".*\\C$", SearchPCRE); }
-void Search_Success1_RE2(int i, int n)      { SearchSuccess(i, n, ".*\\C$", SearchRE2); }
-void Search_Success1_BitState(int i, int n) { SearchSuccess(i, n, ".*\\C$", SearchBitState); }
+void Search_Success1_DFA(benchmark::State& state)      { SearchSuccess(state, ".*\\C$", SearchDFA); }
+void Search_Success1_NFA(benchmark::State& state)      { SearchSuccess(state, ".*\\C$", SearchNFA); }
+void Search_Success1_PCRE(benchmark::State& state)     { SearchSuccess(state, ".*\\C$", SearchPCRE); }
+void Search_Success1_RE2(benchmark::State& state)      { SearchSuccess(state, ".*\\C$", SearchRE2); }
+void Search_Success1_BitState(benchmark::State& state) { SearchSuccess(state, ".*\\C$", SearchBitState); }
 
 BENCHMARK_RANGE(Search_Success1_DFA,      8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_Success1_NFA,      8, 16<<20)->ThreadRange(1, NumCPUs());
@@ -364,11 +383,11 @@ BENCHMARK_RANGE(Search_Success1_PCRE,     8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_Success1_RE2,      8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_Success1_BitState, 8, 2<<20)->ThreadRange(1, NumCPUs());
 
-void Search_Success1_CachedDFA(int i, int n)      { SearchSuccess(i, n, ".*\\C$", SearchCachedDFA); }
-void Search_Success1_CachedNFA(int i, int n)      { SearchSuccess(i, n, ".*\\C$", SearchCachedNFA); }
-void Search_Success1_CachedPCRE(int i, int n)     { SearchSuccess(i, n, ".*\\C$", SearchCachedPCRE); }
-void Search_Success1_CachedRE2(int i, int n)      { SearchSuccess(i, n, ".*\\C$", SearchCachedRE2); }
-void Search_Success1_CachedBitState(int i, int n) { SearchSuccess(i, n, ".*\\C$", SearchCachedBitState); }
+void Search_Success1_CachedDFA(benchmark::State& state)      { SearchSuccess(state, ".*\\C$", SearchCachedDFA); }
+void Search_Success1_CachedNFA(benchmark::State& state)      { SearchSuccess(state, ".*\\C$", SearchCachedNFA); }
+void Search_Success1_CachedPCRE(benchmark::State& state)     { SearchSuccess(state, ".*\\C$", SearchCachedPCRE); }
+void Search_Success1_CachedRE2(benchmark::State& state)      { SearchSuccess(state, ".*\\C$", SearchCachedRE2); }
+void Search_Success1_CachedBitState(benchmark::State& state) { SearchSuccess(state, ".*\\C$", SearchCachedBitState); }
 
 BENCHMARK_RANGE(Search_Success1_CachedDFA,      8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_Success1_CachedNFA,      8, 16<<20)->ThreadRange(1, NumCPUs());
@@ -381,22 +400,18 @@ BENCHMARK_RANGE(Search_Success1_CachedBitState, 8, 2<<20)->ThreadRange(1, NumCPU
 // Benchmark: AltMatch optimisation (just to verify that it works)
 // Note that OnePass doesn't implement it!
 
-void SearchAltMatch(int iters, int nbytes, SearchImpl* search) {
-  StopBenchmarkTiming();
-  string s;
-  MakeText(&s, nbytes);
-  BenchmarkMemoryUsage();
-  StartBenchmarkTiming();
-  search(iters, "\\C*", s, Prog::kAnchored, true);
-  SetBenchmarkBytesProcessed(static_cast<int64_t>(iters)*nbytes);
+void SearchAltMatch(benchmark::State& state, SearchImpl* search) {
+  std::string s = RandomText(state.range(0));
+  search(state, "\\C*", s, Prog::kAnchored, true);
+  state.SetBytesProcessed(state.iterations() * state.range(0));
 }
 
-void Search_AltMatch_DFA(int i, int n)      { SearchAltMatch(i, n, SearchDFA); }
-void Search_AltMatch_NFA(int i, int n)      { SearchAltMatch(i, n, SearchNFA); }
-void Search_AltMatch_OnePass(int i, int n)  { SearchAltMatch(i, n, SearchOnePass); }
-void Search_AltMatch_BitState(int i, int n) { SearchAltMatch(i, n, SearchBitState); }
-void Search_AltMatch_PCRE(int i, int n)     { SearchAltMatch(i, n, SearchPCRE); }
-void Search_AltMatch_RE2(int i, int n)      { SearchAltMatch(i, n, SearchRE2); }
+void Search_AltMatch_DFA(benchmark::State& state)      { SearchAltMatch(state, SearchDFA); }
+void Search_AltMatch_NFA(benchmark::State& state)      { SearchAltMatch(state, SearchNFA); }
+void Search_AltMatch_OnePass(benchmark::State& state)  { SearchAltMatch(state, SearchOnePass); }
+void Search_AltMatch_BitState(benchmark::State& state) { SearchAltMatch(state, SearchBitState); }
+void Search_AltMatch_PCRE(benchmark::State& state)     { SearchAltMatch(state, SearchPCRE); }
+void Search_AltMatch_RE2(benchmark::State& state)      { SearchAltMatch(state, SearchRE2); }
 
 BENCHMARK_RANGE(Search_AltMatch_DFA,      8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_AltMatch_NFA,      8, 16<<20)->ThreadRange(1, NumCPUs());
@@ -407,12 +422,12 @@ BENCHMARK_RANGE(Search_AltMatch_PCRE,     8, 16<<20)->ThreadRange(1, NumCPUs());
 #endif
 BENCHMARK_RANGE(Search_AltMatch_RE2,      8, 16<<20)->ThreadRange(1, NumCPUs());
 
-void Search_AltMatch_CachedDFA(int i, int n)      { SearchAltMatch(i, n, SearchCachedDFA); }
-void Search_AltMatch_CachedNFA(int i, int n)      { SearchAltMatch(i, n, SearchCachedNFA); }
-void Search_AltMatch_CachedOnePass(int i, int n)  { SearchAltMatch(i, n, SearchCachedOnePass); }
-void Search_AltMatch_CachedBitState(int i, int n) { SearchAltMatch(i, n, SearchCachedBitState); }
-void Search_AltMatch_CachedPCRE(int i, int n)     { SearchAltMatch(i, n, SearchCachedPCRE); }
-void Search_AltMatch_CachedRE2(int i, int n)      { SearchAltMatch(i, n, SearchCachedRE2); }
+void Search_AltMatch_CachedDFA(benchmark::State& state)      { SearchAltMatch(state, SearchCachedDFA); }
+void Search_AltMatch_CachedNFA(benchmark::State& state)      { SearchAltMatch(state, SearchCachedNFA); }
+void Search_AltMatch_CachedOnePass(benchmark::State& state)  { SearchAltMatch(state, SearchCachedOnePass); }
+void Search_AltMatch_CachedBitState(benchmark::State& state) { SearchAltMatch(state, SearchCachedBitState); }
+void Search_AltMatch_CachedPCRE(benchmark::State& state)     { SearchAltMatch(state, SearchCachedPCRE); }
+void Search_AltMatch_CachedRE2(benchmark::State& state)      { SearchAltMatch(state, SearchCachedRE2); }
 
 BENCHMARK_RANGE(Search_AltMatch_CachedDFA,      8, 16<<20)->ThreadRange(1, NumCPUs());
 BENCHMARK_RANGE(Search_AltMatch_CachedNFA,      8, 16<<20)->ThreadRange(1, NumCPUs());
@@ -425,19 +440,18 @@ BENCHMARK_RANGE(Search_AltMatch_CachedRE2,      8, 16<<20)->ThreadRange(1, NumCP
 
 // Benchmark: use regexp to find phone number.
 
-void SearchDigits(int iters, SearchImpl* search) {
-  StringPiece s("650-253-0001");
-  BenchmarkMemoryUsage();
-  search(iters, "([0-9]+)-([0-9]+)-([0-9]+)", s, Prog::kAnchored, true);
-  SetBenchmarkItemsProcessed(iters);
+void SearchDigits(benchmark::State& state, SearchImpl* search) {
+  absl::string_view s("650-253-0001");
+  search(state, "([0-9]+)-([0-9]+)-([0-9]+)", s, Prog::kAnchored, true);
+  state.SetItemsProcessed(state.iterations());
 }
 
-void Search_Digits_DFA(int i)         { SearchDigits(i, SearchDFA); }
-void Search_Digits_NFA(int i)         { SearchDigits(i, SearchNFA); }
-void Search_Digits_OnePass(int i)     { SearchDigits(i, SearchOnePass); }
-void Search_Digits_PCRE(int i)        { SearchDigits(i, SearchPCRE); }
-void Search_Digits_RE2(int i)         { SearchDigits(i, SearchRE2); }
-void Search_Digits_BitState(int i)         { SearchDigits(i, SearchBitState); }
+void Search_Digits_DFA(benchmark::State& state)         { SearchDigits(state, SearchDFA); }
+void Search_Digits_NFA(benchmark::State& state)         { SearchDigits(state, SearchNFA); }
+void Search_Digits_OnePass(benchmark::State& state)     { SearchDigits(state, SearchOnePass); }
+void Search_Digits_PCRE(benchmark::State& state)        { SearchDigits(state, SearchPCRE); }
+void Search_Digits_RE2(benchmark::State& state)         { SearchDigits(state, SearchRE2); }
+void Search_Digits_BitState(benchmark::State& state)    { SearchDigits(state, SearchBitState); }
 
 BENCHMARK(Search_Digits_DFA)->ThreadRange(1, NumCPUs());
 BENCHMARK(Search_Digits_NFA)->ThreadRange(1, NumCPUs());
@@ -450,19 +464,19 @@ BENCHMARK(Search_Digits_BitState)->ThreadRange(1, NumCPUs());
 
 // Benchmark: use regexp to parse digit fields in phone number.
 
-void Parse3Digits(int iters,
-               void (*parse3)(int, const char*, const StringPiece&)) {
-  BenchmarkMemoryUsage();
-  parse3(iters, "([0-9]+)-([0-9]+)-([0-9]+)", "650-253-0001");
-  SetBenchmarkItemsProcessed(iters);
+void Parse3Digits(benchmark::State& state,
+                  void (*parse3)(benchmark::State&, const char*,
+                                 absl::string_view)) {
+  parse3(state, "([0-9]+)-([0-9]+)-([0-9]+)", "650-253-0001");
+  state.SetItemsProcessed(state.iterations());
 }
 
-void Parse_Digits_NFA(int i)         { Parse3Digits(i, Parse3NFA); }
-void Parse_Digits_OnePass(int i)     { Parse3Digits(i, Parse3OnePass); }
-void Parse_Digits_PCRE(int i)        { Parse3Digits(i, Parse3PCRE); }
-void Parse_Digits_RE2(int i)         { Parse3Digits(i, Parse3RE2); }
-void Parse_Digits_Backtrack(int i)   { Parse3Digits(i, Parse3Backtrack); }
-void Parse_Digits_BitState(int i)   { Parse3Digits(i, Parse3BitState); }
+void Parse_Digits_NFA(benchmark::State& state)         { Parse3Digits(state, Parse3NFA); }
+void Parse_Digits_OnePass(benchmark::State& state)     { Parse3Digits(state, Parse3OnePass); }
+void Parse_Digits_PCRE(benchmark::State& state)        { Parse3Digits(state, Parse3PCRE); }
+void Parse_Digits_RE2(benchmark::State& state)         { Parse3Digits(state, Parse3RE2); }
+void Parse_Digits_Backtrack(benchmark::State& state)   { Parse3Digits(state, Parse3Backtrack); }
+void Parse_Digits_BitState(benchmark::State& state)    { Parse3Digits(state, Parse3BitState); }
 
 BENCHMARK(Parse_Digits_NFA)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_Digits_OnePass)->ThreadRange(1, NumCPUs());
@@ -473,12 +487,12 @@ BENCHMARK(Parse_Digits_RE2)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_Digits_Backtrack)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_Digits_BitState)->ThreadRange(1, NumCPUs());
 
-void Parse_CachedDigits_NFA(int i)         { Parse3Digits(i, Parse3CachedNFA); }
-void Parse_CachedDigits_OnePass(int i)     { Parse3Digits(i, Parse3CachedOnePass); }
-void Parse_CachedDigits_PCRE(int i)        { Parse3Digits(i, Parse3CachedPCRE); }
-void Parse_CachedDigits_RE2(int i)         { Parse3Digits(i, Parse3CachedRE2); }
-void Parse_CachedDigits_Backtrack(int i)   { Parse3Digits(i, Parse3CachedBacktrack); }
-void Parse_CachedDigits_BitState(int i)   { Parse3Digits(i, Parse3CachedBitState); }
+void Parse_CachedDigits_NFA(benchmark::State& state)         { Parse3Digits(state, Parse3CachedNFA); }
+void Parse_CachedDigits_OnePass(benchmark::State& state)     { Parse3Digits(state, Parse3CachedOnePass); }
+void Parse_CachedDigits_PCRE(benchmark::State& state)        { Parse3Digits(state, Parse3CachedPCRE); }
+void Parse_CachedDigits_RE2(benchmark::State& state)         { Parse3Digits(state, Parse3CachedRE2); }
+void Parse_CachedDigits_Backtrack(benchmark::State& state)   { Parse3Digits(state, Parse3CachedBacktrack); }
+void Parse_CachedDigits_BitState(benchmark::State& state)    { Parse3Digits(state, Parse3CachedBitState); }
 
 BENCHMARK(Parse_CachedDigits_NFA)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_CachedDigits_OnePass)->ThreadRange(1, NumCPUs());
@@ -489,19 +503,19 @@ BENCHMARK(Parse_CachedDigits_Backtrack)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_CachedDigits_RE2)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_CachedDigits_BitState)->ThreadRange(1, NumCPUs());
 
-void Parse3DigitDs(int iters,
-               void (*parse3)(int, const char*, const StringPiece&)) {
-  BenchmarkMemoryUsage();
-  parse3(iters, "(\\d+)-(\\d+)-(\\d+)", "650-253-0001");
-  SetBenchmarkItemsProcessed(iters);
+void Parse3DigitDs(benchmark::State& state,
+                   void (*parse3)(benchmark::State&, const char*,
+                                  absl::string_view)) {
+  parse3(state, "(\\d+)-(\\d+)-(\\d+)", "650-253-0001");
+  state.SetItemsProcessed(state.iterations());
 }
 
-void Parse_DigitDs_NFA(int i)         { Parse3DigitDs(i, Parse3NFA); }
-void Parse_DigitDs_OnePass(int i)     { Parse3DigitDs(i, Parse3OnePass); }
-void Parse_DigitDs_PCRE(int i)        { Parse3DigitDs(i, Parse3PCRE); }
-void Parse_DigitDs_RE2(int i)         { Parse3DigitDs(i, Parse3RE2); }
-void Parse_DigitDs_Backtrack(int i)   { Parse3DigitDs(i, Parse3CachedBacktrack); }
-void Parse_DigitDs_BitState(int i)   { Parse3DigitDs(i, Parse3CachedBitState); }
+void Parse_DigitDs_NFA(benchmark::State& state)         { Parse3DigitDs(state, Parse3NFA); }
+void Parse_DigitDs_OnePass(benchmark::State& state)     { Parse3DigitDs(state, Parse3OnePass); }
+void Parse_DigitDs_PCRE(benchmark::State& state)        { Parse3DigitDs(state, Parse3PCRE); }
+void Parse_DigitDs_RE2(benchmark::State& state)         { Parse3DigitDs(state, Parse3RE2); }
+void Parse_DigitDs_Backtrack(benchmark::State& state)   { Parse3DigitDs(state, Parse3CachedBacktrack); }
+void Parse_DigitDs_BitState(benchmark::State& state)    { Parse3DigitDs(state, Parse3CachedBitState); }
 
 BENCHMARK(Parse_DigitDs_NFA)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_DigitDs_OnePass)->ThreadRange(1, NumCPUs());
@@ -512,12 +526,12 @@ BENCHMARK(Parse_DigitDs_RE2)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_DigitDs_Backtrack)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_DigitDs_BitState)->ThreadRange(1, NumCPUs());
 
-void Parse_CachedDigitDs_NFA(int i)         { Parse3DigitDs(i, Parse3CachedNFA); }
-void Parse_CachedDigitDs_OnePass(int i)     { Parse3DigitDs(i, Parse3CachedOnePass); }
-void Parse_CachedDigitDs_PCRE(int i)        { Parse3DigitDs(i, Parse3CachedPCRE); }
-void Parse_CachedDigitDs_RE2(int i)         { Parse3DigitDs(i, Parse3CachedRE2); }
-void Parse_CachedDigitDs_Backtrack(int i)   { Parse3DigitDs(i, Parse3CachedBacktrack); }
-void Parse_CachedDigitDs_BitState(int i)   { Parse3DigitDs(i, Parse3CachedBitState); }
+void Parse_CachedDigitDs_NFA(benchmark::State& state)         { Parse3DigitDs(state, Parse3CachedNFA); }
+void Parse_CachedDigitDs_OnePass(benchmark::State& state)     { Parse3DigitDs(state, Parse3CachedOnePass); }
+void Parse_CachedDigitDs_PCRE(benchmark::State& state)        { Parse3DigitDs(state, Parse3CachedPCRE); }
+void Parse_CachedDigitDs_RE2(benchmark::State& state)         { Parse3DigitDs(state, Parse3CachedRE2); }
+void Parse_CachedDigitDs_Backtrack(benchmark::State& state)   { Parse3DigitDs(state, Parse3CachedBacktrack); }
+void Parse_CachedDigitDs_BitState(benchmark::State& state)    { Parse3DigitDs(state, Parse3CachedBitState); }
 
 BENCHMARK(Parse_CachedDigitDs_NFA)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_CachedDigitDs_OnePass)->ThreadRange(1, NumCPUs());
@@ -530,18 +544,18 @@ BENCHMARK(Parse_CachedDigitDs_BitState)->ThreadRange(1, NumCPUs());
 
 // Benchmark: splitting off leading number field.
 
-void Parse1Split(int iters,
-              void (*parse1)(int, const char*, const StringPiece&)) {
-  BenchmarkMemoryUsage();
-  parse1(iters, "[0-9]+-(.*)", "650-253-0001");
-  SetBenchmarkItemsProcessed(iters);
+void Parse1Split(benchmark::State& state,
+                 void (*parse1)(benchmark::State&, const char*,
+                                absl::string_view)) {
+  parse1(state, "[0-9]+-(.*)", "650-253-0001");
+  state.SetItemsProcessed(state.iterations());
 }
 
-void Parse_Split_NFA(int i)         { Parse1Split(i, Parse1NFA); }
-void Parse_Split_OnePass(int i)     { Parse1Split(i, Parse1OnePass); }
-void Parse_Split_PCRE(int i)        { Parse1Split(i, Parse1PCRE); }
-void Parse_Split_RE2(int i)         { Parse1Split(i, Parse1RE2); }
-void Parse_Split_BitState(int i)         { Parse1Split(i, Parse1BitState); }
+void Parse_Split_NFA(benchmark::State& state)         { Parse1Split(state, Parse1NFA); }
+void Parse_Split_OnePass(benchmark::State& state)     { Parse1Split(state, Parse1OnePass); }
+void Parse_Split_PCRE(benchmark::State& state)        { Parse1Split(state, Parse1PCRE); }
+void Parse_Split_RE2(benchmark::State& state)         { Parse1Split(state, Parse1RE2); }
+void Parse_Split_BitState(benchmark::State& state)    { Parse1Split(state, Parse1BitState); }
 
 BENCHMARK(Parse_Split_NFA)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_Split_OnePass)->ThreadRange(1, NumCPUs());
@@ -551,11 +565,11 @@ BENCHMARK(Parse_Split_PCRE)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_Split_RE2)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_Split_BitState)->ThreadRange(1, NumCPUs());
 
-void Parse_CachedSplit_NFA(int i)         { Parse1Split(i, Parse1CachedNFA); }
-void Parse_CachedSplit_OnePass(int i)     { Parse1Split(i, Parse1CachedOnePass); }
-void Parse_CachedSplit_PCRE(int i)        { Parse1Split(i, Parse1CachedPCRE); }
-void Parse_CachedSplit_RE2(int i)         { Parse1Split(i, Parse1CachedRE2); }
-void Parse_CachedSplit_BitState(int i)         { Parse1Split(i, Parse1CachedBitState); }
+void Parse_CachedSplit_NFA(benchmark::State& state)         { Parse1Split(state, Parse1CachedNFA); }
+void Parse_CachedSplit_OnePass(benchmark::State& state)     { Parse1Split(state, Parse1CachedOnePass); }
+void Parse_CachedSplit_PCRE(benchmark::State& state)        { Parse1Split(state, Parse1CachedPCRE); }
+void Parse_CachedSplit_RE2(benchmark::State& state)         { Parse1Split(state, Parse1CachedRE2); }
+void Parse_CachedSplit_BitState(benchmark::State& state)    { Parse1Split(state, Parse1CachedBitState); }
 
 BENCHMARK(Parse_CachedSplit_NFA)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_CachedSplit_OnePass)->ThreadRange(1, NumCPUs());
@@ -567,17 +581,17 @@ BENCHMARK(Parse_CachedSplit_BitState)->ThreadRange(1, NumCPUs());
 
 // Benchmark: splitting off leading number field but harder (ambiguous regexp).
 
-void Parse1SplitHard(int iters,
-                  void (*run)(int, const char*, const StringPiece&)) {
-  BenchmarkMemoryUsage();
-  run(iters, "[0-9]+.(.*)", "650-253-0001");
-  SetBenchmarkItemsProcessed(iters);
+void Parse1SplitHard(benchmark::State& state,
+                     void (*run)(benchmark::State&, const char*,
+                                 absl::string_view)) {
+  run(state, "[0-9]+.(.*)", "650-253-0001");
+  state.SetItemsProcessed(state.iterations());
 }
 
-void Parse_SplitHard_NFA(int i)         { Parse1SplitHard(i, Parse1NFA); }
-void Parse_SplitHard_PCRE(int i)        { Parse1SplitHard(i, Parse1PCRE); }
-void Parse_SplitHard_RE2(int i)         { Parse1SplitHard(i, Parse1RE2); }
-void Parse_SplitHard_BitState(int i)         { Parse1SplitHard(i, Parse1BitState); }
+void Parse_SplitHard_NFA(benchmark::State& state)         { Parse1SplitHard(state, Parse1NFA); }
+void Parse_SplitHard_PCRE(benchmark::State& state)        { Parse1SplitHard(state, Parse1PCRE); }
+void Parse_SplitHard_RE2(benchmark::State& state)         { Parse1SplitHard(state, Parse1RE2); }
+void Parse_SplitHard_BitState(benchmark::State& state)    { Parse1SplitHard(state, Parse1BitState); }
 
 #ifdef USEPCRE
 BENCHMARK(Parse_SplitHard_PCRE)->ThreadRange(1, NumCPUs());
@@ -586,11 +600,11 @@ BENCHMARK(Parse_SplitHard_RE2)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_SplitHard_BitState)->ThreadRange(1, NumCPUs());
 BENCHMARK(Parse_SplitHard_NFA)->ThreadRange(1, NumCPUs());
 
-void Parse_CachedSplitHard_NFA(int i)       { Parse1SplitHard(i, Parse1CachedNFA); }
-void Parse_CachedSplitHard_PCRE(int i)      { Parse1SplitHard(i, Parse1CachedPCRE); }
-void Parse_CachedSplitHard_RE2(int i)       { Parse1SplitHard(i, Parse1CachedRE2); }
-void Parse_CachedSplitHard_BitState(int i)       { Parse1SplitHard(i, Parse1CachedBitState); }
-void Parse_CachedSplitHard_Backtrack(int i)       { Parse1SplitHard(i, Parse1CachedBacktrack); }
+void Parse_CachedSplitHard_NFA(benchmark::State& state)       { Parse1SplitHard(state, Parse1CachedNFA); }
+void Parse_CachedSplitHard_PCRE(benchmark::State& state)      { Parse1SplitHard(state, Parse1CachedPCRE); }
+void Parse_CachedSplitHard_RE2(benchmark::State& state)       { Parse1SplitHard(state, Parse1CachedRE2); }
+void Parse_CachedSplitHard_BitState(benchmark::State& state)  { Parse1SplitHard(state, Parse1CachedBitState); }
+void Parse_CachedSplitHard_Backtrack(benchmark::State& state) { Parse1SplitHard(state, Parse1CachedBacktrack); }
 
 #ifdef USEPCRE
 BENCHMARK(Parse_CachedSplitHard_PCRE)->ThreadRange(1, NumCPUs());
@@ -602,18 +616,18 @@ BENCHMARK(Parse_CachedSplitHard_Backtrack)->ThreadRange(1, NumCPUs());
 
 // Benchmark: Parse1SplitHard, big text, small match.
 
-void Parse1SplitBig1(int iters,
-                  void (*run)(int, const char*, const StringPiece&)) {
-  string s;
+void Parse1SplitBig1(benchmark::State& state,
+                     void (*run)(benchmark::State&, const char*,
+                                 absl::string_view)) {
+  std::string s;
   s.append(100000, 'x');
   s.append("650-253-0001");
-  BenchmarkMemoryUsage();
-  run(iters, "[0-9]+.(.*)", s);
-  SetBenchmarkItemsProcessed(iters);
+  run(state, "[0-9]+.(.*)", s);
+  state.SetItemsProcessed(state.iterations());
 }
 
-void Parse_CachedSplitBig1_PCRE(int i)      { Parse1SplitBig1(i, SearchParse1CachedPCRE); }
-void Parse_CachedSplitBig1_RE2(int i)       { Parse1SplitBig1(i, SearchParse1CachedRE2); }
+void Parse_CachedSplitBig1_PCRE(benchmark::State& state)      { Parse1SplitBig1(state, SearchParse1CachedPCRE); }
+void Parse_CachedSplitBig1_RE2(benchmark::State& state)       { Parse1SplitBig1(state, SearchParse1CachedRE2); }
 
 #ifdef USEPCRE
 BENCHMARK(Parse_CachedSplitBig1_PCRE)->ThreadRange(1, NumCPUs());
@@ -622,18 +636,18 @@ BENCHMARK(Parse_CachedSplitBig1_RE2)->ThreadRange(1, NumCPUs());
 
 // Benchmark: Parse1SplitHard, big text, big match.
 
-void Parse1SplitBig2(int iters,
-                  void (*run)(int, const char*, const StringPiece&)) {
-  string s;
+void Parse1SplitBig2(benchmark::State& state,
+                     void (*run)(benchmark::State&, const char*,
+                                 absl::string_view)) {
+  std::string s;
   s.append("650-253-");
   s.append(100000, '0');
-  BenchmarkMemoryUsage();
-  run(iters, "[0-9]+.(.*)", s);
-  SetBenchmarkItemsProcessed(iters);
+  run(state, "[0-9]+.(.*)", s);
+  state.SetItemsProcessed(state.iterations());
 }
 
-void Parse_CachedSplitBig2_PCRE(int i)      { Parse1SplitBig2(i, SearchParse1CachedPCRE); }
-void Parse_CachedSplitBig2_RE2(int i)       { Parse1SplitBig2(i, SearchParse1CachedRE2); }
+void Parse_CachedSplitBig2_PCRE(benchmark::State& state)      { Parse1SplitBig2(state, SearchParse1CachedPCRE); }
+void Parse_CachedSplitBig2_RE2(benchmark::State& state)       { Parse1SplitBig2(state, SearchParse1CachedRE2); }
 
 #ifdef USEPCRE
 BENCHMARK(Parse_CachedSplitBig2_PCRE)->ThreadRange(1, NumCPUs());
@@ -643,16 +657,16 @@ BENCHMARK(Parse_CachedSplitBig2_RE2)->ThreadRange(1, NumCPUs());
 // Benchmark: measure time required to parse (but not execute)
 // a simple regular expression.
 
-void ParseRegexp(int iters, const string& regexp) {
-  for (int i = 0; i < iters; i++) {
+void ParseRegexp(benchmark::State& state, const std::string& regexp) {
+  for (auto _ : state) {
     Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
     CHECK(re);
     re->Decref();
   }
 }
 
-void SimplifyRegexp(int iters, const string& regexp) {
-  for (int i = 0; i < iters; i++) {
+void SimplifyRegexp(benchmark::State& state, const std::string& regexp) {
+  for (auto _ : state) {
     Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
     CHECK(re);
     Regexp* sre = re->Simplify();
@@ -662,17 +676,17 @@ void SimplifyRegexp(int iters, const string& regexp) {
   }
 }
 
-void NullWalkRegexp(int iters, const string& regexp) {
+void NullWalkRegexp(benchmark::State& state, const std::string& regexp) {
   Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
   CHECK(re);
-  for (int i = 0; i < iters; i++) {
+  for (auto _ : state) {
     re->NullWalk();
   }
   re->Decref();
 }
 
-void SimplifyCompileRegexp(int iters, const string& regexp) {
-  for (int i = 0; i < iters; i++) {
+void SimplifyCompileRegexp(benchmark::State& state, const std::string& regexp) {
+  for (auto _ : state) {
     Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
     CHECK(re);
     Regexp* sre = re->Simplify();
@@ -685,8 +699,8 @@ void SimplifyCompileRegexp(int iters, const string& regexp) {
   }
 }
 
-void CompileRegexp(int iters, const string& regexp) {
-  for (int i = 0; i < iters; i++) {
+void CompileRegexp(benchmark::State& state, const std::string& regexp) {
+  for (auto _ : state) {
     Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
     CHECK(re);
     Prog* prog = re->CompileToProg(0);
@@ -696,10 +710,10 @@ void CompileRegexp(int iters, const string& regexp) {
   }
 }
 
-void CompileToProg(int iters, const string& regexp) {
+void CompileToProg(benchmark::State& state, const std::string& regexp) {
   Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
   CHECK(re);
-  for (int i = 0; i < iters; i++) {
+  for (auto _ : state) {
     Prog* prog = re->CompileToProg(0);
     CHECK(prog);
     delete prog;
@@ -707,52 +721,54 @@ void CompileToProg(int iters, const string& regexp) {
   re->Decref();
 }
 
-void CompileByteMap(int iters, const string& regexp) {
+void CompileByteMap(benchmark::State& state, const std::string& regexp) {
   Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
   CHECK(re);
   Prog* prog = re->CompileToProg(0);
   CHECK(prog);
-  for (int i = 0; i < iters; i++) {
+  for (auto _ : state) {
     prog->ComputeByteMap();
   }
   delete prog;
   re->Decref();
 }
 
-void CompilePCRE(int iters, const string& regexp) {
-  for (int i = 0; i < iters; i++) {
+void CompilePCRE(benchmark::State& state, const std::string& regexp) {
+  for (auto _ : state) {
     PCRE re(regexp, PCRE::UTF8);
     CHECK_EQ(re.error(), "");
   }
 }
 
-void CompileRE2(int iters, const string& regexp) {
-  for (int i = 0; i < iters; i++) {
+void CompileRE2(benchmark::State& state, const std::string& regexp) {
+  for (auto _ : state) {
     RE2 re(regexp);
     CHECK_EQ(re.error(), "");
   }
 }
 
-void RunBuild(int iters, const string& regexp, void (*run)(int, const string&)) {
-  run(iters, regexp);
-  SetBenchmarkItemsProcessed(iters);
+void RunBuild(benchmark::State& state, const std::string& regexp,
+              void (*run)(benchmark::State&, const std::string&)) {
+  run(state, regexp);
+  state.SetItemsProcessed(state.iterations());
 }
 
 }  // namespace re2
 
-DEFINE_string(compile_regexp, "(.*)-(\\d+)-of-(\\d+)", "regexp for compile benchmarks");
+ABSL_FLAG(std::string, compile_regexp, "(.*)-(\\d+)-of-(\\d+)",
+          "regexp for compile benchmarks");
 
 namespace re2 {
 
-void BM_PCRE_Compile(int i)      { RunBuild(i, FLAGS_compile_regexp, CompilePCRE); }
-void BM_Regexp_Parse(int i)      { RunBuild(i, FLAGS_compile_regexp, ParseRegexp); }
-void BM_Regexp_Simplify(int i)   { RunBuild(i, FLAGS_compile_regexp, SimplifyRegexp); }
-void BM_CompileToProg(int i)     { RunBuild(i, FLAGS_compile_regexp, CompileToProg); }
-void BM_CompileByteMap(int i)     { RunBuild(i, FLAGS_compile_regexp, CompileByteMap); }
-void BM_Regexp_Compile(int i)    { RunBuild(i, FLAGS_compile_regexp, CompileRegexp); }
-void BM_Regexp_SimplifyCompile(int i)   { RunBuild(i, FLAGS_compile_regexp, SimplifyCompileRegexp); }
-void BM_Regexp_NullWalk(int i)   { RunBuild(i, FLAGS_compile_regexp, NullWalkRegexp); }
-void BM_RE2_Compile(int i)       { RunBuild(i, FLAGS_compile_regexp, CompileRE2); }
+void BM_PCRE_Compile(benchmark::State& state)             { RunBuild(state, absl::GetFlag(FLAGS_compile_regexp), CompilePCRE); }
+void BM_Regexp_Parse(benchmark::State& state)             { RunBuild(state, absl::GetFlag(FLAGS_compile_regexp), ParseRegexp); }
+void BM_Regexp_Simplify(benchmark::State& state)          { RunBuild(state, absl::GetFlag(FLAGS_compile_regexp), SimplifyRegexp); }
+void BM_CompileToProg(benchmark::State& state)            { RunBuild(state, absl::GetFlag(FLAGS_compile_regexp), CompileToProg); }
+void BM_CompileByteMap(benchmark::State& state)           { RunBuild(state, absl::GetFlag(FLAGS_compile_regexp), CompileByteMap); }
+void BM_Regexp_Compile(benchmark::State& state)           { RunBuild(state, absl::GetFlag(FLAGS_compile_regexp), CompileRegexp); }
+void BM_Regexp_SimplifyCompile(benchmark::State& state)   { RunBuild(state, absl::GetFlag(FLAGS_compile_regexp), SimplifyCompileRegexp); }
+void BM_Regexp_NullWalk(benchmark::State& state)          { RunBuild(state, absl::GetFlag(FLAGS_compile_regexp), NullWalkRegexp); }
+void BM_RE2_Compile(benchmark::State& state)              { RunBuild(state, absl::GetFlag(FLAGS_compile_regexp), CompileRE2); }
 
 #ifdef USEPCRE
 BENCHMARK(BM_PCRE_Compile)->ThreadRange(1, NumCPUs());
@@ -768,22 +784,19 @@ BENCHMARK(BM_RE2_Compile)->ThreadRange(1, NumCPUs());
 
 // Makes text of size nbytes, then calls run to search
 // the text for regexp iters times.
-void SearchPhone(int iters, int nbytes, ParseImpl* search) {
-  StopBenchmarkTiming();
-  string s;
-  MakeText(&s, nbytes);
+void SearchPhone(benchmark::State& state, ParseImpl* search) {
+  std::string s = RandomText(state.range(0));
   s.append("(650) 253-0001");
-  BenchmarkMemoryUsage();
-  StartBenchmarkTiming();
-  search(iters, "(\\d{3}-|\\(\\d{3}\\)\\s+)(\\d{3}-\\d{4})", s);
-  SetBenchmarkBytesProcessed(static_cast<int64_t>(iters)*nbytes);
+  search(state, "(\\d{3}-|\\(\\d{3}\\)\\s+)(\\d{3}-\\d{4})", s);
+  state.SetBytesProcessed(state.iterations() * state.range(0));
 }
 
-void SearchPhone_CachedPCRE(int i, int n) {
-  SearchPhone(i, n, SearchParse2CachedPCRE);
+void SearchPhone_CachedPCRE(benchmark::State& state) {
+  SearchPhone(state, SearchParse2CachedPCRE);
 }
-void SearchPhone_CachedRE2(int i, int n) {
-  SearchPhone(i, n, SearchParse2CachedRE2);
+
+void SearchPhone_CachedRE2(benchmark::State& state) {
+  SearchPhone(state, SearchParse2CachedRE2);
 }
 
 #ifdef USEPCRE
@@ -793,43 +806,9 @@ BENCHMARK_RANGE(SearchPhone_CachedRE2, 8, 16<<20)->ThreadRange(1, NumCPUs());
 
 /*
 TODO(rsc): Make this work again.
-
-// Generates and returns a string over binary alphabet {0,1} that contains
-// all possible binary sequences of length n as subsequences.  The obvious
-// brute force method would generate a string of length n * 2^n, but this
-// generates a string of length n + 2^n - 1 called a De Bruijn cycle.
-// See Knuth, The Art of Computer Programming, Vol 2, Exercise 3.2.2 #17.
-static string DeBruijnString(int n) {
-  CHECK_LT(n, 8*sizeof(int));
-  CHECK_GT(n, 0);
-
-  std::vector<bool> did(1<<n);
-  for (int i = 0; i < 1<<n; i++)
-    did[i] = false;
-
-  string s;
-  for (int i = 0; i < n-1; i++)
-    s.append("0");
-  int bits = 0;
-  int mask = (1<<n) - 1;
-  for (int i = 0; i < (1<<n); i++) {
-    bits <<= 1;
-    bits &= mask;
-    if (!did[bits|1]) {
-      bits |= 1;
-      s.append("1");
-    } else {
-      s.append("0");
-    }
-    CHECK(!did[bits]);
-    did[bits] = true;
-  }
-  return s;
-}
-
 void CacheFill(int iters, int n, SearchImpl *srch) {
-  string s = DeBruijnString(n+1);
-  string t;
+  std::string s = DeBruijnString(n+1);
+  std::string t;
   for (int i = n+1; i < 20; i++) {
     t = s + s;
     using std::swap;
@@ -878,16 +857,17 @@ DO24(MY_BENCHMARK_WITH_ARG, CacheFillDFA)
 // Expect_match says whether the regexp should be found.
 // Anchored says whether to run an anchored search.
 
-void SearchDFA(int iters, const char* regexp, const StringPiece& text,
-            Prog::Anchor anchor, bool expect_match) {
-  for (int i = 0; i < iters; i++) {
+void SearchDFA(benchmark::State& state, const char* regexp,
+               absl::string_view text, Prog::Anchor anchor,
+               bool expect_match) {
+  for (auto _ : state) {
     Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
     CHECK(re);
     Prog* prog = re->CompileToProg(0);
     CHECK(prog);
     bool failed = false;
-    CHECK_EQ(prog->SearchDFA(text, StringPiece(), anchor, Prog::kFirstMatch,
-                             NULL, &failed, NULL),
+    CHECK_EQ(prog->SearchDFA(text, absl::string_view(), anchor,
+                             Prog::kFirstMatch, NULL, &failed, NULL),
              expect_match);
     CHECK(!failed);
     delete prog;
@@ -895,24 +875,26 @@ void SearchDFA(int iters, const char* regexp, const StringPiece& text,
   }
 }
 
-void SearchNFA(int iters, const char* regexp, const StringPiece& text,
-            Prog::Anchor anchor, bool expect_match) {
-  for (int i = 0; i < iters; i++) {
+void SearchNFA(benchmark::State& state, const char* regexp,
+               absl::string_view text, Prog::Anchor anchor,
+               bool expect_match) {
+  for (auto _ : state) {
     Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
     CHECK(re);
     Prog* prog = re->CompileToProg(0);
     CHECK(prog);
-    CHECK_EQ(prog->SearchNFA(text, StringPiece(), anchor, Prog::kFirstMatch,
-                             NULL, 0),
+    CHECK_EQ(prog->SearchNFA(text, absl::string_view(), anchor,
+                             Prog::kFirstMatch, NULL, 0),
              expect_match);
     delete prog;
     re->Decref();
   }
 }
 
-void SearchOnePass(int iters, const char* regexp, const StringPiece& text,
-            Prog::Anchor anchor, bool expect_match) {
-  for (int i = 0; i < iters; i++) {
+void SearchOnePass(benchmark::State& state, const char* regexp,
+                   absl::string_view text, Prog::Anchor anchor,
+                   bool expect_match) {
+  for (auto _ : state) {
     Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
     CHECK(re);
     Prog* prog = re->CompileToProg(0);
@@ -925,13 +907,15 @@ void SearchOnePass(int iters, const char* regexp, const StringPiece& text,
   }
 }
 
-void SearchBitState(int iters, const char* regexp, const StringPiece& text,
-            Prog::Anchor anchor, bool expect_match) {
-  for (int i = 0; i < iters; i++) {
+void SearchBitState(benchmark::State& state, const char* regexp,
+                    absl::string_view text, Prog::Anchor anchor,
+                    bool expect_match) {
+  for (auto _ : state) {
     Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
     CHECK(re);
     Prog* prog = re->CompileToProg(0);
     CHECK(prog);
+    CHECK(prog->CanBitState());
     CHECK_EQ(prog->SearchBitState(text, text, anchor, Prog::kFirstMatch, NULL, 0),
              expect_match);
     delete prog;
@@ -939,9 +923,10 @@ void SearchBitState(int iters, const char* regexp, const StringPiece& text,
   }
 }
 
-void SearchPCRE(int iters, const char* regexp, const StringPiece& text,
-                Prog::Anchor anchor, bool expect_match) {
-  for (int i = 0; i < iters; i++) {
+void SearchPCRE(benchmark::State& state, const char* regexp,
+                absl::string_view text, Prog::Anchor anchor,
+                bool expect_match) {
+  for (auto _ : state) {
     PCRE re(regexp, PCRE::UTF8);
     CHECK_EQ(re.error(), "");
     if (anchor == Prog::kAnchored)
@@ -951,9 +936,10 @@ void SearchPCRE(int iters, const char* regexp, const StringPiece& text,
   }
 }
 
-void SearchRE2(int iters, const char* regexp, const StringPiece& text,
-               Prog::Anchor anchor, bool expect_match) {
-  for (int i = 0; i < iters; i++) {
+void SearchRE2(benchmark::State& state, const char* regexp,
+               absl::string_view text, Prog::Anchor anchor,
+               bool expect_match) {
+  for (auto _ : state) {
     RE2 re(regexp);
     CHECK_EQ(re.error(), "");
     if (anchor == Prog::kAnchored)
@@ -967,70 +953,101 @@ void SearchRE2(int iters, const char* regexp, const StringPiece& text,
 // regexp parsing and compiling once.  This lets us measure
 // search time without the per-regexp overhead.
 
-void SearchCachedDFA(int iters, const char* regexp, const StringPiece& text,
-                     Prog::Anchor anchor, bool expect_match) {
-  Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
-  CHECK(re);
-  Prog* prog = re->CompileToProg(1LL<<31);
-  CHECK(prog);
-  for (int i = 0; i < iters; i++) {
+Prog* GetCachedProg(const char* regexp) {
+  static auto& mutex = *new absl::Mutex;
+  absl::MutexLock lock(&mutex);
+  static auto& cache = *new absl::flat_hash_map<std::string, Prog*>;
+  Prog* prog = cache[regexp];
+  if (prog == NULL) {
+    Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
+    CHECK(re);
+    prog = re->CompileToProg(int64_t{1}<<31);  // mostly for the DFA
+    CHECK(prog);
+    cache[regexp] = prog;
+    re->Decref();
+    // We must call this here - while we have exclusive access.
+    prog->IsOnePass();
+  }
+  return prog;
+}
+
+PCRE* GetCachedPCRE(const char* regexp) {
+  static auto& mutex = *new absl::Mutex;
+  absl::MutexLock lock(&mutex);
+  static auto& cache = *new absl::flat_hash_map<std::string, PCRE*>;
+  PCRE* re = cache[regexp];
+  if (re == NULL) {
+    re = new PCRE(regexp, PCRE::UTF8);
+    CHECK_EQ(re->error(), "");
+    cache[regexp] = re;
+  }
+  return re;
+}
+
+RE2* GetCachedRE2(const char* regexp) {
+  static auto& mutex = *new absl::Mutex;
+  absl::MutexLock lock(&mutex);
+  static auto& cache = *new absl::flat_hash_map<std::string, RE2*>;
+  RE2* re = cache[regexp];
+  if (re == NULL) {
+    re = new RE2(regexp);
+    CHECK_EQ(re->error(), "");
+    cache[regexp] = re;
+  }
+  return re;
+}
+
+void SearchCachedDFA(benchmark::State& state, const char* regexp,
+                     absl::string_view text, Prog::Anchor anchor,
+                     bool expect_match) {
+  Prog* prog = GetCachedProg(regexp);
+  for (auto _ : state) {
     bool failed = false;
-    CHECK_EQ(prog->SearchDFA(text, StringPiece(), anchor, Prog::kFirstMatch,
-                             NULL, &failed, NULL),
+    CHECK_EQ(prog->SearchDFA(text, absl::string_view(), anchor,
+                             Prog::kFirstMatch, NULL, &failed, NULL),
              expect_match);
     CHECK(!failed);
   }
-  delete prog;
-  re->Decref();
 }
 
-void SearchCachedNFA(int iters, const char* regexp, const StringPiece& text,
-                     Prog::Anchor anchor, bool expect_match) {
-  Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
-  CHECK(re);
-  Prog* prog = re->CompileToProg(0);
-  CHECK(prog);
-  for (int i = 0; i < iters; i++) {
-    CHECK_EQ(prog->SearchNFA(text, StringPiece(), anchor, Prog::kFirstMatch,
-                             NULL, 0),
+void SearchCachedNFA(benchmark::State& state, const char* regexp,
+                     absl::string_view text, Prog::Anchor anchor,
+                     bool expect_match) {
+  Prog* prog = GetCachedProg(regexp);
+  for (auto _ : state) {
+    CHECK_EQ(prog->SearchNFA(text, absl::string_view(), anchor,
+                             Prog::kFirstMatch, NULL, 0),
              expect_match);
   }
-  delete prog;
-  re->Decref();
 }
 
-void SearchCachedOnePass(int iters, const char* regexp, const StringPiece& text,
-                     Prog::Anchor anchor, bool expect_match) {
-  Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
-  CHECK(re);
-  Prog* prog = re->CompileToProg(0);
-  CHECK(prog);
+void SearchCachedOnePass(benchmark::State& state, const char* regexp,
+                         absl::string_view text, Prog::Anchor anchor,
+                         bool expect_match) {
+  Prog* prog = GetCachedProg(regexp);
   CHECK(prog->IsOnePass());
-  for (int i = 0; i < iters; i++)
+  for (auto _ : state) {
     CHECK_EQ(prog->SearchOnePass(text, text, anchor, Prog::kFirstMatch, NULL, 0),
              expect_match);
-  delete prog;
-  re->Decref();
+  }
 }
 
-void SearchCachedBitState(int iters, const char* regexp, const StringPiece& text,
-                     Prog::Anchor anchor, bool expect_match) {
-  Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
-  CHECK(re);
-  Prog* prog = re->CompileToProg(0);
-  CHECK(prog);
-  for (int i = 0; i < iters; i++)
+void SearchCachedBitState(benchmark::State& state, const char* regexp,
+                          absl::string_view text, Prog::Anchor anchor,
+                          bool expect_match) {
+  Prog* prog = GetCachedProg(regexp);
+  CHECK(prog->CanBitState());
+  for (auto _ : state) {
     CHECK_EQ(prog->SearchBitState(text, text, anchor, Prog::kFirstMatch, NULL, 0),
              expect_match);
-  delete prog;
-  re->Decref();
+  }
 }
 
-void SearchCachedPCRE(int iters, const char* regexp, const StringPiece& text,
-                     Prog::Anchor anchor, bool expect_match) {
-  PCRE re(regexp, PCRE::UTF8);
-  CHECK_EQ(re.error(), "");
-  for (int i = 0; i < iters; i++) {
+void SearchCachedPCRE(benchmark::State& state, const char* regexp,
+                      absl::string_view text, Prog::Anchor anchor,
+                      bool expect_match) {
+  PCRE& re = *GetCachedPCRE(regexp);
+  for (auto _ : state) {
     if (anchor == Prog::kAnchored)
       CHECK_EQ(PCRE::FullMatch(text, re), expect_match);
     else
@@ -1038,11 +1055,11 @@ void SearchCachedPCRE(int iters, const char* regexp, const StringPiece& text,
   }
 }
 
-void SearchCachedRE2(int iters, const char* regexp, const StringPiece& text,
-                     Prog::Anchor anchor, bool expect_match) {
-  RE2 re(regexp);
-  CHECK_EQ(re.error(), "");
-  for (int i = 0; i < iters; i++) {
+void SearchCachedRE2(benchmark::State& state, const char* regexp,
+                     absl::string_view text, Prog::Anchor anchor,
+                     bool expect_match) {
+  RE2& re = *GetCachedRE2(regexp);
+  for (auto _ : state) {
     if (anchor == Prog::kAnchored)
       CHECK_EQ(RE2::FullMatch(text, re), expect_match);
     else
@@ -1050,333 +1067,316 @@ void SearchCachedRE2(int iters, const char* regexp, const StringPiece& text,
   }
 }
 
-
 // Runs implementation to full match regexp against text,
 // extracting three submatches.  Expects match always.
 
-void Parse3NFA(int iters, const char* regexp, const StringPiece& text) {
-  for (int i = 0; i < iters; i++) {
+void Parse3NFA(benchmark::State& state, const char* regexp,
+               absl::string_view text) {
+  for (auto _ : state) {
     Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
     CHECK(re);
     Prog* prog = re->CompileToProg(0);
     CHECK(prog);
-    StringPiece sp[4];  // 4 because sp[0] is whole match.
-    CHECK(prog->SearchNFA(text, StringPiece(), Prog::kAnchored,
+    absl::string_view sp[4];  // 4 because sp[0] is whole match.
+    CHECK(prog->SearchNFA(text, absl::string_view(), Prog::kAnchored,
                           Prog::kFullMatch, sp, 4));
     delete prog;
     re->Decref();
   }
 }
 
-void Parse3OnePass(int iters, const char* regexp, const StringPiece& text) {
-  for (int i = 0; i < iters; i++) {
+void Parse3OnePass(benchmark::State& state, const char* regexp,
+                   absl::string_view text) {
+  for (auto _ : state) {
     Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
     CHECK(re);
     Prog* prog = re->CompileToProg(0);
     CHECK(prog);
     CHECK(prog->IsOnePass());
-    StringPiece sp[4];  // 4 because sp[0] is whole match.
+    absl::string_view sp[4];  // 4 because sp[0] is whole match.
     CHECK(prog->SearchOnePass(text, text, Prog::kAnchored, Prog::kFullMatch, sp, 4));
     delete prog;
     re->Decref();
   }
 }
 
-void Parse3BitState(int iters, const char* regexp, const StringPiece& text) {
-  for (int i = 0; i < iters; i++) {
+void Parse3BitState(benchmark::State& state, const char* regexp,
+                    absl::string_view text) {
+  for (auto _ : state) {
     Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
     CHECK(re);
     Prog* prog = re->CompileToProg(0);
     CHECK(prog);
-    StringPiece sp[4];  // 4 because sp[0] is whole match.
+    CHECK(prog->CanBitState());
+    absl::string_view sp[4];  // 4 because sp[0] is whole match.
     CHECK(prog->SearchBitState(text, text, Prog::kAnchored, Prog::kFullMatch, sp, 4));
     delete prog;
     re->Decref();
   }
 }
 
-void Parse3Backtrack(int iters, const char* regexp, const StringPiece& text) {
-  for (int i = 0; i < iters; i++) {
+void Parse3Backtrack(benchmark::State& state, const char* regexp,
+                     absl::string_view text) {
+  for (auto _ : state) {
     Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
     CHECK(re);
     Prog* prog = re->CompileToProg(0);
     CHECK(prog);
-    StringPiece sp[4];  // 4 because sp[0] is whole match.
+    absl::string_view sp[4];  // 4 because sp[0] is whole match.
     CHECK(prog->UnsafeSearchBacktrack(text, text, Prog::kAnchored, Prog::kFullMatch, sp, 4));
     delete prog;
     re->Decref();
   }
 }
 
-void Parse3PCRE(int iters, const char* regexp, const StringPiece& text) {
-  for (int i = 0; i < iters; i++) {
+void Parse3PCRE(benchmark::State& state, const char* regexp,
+                absl::string_view text) {
+  for (auto _ : state) {
     PCRE re(regexp, PCRE::UTF8);
     CHECK_EQ(re.error(), "");
-    StringPiece sp1, sp2, sp3;
+    absl::string_view sp1, sp2, sp3;
     CHECK(PCRE::FullMatch(text, re, &sp1, &sp2, &sp3));
   }
 }
 
-void Parse3RE2(int iters, const char* regexp, const StringPiece& text) {
-  for (int i = 0; i < iters; i++) {
+void Parse3RE2(benchmark::State& state, const char* regexp,
+               absl::string_view text) {
+  for (auto _ : state) {
     RE2 re(regexp);
     CHECK_EQ(re.error(), "");
-    StringPiece sp1, sp2, sp3;
+    absl::string_view sp1, sp2, sp3;
     CHECK(RE2::FullMatch(text, re, &sp1, &sp2, &sp3));
   }
 }
 
-void Parse3CachedNFA(int iters, const char* regexp, const StringPiece& text) {
-  Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
-  CHECK(re);
-  Prog* prog = re->CompileToProg(0);
-  CHECK(prog);
-  StringPiece sp[4];  // 4 because sp[0] is whole match.
-  for (int i = 0; i < iters; i++) {
-    CHECK(prog->SearchNFA(text, StringPiece(), Prog::kAnchored,
+void Parse3CachedNFA(benchmark::State& state, const char* regexp,
+                     absl::string_view text) {
+  Prog* prog = GetCachedProg(regexp);
+  absl::string_view sp[4];  // 4 because sp[0] is whole match.
+  for (auto _ : state) {
+    CHECK(prog->SearchNFA(text, absl::string_view(), Prog::kAnchored,
                           Prog::kFullMatch, sp, 4));
   }
-  delete prog;
-  re->Decref();
 }
 
-void Parse3CachedOnePass(int iters, const char* regexp, const StringPiece& text) {
-  Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
-  CHECK(re);
-  Prog* prog = re->CompileToProg(0);
-  CHECK(prog);
+void Parse3CachedOnePass(benchmark::State& state, const char* regexp,
+                         absl::string_view text) {
+  Prog* prog = GetCachedProg(regexp);
   CHECK(prog->IsOnePass());
-  StringPiece sp[4];  // 4 because sp[0] is whole match.
-  for (int i = 0; i < iters; i++)
+  absl::string_view sp[4];  // 4 because sp[0] is whole match.
+  for (auto _ : state) {
     CHECK(prog->SearchOnePass(text, text, Prog::kAnchored, Prog::kFullMatch, sp, 4));
-  delete prog;
-  re->Decref();
+  }
 }
 
-void Parse3CachedBitState(int iters, const char* regexp, const StringPiece& text) {
-  Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
-  CHECK(re);
-  Prog* prog = re->CompileToProg(0);
-  CHECK(prog);
-  StringPiece sp[4];  // 4 because sp[0] is whole match.
-  for (int i = 0; i < iters; i++)
+void Parse3CachedBitState(benchmark::State& state, const char* regexp,
+                          absl::string_view text) {
+  Prog* prog = GetCachedProg(regexp);
+  CHECK(prog->CanBitState());
+  absl::string_view sp[4];  // 4 because sp[0] is whole match.
+  for (auto _ : state) {
     CHECK(prog->SearchBitState(text, text, Prog::kAnchored, Prog::kFullMatch, sp, 4));
-  delete prog;
-  re->Decref();
+  }
 }
 
-void Parse3CachedBacktrack(int iters, const char* regexp, const StringPiece& text) {
-  Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
-  CHECK(re);
-  Prog* prog = re->CompileToProg(0);
-  CHECK(prog);
-  StringPiece sp[4];  // 4 because sp[0] is whole match.
-  for (int i = 0; i < iters; i++)
+void Parse3CachedBacktrack(benchmark::State& state, const char* regexp,
+                           absl::string_view text) {
+  Prog* prog = GetCachedProg(regexp);
+  absl::string_view sp[4];  // 4 because sp[0] is whole match.
+  for (auto _ : state) {
     CHECK(prog->UnsafeSearchBacktrack(text, text, Prog::kAnchored, Prog::kFullMatch, sp, 4));
-  delete prog;
-  re->Decref();
+  }
 }
 
-void Parse3CachedPCRE(int iters, const char* regexp, const StringPiece& text) {
-  PCRE re(regexp, PCRE::UTF8);
-  CHECK_EQ(re.error(), "");
-  StringPiece sp1, sp2, sp3;
-  for (int i = 0; i < iters; i++) {
+void Parse3CachedPCRE(benchmark::State& state, const char* regexp,
+                      absl::string_view text) {
+  PCRE& re = *GetCachedPCRE(regexp);
+  absl::string_view sp1, sp2, sp3;
+  for (auto _ : state) {
     CHECK(PCRE::FullMatch(text, re, &sp1, &sp2, &sp3));
   }
 }
 
-void Parse3CachedRE2(int iters, const char* regexp, const StringPiece& text) {
-  RE2 re(regexp);
-  CHECK_EQ(re.error(), "");
-  StringPiece sp1, sp2, sp3;
-  for (int i = 0; i < iters; i++) {
+void Parse3CachedRE2(benchmark::State& state, const char* regexp,
+                     absl::string_view text) {
+  RE2& re = *GetCachedRE2(regexp);
+  absl::string_view sp1, sp2, sp3;
+  for (auto _ : state) {
     CHECK(RE2::FullMatch(text, re, &sp1, &sp2, &sp3));
   }
 }
 
-
 // Runs implementation to full match regexp against text,
 // extracting three submatches.  Expects match always.
 
-void Parse1NFA(int iters, const char* regexp, const StringPiece& text) {
-  for (int i = 0; i < iters; i++) {
+void Parse1NFA(benchmark::State& state, const char* regexp,
+               absl::string_view text) {
+  for (auto _ : state) {
     Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
     CHECK(re);
     Prog* prog = re->CompileToProg(0);
     CHECK(prog);
-    StringPiece sp[2];  // 2 because sp[0] is whole match.
-    CHECK(prog->SearchNFA(text, StringPiece(), Prog::kAnchored,
+    absl::string_view sp[2];  // 2 because sp[0] is whole match.
+    CHECK(prog->SearchNFA(text, absl::string_view(), Prog::kAnchored,
                           Prog::kFullMatch, sp, 2));
     delete prog;
     re->Decref();
   }
 }
 
-void Parse1OnePass(int iters, const char* regexp, const StringPiece& text) {
-  for (int i = 0; i < iters; i++) {
+void Parse1OnePass(benchmark::State& state, const char* regexp,
+                   absl::string_view text) {
+  for (auto _ : state) {
     Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
     CHECK(re);
     Prog* prog = re->CompileToProg(0);
     CHECK(prog);
     CHECK(prog->IsOnePass());
-    StringPiece sp[2];  // 2 because sp[0] is whole match.
+    absl::string_view sp[2];  // 2 because sp[0] is whole match.
     CHECK(prog->SearchOnePass(text, text, Prog::kAnchored, Prog::kFullMatch, sp, 2));
     delete prog;
     re->Decref();
   }
 }
 
-void Parse1BitState(int iters, const char* regexp, const StringPiece& text) {
-  for (int i = 0; i < iters; i++) {
+void Parse1BitState(benchmark::State& state, const char* regexp,
+                    absl::string_view text) {
+  for (auto _ : state) {
     Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
     CHECK(re);
     Prog* prog = re->CompileToProg(0);
     CHECK(prog);
-    StringPiece sp[2];  // 2 because sp[0] is whole match.
+    CHECK(prog->CanBitState());
+    absl::string_view sp[2];  // 2 because sp[0] is whole match.
     CHECK(prog->SearchBitState(text, text, Prog::kAnchored, Prog::kFullMatch, sp, 2));
     delete prog;
     re->Decref();
   }
 }
 
-void Parse1PCRE(int iters, const char* regexp, const StringPiece& text) {
-  for (int i = 0; i < iters; i++) {
+void Parse1PCRE(benchmark::State& state, const char* regexp,
+                absl::string_view text) {
+  for (auto _ : state) {
     PCRE re(regexp, PCRE::UTF8);
     CHECK_EQ(re.error(), "");
-    StringPiece sp1;
+    absl::string_view sp1;
     CHECK(PCRE::FullMatch(text, re, &sp1));
   }
 }
 
-void Parse1RE2(int iters, const char* regexp, const StringPiece& text) {
-  for (int i = 0; i < iters; i++) {
+void Parse1RE2(benchmark::State& state, const char* regexp,
+               absl::string_view text) {
+  for (auto _ : state) {
     RE2 re(regexp);
     CHECK_EQ(re.error(), "");
-    StringPiece sp1;
+    absl::string_view sp1;
     CHECK(RE2::FullMatch(text, re, &sp1));
   }
 }
 
-void Parse1CachedNFA(int iters, const char* regexp, const StringPiece& text) {
-  Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
-  CHECK(re);
-  Prog* prog = re->CompileToProg(0);
-  CHECK(prog);
-  StringPiece sp[2];  // 2 because sp[0] is whole match.
-  for (int i = 0; i < iters; i++) {
-    CHECK(prog->SearchNFA(text, StringPiece(), Prog::kAnchored,
+void Parse1CachedNFA(benchmark::State& state, const char* regexp,
+                     absl::string_view text) {
+  Prog* prog = GetCachedProg(regexp);
+  absl::string_view sp[2];  // 2 because sp[0] is whole match.
+  for (auto _ : state) {
+    CHECK(prog->SearchNFA(text, absl::string_view(), Prog::kAnchored,
                           Prog::kFullMatch, sp, 2));
   }
-  delete prog;
-  re->Decref();
 }
 
-void Parse1CachedOnePass(int iters, const char* regexp, const StringPiece& text) {
-  Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
-  CHECK(re);
-  Prog* prog = re->CompileToProg(0);
-  CHECK(prog);
+void Parse1CachedOnePass(benchmark::State& state, const char* regexp,
+                         absl::string_view text) {
+  Prog* prog = GetCachedProg(regexp);
   CHECK(prog->IsOnePass());
-  StringPiece sp[2];  // 2 because sp[0] is whole match.
-  for (int i = 0; i < iters; i++)
+  absl::string_view sp[2];  // 2 because sp[0] is whole match.
+  for (auto _ : state) {
     CHECK(prog->SearchOnePass(text, text, Prog::kAnchored, Prog::kFullMatch, sp, 2));
-  delete prog;
-  re->Decref();
+  }
 }
 
-void Parse1CachedBitState(int iters, const char* regexp, const StringPiece& text) {
-  Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
-  CHECK(re);
-  Prog* prog = re->CompileToProg(0);
-  CHECK(prog);
-  StringPiece sp[2];  // 2 because sp[0] is whole match.
-  for (int i = 0; i < iters; i++)
+void Parse1CachedBitState(benchmark::State& state, const char* regexp,
+                          absl::string_view text) {
+  Prog* prog = GetCachedProg(regexp);
+  CHECK(prog->CanBitState());
+  absl::string_view sp[2];  // 2 because sp[0] is whole match.
+  for (auto _ : state) {
     CHECK(prog->SearchBitState(text, text, Prog::kAnchored, Prog::kFullMatch, sp, 2));
-  delete prog;
-  re->Decref();
+  }
 }
 
-void Parse1CachedBacktrack(int iters, const char* regexp, const StringPiece& text) {
-  Regexp* re = Regexp::Parse(regexp, Regexp::LikePerl, NULL);
-  CHECK(re);
-  Prog* prog = re->CompileToProg(0);
-  CHECK(prog);
-  StringPiece sp[2];  // 2 because sp[0] is whole match.
-  for (int i = 0; i < iters; i++)
+void Parse1CachedBacktrack(benchmark::State& state, const char* regexp,
+                           absl::string_view text) {
+  Prog* prog = GetCachedProg(regexp);
+  absl::string_view sp[2];  // 2 because sp[0] is whole match.
+  for (auto _ : state) {
     CHECK(prog->UnsafeSearchBacktrack(text, text, Prog::kAnchored, Prog::kFullMatch, sp, 2));
-  delete prog;
-  re->Decref();
+  }
 }
 
-void Parse1CachedPCRE(int iters, const char* regexp, const StringPiece& text) {
-  PCRE re(regexp, PCRE::UTF8);
-  CHECK_EQ(re.error(), "");
-  StringPiece sp1;
-  for (int i = 0; i < iters; i++) {
+void Parse1CachedPCRE(benchmark::State& state, const char* regexp,
+                      absl::string_view text) {
+  PCRE& re = *GetCachedPCRE(regexp);
+  absl::string_view sp1;
+  for (auto _ : state) {
     CHECK(PCRE::FullMatch(text, re, &sp1));
   }
 }
 
-void Parse1CachedRE2(int iters, const char* regexp, const StringPiece& text) {
-  RE2 re(regexp);
-  CHECK_EQ(re.error(), "");
-  StringPiece sp1;
-  for (int i = 0; i < iters; i++) {
+void Parse1CachedRE2(benchmark::State& state, const char* regexp,
+                     absl::string_view text) {
+  RE2& re = *GetCachedRE2(regexp);
+  absl::string_view sp1;
+  for (auto _ : state) {
     CHECK(RE2::FullMatch(text, re, &sp1));
   }
 }
 
-void SearchParse2CachedPCRE(int iters, const char* regexp,
-                            const StringPiece& text) {
-  PCRE re(regexp, PCRE::UTF8);
-  CHECK_EQ(re.error(), "");
-  for (int i = 0; i < iters; i++) {
-    StringPiece sp1, sp2;
+void SearchParse2CachedPCRE(benchmark::State& state, const char* regexp,
+                            absl::string_view text) {
+  PCRE& re = *GetCachedPCRE(regexp);
+  for (auto _ : state) {
+    absl::string_view sp1, sp2;
     CHECK(PCRE::PartialMatch(text, re, &sp1, &sp2));
   }
 }
 
-void SearchParse2CachedRE2(int iters, const char* regexp,
-                           const StringPiece& text) {
-  RE2 re(regexp);
-  CHECK_EQ(re.error(), "");
-  for (int i = 0; i < iters; i++) {
-    StringPiece sp1, sp2;
+void SearchParse2CachedRE2(benchmark::State& state, const char* regexp,
+                           absl::string_view text) {
+  RE2& re = *GetCachedRE2(regexp);
+  for (auto _ : state) {
+    absl::string_view sp1, sp2;
     CHECK(RE2::PartialMatch(text, re, &sp1, &sp2));
   }
 }
 
-void SearchParse1CachedPCRE(int iters, const char* regexp,
-                            const StringPiece& text) {
-  PCRE re(regexp, PCRE::UTF8);
-  CHECK_EQ(re.error(), "");
-  for (int i = 0; i < iters; i++) {
-    StringPiece sp1;
+void SearchParse1CachedPCRE(benchmark::State& state, const char* regexp,
+                            absl::string_view text) {
+  PCRE& re = *GetCachedPCRE(regexp);
+  for (auto _ : state) {
+    absl::string_view sp1;
     CHECK(PCRE::PartialMatch(text, re, &sp1));
   }
 }
 
-void SearchParse1CachedRE2(int iters, const char* regexp,
-                           const StringPiece& text) {
-  RE2 re(regexp);
-  CHECK_EQ(re.error(), "");
-  for (int i = 0; i < iters; i++) {
-    StringPiece sp1;
+void SearchParse1CachedRE2(benchmark::State& state, const char* regexp,
+                           absl::string_view text) {
+  RE2& re = *GetCachedRE2(regexp);
+  for (auto _ : state) {
+    absl::string_view sp1;
     CHECK(RE2::PartialMatch(text, re, &sp1));
   }
 }
 
-void EmptyPartialMatchPCRE(int n) {
+void EmptyPartialMatchPCRE(benchmark::State& state) {
   PCRE re("");
-  for (int i = 0; i < n; i++) {
+  for (auto _ : state) {
     PCRE::PartialMatch("", re);
   }
 }
 
-void EmptyPartialMatchRE2(int n) {
+void EmptyPartialMatchRE2(benchmark::State& state) {
   RE2 re("");
-  for (int i = 0; i < n; i++) {
+  for (auto _ : state) {
     RE2::PartialMatch("", re);
   }
 }
@@ -1385,16 +1385,16 @@ BENCHMARK(EmptyPartialMatchPCRE)->ThreadRange(1, NumCPUs());
 #endif
 BENCHMARK(EmptyPartialMatchRE2)->ThreadRange(1, NumCPUs());
 
-void SimplePartialMatchPCRE(int n) {
+void SimplePartialMatchPCRE(benchmark::State& state) {
   PCRE re("abcdefg");
-  for (int i = 0; i < n; i++) {
+  for (auto _ : state) {
     PCRE::PartialMatch("abcdefg", re);
   }
 }
 
-void SimplePartialMatchRE2(int n) {
+void SimplePartialMatchRE2(benchmark::State& state) {
   RE2 re("abcdefg");
-  for (int i = 0; i < n; i++) {
+  for (auto _ : state) {
     RE2::PartialMatch("abcdefg", re);
   }
 }
@@ -1403,22 +1403,22 @@ BENCHMARK(SimplePartialMatchPCRE)->ThreadRange(1, NumCPUs());
 #endif
 BENCHMARK(SimplePartialMatchRE2)->ThreadRange(1, NumCPUs());
 
-static string http_text =
+static std::string http_text =
   "GET /asdfhjasdhfasdlfhasdflkjasdfkljasdhflaskdjhf"
   "alksdjfhasdlkfhasdlkjfhasdljkfhadsjklf HTTP/1.1";
 
-void HTTPPartialMatchPCRE(int n) {
-  StringPiece a;
+void HTTPPartialMatchPCRE(benchmark::State& state) {
+  absl::string_view a;
   PCRE re("(?-s)^(?:GET|POST) +([^ ]+) HTTP");
-  for (int i = 0; i < n; i++) {
+  for (auto _ : state) {
     PCRE::PartialMatch(http_text, re, &a);
   }
 }
 
-void HTTPPartialMatchRE2(int n) {
-  StringPiece a;
+void HTTPPartialMatchRE2(benchmark::State& state) {
+  absl::string_view a;
   RE2 re("(?-s)^(?:GET|POST) +([^ ]+) HTTP");
-  for (int i = 0; i < n; i++) {
+  for (auto _ : state) {
     RE2::PartialMatch(http_text, re, &a);
   }
 }
@@ -1428,21 +1428,21 @@ BENCHMARK(HTTPPartialMatchPCRE)->ThreadRange(1, NumCPUs());
 #endif
 BENCHMARK(HTTPPartialMatchRE2)->ThreadRange(1, NumCPUs());
 
-static string smallhttp_text =
+static std::string smallhttp_text =
   "GET /abc HTTP/1.1";
 
-void SmallHTTPPartialMatchPCRE(int n) {
-  StringPiece a;
+void SmallHTTPPartialMatchPCRE(benchmark::State& state) {
+  absl::string_view a;
   PCRE re("(?-s)^(?:GET|POST) +([^ ]+) HTTP");
-  for (int i = 0; i < n; i++) {
+  for (auto _ : state) {
     PCRE::PartialMatch(smallhttp_text, re, &a);
   }
 }
 
-void SmallHTTPPartialMatchRE2(int n) {
-  StringPiece a;
+void SmallHTTPPartialMatchRE2(benchmark::State& state) {
+  absl::string_view a;
   RE2 re("(?-s)^(?:GET|POST) +([^ ]+) HTTP");
-  for (int i = 0; i < n; i++) {
+  for (auto _ : state) {
     RE2::PartialMatch(smallhttp_text, re, &a);
   }
 }
@@ -1452,18 +1452,18 @@ BENCHMARK(SmallHTTPPartialMatchPCRE)->ThreadRange(1, NumCPUs());
 #endif
 BENCHMARK(SmallHTTPPartialMatchRE2)->ThreadRange(1, NumCPUs());
 
-void DotMatchPCRE(int n) {
-  StringPiece a;
+void DotMatchPCRE(benchmark::State& state) {
+  absl::string_view a;
   PCRE re("(?-s)^(.+)");
-  for (int i = 0; i < n; i++) {
+  for (auto _ : state) {
     PCRE::PartialMatch(http_text, re, &a);
   }
 }
 
-void DotMatchRE2(int n) {
-  StringPiece a;
+void DotMatchRE2(benchmark::State& state) {
+  absl::string_view a;
   RE2 re("(?-s)^(.+)");
-  for (int i = 0; i < n; i++) {
+  for (auto _ : state) {
     RE2::PartialMatch(http_text, re, &a);
   }
 }
@@ -1473,18 +1473,18 @@ BENCHMARK(DotMatchPCRE)->ThreadRange(1, NumCPUs());
 #endif
 BENCHMARK(DotMatchRE2)->ThreadRange(1, NumCPUs());
 
-void ASCIIMatchPCRE(int n) {
-  StringPiece a;
+void ASCIIMatchPCRE(benchmark::State& state) {
+  absl::string_view a;
   PCRE re("(?-s)^([ -~]+)");
-  for (int i = 0; i < n; i++) {
+  for (auto _ : state) {
     PCRE::PartialMatch(http_text, re, &a);
   }
 }
 
-void ASCIIMatchRE2(int n) {
-  StringPiece a;
+void ASCIIMatchRE2(benchmark::State& state) {
+  absl::string_view a;
   RE2 re("(?-s)^([ -~]+)");
-  for (int i = 0; i < n; i++) {
+  for (auto _ : state) {
     RE2::PartialMatch(http_text, re, &a);
   }
 }
@@ -1494,40 +1494,34 @@ BENCHMARK(ASCIIMatchPCRE)->ThreadRange(1, NumCPUs());
 #endif
 BENCHMARK(ASCIIMatchRE2)->ThreadRange(1, NumCPUs());
 
-void FullMatchPCRE(int iter, int n, const char *regexp) {
-  StopBenchmarkTiming();
-  string s;
-  MakeText(&s, n);
+void FullMatchPCRE(benchmark::State& state, const char *regexp) {
+  std::string s = RandomText(state.range(0));
   s += "ABCDEFGHIJ";
-  BenchmarkMemoryUsage();
   PCRE re(regexp);
-  StartBenchmarkTiming();
-  for (int i = 0; i < iter; i++)
+  for (auto _ : state) {
     CHECK(PCRE::FullMatch(s, re));
-  SetBenchmarkBytesProcessed(static_cast<int64_t>(iter)*n);
+  }
+  state.SetBytesProcessed(state.iterations() * state.range(0));
 }
 
-void FullMatchRE2(int iter, int n, const char *regexp) {
-  StopBenchmarkTiming();
-  string s;
-  MakeText(&s, n);
+void FullMatchRE2(benchmark::State& state, const char *regexp) {
+  std::string s = RandomText(state.range(0));
   s += "ABCDEFGHIJ";
-  BenchmarkMemoryUsage();
   RE2 re(regexp, RE2::Latin1);
-  StartBenchmarkTiming();
-  for (int i = 0; i < iter; i++)
+  for (auto _ : state) {
     CHECK(RE2::FullMatch(s, re));
-  SetBenchmarkBytesProcessed(static_cast<int64_t>(iter)*n);
+  }
+  state.SetBytesProcessed(state.iterations() * state.range(0));
 }
 
-void FullMatch_DotStar_CachedPCRE(int i, int n) { FullMatchPCRE(i, n, "(?s).*"); }
-void FullMatch_DotStar_CachedRE2(int i, int n)  { FullMatchRE2(i, n, "(?s).*"); }
+void FullMatch_DotStar_CachedPCRE(benchmark::State& state) { FullMatchPCRE(state, "(?s).*"); }
+void FullMatch_DotStar_CachedRE2(benchmark::State& state)  { FullMatchRE2(state, "(?s).*"); }
 
-void FullMatch_DotStarDollar_CachedPCRE(int i, int n) { FullMatchPCRE(i, n, "(?s).*$"); }
-void FullMatch_DotStarDollar_CachedRE2(int i, int n)  { FullMatchRE2(i, n, "(?s).*$"); }
+void FullMatch_DotStarDollar_CachedPCRE(benchmark::State& state) { FullMatchPCRE(state, "(?s).*$"); }
+void FullMatch_DotStarDollar_CachedRE2(benchmark::State& state)  { FullMatchRE2(state, "(?s).*$"); }
 
-void FullMatch_DotStarCapture_CachedPCRE(int i, int n) { FullMatchPCRE(i, n, "(?s)((.*)()()($))"); }
-void FullMatch_DotStarCapture_CachedRE2(int i, int n)  { FullMatchRE2(i, n, "(?s)((.*)()()($))"); }
+void FullMatch_DotStarCapture_CachedPCRE(benchmark::State& state) { FullMatchPCRE(state, "(?s)((.*)()()($))"); }
+void FullMatch_DotStarCapture_CachedRE2(benchmark::State& state)  { FullMatchRE2(state, "(?s)((.*)()()($))"); }
 
 #ifdef USEPCRE
 BENCHMARK_RANGE(FullMatch_DotStar_CachedPCRE, 8, 2<<20);
@@ -1544,29 +1538,27 @@ BENCHMARK_RANGE(FullMatch_DotStarCapture_CachedPCRE, 8, 2<<20);
 #endif
 BENCHMARK_RANGE(FullMatch_DotStarCapture_CachedRE2,  8, 2<<20);
 
-void PossibleMatchRangeCommon(int iter, const char* regexp) {
-  StopBenchmarkTiming();
+void PossibleMatchRangeCommon(benchmark::State& state, const char* regexp) {
   RE2 re(regexp);
-  StartBenchmarkTiming();
-  string min;
-  string max;
+  std::string min;
+  std::string max;
   const int kMaxLen = 16;
-  for (int i = 0; i < iter; i++) {
+  for (auto _ : state) {
     CHECK(re.PossibleMatchRange(&min, &max, kMaxLen));
   }
 }
 
-void PossibleMatchRange_Trivial(int i) {
-  PossibleMatchRangeCommon(i, ".*");
+void PossibleMatchRange_Trivial(benchmark::State& state) {
+  PossibleMatchRangeCommon(state, ".*");
 }
-void PossibleMatchRange_Complex(int i) {
-  PossibleMatchRangeCommon(i, "^abc[def]?[gh]{1,2}.*");
+void PossibleMatchRange_Complex(benchmark::State& state) {
+  PossibleMatchRangeCommon(state, "^abc[def]?[gh]{1,2}.*");
 }
-void PossibleMatchRange_Prefix(int i) {
-  PossibleMatchRangeCommon(i, "^some_random_prefix.*");
+void PossibleMatchRange_Prefix(benchmark::State& state) {
+  PossibleMatchRangeCommon(state, "^some_random_prefix.*");
 }
-void PossibleMatchRange_NoProg(int i) {
-  PossibleMatchRangeCommon(i, "^some_random_string$");
+void PossibleMatchRange_NoProg(benchmark::State& state) {
+  PossibleMatchRangeCommon(state, "^some_random_string$");
 }
 
 BENCHMARK(PossibleMatchRange_Trivial);
diff --git a/re2/testing/regexp_generator.cc b/re2/testing/regexp_generator.cc
index c0f26fe..b1761ed 100644
--- a/re2/testing/regexp_generator.cc
+++ b/re2/testing/regexp_generator.cc
@@ -29,16 +29,18 @@
 #include <string>
 #include <vector>
 
-#include "util/test.h"
+#include "absl/base/macros.h"
+#include "absl/strings/escaping.h"
+#include "absl/strings/str_format.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
-#include "util/strutil.h"
 #include "util/utf.h"
 #include "re2/testing/regexp_generator.h"
 
 namespace re2 {
 
 // Returns a vector of the egrep regexp operators.
-const std::vector<string>& RegexpGenerator::EgrepOps() {
+const std::vector<std::string>& RegexpGenerator::EgrepOps() {
   static const char *ops[] = {
     "%s%s",
     "%s|%s",
@@ -47,13 +49,13 @@ const std::vector<string>& RegexpGenerator::EgrepOps() {
     "%s?",
     "%s\\C*",
   };
-  static std::vector<string> v(ops, ops + arraysize(ops));
+  static std::vector<std::string> v(ops, ops + ABSL_ARRAYSIZE(ops));
   return v;
 }
 
 RegexpGenerator::RegexpGenerator(int maxatoms, int maxops,
-                                 const std::vector<string>& atoms,
-                                 const std::vector<string>& ops)
+                                 const std::vector<std::string>& atoms,
+                                 const std::vector<std::string>& ops)
     : maxatoms_(maxatoms), maxops_(maxops), atoms_(atoms), ops_(ops) {
   // Degenerate case.
   if (atoms_.empty())
@@ -65,7 +67,7 @@ RegexpGenerator::RegexpGenerator(int maxatoms, int maxops,
 // Generates all possible regular expressions (within the parameters),
 // calling HandleRegexp for each one.
 void RegexpGenerator::Generate() {
-  std::vector<string> postfix;
+  std::vector<std::string> postfix;
   GeneratePostfix(&postfix, 0, 0, 0);
 }
 
@@ -74,13 +76,13 @@ void RegexpGenerator::GenerateRandom(int32_t seed, int n) {
   rng_.seed(seed);
 
   for (int i = 0; i < n; i++) {
-    std::vector<string> postfix;
+    std::vector<std::string> postfix;
     GenerateRandomPostfix(&postfix, 0, 0, 0);
   }
 }
 
 // Counts and returns the number of occurrences of "%s" in s.
-static int CountArgs(const string& s) {
+static int CountArgs(const std::string& s) {
   const char *p = s.c_str();
   int n = 0;
   while ((p = strstr(p, "%s")) != NULL) {
@@ -103,8 +105,8 @@ static int CountArgs(const string& s) {
 //
 // The initial call should be GeneratePostfix([empty vector], 0, 0, 0).
 //
-void RegexpGenerator::GeneratePostfix(std::vector<string>* post, int nstk,
-                                      int ops, int atoms) {
+void RegexpGenerator::GeneratePostfix(std::vector<std::string>* post,
+                                      int nstk, int ops, int atoms) {
   if (nstk == 1)
     RunPostfix(*post);
 
@@ -126,7 +128,7 @@ void RegexpGenerator::GeneratePostfix(std::vector<string>* post, int nstk,
   // Add operators if there are enough arguments.
   if (ops < maxops_) {
     for (size_t i = 0; i < ops_.size(); i++) {
-      const string& fmt = ops_[i];
+      const std::string& fmt = ops_[i];
       int nargs = CountArgs(fmt);
       if (nargs <= nstk) {
         post->push_back(fmt);
@@ -139,8 +141,8 @@ void RegexpGenerator::GeneratePostfix(std::vector<string>* post, int nstk,
 
 // Generates a random postfix command sequence.
 // Stops and returns true once a single sequence has been generated.
-bool RegexpGenerator::GenerateRandomPostfix(std::vector<string>* post, int nstk,
-                                            int ops, int atoms) {
+bool RegexpGenerator::GenerateRandomPostfix(std::vector<std::string>* post,
+                                            int nstk, int ops, int atoms) {
   std::uniform_int_distribution<int> random_stop(0, maxatoms_ - atoms);
   std::uniform_int_distribution<int> random_bit(0, 1);
   std::uniform_int_distribution<int> random_ops_index(
@@ -163,7 +165,7 @@ bool RegexpGenerator::GenerateRandomPostfix(std::vector<string>* post, int nstk,
 
     // Add operators if there are enough arguments.
     if (ops < maxops_ && random_bit(rng_) == 0) {
-      const string& fmt = ops_[random_ops_index(rng_)];
+      const std::string& fmt = ops_[random_ops_index(rng_)];
       int nargs = CountArgs(fmt);
       if (nargs <= nstk) {
         post->push_back(fmt);
@@ -189,8 +191,8 @@ bool RegexpGenerator::GenerateRandomPostfix(std::vector<string>* post, int nstk,
 // Interprets the postfix command sequence to create a regular expression
 // passed to HandleRegexp.  The results of operators like %s|%s are wrapped
 // in (?: ) to avoid needing to maintain a precedence table.
-void RegexpGenerator::RunPostfix(const std::vector<string>& post) {
-  std::stack<string> regexps;
+void RegexpGenerator::RunPostfix(const std::vector<std::string>& post) {
+  std::stack<std::string> regexps;
   for (size_t i = 0; i < post.size(); i++) {
     switch (CountArgs(post[i])) {
       default:
@@ -199,19 +201,21 @@ void RegexpGenerator::RunPostfix(const std::vector<string>& post) {
         regexps.push(post[i]);
         break;
       case 1: {
-        string a = regexps.top();
+        auto fmt = absl::ParsedFormat<'s'>::New(post[i]);
+        CHECK(fmt != nullptr);
+        std::string a = regexps.top();
         regexps.pop();
-        regexps.push("(?:" + StringPrintf(post[i].c_str(), a.c_str()) + ")");
+        regexps.push("(?:" + absl::StrFormat(*fmt, a) + ")");
         break;
       }
       case 2: {
-        string b = regexps.top();
+        auto fmt = absl::ParsedFormat<'s', 's'>::New(post[i]);
+        CHECK(fmt != nullptr);
+        std::string b = regexps.top();
         regexps.pop();
-        string a = regexps.top();
+        std::string a = regexps.top();
         regexps.pop();
-        regexps.push("(?:" +
-                     StringPrintf(post[i].c_str(), a.c_str(), b.c_str()) +
-                     ")");
+        regexps.push("(?:" + absl::StrFormat(*fmt, a, b) + ")");
         break;
       }
     }
@@ -219,13 +223,13 @@ void RegexpGenerator::RunPostfix(const std::vector<string>& post) {
 
   if (regexps.size() != 1) {
     // Internal error - should never happen.
-    printf("Bad regexp program:\n");
+    absl::PrintF("Bad regexp program:\n");
     for (size_t i = 0; i < post.size(); i++) {
-      printf("  %s\n", CEscape(post[i]).c_str());
+      absl::PrintF("  %s\n", absl::CEscape(post[i]));
     }
-    printf("Stack after running program:\n");
+    absl::PrintF("Stack after running program:\n");
     while (!regexps.empty()) {
-      printf("  %s\n", CEscape(regexps.top()).c_str());
+      absl::PrintF("  %s\n", absl::CEscape(regexps.top()));
       regexps.pop();
     }
     LOG(FATAL) << "Bad regexp program.";
@@ -238,14 +242,14 @@ void RegexpGenerator::RunPostfix(const std::vector<string>& post) {
 }
 
 // Split s into an vector of strings, one for each UTF-8 character.
-std::vector<string> Explode(const StringPiece& s) {
-  std::vector<string> v;
+std::vector<std::string> Explode(absl::string_view s) {
+  std::vector<std::string> v;
 
-  for (const char *q = s.begin(); q < s.end(); ) {
+  for (const char *q = s.data(); q < s.data() + s.size(); ) {
     const char* p = q;
     Rune r;
     q += chartorune(&r, q);
-    v.push_back(string(p, q - p));
+    v.push_back(std::string(p, q - p));
   }
 
   return v;
@@ -253,23 +257,23 @@ std::vector<string> Explode(const StringPiece& s) {
 
 // Split string everywhere a substring is found, returning
 // vector of pieces.
-std::vector<string> Split(const StringPiece& sep, const StringPiece& s) {
-  std::vector<string> v;
+std::vector<std::string> Split(absl::string_view sep, absl::string_view s) {
+  std::vector<std::string> v;
 
-  if (sep.size() == 0)
+  if (sep.empty())
     return Explode(s);
 
-  const char *p = s.begin();
-  for (const char *q = s.begin(); q + sep.size() <= s.end(); q++) {
-    if (StringPiece(q, sep.size()) == sep) {
-      v.push_back(string(p, q - p));
+  const char *p = s.data();
+  for (const char *q = s.data(); q + sep.size() <= s.data() + s.size(); q++) {
+    if (absl::string_view(q, sep.size()) == sep) {
+      v.push_back(std::string(p, q - p));
       p = q + sep.size();
       q = p - 1;  // -1 for ++ in loop
       continue;
     }
   }
-  if (p < s.end())
-    v.push_back(string(p, s.end() - p));
+  if (p < s.data() + s.size())
+    v.push_back(std::string(p, s.data() + s.size() - p));
   return v;
 }
 
diff --git a/re2/testing/regexp_generator.h b/re2/testing/regexp_generator.h
index b746399..e1be1a9 100644
--- a/re2/testing/regexp_generator.h
+++ b/re2/testing/regexp_generator.h
@@ -13,8 +13,7 @@
 #include <string>
 #include <vector>
 
-#include "util/util.h"
-#include "re2/stringpiece.h"
+#include "absl/strings/string_view.h"
 
 namespace re2 {
 
@@ -29,8 +28,9 @@ namespace re2 {
 //
 class RegexpGenerator {
  public:
-  RegexpGenerator(int maxatoms, int maxops, const std::vector<string>& atoms,
-                  const std::vector<string>& ops);
+  RegexpGenerator(int maxatoms, int maxops,
+                  const std::vector<std::string>& atoms,
+                  const std::vector<std::string>& ops);
   virtual ~RegexpGenerator() {}
 
   // Generates all the regular expressions, calling HandleRegexp(re) for each.
@@ -40,22 +40,23 @@ class RegexpGenerator {
   void GenerateRandom(int32_t seed, int n);
 
   // Handles a regular expression.  Must be provided by subclass.
-  virtual void HandleRegexp(const string& regexp) = 0;
+  virtual void HandleRegexp(const std::string& regexp) = 0;
 
   // The egrep regexp operators: * + ? | and concatenation.
-  static const std::vector<string>& EgrepOps();
+  static const std::vector<std::string>& EgrepOps();
 
  private:
-  void RunPostfix(const std::vector<string>& post);
-  void GeneratePostfix(std::vector<string>* post, int nstk, int ops, int lits);
-  bool GenerateRandomPostfix(std::vector<string>* post, int nstk, int ops,
-                             int lits);
-
-  int maxatoms_;               // Maximum number of atoms allowed in expr.
-  int maxops_;                 // Maximum number of ops allowed in expr.
-  std::vector<string> atoms_;  // Possible atoms.
-  std::vector<string> ops_;    // Possible ops.
-  std::minstd_rand0 rng_;      // Random number generator.
+  void RunPostfix(const std::vector<std::string>& post);
+  void GeneratePostfix(std::vector<std::string>* post,
+                       int nstk, int ops, int lits);
+  bool GenerateRandomPostfix(std::vector<std::string>* post,
+                             int nstk, int ops, int lits);
+
+  int maxatoms_;                    // Maximum number of atoms allowed in expr.
+  int maxops_;                      // Maximum number of ops allowed in expr.
+  std::vector<std::string> atoms_;  // Possible atoms.
+  std::vector<std::string> ops_;    // Possible ops.
+  std::minstd_rand0 rng_;           // Random number generator.
 
   RegexpGenerator(const RegexpGenerator&) = delete;
   RegexpGenerator& operator=(const RegexpGenerator&) = delete;
@@ -64,11 +65,11 @@ class RegexpGenerator {
 // Helpers for preparing arguments to RegexpGenerator constructor.
 
 // Returns one string for each character in s.
-std::vector<string> Explode(const StringPiece& s);
+std::vector<std::string> Explode(absl::string_view s);
 
 // Splits string everywhere sep is found, returning
 // vector of pieces.
-std::vector<string> Split(const StringPiece& sep, const StringPiece& s);
+std::vector<std::string> Split(absl::string_view sep, absl::string_view s);
 
 }  // namespace re2
 
diff --git a/re2/testing/regexp_test.cc b/re2/testing/regexp_test.cc
index 7830322..ef8f59d 100644
--- a/re2/testing/regexp_test.cc
+++ b/re2/testing/regexp_test.cc
@@ -9,7 +9,7 @@
 #include <string>
 #include <vector>
 
-#include "util/test.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
 #include "re2/regexp.h"
 
@@ -38,7 +38,7 @@ TEST(Regexp, BigConcat) {
   ASSERT_EQ(x->Ref(), 1 + static_cast<int>(v.size())) << x->Ref();
   Regexp* re = Regexp::Concat(v.data(), static_cast<int>(v.size()),
                               Regexp::NoParseFlags);
-  ASSERT_EQ(re->ToString(), string(v.size(), 'x'));
+  ASSERT_EQ(re->ToString(), std::string(v.size(), 'x'));
   re->Decref();
   ASSERT_EQ(x->Ref(), 1) << x->Ref();
   x->Decref();
@@ -51,11 +51,11 @@ TEST(Regexp, NamedCaptures) {
       "(?P<g1>a+)|(e)(?P<g2>w*)+(?P<g1>b+)", Regexp::PerlX, &status);
   EXPECT_TRUE(status.ok());
   EXPECT_EQ(4, x->NumCaptures());
-  const std::map<string, int>* have = x->NamedCaptures();
+  const std::map<std::string, int>* have = x->NamedCaptures();
   EXPECT_TRUE(have != NULL);
   EXPECT_EQ(2, have->size());  // there are only two named groups in
                                // the regexp: 'g1' and 'g2'.
-  std::map<string, int> want;
+  std::map<std::string, int> want;
   want["g1"] = 1;
   want["g2"] = 3;
   EXPECT_EQ(want, *have);
@@ -70,10 +70,10 @@ TEST(Regexp, CaptureNames) {
       "(?P<g1>a+)|(e)(?P<g2>w*)+(?P<g1>b+)", Regexp::PerlX, &status);
   EXPECT_TRUE(status.ok());
   EXPECT_EQ(4, x->NumCaptures());
-  const std::map<int, string>* have = x->CaptureNames();
+  const std::map<int, std::string>* have = x->CaptureNames();
   EXPECT_TRUE(have != NULL);
   EXPECT_EQ(3, have->size());
-  std::map<int, string> want;
+  std::map<int, std::string> want;
   want[1] = "g1";
   want[3] = "g2";
   want[4] = "g1";
diff --git a/re2/testing/required_prefix_test.cc b/re2/testing/required_prefix_test.cc
index 3f18d9b..231fd34 100644
--- a/re2/testing/required_prefix_test.cc
+++ b/re2/testing/required_prefix_test.cc
@@ -4,8 +4,10 @@
 
 #include <string>
 
-#include "util/test.h"
+#include "absl/base/macros.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
+#include "re2/prog.h"
 #include "re2/regexp.h"
 
 namespace re2 {
@@ -19,15 +21,18 @@ struct PrefixTest {
 };
 
 static PrefixTest tests[] = {
-  // If the regexp is missing a ^, there's no required prefix.
-  { "abc", false },
+  // Empty cases.
   { "", false },
   { "(?m)^", false },
+  { "(?-m)^", false },
+
+  // If the regexp has no ^, there's no required prefix.
+  { "abc", false },
 
   // If the regexp immediately goes into
   // something not a literal match, there's no required prefix.
-  { "^(abc)", false },
   { "^a*",  false },
+  { "^(abc)", false },
 
   // Otherwise, it should work.
   { "^abc$", true, "abc", false, "(?-m:$)" },
@@ -40,28 +45,28 @@ static PrefixTest tests[] = {
 };
 
 TEST(RequiredPrefix, SimpleTests) {
-  for (int i = 0; i < arraysize(tests); i++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(tests); i++) {
     const PrefixTest& t = tests[i];
-    for (int j = 0; j < 2; j++) {
+    for (size_t j = 0; j < 2; j++) {
       Regexp::ParseFlags flags = Regexp::LikePerl;
       if (j == 0)
         flags = flags | Regexp::Latin1;
       Regexp* re = Regexp::Parse(t.regexp, flags, NULL);
       ASSERT_TRUE(re != NULL) << " " << t.regexp;
 
-      string p;
+      std::string p;
       bool f;
       Regexp* s;
       ASSERT_EQ(t.return_value, re->RequiredPrefix(&p, &f, &s))
-        << " " << t.regexp << " " << (j==0 ? "latin1" : "utf")
+        << " " << t.regexp << " " << (j == 0 ? "latin1" : "utf8")
         << " " << re->Dump();
       if (t.return_value) {
-        ASSERT_EQ(p, string(t.prefix))
-          << " " << t.regexp << " " << (j==0 ? "latin1" : "utf");
+        ASSERT_EQ(p, std::string(t.prefix))
+          << " " << t.regexp << " " << (j == 0 ? "latin1" : "utf8");
         ASSERT_EQ(f, t.foldcase)
-          << " " << t.regexp << " " << (j==0 ? "latin1" : "utf");
-        ASSERT_EQ(s->ToString(), string(t.suffix))
-          << " " << t.regexp << " " << (j==0 ? "latin1" : "utf");
+          << " " << t.regexp << " " << (j == 0 ? "latin1" : "utf8");
+        ASSERT_EQ(s->ToString(), std::string(t.suffix))
+          << " " << t.regexp << " " << (j == 0 ? "latin1" : "utf8");
         s->Decref();
       }
       re->Decref();
@@ -69,4 +74,127 @@ TEST(RequiredPrefix, SimpleTests) {
   }
 }
 
+static PrefixTest for_accel_tests[] = {
+  // Empty cases.
+  { "", false },
+  { "(?m)^", false },
+  { "(?-m)^", false },
+
+  // If the regexp has a ^, there's no required prefix.
+  { "^abc", false },
+
+  // If the regexp immediately goes into
+  // something not a literal match, there's no required prefix.
+  { "a*",  false },
+
+  // Unlike RequiredPrefix(), RequiredPrefixForAccel() can "see through"
+  // capturing groups, but doesn't try to glue prefix fragments together.
+  { "(a?)def", false },
+  { "(ab?)def", true, "a", false },
+  { "(abc?)def", true, "ab", false },
+  { "(()a)def", false },
+  { "((a)b)def", true, "a", false },
+  { "((ab)c)def", true, "ab", false },
+
+  // Otherwise, it should work.
+  { "abc$", true, "abc", false },
+  { "abc", true, "abc", false },
+  { "(?i)abc", true, "abc", true },
+  { "abcd*", true, "abc", false },
+  { "[Aa][Bb]cd*", true, "ab", true },
+  { "ab[Cc]d*", true, "ab", false },
+  { "abc", true, "abc", false },
+};
+
+TEST(RequiredPrefixForAccel, SimpleTests) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(for_accel_tests); i++) {
+    const PrefixTest& t = for_accel_tests[i];
+    for (size_t j = 0; j < 2; j++) {
+      Regexp::ParseFlags flags = Regexp::LikePerl;
+      if (j == 0)
+        flags = flags | Regexp::Latin1;
+      Regexp* re = Regexp::Parse(t.regexp, flags, NULL);
+      ASSERT_TRUE(re != NULL) << " " << t.regexp;
+
+      std::string p;
+      bool f;
+      ASSERT_EQ(t.return_value, re->RequiredPrefixForAccel(&p, &f))
+        << " " << t.regexp << " " << (j == 0 ? "latin1" : "utf8")
+        << " " << re->Dump();
+      if (t.return_value) {
+        ASSERT_EQ(p, std::string(t.prefix))
+          << " " << t.regexp << " " << (j == 0 ? "latin1" : "utf8");
+        ASSERT_EQ(f, t.foldcase)
+          << " " << t.regexp << " " << (j == 0 ? "latin1" : "utf8");
+      }
+      re->Decref();
+    }
+  }
+}
+
+TEST(RequiredPrefixForAccel, CaseFoldingForKAndS) {
+  Regexp* re;
+  std::string p;
+  bool f;
+
+  // With Latin-1 encoding, `(?i)` prefixes can include 'k' and 's'.
+  re = Regexp::Parse("(?i)KLM", Regexp::LikePerl|Regexp::Latin1, NULL);
+  ASSERT_TRUE(re != NULL);
+  ASSERT_TRUE(re->RequiredPrefixForAccel(&p, &f));
+  ASSERT_EQ(p, "klm");
+  ASSERT_EQ(f, true);
+  re->Decref();
+
+  re = Regexp::Parse("(?i)STU", Regexp::LikePerl|Regexp::Latin1, NULL);
+  ASSERT_TRUE(re != NULL);
+  ASSERT_TRUE(re->RequiredPrefixForAccel(&p, &f));
+  ASSERT_EQ(p, "stu");
+  ASSERT_EQ(f, true);
+  re->Decref();
+
+  // With UTF-8 encoding, `(?i)` prefixes can't include 'k' and 's'.
+  // This is because they match U+212A and U+017F, respectively, and
+  // so the parser ends up emitting character classes, not literals.
+  re = Regexp::Parse("(?i)KLM", Regexp::LikePerl, NULL);
+  ASSERT_TRUE(re != NULL);
+  ASSERT_FALSE(re->RequiredPrefixForAccel(&p, &f));
+  re->Decref();
+
+  re = Regexp::Parse("(?i)STU", Regexp::LikePerl, NULL);
+  ASSERT_TRUE(re != NULL);
+  ASSERT_FALSE(re->RequiredPrefixForAccel(&p, &f));
+  re->Decref();
+}
+
+static const char* prefix_accel_tests[] = {
+    "aababc\\d+",
+    "(?i)AABABC\\d+",
+};
+
+TEST(PrefixAccel, SimpleTests) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(prefix_accel_tests); i++) {
+    const char* pattern = prefix_accel_tests[i];
+    Regexp* re = Regexp::Parse(pattern, Regexp::LikePerl, NULL);
+    ASSERT_TRUE(re != NULL);
+    Prog* prog = re->CompileToProg(0);
+    ASSERT_TRUE(prog != NULL);
+    ASSERT_TRUE(prog->can_prefix_accel());
+    for (int j = 0; j < 100; j++) {
+      std::string text(j, 'a');
+      const char* p = reinterpret_cast<const char*>(
+          prog->PrefixAccel(text.data(), text.size()));
+      EXPECT_TRUE(p == NULL);
+      text.append("aababc");
+      for (int k = 0; k < 100; k++) {
+        text.append(k, 'a');
+        p = reinterpret_cast<const char*>(
+            prog->PrefixAccel(text.data(), text.size()));
+        EXPECT_EQ(j, p - text.data());
+      }
+    }
+    delete prog;
+    re->Decref();
+  }
+}
+
 }  // namespace re2
diff --git a/re2/testing/search_test.cc b/re2/testing/search_test.cc
index 8adef6c..166652a 100644
--- a/re2/testing/search_test.cc
+++ b/re2/testing/search_test.cc
@@ -2,7 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-#include "util/test.h"
+#include "absl/base/macros.h"
+#include "gtest/gtest.h"
 #include "re2/prog.h"
 #include "re2/regexp.h"
 #include "re2/testing/tester.h"
@@ -307,11 +308,14 @@ RegexpTest simple_tests[] = {
 
   // Former bugs.
   { "a\\C*|ba\\C", "baba" },
+  { "\\w*I\\w*", "Inc." },
+  { "(?:|a)*", "aaa" },
+  { "(?:|a)+", "aaa" },
 };
 
 TEST(Regexp, SearchTests) {
   int failures = 0;
-  for (int i = 0; i < arraysize(simple_tests); i++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(simple_tests); i++) {
     const RegexpTest& t = simple_tests[i];
     if (!TestRegexpOnText(t.regexp, t.text))
       failures++;
@@ -319,7 +323,7 @@ TEST(Regexp, SearchTests) {
     if (LOGGING) {
       // Build a dummy ExhaustiveTest call that will trigger just
       // this one test, so that we log the test case.
-      std::vector<string> atom, alpha, ops;
+      std::vector<std::string> atom, alpha, ops;
       atom.push_back(t.regexp);
       alpha.push_back(t.text);
       ExhaustiveTest(1, 0, atom, ops, 1, alpha, "", "");
diff --git a/re2/testing/set_test.cc b/re2/testing/set_test.cc
index 5cdc11f..fdbc0b2 100644
--- a/re2/testing/set_test.cc
+++ b/re2/testing/set_test.cc
@@ -5,8 +5,9 @@
 #include <stddef.h>
 #include <string>
 #include <vector>
+#include <utility>
 
-#include "util/test.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
 #include "re2/re2.h"
 #include "re2/set.h"
@@ -201,18 +202,29 @@ TEST(Set, Prefix) {
   ASSERT_EQ(v[0], 0);
 }
 
-TEST(Set, OutOfMemory) {
-  RE2::Set s(RE2::DefaultOptions, RE2::UNANCHORED);
-
-  string a(10000, 'a');
-  ASSERT_EQ(s.Add(a, NULL), 0);
-  ASSERT_EQ(s.Compile(), true);
-
-  std::vector<int> v;
-  RE2::Set::ErrorInfo ei;
-  ASSERT_EQ(s.Match(a, &v, &ei), false);
-  ASSERT_EQ(v.size(), 0);
-  ASSERT_EQ(ei.kind, RE2::Set::kOutOfMemory);
+TEST(Set, MoveSemantics) {
+  RE2::Set s1(RE2::DefaultOptions, RE2::UNANCHORED);
+  ASSERT_EQ(s1.Add("foo\\d+", NULL), 0);
+  ASSERT_EQ(s1.Compile(), true);
+  ASSERT_EQ(s1.Match("abc foo1 xyz", NULL), true);
+  ASSERT_EQ(s1.Match("abc bar2 xyz", NULL), false);
+
+  // The moved-to object should do what the moved-from object did.
+  RE2::Set s2 = std::move(s1);
+  ASSERT_EQ(s2.Match("abc foo1 xyz", NULL), true);
+  ASSERT_EQ(s2.Match("abc bar2 xyz", NULL), false);
+
+  // The moved-from object should have been reset and be reusable.
+  ASSERT_EQ(s1.Add("bar\\d+", NULL), 0);
+  ASSERT_EQ(s1.Compile(), true);
+  ASSERT_EQ(s1.Match("abc foo1 xyz", NULL), false);
+  ASSERT_EQ(s1.Match("abc bar2 xyz", NULL), true);
+
+  // Verify that "overwriting" works and also doesn't leak memory.
+  // (The latter will need a leak detector such as LeakSanitizer.)
+  s1 = std::move(s2);
+  ASSERT_EQ(s1.Match("abc foo1 xyz", NULL), true);
+  ASSERT_EQ(s1.Match("abc bar2 xyz", NULL), false);
 }
 
 }  // namespace re2
diff --git a/re2/testing/simplify_test.cc b/re2/testing/simplify_test.cc
index ede0f32..d2c136a 100644
--- a/re2/testing/simplify_test.cc
+++ b/re2/testing/simplify_test.cc
@@ -7,7 +7,8 @@
 #include <string.h>
 #include <string>
 
-#include "util/test.h"
+#include "absl/base/macros.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
 #include "re2/regexp.h"
 
@@ -245,7 +246,7 @@ static Test tests[] = {
 };
 
 TEST(TestSimplify, SimpleRegexps) {
-  for (int i = 0; i < arraysize(tests); i++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(tests); i++) {
     RegexpStatus status;
     VLOG(1) << "Testing " << tests[i].regexp;
     Regexp* re = Regexp::Parse(tests[i].regexp,
diff --git a/re2/testing/string_generator.cc b/re2/testing/string_generator.cc
index feef200..1891b14 100644
--- a/re2/testing/string_generator.cc
+++ b/re2/testing/string_generator.cc
@@ -11,14 +11,14 @@
 #include <string>
 #include <vector>
 
-#include "util/test.h"
+#include "gtest/gtest.h"
 #include "util/logging.h"
 #include "re2/testing/string_generator.h"
 
 namespace re2 {
 
 StringGenerator::StringGenerator(int maxlen,
-                                 const std::vector<string>& alphabet)
+                                 const std::vector<std::string>& alphabet)
     : maxlen_(maxlen), alphabet_(alphabet),
       generate_null_(false),
       random_(false), nrandom_(0) {
@@ -81,11 +81,11 @@ bool StringGenerator::RandomDigits() {
 // currently described by digits_.  Calls IncrementDigits
 // after computing the string, so that it knows the answer
 // for subsequent HasNext() calls.
-const StringPiece& StringGenerator::Next() {
+absl::string_view StringGenerator::Next() {
   CHECK(hasnext_);
   if (generate_null_) {
     generate_null_ = false;
-    sp_ = StringPiece();
+    sp_ = absl::string_view();
     return sp_;
   }
   s_.clear();
@@ -111,4 +111,31 @@ void StringGenerator::GenerateNULL() {
   hasnext_ = true;
 }
 
+std::string DeBruijnString(int n) {
+  CHECK_GE(n, 1);
+  CHECK_LE(n, 29);
+  const size_t size = size_t{1} << static_cast<size_t>(n);
+  const size_t mask = size - 1;
+  std::vector<bool> did(size, false);
+  std::string s;
+  s.reserve(static_cast<size_t>(n) + size);
+  for (size_t i = 0; i < static_cast<size_t>(n - 1); i++)
+    s += '0';
+  size_t bits = 0;
+  for (size_t i = 0; i < size; i++) {
+    bits <<= 1;
+    bits &= mask;
+    if (!did[bits | 1]) {
+      bits |= 1;
+      s += '1';
+    } else {
+      s += '0';
+    }
+    CHECK(!did[bits]);
+    did[bits] = true;
+  }
+  CHECK_EQ(s.size(), static_cast<size_t>(n - 1) + size);
+  return s;
+}
+
 }  // namespace re2
diff --git a/re2/testing/string_generator.h b/re2/testing/string_generator.h
index 5a36617..0d6f5fc 100644
--- a/re2/testing/string_generator.h
+++ b/re2/testing/string_generator.h
@@ -14,17 +14,16 @@
 #include <string>
 #include <vector>
 
-#include "util/util.h"
-#include "re2/stringpiece.h"
+#include "absl/strings/string_view.h"
 
 namespace re2 {
 
 class StringGenerator {
  public:
-  StringGenerator(int maxlen, const std::vector<string>& alphabet);
+  StringGenerator(int maxlen, const std::vector<std::string>& alphabet);
   ~StringGenerator() {}
 
-  const StringPiece& Next();
+  absl::string_view Next();
   bool HasNext() { return hasnext_; }
 
   // Resets generator to start sequence over.
@@ -41,15 +40,15 @@ class StringGenerator {
   bool RandomDigits();
 
   // Global state.
-  int maxlen_;                    // Maximum length string to generate.
-  std::vector<string> alphabet_;  // Alphabet, one string per letter.
+  int maxlen_;                         // Maximum length string to generate.
+  std::vector<std::string> alphabet_;  // Alphabet, one string per letter.
 
   // Iteration state.
-  StringPiece sp_;           // Last StringPiece returned by Next().
-  string s_;                 // String data in last StringPiece returned by Next().
+  absl::string_view sp_;     // Last string_view returned by Next().
+  std::string s_;            // String data in last string_view returned by Next().
   bool hasnext_;             // Whether Next() can be called again.
   std::vector<int> digits_;  // Alphabet indices for next string.
-  bool generate_null_;       // Whether to generate a NULL StringPiece next.
+  bool generate_null_;       // Whether to generate a NULL string_view next.
   bool random_;              // Whether generated strings are random.
   int nrandom_;              // Number of random strings left to generate.
   std::minstd_rand0 rng_;    // Random number generator.
@@ -58,6 +57,19 @@ class StringGenerator {
   StringGenerator& operator=(const StringGenerator&) = delete;
 };
 
+// Generates and returns a string over binary alphabet {0,1} that contains
+// all possible binary sequences of length n as subsequences.  The obvious
+// brute force method would generate a string of length n * 2^n, but this
+// generates a string of length n-1 + 2^n called a De Bruijn cycle.
+// See Knuth, The Art of Computer Programming, Vol 2, Exercise 3.2.2 #17.
+//
+// Such a string is useful for testing a DFA.  If you have a DFA
+// where distinct last n bytes implies distinct states, then running on a
+// DeBruijn string causes the DFA to need to create a new state at every
+// position in the input, never reusing any states until it gets to the
+// end of the string.  This is the worst possible case for DFA execution.
+std::string DeBruijnString(int n);
+
 }  // namespace re2
 
 #endif  // RE2_TESTING_STRING_GENERATOR_H_
diff --git a/re2/testing/string_generator_test.cc b/re2/testing/string_generator_test.cc
index 2c040a3..b1273d9 100644
--- a/re2/testing/string_generator_test.cc
+++ b/re2/testing/string_generator_test.cc
@@ -7,7 +7,7 @@
 #include <stdint.h>
 #include <string>
 
-#include "util/test.h"
+#include "gtest/gtest.h"
 #include "util/utf.h"
 #include "re2/testing/string_generator.h"
 #include "re2/testing/regexp_generator.h"
@@ -31,23 +31,23 @@ static int64_t IntegerPower(int i, int e) {
 // If all of these hold, the StringGenerator is behaving.
 // Assumes that the alphabet is sorted, so that the generated
 // strings can just be compared lexicographically.
-static void RunTest(int len, const string& alphabet, bool donull) {
+static void RunTest(int len, const std::string& alphabet, bool donull) {
   StringGenerator g(len, Explode(alphabet));
 
   int n = 0;
   int last_l = -1;
-  string last_s;
+  std::string last_s;
 
   if (donull) {
     g.GenerateNULL();
     EXPECT_TRUE(g.HasNext());
-    StringPiece sp = g.Next();
+    absl::string_view sp = g.Next();
     EXPECT_EQ(sp.data(), static_cast<const char*>(NULL));
     EXPECT_EQ(sp.size(), 0);
   }
 
   while (g.HasNext()) {
-    string s = string(g.Next());
+    std::string s = std::string(g.Next());
     n++;
 
     // Check that all characters in s appear in alphabet.
diff --git a/re2/testing/tester.cc b/re2/testing/tester.cc
index c37aada..a094cb4 100644
--- a/re2/testing/tester.cc
+++ b/re2/testing/tester.cc
@@ -9,23 +9,25 @@
 #include <string.h>
 #include <string>
 
-#include "util/util.h"
-#include "util/flags.h"
+#include "absl/base/macros.h"
+#include "absl/flags/flag.h"
+#include "absl/strings/escaping.h"
+#include "absl/strings/str_format.h"
 #include "util/logging.h"
-#include "util/strutil.h"
 #include "re2/testing/tester.h"
 #include "re2/prog.h"
 #include "re2/re2.h"
 #include "re2/regexp.h"
 
-DEFINE_bool(dump_prog, false, "dump regexp program");
-DEFINE_bool(log_okay, false, "log successful runs");
-DEFINE_bool(dump_rprog, false, "dump reversed regexp program");
+ABSL_FLAG(bool, dump_prog, false, "dump regexp program");
+ABSL_FLAG(bool, log_okay, false, "log successful runs");
+ABSL_FLAG(bool, dump_rprog, false, "dump reversed regexp program");
 
-DEFINE_int32(max_regexp_failures, 100,
-             "maximum number of regexp test failures (-1 = unlimited)");
+ABSL_FLAG(int, max_regexp_failures, 100,
+          "maximum number of regexp test failures (-1 = unlimited)");
 
-DEFINE_string(regexp_engines, "", "pattern to select regexp engines to test");
+ABSL_FLAG(std::string, regexp_engines, "",
+          "pattern to select regexp engines to test");
 
 namespace re2 {
 
@@ -49,7 +51,7 @@ const char* engine_names[kEngineMax] = {
 // Returns the name of the engine.
 static const char* EngineName(Engine e) {
   CHECK_GE(e, 0);
-  CHECK_LT(e, arraysize(engine_names));
+  CHECK_LT(e, ABSL_ARRAYSIZE(engine_names));
   CHECK(engine_names[e] != NULL);
   return engine_names[e];
 }
@@ -62,11 +64,11 @@ static uint32_t Engines() {
   if (did_parse)
     return cached_engines;
 
-  if (FLAGS_regexp_engines.empty()) {
+  if (absl::GetFlag(FLAGS_regexp_engines).empty()) {
     cached_engines = ~0;
   } else {
     for (Engine i = static_cast<Engine>(0); i < kEngineMax; i++)
-      if (FLAGS_regexp_engines.find(EngineName(i)) != string::npos)
+      if (absl::GetFlag(FLAGS_regexp_engines).find(EngineName(i)) != std::string::npos)
         cached_engines |= 1<<i;
   }
 
@@ -85,27 +87,43 @@ static uint32_t Engines() {
 
 // The result of running a match.
 struct TestInstance::Result {
+  Result()
+      : skipped(false),
+        matched(false),
+        untrusted(false),
+        have_submatch(false),
+        have_submatch0(false) {
+    ClearSubmatch();
+  }
+
+  void ClearSubmatch() {
+    for (int i = 0; i < kMaxSubmatch; i++)
+      submatch[i] = absl::string_view();
+  }
+
   bool skipped;         // test skipped: wasn't applicable
   bool matched;         // found a match
   bool untrusted;       // don't really trust the answer
   bool have_submatch;   // computed all submatch info
   bool have_submatch0;  // computed just submatch[0]
-  StringPiece submatch[kMaxSubmatch];
+  absl::string_view submatch[kMaxSubmatch];
 };
 
 typedef TestInstance::Result Result;
 
 // Formats a single capture range s in text in the form (a,b)
 // where a and b are the starting and ending offsets of s in text.
-static string FormatCapture(const StringPiece& text, const StringPiece& s) {
-  if (s.begin() == NULL)
+static std::string FormatCapture(absl::string_view text,
+                                 absl::string_view s) {
+  if (s.data() == NULL)
     return "(?,?)";
-  return StringPrintf("(%td,%td)",
-                      s.begin() - text.begin(), s.end() - text.begin());
+  return absl::StrFormat("(%d,%d)",
+                         BeginPtr(s) - BeginPtr(text),
+                         EndPtr(s) - BeginPtr(text));
 }
 
 // Returns whether text contains non-ASCII (>= 0x80) bytes.
-static bool NonASCII(const StringPiece& text) {
+static bool NonASCII(absl::string_view text) {
   for (size_t i = 0; i < text.size(); i++)
     if ((uint8_t)text[i] >= 0x80)
       return true;
@@ -113,7 +131,7 @@ static bool NonASCII(const StringPiece& text) {
 }
 
 // Returns string representation of match kind.
-static string FormatKind(Prog::MatchKind kind) {
+static std::string FormatKind(Prog::MatchKind kind) {
   switch (kind) {
     case Prog::kFullMatch:
       return "full match";
@@ -128,7 +146,7 @@ static string FormatKind(Prog::MatchKind kind) {
 }
 
 // Returns string representation of anchor kind.
-static string FormatAnchor(Prog::Anchor anchor) {
+static std::string FormatAnchor(Prog::Anchor anchor) {
   switch (anchor) {
     case Prog::kAnchored:
       return "anchored";
@@ -140,7 +158,7 @@ static string FormatAnchor(Prog::Anchor anchor) {
 
 struct ParseMode {
   Regexp::ParseFlags parse_flags;
-  string desc;
+  std::string desc;
 };
 
 static const Regexp::ParseFlags single_line =
@@ -156,16 +174,16 @@ static ParseMode parse_modes[] = {
   { multi_line|Regexp::Latin1,     "multiline, latin1"    },
 };
 
-static string FormatMode(Regexp::ParseFlags flags) {
-  for (int i = 0; i < arraysize(parse_modes); i++)
+static std::string FormatMode(Regexp::ParseFlags flags) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(parse_modes); i++)
     if (parse_modes[i].parse_flags == flags)
       return parse_modes[i].desc;
-  return StringPrintf("%#x", static_cast<uint32_t>(flags));
+  return absl::StrFormat("%#x", static_cast<uint32_t>(flags));
 }
 
 // Constructs and saves all the matching engines that
 // will be required for the given tests.
-TestInstance::TestInstance(const StringPiece& regexp_str, Prog::MatchKind kind,
+TestInstance::TestInstance(absl::string_view regexp_str, Prog::MatchKind kind,
                            Regexp::ParseFlags flags)
   : regexp_str_(regexp_str),
     kind_(kind),
@@ -178,14 +196,14 @@ TestInstance::TestInstance(const StringPiece& regexp_str, Prog::MatchKind kind,
     re_(NULL),
     re2_(NULL) {
 
-  VLOG(1) << CEscape(regexp_str);
+  VLOG(1) << absl::CEscape(regexp_str);
 
   // Compile regexp to prog.
   // Always required - needed for backtracking (reference implementation).
   RegexpStatus status;
   regexp_ = Regexp::Parse(regexp_str, flags, &status);
   if (regexp_ == NULL) {
-    LOG(INFO) << "Cannot parse: " << CEscape(regexp_str_)
+    LOG(INFO) << "Cannot parse: " << absl::CEscape(regexp_str_)
               << " mode: " << FormatMode(flags);
     error_ = true;
     return;
@@ -193,14 +211,14 @@ TestInstance::TestInstance(const StringPiece& regexp_str, Prog::MatchKind kind,
   num_captures_ = regexp_->NumCaptures();
   prog_ = regexp_->CompileToProg(0);
   if (prog_ == NULL) {
-    LOG(INFO) << "Cannot compile: " << CEscape(regexp_str_);
+    LOG(INFO) << "Cannot compile: " << absl::CEscape(regexp_str_);
     error_ = true;
     return;
   }
-  if (FLAGS_dump_prog) {
+  if (absl::GetFlag(FLAGS_dump_prog)) {
     LOG(INFO) << "Prog for "
               << " regexp "
-              << CEscape(regexp_str_)
+              << absl::CEscape(regexp_str_)
               << " (" << FormatKind(kind_)
               << ", " << FormatMode(flags_)
               << ")\n"
@@ -211,16 +229,16 @@ TestInstance::TestInstance(const StringPiece& regexp_str, Prog::MatchKind kind,
   if (Engines() & ((1<<kEngineDFA)|(1<<kEngineDFA1))) {
     rprog_ = regexp_->CompileToReverseProg(0);
     if (rprog_ == NULL) {
-      LOG(INFO) << "Cannot reverse compile: " << CEscape(regexp_str_);
+      LOG(INFO) << "Cannot reverse compile: " << absl::CEscape(regexp_str_);
       error_ = true;
       return;
     }
-    if (FLAGS_dump_rprog)
+    if (absl::GetFlag(FLAGS_dump_rprog))
       LOG(INFO) << rprog_->Dump();
   }
 
   // Create re string that will be used for RE and RE2.
-  string re = string(regexp_str);
+  std::string re = std::string(regexp_str);
   // Accomodate flags.
   // Regexp::Latin1 will be accomodated below.
   if (!(flags & Regexp::OneLine))
@@ -239,7 +257,7 @@ TestInstance::TestInstance(const StringPiece& regexp_str, Prog::MatchKind kind,
       options.set_longest_match(true);
     re2_ = new RE2(re, options);
     if (!re2_->error().empty()) {
-      LOG(INFO) << "Cannot RE2: " << CEscape(re);
+      LOG(INFO) << "Cannot RE2: " << absl::CEscape(re);
       error_ = true;
       return;
     }
@@ -265,7 +283,7 @@ TestInstance::TestInstance(const StringPiece& regexp_str, Prog::MatchKind kind,
     // add one more layer of parens.
     re_ = new PCRE("("+re+")", o);
     if (!re_->error().empty()) {
-      LOG(INFO) << "Cannot PCRE: " << CEscape(re);
+      LOG(INFO) << "Cannot PCRE: " << absl::CEscape(re);
       error_ = true;
       return;
     }
@@ -284,14 +302,9 @@ TestInstance::~TestInstance() {
 // Runs a single search using the named engine type.
 // This interface hides all the irregularities of the various
 // engine interfaces from the rest of this file.
-void TestInstance::RunSearch(Engine type,
-                             const StringPiece& orig_text,
-                             const StringPiece& orig_context,
-                             Prog::Anchor anchor,
-                             Result* result) {
-  // Result is not trivial, so we cannot freely clear it with memset(3),
-  // but zeroing objects like so is safe and expedient for our purposes.
-  memset(reinterpret_cast<void*>(result), 0, sizeof *result);
+void TestInstance::RunSearch(Engine type, absl::string_view orig_text,
+                             absl::string_view orig_context,
+                             Prog::Anchor anchor, Result* result) {
   if (regexp_ == NULL) {
     result->skipped = true;
     return;
@@ -300,8 +313,8 @@ void TestInstance::RunSearch(Engine type,
   if (nsubmatch > kMaxSubmatch)
     nsubmatch = kMaxSubmatch;
 
-  StringPiece text = orig_text;
-  StringPiece context = orig_context;
+  absl::string_view text = orig_text;
+  absl::string_view context = orig_context;
 
   switch (type) {
     default:
@@ -354,8 +367,8 @@ void TestInstance::RunSearch(Engine type,
                                result->submatch,
                                &result->skipped, NULL)) {
           LOG(ERROR) << "Reverse DFA inconsistency: "
-                     << CEscape(regexp_str_)
-                     << " on " << CEscape(text);
+                     << absl::CEscape(regexp_str_)
+                     << " on " << absl::CEscape(text);
           result->matched = false;
         }
       }
@@ -364,8 +377,8 @@ void TestInstance::RunSearch(Engine type,
 
     case kEngineOnePass:
       if (prog_ == NULL ||
-          anchor == Prog::kUnanchored ||
           !prog_->IsOnePass() ||
+          anchor == Prog::kUnanchored ||
           nsubmatch > Prog::kMaxOnePassCapture) {
         result->skipped = true;
         break;
@@ -376,7 +389,8 @@ void TestInstance::RunSearch(Engine type,
       break;
 
     case kEngineBitState:
-      if (prog_ == NULL) {
+      if (prog_ == NULL ||
+          !prog_->CanBitState()) {
         result->skipped = true;
         break;
       }
@@ -388,7 +402,7 @@ void TestInstance::RunSearch(Engine type,
     case kEngineRE2:
     case kEngineRE2a:
     case kEngineRE2b: {
-      if (!re2_ || text.end() != context.end()) {
+      if (!re2_ || EndPtr(text) != EndPtr(context)) {
         result->skipped = true;
         break;
       }
@@ -403,8 +417,8 @@ void TestInstance::RunSearch(Engine type,
 
       result->matched = re2_->Match(
           context,
-          static_cast<size_t>(text.begin() - context.begin()),
-          static_cast<size_t>(text.end() - context.begin()),
+          static_cast<size_t>(BeginPtr(text) - BeginPtr(context)),
+          static_cast<size_t>(EndPtr(text) - BeginPtr(context)),
           re_anchor,
           result->submatch,
           nsubmatch);
@@ -413,8 +427,8 @@ void TestInstance::RunSearch(Engine type,
     }
 
     case kEnginePCRE: {
-      if (!re_ || text.begin() != context.begin() ||
-          text.end() != context.end()) {
+      if (!re_ || BeginPtr(text) != BeginPtr(context) ||
+          EndPtr(text) != EndPtr(context)) {
         result->skipped = true;
         break;
       }
@@ -423,19 +437,19 @@ void TestInstance::RunSearch(Engine type,
       // whitespace, not just vertical tab. Regexp::MimicsPCRE() is
       // unable to handle all cases of this, unfortunately, so just
       // catch them here. :(
-      if (regexp_str_.find("\\v") != StringPiece::npos &&
-          (text.find('\n') != StringPiece::npos ||
-           text.find('\f') != StringPiece::npos ||
-           text.find('\r') != StringPiece::npos)) {
+      if (regexp_str_.find("\\v") != absl::string_view::npos &&
+          (text.find('\n') != absl::string_view::npos ||
+           text.find('\f') != absl::string_view::npos ||
+           text.find('\r') != absl::string_view::npos)) {
         result->skipped = true;
         break;
       }
 
       // PCRE 8.34 or so started allowing vertical tab to match \s,
       // following a change made in Perl 5.18. RE2 does not.
-      if ((regexp_str_.find("\\s") != StringPiece::npos ||
-           regexp_str_.find("\\S") != StringPiece::npos) &&
-          text.find('\v') != StringPiece::npos) {
+      if ((regexp_str_.find("\\s") != absl::string_view::npos ||
+           regexp_str_.find("\\S") != absl::string_view::npos) &&
+          text.find('\v') != absl::string_view::npos) {
         result->skipped = true;
         break;
       }
@@ -474,7 +488,7 @@ void TestInstance::RunSearch(Engine type,
   }
 
   if (!result->matched)
-    memset(result->submatch, 0, sizeof result->submatch);
+    result->ClearSubmatch();
 }
 
 // Checks whether r is okay given that correct is the right answer.
@@ -487,7 +501,7 @@ static bool ResultOkay(const Result& r, const Result& correct) {
     return false;
   if (r.have_submatch || r.have_submatch0) {
     for (int i = 0; i < kMaxSubmatch; i++) {
-      if (correct.submatch[i].begin() != r.submatch[i].begin() ||
+      if (correct.submatch[i].data() != r.submatch[i].data() ||
           correct.submatch[i].size() != r.submatch[i].size())
         return false;
       if (!r.have_submatch)
@@ -498,7 +512,7 @@ static bool ResultOkay(const Result& r, const Result& correct) {
 }
 
 // Runs a single test.
-bool TestInstance::RunCase(const StringPiece& text, const StringPiece& context,
+bool TestInstance::RunCase(absl::string_view text, absl::string_view context,
                            Prog::Anchor anchor) {
   // Backtracking is the gold standard.
   Result correct;
@@ -506,12 +520,12 @@ bool TestInstance::RunCase(const StringPiece& text, const StringPiece& context,
   if (correct.skipped) {
     if (regexp_ == NULL)
       return true;
-    LOG(ERROR) << "Skipped backtracking! " << CEscape(regexp_str_)
+    LOG(ERROR) << "Skipped backtracking! " << absl::CEscape(regexp_str_)
                << " " << FormatMode(flags_);
     return false;
   }
-  VLOG(1) << "Try: regexp " << CEscape(regexp_str_)
-          << " text " << CEscape(text)
+  VLOG(1) << "Try: regexp " << absl::CEscape(regexp_str_)
+          << " text " << absl::CEscape(text)
           << " (" << FormatKind(kind_)
           << ", " << FormatAnchor(anchor)
           << ", " << FormatMode(flags_)
@@ -526,7 +540,7 @@ bool TestInstance::RunCase(const StringPiece& text, const StringPiece& context,
     Result r;
     RunSearch(i, text, context, anchor, &r);
     if (ResultOkay(r, correct)) {
-      if (FLAGS_log_okay)
+      if (absl::GetFlag(FLAGS_log_okay))
         LogMatch(r.skipped ? "Skipped: " : "Okay: ", i, text, context, anchor);
       continue;
     }
@@ -553,23 +567,26 @@ bool TestInstance::RunCase(const StringPiece& text, const StringPiece& context,
       }
     }
     for (int i = 0; i < 1+num_captures_; i++) {
-      if (r.submatch[i].begin() != correct.submatch[i].begin() ||
-          r.submatch[i].end() != correct.submatch[i].end()) {
+      if (r.submatch[i].data() != correct.submatch[i].data() ||
+          r.submatch[i].size() != correct.submatch[i].size()) {
         LOG(INFO) <<
-          StringPrintf("   $%d: should be %s is %s",
-                       i,
-                       FormatCapture(text, correct.submatch[i]).c_str(),
-                       FormatCapture(text, r.submatch[i]).c_str());
+          absl::StrFormat("   $%d: should be %s is %s",
+                          i,
+                          FormatCapture(text, correct.submatch[i]),
+                          FormatCapture(text, r.submatch[i]));
       } else {
         LOG(INFO) <<
-          StringPrintf("   $%d: %s ok", i,
-                       FormatCapture(text, r.submatch[i]).c_str());
+          absl::StrFormat("   $%d: %s ok", i,
+                          FormatCapture(text, r.submatch[i]));
       }
     }
   }
 
   if (!all_okay) {
-    if (FLAGS_max_regexp_failures > 0 && --FLAGS_max_regexp_failures == 0)
+    // This will be initialised once (after flags have been initialised)
+    // and that is desirable because we want to enforce a global limit.
+    static int max_regexp_failures = absl::GetFlag(FLAGS_max_regexp_failures);
+    if (max_regexp_failures > 0 && --max_regexp_failures == 0)
       LOG(QFATAL) << "Too many regexp failures.";
   }
 
@@ -577,22 +594,22 @@ bool TestInstance::RunCase(const StringPiece& text, const StringPiece& context,
 }
 
 void TestInstance::LogMatch(const char* prefix, Engine e,
-                            const StringPiece& text, const StringPiece& context,
+                            absl::string_view text, absl::string_view context,
                             Prog::Anchor anchor) {
   LOG(INFO) << prefix
     << EngineName(e)
     << " regexp "
-    << CEscape(regexp_str_)
+    << absl::CEscape(regexp_str_)
     << " "
-    << CEscape(regexp_->ToString())
+    << absl::CEscape(regexp_->ToString())
     << " text "
-    << CEscape(text)
+    << absl::CEscape(text)
     << " ("
-    << text.begin() - context.begin()
+    << BeginPtr(text) - BeginPtr(context)
     << ","
-    << text.end() - context.begin()
+    << EndPtr(text) - BeginPtr(context)
     << ") of context "
-    << CEscape(context)
+    << absl::CEscape(context)
     << " (" << FormatKind(kind_)
     << ", " << FormatAnchor(anchor)
     << ", " << FormatMode(flags_)
@@ -606,10 +623,10 @@ static Prog::MatchKind kinds[] = {
 };
 
 // Test all possible match kinds and parse modes.
-Tester::Tester(const StringPiece& regexp) {
+Tester::Tester(absl::string_view regexp) {
   error_ = false;
-  for (int i = 0; i < arraysize(kinds); i++) {
-    for (int j = 0; j < arraysize(parse_modes); j++) {
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(kinds); i++) {
+    for (size_t j = 0; j < ABSL_ARRAYSIZE(parse_modes); j++) {
       TestInstance* t = new TestInstance(regexp, kinds[i],
                                          parse_modes[j].parse_flags);
       error_ |= t->error();
@@ -623,8 +640,8 @@ Tester::~Tester() {
     delete v_[i];
 }
 
-bool Tester::TestCase(const StringPiece& text, const StringPiece& context,
-                         Prog::Anchor anchor) {
+bool Tester::TestCase(absl::string_view text, absl::string_view context,
+                      Prog::Anchor anchor) {
   bool okay = true;
   for (size_t i = 0; i < v_.size(); i++)
     okay &= (!v_[i]->error() && v_[i]->RunCase(text, context, anchor));
@@ -636,10 +653,10 @@ static Prog::Anchor anchors[] = {
   Prog::kUnanchored
 };
 
-bool Tester::TestInput(const StringPiece& text) {
+bool Tester::TestInput(absl::string_view text) {
   bool okay = TestInputInContext(text, text);
-  if (text.size() > 0) {
-    StringPiece sp;
+  if (!text.empty()) {
+    absl::string_view sp;
     sp = text;
     sp.remove_prefix(1);
     okay &= TestInputInContext(sp, text);
@@ -650,16 +667,16 @@ bool Tester::TestInput(const StringPiece& text) {
   return okay;
 }
 
-bool Tester::TestInputInContext(const StringPiece& text,
-                                const StringPiece& context) {
+bool Tester::TestInputInContext(absl::string_view text,
+                                absl::string_view context) {
   bool okay = true;
-  for (int i = 0; i < arraysize(anchors); i++)
+  for (size_t i = 0; i < ABSL_ARRAYSIZE(anchors); i++)
     okay &= TestCase(text, context, anchors[i]);
   return okay;
 }
 
-bool TestRegexpOnText(const StringPiece& regexp,
-                      const StringPiece& text) {
+bool TestRegexpOnText(absl::string_view regexp,
+                      absl::string_view text) {
   Tester t(regexp);
   return t.TestInput(text);
 }
diff --git a/re2/testing/tester.h b/re2/testing/tester.h
index 47d0c43..59be5ea 100644
--- a/re2/testing/tester.h
+++ b/re2/testing/tester.h
@@ -10,7 +10,7 @@
 
 #include <vector>
 
-#include "re2/stringpiece.h"
+#include "absl/strings/string_view.h"
 #include "re2/prog.h"
 #include "re2/regexp.h"
 #include "re2/re2.h"
@@ -51,7 +51,7 @@ class TestInstance {
  public:
   struct Result;
 
-  TestInstance(const StringPiece& regexp, Prog::MatchKind kind,
+  TestInstance(absl::string_view regexp, Prog::MatchKind kind,
                Regexp::ParseFlags flags);
   ~TestInstance();
   Regexp::ParseFlags flags() { return flags_; }
@@ -59,20 +59,18 @@ class TestInstance {
 
   // Runs a single test case: search in text, which is in context,
   // using the given anchoring.
-  bool RunCase(const StringPiece& text, const StringPiece& context,
+  bool RunCase(absl::string_view text, absl::string_view context,
                Prog::Anchor anchor);
 
  private:
   // Runs a single search using the named engine type.
-  void RunSearch(Engine type,
-                 const StringPiece& text, const StringPiece& context,
-                 Prog::Anchor anchor,
-                 Result *result);
+  void RunSearch(Engine type, absl::string_view text, absl::string_view context,
+                 Prog::Anchor anchor, Result* result);
 
-  void LogMatch(const char* prefix, Engine e, const StringPiece& text,
-                const StringPiece& context, Prog::Anchor anchor);
+  void LogMatch(const char* prefix, Engine e, absl::string_view text,
+                absl::string_view context, Prog::Anchor anchor);
 
-  const StringPiece regexp_str_;    // regexp being tested
+  absl::string_view regexp_str_;    // regexp being tested
   Prog::MatchKind kind_;            // kind of match
   Regexp::ParseFlags flags_;        // flags for parsing regexp_str_
   bool error_;                      // error during constructor?
@@ -91,21 +89,21 @@ class TestInstance {
 // A group of TestInstances for all possible configurations.
 class Tester {
  public:
-  explicit Tester(const StringPiece& regexp);
+  explicit Tester(absl::string_view regexp);
   ~Tester();
 
   bool error() { return error_; }
 
   // Runs a single test case: search in text, which is in context,
   // using the given anchoring.
-  bool TestCase(const StringPiece& text, const StringPiece& context,
+  bool TestCase(absl::string_view text, absl::string_view context,
                 Prog::Anchor anchor);
 
   // Run TestCase(text, text, anchor) for all anchoring modes.
-  bool TestInput(const StringPiece& text);
+  bool TestInput(absl::string_view text);
 
   // Run TestCase(text, context, anchor) for all anchoring modes.
-  bool TestInputInContext(const StringPiece& text, const StringPiece& context);
+  bool TestInputInContext(absl::string_view text, absl::string_view context);
 
  private:
   bool error_;
@@ -116,7 +114,7 @@ class Tester {
 };
 
 // Run all possible tests using regexp and text.
-bool TestRegexpOnText(const StringPiece& regexp, const StringPiece& text);
+bool TestRegexpOnText(absl::string_view regexp, absl::string_view text);
 
 }  // namespace re2
 
diff --git a/re2/tostring.cc b/re2/tostring.cc
index 278c310..33179fd 100644
--- a/re2/tostring.cc
+++ b/re2/tostring.cc
@@ -8,9 +8,8 @@
 #include <string.h>
 #include <string>
 
-#include "util/util.h"
+#include "absl/strings/str_format.h"
 #include "util/logging.h"
-#include "util/strutil.h"
 #include "util/utf.h"
 #include "re2/regexp.h"
 #include "re2/walker-inl.h"
@@ -28,7 +27,7 @@ enum {
 };
 
 // Helper function.  See description below.
-static void AppendCCRange(string* t, Rune lo, Rune hi);
+static void AppendCCRange(std::string* t, Rune lo, Rune hi);
 
 // Walker to generate string in s_.
 // The arg pointers are actually integers giving the
@@ -36,7 +35,7 @@ static void AppendCCRange(string* t, Rune lo, Rune hi);
 // The child_args are always NULL.
 class ToStringWalker : public Regexp::Walker<int> {
  public:
-  explicit ToStringWalker(string* t) : t_(t) {}
+  explicit ToStringWalker(std::string* t) : t_(t) {}
 
   virtual int PreVisit(Regexp* re, int parent_arg, bool* stop);
   virtual int PostVisit(Regexp* re, int parent_arg, int pre_arg,
@@ -46,14 +45,14 @@ class ToStringWalker : public Regexp::Walker<int> {
   }
 
  private:
-  string* t_;  // The string the walker appends to.
+  std::string* t_;  // The string the walker appends to.
 
   ToStringWalker(const ToStringWalker&) = delete;
   ToStringWalker& operator=(const ToStringWalker&) = delete;
 };
 
-string Regexp::ToString() {
-  string t;
+std::string Regexp::ToString() {
+  std::string t;
   ToStringWalker w(&t);
   w.WalkExponential(this, PrecToplevel, 100000);
   if (w.stopped_early())
@@ -126,7 +125,7 @@ int ToStringWalker::PreVisit(Regexp* re, int parent_arg, bool* stop) {
   return nprec;
 }
 
-static void AppendLiteral(string *t, Rune r, bool foldcase) {
+static void AppendLiteral(std::string *t, Rune r, bool foldcase) {
   if (r != 0 && r < 0x80 && strchr("(){}[]*+?|.^$\\", r)) {
     t->append(1, '\\');
     t->append(1, static_cast<char>(r));
@@ -216,11 +215,11 @@ int ToStringWalker::PostVisit(Regexp* re, int parent_arg, int pre_arg,
 
     case kRegexpRepeat:
       if (re->max() == -1)
-        t_->append(StringPrintf("{%d,}", re->min()));
+        t_->append(absl::StrFormat("{%d,}", re->min()));
       else if (re->min() == re->max())
-        t_->append(StringPrintf("{%d}", re->min()));
+        t_->append(absl::StrFormat("{%d}", re->min()));
       else
-        t_->append(StringPrintf("{%d,%d}", re->min(), re->max()));
+        t_->append(absl::StrFormat("{%d,%d}", re->min(), re->max()));
       if (re->parse_flags() & Regexp::NonGreedy)
         t_->append("?");
       if (prec < PrecUnary)
@@ -269,9 +268,9 @@ int ToStringWalker::PostVisit(Regexp* re, int parent_arg, int pre_arg,
       }
       t_->append("[");
       // Heuristic: show class as negated if it contains the
-      // non-character 0xFFFE.
+      // non-character 0xFFFE and yet somehow isn't full.
       CharClass* cc = re->cc();
-      if (cc->Contains(0xFFFE)) {
+      if (cc->Contains(0xFFFE) && !cc->full()) {
         cc = cc->Negate();
         t_->append("^");
       }
@@ -291,7 +290,7 @@ int ToStringWalker::PostVisit(Regexp* re, int parent_arg, int pre_arg,
       // There's no syntax accepted by the parser to generate
       // this node (it is generated by RE2::Set) so make something
       // up that is readable but won't compile.
-      t_->append("(?HaveMatch:%d)", re->match_id());
+      t_->append(absl::StrFormat("(?HaveMatch:%d)", re->match_id()));
       break;
   }
 
@@ -303,7 +302,7 @@ int ToStringWalker::PostVisit(Regexp* re, int parent_arg, int pre_arg,
 }
 
 // Appends a rune for use in a character class to the string t.
-static void AppendCCChar(string* t, Rune r) {
+static void AppendCCChar(std::string* t, Rune r) {
   if (0x20 <= r && r <= 0x7E) {
     if (strchr("[]^-\\", r))
       t->append("\\");
@@ -332,13 +331,13 @@ static void AppendCCChar(string* t, Rune r) {
   }
 
   if (r < 0x100) {
-    StringAppendF(t, "\\x%02x", static_cast<int>(r));
+    *t += absl::StrFormat("\\x%02x", static_cast<int>(r));
     return;
   }
-  StringAppendF(t, "\\x{%x}", static_cast<int>(r));
+  *t += absl::StrFormat("\\x{%x}", static_cast<int>(r));
 }
 
-static void AppendCCRange(string* t, Rune lo, Rune hi) {
+static void AppendCCRange(std::string* t, Rune lo, Rune hi) {
   if (lo > hi)
     return;
   AppendCCChar(t, lo);
diff --git a/re2/unicode.py b/re2/unicode.py
index deff4d8..1b68cbe 100644
--- a/re2/unicode.py
+++ b/re2/unicode.py
@@ -4,12 +4,16 @@
 
 """Parser for Unicode data files (as distributed by unicode.org)."""
 
+from __future__ import absolute_import
+from __future__ import division
+from __future__ import print_function
+
 import os
 import re
-import urllib2
+import urllib.request
 
 # Directory or URL where Unicode tables reside.
-_UNICODE_DIR = "https://www.unicode.org/Public/11.0.0/ucd"
+_UNICODE_DIR = "https://www.unicode.org/Public/15.0.0/ucd"
 
 # Largest valid Unicode code value.
 _RUNE_MAX = 0x10FFFF
@@ -149,9 +153,9 @@ def ReadUnicodeTable(filename, nfields, doline):
 
   if type(filename) == str:
     if filename.startswith("https://"):
-      fil = urllib2.urlopen(filename)
+      fil = urllib.request.urlopen(filename)
     else:
-      fil = open(filename, "r")
+      fil = open(filename, "rb")
   else:
     fil = filename
 
@@ -161,6 +165,8 @@ def ReadUnicodeTable(filename, nfields, doline):
   for line in fil:
     lineno += 1
     try:
+      line = line.decode('latin1')
+
       # Chop # comments and white space; ignore empty lines.
       sharp = line.find("#")
       if sharp >= 0:
@@ -207,8 +213,8 @@ def ReadUnicodeTable(filename, nfields, doline):
 
       doline(codes, fields)
 
-    except Exception, e:
-      print "%s:%d: %s" % (filename, lineno, e)
+    except Exception as e:
+      print("%s:%d: %s" % (filename, lineno, e))
       raise
 
   if expect_last is not None:
@@ -243,7 +249,7 @@ def CaseGroups(unicode_dir=_UNICODE_DIR):
 
   ReadUnicodeTable(unicode_dir+"/CaseFolding.txt", 4, DoLine)
 
-  groups = togroup.values()
+  groups = list(togroup.values())
   for g in groups:
     g.sort()
   groups.sort()
diff --git a/re2/unicode_casefold.cc b/re2/unicode_casefold.cc
index b4da09d..d9de282 100644
--- a/re2/unicode_casefold.cc
+++ b/re2/unicode_casefold.cc
@@ -7,7 +7,7 @@
 namespace re2 {
 
 
-// 1374 groups, 2778 pairs, 349 ranges
+// 1424 groups, 2878 pairs, 367 ranges
 const CaseFold unicode_casefold[] = {
 	{ 65, 90, 32 },
 	{ 97, 106, -32 },
@@ -122,6 +122,7 @@ const CaseFold unicode_casefold[] = {
 	{ 629, 629, -214 },
 	{ 637, 637, 10727 },
 	{ 640, 640, -218 },
+	{ 642, 642, 42307 },
 	{ 643, 643, -218 },
 	{ 647, 647, 42282 },
 	{ 648, 648, -218 },
@@ -228,6 +229,7 @@ const CaseFold unicode_casefold[] = {
 	{ 7357, 7359, -3008 },
 	{ 7545, 7545, 35332 },
 	{ 7549, 7549, 3814 },
+	{ 7566, 7566, 35384 },
 	{ 7680, 7776, EvenOdd },
 	{ 7777, 7777, 58 },
 	{ 7778, 7829, EvenOdd },
@@ -297,8 +299,8 @@ const CaseFold unicode_casefold[] = {
 	{ 8579, 8580, OddEven },
 	{ 9398, 9423, 26 },
 	{ 9424, 9449, -26 },
-	{ 11264, 11310, 48 },
-	{ 11312, 11358, -48 },
+	{ 11264, 11311, 48 },
+	{ 11312, 11359, -48 },
 	{ 11360, 11361, EvenOdd },
 	{ 11362, 11362, -10743 },
 	{ 11363, 11363, -3814 },
@@ -331,6 +333,7 @@ const CaseFold unicode_casefold[] = {
 	{ 42891, 42892, OddEven },
 	{ 42893, 42893, -42280 },
 	{ 42896, 42899, EvenOdd },
+	{ 42900, 42900, 48 },
 	{ 42902, 42921, EvenOdd },
 	{ 42922, 42922, -42308 },
 	{ 42923, 42923, -42319 },
@@ -341,7 +344,14 @@ const CaseFold unicode_casefold[] = {
 	{ 42929, 42929, -42282 },
 	{ 42930, 42930, -42261 },
 	{ 42931, 42931, 928 },
-	{ 42932, 42937, EvenOdd },
+	{ 42932, 42947, EvenOdd },
+	{ 42948, 42948, -48 },
+	{ 42949, 42949, -42307 },
+	{ 42950, 42950, -35384 },
+	{ 42951, 42954, OddEven },
+	{ 42960, 42961, EvenOdd },
+	{ 42966, 42969, EvenOdd },
+	{ 42997, 42998, OddEven },
 	{ 43859, 43859, -928 },
 	{ 43888, 43967, -38864 },
 	{ 65313, 65338, 32 },
@@ -350,6 +360,14 @@ const CaseFold unicode_casefold[] = {
 	{ 66600, 66639, -40 },
 	{ 66736, 66771, 40 },
 	{ 66776, 66811, -40 },
+	{ 66928, 66938, 39 },
+	{ 66940, 66954, 39 },
+	{ 66956, 66962, 39 },
+	{ 66964, 66965, 39 },
+	{ 66967, 66977, -39 },
+	{ 66979, 66993, -39 },
+	{ 66995, 67001, -39 },
+	{ 67003, 67004, -39 },
 	{ 68736, 68786, 64 },
 	{ 68800, 68850, -64 },
 	{ 71840, 71871, 32 },
@@ -359,9 +377,9 @@ const CaseFold unicode_casefold[] = {
 	{ 125184, 125217, 34 },
 	{ 125218, 125251, -34 },
 };
-const int num_unicode_casefold = 349;
+const int num_unicode_casefold = 367;
 
-// 1374 groups, 1404 pairs, 194 ranges
+// 1424 groups, 1454 pairs, 205 ranges
 const CaseFold unicode_tolower[] = {
 	{ 65, 90, 32 },
 	{ 181, 181, 775 },
@@ -512,7 +530,7 @@ const CaseFold unicode_tolower[] = {
 	{ 8544, 8559, 16 },
 	{ 8579, 8579, OddEven },
 	{ 9398, 9423, 26 },
-	{ 11264, 11310, 48 },
+	{ 11264, 11311, 48 },
 	{ 11360, 11360, EvenOdd },
 	{ 11362, 11362, -10743 },
 	{ 11363, 11363, -3814 },
@@ -548,17 +566,28 @@ const CaseFold unicode_tolower[] = {
 	{ 42929, 42929, -42282 },
 	{ 42930, 42930, -42261 },
 	{ 42931, 42931, 928 },
-	{ 42932, 42936, EvenOddSkip },
+	{ 42932, 42946, EvenOddSkip },
+	{ 42948, 42948, -48 },
+	{ 42949, 42949, -42307 },
+	{ 42950, 42950, -35384 },
+	{ 42951, 42953, OddEvenSkip },
+	{ 42960, 42960, EvenOdd },
+	{ 42966, 42968, EvenOddSkip },
+	{ 42997, 42997, OddEven },
 	{ 43888, 43967, -38864 },
 	{ 65313, 65338, 32 },
 	{ 66560, 66599, 40 },
 	{ 66736, 66771, 40 },
+	{ 66928, 66938, 39 },
+	{ 66940, 66954, 39 },
+	{ 66956, 66962, 39 },
+	{ 66964, 66965, 39 },
 	{ 68736, 68786, 64 },
 	{ 71840, 71871, 32 },
 	{ 93760, 93791, 32 },
 	{ 125184, 125217, 34 },
 };
-const int num_unicode_tolower = 194;
+const int num_unicode_tolower = 205;
 
 
 
diff --git a/re2/unicode_casefold.h b/re2/unicode_casefold.h
index 8bdbb42..4acad68 100644
--- a/re2/unicode_casefold.h
+++ b/re2/unicode_casefold.h
@@ -41,7 +41,6 @@
 
 #include <stdint.h>
 
-#include "util/util.h"
 #include "util/utf.h"
 
 namespace re2 {
diff --git a/re2/unicode_groups.cc b/re2/unicode_groups.cc
index 8052827..3b58be4 100644
--- a/re2/unicode_groups.cc
+++ b/re2/unicode_groups.cc
@@ -7,183 +7,109 @@
 namespace re2 {
 
 
-static const URange16 Ps_range16[] = {
-	{ 40, 40 },
-	{ 91, 91 },
-	{ 123, 123 },
-	{ 3898, 3898 },
-	{ 3900, 3900 },
-	{ 5787, 5787 },
-	{ 8218, 8218 },
-	{ 8222, 8222 },
-	{ 8261, 8261 },
-	{ 8317, 8317 },
-	{ 8333, 8333 },
-	{ 8968, 8968 },
-	{ 8970, 8970 },
-	{ 9001, 9001 },
-	{ 10088, 10088 },
-	{ 10090, 10090 },
-	{ 10092, 10092 },
-	{ 10094, 10094 },
-	{ 10096, 10096 },
-	{ 10098, 10098 },
-	{ 10100, 10100 },
-	{ 10181, 10181 },
-	{ 10214, 10214 },
-	{ 10216, 10216 },
-	{ 10218, 10218 },
-	{ 10220, 10220 },
-	{ 10222, 10222 },
-	{ 10627, 10627 },
-	{ 10629, 10629 },
-	{ 10631, 10631 },
-	{ 10633, 10633 },
-	{ 10635, 10635 },
-	{ 10637, 10637 },
-	{ 10639, 10639 },
-	{ 10641, 10641 },
-	{ 10643, 10643 },
-	{ 10645, 10645 },
-	{ 10647, 10647 },
-	{ 10712, 10712 },
-	{ 10714, 10714 },
-	{ 10748, 10748 },
-	{ 11810, 11810 },
-	{ 11812, 11812 },
-	{ 11814, 11814 },
-	{ 11816, 11816 },
-	{ 11842, 11842 },
-	{ 12296, 12296 },
-	{ 12298, 12298 },
-	{ 12300, 12300 },
-	{ 12302, 12302 },
-	{ 12304, 12304 },
-	{ 12308, 12308 },
-	{ 12310, 12310 },
-	{ 12312, 12312 },
-	{ 12314, 12314 },
-	{ 12317, 12317 },
-	{ 64831, 64831 },
-	{ 65047, 65047 },
-	{ 65077, 65077 },
-	{ 65079, 65079 },
-	{ 65081, 65081 },
-	{ 65083, 65083 },
-	{ 65085, 65085 },
-	{ 65087, 65087 },
-	{ 65089, 65089 },
-	{ 65091, 65091 },
-	{ 65095, 65095 },
-	{ 65113, 65113 },
-	{ 65115, 65115 },
-	{ 65117, 65117 },
-	{ 65288, 65288 },
-	{ 65339, 65339 },
-	{ 65371, 65371 },
-	{ 65375, 65375 },
-	{ 65378, 65378 },
+static const URange16 C_range16[] = {
+	{ 0, 31 },
+	{ 127, 159 },
+	{ 173, 173 },
+	{ 1536, 1541 },
+	{ 1564, 1564 },
+	{ 1757, 1757 },
+	{ 1807, 1807 },
+	{ 2192, 2193 },
+	{ 2274, 2274 },
+	{ 6158, 6158 },
+	{ 8203, 8207 },
+	{ 8234, 8238 },
+	{ 8288, 8292 },
+	{ 8294, 8303 },
+	{ 55296, 63743 },
+	{ 65279, 65279 },
+	{ 65529, 65531 },
 };
-static const URange16 Nl_range16[] = {
-	{ 5870, 5872 },
-	{ 8544, 8578 },
-	{ 8581, 8584 },
-	{ 12295, 12295 },
-	{ 12321, 12329 },
-	{ 12344, 12346 },
-	{ 42726, 42735 },
+static const URange32 C_range32[] = {
+	{ 69821, 69821 },
+	{ 69837, 69837 },
+	{ 78896, 78911 },
+	{ 113824, 113827 },
+	{ 119155, 119162 },
+	{ 917505, 917505 },
+	{ 917536, 917631 },
+	{ 983040, 1048573 },
+	{ 1048576, 1114109 },
 };
-static const URange32 Nl_range32[] = {
-	{ 65856, 65908 },
-	{ 66369, 66369 },
-	{ 66378, 66378 },
-	{ 66513, 66517 },
-	{ 74752, 74862 },
+static const URange16 Cc_range16[] = {
+	{ 0, 31 },
+	{ 127, 159 },
 };
-static const URange16 No_range16[] = {
-	{ 178, 179 },
-	{ 185, 185 },
-	{ 188, 190 },
-	{ 2548, 2553 },
-	{ 2930, 2935 },
-	{ 3056, 3058 },
-	{ 3192, 3198 },
-	{ 3416, 3422 },
-	{ 3440, 3448 },
-	{ 3882, 3891 },
-	{ 4969, 4988 },
-	{ 6128, 6137 },
-	{ 6618, 6618 },
-	{ 8304, 8304 },
-	{ 8308, 8313 },
-	{ 8320, 8329 },
-	{ 8528, 8543 },
-	{ 8585, 8585 },
-	{ 9312, 9371 },
-	{ 9450, 9471 },
-	{ 10102, 10131 },
-	{ 11517, 11517 },
-	{ 12690, 12693 },
-	{ 12832, 12841 },
-	{ 12872, 12879 },
-	{ 12881, 12895 },
-	{ 12928, 12937 },
-	{ 12977, 12991 },
-	{ 43056, 43061 },
+static const URange16 Cf_range16[] = {
+	{ 173, 173 },
+	{ 1536, 1541 },
+	{ 1564, 1564 },
+	{ 1757, 1757 },
+	{ 1807, 1807 },
+	{ 2192, 2193 },
+	{ 2274, 2274 },
+	{ 6158, 6158 },
+	{ 8203, 8207 },
+	{ 8234, 8238 },
+	{ 8288, 8292 },
+	{ 8294, 8303 },
+	{ 65279, 65279 },
+	{ 65529, 65531 },
 };
-static const URange32 No_range32[] = {
-	{ 65799, 65843 },
-	{ 65909, 65912 },
-	{ 65930, 65931 },
-	{ 66273, 66299 },
-	{ 66336, 66339 },
-	{ 67672, 67679 },
-	{ 67705, 67711 },
-	{ 67751, 67759 },
-	{ 67835, 67839 },
-	{ 67862, 67867 },
-	{ 68028, 68029 },
-	{ 68032, 68047 },
-	{ 68050, 68095 },
-	{ 68160, 68168 },
-	{ 68221, 68222 },
-	{ 68253, 68255 },
-	{ 68331, 68335 },
-	{ 68440, 68447 },
-	{ 68472, 68479 },
-	{ 68521, 68527 },
-	{ 68858, 68863 },
-	{ 69216, 69246 },
-	{ 69405, 69414 },
-	{ 69457, 69460 },
-	{ 69714, 69733 },
-	{ 70113, 70132 },
-	{ 71482, 71483 },
-	{ 71914, 71922 },
-	{ 72794, 72812 },
-	{ 93019, 93025 },
-	{ 93824, 93846 },
-	{ 119520, 119539 },
-	{ 119648, 119672 },
-	{ 125127, 125135 },
-	{ 126065, 126123 },
-	{ 126125, 126127 },
-	{ 126129, 126132 },
-	{ 127232, 127244 },
+static const URange32 Cf_range32[] = {
+	{ 69821, 69821 },
+	{ 69837, 69837 },
+	{ 78896, 78911 },
+	{ 113824, 113827 },
+	{ 119155, 119162 },
+	{ 917505, 917505 },
+	{ 917536, 917631 },
 };
-static const URange16 Lo_range16[] = {
+static const URange16 Co_range16[] = {
+	{ 57344, 63743 },
+};
+static const URange32 Co_range32[] = {
+	{ 983040, 1048573 },
+	{ 1048576, 1114109 },
+};
+static const URange16 Cs_range16[] = {
+	{ 55296, 57343 },
+};
+static const URange16 L_range16[] = {
+	{ 65, 90 },
+	{ 97, 122 },
 	{ 170, 170 },
+	{ 181, 181 },
 	{ 186, 186 },
-	{ 443, 443 },
-	{ 448, 451 },
-	{ 660, 660 },
+	{ 192, 214 },
+	{ 216, 246 },
+	{ 248, 705 },
+	{ 710, 721 },
+	{ 736, 740 },
+	{ 748, 748 },
+	{ 750, 750 },
+	{ 880, 884 },
+	{ 886, 887 },
+	{ 890, 893 },
+	{ 895, 895 },
+	{ 902, 902 },
+	{ 904, 906 },
+	{ 908, 908 },
+	{ 910, 929 },
+	{ 931, 1013 },
+	{ 1015, 1153 },
+	{ 1162, 1327 },
+	{ 1329, 1366 },
+	{ 1369, 1369 },
+	{ 1376, 1416 },
 	{ 1488, 1514 },
 	{ 1519, 1522 },
-	{ 1568, 1599 },
-	{ 1601, 1610 },
+	{ 1568, 1610 },
 	{ 1646, 1647 },
 	{ 1649, 1747 },
 	{ 1749, 1749 },
+	{ 1765, 1766 },
 	{ 1774, 1775 },
 	{ 1786, 1788 },
 	{ 1791, 1791 },
@@ -192,16 +118,22 @@ static const URange16 Lo_range16[] = {
 	{ 1869, 1957 },
 	{ 1969, 1969 },
 	{ 1994, 2026 },
+	{ 2036, 2037 },
+	{ 2042, 2042 },
 	{ 2048, 2069 },
-	{ 2112, 2136 },
-	{ 2144, 2154 },
-	{ 2208, 2228 },
-	{ 2230, 2237 },
+	{ 2074, 2074 },
+	{ 2084, 2084 },
+	{ 2088, 2088 },
+	{ 2112, 2136 },
+	{ 2144, 2154 },
+	{ 2160, 2183 },
+	{ 2185, 2190 },
+	{ 2208, 2249 },
 	{ 2308, 2361 },
 	{ 2365, 2365 },
 	{ 2384, 2384 },
 	{ 2392, 2401 },
-	{ 2418, 2432 },
+	{ 2417, 2432 },
 	{ 2437, 2444 },
 	{ 2447, 2448 },
 	{ 2451, 2472 },
@@ -261,6 +193,7 @@ static const URange16 Lo_range16[] = {
 	{ 3114, 3129 },
 	{ 3133, 3133 },
 	{ 3160, 3162 },
+	{ 3165, 3165 },
 	{ 3168, 3169 },
 	{ 3200, 3200 },
 	{ 3205, 3212 },
@@ -269,10 +202,10 @@ static const URange16 Lo_range16[] = {
 	{ 3242, 3251 },
 	{ 3253, 3257 },
 	{ 3261, 3261 },
-	{ 3294, 3294 },
+	{ 3293, 3294 },
 	{ 3296, 3297 },
 	{ 3313, 3314 },
-	{ 3333, 3340 },
+	{ 3332, 3340 },
 	{ 3342, 3344 },
 	{ 3346, 3386 },
 	{ 3389, 3389 },
@@ -287,22 +220,17 @@ static const URange16 Lo_range16[] = {
 	{ 3520, 3526 },
 	{ 3585, 3632 },
 	{ 3634, 3635 },
-	{ 3648, 3653 },
+	{ 3648, 3654 },
 	{ 3713, 3714 },
 	{ 3716, 3716 },
-	{ 3719, 3720 },
-	{ 3722, 3722 },
-	{ 3725, 3725 },
-	{ 3732, 3735 },
-	{ 3737, 3743 },
-	{ 3745, 3747 },
+	{ 3718, 3722 },
+	{ 3724, 3747 },
 	{ 3749, 3749 },
-	{ 3751, 3751 },
-	{ 3754, 3755 },
-	{ 3757, 3760 },
+	{ 3751, 3760 },
 	{ 3762, 3763 },
 	{ 3773, 3773 },
 	{ 3776, 3780 },
+	{ 3782, 3782 },
 	{ 3804, 3807 },
 	{ 3840, 3840 },
 	{ 3904, 3911 },
@@ -317,7 +245,11 @@ static const URange16 Lo_range16[] = {
 	{ 4206, 4208 },
 	{ 4213, 4225 },
 	{ 4238, 4238 },
-	{ 4352, 4680 },
+	{ 4256, 4293 },
+	{ 4295, 4295 },
+	{ 4301, 4301 },
+	{ 4304, 4346 },
+	{ 4348, 4680 },
 	{ 4682, 4685 },
 	{ 4688, 4694 },
 	{ 4696, 4696 },
@@ -334,21 +266,22 @@ static const URange16 Lo_range16[] = {
 	{ 4882, 4885 },
 	{ 4888, 4954 },
 	{ 4992, 5007 },
+	{ 5024, 5109 },
+	{ 5112, 5117 },
 	{ 5121, 5740 },
 	{ 5743, 5759 },
 	{ 5761, 5786 },
 	{ 5792, 5866 },
 	{ 5873, 5880 },
-	{ 5888, 5900 },
-	{ 5902, 5905 },
-	{ 5920, 5937 },
+	{ 5888, 5905 },
+	{ 5919, 5937 },
 	{ 5952, 5969 },
 	{ 5984, 5996 },
 	{ 5998, 6000 },
 	{ 6016, 6067 },
+	{ 6103, 6103 },
 	{ 6108, 6108 },
-	{ 6176, 6210 },
-	{ 6212, 6264 },
+	{ 6176, 6264 },
 	{ 6272, 6276 },
 	{ 6279, 6312 },
 	{ 6314, 6314 },
@@ -360,19 +293,67 @@ static const URange16 Lo_range16[] = {
 	{ 6576, 6601 },
 	{ 6656, 6678 },
 	{ 6688, 6740 },
+	{ 6823, 6823 },
 	{ 6917, 6963 },
-	{ 6981, 6987 },
+	{ 6981, 6988 },
 	{ 7043, 7072 },
 	{ 7086, 7087 },
 	{ 7098, 7141 },
 	{ 7168, 7203 },
 	{ 7245, 7247 },
-	{ 7258, 7287 },
+	{ 7258, 7293 },
+	{ 7296, 7304 },
+	{ 7312, 7354 },
+	{ 7357, 7359 },
 	{ 7401, 7404 },
-	{ 7406, 7409 },
+	{ 7406, 7411 },
 	{ 7413, 7414 },
-	{ 8501, 8504 },
+	{ 7418, 7418 },
+	{ 7424, 7615 },
+	{ 7680, 7957 },
+	{ 7960, 7965 },
+	{ 7968, 8005 },
+	{ 8008, 8013 },
+	{ 8016, 8023 },
+	{ 8025, 8025 },
+	{ 8027, 8027 },
+	{ 8029, 8029 },
+	{ 8031, 8061 },
+	{ 8064, 8116 },
+	{ 8118, 8124 },
+	{ 8126, 8126 },
+	{ 8130, 8132 },
+	{ 8134, 8140 },
+	{ 8144, 8147 },
+	{ 8150, 8155 },
+	{ 8160, 8172 },
+	{ 8178, 8180 },
+	{ 8182, 8188 },
+	{ 8305, 8305 },
+	{ 8319, 8319 },
+	{ 8336, 8348 },
+	{ 8450, 8450 },
+	{ 8455, 8455 },
+	{ 8458, 8467 },
+	{ 8469, 8469 },
+	{ 8473, 8477 },
+	{ 8484, 8484 },
+	{ 8486, 8486 },
+	{ 8488, 8488 },
+	{ 8490, 8493 },
+	{ 8495, 8505 },
+	{ 8508, 8511 },
+	{ 8517, 8521 },
+	{ 8526, 8526 },
+	{ 8579, 8580 },
+	{ 11264, 11492 },
+	{ 11499, 11502 },
+	{ 11506, 11507 },
+	{ 11520, 11557 },
+	{ 11559, 11559 },
+	{ 11565, 11565 },
 	{ 11568, 11623 },
+	{ 11631, 11631 },
 	{ 11648, 11670 },
 	{ 11680, 11686 },
 	{ 11688, 11694 },
@@ -382,29 +363,34 @@ static const URange16 Lo_range16[] = {
 	{ 11720, 11726 },
 	{ 11728, 11734 },
 	{ 11736, 11742 },
-	{ 12294, 12294 },
-	{ 12348, 12348 },
+	{ 11823, 11823 },
+	{ 12293, 12294 },
+	{ 12337, 12341 },
+	{ 12347, 12348 },
 	{ 12353, 12438 },
-	{ 12447, 12447 },
+	{ 12445, 12447 },
 	{ 12449, 12538 },
-	{ 12543, 12543 },
+	{ 12540, 12543 },
 	{ 12549, 12591 },
 	{ 12593, 12686 },
-	{ 12704, 12730 },
+	{ 12704, 12735 },
 	{ 12784, 12799 },
-	{ 13312, 19893 },
-	{ 19968, 40943 },
-	{ 40960, 40980 },
-	{ 40982, 42124 },
-	{ 42192, 42231 },
-	{ 42240, 42507 },
+	{ 13312, 19903 },
+	{ 19968, 42124 },
+	{ 42192, 42237 },
+	{ 42240, 42508 },
 	{ 42512, 42527 },
 	{ 42538, 42539 },
-	{ 42606, 42606 },
+	{ 42560, 42606 },
+	{ 42623, 42653 },
 	{ 42656, 42725 },
-	{ 42895, 42895 },
-	{ 42999, 42999 },
-	{ 43003, 43009 },
+	{ 42775, 42783 },
+	{ 42786, 42888 },
+	{ 42891, 42954 },
+	{ 42960, 42961 },
+	{ 42963, 42963 },
+	{ 42965, 42969 },
+	{ 42994, 43009 },
 	{ 43011, 43013 },
 	{ 43015, 43018 },
 	{ 43020, 43042 },
@@ -417,14 +403,14 @@ static const URange16 Lo_range16[] = {
 	{ 43312, 43334 },
 	{ 43360, 43388 },
 	{ 43396, 43442 },
+	{ 43471, 43471 },
 	{ 43488, 43492 },
-	{ 43495, 43503 },
+	{ 43494, 43503 },
 	{ 43514, 43518 },
 	{ 43520, 43560 },
 	{ 43584, 43586 },
 	{ 43588, 43595 },
-	{ 43616, 43631 },
-	{ 43633, 43638 },
+	{ 43616, 43638 },
 	{ 43642, 43642 },
 	{ 43646, 43695 },
 	{ 43697, 43697 },
@@ -432,20 +418,24 @@ static const URange16 Lo_range16[] = {
 	{ 43705, 43709 },
 	{ 43712, 43712 },
 	{ 43714, 43714 },
-	{ 43739, 43740 },
+	{ 43739, 43741 },
 	{ 43744, 43754 },
-	{ 43762, 43762 },
+	{ 43762, 43764 },
 	{ 43777, 43782 },
 	{ 43785, 43790 },
 	{ 43793, 43798 },
 	{ 43808, 43814 },
 	{ 43816, 43822 },
-	{ 43968, 44002 },
+	{ 43824, 43866 },
+	{ 43868, 43881 },
+	{ 43888, 44002 },
 	{ 44032, 55203 },
 	{ 55216, 55238 },
 	{ 55243, 55291 },
 	{ 63744, 64109 },
 	{ 64112, 64217 },
+	{ 64256, 64262 },
+	{ 64275, 64279 },
 	{ 64285, 64285 },
 	{ 64287, 64296 },
 	{ 64298, 64310 },
@@ -460,15 +450,15 @@ static const URange16 Lo_range16[] = {
 	{ 65008, 65019 },
 	{ 65136, 65140 },
 	{ 65142, 65276 },
-	{ 65382, 65391 },
-	{ 65393, 65437 },
-	{ 65440, 65470 },
+	{ 65313, 65338 },
+	{ 65345, 65370 },
+	{ 65382, 65470 },
 	{ 65474, 65479 },
 	{ 65482, 65487 },
 	{ 65490, 65495 },
 	{ 65498, 65500 },
 };
-static const URange32 Lo_range32[] = {
+static const URange32 L_range32[] = {
 	{ 65536, 65547 },
 	{ 65549, 65574 },
 	{ 65576, 65594 },
@@ -485,12 +475,25 @@ static const URange32 Lo_range32[] = {
 	{ 66432, 66461 },
 	{ 66464, 66499 },
 	{ 66504, 66511 },
-	{ 66640, 66717 },
+	{ 66560, 66717 },
+	{ 66736, 66771 },
+	{ 66776, 66811 },
 	{ 66816, 66855 },
 	{ 66864, 66915 },
+	{ 66928, 66938 },
+	{ 66940, 66954 },
+	{ 66956, 66962 },
+	{ 66964, 66965 },
+	{ 66967, 66977 },
+	{ 66979, 66993 },
+	{ 66995, 67001 },
+	{ 67003, 67004 },
 	{ 67072, 67382 },
 	{ 67392, 67413 },
 	{ 67424, 67431 },
+	{ 67456, 67461 },
+	{ 67463, 67504 },
+	{ 67506, 67514 },
 	{ 67584, 67589 },
 	{ 67592, 67592 },
 	{ 67594, 67637 },
@@ -518,15 +521,25 @@ static const URange32 Lo_range32[] = {
 	{ 68448, 68466 },
 	{ 68480, 68497 },
 	{ 68608, 68680 },
+	{ 68736, 68786 },
+	{ 68800, 68850 },
 	{ 68864, 68899 },
+	{ 69248, 69289 },
+	{ 69296, 69297 },
 	{ 69376, 69404 },
 	{ 69415, 69415 },
 	{ 69424, 69445 },
+	{ 69488, 69505 },
+	{ 69552, 69572 },
+	{ 69600, 69622 },
 	{ 69635, 69687 },
+	{ 69745, 69746 },
+	{ 69749, 69749 },
 	{ 69763, 69807 },
 	{ 69840, 69864 },
 	{ 69891, 69926 },
 	{ 69956, 69956 },
+	{ 69959, 69959 },
 	{ 69968, 70002 },
 	{ 70006, 70006 },
 	{ 70019, 70066 },
@@ -535,6 +548,7 @@ static const URange32 Lo_range32[] = {
 	{ 70108, 70108 },
 	{ 70144, 70161 },
 	{ 70163, 70187 },
+	{ 70207, 70208 },
 	{ 70272, 70278 },
 	{ 70280, 70280 },
 	{ 70282, 70285 },
@@ -552,6 +566,7 @@ static const URange32 Lo_range32[] = {
 	{ 70493, 70497 },
 	{ 70656, 70708 },
 	{ 70727, 70730 },
+	{ 70751, 70753 },
 	{ 70784, 70831 },
 	{ 70852, 70853 },
 	{ 70855, 70855 },
@@ -560,17 +575,29 @@ static const URange32 Lo_range32[] = {
 	{ 71168, 71215 },
 	{ 71236, 71236 },
 	{ 71296, 71338 },
+	{ 71352, 71352 },
 	{ 71424, 71450 },
+	{ 71488, 71494 },
 	{ 71680, 71723 },
-	{ 71935, 71935 },
+	{ 71840, 71903 },
+	{ 71935, 71942 },
+	{ 71945, 71945 },
+	{ 71948, 71955 },
+	{ 71957, 71958 },
+	{ 71960, 71983 },
+	{ 71999, 71999 },
+	{ 72001, 72001 },
+	{ 72096, 72103 },
+	{ 72106, 72144 },
+	{ 72161, 72161 },
+	{ 72163, 72163 },
 	{ 72192, 72192 },
 	{ 72203, 72242 },
 	{ 72250, 72250 },
 	{ 72272, 72272 },
-	{ 72284, 72323 },
-	{ 72326, 72329 },
+	{ 72284, 72329 },
 	{ 72349, 72349 },
-	{ 72384, 72440 },
+	{ 72368, 72440 },
 	{ 72704, 72712 },
 	{ 72714, 72750 },
 	{ 72768, 72768 },
@@ -584,27 +611,92 @@ static const URange32 Lo_range32[] = {
 	{ 73066, 73097 },
 	{ 73112, 73112 },
 	{ 73440, 73458 },
+	{ 73474, 73474 },
+	{ 73476, 73488 },
+	{ 73490, 73523 },
+	{ 73648, 73648 },
 	{ 73728, 74649 },
 	{ 74880, 75075 },
-	{ 77824, 78894 },
+	{ 77712, 77808 },
+	{ 77824, 78895 },
+	{ 78913, 78918 },
 	{ 82944, 83526 },
 	{ 92160, 92728 },
 	{ 92736, 92766 },
+	{ 92784, 92862 },
 	{ 92880, 92909 },
 	{ 92928, 92975 },
+	{ 92992, 92995 },
 	{ 93027, 93047 },
 	{ 93053, 93071 },
-	{ 93952, 94020 },
+	{ 93760, 93823 },
+	{ 93952, 94026 },
 	{ 94032, 94032 },
-	{ 94208, 100337 },
-	{ 100352, 101106 },
-	{ 110592, 110878 },
+	{ 94099, 94111 },
+	{ 94176, 94177 },
+	{ 94179, 94179 },
+	{ 94208, 100343 },
+	{ 100352, 101589 },
+	{ 101632, 101640 },
+	{ 110576, 110579 },
+	{ 110581, 110587 },
+	{ 110589, 110590 },
+	{ 110592, 110882 },
+	{ 110898, 110898 },
+	{ 110928, 110930 },
+	{ 110933, 110933 },
+	{ 110948, 110951 },
 	{ 110960, 111355 },
 	{ 113664, 113770 },
 	{ 113776, 113788 },
 	{ 113792, 113800 },
 	{ 113808, 113817 },
+	{ 119808, 119892 },
+	{ 119894, 119964 },
+	{ 119966, 119967 },
+	{ 119970, 119970 },
+	{ 119973, 119974 },
+	{ 119977, 119980 },
+	{ 119982, 119993 },
+	{ 119995, 119995 },
+	{ 119997, 120003 },
+	{ 120005, 120069 },
+	{ 120071, 120074 },
+	{ 120077, 120084 },
+	{ 120086, 120092 },
+	{ 120094, 120121 },
+	{ 120123, 120126 },
+	{ 120128, 120132 },
+	{ 120134, 120134 },
+	{ 120138, 120144 },
+	{ 120146, 120485 },
+	{ 120488, 120512 },
+	{ 120514, 120538 },
+	{ 120540, 120570 },
+	{ 120572, 120596 },
+	{ 120598, 120628 },
+	{ 120630, 120654 },
+	{ 120656, 120686 },
+	{ 120688, 120712 },
+	{ 120714, 120744 },
+	{ 120746, 120770 },
+	{ 120772, 120779 },
+	{ 122624, 122654 },
+	{ 122661, 122666 },
+	{ 122928, 122989 },
+	{ 123136, 123180 },
+	{ 123191, 123197 },
+	{ 123214, 123214 },
+	{ 123536, 123565 },
+	{ 123584, 123627 },
+	{ 124112, 124139 },
+	{ 124896, 124902 },
+	{ 124904, 124907 },
+	{ 124909, 124910 },
+	{ 124912, 124926 },
 	{ 124928, 125124 },
+	{ 125184, 125251 },
+	{ 125259, 125259 },
 	{ 126464, 126467 },
 	{ 126469, 126495 },
 	{ 126497, 126498 },
@@ -638,12 +730,14 @@ static const URange32 Lo_range32[] = {
 	{ 126625, 126627 },
 	{ 126629, 126633 },
 	{ 126635, 126651 },
-	{ 131072, 173782 },
-	{ 173824, 177972 },
+	{ 131072, 173791 },
+	{ 173824, 177977 },
 	{ 177984, 178205 },
 	{ 178208, 183969 },
 	{ 183984, 191456 },
 	{ 194560, 195101 },
+	{ 196608, 201546 },
+	{ 201552, 205743 },
 };
 static const URange16 Ll_range16[] = {
 	{ 97, 122 },
@@ -1077,7 +1171,7 @@ static const URange16 Ll_range16[] = {
 	{ 8518, 8521 },
 	{ 8526, 8526 },
 	{ 8580, 8580 },
-	{ 11312, 11358 },
+	{ 11312, 11359 },
 	{ 11361, 11361 },
 	{ 11365, 11366 },
 	{ 11368, 11368 },
@@ -1243,9 +1337,22 @@ static const URange16 Ll_range16[] = {
 	{ 42933, 42933 },
 	{ 42935, 42935 },
 	{ 42937, 42937 },
+	{ 42939, 42939 },
+	{ 42941, 42941 },
+	{ 42943, 42943 },
+	{ 42945, 42945 },
+	{ 42947, 42947 },
+	{ 42952, 42952 },
+	{ 42954, 42954 },
+	{ 42961, 42961 },
+	{ 42963, 42963 },
+	{ 42965, 42965 },
+	{ 42967, 42967 },
+	{ 42969, 42969 },
+	{ 42998, 42998 },
 	{ 43002, 43002 },
 	{ 43824, 43866 },
-	{ 43872, 43877 },
+	{ 43872, 43880 },
 	{ 43888, 43967 },
 	{ 64256, 64262 },
 	{ 64275, 64279 },
@@ -1254,6 +1361,10 @@ static const URange16 Ll_range16[] = {
 static const URange32 Ll_range32[] = {
 	{ 66600, 66639 },
 	{ 66776, 66811 },
+	{ 66967, 66977 },
+	{ 66979, 66993 },
+	{ 66995, 67001 },
+	{ 67003, 67004 },
 	{ 68800, 68850 },
 	{ 71872, 71903 },
 	{ 93792, 93823 },
@@ -1285,6 +1396,9 @@ static const URange32 Ll_range32[] = {
 	{ 120746, 120770 },
 	{ 120772, 120777 },
 	{ 120779, 120779 },
+	{ 122624, 122633 },
+	{ 122635, 122654 },
+	{ 122661, 122666 },
 	{ 125218, 125251 },
 };
 static const URange16 Lm_range16[] = {
@@ -1303,6 +1417,7 @@ static const URange16 Lm_range16[] = {
 	{ 2074, 2074 },
 	{ 2084, 2084 },
 	{ 2088, 2088 },
+	{ 2249, 2249 },
 	{ 2417, 2417 },
 	{ 3654, 3654 },
 	{ 3782, 3782 },
@@ -1333,6 +1448,7 @@ static const URange16 Lm_range16[] = {
 	{ 42775, 42783 },
 	{ 42864, 42864 },
 	{ 42888, 42888 },
+	{ 42994, 42996 },
 	{ 43000, 43001 },
 	{ 43471, 43471 },
 	{ 43494, 43494 },
@@ -1340,3900 +1456,4090 @@ static const URange16 Lm_range16[] = {
 	{ 43741, 43741 },
 	{ 43763, 43764 },
 	{ 43868, 43871 },
+	{ 43881, 43881 },
 	{ 65392, 65392 },
 	{ 65438, 65439 },
 };
 static const URange32 Lm_range32[] = {
+	{ 67456, 67461 },
+	{ 67463, 67504 },
+	{ 67506, 67514 },
 	{ 92992, 92995 },
 	{ 94099, 94111 },
 	{ 94176, 94177 },
+	{ 94179, 94179 },
+	{ 110576, 110579 },
+	{ 110581, 110587 },
+	{ 110589, 110590 },
+	{ 122928, 122989 },
+	{ 123191, 123197 },
+	{ 124139, 124139 },
+	{ 125259, 125259 },
 };
-static const URange16 Nd_range16[] = {
-	{ 48, 57 },
-	{ 1632, 1641 },
-	{ 1776, 1785 },
-	{ 1984, 1993 },
-	{ 2406, 2415 },
-	{ 2534, 2543 },
-	{ 2662, 2671 },
-	{ 2790, 2799 },
-	{ 2918, 2927 },
-	{ 3046, 3055 },
-	{ 3174, 3183 },
-	{ 3302, 3311 },
-	{ 3430, 3439 },
-	{ 3558, 3567 },
-	{ 3664, 3673 },
-	{ 3792, 3801 },
-	{ 3872, 3881 },
-	{ 4160, 4169 },
-	{ 4240, 4249 },
-	{ 6112, 6121 },
-	{ 6160, 6169 },
-	{ 6470, 6479 },
-	{ 6608, 6617 },
-	{ 6784, 6793 },
-	{ 6800, 6809 },
-	{ 6992, 7001 },
-	{ 7088, 7097 },
-	{ 7232, 7241 },
-	{ 7248, 7257 },
-	{ 42528, 42537 },
-	{ 43216, 43225 },
-	{ 43264, 43273 },
-	{ 43472, 43481 },
-	{ 43504, 43513 },
-	{ 43600, 43609 },
-	{ 44016, 44025 },
-	{ 65296, 65305 },
-};
-static const URange32 Nd_range32[] = {
-	{ 66720, 66729 },
-	{ 68912, 68921 },
-	{ 69734, 69743 },
-	{ 69872, 69881 },
-	{ 69942, 69951 },
-	{ 70096, 70105 },
-	{ 70384, 70393 },
-	{ 70736, 70745 },
-	{ 70864, 70873 },
-	{ 71248, 71257 },
-	{ 71360, 71369 },
-	{ 71472, 71481 },
-	{ 71904, 71913 },
-	{ 72784, 72793 },
-	{ 73040, 73049 },
-	{ 73120, 73129 },
-	{ 92768, 92777 },
-	{ 93008, 93017 },
-	{ 120782, 120831 },
-	{ 125264, 125273 },
-};
-static const URange16 Pc_range16[] = {
-	{ 95, 95 },
-	{ 8255, 8256 },
-	{ 8276, 8276 },
-	{ 65075, 65076 },
-	{ 65101, 65103 },
-	{ 65343, 65343 },
-};
-static const URange16 Lt_range16[] = {
-	{ 453, 453 },
-	{ 456, 456 },
-	{ 459, 459 },
-	{ 498, 498 },
-	{ 8072, 8079 },
-	{ 8088, 8095 },
-	{ 8104, 8111 },
-	{ 8124, 8124 },
-	{ 8140, 8140 },
-	{ 8188, 8188 },
-};
-static const URange16 Lu_range16[] = {
-	{ 65, 90 },
-	{ 192, 214 },
-	{ 216, 222 },
-	{ 256, 256 },
-	{ 258, 258 },
-	{ 260, 260 },
-	{ 262, 262 },
-	{ 264, 264 },
-	{ 266, 266 },
-	{ 268, 268 },
-	{ 270, 270 },
-	{ 272, 272 },
-	{ 274, 274 },
-	{ 276, 276 },
-	{ 278, 278 },
-	{ 280, 280 },
-	{ 282, 282 },
-	{ 284, 284 },
-	{ 286, 286 },
-	{ 288, 288 },
-	{ 290, 290 },
-	{ 292, 292 },
-	{ 294, 294 },
-	{ 296, 296 },
-	{ 298, 298 },
-	{ 300, 300 },
-	{ 302, 302 },
-	{ 304, 304 },
-	{ 306, 306 },
-	{ 308, 308 },
-	{ 310, 310 },
-	{ 313, 313 },
-	{ 315, 315 },
-	{ 317, 317 },
-	{ 319, 319 },
-	{ 321, 321 },
-	{ 323, 323 },
-	{ 325, 325 },
-	{ 327, 327 },
-	{ 330, 330 },
-	{ 332, 332 },
-	{ 334, 334 },
-	{ 336, 336 },
-	{ 338, 338 },
-	{ 340, 340 },
-	{ 342, 342 },
-	{ 344, 344 },
-	{ 346, 346 },
-	{ 348, 348 },
-	{ 350, 350 },
-	{ 352, 352 },
-	{ 354, 354 },
-	{ 356, 356 },
-	{ 358, 358 },
-	{ 360, 360 },
-	{ 362, 362 },
-	{ 364, 364 },
-	{ 366, 366 },
-	{ 368, 368 },
-	{ 370, 370 },
-	{ 372, 372 },
-	{ 374, 374 },
-	{ 376, 377 },
-	{ 379, 379 },
-	{ 381, 381 },
-	{ 385, 386 },
-	{ 388, 388 },
-	{ 390, 391 },
-	{ 393, 395 },
-	{ 398, 401 },
-	{ 403, 404 },
-	{ 406, 408 },
-	{ 412, 413 },
-	{ 415, 416 },
-	{ 418, 418 },
-	{ 420, 420 },
-	{ 422, 423 },
-	{ 425, 425 },
-	{ 428, 428 },
-	{ 430, 431 },
-	{ 433, 435 },
-	{ 437, 437 },
-	{ 439, 440 },
-	{ 444, 444 },
-	{ 452, 452 },
-	{ 455, 455 },
-	{ 458, 458 },
-	{ 461, 461 },
-	{ 463, 463 },
-	{ 465, 465 },
-	{ 467, 467 },
-	{ 469, 469 },
-	{ 471, 471 },
-	{ 473, 473 },
-	{ 475, 475 },
-	{ 478, 478 },
-	{ 480, 480 },
-	{ 482, 482 },
-	{ 484, 484 },
-	{ 486, 486 },
-	{ 488, 488 },
-	{ 490, 490 },
-	{ 492, 492 },
-	{ 494, 494 },
-	{ 497, 497 },
-	{ 500, 500 },
-	{ 502, 504 },
-	{ 506, 506 },
-	{ 508, 508 },
-	{ 510, 510 },
-	{ 512, 512 },
-	{ 514, 514 },
-	{ 516, 516 },
-	{ 518, 518 },
-	{ 520, 520 },
-	{ 522, 522 },
-	{ 524, 524 },
-	{ 526, 526 },
-	{ 528, 528 },
-	{ 530, 530 },
-	{ 532, 532 },
-	{ 534, 534 },
-	{ 536, 536 },
-	{ 538, 538 },
-	{ 540, 540 },
-	{ 542, 542 },
-	{ 544, 544 },
-	{ 546, 546 },
-	{ 548, 548 },
-	{ 550, 550 },
-	{ 552, 552 },
-	{ 554, 554 },
-	{ 556, 556 },
-	{ 558, 558 },
-	{ 560, 560 },
-	{ 562, 562 },
-	{ 570, 571 },
-	{ 573, 574 },
-	{ 577, 577 },
-	{ 579, 582 },
-	{ 584, 584 },
-	{ 586, 586 },
-	{ 588, 588 },
-	{ 590, 590 },
-	{ 880, 880 },
-	{ 882, 882 },
-	{ 886, 886 },
-	{ 895, 895 },
-	{ 902, 902 },
-	{ 904, 906 },
-	{ 908, 908 },
-	{ 910, 911 },
-	{ 913, 929 },
-	{ 931, 939 },
-	{ 975, 975 },
-	{ 978, 980 },
-	{ 984, 984 },
-	{ 986, 986 },
-	{ 988, 988 },
-	{ 990, 990 },
-	{ 992, 992 },
-	{ 994, 994 },
-	{ 996, 996 },
-	{ 998, 998 },
-	{ 1000, 1000 },
-	{ 1002, 1002 },
-	{ 1004, 1004 },
-	{ 1006, 1006 },
-	{ 1012, 1012 },
-	{ 1015, 1015 },
-	{ 1017, 1018 },
-	{ 1021, 1071 },
-	{ 1120, 1120 },
-	{ 1122, 1122 },
-	{ 1124, 1124 },
-	{ 1126, 1126 },
-	{ 1128, 1128 },
-	{ 1130, 1130 },
-	{ 1132, 1132 },
-	{ 1134, 1134 },
-	{ 1136, 1136 },
-	{ 1138, 1138 },
-	{ 1140, 1140 },
-	{ 1142, 1142 },
-	{ 1144, 1144 },
-	{ 1146, 1146 },
-	{ 1148, 1148 },
-	{ 1150, 1150 },
-	{ 1152, 1152 },
-	{ 1162, 1162 },
-	{ 1164, 1164 },
-	{ 1166, 1166 },
-	{ 1168, 1168 },
-	{ 1170, 1170 },
-	{ 1172, 1172 },
-	{ 1174, 1174 },
-	{ 1176, 1176 },
-	{ 1178, 1178 },
-	{ 1180, 1180 },
-	{ 1182, 1182 },
-	{ 1184, 1184 },
-	{ 1186, 1186 },
-	{ 1188, 1188 },
-	{ 1190, 1190 },
-	{ 1192, 1192 },
-	{ 1194, 1194 },
-	{ 1196, 1196 },
-	{ 1198, 1198 },
-	{ 1200, 1200 },
-	{ 1202, 1202 },
-	{ 1204, 1204 },
-	{ 1206, 1206 },
-	{ 1208, 1208 },
-	{ 1210, 1210 },
-	{ 1212, 1212 },
-	{ 1214, 1214 },
-	{ 1216, 1217 },
-	{ 1219, 1219 },
-	{ 1221, 1221 },
-	{ 1223, 1223 },
-	{ 1225, 1225 },
-	{ 1227, 1227 },
-	{ 1229, 1229 },
-	{ 1232, 1232 },
-	{ 1234, 1234 },
-	{ 1236, 1236 },
-	{ 1238, 1238 },
-	{ 1240, 1240 },
-	{ 1242, 1242 },
-	{ 1244, 1244 },
-	{ 1246, 1246 },
-	{ 1248, 1248 },
-	{ 1250, 1250 },
-	{ 1252, 1252 },
-	{ 1254, 1254 },
-	{ 1256, 1256 },
-	{ 1258, 1258 },
-	{ 1260, 1260 },
-	{ 1262, 1262 },
-	{ 1264, 1264 },
-	{ 1266, 1266 },
-	{ 1268, 1268 },
-	{ 1270, 1270 },
-	{ 1272, 1272 },
-	{ 1274, 1274 },
-	{ 1276, 1276 },
-	{ 1278, 1278 },
-	{ 1280, 1280 },
-	{ 1282, 1282 },
-	{ 1284, 1284 },
-	{ 1286, 1286 },
-	{ 1288, 1288 },
-	{ 1290, 1290 },
-	{ 1292, 1292 },
-	{ 1294, 1294 },
-	{ 1296, 1296 },
-	{ 1298, 1298 },
-	{ 1300, 1300 },
-	{ 1302, 1302 },
-	{ 1304, 1304 },
-	{ 1306, 1306 },
-	{ 1308, 1308 },
-	{ 1310, 1310 },
-	{ 1312, 1312 },
-	{ 1314, 1314 },
-	{ 1316, 1316 },
-	{ 1318, 1318 },
-	{ 1320, 1320 },
-	{ 1322, 1322 },
-	{ 1324, 1324 },
-	{ 1326, 1326 },
-	{ 1329, 1366 },
-	{ 4256, 4293 },
-	{ 4295, 4295 },
-	{ 4301, 4301 },
-	{ 5024, 5109 },
-	{ 7312, 7354 },
-	{ 7357, 7359 },
-	{ 7680, 7680 },
-	{ 7682, 7682 },
-	{ 7684, 7684 },
-	{ 7686, 7686 },
-	{ 7688, 7688 },
-	{ 7690, 7690 },
-	{ 7692, 7692 },
-	{ 7694, 7694 },
-	{ 7696, 7696 },
-	{ 7698, 7698 },
-	{ 7700, 7700 },
-	{ 7702, 7702 },
-	{ 7704, 7704 },
-	{ 7706, 7706 },
-	{ 7708, 7708 },
-	{ 7710, 7710 },
-	{ 7712, 7712 },
-	{ 7714, 7714 },
-	{ 7716, 7716 },
-	{ 7718, 7718 },
-	{ 7720, 7720 },
-	{ 7722, 7722 },
-	{ 7724, 7724 },
-	{ 7726, 7726 },
-	{ 7728, 7728 },
-	{ 7730, 7730 },
-	{ 7732, 7732 },
-	{ 7734, 7734 },
-	{ 7736, 7736 },
-	{ 7738, 7738 },
-	{ 7740, 7740 },
-	{ 7742, 7742 },
-	{ 7744, 7744 },
-	{ 7746, 7746 },
-	{ 7748, 7748 },
-	{ 7750, 7750 },
-	{ 7752, 7752 },
-	{ 7754, 7754 },
-	{ 7756, 7756 },
-	{ 7758, 7758 },
-	{ 7760, 7760 },
-	{ 7762, 7762 },
-	{ 7764, 7764 },
-	{ 7766, 7766 },
-	{ 7768, 7768 },
-	{ 7770, 7770 },
-	{ 7772, 7772 },
-	{ 7774, 7774 },
-	{ 7776, 7776 },
-	{ 7778, 7778 },
-	{ 7780, 7780 },
-	{ 7782, 7782 },
-	{ 7784, 7784 },
-	{ 7786, 7786 },
-	{ 7788, 7788 },
-	{ 7790, 7790 },
-	{ 7792, 7792 },
-	{ 7794, 7794 },
-	{ 7796, 7796 },
-	{ 7798, 7798 },
-	{ 7800, 7800 },
-	{ 7802, 7802 },
-	{ 7804, 7804 },
-	{ 7806, 7806 },
-	{ 7808, 7808 },
-	{ 7810, 7810 },
-	{ 7812, 7812 },
-	{ 7814, 7814 },
-	{ 7816, 7816 },
-	{ 7818, 7818 },
-	{ 7820, 7820 },
-	{ 7822, 7822 },
-	{ 7824, 7824 },
-	{ 7826, 7826 },
-	{ 7828, 7828 },
-	{ 7838, 7838 },
-	{ 7840, 7840 },
-	{ 7842, 7842 },
-	{ 7844, 7844 },
-	{ 7846, 7846 },
-	{ 7848, 7848 },
-	{ 7850, 7850 },
-	{ 7852, 7852 },
-	{ 7854, 7854 },
-	{ 7856, 7856 },
-	{ 7858, 7858 },
-	{ 7860, 7860 },
-	{ 7862, 7862 },
-	{ 7864, 7864 },
-	{ 7866, 7866 },
-	{ 7868, 7868 },
-	{ 7870, 7870 },
-	{ 7872, 7872 },
-	{ 7874, 7874 },
-	{ 7876, 7876 },
-	{ 7878, 7878 },
-	{ 7880, 7880 },
-	{ 7882, 7882 },
-	{ 7884, 7884 },
-	{ 7886, 7886 },
-	{ 7888, 7888 },
-	{ 7890, 7890 },
-	{ 7892, 7892 },
-	{ 7894, 7894 },
-	{ 7896, 7896 },
-	{ 7898, 7898 },
-	{ 7900, 7900 },
-	{ 7902, 7902 },
-	{ 7904, 7904 },
-	{ 7906, 7906 },
-	{ 7908, 7908 },
-	{ 7910, 7910 },
-	{ 7912, 7912 },
-	{ 7914, 7914 },
-	{ 7916, 7916 },
-	{ 7918, 7918 },
-	{ 7920, 7920 },
-	{ 7922, 7922 },
-	{ 7924, 7924 },
-	{ 7926, 7926 },
-	{ 7928, 7928 },
-	{ 7930, 7930 },
-	{ 7932, 7932 },
-	{ 7934, 7934 },
-	{ 7944, 7951 },
-	{ 7960, 7965 },
-	{ 7976, 7983 },
-	{ 7992, 7999 },
-	{ 8008, 8013 },
-	{ 8025, 8025 },
-	{ 8027, 8027 },
-	{ 8029, 8029 },
-	{ 8031, 8031 },
-	{ 8040, 8047 },
-	{ 8120, 8123 },
-	{ 8136, 8139 },
-	{ 8152, 8155 },
-	{ 8168, 8172 },
-	{ 8184, 8187 },
-	{ 8450, 8450 },
-	{ 8455, 8455 },
-	{ 8459, 8461 },
-	{ 8464, 8466 },
-	{ 8469, 8469 },
-	{ 8473, 8477 },
-	{ 8484, 8484 },
-	{ 8486, 8486 },
-	{ 8488, 8488 },
-	{ 8490, 8493 },
-	{ 8496, 8499 },
-	{ 8510, 8511 },
-	{ 8517, 8517 },
-	{ 8579, 8579 },
-	{ 11264, 11310 },
-	{ 11360, 11360 },
-	{ 11362, 11364 },
-	{ 11367, 11367 },
-	{ 11369, 11369 },
-	{ 11371, 11371 },
-	{ 11373, 11376 },
-	{ 11378, 11378 },
-	{ 11381, 11381 },
-	{ 11390, 11392 },
-	{ 11394, 11394 },
-	{ 11396, 11396 },
-	{ 11398, 11398 },
-	{ 11400, 11400 },
-	{ 11402, 11402 },
-	{ 11404, 11404 },
-	{ 11406, 11406 },
-	{ 11408, 11408 },
-	{ 11410, 11410 },
-	{ 11412, 11412 },
-	{ 11414, 11414 },
-	{ 11416, 11416 },
-	{ 11418, 11418 },
-	{ 11420, 11420 },
-	{ 11422, 11422 },
-	{ 11424, 11424 },
-	{ 11426, 11426 },
-	{ 11428, 11428 },
-	{ 11430, 11430 },
-	{ 11432, 11432 },
-	{ 11434, 11434 },
-	{ 11436, 11436 },
-	{ 11438, 11438 },
-	{ 11440, 11440 },
-	{ 11442, 11442 },
-	{ 11444, 11444 },
-	{ 11446, 11446 },
-	{ 11448, 11448 },
-	{ 11450, 11450 },
-	{ 11452, 11452 },
-	{ 11454, 11454 },
-	{ 11456, 11456 },
-	{ 11458, 11458 },
-	{ 11460, 11460 },
-	{ 11462, 11462 },
-	{ 11464, 11464 },
-	{ 11466, 11466 },
-	{ 11468, 11468 },
-	{ 11470, 11470 },
-	{ 11472, 11472 },
-	{ 11474, 11474 },
-	{ 11476, 11476 },
-	{ 11478, 11478 },
-	{ 11480, 11480 },
-	{ 11482, 11482 },
-	{ 11484, 11484 },
-	{ 11486, 11486 },
-	{ 11488, 11488 },
-	{ 11490, 11490 },
-	{ 11499, 11499 },
-	{ 11501, 11501 },
-	{ 11506, 11506 },
-	{ 42560, 42560 },
-	{ 42562, 42562 },
-	{ 42564, 42564 },
-	{ 42566, 42566 },
-	{ 42568, 42568 },
-	{ 42570, 42570 },
-	{ 42572, 42572 },
-	{ 42574, 42574 },
-	{ 42576, 42576 },
-	{ 42578, 42578 },
-	{ 42580, 42580 },
-	{ 42582, 42582 },
-	{ 42584, 42584 },
-	{ 42586, 42586 },
-	{ 42588, 42588 },
-	{ 42590, 42590 },
-	{ 42592, 42592 },
-	{ 42594, 42594 },
-	{ 42596, 42596 },
-	{ 42598, 42598 },
-	{ 42600, 42600 },
-	{ 42602, 42602 },
-	{ 42604, 42604 },
-	{ 42624, 42624 },
-	{ 42626, 42626 },
-	{ 42628, 42628 },
-	{ 42630, 42630 },
-	{ 42632, 42632 },
-	{ 42634, 42634 },
-	{ 42636, 42636 },
-	{ 42638, 42638 },
-	{ 42640, 42640 },
-	{ 42642, 42642 },
-	{ 42644, 42644 },
-	{ 42646, 42646 },
-	{ 42648, 42648 },
-	{ 42650, 42650 },
-	{ 42786, 42786 },
-	{ 42788, 42788 },
-	{ 42790, 42790 },
-	{ 42792, 42792 },
-	{ 42794, 42794 },
-	{ 42796, 42796 },
-	{ 42798, 42798 },
-	{ 42802, 42802 },
-	{ 42804, 42804 },
-	{ 42806, 42806 },
-	{ 42808, 42808 },
-	{ 42810, 42810 },
-	{ 42812, 42812 },
-	{ 42814, 42814 },
-	{ 42816, 42816 },
-	{ 42818, 42818 },
-	{ 42820, 42820 },
-	{ 42822, 42822 },
-	{ 42824, 42824 },
-	{ 42826, 42826 },
-	{ 42828, 42828 },
-	{ 42830, 42830 },
-	{ 42832, 42832 },
-	{ 42834, 42834 },
-	{ 42836, 42836 },
-	{ 42838, 42838 },
-	{ 42840, 42840 },
-	{ 42842, 42842 },
-	{ 42844, 42844 },
-	{ 42846, 42846 },
-	{ 42848, 42848 },
-	{ 42850, 42850 },
-	{ 42852, 42852 },
-	{ 42854, 42854 },
-	{ 42856, 42856 },
-	{ 42858, 42858 },
-	{ 42860, 42860 },
-	{ 42862, 42862 },
-	{ 42873, 42873 },
-	{ 42875, 42875 },
-	{ 42877, 42878 },
-	{ 42880, 42880 },
-	{ 42882, 42882 },
-	{ 42884, 42884 },
-	{ 42886, 42886 },
-	{ 42891, 42891 },
-	{ 42893, 42893 },
-	{ 42896, 42896 },
-	{ 42898, 42898 },
-	{ 42902, 42902 },
-	{ 42904, 42904 },
-	{ 42906, 42906 },
-	{ 42908, 42908 },
-	{ 42910, 42910 },
-	{ 42912, 42912 },
-	{ 42914, 42914 },
-	{ 42916, 42916 },
-	{ 42918, 42918 },
-	{ 42920, 42920 },
-	{ 42922, 42926 },
-	{ 42928, 42932 },
-	{ 42934, 42934 },
-	{ 42936, 42936 },
-	{ 65313, 65338 },
-};
-static const URange32 Lu_range32[] = {
-	{ 66560, 66599 },
-	{ 66736, 66771 },
-	{ 68736, 68786 },
-	{ 71840, 71871 },
-	{ 93760, 93791 },
-	{ 119808, 119833 },
-	{ 119860, 119885 },
-	{ 119912, 119937 },
-	{ 119964, 119964 },
-	{ 119966, 119967 },
-	{ 119970, 119970 },
-	{ 119973, 119974 },
-	{ 119977, 119980 },
-	{ 119982, 119989 },
-	{ 120016, 120041 },
-	{ 120068, 120069 },
-	{ 120071, 120074 },
-	{ 120077, 120084 },
-	{ 120086, 120092 },
-	{ 120120, 120121 },
-	{ 120123, 120126 },
-	{ 120128, 120132 },
-	{ 120134, 120134 },
-	{ 120138, 120144 },
-	{ 120172, 120197 },
-	{ 120224, 120249 },
-	{ 120276, 120301 },
-	{ 120328, 120353 },
-	{ 120380, 120405 },
-	{ 120432, 120457 },
-	{ 120488, 120512 },
-	{ 120546, 120570 },
-	{ 120604, 120628 },
-	{ 120662, 120686 },
-	{ 120720, 120744 },
-	{ 120778, 120778 },
-	{ 125184, 125217 },
-};
-static const URange16 Pf_range16[] = {
-	{ 187, 187 },
-	{ 8217, 8217 },
-	{ 8221, 8221 },
-	{ 8250, 8250 },
-	{ 11779, 11779 },
-	{ 11781, 11781 },
-	{ 11786, 11786 },
-	{ 11789, 11789 },
-	{ 11805, 11805 },
-	{ 11809, 11809 },
-};
-static const URange16 Pd_range16[] = {
-	{ 45, 45 },
-	{ 1418, 1418 },
-	{ 1470, 1470 },
-	{ 5120, 5120 },
-	{ 6150, 6150 },
-	{ 8208, 8213 },
-	{ 11799, 11799 },
-	{ 11802, 11802 },
-	{ 11834, 11835 },
-	{ 11840, 11840 },
-	{ 12316, 12316 },
-	{ 12336, 12336 },
-	{ 12448, 12448 },
-	{ 65073, 65074 },
-	{ 65112, 65112 },
-	{ 65123, 65123 },
-	{ 65293, 65293 },
-};
-static const URange16 Pe_range16[] = {
-	{ 41, 41 },
-	{ 93, 93 },
-	{ 125, 125 },
-	{ 3899, 3899 },
-	{ 3901, 3901 },
-	{ 5788, 5788 },
-	{ 8262, 8262 },
-	{ 8318, 8318 },
-	{ 8334, 8334 },
-	{ 8969, 8969 },
-	{ 8971, 8971 },
-	{ 9002, 9002 },
-	{ 10089, 10089 },
-	{ 10091, 10091 },
-	{ 10093, 10093 },
-	{ 10095, 10095 },
-	{ 10097, 10097 },
-	{ 10099, 10099 },
-	{ 10101, 10101 },
-	{ 10182, 10182 },
-	{ 10215, 10215 },
-	{ 10217, 10217 },
-	{ 10219, 10219 },
-	{ 10221, 10221 },
-	{ 10223, 10223 },
-	{ 10628, 10628 },
-	{ 10630, 10630 },
-	{ 10632, 10632 },
-	{ 10634, 10634 },
-	{ 10636, 10636 },
-	{ 10638, 10638 },
-	{ 10640, 10640 },
-	{ 10642, 10642 },
-	{ 10644, 10644 },
-	{ 10646, 10646 },
-	{ 10648, 10648 },
-	{ 10713, 10713 },
-	{ 10715, 10715 },
-	{ 10749, 10749 },
-	{ 11811, 11811 },
-	{ 11813, 11813 },
-	{ 11815, 11815 },
-	{ 11817, 11817 },
-	{ 12297, 12297 },
-	{ 12299, 12299 },
-	{ 12301, 12301 },
-	{ 12303, 12303 },
-	{ 12305, 12305 },
-	{ 12309, 12309 },
-	{ 12311, 12311 },
-	{ 12313, 12313 },
-	{ 12315, 12315 },
-	{ 12318, 12319 },
-	{ 64830, 64830 },
-	{ 65048, 65048 },
-	{ 65078, 65078 },
-	{ 65080, 65080 },
-	{ 65082, 65082 },
-	{ 65084, 65084 },
-	{ 65086, 65086 },
-	{ 65088, 65088 },
-	{ 65090, 65090 },
-	{ 65092, 65092 },
-	{ 65096, 65096 },
-	{ 65114, 65114 },
-	{ 65116, 65116 },
-	{ 65118, 65118 },
-	{ 65289, 65289 },
-	{ 65341, 65341 },
-	{ 65373, 65373 },
-	{ 65376, 65376 },
-	{ 65379, 65379 },
-};
-static const URange16 Pi_range16[] = {
-	{ 171, 171 },
-	{ 8216, 8216 },
-	{ 8219, 8220 },
-	{ 8223, 8223 },
-	{ 8249, 8249 },
-	{ 11778, 11778 },
-	{ 11780, 11780 },
-	{ 11785, 11785 },
-	{ 11788, 11788 },
-	{ 11804, 11804 },
-	{ 11808, 11808 },
-};
-static const URange16 Po_range16[] = {
-	{ 33, 35 },
-	{ 37, 39 },
-	{ 42, 42 },
-	{ 44, 44 },
-	{ 46, 47 },
-	{ 58, 59 },
-	{ 63, 64 },
-	{ 92, 92 },
-	{ 161, 161 },
-	{ 167, 167 },
-	{ 182, 183 },
-	{ 191, 191 },
-	{ 894, 894 },
-	{ 903, 903 },
-	{ 1370, 1375 },
-	{ 1417, 1417 },
-	{ 1472, 1472 },
-	{ 1475, 1475 },
-	{ 1478, 1478 },
-	{ 1523, 1524 },
-	{ 1545, 1546 },
-	{ 1548, 1549 },
-	{ 1563, 1563 },
-	{ 1566, 1567 },
-	{ 1642, 1645 },
-	{ 1748, 1748 },
-	{ 1792, 1805 },
-	{ 2039, 2041 },
-	{ 2096, 2110 },
-	{ 2142, 2142 },
-	{ 2404, 2405 },
-	{ 2416, 2416 },
-	{ 2557, 2557 },
-	{ 2678, 2678 },
-	{ 2800, 2800 },
-	{ 3204, 3204 },
-	{ 3572, 3572 },
-	{ 3663, 3663 },
-	{ 3674, 3675 },
-	{ 3844, 3858 },
-	{ 3860, 3860 },
-	{ 3973, 3973 },
-	{ 4048, 4052 },
-	{ 4057, 4058 },
-	{ 4170, 4175 },
-	{ 4347, 4347 },
-	{ 4960, 4968 },
-	{ 5741, 5742 },
-	{ 5867, 5869 },
-	{ 5941, 5942 },
-	{ 6100, 6102 },
-	{ 6104, 6106 },
-	{ 6144, 6149 },
-	{ 6151, 6154 },
-	{ 6468, 6469 },
-	{ 6686, 6687 },
-	{ 6816, 6822 },
-	{ 6824, 6829 },
-	{ 7002, 7008 },
-	{ 7164, 7167 },
-	{ 7227, 7231 },
-	{ 7294, 7295 },
-	{ 7360, 7367 },
-	{ 7379, 7379 },
-	{ 8214, 8215 },
-	{ 8224, 8231 },
-	{ 8240, 8248 },
-	{ 8251, 8254 },
-	{ 8257, 8259 },
-	{ 8263, 8273 },
-	{ 8275, 8275 },
-	{ 8277, 8286 },
-	{ 11513, 11516 },
-	{ 11518, 11519 },
-	{ 11632, 11632 },
-	{ 11776, 11777 },
-	{ 11782, 11784 },
-	{ 11787, 11787 },
-	{ 11790, 11798 },
-	{ 11800, 11801 },
-	{ 11803, 11803 },
-	{ 11806, 11807 },
-	{ 11818, 11822 },
-	{ 11824, 11833 },
-	{ 11836, 11839 },
-	{ 11841, 11841 },
-	{ 11843, 11854 },
-	{ 12289, 12291 },
-	{ 12349, 12349 },
-	{ 12539, 12539 },
-	{ 42238, 42239 },
-	{ 42509, 42511 },
-	{ 42611, 42611 },
-	{ 42622, 42622 },
-	{ 42738, 42743 },
-	{ 43124, 43127 },
-	{ 43214, 43215 },
-	{ 43256, 43258 },
-	{ 43260, 43260 },
-	{ 43310, 43311 },
-	{ 43359, 43359 },
-	{ 43457, 43469 },
-	{ 43486, 43487 },
-	{ 43612, 43615 },
-	{ 43742, 43743 },
-	{ 43760, 43761 },
-	{ 44011, 44011 },
-	{ 65040, 65046 },
-	{ 65049, 65049 },
-	{ 65072, 65072 },
-	{ 65093, 65094 },
-	{ 65097, 65100 },
-	{ 65104, 65106 },
-	{ 65108, 65111 },
-	{ 65119, 65121 },
-	{ 65128, 65128 },
-	{ 65130, 65131 },
-	{ 65281, 65283 },
-	{ 65285, 65287 },
-	{ 65290, 65290 },
-	{ 65292, 65292 },
-	{ 65294, 65295 },
-	{ 65306, 65307 },
-	{ 65311, 65312 },
-	{ 65340, 65340 },
-	{ 65377, 65377 },
-	{ 65380, 65381 },
-};
-static const URange32 Po_range32[] = {
-	{ 65792, 65794 },
-	{ 66463, 66463 },
-	{ 66512, 66512 },
-	{ 66927, 66927 },
-	{ 67671, 67671 },
-	{ 67871, 67871 },
-	{ 67903, 67903 },
-	{ 68176, 68184 },
-	{ 68223, 68223 },
-	{ 68336, 68342 },
-	{ 68409, 68415 },
-	{ 68505, 68508 },
-	{ 69461, 69465 },
-	{ 69703, 69709 },
-	{ 69819, 69820 },
-	{ 69822, 69825 },
-	{ 69952, 69955 },
-	{ 70004, 70005 },
-	{ 70085, 70088 },
-	{ 70093, 70093 },
-	{ 70107, 70107 },
-	{ 70109, 70111 },
-	{ 70200, 70205 },
-	{ 70313, 70313 },
-	{ 70731, 70735 },
-	{ 70747, 70747 },
-	{ 70749, 70749 },
-	{ 70854, 70854 },
-	{ 71105, 71127 },
-	{ 71233, 71235 },
-	{ 71264, 71276 },
-	{ 71484, 71486 },
-	{ 71739, 71739 },
-	{ 72255, 72262 },
-	{ 72346, 72348 },
-	{ 72350, 72354 },
-	{ 72769, 72773 },
-	{ 72816, 72817 },
-	{ 73463, 73464 },
-	{ 74864, 74868 },
-	{ 92782, 92783 },
-	{ 92917, 92917 },
-	{ 92983, 92987 },
-	{ 92996, 92996 },
-	{ 93847, 93850 },
-	{ 113823, 113823 },
-	{ 121479, 121483 },
-	{ 125278, 125279 },
-};
-static const URange16 Me_range16[] = {
-	{ 1160, 1161 },
-	{ 6846, 6846 },
-	{ 8413, 8416 },
-	{ 8418, 8420 },
-	{ 42608, 42610 },
-};
-static const URange16 C_range16[] = {
-	{ 0, 31 },
-	{ 127, 159 },
-	{ 173, 173 },
-	{ 1536, 1541 },
-	{ 1564, 1564 },
-	{ 1757, 1757 },
-	{ 1807, 1807 },
-	{ 2274, 2274 },
-	{ 6158, 6158 },
-	{ 8203, 8207 },
-	{ 8234, 8238 },
-	{ 8288, 8292 },
-	{ 8294, 8303 },
-	{ 55296, 63743 },
-	{ 65279, 65279 },
-	{ 65529, 65531 },
-};
-static const URange32 C_range32[] = {
-	{ 69821, 69821 },
-	{ 69837, 69837 },
-	{ 113824, 113827 },
-	{ 119155, 119162 },
-	{ 917505, 917505 },
-	{ 917536, 917631 },
-	{ 983040, 1048573 },
-	{ 1048576, 1114109 },
-};
-static const URange16 Mc_range16[] = {
-	{ 2307, 2307 },
-	{ 2363, 2363 },
-	{ 2366, 2368 },
-	{ 2377, 2380 },
-	{ 2382, 2383 },
-	{ 2434, 2435 },
-	{ 2494, 2496 },
-	{ 2503, 2504 },
-	{ 2507, 2508 },
-	{ 2519, 2519 },
-	{ 2563, 2563 },
-	{ 2622, 2624 },
-	{ 2691, 2691 },
-	{ 2750, 2752 },
-	{ 2761, 2761 },
-	{ 2763, 2764 },
-	{ 2818, 2819 },
-	{ 2878, 2878 },
-	{ 2880, 2880 },
-	{ 2887, 2888 },
-	{ 2891, 2892 },
-	{ 2903, 2903 },
-	{ 3006, 3007 },
-	{ 3009, 3010 },
-	{ 3014, 3016 },
-	{ 3018, 3020 },
-	{ 3031, 3031 },
-	{ 3073, 3075 },
-	{ 3137, 3140 },
-	{ 3202, 3203 },
-	{ 3262, 3262 },
-	{ 3264, 3268 },
-	{ 3271, 3272 },
-	{ 3274, 3275 },
-	{ 3285, 3286 },
-	{ 3330, 3331 },
-	{ 3390, 3392 },
-	{ 3398, 3400 },
-	{ 3402, 3404 },
-	{ 3415, 3415 },
-	{ 3458, 3459 },
-	{ 3535, 3537 },
-	{ 3544, 3551 },
-	{ 3570, 3571 },
-	{ 3902, 3903 },
-	{ 3967, 3967 },
-	{ 4139, 4140 },
-	{ 4145, 4145 },
-	{ 4152, 4152 },
-	{ 4155, 4156 },
-	{ 4182, 4183 },
-	{ 4194, 4196 },
-	{ 4199, 4205 },
-	{ 4227, 4228 },
-	{ 4231, 4236 },
-	{ 4239, 4239 },
-	{ 4250, 4252 },
-	{ 6070, 6070 },
-	{ 6078, 6085 },
-	{ 6087, 6088 },
-	{ 6435, 6438 },
-	{ 6441, 6443 },
-	{ 6448, 6449 },
-	{ 6451, 6456 },
-	{ 6681, 6682 },
-	{ 6741, 6741 },
-	{ 6743, 6743 },
-	{ 6753, 6753 },
-	{ 6755, 6756 },
-	{ 6765, 6770 },
-	{ 6916, 6916 },
-	{ 6965, 6965 },
-	{ 6971, 6971 },
-	{ 6973, 6977 },
-	{ 6979, 6980 },
-	{ 7042, 7042 },
-	{ 7073, 7073 },
-	{ 7078, 7079 },
-	{ 7082, 7082 },
-	{ 7143, 7143 },
-	{ 7146, 7148 },
-	{ 7150, 7150 },
-	{ 7154, 7155 },
-	{ 7204, 7211 },
-	{ 7220, 7221 },
-	{ 7393, 7393 },
-	{ 7410, 7411 },
-	{ 7415, 7415 },
-	{ 12334, 12335 },
-	{ 43043, 43044 },
-	{ 43047, 43047 },
-	{ 43136, 43137 },
-	{ 43188, 43203 },
-	{ 43346, 43347 },
-	{ 43395, 43395 },
-	{ 43444, 43445 },
-	{ 43450, 43451 },
-	{ 43453, 43456 },
-	{ 43567, 43568 },
-	{ 43571, 43572 },
-	{ 43597, 43597 },
-	{ 43643, 43643 },
-	{ 43645, 43645 },
-	{ 43755, 43755 },
-	{ 43758, 43759 },
-	{ 43765, 43765 },
-	{ 44003, 44004 },
-	{ 44006, 44007 },
-	{ 44009, 44010 },
-	{ 44012, 44012 },
-};
-static const URange32 Mc_range32[] = {
-	{ 69632, 69632 },
-	{ 69634, 69634 },
-	{ 69762, 69762 },
-	{ 69808, 69810 },
-	{ 69815, 69816 },
-	{ 69932, 69932 },
-	{ 69957, 69958 },
-	{ 70018, 70018 },
-	{ 70067, 70069 },
-	{ 70079, 70080 },
-	{ 70188, 70190 },
-	{ 70194, 70195 },
-	{ 70197, 70197 },
-	{ 70368, 70370 },
-	{ 70402, 70403 },
-	{ 70462, 70463 },
-	{ 70465, 70468 },
-	{ 70471, 70472 },
-	{ 70475, 70477 },
-	{ 70487, 70487 },
-	{ 70498, 70499 },
-	{ 70709, 70711 },
-	{ 70720, 70721 },
-	{ 70725, 70725 },
-	{ 70832, 70834 },
-	{ 70841, 70841 },
-	{ 70843, 70846 },
-	{ 70849, 70849 },
-	{ 71087, 71089 },
-	{ 71096, 71099 },
-	{ 71102, 71102 },
-	{ 71216, 71218 },
-	{ 71227, 71228 },
-	{ 71230, 71230 },
-	{ 71340, 71340 },
-	{ 71342, 71343 },
-	{ 71350, 71350 },
-	{ 71456, 71457 },
-	{ 71462, 71462 },
-	{ 71724, 71726 },
-	{ 71736, 71736 },
-	{ 72249, 72249 },
-	{ 72279, 72280 },
-	{ 72343, 72343 },
-	{ 72751, 72751 },
-	{ 72766, 72766 },
-	{ 72873, 72873 },
-	{ 72881, 72881 },
-	{ 72884, 72884 },
-	{ 73098, 73102 },
-	{ 73107, 73108 },
-	{ 73110, 73110 },
-	{ 73461, 73462 },
-	{ 94033, 94078 },
-	{ 119141, 119142 },
-	{ 119149, 119154 },
-};
-static const URange16 Mn_range16[] = {
-	{ 768, 879 },
-	{ 1155, 1159 },
-	{ 1425, 1469 },
-	{ 1471, 1471 },
-	{ 1473, 1474 },
-	{ 1476, 1477 },
-	{ 1479, 1479 },
-	{ 1552, 1562 },
-	{ 1611, 1631 },
-	{ 1648, 1648 },
-	{ 1750, 1756 },
-	{ 1759, 1764 },
-	{ 1767, 1768 },
-	{ 1770, 1773 },
-	{ 1809, 1809 },
-	{ 1840, 1866 },
-	{ 1958, 1968 },
-	{ 2027, 2035 },
-	{ 2045, 2045 },
-	{ 2070, 2073 },
-	{ 2075, 2083 },
-	{ 2085, 2087 },
-	{ 2089, 2093 },
-	{ 2137, 2139 },
-	{ 2259, 2273 },
-	{ 2275, 2306 },
-	{ 2362, 2362 },
-	{ 2364, 2364 },
-	{ 2369, 2376 },
-	{ 2381, 2381 },
-	{ 2385, 2391 },
-	{ 2402, 2403 },
-	{ 2433, 2433 },
-	{ 2492, 2492 },
-	{ 2497, 2500 },
-	{ 2509, 2509 },
-	{ 2530, 2531 },
-	{ 2558, 2558 },
-	{ 2561, 2562 },
-	{ 2620, 2620 },
-	{ 2625, 2626 },
-	{ 2631, 2632 },
-	{ 2635, 2637 },
-	{ 2641, 2641 },
-	{ 2672, 2673 },
-	{ 2677, 2677 },
-	{ 2689, 2690 },
-	{ 2748, 2748 },
-	{ 2753, 2757 },
-	{ 2759, 2760 },
-	{ 2765, 2765 },
-	{ 2786, 2787 },
-	{ 2810, 2815 },
-	{ 2817, 2817 },
-	{ 2876, 2876 },
-	{ 2879, 2879 },
-	{ 2881, 2884 },
-	{ 2893, 2893 },
-	{ 2902, 2902 },
-	{ 2914, 2915 },
-	{ 2946, 2946 },
-	{ 3008, 3008 },
-	{ 3021, 3021 },
-	{ 3072, 3072 },
-	{ 3076, 3076 },
-	{ 3134, 3136 },
-	{ 3142, 3144 },
-	{ 3146, 3149 },
-	{ 3157, 3158 },
-	{ 3170, 3171 },
-	{ 3201, 3201 },
-	{ 3260, 3260 },
-	{ 3263, 3263 },
-	{ 3270, 3270 },
-	{ 3276, 3277 },
-	{ 3298, 3299 },
-	{ 3328, 3329 },
-	{ 3387, 3388 },
-	{ 3393, 3396 },
-	{ 3405, 3405 },
-	{ 3426, 3427 },
-	{ 3530, 3530 },
-	{ 3538, 3540 },
-	{ 3542, 3542 },
-	{ 3633, 3633 },
-	{ 3636, 3642 },
-	{ 3655, 3662 },
-	{ 3761, 3761 },
-	{ 3764, 3769 },
-	{ 3771, 3772 },
-	{ 3784, 3789 },
-	{ 3864, 3865 },
-	{ 3893, 3893 },
-	{ 3895, 3895 },
-	{ 3897, 3897 },
-	{ 3953, 3966 },
-	{ 3968, 3972 },
-	{ 3974, 3975 },
-	{ 3981, 3991 },
-	{ 3993, 4028 },
-	{ 4038, 4038 },
-	{ 4141, 4144 },
-	{ 4146, 4151 },
-	{ 4153, 4154 },
-	{ 4157, 4158 },
-	{ 4184, 4185 },
-	{ 4190, 4192 },
-	{ 4209, 4212 },
-	{ 4226, 4226 },
-	{ 4229, 4230 },
-	{ 4237, 4237 },
-	{ 4253, 4253 },
-	{ 4957, 4959 },
-	{ 5906, 5908 },
-	{ 5938, 5940 },
-	{ 5970, 5971 },
-	{ 6002, 6003 },
-	{ 6068, 6069 },
-	{ 6071, 6077 },
-	{ 6086, 6086 },
-	{ 6089, 6099 },
-	{ 6109, 6109 },
-	{ 6155, 6157 },
-	{ 6277, 6278 },
-	{ 6313, 6313 },
-	{ 6432, 6434 },
-	{ 6439, 6440 },
-	{ 6450, 6450 },
-	{ 6457, 6459 },
-	{ 6679, 6680 },
-	{ 6683, 6683 },
-	{ 6742, 6742 },
-	{ 6744, 6750 },
-	{ 6752, 6752 },
-	{ 6754, 6754 },
-	{ 6757, 6764 },
-	{ 6771, 6780 },
-	{ 6783, 6783 },
-	{ 6832, 6845 },
-	{ 6912, 6915 },
-	{ 6964, 6964 },
-	{ 6966, 6970 },
-	{ 6972, 6972 },
-	{ 6978, 6978 },
-	{ 7019, 7027 },
-	{ 7040, 7041 },
-	{ 7074, 7077 },
-	{ 7080, 7081 },
-	{ 7083, 7085 },
-	{ 7142, 7142 },
-	{ 7144, 7145 },
-	{ 7149, 7149 },
-	{ 7151, 7153 },
-	{ 7212, 7219 },
-	{ 7222, 7223 },
-	{ 7376, 7378 },
-	{ 7380, 7392 },
-	{ 7394, 7400 },
-	{ 7405, 7405 },
-	{ 7412, 7412 },
-	{ 7416, 7417 },
-	{ 7616, 7673 },
-	{ 7675, 7679 },
-	{ 8400, 8412 },
-	{ 8417, 8417 },
-	{ 8421, 8432 },
-	{ 11503, 11505 },
-	{ 11647, 11647 },
-	{ 11744, 11775 },
-	{ 12330, 12333 },
-	{ 12441, 12442 },
-	{ 42607, 42607 },
-	{ 42612, 42621 },
-	{ 42654, 42655 },
-	{ 42736, 42737 },
-	{ 43010, 43010 },
-	{ 43014, 43014 },
-	{ 43019, 43019 },
-	{ 43045, 43046 },
-	{ 43204, 43205 },
-	{ 43232, 43249 },
-	{ 43263, 43263 },
-	{ 43302, 43309 },
-	{ 43335, 43345 },
-	{ 43392, 43394 },
-	{ 43443, 43443 },
-	{ 43446, 43449 },
-	{ 43452, 43452 },
-	{ 43493, 43493 },
-	{ 43561, 43566 },
-	{ 43569, 43570 },
-	{ 43573, 43574 },
-	{ 43587, 43587 },
-	{ 43596, 43596 },
-	{ 43644, 43644 },
-	{ 43696, 43696 },
-	{ 43698, 43700 },
-	{ 43703, 43704 },
-	{ 43710, 43711 },
-	{ 43713, 43713 },
-	{ 43756, 43757 },
-	{ 43766, 43766 },
-	{ 44005, 44005 },
-	{ 44008, 44008 },
-	{ 44013, 44013 },
-	{ 64286, 64286 },
-	{ 65024, 65039 },
-	{ 65056, 65071 },
-};
-static const URange32 Mn_range32[] = {
-	{ 66045, 66045 },
-	{ 66272, 66272 },
-	{ 66422, 66426 },
-	{ 68097, 68099 },
-	{ 68101, 68102 },
-	{ 68108, 68111 },
-	{ 68152, 68154 },
-	{ 68159, 68159 },
-	{ 68325, 68326 },
-	{ 68900, 68903 },
-	{ 69446, 69456 },
-	{ 69633, 69633 },
-	{ 69688, 69702 },
-	{ 69759, 69761 },
-	{ 69811, 69814 },
-	{ 69817, 69818 },
-	{ 69888, 69890 },
-	{ 69927, 69931 },
-	{ 69933, 69940 },
-	{ 70003, 70003 },
-	{ 70016, 70017 },
-	{ 70070, 70078 },
-	{ 70089, 70092 },
-	{ 70191, 70193 },
-	{ 70196, 70196 },
-	{ 70198, 70199 },
-	{ 70206, 70206 },
-	{ 70367, 70367 },
-	{ 70371, 70378 },
-	{ 70400, 70401 },
-	{ 70459, 70460 },
-	{ 70464, 70464 },
-	{ 70502, 70508 },
-	{ 70512, 70516 },
-	{ 70712, 70719 },
-	{ 70722, 70724 },
-	{ 70726, 70726 },
-	{ 70750, 70750 },
-	{ 70835, 70840 },
-	{ 70842, 70842 },
-	{ 70847, 70848 },
-	{ 70850, 70851 },
-	{ 71090, 71093 },
-	{ 71100, 71101 },
-	{ 71103, 71104 },
-	{ 71132, 71133 },
-	{ 71219, 71226 },
-	{ 71229, 71229 },
-	{ 71231, 71232 },
-	{ 71339, 71339 },
-	{ 71341, 71341 },
-	{ 71344, 71349 },
-	{ 71351, 71351 },
-	{ 71453, 71455 },
-	{ 71458, 71461 },
-	{ 71463, 71467 },
-	{ 71727, 71735 },
-	{ 71737, 71738 },
-	{ 72193, 72202 },
-	{ 72243, 72248 },
-	{ 72251, 72254 },
-	{ 72263, 72263 },
-	{ 72273, 72278 },
-	{ 72281, 72283 },
-	{ 72330, 72342 },
-	{ 72344, 72345 },
-	{ 72752, 72758 },
-	{ 72760, 72765 },
-	{ 72767, 72767 },
-	{ 72850, 72871 },
-	{ 72874, 72880 },
-	{ 72882, 72883 },
-	{ 72885, 72886 },
-	{ 73009, 73014 },
-	{ 73018, 73018 },
-	{ 73020, 73021 },
-	{ 73023, 73029 },
-	{ 73031, 73031 },
-	{ 73104, 73105 },
-	{ 73109, 73109 },
-	{ 73111, 73111 },
-	{ 73459, 73460 },
-	{ 92912, 92916 },
-	{ 92976, 92982 },
-	{ 94095, 94098 },
-	{ 113821, 113822 },
-	{ 119143, 119145 },
-	{ 119163, 119170 },
-	{ 119173, 119179 },
-	{ 119210, 119213 },
-	{ 119362, 119364 },
-	{ 121344, 121398 },
-	{ 121403, 121452 },
-	{ 121461, 121461 },
-	{ 121476, 121476 },
-	{ 121499, 121503 },
-	{ 121505, 121519 },
-	{ 122880, 122886 },
-	{ 122888, 122904 },
-	{ 122907, 122913 },
-	{ 122915, 122916 },
-	{ 122918, 122922 },
-	{ 125136, 125142 },
-	{ 125252, 125258 },
-	{ 917760, 917999 },
-};
-static const URange16 M_range16[] = {
-	{ 768, 879 },
-	{ 1155, 1161 },
-	{ 1425, 1469 },
-	{ 1471, 1471 },
-	{ 1473, 1474 },
-	{ 1476, 1477 },
-	{ 1479, 1479 },
-	{ 1552, 1562 },
-	{ 1611, 1631 },
-	{ 1648, 1648 },
-	{ 1750, 1756 },
-	{ 1759, 1764 },
-	{ 1767, 1768 },
-	{ 1770, 1773 },
-	{ 1809, 1809 },
-	{ 1840, 1866 },
-	{ 1958, 1968 },
-	{ 2027, 2035 },
-	{ 2045, 2045 },
-	{ 2070, 2073 },
-	{ 2075, 2083 },
-	{ 2085, 2087 },
-	{ 2089, 2093 },
-	{ 2137, 2139 },
-	{ 2259, 2273 },
-	{ 2275, 2307 },
-	{ 2362, 2364 },
-	{ 2366, 2383 },
-	{ 2385, 2391 },
-	{ 2402, 2403 },
-	{ 2433, 2435 },
-	{ 2492, 2492 },
-	{ 2494, 2500 },
-	{ 2503, 2504 },
-	{ 2507, 2509 },
-	{ 2519, 2519 },
-	{ 2530, 2531 },
-	{ 2558, 2558 },
-	{ 2561, 2563 },
-	{ 2620, 2620 },
-	{ 2622, 2626 },
-	{ 2631, 2632 },
-	{ 2635, 2637 },
-	{ 2641, 2641 },
-	{ 2672, 2673 },
-	{ 2677, 2677 },
-	{ 2689, 2691 },
-	{ 2748, 2748 },
-	{ 2750, 2757 },
-	{ 2759, 2761 },
-	{ 2763, 2765 },
-	{ 2786, 2787 },
-	{ 2810, 2815 },
-	{ 2817, 2819 },
-	{ 2876, 2876 },
-	{ 2878, 2884 },
-	{ 2887, 2888 },
-	{ 2891, 2893 },
-	{ 2902, 2903 },
-	{ 2914, 2915 },
-	{ 2946, 2946 },
-	{ 3006, 3010 },
-	{ 3014, 3016 },
-	{ 3018, 3021 },
-	{ 3031, 3031 },
-	{ 3072, 3076 },
-	{ 3134, 3140 },
-	{ 3142, 3144 },
-	{ 3146, 3149 },
-	{ 3157, 3158 },
-	{ 3170, 3171 },
-	{ 3201, 3203 },
-	{ 3260, 3260 },
-	{ 3262, 3268 },
-	{ 3270, 3272 },
-	{ 3274, 3277 },
-	{ 3285, 3286 },
-	{ 3298, 3299 },
-	{ 3328, 3331 },
-	{ 3387, 3388 },
-	{ 3390, 3396 },
-	{ 3398, 3400 },
-	{ 3402, 3405 },
-	{ 3415, 3415 },
-	{ 3426, 3427 },
-	{ 3458, 3459 },
-	{ 3530, 3530 },
-	{ 3535, 3540 },
-	{ 3542, 3542 },
-	{ 3544, 3551 },
-	{ 3570, 3571 },
-	{ 3633, 3633 },
-	{ 3636, 3642 },
-	{ 3655, 3662 },
-	{ 3761, 3761 },
-	{ 3764, 3769 },
-	{ 3771, 3772 },
-	{ 3784, 3789 },
-	{ 3864, 3865 },
-	{ 3893, 3893 },
-	{ 3895, 3895 },
-	{ 3897, 3897 },
-	{ 3902, 3903 },
-	{ 3953, 3972 },
-	{ 3974, 3975 },
-	{ 3981, 3991 },
-	{ 3993, 4028 },
-	{ 4038, 4038 },
-	{ 4139, 4158 },
-	{ 4182, 4185 },
-	{ 4190, 4192 },
-	{ 4194, 4196 },
-	{ 4199, 4205 },
-	{ 4209, 4212 },
-	{ 4226, 4237 },
-	{ 4239, 4239 },
-	{ 4250, 4253 },
-	{ 4957, 4959 },
-	{ 5906, 5908 },
-	{ 5938, 5940 },
-	{ 5970, 5971 },
-	{ 6002, 6003 },
-	{ 6068, 6099 },
-	{ 6109, 6109 },
-	{ 6155, 6157 },
-	{ 6277, 6278 },
-	{ 6313, 6313 },
-	{ 6432, 6443 },
-	{ 6448, 6459 },
-	{ 6679, 6683 },
-	{ 6741, 6750 },
-	{ 6752, 6780 },
-	{ 6783, 6783 },
-	{ 6832, 6846 },
-	{ 6912, 6916 },
-	{ 6964, 6980 },
-	{ 7019, 7027 },
-	{ 7040, 7042 },
-	{ 7073, 7085 },
-	{ 7142, 7155 },
-	{ 7204, 7223 },
-	{ 7376, 7378 },
-	{ 7380, 7400 },
-	{ 7405, 7405 },
-	{ 7410, 7412 },
-	{ 7415, 7417 },
-	{ 7616, 7673 },
-	{ 7675, 7679 },
-	{ 8400, 8432 },
-	{ 11503, 11505 },
-	{ 11647, 11647 },
-	{ 11744, 11775 },
-	{ 12330, 12335 },
-	{ 12441, 12442 },
-	{ 42607, 42610 },
-	{ 42612, 42621 },
-	{ 42654, 42655 },
-	{ 42736, 42737 },
-	{ 43010, 43010 },
-	{ 43014, 43014 },
-	{ 43019, 43019 },
-	{ 43043, 43047 },
-	{ 43136, 43137 },
-	{ 43188, 43205 },
-	{ 43232, 43249 },
-	{ 43263, 43263 },
-	{ 43302, 43309 },
-	{ 43335, 43347 },
-	{ 43392, 43395 },
-	{ 43443, 43456 },
-	{ 43493, 43493 },
-	{ 43561, 43574 },
-	{ 43587, 43587 },
-	{ 43596, 43597 },
-	{ 43643, 43645 },
-	{ 43696, 43696 },
-	{ 43698, 43700 },
-	{ 43703, 43704 },
-	{ 43710, 43711 },
-	{ 43713, 43713 },
-	{ 43755, 43759 },
-	{ 43765, 43766 },
-	{ 44003, 44010 },
-	{ 44012, 44013 },
-	{ 64286, 64286 },
-	{ 65024, 65039 },
-	{ 65056, 65071 },
-};
-static const URange32 M_range32[] = {
-	{ 66045, 66045 },
-	{ 66272, 66272 },
-	{ 66422, 66426 },
-	{ 68097, 68099 },
-	{ 68101, 68102 },
-	{ 68108, 68111 },
-	{ 68152, 68154 },
-	{ 68159, 68159 },
-	{ 68325, 68326 },
-	{ 68900, 68903 },
-	{ 69446, 69456 },
-	{ 69632, 69634 },
-	{ 69688, 69702 },
-	{ 69759, 69762 },
-	{ 69808, 69818 },
-	{ 69888, 69890 },
-	{ 69927, 69940 },
-	{ 69957, 69958 },
-	{ 70003, 70003 },
-	{ 70016, 70018 },
-	{ 70067, 70080 },
-	{ 70089, 70092 },
-	{ 70188, 70199 },
-	{ 70206, 70206 },
-	{ 70367, 70378 },
-	{ 70400, 70403 },
-	{ 70459, 70460 },
-	{ 70462, 70468 },
-	{ 70471, 70472 },
-	{ 70475, 70477 },
-	{ 70487, 70487 },
-	{ 70498, 70499 },
-	{ 70502, 70508 },
-	{ 70512, 70516 },
-	{ 70709, 70726 },
-	{ 70750, 70750 },
-	{ 70832, 70851 },
-	{ 71087, 71093 },
-	{ 71096, 71104 },
-	{ 71132, 71133 },
-	{ 71216, 71232 },
-	{ 71339, 71351 },
-	{ 71453, 71467 },
-	{ 71724, 71738 },
-	{ 72193, 72202 },
-	{ 72243, 72249 },
-	{ 72251, 72254 },
-	{ 72263, 72263 },
-	{ 72273, 72283 },
-	{ 72330, 72345 },
-	{ 72751, 72758 },
-	{ 72760, 72767 },
-	{ 72850, 72871 },
-	{ 72873, 72886 },
-	{ 73009, 73014 },
-	{ 73018, 73018 },
-	{ 73020, 73021 },
-	{ 73023, 73029 },
-	{ 73031, 73031 },
-	{ 73098, 73102 },
-	{ 73104, 73105 },
-	{ 73107, 73111 },
-	{ 73459, 73462 },
-	{ 92912, 92916 },
-	{ 92976, 92982 },
-	{ 94033, 94078 },
-	{ 94095, 94098 },
-	{ 113821, 113822 },
-	{ 119141, 119145 },
-	{ 119149, 119154 },
-	{ 119163, 119170 },
-	{ 119173, 119179 },
-	{ 119210, 119213 },
-	{ 119362, 119364 },
-	{ 121344, 121398 },
-	{ 121403, 121452 },
-	{ 121461, 121461 },
-	{ 121476, 121476 },
-	{ 121499, 121503 },
-	{ 121505, 121519 },
-	{ 122880, 122886 },
-	{ 122888, 122904 },
-	{ 122907, 122913 },
-	{ 122915, 122916 },
-	{ 122918, 122922 },
-	{ 125136, 125142 },
-	{ 125252, 125258 },
-	{ 917760, 917999 },
-};
-static const URange16 L_range16[] = {
-	{ 65, 90 },
-	{ 97, 122 },
-	{ 170, 170 },
-	{ 181, 181 },
-	{ 186, 186 },
-	{ 192, 214 },
-	{ 216, 246 },
-	{ 248, 705 },
-	{ 710, 721 },
-	{ 736, 740 },
-	{ 748, 748 },
-	{ 750, 750 },
-	{ 880, 884 },
-	{ 886, 887 },
-	{ 890, 893 },
-	{ 895, 895 },
-	{ 902, 902 },
-	{ 904, 906 },
-	{ 908, 908 },
-	{ 910, 929 },
-	{ 931, 1013 },
-	{ 1015, 1153 },
-	{ 1162, 1327 },
-	{ 1329, 1366 },
-	{ 1369, 1369 },
-	{ 1376, 1416 },
-	{ 1488, 1514 },
-	{ 1519, 1522 },
-	{ 1568, 1610 },
-	{ 1646, 1647 },
-	{ 1649, 1747 },
-	{ 1749, 1749 },
-	{ 1765, 1766 },
-	{ 1774, 1775 },
-	{ 1786, 1788 },
-	{ 1791, 1791 },
-	{ 1808, 1808 },
-	{ 1810, 1839 },
-	{ 1869, 1957 },
-	{ 1969, 1969 },
-	{ 1994, 2026 },
-	{ 2036, 2037 },
-	{ 2042, 2042 },
-	{ 2048, 2069 },
-	{ 2074, 2074 },
-	{ 2084, 2084 },
-	{ 2088, 2088 },
-	{ 2112, 2136 },
-	{ 2144, 2154 },
-	{ 2208, 2228 },
-	{ 2230, 2237 },
-	{ 2308, 2361 },
-	{ 2365, 2365 },
-	{ 2384, 2384 },
-	{ 2392, 2401 },
-	{ 2417, 2432 },
-	{ 2437, 2444 },
-	{ 2447, 2448 },
-	{ 2451, 2472 },
-	{ 2474, 2480 },
-	{ 2482, 2482 },
-	{ 2486, 2489 },
-	{ 2493, 2493 },
-	{ 2510, 2510 },
-	{ 2524, 2525 },
-	{ 2527, 2529 },
-	{ 2544, 2545 },
-	{ 2556, 2556 },
-	{ 2565, 2570 },
-	{ 2575, 2576 },
-	{ 2579, 2600 },
-	{ 2602, 2608 },
-	{ 2610, 2611 },
-	{ 2613, 2614 },
-	{ 2616, 2617 },
-	{ 2649, 2652 },
-	{ 2654, 2654 },
-	{ 2674, 2676 },
-	{ 2693, 2701 },
-	{ 2703, 2705 },
-	{ 2707, 2728 },
-	{ 2730, 2736 },
-	{ 2738, 2739 },
-	{ 2741, 2745 },
-	{ 2749, 2749 },
-	{ 2768, 2768 },
-	{ 2784, 2785 },
-	{ 2809, 2809 },
-	{ 2821, 2828 },
-	{ 2831, 2832 },
-	{ 2835, 2856 },
-	{ 2858, 2864 },
-	{ 2866, 2867 },
-	{ 2869, 2873 },
-	{ 2877, 2877 },
-	{ 2908, 2909 },
-	{ 2911, 2913 },
-	{ 2929, 2929 },
-	{ 2947, 2947 },
-	{ 2949, 2954 },
-	{ 2958, 2960 },
-	{ 2962, 2965 },
-	{ 2969, 2970 },
-	{ 2972, 2972 },
-	{ 2974, 2975 },
-	{ 2979, 2980 },
-	{ 2984, 2986 },
-	{ 2990, 3001 },
-	{ 3024, 3024 },
-	{ 3077, 3084 },
-	{ 3086, 3088 },
-	{ 3090, 3112 },
-	{ 3114, 3129 },
-	{ 3133, 3133 },
-	{ 3160, 3162 },
-	{ 3168, 3169 },
-	{ 3200, 3200 },
-	{ 3205, 3212 },
-	{ 3214, 3216 },
-	{ 3218, 3240 },
-	{ 3242, 3251 },
-	{ 3253, 3257 },
-	{ 3261, 3261 },
-	{ 3294, 3294 },
-	{ 3296, 3297 },
-	{ 3313, 3314 },
-	{ 3333, 3340 },
-	{ 3342, 3344 },
-	{ 3346, 3386 },
-	{ 3389, 3389 },
-	{ 3406, 3406 },
-	{ 3412, 3414 },
-	{ 3423, 3425 },
-	{ 3450, 3455 },
-	{ 3461, 3478 },
-	{ 3482, 3505 },
-	{ 3507, 3515 },
-	{ 3517, 3517 },
-	{ 3520, 3526 },
-	{ 3585, 3632 },
-	{ 3634, 3635 },
-	{ 3648, 3654 },
-	{ 3713, 3714 },
-	{ 3716, 3716 },
-	{ 3719, 3720 },
-	{ 3722, 3722 },
-	{ 3725, 3725 },
-	{ 3732, 3735 },
-	{ 3737, 3743 },
-	{ 3745, 3747 },
-	{ 3749, 3749 },
-	{ 3751, 3751 },
-	{ 3754, 3755 },
-	{ 3757, 3760 },
-	{ 3762, 3763 },
-	{ 3773, 3773 },
-	{ 3776, 3780 },
-	{ 3782, 3782 },
-	{ 3804, 3807 },
-	{ 3840, 3840 },
-	{ 3904, 3911 },
-	{ 3913, 3948 },
-	{ 3976, 3980 },
-	{ 4096, 4138 },
-	{ 4159, 4159 },
-	{ 4176, 4181 },
-	{ 4186, 4189 },
-	{ 4193, 4193 },
-	{ 4197, 4198 },
-	{ 4206, 4208 },
-	{ 4213, 4225 },
-	{ 4238, 4238 },
-	{ 4256, 4293 },
-	{ 4295, 4295 },
-	{ 4301, 4301 },
-	{ 4304, 4346 },
-	{ 4348, 4680 },
-	{ 4682, 4685 },
-	{ 4688, 4694 },
-	{ 4696, 4696 },
-	{ 4698, 4701 },
-	{ 4704, 4744 },
-	{ 4746, 4749 },
-	{ 4752, 4784 },
-	{ 4786, 4789 },
-	{ 4792, 4798 },
-	{ 4800, 4800 },
-	{ 4802, 4805 },
-	{ 4808, 4822 },
-	{ 4824, 4880 },
-	{ 4882, 4885 },
-	{ 4888, 4954 },
-	{ 4992, 5007 },
-	{ 5024, 5109 },
-	{ 5112, 5117 },
-	{ 5121, 5740 },
-	{ 5743, 5759 },
-	{ 5761, 5786 },
-	{ 5792, 5866 },
-	{ 5873, 5880 },
-	{ 5888, 5900 },
-	{ 5902, 5905 },
-	{ 5920, 5937 },
-	{ 5952, 5969 },
-	{ 5984, 5996 },
-	{ 5998, 6000 },
-	{ 6016, 6067 },
-	{ 6103, 6103 },
-	{ 6108, 6108 },
-	{ 6176, 6264 },
-	{ 6272, 6276 },
-	{ 6279, 6312 },
-	{ 6314, 6314 },
-	{ 6320, 6389 },
-	{ 6400, 6430 },
-	{ 6480, 6509 },
-	{ 6512, 6516 },
-	{ 6528, 6571 },
-	{ 6576, 6601 },
-	{ 6656, 6678 },
-	{ 6688, 6740 },
-	{ 6823, 6823 },
-	{ 6917, 6963 },
-	{ 6981, 6987 },
-	{ 7043, 7072 },
-	{ 7086, 7087 },
-	{ 7098, 7141 },
-	{ 7168, 7203 },
-	{ 7245, 7247 },
-	{ 7258, 7293 },
-	{ 7296, 7304 },
-	{ 7312, 7354 },
-	{ 7357, 7359 },
-	{ 7401, 7404 },
-	{ 7406, 7409 },
-	{ 7413, 7414 },
-	{ 7424, 7615 },
-	{ 7680, 7957 },
-	{ 7960, 7965 },
-	{ 7968, 8005 },
-	{ 8008, 8013 },
-	{ 8016, 8023 },
-	{ 8025, 8025 },
-	{ 8027, 8027 },
-	{ 8029, 8029 },
-	{ 8031, 8061 },
-	{ 8064, 8116 },
-	{ 8118, 8124 },
-	{ 8126, 8126 },
-	{ 8130, 8132 },
-	{ 8134, 8140 },
-	{ 8144, 8147 },
-	{ 8150, 8155 },
-	{ 8160, 8172 },
-	{ 8178, 8180 },
-	{ 8182, 8188 },
-	{ 8305, 8305 },
-	{ 8319, 8319 },
-	{ 8336, 8348 },
-	{ 8450, 8450 },
-	{ 8455, 8455 },
-	{ 8458, 8467 },
-	{ 8469, 8469 },
-	{ 8473, 8477 },
-	{ 8484, 8484 },
-	{ 8486, 8486 },
-	{ 8488, 8488 },
-	{ 8490, 8493 },
-	{ 8495, 8505 },
-	{ 8508, 8511 },
-	{ 8517, 8521 },
-	{ 8526, 8526 },
-	{ 8579, 8580 },
-	{ 11264, 11310 },
-	{ 11312, 11358 },
-	{ 11360, 11492 },
-	{ 11499, 11502 },
-	{ 11506, 11507 },
-	{ 11520, 11557 },
-	{ 11559, 11559 },
-	{ 11565, 11565 },
-	{ 11568, 11623 },
-	{ 11631, 11631 },
-	{ 11648, 11670 },
-	{ 11680, 11686 },
-	{ 11688, 11694 },
-	{ 11696, 11702 },
-	{ 11704, 11710 },
-	{ 11712, 11718 },
-	{ 11720, 11726 },
-	{ 11728, 11734 },
-	{ 11736, 11742 },
-	{ 11823, 11823 },
-	{ 12293, 12294 },
-	{ 12337, 12341 },
-	{ 12347, 12348 },
-	{ 12353, 12438 },
-	{ 12445, 12447 },
-	{ 12449, 12538 },
-	{ 12540, 12543 },
-	{ 12549, 12591 },
-	{ 12593, 12686 },
-	{ 12704, 12730 },
-	{ 12784, 12799 },
-	{ 13312, 19893 },
-	{ 19968, 40943 },
-	{ 40960, 42124 },
-	{ 42192, 42237 },
-	{ 42240, 42508 },
-	{ 42512, 42527 },
-	{ 42538, 42539 },
-	{ 42560, 42606 },
-	{ 42623, 42653 },
-	{ 42656, 42725 },
-	{ 42775, 42783 },
-	{ 42786, 42888 },
-	{ 42891, 42937 },
-	{ 42999, 43009 },
-	{ 43011, 43013 },
-	{ 43015, 43018 },
-	{ 43020, 43042 },
-	{ 43072, 43123 },
-	{ 43138, 43187 },
-	{ 43250, 43255 },
-	{ 43259, 43259 },
-	{ 43261, 43262 },
-	{ 43274, 43301 },
-	{ 43312, 43334 },
-	{ 43360, 43388 },
-	{ 43396, 43442 },
-	{ 43471, 43471 },
-	{ 43488, 43492 },
-	{ 43494, 43503 },
-	{ 43514, 43518 },
-	{ 43520, 43560 },
-	{ 43584, 43586 },
-	{ 43588, 43595 },
-	{ 43616, 43638 },
-	{ 43642, 43642 },
-	{ 43646, 43695 },
-	{ 43697, 43697 },
-	{ 43701, 43702 },
-	{ 43705, 43709 },
-	{ 43712, 43712 },
-	{ 43714, 43714 },
-	{ 43739, 43741 },
-	{ 43744, 43754 },
-	{ 43762, 43764 },
-	{ 43777, 43782 },
-	{ 43785, 43790 },
-	{ 43793, 43798 },
-	{ 43808, 43814 },
-	{ 43816, 43822 },
-	{ 43824, 43866 },
-	{ 43868, 43877 },
-	{ 43888, 44002 },
-	{ 44032, 55203 },
-	{ 55216, 55238 },
-	{ 55243, 55291 },
-	{ 63744, 64109 },
-	{ 64112, 64217 },
-	{ 64256, 64262 },
-	{ 64275, 64279 },
-	{ 64285, 64285 },
-	{ 64287, 64296 },
-	{ 64298, 64310 },
-	{ 64312, 64316 },
-	{ 64318, 64318 },
-	{ 64320, 64321 },
-	{ 64323, 64324 },
-	{ 64326, 64433 },
-	{ 64467, 64829 },
-	{ 64848, 64911 },
-	{ 64914, 64967 },
-	{ 65008, 65019 },
-	{ 65136, 65140 },
-	{ 65142, 65276 },
-	{ 65313, 65338 },
-	{ 65345, 65370 },
-	{ 65382, 65470 },
-	{ 65474, 65479 },
-	{ 65482, 65487 },
-	{ 65490, 65495 },
-	{ 65498, 65500 },
-};
-static const URange32 L_range32[] = {
-	{ 65536, 65547 },
-	{ 65549, 65574 },
-	{ 65576, 65594 },
-	{ 65596, 65597 },
-	{ 65599, 65613 },
-	{ 65616, 65629 },
-	{ 65664, 65786 },
-	{ 66176, 66204 },
-	{ 66208, 66256 },
-	{ 66304, 66335 },
-	{ 66349, 66368 },
-	{ 66370, 66377 },
-	{ 66384, 66421 },
-	{ 66432, 66461 },
-	{ 66464, 66499 },
-	{ 66504, 66511 },
-	{ 66560, 66717 },
-	{ 66736, 66771 },
-	{ 66776, 66811 },
-	{ 66816, 66855 },
-	{ 66864, 66915 },
-	{ 67072, 67382 },
-	{ 67392, 67413 },
-	{ 67424, 67431 },
-	{ 67584, 67589 },
-	{ 67592, 67592 },
-	{ 67594, 67637 },
-	{ 67639, 67640 },
-	{ 67644, 67644 },
-	{ 67647, 67669 },
-	{ 67680, 67702 },
-	{ 67712, 67742 },
-	{ 67808, 67826 },
-	{ 67828, 67829 },
-	{ 67840, 67861 },
-	{ 67872, 67897 },
-	{ 67968, 68023 },
-	{ 68030, 68031 },
-	{ 68096, 68096 },
-	{ 68112, 68115 },
-	{ 68117, 68119 },
-	{ 68121, 68149 },
-	{ 68192, 68220 },
-	{ 68224, 68252 },
-	{ 68288, 68295 },
-	{ 68297, 68324 },
-	{ 68352, 68405 },
-	{ 68416, 68437 },
-	{ 68448, 68466 },
-	{ 68480, 68497 },
-	{ 68608, 68680 },
-	{ 68736, 68786 },
-	{ 68800, 68850 },
-	{ 68864, 68899 },
-	{ 69376, 69404 },
-	{ 69415, 69415 },
-	{ 69424, 69445 },
-	{ 69635, 69687 },
-	{ 69763, 69807 },
-	{ 69840, 69864 },
-	{ 69891, 69926 },
-	{ 69956, 69956 },
-	{ 69968, 70002 },
-	{ 70006, 70006 },
-	{ 70019, 70066 },
-	{ 70081, 70084 },
-	{ 70106, 70106 },
-	{ 70108, 70108 },
-	{ 70144, 70161 },
-	{ 70163, 70187 },
-	{ 70272, 70278 },
-	{ 70280, 70280 },
-	{ 70282, 70285 },
-	{ 70287, 70301 },
-	{ 70303, 70312 },
-	{ 70320, 70366 },
-	{ 70405, 70412 },
-	{ 70415, 70416 },
-	{ 70419, 70440 },
-	{ 70442, 70448 },
-	{ 70450, 70451 },
-	{ 70453, 70457 },
-	{ 70461, 70461 },
-	{ 70480, 70480 },
-	{ 70493, 70497 },
-	{ 70656, 70708 },
-	{ 70727, 70730 },
-	{ 70784, 70831 },
-	{ 70852, 70853 },
-	{ 70855, 70855 },
-	{ 71040, 71086 },
-	{ 71128, 71131 },
-	{ 71168, 71215 },
-	{ 71236, 71236 },
-	{ 71296, 71338 },
-	{ 71424, 71450 },
-	{ 71680, 71723 },
-	{ 71840, 71903 },
-	{ 71935, 71935 },
-	{ 72192, 72192 },
-	{ 72203, 72242 },
-	{ 72250, 72250 },
-	{ 72272, 72272 },
-	{ 72284, 72323 },
-	{ 72326, 72329 },
-	{ 72349, 72349 },
-	{ 72384, 72440 },
-	{ 72704, 72712 },
-	{ 72714, 72750 },
-	{ 72768, 72768 },
-	{ 72818, 72847 },
-	{ 72960, 72966 },
-	{ 72968, 72969 },
-	{ 72971, 73008 },
-	{ 73030, 73030 },
-	{ 73056, 73061 },
-	{ 73063, 73064 },
-	{ 73066, 73097 },
-	{ 73112, 73112 },
-	{ 73440, 73458 },
-	{ 73728, 74649 },
-	{ 74880, 75075 },
-	{ 77824, 78894 },
-	{ 82944, 83526 },
-	{ 92160, 92728 },
-	{ 92736, 92766 },
-	{ 92880, 92909 },
-	{ 92928, 92975 },
-	{ 92992, 92995 },
-	{ 93027, 93047 },
-	{ 93053, 93071 },
-	{ 93760, 93823 },
-	{ 93952, 94020 },
-	{ 94032, 94032 },
-	{ 94099, 94111 },
-	{ 94176, 94177 },
-	{ 94208, 100337 },
-	{ 100352, 101106 },
-	{ 110592, 110878 },
-	{ 110960, 111355 },
-	{ 113664, 113770 },
-	{ 113776, 113788 },
-	{ 113792, 113800 },
-	{ 113808, 113817 },
-	{ 119808, 119892 },
-	{ 119894, 119964 },
-	{ 119966, 119967 },
-	{ 119970, 119970 },
-	{ 119973, 119974 },
-	{ 119977, 119980 },
-	{ 119982, 119993 },
-	{ 119995, 119995 },
-	{ 119997, 120003 },
-	{ 120005, 120069 },
-	{ 120071, 120074 },
-	{ 120077, 120084 },
-	{ 120086, 120092 },
-	{ 120094, 120121 },
-	{ 120123, 120126 },
-	{ 120128, 120132 },
-	{ 120134, 120134 },
-	{ 120138, 120144 },
-	{ 120146, 120485 },
-	{ 120488, 120512 },
-	{ 120514, 120538 },
-	{ 120540, 120570 },
-	{ 120572, 120596 },
-	{ 120598, 120628 },
-	{ 120630, 120654 },
-	{ 120656, 120686 },
-	{ 120688, 120712 },
-	{ 120714, 120744 },
-	{ 120746, 120770 },
-	{ 120772, 120779 },
-	{ 124928, 125124 },
-	{ 125184, 125251 },
-	{ 126464, 126467 },
-	{ 126469, 126495 },
-	{ 126497, 126498 },
-	{ 126500, 126500 },
-	{ 126503, 126503 },
-	{ 126505, 126514 },
-	{ 126516, 126519 },
-	{ 126521, 126521 },
-	{ 126523, 126523 },
-	{ 126530, 126530 },
-	{ 126535, 126535 },
-	{ 126537, 126537 },
-	{ 126539, 126539 },
-	{ 126541, 126543 },
-	{ 126545, 126546 },
-	{ 126548, 126548 },
-	{ 126551, 126551 },
-	{ 126553, 126553 },
-	{ 126555, 126555 },
-	{ 126557, 126557 },
-	{ 126559, 126559 },
-	{ 126561, 126562 },
-	{ 126564, 126564 },
-	{ 126567, 126570 },
-	{ 126572, 126578 },
-	{ 126580, 126583 },
-	{ 126585, 126588 },
-	{ 126590, 126590 },
-	{ 126592, 126601 },
-	{ 126603, 126619 },
-	{ 126625, 126627 },
-	{ 126629, 126633 },
-	{ 126635, 126651 },
-	{ 131072, 173782 },
-	{ 173824, 177972 },
-	{ 177984, 178205 },
-	{ 178208, 183969 },
-	{ 183984, 191456 },
-	{ 194560, 195101 },
-};
-static const URange16 N_range16[] = {
-	{ 48, 57 },
-	{ 178, 179 },
-	{ 185, 185 },
-	{ 188, 190 },
-	{ 1632, 1641 },
-	{ 1776, 1785 },
-	{ 1984, 1993 },
-	{ 2406, 2415 },
-	{ 2534, 2543 },
-	{ 2548, 2553 },
-	{ 2662, 2671 },
-	{ 2790, 2799 },
-	{ 2918, 2927 },
-	{ 2930, 2935 },
-	{ 3046, 3058 },
-	{ 3174, 3183 },
-	{ 3192, 3198 },
-	{ 3302, 3311 },
-	{ 3416, 3422 },
-	{ 3430, 3448 },
-	{ 3558, 3567 },
-	{ 3664, 3673 },
-	{ 3792, 3801 },
-	{ 3872, 3891 },
-	{ 4160, 4169 },
-	{ 4240, 4249 },
-	{ 4969, 4988 },
-	{ 5870, 5872 },
-	{ 6112, 6121 },
-	{ 6128, 6137 },
-	{ 6160, 6169 },
-	{ 6470, 6479 },
-	{ 6608, 6618 },
-	{ 6784, 6793 },
-	{ 6800, 6809 },
-	{ 6992, 7001 },
-	{ 7088, 7097 },
-	{ 7232, 7241 },
-	{ 7248, 7257 },
-	{ 8304, 8304 },
-	{ 8308, 8313 },
-	{ 8320, 8329 },
-	{ 8528, 8578 },
-	{ 8581, 8585 },
-	{ 9312, 9371 },
-	{ 9450, 9471 },
-	{ 10102, 10131 },
-	{ 11517, 11517 },
-	{ 12295, 12295 },
-	{ 12321, 12329 },
-	{ 12344, 12346 },
-	{ 12690, 12693 },
-	{ 12832, 12841 },
-	{ 12872, 12879 },
-	{ 12881, 12895 },
-	{ 12928, 12937 },
-	{ 12977, 12991 },
-	{ 42528, 42537 },
-	{ 42726, 42735 },
-	{ 43056, 43061 },
-	{ 43216, 43225 },
-	{ 43264, 43273 },
-	{ 43472, 43481 },
-	{ 43504, 43513 },
-	{ 43600, 43609 },
-	{ 44016, 44025 },
-	{ 65296, 65305 },
-};
-static const URange32 N_range32[] = {
-	{ 65799, 65843 },
-	{ 65856, 65912 },
-	{ 65930, 65931 },
-	{ 66273, 66299 },
-	{ 66336, 66339 },
-	{ 66369, 66369 },
-	{ 66378, 66378 },
-	{ 66513, 66517 },
-	{ 66720, 66729 },
-	{ 67672, 67679 },
-	{ 67705, 67711 },
-	{ 67751, 67759 },
-	{ 67835, 67839 },
-	{ 67862, 67867 },
-	{ 68028, 68029 },
-	{ 68032, 68047 },
-	{ 68050, 68095 },
-	{ 68160, 68168 },
-	{ 68221, 68222 },
-	{ 68253, 68255 },
-	{ 68331, 68335 },
-	{ 68440, 68447 },
-	{ 68472, 68479 },
-	{ 68521, 68527 },
-	{ 68858, 68863 },
-	{ 68912, 68921 },
-	{ 69216, 69246 },
-	{ 69405, 69414 },
-	{ 69457, 69460 },
-	{ 69714, 69743 },
-	{ 69872, 69881 },
-	{ 69942, 69951 },
-	{ 70096, 70105 },
-	{ 70113, 70132 },
-	{ 70384, 70393 },
-	{ 70736, 70745 },
-	{ 70864, 70873 },
-	{ 71248, 71257 },
-	{ 71360, 71369 },
-	{ 71472, 71483 },
-	{ 71904, 71922 },
-	{ 72784, 72812 },
-	{ 73040, 73049 },
-	{ 73120, 73129 },
-	{ 74752, 74862 },
-	{ 92768, 92777 },
-	{ 93008, 93017 },
-	{ 93019, 93025 },
-	{ 93824, 93846 },
-	{ 119520, 119539 },
-	{ 119648, 119672 },
-	{ 120782, 120831 },
-	{ 125127, 125135 },
-	{ 125264, 125273 },
-	{ 126065, 126123 },
-	{ 126125, 126127 },
-	{ 126129, 126132 },
-	{ 127232, 127244 },
-};
-static const URange16 Sk_range16[] = {
-	{ 94, 94 },
-	{ 96, 96 },
-	{ 168, 168 },
-	{ 175, 175 },
-	{ 180, 180 },
-	{ 184, 184 },
-	{ 706, 709 },
-	{ 722, 735 },
-	{ 741, 747 },
-	{ 749, 749 },
-	{ 751, 767 },
-	{ 885, 885 },
-	{ 900, 901 },
-	{ 8125, 8125 },
-	{ 8127, 8129 },
-	{ 8141, 8143 },
-	{ 8157, 8159 },
-	{ 8173, 8175 },
-	{ 8189, 8190 },
-	{ 12443, 12444 },
-	{ 42752, 42774 },
-	{ 42784, 42785 },
-	{ 42889, 42890 },
-	{ 43867, 43867 },
-	{ 64434, 64449 },
-	{ 65342, 65342 },
-	{ 65344, 65344 },
-	{ 65507, 65507 },
-};
-static const URange32 Sk_range32[] = {
-	{ 127995, 127999 },
-};
-static const URange16 P_range16[] = {
-	{ 33, 35 },
-	{ 37, 42 },
-	{ 44, 47 },
-	{ 58, 59 },
-	{ 63, 64 },
-	{ 91, 93 },
-	{ 95, 95 },
-	{ 123, 123 },
-	{ 125, 125 },
-	{ 161, 161 },
-	{ 167, 167 },
-	{ 171, 171 },
-	{ 182, 183 },
-	{ 187, 187 },
-	{ 191, 191 },
-	{ 894, 894 },
-	{ 903, 903 },
-	{ 1370, 1375 },
-	{ 1417, 1418 },
-	{ 1470, 1470 },
-	{ 1472, 1472 },
-	{ 1475, 1475 },
-	{ 1478, 1478 },
-	{ 1523, 1524 },
-	{ 1545, 1546 },
-	{ 1548, 1549 },
-	{ 1563, 1563 },
-	{ 1566, 1567 },
-	{ 1642, 1645 },
-	{ 1748, 1748 },
-	{ 1792, 1805 },
-	{ 2039, 2041 },
-	{ 2096, 2110 },
-	{ 2142, 2142 },
-	{ 2404, 2405 },
-	{ 2416, 2416 },
-	{ 2557, 2557 },
-	{ 2678, 2678 },
-	{ 2800, 2800 },
-	{ 3204, 3204 },
-	{ 3572, 3572 },
-	{ 3663, 3663 },
-	{ 3674, 3675 },
-	{ 3844, 3858 },
-	{ 3860, 3860 },
-	{ 3898, 3901 },
-	{ 3973, 3973 },
-	{ 4048, 4052 },
-	{ 4057, 4058 },
-	{ 4170, 4175 },
-	{ 4347, 4347 },
-	{ 4960, 4968 },
-	{ 5120, 5120 },
-	{ 5741, 5742 },
-	{ 5787, 5788 },
-	{ 5867, 5869 },
-	{ 5941, 5942 },
-	{ 6100, 6102 },
-	{ 6104, 6106 },
-	{ 6144, 6154 },
-	{ 6468, 6469 },
-	{ 6686, 6687 },
-	{ 6816, 6822 },
-	{ 6824, 6829 },
-	{ 7002, 7008 },
-	{ 7164, 7167 },
-	{ 7227, 7231 },
-	{ 7294, 7295 },
-	{ 7360, 7367 },
-	{ 7379, 7379 },
-	{ 8208, 8231 },
-	{ 8240, 8259 },
-	{ 8261, 8273 },
-	{ 8275, 8286 },
-	{ 8317, 8318 },
-	{ 8333, 8334 },
-	{ 8968, 8971 },
-	{ 9001, 9002 },
-	{ 10088, 10101 },
-	{ 10181, 10182 },
-	{ 10214, 10223 },
-	{ 10627, 10648 },
-	{ 10712, 10715 },
-	{ 10748, 10749 },
-	{ 11513, 11516 },
-	{ 11518, 11519 },
-	{ 11632, 11632 },
-	{ 11776, 11822 },
-	{ 11824, 11854 },
-	{ 12289, 12291 },
-	{ 12296, 12305 },
-	{ 12308, 12319 },
-	{ 12336, 12336 },
-	{ 12349, 12349 },
-	{ 12448, 12448 },
-	{ 12539, 12539 },
-	{ 42238, 42239 },
-	{ 42509, 42511 },
-	{ 42611, 42611 },
-	{ 42622, 42622 },
-	{ 42738, 42743 },
-	{ 43124, 43127 },
-	{ 43214, 43215 },
-	{ 43256, 43258 },
-	{ 43260, 43260 },
-	{ 43310, 43311 },
-	{ 43359, 43359 },
-	{ 43457, 43469 },
-	{ 43486, 43487 },
-	{ 43612, 43615 },
-	{ 43742, 43743 },
-	{ 43760, 43761 },
-	{ 44011, 44011 },
-	{ 64830, 64831 },
-	{ 65040, 65049 },
-	{ 65072, 65106 },
-	{ 65108, 65121 },
-	{ 65123, 65123 },
-	{ 65128, 65128 },
-	{ 65130, 65131 },
-	{ 65281, 65283 },
-	{ 65285, 65290 },
-	{ 65292, 65295 },
-	{ 65306, 65307 },
-	{ 65311, 65312 },
-	{ 65339, 65341 },
-	{ 65343, 65343 },
-	{ 65371, 65371 },
-	{ 65373, 65373 },
-	{ 65375, 65381 },
-};
-static const URange32 P_range32[] = {
-	{ 65792, 65794 },
-	{ 66463, 66463 },
-	{ 66512, 66512 },
-	{ 66927, 66927 },
-	{ 67671, 67671 },
-	{ 67871, 67871 },
-	{ 67903, 67903 },
-	{ 68176, 68184 },
-	{ 68223, 68223 },
-	{ 68336, 68342 },
-	{ 68409, 68415 },
-	{ 68505, 68508 },
-	{ 69461, 69465 },
-	{ 69703, 69709 },
-	{ 69819, 69820 },
-	{ 69822, 69825 },
-	{ 69952, 69955 },
-	{ 70004, 70005 },
-	{ 70085, 70088 },
-	{ 70093, 70093 },
-	{ 70107, 70107 },
-	{ 70109, 70111 },
-	{ 70200, 70205 },
-	{ 70313, 70313 },
-	{ 70731, 70735 },
-	{ 70747, 70747 },
-	{ 70749, 70749 },
-	{ 70854, 70854 },
-	{ 71105, 71127 },
-	{ 71233, 71235 },
-	{ 71264, 71276 },
-	{ 71484, 71486 },
-	{ 71739, 71739 },
-	{ 72255, 72262 },
-	{ 72346, 72348 },
-	{ 72350, 72354 },
-	{ 72769, 72773 },
-	{ 72816, 72817 },
-	{ 73463, 73464 },
-	{ 74864, 74868 },
-	{ 92782, 92783 },
-	{ 92917, 92917 },
-	{ 92983, 92987 },
-	{ 92996, 92996 },
-	{ 93847, 93850 },
-	{ 113823, 113823 },
-	{ 121479, 121483 },
-	{ 125278, 125279 },
-};
-static const URange16 S_range16[] = {
-	{ 36, 36 },
-	{ 43, 43 },
-	{ 60, 62 },
-	{ 94, 94 },
-	{ 96, 96 },
-	{ 124, 124 },
-	{ 126, 126 },
-	{ 162, 166 },
-	{ 168, 169 },
-	{ 172, 172 },
-	{ 174, 177 },
-	{ 180, 180 },
-	{ 184, 184 },
-	{ 215, 215 },
-	{ 247, 247 },
-	{ 706, 709 },
-	{ 722, 735 },
-	{ 741, 747 },
-	{ 749, 749 },
-	{ 751, 767 },
-	{ 885, 885 },
-	{ 900, 901 },
-	{ 1014, 1014 },
-	{ 1154, 1154 },
-	{ 1421, 1423 },
-	{ 1542, 1544 },
-	{ 1547, 1547 },
-	{ 1550, 1551 },
-	{ 1758, 1758 },
-	{ 1769, 1769 },
-	{ 1789, 1790 },
-	{ 2038, 2038 },
-	{ 2046, 2047 },
-	{ 2546, 2547 },
-	{ 2554, 2555 },
-	{ 2801, 2801 },
-	{ 2928, 2928 },
-	{ 3059, 3066 },
-	{ 3199, 3199 },
-	{ 3407, 3407 },
-	{ 3449, 3449 },
-	{ 3647, 3647 },
-	{ 3841, 3843 },
-	{ 3859, 3859 },
-	{ 3861, 3863 },
-	{ 3866, 3871 },
-	{ 3892, 3892 },
-	{ 3894, 3894 },
-	{ 3896, 3896 },
-	{ 4030, 4037 },
-	{ 4039, 4044 },
-	{ 4046, 4047 },
-	{ 4053, 4056 },
-	{ 4254, 4255 },
-	{ 5008, 5017 },
-	{ 6107, 6107 },
-	{ 6464, 6464 },
-	{ 6622, 6655 },
-	{ 7009, 7018 },
-	{ 7028, 7036 },
-	{ 8125, 8125 },
-	{ 8127, 8129 },
-	{ 8141, 8143 },
-	{ 8157, 8159 },
-	{ 8173, 8175 },
-	{ 8189, 8190 },
-	{ 8260, 8260 },
-	{ 8274, 8274 },
-	{ 8314, 8316 },
-	{ 8330, 8332 },
-	{ 8352, 8383 },
-	{ 8448, 8449 },
-	{ 8451, 8454 },
-	{ 8456, 8457 },
-	{ 8468, 8468 },
-	{ 8470, 8472 },
-	{ 8478, 8483 },
-	{ 8485, 8485 },
-	{ 8487, 8487 },
-	{ 8489, 8489 },
-	{ 8494, 8494 },
-	{ 8506, 8507 },
-	{ 8512, 8516 },
-	{ 8522, 8525 },
-	{ 8527, 8527 },
-	{ 8586, 8587 },
-	{ 8592, 8967 },
-	{ 8972, 9000 },
-	{ 9003, 9254 },
-	{ 9280, 9290 },
-	{ 9372, 9449 },
-	{ 9472, 10087 },
-	{ 10132, 10180 },
-	{ 10183, 10213 },
-	{ 10224, 10626 },
-	{ 10649, 10711 },
-	{ 10716, 10747 },
-	{ 10750, 11123 },
-	{ 11126, 11157 },
-	{ 11160, 11208 },
-	{ 11210, 11262 },
-	{ 11493, 11498 },
-	{ 11904, 11929 },
-	{ 11931, 12019 },
-	{ 12032, 12245 },
-	{ 12272, 12283 },
-	{ 12292, 12292 },
-	{ 12306, 12307 },
-	{ 12320, 12320 },
-	{ 12342, 12343 },
-	{ 12350, 12351 },
-	{ 12443, 12444 },
-	{ 12688, 12689 },
-	{ 12694, 12703 },
-	{ 12736, 12771 },
-	{ 12800, 12830 },
-	{ 12842, 12871 },
-	{ 12880, 12880 },
-	{ 12896, 12927 },
-	{ 12938, 12976 },
-	{ 12992, 13054 },
-	{ 13056, 13311 },
-	{ 19904, 19967 },
-	{ 42128, 42182 },
-	{ 42752, 42774 },
-	{ 42784, 42785 },
-	{ 42889, 42890 },
-	{ 43048, 43051 },
-	{ 43062, 43065 },
-	{ 43639, 43641 },
-	{ 43867, 43867 },
-	{ 64297, 64297 },
-	{ 64434, 64449 },
-	{ 65020, 65021 },
-	{ 65122, 65122 },
-	{ 65124, 65126 },
-	{ 65129, 65129 },
-	{ 65284, 65284 },
-	{ 65291, 65291 },
-	{ 65308, 65310 },
-	{ 65342, 65342 },
-	{ 65344, 65344 },
-	{ 65372, 65372 },
-	{ 65374, 65374 },
-	{ 65504, 65510 },
-	{ 65512, 65518 },
-	{ 65532, 65533 },
+static const URange16 Lo_range16[] = {
+	{ 170, 170 },
+	{ 186, 186 },
+	{ 443, 443 },
+	{ 448, 451 },
+	{ 660, 660 },
+	{ 1488, 1514 },
+	{ 1519, 1522 },
+	{ 1568, 1599 },
+	{ 1601, 1610 },
+	{ 1646, 1647 },
+	{ 1649, 1747 },
+	{ 1749, 1749 },
+	{ 1774, 1775 },
+	{ 1786, 1788 },
+	{ 1791, 1791 },
+	{ 1808, 1808 },
+	{ 1810, 1839 },
+	{ 1869, 1957 },
+	{ 1969, 1969 },
+	{ 1994, 2026 },
+	{ 2048, 2069 },
+	{ 2112, 2136 },
+	{ 2144, 2154 },
+	{ 2160, 2183 },
+	{ 2185, 2190 },
+	{ 2208, 2248 },
+	{ 2308, 2361 },
+	{ 2365, 2365 },
+	{ 2384, 2384 },
+	{ 2392, 2401 },
+	{ 2418, 2432 },
+	{ 2437, 2444 },
+	{ 2447, 2448 },
+	{ 2451, 2472 },
+	{ 2474, 2480 },
+	{ 2482, 2482 },
+	{ 2486, 2489 },
+	{ 2493, 2493 },
+	{ 2510, 2510 },
+	{ 2524, 2525 },
+	{ 2527, 2529 },
+	{ 2544, 2545 },
+	{ 2556, 2556 },
+	{ 2565, 2570 },
+	{ 2575, 2576 },
+	{ 2579, 2600 },
+	{ 2602, 2608 },
+	{ 2610, 2611 },
+	{ 2613, 2614 },
+	{ 2616, 2617 },
+	{ 2649, 2652 },
+	{ 2654, 2654 },
+	{ 2674, 2676 },
+	{ 2693, 2701 },
+	{ 2703, 2705 },
+	{ 2707, 2728 },
+	{ 2730, 2736 },
+	{ 2738, 2739 },
+	{ 2741, 2745 },
+	{ 2749, 2749 },
+	{ 2768, 2768 },
+	{ 2784, 2785 },
+	{ 2809, 2809 },
+	{ 2821, 2828 },
+	{ 2831, 2832 },
+	{ 2835, 2856 },
+	{ 2858, 2864 },
+	{ 2866, 2867 },
+	{ 2869, 2873 },
+	{ 2877, 2877 },
+	{ 2908, 2909 },
+	{ 2911, 2913 },
+	{ 2929, 2929 },
+	{ 2947, 2947 },
+	{ 2949, 2954 },
+	{ 2958, 2960 },
+	{ 2962, 2965 },
+	{ 2969, 2970 },
+	{ 2972, 2972 },
+	{ 2974, 2975 },
+	{ 2979, 2980 },
+	{ 2984, 2986 },
+	{ 2990, 3001 },
+	{ 3024, 3024 },
+	{ 3077, 3084 },
+	{ 3086, 3088 },
+	{ 3090, 3112 },
+	{ 3114, 3129 },
+	{ 3133, 3133 },
+	{ 3160, 3162 },
+	{ 3165, 3165 },
+	{ 3168, 3169 },
+	{ 3200, 3200 },
+	{ 3205, 3212 },
+	{ 3214, 3216 },
+	{ 3218, 3240 },
+	{ 3242, 3251 },
+	{ 3253, 3257 },
+	{ 3261, 3261 },
+	{ 3293, 3294 },
+	{ 3296, 3297 },
+	{ 3313, 3314 },
+	{ 3332, 3340 },
+	{ 3342, 3344 },
+	{ 3346, 3386 },
+	{ 3389, 3389 },
+	{ 3406, 3406 },
+	{ 3412, 3414 },
+	{ 3423, 3425 },
+	{ 3450, 3455 },
+	{ 3461, 3478 },
+	{ 3482, 3505 },
+	{ 3507, 3515 },
+	{ 3517, 3517 },
+	{ 3520, 3526 },
+	{ 3585, 3632 },
+	{ 3634, 3635 },
+	{ 3648, 3653 },
+	{ 3713, 3714 },
+	{ 3716, 3716 },
+	{ 3718, 3722 },
+	{ 3724, 3747 },
+	{ 3749, 3749 },
+	{ 3751, 3760 },
+	{ 3762, 3763 },
+	{ 3773, 3773 },
+	{ 3776, 3780 },
+	{ 3804, 3807 },
+	{ 3840, 3840 },
+	{ 3904, 3911 },
+	{ 3913, 3948 },
+	{ 3976, 3980 },
+	{ 4096, 4138 },
+	{ 4159, 4159 },
+	{ 4176, 4181 },
+	{ 4186, 4189 },
+	{ 4193, 4193 },
+	{ 4197, 4198 },
+	{ 4206, 4208 },
+	{ 4213, 4225 },
+	{ 4238, 4238 },
+	{ 4352, 4680 },
+	{ 4682, 4685 },
+	{ 4688, 4694 },
+	{ 4696, 4696 },
+	{ 4698, 4701 },
+	{ 4704, 4744 },
+	{ 4746, 4749 },
+	{ 4752, 4784 },
+	{ 4786, 4789 },
+	{ 4792, 4798 },
+	{ 4800, 4800 },
+	{ 4802, 4805 },
+	{ 4808, 4822 },
+	{ 4824, 4880 },
+	{ 4882, 4885 },
+	{ 4888, 4954 },
+	{ 4992, 5007 },
+	{ 5121, 5740 },
+	{ 5743, 5759 },
+	{ 5761, 5786 },
+	{ 5792, 5866 },
+	{ 5873, 5880 },
+	{ 5888, 5905 },
+	{ 5919, 5937 },
+	{ 5952, 5969 },
+	{ 5984, 5996 },
+	{ 5998, 6000 },
+	{ 6016, 6067 },
+	{ 6108, 6108 },
+	{ 6176, 6210 },
+	{ 6212, 6264 },
+	{ 6272, 6276 },
+	{ 6279, 6312 },
+	{ 6314, 6314 },
+	{ 6320, 6389 },
+	{ 6400, 6430 },
+	{ 6480, 6509 },
+	{ 6512, 6516 },
+	{ 6528, 6571 },
+	{ 6576, 6601 },
+	{ 6656, 6678 },
+	{ 6688, 6740 },
+	{ 6917, 6963 },
+	{ 6981, 6988 },
+	{ 7043, 7072 },
+	{ 7086, 7087 },
+	{ 7098, 7141 },
+	{ 7168, 7203 },
+	{ 7245, 7247 },
+	{ 7258, 7287 },
+	{ 7401, 7404 },
+	{ 7406, 7411 },
+	{ 7413, 7414 },
+	{ 7418, 7418 },
+	{ 8501, 8504 },
+	{ 11568, 11623 },
+	{ 11648, 11670 },
+	{ 11680, 11686 },
+	{ 11688, 11694 },
+	{ 11696, 11702 },
+	{ 11704, 11710 },
+	{ 11712, 11718 },
+	{ 11720, 11726 },
+	{ 11728, 11734 },
+	{ 11736, 11742 },
+	{ 12294, 12294 },
+	{ 12348, 12348 },
+	{ 12353, 12438 },
+	{ 12447, 12447 },
+	{ 12449, 12538 },
+	{ 12543, 12543 },
+	{ 12549, 12591 },
+	{ 12593, 12686 },
+	{ 12704, 12735 },
+	{ 12784, 12799 },
+	{ 13312, 19903 },
+	{ 19968, 40980 },
+	{ 40982, 42124 },
+	{ 42192, 42231 },
+	{ 42240, 42507 },
+	{ 42512, 42527 },
+	{ 42538, 42539 },
+	{ 42606, 42606 },
+	{ 42656, 42725 },
+	{ 42895, 42895 },
+	{ 42999, 42999 },
+	{ 43003, 43009 },
+	{ 43011, 43013 },
+	{ 43015, 43018 },
+	{ 43020, 43042 },
+	{ 43072, 43123 },
+	{ 43138, 43187 },
+	{ 43250, 43255 },
+	{ 43259, 43259 },
+	{ 43261, 43262 },
+	{ 43274, 43301 },
+	{ 43312, 43334 },
+	{ 43360, 43388 },
+	{ 43396, 43442 },
+	{ 43488, 43492 },
+	{ 43495, 43503 },
+	{ 43514, 43518 },
+	{ 43520, 43560 },
+	{ 43584, 43586 },
+	{ 43588, 43595 },
+	{ 43616, 43631 },
+	{ 43633, 43638 },
+	{ 43642, 43642 },
+	{ 43646, 43695 },
+	{ 43697, 43697 },
+	{ 43701, 43702 },
+	{ 43705, 43709 },
+	{ 43712, 43712 },
+	{ 43714, 43714 },
+	{ 43739, 43740 },
+	{ 43744, 43754 },
+	{ 43762, 43762 },
+	{ 43777, 43782 },
+	{ 43785, 43790 },
+	{ 43793, 43798 },
+	{ 43808, 43814 },
+	{ 43816, 43822 },
+	{ 43968, 44002 },
+	{ 44032, 55203 },
+	{ 55216, 55238 },
+	{ 55243, 55291 },
+	{ 63744, 64109 },
+	{ 64112, 64217 },
+	{ 64285, 64285 },
+	{ 64287, 64296 },
+	{ 64298, 64310 },
+	{ 64312, 64316 },
+	{ 64318, 64318 },
+	{ 64320, 64321 },
+	{ 64323, 64324 },
+	{ 64326, 64433 },
+	{ 64467, 64829 },
+	{ 64848, 64911 },
+	{ 64914, 64967 },
+	{ 65008, 65019 },
+	{ 65136, 65140 },
+	{ 65142, 65276 },
+	{ 65382, 65391 },
+	{ 65393, 65437 },
+	{ 65440, 65470 },
+	{ 65474, 65479 },
+	{ 65482, 65487 },
+	{ 65490, 65495 },
+	{ 65498, 65500 },
 };
-static const URange32 S_range32[] = {
-	{ 65847, 65855 },
-	{ 65913, 65929 },
-	{ 65932, 65934 },
-	{ 65936, 65947 },
-	{ 65952, 65952 },
-	{ 66000, 66044 },
-	{ 67703, 67704 },
-	{ 68296, 68296 },
-	{ 71487, 71487 },
-	{ 92988, 92991 },
-	{ 92997, 92997 },
-	{ 113820, 113820 },
-	{ 118784, 119029 },
-	{ 119040, 119078 },
-	{ 119081, 119140 },
-	{ 119146, 119148 },
-	{ 119171, 119172 },
-	{ 119180, 119209 },
-	{ 119214, 119272 },
-	{ 119296, 119361 },
-	{ 119365, 119365 },
-	{ 119552, 119638 },
-	{ 120513, 120513 },
-	{ 120539, 120539 },
-	{ 120571, 120571 },
-	{ 120597, 120597 },
-	{ 120629, 120629 },
-	{ 120655, 120655 },
-	{ 120687, 120687 },
-	{ 120713, 120713 },
-	{ 120745, 120745 },
-	{ 120771, 120771 },
-	{ 120832, 121343 },
-	{ 121399, 121402 },
-	{ 121453, 121460 },
-	{ 121462, 121475 },
-	{ 121477, 121478 },
-	{ 126124, 126124 },
-	{ 126128, 126128 },
-	{ 126704, 126705 },
-	{ 126976, 127019 },
-	{ 127024, 127123 },
-	{ 127136, 127150 },
-	{ 127153, 127167 },
-	{ 127169, 127183 },
-	{ 127185, 127221 },
-	{ 127248, 127339 },
-	{ 127344, 127404 },
-	{ 127462, 127490 },
-	{ 127504, 127547 },
-	{ 127552, 127560 },
-	{ 127568, 127569 },
-	{ 127584, 127589 },
-	{ 127744, 128724 },
-	{ 128736, 128748 },
-	{ 128752, 128761 },
-	{ 128768, 128883 },
-	{ 128896, 128984 },
-	{ 129024, 129035 },
-	{ 129040, 129095 },
-	{ 129104, 129113 },
-	{ 129120, 129159 },
-	{ 129168, 129197 },
-	{ 129280, 129291 },
-	{ 129296, 129342 },
-	{ 129344, 129392 },
-	{ 129395, 129398 },
-	{ 129402, 129402 },
-	{ 129404, 129442 },
-	{ 129456, 129465 },
-	{ 129472, 129474 },
-	{ 129488, 129535 },
-	{ 129632, 129645 },
+static const URange32 Lo_range32[] = {
+	{ 65536, 65547 },
+	{ 65549, 65574 },
+	{ 65576, 65594 },
+	{ 65596, 65597 },
+	{ 65599, 65613 },
+	{ 65616, 65629 },
+	{ 65664, 65786 },
+	{ 66176, 66204 },
+	{ 66208, 66256 },
+	{ 66304, 66335 },
+	{ 66349, 66368 },
+	{ 66370, 66377 },
+	{ 66384, 66421 },
+	{ 66432, 66461 },
+	{ 66464, 66499 },
+	{ 66504, 66511 },
+	{ 66640, 66717 },
+	{ 66816, 66855 },
+	{ 66864, 66915 },
+	{ 67072, 67382 },
+	{ 67392, 67413 },
+	{ 67424, 67431 },
+	{ 67584, 67589 },
+	{ 67592, 67592 },
+	{ 67594, 67637 },
+	{ 67639, 67640 },
+	{ 67644, 67644 },
+	{ 67647, 67669 },
+	{ 67680, 67702 },
+	{ 67712, 67742 },
+	{ 67808, 67826 },
+	{ 67828, 67829 },
+	{ 67840, 67861 },
+	{ 67872, 67897 },
+	{ 67968, 68023 },
+	{ 68030, 68031 },
+	{ 68096, 68096 },
+	{ 68112, 68115 },
+	{ 68117, 68119 },
+	{ 68121, 68149 },
+	{ 68192, 68220 },
+	{ 68224, 68252 },
+	{ 68288, 68295 },
+	{ 68297, 68324 },
+	{ 68352, 68405 },
+	{ 68416, 68437 },
+	{ 68448, 68466 },
+	{ 68480, 68497 },
+	{ 68608, 68680 },
+	{ 68864, 68899 },
+	{ 69248, 69289 },
+	{ 69296, 69297 },
+	{ 69376, 69404 },
+	{ 69415, 69415 },
+	{ 69424, 69445 },
+	{ 69488, 69505 },
+	{ 69552, 69572 },
+	{ 69600, 69622 },
+	{ 69635, 69687 },
+	{ 69745, 69746 },
+	{ 69749, 69749 },
+	{ 69763, 69807 },
+	{ 69840, 69864 },
+	{ 69891, 69926 },
+	{ 69956, 69956 },
+	{ 69959, 69959 },
+	{ 69968, 70002 },
+	{ 70006, 70006 },
+	{ 70019, 70066 },
+	{ 70081, 70084 },
+	{ 70106, 70106 },
+	{ 70108, 70108 },
+	{ 70144, 70161 },
+	{ 70163, 70187 },
+	{ 70207, 70208 },
+	{ 70272, 70278 },
+	{ 70280, 70280 },
+	{ 70282, 70285 },
+	{ 70287, 70301 },
+	{ 70303, 70312 },
+	{ 70320, 70366 },
+	{ 70405, 70412 },
+	{ 70415, 70416 },
+	{ 70419, 70440 },
+	{ 70442, 70448 },
+	{ 70450, 70451 },
+	{ 70453, 70457 },
+	{ 70461, 70461 },
+	{ 70480, 70480 },
+	{ 70493, 70497 },
+	{ 70656, 70708 },
+	{ 70727, 70730 },
+	{ 70751, 70753 },
+	{ 70784, 70831 },
+	{ 70852, 70853 },
+	{ 70855, 70855 },
+	{ 71040, 71086 },
+	{ 71128, 71131 },
+	{ 71168, 71215 },
+	{ 71236, 71236 },
+	{ 71296, 71338 },
+	{ 71352, 71352 },
+	{ 71424, 71450 },
+	{ 71488, 71494 },
+	{ 71680, 71723 },
+	{ 71935, 71942 },
+	{ 71945, 71945 },
+	{ 71948, 71955 },
+	{ 71957, 71958 },
+	{ 71960, 71983 },
+	{ 71999, 71999 },
+	{ 72001, 72001 },
+	{ 72096, 72103 },
+	{ 72106, 72144 },
+	{ 72161, 72161 },
+	{ 72163, 72163 },
+	{ 72192, 72192 },
+	{ 72203, 72242 },
+	{ 72250, 72250 },
+	{ 72272, 72272 },
+	{ 72284, 72329 },
+	{ 72349, 72349 },
+	{ 72368, 72440 },
+	{ 72704, 72712 },
+	{ 72714, 72750 },
+	{ 72768, 72768 },
+	{ 72818, 72847 },
+	{ 72960, 72966 },
+	{ 72968, 72969 },
+	{ 72971, 73008 },
+	{ 73030, 73030 },
+	{ 73056, 73061 },
+	{ 73063, 73064 },
+	{ 73066, 73097 },
+	{ 73112, 73112 },
+	{ 73440, 73458 },
+	{ 73474, 73474 },
+	{ 73476, 73488 },
+	{ 73490, 73523 },
+	{ 73648, 73648 },
+	{ 73728, 74649 },
+	{ 74880, 75075 },
+	{ 77712, 77808 },
+	{ 77824, 78895 },
+	{ 78913, 78918 },
+	{ 82944, 83526 },
+	{ 92160, 92728 },
+	{ 92736, 92766 },
+	{ 92784, 92862 },
+	{ 92880, 92909 },
+	{ 92928, 92975 },
+	{ 93027, 93047 },
+	{ 93053, 93071 },
+	{ 93952, 94026 },
+	{ 94032, 94032 },
+	{ 94208, 100343 },
+	{ 100352, 101589 },
+	{ 101632, 101640 },
+	{ 110592, 110882 },
+	{ 110898, 110898 },
+	{ 110928, 110930 },
+	{ 110933, 110933 },
+	{ 110948, 110951 },
+	{ 110960, 111355 },
+	{ 113664, 113770 },
+	{ 113776, 113788 },
+	{ 113792, 113800 },
+	{ 113808, 113817 },
+	{ 122634, 122634 },
+	{ 123136, 123180 },
+	{ 123214, 123214 },
+	{ 123536, 123565 },
+	{ 123584, 123627 },
+	{ 124112, 124138 },
+	{ 124896, 124902 },
+	{ 124904, 124907 },
+	{ 124909, 124910 },
+	{ 124912, 124926 },
+	{ 124928, 125124 },
+	{ 126464, 126467 },
+	{ 126469, 126495 },
+	{ 126497, 126498 },
+	{ 126500, 126500 },
+	{ 126503, 126503 },
+	{ 126505, 126514 },
+	{ 126516, 126519 },
+	{ 126521, 126521 },
+	{ 126523, 126523 },
+	{ 126530, 126530 },
+	{ 126535, 126535 },
+	{ 126537, 126537 },
+	{ 126539, 126539 },
+	{ 126541, 126543 },
+	{ 126545, 126546 },
+	{ 126548, 126548 },
+	{ 126551, 126551 },
+	{ 126553, 126553 },
+	{ 126555, 126555 },
+	{ 126557, 126557 },
+	{ 126559, 126559 },
+	{ 126561, 126562 },
+	{ 126564, 126564 },
+	{ 126567, 126570 },
+	{ 126572, 126578 },
+	{ 126580, 126583 },
+	{ 126585, 126588 },
+	{ 126590, 126590 },
+	{ 126592, 126601 },
+	{ 126603, 126619 },
+	{ 126625, 126627 },
+	{ 126629, 126633 },
+	{ 126635, 126651 },
+	{ 131072, 173791 },
+	{ 173824, 177977 },
+	{ 177984, 178205 },
+	{ 178208, 183969 },
+	{ 183984, 191456 },
+	{ 194560, 195101 },
+	{ 196608, 201546 },
+	{ 201552, 205743 },
 };
-static const URange16 So_range16[] = {
-	{ 166, 166 },
-	{ 169, 169 },
-	{ 174, 174 },
-	{ 176, 176 },
-	{ 1154, 1154 },
-	{ 1421, 1422 },
-	{ 1550, 1551 },
-	{ 1758, 1758 },
-	{ 1769, 1769 },
-	{ 1789, 1790 },
-	{ 2038, 2038 },
-	{ 2554, 2554 },
-	{ 2928, 2928 },
-	{ 3059, 3064 },
-	{ 3066, 3066 },
-	{ 3199, 3199 },
-	{ 3407, 3407 },
-	{ 3449, 3449 },
-	{ 3841, 3843 },
-	{ 3859, 3859 },
-	{ 3861, 3863 },
-	{ 3866, 3871 },
-	{ 3892, 3892 },
-	{ 3894, 3894 },
-	{ 3896, 3896 },
-	{ 4030, 4037 },
-	{ 4039, 4044 },
-	{ 4046, 4047 },
-	{ 4053, 4056 },
-	{ 4254, 4255 },
-	{ 5008, 5017 },
-	{ 6464, 6464 },
-	{ 6622, 6655 },
-	{ 7009, 7018 },
-	{ 7028, 7036 },
-	{ 8448, 8449 },
-	{ 8451, 8454 },
-	{ 8456, 8457 },
-	{ 8468, 8468 },
-	{ 8470, 8471 },
-	{ 8478, 8483 },
-	{ 8485, 8485 },
-	{ 8487, 8487 },
-	{ 8489, 8489 },
-	{ 8494, 8494 },
-	{ 8506, 8507 },
-	{ 8522, 8522 },
-	{ 8524, 8525 },
-	{ 8527, 8527 },
-	{ 8586, 8587 },
-	{ 8597, 8601 },
-	{ 8604, 8607 },
-	{ 8609, 8610 },
-	{ 8612, 8613 },
-	{ 8615, 8621 },
-	{ 8623, 8653 },
-	{ 8656, 8657 },
-	{ 8659, 8659 },
-	{ 8661, 8691 },
-	{ 8960, 8967 },
-	{ 8972, 8991 },
-	{ 8994, 9000 },
-	{ 9003, 9083 },
-	{ 9085, 9114 },
-	{ 9140, 9179 },
-	{ 9186, 9254 },
-	{ 9280, 9290 },
-	{ 9372, 9449 },
-	{ 9472, 9654 },
-	{ 9656, 9664 },
-	{ 9666, 9719 },
-	{ 9728, 9838 },
-	{ 9840, 10087 },
-	{ 10132, 10175 },
-	{ 10240, 10495 },
-	{ 11008, 11055 },
-	{ 11077, 11078 },
-	{ 11085, 11123 },
-	{ 11126, 11157 },
-	{ 11160, 11208 },
-	{ 11210, 11262 },
-	{ 11493, 11498 },
-	{ 11904, 11929 },
-	{ 11931, 12019 },
-	{ 12032, 12245 },
-	{ 12272, 12283 },
-	{ 12292, 12292 },
-	{ 12306, 12307 },
-	{ 12320, 12320 },
-	{ 12342, 12343 },
-	{ 12350, 12351 },
-	{ 12688, 12689 },
-	{ 12694, 12703 },
-	{ 12736, 12771 },
-	{ 12800, 12830 },
-	{ 12842, 12871 },
-	{ 12880, 12880 },
-	{ 12896, 12927 },
-	{ 12938, 12976 },
-	{ 12992, 13054 },
-	{ 13056, 13311 },
-	{ 19904, 19967 },
-	{ 42128, 42182 },
-	{ 43048, 43051 },
-	{ 43062, 43063 },
-	{ 43065, 43065 },
-	{ 43639, 43641 },
-	{ 65021, 65021 },
-	{ 65508, 65508 },
-	{ 65512, 65512 },
-	{ 65517, 65518 },
-	{ 65532, 65533 },
+static const URange16 Lt_range16[] = {
+	{ 453, 453 },
+	{ 456, 456 },
+	{ 459, 459 },
+	{ 498, 498 },
+	{ 8072, 8079 },
+	{ 8088, 8095 },
+	{ 8104, 8111 },
+	{ 8124, 8124 },
+	{ 8140, 8140 },
+	{ 8188, 8188 },
 };
-static const URange32 So_range32[] = {
-	{ 65847, 65855 },
-	{ 65913, 65929 },
-	{ 65932, 65934 },
-	{ 65936, 65947 },
-	{ 65952, 65952 },
-	{ 66000, 66044 },
-	{ 67703, 67704 },
-	{ 68296, 68296 },
-	{ 71487, 71487 },
-	{ 92988, 92991 },
-	{ 92997, 92997 },
-	{ 113820, 113820 },
-	{ 118784, 119029 },
-	{ 119040, 119078 },
-	{ 119081, 119140 },
-	{ 119146, 119148 },
-	{ 119171, 119172 },
-	{ 119180, 119209 },
-	{ 119214, 119272 },
-	{ 119296, 119361 },
-	{ 119365, 119365 },
-	{ 119552, 119638 },
-	{ 120832, 121343 },
-	{ 121399, 121402 },
-	{ 121453, 121460 },
-	{ 121462, 121475 },
-	{ 121477, 121478 },
-	{ 126124, 126124 },
-	{ 126976, 127019 },
-	{ 127024, 127123 },
-	{ 127136, 127150 },
-	{ 127153, 127167 },
-	{ 127169, 127183 },
-	{ 127185, 127221 },
-	{ 127248, 127339 },
-	{ 127344, 127404 },
-	{ 127462, 127490 },
-	{ 127504, 127547 },
-	{ 127552, 127560 },
-	{ 127568, 127569 },
-	{ 127584, 127589 },
-	{ 127744, 127994 },
-	{ 128000, 128724 },
-	{ 128736, 128748 },
-	{ 128752, 128761 },
-	{ 128768, 128883 },
-	{ 128896, 128984 },
-	{ 129024, 129035 },
-	{ 129040, 129095 },
-	{ 129104, 129113 },
-	{ 129120, 129159 },
-	{ 129168, 129197 },
-	{ 129280, 129291 },
-	{ 129296, 129342 },
-	{ 129344, 129392 },
-	{ 129395, 129398 },
-	{ 129402, 129402 },
-	{ 129404, 129442 },
-	{ 129456, 129465 },
-	{ 129472, 129474 },
-	{ 129488, 129535 },
-	{ 129632, 129645 },
+static const URange16 Lu_range16[] = {
+	{ 65, 90 },
+	{ 192, 214 },
+	{ 216, 222 },
+	{ 256, 256 },
+	{ 258, 258 },
+	{ 260, 260 },
+	{ 262, 262 },
+	{ 264, 264 },
+	{ 266, 266 },
+	{ 268, 268 },
+	{ 270, 270 },
+	{ 272, 272 },
+	{ 274, 274 },
+	{ 276, 276 },
+	{ 278, 278 },
+	{ 280, 280 },
+	{ 282, 282 },
+	{ 284, 284 },
+	{ 286, 286 },
+	{ 288, 288 },
+	{ 290, 290 },
+	{ 292, 292 },
+	{ 294, 294 },
+	{ 296, 296 },
+	{ 298, 298 },
+	{ 300, 300 },
+	{ 302, 302 },
+	{ 304, 304 },
+	{ 306, 306 },
+	{ 308, 308 },
+	{ 310, 310 },
+	{ 313, 313 },
+	{ 315, 315 },
+	{ 317, 317 },
+	{ 319, 319 },
+	{ 321, 321 },
+	{ 323, 323 },
+	{ 325, 325 },
+	{ 327, 327 },
+	{ 330, 330 },
+	{ 332, 332 },
+	{ 334, 334 },
+	{ 336, 336 },
+	{ 338, 338 },
+	{ 340, 340 },
+	{ 342, 342 },
+	{ 344, 344 },
+	{ 346, 346 },
+	{ 348, 348 },
+	{ 350, 350 },
+	{ 352, 352 },
+	{ 354, 354 },
+	{ 356, 356 },
+	{ 358, 358 },
+	{ 360, 360 },
+	{ 362, 362 },
+	{ 364, 364 },
+	{ 366, 366 },
+	{ 368, 368 },
+	{ 370, 370 },
+	{ 372, 372 },
+	{ 374, 374 },
+	{ 376, 377 },
+	{ 379, 379 },
+	{ 381, 381 },
+	{ 385, 386 },
+	{ 388, 388 },
+	{ 390, 391 },
+	{ 393, 395 },
+	{ 398, 401 },
+	{ 403, 404 },
+	{ 406, 408 },
+	{ 412, 413 },
+	{ 415, 416 },
+	{ 418, 418 },
+	{ 420, 420 },
+	{ 422, 423 },
+	{ 425, 425 },
+	{ 428, 428 },
+	{ 430, 431 },
+	{ 433, 435 },
+	{ 437, 437 },
+	{ 439, 440 },
+	{ 444, 444 },
+	{ 452, 452 },
+	{ 455, 455 },
+	{ 458, 458 },
+	{ 461, 461 },
+	{ 463, 463 },
+	{ 465, 465 },
+	{ 467, 467 },
+	{ 469, 469 },
+	{ 471, 471 },
+	{ 473, 473 },
+	{ 475, 475 },
+	{ 478, 478 },
+	{ 480, 480 },
+	{ 482, 482 },
+	{ 484, 484 },
+	{ 486, 486 },
+	{ 488, 488 },
+	{ 490, 490 },
+	{ 492, 492 },
+	{ 494, 494 },
+	{ 497, 497 },
+	{ 500, 500 },
+	{ 502, 504 },
+	{ 506, 506 },
+	{ 508, 508 },
+	{ 510, 510 },
+	{ 512, 512 },
+	{ 514, 514 },
+	{ 516, 516 },
+	{ 518, 518 },
+	{ 520, 520 },
+	{ 522, 522 },
+	{ 524, 524 },
+	{ 526, 526 },
+	{ 528, 528 },
+	{ 530, 530 },
+	{ 532, 532 },
+	{ 534, 534 },
+	{ 536, 536 },
+	{ 538, 538 },
+	{ 540, 540 },
+	{ 542, 542 },
+	{ 544, 544 },
+	{ 546, 546 },
+	{ 548, 548 },
+	{ 550, 550 },
+	{ 552, 552 },
+	{ 554, 554 },
+	{ 556, 556 },
+	{ 558, 558 },
+	{ 560, 560 },
+	{ 562, 562 },
+	{ 570, 571 },
+	{ 573, 574 },
+	{ 577, 577 },
+	{ 579, 582 },
+	{ 584, 584 },
+	{ 586, 586 },
+	{ 588, 588 },
+	{ 590, 590 },
+	{ 880, 880 },
+	{ 882, 882 },
+	{ 886, 886 },
+	{ 895, 895 },
+	{ 902, 902 },
+	{ 904, 906 },
+	{ 908, 908 },
+	{ 910, 911 },
+	{ 913, 929 },
+	{ 931, 939 },
+	{ 975, 975 },
+	{ 978, 980 },
+	{ 984, 984 },
+	{ 986, 986 },
+	{ 988, 988 },
+	{ 990, 990 },
+	{ 992, 992 },
+	{ 994, 994 },
+	{ 996, 996 },
+	{ 998, 998 },
+	{ 1000, 1000 },
+	{ 1002, 1002 },
+	{ 1004, 1004 },
+	{ 1006, 1006 },
+	{ 1012, 1012 },
+	{ 1015, 1015 },
+	{ 1017, 1018 },
+	{ 1021, 1071 },
+	{ 1120, 1120 },
+	{ 1122, 1122 },
+	{ 1124, 1124 },
+	{ 1126, 1126 },
+	{ 1128, 1128 },
+	{ 1130, 1130 },
+	{ 1132, 1132 },
+	{ 1134, 1134 },
+	{ 1136, 1136 },
+	{ 1138, 1138 },
+	{ 1140, 1140 },
+	{ 1142, 1142 },
+	{ 1144, 1144 },
+	{ 1146, 1146 },
+	{ 1148, 1148 },
+	{ 1150, 1150 },
+	{ 1152, 1152 },
+	{ 1162, 1162 },
+	{ 1164, 1164 },
+	{ 1166, 1166 },
+	{ 1168, 1168 },
+	{ 1170, 1170 },
+	{ 1172, 1172 },
+	{ 1174, 1174 },
+	{ 1176, 1176 },
+	{ 1178, 1178 },
+	{ 1180, 1180 },
+	{ 1182, 1182 },
+	{ 1184, 1184 },
+	{ 1186, 1186 },
+	{ 1188, 1188 },
+	{ 1190, 1190 },
+	{ 1192, 1192 },
+	{ 1194, 1194 },
+	{ 1196, 1196 },
+	{ 1198, 1198 },
+	{ 1200, 1200 },
+	{ 1202, 1202 },
+	{ 1204, 1204 },
+	{ 1206, 1206 },
+	{ 1208, 1208 },
+	{ 1210, 1210 },
+	{ 1212, 1212 },
+	{ 1214, 1214 },
+	{ 1216, 1217 },
+	{ 1219, 1219 },
+	{ 1221, 1221 },
+	{ 1223, 1223 },
+	{ 1225, 1225 },
+	{ 1227, 1227 },
+	{ 1229, 1229 },
+	{ 1232, 1232 },
+	{ 1234, 1234 },
+	{ 1236, 1236 },
+	{ 1238, 1238 },
+	{ 1240, 1240 },
+	{ 1242, 1242 },
+	{ 1244, 1244 },
+	{ 1246, 1246 },
+	{ 1248, 1248 },
+	{ 1250, 1250 },
+	{ 1252, 1252 },
+	{ 1254, 1254 },
+	{ 1256, 1256 },
+	{ 1258, 1258 },
+	{ 1260, 1260 },
+	{ 1262, 1262 },
+	{ 1264, 1264 },
+	{ 1266, 1266 },
+	{ 1268, 1268 },
+	{ 1270, 1270 },
+	{ 1272, 1272 },
+	{ 1274, 1274 },
+	{ 1276, 1276 },
+	{ 1278, 1278 },
+	{ 1280, 1280 },
+	{ 1282, 1282 },
+	{ 1284, 1284 },
+	{ 1286, 1286 },
+	{ 1288, 1288 },
+	{ 1290, 1290 },
+	{ 1292, 1292 },
+	{ 1294, 1294 },
+	{ 1296, 1296 },
+	{ 1298, 1298 },
+	{ 1300, 1300 },
+	{ 1302, 1302 },
+	{ 1304, 1304 },
+	{ 1306, 1306 },
+	{ 1308, 1308 },
+	{ 1310, 1310 },
+	{ 1312, 1312 },
+	{ 1314, 1314 },
+	{ 1316, 1316 },
+	{ 1318, 1318 },
+	{ 1320, 1320 },
+	{ 1322, 1322 },
+	{ 1324, 1324 },
+	{ 1326, 1326 },
+	{ 1329, 1366 },
+	{ 4256, 4293 },
+	{ 4295, 4295 },
+	{ 4301, 4301 },
+	{ 5024, 5109 },
+	{ 7312, 7354 },
+	{ 7357, 7359 },
+	{ 7680, 7680 },
+	{ 7682, 7682 },
+	{ 7684, 7684 },
+	{ 7686, 7686 },
+	{ 7688, 7688 },
+	{ 7690, 7690 },
+	{ 7692, 7692 },
+	{ 7694, 7694 },
+	{ 7696, 7696 },
+	{ 7698, 7698 },
+	{ 7700, 7700 },
+	{ 7702, 7702 },
+	{ 7704, 7704 },
+	{ 7706, 7706 },
+	{ 7708, 7708 },
+	{ 7710, 7710 },
+	{ 7712, 7712 },
+	{ 7714, 7714 },
+	{ 7716, 7716 },
+	{ 7718, 7718 },
+	{ 7720, 7720 },
+	{ 7722, 7722 },
+	{ 7724, 7724 },
+	{ 7726, 7726 },
+	{ 7728, 7728 },
+	{ 7730, 7730 },
+	{ 7732, 7732 },
+	{ 7734, 7734 },
+	{ 7736, 7736 },
+	{ 7738, 7738 },
+	{ 7740, 7740 },
+	{ 7742, 7742 },
+	{ 7744, 7744 },
+	{ 7746, 7746 },
+	{ 7748, 7748 },
+	{ 7750, 7750 },
+	{ 7752, 7752 },
+	{ 7754, 7754 },
+	{ 7756, 7756 },
+	{ 7758, 7758 },
+	{ 7760, 7760 },
+	{ 7762, 7762 },
+	{ 7764, 7764 },
+	{ 7766, 7766 },
+	{ 7768, 7768 },
+	{ 7770, 7770 },
+	{ 7772, 7772 },
+	{ 7774, 7774 },
+	{ 7776, 7776 },
+	{ 7778, 7778 },
+	{ 7780, 7780 },
+	{ 7782, 7782 },
+	{ 7784, 7784 },
+	{ 7786, 7786 },
+	{ 7788, 7788 },
+	{ 7790, 7790 },
+	{ 7792, 7792 },
+	{ 7794, 7794 },
+	{ 7796, 7796 },
+	{ 7798, 7798 },
+	{ 7800, 7800 },
+	{ 7802, 7802 },
+	{ 7804, 7804 },
+	{ 7806, 7806 },
+	{ 7808, 7808 },
+	{ 7810, 7810 },
+	{ 7812, 7812 },
+	{ 7814, 7814 },
+	{ 7816, 7816 },
+	{ 7818, 7818 },
+	{ 7820, 7820 },
+	{ 7822, 7822 },
+	{ 7824, 7824 },
+	{ 7826, 7826 },
+	{ 7828, 7828 },
+	{ 7838, 7838 },
+	{ 7840, 7840 },
+	{ 7842, 7842 },
+	{ 7844, 7844 },
+	{ 7846, 7846 },
+	{ 7848, 7848 },
+	{ 7850, 7850 },
+	{ 7852, 7852 },
+	{ 7854, 7854 },
+	{ 7856, 7856 },
+	{ 7858, 7858 },
+	{ 7860, 7860 },
+	{ 7862, 7862 },
+	{ 7864, 7864 },
+	{ 7866, 7866 },
+	{ 7868, 7868 },
+	{ 7870, 7870 },
+	{ 7872, 7872 },
+	{ 7874, 7874 },
+	{ 7876, 7876 },
+	{ 7878, 7878 },
+	{ 7880, 7880 },
+	{ 7882, 7882 },
+	{ 7884, 7884 },
+	{ 7886, 7886 },
+	{ 7888, 7888 },
+	{ 7890, 7890 },
+	{ 7892, 7892 },
+	{ 7894, 7894 },
+	{ 7896, 7896 },
+	{ 7898, 7898 },
+	{ 7900, 7900 },
+	{ 7902, 7902 },
+	{ 7904, 7904 },
+	{ 7906, 7906 },
+	{ 7908, 7908 },
+	{ 7910, 7910 },
+	{ 7912, 7912 },
+	{ 7914, 7914 },
+	{ 7916, 7916 },
+	{ 7918, 7918 },
+	{ 7920, 7920 },
+	{ 7922, 7922 },
+	{ 7924, 7924 },
+	{ 7926, 7926 },
+	{ 7928, 7928 },
+	{ 7930, 7930 },
+	{ 7932, 7932 },
+	{ 7934, 7934 },
+	{ 7944, 7951 },
+	{ 7960, 7965 },
+	{ 7976, 7983 },
+	{ 7992, 7999 },
+	{ 8008, 8013 },
+	{ 8025, 8025 },
+	{ 8027, 8027 },
+	{ 8029, 8029 },
+	{ 8031, 8031 },
+	{ 8040, 8047 },
+	{ 8120, 8123 },
+	{ 8136, 8139 },
+	{ 8152, 8155 },
+	{ 8168, 8172 },
+	{ 8184, 8187 },
+	{ 8450, 8450 },
+	{ 8455, 8455 },
+	{ 8459, 8461 },
+	{ 8464, 8466 },
+	{ 8469, 8469 },
+	{ 8473, 8477 },
+	{ 8484, 8484 },
+	{ 8486, 8486 },
+	{ 8488, 8488 },
+	{ 8490, 8493 },
+	{ 8496, 8499 },
+	{ 8510, 8511 },
+	{ 8517, 8517 },
+	{ 8579, 8579 },
+	{ 11264, 11311 },
+	{ 11360, 11360 },
+	{ 11362, 11364 },
+	{ 11367, 11367 },
+	{ 11369, 11369 },
+	{ 11371, 11371 },
+	{ 11373, 11376 },
+	{ 11378, 11378 },
+	{ 11381, 11381 },
+	{ 11390, 11392 },
+	{ 11394, 11394 },
+	{ 11396, 11396 },
+	{ 11398, 11398 },
+	{ 11400, 11400 },
+	{ 11402, 11402 },
+	{ 11404, 11404 },
+	{ 11406, 11406 },
+	{ 11408, 11408 },
+	{ 11410, 11410 },
+	{ 11412, 11412 },
+	{ 11414, 11414 },
+	{ 11416, 11416 },
+	{ 11418, 11418 },
+	{ 11420, 11420 },
+	{ 11422, 11422 },
+	{ 11424, 11424 },
+	{ 11426, 11426 },
+	{ 11428, 11428 },
+	{ 11430, 11430 },
+	{ 11432, 11432 },
+	{ 11434, 11434 },
+	{ 11436, 11436 },
+	{ 11438, 11438 },
+	{ 11440, 11440 },
+	{ 11442, 11442 },
+	{ 11444, 11444 },
+	{ 11446, 11446 },
+	{ 11448, 11448 },
+	{ 11450, 11450 },
+	{ 11452, 11452 },
+	{ 11454, 11454 },
+	{ 11456, 11456 },
+	{ 11458, 11458 },
+	{ 11460, 11460 },
+	{ 11462, 11462 },
+	{ 11464, 11464 },
+	{ 11466, 11466 },
+	{ 11468, 11468 },
+	{ 11470, 11470 },
+	{ 11472, 11472 },
+	{ 11474, 11474 },
+	{ 11476, 11476 },
+	{ 11478, 11478 },
+	{ 11480, 11480 },
+	{ 11482, 11482 },
+	{ 11484, 11484 },
+	{ 11486, 11486 },
+	{ 11488, 11488 },
+	{ 11490, 11490 },
+	{ 11499, 11499 },
+	{ 11501, 11501 },
+	{ 11506, 11506 },
+	{ 42560, 42560 },
+	{ 42562, 42562 },
+	{ 42564, 42564 },
+	{ 42566, 42566 },
+	{ 42568, 42568 },
+	{ 42570, 42570 },
+	{ 42572, 42572 },
+	{ 42574, 42574 },
+	{ 42576, 42576 },
+	{ 42578, 42578 },
+	{ 42580, 42580 },
+	{ 42582, 42582 },
+	{ 42584, 42584 },
+	{ 42586, 42586 },
+	{ 42588, 42588 },
+	{ 42590, 42590 },
+	{ 42592, 42592 },
+	{ 42594, 42594 },
+	{ 42596, 42596 },
+	{ 42598, 42598 },
+	{ 42600, 42600 },
+	{ 42602, 42602 },
+	{ 42604, 42604 },
+	{ 42624, 42624 },
+	{ 42626, 42626 },
+	{ 42628, 42628 },
+	{ 42630, 42630 },
+	{ 42632, 42632 },
+	{ 42634, 42634 },
+	{ 42636, 42636 },
+	{ 42638, 42638 },
+	{ 42640, 42640 },
+	{ 42642, 42642 },
+	{ 42644, 42644 },
+	{ 42646, 42646 },
+	{ 42648, 42648 },
+	{ 42650, 42650 },
+	{ 42786, 42786 },
+	{ 42788, 42788 },
+	{ 42790, 42790 },
+	{ 42792, 42792 },
+	{ 42794, 42794 },
+	{ 42796, 42796 },
+	{ 42798, 42798 },
+	{ 42802, 42802 },
+	{ 42804, 42804 },
+	{ 42806, 42806 },
+	{ 42808, 42808 },
+	{ 42810, 42810 },
+	{ 42812, 42812 },
+	{ 42814, 42814 },
+	{ 42816, 42816 },
+	{ 42818, 42818 },
+	{ 42820, 42820 },
+	{ 42822, 42822 },
+	{ 42824, 42824 },
+	{ 42826, 42826 },
+	{ 42828, 42828 },
+	{ 42830, 42830 },
+	{ 42832, 42832 },
+	{ 42834, 42834 },
+	{ 42836, 42836 },
+	{ 42838, 42838 },
+	{ 42840, 42840 },
+	{ 42842, 42842 },
+	{ 42844, 42844 },
+	{ 42846, 42846 },
+	{ 42848, 42848 },
+	{ 42850, 42850 },
+	{ 42852, 42852 },
+	{ 42854, 42854 },
+	{ 42856, 42856 },
+	{ 42858, 42858 },
+	{ 42860, 42860 },
+	{ 42862, 42862 },
+	{ 42873, 42873 },
+	{ 42875, 42875 },
+	{ 42877, 42878 },
+	{ 42880, 42880 },
+	{ 42882, 42882 },
+	{ 42884, 42884 },
+	{ 42886, 42886 },
+	{ 42891, 42891 },
+	{ 42893, 42893 },
+	{ 42896, 42896 },
+	{ 42898, 42898 },
+	{ 42902, 42902 },
+	{ 42904, 42904 },
+	{ 42906, 42906 },
+	{ 42908, 42908 },
+	{ 42910, 42910 },
+	{ 42912, 42912 },
+	{ 42914, 42914 },
+	{ 42916, 42916 },
+	{ 42918, 42918 },
+	{ 42920, 42920 },
+	{ 42922, 42926 },
+	{ 42928, 42932 },
+	{ 42934, 42934 },
+	{ 42936, 42936 },
+	{ 42938, 42938 },
+	{ 42940, 42940 },
+	{ 42942, 42942 },
+	{ 42944, 42944 },
+	{ 42946, 42946 },
+	{ 42948, 42951 },
+	{ 42953, 42953 },
+	{ 42960, 42960 },
+	{ 42966, 42966 },
+	{ 42968, 42968 },
+	{ 42997, 42997 },
+	{ 65313, 65338 },
 };
-static const URange16 Sm_range16[] = {
-	{ 43, 43 },
-	{ 60, 62 },
-	{ 124, 124 },
-	{ 126, 126 },
-	{ 172, 172 },
-	{ 177, 177 },
-	{ 215, 215 },
-	{ 247, 247 },
-	{ 1014, 1014 },
-	{ 1542, 1544 },
-	{ 8260, 8260 },
-	{ 8274, 8274 },
-	{ 8314, 8316 },
-	{ 8330, 8332 },
-	{ 8472, 8472 },
-	{ 8512, 8516 },
-	{ 8523, 8523 },
-	{ 8592, 8596 },
-	{ 8602, 8603 },
-	{ 8608, 8608 },
-	{ 8611, 8611 },
-	{ 8614, 8614 },
-	{ 8622, 8622 },
-	{ 8654, 8655 },
-	{ 8658, 8658 },
-	{ 8660, 8660 },
-	{ 8692, 8959 },
-	{ 8992, 8993 },
-	{ 9084, 9084 },
-	{ 9115, 9139 },
-	{ 9180, 9185 },
-	{ 9655, 9655 },
-	{ 9665, 9665 },
-	{ 9720, 9727 },
-	{ 9839, 9839 },
-	{ 10176, 10180 },
-	{ 10183, 10213 },
-	{ 10224, 10239 },
-	{ 10496, 10626 },
-	{ 10649, 10711 },
-	{ 10716, 10747 },
-	{ 10750, 11007 },
-	{ 11056, 11076 },
-	{ 11079, 11084 },
-	{ 64297, 64297 },
-	{ 65122, 65122 },
-	{ 65124, 65126 },
-	{ 65291, 65291 },
-	{ 65308, 65310 },
-	{ 65372, 65372 },
-	{ 65374, 65374 },
-	{ 65506, 65506 },
-	{ 65513, 65516 },
+static const URange32 Lu_range32[] = {
+	{ 66560, 66599 },
+	{ 66736, 66771 },
+	{ 66928, 66938 },
+	{ 66940, 66954 },
+	{ 66956, 66962 },
+	{ 66964, 66965 },
+	{ 68736, 68786 },
+	{ 71840, 71871 },
+	{ 93760, 93791 },
+	{ 119808, 119833 },
+	{ 119860, 119885 },
+	{ 119912, 119937 },
+	{ 119964, 119964 },
+	{ 119966, 119967 },
+	{ 119970, 119970 },
+	{ 119973, 119974 },
+	{ 119977, 119980 },
+	{ 119982, 119989 },
+	{ 120016, 120041 },
+	{ 120068, 120069 },
+	{ 120071, 120074 },
+	{ 120077, 120084 },
+	{ 120086, 120092 },
+	{ 120120, 120121 },
+	{ 120123, 120126 },
+	{ 120128, 120132 },
+	{ 120134, 120134 },
+	{ 120138, 120144 },
+	{ 120172, 120197 },
+	{ 120224, 120249 },
+	{ 120276, 120301 },
+	{ 120328, 120353 },
+	{ 120380, 120405 },
+	{ 120432, 120457 },
+	{ 120488, 120512 },
+	{ 120546, 120570 },
+	{ 120604, 120628 },
+	{ 120662, 120686 },
+	{ 120720, 120744 },
+	{ 120778, 120778 },
+	{ 125184, 125217 },
+};
+static const URange16 M_range16[] = {
+	{ 768, 879 },
+	{ 1155, 1161 },
+	{ 1425, 1469 },
+	{ 1471, 1471 },
+	{ 1473, 1474 },
+	{ 1476, 1477 },
+	{ 1479, 1479 },
+	{ 1552, 1562 },
+	{ 1611, 1631 },
+	{ 1648, 1648 },
+	{ 1750, 1756 },
+	{ 1759, 1764 },
+	{ 1767, 1768 },
+	{ 1770, 1773 },
+	{ 1809, 1809 },
+	{ 1840, 1866 },
+	{ 1958, 1968 },
+	{ 2027, 2035 },
+	{ 2045, 2045 },
+	{ 2070, 2073 },
+	{ 2075, 2083 },
+	{ 2085, 2087 },
+	{ 2089, 2093 },
+	{ 2137, 2139 },
+	{ 2200, 2207 },
+	{ 2250, 2273 },
+	{ 2275, 2307 },
+	{ 2362, 2364 },
+	{ 2366, 2383 },
+	{ 2385, 2391 },
+	{ 2402, 2403 },
+	{ 2433, 2435 },
+	{ 2492, 2492 },
+	{ 2494, 2500 },
+	{ 2503, 2504 },
+	{ 2507, 2509 },
+	{ 2519, 2519 },
+	{ 2530, 2531 },
+	{ 2558, 2558 },
+	{ 2561, 2563 },
+	{ 2620, 2620 },
+	{ 2622, 2626 },
+	{ 2631, 2632 },
+	{ 2635, 2637 },
+	{ 2641, 2641 },
+	{ 2672, 2673 },
+	{ 2677, 2677 },
+	{ 2689, 2691 },
+	{ 2748, 2748 },
+	{ 2750, 2757 },
+	{ 2759, 2761 },
+	{ 2763, 2765 },
+	{ 2786, 2787 },
+	{ 2810, 2815 },
+	{ 2817, 2819 },
+	{ 2876, 2876 },
+	{ 2878, 2884 },
+	{ 2887, 2888 },
+	{ 2891, 2893 },
+	{ 2901, 2903 },
+	{ 2914, 2915 },
+	{ 2946, 2946 },
+	{ 3006, 3010 },
+	{ 3014, 3016 },
+	{ 3018, 3021 },
+	{ 3031, 3031 },
+	{ 3072, 3076 },
+	{ 3132, 3132 },
+	{ 3134, 3140 },
+	{ 3142, 3144 },
+	{ 3146, 3149 },
+	{ 3157, 3158 },
+	{ 3170, 3171 },
+	{ 3201, 3203 },
+	{ 3260, 3260 },
+	{ 3262, 3268 },
+	{ 3270, 3272 },
+	{ 3274, 3277 },
+	{ 3285, 3286 },
+	{ 3298, 3299 },
+	{ 3315, 3315 },
+	{ 3328, 3331 },
+	{ 3387, 3388 },
+	{ 3390, 3396 },
+	{ 3398, 3400 },
+	{ 3402, 3405 },
+	{ 3415, 3415 },
+	{ 3426, 3427 },
+	{ 3457, 3459 },
+	{ 3530, 3530 },
+	{ 3535, 3540 },
+	{ 3542, 3542 },
+	{ 3544, 3551 },
+	{ 3570, 3571 },
+	{ 3633, 3633 },
+	{ 3636, 3642 },
+	{ 3655, 3662 },
+	{ 3761, 3761 },
+	{ 3764, 3772 },
+	{ 3784, 3790 },
+	{ 3864, 3865 },
+	{ 3893, 3893 },
+	{ 3895, 3895 },
+	{ 3897, 3897 },
+	{ 3902, 3903 },
+	{ 3953, 3972 },
+	{ 3974, 3975 },
+	{ 3981, 3991 },
+	{ 3993, 4028 },
+	{ 4038, 4038 },
+	{ 4139, 4158 },
+	{ 4182, 4185 },
+	{ 4190, 4192 },
+	{ 4194, 4196 },
+	{ 4199, 4205 },
+	{ 4209, 4212 },
+	{ 4226, 4237 },
+	{ 4239, 4239 },
+	{ 4250, 4253 },
+	{ 4957, 4959 },
+	{ 5906, 5909 },
+	{ 5938, 5940 },
+	{ 5970, 5971 },
+	{ 6002, 6003 },
+	{ 6068, 6099 },
+	{ 6109, 6109 },
+	{ 6155, 6157 },
+	{ 6159, 6159 },
+	{ 6277, 6278 },
+	{ 6313, 6313 },
+	{ 6432, 6443 },
+	{ 6448, 6459 },
+	{ 6679, 6683 },
+	{ 6741, 6750 },
+	{ 6752, 6780 },
+	{ 6783, 6783 },
+	{ 6832, 6862 },
+	{ 6912, 6916 },
+	{ 6964, 6980 },
+	{ 7019, 7027 },
+	{ 7040, 7042 },
+	{ 7073, 7085 },
+	{ 7142, 7155 },
+	{ 7204, 7223 },
+	{ 7376, 7378 },
+	{ 7380, 7400 },
+	{ 7405, 7405 },
+	{ 7412, 7412 },
+	{ 7415, 7417 },
+	{ 7616, 7679 },
+	{ 8400, 8432 },
+	{ 11503, 11505 },
+	{ 11647, 11647 },
+	{ 11744, 11775 },
+	{ 12330, 12335 },
+	{ 12441, 12442 },
+	{ 42607, 42610 },
+	{ 42612, 42621 },
+	{ 42654, 42655 },
+	{ 42736, 42737 },
+	{ 43010, 43010 },
+	{ 43014, 43014 },
+	{ 43019, 43019 },
+	{ 43043, 43047 },
+	{ 43052, 43052 },
+	{ 43136, 43137 },
+	{ 43188, 43205 },
+	{ 43232, 43249 },
+	{ 43263, 43263 },
+	{ 43302, 43309 },
+	{ 43335, 43347 },
+	{ 43392, 43395 },
+	{ 43443, 43456 },
+	{ 43493, 43493 },
+	{ 43561, 43574 },
+	{ 43587, 43587 },
+	{ 43596, 43597 },
+	{ 43643, 43645 },
+	{ 43696, 43696 },
+	{ 43698, 43700 },
+	{ 43703, 43704 },
+	{ 43710, 43711 },
+	{ 43713, 43713 },
+	{ 43755, 43759 },
+	{ 43765, 43766 },
+	{ 44003, 44010 },
+	{ 44012, 44013 },
+	{ 64286, 64286 },
+	{ 65024, 65039 },
+	{ 65056, 65071 },
 };
-static const URange32 Sm_range32[] = {
-	{ 120513, 120513 },
-	{ 120539, 120539 },
-	{ 120571, 120571 },
-	{ 120597, 120597 },
-	{ 120629, 120629 },
-	{ 120655, 120655 },
-	{ 120687, 120687 },
-	{ 120713, 120713 },
-	{ 120745, 120745 },
-	{ 120771, 120771 },
-	{ 126704, 126705 },
+static const URange32 M_range32[] = {
+	{ 66045, 66045 },
+	{ 66272, 66272 },
+	{ 66422, 66426 },
+	{ 68097, 68099 },
+	{ 68101, 68102 },
+	{ 68108, 68111 },
+	{ 68152, 68154 },
+	{ 68159, 68159 },
+	{ 68325, 68326 },
+	{ 68900, 68903 },
+	{ 69291, 69292 },
+	{ 69373, 69375 },
+	{ 69446, 69456 },
+	{ 69506, 69509 },
+	{ 69632, 69634 },
+	{ 69688, 69702 },
+	{ 69744, 69744 },
+	{ 69747, 69748 },
+	{ 69759, 69762 },
+	{ 69808, 69818 },
+	{ 69826, 69826 },
+	{ 69888, 69890 },
+	{ 69927, 69940 },
+	{ 69957, 69958 },
+	{ 70003, 70003 },
+	{ 70016, 70018 },
+	{ 70067, 70080 },
+	{ 70089, 70092 },
+	{ 70094, 70095 },
+	{ 70188, 70199 },
+	{ 70206, 70206 },
+	{ 70209, 70209 },
+	{ 70367, 70378 },
+	{ 70400, 70403 },
+	{ 70459, 70460 },
+	{ 70462, 70468 },
+	{ 70471, 70472 },
+	{ 70475, 70477 },
+	{ 70487, 70487 },
+	{ 70498, 70499 },
+	{ 70502, 70508 },
+	{ 70512, 70516 },
+	{ 70709, 70726 },
+	{ 70750, 70750 },
+	{ 70832, 70851 },
+	{ 71087, 71093 },
+	{ 71096, 71104 },
+	{ 71132, 71133 },
+	{ 71216, 71232 },
+	{ 71339, 71351 },
+	{ 71453, 71467 },
+	{ 71724, 71738 },
+	{ 71984, 71989 },
+	{ 71991, 71992 },
+	{ 71995, 71998 },
+	{ 72000, 72000 },
+	{ 72002, 72003 },
+	{ 72145, 72151 },
+	{ 72154, 72160 },
+	{ 72164, 72164 },
+	{ 72193, 72202 },
+	{ 72243, 72249 },
+	{ 72251, 72254 },
+	{ 72263, 72263 },
+	{ 72273, 72283 },
+	{ 72330, 72345 },
+	{ 72751, 72758 },
+	{ 72760, 72767 },
+	{ 72850, 72871 },
+	{ 72873, 72886 },
+	{ 73009, 73014 },
+	{ 73018, 73018 },
+	{ 73020, 73021 },
+	{ 73023, 73029 },
+	{ 73031, 73031 },
+	{ 73098, 73102 },
+	{ 73104, 73105 },
+	{ 73107, 73111 },
+	{ 73459, 73462 },
+	{ 73472, 73473 },
+	{ 73475, 73475 },
+	{ 73524, 73530 },
+	{ 73534, 73538 },
+	{ 78912, 78912 },
+	{ 78919, 78933 },
+	{ 92912, 92916 },
+	{ 92976, 92982 },
+	{ 94031, 94031 },
+	{ 94033, 94087 },
+	{ 94095, 94098 },
+	{ 94180, 94180 },
+	{ 94192, 94193 },
+	{ 113821, 113822 },
+	{ 118528, 118573 },
+	{ 118576, 118598 },
+	{ 119141, 119145 },
+	{ 119149, 119154 },
+	{ 119163, 119170 },
+	{ 119173, 119179 },
+	{ 119210, 119213 },
+	{ 119362, 119364 },
+	{ 121344, 121398 },
+	{ 121403, 121452 },
+	{ 121461, 121461 },
+	{ 121476, 121476 },
+	{ 121499, 121503 },
+	{ 121505, 121519 },
+	{ 122880, 122886 },
+	{ 122888, 122904 },
+	{ 122907, 122913 },
+	{ 122915, 122916 },
+	{ 122918, 122922 },
+	{ 123023, 123023 },
+	{ 123184, 123190 },
+	{ 123566, 123566 },
+	{ 123628, 123631 },
+	{ 124140, 124143 },
+	{ 125136, 125142 },
+	{ 125252, 125258 },
+	{ 917760, 917999 },
 };
-static const URange16 Sc_range16[] = {
-	{ 36, 36 },
-	{ 162, 165 },
-	{ 1423, 1423 },
-	{ 1547, 1547 },
-	{ 2046, 2047 },
-	{ 2546, 2547 },
-	{ 2555, 2555 },
-	{ 2801, 2801 },
-	{ 3065, 3065 },
-	{ 3647, 3647 },
-	{ 6107, 6107 },
-	{ 8352, 8383 },
-	{ 43064, 43064 },
-	{ 65020, 65020 },
-	{ 65129, 65129 },
-	{ 65284, 65284 },
-	{ 65504, 65505 },
-	{ 65509, 65510 },
+static const URange16 Mc_range16[] = {
+	{ 2307, 2307 },
+	{ 2363, 2363 },
+	{ 2366, 2368 },
+	{ 2377, 2380 },
+	{ 2382, 2383 },
+	{ 2434, 2435 },
+	{ 2494, 2496 },
+	{ 2503, 2504 },
+	{ 2507, 2508 },
+	{ 2519, 2519 },
+	{ 2563, 2563 },
+	{ 2622, 2624 },
+	{ 2691, 2691 },
+	{ 2750, 2752 },
+	{ 2761, 2761 },
+	{ 2763, 2764 },
+	{ 2818, 2819 },
+	{ 2878, 2878 },
+	{ 2880, 2880 },
+	{ 2887, 2888 },
+	{ 2891, 2892 },
+	{ 2903, 2903 },
+	{ 3006, 3007 },
+	{ 3009, 3010 },
+	{ 3014, 3016 },
+	{ 3018, 3020 },
+	{ 3031, 3031 },
+	{ 3073, 3075 },
+	{ 3137, 3140 },
+	{ 3202, 3203 },
+	{ 3262, 3262 },
+	{ 3264, 3268 },
+	{ 3271, 3272 },
+	{ 3274, 3275 },
+	{ 3285, 3286 },
+	{ 3315, 3315 },
+	{ 3330, 3331 },
+	{ 3390, 3392 },
+	{ 3398, 3400 },
+	{ 3402, 3404 },
+	{ 3415, 3415 },
+	{ 3458, 3459 },
+	{ 3535, 3537 },
+	{ 3544, 3551 },
+	{ 3570, 3571 },
+	{ 3902, 3903 },
+	{ 3967, 3967 },
+	{ 4139, 4140 },
+	{ 4145, 4145 },
+	{ 4152, 4152 },
+	{ 4155, 4156 },
+	{ 4182, 4183 },
+	{ 4194, 4196 },
+	{ 4199, 4205 },
+	{ 4227, 4228 },
+	{ 4231, 4236 },
+	{ 4239, 4239 },
+	{ 4250, 4252 },
+	{ 5909, 5909 },
+	{ 5940, 5940 },
+	{ 6070, 6070 },
+	{ 6078, 6085 },
+	{ 6087, 6088 },
+	{ 6435, 6438 },
+	{ 6441, 6443 },
+	{ 6448, 6449 },
+	{ 6451, 6456 },
+	{ 6681, 6682 },
+	{ 6741, 6741 },
+	{ 6743, 6743 },
+	{ 6753, 6753 },
+	{ 6755, 6756 },
+	{ 6765, 6770 },
+	{ 6916, 6916 },
+	{ 6965, 6965 },
+	{ 6971, 6971 },
+	{ 6973, 6977 },
+	{ 6979, 6980 },
+	{ 7042, 7042 },
+	{ 7073, 7073 },
+	{ 7078, 7079 },
+	{ 7082, 7082 },
+	{ 7143, 7143 },
+	{ 7146, 7148 },
+	{ 7150, 7150 },
+	{ 7154, 7155 },
+	{ 7204, 7211 },
+	{ 7220, 7221 },
+	{ 7393, 7393 },
+	{ 7415, 7415 },
+	{ 12334, 12335 },
+	{ 43043, 43044 },
+	{ 43047, 43047 },
+	{ 43136, 43137 },
+	{ 43188, 43203 },
+	{ 43346, 43347 },
+	{ 43395, 43395 },
+	{ 43444, 43445 },
+	{ 43450, 43451 },
+	{ 43454, 43456 },
+	{ 43567, 43568 },
+	{ 43571, 43572 },
+	{ 43597, 43597 },
+	{ 43643, 43643 },
+	{ 43645, 43645 },
+	{ 43755, 43755 },
+	{ 43758, 43759 },
+	{ 43765, 43765 },
+	{ 44003, 44004 },
+	{ 44006, 44007 },
+	{ 44009, 44010 },
+	{ 44012, 44012 },
 };
-static const URange32 Sc_range32[] = {
-	{ 126128, 126128 },
+static const URange32 Mc_range32[] = {
+	{ 69632, 69632 },
+	{ 69634, 69634 },
+	{ 69762, 69762 },
+	{ 69808, 69810 },
+	{ 69815, 69816 },
+	{ 69932, 69932 },
+	{ 69957, 69958 },
+	{ 70018, 70018 },
+	{ 70067, 70069 },
+	{ 70079, 70080 },
+	{ 70094, 70094 },
+	{ 70188, 70190 },
+	{ 70194, 70195 },
+	{ 70197, 70197 },
+	{ 70368, 70370 },
+	{ 70402, 70403 },
+	{ 70462, 70463 },
+	{ 70465, 70468 },
+	{ 70471, 70472 },
+	{ 70475, 70477 },
+	{ 70487, 70487 },
+	{ 70498, 70499 },
+	{ 70709, 70711 },
+	{ 70720, 70721 },
+	{ 70725, 70725 },
+	{ 70832, 70834 },
+	{ 70841, 70841 },
+	{ 70843, 70846 },
+	{ 70849, 70849 },
+	{ 71087, 71089 },
+	{ 71096, 71099 },
+	{ 71102, 71102 },
+	{ 71216, 71218 },
+	{ 71227, 71228 },
+	{ 71230, 71230 },
+	{ 71340, 71340 },
+	{ 71342, 71343 },
+	{ 71350, 71350 },
+	{ 71456, 71457 },
+	{ 71462, 71462 },
+	{ 71724, 71726 },
+	{ 71736, 71736 },
+	{ 71984, 71989 },
+	{ 71991, 71992 },
+	{ 71997, 71997 },
+	{ 72000, 72000 },
+	{ 72002, 72002 },
+	{ 72145, 72147 },
+	{ 72156, 72159 },
+	{ 72164, 72164 },
+	{ 72249, 72249 },
+	{ 72279, 72280 },
+	{ 72343, 72343 },
+	{ 72751, 72751 },
+	{ 72766, 72766 },
+	{ 72873, 72873 },
+	{ 72881, 72881 },
+	{ 72884, 72884 },
+	{ 73098, 73102 },
+	{ 73107, 73108 },
+	{ 73110, 73110 },
+	{ 73461, 73462 },
+	{ 73475, 73475 },
+	{ 73524, 73525 },
+	{ 73534, 73535 },
+	{ 73537, 73537 },
+	{ 94033, 94087 },
+	{ 94192, 94193 },
+	{ 119141, 119142 },
+	{ 119149, 119154 },
 };
-static const URange16 Z_range16[] = {
-	{ 32, 32 },
-	{ 160, 160 },
-	{ 5760, 5760 },
-	{ 8192, 8202 },
-	{ 8232, 8233 },
-	{ 8239, 8239 },
-	{ 8287, 8287 },
-	{ 12288, 12288 },
+static const URange16 Me_range16[] = {
+	{ 1160, 1161 },
+	{ 6846, 6846 },
+	{ 8413, 8416 },
+	{ 8418, 8420 },
+	{ 42608, 42610 },
 };
-static const URange16 Zl_range16[] = {
-	{ 8232, 8232 },
+static const URange16 Mn_range16[] = {
+	{ 768, 879 },
+	{ 1155, 1159 },
+	{ 1425, 1469 },
+	{ 1471, 1471 },
+	{ 1473, 1474 },
+	{ 1476, 1477 },
+	{ 1479, 1479 },
+	{ 1552, 1562 },
+	{ 1611, 1631 },
+	{ 1648, 1648 },
+	{ 1750, 1756 },
+	{ 1759, 1764 },
+	{ 1767, 1768 },
+	{ 1770, 1773 },
+	{ 1809, 1809 },
+	{ 1840, 1866 },
+	{ 1958, 1968 },
+	{ 2027, 2035 },
+	{ 2045, 2045 },
+	{ 2070, 2073 },
+	{ 2075, 2083 },
+	{ 2085, 2087 },
+	{ 2089, 2093 },
+	{ 2137, 2139 },
+	{ 2200, 2207 },
+	{ 2250, 2273 },
+	{ 2275, 2306 },
+	{ 2362, 2362 },
+	{ 2364, 2364 },
+	{ 2369, 2376 },
+	{ 2381, 2381 },
+	{ 2385, 2391 },
+	{ 2402, 2403 },
+	{ 2433, 2433 },
+	{ 2492, 2492 },
+	{ 2497, 2500 },
+	{ 2509, 2509 },
+	{ 2530, 2531 },
+	{ 2558, 2558 },
+	{ 2561, 2562 },
+	{ 2620, 2620 },
+	{ 2625, 2626 },
+	{ 2631, 2632 },
+	{ 2635, 2637 },
+	{ 2641, 2641 },
+	{ 2672, 2673 },
+	{ 2677, 2677 },
+	{ 2689, 2690 },
+	{ 2748, 2748 },
+	{ 2753, 2757 },
+	{ 2759, 2760 },
+	{ 2765, 2765 },
+	{ 2786, 2787 },
+	{ 2810, 2815 },
+	{ 2817, 2817 },
+	{ 2876, 2876 },
+	{ 2879, 2879 },
+	{ 2881, 2884 },
+	{ 2893, 2893 },
+	{ 2901, 2902 },
+	{ 2914, 2915 },
+	{ 2946, 2946 },
+	{ 3008, 3008 },
+	{ 3021, 3021 },
+	{ 3072, 3072 },
+	{ 3076, 3076 },
+	{ 3132, 3132 },
+	{ 3134, 3136 },
+	{ 3142, 3144 },
+	{ 3146, 3149 },
+	{ 3157, 3158 },
+	{ 3170, 3171 },
+	{ 3201, 3201 },
+	{ 3260, 3260 },
+	{ 3263, 3263 },
+	{ 3270, 3270 },
+	{ 3276, 3277 },
+	{ 3298, 3299 },
+	{ 3328, 3329 },
+	{ 3387, 3388 },
+	{ 3393, 3396 },
+	{ 3405, 3405 },
+	{ 3426, 3427 },
+	{ 3457, 3457 },
+	{ 3530, 3530 },
+	{ 3538, 3540 },
+	{ 3542, 3542 },
+	{ 3633, 3633 },
+	{ 3636, 3642 },
+	{ 3655, 3662 },
+	{ 3761, 3761 },
+	{ 3764, 3772 },
+	{ 3784, 3790 },
+	{ 3864, 3865 },
+	{ 3893, 3893 },
+	{ 3895, 3895 },
+	{ 3897, 3897 },
+	{ 3953, 3966 },
+	{ 3968, 3972 },
+	{ 3974, 3975 },
+	{ 3981, 3991 },
+	{ 3993, 4028 },
+	{ 4038, 4038 },
+	{ 4141, 4144 },
+	{ 4146, 4151 },
+	{ 4153, 4154 },
+	{ 4157, 4158 },
+	{ 4184, 4185 },
+	{ 4190, 4192 },
+	{ 4209, 4212 },
+	{ 4226, 4226 },
+	{ 4229, 4230 },
+	{ 4237, 4237 },
+	{ 4253, 4253 },
+	{ 4957, 4959 },
+	{ 5906, 5908 },
+	{ 5938, 5939 },
+	{ 5970, 5971 },
+	{ 6002, 6003 },
+	{ 6068, 6069 },
+	{ 6071, 6077 },
+	{ 6086, 6086 },
+	{ 6089, 6099 },
+	{ 6109, 6109 },
+	{ 6155, 6157 },
+	{ 6159, 6159 },
+	{ 6277, 6278 },
+	{ 6313, 6313 },
+	{ 6432, 6434 },
+	{ 6439, 6440 },
+	{ 6450, 6450 },
+	{ 6457, 6459 },
+	{ 6679, 6680 },
+	{ 6683, 6683 },
+	{ 6742, 6742 },
+	{ 6744, 6750 },
+	{ 6752, 6752 },
+	{ 6754, 6754 },
+	{ 6757, 6764 },
+	{ 6771, 6780 },
+	{ 6783, 6783 },
+	{ 6832, 6845 },
+	{ 6847, 6862 },
+	{ 6912, 6915 },
+	{ 6964, 6964 },
+	{ 6966, 6970 },
+	{ 6972, 6972 },
+	{ 6978, 6978 },
+	{ 7019, 7027 },
+	{ 7040, 7041 },
+	{ 7074, 7077 },
+	{ 7080, 7081 },
+	{ 7083, 7085 },
+	{ 7142, 7142 },
+	{ 7144, 7145 },
+	{ 7149, 7149 },
+	{ 7151, 7153 },
+	{ 7212, 7219 },
+	{ 7222, 7223 },
+	{ 7376, 7378 },
+	{ 7380, 7392 },
+	{ 7394, 7400 },
+	{ 7405, 7405 },
+	{ 7412, 7412 },
+	{ 7416, 7417 },
+	{ 7616, 7679 },
+	{ 8400, 8412 },
+	{ 8417, 8417 },
+	{ 8421, 8432 },
+	{ 11503, 11505 },
+	{ 11647, 11647 },
+	{ 11744, 11775 },
+	{ 12330, 12333 },
+	{ 12441, 12442 },
+	{ 42607, 42607 },
+	{ 42612, 42621 },
+	{ 42654, 42655 },
+	{ 42736, 42737 },
+	{ 43010, 43010 },
+	{ 43014, 43014 },
+	{ 43019, 43019 },
+	{ 43045, 43046 },
+	{ 43052, 43052 },
+	{ 43204, 43205 },
+	{ 43232, 43249 },
+	{ 43263, 43263 },
+	{ 43302, 43309 },
+	{ 43335, 43345 },
+	{ 43392, 43394 },
+	{ 43443, 43443 },
+	{ 43446, 43449 },
+	{ 43452, 43453 },
+	{ 43493, 43493 },
+	{ 43561, 43566 },
+	{ 43569, 43570 },
+	{ 43573, 43574 },
+	{ 43587, 43587 },
+	{ 43596, 43596 },
+	{ 43644, 43644 },
+	{ 43696, 43696 },
+	{ 43698, 43700 },
+	{ 43703, 43704 },
+	{ 43710, 43711 },
+	{ 43713, 43713 },
+	{ 43756, 43757 },
+	{ 43766, 43766 },
+	{ 44005, 44005 },
+	{ 44008, 44008 },
+	{ 44013, 44013 },
+	{ 64286, 64286 },
+	{ 65024, 65039 },
+	{ 65056, 65071 },
 };
-static const URange16 Co_range16[] = {
-	{ 57344, 63743 },
+static const URange32 Mn_range32[] = {
+	{ 66045, 66045 },
+	{ 66272, 66272 },
+	{ 66422, 66426 },
+	{ 68097, 68099 },
+	{ 68101, 68102 },
+	{ 68108, 68111 },
+	{ 68152, 68154 },
+	{ 68159, 68159 },
+	{ 68325, 68326 },
+	{ 68900, 68903 },
+	{ 69291, 69292 },
+	{ 69373, 69375 },
+	{ 69446, 69456 },
+	{ 69506, 69509 },
+	{ 69633, 69633 },
+	{ 69688, 69702 },
+	{ 69744, 69744 },
+	{ 69747, 69748 },
+	{ 69759, 69761 },
+	{ 69811, 69814 },
+	{ 69817, 69818 },
+	{ 69826, 69826 },
+	{ 69888, 69890 },
+	{ 69927, 69931 },
+	{ 69933, 69940 },
+	{ 70003, 70003 },
+	{ 70016, 70017 },
+	{ 70070, 70078 },
+	{ 70089, 70092 },
+	{ 70095, 70095 },
+	{ 70191, 70193 },
+	{ 70196, 70196 },
+	{ 70198, 70199 },
+	{ 70206, 70206 },
+	{ 70209, 70209 },
+	{ 70367, 70367 },
+	{ 70371, 70378 },
+	{ 70400, 70401 },
+	{ 70459, 70460 },
+	{ 70464, 70464 },
+	{ 70502, 70508 },
+	{ 70512, 70516 },
+	{ 70712, 70719 },
+	{ 70722, 70724 },
+	{ 70726, 70726 },
+	{ 70750, 70750 },
+	{ 70835, 70840 },
+	{ 70842, 70842 },
+	{ 70847, 70848 },
+	{ 70850, 70851 },
+	{ 71090, 71093 },
+	{ 71100, 71101 },
+	{ 71103, 71104 },
+	{ 71132, 71133 },
+	{ 71219, 71226 },
+	{ 71229, 71229 },
+	{ 71231, 71232 },
+	{ 71339, 71339 },
+	{ 71341, 71341 },
+	{ 71344, 71349 },
+	{ 71351, 71351 },
+	{ 71453, 71455 },
+	{ 71458, 71461 },
+	{ 71463, 71467 },
+	{ 71727, 71735 },
+	{ 71737, 71738 },
+	{ 71995, 71996 },
+	{ 71998, 71998 },
+	{ 72003, 72003 },
+	{ 72148, 72151 },
+	{ 72154, 72155 },
+	{ 72160, 72160 },
+	{ 72193, 72202 },
+	{ 72243, 72248 },
+	{ 72251, 72254 },
+	{ 72263, 72263 },
+	{ 72273, 72278 },
+	{ 72281, 72283 },
+	{ 72330, 72342 },
+	{ 72344, 72345 },
+	{ 72752, 72758 },
+	{ 72760, 72765 },
+	{ 72767, 72767 },
+	{ 72850, 72871 },
+	{ 72874, 72880 },
+	{ 72882, 72883 },
+	{ 72885, 72886 },
+	{ 73009, 73014 },
+	{ 73018, 73018 },
+	{ 73020, 73021 },
+	{ 73023, 73029 },
+	{ 73031, 73031 },
+	{ 73104, 73105 },
+	{ 73109, 73109 },
+	{ 73111, 73111 },
+	{ 73459, 73460 },
+	{ 73472, 73473 },
+	{ 73526, 73530 },
+	{ 73536, 73536 },
+	{ 73538, 73538 },
+	{ 78912, 78912 },
+	{ 78919, 78933 },
+	{ 92912, 92916 },
+	{ 92976, 92982 },
+	{ 94031, 94031 },
+	{ 94095, 94098 },
+	{ 94180, 94180 },
+	{ 113821, 113822 },
+	{ 118528, 118573 },
+	{ 118576, 118598 },
+	{ 119143, 119145 },
+	{ 119163, 119170 },
+	{ 119173, 119179 },
+	{ 119210, 119213 },
+	{ 119362, 119364 },
+	{ 121344, 121398 },
+	{ 121403, 121452 },
+	{ 121461, 121461 },
+	{ 121476, 121476 },
+	{ 121499, 121503 },
+	{ 121505, 121519 },
+	{ 122880, 122886 },
+	{ 122888, 122904 },
+	{ 122907, 122913 },
+	{ 122915, 122916 },
+	{ 122918, 122922 },
+	{ 123023, 123023 },
+	{ 123184, 123190 },
+	{ 123566, 123566 },
+	{ 123628, 123631 },
+	{ 124140, 124143 },
+	{ 125136, 125142 },
+	{ 125252, 125258 },
+	{ 917760, 917999 },
 };
-static const URange32 Co_range32[] = {
-	{ 983040, 1048573 },
-	{ 1048576, 1114109 },
+static const URange16 N_range16[] = {
+	{ 48, 57 },
+	{ 178, 179 },
+	{ 185, 185 },
+	{ 188, 190 },
+	{ 1632, 1641 },
+	{ 1776, 1785 },
+	{ 1984, 1993 },
+	{ 2406, 2415 },
+	{ 2534, 2543 },
+	{ 2548, 2553 },
+	{ 2662, 2671 },
+	{ 2790, 2799 },
+	{ 2918, 2927 },
+	{ 2930, 2935 },
+	{ 3046, 3058 },
+	{ 3174, 3183 },
+	{ 3192, 3198 },
+	{ 3302, 3311 },
+	{ 3416, 3422 },
+	{ 3430, 3448 },
+	{ 3558, 3567 },
+	{ 3664, 3673 },
+	{ 3792, 3801 },
+	{ 3872, 3891 },
+	{ 4160, 4169 },
+	{ 4240, 4249 },
+	{ 4969, 4988 },
+	{ 5870, 5872 },
+	{ 6112, 6121 },
+	{ 6128, 6137 },
+	{ 6160, 6169 },
+	{ 6470, 6479 },
+	{ 6608, 6618 },
+	{ 6784, 6793 },
+	{ 6800, 6809 },
+	{ 6992, 7001 },
+	{ 7088, 7097 },
+	{ 7232, 7241 },
+	{ 7248, 7257 },
+	{ 8304, 8304 },
+	{ 8308, 8313 },
+	{ 8320, 8329 },
+	{ 8528, 8578 },
+	{ 8581, 8585 },
+	{ 9312, 9371 },
+	{ 9450, 9471 },
+	{ 10102, 10131 },
+	{ 11517, 11517 },
+	{ 12295, 12295 },
+	{ 12321, 12329 },
+	{ 12344, 12346 },
+	{ 12690, 12693 },
+	{ 12832, 12841 },
+	{ 12872, 12879 },
+	{ 12881, 12895 },
+	{ 12928, 12937 },
+	{ 12977, 12991 },
+	{ 42528, 42537 },
+	{ 42726, 42735 },
+	{ 43056, 43061 },
+	{ 43216, 43225 },
+	{ 43264, 43273 },
+	{ 43472, 43481 },
+	{ 43504, 43513 },
+	{ 43600, 43609 },
+	{ 44016, 44025 },
+	{ 65296, 65305 },
 };
-static const URange16 Cc_range16[] = {
-	{ 0, 31 },
-	{ 127, 159 },
+static const URange32 N_range32[] = {
+	{ 65799, 65843 },
+	{ 65856, 65912 },
+	{ 65930, 65931 },
+	{ 66273, 66299 },
+	{ 66336, 66339 },
+	{ 66369, 66369 },
+	{ 66378, 66378 },
+	{ 66513, 66517 },
+	{ 66720, 66729 },
+	{ 67672, 67679 },
+	{ 67705, 67711 },
+	{ 67751, 67759 },
+	{ 67835, 67839 },
+	{ 67862, 67867 },
+	{ 68028, 68029 },
+	{ 68032, 68047 },
+	{ 68050, 68095 },
+	{ 68160, 68168 },
+	{ 68221, 68222 },
+	{ 68253, 68255 },
+	{ 68331, 68335 },
+	{ 68440, 68447 },
+	{ 68472, 68479 },
+	{ 68521, 68527 },
+	{ 68858, 68863 },
+	{ 68912, 68921 },
+	{ 69216, 69246 },
+	{ 69405, 69414 },
+	{ 69457, 69460 },
+	{ 69573, 69579 },
+	{ 69714, 69743 },
+	{ 69872, 69881 },
+	{ 69942, 69951 },
+	{ 70096, 70105 },
+	{ 70113, 70132 },
+	{ 70384, 70393 },
+	{ 70736, 70745 },
+	{ 70864, 70873 },
+	{ 71248, 71257 },
+	{ 71360, 71369 },
+	{ 71472, 71483 },
+	{ 71904, 71922 },
+	{ 72016, 72025 },
+	{ 72784, 72812 },
+	{ 73040, 73049 },
+	{ 73120, 73129 },
+	{ 73552, 73561 },
+	{ 73664, 73684 },
+	{ 74752, 74862 },
+	{ 92768, 92777 },
+	{ 92864, 92873 },
+	{ 93008, 93017 },
+	{ 93019, 93025 },
+	{ 93824, 93846 },
+	{ 119488, 119507 },
+	{ 119520, 119539 },
+	{ 119648, 119672 },
+	{ 120782, 120831 },
+	{ 123200, 123209 },
+	{ 123632, 123641 },
+	{ 124144, 124153 },
+	{ 125127, 125135 },
+	{ 125264, 125273 },
+	{ 126065, 126123 },
+	{ 126125, 126127 },
+	{ 126129, 126132 },
+	{ 126209, 126253 },
+	{ 126255, 126269 },
+	{ 127232, 127244 },
+	{ 130032, 130041 },
 };
-static const URange16 Cf_range16[] = {
-	{ 173, 173 },
-	{ 1536, 1541 },
-	{ 1564, 1564 },
-	{ 1757, 1757 },
-	{ 1807, 1807 },
-	{ 2274, 2274 },
-	{ 6158, 6158 },
-	{ 8203, 8207 },
-	{ 8234, 8238 },
-	{ 8288, 8292 },
-	{ 8294, 8303 },
-	{ 65279, 65279 },
-	{ 65529, 65531 },
+static const URange16 Nd_range16[] = {
+	{ 48, 57 },
+	{ 1632, 1641 },
+	{ 1776, 1785 },
+	{ 1984, 1993 },
+	{ 2406, 2415 },
+	{ 2534, 2543 },
+	{ 2662, 2671 },
+	{ 2790, 2799 },
+	{ 2918, 2927 },
+	{ 3046, 3055 },
+	{ 3174, 3183 },
+	{ 3302, 3311 },
+	{ 3430, 3439 },
+	{ 3558, 3567 },
+	{ 3664, 3673 },
+	{ 3792, 3801 },
+	{ 3872, 3881 },
+	{ 4160, 4169 },
+	{ 4240, 4249 },
+	{ 6112, 6121 },
+	{ 6160, 6169 },
+	{ 6470, 6479 },
+	{ 6608, 6617 },
+	{ 6784, 6793 },
+	{ 6800, 6809 },
+	{ 6992, 7001 },
+	{ 7088, 7097 },
+	{ 7232, 7241 },
+	{ 7248, 7257 },
+	{ 42528, 42537 },
+	{ 43216, 43225 },
+	{ 43264, 43273 },
+	{ 43472, 43481 },
+	{ 43504, 43513 },
+	{ 43600, 43609 },
+	{ 44016, 44025 },
+	{ 65296, 65305 },
 };
-static const URange32 Cf_range32[] = {
-	{ 69821, 69821 },
-	{ 69837, 69837 },
-	{ 113824, 113827 },
-	{ 119155, 119162 },
-	{ 917505, 917505 },
-	{ 917536, 917631 },
+static const URange32 Nd_range32[] = {
+	{ 66720, 66729 },
+	{ 68912, 68921 },
+	{ 69734, 69743 },
+	{ 69872, 69881 },
+	{ 69942, 69951 },
+	{ 70096, 70105 },
+	{ 70384, 70393 },
+	{ 70736, 70745 },
+	{ 70864, 70873 },
+	{ 71248, 71257 },
+	{ 71360, 71369 },
+	{ 71472, 71481 },
+	{ 71904, 71913 },
+	{ 72016, 72025 },
+	{ 72784, 72793 },
+	{ 73040, 73049 },
+	{ 73120, 73129 },
+	{ 73552, 73561 },
+	{ 92768, 92777 },
+	{ 92864, 92873 },
+	{ 93008, 93017 },
+	{ 120782, 120831 },
+	{ 123200, 123209 },
+	{ 123632, 123641 },
+	{ 124144, 124153 },
+	{ 125264, 125273 },
+	{ 130032, 130041 },
 };
-static const URange16 Cs_range16[] = {
-	{ 55296, 57343 },
+static const URange16 Nl_range16[] = {
+	{ 5870, 5872 },
+	{ 8544, 8578 },
+	{ 8581, 8584 },
+	{ 12295, 12295 },
+	{ 12321, 12329 },
+	{ 12344, 12346 },
+	{ 42726, 42735 },
 };
-static const URange16 Zp_range16[] = {
-	{ 8233, 8233 },
+static const URange32 Nl_range32[] = {
+	{ 65856, 65908 },
+	{ 66369, 66369 },
+	{ 66378, 66378 },
+	{ 66513, 66517 },
+	{ 74752, 74862 },
 };
-static const URange16 Zs_range16[] = {
-	{ 32, 32 },
-	{ 160, 160 },
-	{ 5760, 5760 },
-	{ 8192, 8202 },
-	{ 8239, 8239 },
-	{ 8287, 8287 },
-	{ 12288, 12288 },
+static const URange16 No_range16[] = {
+	{ 178, 179 },
+	{ 185, 185 },
+	{ 188, 190 },
+	{ 2548, 2553 },
+	{ 2930, 2935 },
+	{ 3056, 3058 },
+	{ 3192, 3198 },
+	{ 3416, 3422 },
+	{ 3440, 3448 },
+	{ 3882, 3891 },
+	{ 4969, 4988 },
+	{ 6128, 6137 },
+	{ 6618, 6618 },
+	{ 8304, 8304 },
+	{ 8308, 8313 },
+	{ 8320, 8329 },
+	{ 8528, 8543 },
+	{ 8585, 8585 },
+	{ 9312, 9371 },
+	{ 9450, 9471 },
+	{ 10102, 10131 },
+	{ 11517, 11517 },
+	{ 12690, 12693 },
+	{ 12832, 12841 },
+	{ 12872, 12879 },
+	{ 12881, 12895 },
+	{ 12928, 12937 },
+	{ 12977, 12991 },
+	{ 43056, 43061 },
 };
-static const URange32 Tangut_range32[] = {
-	{ 94176, 94176 },
-	{ 94208, 100337 },
-	{ 100352, 101106 },
+static const URange32 No_range32[] = {
+	{ 65799, 65843 },
+	{ 65909, 65912 },
+	{ 65930, 65931 },
+	{ 66273, 66299 },
+	{ 66336, 66339 },
+	{ 67672, 67679 },
+	{ 67705, 67711 },
+	{ 67751, 67759 },
+	{ 67835, 67839 },
+	{ 67862, 67867 },
+	{ 68028, 68029 },
+	{ 68032, 68047 },
+	{ 68050, 68095 },
+	{ 68160, 68168 },
+	{ 68221, 68222 },
+	{ 68253, 68255 },
+	{ 68331, 68335 },
+	{ 68440, 68447 },
+	{ 68472, 68479 },
+	{ 68521, 68527 },
+	{ 68858, 68863 },
+	{ 69216, 69246 },
+	{ 69405, 69414 },
+	{ 69457, 69460 },
+	{ 69573, 69579 },
+	{ 69714, 69733 },
+	{ 70113, 70132 },
+	{ 71482, 71483 },
+	{ 71914, 71922 },
+	{ 72794, 72812 },
+	{ 73664, 73684 },
+	{ 93019, 93025 },
+	{ 93824, 93846 },
+	{ 119488, 119507 },
+	{ 119520, 119539 },
+	{ 119648, 119672 },
+	{ 125127, 125135 },
+	{ 126065, 126123 },
+	{ 126125, 126127 },
+	{ 126129, 126132 },
+	{ 126209, 126253 },
+	{ 126255, 126269 },
+	{ 127232, 127244 },
 };
-static const URange16 Thaana_range16[] = {
-	{ 1920, 1969 },
+static const URange16 P_range16[] = {
+	{ 33, 35 },
+	{ 37, 42 },
+	{ 44, 47 },
+	{ 58, 59 },
+	{ 63, 64 },
+	{ 91, 93 },
+	{ 95, 95 },
+	{ 123, 123 },
+	{ 125, 125 },
+	{ 161, 161 },
+	{ 167, 167 },
+	{ 171, 171 },
+	{ 182, 183 },
+	{ 187, 187 },
+	{ 191, 191 },
+	{ 894, 894 },
+	{ 903, 903 },
+	{ 1370, 1375 },
+	{ 1417, 1418 },
+	{ 1470, 1470 },
+	{ 1472, 1472 },
+	{ 1475, 1475 },
+	{ 1478, 1478 },
+	{ 1523, 1524 },
+	{ 1545, 1546 },
+	{ 1548, 1549 },
+	{ 1563, 1563 },
+	{ 1565, 1567 },
+	{ 1642, 1645 },
+	{ 1748, 1748 },
+	{ 1792, 1805 },
+	{ 2039, 2041 },
+	{ 2096, 2110 },
+	{ 2142, 2142 },
+	{ 2404, 2405 },
+	{ 2416, 2416 },
+	{ 2557, 2557 },
+	{ 2678, 2678 },
+	{ 2800, 2800 },
+	{ 3191, 3191 },
+	{ 3204, 3204 },
+	{ 3572, 3572 },
+	{ 3663, 3663 },
+	{ 3674, 3675 },
+	{ 3844, 3858 },
+	{ 3860, 3860 },
+	{ 3898, 3901 },
+	{ 3973, 3973 },
+	{ 4048, 4052 },
+	{ 4057, 4058 },
+	{ 4170, 4175 },
+	{ 4347, 4347 },
+	{ 4960, 4968 },
+	{ 5120, 5120 },
+	{ 5742, 5742 },
+	{ 5787, 5788 },
+	{ 5867, 5869 },
+	{ 5941, 5942 },
+	{ 6100, 6102 },
+	{ 6104, 6106 },
+	{ 6144, 6154 },
+	{ 6468, 6469 },
+	{ 6686, 6687 },
+	{ 6816, 6822 },
+	{ 6824, 6829 },
+	{ 7002, 7008 },
+	{ 7037, 7038 },
+	{ 7164, 7167 },
+	{ 7227, 7231 },
+	{ 7294, 7295 },
+	{ 7360, 7367 },
+	{ 7379, 7379 },
+	{ 8208, 8231 },
+	{ 8240, 8259 },
+	{ 8261, 8273 },
+	{ 8275, 8286 },
+	{ 8317, 8318 },
+	{ 8333, 8334 },
+	{ 8968, 8971 },
+	{ 9001, 9002 },
+	{ 10088, 10101 },
+	{ 10181, 10182 },
+	{ 10214, 10223 },
+	{ 10627, 10648 },
+	{ 10712, 10715 },
+	{ 10748, 10749 },
+	{ 11513, 11516 },
+	{ 11518, 11519 },
+	{ 11632, 11632 },
+	{ 11776, 11822 },
+	{ 11824, 11855 },
+	{ 11858, 11869 },
+	{ 12289, 12291 },
+	{ 12296, 12305 },
+	{ 12308, 12319 },
+	{ 12336, 12336 },
+	{ 12349, 12349 },
+	{ 12448, 12448 },
+	{ 12539, 12539 },
+	{ 42238, 42239 },
+	{ 42509, 42511 },
+	{ 42611, 42611 },
+	{ 42622, 42622 },
+	{ 42738, 42743 },
+	{ 43124, 43127 },
+	{ 43214, 43215 },
+	{ 43256, 43258 },
+	{ 43260, 43260 },
+	{ 43310, 43311 },
+	{ 43359, 43359 },
+	{ 43457, 43469 },
+	{ 43486, 43487 },
+	{ 43612, 43615 },
+	{ 43742, 43743 },
+	{ 43760, 43761 },
+	{ 44011, 44011 },
+	{ 64830, 64831 },
+	{ 65040, 65049 },
+	{ 65072, 65106 },
+	{ 65108, 65121 },
+	{ 65123, 65123 },
+	{ 65128, 65128 },
+	{ 65130, 65131 },
+	{ 65281, 65283 },
+	{ 65285, 65290 },
+	{ 65292, 65295 },
+	{ 65306, 65307 },
+	{ 65311, 65312 },
+	{ 65339, 65341 },
+	{ 65343, 65343 },
+	{ 65371, 65371 },
+	{ 65373, 65373 },
+	{ 65375, 65381 },
 };
-static const URange32 Adlam_range32[] = {
-	{ 125184, 125258 },
-	{ 125264, 125273 },
+static const URange32 P_range32[] = {
+	{ 65792, 65794 },
+	{ 66463, 66463 },
+	{ 66512, 66512 },
+	{ 66927, 66927 },
+	{ 67671, 67671 },
+	{ 67871, 67871 },
+	{ 67903, 67903 },
+	{ 68176, 68184 },
+	{ 68223, 68223 },
+	{ 68336, 68342 },
+	{ 68409, 68415 },
+	{ 68505, 68508 },
+	{ 69293, 69293 },
+	{ 69461, 69465 },
+	{ 69510, 69513 },
+	{ 69703, 69709 },
+	{ 69819, 69820 },
+	{ 69822, 69825 },
+	{ 69952, 69955 },
+	{ 70004, 70005 },
+	{ 70085, 70088 },
+	{ 70093, 70093 },
+	{ 70107, 70107 },
+	{ 70109, 70111 },
+	{ 70200, 70205 },
+	{ 70313, 70313 },
+	{ 70731, 70735 },
+	{ 70746, 70747 },
+	{ 70749, 70749 },
+	{ 70854, 70854 },
+	{ 71105, 71127 },
+	{ 71233, 71235 },
+	{ 71264, 71276 },
+	{ 71353, 71353 },
+	{ 71484, 71486 },
+	{ 71739, 71739 },
+	{ 72004, 72006 },
+	{ 72162, 72162 },
+	{ 72255, 72262 },
+	{ 72346, 72348 },
+	{ 72350, 72354 },
+	{ 72448, 72457 },
+	{ 72769, 72773 },
+	{ 72816, 72817 },
+	{ 73463, 73464 },
+	{ 73539, 73551 },
+	{ 73727, 73727 },
+	{ 74864, 74868 },
+	{ 77809, 77810 },
+	{ 92782, 92783 },
+	{ 92917, 92917 },
+	{ 92983, 92987 },
+	{ 92996, 92996 },
+	{ 93847, 93850 },
+	{ 94178, 94178 },
+	{ 113823, 113823 },
+	{ 121479, 121483 },
 	{ 125278, 125279 },
 };
-static const URange16 Telugu_range16[] = {
-	{ 3072, 3084 },
-	{ 3086, 3088 },
-	{ 3090, 3112 },
-	{ 3114, 3129 },
-	{ 3133, 3140 },
-	{ 3142, 3144 },
-	{ 3146, 3149 },
-	{ 3157, 3158 },
-	{ 3160, 3162 },
-	{ 3168, 3171 },
-	{ 3174, 3183 },
-	{ 3192, 3199 },
-};
-static const URange16 Cyrillic_range16[] = {
-	{ 1024, 1156 },
-	{ 1159, 1327 },
-	{ 7296, 7304 },
-	{ 7467, 7467 },
-	{ 7544, 7544 },
-	{ 11744, 11775 },
-	{ 42560, 42655 },
-	{ 65070, 65071 },
-};
-static const URange32 Zanabazar_Square_range32[] = {
-	{ 72192, 72263 },
+static const URange16 Pc_range16[] = {
+	{ 95, 95 },
+	{ 8255, 8256 },
+	{ 8276, 8276 },
+	{ 65075, 65076 },
+	{ 65101, 65103 },
+	{ 65343, 65343 },
 };
-static const URange16 Hangul_range16[] = {
-	{ 4352, 4607 },
-	{ 12334, 12335 },
-	{ 12593, 12686 },
-	{ 12800, 12830 },
-	{ 12896, 12926 },
-	{ 43360, 43388 },
-	{ 44032, 55203 },
-	{ 55216, 55238 },
-	{ 55243, 55291 },
-	{ 65440, 65470 },
-	{ 65474, 65479 },
-	{ 65482, 65487 },
-	{ 65490, 65495 },
-	{ 65498, 65500 },
+static const URange16 Pd_range16[] = {
+	{ 45, 45 },
+	{ 1418, 1418 },
+	{ 1470, 1470 },
+	{ 5120, 5120 },
+	{ 6150, 6150 },
+	{ 8208, 8213 },
+	{ 11799, 11799 },
+	{ 11802, 11802 },
+	{ 11834, 11835 },
+	{ 11840, 11840 },
+	{ 11869, 11869 },
+	{ 12316, 12316 },
+	{ 12336, 12336 },
+	{ 12448, 12448 },
+	{ 65073, 65074 },
+	{ 65112, 65112 },
+	{ 65123, 65123 },
+	{ 65293, 65293 },
 };
-static const URange32 Old_South_Arabian_range32[] = {
-	{ 68192, 68223 },
+static const URange32 Pd_range32[] = {
+	{ 69293, 69293 },
 };
-static const URange16 Ethiopic_range16[] = {
-	{ 4608, 4680 },
-	{ 4682, 4685 },
-	{ 4688, 4694 },
-	{ 4696, 4696 },
-	{ 4698, 4701 },
-	{ 4704, 4744 },
-	{ 4746, 4749 },
-	{ 4752, 4784 },
-	{ 4786, 4789 },
-	{ 4792, 4798 },
-	{ 4800, 4800 },
-	{ 4802, 4805 },
-	{ 4808, 4822 },
-	{ 4824, 4880 },
-	{ 4882, 4885 },
-	{ 4888, 4954 },
-	{ 4957, 4988 },
-	{ 4992, 5017 },
-	{ 11648, 11670 },
-	{ 11680, 11686 },
-	{ 11688, 11694 },
-	{ 11696, 11702 },
-	{ 11704, 11710 },
-	{ 11712, 11718 },
-	{ 11720, 11726 },
-	{ 11728, 11734 },
-	{ 11736, 11742 },
-	{ 43777, 43782 },
-	{ 43785, 43790 },
-	{ 43793, 43798 },
-	{ 43808, 43814 },
-	{ 43816, 43822 },
+static const URange16 Pe_range16[] = {
+	{ 41, 41 },
+	{ 93, 93 },
+	{ 125, 125 },
+	{ 3899, 3899 },
+	{ 3901, 3901 },
+	{ 5788, 5788 },
+	{ 8262, 8262 },
+	{ 8318, 8318 },
+	{ 8334, 8334 },
+	{ 8969, 8969 },
+	{ 8971, 8971 },
+	{ 9002, 9002 },
+	{ 10089, 10089 },
+	{ 10091, 10091 },
+	{ 10093, 10093 },
+	{ 10095, 10095 },
+	{ 10097, 10097 },
+	{ 10099, 10099 },
+	{ 10101, 10101 },
+	{ 10182, 10182 },
+	{ 10215, 10215 },
+	{ 10217, 10217 },
+	{ 10219, 10219 },
+	{ 10221, 10221 },
+	{ 10223, 10223 },
+	{ 10628, 10628 },
+	{ 10630, 10630 },
+	{ 10632, 10632 },
+	{ 10634, 10634 },
+	{ 10636, 10636 },
+	{ 10638, 10638 },
+	{ 10640, 10640 },
+	{ 10642, 10642 },
+	{ 10644, 10644 },
+	{ 10646, 10646 },
+	{ 10648, 10648 },
+	{ 10713, 10713 },
+	{ 10715, 10715 },
+	{ 10749, 10749 },
+	{ 11811, 11811 },
+	{ 11813, 11813 },
+	{ 11815, 11815 },
+	{ 11817, 11817 },
+	{ 11862, 11862 },
+	{ 11864, 11864 },
+	{ 11866, 11866 },
+	{ 11868, 11868 },
+	{ 12297, 12297 },
+	{ 12299, 12299 },
+	{ 12301, 12301 },
+	{ 12303, 12303 },
+	{ 12305, 12305 },
+	{ 12309, 12309 },
+	{ 12311, 12311 },
+	{ 12313, 12313 },
+	{ 12315, 12315 },
+	{ 12318, 12319 },
+	{ 64830, 64830 },
+	{ 65048, 65048 },
+	{ 65078, 65078 },
+	{ 65080, 65080 },
+	{ 65082, 65082 },
+	{ 65084, 65084 },
+	{ 65086, 65086 },
+	{ 65088, 65088 },
+	{ 65090, 65090 },
+	{ 65092, 65092 },
+	{ 65096, 65096 },
+	{ 65114, 65114 },
+	{ 65116, 65116 },
+	{ 65118, 65118 },
+	{ 65289, 65289 },
+	{ 65341, 65341 },
+	{ 65373, 65373 },
+	{ 65376, 65376 },
+	{ 65379, 65379 },
 };
-static const URange16 Inherited_range16[] = {
-	{ 768, 879 },
-	{ 1157, 1158 },
-	{ 1611, 1621 },
-	{ 1648, 1648 },
-	{ 2385, 2386 },
-	{ 6832, 6846 },
-	{ 7376, 7378 },
-	{ 7380, 7392 },
-	{ 7394, 7400 },
-	{ 7405, 7405 },
-	{ 7412, 7412 },
-	{ 7416, 7417 },
-	{ 7616, 7673 },
-	{ 7675, 7679 },
-	{ 8204, 8205 },
-	{ 8400, 8432 },
-	{ 12330, 12333 },
-	{ 12441, 12442 },
-	{ 65024, 65039 },
-	{ 65056, 65069 },
+static const URange16 Pf_range16[] = {
+	{ 187, 187 },
+	{ 8217, 8217 },
+	{ 8221, 8221 },
+	{ 8250, 8250 },
+	{ 11779, 11779 },
+	{ 11781, 11781 },
+	{ 11786, 11786 },
+	{ 11789, 11789 },
+	{ 11805, 11805 },
+	{ 11809, 11809 },
 };
-static const URange32 Inherited_range32[] = {
-	{ 66045, 66045 },
-	{ 66272, 66272 },
-	{ 70459, 70459 },
-	{ 119143, 119145 },
-	{ 119163, 119170 },
-	{ 119173, 119179 },
-	{ 119210, 119213 },
-	{ 917760, 917999 },
+static const URange16 Pi_range16[] = {
+	{ 171, 171 },
+	{ 8216, 8216 },
+	{ 8219, 8220 },
+	{ 8223, 8223 },
+	{ 8249, 8249 },
+	{ 11778, 11778 },
+	{ 11780, 11780 },
+	{ 11785, 11785 },
+	{ 11788, 11788 },
+	{ 11804, 11804 },
+	{ 11808, 11808 },
 };
-static const URange32 Meroitic_Cursive_range32[] = {
-	{ 68000, 68023 },
-	{ 68028, 68047 },
-	{ 68050, 68095 },
+static const URange16 Po_range16[] = {
+	{ 33, 35 },
+	{ 37, 39 },
+	{ 42, 42 },
+	{ 44, 44 },
+	{ 46, 47 },
+	{ 58, 59 },
+	{ 63, 64 },
+	{ 92, 92 },
+	{ 161, 161 },
+	{ 167, 167 },
+	{ 182, 183 },
+	{ 191, 191 },
+	{ 894, 894 },
+	{ 903, 903 },
+	{ 1370, 1375 },
+	{ 1417, 1417 },
+	{ 1472, 1472 },
+	{ 1475, 1475 },
+	{ 1478, 1478 },
+	{ 1523, 1524 },
+	{ 1545, 1546 },
+	{ 1548, 1549 },
+	{ 1563, 1563 },
+	{ 1565, 1567 },
+	{ 1642, 1645 },
+	{ 1748, 1748 },
+	{ 1792, 1805 },
+	{ 2039, 2041 },
+	{ 2096, 2110 },
+	{ 2142, 2142 },
+	{ 2404, 2405 },
+	{ 2416, 2416 },
+	{ 2557, 2557 },
+	{ 2678, 2678 },
+	{ 2800, 2800 },
+	{ 3191, 3191 },
+	{ 3204, 3204 },
+	{ 3572, 3572 },
+	{ 3663, 3663 },
+	{ 3674, 3675 },
+	{ 3844, 3858 },
+	{ 3860, 3860 },
+	{ 3973, 3973 },
+	{ 4048, 4052 },
+	{ 4057, 4058 },
+	{ 4170, 4175 },
+	{ 4347, 4347 },
+	{ 4960, 4968 },
+	{ 5742, 5742 },
+	{ 5867, 5869 },
+	{ 5941, 5942 },
+	{ 6100, 6102 },
+	{ 6104, 6106 },
+	{ 6144, 6149 },
+	{ 6151, 6154 },
+	{ 6468, 6469 },
+	{ 6686, 6687 },
+	{ 6816, 6822 },
+	{ 6824, 6829 },
+	{ 7002, 7008 },
+	{ 7037, 7038 },
+	{ 7164, 7167 },
+	{ 7227, 7231 },
+	{ 7294, 7295 },
+	{ 7360, 7367 },
+	{ 7379, 7379 },
+	{ 8214, 8215 },
+	{ 8224, 8231 },
+	{ 8240, 8248 },
+	{ 8251, 8254 },
+	{ 8257, 8259 },
+	{ 8263, 8273 },
+	{ 8275, 8275 },
+	{ 8277, 8286 },
+	{ 11513, 11516 },
+	{ 11518, 11519 },
+	{ 11632, 11632 },
+	{ 11776, 11777 },
+	{ 11782, 11784 },
+	{ 11787, 11787 },
+	{ 11790, 11798 },
+	{ 11800, 11801 },
+	{ 11803, 11803 },
+	{ 11806, 11807 },
+	{ 11818, 11822 },
+	{ 11824, 11833 },
+	{ 11836, 11839 },
+	{ 11841, 11841 },
+	{ 11843, 11855 },
+	{ 11858, 11860 },
+	{ 12289, 12291 },
+	{ 12349, 12349 },
+	{ 12539, 12539 },
+	{ 42238, 42239 },
+	{ 42509, 42511 },
+	{ 42611, 42611 },
+	{ 42622, 42622 },
+	{ 42738, 42743 },
+	{ 43124, 43127 },
+	{ 43214, 43215 },
+	{ 43256, 43258 },
+	{ 43260, 43260 },
+	{ 43310, 43311 },
+	{ 43359, 43359 },
+	{ 43457, 43469 },
+	{ 43486, 43487 },
+	{ 43612, 43615 },
+	{ 43742, 43743 },
+	{ 43760, 43761 },
+	{ 44011, 44011 },
+	{ 65040, 65046 },
+	{ 65049, 65049 },
+	{ 65072, 65072 },
+	{ 65093, 65094 },
+	{ 65097, 65100 },
+	{ 65104, 65106 },
+	{ 65108, 65111 },
+	{ 65119, 65121 },
+	{ 65128, 65128 },
+	{ 65130, 65131 },
+	{ 65281, 65283 },
+	{ 65285, 65287 },
+	{ 65290, 65290 },
+	{ 65292, 65292 },
+	{ 65294, 65295 },
+	{ 65306, 65307 },
+	{ 65311, 65312 },
+	{ 65340, 65340 },
+	{ 65377, 65377 },
+	{ 65380, 65381 },
 };
-static const URange32 Bhaiksuki_range32[] = {
-	{ 72704, 72712 },
-	{ 72714, 72758 },
-	{ 72760, 72773 },
-	{ 72784, 72812 },
+static const URange32 Po_range32[] = {
+	{ 65792, 65794 },
+	{ 66463, 66463 },
+	{ 66512, 66512 },
+	{ 66927, 66927 },
+	{ 67671, 67671 },
+	{ 67871, 67871 },
+	{ 67903, 67903 },
+	{ 68176, 68184 },
+	{ 68223, 68223 },
+	{ 68336, 68342 },
+	{ 68409, 68415 },
+	{ 68505, 68508 },
+	{ 69461, 69465 },
+	{ 69510, 69513 },
+	{ 69703, 69709 },
+	{ 69819, 69820 },
+	{ 69822, 69825 },
+	{ 69952, 69955 },
+	{ 70004, 70005 },
+	{ 70085, 70088 },
+	{ 70093, 70093 },
+	{ 70107, 70107 },
+	{ 70109, 70111 },
+	{ 70200, 70205 },
+	{ 70313, 70313 },
+	{ 70731, 70735 },
+	{ 70746, 70747 },
+	{ 70749, 70749 },
+	{ 70854, 70854 },
+	{ 71105, 71127 },
+	{ 71233, 71235 },
+	{ 71264, 71276 },
+	{ 71353, 71353 },
+	{ 71484, 71486 },
+	{ 71739, 71739 },
+	{ 72004, 72006 },
+	{ 72162, 72162 },
+	{ 72255, 72262 },
+	{ 72346, 72348 },
+	{ 72350, 72354 },
+	{ 72448, 72457 },
+	{ 72769, 72773 },
+	{ 72816, 72817 },
+	{ 73463, 73464 },
+	{ 73539, 73551 },
+	{ 73727, 73727 },
+	{ 74864, 74868 },
+	{ 77809, 77810 },
+	{ 92782, 92783 },
+	{ 92917, 92917 },
+	{ 92983, 92987 },
+	{ 92996, 92996 },
+	{ 93847, 93850 },
+	{ 94178, 94178 },
+	{ 113823, 113823 },
+	{ 121479, 121483 },
+	{ 125278, 125279 },
 };
-static const URange32 Ahom_range32[] = {
-	{ 71424, 71450 },
-	{ 71453, 71467 },
-	{ 71472, 71487 },
+static const URange16 Ps_range16[] = {
+	{ 40, 40 },
+	{ 91, 91 },
+	{ 123, 123 },
+	{ 3898, 3898 },
+	{ 3900, 3900 },
+	{ 5787, 5787 },
+	{ 8218, 8218 },
+	{ 8222, 8222 },
+	{ 8261, 8261 },
+	{ 8317, 8317 },
+	{ 8333, 8333 },
+	{ 8968, 8968 },
+	{ 8970, 8970 },
+	{ 9001, 9001 },
+	{ 10088, 10088 },
+	{ 10090, 10090 },
+	{ 10092, 10092 },
+	{ 10094, 10094 },
+	{ 10096, 10096 },
+	{ 10098, 10098 },
+	{ 10100, 10100 },
+	{ 10181, 10181 },
+	{ 10214, 10214 },
+	{ 10216, 10216 },
+	{ 10218, 10218 },
+	{ 10220, 10220 },
+	{ 10222, 10222 },
+	{ 10627, 10627 },
+	{ 10629, 10629 },
+	{ 10631, 10631 },
+	{ 10633, 10633 },
+	{ 10635, 10635 },
+	{ 10637, 10637 },
+	{ 10639, 10639 },
+	{ 10641, 10641 },
+	{ 10643, 10643 },
+	{ 10645, 10645 },
+	{ 10647, 10647 },
+	{ 10712, 10712 },
+	{ 10714, 10714 },
+	{ 10748, 10748 },
+	{ 11810, 11810 },
+	{ 11812, 11812 },
+	{ 11814, 11814 },
+	{ 11816, 11816 },
+	{ 11842, 11842 },
+	{ 11861, 11861 },
+	{ 11863, 11863 },
+	{ 11865, 11865 },
+	{ 11867, 11867 },
+	{ 12296, 12296 },
+	{ 12298, 12298 },
+	{ 12300, 12300 },
+	{ 12302, 12302 },
+	{ 12304, 12304 },
+	{ 12308, 12308 },
+	{ 12310, 12310 },
+	{ 12312, 12312 },
+	{ 12314, 12314 },
+	{ 12317, 12317 },
+	{ 64831, 64831 },
+	{ 65047, 65047 },
+	{ 65077, 65077 },
+	{ 65079, 65079 },
+	{ 65081, 65081 },
+	{ 65083, 65083 },
+	{ 65085, 65085 },
+	{ 65087, 65087 },
+	{ 65089, 65089 },
+	{ 65091, 65091 },
+	{ 65095, 65095 },
+	{ 65113, 65113 },
+	{ 65115, 65115 },
+	{ 65117, 65117 },
+	{ 65288, 65288 },
+	{ 65339, 65339 },
+	{ 65371, 65371 },
+	{ 65375, 65375 },
+	{ 65378, 65378 },
 };
-static const URange16 Han_range16[] = {
+static const URange16 S_range16[] = {
+	{ 36, 36 },
+	{ 43, 43 },
+	{ 60, 62 },
+	{ 94, 94 },
+	{ 96, 96 },
+	{ 124, 124 },
+	{ 126, 126 },
+	{ 162, 166 },
+	{ 168, 169 },
+	{ 172, 172 },
+	{ 174, 177 },
+	{ 180, 180 },
+	{ 184, 184 },
+	{ 215, 215 },
+	{ 247, 247 },
+	{ 706, 709 },
+	{ 722, 735 },
+	{ 741, 747 },
+	{ 749, 749 },
+	{ 751, 767 },
+	{ 885, 885 },
+	{ 900, 901 },
+	{ 1014, 1014 },
+	{ 1154, 1154 },
+	{ 1421, 1423 },
+	{ 1542, 1544 },
+	{ 1547, 1547 },
+	{ 1550, 1551 },
+	{ 1758, 1758 },
+	{ 1769, 1769 },
+	{ 1789, 1790 },
+	{ 2038, 2038 },
+	{ 2046, 2047 },
+	{ 2184, 2184 },
+	{ 2546, 2547 },
+	{ 2554, 2555 },
+	{ 2801, 2801 },
+	{ 2928, 2928 },
+	{ 3059, 3066 },
+	{ 3199, 3199 },
+	{ 3407, 3407 },
+	{ 3449, 3449 },
+	{ 3647, 3647 },
+	{ 3841, 3843 },
+	{ 3859, 3859 },
+	{ 3861, 3863 },
+	{ 3866, 3871 },
+	{ 3892, 3892 },
+	{ 3894, 3894 },
+	{ 3896, 3896 },
+	{ 4030, 4037 },
+	{ 4039, 4044 },
+	{ 4046, 4047 },
+	{ 4053, 4056 },
+	{ 4254, 4255 },
+	{ 5008, 5017 },
+	{ 5741, 5741 },
+	{ 6107, 6107 },
+	{ 6464, 6464 },
+	{ 6622, 6655 },
+	{ 7009, 7018 },
+	{ 7028, 7036 },
+	{ 8125, 8125 },
+	{ 8127, 8129 },
+	{ 8141, 8143 },
+	{ 8157, 8159 },
+	{ 8173, 8175 },
+	{ 8189, 8190 },
+	{ 8260, 8260 },
+	{ 8274, 8274 },
+	{ 8314, 8316 },
+	{ 8330, 8332 },
+	{ 8352, 8384 },
+	{ 8448, 8449 },
+	{ 8451, 8454 },
+	{ 8456, 8457 },
+	{ 8468, 8468 },
+	{ 8470, 8472 },
+	{ 8478, 8483 },
+	{ 8485, 8485 },
+	{ 8487, 8487 },
+	{ 8489, 8489 },
+	{ 8494, 8494 },
+	{ 8506, 8507 },
+	{ 8512, 8516 },
+	{ 8522, 8525 },
+	{ 8527, 8527 },
+	{ 8586, 8587 },
+	{ 8592, 8967 },
+	{ 8972, 9000 },
+	{ 9003, 9254 },
+	{ 9280, 9290 },
+	{ 9372, 9449 },
+	{ 9472, 10087 },
+	{ 10132, 10180 },
+	{ 10183, 10213 },
+	{ 10224, 10626 },
+	{ 10649, 10711 },
+	{ 10716, 10747 },
+	{ 10750, 11123 },
+	{ 11126, 11157 },
+	{ 11159, 11263 },
+	{ 11493, 11498 },
+	{ 11856, 11857 },
 	{ 11904, 11929 },
 	{ 11931, 12019 },
 	{ 12032, 12245 },
-	{ 12293, 12293 },
-	{ 12295, 12295 },
-	{ 12321, 12329 },
-	{ 12344, 12347 },
-	{ 13312, 19893 },
-	{ 19968, 40943 },
-	{ 63744, 64109 },
-	{ 64112, 64217 },
-};
-static const URange32 Han_range32[] = {
-	{ 131072, 173782 },
-	{ 173824, 177972 },
-	{ 177984, 178205 },
-	{ 178208, 183969 },
-	{ 183984, 191456 },
-	{ 194560, 195101 },
-};
-static const URange32 Old_North_Arabian_range32[] = {
-	{ 68224, 68255 },
-};
-static const URange16 Armenian_range16[] = {
-	{ 1329, 1366 },
-	{ 1369, 1416 },
-	{ 1418, 1418 },
-	{ 1421, 1423 },
-	{ 64275, 64279 },
-};
-static const URange16 Tamil_range16[] = {
-	{ 2946, 2947 },
-	{ 2949, 2954 },
-	{ 2958, 2960 },
-	{ 2962, 2965 },
-	{ 2969, 2970 },
-	{ 2972, 2972 },
-	{ 2974, 2975 },
-	{ 2979, 2980 },
-	{ 2984, 2986 },
-	{ 2990, 3001 },
-	{ 3006, 3010 },
-	{ 3014, 3016 },
-	{ 3018, 3021 },
-	{ 3024, 3024 },
-	{ 3031, 3031 },
-	{ 3046, 3066 },
-};
-static const URange16 Bopomofo_range16[] = {
-	{ 746, 747 },
-	{ 12549, 12591 },
-	{ 12704, 12730 },
-};
-static const URange32 Bassa_Vah_range32[] = {
-	{ 92880, 92909 },
-	{ 92912, 92917 },
-};
-static const URange16 Sundanese_range16[] = {
-	{ 7040, 7103 },
-	{ 7360, 7367 },
-};
-static const URange32 Osage_range32[] = {
-	{ 66736, 66771 },
-	{ 66776, 66811 },
-};
-static const URange32 Old_Sogdian_range32[] = {
-	{ 69376, 69415 },
-};
-static const URange16 Tagalog_range16[] = {
-	{ 5888, 5900 },
-	{ 5902, 5908 },
+	{ 12272, 12283 },
+	{ 12292, 12292 },
+	{ 12306, 12307 },
+	{ 12320, 12320 },
+	{ 12342, 12343 },
+	{ 12350, 12351 },
+	{ 12443, 12444 },
+	{ 12688, 12689 },
+	{ 12694, 12703 },
+	{ 12736, 12771 },
+	{ 12800, 12830 },
+	{ 12842, 12871 },
+	{ 12880, 12880 },
+	{ 12896, 12927 },
+	{ 12938, 12976 },
+	{ 12992, 13311 },
+	{ 19904, 19967 },
+	{ 42128, 42182 },
+	{ 42752, 42774 },
+	{ 42784, 42785 },
+	{ 42889, 42890 },
+	{ 43048, 43051 },
+	{ 43062, 43065 },
+	{ 43639, 43641 },
+	{ 43867, 43867 },
+	{ 43882, 43883 },
+	{ 64297, 64297 },
+	{ 64434, 64450 },
+	{ 64832, 64847 },
+	{ 64975, 64975 },
+	{ 65020, 65023 },
+	{ 65122, 65122 },
+	{ 65124, 65126 },
+	{ 65129, 65129 },
+	{ 65284, 65284 },
+	{ 65291, 65291 },
+	{ 65308, 65310 },
+	{ 65342, 65342 },
+	{ 65344, 65344 },
+	{ 65372, 65372 },
+	{ 65374, 65374 },
+	{ 65504, 65510 },
+	{ 65512, 65518 },
+	{ 65532, 65533 },
 };
-static const URange16 Malayalam_range16[] = {
-	{ 3328, 3331 },
-	{ 3333, 3340 },
-	{ 3342, 3344 },
-	{ 3346, 3396 },
-	{ 3398, 3400 },
-	{ 3402, 3407 },
-	{ 3412, 3427 },
-	{ 3430, 3455 },
+static const URange32 S_range32[] = {
+	{ 65847, 65855 },
+	{ 65913, 65929 },
+	{ 65932, 65934 },
+	{ 65936, 65948 },
+	{ 65952, 65952 },
+	{ 66000, 66044 },
+	{ 67703, 67704 },
+	{ 68296, 68296 },
+	{ 71487, 71487 },
+	{ 73685, 73713 },
+	{ 92988, 92991 },
+	{ 92997, 92997 },
+	{ 113820, 113820 },
+	{ 118608, 118723 },
+	{ 118784, 119029 },
+	{ 119040, 119078 },
+	{ 119081, 119140 },
+	{ 119146, 119148 },
+	{ 119171, 119172 },
+	{ 119180, 119209 },
+	{ 119214, 119274 },
+	{ 119296, 119361 },
+	{ 119365, 119365 },
+	{ 119552, 119638 },
+	{ 120513, 120513 },
+	{ 120539, 120539 },
+	{ 120571, 120571 },
+	{ 120597, 120597 },
+	{ 120629, 120629 },
+	{ 120655, 120655 },
+	{ 120687, 120687 },
+	{ 120713, 120713 },
+	{ 120745, 120745 },
+	{ 120771, 120771 },
+	{ 120832, 121343 },
+	{ 121399, 121402 },
+	{ 121453, 121460 },
+	{ 121462, 121475 },
+	{ 121477, 121478 },
+	{ 123215, 123215 },
+	{ 123647, 123647 },
+	{ 126124, 126124 },
+	{ 126128, 126128 },
+	{ 126254, 126254 },
+	{ 126704, 126705 },
+	{ 126976, 127019 },
+	{ 127024, 127123 },
+	{ 127136, 127150 },
+	{ 127153, 127167 },
+	{ 127169, 127183 },
+	{ 127185, 127221 },
+	{ 127245, 127405 },
+	{ 127462, 127490 },
+	{ 127504, 127547 },
+	{ 127552, 127560 },
+	{ 127568, 127569 },
+	{ 127584, 127589 },
+	{ 127744, 128727 },
+	{ 128732, 128748 },
+	{ 128752, 128764 },
+	{ 128768, 128886 },
+	{ 128891, 128985 },
+	{ 128992, 129003 },
+	{ 129008, 129008 },
+	{ 129024, 129035 },
+	{ 129040, 129095 },
+	{ 129104, 129113 },
+	{ 129120, 129159 },
+	{ 129168, 129197 },
+	{ 129200, 129201 },
+	{ 129280, 129619 },
+	{ 129632, 129645 },
+	{ 129648, 129660 },
+	{ 129664, 129672 },
+	{ 129680, 129725 },
+	{ 129727, 129733 },
+	{ 129742, 129755 },
+	{ 129760, 129768 },
+	{ 129776, 129784 },
+	{ 129792, 129938 },
+	{ 129940, 129994 },
 };
-static const URange32 Marchen_range32[] = {
-	{ 72816, 72847 },
-	{ 72850, 72871 },
-	{ 72873, 72886 },
+static const URange16 Sc_range16[] = {
+	{ 36, 36 },
+	{ 162, 165 },
+	{ 1423, 1423 },
+	{ 1547, 1547 },
+	{ 2046, 2047 },
+	{ 2546, 2547 },
+	{ 2555, 2555 },
+	{ 2801, 2801 },
+	{ 3065, 3065 },
+	{ 3647, 3647 },
+	{ 6107, 6107 },
+	{ 8352, 8384 },
+	{ 43064, 43064 },
+	{ 65020, 65020 },
+	{ 65129, 65129 },
+	{ 65284, 65284 },
+	{ 65504, 65505 },
+	{ 65509, 65510 },
 };
-static const URange32 Carian_range32[] = {
-	{ 66208, 66256 },
+static const URange32 Sc_range32[] = {
+	{ 73693, 73696 },
+	{ 123647, 123647 },
+	{ 126128, 126128 },
 };
-static const URange16 Hiragana_range16[] = {
-	{ 12353, 12438 },
-	{ 12445, 12447 },
+static const URange16 Sk_range16[] = {
+	{ 94, 94 },
+	{ 96, 96 },
+	{ 168, 168 },
+	{ 175, 175 },
+	{ 180, 180 },
+	{ 184, 184 },
+	{ 706, 709 },
+	{ 722, 735 },
+	{ 741, 747 },
+	{ 749, 749 },
+	{ 751, 767 },
+	{ 885, 885 },
+	{ 900, 901 },
+	{ 2184, 2184 },
+	{ 8125, 8125 },
+	{ 8127, 8129 },
+	{ 8141, 8143 },
+	{ 8157, 8159 },
+	{ 8173, 8175 },
+	{ 8189, 8190 },
+	{ 12443, 12444 },
+	{ 42752, 42774 },
+	{ 42784, 42785 },
+	{ 42889, 42890 },
+	{ 43867, 43867 },
+	{ 43882, 43883 },
+	{ 64434, 64450 },
+	{ 65342, 65342 },
+	{ 65344, 65344 },
+	{ 65507, 65507 },
 };
-static const URange32 Hiragana_range32[] = {
-	{ 110593, 110878 },
-	{ 127488, 127488 },
+static const URange32 Sk_range32[] = {
+	{ 127995, 127999 },
 };
-static const URange16 Tagbanwa_range16[] = {
-	{ 5984, 5996 },
-	{ 5998, 6000 },
-	{ 6002, 6003 },
+static const URange16 Sm_range16[] = {
+	{ 43, 43 },
+	{ 60, 62 },
+	{ 124, 124 },
+	{ 126, 126 },
+	{ 172, 172 },
+	{ 177, 177 },
+	{ 215, 215 },
+	{ 247, 247 },
+	{ 1014, 1014 },
+	{ 1542, 1544 },
+	{ 8260, 8260 },
+	{ 8274, 8274 },
+	{ 8314, 8316 },
+	{ 8330, 8332 },
+	{ 8472, 8472 },
+	{ 8512, 8516 },
+	{ 8523, 8523 },
+	{ 8592, 8596 },
+	{ 8602, 8603 },
+	{ 8608, 8608 },
+	{ 8611, 8611 },
+	{ 8614, 8614 },
+	{ 8622, 8622 },
+	{ 8654, 8655 },
+	{ 8658, 8658 },
+	{ 8660, 8660 },
+	{ 8692, 8959 },
+	{ 8992, 8993 },
+	{ 9084, 9084 },
+	{ 9115, 9139 },
+	{ 9180, 9185 },
+	{ 9655, 9655 },
+	{ 9665, 9665 },
+	{ 9720, 9727 },
+	{ 9839, 9839 },
+	{ 10176, 10180 },
+	{ 10183, 10213 },
+	{ 10224, 10239 },
+	{ 10496, 10626 },
+	{ 10649, 10711 },
+	{ 10716, 10747 },
+	{ 10750, 11007 },
+	{ 11056, 11076 },
+	{ 11079, 11084 },
+	{ 64297, 64297 },
+	{ 65122, 65122 },
+	{ 65124, 65126 },
+	{ 65291, 65291 },
+	{ 65308, 65310 },
+	{ 65372, 65372 },
+	{ 65374, 65374 },
+	{ 65506, 65506 },
+	{ 65513, 65516 },
 };
-static const URange16 Meetei_Mayek_range16[] = {
-	{ 43744, 43766 },
-	{ 43968, 44013 },
-	{ 44016, 44025 },
+static const URange32 Sm_range32[] = {
+	{ 120513, 120513 },
+	{ 120539, 120539 },
+	{ 120571, 120571 },
+	{ 120597, 120597 },
+	{ 120629, 120629 },
+	{ 120655, 120655 },
+	{ 120687, 120687 },
+	{ 120713, 120713 },
+	{ 120745, 120745 },
+	{ 120771, 120771 },
+	{ 126704, 126705 },
 };
-static const URange32 Hanifi_Rohingya_range32[] = {
-	{ 68864, 68903 },
-	{ 68912, 68921 },
+static const URange16 So_range16[] = {
+	{ 166, 166 },
+	{ 169, 169 },
+	{ 174, 174 },
+	{ 176, 176 },
+	{ 1154, 1154 },
+	{ 1421, 1422 },
+	{ 1550, 1551 },
+	{ 1758, 1758 },
+	{ 1769, 1769 },
+	{ 1789, 1790 },
+	{ 2038, 2038 },
+	{ 2554, 2554 },
+	{ 2928, 2928 },
+	{ 3059, 3064 },
+	{ 3066, 3066 },
+	{ 3199, 3199 },
+	{ 3407, 3407 },
+	{ 3449, 3449 },
+	{ 3841, 3843 },
+	{ 3859, 3859 },
+	{ 3861, 3863 },
+	{ 3866, 3871 },
+	{ 3892, 3892 },
+	{ 3894, 3894 },
+	{ 3896, 3896 },
+	{ 4030, 4037 },
+	{ 4039, 4044 },
+	{ 4046, 4047 },
+	{ 4053, 4056 },
+	{ 4254, 4255 },
+	{ 5008, 5017 },
+	{ 5741, 5741 },
+	{ 6464, 6464 },
+	{ 6622, 6655 },
+	{ 7009, 7018 },
+	{ 7028, 7036 },
+	{ 8448, 8449 },
+	{ 8451, 8454 },
+	{ 8456, 8457 },
+	{ 8468, 8468 },
+	{ 8470, 8471 },
+	{ 8478, 8483 },
+	{ 8485, 8485 },
+	{ 8487, 8487 },
+	{ 8489, 8489 },
+	{ 8494, 8494 },
+	{ 8506, 8507 },
+	{ 8522, 8522 },
+	{ 8524, 8525 },
+	{ 8527, 8527 },
+	{ 8586, 8587 },
+	{ 8597, 8601 },
+	{ 8604, 8607 },
+	{ 8609, 8610 },
+	{ 8612, 8613 },
+	{ 8615, 8621 },
+	{ 8623, 8653 },
+	{ 8656, 8657 },
+	{ 8659, 8659 },
+	{ 8661, 8691 },
+	{ 8960, 8967 },
+	{ 8972, 8991 },
+	{ 8994, 9000 },
+	{ 9003, 9083 },
+	{ 9085, 9114 },
+	{ 9140, 9179 },
+	{ 9186, 9254 },
+	{ 9280, 9290 },
+	{ 9372, 9449 },
+	{ 9472, 9654 },
+	{ 9656, 9664 },
+	{ 9666, 9719 },
+	{ 9728, 9838 },
+	{ 9840, 10087 },
+	{ 10132, 10175 },
+	{ 10240, 10495 },
+	{ 11008, 11055 },
+	{ 11077, 11078 },
+	{ 11085, 11123 },
+	{ 11126, 11157 },
+	{ 11159, 11263 },
+	{ 11493, 11498 },
+	{ 11856, 11857 },
+	{ 11904, 11929 },
+	{ 11931, 12019 },
+	{ 12032, 12245 },
+	{ 12272, 12283 },
+	{ 12292, 12292 },
+	{ 12306, 12307 },
+	{ 12320, 12320 },
+	{ 12342, 12343 },
+	{ 12350, 12351 },
+	{ 12688, 12689 },
+	{ 12694, 12703 },
+	{ 12736, 12771 },
+	{ 12800, 12830 },
+	{ 12842, 12871 },
+	{ 12880, 12880 },
+	{ 12896, 12927 },
+	{ 12938, 12976 },
+	{ 12992, 13311 },
+	{ 19904, 19967 },
+	{ 42128, 42182 },
+	{ 43048, 43051 },
+	{ 43062, 43063 },
+	{ 43065, 43065 },
+	{ 43639, 43641 },
+	{ 64832, 64847 },
+	{ 64975, 64975 },
+	{ 65021, 65023 },
+	{ 65508, 65508 },
+	{ 65512, 65512 },
+	{ 65517, 65518 },
+	{ 65532, 65533 },
 };
-static const URange32 Pahawh_Hmong_range32[] = {
-	{ 92928, 92997 },
-	{ 93008, 93017 },
-	{ 93019, 93025 },
-	{ 93027, 93047 },
-	{ 93053, 93071 },
+static const URange32 So_range32[] = {
+	{ 65847, 65855 },
+	{ 65913, 65929 },
+	{ 65932, 65934 },
+	{ 65936, 65948 },
+	{ 65952, 65952 },
+	{ 66000, 66044 },
+	{ 67703, 67704 },
+	{ 68296, 68296 },
+	{ 71487, 71487 },
+	{ 73685, 73692 },
+	{ 73697, 73713 },
+	{ 92988, 92991 },
+	{ 92997, 92997 },
+	{ 113820, 113820 },
+	{ 118608, 118723 },
+	{ 118784, 119029 },
+	{ 119040, 119078 },
+	{ 119081, 119140 },
+	{ 119146, 119148 },
+	{ 119171, 119172 },
+	{ 119180, 119209 },
+	{ 119214, 119274 },
+	{ 119296, 119361 },
+	{ 119365, 119365 },
+	{ 119552, 119638 },
+	{ 120832, 121343 },
+	{ 121399, 121402 },
+	{ 121453, 121460 },
+	{ 121462, 121475 },
+	{ 121477, 121478 },
+	{ 123215, 123215 },
+	{ 126124, 126124 },
+	{ 126254, 126254 },
+	{ 126976, 127019 },
+	{ 127024, 127123 },
+	{ 127136, 127150 },
+	{ 127153, 127167 },
+	{ 127169, 127183 },
+	{ 127185, 127221 },
+	{ 127245, 127405 },
+	{ 127462, 127490 },
+	{ 127504, 127547 },
+	{ 127552, 127560 },
+	{ 127568, 127569 },
+	{ 127584, 127589 },
+	{ 127744, 127994 },
+	{ 128000, 128727 },
+	{ 128732, 128748 },
+	{ 128752, 128764 },
+	{ 128768, 128886 },
+	{ 128891, 128985 },
+	{ 128992, 129003 },
+	{ 129008, 129008 },
+	{ 129024, 129035 },
+	{ 129040, 129095 },
+	{ 129104, 129113 },
+	{ 129120, 129159 },
+	{ 129168, 129197 },
+	{ 129200, 129201 },
+	{ 129280, 129619 },
+	{ 129632, 129645 },
+	{ 129648, 129660 },
+	{ 129664, 129672 },
+	{ 129680, 129725 },
+	{ 129727, 129733 },
+	{ 129742, 129755 },
+	{ 129760, 129768 },
+	{ 129776, 129784 },
+	{ 129792, 129938 },
+	{ 129940, 129994 },
 };
-static const URange16 Tai_Le_range16[] = {
-	{ 6480, 6509 },
-	{ 6512, 6516 },
+static const URange16 Z_range16[] = {
+	{ 32, 32 },
+	{ 160, 160 },
+	{ 5760, 5760 },
+	{ 8192, 8202 },
+	{ 8232, 8233 },
+	{ 8239, 8239 },
+	{ 8287, 8287 },
+	{ 12288, 12288 },
 };
-static const URange16 Kayah_Li_range16[] = {
-	{ 43264, 43309 },
-	{ 43311, 43311 },
+static const URange16 Zl_range16[] = {
+	{ 8232, 8232 },
 };
-static const URange16 Buginese_range16[] = {
-	{ 6656, 6683 },
-	{ 6686, 6687 },
+static const URange16 Zp_range16[] = {
+	{ 8233, 8233 },
 };
-static const URange32 Kharoshthi_range32[] = {
-	{ 68096, 68099 },
-	{ 68101, 68102 },
-	{ 68108, 68115 },
-	{ 68117, 68119 },
-	{ 68121, 68149 },
-	{ 68152, 68154 },
-	{ 68159, 68168 },
-	{ 68176, 68184 },
+static const URange16 Zs_range16[] = {
+	{ 32, 32 },
+	{ 160, 160 },
+	{ 5760, 5760 },
+	{ 8192, 8202 },
+	{ 8239, 8239 },
+	{ 8287, 8287 },
+	{ 12288, 12288 },
 };
-static const URange16 Tai_Tham_range16[] = {
-	{ 6688, 6750 },
-	{ 6752, 6780 },
-	{ 6783, 6793 },
-	{ 6800, 6809 },
-	{ 6816, 6829 },
+static const URange32 Adlam_range32[] = {
+	{ 125184, 125259 },
+	{ 125264, 125273 },
+	{ 125278, 125279 },
 };
-static const URange32 Old_Italic_range32[] = {
-	{ 66304, 66339 },
-	{ 66349, 66351 },
+static const URange32 Ahom_range32[] = {
+	{ 71424, 71450 },
+	{ 71453, 71467 },
+	{ 71472, 71494 },
 };
-static const URange32 Old_Persian_range32[] = {
-	{ 66464, 66499 },
-	{ 66504, 66517 },
+static const URange32 Anatolian_Hieroglyphs_range32[] = {
+	{ 82944, 83526 },
 };
-static const URange32 Warang_Citi_range32[] = {
-	{ 71840, 71922 },
-	{ 71935, 71935 },
+static const URange16 Arabic_range16[] = {
+	{ 1536, 1540 },
+	{ 1542, 1547 },
+	{ 1549, 1562 },
+	{ 1564, 1566 },
+	{ 1568, 1599 },
+	{ 1601, 1610 },
+	{ 1622, 1647 },
+	{ 1649, 1756 },
+	{ 1758, 1791 },
+	{ 1872, 1919 },
+	{ 2160, 2190 },
+	{ 2192, 2193 },
+	{ 2200, 2273 },
+	{ 2275, 2303 },
+	{ 64336, 64450 },
+	{ 64467, 64829 },
+	{ 64832, 64911 },
+	{ 64914, 64967 },
+	{ 64975, 64975 },
+	{ 65008, 65023 },
+	{ 65136, 65140 },
+	{ 65142, 65276 },
 };
-static const URange16 Latin_range16[] = {
-	{ 65, 90 },
-	{ 97, 122 },
-	{ 170, 170 },
-	{ 186, 186 },
-	{ 192, 214 },
-	{ 216, 246 },
-	{ 248, 696 },
-	{ 736, 740 },
-	{ 7424, 7461 },
-	{ 7468, 7516 },
-	{ 7522, 7525 },
-	{ 7531, 7543 },
-	{ 7545, 7614 },
-	{ 7680, 7935 },
-	{ 8305, 8305 },
-	{ 8319, 8319 },
-	{ 8336, 8348 },
-	{ 8490, 8491 },
-	{ 8498, 8498 },
-	{ 8526, 8526 },
-	{ 8544, 8584 },
-	{ 11360, 11391 },
-	{ 42786, 42887 },
-	{ 42891, 42937 },
-	{ 42999, 43007 },
-	{ 43824, 43866 },
-	{ 43868, 43876 },
-	{ 64256, 64262 },
-	{ 65313, 65338 },
-	{ 65345, 65370 },
+static const URange32 Arabic_range32[] = {
+	{ 69216, 69246 },
+	{ 69373, 69375 },
+	{ 126464, 126467 },
+	{ 126469, 126495 },
+	{ 126497, 126498 },
+	{ 126500, 126500 },
+	{ 126503, 126503 },
+	{ 126505, 126514 },
+	{ 126516, 126519 },
+	{ 126521, 126521 },
+	{ 126523, 126523 },
+	{ 126530, 126530 },
+	{ 126535, 126535 },
+	{ 126537, 126537 },
+	{ 126539, 126539 },
+	{ 126541, 126543 },
+	{ 126545, 126546 },
+	{ 126548, 126548 },
+	{ 126551, 126551 },
+	{ 126553, 126553 },
+	{ 126555, 126555 },
+	{ 126557, 126557 },
+	{ 126559, 126559 },
+	{ 126561, 126562 },
+	{ 126564, 126564 },
+	{ 126567, 126570 },
+	{ 126572, 126578 },
+	{ 126580, 126583 },
+	{ 126585, 126588 },
+	{ 126590, 126590 },
+	{ 126592, 126601 },
+	{ 126603, 126619 },
+	{ 126625, 126627 },
+	{ 126629, 126633 },
+	{ 126635, 126651 },
+	{ 126704, 126705 },
 };
-static const URange16 Saurashtra_range16[] = {
-	{ 43136, 43205 },
-	{ 43214, 43225 },
+static const URange16 Armenian_range16[] = {
+	{ 1329, 1366 },
+	{ 1369, 1418 },
+	{ 1421, 1423 },
+	{ 64275, 64279 },
 };
-static const URange32 Shavian_range32[] = {
-	{ 66640, 66687 },
+static const URange32 Avestan_range32[] = {
+	{ 68352, 68405 },
+	{ 68409, 68415 },
 };
-static const URange16 Georgian_range16[] = {
-	{ 4256, 4293 },
-	{ 4295, 4295 },
-	{ 4301, 4301 },
-	{ 4304, 4346 },
-	{ 4348, 4351 },
-	{ 7312, 7354 },
-	{ 7357, 7359 },
-	{ 11520, 11557 },
-	{ 11559, 11559 },
-	{ 11565, 11565 },
+static const URange16 Balinese_range16[] = {
+	{ 6912, 6988 },
+	{ 6992, 7038 },
 };
-static const URange32 Grantha_range32[] = {
-	{ 70400, 70403 },
-	{ 70405, 70412 },
-	{ 70415, 70416 },
-	{ 70419, 70440 },
-	{ 70442, 70448 },
-	{ 70450, 70451 },
-	{ 70453, 70457 },
-	{ 70460, 70468 },
-	{ 70471, 70472 },
-	{ 70475, 70477 },
-	{ 70480, 70480 },
-	{ 70487, 70487 },
-	{ 70493, 70499 },
-	{ 70502, 70508 },
-	{ 70512, 70516 },
+static const URange16 Bamum_range16[] = {
+	{ 42656, 42743 },
 };
-static const URange32 Duployan_range32[] = {
-	{ 113664, 113770 },
-	{ 113776, 113788 },
-	{ 113792, 113800 },
-	{ 113808, 113817 },
-	{ 113820, 113823 },
+static const URange32 Bamum_range32[] = {
+	{ 92160, 92728 },
+};
+static const URange32 Bassa_Vah_range32[] = {
+	{ 92880, 92909 },
+	{ 92912, 92917 },
 };
 static const URange16 Batak_range16[] = {
 	{ 7104, 7155 },
 	{ 7164, 7167 },
 };
-static const URange16 Devanagari_range16[] = {
-	{ 2304, 2384 },
-	{ 2387, 2403 },
-	{ 2406, 2431 },
-	{ 43232, 43263 },
-};
-static const URange16 Thai_range16[] = {
-	{ 3585, 3642 },
-	{ 3648, 3675 },
+static const URange16 Bengali_range16[] = {
+	{ 2432, 2435 },
+	{ 2437, 2444 },
+	{ 2447, 2448 },
+	{ 2451, 2472 },
+	{ 2474, 2480 },
+	{ 2482, 2482 },
+	{ 2486, 2489 },
+	{ 2492, 2500 },
+	{ 2503, 2504 },
+	{ 2507, 2510 },
+	{ 2519, 2519 },
+	{ 2524, 2525 },
+	{ 2527, 2531 },
+	{ 2534, 2558 },
 };
-static const URange16 Tibetan_range16[] = {
-	{ 3840, 3911 },
-	{ 3913, 3948 },
-	{ 3953, 3991 },
-	{ 3993, 4028 },
-	{ 4030, 4044 },
-	{ 4046, 4052 },
-	{ 4057, 4058 },
+static const URange32 Bhaiksuki_range32[] = {
+	{ 72704, 72712 },
+	{ 72714, 72758 },
+	{ 72760, 72773 },
+	{ 72784, 72812 },
 };
-static const URange16 Tifinagh_range16[] = {
-	{ 11568, 11623 },
-	{ 11631, 11632 },
-	{ 11647, 11647 },
+static const URange16 Bopomofo_range16[] = {
+	{ 746, 747 },
+	{ 12549, 12591 },
+	{ 12704, 12735 },
 };
-static const URange32 Ugaritic_range32[] = {
-	{ 66432, 66461 },
-	{ 66463, 66463 },
+static const URange32 Brahmi_range32[] = {
+	{ 69632, 69709 },
+	{ 69714, 69749 },
+	{ 69759, 69759 },
 };
 static const URange16 Braille_range16[] = {
 	{ 10240, 10495 },
 };
-static const URange32 Anatolian_Hieroglyphs_range32[] = {
-	{ 82944, 83526 },
+static const URange16 Buginese_range16[] = {
+	{ 6656, 6683 },
+	{ 6686, 6687 },
 };
-static const URange16 Greek_range16[] = {
-	{ 880, 883 },
-	{ 885, 887 },
-	{ 890, 893 },
-	{ 895, 895 },
-	{ 900, 900 },
-	{ 902, 902 },
-	{ 904, 906 },
-	{ 908, 908 },
-	{ 910, 929 },
-	{ 931, 993 },
-	{ 1008, 1023 },
-	{ 7462, 7466 },
-	{ 7517, 7521 },
-	{ 7526, 7530 },
-	{ 7615, 7615 },
-	{ 7936, 7957 },
-	{ 7960, 7965 },
-	{ 7968, 8005 },
-	{ 8008, 8013 },
-	{ 8016, 8023 },
-	{ 8025, 8025 },
-	{ 8027, 8027 },
-	{ 8029, 8029 },
-	{ 8031, 8061 },
-	{ 8064, 8116 },
-	{ 8118, 8132 },
-	{ 8134, 8147 },
-	{ 8150, 8155 },
-	{ 8157, 8175 },
-	{ 8178, 8180 },
-	{ 8182, 8190 },
-	{ 8486, 8486 },
-	{ 43877, 43877 },
+static const URange16 Buhid_range16[] = {
+	{ 5952, 5971 },
 };
-static const URange32 Greek_range32[] = {
-	{ 65856, 65934 },
-	{ 65952, 65952 },
-	{ 119296, 119365 },
+static const URange16 Canadian_Aboriginal_range16[] = {
+	{ 5120, 5759 },
+	{ 6320, 6389 },
 };
-static const URange32 Lycian_range32[] = {
-	{ 66176, 66204 },
+static const URange32 Canadian_Aboriginal_range32[] = {
+	{ 72368, 72383 },
+};
+static const URange32 Carian_range32[] = {
+	{ 66208, 66256 },
+};
+static const URange32 Caucasian_Albanian_range32[] = {
+	{ 66864, 66915 },
+	{ 66927, 66927 },
+};
+static const URange32 Chakma_range32[] = {
+	{ 69888, 69940 },
+	{ 69942, 69959 },
+};
+static const URange16 Cham_range16[] = {
+	{ 43520, 43574 },
+	{ 43584, 43597 },
+	{ 43600, 43609 },
+	{ 43612, 43615 },
+};
+static const URange16 Cherokee_range16[] = {
+	{ 5024, 5109 },
+	{ 5112, 5117 },
+	{ 43888, 43967 },
+};
+static const URange32 Chorasmian_range32[] = {
+	{ 69552, 69579 },
+};
+static const URange16 Common_range16[] = {
+	{ 0, 64 },
+	{ 91, 96 },
+	{ 123, 169 },
+	{ 171, 185 },
+	{ 187, 191 },
+	{ 215, 215 },
+	{ 247, 247 },
+	{ 697, 735 },
+	{ 741, 745 },
+	{ 748, 767 },
+	{ 884, 884 },
+	{ 894, 894 },
+	{ 901, 901 },
+	{ 903, 903 },
+	{ 1541, 1541 },
+	{ 1548, 1548 },
+	{ 1563, 1563 },
+	{ 1567, 1567 },
+	{ 1600, 1600 },
+	{ 1757, 1757 },
+	{ 2274, 2274 },
+	{ 2404, 2405 },
+	{ 3647, 3647 },
+	{ 4053, 4056 },
+	{ 4347, 4347 },
+	{ 5867, 5869 },
+	{ 5941, 5942 },
+	{ 6146, 6147 },
+	{ 6149, 6149 },
+	{ 7379, 7379 },
+	{ 7393, 7393 },
+	{ 7401, 7404 },
+	{ 7406, 7411 },
+	{ 7413, 7415 },
+	{ 7418, 7418 },
+	{ 8192, 8203 },
+	{ 8206, 8292 },
+	{ 8294, 8304 },
+	{ 8308, 8318 },
+	{ 8320, 8334 },
+	{ 8352, 8384 },
+	{ 8448, 8485 },
+	{ 8487, 8489 },
+	{ 8492, 8497 },
+	{ 8499, 8525 },
+	{ 8527, 8543 },
+	{ 8585, 8587 },
+	{ 8592, 9254 },
+	{ 9280, 9290 },
+	{ 9312, 10239 },
+	{ 10496, 11123 },
+	{ 11126, 11157 },
+	{ 11159, 11263 },
+	{ 11776, 11869 },
+	{ 12272, 12283 },
+	{ 12288, 12292 },
+	{ 12294, 12294 },
+	{ 12296, 12320 },
+	{ 12336, 12343 },
+	{ 12348, 12351 },
+	{ 12443, 12444 },
+	{ 12448, 12448 },
+	{ 12539, 12540 },
+	{ 12688, 12703 },
+	{ 12736, 12771 },
+	{ 12832, 12895 },
+	{ 12927, 13007 },
+	{ 13055, 13055 },
+	{ 13144, 13311 },
+	{ 19904, 19967 },
+	{ 42752, 42785 },
+	{ 42888, 42890 },
+	{ 43056, 43065 },
+	{ 43310, 43310 },
+	{ 43471, 43471 },
+	{ 43867, 43867 },
+	{ 43882, 43883 },
+	{ 64830, 64831 },
+	{ 65040, 65049 },
+	{ 65072, 65106 },
+	{ 65108, 65126 },
+	{ 65128, 65131 },
+	{ 65279, 65279 },
+	{ 65281, 65312 },
+	{ 65339, 65344 },
+	{ 65371, 65381 },
+	{ 65392, 65392 },
+	{ 65438, 65439 },
+	{ 65504, 65510 },
+	{ 65512, 65518 },
+	{ 65529, 65533 },
 };
-static const URange32 Mende_Kikakui_range32[] = {
-	{ 124928, 125124 },
-	{ 125127, 125142 },
+static const URange32 Common_range32[] = {
+	{ 65792, 65794 },
+	{ 65799, 65843 },
+	{ 65847, 65855 },
+	{ 65936, 65948 },
+	{ 66000, 66044 },
+	{ 66273, 66299 },
+	{ 113824, 113827 },
+	{ 118608, 118723 },
+	{ 118784, 119029 },
+	{ 119040, 119078 },
+	{ 119081, 119142 },
+	{ 119146, 119162 },
+	{ 119171, 119172 },
+	{ 119180, 119209 },
+	{ 119214, 119274 },
+	{ 119488, 119507 },
+	{ 119520, 119539 },
+	{ 119552, 119638 },
+	{ 119648, 119672 },
+	{ 119808, 119892 },
+	{ 119894, 119964 },
+	{ 119966, 119967 },
+	{ 119970, 119970 },
+	{ 119973, 119974 },
+	{ 119977, 119980 },
+	{ 119982, 119993 },
+	{ 119995, 119995 },
+	{ 119997, 120003 },
+	{ 120005, 120069 },
+	{ 120071, 120074 },
+	{ 120077, 120084 },
+	{ 120086, 120092 },
+	{ 120094, 120121 },
+	{ 120123, 120126 },
+	{ 120128, 120132 },
+	{ 120134, 120134 },
+	{ 120138, 120144 },
+	{ 120146, 120485 },
+	{ 120488, 120779 },
+	{ 120782, 120831 },
+	{ 126065, 126132 },
+	{ 126209, 126269 },
+	{ 126976, 127019 },
+	{ 127024, 127123 },
+	{ 127136, 127150 },
+	{ 127153, 127167 },
+	{ 127169, 127183 },
+	{ 127185, 127221 },
+	{ 127232, 127405 },
+	{ 127462, 127487 },
+	{ 127489, 127490 },
+	{ 127504, 127547 },
+	{ 127552, 127560 },
+	{ 127568, 127569 },
+	{ 127584, 127589 },
+	{ 127744, 128727 },
+	{ 128732, 128748 },
+	{ 128752, 128764 },
+	{ 128768, 128886 },
+	{ 128891, 128985 },
+	{ 128992, 129003 },
+	{ 129008, 129008 },
+	{ 129024, 129035 },
+	{ 129040, 129095 },
+	{ 129104, 129113 },
+	{ 129120, 129159 },
+	{ 129168, 129197 },
+	{ 129200, 129201 },
+	{ 129280, 129619 },
+	{ 129632, 129645 },
+	{ 129648, 129660 },
+	{ 129664, 129672 },
+	{ 129680, 129725 },
+	{ 129727, 129733 },
+	{ 129742, 129755 },
+	{ 129760, 129768 },
+	{ 129776, 129784 },
+	{ 129792, 129938 },
+	{ 129940, 129994 },
+	{ 130032, 130041 },
+	{ 917505, 917505 },
+	{ 917536, 917631 },
 };
-static const URange16 Tai_Viet_range16[] = {
-	{ 43648, 43714 },
-	{ 43739, 43743 },
+static const URange16 Coptic_range16[] = {
+	{ 994, 1007 },
+	{ 11392, 11507 },
+	{ 11513, 11519 },
 };
-static const URange16 Vai_range16[] = {
-	{ 42240, 42539 },
+static const URange32 Cuneiform_range32[] = {
+	{ 73728, 74649 },
+	{ 74752, 74862 },
+	{ 74864, 74868 },
+	{ 74880, 75075 },
 };
-static const URange16 Ogham_range16[] = {
-	{ 5760, 5788 },
+static const URange32 Cypriot_range32[] = {
+	{ 67584, 67589 },
+	{ 67592, 67592 },
+	{ 67594, 67637 },
+	{ 67639, 67640 },
+	{ 67644, 67644 },
+	{ 67647, 67647 },
 };
-static const URange32 Inscriptional_Parthian_range32[] = {
-	{ 68416, 68437 },
-	{ 68440, 68447 },
+static const URange32 Cypro_Minoan_range32[] = {
+	{ 77712, 77810 },
 };
-static const URange16 Cham_range16[] = {
-	{ 43520, 43574 },
-	{ 43584, 43597 },
-	{ 43600, 43609 },
-	{ 43612, 43615 },
+static const URange16 Cyrillic_range16[] = {
+	{ 1024, 1156 },
+	{ 1159, 1327 },
+	{ 7296, 7304 },
+	{ 7467, 7467 },
+	{ 7544, 7544 },
+	{ 11744, 11775 },
+	{ 42560, 42655 },
+	{ 65070, 65071 },
 };
-static const URange16 Syriac_range16[] = {
-	{ 1792, 1805 },
-	{ 1807, 1866 },
-	{ 1869, 1871 },
-	{ 2144, 2154 },
+static const URange32 Cyrillic_range32[] = {
+	{ 122928, 122989 },
+	{ 123023, 123023 },
 };
-static const URange16 Runic_range16[] = {
-	{ 5792, 5866 },
-	{ 5870, 5880 },
+static const URange32 Deseret_range32[] = {
+	{ 66560, 66639 },
 };
-static const URange32 Gothic_range32[] = {
-	{ 66352, 66378 },
+static const URange16 Devanagari_range16[] = {
+	{ 2304, 2384 },
+	{ 2389, 2403 },
+	{ 2406, 2431 },
+	{ 43232, 43263 },
 };
-static const URange32 Mahajani_range32[] = {
-	{ 69968, 70006 },
+static const URange32 Devanagari_range32[] = {
+	{ 72448, 72457 },
 };
-static const URange16 Katakana_range16[] = {
-	{ 12449, 12538 },
-	{ 12541, 12543 },
-	{ 12784, 12799 },
-	{ 13008, 13054 },
-	{ 13056, 13143 },
-	{ 65382, 65391 },
-	{ 65393, 65437 },
+static const URange32 Dives_Akuru_range32[] = {
+	{ 71936, 71942 },
+	{ 71945, 71945 },
+	{ 71948, 71955 },
+	{ 71957, 71958 },
+	{ 71960, 71989 },
+	{ 71991, 71992 },
+	{ 71995, 72006 },
+	{ 72016, 72025 },
 };
-static const URange32 Katakana_range32[] = {
-	{ 110592, 110592 },
+static const URange32 Dogra_range32[] = {
+	{ 71680, 71739 },
 };
-static const URange32 Osmanya_range32[] = {
-	{ 66688, 66717 },
-	{ 66720, 66729 },
+static const URange32 Duployan_range32[] = {
+	{ 113664, 113770 },
+	{ 113776, 113788 },
+	{ 113792, 113800 },
+	{ 113808, 113817 },
+	{ 113820, 113823 },
 };
-static const URange16 New_Tai_Lue_range16[] = {
-	{ 6528, 6571 },
-	{ 6576, 6601 },
-	{ 6608, 6618 },
-	{ 6622, 6623 },
+static const URange32 Egyptian_Hieroglyphs_range32[] = {
+	{ 77824, 78933 },
 };
-static const URange16 Ol_Chiki_range16[] = {
-	{ 7248, 7295 },
+static const URange32 Elbasan_range32[] = {
+	{ 66816, 66855 },
 };
-static const URange32 Newa_range32[] = {
-	{ 70656, 70745 },
-	{ 70747, 70747 },
-	{ 70749, 70750 },
+static const URange32 Elymaic_range32[] = {
+	{ 69600, 69622 },
 };
-static const URange16 Limbu_range16[] = {
-	{ 6400, 6430 },
-	{ 6432, 6443 },
-	{ 6448, 6459 },
-	{ 6464, 6464 },
-	{ 6468, 6479 },
+static const URange16 Ethiopic_range16[] = {
+	{ 4608, 4680 },
+	{ 4682, 4685 },
+	{ 4688, 4694 },
+	{ 4696, 4696 },
+	{ 4698, 4701 },
+	{ 4704, 4744 },
+	{ 4746, 4749 },
+	{ 4752, 4784 },
+	{ 4786, 4789 },
+	{ 4792, 4798 },
+	{ 4800, 4800 },
+	{ 4802, 4805 },
+	{ 4808, 4822 },
+	{ 4824, 4880 },
+	{ 4882, 4885 },
+	{ 4888, 4954 },
+	{ 4957, 4988 },
+	{ 4992, 5017 },
+	{ 11648, 11670 },
+	{ 11680, 11686 },
+	{ 11688, 11694 },
+	{ 11696, 11702 },
+	{ 11704, 11710 },
+	{ 11712, 11718 },
+	{ 11720, 11726 },
+	{ 11728, 11734 },
+	{ 11736, 11742 },
+	{ 43777, 43782 },
+	{ 43785, 43790 },
+	{ 43793, 43798 },
+	{ 43808, 43814 },
+	{ 43816, 43822 },
 };
-static const URange32 Pau_Cin_Hau_range32[] = {
-	{ 72384, 72440 },
+static const URange32 Ethiopic_range32[] = {
+	{ 124896, 124902 },
+	{ 124904, 124907 },
+	{ 124909, 124910 },
+	{ 124912, 124926 },
 };
-static const URange16 Cherokee_range16[] = {
-	{ 5024, 5109 },
-	{ 5112, 5117 },
-	{ 43888, 43967 },
+static const URange16 Georgian_range16[] = {
+	{ 4256, 4293 },
+	{ 4295, 4295 },
+	{ 4301, 4301 },
+	{ 4304, 4346 },
+	{ 4348, 4351 },
+	{ 7312, 7354 },
+	{ 7357, 7359 },
+	{ 11520, 11557 },
+	{ 11559, 11559 },
+	{ 11565, 11565 },
 };
-static const URange32 Miao_range32[] = {
-	{ 93952, 94020 },
-	{ 94032, 94078 },
-	{ 94095, 94111 },
+static const URange16 Glagolitic_range16[] = {
+	{ 11264, 11359 },
 };
-static const URange16 Oriya_range16[] = {
-	{ 2817, 2819 },
-	{ 2821, 2828 },
-	{ 2831, 2832 },
-	{ 2835, 2856 },
-	{ 2858, 2864 },
-	{ 2866, 2867 },
-	{ 2869, 2873 },
-	{ 2876, 2884 },
-	{ 2887, 2888 },
-	{ 2891, 2893 },
-	{ 2902, 2903 },
-	{ 2908, 2909 },
-	{ 2911, 2915 },
-	{ 2918, 2935 },
+static const URange32 Glagolitic_range32[] = {
+	{ 122880, 122886 },
+	{ 122888, 122904 },
+	{ 122907, 122913 },
+	{ 122915, 122916 },
+	{ 122918, 122922 },
 };
-static const URange32 Medefaidrin_range32[] = {
-	{ 93760, 93850 },
+static const URange32 Gothic_range32[] = {
+	{ 66352, 66378 },
 };
-static const URange32 Sharada_range32[] = {
-	{ 70016, 70093 },
-	{ 70096, 70111 },
+static const URange32 Grantha_range32[] = {
+	{ 70400, 70403 },
+	{ 70405, 70412 },
+	{ 70415, 70416 },
+	{ 70419, 70440 },
+	{ 70442, 70448 },
+	{ 70450, 70451 },
+	{ 70453, 70457 },
+	{ 70460, 70468 },
+	{ 70471, 70472 },
+	{ 70475, 70477 },
+	{ 70480, 70480 },
+	{ 70487, 70487 },
+	{ 70493, 70499 },
+	{ 70502, 70508 },
+	{ 70512, 70516 },
+};
+static const URange16 Greek_range16[] = {
+	{ 880, 883 },
+	{ 885, 887 },
+	{ 890, 893 },
+	{ 895, 895 },
+	{ 900, 900 },
+	{ 902, 902 },
+	{ 904, 906 },
+	{ 908, 908 },
+	{ 910, 929 },
+	{ 931, 993 },
+	{ 1008, 1023 },
+	{ 7462, 7466 },
+	{ 7517, 7521 },
+	{ 7526, 7530 },
+	{ 7615, 7615 },
+	{ 7936, 7957 },
+	{ 7960, 7965 },
+	{ 7968, 8005 },
+	{ 8008, 8013 },
+	{ 8016, 8023 },
+	{ 8025, 8025 },
+	{ 8027, 8027 },
+	{ 8029, 8029 },
+	{ 8031, 8061 },
+	{ 8064, 8116 },
+	{ 8118, 8132 },
+	{ 8134, 8147 },
+	{ 8150, 8155 },
+	{ 8157, 8175 },
+	{ 8178, 8180 },
+	{ 8182, 8190 },
+	{ 8486, 8486 },
+	{ 43877, 43877 },
+};
+static const URange32 Greek_range32[] = {
+	{ 65856, 65934 },
+	{ 65952, 65952 },
+	{ 119296, 119365 },
 };
 static const URange16 Gujarati_range16[] = {
 	{ 2689, 2691 },
@@ -5251,14 +5557,6 @@ static const URange16 Gujarati_range16[] = {
 	{ 2790, 2801 },
 	{ 2809, 2815 },
 };
-static const URange32 Nushu_range32[] = {
-	{ 94177, 94177 },
-	{ 110960, 111355 },
-};
-static const URange32 Modi_range32[] = {
-	{ 71168, 71236 },
-	{ 71248, 71257 },
-};
 static const URange32 Gunjala_Gondi_range32[] = {
 	{ 73056, 73061 },
 	{ 73063, 73064 },
@@ -5267,136 +5565,151 @@ static const URange32 Gunjala_Gondi_range32[] = {
 	{ 73107, 73112 },
 	{ 73120, 73129 },
 };
-static const URange32 Inscriptional_Pahlavi_range32[] = {
-	{ 68448, 68466 },
-	{ 68472, 68479 },
+static const URange16 Gurmukhi_range16[] = {
+	{ 2561, 2563 },
+	{ 2565, 2570 },
+	{ 2575, 2576 },
+	{ 2579, 2600 },
+	{ 2602, 2608 },
+	{ 2610, 2611 },
+	{ 2613, 2614 },
+	{ 2616, 2617 },
+	{ 2620, 2620 },
+	{ 2622, 2626 },
+	{ 2631, 2632 },
+	{ 2635, 2637 },
+	{ 2641, 2641 },
+	{ 2649, 2652 },
+	{ 2654, 2654 },
+	{ 2662, 2678 },
 };
-static const URange32 Manichaean_range32[] = {
-	{ 68288, 68326 },
-	{ 68331, 68342 },
+static const URange16 Han_range16[] = {
+	{ 11904, 11929 },
+	{ 11931, 12019 },
+	{ 12032, 12245 },
+	{ 12293, 12293 },
+	{ 12295, 12295 },
+	{ 12321, 12329 },
+	{ 12344, 12347 },
+	{ 13312, 19903 },
+	{ 19968, 40959 },
+	{ 63744, 64109 },
+	{ 64112, 64217 },
 };
-static const URange16 Khmer_range16[] = {
-	{ 6016, 6109 },
-	{ 6112, 6121 },
-	{ 6128, 6137 },
-	{ 6624, 6655 },
+static const URange32 Han_range32[] = {
+	{ 94178, 94179 },
+	{ 94192, 94193 },
+	{ 131072, 173791 },
+	{ 173824, 177977 },
+	{ 177984, 178205 },
+	{ 178208, 183969 },
+	{ 183984, 191456 },
+	{ 194560, 195101 },
+	{ 196608, 201546 },
+	{ 201552, 205743 },
 };
-static const URange32 Cuneiform_range32[] = {
-	{ 73728, 74649 },
-	{ 74752, 74862 },
-	{ 74864, 74868 },
-	{ 74880, 75075 },
+static const URange16 Hangul_range16[] = {
+	{ 4352, 4607 },
+	{ 12334, 12335 },
+	{ 12593, 12686 },
+	{ 12800, 12830 },
+	{ 12896, 12926 },
+	{ 43360, 43388 },
+	{ 44032, 55203 },
+	{ 55216, 55238 },
+	{ 55243, 55291 },
+	{ 65440, 65470 },
+	{ 65474, 65479 },
+	{ 65482, 65487 },
+	{ 65490, 65495 },
+	{ 65498, 65500 },
 };
-static const URange32 Khudawadi_range32[] = {
-	{ 70320, 70378 },
-	{ 70384, 70393 },
+static const URange32 Hanifi_Rohingya_range32[] = {
+	{ 68864, 68903 },
+	{ 68912, 68921 },
 };
-static const URange16 Mandaic_range16[] = {
-	{ 2112, 2139 },
-	{ 2142, 2142 },
+static const URange16 Hanunoo_range16[] = {
+	{ 5920, 5940 },
 };
 static const URange32 Hatran_range32[] = {
 	{ 67808, 67826 },
 	{ 67828, 67829 },
 	{ 67835, 67839 },
 };
-static const URange16 Syloti_Nagri_range16[] = {
-	{ 43008, 43051 },
-};
-static const URange16 Nko_range16[] = {
-	{ 1984, 2042 },
-	{ 2045, 2047 },
-};
-static const URange16 Canadian_Aboriginal_range16[] = {
-	{ 5120, 5759 },
-	{ 6320, 6389 },
-};
-static const URange32 Meroitic_Hieroglyphs_range32[] = {
-	{ 67968, 67999 },
-};
-static const URange32 Phoenician_range32[] = {
-	{ 67840, 67867 },
-	{ 67871, 67871 },
-};
-static const URange32 Nabataean_range32[] = {
-	{ 67712, 67742 },
-	{ 67751, 67759 },
-};
-static const URange16 Bengali_range16[] = {
-	{ 2432, 2435 },
-	{ 2437, 2444 },
-	{ 2447, 2448 },
-	{ 2451, 2472 },
-	{ 2474, 2480 },
-	{ 2482, 2482 },
-	{ 2486, 2489 },
-	{ 2492, 2500 },
-	{ 2503, 2504 },
-	{ 2507, 2510 },
-	{ 2519, 2519 },
-	{ 2524, 2525 },
-	{ 2527, 2531 },
-	{ 2534, 2558 },
-};
-static const URange32 Kaithi_range32[] = {
-	{ 69760, 69825 },
-	{ 69837, 69837 },
+static const URange16 Hebrew_range16[] = {
+	{ 1425, 1479 },
+	{ 1488, 1514 },
+	{ 1519, 1524 },
+	{ 64285, 64310 },
+	{ 64312, 64316 },
+	{ 64318, 64318 },
+	{ 64320, 64321 },
+	{ 64323, 64324 },
+	{ 64326, 64335 },
 };
-static const URange16 Glagolitic_range16[] = {
-	{ 11264, 11310 },
-	{ 11312, 11358 },
+static const URange16 Hiragana_range16[] = {
+	{ 12353, 12438 },
+	{ 12445, 12447 },
 };
-static const URange32 Glagolitic_range32[] = {
-	{ 122880, 122886 },
-	{ 122888, 122904 },
-	{ 122907, 122913 },
-	{ 122915, 122916 },
-	{ 122918, 122922 },
+static const URange32 Hiragana_range32[] = {
+	{ 110593, 110879 },
+	{ 110898, 110898 },
+	{ 110928, 110930 },
+	{ 127488, 127488 },
 };
 static const URange32 Imperial_Aramaic_range32[] = {
 	{ 67648, 67669 },
 	{ 67671, 67679 },
 };
-static const URange32 Sora_Sompeng_range32[] = {
-	{ 69840, 69864 },
-	{ 69872, 69881 },
+static const URange16 Inherited_range16[] = {
+	{ 768, 879 },
+	{ 1157, 1158 },
+	{ 1611, 1621 },
+	{ 1648, 1648 },
+	{ 2385, 2388 },
+	{ 6832, 6862 },
+	{ 7376, 7378 },
+	{ 7380, 7392 },
+	{ 7394, 7400 },
+	{ 7405, 7405 },
+	{ 7412, 7412 },
+	{ 7416, 7417 },
+	{ 7616, 7679 },
+	{ 8204, 8205 },
+	{ 8400, 8432 },
+	{ 12330, 12333 },
+	{ 12441, 12442 },
+	{ 65024, 65039 },
+	{ 65056, 65069 },
 };
-static const URange16 Gurmukhi_range16[] = {
-	{ 2561, 2563 },
-	{ 2565, 2570 },
-	{ 2575, 2576 },
-	{ 2579, 2600 },
-	{ 2602, 2608 },
-	{ 2610, 2611 },
-	{ 2613, 2614 },
-	{ 2616, 2617 },
-	{ 2620, 2620 },
-	{ 2622, 2626 },
-	{ 2631, 2632 },
-	{ 2635, 2637 },
-	{ 2641, 2641 },
-	{ 2649, 2652 },
-	{ 2654, 2654 },
-	{ 2662, 2678 },
+static const URange32 Inherited_range32[] = {
+	{ 66045, 66045 },
+	{ 66272, 66272 },
+	{ 70459, 70459 },
+	{ 118528, 118573 },
+	{ 118576, 118598 },
+	{ 119143, 119145 },
+	{ 119163, 119170 },
+	{ 119173, 119179 },
+	{ 119210, 119213 },
+	{ 917760, 917999 },
+};
+static const URange32 Inscriptional_Pahlavi_range32[] = {
+	{ 68448, 68466 },
+	{ 68472, 68479 },
+};
+static const URange32 Inscriptional_Parthian_range32[] = {
+	{ 68416, 68437 },
+	{ 68440, 68447 },
 };
 static const URange16 Javanese_range16[] = {
 	{ 43392, 43469 },
 	{ 43472, 43481 },
 	{ 43486, 43487 },
 };
-static const URange32 Old_Permic_range32[] = {
-	{ 66384, 66426 },
-};
-static const URange16 Phags_Pa_range16[] = {
-	{ 43072, 43127 },
-};
-static const URange32 Cypriot_range32[] = {
-	{ 67584, 67589 },
-	{ 67592, 67592 },
-	{ 67594, 67637 },
-	{ 67639, 67640 },
-	{ 67644, 67644 },
-	{ 67647, 67647 },
+static const URange32 Kaithi_range32[] = {
+	{ 69760, 69826 },
+	{ 69837, 69837 },
 };
 static const URange16 Kannada_range16[] = {
 	{ 3200, 3212 },
@@ -5408,109 +5721,138 @@ static const URange16 Kannada_range16[] = {
 	{ 3270, 3272 },
 	{ 3274, 3277 },
 	{ 3285, 3286 },
-	{ 3294, 3294 },
+	{ 3293, 3294 },
 	{ 3296, 3299 },
 	{ 3302, 3311 },
-	{ 3313, 3314 },
-};
-static const URange32 Khojki_range32[] = {
-	{ 70144, 70161 },
-	{ 70163, 70206 },
-};
-static const URange16 Mongolian_range16[] = {
-	{ 6144, 6145 },
-	{ 6148, 6148 },
-	{ 6150, 6158 },
-	{ 6160, 6169 },
-	{ 6176, 6264 },
-	{ 6272, 6314 },
-};
-static const URange32 Mongolian_range32[] = {
-	{ 71264, 71276 },
-};
-static const URange16 Sinhala_range16[] = {
-	{ 3458, 3459 },
-	{ 3461, 3478 },
-	{ 3482, 3505 },
-	{ 3507, 3515 },
-	{ 3517, 3517 },
-	{ 3520, 3526 },
-	{ 3530, 3530 },
-	{ 3535, 3540 },
-	{ 3542, 3542 },
-	{ 3544, 3551 },
-	{ 3558, 3567 },
-	{ 3570, 3572 },
+	{ 3313, 3315 },
 };
-static const URange32 Sinhala_range32[] = {
-	{ 70113, 70132 },
+static const URange16 Katakana_range16[] = {
+	{ 12449, 12538 },
+	{ 12541, 12543 },
+	{ 12784, 12799 },
+	{ 13008, 13054 },
+	{ 13056, 13143 },
+	{ 65382, 65391 },
+	{ 65393, 65437 },
 };
-static const URange32 Brahmi_range32[] = {
-	{ 69632, 69709 },
-	{ 69714, 69743 },
-	{ 69759, 69759 },
+static const URange32 Katakana_range32[] = {
+	{ 110576, 110579 },
+	{ 110581, 110587 },
+	{ 110589, 110590 },
+	{ 110592, 110592 },
+	{ 110880, 110882 },
+	{ 110933, 110933 },
+	{ 110948, 110951 },
 };
-static const URange32 Elbasan_range32[] = {
-	{ 66816, 66855 },
+static const URange32 Kawi_range32[] = {
+	{ 73472, 73488 },
+	{ 73490, 73530 },
+	{ 73534, 73561 },
 };
-static const URange32 Deseret_range32[] = {
-	{ 66560, 66639 },
+static const URange16 Kayah_Li_range16[] = {
+	{ 43264, 43309 },
+	{ 43311, 43311 },
 };
-static const URange16 Rejang_range16[] = {
-	{ 43312, 43347 },
-	{ 43359, 43359 },
+static const URange32 Kharoshthi_range32[] = {
+	{ 68096, 68099 },
+	{ 68101, 68102 },
+	{ 68108, 68115 },
+	{ 68117, 68119 },
+	{ 68121, 68149 },
+	{ 68152, 68154 },
+	{ 68159, 68168 },
+	{ 68176, 68184 },
 };
-static const URange32 SignWriting_range32[] = {
-	{ 120832, 121483 },
-	{ 121499, 121503 },
-	{ 121505, 121519 },
+static const URange32 Khitan_Small_Script_range32[] = {
+	{ 94180, 94180 },
+	{ 101120, 101589 },
 };
-static const URange32 Multani_range32[] = {
-	{ 70272, 70278 },
-	{ 70280, 70280 },
-	{ 70282, 70285 },
-	{ 70287, 70301 },
-	{ 70303, 70313 },
+static const URange16 Khmer_range16[] = {
+	{ 6016, 6109 },
+	{ 6112, 6121 },
+	{ 6128, 6137 },
+	{ 6624, 6655 },
 };
-static const URange16 Yi_range16[] = {
-	{ 40960, 42124 },
-	{ 42128, 42182 },
+static const URange32 Khojki_range32[] = {
+	{ 70144, 70161 },
+	{ 70163, 70209 },
 };
-static const URange16 Balinese_range16[] = {
-	{ 6912, 6987 },
-	{ 6992, 7036 },
+static const URange32 Khudawadi_range32[] = {
+	{ 70320, 70378 },
+	{ 70384, 70393 },
 };
 static const URange16 Lao_range16[] = {
 	{ 3713, 3714 },
 	{ 3716, 3716 },
-	{ 3719, 3720 },
-	{ 3722, 3722 },
-	{ 3725, 3725 },
-	{ 3732, 3735 },
-	{ 3737, 3743 },
-	{ 3745, 3747 },
+	{ 3718, 3722 },
+	{ 3724, 3747 },
 	{ 3749, 3749 },
-	{ 3751, 3751 },
-	{ 3754, 3755 },
-	{ 3757, 3769 },
-	{ 3771, 3773 },
+	{ 3751, 3773 },
 	{ 3776, 3780 },
 	{ 3782, 3782 },
-	{ 3784, 3789 },
+	{ 3784, 3790 },
 	{ 3792, 3801 },
 	{ 3804, 3807 },
 };
-static const URange16 Hanunoo_range16[] = {
-	{ 5920, 5940 },
+static const URange16 Latin_range16[] = {
+	{ 65, 90 },
+	{ 97, 122 },
+	{ 170, 170 },
+	{ 186, 186 },
+	{ 192, 214 },
+	{ 216, 246 },
+	{ 248, 696 },
+	{ 736, 740 },
+	{ 7424, 7461 },
+	{ 7468, 7516 },
+	{ 7522, 7525 },
+	{ 7531, 7543 },
+	{ 7545, 7614 },
+	{ 7680, 7935 },
+	{ 8305, 8305 },
+	{ 8319, 8319 },
+	{ 8336, 8348 },
+	{ 8490, 8491 },
+	{ 8498, 8498 },
+	{ 8526, 8526 },
+	{ 8544, 8584 },
+	{ 11360, 11391 },
+	{ 42786, 42887 },
+	{ 42891, 42954 },
+	{ 42960, 42961 },
+	{ 42963, 42963 },
+	{ 42965, 42969 },
+	{ 42994, 43007 },
+	{ 43824, 43866 },
+	{ 43868, 43876 },
+	{ 43878, 43881 },
+	{ 64256, 64262 },
+	{ 65313, 65338 },
+	{ 65345, 65370 },
 };
-static const URange32 Masaram_Gondi_range32[] = {
-	{ 72960, 72966 },
-	{ 72968, 72969 },
-	{ 72971, 73014 },
-	{ 73018, 73018 },
-	{ 73020, 73021 },
-	{ 73023, 73031 },
-	{ 73040, 73049 },
+static const URange32 Latin_range32[] = {
+	{ 67456, 67461 },
+	{ 67463, 67504 },
+	{ 67506, 67514 },
+	{ 122624, 122654 },
+	{ 122661, 122666 },
+};
+static const URange16 Lepcha_range16[] = {
+	{ 7168, 7223 },
+	{ 7227, 7241 },
+	{ 7245, 7247 },
+};
+static const URange16 Limbu_range16[] = {
+	{ 6400, 6430 },
+	{ 6432, 6443 },
+	{ 6448, 6459 },
+	{ 6464, 6464 },
+	{ 6468, 6479 },
+};
+static const URange32 Linear_A_range32[] = {
+	{ 67072, 67382 },
+	{ 67392, 67413 },
+	{ 67424, 67431 },
 };
 static const URange32 Linear_B_range32[] = {
 	{ 65536, 65547 },
@@ -5521,356 +5863,452 @@ static const URange32 Linear_B_range32[] = {
 	{ 65616, 65629 },
 	{ 65664, 65786 },
 };
-static const URange32 Linear_A_range32[] = {
-	{ 67072, 67382 },
-	{ 67392, 67413 },
-	{ 67424, 67431 },
+static const URange16 Lisu_range16[] = {
+	{ 42192, 42239 },
+};
+static const URange32 Lisu_range32[] = {
+	{ 73648, 73648 },
+};
+static const URange32 Lycian_range32[] = {
+	{ 66176, 66204 },
+};
+static const URange32 Lydian_range32[] = {
+	{ 67872, 67897 },
+	{ 67903, 67903 },
+};
+static const URange32 Mahajani_range32[] = {
+	{ 69968, 70006 },
+};
+static const URange32 Makasar_range32[] = {
+	{ 73440, 73464 },
+};
+static const URange16 Malayalam_range16[] = {
+	{ 3328, 3340 },
+	{ 3342, 3344 },
+	{ 3346, 3396 },
+	{ 3398, 3400 },
+	{ 3402, 3407 },
+	{ 3412, 3427 },
+	{ 3430, 3455 },
+};
+static const URange16 Mandaic_range16[] = {
+	{ 2112, 2139 },
+	{ 2142, 2142 },
+};
+static const URange32 Manichaean_range32[] = {
+	{ 68288, 68326 },
+	{ 68331, 68342 },
+};
+static const URange32 Marchen_range32[] = {
+	{ 72816, 72847 },
+	{ 72850, 72871 },
+	{ 72873, 72886 },
+};
+static const URange32 Masaram_Gondi_range32[] = {
+	{ 72960, 72966 },
+	{ 72968, 72969 },
+	{ 72971, 73014 },
+	{ 73018, 73018 },
+	{ 73020, 73021 },
+	{ 73023, 73031 },
+	{ 73040, 73049 },
+};
+static const URange32 Medefaidrin_range32[] = {
+	{ 93760, 93850 },
+};
+static const URange16 Meetei_Mayek_range16[] = {
+	{ 43744, 43766 },
+	{ 43968, 44013 },
+	{ 44016, 44025 },
+};
+static const URange32 Mende_Kikakui_range32[] = {
+	{ 124928, 125124 },
+	{ 125127, 125142 },
+};
+static const URange32 Meroitic_Cursive_range32[] = {
+	{ 68000, 68023 },
+	{ 68028, 68047 },
+	{ 68050, 68095 },
+};
+static const URange32 Meroitic_Hieroglyphs_range32[] = {
+	{ 67968, 67999 },
+};
+static const URange32 Miao_range32[] = {
+	{ 93952, 94026 },
+	{ 94031, 94087 },
+	{ 94095, 94111 },
+};
+static const URange32 Modi_range32[] = {
+	{ 71168, 71236 },
+	{ 71248, 71257 },
+};
+static const URange16 Mongolian_range16[] = {
+	{ 6144, 6145 },
+	{ 6148, 6148 },
+	{ 6150, 6169 },
+	{ 6176, 6264 },
+	{ 6272, 6314 },
+};
+static const URange32 Mongolian_range32[] = {
+	{ 71264, 71276 },
+};
+static const URange32 Mro_range32[] = {
+	{ 92736, 92766 },
+	{ 92768, 92777 },
+	{ 92782, 92783 },
+};
+static const URange32 Multani_range32[] = {
+	{ 70272, 70278 },
+	{ 70280, 70280 },
+	{ 70282, 70285 },
+	{ 70287, 70301 },
+	{ 70303, 70313 },
+};
+static const URange16 Myanmar_range16[] = {
+	{ 4096, 4255 },
+	{ 43488, 43518 },
+	{ 43616, 43647 },
+};
+static const URange32 Nabataean_range32[] = {
+	{ 67712, 67742 },
+	{ 67751, 67759 },
 };
-static const URange32 Dogra_range32[] = {
-	{ 71680, 71739 },
+static const URange32 Nag_Mundari_range32[] = {
+	{ 124112, 124153 },
 };
-static const URange32 Old_Turkic_range32[] = {
-	{ 68608, 68680 },
+static const URange32 Nandinagari_range32[] = {
+	{ 72096, 72103 },
+	{ 72106, 72151 },
+	{ 72154, 72164 },
 };
-static const URange16 Lepcha_range16[] = {
-	{ 7168, 7223 },
-	{ 7227, 7241 },
-	{ 7245, 7247 },
+static const URange16 New_Tai_Lue_range16[] = {
+	{ 6528, 6571 },
+	{ 6576, 6601 },
+	{ 6608, 6618 },
+	{ 6622, 6623 },
 };
-static const URange32 Lydian_range32[] = {
-	{ 67872, 67897 },
-	{ 67903, 67903 },
+static const URange32 Newa_range32[] = {
+	{ 70656, 70747 },
+	{ 70749, 70753 },
 };
-static const URange32 Egyptian_Hieroglyphs_range32[] = {
-	{ 77824, 78894 },
+static const URange16 Nko_range16[] = {
+	{ 1984, 2042 },
+	{ 2045, 2047 },
 };
-static const URange32 Sogdian_range32[] = {
-	{ 69424, 69465 },
+static const URange32 Nushu_range32[] = {
+	{ 94177, 94177 },
+	{ 110960, 111355 },
 };
-static const URange32 Caucasian_Albanian_range32[] = {
-	{ 66864, 66915 },
-	{ 66927, 66927 },
+static const URange32 Nyiakeng_Puachue_Hmong_range32[] = {
+	{ 123136, 123180 },
+	{ 123184, 123197 },
+	{ 123200, 123209 },
+	{ 123214, 123215 },
 };
-static const URange32 Makasar_range32[] = {
-	{ 73440, 73464 },
+static const URange16 Ogham_range16[] = {
+	{ 5760, 5788 },
+};
+static const URange16 Ol_Chiki_range16[] = {
+	{ 7248, 7295 },
 };
 static const URange32 Old_Hungarian_range32[] = {
 	{ 68736, 68786 },
 	{ 68800, 68850 },
 	{ 68858, 68863 },
 };
-static const URange16 Samaritan_range16[] = {
-	{ 2048, 2093 },
-	{ 2096, 2110 },
+static const URange32 Old_Italic_range32[] = {
+	{ 66304, 66339 },
+	{ 66349, 66351 },
 };
-static const URange16 Lisu_range16[] = {
-	{ 42192, 42239 },
+static const URange32 Old_North_Arabian_range32[] = {
+	{ 68224, 68255 },
 };
-static const URange16 Buhid_range16[] = {
-	{ 5952, 5971 },
+static const URange32 Old_Permic_range32[] = {
+	{ 66384, 66426 },
 };
-static const URange32 Palmyrene_range32[] = {
-	{ 67680, 67711 },
+static const URange32 Old_Persian_range32[] = {
+	{ 66464, 66499 },
+	{ 66504, 66517 },
 };
-static const URange32 Tirhuta_range32[] = {
-	{ 70784, 70855 },
-	{ 70864, 70873 },
+static const URange32 Old_Sogdian_range32[] = {
+	{ 69376, 69415 },
 };
-static const URange32 Mro_range32[] = {
-	{ 92736, 92766 },
-	{ 92768, 92777 },
-	{ 92782, 92783 },
+static const URange32 Old_South_Arabian_range32[] = {
+	{ 68192, 68223 },
 };
-static const URange16 Common_range16[] = {
-	{ 0, 64 },
-	{ 91, 96 },
-	{ 123, 169 },
-	{ 171, 185 },
-	{ 187, 191 },
-	{ 215, 215 },
-	{ 247, 247 },
-	{ 697, 735 },
-	{ 741, 745 },
-	{ 748, 767 },
-	{ 884, 884 },
-	{ 894, 894 },
-	{ 901, 901 },
-	{ 903, 903 },
-	{ 1417, 1417 },
-	{ 1541, 1541 },
-	{ 1548, 1548 },
-	{ 1563, 1563 },
-	{ 1567, 1567 },
-	{ 1600, 1600 },
-	{ 1757, 1757 },
-	{ 2274, 2274 },
-	{ 2404, 2405 },
-	{ 3647, 3647 },
-	{ 4053, 4056 },
-	{ 4347, 4347 },
-	{ 5867, 5869 },
-	{ 5941, 5942 },
-	{ 6146, 6147 },
-	{ 6149, 6149 },
-	{ 7379, 7379 },
-	{ 7393, 7393 },
-	{ 7401, 7404 },
-	{ 7406, 7411 },
-	{ 7413, 7415 },
-	{ 8192, 8203 },
-	{ 8206, 8292 },
-	{ 8294, 8304 },
-	{ 8308, 8318 },
-	{ 8320, 8334 },
-	{ 8352, 8383 },
-	{ 8448, 8485 },
-	{ 8487, 8489 },
-	{ 8492, 8497 },
-	{ 8499, 8525 },
-	{ 8527, 8543 },
-	{ 8585, 8587 },
-	{ 8592, 9254 },
-	{ 9280, 9290 },
-	{ 9312, 10239 },
-	{ 10496, 11123 },
-	{ 11126, 11157 },
-	{ 11160, 11208 },
-	{ 11210, 11262 },
-	{ 11776, 11854 },
-	{ 12272, 12283 },
-	{ 12288, 12292 },
-	{ 12294, 12294 },
-	{ 12296, 12320 },
-	{ 12336, 12343 },
-	{ 12348, 12351 },
-	{ 12443, 12444 },
-	{ 12448, 12448 },
-	{ 12539, 12540 },
-	{ 12688, 12703 },
-	{ 12736, 12771 },
-	{ 12832, 12895 },
-	{ 12927, 13007 },
-	{ 13144, 13311 },
-	{ 19904, 19967 },
-	{ 42752, 42785 },
-	{ 42888, 42890 },
-	{ 43056, 43065 },
-	{ 43310, 43310 },
-	{ 43471, 43471 },
-	{ 43867, 43867 },
-	{ 64830, 64831 },
-	{ 65040, 65049 },
-	{ 65072, 65106 },
-	{ 65108, 65126 },
-	{ 65128, 65131 },
-	{ 65279, 65279 },
-	{ 65281, 65312 },
-	{ 65339, 65344 },
-	{ 65371, 65381 },
-	{ 65392, 65392 },
-	{ 65438, 65439 },
-	{ 65504, 65510 },
-	{ 65512, 65518 },
-	{ 65529, 65533 },
+static const URange32 Old_Turkic_range32[] = {
+	{ 68608, 68680 },
 };
-static const URange32 Common_range32[] = {
-	{ 65792, 65794 },
-	{ 65799, 65843 },
-	{ 65847, 65855 },
-	{ 65936, 65947 },
-	{ 66000, 66044 },
-	{ 66273, 66299 },
-	{ 113824, 113827 },
-	{ 118784, 119029 },
-	{ 119040, 119078 },
-	{ 119081, 119142 },
-	{ 119146, 119162 },
-	{ 119171, 119172 },
-	{ 119180, 119209 },
-	{ 119214, 119272 },
-	{ 119520, 119539 },
-	{ 119552, 119638 },
-	{ 119648, 119672 },
-	{ 119808, 119892 },
-	{ 119894, 119964 },
-	{ 119966, 119967 },
-	{ 119970, 119970 },
-	{ 119973, 119974 },
-	{ 119977, 119980 },
-	{ 119982, 119993 },
-	{ 119995, 119995 },
-	{ 119997, 120003 },
-	{ 120005, 120069 },
-	{ 120071, 120074 },
-	{ 120077, 120084 },
-	{ 120086, 120092 },
-	{ 120094, 120121 },
-	{ 120123, 120126 },
-	{ 120128, 120132 },
-	{ 120134, 120134 },
-	{ 120138, 120144 },
-	{ 120146, 120485 },
-	{ 120488, 120779 },
-	{ 120782, 120831 },
-	{ 126065, 126132 },
-	{ 126976, 127019 },
-	{ 127024, 127123 },
-	{ 127136, 127150 },
-	{ 127153, 127167 },
-	{ 127169, 127183 },
-	{ 127185, 127221 },
-	{ 127232, 127244 },
-	{ 127248, 127339 },
-	{ 127344, 127404 },
-	{ 127462, 127487 },
-	{ 127489, 127490 },
-	{ 127504, 127547 },
-	{ 127552, 127560 },
-	{ 127568, 127569 },
-	{ 127584, 127589 },
-	{ 127744, 128724 },
-	{ 128736, 128748 },
-	{ 128752, 128761 },
-	{ 128768, 128883 },
-	{ 128896, 128984 },
-	{ 129024, 129035 },
-	{ 129040, 129095 },
-	{ 129104, 129113 },
-	{ 129120, 129159 },
-	{ 129168, 129197 },
-	{ 129280, 129291 },
-	{ 129296, 129342 },
-	{ 129344, 129392 },
-	{ 129395, 129398 },
-	{ 129402, 129402 },
-	{ 129404, 129442 },
-	{ 129456, 129465 },
-	{ 129472, 129474 },
-	{ 129488, 129535 },
-	{ 129632, 129645 },
-	{ 917505, 917505 },
-	{ 917536, 917631 },
+static const URange32 Old_Uyghur_range32[] = {
+	{ 69488, 69513 },
+};
+static const URange16 Oriya_range16[] = {
+	{ 2817, 2819 },
+	{ 2821, 2828 },
+	{ 2831, 2832 },
+	{ 2835, 2856 },
+	{ 2858, 2864 },
+	{ 2866, 2867 },
+	{ 2869, 2873 },
+	{ 2876, 2884 },
+	{ 2887, 2888 },
+	{ 2891, 2893 },
+	{ 2901, 2903 },
+	{ 2908, 2909 },
+	{ 2911, 2915 },
+	{ 2918, 2935 },
+};
+static const URange32 Osage_range32[] = {
+	{ 66736, 66771 },
+	{ 66776, 66811 },
+};
+static const URange32 Osmanya_range32[] = {
+	{ 66688, 66717 },
+	{ 66720, 66729 },
+};
+static const URange32 Pahawh_Hmong_range32[] = {
+	{ 92928, 92997 },
+	{ 93008, 93017 },
+	{ 93019, 93025 },
+	{ 93027, 93047 },
+	{ 93053, 93071 },
+};
+static const URange32 Palmyrene_range32[] = {
+	{ 67680, 67711 },
 };
-static const URange16 Coptic_range16[] = {
-	{ 994, 1007 },
-	{ 11392, 11507 },
-	{ 11513, 11519 },
+static const URange32 Pau_Cin_Hau_range32[] = {
+	{ 72384, 72440 },
 };
-static const URange32 Chakma_range32[] = {
-	{ 69888, 69940 },
-	{ 69942, 69958 },
+static const URange16 Phags_Pa_range16[] = {
+	{ 43072, 43127 },
 };
-static const URange16 Arabic_range16[] = {
-	{ 1536, 1540 },
-	{ 1542, 1547 },
-	{ 1549, 1562 },
-	{ 1564, 1564 },
-	{ 1566, 1566 },
-	{ 1568, 1599 },
-	{ 1601, 1610 },
-	{ 1622, 1647 },
-	{ 1649, 1756 },
-	{ 1758, 1791 },
-	{ 1872, 1919 },
-	{ 2208, 2228 },
-	{ 2230, 2237 },
-	{ 2259, 2273 },
-	{ 2275, 2303 },
-	{ 64336, 64449 },
-	{ 64467, 64829 },
-	{ 64848, 64911 },
-	{ 64914, 64967 },
-	{ 65008, 65021 },
-	{ 65136, 65140 },
-	{ 65142, 65276 },
+static const URange32 Phoenician_range32[] = {
+	{ 67840, 67867 },
+	{ 67871, 67871 },
 };
-static const URange32 Arabic_range32[] = {
-	{ 69216, 69246 },
-	{ 126464, 126467 },
-	{ 126469, 126495 },
-	{ 126497, 126498 },
-	{ 126500, 126500 },
-	{ 126503, 126503 },
-	{ 126505, 126514 },
-	{ 126516, 126519 },
-	{ 126521, 126521 },
-	{ 126523, 126523 },
-	{ 126530, 126530 },
-	{ 126535, 126535 },
-	{ 126537, 126537 },
-	{ 126539, 126539 },
-	{ 126541, 126543 },
-	{ 126545, 126546 },
-	{ 126548, 126548 },
-	{ 126551, 126551 },
-	{ 126553, 126553 },
-	{ 126555, 126555 },
-	{ 126557, 126557 },
-	{ 126559, 126559 },
-	{ 126561, 126562 },
-	{ 126564, 126564 },
-	{ 126567, 126570 },
-	{ 126572, 126578 },
-	{ 126580, 126583 },
-	{ 126585, 126588 },
-	{ 126590, 126590 },
-	{ 126592, 126601 },
-	{ 126603, 126619 },
-	{ 126625, 126627 },
-	{ 126629, 126633 },
-	{ 126635, 126651 },
-	{ 126704, 126705 },
+static const URange32 Psalter_Pahlavi_range32[] = {
+	{ 68480, 68497 },
+	{ 68505, 68508 },
+	{ 68521, 68527 },
 };
-static const URange16 Bamum_range16[] = {
-	{ 42656, 42743 },
+static const URange16 Rejang_range16[] = {
+	{ 43312, 43347 },
+	{ 43359, 43359 },
 };
-static const URange32 Bamum_range32[] = {
-	{ 92160, 92728 },
+static const URange16 Runic_range16[] = {
+	{ 5792, 5866 },
+	{ 5870, 5880 },
 };
-static const URange16 Myanmar_range16[] = {
-	{ 4096, 4255 },
-	{ 43488, 43518 },
-	{ 43616, 43647 },
+static const URange16 Samaritan_range16[] = {
+	{ 2048, 2093 },
+	{ 2096, 2110 },
+};
+static const URange16 Saurashtra_range16[] = {
+	{ 43136, 43205 },
+	{ 43214, 43225 },
+};
+static const URange32 Sharada_range32[] = {
+	{ 70016, 70111 },
+};
+static const URange32 Shavian_range32[] = {
+	{ 66640, 66687 },
 };
 static const URange32 Siddham_range32[] = {
 	{ 71040, 71093 },
 	{ 71096, 71133 },
 };
+static const URange32 SignWriting_range32[] = {
+	{ 120832, 121483 },
+	{ 121499, 121503 },
+	{ 121505, 121519 },
+};
+static const URange16 Sinhala_range16[] = {
+	{ 3457, 3459 },
+	{ 3461, 3478 },
+	{ 3482, 3505 },
+	{ 3507, 3515 },
+	{ 3517, 3517 },
+	{ 3520, 3526 },
+	{ 3530, 3530 },
+	{ 3535, 3540 },
+	{ 3542, 3542 },
+	{ 3544, 3551 },
+	{ 3558, 3567 },
+	{ 3570, 3572 },
+};
+static const URange32 Sinhala_range32[] = {
+	{ 70113, 70132 },
+};
+static const URange32 Sogdian_range32[] = {
+	{ 69424, 69465 },
+};
+static const URange32 Sora_Sompeng_range32[] = {
+	{ 69840, 69864 },
+	{ 69872, 69881 },
+};
 static const URange32 Soyombo_range32[] = {
-	{ 72272, 72323 },
-	{ 72326, 72354 },
+	{ 72272, 72354 },
 };
-static const URange32 Avestan_range32[] = {
-	{ 68352, 68405 },
-	{ 68409, 68415 },
+static const URange16 Sundanese_range16[] = {
+	{ 7040, 7103 },
+	{ 7360, 7367 },
 };
-static const URange16 Hebrew_range16[] = {
-	{ 1425, 1479 },
-	{ 1488, 1514 },
-	{ 1519, 1524 },
-	{ 64285, 64310 },
-	{ 64312, 64316 },
-	{ 64318, 64318 },
-	{ 64320, 64321 },
-	{ 64323, 64324 },
-	{ 64326, 64335 },
+static const URange16 Syloti_Nagri_range16[] = {
+	{ 43008, 43052 },
 };
-static const URange32 Psalter_Pahlavi_range32[] = {
-	{ 68480, 68497 },
-	{ 68505, 68508 },
-	{ 68521, 68527 },
+static const URange16 Syriac_range16[] = {
+	{ 1792, 1805 },
+	{ 1807, 1866 },
+	{ 1869, 1871 },
+	{ 2144, 2154 },
+};
+static const URange16 Tagalog_range16[] = {
+	{ 5888, 5909 },
+	{ 5919, 5919 },
+};
+static const URange16 Tagbanwa_range16[] = {
+	{ 5984, 5996 },
+	{ 5998, 6000 },
+	{ 6002, 6003 },
+};
+static const URange16 Tai_Le_range16[] = {
+	{ 6480, 6509 },
+	{ 6512, 6516 },
+};
+static const URange16 Tai_Tham_range16[] = {
+	{ 6688, 6750 },
+	{ 6752, 6780 },
+	{ 6783, 6793 },
+	{ 6800, 6809 },
+	{ 6816, 6829 },
+};
+static const URange16 Tai_Viet_range16[] = {
+	{ 43648, 43714 },
+	{ 43739, 43743 },
 };
 static const URange32 Takri_range32[] = {
-	{ 71296, 71351 },
+	{ 71296, 71353 },
 	{ 71360, 71369 },
 };
-// 3994 16-bit ranges, 1429 32-bit ranges
+static const URange16 Tamil_range16[] = {
+	{ 2946, 2947 },
+	{ 2949, 2954 },
+	{ 2958, 2960 },
+	{ 2962, 2965 },
+	{ 2969, 2970 },
+	{ 2972, 2972 },
+	{ 2974, 2975 },
+	{ 2979, 2980 },
+	{ 2984, 2986 },
+	{ 2990, 3001 },
+	{ 3006, 3010 },
+	{ 3014, 3016 },
+	{ 3018, 3021 },
+	{ 3024, 3024 },
+	{ 3031, 3031 },
+	{ 3046, 3066 },
+};
+static const URange32 Tamil_range32[] = {
+	{ 73664, 73713 },
+	{ 73727, 73727 },
+};
+static const URange32 Tangsa_range32[] = {
+	{ 92784, 92862 },
+	{ 92864, 92873 },
+};
+static const URange32 Tangut_range32[] = {
+	{ 94176, 94176 },
+	{ 94208, 100343 },
+	{ 100352, 101119 },
+	{ 101632, 101640 },
+};
+static const URange16 Telugu_range16[] = {
+	{ 3072, 3084 },
+	{ 3086, 3088 },
+	{ 3090, 3112 },
+	{ 3114, 3129 },
+	{ 3132, 3140 },
+	{ 3142, 3144 },
+	{ 3146, 3149 },
+	{ 3157, 3158 },
+	{ 3160, 3162 },
+	{ 3165, 3165 },
+	{ 3168, 3171 },
+	{ 3174, 3183 },
+	{ 3191, 3199 },
+};
+static const URange16 Thaana_range16[] = {
+	{ 1920, 1969 },
+};
+static const URange16 Thai_range16[] = {
+	{ 3585, 3642 },
+	{ 3648, 3675 },
+};
+static const URange16 Tibetan_range16[] = {
+	{ 3840, 3911 },
+	{ 3913, 3948 },
+	{ 3953, 3991 },
+	{ 3993, 4028 },
+	{ 4030, 4044 },
+	{ 4046, 4052 },
+	{ 4057, 4058 },
+};
+static const URange16 Tifinagh_range16[] = {
+	{ 11568, 11623 },
+	{ 11631, 11632 },
+	{ 11647, 11647 },
+};
+static const URange32 Tirhuta_range32[] = {
+	{ 70784, 70855 },
+	{ 70864, 70873 },
+};
+static const URange32 Toto_range32[] = {
+	{ 123536, 123566 },
+};
+static const URange32 Ugaritic_range32[] = {
+	{ 66432, 66461 },
+	{ 66463, 66463 },
+};
+static const URange16 Vai_range16[] = {
+	{ 42240, 42539 },
+};
+static const URange32 Vithkuqi_range32[] = {
+	{ 66928, 66938 },
+	{ 66940, 66954 },
+	{ 66956, 66962 },
+	{ 66964, 66965 },
+	{ 66967, 66977 },
+	{ 66979, 66993 },
+	{ 66995, 67001 },
+	{ 67003, 67004 },
+};
+static const URange32 Wancho_range32[] = {
+	{ 123584, 123641 },
+	{ 123647, 123647 },
+};
+static const URange32 Warang_Citi_range32[] = {
+	{ 71840, 71922 },
+	{ 71935, 71935 },
+};
+static const URange32 Yezidi_range32[] = {
+	{ 69248, 69289 },
+	{ 69291, 69293 },
+	{ 69296, 69297 },
+};
+static const URange16 Yi_range16[] = {
+	{ 40960, 42124 },
+	{ 42128, 42182 },
+};
+static const URange32 Zanabazar_Square_range32[] = {
+	{ 72192, 72263 },
+};
+// 4040 16-bit ranges, 1775 32-bit ranges
 const UGroup unicode_groups[] = {
 	{ "Adlam", +1, 0, 0, Adlam_range32, 3 },
 	{ "Ahom", +1, 0, 0, Ahom_range32, 3 },
 	{ "Anatolian_Hieroglyphs", +1, 0, 0, Anatolian_Hieroglyphs_range32, 1 },
-	{ "Arabic", +1, Arabic_range16, 22, Arabic_range32, 35 },
-	{ "Armenian", +1, Armenian_range16, 5, 0, 0 },
+	{ "Arabic", +1, Arabic_range16, 22, Arabic_range32, 36 },
+	{ "Armenian", +1, Armenian_range16, 4, 0, 0 },
 	{ "Avestan", +1, 0, 0, Avestan_range32, 2 },
 	{ "Balinese", +1, Balinese_range16, 2, 0, 0 },
 	{ "Bamum", +1, Bamum_range16, 1, Bamum_range32, 1 },
@@ -5883,81 +6321,87 @@ const UGroup unicode_groups[] = {
 	{ "Braille", +1, Braille_range16, 1, 0, 0 },
 	{ "Buginese", +1, Buginese_range16, 2, 0, 0 },
 	{ "Buhid", +1, Buhid_range16, 1, 0, 0 },
-	{ "C", +1, C_range16, 16, C_range32, 8 },
-	{ "Canadian_Aboriginal", +1, Canadian_Aboriginal_range16, 2, 0, 0 },
+	{ "C", +1, C_range16, 17, C_range32, 9 },
+	{ "Canadian_Aboriginal", +1, Canadian_Aboriginal_range16, 2, Canadian_Aboriginal_range32, 1 },
 	{ "Carian", +1, 0, 0, Carian_range32, 1 },
 	{ "Caucasian_Albanian", +1, 0, 0, Caucasian_Albanian_range32, 2 },
 	{ "Cc", +1, Cc_range16, 2, 0, 0 },
-	{ "Cf", +1, Cf_range16, 13, Cf_range32, 6 },
+	{ "Cf", +1, Cf_range16, 14, Cf_range32, 7 },
 	{ "Chakma", +1, 0, 0, Chakma_range32, 2 },
 	{ "Cham", +1, Cham_range16, 4, 0, 0 },
 	{ "Cherokee", +1, Cherokee_range16, 3, 0, 0 },
+	{ "Chorasmian", +1, 0, 0, Chorasmian_range32, 1 },
 	{ "Co", +1, Co_range16, 1, Co_range32, 2 },
-	{ "Common", +1, Common_range16, 90, Common_range32, 76 },
+	{ "Common", +1, Common_range16, 91, Common_range32, 82 },
 	{ "Coptic", +1, Coptic_range16, 3, 0, 0 },
 	{ "Cs", +1, Cs_range16, 1, 0, 0 },
 	{ "Cuneiform", +1, 0, 0, Cuneiform_range32, 4 },
 	{ "Cypriot", +1, 0, 0, Cypriot_range32, 6 },
-	{ "Cyrillic", +1, Cyrillic_range16, 8, 0, 0 },
+	{ "Cypro_Minoan", +1, 0, 0, Cypro_Minoan_range32, 1 },
+	{ "Cyrillic", +1, Cyrillic_range16, 8, Cyrillic_range32, 2 },
 	{ "Deseret", +1, 0, 0, Deseret_range32, 1 },
-	{ "Devanagari", +1, Devanagari_range16, 4, 0, 0 },
+	{ "Devanagari", +1, Devanagari_range16, 4, Devanagari_range32, 1 },
+	{ "Dives_Akuru", +1, 0, 0, Dives_Akuru_range32, 8 },
 	{ "Dogra", +1, 0, 0, Dogra_range32, 1 },
 	{ "Duployan", +1, 0, 0, Duployan_range32, 5 },
 	{ "Egyptian_Hieroglyphs", +1, 0, 0, Egyptian_Hieroglyphs_range32, 1 },
 	{ "Elbasan", +1, 0, 0, Elbasan_range32, 1 },
-	{ "Ethiopic", +1, Ethiopic_range16, 32, 0, 0 },
+	{ "Elymaic", +1, 0, 0, Elymaic_range32, 1 },
+	{ "Ethiopic", +1, Ethiopic_range16, 32, Ethiopic_range32, 4 },
 	{ "Georgian", +1, Georgian_range16, 10, 0, 0 },
-	{ "Glagolitic", +1, Glagolitic_range16, 2, Glagolitic_range32, 5 },
+	{ "Glagolitic", +1, Glagolitic_range16, 1, Glagolitic_range32, 5 },
 	{ "Gothic", +1, 0, 0, Gothic_range32, 1 },
 	{ "Grantha", +1, 0, 0, Grantha_range32, 15 },
 	{ "Greek", +1, Greek_range16, 33, Greek_range32, 3 },
 	{ "Gujarati", +1, Gujarati_range16, 14, 0, 0 },
 	{ "Gunjala_Gondi", +1, 0, 0, Gunjala_Gondi_range32, 6 },
 	{ "Gurmukhi", +1, Gurmukhi_range16, 16, 0, 0 },
-	{ "Han", +1, Han_range16, 11, Han_range32, 6 },
+	{ "Han", +1, Han_range16, 11, Han_range32, 10 },
 	{ "Hangul", +1, Hangul_range16, 14, 0, 0 },
 	{ "Hanifi_Rohingya", +1, 0, 0, Hanifi_Rohingya_range32, 2 },
 	{ "Hanunoo", +1, Hanunoo_range16, 1, 0, 0 },
 	{ "Hatran", +1, 0, 0, Hatran_range32, 3 },
 	{ "Hebrew", +1, Hebrew_range16, 9, 0, 0 },
-	{ "Hiragana", +1, Hiragana_range16, 2, Hiragana_range32, 2 },
+	{ "Hiragana", +1, Hiragana_range16, 2, Hiragana_range32, 4 },
 	{ "Imperial_Aramaic", +1, 0, 0, Imperial_Aramaic_range32, 2 },
-	{ "Inherited", +1, Inherited_range16, 20, Inherited_range32, 8 },
+	{ "Inherited", +1, Inherited_range16, 19, Inherited_range32, 10 },
 	{ "Inscriptional_Pahlavi", +1, 0, 0, Inscriptional_Pahlavi_range32, 2 },
 	{ "Inscriptional_Parthian", +1, 0, 0, Inscriptional_Parthian_range32, 2 },
 	{ "Javanese", +1, Javanese_range16, 3, 0, 0 },
 	{ "Kaithi", +1, 0, 0, Kaithi_range32, 2 },
 	{ "Kannada", +1, Kannada_range16, 13, 0, 0 },
-	{ "Katakana", +1, Katakana_range16, 7, Katakana_range32, 1 },
+	{ "Katakana", +1, Katakana_range16, 7, Katakana_range32, 7 },
+	{ "Kawi", +1, 0, 0, Kawi_range32, 3 },
 	{ "Kayah_Li", +1, Kayah_Li_range16, 2, 0, 0 },
 	{ "Kharoshthi", +1, 0, 0, Kharoshthi_range32, 8 },
+	{ "Khitan_Small_Script", +1, 0, 0, Khitan_Small_Script_range32, 2 },
 	{ "Khmer", +1, Khmer_range16, 4, 0, 0 },
 	{ "Khojki", +1, 0, 0, Khojki_range32, 2 },
 	{ "Khudawadi", +1, 0, 0, Khudawadi_range32, 2 },
-	{ "L", +1, L_range16, 384, L_range32, 215 },
-	{ "Lao", +1, Lao_range16, 18, 0, 0 },
-	{ "Latin", +1, Latin_range16, 30, 0, 0 },
+	{ "L", +1, L_range16, 380, L_range32, 279 },
+	{ "Lao", +1, Lao_range16, 11, 0, 0 },
+	{ "Latin", +1, Latin_range16, 34, Latin_range32, 5 },
 	{ "Lepcha", +1, Lepcha_range16, 3, 0, 0 },
 	{ "Limbu", +1, Limbu_range16, 5, 0, 0 },
 	{ "Linear_A", +1, 0, 0, Linear_A_range32, 3 },
 	{ "Linear_B", +1, 0, 0, Linear_B_range32, 7 },
-	{ "Lisu", +1, Lisu_range16, 1, 0, 0 },
-	{ "Ll", +1, Ll_range16, 604, Ll_range32, 34 },
-	{ "Lm", +1, Lm_range16, 54, Lm_range32, 3 },
-	{ "Lo", +1, Lo_range16, 295, Lo_range32, 175 },
+	{ "Lisu", +1, Lisu_range16, 1, Lisu_range32, 1 },
+	{ "Ll", +1, Ll_range16, 617, Ll_range32, 41 },
+	{ "Lm", +1, Lm_range16, 57, Lm_range32, 14 },
+	{ "Lo", +1, Lo_range16, 290, Lo_range32, 220 },
 	{ "Lt", +1, Lt_range16, 10, 0, 0 },
-	{ "Lu", +1, Lu_range16, 594, Lu_range32, 37 },
+	{ "Lu", +1, Lu_range16, 605, Lu_range32, 41 },
 	{ "Lycian", +1, 0, 0, Lycian_range32, 1 },
 	{ "Lydian", +1, 0, 0, Lydian_range32, 2 },
-	{ "M", +1, M_range16, 187, M_range32, 88 },
+	{ "M", +1, M_range16, 190, M_range32, 120 },
 	{ "Mahajani", +1, 0, 0, Mahajani_range32, 1 },
 	{ "Makasar", +1, 0, 0, Makasar_range32, 1 },
-	{ "Malayalam", +1, Malayalam_range16, 8, 0, 0 },
+	{ "Malayalam", +1, Malayalam_range16, 7, 0, 0 },
 	{ "Mandaic", +1, Mandaic_range16, 2, 0, 0 },
 	{ "Manichaean", +1, 0, 0, Manichaean_range32, 2 },
 	{ "Marchen", +1, 0, 0, Marchen_range32, 3 },
 	{ "Masaram_Gondi", +1, 0, 0, Masaram_Gondi_range32, 7 },
-	{ "Mc", +1, Mc_range16, 110, Mc_range32, 56 },
+	{ "Mc", +1, Mc_range16, 112, Mc_range32, 70 },
 	{ "Me", +1, Me_range16, 5, 0, 0 },
 	{ "Medefaidrin", +1, 0, 0, Medefaidrin_range32, 1 },
 	{ "Meetei_Mayek", +1, Meetei_Mayek_range16, 3, 0, 0 },
@@ -5965,21 +6409,24 @@ const UGroup unicode_groups[] = {
 	{ "Meroitic_Cursive", +1, 0, 0, Meroitic_Cursive_range32, 3 },
 	{ "Meroitic_Hieroglyphs", +1, 0, 0, Meroitic_Hieroglyphs_range32, 1 },
 	{ "Miao", +1, 0, 0, Miao_range32, 3 },
-	{ "Mn", +1, Mn_range16, 208, Mn_range32, 105 },
+	{ "Mn", +1, Mn_range16, 212, Mn_range32, 134 },
 	{ "Modi", +1, 0, 0, Modi_range32, 2 },
-	{ "Mongolian", +1, Mongolian_range16, 6, Mongolian_range32, 1 },
+	{ "Mongolian", +1, Mongolian_range16, 5, Mongolian_range32, 1 },
 	{ "Mro", +1, 0, 0, Mro_range32, 3 },
 	{ "Multani", +1, 0, 0, Multani_range32, 5 },
 	{ "Myanmar", +1, Myanmar_range16, 3, 0, 0 },
-	{ "N", +1, N_range16, 67, N_range32, 58 },
+	{ "N", +1, N_range16, 67, N_range32, 70 },
 	{ "Nabataean", +1, 0, 0, Nabataean_range32, 2 },
-	{ "Nd", +1, Nd_range16, 37, Nd_range32, 20 },
+	{ "Nag_Mundari", +1, 0, 0, Nag_Mundari_range32, 1 },
+	{ "Nandinagari", +1, 0, 0, Nandinagari_range32, 3 },
+	{ "Nd", +1, Nd_range16, 37, Nd_range32, 27 },
 	{ "New_Tai_Lue", +1, New_Tai_Lue_range16, 4, 0, 0 },
-	{ "Newa", +1, 0, 0, Newa_range32, 3 },
+	{ "Newa", +1, 0, 0, Newa_range32, 2 },
 	{ "Nko", +1, Nko_range16, 2, 0, 0 },
 	{ "Nl", +1, Nl_range16, 7, Nl_range32, 5 },
-	{ "No", +1, No_range16, 29, No_range32, 38 },
+	{ "No", +1, No_range16, 29, No_range32, 43 },
 	{ "Nushu", +1, 0, 0, Nushu_range32, 2 },
+	{ "Nyiakeng_Puachue_Hmong", +1, 0, 0, Nyiakeng_Puachue_Hmong_range32, 4 },
 	{ "Ogham", +1, Ogham_range16, 1, 0, 0 },
 	{ "Ol_Chiki", +1, Ol_Chiki_range16, 1, 0, 0 },
 	{ "Old_Hungarian", +1, 0, 0, Old_Hungarian_range32, 3 },
@@ -5990,40 +6437,41 @@ const UGroup unicode_groups[] = {
 	{ "Old_Sogdian", +1, 0, 0, Old_Sogdian_range32, 1 },
 	{ "Old_South_Arabian", +1, 0, 0, Old_South_Arabian_range32, 1 },
 	{ "Old_Turkic", +1, 0, 0, Old_Turkic_range32, 1 },
+	{ "Old_Uyghur", +1, 0, 0, Old_Uyghur_range32, 1 },
 	{ "Oriya", +1, Oriya_range16, 14, 0, 0 },
 	{ "Osage", +1, 0, 0, Osage_range32, 2 },
 	{ "Osmanya", +1, 0, 0, Osmanya_range32, 2 },
-	{ "P", +1, P_range16, 130, P_range32, 48 },
+	{ "P", +1, P_range16, 133, P_range32, 58 },
 	{ "Pahawh_Hmong", +1, 0, 0, Pahawh_Hmong_range32, 5 },
 	{ "Palmyrene", +1, 0, 0, Palmyrene_range32, 1 },
 	{ "Pau_Cin_Hau", +1, 0, 0, Pau_Cin_Hau_range32, 1 },
 	{ "Pc", +1, Pc_range16, 6, 0, 0 },
-	{ "Pd", +1, Pd_range16, 17, 0, 0 },
-	{ "Pe", +1, Pe_range16, 72, 0, 0 },
+	{ "Pd", +1, Pd_range16, 18, Pd_range32, 1 },
+	{ "Pe", +1, Pe_range16, 76, 0, 0 },
 	{ "Pf", +1, Pf_range16, 10, 0, 0 },
 	{ "Phags_Pa", +1, Phags_Pa_range16, 1, 0, 0 },
 	{ "Phoenician", +1, 0, 0, Phoenician_range32, 2 },
 	{ "Pi", +1, Pi_range16, 11, 0, 0 },
-	{ "Po", +1, Po_range16, 127, Po_range32, 48 },
-	{ "Ps", +1, Ps_range16, 75, 0, 0 },
+	{ "Po", +1, Po_range16, 130, Po_range32, 57 },
+	{ "Ps", +1, Ps_range16, 79, 0, 0 },
 	{ "Psalter_Pahlavi", +1, 0, 0, Psalter_Pahlavi_range32, 3 },
 	{ "Rejang", +1, Rejang_range16, 2, 0, 0 },
 	{ "Runic", +1, Runic_range16, 2, 0, 0 },
-	{ "S", +1, S_range16, 147, S_range32, 73 },
+	{ "S", +1, S_range16, 151, S_range32, 81 },
 	{ "Samaritan", +1, Samaritan_range16, 2, 0, 0 },
 	{ "Saurashtra", +1, Saurashtra_range16, 2, 0, 0 },
-	{ "Sc", +1, Sc_range16, 18, Sc_range32, 1 },
-	{ "Sharada", +1, 0, 0, Sharada_range32, 2 },
+	{ "Sc", +1, Sc_range16, 18, Sc_range32, 3 },
+	{ "Sharada", +1, 0, 0, Sharada_range32, 1 },
 	{ "Shavian", +1, 0, 0, Shavian_range32, 1 },
 	{ "Siddham", +1, 0, 0, Siddham_range32, 2 },
 	{ "SignWriting", +1, 0, 0, SignWriting_range32, 3 },
 	{ "Sinhala", +1, Sinhala_range16, 12, Sinhala_range32, 1 },
-	{ "Sk", +1, Sk_range16, 28, Sk_range32, 1 },
+	{ "Sk", +1, Sk_range16, 30, Sk_range32, 1 },
 	{ "Sm", +1, Sm_range16, 53, Sm_range32, 11 },
-	{ "So", +1, So_range16, 112, So_range32, 62 },
+	{ "So", +1, So_range16, 114, So_range32, 70 },
 	{ "Sogdian", +1, 0, 0, Sogdian_range32, 1 },
 	{ "Sora_Sompeng", +1, 0, 0, Sora_Sompeng_range32, 2 },
-	{ "Soyombo", +1, 0, 0, Soyombo_range32, 2 },
+	{ "Soyombo", +1, 0, 0, Soyombo_range32, 1 },
 	{ "Sundanese", +1, Sundanese_range16, 2, 0, 0 },
 	{ "Syloti_Nagri", +1, Syloti_Nagri_range16, 1, 0, 0 },
 	{ "Syriac", +1, Syriac_range16, 4, 0, 0 },
@@ -6033,17 +6481,22 @@ const UGroup unicode_groups[] = {
 	{ "Tai_Tham", +1, Tai_Tham_range16, 5, 0, 0 },
 	{ "Tai_Viet", +1, Tai_Viet_range16, 2, 0, 0 },
 	{ "Takri", +1, 0, 0, Takri_range32, 2 },
-	{ "Tamil", +1, Tamil_range16, 16, 0, 0 },
-	{ "Tangut", +1, 0, 0, Tangut_range32, 3 },
-	{ "Telugu", +1, Telugu_range16, 12, 0, 0 },
+	{ "Tamil", +1, Tamil_range16, 16, Tamil_range32, 2 },
+	{ "Tangsa", +1, 0, 0, Tangsa_range32, 2 },
+	{ "Tangut", +1, 0, 0, Tangut_range32, 4 },
+	{ "Telugu", +1, Telugu_range16, 13, 0, 0 },
 	{ "Thaana", +1, Thaana_range16, 1, 0, 0 },
 	{ "Thai", +1, Thai_range16, 2, 0, 0 },
 	{ "Tibetan", +1, Tibetan_range16, 7, 0, 0 },
 	{ "Tifinagh", +1, Tifinagh_range16, 3, 0, 0 },
 	{ "Tirhuta", +1, 0, 0, Tirhuta_range32, 2 },
+	{ "Toto", +1, 0, 0, Toto_range32, 1 },
 	{ "Ugaritic", +1, 0, 0, Ugaritic_range32, 2 },
 	{ "Vai", +1, Vai_range16, 1, 0, 0 },
+	{ "Vithkuqi", +1, 0, 0, Vithkuqi_range32, 8 },
+	{ "Wancho", +1, 0, 0, Wancho_range32, 2 },
 	{ "Warang_Citi", +1, 0, 0, Warang_Citi_range32, 2 },
+	{ "Yezidi", +1, 0, 0, Yezidi_range32, 3 },
 	{ "Yi", +1, Yi_range16, 2, 0, 0 },
 	{ "Z", +1, Z_range16, 8, 0, 0 },
 	{ "Zanabazar_Square", +1, 0, 0, Zanabazar_Square_range32, 1 },
@@ -6051,7 +6504,7 @@ const UGroup unicode_groups[] = {
 	{ "Zp", +1, Zp_range16, 1, 0, 0 },
 	{ "Zs", +1, Zs_range16, 7, 0, 0 },
 };
-const int num_unicode_groups = 184;
+const int num_unicode_groups = 199;
 
 
 }  // namespace re2
diff --git a/re2/unicode_groups.h b/re2/unicode_groups.h
index 75f55da..6dc6532 100644
--- a/re2/unicode_groups.h
+++ b/re2/unicode_groups.h
@@ -20,7 +20,6 @@
 
 #include <stdint.h>
 
-#include "util/util.h"
 #include "util/utf.h"
 
 namespace re2 {
diff --git a/re2/walker-inl.h b/re2/walker-inl.h
index 032b8ac..45763a7 100644
--- a/re2/walker-inl.h
+++ b/re2/walker-inl.h
@@ -15,6 +15,7 @@
 
 #include <stack>
 
+#include "absl/base/macros.h"
 #include "util/logging.h"
 #include "re2/regexp.h"
 
@@ -89,7 +90,7 @@ template<typename T> class Regexp::Walker {
 
  private:
   // Walk state for the entire traversal.
-  std::stack<WalkState<T> >* stack_;
+  std::stack<WalkState<T>> stack_;
   bool stopped_early_;
   int max_visits_;
 
@@ -119,7 +120,7 @@ template<typename T> T Regexp::Walker<T>::Copy(T arg) {
 
 // State about a single level in the traversal.
 template<typename T> struct WalkState {
-  WalkState<T>(Regexp* re, T parent)
+  WalkState(Regexp* re, T parent)
     : re(re),
       n(-1),
       parent_arg(parent),
@@ -134,24 +135,23 @@ template<typename T> struct WalkState {
 };
 
 template<typename T> Regexp::Walker<T>::Walker() {
-  stack_ = new std::stack<WalkState<T> >;
   stopped_early_ = false;
 }
 
 template<typename T> Regexp::Walker<T>::~Walker() {
   Reset();
-  delete stack_;
 }
 
 // Clears the stack.  Should never be necessary, since
 // Walk always enters and exits with an empty stack.
 // Logs DFATAL if stack is not already clear.
 template<typename T> void Regexp::Walker<T>::Reset() {
-  if (stack_ && stack_->size() > 0) {
+  if (!stack_.empty()) {
     LOG(DFATAL) << "Stack not empty.";
-    while (stack_->size() > 0) {
-      delete stack_->top().child_args;
-      stack_->pop();
+    while (!stack_.empty()) {
+      if (stack_.top().re->nsub_ > 1)
+        delete[] stack_.top().child_args;
+      stack_.pop();
     }
   }
 }
@@ -165,13 +165,13 @@ template<typename T> T Regexp::Walker<T>::WalkInternal(Regexp* re, T top_arg,
     return top_arg;
   }
 
-  stack_->push(WalkState<T>(re, top_arg));
+  stack_.push(WalkState<T>(re, top_arg));
 
   WalkState<T>* s;
   for (;;) {
     T t;
-    s = &stack_->top();
-    Regexp* re = s->re;
+    s = &stack_.top();
+    re = s->re;
     switch (s->n) {
       case -1: {
         if (--max_visits_ < 0) {
@@ -191,7 +191,7 @@ template<typename T> T Regexp::Walker<T>::WalkInternal(Regexp* re, T top_arg,
           s->child_args = &s->child_arg;
         else if (re->nsub_ > 1)
           s->child_args = new T[re->nsub_];
-        FALLTHROUGH_INTENDED;
+        ABSL_FALLTHROUGH_INTENDED;
       }
       default: {
         if (re->nsub_ > 0) {
@@ -201,7 +201,7 @@ template<typename T> T Regexp::Walker<T>::WalkInternal(Regexp* re, T top_arg,
               s->child_args[s->n] = Copy(s->child_args[s->n - 1]);
               s->n++;
             } else {
-              stack_->push(WalkState<T>(sub[s->n], s->pre_arg));
+              stack_.push(WalkState<T>(sub[s->n], s->pre_arg));
             }
             continue;
           }
@@ -214,12 +214,12 @@ template<typename T> T Regexp::Walker<T>::WalkInternal(Regexp* re, T top_arg,
       }
     }
 
-    // We've finished stack_->top().
+    // We've finished stack_.top().
     // Update next guy down.
-    stack_->pop();
-    if (stack_->size() == 0)
+    stack_.pop();
+    if (stack_.empty())
       return t;
-    s = &stack_->top();
+    s = &stack_.top();
     if (s->child_args != NULL)
       s->child_args[s->n] = t;
     else
diff --git a/re2Config.cmake.in b/re2Config.cmake.in
new file mode 100644
index 0000000..6a177c6
--- /dev/null
+++ b/re2Config.cmake.in
@@ -0,0 +1,28 @@
+# Copyright 2022 The RE2 Authors.  All Rights Reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+
+@PACKAGE_INIT@
+
+include(CMakeFindDependencyMacro)
+
+set_and_check(re2_INCLUDE_DIR ${PACKAGE_PREFIX_DIR}/@CMAKE_INSTALL_INCLUDEDIR@)
+
+if(UNIX)
+  set(THREADS_PREFER_PTHREAD_FLAG ON)
+  find_dependency(Threads REQUIRED)
+endif()
+
+find_dependency(absl REQUIRED)
+
+if(@RE2_USE_ICU@)
+  find_dependency(ICU REQUIRED COMPONENTS uc)
+endif()
+
+check_required_components(re2)
+
+if(TARGET re2::re2)
+  return()
+endif()
+
+include(${CMAKE_CURRENT_LIST_DIR}/re2Targets.cmake)
diff --git a/re2_test.bzl b/re2_test.bzl
deleted file mode 100644
index c0eb654..0000000
--- a/re2_test.bzl
+++ /dev/null
@@ -1,12 +0,0 @@
-# Copyright 2009 The RE2 Authors.  All Rights Reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-# Defines a Bazel macro that instantiates a native cc_test rule for an RE2 test.
-def re2_test(name, deps=[], size="medium"):
-  native.cc_test(
-      name=name,
-      srcs=["re2/testing/%s.cc" % (name)],
-      deps=[":test"] + deps,
-      size=size,
-  )
diff --git a/testinstall.cc b/testinstall.cc
index 47db4e6..19cc900 100644
--- a/testinstall.cc
+++ b/testinstall.cc
@@ -2,23 +2,26 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-#include <re2/re2.h>
-#include <re2/filtered_re2.h>
 #include <stdio.h>
+#include <re2/filtered_re2.h>
+#include <re2/re2.h>
+
+int main() {
+  re2::FilteredRE2 f;
+  int id;
+  f.Add("a.*b.*c", RE2::DefaultOptions, &id);
+  std::vector<std::string> v;
+  f.Compile(&v);
+  std::vector<int> ids;
+  f.FirstMatch("abbccc", ids);
 
-int main(void) {
-	re2::FilteredRE2 f;
-	int id;
-	f.Add("a.*b.*c", RE2::DefaultOptions, &id);
-	std::vector<std::string> v;
-	f.Compile(&v);
-	std::vector<int> ids;
-	f.FirstMatch("abbccc", ids);
+  int n;
+  if (RE2::FullMatch("axbyc", "a.*b.*c") &&
+      RE2::PartialMatch("foo123bar", "(\\d+)", &n) && n == 123) {
+    printf("PASS\n");
+    return 0;
+  }
 
-	if(RE2::FullMatch("axbyc", "a.*b.*c")) {
-		printf("PASS\n");
-		return 0;
-	}
-	printf("FAIL\n");
-	return 2;
+  printf("FAIL\n");
+  return 2;
 }
diff --git a/util/benchmark.cc b/util/benchmark.cc
deleted file mode 100644
index 144f550..0000000
--- a/util/benchmark.cc
+++ /dev/null
@@ -1,161 +0,0 @@
-// Copyright 2009 The RE2 Authors.  All Rights Reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <algorithm>
-#include <chrono>
-#include <thread>
-
-#include "util/util.h"
-#include "util/flags.h"
-#include "util/benchmark.h"
-#include "re2/re2.h"
-
-DEFINE_string(test_tmpdir, "/var/tmp", "temp directory");
-
-#ifdef _WIN32
-#define snprintf _snprintf
-#endif
-
-using testing::Benchmark;
-
-static Benchmark* benchmarks[10000];
-static int nbenchmarks;
-
-void Benchmark::Register() {
-	benchmarks[nbenchmarks] = this;
-	if(lo < 1)
-		lo = 1;
-	if(hi < lo)
-		hi = lo;
-	nbenchmarks++;
-}
-
-static int64_t nsec() {
-	return std::chrono::duration_cast<std::chrono::nanoseconds>(
-		std::chrono::steady_clock::now().time_since_epoch()).count();
-}
-
-static int64_t bytes;
-static int64_t ns;
-static int64_t t0;
-static int64_t items;
-
-void SetBenchmarkBytesProcessed(int64_t x) {
-	bytes = x;
-}
-
-void StopBenchmarkTiming() {
-	if(t0 != 0)
-		ns += nsec() - t0;
-	t0 = 0;
-}
-
-void StartBenchmarkTiming() {
-	if(t0 == 0)
-		t0 = nsec();
-}
-
-void SetBenchmarkItemsProcessed(int n) {
-	items = n;
-}
-
-void BenchmarkMemoryUsage() {
-	// TODO(rsc): Implement.
-}
-
-int NumCPUs() {
-	return static_cast<int>(std::thread::hardware_concurrency());
-}
-
-static void runN(Benchmark *b, int n, int siz) {
-	bytes = 0;
-	items = 0;
-	ns = 0;
-	t0 = nsec();
-	if(b->fn)
-		b->fn(n);
-	else if(b->fnr)
-		b->fnr(n, siz);
-	else {
-		fprintf(stderr, "%s: missing function\n", b->name);
-		abort();
-	}
-	if(t0 != 0)
-		ns += nsec() - t0;
-}
-
-static int round(int n) {
-	int base = 1;
-	
-	while(base*10 < n)
-		base *= 10;
-	if(n < 2*base)
-		return 2*base;
-	if(n < 5*base)
-		return 5*base;
-	return 10*base;
-}
-
-void RunBench(Benchmark* b, int nthread, int siz) {
-	int n, last;
-
-	// TODO(rsc): Threaded benchmarks.
-	if(nthread != 1)
-		return;
-	
-	// run once in case it's expensive
-	n = 1;
-	runN(b, n, siz);
-	while(ns < (int)1e9 && n < (int)1e9) {
-		last = n;
-		if(ns/n == 0)
-			n = (int)1e9;
-		else
-			n = (int)1e9 / static_cast<int>(ns/n);
-		
-		n = std::max(last+1, std::min(n+n/2, 100*last));
-		n = round(n);
-		runN(b, n, siz);
-	}
-	
-	char mb[100];
-	char suf[100];
-	mb[0] = '\0';
-	suf[0] = '\0';
-	if(ns > 0 && bytes > 0)
-		snprintf(mb, sizeof mb, "\t%7.2f MB/s", ((double)bytes/1e6)/((double)ns/1e9));
-	if(b->fnr || b->lo != b->hi) {
-		if(siz >= (1<<20))
-			snprintf(suf, sizeof suf, "/%dM", siz/(1<<20));
-		else if(siz >= (1<<10))
-			snprintf(suf, sizeof suf, "/%dK", siz/(1<<10));
-		else
-			snprintf(suf, sizeof suf, "/%d", siz);
-	}
-	printf("%s%s\t%8lld\t%10lld ns/op%s\n", b->name, suf, (long long)n, (long long)ns/n, mb);
-	fflush(stdout);
-}
-
-static int match(const char* name, int argc, const char** argv) {
-	if(argc == 1)
-		return 1;
-	for(int i = 1; i < argc; i++)
-		if(RE2::PartialMatch(name, argv[i]))
-			return 1;
-	return 0;
-}
-
-int main(int argc, const char** argv) {
-	for(int i = 0; i < nbenchmarks; i++) {
-		Benchmark* b = benchmarks[i];
-		if(match(b->name, argc, argv))
-			for(int j = b->threadlo; j <= b->threadhi; j++)
-				for(int k = std::max(b->lo, 1); k <= std::max(b->hi, 1); k<<=1)
-					RunBench(b, j, k);
-	}
-}
-
diff --git a/util/benchmark.h b/util/benchmark.h
deleted file mode 100644
index fba30b9..0000000
--- a/util/benchmark.h
+++ /dev/null
@@ -1,43 +0,0 @@
-// Copyright 2009 The RE2 Authors.  All Rights Reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-#ifndef UTIL_BENCHMARK_H_
-#define UTIL_BENCHMARK_H_
-
-#include <stdint.h>
-
-namespace testing {
-struct Benchmark {
-  const char* name;
-  void (*fn)(int);
-  void (*fnr)(int, int);
-  int lo;
-  int hi;
-  int threadlo;
-  int threadhi;
-
-  void Register();
-  Benchmark(const char* name, void (*f)(int)) { Clear(name); fn = f; Register(); }
-  Benchmark(const char* name, void (*f)(int, int), int l, int h) { Clear(name); fnr = f; lo = l; hi = h; Register(); }
-  void Clear(const char* n) { name = n; fn = 0; fnr = 0; lo = 0; hi = 0; threadlo = 0; threadhi = 0; }
-  Benchmark* ThreadRange(int lo, int hi) { threadlo = lo; threadhi = hi; return this; }
-};
-}  // namespace testing
-
-void SetBenchmarkBytesProcessed(int64_t);
-void StopBenchmarkTiming();
-void StartBenchmarkTiming();
-void BenchmarkMemoryUsage();
-void SetBenchmarkItemsProcessed(int);
-
-int NumCPUs();
-
-#define BENCHMARK(f) \
-	::testing::Benchmark* _benchmark_##f = (new ::testing::Benchmark(#f, f))
-
-#define BENCHMARK_RANGE(f, lo, hi) \
-	::testing::Benchmark* _benchmark_##f = \
-	(new ::testing::Benchmark(#f, f, lo, hi))
-
-#endif  // UTIL_BENCHMARK_H_
diff --git a/util/flags.h b/util/flags.h
deleted file mode 100644
index 5af1320..0000000
--- a/util/flags.h
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright 2009 The RE2 Authors.  All Rights Reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-#ifndef UTIL_FLAGS_H_
-#define UTIL_FLAGS_H_
-
-// Simplified version of Google's command line flags.
-// Does not support parsing the command line.
-// If you want to do that, see
-// https://gflags.github.io/gflags/
-
-#include <stdint.h>
-
-#define DEFINE_flag(type, name, deflt, desc) \
-	namespace re2 { type FLAGS_##name = deflt; }
-
-#define DECLARE_flag(type, name) \
-	namespace re2 { extern type FLAGS_##name; }
-
-#define DEFINE_bool(name, deflt, desc) DEFINE_flag(bool, name, deflt, desc)
-#define DEFINE_int32(name, deflt, desc) DEFINE_flag(int32_t, name, deflt, desc)
-#define DEFINE_string(name, deflt, desc) DEFINE_flag(string, name, deflt, desc)
-
-#define DECLARE_bool(name) DECLARE_flag(bool, name)
-#define DECLARE_int32(name) DECLARE_flag(int32_t, name)
-#define DECLARE_string(name) DECLARE_flag(string, name)
-
-#endif  // UTIL_FLAGS_H_
diff --git a/util/fuzz.cc b/util/fuzz.cc
index 9cac118..725cad8 100644
--- a/util/fuzz.cc
+++ b/util/fuzz.cc
@@ -10,12 +10,12 @@
 extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size);
 
 int main(int argc, char** argv) {
-  uint8_t data[32];
-  for (int i = 0; i < 32; i++) {
-    for (int j = 0; j < 32; j++) {
+  uint8_t data[4096];
+  for (int i = 0; i < 4096; i++) {
+    for (int j = 0; j < 4096; j++) {
       data[j] = random() & 0xFF;
     }
-    LLVMFuzzerTestOneInput(data, 32);
+    LLVMFuzzerTestOneInput(data, 4096);
   }
   return 0;
 }
diff --git a/util/logging.h b/util/logging.h
index c78f6c1..946962b 100644
--- a/util/logging.h
+++ b/util/logging.h
@@ -13,7 +13,7 @@
 #include <ostream>
 #include <sstream>
 
-#include "util/util.h"
+#include "absl/base/attributes.h"
 
 // Debug-only checking.
 #define DCHECK(condition) assert(condition)
@@ -62,7 +62,7 @@ class LogMessage {
   }
   void Flush() {
     stream() << "\n";
-    string s = str_.str();
+    std::string s = str_.str();
     size_t n = s.size();
     if (fwrite(s.data(), 1, n, stderr) < n) {}  // shut up gcc
     flushed_ = true;
@@ -93,7 +93,7 @@ class LogMessageFatal : public LogMessage {
  public:
   LogMessageFatal(const char* file, int line)
       : LogMessage(file, line) {}
-  ATTRIBUTE_NORETURN ~LogMessageFatal() {
+  ABSL_ATTRIBUTE_NORETURN ~LogMessageFatal() {
     Flush();
     abort();
   }
diff --git a/util/malloc_counter.h b/util/malloc_counter.h
new file mode 100644
index 0000000..81b564f
--- /dev/null
+++ b/util/malloc_counter.h
@@ -0,0 +1,19 @@
+// Copyright 2009 The RE2 Authors.  All Rights Reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+#ifndef UTIL_MALLOC_COUNTER_H_
+#define UTIL_MALLOC_COUNTER_H_
+
+namespace testing {
+class MallocCounter {
+ public:
+  MallocCounter(int x) {}
+  static const int THIS_THREAD_ONLY = 0;
+  long long HeapGrowth() { return 0; }
+  long long PeakHeapGrowth() { return 0; }
+  void Reset() {}
+};
+}  // namespace testing
+
+#endif  // UTIL_MALLOC_COUNTER_H_
diff --git a/util/mix.h b/util/mix.h
deleted file mode 100644
index d85c172..0000000
--- a/util/mix.h
+++ /dev/null
@@ -1,41 +0,0 @@
-// Copyright 2016 The RE2 Authors.  All Rights Reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-#ifndef UTIL_MIX_H_
-#define UTIL_MIX_H_
-
-#include <stddef.h>
-#include <limits>
-
-namespace re2 {
-
-// Silence "truncation of constant value" warning for kMul in 32-bit mode.
-// Since this is a header file, push and then pop to limit the scope.
-#ifdef _MSC_VER
-#pragma warning(push)
-#pragma warning(disable: 4309)
-#endif
-
-class HashMix {
- public:
-  HashMix() : hash_(1) {}
-  explicit HashMix(size_t val) : hash_(val + 83) {}
-  void Mix(size_t val) {
-    static const size_t kMul = static_cast<size_t>(0xdc3eb94af8ab4c93ULL);
-    hash_ *= kMul;
-    hash_ = ((hash_ << 19) |
-             (hash_ >> (std::numeric_limits<size_t>::digits - 19))) + val;
-  }
-  size_t get() const { return hash_; }
- private:
-  size_t hash_;
-};
-
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif
-
-}  // namespace re2
-
-#endif  // UTIL_MIX_H_
diff --git a/util/mutex.h b/util/mutex.h
deleted file mode 100644
index 9c49158..0000000
--- a/util/mutex.h
+++ /dev/null
@@ -1,131 +0,0 @@
-// Copyright 2007 The RE2 Authors.  All Rights Reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-#ifndef UTIL_MUTEX_H_
-#define UTIL_MUTEX_H_
-
-/*
- * A simple mutex wrapper, supporting locks and read-write locks.
- * You should assume the locks are *not* re-entrant.
- */
-
-#if !defined(_WIN32)
-#ifndef _POSIX_C_SOURCE
-#define _POSIX_C_SOURCE 200809L
-#endif
-#include <unistd.h>
-#if defined(_POSIX_READER_WRITER_LOCKS) && _POSIX_READER_WRITER_LOCKS > 0
-#define MUTEX_IS_PTHREAD_RWLOCK
-#endif
-#endif
-
-#if defined(MUTEX_IS_PTHREAD_RWLOCK)
-#include <pthread.h>
-#include <stdlib.h>
-typedef pthread_rwlock_t MutexType;
-#else
-#include <mutex>
-typedef std::mutex MutexType;
-#endif
-
-namespace re2 {
-
-class Mutex {
- public:
-  inline Mutex();
-  inline ~Mutex();
-  inline void Lock();    // Block if needed until free then acquire exclusively
-  inline void Unlock();  // Release a lock acquired via Lock()
-  // Note that on systems that don't support read-write locks, these may
-  // be implemented as synonyms to Lock() and Unlock().  So you can use
-  // these for efficiency, but don't use them anyplace where being able
-  // to do shared reads is necessary to avoid deadlock.
-  inline void ReaderLock();   // Block until free or shared then acquire a share
-  inline void ReaderUnlock(); // Release a read share of this Mutex
-  inline void WriterLock() { Lock(); }     // Acquire an exclusive lock
-  inline void WriterUnlock() { Unlock(); } // Release a lock from WriterLock()
-
- private:
-  MutexType mutex_;
-
-  // Catch the error of writing Mutex when intending MutexLock.
-  Mutex(Mutex *ignored);
-
-  Mutex(const Mutex&) = delete;
-  Mutex& operator=(const Mutex&) = delete;
-};
-
-#if defined(MUTEX_IS_PTHREAD_RWLOCK)
-
-#define SAFE_PTHREAD(fncall)    \
-  do {                          \
-    if ((fncall) != 0) abort(); \
-  } while (0)
-
-Mutex::Mutex()             { SAFE_PTHREAD(pthread_rwlock_init(&mutex_, NULL)); }
-Mutex::~Mutex()            { SAFE_PTHREAD(pthread_rwlock_destroy(&mutex_)); }
-void Mutex::Lock()         { SAFE_PTHREAD(pthread_rwlock_wrlock(&mutex_)); }
-void Mutex::Unlock()       { SAFE_PTHREAD(pthread_rwlock_unlock(&mutex_)); }
-void Mutex::ReaderLock()   { SAFE_PTHREAD(pthread_rwlock_rdlock(&mutex_)); }
-void Mutex::ReaderUnlock() { SAFE_PTHREAD(pthread_rwlock_unlock(&mutex_)); }
-
-#undef SAFE_PTHREAD
-
-#else
-
-Mutex::Mutex()             { }
-Mutex::~Mutex()            { }
-void Mutex::Lock()         { mutex_.lock(); }
-void Mutex::Unlock()       { mutex_.unlock(); }
-void Mutex::ReaderLock()   { Lock(); }  // C++11 doesn't have std::shared_mutex.
-void Mutex::ReaderUnlock() { Unlock(); }
-
-#endif
-
-// --------------------------------------------------------------------------
-// Some helper classes
-
-// MutexLock(mu) acquires mu when constructed and releases it when destroyed.
-class MutexLock {
- public:
-  explicit MutexLock(Mutex *mu) : mu_(mu) { mu_->Lock(); }
-  ~MutexLock() { mu_->Unlock(); }
- private:
-  Mutex * const mu_;
-
-  MutexLock(const MutexLock&) = delete;
-  MutexLock& operator=(const MutexLock&) = delete;
-};
-
-// ReaderMutexLock and WriterMutexLock do the same, for rwlocks
-class ReaderMutexLock {
- public:
-  explicit ReaderMutexLock(Mutex *mu) : mu_(mu) { mu_->ReaderLock(); }
-  ~ReaderMutexLock() { mu_->ReaderUnlock(); }
- private:
-  Mutex * const mu_;
-
-  ReaderMutexLock(const ReaderMutexLock&) = delete;
-  ReaderMutexLock& operator=(const ReaderMutexLock&) = delete;
-};
-
-class WriterMutexLock {
- public:
-  explicit WriterMutexLock(Mutex *mu) : mu_(mu) { mu_->WriterLock(); }
-  ~WriterMutexLock() { mu_->WriterUnlock(); }
- private:
-  Mutex * const mu_;
-
-  WriterMutexLock(const WriterMutexLock&) = delete;
-  WriterMutexLock& operator=(const WriterMutexLock&) = delete;
-};
-
-// Catch bug where variable name is omitted, e.g. MutexLock (&mu);
-#define MutexLock(x) static_assert(false, "MutexLock declaration missing variable name")
-#define ReaderMutexLock(x) static_assert(false, "ReaderMutexLock declaration missing variable name")
-#define WriterMutexLock(x) static_assert(false, "WriterMutexLock declaration missing variable name")
-
-}  // namespace re2
-
-#endif  // UTIL_MUTEX_H_
diff --git a/util/pcre.cc b/util/pcre.cc
index 78de292..82b4f59 100644
--- a/util/pcre.cc
+++ b/util/pcre.cc
@@ -15,16 +15,13 @@
 #include <string>
 #include <utility>
 
-#include "util/util.h"
-#include "util/flags.h"
+#include "absl/flags/flag.h"
+#include "absl/strings/str_format.h"
 #include "util/logging.h"
 #include "util/pcre.h"
-#include "util/strutil.h"
 
 // Silence warnings about the wacky formatting in the operator() functions.
-// Note that we test for Clang first because it defines __GNUC__ as well.
-#if defined(__clang__)
-#elif defined(__GNUC__) && __GNUC__ >= 6
+#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 6
 #pragma GCC diagnostic ignored "-Wmisleading-indentation"
 #endif
 
@@ -35,9 +32,10 @@
 // not exceed main thread stacks.  Note that other threads
 // often have smaller stacks, and therefore tightening
 // regexp_stack_limit may frequently be necessary.
-DEFINE_int32(regexp_stack_limit, 256<<10, "default PCRE stack limit (bytes)");
-DEFINE_int32(regexp_match_limit, 1000000,
-             "default PCRE match limit (function calls)");
+ABSL_FLAG(int, regexp_stack_limit, 256 << 10,
+          "default PCRE stack limit (bytes)");
+ABSL_FLAG(int, regexp_match_limit, 1000000,
+          "default PCRE match limit (function calls)");
 
 #ifndef USEPCRE
 
@@ -99,7 +97,7 @@ const PCRE::ConsumeFunctor PCRE::Consume = { };
 const PCRE::FindAndConsumeFunctor PCRE::FindAndConsume = { };
 
 // If a regular expression has no error, its error_ field points here
-static const string empty_string;
+static const std::string empty_string;
 
 void PCRE::Init(const char* pattern, Option options, int match_limit,
               int stack_limit, bool report_errors) {
@@ -114,7 +112,7 @@ void PCRE::Init(const char* pattern, Option options, int match_limit,
   re_partial_ = NULL;
 
   if (options & ~(EnabledCompileOptions | EnabledExecOptions)) {
-    error_ = new string("illegal regexp option");
+    error_ = new std::string("illegal regexp option");
     PCREPORT(ERROR)
         << "Error compiling '" << pattern << "': illegal regexp option";
   } else {
@@ -131,13 +129,13 @@ PCRE::PCRE(const char* pattern) {
 PCRE::PCRE(const char* pattern, Option option) {
   Init(pattern, option, 0, 0, true);
 }
-PCRE::PCRE(const string& pattern) {
+PCRE::PCRE(const std::string& pattern) {
   Init(pattern.c_str(), None, 0, 0, true);
 }
-PCRE::PCRE(const string& pattern, Option option) {
+PCRE::PCRE(const std::string& pattern, Option option) {
   Init(pattern.c_str(), option, 0, 0, true);
 }
-PCRE::PCRE(const string& pattern, const PCRE_Options& re_option) {
+PCRE::PCRE(const std::string& pattern, const PCRE_Options& re_option) {
   Init(pattern.c_str(), re_option.option(), re_option.match_limit(),
        re_option.stack_limit(), re_option.report_errors());
 }
@@ -176,7 +174,7 @@ pcre* PCRE::Compile(Anchor anchor) {
   } else {
     // Tack a '\z' at the end of PCRE.  Parenthesize it first so that
     // the '\z' applies to all top-level alternatives in the regexp.
-    string wrapped = "(?:";  // A non-counting grouping operator
+    std::string wrapped = "(?:";  // A non-counting grouping operator
     wrapped += pattern_;
     wrapped += ")\\z";
     re = pcre_compile(wrapped.c_str(),
@@ -184,7 +182,7 @@ pcre* PCRE::Compile(Anchor anchor) {
                       &error, &eoffset, NULL);
   }
   if (re == NULL) {
-    if (error_ == &empty_string) error_ = new string(error);
+    if (error_ == &empty_string) error_ = new std::string(error);
     PCREPORT(ERROR) << "Error compiling '" << pattern_ << "': " << error;
   }
   return re;
@@ -192,24 +190,11 @@ pcre* PCRE::Compile(Anchor anchor) {
 
 /***** Convenience interfaces *****/
 
-bool PCRE::FullMatchFunctor::operator ()(const StringPiece& text,
-                                       const PCRE& re,
-                                       const Arg& a0,
-                                       const Arg& a1,
-                                       const Arg& a2,
-                                       const Arg& a3,
-                                       const Arg& a4,
-                                       const Arg& a5,
-                                       const Arg& a6,
-                                       const Arg& a7,
-                                       const Arg& a8,
-                                       const Arg& a9,
-                                       const Arg& a10,
-                                       const Arg& a11,
-                                       const Arg& a12,
-                                       const Arg& a13,
-                                       const Arg& a14,
-                                       const Arg& a15) const {
+bool PCRE::FullMatchFunctor::operator()(
+    absl::string_view text, const PCRE& re, const Arg& a0, const Arg& a1,
+    const Arg& a2, const Arg& a3, const Arg& a4, const Arg& a5, const Arg& a6,
+    const Arg& a7, const Arg& a8, const Arg& a9, const Arg& a10, const Arg& a11,
+    const Arg& a12, const Arg& a13, const Arg& a14, const Arg& a15) const {
   const Arg* args[kMaxArgs];
   int n = 0;
   if (&a0 == &no_more_args)  goto done; args[n++] = &a0;
@@ -235,24 +220,11 @@ done:
   return re.DoMatchImpl(text, ANCHOR_BOTH, &consumed, args, n, vec, kVecSize);
 }
 
-bool PCRE::PartialMatchFunctor::operator ()(const StringPiece& text,
-                                          const PCRE& re,
-                                          const Arg& a0,
-                                          const Arg& a1,
-                                          const Arg& a2,
-                                          const Arg& a3,
-                                          const Arg& a4,
-                                          const Arg& a5,
-                                          const Arg& a6,
-                                          const Arg& a7,
-                                          const Arg& a8,
-                                          const Arg& a9,
-                                          const Arg& a10,
-                                          const Arg& a11,
-                                          const Arg& a12,
-                                          const Arg& a13,
-                                          const Arg& a14,
-                                          const Arg& a15) const {
+bool PCRE::PartialMatchFunctor::operator()(
+    absl::string_view text, const PCRE& re, const Arg& a0, const Arg& a1,
+    const Arg& a2, const Arg& a3, const Arg& a4, const Arg& a5, const Arg& a6,
+    const Arg& a7, const Arg& a8, const Arg& a9, const Arg& a10, const Arg& a11,
+    const Arg& a12, const Arg& a13, const Arg& a14, const Arg& a15) const {
   const Arg* args[kMaxArgs];
   int n = 0;
   if (&a0 == &no_more_args)  goto done; args[n++] = &a0;
@@ -278,24 +250,11 @@ done:
   return re.DoMatchImpl(text, UNANCHORED, &consumed, args, n, vec, kVecSize);
 }
 
-bool PCRE::ConsumeFunctor::operator ()(StringPiece* input,
-                                     const PCRE& pattern,
-                                     const Arg& a0,
-                                     const Arg& a1,
-                                     const Arg& a2,
-                                     const Arg& a3,
-                                     const Arg& a4,
-                                     const Arg& a5,
-                                     const Arg& a6,
-                                     const Arg& a7,
-                                     const Arg& a8,
-                                     const Arg& a9,
-                                     const Arg& a10,
-                                     const Arg& a11,
-                                     const Arg& a12,
-                                     const Arg& a13,
-                                     const Arg& a14,
-                                     const Arg& a15) const {
+bool PCRE::ConsumeFunctor::operator()(
+    absl::string_view* input, const PCRE& pattern, const Arg& a0, const Arg& a1,
+    const Arg& a2, const Arg& a3, const Arg& a4, const Arg& a5, const Arg& a6,
+    const Arg& a7, const Arg& a8, const Arg& a9, const Arg& a10, const Arg& a11,
+    const Arg& a12, const Arg& a13, const Arg& a14, const Arg& a15) const {
   const Arg* args[kMaxArgs];
   int n = 0;
   if (&a0 == &no_more_args)  goto done; args[n++] = &a0;
@@ -327,24 +286,11 @@ done:
   }
 }
 
-bool PCRE::FindAndConsumeFunctor::operator ()(StringPiece* input,
-                                            const PCRE& pattern,
-                                            const Arg& a0,
-                                            const Arg& a1,
-                                            const Arg& a2,
-                                            const Arg& a3,
-                                            const Arg& a4,
-                                            const Arg& a5,
-                                            const Arg& a6,
-                                            const Arg& a7,
-                                            const Arg& a8,
-                                            const Arg& a9,
-                                            const Arg& a10,
-                                            const Arg& a11,
-                                            const Arg& a12,
-                                            const Arg& a13,
-                                            const Arg& a14,
-                                            const Arg& a15) const {
+bool PCRE::FindAndConsumeFunctor::operator()(
+    absl::string_view* input, const PCRE& pattern, const Arg& a0, const Arg& a1,
+    const Arg& a2, const Arg& a3, const Arg& a4, const Arg& a5, const Arg& a6,
+    const Arg& a7, const Arg& a8, const Arg& a9, const Arg& a10, const Arg& a11,
+    const Arg& a12, const Arg& a13, const Arg& a14, const Arg& a15) const {
   const Arg* args[kMaxArgs];
   int n = 0;
   if (&a0 == &no_more_args)  goto done; args[n++] = &a0;
@@ -376,15 +322,14 @@ done:
   }
 }
 
-bool PCRE::Replace(string *str,
-                 const PCRE& pattern,
-                 const StringPiece& rewrite) {
+bool PCRE::Replace(std::string* str, const PCRE& pattern,
+                   absl::string_view rewrite) {
   int vec[kVecSize] = {};
   int matches = pattern.TryMatch(*str, 0, UNANCHORED, true, vec, kVecSize);
   if (matches == 0)
     return false;
 
-  string s;
+  std::string s;
   if (!pattern.Rewrite(&s, rewrite, *str, vec, matches))
     return false;
 
@@ -394,12 +339,11 @@ bool PCRE::Replace(string *str,
   return true;
 }
 
-int PCRE::GlobalReplace(string *str,
-                      const PCRE& pattern,
-                      const StringPiece& rewrite) {
+int PCRE::GlobalReplace(std::string* str, const PCRE& pattern,
+                        absl::string_view rewrite) {
   int count = 0;
   int vec[kVecSize] = {};
-  string out;
+  std::string out;
   size_t start = 0;
   bool last_match_was_empty_string = false;
 
@@ -452,10 +396,8 @@ int PCRE::GlobalReplace(string *str,
   return count;
 }
 
-bool PCRE::Extract(const StringPiece &text,
-                 const PCRE& pattern,
-                 const StringPiece &rewrite,
-                 string *out) {
+bool PCRE::Extract(absl::string_view text, const PCRE& pattern,
+                   absl::string_view rewrite, std::string* out) {
   int vec[kVecSize] = {};
   int matches = pattern.TryMatch(text, 0, UNANCHORED, true, vec, kVecSize);
   if (matches == 0)
@@ -464,8 +406,8 @@ bool PCRE::Extract(const StringPiece &text,
   return pattern.Rewrite(out, rewrite, text, vec, matches);
 }
 
-string PCRE::QuoteMeta(const StringPiece& unquoted) {
-  string result;
+std::string PCRE::QuoteMeta(absl::string_view unquoted) {
+  std::string result;
   result.reserve(unquoted.size() << 1);
 
   // Escape any ascii character not in [A-Za-z_0-9].
@@ -509,12 +451,8 @@ void PCRE::ClearHitLimit() {
   hit_limit_ = 0;
 }
 
-int PCRE::TryMatch(const StringPiece& text,
-                   size_t startpos,
-                   Anchor anchor,
-                   bool empty_ok,
-                   int *vec,
-                   int vecsize) const {
+int PCRE::TryMatch(absl::string_view text, size_t startpos, Anchor anchor,
+                   bool empty_ok, int* vec, int vecsize) const {
   pcre* re = (anchor == ANCHOR_BOTH) ? re_full_ : re_partial_;
   if (re == NULL) {
     PCREPORT(ERROR) << "Matching against invalid re: " << *error_;
@@ -523,12 +461,12 @@ int PCRE::TryMatch(const StringPiece& text,
 
   int match_limit = match_limit_;
   if (match_limit <= 0) {
-    match_limit = FLAGS_regexp_match_limit;
+    match_limit = absl::GetFlag(FLAGS_regexp_match_limit);
   }
 
   int stack_limit = stack_limit_;
   if (stack_limit <= 0) {
-    stack_limit = FLAGS_regexp_stack_limit;
+    stack_limit = absl::GetFlag(FLAGS_regexp_stack_limit);
   }
 
   pcre_extra extra = { 0 };
@@ -605,12 +543,8 @@ int PCRE::TryMatch(const StringPiece& text,
   return rc;
 }
 
-bool PCRE::DoMatchImpl(const StringPiece& text,
-                       Anchor anchor,
-                       size_t* consumed,
-                       const Arg* const* args,
-                       int n,
-                       int* vec,
+bool PCRE::DoMatchImpl(absl::string_view text, Anchor anchor, size_t* consumed,
+                       const Arg* const* args, int n, int* vec,
                        int vecsize) const {
   assert((1 + n) * 3 <= vecsize);  // results + PCRE workspace
   if (NumberOfCapturingGroups() < n) {
@@ -655,11 +589,8 @@ bool PCRE::DoMatchImpl(const StringPiece& text,
   return true;
 }
 
-bool PCRE::DoMatch(const StringPiece& text,
-                   Anchor anchor,
-                   size_t* consumed,
-                   const Arg* const args[],
-                   int n) const {
+bool PCRE::DoMatch(absl::string_view text, Anchor anchor, size_t* consumed,
+                   const Arg* const args[], int n) const {
   assert(n >= 0);
   const int vecsize = (1 + n) * 3;  // results + PCRE workspace
                                     // (as for kVecSize)
@@ -669,8 +600,8 @@ bool PCRE::DoMatch(const StringPiece& text,
   return b;
 }
 
-bool PCRE::Rewrite(string *out, const StringPiece &rewrite,
-                 const StringPiece &text, int *vec, int veclen) const {
+bool PCRE::Rewrite(std::string* out, absl::string_view rewrite,
+                   absl::string_view text, int* vec, int veclen) const {
   int number_of_capturing_groups = NumberOfCapturingGroups();
   for (const char *s = rewrite.data(), *end = s + rewrite.size();
        s < end; s++) {
@@ -705,7 +636,8 @@ bool PCRE::Rewrite(string *out, const StringPiece &rewrite,
   return true;
 }
 
-bool PCRE::CheckRewriteString(const StringPiece& rewrite, string* error) const {
+bool PCRE::CheckRewriteString(absl::string_view rewrite,
+                              std::string* error) const {
   int max_token = -1;
   for (const char *s = rewrite.data(), *end = s + rewrite.size();
        s < end; s++) {
@@ -733,15 +665,15 @@ bool PCRE::CheckRewriteString(const StringPiece& rewrite, string* error) const {
   }
 
   if (max_token > NumberOfCapturingGroups()) {
-    SStringPrintf(error, "Rewrite schema requests %d matches, "
-                  "but the regexp only has %d parenthesized subexpressions.",
-                  max_token, NumberOfCapturingGroups());
+    *error = absl::StrFormat(
+        "Rewrite schema requests %d matches, but the regexp only has %d "
+        "parenthesized subexpressions.",
+        max_token, NumberOfCapturingGroups());
     return false;
   }
   return true;
 }
 
-
 // Return the number of capturing subpatterns, or -1 if the
 // regexp wasn't valid on construction.
 int PCRE::NumberOfCapturingGroups() const {
@@ -769,13 +701,13 @@ bool PCRE::Arg::parse_null(const char* str, size_t n, void* dest) {
 
 bool PCRE::Arg::parse_string(const char* str, size_t n, void* dest) {
   if (dest == NULL) return true;
-  reinterpret_cast<string*>(dest)->assign(str, n);
+  reinterpret_cast<std::string*>(dest)->assign(str, n);
   return true;
 }
 
-bool PCRE::Arg::parse_stringpiece(const char* str, size_t n, void* dest) {
+bool PCRE::Arg::parse_string_view(const char* str, size_t n, void* dest) {
   if (dest == NULL) return true;
-  *(reinterpret_cast<StringPiece*>(dest)) = StringPiece(str, n);
+  *(reinterpret_cast<absl::string_view*>(dest)) = absl::string_view(str, n);
   return true;
 }
 
@@ -975,32 +907,7 @@ static bool parse_double_float(const char* str, size_t n, bool isfloat,
   } else {
     r = strtod(buf, &end);
   }
-  if (end != buf + n) {
-#ifdef _WIN32
-    // Microsoft's strtod() doesn't handle inf and nan, so we have to
-    // handle it explicitly.  Speed is not important here because this
-    // code is only called in unit tests.
-    bool pos = true;
-    const char* i = buf;
-    if ('-' == *i) {
-      pos = false;
-      ++i;
-    } else if ('+' == *i) {
-      ++i;
-    }
-    if (0 == _stricmp(i, "inf") || 0 == _stricmp(i, "infinity")) {
-      r = std::numeric_limits<double>::infinity();
-      if (!pos)
-        r = -r;
-    } else if (0 == _stricmp(i, "nan")) {
-      r = std::numeric_limits<double>::quiet_NaN();
-    } else {
-      return false;
-    }
-#else
-    return false;   // Leftover junk
-#endif
-  }
+  if (end != buf + n) return false;   // Leftover junk
   if (errno) return false;
   if (dest == NULL) return true;
   if (isfloat) {
diff --git a/util/pcre.h b/util/pcre.h
index 10ec4f2..c270942 100644
--- a/util/pcre.h
+++ b/util/pcre.h
@@ -67,7 +67,7 @@
 //
 // Example: extracts "ruby" into "s" and 1234 into "i"
 //    int i;
-//    string s;
+//    std::string s;
 //    CHECK(PCRE::FullMatch("ruby:1234", "(\\w+):(\\d+)", &s, &i));
 //
 // Example: fails because string cannot be stored in integer
@@ -120,14 +120,14 @@
 //
 // The "Consume" operation may be useful if you want to repeatedly
 // match regular expressions at the front of a string and skip over
-// them as they match.  This requires use of the "StringPiece" type,
+// them as they match.  This requires use of the string_view type,
 // which represents a sub-range of a real string.
 //
 // Example: read lines of the form "var = value" from a string.
-//      string contents = ...;          // Fill string somehow
-//      StringPiece input(contents);    // Wrap a StringPiece around it
+//      std::string contents = ...;         // Fill string somehow
+//      absl::string_view input(contents);  // Wrap a string_view around it
 //
-//      string var;
+//      std::string var;
 //      int value;
 //      while (PCRE::Consume(&input, "(\\w+) = (\\d+)\n", &var, &value)) {
 //        ...;
@@ -161,8 +161,7 @@
 //         Octal(&a), Hex(&b), CRadix(&c), CRadix(&d));
 // will leave 64 in a, b, c, and d.
 
-#include "util/util.h"
-#include "re2/stringpiece.h"
+#include "absl/strings/string_view.h"
 
 #ifdef USEPCRE
 #include <pcre.h>
@@ -212,21 +211,21 @@ class PCRE {
   // pass in a string or a "const char*" wherever an "PCRE" is expected.
   PCRE(const char* pattern);
   PCRE(const char* pattern, Option option);
-  PCRE(const string& pattern);
-  PCRE(const string& pattern, Option option);
+  PCRE(const std::string& pattern);
+  PCRE(const std::string& pattern, Option option);
   PCRE(const char *pattern, const PCRE_Options& re_option);
-  PCRE(const string& pattern, const PCRE_Options& re_option);
+  PCRE(const std::string& pattern, const PCRE_Options& re_option);
 
   ~PCRE();
 
   // The string specification for this PCRE.  E.g.
   //   PCRE re("ab*c?d+");
   //   re.pattern();    // "ab*c?d+"
-  const string& pattern() const { return pattern_; }
+  const std::string& pattern() const { return pattern_; }
 
   // If PCRE could not be created properly, returns an error string.
   // Else returns the empty string.
-  const string& error() const { return *error_; }
+  const std::string& error() const { return *error_; }
 
   // Whether the PCRE has hit a match limit during execution.
   // Not thread safe.  Intended only for testing.
@@ -241,15 +240,15 @@ class PCRE {
   // Matches "text" against "pattern".  If pointer arguments are
   // supplied, copies matched sub-patterns into them.
   //
-  // You can pass in a "const char*" or a "string" for "text".
-  // You can pass in a "const char*" or a "string" or a "PCRE" for "pattern".
+  // You can pass in a "const char*" or a "std::string" for "text".
+  // You can pass in a "const char*" or a "std::string" or a "PCRE" for "pattern".
   //
   // The provided pointer arguments can be pointers to any scalar numeric
   // type, or one of:
-  //    string          (matched piece is copied to string)
-  //    StringPiece     (StringPiece is mutated to point to matched piece)
-  //    T               (where "bool T::ParseFrom(const char*, size_t)" exists)
-  //    (void*)NULL     (the corresponding matched sub-pattern is not copied)
+  //    std::string        (matched piece is copied to string)
+  //    absl::string_view  (string_view is mutated to point to matched piece)
+  //    T                  ("bool T::ParseFrom(const char*, size_t)" must exist)
+  //    (void*)NULL        (the corresponding matched sub-pattern is not copied)
   //
   // Returns true iff all of the following conditions are satisfied:
   //   a. "text" matches "pattern" exactly
@@ -267,7 +266,7 @@ class PCRE {
   //    int number;
   //    PCRE::FullMatch("abc", "[a-z]+(\\d+)?", &number);
   struct FullMatchFunctor {
-    bool operator ()(const StringPiece& text, const PCRE& re, // 3..16 args
+    bool operator ()(absl::string_view text, const PCRE& re,  // 3..16 args
                      const Arg& ptr1 = no_more_args,
                      const Arg& ptr2 = no_more_args,
                      const Arg& ptr3 = no_more_args,
@@ -291,7 +290,7 @@ class PCRE {
   // Exactly like FullMatch(), except that "pattern" is allowed to match
   // a substring of "text".
   struct PartialMatchFunctor {
-    bool operator ()(const StringPiece& text, const PCRE& re, // 3..16 args
+    bool operator ()(absl::string_view text, const PCRE& re,  // 3..16 args
                      const Arg& ptr1 = no_more_args,
                      const Arg& ptr2 = no_more_args,
                      const Arg& ptr3 = no_more_args,
@@ -316,7 +315,7 @@ class PCRE {
   // match a prefix of "text", and "input" is advanced past the matched
   // text.  Note: "input" is modified iff this routine returns true.
   struct ConsumeFunctor {
-    bool operator ()(StringPiece* input, const PCRE& pattern, // 3..16 args
+    bool operator ()(absl::string_view* input, const PCRE& pattern,  // 3..16 args
                      const Arg& ptr1 = no_more_args,
                      const Arg& ptr2 = no_more_args,
                      const Arg& ptr3 = no_more_args,
@@ -342,7 +341,7 @@ class PCRE {
   // "input".  For example, "FindAndConsume(s, "(\\w+)", &word)" finds the next
   // word in "s" and stores it in "word".
   struct FindAndConsumeFunctor {
-    bool operator ()(StringPiece* input, const PCRE& pattern,
+    bool operator ()(absl::string_view* input, const PCRE& pattern,  // 3..16 args
                      const Arg& ptr1 = no_more_args,
                      const Arg& ptr2 = no_more_args,
                      const Arg& ptr3 = no_more_args,
@@ -369,30 +368,28 @@ class PCRE {
   // from the pattern.  \0 in "rewrite" refers to the entire matching
   // text.  E.g.,
   //
-  //   string s = "yabba dabba doo";
+  //   std::string s = "yabba dabba doo";
   //   CHECK(PCRE::Replace(&s, "b+", "d"));
   //
   // will leave "s" containing "yada dabba doo"
   //
   // Returns true if the pattern matches and a replacement occurs,
   // false otherwise.
-  static bool Replace(string *str,
-                      const PCRE& pattern,
-                      const StringPiece& rewrite);
+  static bool Replace(std::string* str, const PCRE& pattern,
+                      absl::string_view rewrite);
 
   // Like Replace(), except replaces all occurrences of the pattern in
   // the string with the rewrite.  Replacements are not subject to
   // re-matching.  E.g.,
   //
-  //   string s = "yabba dabba doo";
+  //   std::string s = "yabba dabba doo";
   //   CHECK(PCRE::GlobalReplace(&s, "b+", "d"));
   //
   // will leave "s" containing "yada dada doo"
   //
   // Returns the number of replacements made.
-  static int GlobalReplace(string *str,
-                           const PCRE& pattern,
-                           const StringPiece& rewrite);
+  static int GlobalReplace(std::string* str, const PCRE& pattern,
+                           absl::string_view rewrite);
 
   // Like Replace, except that if the pattern matches, "rewrite"
   // is copied into "out" with substitutions.  The non-matching
@@ -400,10 +397,8 @@ class PCRE {
   //
   // Returns true iff a match occurred and the extraction happened
   // successfully;  if no match occurs, the string is left unaffected.
-  static bool Extract(const StringPiece &text,
-                      const PCRE& pattern,
-                      const StringPiece &rewrite,
-                      string *out);
+  static bool Extract(absl::string_view text, const PCRE& pattern,
+                      absl::string_view rewrite, std::string* out);
 
   // Check that the given @p rewrite string is suitable for use with
   // this PCRE.  It checks that:
@@ -418,7 +413,7 @@ class PCRE {
   // @param error An error message is recorded here, iff we return false.
   //              Otherwise, it is unchanged.
   // @return true, iff @p rewrite is suitable for use with the PCRE.
-  bool CheckRewriteString(const StringPiece& rewrite, string* error) const;
+  bool CheckRewriteString(absl::string_view rewrite, std::string* error) const;
 
   // Returns a copy of 'unquoted' with all potentially meaningful
   // regexp characters backslash-escaped.  The returned string, used
@@ -427,7 +422,7 @@ class PCRE {
   //           1.5-2.0?
   //  becomes:
   //           1\.5\-2\.0\?
-  static string QuoteMeta(const StringPiece& unquoted);
+  static std::string QuoteMeta(absl::string_view unquoted);
 
   /***** Generic matching interface (not so nice to use) *****/
 
@@ -440,9 +435,7 @@ class PCRE {
 
   // General matching routine.  Stores the length of the match in
   // "*consumed" if successful.
-  bool DoMatch(const StringPiece& text,
-               Anchor anchor,
-               size_t* consumed,
+  bool DoMatch(absl::string_view text, Anchor anchor, size_t* consumed,
                const Arg* const* args, int n) const;
 
   // Return the number of capturing subpatterns, or -1 if the
@@ -464,42 +457,30 @@ class PCRE {
   // against "foo", "bar", and "baz" respectively.
   // When matching PCRE("(foo)|hello") against "hello", it will return 1.
   // But the values for all subpattern are filled in into "vec".
-  int TryMatch(const StringPiece& text,
-               size_t startpos,
-               Anchor anchor,
-               bool empty_ok,
-               int *vec,
-               int vecsize) const;
+  int TryMatch(absl::string_view text, size_t startpos, Anchor anchor,
+               bool empty_ok, int* vec, int vecsize) const;
 
   // Append the "rewrite" string, with backslash subsitutions from "text"
   // and "vec", to string "out".
-  bool Rewrite(string *out,
-               const StringPiece &rewrite,
-               const StringPiece &text,
-               int *vec,
-               int veclen) const;
+  bool Rewrite(std::string* out, absl::string_view rewrite,
+               absl::string_view text, int* vec, int veclen) const;
 
   // internal implementation for DoMatch
-  bool DoMatchImpl(const StringPiece& text,
-                   Anchor anchor,
-                   size_t* consumed,
-                   const Arg* const args[],
-                   int n,
-                   int* vec,
-                   int vecsize) const;
+  bool DoMatchImpl(absl::string_view text, Anchor anchor, size_t* consumed,
+                   const Arg* const args[], int n, int* vec, int vecsize) const;
 
   // Compile the regexp for the specified anchoring mode
   pcre* Compile(Anchor anchor);
 
-  string            pattern_;
-  Option            options_;
-  pcre*             re_full_;        // For full matches
-  pcre*             re_partial_;     // For partial matches
-  const string*     error_;          // Error indicator (or empty string)
-  bool              report_errors_;  // Silences error logging if false
-  int               match_limit_;    // Limit on execution resources
-  int               stack_limit_;    // Limit on stack resources (bytes)
-  mutable int32_t   hit_limit_;  // Hit limit during execution (bool)?
+  std::string         pattern_;
+  Option              options_;
+  pcre*               re_full_;        // For full matches
+  pcre*               re_partial_;     // For partial matches
+  const std::string*  error_;          // Error indicator (or empty string)
+  bool                report_errors_;  // Silences error logging if false
+  int                 match_limit_;    // Limit on execution resources
+  int                 stack_limit_;    // Limit on stack resources (bytes)
+  mutable int         hit_limit_;      // Hit limit during execution (bool)
 
   PCRE(const PCRE&) = delete;
   PCRE& operator=(const PCRE&) = delete;
@@ -554,7 +535,7 @@ class PCRE_Options {
 // Hex/Octal/Binary?
 
 // Special class for parsing into objects that define a ParseFrom() method
-template <class T>
+template <typename T>
 class _PCRE_MatchObject {
  public:
   static inline bool Parse(const char* str, size_t n, void* dest) {
@@ -584,8 +565,8 @@ class PCRE::Arg {
   MAKE_PARSER(unsigned char,      parse_uchar);
   MAKE_PARSER(float,              parse_float);
   MAKE_PARSER(double,             parse_double);
-  MAKE_PARSER(string,             parse_string);
-  MAKE_PARSER(StringPiece,        parse_stringpiece);
+  MAKE_PARSER(std::string,        parse_string);
+  MAKE_PARSER(absl::string_view,  parse_string_view);
 
   MAKE_PARSER(short,              parse_short);
   MAKE_PARSER(unsigned short,     parse_ushort);
@@ -599,9 +580,9 @@ class PCRE::Arg {
 #undef MAKE_PARSER
 
   // Generic constructor
-  template <class T> Arg(T*, Parser parser);
+  template <typename T> Arg(T*, Parser parser);
   // Generic constructor template
-  template <class T> Arg(T* p)
+  template <typename T> Arg(T* p)
     : arg_(p), parser_(_PCRE_MatchObject<T>::Parse) {
   }
 
@@ -612,14 +593,14 @@ class PCRE::Arg {
   void*         arg_;
   Parser        parser_;
 
-  static bool parse_null          (const char* str, size_t n, void* dest);
-  static bool parse_char          (const char* str, size_t n, void* dest);
-  static bool parse_schar         (const char* str, size_t n, void* dest);
-  static bool parse_uchar         (const char* str, size_t n, void* dest);
-  static bool parse_float         (const char* str, size_t n, void* dest);
-  static bool parse_double        (const char* str, size_t n, void* dest);
-  static bool parse_string        (const char* str, size_t n, void* dest);
-  static bool parse_stringpiece   (const char* str, size_t n, void* dest);
+  static bool parse_null        (const char* str, size_t n, void* dest);
+  static bool parse_char        (const char* str, size_t n, void* dest);
+  static bool parse_schar       (const char* str, size_t n, void* dest);
+  static bool parse_uchar       (const char* str, size_t n, void* dest);
+  static bool parse_float       (const char* str, size_t n, void* dest);
+  static bool parse_double      (const char* str, size_t n, void* dest);
+  static bool parse_string      (const char* str, size_t n, void* dest);
+  static bool parse_string_view (const char* str, size_t n, void* dest);
 
 #define DECLARE_INTEGER_PARSER(name)                                       \
  private:                                                                  \
diff --git a/util/rune.cc b/util/rune.cc
index 4f625ea..a40e756 100644
--- a/util/rune.cc
+++ b/util/rune.cc
@@ -51,7 +51,7 @@ int
 chartorune(Rune *rune, const char *str)
 {
 	int c, c1, c2, c3;
-	long l;
+	Rune l;
 
 	/*
 	 * one character sequence
@@ -127,7 +127,7 @@ int
 runetochar(char *str, const Rune *rune)
 {
 	/* Runes are signed, so convert to unsigned for range check. */
-	unsigned long c;
+	unsigned int c;
 
 	/*
 	 * one character sequence
@@ -212,7 +212,7 @@ int
 utflen(const char *s)
 {
 	int c;
-	long n;
+	int n;
 	Rune rune;
 
 	n = 0;
@@ -232,7 +232,7 @@ utflen(const char *s)
 char*
 utfrune(const char *s, Rune c)
 {
-	long c1;
+	int c1;
 	Rune r;
 	int n;
 
diff --git a/util/strutil.cc b/util/strutil.cc
index 8eabfa4..da06f85 100644
--- a/util/strutil.cc
+++ b/util/strutil.cc
@@ -2,80 +2,11 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-#include <stdarg.h>
-#include <stdio.h>
-
 #include "util/strutil.h"
 
-#ifdef _WIN32
-#define snprintf _snprintf
-#define vsnprintf _vsnprintf
-#endif
-
 namespace re2 {
 
-// ----------------------------------------------------------------------
-// CEscapeString()
-//    Copies 'src' to 'dest', escaping dangerous characters using
-//    C-style escape sequences.  'src' and 'dest' should not overlap.
-//    Returns the number of bytes written to 'dest' (not including the \0)
-//    or (size_t)-1 if there was insufficient space.
-// ----------------------------------------------------------------------
-static size_t CEscapeString(const char* src, size_t src_len,
-                            char* dest, size_t dest_len) {
-  const char* src_end = src + src_len;
-  size_t used = 0;
-
-  for (; src < src_end; src++) {
-    if (dest_len - used < 2)   // space for two-character escape
-      return (size_t)-1;
-
-    unsigned char c = *src;
-    switch (c) {
-      case '\n': dest[used++] = '\\'; dest[used++] = 'n';  break;
-      case '\r': dest[used++] = '\\'; dest[used++] = 'r';  break;
-      case '\t': dest[used++] = '\\'; dest[used++] = 't';  break;
-      case '\"': dest[used++] = '\\'; dest[used++] = '\"'; break;
-      case '\'': dest[used++] = '\\'; dest[used++] = '\''; break;
-      case '\\': dest[used++] = '\\'; dest[used++] = '\\'; break;
-      default:
-        // Note that if we emit \xNN and the src character after that is a hex
-        // digit then that digit must be escaped too to prevent it being
-        // interpreted as part of the character code by C.
-        if (c < ' ' || c > '~') {
-          if (dest_len - used < 5)   // space for four-character escape + \0
-            return (size_t)-1;
-          snprintf(dest + used, 5, "\\%03o", c);
-          used += 4;
-        } else {
-          dest[used++] = c; break;
-        }
-    }
-  }
-
-  if (dest_len - used < 1)   // make sure that there is room for \0
-    return (size_t)-1;
-
-  dest[used] = '\0';   // doesn't count towards return value though
-  return used;
-}
-
-// ----------------------------------------------------------------------
-// CEscape()
-//    Copies 'src' to result, escaping dangerous characters using
-//    C-style escape sequences.  'src' and 'dest' should not overlap.
-// ----------------------------------------------------------------------
-string CEscape(const StringPiece& src) {
-  const size_t dest_len = src.size() * 4 + 1; // Maximum possible expansion
-  char* dest = new char[dest_len];
-  const size_t used = CEscapeString(src.data(), src.size(),
-                                    dest, dest_len);
-  string s = string(dest, used);
-  delete[] dest;
-  return s;
-}
-
-void PrefixSuccessor(string* prefix) {
+void PrefixSuccessor(std::string* prefix) {
   // We can increment the last character in the string and be done
   // unless that character is 255, in which case we have to erase the
   // last character and increment the previous character, unless that
@@ -92,73 +23,4 @@ void PrefixSuccessor(string* prefix) {
   }
 }
 
-static void StringAppendV(string* dst, const char* format, va_list ap) {
-  // First try with a small fixed size buffer
-  char space[1024];
-
-  // It's possible for methods that use a va_list to invalidate
-  // the data in it upon use.  The fix is to make a copy
-  // of the structure before using it and use that copy instead.
-  va_list backup_ap;
-  va_copy(backup_ap, ap);
-  int result = vsnprintf(space, sizeof(space), format, backup_ap);
-  va_end(backup_ap);
-
-  if ((result >= 0) && (static_cast<size_t>(result) < sizeof(space))) {
-    // It fit
-    dst->append(space, result);
-    return;
-  }
-
-  // Repeatedly increase buffer size until it fits
-  int length = sizeof(space);
-  while (true) {
-    if (result < 0) {
-      // Older behavior: just try doubling the buffer size
-      length *= 2;
-    } else {
-      // We need exactly "result+1" characters
-      length = result+1;
-    }
-    char* buf = new char[length];
-
-    // Restore the va_list before we use it again
-    va_copy(backup_ap, ap);
-    result = vsnprintf(buf, length, format, backup_ap);
-    va_end(backup_ap);
-
-    if ((result >= 0) && (result < length)) {
-      // It fit
-      dst->append(buf, result);
-      delete[] buf;
-      return;
-    }
-    delete[] buf;
-  }
-}
-
-string StringPrintf(const char* format, ...) {
-  va_list ap;
-  va_start(ap, format);
-  string result;
-  StringAppendV(&result, format, ap);
-  va_end(ap);
-  return result;
-}
-
-void SStringPrintf(string* dst, const char* format, ...) {
-  va_list ap;
-  va_start(ap, format);
-  dst->clear();
-  StringAppendV(dst, format, ap);
-  va_end(ap);
-}
-
-void StringAppendF(string* dst, const char* format, ...) {
-  va_list ap;
-  va_start(ap, format);
-  StringAppendV(dst, format, ap);
-  va_end(ap);
-}
-
 }  // namespace re2
diff --git a/util/strutil.h b/util/strutil.h
index 2c3c104..f5d87a5 100644
--- a/util/strutil.h
+++ b/util/strutil.h
@@ -7,16 +7,9 @@
 
 #include <string>
 
-#include "re2/stringpiece.h"
-#include "util/util.h"
-
 namespace re2 {
 
-string CEscape(const StringPiece& src);
-void PrefixSuccessor(string* prefix);
-string StringPrintf(const char* format, ...);
-void SStringPrintf(string* dst, const char* format, ...);
-void StringAppendF(string* dst, const char* format, ...);
+void PrefixSuccessor(std::string* prefix);
 
 }  // namespace re2
 
diff --git a/util/test.cc b/util/test.cc
deleted file mode 100644
index 29c8b41..0000000
--- a/util/test.cc
+++ /dev/null
@@ -1,31 +0,0 @@
-// Copyright 2009 The RE2 Authors.  All Rights Reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-#include <stdio.h>
-
-#include "util/test.h"
-
-DEFINE_string(test_tmpdir, "/var/tmp", "temp directory");
-
-struct Test {
-  void (*fn)(void);
-  const char *name;
-};
-
-static Test tests[10000];
-static int ntests;
-
-void RegisterTest(void (*fn)(void), const char *name) {
-  tests[ntests].fn = fn;
-  tests[ntests++].name = name;
-}
-
-int main(int argc, char** argv) {
-  for (int i = 0; i < ntests; i++) {
-    printf("%s\n", tests[i].name);
-    tests[i].fn();
-  }
-  printf("PASS\n");
-  return 0;
-}
diff --git a/util/test.h b/util/test.h
deleted file mode 100644
index 5242e94..0000000
--- a/util/test.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// Copyright 2009 The RE2 Authors.  All Rights Reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-#ifndef UTIL_TEST_H_
-#define UTIL_TEST_H_
-
-#include "util/util.h"
-#include "util/flags.h"
-#include "util/logging.h"
-
-#define TEST(x, y) \
-	void x##y(void); \
-	TestRegisterer r##x##y(x##y, # x "." # y); \
-	void x##y(void)
-
-void RegisterTest(void (*)(void), const char*);
-
-class TestRegisterer {
- public:
-  TestRegisterer(void (*fn)(void), const char *s) {
-    RegisterTest(fn, s);
-  }
-};
-
-// fatal assertions
-#define ASSERT_TRUE CHECK
-#define ASSERT_FALSE(x) CHECK(!(x))
-#define ASSERT_EQ CHECK_EQ
-#define ASSERT_NE CHECK_NE
-#define ASSERT_LT CHECK_LT
-#define ASSERT_LE CHECK_LE
-#define ASSERT_GT CHECK_GT
-#define ASSERT_GE CHECK_GE
-
-// nonfatal assertions
-// TODO(rsc): Do a better job?
-#define EXPECT_TRUE CHECK
-#define EXPECT_FALSE(x) CHECK(!(x))
-#define EXPECT_EQ CHECK_EQ
-#define EXPECT_NE CHECK_NE
-#define EXPECT_LT CHECK_LT
-#define EXPECT_LE CHECK_LE
-#define EXPECT_GT CHECK_GT
-#define EXPECT_GE CHECK_GE
-
-namespace testing {
-class MallocCounter {
- public:
-  MallocCounter(int x) {}
-  static const int THIS_THREAD_ONLY = 0;
-  long long HeapGrowth() { return 0; }
-  long long PeakHeapGrowth() { return 0; }
-  void Reset() {}
-};
-}  // namespace testing
-
-#endif  // UTIL_TEST_H_
diff --git a/util/util.h b/util/util.h
deleted file mode 100644
index 33d100a..0000000
--- a/util/util.h
+++ /dev/null
@@ -1,38 +0,0 @@
-// Copyright 2009 The RE2 Authors.  All Rights Reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-#ifndef UTIL_UTIL_H_
-#define UTIL_UTIL_H_
-
-// TODO(junyer): Get rid of this.
-#include <string>
-using std::string;
-
-#define arraysize(array) (int)(sizeof(array)/sizeof((array)[0]))
-
-#ifndef ATTRIBUTE_NORETURN
-#if defined(__GNUC__)
-#define ATTRIBUTE_NORETURN __attribute__((noreturn))
-#elif defined(_MSC_VER)
-#define ATTRIBUTE_NORETURN __declspec(noreturn)
-#else
-#define ATTRIBUTE_NORETURN
-#endif
-#endif
-
-#ifndef FALLTHROUGH_INTENDED
-#if defined(__clang__)
-#define FALLTHROUGH_INTENDED [[clang::fallthrough]]
-#elif defined(__GNUC__) && __GNUC__ >= 7
-#define FALLTHROUGH_INTENDED [[gnu::fallthrough]]
-#else
-#define FALLTHROUGH_INTENDED do {} while (0)
-#endif
-#endif
-
-#ifndef NO_THREAD_SAFETY_ANALYSIS
-#define NO_THREAD_SAFETY_ANALYSIS
-#endif
-
-#endif  // UTIL_UTIL_H_
```

