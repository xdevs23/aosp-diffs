```diff
diff --git a/.devcontainer/Dockerfile b/.devcontainer/Dockerfile
index 24a2d0d57..3933a9da4 100644
--- a/.devcontainer/Dockerfile
+++ b/.devcontainer/Dockerfile
@@ -1,14 +1,12 @@
 # Modified from https://github.com/iwahjoedi/android-devcontainer/blob/main/Image/Dockerfile
-ARG VARIENT="ubuntu-22.04"
-FROM mcr.microsoft.com/vscode/devcontainers/base:0-${VARIENT}
+# Docker image version history: https://github.com/devcontainers/images/tree/main/src/base-ubuntu/history
+FROM mcr.microsoft.com/devcontainers/base:1-ubuntu-24.04
 
 ENV DEVCONTAINER="true"
 
 RUN apt clean && apt-get update && export DEBIAN_FRONTEND=noninteractive \
     && apt-get -y upgrade \
-    && apt-get -y install git \
     && apt-get -y install clang cmake ninja-build pkg-config \
-    && apt-get -y install wget unzip \
     && apt-get -y install openjdk-17-jdk \
     && apt-get clean -y \
     && rm -rf /var/lib/apt/lists/*
@@ -55,4 +53,6 @@ RUN yes | sdkmanager --install "platforms;android-31"
 RUN yes | sdkmanager --install "platforms;android-32"
 RUN yes | sdkmanager --install "platforms;android-33"
 RUN yes | sdkmanager --install "platforms;android-34"
-RUN yes | sdkmanager --install "platform-tools" "cmdline-tools;latest"
\ No newline at end of file
+RUN yes | sdkmanager --install "platforms;android-35"
+RUN yes | sdkmanager --install "cmdline-tools;latest"
+RUN yes | sdkmanager --install "platform-tools"
diff --git a/.github/.java-version b/.github/.java-version
new file mode 100644
index 000000000..98d9bcb75
--- /dev/null
+++ b/.github/.java-version
@@ -0,0 +1 @@
+17
diff --git a/.github/dependabot.yml b/.github/dependabot.yml
deleted file mode 100644
index 9cd302c72..000000000
--- a/.github/dependabot.yml
+++ /dev/null
@@ -1,27 +0,0 @@
-version: 2
-
-updates:
-  - package-ecosystem: "github-actions"
-    directory: "/"
-    schedule:
-      interval: "weekly"
-
-  - package-ecosystem: "gradle"
-    directory: "/"
-    schedule:
-      interval: "weekly"
-    groups:
-      android-gradle-plugin:
-        patterns:
-          - "com.android.tools:common"
-          - "com.android.tools.build:gradle*"
-      androidx-test:
-        patterns:
-          - "androidx.test*"
-      androidx:
-        patterns:
-          - "androidx.*"
-    ignore:
-      # don't auto update nativeruntime-dist-compat since it needs
-      # to be updated with code changes together
-      - dependency-name: "org.robolectric:nativeruntime-dist-compat"
diff --git a/.github/renovate.json b/.github/renovate.json
new file mode 100644
index 000000000..e81d41d9b
--- /dev/null
+++ b/.github/renovate.json
@@ -0,0 +1,56 @@
+{
+  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
+  "extends": [
+    "config:recommended",
+    ":disableDependencyDashboard",
+    "schedule:weekly"
+  ],
+  "ignoreDeps": [
+    "com.google.android.gms:play-services-auth",
+    "com.google.android.gms:play-services-base",
+    "com.google.android.gms:play-services-basement",
+    "org.apache.httpcomponents:httpclient",
+    "org.apache.httpcomponents:httpcore",
+    "org.robolectric:nativeruntime-dist-compat"
+  ],
+  "labels": [
+    "dependencies"
+  ],
+  "packageRules": [
+    {
+      "groupName": "GitHub Actions",
+      "matchManagers": "github-actions"
+    },
+    {
+      "groupName": "Android Gradle Plugin",
+      "matchManagers": "gradle",
+      "matchPackageNames": [
+        "com.android.library",
+        "com.android.tools:common",
+        "com.android.tools.build:gradle*"
+      ]
+    },
+    {
+      "groupName": "AndroidX Test",
+      "matchManagers": "gradle",
+      "matchPackageNames": [
+        "androidx.test*"
+      ]
+    },
+    {
+      "groupName": "AndroidX",
+      "matchManagers": "gradle",
+      "matchPackageNames": [
+        "androidx.*"
+      ]
+    },
+    {
+      "enabled": false,
+      "matchCurrentVersion": "1.2.0",
+      "matchManagers": "gradle",
+      "matchPackageNames": [
+        "androidx.fragment:fragment"
+      ]
+    }
+  ]
+}
diff --git a/.github/workflows/check_code_style.yml b/.github/workflows/check_code_style.yml
index 5a00834c0..9d38a5658 100644
--- a/.github/workflows/check_code_style.yml
+++ b/.github/workflows/check_code_style.yml
@@ -27,15 +27,15 @@ jobs:
         with:
           fetch-depth: 0
 
-      - name: Set up JDK 17
+      - name: Set up JDK
         uses: actions/setup-java@v4
         with:
           distribution: 'adopt'
-          java-version: 17
+          java-version-file: .github/.java-version
 
       - name: Download google-java-format
         run: |
-          googleJavaFormatVersion="1.25.0"
+          googleJavaFormatVersion="1.26.0"
           curl -L -o $HOME/google-java-format.jar https://github.com/google/google-java-format/releases/download/v${googleJavaFormatVersion}/google-java-format-${googleJavaFormatVersion}-all-deps.jar
           curl -L -o $HOME/google-java-format-diff.py https://raw.githubusercontent.com/google/google-java-format/v${googleJavaFormatVersion}/scripts/google-java-format-diff.py
           chmod +x $HOME/google-java-format-diff.py
@@ -46,6 +46,7 @@ jobs:
           echo "Running google-java-format-diff against 'origin/$base_branch'"
           git fetch origin "$base_branch" --depth 1
           diff=$(git diff -U0 $(git merge-base HEAD origin/$base_branch) -- . \
+            ':(exclude)processor/src/test/resources/org/robolectric/Robolectric_*.java' \
             ':(exclude)robolectric/src/test/java/org/robolectric/R.java' \
             ':(exclude)robolectric/src/test/java/org/robolectric/Manifest.java' \
             | $HOME/google-java-format-diff.py --google-java-format-jar=$HOME/google-java-format.jar -p1)
diff --git a/.github/workflows/copybara_build_and_test.yml b/.github/workflows/copybara_build_and_test.yml
index 367506bd2..9963c8657 100644
--- a/.github/workflows/copybara_build_and_test.yml
+++ b/.github/workflows/copybara_build_and_test.yml
@@ -18,11 +18,11 @@ jobs:
     steps:
       - uses: actions/checkout@v4
 
-      - name: Set up JDK 17
+      - name: Set up JDK
         uses: actions/setup-java@v4
         with:
           distribution: 'adopt'
-          java-version: 17
+          java-version-file: .github/.java-version
 
       - uses: gradle/actions/setup-gradle@v4
 
diff --git a/.github/workflows/gradle_tasks_validation.yml b/.github/workflows/gradle_tasks_validation.yml
index d1ee11b14..d4a27d2e1 100644
--- a/.github/workflows/gradle_tasks_validation.yml
+++ b/.github/workflows/gradle_tasks_validation.yml
@@ -29,7 +29,7 @@ jobs:
         uses: actions/setup-java@v4
         with:
           distribution: 'adopt'
-          java-version: 17
+          java-version-file: .github/.java-version
 
       - uses: gradle/actions/setup-gradle@v4
 
@@ -52,7 +52,7 @@ jobs:
         uses: actions/setup-java@v4
         with:
           distribution: 'adopt'
-          java-version: 17
+          java-version-file: .github/.java-version
 
       - uses: gradle/actions/setup-gradle@v4
 
@@ -70,7 +70,7 @@ jobs:
         uses: actions/setup-java@v4
         with:
           distribution: 'adopt'
-          java-version: 17
+          java-version-file: .github/.java-version
 
       - uses: gradle/actions/setup-gradle@v4
 
@@ -89,11 +89,11 @@ jobs:
     steps:
       - uses: actions/checkout@v4
 
-      - name: Set up JDK 17
+      - name: Set up JDK
         uses: actions/setup-java@v4
         with:
           distribution: 'adopt'
-          java-version: 17
+          java-version-file: .github/.java-version
 
       - uses: gradle/actions/setup-gradle@v4
 
diff --git a/.github/workflows/graphics_tests.yml b/.github/workflows/graphics_tests.yml
index b0c77034c..f8d4d6c6f 100644
--- a/.github/workflows/graphics_tests.yml
+++ b/.github/workflows/graphics_tests.yml
@@ -33,11 +33,11 @@ jobs:
     steps:
       - uses: actions/checkout@v4
 
-      - name: Set up JDK 17
+      - name: Set up JDK
         uses: actions/setup-java@v4
         with:
           distribution: 'adopt'
-          java-version: 17
+          java-version-file: .github/.java-version
 
       - uses: gradle/actions/setup-gradle@v4
 
diff --git a/.github/workflows/tests.yml b/.github/workflows/tests.yml
index 1f0a295ee..a560bb2bd 100644
--- a/.github/workflows/tests.yml
+++ b/.github/workflows/tests.yml
@@ -28,11 +28,11 @@ jobs:
     steps:
       - uses: actions/checkout@v4
 
-      - name: Set up JDK 17
+      - name: Set up JDK
         uses: actions/setup-java@v4
         with:
           distribution: 'adopt'
-          java-version: 17
+          java-version-file: .github/.java-version
 
       - uses: gradle/actions/setup-gradle@v4
 
@@ -52,11 +52,11 @@ jobs:
     steps:
       - uses: actions/checkout@v4
 
-      - name: Set up JDK 17
+      - name: Set up JDK
         uses: actions/setup-java@v4
         with:
           distribution: 'adopt'
-          java-version: 17
+          java-version-file: .github/.java-version
 
       - uses: gradle/actions/setup-gradle@v4
 
@@ -97,11 +97,11 @@ jobs:
 
       - uses: actions/checkout@v4
 
-      - name: Set up JDK 17
+      - name: Set up JDK
         uses: actions/setup-java@v4
         with:
           distribution: 'adopt'
-          java-version: 17
+          java-version-file: .github/.java-version
 
       - uses: gradle/actions/setup-gradle@v4
 
@@ -172,15 +172,15 @@ jobs:
       SONATYPE_LOGIN: ${{ secrets.SONATYPE_LOGIN }}
       SONATYPE_PASSWORD: ${{ secrets.SONATYPE_PASSWORD }}
     needs: unit-tests
-    if: github.ref == 'refs/heads/master'
+    if: github.repository == 'robolectric/robolectric' && github.ref == 'refs/heads/master'
     steps:
       - uses: actions/checkout@v4
 
-      - name: Set up JDK 17
+      - name: Set up JDK
         uses: actions/setup-java@v4
         with:
           distribution: 'adopt'
-          java-version: 17
+          java-version-file: .github/.java-version
 
       - uses: gradle/actions/setup-gradle@v4
 
diff --git a/.github/workflows/validate_commit_message.yml b/.github/workflows/validate_commit_message.yml
index 43016a6ea..39e2ddcd8 100644
--- a/.github/workflows/validate_commit_message.yml
+++ b/.github/workflows/validate_commit_message.yml
@@ -37,7 +37,7 @@ jobs:
           fi
 
       - name: Validate commit body
-        if: github.actor != 'dependabot[bot]'
+        if: github.actor != 'renovate[bot]'
         run: |
           # Check that the commit has a body
           commit_body="$(git log -1 --pretty=format:'%b' | grep -v 'PiperOrigin-RevId')"
diff --git a/Android.bp b/Android.bp
index bf728d0dd..cbc17c018 100644
--- a/Android.bp
+++ b/Android.bp
@@ -62,6 +62,18 @@ robolectric_build_props {
     name: "robolectric_build_props",
 }
 
+java_genrule {
+    name: "libandroid_runtime_jar",
+    host_supported: true,
+    device_supported: false,
+    tools: ["soong_zip"],
+    host_first_srcs: [":libandroid_runtime"],
+    out: ["libandroid_runtime.jar"],
+    cmd: "mkdir -p ./native/linux/x86_64/ && " +
+        "cp $(location :libandroid_runtime) ./native/linux/x86_64/ && " +
+        "$(location soong_zip) -o $(location libandroid_runtime.jar) -D ./native",
+}
+
 java_genrule {
     name: "robolectric_props_jar",
     host_supported: true,
@@ -117,7 +129,7 @@ java_library {
         "robolectric_tzdata",
         "robolectric_framework_res",
         "robolectric_props_jar",
-        "robolectric_nativeruntime_native_prebuilt_main",
+        "libandroid_runtime_jar",
         "icu-data_host_robolectric",
     ],
     // WARNING: DO NOT ADD NEW DEPENDENCIES ON THIS MODULE OR ITS DIST JAR
@@ -229,6 +241,7 @@ java_host_for_device {
         "//packages/apps/Car/Launcher/libs/appgrid/lib/robotests:__pkg__",
         "//packages/apps/Car/libs/car-ui-lib:__pkg__",
         "//packages/apps/Car/Notification/tests/robotests:__pkg__",
+        "//packages/apps/Car/SensitiveAppLock/tests:__pkg__",
         "//packages/apps/Car/Settings/tests/deviceless:__pkg__",
         "//packages/apps/Car/Settings/tests/multivalent:__pkg__",
         "//packages/apps/Car/Settings/tests/robotests:__pkg__",
@@ -237,12 +250,14 @@ java_host_for_device {
         "//packages/apps/EmergencyInfo/tests/robolectric:__pkg__",
         "//packages/apps/KeyChain/robotests:__pkg__",
         "//packages/apps/Launcher3/tests:__pkg__",
+        "//packages/apps/Launcher3/modules/widgetpicker/tests:__pkg__",
         "//packages/apps/QuickAccessWallet/tests/robolectric:__pkg__",
         "//packages/apps/Settings/tests/robotests:__pkg__",
         "//packages/apps/StorageManager/robotests:__pkg__",
         "//packages/apps/ThemePicker/tests/robotests:__pkg__",
         "//packages/apps/TV/common/tests/robotests:__pkg__",
         "//packages/apps/TvSettings/Settings/tests/robotests:__pkg__",
+        "//packages/apps/TvSystemUI/tests/screenshot",
         "//packages/apps/TV/tests/common:__pkg__",
         "//packages/apps/WallpaperPicker2/tests/robotests:__pkg__",
         "//packages/apps/WallpaperPicker2/tests/robotests/common:__pkg__",
diff --git a/annotations/src/main/java/org/robolectric/annotation/TextLayoutMode.java b/annotations/src/main/java/org/robolectric/annotation/TextLayoutMode.java
index 9525d3215..664ded793 100644
--- a/annotations/src/main/java/org/robolectric/annotation/TextLayoutMode.java
+++ b/annotations/src/main/java/org/robolectric/annotation/TextLayoutMode.java
@@ -38,7 +38,7 @@ public @interface TextLayoutMode {
     /**
      * The new, more accurate layout mechanism.
      *
-     * @deprecated REALTISTIC is the default mode and does not need to be stated explicity.
+     * @deprecated REALISTIC is the default mode and does not need to be stated explicitly.
      */
     @Deprecated
     REALISTIC,
diff --git a/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java b/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java
index abb8abb0f..c24addd1e 100644
--- a/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java
+++ b/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java
@@ -674,7 +674,7 @@ public final class AndroidVersions {
    * Version: 14 <br>
    * ShortCode: U <br>
    * SDK API Level: 34 <br>
-   * release: false <br>
+   * release: true <br>
    */
   public static final class U extends AndroidReleased {
 
@@ -731,11 +731,11 @@ public final class AndroidVersions {
   }
 
   /**
-   * Baklava is an InDevelopment SDK after V, the name scheme has wrapped the alphabet.
+   * Baklava is an SDK after V, the name scheme has wrapped the alphabet.
    *
    * <p>All values here subject to change.
    */
-  public static final class Baklava extends AndroidUnreleased {
+  public static final class Baklava extends AndroidReleased {
 
     public static final int SDK_INT = 36;
 
@@ -759,6 +759,35 @@ public final class AndroidVersions {
     }
   }
 
+  /**
+   * Placeholder for the next InDevelopment release after Baklava.
+   *
+   * <p>All values here subject to change.
+   */
+  public static final class PostBaklava extends AndroidUnreleased {
+
+    public static final int SDK_INT = 37;
+
+    public static final String SHORT_CODE = "PostBaklava";
+
+    public static final String VERSION = "17";
+
+    @Override
+    public int getSdkInt() {
+      return SDK_INT;
+    }
+
+    @Override
+    public String getShortCode() {
+      return SHORT_CODE;
+    }
+
+    @Override
+    public String getVersion() {
+      return VERSION;
+    }
+  }
+
   /** The current release this process is running on. */
   public static final AndroidRelease CURRENT;
 
@@ -942,9 +971,9 @@ public final class AndroidVersions {
                 .append(activeCodenameLetter)
                 .append("\n");
           } else {
-            // attempt to find assume the fullname is the "shortCode", aka "Sv2", "OMR1".
+            // attempt to find assume the full name is the "shortCode", aka "Sv2", "OMR1".
             current = shortCodeToAllReleases.get(codename);
-            // else, assume the fullname is the first letter is correct.
+            // else, assume the full name is the first letter is correct.
             if (current == null) {
               current = shortCodeToAllReleases.get(foundCode);
             }
@@ -1003,6 +1032,22 @@ public final class AndroidVersions {
 
       return current;
     }
+
+    // Computes sdk int from short name. Returns -1 if not found.
+    public int computeSdkIntFromShortCode(String shortCode) {
+      for (AndroidRelease release : this.allReleases) {
+        if (release.getShortCode().equals(shortCode)) {
+          return release.getSdkInt();
+        }
+      }
+      return -1;
+    }
+  }
+
+  /** Computes sdk int from short name. Returns -1 if not found. */
+  public static int computeSdkIntFromShortCode(String shortCode) {
+    SdkInformation information = gatherStaticSdkInformationFromThisClass();
+    return information.computeSdkIntFromShortCode(shortCode);
   }
 
   /**
@@ -1062,9 +1107,9 @@ public final class AndroidVersions {
     int sdk = sdkVersionString == null ? 0 : Integer.parseInt(sdkVersionString);
     // "REL"
     String release = buildProps.getProperty("ro.build.version.release");
-    // "Tiramasu", "UpsideDownCake"
+    // "Tiramisu", "UpsideDownCake"
     String codename = buildProps.getProperty("ro.build.version.codename");
-    // "Tiramasu,UpsideDownCake", "UpsideDownCake", "REL"
+    // "Tiramisu,UpsideDownCake", "UpsideDownCake", "REL"
     String codenames = buildProps.getProperty("ro.build.version.all_codenames");
     String[] allCodeNames = codenames == null ? new String[0] : codenames.split(",");
     String[] activeCodeNames =
diff --git a/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java b/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java
index fd7723240..42c4a9aac 100644
--- a/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java
+++ b/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java
@@ -22,12 +22,12 @@ public final class AndroidVersionsTest {
                 .map(AndroidRelease::getSdkInt)
                 .collect(Collectors.toList()))
         .containsExactly(
-            16, 17, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35);
+            16, 17, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36);
     assertThat(
             AndroidVersions.getUnreleased().stream()
                 .map(AndroidRelease::getSdkInt)
                 .collect(Collectors.toList()))
-        .containsExactly(36);
+        .containsExactly(37);
   }
 
   @Test
@@ -38,7 +38,7 @@ public final class AndroidVersionsTest {
     assertThat(new AndroidVersions.Baklava().getSdkInt()).isEqualTo(36);
     assertThat(new AndroidVersions.Baklava().getShortCode()).isEqualTo("Baklava");
     assertThat(new AndroidVersions.Baklava().getVersion()).isEqualTo("16");
-    assertThat(new AndroidVersions.Baklava().isReleased()).isFalse();
+    assertThat(new AndroidVersions.Baklava().isReleased()).isTrue();
   }
 
   @Test
diff --git a/buildSrc/src/main/java/org/robolectric/gradle/DeployedRoboJavaModulePlugin.kt b/buildSrc/src/main/java/org/robolectric/gradle/DeployedRoboJavaModulePlugin.kt
index 14957ae23..0f4268fe3 100644
--- a/buildSrc/src/main/java/org/robolectric/gradle/DeployedRoboJavaModulePlugin.kt
+++ b/buildSrc/src/main/java/org/robolectric/gradle/DeployedRoboJavaModulePlugin.kt
@@ -1,6 +1,5 @@
 package org.robolectric.gradle
 
-import java.net.URI
 import org.gradle.api.Plugin
 import org.gradle.api.Project
 import org.gradle.api.plugins.BasePluginExtension
@@ -78,61 +77,11 @@ class DeployedRoboJavaModulePlugin : Plugin<Project> {
 
             artifactId = mavenArtifactName
 
-            pom {
-              name.set(project.name)
-              description.set("An alternative Android testing framework.")
-              url.set("http://robolectric.org")
-
-              licenses {
-                license {
-                  name.set("The MIT License")
-                  url.set("https://opensource.org/licenses/MIT")
-                }
-              }
-
-              scm {
-                url.set("git@github.com:robolectric/robolectric.git")
-                connection.set("scm:git:git://github.com/robolectric/robolectric.git")
-                developerConnection.set("scm:git:https://github.com/robolectric/robolectric.git")
-              }
-
-              developers {
-                developer {
-                  name.set("Brett Chabot")
-                  email.set("brettchabot@google.com")
-                  organization.set("Google Inc.")
-                  organizationUrl.set("http://google.com")
-                }
-
-                developer {
-                  name.set("Michael Hoisie")
-                  email.set("hoisie@google.com")
-                  organization.set("Google Inc.")
-                  organizationUrl.set("http://google.com")
-                }
-
-                developer {
-                  name.set("Christian Williams")
-                  email.set("antixian666@gmail.com")
-                }
-              }
-            }
+            applyPomMetadata(project)
           }
         }
 
-        repositories {
-          maven {
-            val releasesRepoUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
-            val snapshotsRepoUrl = "https://oss.sonatype.org/content/repositories/snapshots"
-
-            url = if (isSnapshotVersion) URI(snapshotsRepoUrl) else URI(releasesRepoUrl)
-
-            credentials {
-              username = System.getProperty("sonatype-login", System.getenv("SONATYPE_LOGIN"))
-              password = System.getProperty("sonatype-password", System.getenv("SONATYPE_PASSWORD"))
-            }
-          }
-        }
+        sonatypeRepositories(isSnapshotVersion)
 
         project.extensions.configure<SigningExtension> {
           setRequired { !isSnapshotVersion && project.gradle.taskGraph.hasTask("uploadArchives") }
diff --git a/buildSrc/src/main/java/org/robolectric/gradle/PomMetadata.kt b/buildSrc/src/main/java/org/robolectric/gradle/PomMetadata.kt
new file mode 100644
index 000000000..d8ff77978
--- /dev/null
+++ b/buildSrc/src/main/java/org/robolectric/gradle/PomMetadata.kt
@@ -0,0 +1,40 @@
+package org.robolectric.gradle
+
+import org.gradle.api.Project
+import org.gradle.api.publish.maven.MavenPublication
+
+fun MavenPublication.applyPomMetadata(project: Project) {
+  pom {
+    name.set(project.name)
+    description.set("An alternative Android testing framework.")
+    url.set("http://robolectric.org")
+
+    licenses {
+      license {
+        name.set("The MIT License")
+        url.set("https://opensource.org/licenses/MIT")
+      }
+    }
+
+    developers {
+      developer {
+        name.set("Brett Chabot")
+        email.set("brettchabot@google.com")
+        organization.set("Google Inc.")
+        organizationUrl.set("http://google.com")
+      }
+
+      developer {
+        name.set("Michael Hoisie")
+        email.set("hoisie@google.com")
+        organization.set("Google Inc.")
+        organizationUrl.set("http://google.com")
+      }
+
+      developer {
+        name.set("Christian Williams")
+        email.set("antixian666@gmail.com")
+      }
+    }
+  }
+}
diff --git a/buildSrc/src/main/java/org/robolectric/gradle/SonatypeRepositories.kt b/buildSrc/src/main/java/org/robolectric/gradle/SonatypeRepositories.kt
new file mode 100644
index 000000000..d70660d75
--- /dev/null
+++ b/buildSrc/src/main/java/org/robolectric/gradle/SonatypeRepositories.kt
@@ -0,0 +1,21 @@
+package org.robolectric.gradle
+
+import java.net.URI
+import org.gradle.api.publish.PublishingExtension
+
+fun PublishingExtension.sonatypeRepositories(isSnapshotVersion: Boolean) {
+  repositories {
+    maven {
+      name = "SonatypeOSS"
+      val releasesRepoUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+      val snapshotsRepoUrl = "https://oss.sonatype.org/content/repositories/snapshots/"
+
+      url = if (isSnapshotVersion) URI(snapshotsRepoUrl) else URI(releasesRepoUrl)
+
+      credentials {
+        username = System.getProperty("sonatype-login", System.getenv("SONATYPE_LOGIN"))
+        password = System.getProperty("sonatype-password", System.getenv("SONATYPE_PASSWORD"))
+      }
+    }
+  }
+}
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index e47f5a9bd..2435695a9 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -1,10 +1,10 @@
 [versions]
-robolectric-nativeruntime-dist-compat = "1.0.16"
+robolectric-nativeruntime-dist-compat = "1.0.17"
 
 # https://developer.android.com/studio/releases
-android-gradle = "8.7.2"
+android-gradle = "8.9.1"
 
-android-tools-common = "31.7.2"
+android-tools-common = "31.9.1"
 
 # The runtime dependency for Android classes when Robolectric tests are run
 androidstubs = "34"
@@ -13,38 +13,38 @@ androidstubs = "34"
 conscrypt = "2.5.2"
 
 # https://github.com/bcgit/bc-java/tags
-bouncycastle = "1.79"
+bouncycastle = "1.80"
 
 # https://github.com/findbugsproject/findbugs/tags
 findbugs-jsr305 = "3.0.2"
 
 # https://github.com/hamcrest/JavaHamcrest/releases
-hamcrest = "2.0.0.0"
+hamcrest = "3.0"
 
 # https://github.com/google/error-prone/releases
-error-prone = "2.36.0"
+error-prone = "2.37.0"
 
 # https://github.com/tbroyer/gradle-errorprone-plugin/releases
 error-prone-gradle = "4.1.0"
 
 # https://kotlinlang.org/docs/releases.html#release-details
-kotlin = "2.1.0"
+kotlin = "2.1.20"
 
 # https://github.com/Kotlin/kotlinx.coroutines/releases/
-kotlinx-coroutines = '1.9.0'
+kotlinx-coroutines = '1.10.1'
 
 # https://github.com/diffplug/spotless/blob/main/plugin-gradle/CHANGES.md
-spotless-gradle = "7.0.0.BETA4"
+spotless-gradle = "7.0.3"
 
 # https://detekt.dev/changelog
-detekt-gradle = "1.23.7"
+detekt-gradle = "1.23.8"
 
 # https://hc.apache.org/news.html
 apache-http-core = "4.0.1"
 apache-http-client = "4.0.3"
 
 # https://asm.ow2.io/versions.html
-asm = "9.7.1"
+asm = "9.8"
 
 # https://github.com/google/auto/releases
 auto-common = "1.2.2"
@@ -55,39 +55,38 @@ auto-value = "1.11.0"
 compile-testing = "0.21.0"
 
 # https://github.com/google/guava/releases
-guava-jre = "33.3.1-jre"
+guava-jre = "33.4.6-jre"
 
 # https://github.com/google/gson/releases
-gson = "2.11.0"
+gson = "2.12.1"
 
 # https://github.com/google/truth/releases
-truth = "1.4.2"
+truth = "1.4.4"
 
 # https://github.com/unicode-org/icu/releases
-icu4j = "76.1"
+icu4j = "77.1"
 
 # https://www.eclemma.org/jacoco/
-jacoco = "0.8.11"
+jacoco = "0.8.13"
 
 # https://github.com/javaee/javax.annotation/tags
 javax-annotation-api = "1.3.2"
-javax-annotation-jsr250-api = "1.0"
 javax-inject = "1"
 
 # https://junit.org/junit4/
 junit4 = "4.13.2"
 
 # https://github.com/google/libphonenumber/releases
-libphonenumber = "8.13.51"
+libphonenumber = "9.0.3"
 
 # https://github.com/mockito/mockito/releases
-mockito = "4.11.0"
+mockito = "5.17.0"
 
 # https://github.com/mockk/mockk/releases
-mockk = "1.13.7"
+mockk = "1.13.17"
 
 # https://github.com/takahirom/roborazzi/releases
-roborazzi = "1.34.0"
+roborazzi = "1.43.1"
 
 # https://square.github.io/okhttp/changelogs/changelog/
 okhttp = "4.12.0"
@@ -95,7 +94,7 @@ okhttp = "4.12.0"
 # https://github.com/powermock/powermock/releases
 powermock = "2.0.9"
 
-snakeyaml = "2.3"
+snakeyaml = "2.4"
 
 sqlite4java = "1.0.392"
 
@@ -103,12 +102,12 @@ sqlite4java = "1.0.392"
 androidx-annotation = "1.9.1"
 androidx-appcompat = "1.7.0"
 androidx-biometric = "1.1.0"
-androidx-constraintlayout = "2.2.0"
+androidx-constraintlayout = "2.2.1"
 androidx-core = "1.15.0"
-androidx-fragment = "1.8.5"
+androidx-fragment = "1.8.6"
 androidx-window = "1.3.0"
 androidx-room = "2.6.1"
-androidx-recyclerview = "1.3.2"
+androidx-recyclerview = "1.4.0"
 
 # https://github.com/android/android-test/tags
 androidx-test-core = "1.6.1"
@@ -120,7 +119,7 @@ androidx-test-runner = "1.6.2"
 androidx-test-services = "1.5.0"
 
 # https://developer.android.com/jetpack/androidx/releases/compose
-androidx-compose-bom = "2024.11.00"
+androidx-compose-bom = "2025.03.01"
 
 # for shadows/playservices/build.gradle
 androidx-fragment-for-shadows = "1.2.0"
@@ -166,14 +165,13 @@ findbugs-jsr305 = { module = "com.google.code.findbugs:jsr305", version.ref = "f
 guava = { module = "com.google.guava:guava", version.ref = "guava-jre" }
 guava-testlib = { module = "com.google.guava:guava-testlib", version.ref = "guava-jre" }
 gson = { module = "com.google.code.gson:gson", version.ref = "gson" }
-hamcrest-junit = { module = "org.hamcrest:hamcrest-junit", version.ref = "hamcrest" }
+hamcrest = { module = "org.hamcrest:hamcrest", version.ref = "hamcrest" }
 
 icu4j = { module = "com.ibm.icu:icu4j", version.ref = "icu4j" }
 
 junit4 = { module = "junit:junit", version.ref = "junit4" }
 
 javax-annotation-api = { module = "javax.annotation:javax.annotation-api", version.ref = "javax-annotation-api" }
-javax-annotation-jsr250-api = { module = "javax.annotation:jsr250-api", version.ref = "javax-annotation-jsr250-api" }
 javax-inject = { module = "javax.inject:javax.inject", version.ref = "javax-inject" }
 
 libphonenumber = { module = "com.googlecode.libphonenumber:libphonenumber", version.ref = "libphonenumber" }
@@ -199,7 +197,7 @@ sqlite4java-win32-x86 = { module = "com.almworks.sqlite4java:sqlite4java-win32-x
 truth = { module = "com.google.truth:truth", version.ref = "truth" }
 
 mockito = { module = "org.mockito:mockito-core", version.ref = "mockito" }
-mockito-inline = { module = "org.mockito:mockito-inline", version.ref = "mockito" }
+mockito-subclass = { module = "org.mockito:mockito-subclass", version.ref = "mockito" }
 mockk = { module = "io.mockk:mockk", version.ref = "mockk" }
 
 roborazzi = { module = "io.github.takahirom.roborazzi:roborazzi", version.ref = "roborazzi" }
@@ -245,6 +243,9 @@ play-services-basement = { module = "com.google.android.gms:play-services-baseme
 
 spotless = { module = "com.diffplug.spotless:spotless-plugin-gradle", version.ref = "spotless-gradle" }
 
+# Not used, but helps Renovate trigger updates for Jacoco
+jacoco-agent = { module = "org.jacoco:org.jacoco.agent", version.ref = "jacoco" }
+
 [bundles]
 play-services-for-shadows = ["androidx-fragment-for-shadows", "play-services-auth-for-shadows", "play-services-base-for-shadows", "play-services-basement-for-shadows"]
 powermock = ["powermock-module-junit4-rule", "powermock-api-mockito2", "powermock-classloading-xstream"]
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 94113f200..37f853b1c 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.11-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
 networkTimeout=10000
 validateDistributionUrl=true
 zipStoreBase=GRADLE_USER_HOME
diff --git a/gradlew b/gradlew
index f5feea6d6..f3b75f3b0 100755
--- a/gradlew
+++ b/gradlew
@@ -86,8 +86,7 @@ done
 # shellcheck disable=SC2034
 APP_BASE_NAME=${0##*/}
 # Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
-APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
-' "$PWD" ) || exit
+APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit
 
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD=maximum
diff --git a/integration_tests/androidx_test/build.gradle.kts b/integration_tests/androidx_test/build.gradle.kts
index e471955b0..169a00d96 100644
--- a/integration_tests/androidx_test/build.gradle.kts
+++ b/integration_tests/androidx_test/build.gradle.kts
@@ -59,6 +59,7 @@ dependencies {
   testImplementation(libs.androidx.fragment)
   testImplementation(libs.androidx.fragment.testing)
   testImplementation(libs.androidx.test.ext.junit)
+  testImplementation(libs.findbugs.jsr305)
   testImplementation(libs.truth)
 
   androidTestImplementation(project(":annotations"))
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithMenuTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithMenuTest.java
index aa1b70db7..79ff1b459 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithMenuTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithMenuTest.java
@@ -11,12 +11,9 @@ import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.TextLayoutMode;
-import org.robolectric.annotation.TextLayoutMode.Mode;
 
 /** Test Espresso on Robolectric interoperability for menus. */
 @RunWith(AndroidJUnit4.class)
-@TextLayoutMode(Mode.REALISTIC)
 public class EspressoWithMenuTest {
 
   @Test
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithSwitchCompatTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithSwitchCompatTest.java
index c4882920c..2613e7e9d 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithSwitchCompatTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithSwitchCompatTest.java
@@ -10,12 +10,10 @@ import androidx.test.core.app.ActivityScenario;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.TextLayoutMode;
 import org.robolectric.integration.axt.R;
 
 /** Tests Espresso on Activities with {@link androidx.appcompat.widget.SwitchCompat}. */
 @RunWith(AndroidJUnit4.class)
-@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
 public class EspressoWithSwitchCompatTest {
   @Test
   public void switchCompatTest() {
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithToolbarMenuTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithToolbarMenuTest.java
index c2d68ea86..2b6240d92 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithToolbarMenuTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithToolbarMenuTest.java
@@ -11,13 +11,10 @@ import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.TextLayoutMode;
-import org.robolectric.annotation.TextLayoutMode.Mode;
 import org.robolectric.shadows.ShadowViewConfiguration;
 
 /** Test Espresso on Robolectric interoperability for toolbar menus. */
 @RunWith(AndroidJUnit4.class)
-@TextLayoutMode(Mode.REALISTIC)
 public class EspressoWithToolbarMenuTest {
   @Test
   public void appCompatToolbarMenuClick() {
diff --git a/integration_tests/composeui/src/test/java/org/robolectric/integrationtests/composeui/FocusRequesterTest.kt b/integration_tests/composeui/src/test/java/org/robolectric/integrationtests/composeui/FocusRequesterTest.kt
index 1034332e4..dd9da3390 100644
--- a/integration_tests/composeui/src/test/java/org/robolectric/integrationtests/composeui/FocusRequesterTest.kt
+++ b/integration_tests/composeui/src/test/java/org/robolectric/integrationtests/composeui/FocusRequesterTest.kt
@@ -1,6 +1,8 @@
 package org.robolectric.integrationtests.composeui
 
-import androidx.compose.material3.TextField
+import androidx.compose.foundation.layout.padding
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
 import androidx.compose.runtime.Composable
 import androidx.compose.runtime.LaunchedEffect
 import androidx.compose.runtime.remember
@@ -17,13 +19,24 @@ import org.robolectric.RobolectricTestRunner
 class FocusRequesterTest {
   @get:Rule val composeTestRule = createComposeRule()
 
-  /** Test for https://github.com/robolectric/robolectric/issues/9703 */
+  /**
+   * Test to ensure that `FocusRequester` can be used within a `Scaffold`.
+   *
+   * Originally reported in
+   * [robolectric/robolectric#9703](https://github.com/robolectric/robolectric/issues/9703).
+   * Solution coming from https://issuetracker.google.com/issues/206249038.
+   */
   @Test
   fun `check FocusRequester is initialized`() {
     composeTestRule.setContent {
-      val focusRequester = rememberFocusRequester()
+      Scaffold { contentPadding ->
+        val focusRequester = rememberFocusRequester()
 
-      TextField(value = "", onValueChange = {}, modifier = Modifier.focusRequester(focusRequester))
+        Text(
+          text = "Robolectric",
+          modifier = Modifier.padding(contentPadding).focusRequester(focusRequester),
+        )
+      }
     }
   }
 
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/ContextTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/ContextTest.java
index 37f8a4193..9b30f2724 100644
--- a/integration_tests/ctesque/src/androidTest/java/android/app/ContextTest.java
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/ContextTest.java
@@ -1,11 +1,13 @@
 package android.app;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
 import static org.junit.Assume.assumeTrue;
 
 import android.Manifest;
 import android.accounts.Account;
 import android.accounts.AccountManager;
+import android.annotation.SuppressLint;
 import android.app.admin.DeviceAdminReceiver;
 import android.app.admin.DevicePolicyManager;
 import android.app.role.RoleManager;
@@ -19,10 +21,13 @@ import android.appwidget.AppWidgetProvider;
 import android.appwidget.AppWidgetProviderInfo;
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothManager;
+import android.content.BroadcastReceiver;
 import android.content.ClipData;
 import android.content.ClipboardManager;
 import android.content.ComponentName;
 import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
 import android.content.pm.CrossProfileApps;
 import android.content.pm.LauncherApps;
 import android.hardware.Sensor;
@@ -61,6 +66,7 @@ import com.google.common.truth.Truth;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Set;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -71,6 +77,7 @@ import org.robolectric.util.ReflectionHelpers;
 @RunWith(AndroidJUnit4.class)
 public class ContextTest {
   private static final int APP_WIDGET_HOST_ID = 1;
+  private Application application;
 
   @Rule
   public GrantPermissionRule mRuntimePermissionRule =
@@ -85,11 +92,15 @@ public class ContextTest {
           Manifest.permission.WRITE_EXTERNAL_STORAGE,
           Manifest.permission.READ_EXTERNAL_STORAGE);
 
+  @Before
+  public void setUp() {
+    application = ApplicationProvider.getApplicationContext();
+  }
+
   @Test
   public void audioManager_applicationInstance_isNotSameAsActivityInstance() {
     AudioManager applicationAudioManager =
-        (AudioManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
+        (AudioManager) application.getSystemService(Context.AUDIO_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -117,8 +128,7 @@ public class ContextTest {
   @Test
   public void audioManager_instance_changesAffectEachOther() {
     AudioManager applicationAudioManager =
-        (AudioManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
+        (AudioManager) application.getSystemService(Context.AUDIO_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -139,8 +149,7 @@ public class ContextTest {
   @Test
   public void accountManager_applicationInstance_isNotSameAsActivityInstance() {
     AccountManager applicationAccountManager =
-        (AccountManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.ACCOUNT_SERVICE);
+        (AccountManager) application.getSystemService(Context.ACCOUNT_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -168,8 +177,7 @@ public class ContextTest {
   @Test
   public void accountManager_instance_retrievesSameAccounts() {
     AccountManager applicationAccountManager =
-        (AccountManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.ACCOUNT_SERVICE);
+        (AccountManager) application.getSystemService(Context.ACCOUNT_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -189,8 +197,7 @@ public class ContextTest {
   @Test
   public void batteryManager_applicationInstance_isNotSameAsActivityInstance() {
     BatteryManager applicationBatteryManager =
-        (BatteryManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.BATTERY_SERVICE);
+        (BatteryManager) application.getSystemService(Context.BATTERY_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -218,8 +225,7 @@ public class ContextTest {
   @Test
   public void alarmManager_applicationInstance_isNotSameAsActivityInstance() {
     AlarmManager applicationAlarmManager =
-        (AlarmManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.ALARM_SERVICE);
+        (AlarmManager) application.getSystemService(Context.ALARM_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -247,8 +253,7 @@ public class ContextTest {
   @Test
   public void alarmManager_instance_retrievesSameAlarmClockInfo() {
     AlarmManager applicationAlarmManager =
-        (AlarmManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.ALARM_SERVICE);
+        (AlarmManager) application.getSystemService(Context.ALARM_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -268,8 +273,7 @@ public class ContextTest {
   @Test
   public void clipboardManager_applicationInstance_isNotSameAsActivityInstance() {
     ClipboardManager applicationClipboardManager =
-        (ClipboardManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.CLIPBOARD_SERVICE);
+        (ClipboardManager) application.getSystemService(Context.CLIPBOARD_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -297,8 +301,7 @@ public class ContextTest {
   @Test
   public void clipboardManager_instance_retrievesSamePrimaryClip() {
     ClipboardManager applicationClipboardManager =
-        (ClipboardManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.CLIPBOARD_SERVICE);
+        (ClipboardManager) application.getSystemService(Context.CLIPBOARD_SERVICE);
     ClipData clipData = ClipData.newPlainText("label", "text");
     applicationClipboardManager.setPrimaryClip(clipData);
 
@@ -319,8 +322,7 @@ public class ContextTest {
   @Test
   public void keyguardManager_applicationInstance_isNotSameAsActivityInstance() {
     KeyguardManager applicationKeyguardManager =
-        (KeyguardManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.KEYGUARD_SERVICE);
+        (KeyguardManager) application.getSystemService(Context.KEYGUARD_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -348,8 +350,7 @@ public class ContextTest {
   @Test
   public void keyguardManager_isKeyguardLocked_retrievesSameState() {
     KeyguardManager applicationKeyguardManager =
-        (KeyguardManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.KEYGUARD_SERVICE);
+        (KeyguardManager) application.getSystemService(Context.KEYGUARD_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -367,9 +368,7 @@ public class ContextTest {
   @Test
   public void devicePolicyManager_applicationInstance_isNotSameAsActivityInstance() {
     DevicePolicyManager applicationDpm =
-        (DevicePolicyManager)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.DEVICE_POLICY_SERVICE);
+        (DevicePolicyManager) application.getSystemService(Context.DEVICE_POLICY_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -397,11 +396,8 @@ public class ContextTest {
   @Test
   public void devicePolicyManager_instance_retrievesSameAdminStatus() {
     DevicePolicyManager applicationDpm =
-        (DevicePolicyManager)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.DEVICE_POLICY_SERVICE);
-    ComponentName testAdminComponent =
-        new ComponentName(ApplicationProvider.getApplicationContext(), DeviceAdminReceiver.class);
+        (DevicePolicyManager) application.getSystemService(Context.DEVICE_POLICY_SERVICE);
+    ComponentName testAdminComponent = new ComponentName(application, DeviceAdminReceiver.class);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -419,7 +415,7 @@ public class ContextTest {
   @Test
   public void autofillManager_applicationInstance_isNotSameAsActivityInstance() {
     AutofillManager applicationAutofillManager =
-        ApplicationProvider.getApplicationContext().getSystemService(AutofillManager.class);
+        application.getSystemService(AutofillManager.class);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -447,7 +443,7 @@ public class ContextTest {
   @Test
   public void autofillManager_instance_retrievesSameAutofillService() {
     AutofillManager applicationAutofillManager =
-        ApplicationProvider.getApplicationContext().getSystemService(AutofillManager.class);
+        application.getSystemService(AutofillManager.class);
 
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
@@ -469,8 +465,7 @@ public class ContextTest {
   @Test
   public void downloadManager_applicationInstance_isNotSameAsActivityInstance() {
     DownloadManager applicationDownloadManager =
-        (DownloadManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.DOWNLOAD_SERVICE);
+        (DownloadManager) application.getSystemService(Context.DOWNLOAD_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -499,8 +494,7 @@ public class ContextTest {
   public void downloadManager_instance_retrievesSameMimeTypeForDownloadedFile() {
     final long testId = 1L;
     DownloadManager applicationDownloadManager =
-        (DownloadManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.DOWNLOAD_SERVICE);
+        (DownloadManager) application.getSystemService(Context.DOWNLOAD_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -519,9 +513,7 @@ public class ContextTest {
   @Test
   public void fingerprintManager_applicationInstance_isNotSameAsActivityInstance() {
     FingerprintManager applicationFingerprintManager =
-        (FingerprintManager)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.FINGERPRINT_SERVICE);
+        (FingerprintManager) application.getSystemService(Context.FINGERPRINT_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -551,9 +543,7 @@ public class ContextTest {
   @Test
   public void fingerprintManager_instance_hasConsistentFingerprintState() {
     FingerprintManager applicationFingerprintManager =
-        (FingerprintManager)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.FINGERPRINT_SERVICE);
+        (FingerprintManager) application.getSystemService(Context.FINGERPRINT_SERVICE);
 
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
@@ -582,8 +572,7 @@ public class ContextTest {
   @Test
   public void activityManager_applicationInstance_isNotSameAsActivityInstance() {
     ActivityManager applicationActivityManager =
-        (ActivityManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE);
+        (ActivityManager) application.getSystemService(Context.ACTIVITY_SERVICE);
 
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
@@ -612,8 +601,7 @@ public class ContextTest {
   @Test
   public void activityManager_instance_retrievesConsistentLowRamDeviceStatus() {
     ActivityManager applicationActivityManager =
-        (ActivityManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE);
+        (ActivityManager) application.getSystemService(Context.ACTIVITY_SERVICE);
 
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
@@ -632,8 +620,7 @@ public class ContextTest {
   @Test
   public void cameraManager_applicationInstance_isNotSameAsActivityInstance() {
     CameraManager applicationCameraManager =
-        (CameraManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.CAMERA_SERVICE);
+        (CameraManager) application.getSystemService(Context.CAMERA_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -661,8 +648,7 @@ public class ContextTest {
   @Test
   public void appWidgetManager_applicationInstance_isNotSameAsActivityInstance() {
     AppWidgetManager applicationAppWidgetManager =
-        (AppWidgetManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.APPWIDGET_SERVICE);
+        (AppWidgetManager) application.getSystemService(Context.APPWIDGET_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -689,23 +675,22 @@ public class ContextTest {
 
   @Test
   public void appWidgetManager_instance_retrievesSameAppWidgets() {
-    Context context = ApplicationProvider.getApplicationContext();
-    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
+    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(application);
 
-    ComponentName providerComponent = new ComponentName(context, TestAppWidgetProvider.class);
+    ComponentName providerComponent = new ComponentName(application, TestAppWidgetProvider.class);
     AppWidgetProviderInfo appWidgetProviderInfo = new AppWidgetProviderInfo();
     appWidgetProviderInfo.provider = providerComponent;
     appWidgetProviderInfo.updatePeriodMillis = 0;
     appWidgetProviderInfo.initialLayout = android.R.layout.simple_list_item_1;
 
-    AppWidgetHost appWidgetHost = new AppWidgetHost(context, APP_WIDGET_HOST_ID);
+    AppWidgetHost appWidgetHost = new AppWidgetHost(application, APP_WIDGET_HOST_ID);
 
     int appWidgetId = appWidgetHost.allocateAppWidgetId();
     appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId, providerComponent);
 
     appWidgetManager.updateAppWidget(
         appWidgetId,
-        new RemoteViews(context.getPackageName(), android.R.layout.simple_list_item_1));
+        new RemoteViews(application.getPackageName(), android.R.layout.simple_list_item_1));
 
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
@@ -726,8 +711,7 @@ public class ContextTest {
   @Test
   public void biometricManager_applicationInstance_isNotSameAsActivityInstance() {
     BiometricManager applicationBiometricManager =
-        (BiometricManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.BIOMETRIC_SERVICE);
+        (BiometricManager) application.getSystemService(Context.BIOMETRIC_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -756,8 +740,7 @@ public class ContextTest {
   @SdkSuppress(minSdkVersion = Build.VERSION_CODES.R)
   public void biometricManager_instance_retrievesSameAuthenticationResult_withAuthenticators() {
     BiometricManager applicationBiometricManager =
-        (BiometricManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.BIOMETRIC_SERVICE);
+        (BiometricManager) application.getSystemService(Context.BIOMETRIC_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -777,8 +760,7 @@ public class ContextTest {
   @Test
   public void bluetoothManager_applicationInstance_isNotSameAsActivityInstance() {
     BluetoothManager applicationBluetoothManager =
-        (BluetoothManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
+        (BluetoothManager) application.getSystemService(Context.BLUETOOTH_SERVICE);
 
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
@@ -808,8 +790,7 @@ public class ContextTest {
   @SdkSuppress(maxSdkVersion = Build.VERSION_CODES.Q)
   public void bluetoothManager_instance_retrievesSameAdapter() {
     BluetoothManager applicationBluetoothManager =
-        (BluetoothManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
+        (BluetoothManager) application.getSystemService(Context.BLUETOOTH_SERVICE);
 
     BluetoothAdapter applicationAdapter = applicationBluetoothManager.getAdapter();
 
@@ -829,8 +810,7 @@ public class ContextTest {
   @Test
   public void appOpsManager_applicationInstance_isNotSameAsActivityInstance() {
     AppOpsManager applicationAppOpsManager =
-        (AppOpsManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.APP_OPS_SERVICE);
+        (AppOpsManager) application.getSystemService(Context.APP_OPS_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -858,8 +838,7 @@ public class ContextTest {
   @Test
   public void appOpsManager_instance_retrievesSameOps() {
     AppOpsManager applicationAppOpsManager =
-        (AppOpsManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.APP_OPS_SERVICE);
+        (AppOpsManager) application.getSystemService(Context.APP_OPS_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -882,8 +861,7 @@ public class ContextTest {
   @Test
   public void euiccManager_applicationInstance_isNotSameAsActivityInstance() {
     EuiccManager applicationEuiccManager =
-        (EuiccManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.EUICC_SERVICE);
+        (EuiccManager) application.getSystemService(Context.EUICC_SERVICE);
     assumeTrue(applicationEuiccManager != null);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
@@ -912,8 +890,7 @@ public class ContextTest {
   @Test
   public void euiccManager_instance_getsEid() {
     EuiccManager applicationEuiccManager =
-        (EuiccManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.EUICC_SERVICE);
+        (EuiccManager) application.getSystemService(Context.EUICC_SERVICE);
     assumeTrue(applicationEuiccManager != null);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
@@ -932,9 +909,7 @@ public class ContextTest {
   @Test
   public void crossProfileApps_applicationInstance_isNotSameAsActivityInstance() {
     CrossProfileApps applicationCrossProfileApps =
-        (CrossProfileApps)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.CROSS_PROFILE_APPS_SERVICE);
+        (CrossProfileApps) application.getSystemService(Context.CROSS_PROFILE_APPS_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -962,9 +937,7 @@ public class ContextTest {
   @Test
   public void crossProfileApps_instance_retrievesSameTargetUserProfiles() {
     CrossProfileApps applicationCrossProfileApps =
-        (CrossProfileApps)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.CROSS_PROFILE_APPS_SERVICE);
+        (CrossProfileApps) application.getSystemService(Context.CROSS_PROFILE_APPS_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -984,9 +957,7 @@ public class ContextTest {
   @Test
   public void launcherApps_applicationInstance_isNotSameAsActivityInstance() {
     LauncherApps applicationLauncherApps =
-        (LauncherApps)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.LAUNCHER_APPS_SERVICE);
+        (LauncherApps) application.getSystemService(Context.LAUNCHER_APPS_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1014,9 +985,7 @@ public class ContextTest {
   @Test
   public void launcherApps_instance_retrievesSameProfiles() {
     LauncherApps applicationLauncherApps =
-        (LauncherApps)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.LAUNCHER_APPS_SERVICE);
+        (LauncherApps) application.getSystemService(Context.LAUNCHER_APPS_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1037,8 +1006,7 @@ public class ContextTest {
   @Test
   public void dropBoxManager_applicationInstance_isNotSameAsActivityInstance() {
     DropBoxManager applicationDropBoxManager =
-        (DropBoxManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.DROPBOX_SERVICE);
+        (DropBoxManager) application.getSystemService(Context.DROPBOX_SERVICE);
 
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
@@ -1067,8 +1035,7 @@ public class ContextTest {
   @Test
   public void dropBoxManager_instance_retrievesSameEntry_noPermissionRequired() {
     DropBoxManager applicationDropBoxManager =
-        (DropBoxManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.DROPBOX_SERVICE);
+        (DropBoxManager) application.getSystemService(Context.DROPBOX_SERVICE);
 
     String tag = "testTag";
     String data = "testData";
@@ -1091,9 +1058,7 @@ public class ContextTest {
   @Test
   public void mediaRouter_applicationInstance_isNotSameAsActivityInstance() {
     MediaRouter applicationMediaRouter =
-        (MediaRouter)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.MEDIA_ROUTER_SERVICE);
+        (MediaRouter) application.getSystemService(Context.MEDIA_ROUTER_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1121,9 +1086,7 @@ public class ContextTest {
   @Test
   public void mediaRouter_instance_retrievesSameDefaultRoute() {
     MediaRouter applicationMediaRouter =
-        (MediaRouter)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.MEDIA_ROUTER_SERVICE);
+        (MediaRouter) application.getSystemService(Context.MEDIA_ROUTER_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1142,9 +1105,7 @@ public class ContextTest {
   @Test
   public void captioningManager_applicationInstance_isNotSameAsActivityInstance() {
     CaptioningManager applicationCaptioningManager =
-        (CaptioningManager)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.CAPTIONING_SERVICE);
+        (CaptioningManager) application.getSystemService(Context.CAPTIONING_SERVICE);
 
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
@@ -1177,9 +1138,7 @@ public class ContextTest {
   @Test
   public void captioningManager_instance_retrievesSameValues() {
     CaptioningManager applicationCaptioningManager =
-        (CaptioningManager)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.CAPTIONING_SERVICE);
+        (CaptioningManager) application.getSystemService(Context.CAPTIONING_SERVICE);
 
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
@@ -1198,8 +1157,7 @@ public class ContextTest {
   @Test
   public void sensorManager_applicationInstance_isNotSameAsActivityInstance() {
     SensorManager applicationSensorManager =
-        (SensorManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.SENSOR_SERVICE);
+        (SensorManager) application.getSystemService(Context.SENSOR_SERVICE);
 
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
@@ -1231,8 +1189,7 @@ public class ContextTest {
   @Test
   public void sensorManager_instance_retrievesSameValues() {
     SensorManager applicationSensorManager =
-        (SensorManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.SENSOR_SERVICE);
+        (SensorManager) application.getSystemService(Context.SENSOR_SERVICE);
 
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
@@ -1262,8 +1219,7 @@ public class ContextTest {
   @Test
   public void roleManager_applicationInstance_isNotSameAsActivityInstance() {
     RoleManager applicationRoleManager =
-        (RoleManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.ROLE_SERVICE);
+        (RoleManager) application.getSystemService(Context.ROLE_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1291,8 +1247,7 @@ public class ContextTest {
   @Test
   public void roleManager_instance_retrievesSameRoles() {
     RoleManager applicationRoleManager =
-        (RoleManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.ROLE_SERVICE);
+        (RoleManager) application.getSystemService(Context.ROLE_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1309,8 +1264,7 @@ public class ContextTest {
 
   @Test
   public void sliceManager_applicationInstance_isNotSameAsActivityInstance() {
-    SliceManager applicationSliceManager =
-        ApplicationProvider.getApplicationContext().getSystemService(SliceManager.class);
+    SliceManager applicationSliceManager = application.getSystemService(SliceManager.class);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1336,8 +1290,7 @@ public class ContextTest {
   @Test
   public void usbManager_applicationInstance_isNotSameAsActivityInstance() {
     UsbManager applicationUsbManager =
-        (UsbManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.USB_SERVICE);
+        (UsbManager) application.getSystemService(Context.USB_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1365,8 +1318,7 @@ public class ContextTest {
   @Test
   public void usbManager_instance_retrievesSameUsbDevices() {
     UsbManager applicationUsbManager =
-        (UsbManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.USB_SERVICE);
+        (UsbManager) application.getSystemService(Context.USB_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1383,8 +1335,7 @@ public class ContextTest {
 
   @Test
   public void sliceManager_instance_retrievesSameSlice() {
-    SliceManager applicationSliceManager =
-        ApplicationProvider.getApplicationContext().getSystemService(SliceManager.class);
+    SliceManager applicationSliceManager = application.getSystemService(SliceManager.class);
     Uri testUri = Uri.parse("content://com.example.slice/test"); // Replace with a valid test URI
     Set<SliceSpec> testSpecs = new ArraySet<>();
 
@@ -1405,8 +1356,7 @@ public class ContextTest {
   @Test
   public void storageManager_applicationInstance_isNotSameAsActivityInstance() {
     StorageManager applicationStorageManager =
-        (StorageManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.STORAGE_SERVICE);
+        (StorageManager) application.getSystemService(Context.STORAGE_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1434,8 +1384,7 @@ public class ContextTest {
   @Test
   public void storageManager_instance_retrievesSameVolumes() {
     StorageManager applicationStorageManager =
-        (StorageManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.STORAGE_SERVICE);
+        (StorageManager) application.getSystemService(Context.STORAGE_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1453,9 +1402,7 @@ public class ContextTest {
   @Test
   public void usageStatsManager_applicationInstance_isNotSameAsActivityInstance() {
     UsageStatsManager applicationUsageStatsManager =
-        (UsageStatsManager)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.USAGE_STATS_SERVICE);
+        (UsageStatsManager) application.getSystemService(Context.USAGE_STATS_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1484,8 +1431,7 @@ public class ContextTest {
   @Test
   public void userManager_isUserAGoat_consistentAcrossContexts() {
     UserManager applicationUserManager =
-        (UserManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.USER_SERVICE);
+        (UserManager) application.getSystemService(Context.USER_SERVICE);
 
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
@@ -1504,9 +1450,7 @@ public class ContextTest {
   @Test
   public void subscriptionManager_applicationInstance_isNotSameAsActivityInstance() {
     SubscriptionManager applicationSubscriptionManager =
-        (SubscriptionManager)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);
+        (SubscriptionManager) application.getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1540,9 +1484,7 @@ public class ContextTest {
   public void subscriptionManager_instance_retrievesSameDefaultSubscriptionInfo() {
     int defaultSubscriptionId = SubscriptionManager.getDefaultSubscriptionId();
     SubscriptionManager applicationSubscriptionManager =
-        (SubscriptionManager)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);
+        (SubscriptionManager) application.getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1563,8 +1505,7 @@ public class ContextTest {
   @Test
   public void telephonyManager_applicationInstance_isNotSameAsActivityInstance() {
     TelephonyManager applicationTelephonyManager =
-        (TelephonyManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.TELEPHONY_SERVICE);
+        (TelephonyManager) application.getSystemService(Context.TELEPHONY_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1592,8 +1533,7 @@ public class ContextTest {
   @Test
   public void telephonyManager_instance_retrievesSamePhoneCount() {
     TelephonyManager applicationTelephonyManager =
-        (TelephonyManager)
-            ApplicationProvider.getApplicationContext().getSystemService(Context.TELEPHONY_SERVICE);
+        (TelephonyManager) application.getSystemService(Context.TELEPHONY_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1611,9 +1551,7 @@ public class ContextTest {
   @Test
   public void systemHealthManager_applicationInstance_isNotSameAsActivityInstance() {
     SystemHealthManager applicationSystemHealthManager =
-        (SystemHealthManager)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.SYSTEM_HEALTH_SERVICE);
+        (SystemHealthManager) application.getSystemService(Context.SYSTEM_HEALTH_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1643,9 +1581,7 @@ public class ContextTest {
   @Test
   public void systemHealthManager_instance_retrievesSameUidSnapshot() {
     SystemHealthManager applicationSystemHealthManager =
-        (SystemHealthManager)
-            ApplicationProvider.getApplicationContext()
-                .getSystemService(Context.SYSTEM_HEALTH_SERVICE);
+        (SystemHealthManager) application.getSystemService(Context.SYSTEM_HEALTH_SERVICE);
     try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
       scenario.onActivity(
           activity -> {
@@ -1669,6 +1605,69 @@ public class ContextTest {
     }
   }
 
+  @SuppressLint("UnspecifiedRegisterReceiverFlag")
+  @Test
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+  public void
+      registerReceiver_withoutAnyExportedFlagsAndTargetSdkGreaterThan33_throwsSecurityException() {
+    IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
+
+    assertThrows(
+        SecurityException.class,
+        () -> application.registerReceiver(new TestBroadcastReceiver(), filter));
+  }
+
+  @Test
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+  public void registerReceiver_withReceiverExportedFlagAndTargetSdkGreaterThan33_succeed() {
+    IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
+    application.registerReceiver(new TestBroadcastReceiver(), filter, Context.RECEIVER_EXPORTED);
+  }
+
+  @Test
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+  public void registerReceiver_withReceiverNotExportedFlagAndTargetSdkGreaterThan33_succeed() {
+    IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
+    application.registerReceiver(
+        new TestBroadcastReceiver(), filter, Context.RECEIVER_NOT_EXPORTED);
+  }
+
+  @Test
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+  public void
+      registerReceiver_withBothExportedFlagsAndTargetSdkGreaterThan33_throwsIllegalArgumentException() {
+    IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
+    assertThrows(
+        IllegalArgumentException.class,
+        () ->
+            application.registerReceiver(
+                new TestBroadcastReceiver(),
+                filter,
+                Context.RECEIVER_EXPORTED | Context.RECEIVER_NOT_EXPORTED));
+  }
+
+  @SuppressLint("UnspecifiedRegisterReceiverFlag")
+  @Test
+  @SdkSuppress(maxSdkVersion = Build.VERSION_CODES.TIRAMISU)
+  public void
+      registerReceiver_withoutAnyExportedFlagsAndTargetLessThan34_doesntThrowSecurityException() {
+    IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
+    application.registerReceiver(new TestBroadcastReceiver(), filter);
+  }
+
+  private static class TestBroadcastReceiver extends BroadcastReceiver {
+    public Context context;
+    public Intent intent;
+    public boolean isSticky;
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+      this.context = context;
+      this.intent = intent;
+      this.isSticky = isInitialStickyBroadcast();
+    }
+  }
+
   private static class TestAppWidgetProvider extends AppWidgetProvider {
     @Override
     public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/content/res/AssetManagerTest.java b/integration_tests/ctesque/src/sharedTest/java/android/content/res/AssetManagerTest.java
index d0b4d7094..521381b37 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/content/res/AssetManagerTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/content/res/AssetManagerTest.java
@@ -2,6 +2,7 @@ package android.content.res;
 
 import static androidx.test.InstrumentationRegistry.getTargetContext;
 import static com.google.common.truth.Truth.assertThat;
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 import android.content.Context;
 import android.os.ParcelFileDescriptor;
@@ -13,7 +14,6 @@ import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
-import java.nio.charset.Charset;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,8 +24,6 @@ public class AssetManagerTest {
 
   private AssetManager assetManager;
 
-  private static final Charset UTF_8 = Charset.forName("UTF-8");
-
   @Before
   public void setup() throws Exception {
     Context context = getTargetContext();
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/content/res/ResourcesTest.java b/integration_tests/ctesque/src/sharedTest/java/android/content/res/ResourcesTest.java
index d987e962e..5bc2edd6c 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/content/res/ResourcesTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/content/res/ResourcesTest.java
@@ -20,7 +20,6 @@ import static android.util.TypedValue.applyDimension;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeFalse;
 import static org.robolectric.testapp.R.color.test_ARGB8;
 import static org.robolectric.testapp.R.color.test_RGB8;
 
@@ -46,7 +45,6 @@ import androidx.test.filters.SdkSuppress;
 import com.google.common.collect.Range;
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.reflect.Method;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -259,13 +257,13 @@ public class ResourcesTest {
 
   @Test
   public void getBoolean() {
-    assertThat(resources.getBoolean(R.bool.false_bool_value)).isEqualTo(false);
-    assertThat(resources.getBoolean(R.bool.true_as_item)).isEqualTo(true);
+    assertThat(resources.getBoolean(R.bool.false_bool_value)).isFalse();
+    assertThat(resources.getBoolean(R.bool.true_as_item)).isTrue();
   }
 
   @Test
   public void getBoolean_withReference() {
-    assertThat(resources.getBoolean(R.bool.reference_to_true)).isEqualTo(true);
+    assertThat(resources.getBoolean(R.bool.reference_to_true)).isTrue();
   }
 
   @Test
@@ -332,7 +330,7 @@ public class ResourcesTest {
 
   @Test
   public void getDimension_withReference() {
-    assertThat(resources.getBoolean(R.bool.reference_to_true)).isEqualTo(true);
+    assertThat(resources.getBoolean(R.bool.reference_to_true)).isTrue();
   }
 
   @Test
@@ -354,9 +352,6 @@ public class ResourcesTest {
 
   @Test
   public void getQuantityText() {
-    // Feature not supported in legacy (raw) resource mode.
-    assumeFalse(isRobolectricLegacyMode());
-
     assertThat(resources.getQuantityText(R.plurals.beer, 1)).isEqualTo("a beer");
     assertThat(resources.getQuantityText(R.plurals.beer, 2)).isEqualTo("some beers");
     assertThat(resources.getQuantityText(R.plurals.beer, 3)).isEqualTo("some beers");
@@ -1125,9 +1120,6 @@ public class ResourcesTest {
   @SdkSuppress(minSdkVersion = O)
   @Config(minSdk = O)
   public void getFont() {
-    // Feature not supported in legacy (raw) resource mode.
-    assumeFalse(isRobolectricLegacyMode());
-
     Typeface typeface = resources.getFont(R.font.vt323_regular);
     assertThat(typeface).isNotNull();
   }
@@ -1136,9 +1128,6 @@ public class ResourcesTest {
   @SdkSuppress(minSdkVersion = O)
   @Config(minSdk = O)
   public void getFontFamily() {
-    // Feature not supported in legacy (raw) resource mode.
-    assumeFalse(isRobolectricLegacyMode());
-
     Typeface typeface = resources.getFont(R.font.vt323);
     assertThat(typeface).isNotNull();
   }
@@ -1147,9 +1136,6 @@ public class ResourcesTest {
   @SdkSuppress(minSdkVersion = O)
   @Config(minSdk = O)
   public void getFontFamily_downloadable() {
-    // Feature not supported in legacy (raw) resource mode.
-    assumeFalse(isRobolectricLegacyMode());
-
     Typeface typeface = resources.getFont(R.font.downloadable);
     assertThat(typeface).isNotNull();
   }
@@ -1195,15 +1181,4 @@ public class ResourcesTest {
       super(res.getAssets(), res.getDisplayMetrics(), res.getConfiguration());
     }
   }
-
-  private static boolean isRobolectricLegacyMode() {
-    try {
-      Class<?> runtimeEnvironmentClass = Class.forName("org.robolectric.RuntimeEnvironment");
-      Method useLegacyResourcesMethod =
-          runtimeEnvironmentClass.getDeclaredMethod("useLegacyResources");
-      return (boolean) useLegacyResourcesMethod.invoke(null);
-    } catch (Exception e) {
-      return false;
-    }
-  }
 }
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/database/SQLiteDatabaseTest.java b/integration_tests/ctesque/src/sharedTest/java/android/database/SQLiteDatabaseTest.java
index a2ff08f65..b8af94de9 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/database/SQLiteDatabaseTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/database/SQLiteDatabaseTest.java
@@ -55,7 +55,7 @@ public class SQLiteDatabaseTest {
   }
 
   /**
-   * If running on Robolectric, this test only works in RobolectriSQLite native mode. Attempt to
+   * If running on Robolectric, this test only works in RobolectricSQLite native mode. Attempt to
    * figure this out
    */
   private boolean isNativeSqliteMode() throws IllegalAccessException, NoSuchFieldException {
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/os/PersistableBundleTest.java b/integration_tests/ctesque/src/sharedTest/java/android/os/PersistableBundleTest.java
new file mode 100644
index 000000000..1b66a55aa
--- /dev/null
+++ b/integration_tests/ctesque/src/sharedTest/java/android/os/PersistableBundleTest.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.os;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SdkSuppress;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+/**
+ * CTS tests for {@link PersistableBundle}.
+ *
+ * <p>Copied from <a
+ * href="https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/os/src/android/os/cts/PersistableBundleTest.java">PersistableBundleTest</a>
+ */
+@RunWith(AndroidJUnit4.class)
+public class PersistableBundleTest {
+  private static final double DELTA_DOUBLE = 0.0d;
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.R)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.R)
+  public void testWriteToStreamAndReadFromStream() throws IOException {
+    PersistableBundle bundle = new PersistableBundle();
+    bundle.putBoolean("boolean", true);
+    bundle.putBooleanArray("boolean_array", new boolean[] {false});
+    bundle.putDouble("double", 1.23);
+    bundle.putDoubleArray("double_array", new double[] {2.34, 3.45});
+    bundle.putInt("int", 1);
+    bundle.putIntArray("int_array", new int[] {2});
+    bundle.putLong("long", 12345L);
+    bundle.putLongArray("long_array", new long[] {1234567L, 2345678L});
+    bundle.putString("string", "abc123");
+    bundle.putStringArray("string_array", new String[] {"xyz789"});
+    PersistableBundle nestedBundle = new PersistableBundle();
+    nestedBundle.putBooleanArray("boolean_array", new boolean[] {});
+    nestedBundle.putInt("int", 9);
+    nestedBundle.putLongArray("long_array", new long[] {654321L});
+    bundle.putPersistableBundle("bundle", nestedBundle);
+
+    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+    bundle.writeToStream(outputStream);
+    ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
+    PersistableBundle restoredBundle = PersistableBundle.readFromStream(inputStream);
+
+    assertEquals(bundle.size(), restoredBundle.size());
+    assertEquals(true, restoredBundle.getBoolean("boolean"));
+    assertTrue(
+        Arrays.equals(new boolean[] {false}, restoredBundle.getBooleanArray("boolean_array")));
+    assertEquals(1.23, restoredBundle.getDouble("double"), DELTA_DOUBLE);
+    assertTrue(
+        Arrays.equals(new double[] {2.34, 3.45}, restoredBundle.getDoubleArray("double_array")));
+    assertEquals(1, restoredBundle.getInt("int"));
+    assertTrue(Arrays.equals(new int[] {2}, restoredBundle.getIntArray("int_array")));
+    assertEquals(12345L, restoredBundle.getLong("long"));
+    assertTrue(
+        Arrays.equals(new long[] {1234567L, 2345678L}, restoredBundle.getLongArray("long_array")));
+    assertEquals("abc123", restoredBundle.getString("string"));
+    assertTrue(
+        Arrays.equals(new String[] {"xyz789"}, restoredBundle.getStringArray("string_array")));
+    PersistableBundle restoredNestedBundle = restoredBundle.getPersistableBundle("bundle");
+    assertEquals(nestedBundle.size(), restoredNestedBundle.size());
+    assertTrue(
+        Arrays.equals(new boolean[] {}, restoredNestedBundle.getBooleanArray("boolean_array")));
+    assertEquals(9, restoredNestedBundle.getInt("int"));
+    assertTrue(
+        Arrays.equals(new long[] {654321L}, restoredNestedBundle.getLongArray("long_array")));
+  }
+}
diff --git a/integration_tests/mockito-experimental/build.gradle.kts b/integration_tests/mockito-experimental/build.gradle.kts
index 76e7c4e41..c105728d9 100644
--- a/integration_tests/mockito-experimental/build.gradle.kts
+++ b/integration_tests/mockito-experimental/build.gradle.kts
@@ -8,5 +8,5 @@ dependencies {
   testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
   testImplementation(libs.junit4)
   testImplementation(libs.truth)
-  testImplementation(libs.mockito.inline)
+  testImplementation(libs.mockito)
 }
diff --git a/integration_tests/mockito-kotlin/build.gradle.kts b/integration_tests/mockito-kotlin/build.gradle.kts
index ef5c4ec6e..537859753 100644
--- a/integration_tests/mockito-kotlin/build.gradle.kts
+++ b/integration_tests/mockito-kotlin/build.gradle.kts
@@ -24,4 +24,5 @@ dependencies {
   testImplementation(libs.truth)
   testImplementation(libs.kotlin.stdlib)
   testImplementation(libs.mockito)
+  testImplementation(libs.mockito.subclass)
 }
diff --git a/integration_tests/mockito/build.gradle.kts b/integration_tests/mockito/build.gradle.kts
index c105728d9..c8e952faf 100644
--- a/integration_tests/mockito/build.gradle.kts
+++ b/integration_tests/mockito/build.gradle.kts
@@ -9,4 +9,5 @@ dependencies {
   testImplementation(libs.junit4)
   testImplementation(libs.truth)
   testImplementation(libs.mockito)
+  testImplementation(libs.mockito.subclass)
 }
diff --git a/integration_tests/nativegraphics/build.gradle.kts b/integration_tests/nativegraphics/build.gradle.kts
index ec7fb6e31..084b3ce02 100644
--- a/integration_tests/nativegraphics/build.gradle.kts
+++ b/integration_tests/nativegraphics/build.gradle.kts
@@ -32,5 +32,6 @@ dependencies {
   testImplementation(libs.truth)
   testImplementation(libs.junit4)
   testImplementation(libs.mockito)
+  testImplementation(libs.mockito.subclass)
   testImplementation(libs.guava.testlib)
 }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedVectorDrawableTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedVectorDrawableTest.java
index 87d439ba5..42cbfa520 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedVectorDrawableTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedVectorDrawableTest.java
@@ -1,9 +1,9 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.O;
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertTrue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 import android.content.res.Resources;
 import android.graphics.Bitmap;
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java
index fb01a61ca..aedddab6a 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java
@@ -15,10 +15,12 @@
  */
 package org.robolectric.shadows;
 
+import static android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -29,16 +31,22 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import android.graphics.ColorSpace;
+import android.hardware.DataSpace;
 import java.util.Arrays;
-import java.util.Objects;
 import java.util.function.DoubleUnaryOperator;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
-import org.robolectric.versioning.AndroidVersions.V;
 
+// Copied from:
+// https://cs.android.com/android/platform/superproject/+/android15-release:cts/tests/tests/graphics/src/android/graphics/cts/ColorSpaceTest.java
+// With the following changes:
+// - Replaced `@Test(expected)` with `assertThrows`.
+// - Removed parameterized tests.
+// - Removed OkLab checks.
+// - Added SDK checks.
 @RunWith(RobolectricTestRunner.class)
 @Config(minSdk = O)
 public class ShadowNativeColorSpaceTest {
@@ -62,8 +70,10 @@ public class ShadowNativeColorSpaceTest {
     0.1430804f, 0.0606169f, 0.7141733f
   };
 
-  private static final float[] rGBPRIMARIESXyY = {0.640f, 0.330f, 0.300f, 0.600f, 0.150f, 0.060f};
-  private static final float[] sRGBWHITEPOINTXyY = {0.3127f, 0.3290f};
+  private static final float[] SRGB_PRIMARIES_xyY = {
+    0.640f, 0.330f, 0.300f, 0.600f, 0.150f, 0.060f
+  };
+  private static final float[] SRGB_WHITE_POINT_xyY = {0.3127f, 0.3290f};
 
   private static final float[] SRGB_PRIMARIES_XYZ = {
     1.939394f, 1.000000f, 0.090909f,
@@ -71,26 +81,18 @@ public class ShadowNativeColorSpaceTest {
     2.500000f, 1.000000f, 13.166667f
   };
   private static final float[] SRGB_WHITE_POINT_XYZ = {0.950456f, 1.000f, 1.089058f};
-
-  private static final DoubleUnaryOperator identity = DoubleUnaryOperator.identity();
+  private static final float[] ILLUMINANT_D50_XYZ = {0.964212f, 1.0f, 0.825188f};
+  private static final DoubleUnaryOperator sIdentity = DoubleUnaryOperator.identity();
 
   @Test
   public void testNamedColorSpaces() {
-    for (ColorSpace.Named named : ColorSpace.Named.values()) {
-      // OK_LAB is behind a feature flag that is not yet enabled by default on V.
-      if (Objects.equals(named.toString(), "OK_LAB")
-          && RuntimeEnvironment.getApiLevel() <= V.SDK_INT) {
-        continue;
-      }
-      // DISPLAY_BT2020 is behind a feature flag that is not yet enabled by default.
-      if (Objects.equals(named.toString(), "DISPLAY_BT2020")) {
-        continue;
-      }
-
+    ColorSpace.Named[] values = ColorSpace.Named.values();
+    for (int i = 0; i < values.length - 1; i++) {
+      ColorSpace.Named named = values[i];
       ColorSpace colorSpace = ColorSpace.get(named);
       assertNotNull(colorSpace.getName());
       assertNotNull(colorSpace);
-      assertEquals(named + " ordinal does not match", named.ordinal(), colorSpace.getId());
+      assertEquals(named.ordinal(), colorSpace.getId());
       assertTrue(colorSpace.getComponentCount() >= 1);
       assertTrue(colorSpace.getComponentCount() <= 4);
     }
@@ -100,20 +102,21 @@ public class ShadowNativeColorSpaceTest {
   public void testNullName() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> new ColorSpace.Rgb(null, new float[6], new float[2], identity, identity, 0.0f, 1.0f));
+        () ->
+            new ColorSpace.Rgb(null, new float[6], new float[2], sIdentity, sIdentity, 0.0f, 1.0f));
   }
 
   @Test
   public void testEmptyName() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> new ColorSpace.Rgb("", new float[6], new float[2], identity, identity, 0.0f, 1.0f));
+        () -> new ColorSpace.Rgb("", new float[6], new float[2], sIdentity, sIdentity, 0.0f, 1.0f));
   }
 
   @Test
   public void testName() {
     ColorSpace.Rgb cs =
-        new ColorSpace.Rgb("Test", new float[6], new float[2], identity, identity, 0.0f, 1.0f);
+        new ColorSpace.Rgb("Test", new float[6], new float[2], sIdentity, sIdentity, 0.0f, 1.0f);
     assertEquals("Test", cs.getName());
   }
 
@@ -122,7 +125,8 @@ public class ShadowNativeColorSpaceTest {
     assertThrows(
         IllegalArgumentException.class,
         () ->
-            new ColorSpace.Rgb("Test", new float[7], new float[2], identity, identity, 0.0f, 1.0f));
+            new ColorSpace.Rgb(
+                "Test", new float[7], new float[2], sIdentity, sIdentity, 0.0f, 1.0f));
   }
 
   @Test
@@ -130,21 +134,22 @@ public class ShadowNativeColorSpaceTest {
     assertThrows(
         IllegalArgumentException.class,
         () ->
-            new ColorSpace.Rgb("Test", new float[6], new float[1], identity, identity, 0.0f, 1.0f));
+            new ColorSpace.Rgb(
+                "Test", new float[6], new float[1], sIdentity, sIdentity, 0.0f, 1.0f));
   }
 
   @Test
   public void testNullOETF() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> new ColorSpace.Rgb("Test", new float[6], new float[2], null, identity, 0.0f, 1.0f));
+        () -> new ColorSpace.Rgb("Test", new float[6], new float[2], null, sIdentity, 0.0f, 1.0f));
   }
 
   @Test
   public void testOETF() {
     DoubleUnaryOperator op = Math::sqrt;
     ColorSpace.Rgb cs =
-        new ColorSpace.Rgb("Test", new float[6], new float[2], op, identity, 0.0f, 1.0f);
+        new ColorSpace.Rgb("Test", new float[6], new float[2], op, sIdentity, 0.0f, 1.0f);
     assertEquals(0.5, cs.getOetf().applyAsDouble(0.25), 1e-5);
   }
 
@@ -152,14 +157,14 @@ public class ShadowNativeColorSpaceTest {
   public void testNullEOTF() {
     assertThrows(
         IllegalArgumentException.class,
-        () -> new ColorSpace.Rgb("Test", new float[6], new float[2], identity, null, 0.0f, 1.0f));
+        () -> new ColorSpace.Rgb("Test", new float[6], new float[2], sIdentity, null, 0.0f, 1.0f));
   }
 
   @Test
   public void testEOTF() {
     DoubleUnaryOperator op = x -> x * x;
     ColorSpace.Rgb cs =
-        new ColorSpace.Rgb("Test", new float[6], new float[2], identity, op, 0.0f, 1.0f);
+        new ColorSpace.Rgb("Test", new float[6], new float[2], sIdentity, op, 0.0f, 1.0f);
     assertEquals(0.0625, cs.getEotf().applyAsDouble(0.25), 1e-5);
   }
 
@@ -168,7 +173,8 @@ public class ShadowNativeColorSpaceTest {
     assertThrows(
         IllegalArgumentException.class,
         () ->
-            new ColorSpace.Rgb("Test", new float[6], new float[2], identity, identity, 2.0f, 1.0f));
+            new ColorSpace.Rgb(
+                "Test", new float[6], new float[2], sIdentity, sIdentity, 2.0f, 1.0f));
   }
 
   @Test
@@ -187,9 +193,9 @@ public class ShadowNativeColorSpaceTest {
     m2 = cs.getMaxValue(1);
     m3 = cs.getMaxValue(2);
 
-    assertEquals(1.0f, m1, 0);
-    assertEquals(1.0f, m2, 0);
-    assertEquals(1.0f, m3, 0);
+    assertEquals(1.0f, m1, 1e-9f);
+    assertEquals(1.0f, m2, 1e-9f);
+    assertEquals(1.0f, m3, 1e-9f);
 
     cs = ColorSpace.get(ColorSpace.Named.CIE_LAB);
 
@@ -198,16 +204,16 @@ public class ShadowNativeColorSpaceTest {
     m3 = cs.getMinValue(2);
 
     assertEquals(0.0f, m1, 1e-9f);
-    assertEquals(-128.0f, m2, 0);
-    assertEquals(-128.0f, m3, 0);
+    assertEquals(-128.0f, m2, 1e-9f);
+    assertEquals(-128.0f, m3, 1e-9f);
 
     m1 = cs.getMaxValue(0);
     m2 = cs.getMaxValue(1);
     m3 = cs.getMaxValue(2);
 
-    assertEquals(100.0f, m1, 0);
-    assertEquals(128.0f, m2, 0);
-    assertEquals(128.0f, m3, 0);
+    assertEquals(100.0f, m1, 1e-9f);
+    assertEquals(128.0f, m2, 1e-9f);
+    assertEquals(128.0f, m3, 1e-9f);
 
     cs = ColorSpace.get(ColorSpace.Named.CIE_XYZ);
 
@@ -215,22 +221,22 @@ public class ShadowNativeColorSpaceTest {
     m2 = cs.getMinValue(1);
     m3 = cs.getMinValue(2);
 
-    assertEquals(-2.0f, m1, 0);
-    assertEquals(-2.0f, m2, 0);
-    assertEquals(-2.0f, m3, 0);
+    assertEquals(-2.0f, m1, 1e-9f);
+    assertEquals(-2.0f, m2, 1e-9f);
+    assertEquals(-2.0f, m3, 1e-9f);
 
     m1 = cs.getMaxValue(0);
     m2 = cs.getMaxValue(1);
     m3 = cs.getMaxValue(2);
 
-    assertEquals(2.0f, m1, 0);
-    assertEquals(2.0f, m2, 0);
-    assertEquals(2.0f, m3, 0);
+    assertEquals(2.0f, m1, 1e-9f);
+    assertEquals(2.0f, m2, 1e-9f);
+    assertEquals(2.0f, m3, 1e-9f);
   }
 
   @Test
   public void testMat3x3() {
-    ColorSpace.Rgb cs = new ColorSpace.Rgb("Test", SRGB_TO_XYZ, identity, identity);
+    ColorSpace.Rgb cs = new ColorSpace.Rgb("Test", SRGB_TO_XYZ, sIdentity, sIdentity);
 
     float[] rgbToXYZ = cs.getTransform();
     for (int i = 0; i < 9; i++) {
@@ -240,7 +246,7 @@ public class ShadowNativeColorSpaceTest {
 
   @Test
   public void testMat3x3Inverse() {
-    ColorSpace.Rgb cs = new ColorSpace.Rgb("Test", SRGB_TO_XYZ, identity, identity);
+    ColorSpace.Rgb cs = new ColorSpace.Rgb("Test", SRGB_TO_XYZ, sIdentity, sIdentity);
 
     float[] xyzToRGB = cs.getInverseTransform();
     for (int i = 0; i < 9; i++) {
@@ -250,39 +256,39 @@ public class ShadowNativeColorSpaceTest {
 
   @Test
   public void testMat3x3Primaries() {
-    ColorSpace.Rgb cs = new ColorSpace.Rgb("Test", SRGB_TO_XYZ, identity, identity);
+    ColorSpace.Rgb cs = new ColorSpace.Rgb("Test", SRGB_TO_XYZ, sIdentity, sIdentity);
 
     float[] primaries = cs.getPrimaries();
 
     assertNotNull(primaries);
     assertEquals(6, primaries.length);
 
-    assertEquals(rGBPRIMARIESXyY[0], primaries[0], 1e-5f);
-    assertEquals(rGBPRIMARIESXyY[1], primaries[1], 1e-5f);
-    assertEquals(rGBPRIMARIESXyY[2], primaries[2], 1e-5f);
-    assertEquals(rGBPRIMARIESXyY[3], primaries[3], 1e-5f);
-    assertEquals(rGBPRIMARIESXyY[4], primaries[4], 1e-5f);
-    assertEquals(rGBPRIMARIESXyY[5], primaries[5], 1e-5f);
+    assertEquals(SRGB_PRIMARIES_xyY[0], primaries[0], 1e-5f);
+    assertEquals(SRGB_PRIMARIES_xyY[1], primaries[1], 1e-5f);
+    assertEquals(SRGB_PRIMARIES_xyY[2], primaries[2], 1e-5f);
+    assertEquals(SRGB_PRIMARIES_xyY[3], primaries[3], 1e-5f);
+    assertEquals(SRGB_PRIMARIES_xyY[4], primaries[4], 1e-5f);
+    assertEquals(SRGB_PRIMARIES_xyY[5], primaries[5], 1e-5f);
   }
 
   @Test
   public void testMat3x3WhitePoint() {
-    ColorSpace.Rgb cs = new ColorSpace.Rgb("Test", SRGB_TO_XYZ, identity, identity);
+    ColorSpace.Rgb cs = new ColorSpace.Rgb("Test", SRGB_TO_XYZ, sIdentity, sIdentity);
 
     float[] whitePoint = cs.getWhitePoint();
 
     assertNotNull(whitePoint);
     assertEquals(2, whitePoint.length);
 
-    assertEquals(sRGBWHITEPOINTXyY[0], whitePoint[0], 1e-5f);
-    assertEquals(sRGBWHITEPOINTXyY[1], whitePoint[1], 1e-5f);
+    assertEquals(SRGB_WHITE_POINT_xyY[0], whitePoint[0], 1e-5f);
+    assertEquals(SRGB_WHITE_POINT_xyY[1], whitePoint[1], 1e-5f);
   }
 
   @Test
   public void testXYZFromPrimaries_xyY() {
     ColorSpace.Rgb cs =
         new ColorSpace.Rgb(
-            "Test", rGBPRIMARIESXyY, sRGBWHITEPOINTXyY, identity, identity, 0.0f, 1.0f);
+            "Test", SRGB_PRIMARIES_xyY, SRGB_WHITE_POINT_xyY, sIdentity, sIdentity, 0.0f, 1.0f);
 
     float[] rgbToXYZ = cs.getTransform();
     for (int i = 0; i < 9; i++) {
@@ -296,10 +302,10 @@ public class ShadowNativeColorSpaceTest {
   }
 
   @Test
-  public void testXYZFromPrimaries_xYZ() {
+  public void testXYZFromPrimaries_XYZ() {
     ColorSpace.Rgb cs =
         new ColorSpace.Rgb(
-            "Test", SRGB_PRIMARIES_XYZ, SRGB_WHITE_POINT_XYZ, identity, identity, 0.0f, 1.0f);
+            "Test", SRGB_PRIMARIES_XYZ, SRGB_WHITE_POINT_XYZ, sIdentity, sIdentity, 0.0f, 1.0f);
 
     float[] primaries = cs.getPrimaries();
 
@@ -307,12 +313,12 @@ public class ShadowNativeColorSpaceTest {
     assertEquals(6, primaries.length);
 
     // SRGB_PRIMARIES_xyY only has 1e-3 of precision, match it
-    assertEquals(rGBPRIMARIESXyY[0], primaries[0], 1e-3f);
-    assertEquals(rGBPRIMARIESXyY[1], primaries[1], 1e-3f);
-    assertEquals(rGBPRIMARIESXyY[2], primaries[2], 1e-3f);
-    assertEquals(rGBPRIMARIESXyY[3], primaries[3], 1e-3f);
-    assertEquals(rGBPRIMARIESXyY[4], primaries[4], 1e-3f);
-    assertEquals(rGBPRIMARIESXyY[5], primaries[5], 1e-3f);
+    assertEquals(SRGB_PRIMARIES_xyY[0], primaries[0], 1e-3f);
+    assertEquals(SRGB_PRIMARIES_xyY[1], primaries[1], 1e-3f);
+    assertEquals(SRGB_PRIMARIES_xyY[2], primaries[2], 1e-3f);
+    assertEquals(SRGB_PRIMARIES_xyY[3], primaries[3], 1e-3f);
+    assertEquals(SRGB_PRIMARIES_xyY[4], primaries[4], 1e-3f);
+    assertEquals(SRGB_PRIMARIES_xyY[5], primaries[5], 1e-3f);
 
     float[] whitePoint = cs.getWhitePoint();
 
@@ -320,8 +326,8 @@ public class ShadowNativeColorSpaceTest {
     assertEquals(2, whitePoint.length);
 
     // SRGB_WHITE_POINT_xyY only has 1e-3 of precision, match it
-    assertEquals(sRGBWHITEPOINTXyY[0], whitePoint[0], 1e-3f);
-    assertEquals(sRGBWHITEPOINTXyY[1], whitePoint[1], 1e-3f);
+    assertEquals(SRGB_WHITE_POINT_xyY[0], whitePoint[0], 1e-3f);
+    assertEquals(SRGB_WHITE_POINT_xyY[1], whitePoint[1], 1e-3f);
 
     float[] rgbToXYZ = cs.getTransform();
     for (int i = 0; i < 9; i++) {
@@ -348,22 +354,17 @@ public class ShadowNativeColorSpaceTest {
   @Test
   @Config(minSdk = Q)
   public void testIsSRGB() {
-    for (ColorSpace.Named named : ColorSpace.Named.values()) {
-      // OK_LAB is behind a feature flag that is not yet enabled by default on V.
-      if (Objects.equals(named.toString(), "OK_LAB")
-          && RuntimeEnvironment.getApiLevel() <= V.SDK_INT) {
-        continue;
-      }
-      // DISPLAY_BT2020 is behind a feature flag that is not yet enabled by default.
-      if (Objects.equals(named.toString(), "DISPLAY_BT2020")) {
-        continue;
-      }
-
-      ColorSpace colorSpace = ColorSpace.get(named);
-      if (named == ColorSpace.Named.SRGB) {
+    for (ColorSpace.Named e : ColorSpace.Named.values()) {
+      ColorSpace colorSpace = ColorSpace.get(e);
+      // ColorSpace.get is guaranteed to return non-null. So if this is queried with
+      // a ColorSpace that is flagged, this falls back to return SRGB as a default.
+      // The values method of an enum will always return the full set of enum values
+      // regardless if they are flagged out or not
+      boolean isSrgbFallback = colorSpace.getId() == 0;
+      if (e == ColorSpace.Named.SRGB || isSrgbFallback) {
         assertTrue(colorSpace.isSrgb());
       } else {
-        assertFalse("Incorrectly treating " + colorSpace + " as SRGB!", colorSpace.isSrgb());
+        assertFalse("Incorrectly treating " + e + " as SRGB!", colorSpace.isSrgb());
       }
     }
 
@@ -842,18 +843,34 @@ public class ShadowNativeColorSpaceTest {
             });
   }
 
-  // TODO: update test with latest
-  // cts/tests/tests/graphics/src/android/graphics/cts/ColorSpaceTest.java from U
+  // This test is flaky about 50% of the time on APIs 35 and 36. This is because the match function
+  // can match multiple color spaces with the same parameters and the list it checks from is not
+  // deterministic (due to the use of a hashmap). This will be fixed in the most recent APIs, but
+  // will remain flaky in 35-36.
   @Test
-  @Config(maxSdk = TIRAMISU)
+  @Config(maxSdk = UPSIDE_DOWN_CAKE)
   public void testMatch() {
+    doTestMatch();
+  }
+
+  @Test
+  @Config(minSdk = CUR_DEVELOPMENT)
+  public void testMatch_mainPlus() {
+    doTestMatch();
+  }
+
+  private void doTestMatch() {
     for (ColorSpace.Named named : ColorSpace.Named.values()) {
       ColorSpace cs = ColorSpace.get(named);
       if (cs.getModel() == ColorSpace.Model.RGB) {
         ColorSpace.Rgb rgb = (ColorSpace.Rgb) cs;
-        // match() cannot match extended sRGB
-        if (!rgb.equals(ColorSpace.get(ColorSpace.Named.EXTENDED_SRGB))
-            && !rgb.equals(ColorSpace.get(ColorSpace.Named.LINEAR_EXTENDED_SRGB))) {
+        // match() cannot match extended sRGB, BT2020_HLG, BT2020_PQ
+        if (rgb != ColorSpace.get(ColorSpace.Named.EXTENDED_SRGB)
+            && rgb != ColorSpace.get(ColorSpace.Named.LINEAR_EXTENDED_SRGB)
+            && (RuntimeEnvironment.getApiLevel() >= UPSIDE_DOWN_CAKE
+                && rgb != ColorSpace.get(ColorSpace.Named.BT2020_HLG))
+            && (RuntimeEnvironment.getApiLevel() >= TIRAMISU
+                && rgb != ColorSpace.get(ColorSpace.Named.BT2020_PQ))) {
 
           // match() uses CIE XYZ D50
           rgb = (ColorSpace.Rgb) ColorSpace.adapt(rgb, ColorSpace.ILLUMINANT_D50);
@@ -881,7 +898,7 @@ public class ShadowNativeColorSpaceTest {
     }
   }
 
-  private static final float[] identityMatrix =
+  private static final float[] sIdentityMatrix =
       new float[] {
         1.0f, 0.0f, 0.0f,
         0.0f, 1.0f, 0.0f,
@@ -909,13 +926,34 @@ public class ShadowNativeColorSpaceTest {
           assertNotNull(result);
           assertEquals(9, result.length);
           if (Arrays.equals(srcWhitePoint, dstWhitePoint)) {
-            assertArrayEquals(identityMatrix, result, 0f);
+            assertArrayEquals(sIdentityMatrix, result, 0f);
           }
         }
       }
     }
   }
 
+  @Test
+  @Config(minSdk = TIRAMISU)
+  public void getDataSpaceFromColorSpace() {
+    ColorSpace cs = ColorSpace.get(ColorSpace.Named.BT709);
+    assertNotNull(cs);
+    assertEquals(DataSpace.DATASPACE_BT709, cs.getDataSpace());
+
+    cs = ColorSpace.get(ColorSpace.Named.ACES);
+    assertEquals(DataSpace.DATASPACE_UNKNOWN, cs.getDataSpace());
+  }
+
+  @Test
+  @Config(minSdk = TIRAMISU)
+  public void getColorSpaceFromDataSpace() {
+    ColorSpace cs = ColorSpace.getFromDataSpace(DataSpace.DATASPACE_SRGB);
+    assertNotNull(cs);
+    assertEquals(DataSpace.DATASPACE_SRGB, cs.getDataSpace());
+
+    assertNull(ColorSpace.getFromDataSpace(DataSpace.DATASPACE_JFIF));
+  }
+
   @SuppressWarnings("SameParameterValue")
   private void assertArrayNotEquals(float[] a, float[] b, float eps) {
     for (int i = 0; i < a.length; i++) {
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageDecoderTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageDecoderTest.java
index 19e391729..f73da3db3 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageDecoderTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageDecoderTest.java
@@ -2,9 +2,9 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertSame;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
 
 import android.content.res.AssetManager;
 import android.content.res.Resources;
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePaintTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePaintTest.java
index 37297c0f9..61d541183 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePaintTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePaintTest.java
@@ -17,6 +17,7 @@ import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeTrue;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.graphics.Bitmap;
@@ -49,6 +50,7 @@ import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions;
 import org.robolectric.versioning.AndroidVersions.U;
 
 @RunWith(RobolectricTestRunner.class)
@@ -106,6 +108,8 @@ public class ShadowNativePaintTest {
   public void measureTextActuallyMeasuresLength() {
     Paint paint = new Paint();
     paint.setTypeface(Typeface.DEFAULT);
+    // TODO: investigate post Baklava measure text differences
+    assumeTrue(RuntimeEnvironment.getApiLevel() <= AndroidVersions.Baklava.SDK_INT);
     assertThat(paint.measureText("Hello")).isEqualTo(28.0f);
     assertThat(paint.measureText("Hello", 1, 3)).isEqualTo(9.0f);
     assertThat(paint.measureText(new StringBuilder("Hello"), 1, 4)).isEqualTo(12.0f);
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeTextRunShaperTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeTextRunShaperTest.java
index eb2888e8d..e08cf56d9 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeTextRunShaperTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeTextRunShaperTest.java
@@ -160,7 +160,7 @@ public class ShadowNativeTextRunShaperTest {
     for (int i = 0; i < result.glyphCount(); ++i) {
       set.add(result.getFont(i));
     }
-    assertThat(set.size()).isEqualTo(2); // Roboto + Emoji is expected
+    assertThat(set).hasSize(2); // Roboto + Emoji is expected
   }
 
   @Test
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeVectorDrawableTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeVectorDrawableTest.java
index 5a6cc5171..138954150 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeVectorDrawableTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeVectorDrawableTest.java
@@ -17,6 +17,7 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.Q;
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.assertEquals;
@@ -33,6 +34,9 @@ import android.graphics.BitmapFactory;
 import android.graphics.Canvas;
 import android.graphics.Color;
 import android.graphics.Insets;
+import android.graphics.Path;
+import android.graphics.PathIterator;
+import android.graphics.PathIterator.Segment;
 import android.graphics.PixelFormat;
 import android.graphics.PorterDuff.Mode;
 import android.graphics.PorterDuffColorFilter;
@@ -481,6 +485,76 @@ public class ShadowNativeVectorDrawableTest {
         .isEqualTo(Color.BLUE);
   }
 
+  // Copied from here: https://skia-review.googlesource.com/c/skia/+/436477
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void test_moveTo() {
+    // First move
+    Path p = new Path();
+    p.moveTo(10, 11);
+    p.lineTo(20, 21);
+    p.close();
+    p.rMoveTo(30, 31);
+
+    PathIterator iter = p.getPathIterator();
+    Segment s = iter.next();
+    assertThat(s.getVerb()).isEqualTo(PathIterator.VERB_MOVE);
+    assertThat(s.getPoints()[0]).isEqualTo(10);
+    assertThat(s.getPoints()[1]).isEqualTo(11);
+
+    s = iter.next();
+    assertThat(s.getVerb()).isEqualTo(PathIterator.VERB_LINE);
+    assertThat(s.getPoints()[2]).isEqualTo(20);
+    assertThat(s.getPoints()[3]).isEqualTo(21);
+
+    s = iter.next();
+    assertThat(s.getVerb()).isEqualTo(PathIterator.VERB_CLOSE);
+
+    s = iter.next();
+    assertThat(s.getVerb()).isEqualTo(PathIterator.VERB_MOVE);
+    assertThat(s.getPoints()[0]).isEqualTo(10 + 30);
+    assertThat(s.getPoints()[1]).isEqualTo(11 + 31);
+
+    s = iter.next();
+    assertThat(s.getVerb()).isEqualTo(PathIterator.VERB_DONE);
+    p.reset();
+
+    p.moveTo(10, 11);
+    p.lineTo(20, 21);
+    p.rMoveTo(30, 31);
+
+    // Second Move
+    iter = p.getPathIterator();
+    s = iter.next();
+    assertThat(s.getVerb()).isEqualTo(PathIterator.VERB_MOVE);
+    assertThat(s.getPoints()[0]).isEqualTo(10);
+    assertThat(s.getPoints()[1]).isEqualTo(11);
+
+    s = iter.next();
+    assertThat(s.getVerb()).isEqualTo(PathIterator.VERB_LINE);
+    assertThat(s.getPoints()[2]).isEqualTo(20);
+    assertThat(s.getPoints()[3]).isEqualTo(21);
+
+    s = iter.next();
+    assertThat(s.getVerb()).isEqualTo(PathIterator.VERB_MOVE);
+    assertThat(s.getPoints()[0]).isEqualTo(20 + 30);
+    assertThat(s.getPoints()[1]).isEqualTo(21 + 31);
+
+    s = iter.next();
+    assertThat(s.getVerb()).isEqualTo(PathIterator.VERB_DONE);
+    p.reset();
+
+    // Third move
+    p.rMoveTo(30, 31);
+    s = iter.next();
+    assertThat(s.getPoints()[0]).isEqualTo(s.getPoints()[2] + 30);
+    assertThat(s.getPoints()[1]).isEqualTo(s.getPoints()[3] + 31);
+
+    s = iter.next();
+    assertThat(s.getVerb()).isEqualTo(PathIterator.VERB_DONE);
+    p.reset();
+  }
+
   private void verifyPreloadDensityInner(Resources res, int densityDpi)
       throws XmlPullParserException, IOException {
     // Capture initial state at default density.
diff --git a/integration_tests/rap/build.gradle.kts b/integration_tests/rap/build.gradle.kts
new file mode 100644
index 000000000..be6667262
--- /dev/null
+++ b/integration_tests/rap/build.gradle.kts
@@ -0,0 +1,36 @@
+plugins {
+  alias(libs.plugins.android.library)
+  alias(libs.plugins.robolectric.android.project)
+}
+
+android {
+  compileSdk = 35
+  namespace = "org.robolectric.rap"
+
+  defaultConfig { minSdk = 21 }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
+  testOptions {
+    targetSdk = 35
+    unitTests.isIncludeAndroidResources = true
+  }
+}
+
+dependencies {
+  annotationProcessor(project(":processor"))
+  api(project(":shadows:framework"))
+  testImplementation(project(":robolectric"))
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+}
+
+tasks.withType<JavaCompile>().configureEach {
+  options.compilerArgs.add(
+    "-Aorg.robolectric.annotation.processing.shadowPackage=org.robolectric.rap"
+  )
+  options.compilerArgs.add("-Aorg.robolectric.annotation.processing.priority=1")
+}
diff --git a/integration_tests/rap/src/main/java/org/robolectric/rap/ExtendedShadowApplication.java b/integration_tests/rap/src/main/java/org/robolectric/rap/ExtendedShadowApplication.java
new file mode 100644
index 000000000..f921b8e42
--- /dev/null
+++ b/integration_tests/rap/src/main/java/org/robolectric/rap/ExtendedShadowApplication.java
@@ -0,0 +1,17 @@
+package org.robolectric.rap;
+
+import static android.os.Build.VERSION_CODES.P;
+import static android.os.Build.VERSION_CODES.S;
+
+import android.app.Application;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
+import org.robolectric.shadows.ShadowApplication;
+
+/** This shadow tests the logic that emits resetters in RAP when a min/max sdk is specified */
+@Implements(value = Application.class, minSdk = P, maxSdk = S)
+public class ExtendedShadowApplication extends ShadowApplication {
+
+  @Resetter
+  public static void reset() {}
+}
diff --git a/integration_tests/rap/src/test/java/org/robolectric/rap/ExtendedShadowApplicationTest.java b/integration_tests/rap/src/test/java/org/robolectric/rap/ExtendedShadowApplicationTest.java
new file mode 100644
index 000000000..cbc009d3b
--- /dev/null
+++ b/integration_tests/rap/src/test/java/org/robolectric/rap/ExtendedShadowApplicationTest.java
@@ -0,0 +1,21 @@
+package org.robolectric.rap;
+
+import static android.os.Build.VERSION_CODES.S;
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadow.api.Shadow;
+
+@RunWith(RobolectricTestRunner.class)
+public final class ExtendedShadowApplicationTest {
+  @Config(sdk = S)
+  @Test
+  public void behaviorBeingTested_expectedResult() {
+    ExtendedShadowApplication application = Shadow.extract(RuntimeEnvironment.getApplication());
+    assertThat(application).isNotNull();
+  }
+}
diff --git a/integration_tests/sdkcompat/src/test/java/org/robolectric/integrationtests/sdkcompat/NormalCompatibilityTest.kt b/integration_tests/sdkcompat/src/test/java/org/robolectric/integrationtests/sdkcompat/NormalCompatibilityTest.kt
index ef1e66c11..084f1542e 100644
--- a/integration_tests/sdkcompat/src/test/java/org/robolectric/integrationtests/sdkcompat/NormalCompatibilityTest.kt
+++ b/integration_tests/sdkcompat/src/test/java/org/robolectric/integrationtests/sdkcompat/NormalCompatibilityTest.kt
@@ -99,7 +99,7 @@ class NormalCompatibilityTest {
   }
 
   @Test
-  @Config(minSdk = 19, maxSdk = 27)
+  @Config(maxSdk = 27)
   fun `MainActivity created correctly using default constructor on api lower than 28`() {
     buildActivity(MainActivity::class.java).use { controller ->
       val activity = controller.setup().get()
diff --git a/integration_tests/testparameterinjector/build.gradle.kts b/integration_tests/testparameterinjector/build.gradle.kts
index a664b5918..fc4e61231 100644
--- a/integration_tests/testparameterinjector/build.gradle.kts
+++ b/integration_tests/testparameterinjector/build.gradle.kts
@@ -24,6 +24,7 @@ dependencies {
   // Testing dependencies
   testImplementation(project(":robolectric"))
   testImplementation("com.google.testparameterinjector:test-parameter-injector:1.18@jar")
+  testImplementation(libs.findbugs.jsr305)
   testImplementation(libs.junit4)
   testImplementation(libs.truth)
 }
diff --git a/nativeruntime/src/main/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoader.java b/nativeruntime/src/main/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoader.java
index 077335766..8acecdd88 100644
--- a/nativeruntime/src/main/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoader.java
+++ b/nativeruntime/src/main/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoader.java
@@ -7,8 +7,10 @@ import android.database.CursorWindow;
 import android.graphics.Typeface;
 import com.google.auto.service.AutoService;
 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Iterables;
 import com.google.common.io.Files;
 import com.google.common.io.Resources;
 import java.io.File;
@@ -150,31 +152,23 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
     nativeRuntimeLoader.get().ensureLoaded();
   }
 
-  /**
-   * Overridable in Android, due to private resources.
-   */
+  /** Overridable in Android, due to private resources. */
   protected void maybeCopyExtraResources(TempDirectory dir) {
-    //default to no-op
+    // default to no-op
   }
 
-  /**
-   * Overridable in Android, due to changing shadows in private branches.
-   */
-  protected List<String> getCoreClassNatives(){
+  /** Overridable in Android, due to changing shadows in private branches. */
+  protected List<String> getCoreClassNatives() {
     return CORE_CLASS_NATIVES;
   }
 
-  /**
-   * Overridable in Android, due to changing shadows in private branches.
-   */
-  protected  List<String> getDeferredStaticInitializers(){
+  /** Overridable in Android, due to changing shadows in private branches. */
+  protected List<String> getDeferredStaticInitializers() {
     return DEFERRED_STATIC_INITIALIZERS;
   }
 
-  /**
-   * Overridable in Android, due to changing shadows in private branches.
-   */
-  protected List<String> getGraphicsNatives(){
+  /** Overridable in Android, due to changing shadows in private branches. */
+  protected List<String> getGraphicsNatives() {
     return GRAPHICS_CLASS_NATIVES;
   }
 
@@ -206,7 +200,8 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
                 maybeCopyIcuData(extractDirectory);
                 maybeCopyExtraResources(extractDirectory);
                 if (isAndroidVOrGreater()) {
-                  System.setProperty("core_native_classes", String.join(",", getCoreClassNatives()));
+                  System.setProperty(
+                      "core_native_classes", String.join(",", getCoreClassNatives()));
                   System.setProperty(
                       "graphics_native_classes", String.join(",", getGraphicsNatives()));
                   System.setProperty("method_binding_format", METHOD_BINDING_FORMAT);
@@ -222,10 +217,12 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
     }
   }
 
-
   private static List<String> getResourcesInAndroidAll(String prefix) throws IOException {
     try {
-      String jarPath = Resources.getResource("build.prop").toURI().toString().split("!")[0].substring("jar:file:".length());
+      String jarPath =
+          Iterables.get(
+                  Splitter.on('!').split(Resources.getResource("build.prop").toURI().toString()), 0)
+              .substring("jar:file:".length());
       List<String> resources = new ArrayList<>();
       try (JarFile jarFile = new JarFile(jarPath)) {
         Enumeration<JarEntry> entries = jarFile.entries();
@@ -246,7 +243,7 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
   private void maybeCopyIcuData(TempDirectory tempDirectory) throws IOException {
     URL icuDatUrl;
     try {
-      if ( AndroidVersions.CURRENT.getSdkInt() <= AndroidVersions.U.SDK_INT ) {
+      if (AndroidVersions.CURRENT.getSdkInt() <= AndroidVersions.U.SDK_INT) {
         icuDatUrl = Resources.getResource("icu/icudt68l.dat");
       } else {
         List<String> resources = getResourcesInAndroidAll("icu/icudt");
@@ -255,7 +252,6 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
         } else {
           icuDatUrl = Resources.getResource(resources.get(0));
         }
-
       }
     } catch (IllegalArgumentException e) {
       System.out.println("Could not load icu data file ");
@@ -263,11 +259,11 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
     }
     Path icuPath = tempDirectory.create("icu");
     Path icuDatPath;
-    if ( AndroidVersions.CURRENT.getSdkInt() <= AndroidVersions.U.SDK_INT ) {
+    if (AndroidVersions.CURRENT.getSdkInt() <= AndroidVersions.U.SDK_INT) {
       icuDatPath = icuPath.resolve("icudt68l.dat");
     } else {
-      String[] parts = icuDatUrl.toString().split("/");
-      icuDatPath = icuPath.resolve(parts[parts.length-1]);
+      List<String> parts = Splitter.on('/').splitToList(icuDatUrl.toString());
+      icuDatPath = icuPath.resolve(Iterables.getLast(parts));
     }
     Resources.asByteSource(icuDatUrl).copyTo(Files.asByteSink(icuDatPath.toFile()));
     System.setProperty("icu.data.path", icuDatPath.toAbsolutePath().toString());
@@ -321,7 +317,7 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
   private void loadLibrary(TempDirectory tempDirectory) throws IOException {
     Path libraryPath = tempDirectory.getBasePath().resolve(libraryName());
     URL libraryResource = Resources.getResource(nativeLibraryPath());
-    Logger.info("Reading android native library from: " + libraryResource);
+    Logger.info("Loading android native library from: " + libraryResource);
     Resources.asByteSource(libraryResource).copyTo(Files.asByteSink(libraryPath.toFile()));
     System.load(libraryPath.toAbsolutePath().toString());
   }
diff --git a/nativeruntime/src/main/resources/arsc/Android.bp b/nativeruntime/src/main/resources/arsc/Android.bp
index e1fa16506..4529db419 100644
--- a/nativeruntime/src/main/resources/arsc/Android.bp
+++ b/nativeruntime/src/main/resources/arsc/Android.bp
@@ -18,8 +18,8 @@ genrule {
     out: ["values/public.xml"],
     cmd: "mkdir -p $(genDir)/values; echo '<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
         " <resources>" +
-        " <public type=\"string\" name=\"config_bodyFontFamily\" id=\"0x010401fe\" /> " +
-        " <public type=\"string\" name=\"config_headlineFontFamily\" id=\"0x01040274\" /> " +
+        " <public type=\"string\" name=\"config_bodyFontFamily\" id=\"0x01040211\" /> " +
+        " <public type=\"string\" name=\"config_headlineFontFamily\" id=\"0x01040287\" /> " +
         " </resources>' > $(out)",
 }
 
diff --git a/nativeruntime/src/main/resources/fonts/GoogleSansFlexClock-Regular.ttf b/nativeruntime/src/main/resources/fonts/GoogleSansFlexClock-Regular.ttf
index 5a5df64aa..26806ae74 100644
Binary files a/nativeruntime/src/main/resources/fonts/GoogleSansFlexClock-Regular.ttf and b/nativeruntime/src/main/resources/fonts/GoogleSansFlexClock-Regular.ttf differ
diff --git a/nativeruntime/src/test/resources/resources.ap_ b/nativeruntime/src/test/resources/resources.ap_
index d5c10672f..89a097e39 100644
Binary files a/nativeruntime/src/test/resources/resources.ap_ and b/nativeruntime/src/test/resources/resources.ap_ differ
diff --git a/pluginapi/build.gradle.kts b/pluginapi/build.gradle.kts
index 9dd5c1130..060426c86 100644
--- a/pluginapi/build.gradle.kts
+++ b/pluginapi/build.gradle.kts
@@ -10,5 +10,4 @@ dependencies {
 
   testImplementation(libs.junit4)
   testImplementation(libs.truth)
-  testImplementation(libs.mockito)
 }
diff --git a/pluginapi/src/main/java/org/robolectric/internal/dependency/DependencyResolver.java b/pluginapi/src/main/java/org/robolectric/internal/dependency/DependencyResolver.java
index 1d6546d28..902cdf57f 100644
--- a/pluginapi/src/main/java/org/robolectric/internal/dependency/DependencyResolver.java
+++ b/pluginapi/src/main/java/org/robolectric/internal/dependency/DependencyResolver.java
@@ -14,15 +14,4 @@ import java.net.URL;
  */
 public interface DependencyResolver {
   URL getLocalArtifactUrl(DependencyJar dependency);
-
-  /**
-   * Returns URLs representing the full transitive dependency graph of the given Maven dependency.
-   *
-   * @deprecated Robolectric will never ask for a dependency composed of more than one artifact, so
-   *     this method isn't necessary.
-   */
-  @Deprecated
-  default URL[] getLocalArtifactUrls(DependencyJar dependency) {
-    return new URL[] {getLocalArtifactUrl(dependency)};
-  }
 }
diff --git a/pluginapi/src/main/java/org/robolectric/pluginapi/perf/Metric.java b/pluginapi/src/main/java/org/robolectric/pluginapi/perf/Metric.java
index 7e635e4cd..2d6b381d7 100644
--- a/pluginapi/src/main/java/org/robolectric/pluginapi/perf/Metric.java
+++ b/pluginapi/src/main/java/org/robolectric/pluginapi/perf/Metric.java
@@ -1,5 +1,7 @@
 package org.robolectric.pluginapi.perf;
 
+import java.util.Objects;
+
 /** Metric for perf stats collection. */
 public class Metric {
   private final String name;
@@ -76,7 +78,7 @@ public class Metric {
     if (success != metric.success) {
       return false;
     }
-    return name != null ? name.equals(metric.name) : metric.name == null;
+    return Objects.equals(name, metric.name);
   }
 
   @Override
diff --git a/pluginapi/src/test/java/org/robolectric/internal/dependency/DependencyJarTest.java b/pluginapi/src/test/java/org/robolectric/internal/dependency/DependencyJarTest.java
index 08074cd88..f83afc4f6 100644
--- a/pluginapi/src/test/java/org/robolectric/internal/dependency/DependencyJarTest.java
+++ b/pluginapi/src/test/java/org/robolectric/internal/dependency/DependencyJarTest.java
@@ -9,7 +9,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public class DependencyJarTest {
   @Test
-  public void testGetShortName() throws Exception {
+  public void testGetShortName() {
     assertThat(new DependencyJar("com.group", "artifact", "1.3", null).getShortName())
         .isEqualTo("com.group:artifact:1.3");
     assertThat(new DependencyJar("com.group", "artifact", "1.3", "dll").getShortName())
diff --git a/plugins/maven-dependency-resolver/build.gradle.kts b/plugins/maven-dependency-resolver/build.gradle.kts
index 900932d75..491c873a0 100644
--- a/plugins/maven-dependency-resolver/build.gradle.kts
+++ b/plugins/maven-dependency-resolver/build.gradle.kts
@@ -24,9 +24,9 @@ dependencies {
   api(libs.auto.value.annotations)
   api(libs.guava)
   annotationProcessor(libs.auto.value)
+  compileOnly(libs.findbugs.jsr305)
 
   testImplementation(libs.junit4)
-  testImplementation(libs.mockito)
   testImplementation(libs.truth)
   testImplementation(libs.kotlin.stdlib)
 }
diff --git a/plugins/maven-dependency-resolver/src/main/java/org/robolectric/internal/dependency/MavenArtifactFetcher.java b/plugins/maven-dependency-resolver/src/main/java/org/robolectric/internal/dependency/MavenArtifactFetcher.java
index adeda9e78..a2971bccd 100644
--- a/plugins/maven-dependency-resolver/src/main/java/org/robolectric/internal/dependency/MavenArtifactFetcher.java
+++ b/plugins/maven-dependency-resolver/src/main/java/org/robolectric/internal/dependency/MavenArtifactFetcher.java
@@ -207,10 +207,10 @@ public class MavenArtifactFetcher {
 
     private final URL remoteURL;
     private final File localFile;
-    private String repositoryUserName;
-    private String repositoryPassword;
-    private String proxyHost;
-    private int proxyPort;
+    private final String repositoryUserName;
+    private final String repositoryPassword;
+    private final String proxyHost;
+    private final int proxyPort;
 
     public FetchToFileTask(
         URL remoteURL,
@@ -227,6 +227,7 @@ public class MavenArtifactFetcher {
       this.proxyPort = proxyPort;
     }
 
+    @Nonnull
     @Override
     public ListenableFuture<Void> call() throws Exception {
       URLConnection connection;
diff --git a/plugins/maven-dependency-resolver/src/main/java/org/robolectric/internal/dependency/MavenDependencyResolver.java b/plugins/maven-dependency-resolver/src/main/java/org/robolectric/internal/dependency/MavenDependencyResolver.java
index 940295a3b..337a64681 100644
--- a/plugins/maven-dependency-resolver/src/main/java/org/robolectric/internal/dependency/MavenDependencyResolver.java
+++ b/plugins/maven-dependency-resolver/src/main/java/org/robolectric/internal/dependency/MavenDependencyResolver.java
@@ -39,7 +39,6 @@ import org.xml.sax.SAXException;
  */
 public class MavenDependencyResolver implements DependencyResolver {
 
-  private final ExecutorService executorService;
   private final MavenArtifactFetcher mavenArtifactFetcher;
   private final File localRepositoryDir;
 
@@ -60,7 +59,6 @@ public class MavenDependencyResolver implements DependencyResolver {
       String repositoryPassword,
       String proxyHost,
       int proxyPort) {
-    this.executorService = createExecutorService();
     this.localRepositoryDir = getLocalRepositoryDir();
     this.mavenArtifactFetcher =
         createMavenFetcher(
@@ -70,12 +68,7 @@ public class MavenDependencyResolver implements DependencyResolver {
             proxyHost,
             proxyPort,
             localRepositoryDir,
-            this.executorService);
-  }
-
-  @Override
-  public URL[] getLocalArtifactUrls(DependencyJar dependency) {
-    return getLocalArtifactUrls(new DependencyJar[] {dependency});
+            createExecutorService());
   }
 
   /**
diff --git a/plugins/maven-dependency-resolver/src/test/java/org/robolectric/MavenRoboSettingsTest.kt b/plugins/maven-dependency-resolver/src/test/java/org/robolectric/MavenRoboSettingsTest.kt
index befa73091..dac356b03 100644
--- a/plugins/maven-dependency-resolver/src/test/java/org/robolectric/MavenRoboSettingsTest.kt
+++ b/plugins/maven-dependency-resolver/src/test/java/org/robolectric/MavenRoboSettingsTest.kt
@@ -8,6 +8,7 @@ import org.junit.runner.RunWith
 import org.junit.runners.JUnit4
 
 @RunWith(JUnit4::class)
+@Suppress("DEPRECATION")
 class MavenRoboSettingsTest {
   private var originalMavenRepositoryId: String? = null
   private var originalMavenRepositoryUrl: String? = null
diff --git a/preinstrumented/build.gradle.kts b/preinstrumented/build.gradle.kts
index 60cfa578a..0d18a3816 100644
--- a/preinstrumented/build.gradle.kts
+++ b/preinstrumented/build.gradle.kts
@@ -20,6 +20,7 @@ dependencies {
 
   testImplementation(libs.junit4)
   testImplementation(libs.mockito)
+  testImplementation(libs.mockito.subclass)
 }
 
 val instrumentAll by
diff --git a/preinstrumented/src/main/java/org/robolectric/preinstrumented/JarInstrumentor.java b/preinstrumented/src/main/java/org/robolectric/preinstrumented/JarInstrumentor.java
index 2b07e0ab0..36dcdb23b 100644
--- a/preinstrumented/src/main/java/org/robolectric/preinstrumented/JarInstrumentor.java
+++ b/preinstrumented/src/main/java/org/robolectric/preinstrumented/JarInstrumentor.java
@@ -1,6 +1,7 @@
 package org.robolectric.preinstrumented;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.nio.file.Files.newOutputStream;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
@@ -10,7 +11,6 @@ import com.google.common.io.ByteStreams;
 import com.google.common.io.Files;
 import java.io.BufferedOutputStream;
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.file.Path;
@@ -152,7 +152,8 @@ public class JarInstrumentor {
     }
 
     try (JarOutputStream jarOut =
-        new JarOutputStream(new BufferedOutputStream(new FileOutputStream(destJarFile), ONE_MB))) {
+        new JarOutputStream(
+            new BufferedOutputStream(newOutputStream(destJarFile.toPath()), ONE_MB))) {
       Enumeration<JarEntry> entries = jarFile.entries();
       while (entries.hasMoreElements()) {
         JarEntry jarEntry = entries.nextElement();
@@ -195,13 +196,11 @@ public class JarInstrumentor {
         } else {
           boolean shouldKeep = true;
           if (hasResourcesToKeepFile) {
-            shouldKeep = false;
-            if (resourceFilesToKeep.contains(name)) {
-              shouldKeep = true;
-            }
+            shouldKeep = resourceFilesToKeep.contains(name);
             for (String dir : resourceDirsToKeep) {
               if (name.startsWith(dir)) {
                 shouldKeep = true;
+                break;
               }
             }
           }
@@ -215,13 +214,12 @@ public class JarInstrumentor {
     }
 
     long elapsedNs = System.nanoTime() - startNs;
-    System.out.println(
-        String.format(
-            Locale.getDefault(),
-            "Wrote %d classes and %d resources in %1.2f seconds",
-            classCount,
-            nonClassCount,
-            elapsedNs / 1000000000.0));
+    System.out.printf(
+        Locale.getDefault(),
+        "Wrote %d classes and %d resources in %1.2f seconds%n",
+        classCount,
+        nonClassCount,
+        elapsedNs / 1000000000.0);
   }
 
   private static byte[] getClassBytes(String className, JarFile jarFile)
diff --git a/preinstrumented/src/test/java/org/robolectric/preinstrumented/JarInstrumentorTest.java b/preinstrumented/src/test/java/org/robolectric/preinstrumented/JarInstrumentorTest.java
index 3e401f37d..f7465a9c7 100644
--- a/preinstrumented/src/test/java/org/robolectric/preinstrumented/JarInstrumentorTest.java
+++ b/preinstrumented/src/test/java/org/robolectric/preinstrumented/JarInstrumentorTest.java
@@ -18,13 +18,13 @@ public class JarInstrumentorTest {
   private JarInstrumentor spyDummyInstrumentor;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     JarInstrumentor dummyInstrumentor =
         new JarInstrumentor() {
           @Override
           protected void instrumentJar(File sourceJarFile, File destJarFile) {
             // No-op. We only want to test the command line processing. Stub the actual
-            // instrumention.
+            // instrumentation.
           }
 
           @Override
diff --git a/processor/build.gradle.kts b/processor/build.gradle.kts
index 341fd8d4f..02b9f7fdc 100644
--- a/processor/build.gradle.kts
+++ b/processor/build.gradle.kts
@@ -43,7 +43,6 @@ dependencies {
 
   compileOnly(libs.findbugs.jsr305)
   api(libs.asm)
-  api(libs.asm.commons)
   api(libs.asm.util)
   api(libs.guava)
   api(libs.gson)
@@ -54,9 +53,10 @@ dependencies {
     implementation(files(toolsJar))
   }
 
-  testImplementation(libs.javax.annotation.jsr250.api)
+  testImplementation(libs.javax.annotation.api)
   testImplementation(libs.junit4)
   testImplementation(libs.mockito)
+  testImplementation(libs.mockito.subclass)
   testImplementation(libs.compile.testing)
   testImplementation(libs.truth)
 }
diff --git a/processor/src/main/java/org/robolectric/annotation/processing/Helpers.java b/processor/src/main/java/org/robolectric/annotation/processing/Helpers.java
index a4324c4b3..932f2bd94 100644
--- a/processor/src/main/java/org/robolectric/annotation/processing/Helpers.java
+++ b/processor/src/main/java/org/robolectric/annotation/processing/Helpers.java
@@ -7,6 +7,7 @@ import com.google.common.base.Predicate;
 import com.google.common.collect.Iterables;
 import java.util.List;
 import java.util.Map.Entry;
+import javax.annotation.Nonnull;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
@@ -20,14 +21,14 @@ import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleAnnotationValueVisitor6;
-import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.SimpleAnnotationValueVisitor8;
+import javax.lang.model.util.SimpleElementVisitor8;
 import javax.lang.model.util.Types;
 
 public class Helpers {
 
   private static final AnnotationValueVisitor<TypeMirror, Void> TYPE_MIRROR_VISITOR =
-      new SimpleAnnotationValueVisitor6<TypeMirror, Void>() {
+      new SimpleAnnotationValueVisitor8<TypeMirror, Void>() {
         @Override
         public TypeMirror visitType(TypeMirror t, Void arg) {
           return t;
@@ -35,7 +36,7 @@ public class Helpers {
       };
 
   private static final ElementVisitor<TypeElement, Void> TYPE_ELEMENT_VISITOR =
-      new SimpleElementVisitor6<TypeElement, Void>() {
+      new SimpleElementVisitor8<TypeElement, Void>() {
         @Override
         public TypeElement visitType(TypeElement e, Void p) {
           return e;
@@ -43,7 +44,7 @@ public class Helpers {
       };
 
   private static final AnnotationValueVisitor<String, Void> STRING_VISITOR =
-      new SimpleAnnotationValueVisitor6<String, Void>() {
+      new SimpleAnnotationValueVisitor8<String, Void>() {
         @Override
         public String visitString(String s, Void arg) {
           return s;
@@ -51,7 +52,7 @@ public class Helpers {
       };
 
   private static final AnnotationValueVisitor<Integer, Void> INT_VISITOR =
-      new SimpleAnnotationValueVisitor6<Integer, Void>() {
+      new SimpleAnnotationValueVisitor8<Integer, Void>() {
         @Override
         public Integer visitInt(int i, Void aVoid) {
           return i;
@@ -122,12 +123,12 @@ public class Helpers {
   private final Equivalence<TypeMirror> typeMirrorEq =
       new Equivalence<TypeMirror>() {
         @Override
-        protected boolean doEquivalent(TypeMirror a, TypeMirror b) {
+        protected boolean doEquivalent(@Nonnull TypeMirror a, @Nonnull TypeMirror b) {
           return types.isSameType(a, b);
         }
 
         @Override
-        protected int doHash(TypeMirror t) {
+        protected int doHash(@Nonnull TypeMirror t) {
           // We're not using the hash.
           return 0;
         }
@@ -145,7 +146,7 @@ public class Helpers {
         }
 
         @Override
-        protected int doHash(TypeParameterElement arg0) {
+        protected int doHash(@Nonnull TypeParameterElement arg0) {
           // We don't use the hash code.
           return 0;
         }
@@ -192,11 +193,7 @@ public class Helpers {
     if (av == null) {
       return null;
     }
-    TypeMirror type = Helpers.getAnnotationTypeMirrorValue(av);
-    if (type == null) {
-      return null;
-    }
-    return type;
+    return Helpers.getAnnotationTypeMirrorValue(av);
   }
 
   String getPackageOf(TypeElement typeElement) {
diff --git a/processor/src/main/java/org/robolectric/annotation/processing/RobolectricModel.java b/processor/src/main/java/org/robolectric/annotation/processing/RobolectricModel.java
index f2327c6fc..1af1f2384 100644
--- a/processor/src/main/java/org/robolectric/annotation/processing/RobolectricModel.java
+++ b/processor/src/main/java/org/robolectric/annotation/processing/RobolectricModel.java
@@ -29,8 +29,8 @@ import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVisitor;
-import javax.lang.model.util.SimpleElementVisitor6;
-import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.SimpleElementVisitor8;
+import javax.lang.model.util.SimpleTypeVisitor8;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadow.api.ShadowPicker;
 
@@ -70,7 +70,7 @@ public class RobolectricModel {
   }
 
   private static final ElementVisitor<TypeElement, Void> TYPE_ELEMENT_VISITOR =
-      new SimpleElementVisitor6<TypeElement, Void>() {
+      new SimpleElementVisitor8<TypeElement, Void>() {
         @Override
         public TypeElement visitType(TypeElement e, Void p) {
           return e;
@@ -201,8 +201,8 @@ public class RobolectricModel {
             referentMap.put(type, referents.getKey());
           } else {
             for (TypeElement type : c) {
-              SimpleElementVisitor6<Void, TypeElement> visitor =
-                  new SimpleElementVisitor6<Void, TypeElement>() {
+              ElementVisitor<Void, TypeElement> visitor =
+                  new SimpleElementVisitor8<Void, TypeElement>() {
                     @Override
                     public Void visitType(TypeElement parent, TypeElement type) {
                       nextRound.put(parent.getSimpleName() + "." + type.getSimpleName(), type);
@@ -276,7 +276,7 @@ public class RobolectricModel {
     }
 
     private final TypeVisitor<String, Void> findReferent =
-        new SimpleTypeVisitor6<String, Void>() {
+        new SimpleTypeVisitor8<String, Void>() {
           @Override
           public String visitDeclared(DeclaredType t, Void p) {
             return referentMap.get(t.asElement());
diff --git a/processor/src/main/java/org/robolectric/annotation/processing/generator/ServiceLoaderGenerator.java b/processor/src/main/java/org/robolectric/annotation/processing/generator/ServiceLoaderGenerator.java
index 13115d7ec..44aeed58e 100644
--- a/processor/src/main/java/org/robolectric/annotation/processing/generator/ServiceLoaderGenerator.java
+++ b/processor/src/main/java/org/robolectric/annotation/processing/generator/ServiceLoaderGenerator.java
@@ -3,6 +3,7 @@ package org.robolectric.annotation.processing.generator;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
+import java.nio.charset.StandardCharsets;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.ProcessingEnvironment;
@@ -29,7 +30,8 @@ public class ServiceLoaderGenerator extends Generator {
     try {
       FileObject file =
           filer.createResource(StandardLocation.CLASS_OUTPUT, "", "META-INF/services/" + fileName);
-      PrintWriter pw = new PrintWriter(new OutputStreamWriter(file.openOutputStream(), "UTF-8"));
+      PrintWriter pw =
+          new PrintWriter(new OutputStreamWriter(file.openOutputStream(), StandardCharsets.UTF_8));
       pw.print(shadowPackage + '.' + GEN_CLASS + '\n');
       pw.close();
     } catch (IOException e) {
diff --git a/processor/src/main/java/org/robolectric/annotation/processing/generator/ShadowProviderGenerator.java b/processor/src/main/java/org/robolectric/annotation/processing/generator/ShadowProviderGenerator.java
index a16aede89..6447f925c 100644
--- a/processor/src/main/java/org/robolectric/annotation/processing/generator/ShadowProviderGenerator.java
+++ b/processor/src/main/java/org/robolectric/annotation/processing/generator/ShadowProviderGenerator.java
@@ -59,7 +59,8 @@ public class ShadowProviderGenerator extends Generator {
   }
 
   void generate(PrintWriter writer) {
-    writer.print("package " + shadowPackage + ";\n");
+    writer.println("package " + shadowPackage + ";");
+    writer.println();
     for (String name : model.getImports()) {
       writer.println("import " + name + ';');
     }
@@ -83,9 +84,9 @@ public class ShadowProviderGenerator extends Generator {
 
     writer.println("  static {");
     for (ShadowInfo shadowInfo : model.getAllShadowTypes()) {
-      final String shadow = shadowInfo.getShadowBinaryName();
-      final String actual = shadowInfo.getActualName();
       if (shadowInfo.getShadowPickerBinaryName() == null) {
+        final String shadow = shadowInfo.getShadowBinaryName();
+        final String actual = shadowInfo.getActualName();
         writer.println(
             "    SHADOWS.add(new AbstractMap.SimpleImmutableEntry<>(\""
                 + actual
@@ -130,15 +131,13 @@ public class ShadowProviderGenerator extends Generator {
               + " shadowOf("
               + shadowInfo.getActualTypeWithParams()
               + " actual) {");
-      writer.println("    return (" + shadow + ") Shadow.extract(actual);");
+      writer.println("    return Shadow.extract(actual);");
       writer.println("  }");
       writer.println();
     }
 
     // this sucks, kill:
-    for (Entry<String, ShadowInfo> entry : model.getShadowPickers().entrySet()) {
-      ShadowInfo shadowInfo = entry.getValue();
-
+    for (ShadowInfo shadowInfo : model.getShadowPickers().values()) {
       if (!shadowInfo.actualIsPublic() || !shadowInfo.isInAndroidSdk()) {
         continue;
       }
@@ -147,7 +146,7 @@ public class ShadowProviderGenerator extends Generator {
         writer.println("  @Deprecated");
       }
       String paramDefStr = shadowInfo.getParamDefStr();
-      final String shadow = shadowInfo.getShadowName();
+      final String shadow = shadowInfo.getShadowTypeWithParams();
       writer.println(
           "  public static "
               + (paramDefStr.isEmpty() ? "" : paramDefStr + " ")
@@ -155,7 +154,7 @@ public class ShadowProviderGenerator extends Generator {
               + " shadowOf("
               + shadowInfo.getActualTypeWithParams()
               + " actual) {");
-      writer.println("    return (" + shadow + ") Shadow.extract(actual);");
+      writer.println("    return Shadow.extract(actual);");
       writer.println("  }");
       writer.println();
     }
@@ -166,6 +165,8 @@ public class ShadowProviderGenerator extends Generator {
       int minSdk = resetterInfo.getMinSdk();
       int maxSdk = resetterInfo.getMaxSdk();
       String ifClause;
+      // The fully-qualiied name 'org.robolectric.RuntimeEnvironment' is required because shadow
+      // packages may not be in the 'org.robolectric' package.
       if (minSdk != -1 && maxSdk != -1) {
         ifClause =
             "if (org.robolectric.RuntimeEnvironment.getApiLevel() >= "
diff --git a/processor/src/main/java/org/robolectric/annotation/processing/validator/ImplementsValidator.java b/processor/src/main/java/org/robolectric/annotation/processing/validator/ImplementsValidator.java
index 6d4af25a5..b0e0883d9 100644
--- a/processor/src/main/java/org/robolectric/annotation/processing/validator/ImplementsValidator.java
+++ b/processor/src/main/java/org/robolectric/annotation/processing/validator/ImplementsValidator.java
@@ -310,7 +310,7 @@ public class ImplementsValidator extends Validator {
       Kind kind = sdkCheckMode == SdkCheckMode.WARN ? Kind.WARNING : Kind.ERROR;
       Problems problems = new Problems(kind);
 
-      for (SdkStore.Sdk sdk : sdkStore.sdksMatching(implementation, classMinSdk, classMaxSdk)) {
+      for (SdkStore.Sdk sdk : sdkStore.sdksMatching(null, classMinSdk, classMaxSdk)) {
         String problem = sdk.verifyMethod(sdkClassName, methodElement, looseSignatures, allowInDev);
         if (problem == null && sdk.getClassInfo(sdkClassName) != null) {
           problems.add(
@@ -345,9 +345,8 @@ public class ImplementsValidator extends Validator {
     Elements elementUtils = env.getElementUtils();
     modelBuilder.documentType(elem, elementUtils.getDocComment(elem), imports);
 
-    for (Element memberElement : ElementFilter.methodsIn(elem.getEnclosedElements())) {
+    for (ExecutableElement memberElement : ElementFilter.methodsIn(elem.getEnclosedElements())) {
       try {
-        ExecutableElement methodElement = (ExecutableElement) memberElement;
         Implementation implementation = memberElement.getAnnotation(Implementation.class);
 
         DocumentedMethod documentedMethod = new DocumentedMethod(memberElement.toString());
@@ -359,14 +358,14 @@ public class ImplementsValidator extends Validator {
           documentedMethod.minSdk = sdkOrNull(implementation.minSdk());
           documentedMethod.maxSdk = sdkOrNull(implementation.maxSdk());
         }
-        for (VariableElement variableElement : methodElement.getParameters()) {
+        for (VariableElement variableElement : memberElement.getParameters()) {
           documentedMethod.params.add(variableElement.toString());
         }
-        documentedMethod.returnType = methodElement.getReturnType().toString();
-        for (TypeMirror typeMirror : methodElement.getThrownTypes()) {
+        documentedMethod.returnType = memberElement.getReturnType().toString();
+        for (TypeMirror typeMirror : memberElement.getThrownTypes()) {
           documentedMethod.exceptions.add(typeMirror.toString());
         }
-        String docMd = elementUtils.getDocComment(methodElement);
+        String docMd = elementUtils.getDocComment(memberElement);
         if (docMd != null) {
           documentedMethod.setDocumentation(docMd);
         }
@@ -392,10 +391,7 @@ public class ImplementsValidator extends Validator {
     }
 
     void add(String problem, int sdkInt) {
-      Set<Integer> sdks = problems.get(problem);
-      if (sdks == null) {
-        problems.put(problem, sdks = new TreeSet<>());
-      }
+      Set<Integer> sdks = problems.computeIfAbsent(problem, k -> new TreeSet<>());
       sdks.add(sdkInt);
     }
 
diff --git a/processor/src/main/java/org/robolectric/annotation/processing/validator/RealObjectValidator.java b/processor/src/main/java/org/robolectric/annotation/processing/validator/RealObjectValidator.java
index 23418226c..dd88ad3ce 100644
--- a/processor/src/main/java/org/robolectric/annotation/processing/validator/RealObjectValidator.java
+++ b/processor/src/main/java/org/robolectric/annotation/processing/validator/RealObjectValidator.java
@@ -8,7 +8,7 @@ import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVisitor;
-import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor8;
 import javax.tools.Diagnostic.Kind;
 import org.robolectric.annotation.processing.RobolectricModel;
 
@@ -20,20 +20,20 @@ public class RealObjectValidator extends FoundOnImplementsValidator {
   }
 
   public static String join(List<?> params) {
-    StringBuilder retval = new StringBuilder();
+    StringBuilder result = new StringBuilder();
     boolean comma = false;
     for (Object p : params) {
       if (comma) {
-        retval.append(',');
+        result.append(',');
       }
       comma = true;
-      retval.append(p);
+      result.append(p);
     }
-    return retval.toString();
+    return result.toString();
   }
 
   TypeVisitor<Void, VariableElement> typeVisitor =
-      new SimpleTypeVisitor6<Void, VariableElement>() {
+      new SimpleTypeVisitor8<Void, VariableElement>() {
         @Override
         public Void visitDeclared(DeclaredType t, VariableElement v) {
           List<? extends TypeMirror> typeParams = t.getTypeArguments();
diff --git a/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java b/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java
index 43b2c0c8a..d74ac136f 100644
--- a/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java
+++ b/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java
@@ -7,7 +7,6 @@ import static org.robolectric.annotation.processing.validator.ImplementsValidato
 import com.google.common.collect.ImmutableList;
 import java.io.BufferedReader;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -18,7 +17,6 @@ import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -140,7 +138,12 @@ public class SdkStore {
     StringBuilder builder = new StringBuilder();
     builder.append("SdkStore [");
     for (Sdk sdk : sdks.stream().sorted().collect(Collectors.toList())) {
-      builder.append("    " + sdk.sdkRelease.getSdkInt() + " : " + sdk.path + "\n");
+      builder
+          .append("    ")
+          .append(sdk.sdkRelease.getSdkInt())
+          .append(" : ")
+          .append(sdk.path)
+          .append("\n");
     }
     builder.append("]");
     return builder.toString();
@@ -157,11 +160,11 @@ public class SdkStore {
    */
   private static String compilationSdkTarget() {
     String cmd = System.getProperty("sun.java.command");
-    Pattern pattern = Pattern.compile("((-cp)|(-classpath))\\s(?<cp>[a-zA-Z-_0-9\\-\\:\\/\\.]*)");
+    Pattern pattern = Pattern.compile("((-cp)|(-classpath))\\s(?<cp>[a-zA-Z-_0-9\\-:/.]*)");
     Matcher matcher = pattern.matcher(cmd);
     if (matcher.find()) {
       String classpathString = matcher.group("cp");
-      List<String> cp = Arrays.asList(classpathString.split(":"));
+      String[] cp = classpathString.split(":");
       for (String fileStr : cp) {
         try (JarFile jarFile = new JarFile(fileStr)) {
           ZipEntry entry = jarFile.getEntry("build.prop");
@@ -191,28 +194,22 @@ public class SdkStore {
   private static ImmutableList<Sdk> loadFromSources(
       boolean localSdk, String sdkFileName, String overrideSdkLocation, int overrideSdkInt) {
     if (localSdk) {
-      Sdk sdk = null;
       if (overrideSdkLocation != null) {
-        sdk = new Sdk(overrideSdkLocation, overrideSdkInt);
-        return sdk == null ? ImmutableList.of() : ImmutableList.of(sdk);
+        Sdk sdk = new Sdk(overrideSdkLocation, overrideSdkInt);
+        return ImmutableList.of(sdk);
       } else {
         String target = compilationSdkTarget();
         if (target != null) {
-          sdk = new Sdk(target);
+          Sdk sdk = new Sdk(target);
           // We don't want to test released versions in Android source tree.
-          return sdk == null || sdk.sdkRelease.isReleased()
-              ? ImmutableList.of()
-              : ImmutableList.of(sdk);
+          return sdk.sdkRelease.isReleased() ? ImmutableList.of() : ImmutableList.of(sdk);
         }
       }
     }
     if (sdkFileName == null || Files.notExists(Paths.get(sdkFileName))) {
       return ImmutableList.of();
     }
-    try (InputStream resIn = new FileInputStream(sdkFileName)) {
-      if (resIn == null) {
-        throw new RuntimeException("no such file " + sdkFileName);
-      }
+    try (InputStream resIn = Files.newInputStream(Paths.get(sdkFileName))) {
       BufferedReader in =
           new BufferedReader(new InputStreamReader(resIn, Charset.defaultCharset()));
       List<Sdk> sdks = new ArrayList<>();
@@ -265,11 +262,10 @@ public class SdkStore {
       }
       if (sdkInt == null) {
         this.sdkRelease = readSdkVersion();
-        this.sdkInt = sdkRelease.getSdkInt();
       } else {
         this.sdkRelease = AndroidVersions.getReleaseForSdkInt(sdkInt);
-        this.sdkInt = sdkRelease.getSdkInt();
       }
+      this.sdkInt = sdkRelease.getSdkInt();
     }
 
     /**
@@ -352,16 +348,13 @@ public class SdkStore {
       InDevelopment[] inDev = annotatedElement.getAnnotationsByType(InDevelopment.class);
       // Marked in development, sdk is not released, or is the last release (which may still be
       // marked unreleased in g/main aosp/main.
-      if (allowInDev
+      return allowInDev
           && inDev.length > 0
           && (!sdkRelease.isReleased()
               || sdkRelease
                   == AndroidVersions.getReleases().stream()
                       .max(AndroidVersions.AndroidRelease::compareTo)
-                      .get())) {
-        return true;
-      }
-      return false;
+                      .get());
     }
 
     private static boolean typeIsOkForLooseSignatures(
@@ -473,7 +466,7 @@ public class SdkStore {
           inputStreamSupplier =
               () -> {
                 try {
-                  return new FileInputStream(classFile);
+                  return Files.newInputStream(classFile.toPath());
                 } catch (IOException ioe) {
                   throw new RuntimeException("could not read file in path " + working, ioe);
                 }
@@ -517,8 +510,7 @@ public class SdkStore {
       } else {
         signature = "";
       }
-      for (Object aMethod : classNode.methods) {
-        MethodNode method = ((MethodNode) aMethod);
+      for (MethodNode method : classNode.methods) {
         MethodInfo methodInfo = new MethodInfo(method);
         MethodExtraInfo methodExtraInfo = new MethodExtraInfo(method);
         methods.put(methodInfo, methodExtraInfo);
diff --git a/processor/src/main/java/org/robolectric/annotation/processing/validator/Validator.java b/processor/src/main/java/org/robolectric/annotation/processing/validator/Validator.java
index a9cbe379a..0a8e3133d 100644
--- a/processor/src/main/java/org/robolectric/annotation/processing/validator/Validator.java
+++ b/processor/src/main/java/org/robolectric/annotation/processing/validator/Validator.java
@@ -11,7 +11,7 @@ import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.util.AbstractElementVisitor6;
+import javax.lang.model.util.AbstractElementVisitor8;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
@@ -28,7 +28,7 @@ public abstract class Validator implements ElementVisitor<Void, Element> {
   protected final Helpers helpers;
   // This is the easiest way to do it because visit() is final in AbstractEV6
   final ElementVisitor<Void, Element> visitorAdapter =
-      new AbstractElementVisitor6<Void, Element>() {
+      new AbstractElementVisitor8<Void, Element>() {
 
         @Override
         public Void visitPackage(PackageElement e, Element p) {
diff --git a/processor/src/test/java/org/robolectric/annotation/processing/RobolectricProcessorTest.java b/processor/src/test/java/org/robolectric/annotation/processing/RobolectricProcessorTest.java
index 17e2d6340..d57a085ce 100644
--- a/processor/src/test/java/org/robolectric/annotation/processing/RobolectricProcessorTest.java
+++ b/processor/src/test/java/org/robolectric/annotation/processing/RobolectricProcessorTest.java
@@ -49,7 +49,7 @@ public class RobolectricProcessorTest {
                 forSourceString("HelloWorld", "final class HelloWorld {}")))
         .processedWith(new RobolectricProcessor(DEFAULT_OPTS))
         .compilesWithoutError();
-    // .and().generatesNoSources(); Should add this assertion onces
+    // .and().generatesNoSources(); Should add this assertion once
     // it becomes available in compile-testing
   }
 
diff --git a/processor/src/test/java/org/robolectric/annotation/processing/Utils.java b/processor/src/test/java/org/robolectric/annotation/processing/Utils.java
index 3a46ad560..03c3541c2 100644
--- a/processor/src/test/java/org/robolectric/annotation/processing/Utils.java
+++ b/processor/src/test/java/org/robolectric/annotation/processing/Utils.java
@@ -15,11 +15,10 @@ import javax.tools.JavaFileObject;
 public class Utils {
 
   public static final ImmutableMap<String, String> DEFAULT_OPTS =
-      ImmutableMap.<String, String>builder()
-          .put(PACKAGE_OPT, "org.robolectric")
-          .put(JSON_DOCS_DIR, Files.createTempDir().toString())
-          .put(SDK_CHECK_MODE, "OFF")
-          .build();
+      ImmutableMap.of(
+          PACKAGE_OPT, "org.robolectric",
+          JSON_DOCS_DIR, Files.createTempDir().toString(),
+          SDK_CHECK_MODE, "OFF");
 
   public static final JavaFileObject SHADOW_PROVIDER_SOURCE =
       forResource("mock-source/org/robolectric/internal/ShadowProvider.java");
diff --git a/processor/src/test/java/org/robolectric/annotation/processing/generator/ShadowProviderGeneratorTest.java b/processor/src/test/java/org/robolectric/annotation/processing/generator/ShadowProviderGeneratorTest.java
index 6e232628a..bc400cc4e 100644
--- a/processor/src/test/java/org/robolectric/annotation/processing/generator/ShadowProviderGeneratorTest.java
+++ b/processor/src/test/java/org/robolectric/annotation/processing/generator/ShadowProviderGeneratorTest.java
@@ -26,7 +26,7 @@ public class ShadowProviderGeneratorTest {
   private StringWriter writer;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     model = mock(RobolectricModel.class);
     generator =
         new ShadowProviderGenerator(
@@ -35,7 +35,7 @@ public class ShadowProviderGeneratorTest {
   }
 
   @Test
-  public void resettersAreOnlyCalledIfSdkMatches() throws Exception {
+  public void resettersAreOnlyCalledIfSdkMatches() {
     when(model.getVisibleShadowTypes()).thenReturn(Collections.emptyList());
 
     List<ResetterInfo> resetterInfos = new ArrayList<>();
@@ -48,8 +48,8 @@ public class ShadowProviderGeneratorTest {
 
     assertThat(writer.toString())
         .contains(
-            "if (org.robolectric.RuntimeEnvironment.getApiLevel() >= 19"
-                + " && org.robolectric.RuntimeEnvironment.getApiLevel() <= 20)"
+            "if (org.robolectric.RuntimeEnvironment.getApiLevel() >= 19 &&"
+                + " org.robolectric.RuntimeEnvironment.getApiLevel() <= 20)"
                 + " ShadowThing.reset19To20();");
     assertThat(writer.toString())
         .contains(
diff --git a/processor/src/test/java/org/robolectric/annotation/processing/validator/SingleClassSubject.java b/processor/src/test/java/org/robolectric/annotation/processing/validator/SingleClassSubject.java
index c883443ec..8e78d0415 100644
--- a/processor/src/test/java/org/robolectric/annotation/processing/validator/SingleClassSubject.java
+++ b/processor/src/test/java/org/robolectric/annotation/processing/validator/SingleClassSubject.java
@@ -93,9 +93,10 @@ public final class SingleClassSubject extends Subject {
       this.source = source;
     }
 
-    public SingleLineClause withErrorContaining(final String messageFragment) {
+    public SingleLineClause<UnsuccessfulCompilationClause> withErrorContaining(
+        final String messageFragment) {
       try {
-        return new SingleLineClause(unsuccessful.withErrorContaining(messageFragment).in(source));
+        return new SingleLineClause<>(unsuccessful.withErrorContaining(messageFragment).in(source));
       } catch (AssertionError e) {
         failWithoutActual(simpleFact(e.getMessage()));
       }
@@ -120,23 +121,18 @@ public final class SingleClassSubject extends Subject {
       return this;
     }
 
-    final class SingleLineClause implements CompileTester.ChainingClause<SingleFileClause> {
+    final class SingleLineClause<T> implements CompileTester.ChainingClause<SingleFileClause> {
 
-      LineClause lineClause;
+      LineClause<T> lineClause;
 
-      public SingleLineClause(LineClause lineClause) {
+      public SingleLineClause(LineClause<T> lineClause) {
         this.lineClause = lineClause;
       }
 
       public CompileTester.ChainingClause<SingleFileClause> onLine(long lineNumber) {
         try {
           lineClause.onLine(lineNumber);
-          return new CompileTester.ChainingClause<SingleFileClause>() {
-            @Override
-            public SingleFileClause and() {
-              return SingleFileClause.this;
-            }
-          };
+          return () -> SingleFileClause.this;
         } catch (AssertionError e) {
           failWithoutActual(simpleFact(e.getMessage()));
         }
diff --git a/processor/src/test/resources/org/robolectric/Robolectric_ClassNameOnly.java b/processor/src/test/resources/org/robolectric/Robolectric_ClassNameOnly.java
index aa0677465..67b7a1368 100644
--- a/processor/src/test/resources/org/robolectric/Robolectric_ClassNameOnly.java
+++ b/processor/src/test/resources/org/robolectric/Robolectric_ClassNameOnly.java
@@ -1,4 +1,5 @@
 package org.robolectric;
+
 import com.example.objects.AnyObject;
 import com.example.objects.Dummy;
 import java.util.AbstractMap;
@@ -27,11 +28,11 @@ public class Shadows implements ShadowProvider {
   }
 
   public static ShadowClassNameOnly shadowOf(AnyObject actual) {
-    return (ShadowClassNameOnly) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   public static ShadowDummy shadowOf(Dummy actual) {
-    return (ShadowDummy) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   @Override
diff --git a/processor/src/test/resources/org/robolectric/Robolectric_EmptyProvidedPackageNames.java b/processor/src/test/resources/org/robolectric/Robolectric_EmptyProvidedPackageNames.java
index 8ace607ca..9e93e9cb4 100644
--- a/processor/src/test/resources/org/robolectric/Robolectric_EmptyProvidedPackageNames.java
+++ b/processor/src/test/resources/org/robolectric/Robolectric_EmptyProvidedPackageNames.java
@@ -1,4 +1,5 @@
 package org.robolectric;
+
 import com.example.objects.Dummy;
 import java.util.AbstractMap;
 import java.util.ArrayList;
@@ -24,7 +25,7 @@ public class Shadows implements ShadowProvider {
   }
 
   public static ShadowDummy shadowOf(Dummy actual) {
-    return (ShadowDummy) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   @Override
diff --git a/processor/src/test/resources/org/robolectric/Robolectric_HiddenClasses.java b/processor/src/test/resources/org/robolectric/Robolectric_HiddenClasses.java
index 22d484385..03438b3ea 100644
--- a/processor/src/test/resources/org/robolectric/Robolectric_HiddenClasses.java
+++ b/processor/src/test/resources/org/robolectric/Robolectric_HiddenClasses.java
@@ -1,4 +1,5 @@
 package org.robolectric;
+
 import com.example.objects.Dummy;
 import com.example.objects.OuterDummy2;
 import java.util.AbstractMap;
@@ -32,11 +33,11 @@ public class Shadows implements ShadowProvider {
   }
 
   public static ShadowDummy shadowOf(Dummy actual) {
-    return (ShadowDummy) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   public static ShadowOuterDummy2 shadowOf(OuterDummy2 actual) {
-    return (ShadowOuterDummy2) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   @Override
diff --git a/processor/src/test/resources/org/robolectric/Robolectric_InnerClassCollision.java b/processor/src/test/resources/org/robolectric/Robolectric_InnerClassCollision.java
index be993554e..cf4dc9c4e 100644
--- a/processor/src/test/resources/org/robolectric/Robolectric_InnerClassCollision.java
+++ b/processor/src/test/resources/org/robolectric/Robolectric_InnerClassCollision.java
@@ -1,4 +1,5 @@
 package org.robolectric;
+
 import com.example.objects.Dummy;
 import com.example.objects.OuterDummy;
 import com.example.objects.UniqueDummy;
@@ -35,27 +36,27 @@ public class Shadows implements ShadowProvider {
   }
 
   public static ShadowDummy shadowOf(Dummy actual) {
-    return (ShadowDummy) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   public static ShadowOuterDummy shadowOf(OuterDummy actual) {
-    return (ShadowOuterDummy) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   public static ShadowOuterDummy.ShadowInnerDummy shadowOf(OuterDummy.InnerDummy actual) {
-    return (ShadowOuterDummy.ShadowInnerDummy) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   public static ShadowUniqueDummy shadowOf(UniqueDummy actual) {
-    return (ShadowUniqueDummy) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   public static ShadowUniqueDummy.ShadowInnerDummy shadowOf(UniqueDummy.InnerDummy actual) {
-    return (ShadowUniqueDummy.ShadowInnerDummy) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   public static ShadowUniqueInnerDummy shadowOf(UniqueInnerDummy actual) {
-    return (ShadowUniqueInnerDummy) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   @Override
diff --git a/processor/src/test/resources/org/robolectric/Robolectric_MinimalPackages.java b/processor/src/test/resources/org/robolectric/Robolectric_MinimalPackages.java
index 34c3e92f8..55b1c5e20 100644
--- a/processor/src/test/resources/org/robolectric/Robolectric_MinimalPackages.java
+++ b/processor/src/test/resources/org/robolectric/Robolectric_MinimalPackages.java
@@ -1,4 +1,5 @@
 package org.robolectric;
+
 import com.example.objects.AnyObject;
 import com.example.objects.innerpackage.InnerPackageDummy;
 import java.util.AbstractMap;
@@ -31,19 +32,19 @@ public class Shadows implements ShadowProvider {
   }
 
   public static ShadowClassNameOnly shadowOf(AnyObject actual) {
-    return (ShadowClassNameOnly) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   public static ShadowDummy shadowOf(com.example.objects.Dummy actual) {
-    return (ShadowDummy) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   public static ShadowDummy2 shadowOf(org.example.objects.Dummy actual) {
-    return (ShadowDummy2) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   public static ShadowInnerPackageDummy shadowOf(InnerPackageDummy actual) {
-    return (ShadowInnerPackageDummy) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   @Override
diff --git a/processor/src/test/resources/org/robolectric/Robolectric_NoExcludedTypes.java b/processor/src/test/resources/org/robolectric/Robolectric_NoExcludedTypes.java
index b4f5602cb..4c44df31c 100644
--- a/processor/src/test/resources/org/robolectric/Robolectric_NoExcludedTypes.java
+++ b/processor/src/test/resources/org/robolectric/Robolectric_NoExcludedTypes.java
@@ -1,4 +1,5 @@
 package org.robolectric;
+
 import java.util.AbstractMap;
 import java.util.ArrayList;
 import java.util.Collection;
diff --git a/processor/src/test/resources/org/robolectric/Robolectric_Parameterized.java b/processor/src/test/resources/org/robolectric/Robolectric_Parameterized.java
index e4ce5cb3d..a63678502 100644
--- a/processor/src/test/resources/org/robolectric/Robolectric_Parameterized.java
+++ b/processor/src/test/resources/org/robolectric/Robolectric_Parameterized.java
@@ -1,4 +1,5 @@
 package org.robolectric;
+
 import com.example.objects.Dummy;
 import com.example.objects.ParameterizedDummy;
 import java.util.AbstractMap;
@@ -27,11 +28,11 @@ public class Shadows implements ShadowProvider {
   }
 
   public static ShadowDummy shadowOf(Dummy actual) {
-    return (ShadowDummy) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   public static <T,N extends Number> ShadowParameterizedDummy<T,N> shadowOf(ParameterizedDummy<T,N> actual) {
-    return (ShadowParameterizedDummy<T,N>) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   @Override
diff --git a/processor/src/test/resources/org/robolectric/Robolectric_ShadowPickers.java b/processor/src/test/resources/org/robolectric/Robolectric_ShadowPickers.java
index e08db1f34..d290090ca 100644
--- a/processor/src/test/resources/org/robolectric/Robolectric_ShadowPickers.java
+++ b/processor/src/test/resources/org/robolectric/Robolectric_ShadowPickers.java
@@ -1,4 +1,5 @@
 package org.robolectric;
+
 import com.example.objects.OuterDummy.InnerDummy;
 import java.util.AbstractMap;
 import java.util.ArrayList;
@@ -28,10 +29,8 @@ public class Shadows implements ShadowProvider {
             "org.robolectric.annotation.processing.shadows.ShadowInnerDummyWithPicker$ShadowInnerDummyWithPicker3"));
   }
 
-  public static org.robolectric.annotation.processing.shadows.ShadowInnerDummyWithPicker shadowOf(
-      InnerDummy actual) {
-    return (org.robolectric.annotation.processing.shadows.ShadowInnerDummyWithPicker)
-        Shadow.extract(actual);
+  public static ShadowInnerDummyWithPicker shadowOf(InnerDummy actual) {
+    return Shadow.extract(actual);
   }
 
   @Override
diff --git a/resources/build.gradle.kts b/resources/build.gradle.kts
index 56f600b06..c1e0f89b6 100644
--- a/resources/build.gradle.kts
+++ b/resources/build.gradle.kts
@@ -5,7 +5,6 @@ plugins {
 
 dependencies {
   api(project(":utils"))
-  api(project(":annotations"))
   api(project(":pluginapi"))
 
   api(libs.auto.value.annotations)
@@ -14,8 +13,8 @@ dependencies {
 
   testImplementation(libs.junit4)
   testImplementation(libs.truth)
-  testImplementation(libs.compile.testing)
   testImplementation(libs.mockito)
+  testImplementation(libs.mockito.subclass)
 
   annotationProcessor(libs.auto.value)
 }
diff --git a/resources/src/main/java/org/robolectric/RoboSettings.java b/resources/src/main/java/org/robolectric/RoboSettings.java
deleted file mode 100644
index cf7954bfe..000000000
--- a/resources/src/main/java/org/robolectric/RoboSettings.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package org.robolectric;
-
-/**
- * Class that encapsulates reading global configuration options from the Java system properties
- * file.
- *
- * @deprecated Don't put more stuff here.
- */
-@Deprecated
-public class RoboSettings {
-
-  private static boolean useGlobalScheduler;
-
-  static {
-    useGlobalScheduler = Boolean.getBoolean("robolectric.scheduling.global");
-  }
-
-  /**
-   * @deprecated Use PAUSED looper mode.
-   */
-  @Deprecated
-  public static boolean isUseGlobalScheduler() {
-    return useGlobalScheduler;
-  }
-
-  /**
-   * @deprecated Use PAUSED looper mode.
-   */
-  @Deprecated
-  public static void setUseGlobalScheduler(boolean useGlobalScheduler) {
-    RoboSettings.useGlobalScheduler = useGlobalScheduler;
-  }
-}
diff --git a/resources/src/main/java/org/robolectric/manifest/ActivityData.java b/resources/src/main/java/org/robolectric/manifest/ActivityData.java
index fcdcc7adc..b5d93bae7 100644
--- a/resources/src/main/java/org/robolectric/manifest/ActivityData.java
+++ b/resources/src/main/java/org/robolectric/manifest/ActivityData.java
@@ -72,7 +72,7 @@ public class ActivityData {
     return getBooleanAttr(withXMLNS(ALWAYS_RETAIN_TASK_STATE), false);
   }
 
-  public boolean isClearTaskOnLaungh() {
+  public boolean isClearTaskOnLaunch() {
     return getBooleanAttr(withXMLNS(CLEAR_TASK_ON_LAUNCH), false);
   }
 
diff --git a/resources/src/main/java/org/robolectric/manifest/AndroidManifest.java b/resources/src/main/java/org/robolectric/manifest/AndroidManifest.java
index 1a4f7e0d7..b90d9718e 100644
--- a/resources/src/main/java/org/robolectric/manifest/AndroidManifest.java
+++ b/resources/src/main/java/org/robolectric/manifest/AndroidManifest.java
@@ -23,6 +23,8 @@ import org.robolectric.res.Fs;
 import org.robolectric.res.ResourcePath;
 import org.robolectric.res.ResourceTable;
 import org.robolectric.util.Logger;
+import org.robolectric.versioning.AndroidVersions;
+import org.robolectric.versioning.AndroidVersions.AndroidRelease;
 import org.w3c.dom.Document;
 import org.w3c.dom.NamedNodeMap;
 import org.w3c.dom.Node;
@@ -151,12 +153,12 @@ public class AndroidManifest implements UsesSdk {
     return themeRef;
   }
 
-  public String getRClassName() throws Exception {
+  public String getRClassName() {
     parseAndroidManifest();
     return rClassName;
   }
 
-  public Class getRClass() {
+  public Class<?> getRClass() {
     try {
       String rClassName = getRClassName();
       return Class.forName(rClassName);
@@ -218,16 +220,13 @@ public class AndroidManifest implements UsesSdk {
         }
 
         minSdkVersion =
-            getTagAttributeIntValue(manifestDocument, "uses-sdk", "android:minSdkVersion");
+            getTagAttributeSdkIntValue(manifestDocument, "uses-sdk", "android:minSdkVersion");
 
-        String targetSdkText =
-            getTagAttributeText(manifestDocument, "uses-sdk", "android:targetSdkVersion");
-        if (targetSdkText != null) {
-          targetSdkVersion = Integer.parseInt(targetSdkText);
-        }
+        targetSdkVersion =
+            getTagAttributeSdkIntValue(manifestDocument, "uses-sdk", "android:targetSdkVersion");
 
         maxSdkVersion =
-            getTagAttributeIntValue(manifestDocument, "uses-sdk", "android:maxSdkVersion");
+            getTagAttributeSdkIntValue(manifestDocument, "uses-sdk", "android:maxSdkVersion");
         if (processName == null) {
           processName = packageName;
         }
@@ -249,7 +248,7 @@ public class AndroidManifest implements UsesSdk {
                 + "testOptions.unitTests.includeAndroidResources = true to your build.gradle");
       }
 
-      if (packageName == null || packageName.equals("")) {
+      if (packageName == null || packageName.isEmpty()) {
         packageName = "org.robolectric.default";
       }
 
@@ -435,9 +434,6 @@ public class AndroidManifest implements UsesSdk {
     ActivityData targetActivity = null;
     if (isAlias) {
       String targetName = resolveClassRef(activityAttrs.get(ActivityData.getTargetAttr("android")));
-      if (activityName == null) {
-        return;
-      }
       // The target activity should have been parsed already so if it exists we should find it in
       // activityDatas.
       targetActivity = activityDatas.get(targetName);
@@ -569,20 +565,60 @@ public class AndroidManifest implements UsesSdk {
     return children;
   }
 
-  private Integer getTagAttributeIntValue(
-      final Document doc, final String tag, final String attribute) {
-    return getTagAttributeIntValue(doc, tag, attribute, null);
-  }
-
   private Integer getTagAttributeIntValue(
       final Document doc, final String tag, final String attribute, final Integer defaultValue) {
     String valueString = getTagAttributeText(doc, tag, attribute);
     if (valueString != null) {
-      return Integer.parseInt(valueString);
+      Integer result;
+      try {
+        result = Integer.parseInt(valueString);
+      } catch (NumberFormatException e) {
+        result = defaultValue;
+        // for unfinalized releases, try to parse the value as a string.
+        if (attribute.endsWith("minSdkVersion")
+            || attribute.endsWith("maxSdkVersion")
+            || attribute.endsWith("targetSdkVersion")) {
+          int sdkInt = AndroidVersions.computeSdkIntFromShortCode(valueString);
+          if (sdkInt != -1) {
+            result = sdkInt;
+          }
+        }
+      }
+      return result;
     }
     return defaultValue;
   }
 
+  private Integer getTagAttributeSdkIntValue(
+      final Document doc, final String tag, final String attribute) {
+    String sdkString = getTagAttributeText(doc, tag, attribute);
+    if (sdkString != null) {
+      try {
+        return Integer.parseInt(sdkString);
+      } catch (NumberFormatException e) {
+        // for unfinalized releases, try to parse the value as a string.
+        List<AndroidRelease> releasedReleases = AndroidVersions.getReleases();
+        List<AndroidRelease> unreleasedReleases = AndroidVersions.getUnreleased();
+
+        // check the latest release
+        if (!releasedReleases.isEmpty()) {
+          AndroidRelease latestRelease = releasedReleases.get(releasedReleases.size() - 1);
+          if (latestRelease.getShortCode().equals(sdkString)) {
+            return latestRelease.getSdkInt();
+          }
+        } else {
+          // check the unreleased versions
+          for (AndroidRelease release : unreleasedReleases) {
+            if (release.getShortCode().equals(sdkString)) {
+              return release.getSdkInt();
+            }
+          }
+        }
+      }
+    }
+    return null;
+  }
+
   public String getApplicationName() {
     parseAndroidManifest();
     return applicationName;
@@ -665,7 +701,7 @@ public class AndroidManifest implements UsesSdk {
   public Map<String, Object> getApplicationMetaData() {
     parseAndroidManifest();
     if (applicationMetaData == null) {
-      applicationMetaData = new MetaData(Collections.<Node>emptyList());
+      applicationMetaData = new MetaData(Collections.emptyList());
     }
     return applicationMetaData.getValueMap();
   }
@@ -843,21 +879,4 @@ public class AndroidManifest implements UsesSdk {
   public Path getApkFile() {
     return apkFile;
   }
-
-  /**
-   * @deprecated Do not use.
-   */
-  @Deprecated
-  @SuppressWarnings("InlineMeSuggester")
-  public final boolean supportsLegacyResourcesMode() {
-    return true;
-  }
-
-  /**
-   * @deprecated Do not use.
-   */
-  @Deprecated
-  public synchronized boolean supportsBinaryResourcesMode() {
-    return true;
-  }
 }
diff --git a/resources/src/main/java/org/robolectric/manifest/BroadcastReceiverData.java b/resources/src/main/java/org/robolectric/manifest/BroadcastReceiverData.java
index 41539a456..edc962b14 100644
--- a/resources/src/main/java/org/robolectric/manifest/BroadcastReceiverData.java
+++ b/resources/src/main/java/org/robolectric/manifest/BroadcastReceiverData.java
@@ -14,7 +14,7 @@ public class BroadcastReceiverData extends PackageItemData {
 
   private final Map<String, String> attributes;
   private final List<String> actions;
-  private List<IntentFilterData> intentFilters;
+  private final List<IntentFilterData> intentFilters;
 
   public BroadcastReceiverData(
       Map<String, String> attributes, MetaData metaData, List<IntentFilterData> intentFilters) {
@@ -78,6 +78,6 @@ public class BroadcastReceiverData extends PackageItemData {
   }
 
   public boolean isEnabled() {
-    return attributes.containsKey(ENABLED) ? Boolean.parseBoolean(attributes.get(ENABLED)) : true;
+    return !attributes.containsKey(ENABLED) || Boolean.parseBoolean(attributes.get(ENABLED));
   }
 }
diff --git a/resources/src/main/java/org/robolectric/manifest/ContentProviderData.java b/resources/src/main/java/org/robolectric/manifest/ContentProviderData.java
index b1c063a0b..559c3d305 100644
--- a/resources/src/main/java/org/robolectric/manifest/ContentProviderData.java
+++ b/resources/src/main/java/org/robolectric/manifest/ContentProviderData.java
@@ -46,6 +46,6 @@ public class ContentProviderData extends PackageItemData {
   }
 
   public boolean isEnabled() {
-    return attributes.containsKey(ENABLED) ? Boolean.parseBoolean(attributes.get(ENABLED)) : true;
+    return !attributes.containsKey(ENABLED) || Boolean.parseBoolean(attributes.get(ENABLED));
   }
 }
diff --git a/resources/src/main/java/org/robolectric/manifest/IntentFilterData.java b/resources/src/main/java/org/robolectric/manifest/IntentFilterData.java
index d18b44329..81e9bc00a 100644
--- a/resources/src/main/java/org/robolectric/manifest/IntentFilterData.java
+++ b/resources/src/main/java/org/robolectric/manifest/IntentFilterData.java
@@ -93,8 +93,8 @@ public class IntentFilterData {
   }
 
   public static class DataAuthority {
-    private String host;
-    private String port;
+    private final String host;
+    private final String port;
 
     public DataAuthority(String host, String port) {
       this.host = host;
diff --git a/resources/src/main/java/org/robolectric/manifest/MetaData.java b/resources/src/main/java/org/robolectric/manifest/MetaData.java
index 0c7b33d0f..824910e60 100644
--- a/resources/src/main/java/org/robolectric/manifest/MetaData.java
+++ b/resources/src/main/java/org/robolectric/manifest/MetaData.java
@@ -126,7 +126,7 @@ public final class MetaData {
    */
   public static int getColor(String value) {
     if (value != null) {
-      if (value.startsWith("#") == false) {
+      if (!value.startsWith("#")) {
         throw new NumberFormatException(String.format("Color value '%s' must start with #", value));
       }
 
diff --git a/resources/src/main/java/org/robolectric/manifest/PackageItemData.java b/resources/src/main/java/org/robolectric/manifest/PackageItemData.java
index 862b7d78f..f8c7d1bca 100644
--- a/resources/src/main/java/org/robolectric/manifest/PackageItemData.java
+++ b/resources/src/main/java/org/robolectric/manifest/PackageItemData.java
@@ -1,7 +1,5 @@
 package org.robolectric.manifest;
 
-import com.google.errorprone.annotations.InlineMe;
-
 public class PackageItemData {
   protected final String name;
   protected final MetaData metaData;
@@ -15,15 +13,6 @@ public class PackageItemData {
     return name;
   }
 
-  /**
-   * @deprecated - Use {@link #getName()} instead.
-   */
-  @Deprecated
-  @InlineMe(replacement = "this.getName()")
-  public final String getClassName() {
-    return getName();
-  }
-
   public MetaData getMetaData() {
     return metaData;
   }
diff --git a/resources/src/main/java/org/robolectric/manifest/ServiceData.java b/resources/src/main/java/org/robolectric/manifest/ServiceData.java
index 850055358..3d57fc4cd 100644
--- a/resources/src/main/java/org/robolectric/manifest/ServiceData.java
+++ b/resources/src/main/java/org/robolectric/manifest/ServiceData.java
@@ -14,7 +14,7 @@ public class ServiceData extends PackageItemData {
 
   private final Map<String, String> attributes;
   private final List<String> actions;
-  private List<IntentFilterData> intentFilters;
+  private final List<IntentFilterData> intentFilters;
 
   public ServiceData(
       Map<String, String> attributes, MetaData metaData, List<IntentFilterData> intentFilters) {
@@ -71,6 +71,6 @@ public class ServiceData extends PackageItemData {
   }
 
   public boolean isEnabled() {
-    return attributes.containsKey(ENABLED) ? Boolean.parseBoolean(attributes.get(ENABLED)) : true;
+    return !attributes.containsKey(ENABLED) || Boolean.parseBoolean(attributes.get(ENABLED));
   }
 }
diff --git a/resources/src/main/java/org/robolectric/res/Fs.java b/resources/src/main/java/org/robolectric/res/Fs.java
index 5591c9948..63c1cd2b8 100644
--- a/resources/src/main/java/org/robolectric/res/Fs.java
+++ b/resources/src/main/java/org/robolectric/res/Fs.java
@@ -1,9 +1,7 @@
 package org.robolectric.res;
 
-import com.google.errorprone.annotations.InlineMe;
 import java.io.BufferedInputStream;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.MalformedURLException;
@@ -25,6 +23,7 @@ import java.util.Map;
 import java.util.Set;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
+import javax.annotation.Nonnull;
 import javax.annotation.concurrent.GuardedBy;
 import org.robolectric.util.Util;
 
@@ -34,24 +33,6 @@ public abstract class Fs {
   @GuardedBy("ZIP_FILESYSTEMS")
   private static final Map<Path, FsWrapper> ZIP_FILESYSTEMS = new HashMap<>();
 
-  /**
-   * @deprecated Use {@link File#toPath()} instead.
-   */
-  @Deprecated
-  @InlineMe(replacement = "file.toPath()")
-  public static Path newFile(File file) {
-    return file.toPath();
-  }
-
-  /**
-   * @deprecated Use {@link #fromUrl(String)} instead.
-   */
-  @Deprecated
-  @InlineMe(replacement = "Fs.fromUrl(path)", imports = "org.robolectric.res.Fs")
-  public static Path fileFromPath(String path) {
-    return Fs.fromUrl(path);
-  }
-
   public static FileSystem forJar(URL url) {
     return forJar(Paths.get(toUri(url)));
   }
@@ -119,10 +100,6 @@ public abstract class Fs {
   }
 
   public static InputStream getInputStream(Path path) throws IOException {
-    // otherwise we get ClosedByInterruptException, meh
-    if (path.toUri().getScheme().equals("file")) {
-      return new BufferedInputStream(new FileInputStream(path.toFile()));
-    }
     return new BufferedInputStream(Files.newInputStream(path));
   }
 
@@ -252,8 +229,9 @@ public abstract class Fs {
       return delegate.supportedFileAttributeViews();
     }
 
+    @Nonnull
     @Override
-    public Path getPath(String first, String... more) {
+    public Path getPath(@Nonnull String first, @Nonnull String... more) {
       return delegate.getPath(first, more);
     }
 
diff --git a/resources/src/main/java/org/robolectric/res/FsFile.java b/resources/src/main/java/org/robolectric/res/FsFile.java
deleted file mode 100644
index fd4207468..000000000
--- a/resources/src/main/java/org/robolectric/res/FsFile.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.robolectric.res;
-
-import java.nio.file.Path;
-
-/**
- * @deprecated Use {@link Path} instead.
- */
-@Deprecated
-@SuppressWarnings("NewApi")
-public interface FsFile extends Path {
-
-  /**
-   * @deprecated use {@link Fs#externalize(Path)} instead.
-   */
-  @Deprecated
-  default String getPath() {
-    return Fs.externalize(this);
-  }
-
-  /**
-   * @deprecated use {@link Path#resolve(Path)} instead.
-   */
-  @Deprecated
-  default Path join(String name) {
-    return this.resolve(name);
-  }
-}
diff --git a/resources/src/main/java/org/robolectric/res/Qualifiers.java b/resources/src/main/java/org/robolectric/res/Qualifiers.java
index 6faf4c4e3..d916e33bf 100644
--- a/resources/src/main/java/org/robolectric/res/Qualifiers.java
+++ b/resources/src/main/java/org/robolectric/res/Qualifiers.java
@@ -7,20 +7,13 @@ import org.robolectric.res.android.ConfigDescription;
 import org.robolectric.res.android.ResTable_config;
 
 /**
- * Android qualifers as defined by
+ * Android qualifiers as defined by
  * https://developer.android.com/guide/topics/resources/providing-resources.html
  */
 @SuppressWarnings("NewApi")
 public class Qualifiers {
   private static final Pattern DIR_QUALIFIER_PATTERN = Pattern.compile("^[^-]+(?:-([^/]*))?/?$");
 
-  // Matches a version qualifier like "v14". Parentheses capture the numeric
-  // part for easy retrieval with Matcher.group(2).
-  private static final Pattern SCREEN_WIDTH_PATTERN = Pattern.compile("^w([0-9]+)dp");
-  private static final Pattern SMALLEST_SCREEN_WIDTH_PATTERN = Pattern.compile("^sw([0-9]+)dp");
-  private static final Pattern VERSION_QUALIFIER_PATTERN = Pattern.compile("(v)([0-9]+)$");
-  private static final Pattern ORIENTATION_QUALIFIER_PATTERN = Pattern.compile("(land|port)");
-
   private final String qualifiers;
   private final ResTable_config config;
 
@@ -70,93 +63,4 @@ public class Qualifiers {
       return parse(qualifiers != null ? qualifiers : "");
     }
   }
-
-  /**
-   * @deprecated Use {@link android.os.Build.VERSION#SDK_INT} instead.
-   */
-  @Deprecated
-  public static int getPlatformVersion(String qualifiers) {
-    Matcher m = VERSION_QUALIFIER_PATTERN.matcher(qualifiers);
-    if (m.find()) {
-      return Integer.parseInt(m.group(2));
-    }
-    return -1;
-  }
-
-  /**
-   * @deprecated Use {@link android.content.res.Configuration#smallestScreenWidthDp} instead.
-   */
-  @Deprecated
-  public static int getSmallestScreenWidth(String qualifiers) {
-    for (String qualifier : qualifiers.split("-", 0)) {
-      Matcher matcher = SMALLEST_SCREEN_WIDTH_PATTERN.matcher(qualifier);
-      if (matcher.find()) {
-        return Integer.parseInt(matcher.group(1));
-      }
-    }
-
-    return -1;
-  }
-
-  /**
-   * If the Config already has a {@code sw} qualifier, do nothing. Otherwise, add a {@code sw}
-   * qualifier for the given width.
-   *
-   * @deprecated Use {@link android.content.res.Configuration#smallestScreenWidthDp} instead.
-   */
-  @Deprecated
-  public static String addSmallestScreenWidth(String qualifiers, int smallestScreenWidth) {
-    int qualifiersSmallestScreenWidth = Qualifiers.getSmallestScreenWidth(qualifiers);
-    if (qualifiersSmallestScreenWidth == -1) {
-      if (qualifiers.length() > 0) {
-        qualifiers += "-";
-      }
-      qualifiers += "sw" + smallestScreenWidth + "dp";
-    }
-    return qualifiers;
-  }
-
-  /**
-   * @deprecated Use {@link android.content.res.Configuration#screenWidthDp} instead.
-   */
-  @Deprecated
-  public static int getScreenWidth(String qualifiers) {
-    for (String qualifier : qualifiers.split("-", 0)) {
-      Matcher matcher = SCREEN_WIDTH_PATTERN.matcher(qualifier);
-      if (matcher.find()) {
-        return Integer.parseInt(matcher.group(1));
-      }
-    }
-
-    return -1;
-  }
-
-  /**
-   * @deprecated Use {@link android.content.res.Configuration#screenWidthDp} instead.
-   */
-  @Deprecated
-  public static String addScreenWidth(String qualifiers, int screenWidth) {
-    int qualifiersScreenWidth = Qualifiers.getScreenWidth(qualifiers);
-    if (qualifiersScreenWidth == -1) {
-      if (qualifiers.length() > 0) {
-        qualifiers += "-";
-      }
-      qualifiers += "w" + screenWidth + "dp";
-    }
-    return qualifiers;
-  }
-
-  /**
-   * @deprecated Use {@link android.content.res.Configuration#orientation} instead.
-   */
-  @Deprecated
-  public static String getOrientation(String qualifiers) {
-    for (String qualifier : qualifiers.split("-", 0)) {
-      Matcher matcher = ORIENTATION_QUALIFIER_PATTERN.matcher(qualifier);
-      if (matcher.find()) {
-        return matcher.group(1);
-      }
-    }
-    return null;
-  }
 }
diff --git a/resources/src/main/java/org/robolectric/res/ResBundle.java b/resources/src/main/java/org/robolectric/res/ResBundle.java
index 677ba3e8b..748ad9da1 100644
--- a/resources/src/main/java/org/robolectric/res/ResBundle.java
+++ b/resources/src/main/java/org/robolectric/res/ResBundle.java
@@ -29,7 +29,7 @@ public class ResBundle {
 
     public TypedResource pick(ResName resName, ResTable_config toMatch) {
       List<TypedResource> values = map.get(resName);
-      if (values == null || values.size() == 0) return null;
+      if (values == null || values.isEmpty()) return null;
 
       TypedResource bestMatchSoFar = null;
       for (TypedResource candidate : values) {
diff --git a/resources/src/main/java/org/robolectric/res/ResName.java b/resources/src/main/java/org/robolectric/res/ResName.java
index eb3aac2dd..efc6e36b9 100644
--- a/resources/src/main/java/org/robolectric/res/ResName.java
+++ b/resources/src/main/java/org/robolectric/res/ResName.java
@@ -134,9 +134,7 @@ public class ResName {
 
     if (!packageName.equals(resName.packageName)) return false;
     if (!type.equals(resName.type)) return false;
-    if (!name.equals(resName.name)) return false;
-
-    return true;
+    return name.equals(resName.name);
   }
 
   @Override
diff --git a/resources/src/main/java/org/robolectric/res/ResourceIdGenerator.java b/resources/src/main/java/org/robolectric/res/ResourceIdGenerator.java
index e3b1a5c09..4838867c7 100644
--- a/resources/src/main/java/org/robolectric/res/ResourceIdGenerator.java
+++ b/resources/src/main/java/org/robolectric/res/ResourceIdGenerator.java
@@ -7,10 +7,10 @@ import java.util.Map;
 public class ResourceIdGenerator {
 
   private final Map<String, TypeTracker> typeInfo = new HashMap<>();
-  private int packageIdentifier;
+  private final int packageIdentifier;
 
   private static class TypeTracker {
-    private int typeIdentifier;
+    private final int typeIdentifier;
     private int currentMaxEntry;
 
     TypeTracker(int typeIdentifier) {
@@ -49,7 +49,7 @@ public class ResourceIdGenerator {
       typeTracker = new TypeTracker(getNextFreeTypeIdentifier());
       typeInfo.put(type, typeTracker);
     }
-    return ResourceIds.makeIdentifer(
+    return ResourceIds.makeIdentifier(
         packageIdentifier, typeTracker.getTypeIdentifier(), typeTracker.getFreeIdentifier());
   }
 
diff --git a/resources/src/main/java/org/robolectric/res/ResourceIds.java b/resources/src/main/java/org/robolectric/res/ResourceIds.java
index a00602f8b..a8262ff7c 100644
--- a/resources/src/main/java/org/robolectric/res/ResourceIds.java
+++ b/resources/src/main/java/org/robolectric/res/ResourceIds.java
@@ -20,7 +20,7 @@ public class ResourceIds {
     return resId & 0x0000FFFF;
   }
 
-  public static int makeIdentifer(int packageIdentifier, int typeIdentifier, int entryIdenifier) {
-    return packageIdentifier << 24 | typeIdentifier << 16 | entryIdenifier;
+  public static int makeIdentifier(int packageIdentifier, int typeIdentifier, int entryIdentifier) {
+    return packageIdentifier << 24 | typeIdentifier << 16 | entryIdentifier;
   }
 }
diff --git a/resources/src/main/java/org/robolectric/res/ResourceMerger.java b/resources/src/main/java/org/robolectric/res/ResourceMerger.java
index 7d4c4db6f..171e810ad 100644
--- a/resources/src/main/java/org/robolectric/res/ResourceMerger.java
+++ b/resources/src/main/java/org/robolectric/res/ResourceMerger.java
@@ -19,7 +19,6 @@ public class ResourceMerger {
 
     return new ResourceTableFactory()
         .newResourceTable(
-            appManifest.getPackageName(),
-            allResourcePaths.toArray(new ResourcePath[allResourcePaths.size()]));
+            appManifest.getPackageName(), allResourcePaths.toArray(new ResourcePath[0]));
   }
 }
diff --git a/resources/src/main/java/org/robolectric/res/ResourcePath.java b/resources/src/main/java/org/robolectric/res/ResourcePath.java
index 09e43a9bb..1b1745ed6 100644
--- a/resources/src/main/java/org/robolectric/res/ResourcePath.java
+++ b/resources/src/main/java/org/robolectric/res/ResourcePath.java
@@ -2,6 +2,7 @@ package org.robolectric.res;
 
 import java.nio.file.Files;
 import java.nio.file.Path;
+import java.util.Objects;
 
 @SuppressWarnings("NewApi")
 public class ResourcePath {
@@ -53,14 +54,10 @@ public class ResourcePath {
 
     ResourcePath that = (ResourcePath) o;
 
-    if (rClass != null ? !rClass.equals(that.rClass) : that.rClass != null) return false;
-    if (resourceBase != null ? !resourceBase.equals(that.resourceBase) : that.resourceBase != null)
-      return false;
-    if (assetsDir != null ? !assetsDir.equals(that.assetsDir) : that.assetsDir != null)
-      return false;
-    return internalRClass != null
-        ? internalRClass.equals(that.internalRClass)
-        : that.internalRClass == null;
+    if (!Objects.equals(rClass, that.rClass)) return false;
+    if (!Objects.equals(resourceBase, that.resourceBase)) return false;
+    if (!Objects.equals(assetsDir, that.assetsDir)) return false;
+    return Objects.equals(internalRClass, that.internalRClass);
   }
 
   @Override
diff --git a/resources/src/main/java/org/robolectric/res/ResourceRemapper.java b/resources/src/main/java/org/robolectric/res/ResourceRemapper.java
index 2e2a25663..450b28d95 100644
--- a/resources/src/main/java/org/robolectric/res/ResourceRemapper.java
+++ b/resources/src/main/java/org/robolectric/res/ResourceRemapper.java
@@ -22,14 +22,14 @@ import java.util.Map;
  */
 class ResourceRemapper {
 
-  private BiMap<String, Integer> resIds = HashBiMap.create();
-  private ResourceIdGenerator resourceIdGenerator = new ResourceIdGenerator(0x7F);
+  private final BiMap<String, Integer> resIds = HashBiMap.create();
+  private final ResourceIdGenerator resourceIdGenerator = new ResourceIdGenerator(0x7F);
 
   /**
    * @param primaryRClass - An R class (usually the applications) that can be assumed to have a
-   *     complete set of IDs. If this is provided then use the values from this class for
-   *     re-writting all values in follow up calls to {@link #remapRClass(Class)}. If it is not
-   *     provided the ResourceRemapper will generate its own unique non-conflicting IDs.
+   *     complete set of IDs. If this is provided then use the values from this class for re-writing
+   *     all values in follow up calls to {@link #remapRClass(Class)}. If it is not provided the
+   *     ResourceRemapper will generate its own unique non-conflicting IDs.
    */
   ResourceRemapper(Class<?> primaryRClass) {
     if (primaryRClass != null) {
diff --git a/resources/src/main/java/org/robolectric/res/ResourceTableFactory.java b/resources/src/main/java/org/robolectric/res/ResourceTableFactory.java
index 906e2382a..580fc8767 100644
--- a/resources/src/main/java/org/robolectric/res/ResourceTableFactory.java
+++ b/resources/src/main/java/org/robolectric/res/ResourceTableFactory.java
@@ -56,7 +56,7 @@ public class ResourceTableFactory {
   }
 
   private void addRClassValues(PackageResourceTable resourceTable, Class<?> rClass) {
-    for (Class innerClass : rClass.getClasses()) {
+    for (Class<?> innerClass : rClass.getClasses()) {
       String resourceType = innerClass.getSimpleName();
       if (!resourceType.equals("styleable")) {
         for (Field field : innerClass.getDeclaredFields()) {
@@ -88,7 +88,7 @@ public class ResourceTableFactory {
    * field.
    */
   private void addMissingStyleableAttributes(PackageResourceTable resourceTable, Class<?> rClass) {
-    for (Class innerClass : rClass.getClasses()) {
+    for (Class<?> innerClass : rClass.getClasses()) {
       if (innerClass.getSimpleName().equals("styleable")) {
         String styleableName = null; // Current styleable name
         int[] styleableArray = null; // Current styleable value array or references
diff --git a/resources/src/main/java/org/robolectric/res/StaxArrayLoader.java b/resources/src/main/java/org/robolectric/res/StaxArrayLoader.java
index 53b023e13..331460c84 100644
--- a/resources/src/main/java/org/robolectric/res/StaxArrayLoader.java
+++ b/resources/src/main/java/org/robolectric/res/StaxArrayLoader.java
@@ -21,19 +21,17 @@ public class StaxArrayLoader extends StaxLoader {
         "item",
         new NodeHandler() {
           @Override
-          public void onStart(XMLStreamReader xml, XmlContext xmlContext)
-              throws XMLStreamException {
+          public void onStart(XMLStreamReader xml, XmlContext xmlContext) {
             buf.setLength(0);
           }
 
           @Override
-          public void onCharacters(XMLStreamReader xml, XmlContext xmlContext)
-              throws XMLStreamException {
+          public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) {
             buf.append(xml.getText());
           }
 
           @Override
-          public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
+          public void onEnd(XMLStreamReader xml, XmlContext xmlContext) {
             ResType resType =
                 scalarResType == null ? ResType.inferType(buf.toString()) : scalarResType;
             items.add(new TypedResource<>(buf.toString(), resType, xmlContext));
@@ -53,7 +51,7 @@ public class StaxArrayLoader extends StaxLoader {
   }
 
   @Override
-  public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
+  public void onEnd(XMLStreamReader xml, XmlContext xmlContext) {
     resourceTable.addResource(attrType, name, new TypedResource<>(items, resType, xmlContext));
   }
 }
diff --git a/resources/src/main/java/org/robolectric/res/StaxAttrLoader.java b/resources/src/main/java/org/robolectric/res/StaxAttrLoader.java
index 2358a27f9..e91609d7d 100644
--- a/resources/src/main/java/org/robolectric/res/StaxAttrLoader.java
+++ b/resources/src/main/java/org/robolectric/res/StaxAttrLoader.java
@@ -16,12 +16,8 @@ public class StaxAttrLoader extends StaxLoader {
     addHandler(
         "*",
         new NodeHandler() {
-          private String value;
-          private String name;
-
           @Override
-          public void onStart(XMLStreamReader xml, XmlContext xmlContext)
-              throws XMLStreamException {
+          public void onStart(XMLStreamReader xml, XmlContext xmlContext) {
             String type = xml.getLocalName();
             if (pairs.isEmpty()) {
               if (format == null) {
@@ -30,17 +26,16 @@ public class StaxAttrLoader extends StaxLoader {
                 format = format + "|" + type;
               }
             }
-            name = xml.getAttributeValue(null, "name");
-            value = xml.getAttributeValue(null, "value");
+            String name = xml.getAttributeValue(null, "name");
+            String value = xml.getAttributeValue(null, "value");
             pairs.add(new AttrData.Pair(name, value));
           }
 
           @Override
-          public void onCharacters(XMLStreamReader xml, XmlContext xmlContext)
-              throws XMLStreamException {}
+          public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) {}
 
           @Override
-          public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {}
+          public void onEnd(XMLStreamReader xml, XmlContext xmlContext) {}
         });
   }
 
@@ -51,7 +46,7 @@ public class StaxAttrLoader extends StaxLoader {
   }
 
   @Override
-  public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
+  public void onEnd(XMLStreamReader xml, XmlContext xmlContext) {
     AttrData attrData = new AttrData(name, format, new ArrayList<>(pairs));
     pairs.clear();
 
diff --git a/resources/src/main/java/org/robolectric/res/StaxPluralsLoader.java b/resources/src/main/java/org/robolectric/res/StaxPluralsLoader.java
index 53b8d1597..29d5b8e32 100644
--- a/resources/src/main/java/org/robolectric/res/StaxPluralsLoader.java
+++ b/resources/src/main/java/org/robolectric/res/StaxPluralsLoader.java
@@ -20,20 +20,18 @@ public class StaxPluralsLoader extends StaxLoader {
           private final StringBuilder buf = new StringBuilder();
 
           @Override
-          public void onStart(XMLStreamReader xml, XmlContext xmlContext)
-              throws XMLStreamException {
+          public void onStart(XMLStreamReader xml, XmlContext xmlContext) {
             quantity = xml.getAttributeValue(null, "quantity");
             buf.setLength(0);
           }
 
           @Override
-          public void onCharacters(XMLStreamReader xml, XmlContext xmlContext)
-              throws XMLStreamException {
+          public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) {
             buf.append(xml.getText());
           }
 
           @Override
-          public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
+          public void onEnd(XMLStreamReader xml, XmlContext xmlContext) {
             plurals.add(new Plural(quantity, buf.toString()));
           }
 
@@ -50,7 +48,7 @@ public class StaxPluralsLoader extends StaxLoader {
   }
 
   @Override
-  public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
+  public void onEnd(XMLStreamReader xml, XmlContext xmlContext) {
     resourceTable.addResource(
         attrType, name, new PluralRules(new ArrayList<>(plurals), resType, xmlContext));
     plurals.clear();
diff --git a/resources/src/main/java/org/robolectric/res/StaxStyleLoader.java b/resources/src/main/java/org/robolectric/res/StaxStyleLoader.java
index 587ddb716..dec257a56 100644
--- a/resources/src/main/java/org/robolectric/res/StaxStyleLoader.java
+++ b/resources/src/main/java/org/robolectric/res/StaxStyleLoader.java
@@ -17,23 +17,21 @@ public class StaxStyleLoader extends StaxLoader {
         "item",
         new NodeHandler() {
           private String attrName;
-          private StringBuilder buf = new StringBuilder();
+          private final StringBuilder buf = new StringBuilder();
 
           @Override
-          public void onStart(XMLStreamReader xml, XmlContext xmlContext)
-              throws XMLStreamException {
+          public void onStart(XMLStreamReader xml, XmlContext xmlContext) {
             attrName = xml.getAttributeValue(null, "name");
             buf.setLength(0);
           }
 
           @Override
-          public void onCharacters(XMLStreamReader xml, XmlContext xmlContext)
-              throws XMLStreamException {
+          public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) {
             buf.append(xml.getText());
           }
 
           @Override
-          public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
+          public void onEnd(XMLStreamReader xml, XmlContext xmlContext) {
             ResName attrResName =
                 ResName.qualifyResName(attrName, xmlContext.getPackageName(), "attr");
             attributeResources.add(
@@ -50,7 +48,7 @@ public class StaxStyleLoader extends StaxLoader {
   }
 
   @Override
-  public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
+  public void onEnd(XMLStreamReader xml, XmlContext xmlContext) {
     String styleParent = parent;
 
     if (styleParent == null) {
diff --git a/resources/src/main/java/org/robolectric/res/StaxValueLoader.java b/resources/src/main/java/org/robolectric/res/StaxValueLoader.java
index 6b580e656..2cb9eb5dc 100644
--- a/resources/src/main/java/org/robolectric/res/StaxValueLoader.java
+++ b/resources/src/main/java/org/robolectric/res/StaxValueLoader.java
@@ -22,12 +22,12 @@ public class StaxValueLoader extends StaxLoader {
   }
 
   @Override
-  public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
+  public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) {
     buf.append(xml.getText());
   }
 
   @Override
-  public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
+  public void onEnd(XMLStreamReader xml, XmlContext xmlContext) {
     String s = buf.toString();
     if (resType == ResType.CHAR_SEQUENCE) {
       s = StringResources.processStringResources(s);
diff --git a/resources/src/main/java/org/robolectric/res/StyleResolver.java b/resources/src/main/java/org/robolectric/res/StyleResolver.java
index f354fe796..f89078645 100644
--- a/resources/src/main/java/org/robolectric/res/StyleResolver.java
+++ b/resources/src/main/java/org/robolectric/res/StyleResolver.java
@@ -51,8 +51,7 @@ public class StyleResolver implements Style {
 
     // todo: is this tested?
     if (theme != null) {
-      AttributeResource value = theme.getAttrValue(resName);
-      if (value != null) return value;
+      return theme.getAttrValue(resName);
     }
 
     return null;
@@ -99,32 +98,29 @@ public class StyleResolver implements Style {
     TypedResource typedResource = resourceProvider.getValue(styleRef, config);
 
     if (typedResource == null) {
-      StringBuilder builder =
-          new StringBuilder("Could not find any resource")
-              .append(" from reference ")
-              .append(styleRef)
-              .append(" from ")
-              .append(style)
-              .append(" with ")
-              .append(theme);
-      throw new RuntimeException(builder.toString());
+      String builder =
+          "Could not find any resource from reference "
+              + styleRef
+              + " from "
+              + style
+              + " with "
+              + theme;
+      throw new RuntimeException(builder);
     }
 
     Object data = typedResource.getData();
     if (data instanceof StyleData) {
       return (StyleData) data;
     } else {
-      StringBuilder builder =
-          new StringBuilder(styleRef.toString())
-              .append(" does not resolve to a Style.")
-              .append(" got ")
-              .append(data)
-              .append(" instead. ")
-              .append(" from ")
-              .append(style)
-              .append(" with ")
-              .append(theme);
-      throw new RuntimeException(builder.toString());
+      String builder =
+          styleRef
+              + " does not resolve to a Style. got "
+              + data
+              + " instead. from "
+              + style
+              + " with "
+              + theme;
+      throw new RuntimeException(builder);
     }
   }
 
diff --git a/resources/src/main/java/org/robolectric/res/TextCollectingNodeHandler.java b/resources/src/main/java/org/robolectric/res/TextCollectingNodeHandler.java
index 2e2cca117..b7f228dcc 100644
--- a/resources/src/main/java/org/robolectric/res/TextCollectingNodeHandler.java
+++ b/resources/src/main/java/org/robolectric/res/TextCollectingNodeHandler.java
@@ -1,6 +1,5 @@
 package org.robolectric.res;
 
-import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 
 public class TextCollectingNodeHandler extends NodeHandler {
@@ -11,7 +10,7 @@ public class TextCollectingNodeHandler extends NodeHandler {
   }
 
   @Override
-  public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
+  public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) {
     buf.append(xml.getText());
   }
 
diff --git a/resources/src/main/java/org/robolectric/res/ThemeStyleSet.java b/resources/src/main/java/org/robolectric/res/ThemeStyleSet.java
index 75a138108..42b1b75ab 100644
--- a/resources/src/main/java/org/robolectric/res/ThemeStyleSet.java
+++ b/resources/src/main/java/org/robolectric/res/ThemeStyleSet.java
@@ -6,7 +6,7 @@ import java.util.List;
 /** Represents the list of styles applied to a Theme. */
 public class ThemeStyleSet implements Style {
 
-  private List<OverlayedStyle> styles = new ArrayList<>();
+  private final List<OverlayedStyle> styles = new ArrayList<>();
 
   @Override
   public AttributeResource getAttrValue(ResName attrName) {
@@ -44,7 +44,7 @@ public class ThemeStyleSet implements Style {
     if (styles.isEmpty()) {
       return "theme with no applied styles";
     } else {
-      return "theme with applied styles: " + styles + "";
+      return "theme with applied styles: " + styles;
     }
   }
 
diff --git a/resources/src/main/java/org/robolectric/res/android/Asset.java b/resources/src/main/java/org/robolectric/res/android/Asset.java
index 54751b489..19847335b 100644
--- a/resources/src/main/java/org/robolectric/res/android/Asset.java
+++ b/resources/src/main/java/org/robolectric/res/android/Asset.java
@@ -14,6 +14,7 @@ import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.nio.file.Files;
 import java.nio.file.Path;
+import java.util.Locale;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 import org.robolectric.res.FileTypedResource;
@@ -80,7 +81,7 @@ public abstract class Asset {
           return enumMode;
         }
       }
-      throw new IllegalArgumentException("invalid mode " + Integer.toString(mode));
+      throw new IllegalArgumentException("invalid mode " + mode);
     }
   }
 
@@ -320,7 +321,7 @@ public abstract class Asset {
           res.append("    ");
           res.append(cur.getAssetSource());
           long size = (cur.getLength() + 512) / 1024;
-          String buf = String.format(": %dK\n", (int) size);
+          String buf = String.format(Locale.getDefault(), ": %dK\n", (int) size);
           res.append(buf);
         }
         cur = cur.mNext;
@@ -779,7 +780,7 @@ public abstract class Asset {
         // if (ftell(mFp) != mStart + mOffset) {
         try {
           if (mFp.getFilePointer() != mStart + mOffset) {
-            ALOGE("Hosed: %d != %d+%d\n", mFp.getFilePointer(), (long) mStart, (long) mOffset);
+            ALOGE("Hosed: %d != %d+%d\n", mFp.getFilePointer(), mStart, mOffset);
             assert false;
           }
 
@@ -791,8 +792,10 @@ public abstract class Asset {
            * hosed.
            */
           actual = mFp.read(buf, 0, count);
-          if (actual == 0) // something failed -- I/O error?
-          return -1;
+          // something failed -- I/O error?
+          if (actual == 0) {
+            return -1;
+          }
 
           assert (actual == count);
         } catch (IOException e) {
@@ -892,7 +895,7 @@ public abstract class Asset {
           return null;
         }
 
-        ALOGV("Asset %s allocating buffer size %d (smaller than threshold)", this, (int) allocLen);
+        ALOGV("Asset %s allocating buffer size %d (smaller than threshold)", this, allocLen);
         if (mLength > 0) {
           try {
             // long oldPosn = ftell(mFp);
@@ -901,7 +904,7 @@ public abstract class Asset {
             mFp.seek(mStart);
             // if (fread(buf, 1, mLength, mFp) != (size_t) mLength) {
             if (mFp.read(buf, 0, toIntExact(mLength)) != (int) mLength) {
-              ALOGE("failed reading %d bytes\n", (long) mLength);
+              ALOGE("failed reading %d bytes\n", mLength);
               // delete[] buf;
               return null;
             }
@@ -992,7 +995,7 @@ public abstract class Asset {
 
     private static FileDescriptor open(String fname) {
       try {
-        return new FileInputStream(new File(fname)).getFD();
+        return new FileInputStream(fname).getFD();
       } catch (IOException e) {
         return null;
       }
@@ -1313,7 +1316,7 @@ public abstract class Asset {
     @Override
     public byte[] getBuffer(boolean wordAligned) {
       // return mBuf = mMap.getDataPtr();
-      byte[] buf = null;
+      byte[] buf;
 
       if (mBuf != null) return mBuf;
 
diff --git a/resources/src/main/java/org/robolectric/res/android/AssetDir.java b/resources/src/main/java/org/robolectric/res/android/AssetDir.java
index 7fb65e911..87cc33302 100644
--- a/resources/src/main/java/org/robolectric/res/android/AssetDir.java
+++ b/resources/src/main/java/org/robolectric/res/android/AssetDir.java
@@ -128,7 +128,6 @@ public class AssetDir {
       return pVector.indexOf(tmpInfo);
     }
   }
-  ;
 
   /* AssetManager uses this to initialize us */
   void setFileList(SortedVector<FileInfo> list) {
diff --git a/resources/src/main/java/org/robolectric/res/android/AttributeResolution.java b/resources/src/main/java/org/robolectric/res/android/AttributeResolution.java
index 57ab24a8b..84464e283 100644
--- a/resources/src/main/java/org/robolectric/res/android/AttributeResolution.java
+++ b/resources/src/main/java/org/robolectric/res/android/AttributeResolution.java
@@ -40,7 +40,7 @@ public class AttributeResolution {
 
   public static class XmlAttributeFinder {
 
-    private ResXMLParser xmlParser;
+    private final ResXMLParser xmlParser;
 
     public XmlAttributeFinder(ResXMLParser xmlParser) {
       this.xmlParser = xmlParser;
@@ -105,7 +105,7 @@ public class AttributeResolution {
         defStyleRes != 0 ? res.getBagLocked(defStyleRes, defStyleStart, defStyleTypeSetFlags) : -1;
     defStyleTypeSetFlags.set(defStyleTypeSetFlags.get() | defStyleBagTypeSetFlags.get());
     //    const ResTable::bag_entry* const defStyleEnd = defStyleStart + (bagOff >= 0 ? bagOff : 0);
-    final int defStyleEnd = (bagOff >= 0 ? bagOff : 0);
+    final int defStyleEnd = Math.max(bagOff, 0);
     BagAttributeFinder defStyleAttrFinder =
         new BagAttributeFinder(defStyleStart.get(), defStyleEnd);
 
@@ -289,7 +289,6 @@ public class AttributeResolution {
             : -1;
     defStyleTypeSetFlags.set(defStyleTypeSetFlags.get() | defStyleBagTypeSetFlags.get());
     // const ResTable::bag_entry* defStyleAttrEnd = defStyleAttrStart + (bagOff >= 0 ? bagOff : 0);
-    final ResTable.bag_entry defStyleAttrEnd = null;
     // BagAttributeFinder defStyleAttrFinder = new BagAttributeFinder(defStyleAttrStart,
     // defStyleAttrEnd);
     BagAttributeFinder defStyleAttrFinder = new BagAttributeFinder(defStyleAttrStart.get(), bagOff);
@@ -300,7 +299,6 @@ public class AttributeResolution {
     bagOff = style != 0 ? res.getBagLocked(style, styleAttrStart, styleTypeSetFlags) : -1;
     styleTypeSetFlags.set(styleTypeSetFlags.get() | styleBagTypeSetFlags.get());
     // final ResTable::bag_entry* final styleAttrEnd = styleAttrStart + (bagOff >= 0 ? bagOff : 0);
-    final ResTable.bag_entry styleAttrEnd = null;
     // BagAttributeFinder styleAttrFinder = new BagAttributeFinder(styleAttrStart, styleAttrEnd);
     BagAttributeFinder styleAttrFinder = new BagAttributeFinder(styleAttrStart.get(), bagOff);
 
@@ -342,7 +340,7 @@ public class AttributeResolution {
           && value.get().data != Res_value.DATA_NULL_EMPTY) {
         // Walk through the style class values looking for the requested attribute.
         final ResTable.bag_entry styleAttrEntry = styleAttrFinder.find(curIdent);
-        if (styleAttrEntry != styleAttrEnd) {
+        if (styleAttrEntry != null) {
           // We found the attribute we were looking for.
           block = styleAttrEntry.stringBlock;
           typeSetFlags.set(styleTypeSetFlags.get());
@@ -357,7 +355,7 @@ public class AttributeResolution {
           && value.get().data != Res_value.DATA_NULL_EMPTY) {
         // Walk through the default style values looking for the requested attribute.
         final ResTable.bag_entry defStyleAttrEntry = defStyleAttrFinder.find(curIdent);
-        if (defStyleAttrEntry != defStyleAttrEnd) {
+        if (defStyleAttrEntry != null) {
           // We found the attribute we were looking for.
           block = defStyleAttrEntry.stringBlock;
           typeSetFlags.set(styleTypeSetFlags.get());
diff --git a/resources/src/main/java/org/robolectric/res/android/AttributeResolution10.java b/resources/src/main/java/org/robolectric/res/android/AttributeResolution10.java
index 3e5e22ddb..b06f1e626 100644
--- a/resources/src/main/java/org/robolectric/res/android/AttributeResolution10.java
+++ b/resources/src/main/java/org/robolectric/res/android/AttributeResolution10.java
@@ -10,10 +10,9 @@ import org.robolectric.res.android.CppAssetManager2.ResolvedBag.Entry;
 import org.robolectric.res.android.CppAssetManager2.Theme;
 import org.robolectric.res.android.ResourceTypes.Res_value;
 
-// TODO: update paths to released version.
 // transliterated from
-// https://android.googlesource.com/platform/frameworks/base/+/android-10.0.0_rXX/libs/androidfw/AttributeResolution.cpp and
-// https://android.googlesource.com/platform/frameworks/base/+/android-10.0.0_rXX/libs/androidfw/include/androidfw/AttributeResolution.h
+// https://android.googlesource.com/platform/frameworks/base/+/android-10.0.0_r47/libs/androidfw/AttributeResolution.cpp and
+// https://android.googlesource.com/platform/frameworks/base/+/android-10.0.0_r47/libs/androidfw/include/androidfw/AttributeResolution.h
 
 public class AttributeResolution10 {
   public static final boolean kThrowOnBadId = false;
@@ -38,7 +37,7 @@ public class AttributeResolution10 {
 
   public static class XmlAttributeFinder {
 
-    private ResXMLParser xmlParser;
+    private final ResXMLParser xmlParser;
 
     XmlAttributeFinder(ResXMLParser xmlParser) {
       this.xmlParser = xmlParser;
@@ -106,7 +105,7 @@ public class AttributeResolution10 {
           theme, def_style_attr, def_style_res);
     }
 
-    CppAssetManager2 assetmanager = theme.GetAssetManager();
+    CppAssetManager2 assetManager = theme.GetAssetManager();
     ResTable_config config = new ResTable_config();
     Res_value value;
 
@@ -128,7 +127,7 @@ public class AttributeResolution10 {
     // Retrieve the default style bag, if requested.
     ResolvedBag default_style_bag = null;
     if (def_style_res != 0) {
-      default_style_bag = assetmanager.GetBag(def_style_res);
+      default_style_bag = assetManager.GetBag(def_style_res);
       if (default_style_bag != null) {
         def_style_flags.set(def_style_flags.get() | default_style_bag.type_spec_flags);
       }
@@ -173,9 +172,9 @@ public class AttributeResolution10 {
         }
       }
 
-      int resid = 0;
+      int resId = 0;
       final Ref<Res_value> valueRef = new Ref<>(value);
-      final Ref<Integer> residRef = new Ref<>(resid);
+      final Ref<Integer> residRef = new Ref<>(resId);
       final Ref<Integer> type_set_flagsRef = new Ref<>(type_set_flags);
       final Ref<ResTable_config> configRef = new Ref<>(config);
       if (value.dataType != Res_value.TYPE_NULL) {
@@ -197,7 +196,7 @@ public class AttributeResolution10 {
             ALOGI("-> From theme: type=0x%x, data=0x%08x", value.dataType, value.data);
           }
           new_cookie =
-              assetmanager.ResolveReference(
+              assetManager.ResolveReference(
                   new_cookie, valueRef, configRef, type_set_flagsRef, residRef);
           if (new_cookie.intValue() != kInvalidCookie) {
             cookie = new_cookie;
@@ -208,7 +207,7 @@ public class AttributeResolution10 {
         }
       }
       value = valueRef.get();
-      resid = residRef.get();
+      resId = residRef.get();
       type_set_flags = type_set_flagsRef.get();
       config = configRef.get();
 
@@ -229,7 +228,7 @@ public class AttributeResolution10 {
       out_values[destOffset + STYLE_TYPE] = value.dataType;
       out_values[destOffset + STYLE_DATA] = value.data;
       out_values[destOffset + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
-      out_values[destOffset + STYLE_RESOURCE_ID] = resid;
+      out_values[destOffset + STYLE_RESOURCE_ID] = resId;
       out_values[destOffset + STYLE_CHANGING_CONFIGURATIONS] = type_set_flags;
       out_values[destOffset + STYLE_DENSITY] = config.density;
 
@@ -251,7 +250,7 @@ public class AttributeResolution10 {
       Theme theme,
       ResXMLParser xml_parser,
       int def_style_attr,
-      int def_style_resid,
+      int def_style_res_id,
       int[] attrs,
       int attrs_length,
       int[] out_values,
@@ -259,10 +258,10 @@ public class AttributeResolution10 {
     if (kDebugStyles) {
       ALOGI(
           "APPLY STYLE: theme=%s defStyleAttr=0x%x defStyleRes=0x%x xml=%s",
-          theme, def_style_attr, def_style_resid, xml_parser);
+          theme, def_style_attr, def_style_res_id, xml_parser);
     }
 
-    CppAssetManager2 assetmanager = theme.GetAssetManager();
+    CppAssetManager2 assetManager = theme.GetAssetManager();
     final Ref<ResTable_config> config = new Ref<>(new ResTable_config());
     final Ref<Res_value> value = new Ref<>(new Res_value());
 
@@ -273,13 +272,13 @@ public class AttributeResolution10 {
     if (def_style_attr != 0) {
       if (theme.GetAttribute(def_style_attr, value, def_style_flags).intValue() != kInvalidCookie) {
         if (value.get().dataType == DataType.REFERENCE.code()) {
-          def_style_resid = value.get().data;
+          def_style_res_id = value.get().data;
         }
       }
     }
 
     // Retrieve the style resource ID associated with the current XML tag's style attribute.
-    int style_resid = 0;
+    int style_res_id = 0;
     final Ref<Integer> style_flags = new Ref<>(0);
     if (xml_parser != null) {
       int idx = xml_parser.indexOfStyle();
@@ -293,15 +292,15 @@ public class AttributeResolution10 {
         }
 
         if (value.get().dataType == DataType.REFERENCE.code()) {
-          style_resid = value.get().data;
+          style_res_id = value.get().data;
         }
       }
     }
 
     // Retrieve the default style bag, if requested.
     ResolvedBag default_style_bag = null;
-    if (def_style_resid != 0) {
-      default_style_bag = assetmanager.GetBag(def_style_resid);
+    if (def_style_res_id != 0) {
+      default_style_bag = assetManager.GetBag(def_style_res_id);
       if (default_style_bag != null) {
         def_style_flags.set(def_style_flags.get() | default_style_bag.type_spec_flags);
       }
@@ -311,8 +310,8 @@ public class AttributeResolution10 {
 
     // Retrieve the style class bag, if requested.
     ResolvedBag xml_style_bag = null;
-    if (style_resid != 0) {
-      xml_style_bag = assetmanager.GetBag(style_resid);
+    if (style_res_id != 0) {
+      xml_style_bag = assetManager.GetBag(style_res_id);
       if (xml_style_bag != null) {
         style_flags.set(style_flags.get() | xml_style_bag.type_spec_flags);
       }
@@ -337,7 +336,7 @@ public class AttributeResolution10 {
 
       value.set(Res_value.NULL_VALUE);
       config.get().density = 0;
-      int source_style_resid = 0;
+      int source_style_res_id = 0;
 
       // Try to find a value for this attribute...  we prioritize values
       // coming from, first XML attributes, then XML style, then default
@@ -363,7 +362,7 @@ public class AttributeResolution10 {
           cookie = entry.cookie;
           type_set_flags.set(style_flags.get());
           value.set(entry.value);
-          source_style_resid = entry.style;
+          source_style_res_id = entry.style;
           if (kDebugStyles) {
             ALOGI(
                 "-> From style: type=0x%x, data=0x%08x, style=0x%08x",
@@ -387,15 +386,15 @@ public class AttributeResolution10 {
                 "-> From def style: type=0x%x, data=0x%08x, style=0x%08x",
                 value.get().dataType, value.get().data, entry.style);
           }
-          source_style_resid = entry.style;
+          source_style_res_id = entry.style;
         }
       }
 
-      final Ref<Integer> resid = new Ref<>(0);
+      final Ref<Integer> resId = new Ref<>(0);
       if (value.get().dataType != DataType.NULL.code()) {
         // Take care of resolving the found resource to its final value.
         ApkAssetsCookie new_cookie =
-            theme.ResolveAttributeReference(cookie, value, config, type_set_flags, resid);
+            theme.ResolveAttributeReference(cookie, value, config, type_set_flags, resId);
         if (new_cookie.intValue() != kInvalidCookie) {
           cookie = new_cookie;
         }
@@ -411,7 +410,7 @@ public class AttributeResolution10 {
             ALOGI("-> From theme: type=0x%x, data=0x%08x", value.get().dataType, value.get().data);
           }
           new_cookie =
-              assetmanager.ResolveReference(new_cookie, value, config, type_set_flags, resid);
+              assetManager.ResolveReference(new_cookie, value, config, type_set_flags, resId);
           if (new_cookie.intValue() != kInvalidCookie) {
             cookie = new_cookie;
           }
@@ -445,10 +444,10 @@ public class AttributeResolution10 {
       out_values[destIndex + STYLE_TYPE] = res_value.dataType;
       out_values[destIndex + STYLE_DATA] = res_value.data;
       out_values[destIndex + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
-      out_values[destIndex + STYLE_RESOURCE_ID] = resid.get();
+      out_values[destIndex + STYLE_RESOURCE_ID] = resId.get();
       out_values[destIndex + STYLE_CHANGING_CONFIGURATIONS] = type_set_flags.get();
       out_values[destIndex + STYLE_DENSITY] = config.get().density;
-      out_values[destIndex + STYLE_SOURCE_STYLE_RESOURCE_ID] = source_style_resid;
+      out_values[destIndex + STYLE_SOURCE_STYLE_RESOURCE_ID] = source_style_res_id;
 
       if (res_value.dataType != DataType.NULL.code()
           || res_value.data == Res_value.DATA_NULL_EMPTY) {
@@ -462,8 +461,8 @@ public class AttributeResolution10 {
       // if (false && res_value.dataType == DataType.ATTRIBUTE.code()) {
       //   final Ref<ResourceName> attrName = new Ref<>(null);
       //   final Ref<ResourceName> attrRefName = new Ref<>(null);
-      //   boolean gotName = assetmanager.GetResourceName(cur_ident, attrName);
-      //   boolean gotRefName = assetmanager.GetResourceName(res_value.data, attrRefName);
+      //   boolean gotName = assetManager.GetResourceName(cur_ident, attrName);
+      //   boolean gotRefName = assetManager.GetResourceName(res_value.data, attrRefName);
       //   Logger.warn(
       //       "Failed to resolve attribute lookup: %s=\"?%s\"; theme: %s",
       //       gotName ? attrName.get() : "unknown", gotRefName ? attrRefName.get() : "unknown",
@@ -478,7 +477,7 @@ public class AttributeResolution10 {
   }
 
   public static boolean RetrieveAttributes(
-      CppAssetManager2 assetmanager,
+      CppAssetManager2 assetManager,
       ResXMLParser xml_parser,
       int[] attrs,
       int attrs_length,
@@ -518,11 +517,11 @@ public class AttributeResolution10 {
         cur_xml_attr = xml_parser.getAttributeNameResID(ix);
       }
 
-      final Ref<Integer> resid = new Ref<>(0);
+      final Ref<Integer> resId = new Ref<>(0);
       if (value.get().dataType != Res_value.TYPE_NULL) {
         // Take care of resolving the found resource to its final value.
         ApkAssetsCookie new_cookie =
-            assetmanager.ResolveReference(cookie, value, config, type_set_flags, resid);
+            assetManager.ResolveReference(cookie, value, config, type_set_flags, resId);
         if (new_cookie.intValue() != kInvalidCookie) {
           cookie = new_cookie;
         }
@@ -538,7 +537,7 @@ public class AttributeResolution10 {
       out_values[baseDest + STYLE_TYPE] = value.get().dataType;
       out_values[baseDest + STYLE_DATA] = value.get().data;
       out_values[baseDest + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
-      out_values[baseDest + STYLE_RESOURCE_ID] = resid.get();
+      out_values[baseDest + STYLE_RESOURCE_ID] = resId.get();
       out_values[baseDest + STYLE_CHANGING_CONFIGURATIONS] = type_set_flags.get();
       out_values[baseDest + STYLE_DENSITY] = config.get().density;
 
diff --git a/resources/src/main/java/org/robolectric/res/android/AttributeResolution9.java b/resources/src/main/java/org/robolectric/res/android/AttributeResolution9.java
index 529c07d03..4733be7ba 100644
--- a/resources/src/main/java/org/robolectric/res/android/AttributeResolution9.java
+++ b/resources/src/main/java/org/robolectric/res/android/AttributeResolution9.java
@@ -35,7 +35,7 @@ public class AttributeResolution9 {
 
   public static class XmlAttributeFinder {
 
-    private ResXMLParser xmlParser;
+    private final ResXMLParser xmlParser;
 
     XmlAttributeFinder(ResXMLParser xmlParser) {
       this.xmlParser = xmlParser;
@@ -103,7 +103,7 @@ public class AttributeResolution9 {
           theme, def_style_attr, def_style_res);
     }
 
-    CppAssetManager2 assetmanager = theme.GetAssetManager();
+    CppAssetManager2 assetManager = theme.GetAssetManager();
     ResTable_config config = new ResTable_config();
     Res_value value;
 
@@ -125,7 +125,7 @@ public class AttributeResolution9 {
     // Retrieve the default style bag, if requested.
     ResolvedBag default_style_bag = null;
     if (def_style_res != 0) {
-      default_style_bag = assetmanager.GetBag(def_style_res);
+      default_style_bag = assetManager.GetBag(def_style_res);
       if (default_style_bag != null) {
         def_style_flags.set(def_style_flags.get() | default_style_bag.type_spec_flags);
       }
@@ -170,9 +170,9 @@ public class AttributeResolution9 {
         }
       }
 
-      int resid = 0;
+      int resId = 0;
       final Ref<Res_value> valueRef = new Ref<>(value);
-      final Ref<Integer> residRef = new Ref<>(resid);
+      final Ref<Integer> residRef = new Ref<>(resId);
       final Ref<Integer> type_set_flagsRef = new Ref<>(type_set_flags);
       final Ref<ResTable_config> configRef = new Ref<>(config);
       if (value.dataType != Res_value.TYPE_NULL) {
@@ -194,7 +194,7 @@ public class AttributeResolution9 {
             ALOGI("-> From theme: type=0x%x, data=0x%08x", value.dataType, value.data);
           }
           new_cookie =
-              assetmanager.ResolveReference(
+              assetManager.ResolveReference(
                   new_cookie, valueRef, configRef, type_set_flagsRef, residRef);
           if (new_cookie.intValue() != kInvalidCookie) {
             cookie = new_cookie;
@@ -205,7 +205,7 @@ public class AttributeResolution9 {
         }
       }
       value = valueRef.get();
-      resid = residRef.get();
+      resId = residRef.get();
       type_set_flags = type_set_flagsRef.get();
       config = configRef.get();
 
@@ -226,7 +226,7 @@ public class AttributeResolution9 {
       out_values[destOffset + STYLE_TYPE] = value.dataType;
       out_values[destOffset + STYLE_DATA] = value.data;
       out_values[destOffset + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
-      out_values[destOffset + STYLE_RESOURCE_ID] = resid;
+      out_values[destOffset + STYLE_RESOURCE_ID] = resId;
       out_values[destOffset + STYLE_CHANGING_CONFIGURATIONS] = type_set_flags;
       out_values[destOffset + STYLE_DENSITY] = config.density;
 
@@ -248,7 +248,7 @@ public class AttributeResolution9 {
       Theme theme,
       ResXMLParser xml_parser,
       int def_style_attr,
-      int def_style_resid,
+      int def_style_res_id,
       int[] attrs,
       int attrs_length,
       int[] out_values,
@@ -256,10 +256,10 @@ public class AttributeResolution9 {
     if (kDebugStyles) {
       ALOGI(
           "APPLY STYLE: theme=%s defStyleAttr=0x%x defStyleRes=0x%x xml=%s",
-          theme, def_style_attr, def_style_resid, xml_parser);
+          theme, def_style_attr, def_style_res_id, xml_parser);
     }
 
-    CppAssetManager2 assetmanager = theme.GetAssetManager();
+    CppAssetManager2 assetManager = theme.GetAssetManager();
     final Ref<ResTable_config> config = new Ref<>(new ResTable_config());
     final Ref<Res_value> value = new Ref<>(new Res_value());
 
@@ -270,13 +270,13 @@ public class AttributeResolution9 {
     if (def_style_attr != 0) {
       if (theme.GetAttribute(def_style_attr, value, def_style_flags).intValue() != kInvalidCookie) {
         if (value.get().dataType == DataType.REFERENCE.code()) {
-          def_style_resid = value.get().data;
+          def_style_res_id = value.get().data;
         }
       }
     }
 
     // Retrieve the style resource ID associated with the current XML tag's style attribute.
-    int style_resid = 0;
+    int style_res_id = 0;
     final Ref<Integer> style_flags = new Ref<>(0);
     if (xml_parser != null) {
       int idx = xml_parser.indexOfStyle();
@@ -290,15 +290,15 @@ public class AttributeResolution9 {
         }
 
         if (value.get().dataType == DataType.REFERENCE.code()) {
-          style_resid = value.get().data;
+          style_res_id = value.get().data;
         }
       }
     }
 
     // Retrieve the default style bag, if requested.
     ResolvedBag default_style_bag = null;
-    if (def_style_resid != 0) {
-      default_style_bag = assetmanager.GetBag(def_style_resid);
+    if (def_style_res_id != 0) {
+      default_style_bag = assetManager.GetBag(def_style_res_id);
       if (default_style_bag != null) {
         def_style_flags.set(def_style_flags.get() | default_style_bag.type_spec_flags);
       }
@@ -308,8 +308,8 @@ public class AttributeResolution9 {
 
     // Retrieve the style class bag, if requested.
     ResolvedBag xml_style_bag = null;
-    if (style_resid != 0) {
-      xml_style_bag = assetmanager.GetBag(style_resid);
+    if (style_res_id != 0) {
+      xml_style_bag = assetManager.GetBag(style_res_id);
       if (xml_style_bag != null) {
         style_flags.set(style_flags.get() | xml_style_bag.type_spec_flags);
       }
@@ -383,11 +383,11 @@ public class AttributeResolution9 {
         }
       }
 
-      final Ref<Integer> resid = new Ref<>(0);
+      final Ref<Integer> resId = new Ref<>(0);
       if (value.get().dataType != DataType.NULL.code()) {
         // Take care of resolving the found resource to its final value.
         ApkAssetsCookie new_cookie =
-            theme.ResolveAttributeReference(cookie, value, config, type_set_flags, resid);
+            theme.ResolveAttributeReference(cookie, value, config, type_set_flags, resId);
         if (new_cookie.intValue() != kInvalidCookie) {
           cookie = new_cookie;
         }
@@ -403,7 +403,7 @@ public class AttributeResolution9 {
             ALOGI("-> From theme: type=0x%x, data=0x%08x", value.get().dataType, value.get().data);
           }
           new_cookie =
-              assetmanager.ResolveReference(new_cookie, value, config, type_set_flags, resid);
+              assetManager.ResolveReference(new_cookie, value, config, type_set_flags, resId);
           if (new_cookie.intValue() != kInvalidCookie) {
             cookie = new_cookie;
           }
@@ -437,7 +437,7 @@ public class AttributeResolution9 {
       out_values[destIndex + STYLE_TYPE] = res_value.dataType;
       out_values[destIndex + STYLE_DATA] = res_value.data;
       out_values[destIndex + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
-      out_values[destIndex + STYLE_RESOURCE_ID] = resid.get();
+      out_values[destIndex + STYLE_RESOURCE_ID] = resId.get();
       out_values[destIndex + STYLE_CHANGING_CONFIGURATIONS] = type_set_flags.get();
       out_values[destIndex + STYLE_DENSITY] = config.get().density;
 
@@ -453,8 +453,8 @@ public class AttributeResolution9 {
       // if (false && res_value.dataType == DataType.ATTRIBUTE.code()) {
       //   final Ref<ResourceName> attrName = new Ref<>(null);
       //   final Ref<ResourceName> attrRefName = new Ref<>(null);
-      //   boolean gotName = assetmanager.GetResourceName(cur_ident, attrName);
-      //   boolean gotRefName = assetmanager.GetResourceName(res_value.data, attrRefName);
+      //   boolean gotName = assetManager.GetResourceName(cur_ident, attrName);
+      //   boolean gotRefName = assetManager.GetResourceName(res_value.data, attrRefName);
       //   Logger.warn(
       //       "Failed to resolve attribute lookup: %s=\"?%s\"; theme: %s",
       //       gotName ? attrName.get() : "unknown", gotRefName ? attrRefName.get() : "unknown",
@@ -469,7 +469,7 @@ public class AttributeResolution9 {
   }
 
   public static boolean RetrieveAttributes(
-      CppAssetManager2 assetmanager,
+      CppAssetManager2 assetManager,
       ResXMLParser xml_parser,
       int[] attrs,
       int attrs_length,
@@ -509,11 +509,11 @@ public class AttributeResolution9 {
         cur_xml_attr = xml_parser.getAttributeNameResID(ix);
       }
 
-      final Ref<Integer> resid = new Ref<>(0);
+      final Ref<Integer> resId = new Ref<>(0);
       if (value.get().dataType != Res_value.TYPE_NULL) {
         // Take care of resolving the found resource to its final value.
         ApkAssetsCookie new_cookie =
-            assetmanager.ResolveReference(cookie, value, config, type_set_flags, resid);
+            assetManager.ResolveReference(cookie, value, config, type_set_flags, resId);
         if (new_cookie.intValue() != kInvalidCookie) {
           cookie = new_cookie;
         }
@@ -529,7 +529,7 @@ public class AttributeResolution9 {
       out_values[baseDest + STYLE_TYPE] = value.get().dataType;
       out_values[baseDest + STYLE_DATA] = value.get().data;
       out_values[baseDest + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
-      out_values[baseDest + STYLE_RESOURCE_ID] = resid.get();
+      out_values[baseDest + STYLE_RESOURCE_ID] = resId.get();
       out_values[baseDest + STYLE_CHANGING_CONFIGURATIONS] = type_set_flags.get();
       out_values[baseDest + STYLE_DENSITY] = config.get().density;
 
diff --git a/resources/src/main/java/org/robolectric/res/android/Chunk.java b/resources/src/main/java/org/robolectric/res/android/Chunk.java
index 00fb56854..0669a76b3 100644
--- a/resources/src/main/java/org/robolectric/res/android/Chunk.java
+++ b/resources/src/main/java/org/robolectric/res/android/Chunk.java
@@ -71,7 +71,7 @@ class Chunk {
   }
 
   // private:
-  private ResChunk_header device_chunk_;
+  private final ResChunk_header device_chunk_;
 
   public ResTable_header asResTable_header() {
     if (header_size() >= ResTable_header.SIZEOF) {
@@ -153,7 +153,6 @@ class Chunk {
     boolean HasNext() {
       return !HadError() && len_ != 0;
     }
-    ;
 
     // Returns whether there was an error and processing should stop
     boolean HadError() {
diff --git a/resources/src/main/java/org/robolectric/res/android/ConfigDescription.java b/resources/src/main/java/org/robolectric/res/android/ConfigDescription.java
index 553418a44..92fe8aa4b 100644
--- a/resources/src/main/java/org/robolectric/res/android/ConfigDescription.java
+++ b/resources/src/main/java/org/robolectric/res/android/ConfigDescription.java
@@ -48,8 +48,8 @@ public class ConfigDescription {
 
   private static final String kWildcardName = "any";
 
-  private static final Pattern MCC_PATTERN = Pattern.compile("mcc([\\d]+)");
-  private static final Pattern MNC_PATTERN = Pattern.compile("mnc([\\d]+)");
+  private static final Pattern MCC_PATTERN = Pattern.compile("mcc(\\d+)");
+  private static final Pattern MNC_PATTERN = Pattern.compile("mnc(\\d+)");
   private static final Pattern SMALLEST_SCREEN_WIDTH_PATTERN = Pattern.compile("^sw([0-9]+)dp");
   private static final Pattern SCREEN_WIDTH_PATTERN = Pattern.compile("^w([0-9]+)dp");
   private static final Pattern SCREEN_HEIGHT_PATTERN = Pattern.compile("^h([0-9]+)dp");
@@ -74,8 +74,7 @@ public class ConfigDescription {
 
     void set_script(String script_chars) {
       script =
-          String.valueOf(Character.toUpperCase(script_chars.charAt(0)))
-              + script_chars.substring(1).toLowerCase();
+          Character.toUpperCase(script_chars.charAt(0)) + script_chars.substring(1).toLowerCase();
     }
 
     void set_variant(String variant_chars) {
@@ -208,14 +207,14 @@ public class ConfigDescription {
     if (part_iter.hasNext() && parseMcc(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseMnc(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
@@ -228,7 +227,7 @@ public class ConfigDescription {
       } else {
         locale.writeTo(out);
         if (!part_iter.hasNext()) {
-          success = !part_iter.hasNext();
+          success = true;
         }
       }
     }
@@ -236,140 +235,140 @@ public class ConfigDescription {
     if (part_iter.hasNext() && parseLayoutDirection(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseSmallestScreenWidthDp(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseScreenWidthDp(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseScreenHeightDp(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseScreenLayoutSize(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseScreenLayoutLong(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseScreenRound(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseWideColorGamut(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseHdr(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseOrientation(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseUiModeType(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseUiModeNight(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseDensity(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseTouchscreen(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseKeysHidden(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseKeyboard(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseNavHidden(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseNavigation(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseScreenSize(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
     if (part_iter.hasNext() && parseVersion(part_iter.peek(), out)) {
       part_iter.next();
       if (!part_iter.hasNext()) {
-        success = !part_iter.hasNext();
+        success = true;
       }
     }
 
diff --git a/resources/src/main/java/org/robolectric/res/android/CppApkAssets.java b/resources/src/main/java/org/robolectric/res/android/CppApkAssets.java
index 304348cc1..6187b1313 100644
--- a/resources/src/main/java/org/robolectric/res/android/CppApkAssets.java
+++ b/resources/src/main/java/org/robolectric/res/android/CppApkAssets.java
@@ -252,10 +252,9 @@ public class CppApkAssets {
     CppApkAssets loaded_apk = new CppApkAssets(unmanaged_handle.get(), path);
 
     // Find the resource table.
-    String entry_name = kResourcesArsc;
     Ref<ZipEntry> entry = new Ref<>(null);
     // result = FindEntry(loaded_apk.zip_handle_.get(), entry_name, &entry);
-    result = ZipFileRO.FindEntry(loaded_apk.zip_handle_, entry_name, entry);
+    result = ZipFileRO.FindEntry(loaded_apk.zip_handle_, kResourcesArsc, entry);
     if (result != 0) {
       // There is no resources.arsc, so create an empty LoadedArsc and return.
       loaded_apk.loaded_arsc_ = LoadedArsc.CreateEmpty();
@@ -284,10 +283,6 @@ public class CppApkAssets {
                 .order(ByteOrder.LITTLE_ENDIAN),
             0 /*(int) loaded_apk.resources_asset_.getLength()*/);
     loaded_apk.loaded_arsc_ = LoadedArsc.Load(data, loaded_idmap, system, load_as_shared_library);
-    if (loaded_apk.loaded_arsc_ == null) {
-      System.err.println("Failed to load '" + kResourcesArsc + "' in APK '" + path + "'.");
-      return null;
-    }
 
     // Need to force a move for mingw32.
     return loaded_apk;
@@ -308,9 +303,8 @@ public class CppApkAssets {
       return null;
     }
 
-    String name = path;
     ZipEntryRO entry;
-    entry = zipFileRO.findEntryByName(name);
+    entry = zipFileRO.findEntryByName(path);
     // int result = FindEntry(zip_handle_.get(), name, &entry);
     // if (result != 0) {
     //   LOG(ERROR) + "No entry '" + path + "' found in APK '" + path_ + "'";
diff --git a/resources/src/main/java/org/robolectric/res/android/CppAssetManager.java b/resources/src/main/java/org/robolectric/res/android/CppAssetManager.java
index 92cd7b328..2d1f23195 100644
--- a/resources/src/main/java/org/robolectric/res/android/CppAssetManager.java
+++ b/resources/src/main/java/org/robolectric/res/android/CppAssetManager.java
@@ -12,7 +12,6 @@ import static org.robolectric.res.android.Util.LOG_FATAL_IF;
 import static org.robolectric.res.android.Util.isTruthy;
 
 import com.google.common.annotations.VisibleForTesting;
-import com.google.common.base.Preconditions;
 import java.io.File;
 import java.io.IOException;
 import java.lang.ref.WeakReference;
@@ -234,13 +233,12 @@ public class CppAssetManager {
     synchronized (mLock) {
       asset_path ap = new asset_path();
 
-      String8 realPath = path;
       if (kAppZipName != null) {
-        realPath.appendPath(kAppZipName);
+        path.appendPath(kAppZipName);
       }
-      ap.type = getFileType(realPath.string());
+      ap.type = getFileType(path.string());
       if (ap.type == FileType.kFileTypeRegular) {
-        ap.path = realPath;
+        ap.path = path;
       } else {
         ap.path = path;
         ap.type = getFileType(path.string());
@@ -324,7 +322,7 @@ public class CppAssetManager {
   //        // delete idmap;
   //
   //        if (overlayPath != packagePath) {
-  //          ALOGW("idmap file %s inconcistent: expected path %s does not match actual path %s\n",
+  //          ALOGW("idmap file %s inconsistent: expected path %s does not match actual path %s\n",
   //              idmapPath.string(), packagePath.string(), overlayPath.string());
   //          return false;
   //        }
@@ -820,8 +818,7 @@ public class CppAssetManager {
   }
 
   final ResTable getResources(boolean required) {
-    final ResTable rt = getResTable(required);
-    return rt;
+    return getResTable(required);
   }
 
   //  boolean isUpToDate()
@@ -942,9 +939,9 @@ public class CppAssetManager {
    * claims to be a ".gz" but isn't.
    */
   static Asset openAssetFromFileLocked(final String8 pathName, AccessMode mode) {
-    Asset pAsset = null;
+    Asset pAsset;
 
-    if (pathName.getPathExtension().toLowerCase().equals(".gz")) {
+    if (pathName.getPathExtension().equalsIgnoreCase(".gz")) {
       // printf("TRYING '%s'\n", (final char*) pathName);
       pAsset = Asset.createFromCompressedFile(pathName.string(), mode);
     } else {
@@ -963,7 +960,7 @@ public class CppAssetManager {
    */
   static Asset openAssetFromZipLocked(
       final ZipFileRO pZipFile, final ZipEntryRO entry, AccessMode mode, final String8 entryName) {
-    Asset pAsset = null;
+    Asset pAsset;
 
     // TODO: look for previously-created shared memory slice?
     final Ref<Short> method = new Ref<>((short) 0);
@@ -1015,7 +1012,7 @@ public class CppAssetManager {
       final Ref<SortedVector<AssetDir.FileInfo>> pMergedInfo;
 
       LOG_FATAL_IF(mAssetPaths.isEmpty(), "No assets added to AssetManager");
-      Preconditions.checkNotNull(dirName);
+      Objects.requireNonNull(dirName);
 
       // printf("+++ openDir(%s) in '%s'\n", dirName, (final char*) mAssetBase);
 
@@ -1030,7 +1027,7 @@ public class CppAssetManager {
        *
        * We start with Zip archives, then do loose files.
        */
-      pMergedInfo = new Ref<>(new SortedVector<AssetDir.FileInfo>());
+      pMergedInfo = new Ref<>(new SortedVector<>());
 
       int i = mAssetPaths.size();
       while (i > 0) {
@@ -1168,7 +1165,7 @@ public class CppAssetManager {
           // printf("+++ no match on '%s'\n", (final char*) match);
         }
 
-        ALOGD("HEY: size=%d removing %d\n", (int) pContents.size(), i);
+        ALOGD("HEY: size=%d removing %d\n", pContents.size(), i);
         pContents.removeAt(i);
         i--; // adjust "for" loop
         count--; //  and loop limit
@@ -1611,7 +1608,7 @@ public class CppAssetManager {
     @Override
     public String toString() {
       String id = Integer.toString(System.identityHashCode(this), 16);
-      return "SharedZip{mPath='" + mPath + "\', id=0x" + id + "}";
+      return "SharedZip{mPath='" + mPath + "', id=0x" + id + "}";
     }
   }
 
@@ -1773,8 +1770,6 @@ public class CppAssetManager {
         Path path;
         switch (assetPath.type) {
           case kFileTypeDirectory:
-            path = Fs.fromUrl(assetPath.path.string());
-            break;
           case kFileTypeRegular:
             path = Fs.fromUrl(assetPath.path.string());
             break;
diff --git a/resources/src/main/java/org/robolectric/res/android/CppAssetManager2.java b/resources/src/main/java/org/robolectric/res/android/CppAssetManager2.java
index e48d5b90e..b2c05072c 100644
--- a/resources/src/main/java/org/robolectric/res/android/CppAssetManager2.java
+++ b/resources/src/main/java/org/robolectric/res/android/CppAssetManager2.java
@@ -104,7 +104,6 @@ public class CppAssetManager2 {
         return "Entry{" + "key=" + key + ", value=" + value + '}';
       }
     }
-    ;
 
     // Denotes the configuration axis that this bag varies with.
     // If a configuration changes with respect to one of these axis,
@@ -118,7 +117,6 @@ public class CppAssetManager2 {
     // of the Entry structs that follow this structure and avoids a bunch of casts.
     public Entry[] entries;
   }
-  ;
 
   // AssetManager2 is the main entry point for accessing assets and resources.
   // AssetManager2 provides caching of resources retrieved via the underlying ApkAssets.
@@ -136,7 +134,6 @@ public class CppAssetManager2 {
     // public String entry16 = null;
     // int entry_len = 0;
   }
-  ;
 
   public CppAssetManager2() {}
 
@@ -291,9 +288,7 @@ public class CppAssetManager2 {
   void BuildDynamicRefTable() {
     package_groups_.clear();
     //    package_ids_.fill(0xff);
-    for (int i = 0; i < package_ids_.length; i++) {
-      package_ids_[i] = (byte) 0xff;
-    }
+    Arrays.fill(package_ids_, (byte) 0xff);
 
     // 0x01 is reserved for the android package.
     int next_package_id = 0x02;
@@ -640,7 +635,7 @@ public class CppAssetManager2 {
     }
 
     if (!is_valid_resid(resid)) {
-      System.err.println(String.format("Invalid ID 0x%08x.", resid));
+      System.err.printf("Invalid ID 0x%08x.%n", resid);
       return K_INVALID_COOKIE;
     }
 
@@ -650,8 +645,7 @@ public class CppAssetManager2 {
 
     final byte package_idx = package_ids_[package_id];
     if (package_idx == (byte) 0xff) {
-      System.err.println(
-          String.format("No package ID %02x found for ID 0x%08x.", package_id, resid));
+      System.err.printf("No package ID %02x found for ID 0x%08x.%n", package_id, resid);
       return K_INVALID_COOKIE;
     }
 
@@ -685,18 +679,15 @@ public class CppAssetManager2 {
         continue;
       }
 
-      int local_entry_idx = entry_idx;
-
       // If there is an IDMAP supplied with this package, translate the entry ID.
       if (type_spec.idmap_entries != null) {
-        if (!LoadedIdmap.Lookup(
-            type_spec.idmap_entries, local_entry_idx, new Ref<>(local_entry_idx))) {
+        if (!LoadedIdmap.Lookup(type_spec.idmap_entries, entry_idx, new Ref<>(entry_idx))) {
           // There is no mapping, so the resource is not meant to be in this overlay package.
           continue;
         }
       }
 
-      type_flags |= type_spec.GetFlagsForEntryIndex(local_entry_idx);
+      type_flags |= type_spec.GetFlagsForEntryIndex(entry_idx);
 
       // If the package is an overlay, then even configurations that are the same MUST be chosen.
       boolean package_is_overlay = loaded_package.IsOverlay();
@@ -715,7 +706,7 @@ public class CppAssetManager2 {
             // The configuration matches and is better than the previous selection.
             // Find the entry value if it exists for this configuration.
             ResTable_type type_chunk = filtered_group.types.get(i);
-            int offset = LoadedPackage.GetEntryOffset(type_chunk, local_entry_idx);
+            int offset = LoadedPackage.GetEntryOffset(type_chunk, entry_idx);
             if (offset == ResTable_type.NO_ENTRY) {
               continue;
             }
@@ -743,7 +734,7 @@ public class CppAssetManager2 {
                 || (package_is_overlay && this_config.compare(best_config) == 0)) {
               // The configuration matches and is better than the previous selection.
               // Find the entry value if it exists for this configuration.
-              int offset = LoadedPackage.GetEntryOffset(type, local_entry_idx);
+              int offset = LoadedPackage.GetEntryOffset(type, entry_idx);
               if (offset == ResTable_type.NO_ENTRY) {
                 continue;
               }
@@ -873,7 +864,7 @@ public class CppAssetManager2 {
 
     if (isTruthy(dtohl(entry.get().entry.flags) & ResTable_entry.FLAG_COMPLEX)) {
       if (!may_be_bag) {
-        System.err.println(String.format("Resource %08x is a complex map type.", resid));
+        System.err.printf("Resource %08x is a complex map type.%n", resid);
         return K_INVALID_COOKIE;
       }
 
@@ -1030,8 +1021,8 @@ public class CppAssetManager2 {
           // Attributes, arrays, etc don't have a resource id as the name. They specify
           // other data, which would be wrong to change via a lookup.
           if (entry.dynamic_ref_table.lookupResourceId(new_key) != NO_ERROR) {
-            System.err.println(
-                String.format("Failed to resolve key 0x%08x in bag 0x%08x.", new_key.get(), resid));
+            System.err.printf(
+                "Failed to resolve key 0x%08x in bag 0x%08x.%n", new_key.get(), resid);
             return null;
           }
         }
@@ -1046,10 +1037,9 @@ public class CppAssetManager2 {
         int err = entry.dynamic_ref_table.lookupResourceValue(valueRef);
         new_entry_.value = valueRef.get();
         if (err != NO_ERROR) {
-          System.err.println(
-              String.format(
-                  "Failed to resolve value t=0x%02x d=0x%08x for key 0x%08x.",
-                  new_entry_.value.dataType, new_entry_.value.data, new_key.get()));
+          System.err.printf(
+              "Failed to resolve value t=0x%02x d=0x%08x for key 0x%08x.%n",
+              new_entry_.value.dataType, new_entry_.value.data, new_key.get());
           return null;
         }
         // ++new_entry;
@@ -1073,8 +1063,7 @@ public class CppAssetManager2 {
     final ResolvedBag parent_bag = GetBag(parent_resid.get(), child_resids);
     if (parent_bag == null) {
       // Failed to get the parent that should exist.
-      System.err.println(
-          String.format("Failed to find parent 0x%08x of bag 0x%08x.", parent_resid.get(), resid));
+      System.err.printf("Failed to find parent 0x%08x of bag 0x%08x.%n", parent_resid.get(), resid);
       return null;
     }
 
@@ -1101,9 +1090,8 @@ public class CppAssetManager2 {
       final Ref<Integer> child_keyRef = new Ref<>(dtohl(map_entry.name.ident));
       if (!is_internal_resid(child_keyRef.get())) {
         if (entry.dynamic_ref_table.lookupResourceId(child_keyRef) != NO_ERROR) {
-          System.err.println(
-              String.format(
-                  "Failed to resolve key 0x%08x in bag 0x%08x.", child_keyRef.get(), resid));
+          System.err.printf(
+              "Failed to resolve key 0x%08x in bag 0x%08x.%n", child_keyRef.get(), resid);
           return null;
         }
       }
@@ -1128,10 +1116,9 @@ public class CppAssetManager2 {
         int err = entry.dynamic_ref_table.lookupResourceValue(valueRef);
         new_entry_.value = valueRef.get();
         if (err != NO_ERROR) {
-          System.err.println(
-              String.format(
-                  "Failed to resolve value t=0x%02x d=0x%08x for key 0x%08x.",
-                  new_entry_.value.dataType, new_entry_.value.data, child_key));
+          System.err.printf(
+              "Failed to resolve value t=0x%02x d=0x%08x for key 0x%08x.%n",
+              new_entry_.value.dataType, new_entry_.value.data, child_key);
           return null;
         }
 
@@ -1160,8 +1147,7 @@ public class CppAssetManager2 {
       final Ref<Integer> new_key = new Ref<>(map_entry.name.ident);
       if (!is_internal_resid(new_key.get())) {
         if (entry.dynamic_ref_table.lookupResourceId(new_key) != NO_ERROR) {
-          System.err.println(
-              String.format("Failed to resolve key 0x%08x in bag 0x%08x.", new_key.get(), resid));
+          System.err.printf("Failed to resolve key 0x%08x in bag 0x%08x.%n", new_key.get(), resid);
           return null;
         }
       }
@@ -1176,10 +1162,9 @@ public class CppAssetManager2 {
       int err = entry.dynamic_ref_table.lookupResourceValue(valueRef);
       new_entry_.value = valueRef.get();
       if (err != NO_ERROR) {
-        System.err.println(
-            String.format(
-                "Failed to resolve value t=0x%02x d=0x%08x for key 0x%08x.",
-                new_entry_.value.dataType, new_entry_.value.data, new_key.get()));
+        System.err.printf(
+            "Failed to resolve value t=0x%02x d=0x%08x for key 0x%08x.%n",
+            new_entry_.value.dataType, new_entry_.value.data, new_key.get());
         return null;
       }
       // ++map_entry;
@@ -1410,25 +1395,21 @@ public class CppAssetManager2 {
     private final CppAssetManager2 asset_manager_;
     private int type_spec_flags_ = 0;
     //  std.array<std.unique_ptr<Package>, kPackageCount> packages_;
-    private ThemePackage[] packages_ = new ThemePackage[kPackageCount];
+    private final ThemePackage[] packages_ = new ThemePackage[kPackageCount];
 
     public Theme(CppAssetManager2 cppAssetManager2) {
       asset_manager_ = cppAssetManager2;
     }
 
     private static class ThemeEntry {
-      static final int SIZEOF = 8 + Res_value.SIZEOF;
-
       ApkAssetsCookie cookie;
       int type_spec_flags;
       Res_value value;
     }
 
     private static class ThemeType {
-      static final int SIZEOF_WITHOUT_ENTRIES = 8;
-
       int entry_count;
-      ThemeEntry entries[];
+      ThemeEntry[] entries;
     }
 
     //  static final int kPackageCount = std.numeric_limits<byte>.max() + 1;
diff --git a/resources/src/main/java/org/robolectric/res/android/DataType.java b/resources/src/main/java/org/robolectric/res/android/DataType.java
index f9e00a71b..1f4b652eb 100644
--- a/resources/src/main/java/org/robolectric/res/android/DataType.java
+++ b/resources/src/main/java/org/robolectric/res/android/DataType.java
@@ -3,6 +3,7 @@ package org.robolectric.res.android;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.primitives.UnsignedBytes;
+import java.util.HashMap;
 import java.util.Map;
 
 /** Resource type codes. */
@@ -51,11 +52,11 @@ public enum DataType {
   private static final Map<Byte, DataType> FROM_BYTE;
 
   static {
-    ImmutableMap.Builder<Byte, DataType> builder = ImmutableMap.builder();
+    HashMap<Byte, DataType> map = new HashMap<>();
     for (DataType type : values()) {
-      builder.put(type.code(), type);
+      map.put(type.code(), type);
     }
-    FROM_BYTE = builder.build();
+    FROM_BYTE = ImmutableMap.copyOf(map);
   }
 
   DataType(int code) {
diff --git a/resources/src/main/java/org/robolectric/res/android/DynamicRefTable.java b/resources/src/main/java/org/robolectric/res/android/DynamicRefTable.java
index 15eb5b6c4..c8e4ab9fc 100644
--- a/resources/src/main/java/org/robolectric/res/android/DynamicRefTable.java
+++ b/resources/src/main/java/org/robolectric/res/android/DynamicRefTable.java
@@ -140,7 +140,7 @@ public class DynamicRefTable {
       return UNKNOWN_ERROR;
     }
 
-    resId.set((res & 0x00ffffff) | (((int) translatedId) << 24));
+    resId.set((res & 0x00ffffff) | (translatedId << 24));
     return NO_ERROR;
   }
 
diff --git a/resources/src/main/java/org/robolectric/res/android/FileMap.java b/resources/src/main/java/org/robolectric/res/android/FileMap.java
index e633a34cf..0db0dc2fa 100644
--- a/resources/src/main/java/org/robolectric/res/android/FileMap.java
+++ b/resources/src/main/java/org/robolectric/res/android/FileMap.java
@@ -15,6 +15,7 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.io.RandomAccessFile;
 import java.nio.charset.Charset;
+import java.util.HashMap;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipException;
 import java.util.zip.ZipFile;
@@ -193,7 +194,7 @@ public class FileMap {
     // }
     // mBasePtr = ptr;
 
-    mFileName = origFileName != null ? origFileName : null;
+    mFileName = origFileName;
     // mBaseLength = adjLength;
     mDataOffset = offset;
     // mDataPtr = mBasePtr + adjust;
@@ -207,7 +208,7 @@ public class FileMap {
   }
 
   static ImmutableMap<String, Long> guessDataOffsets(File zipFile, int length) {
-    ImmutableMap.Builder<String, Long> result = ImmutableMap.builder();
+    HashMap<String, Long> result = new HashMap<>();
 
     // Parse the zip file entry offsets from the central directory section.
     // See https://en.wikipedia.org/wiki/Zip_(file_format)
@@ -274,7 +275,7 @@ public class FileMap {
         offset += 46 + fileNameLength + extraLength + fieldCommentLength;
       }
 
-      return result.build();
+      return ImmutableMap.copyOf(result);
     } catch (IOException e) {
       throw new RuntimeException(e);
     }
@@ -311,8 +312,7 @@ public class FileMap {
     }
     // scanOffset is now start of end of central directory record
     // the 'offset to central dir' data is at position 16 in the record
-    int offsetToCentralDir = readInt(buffer, scanOffset + 16);
-    return offsetToCentralDir;
+    return readInt(buffer, scanOffset + 16);
   }
 
   private static int findCentralDir64(byte[] buffer) throws IOException {
diff --git a/resources/src/main/java/org/robolectric/res/android/Idmap.java b/resources/src/main/java/org/robolectric/res/android/Idmap.java
index b52d667d1..81db870e5 100644
--- a/resources/src/main/java/org/robolectric/res/android/Idmap.java
+++ b/resources/src/main/java/org/robolectric/res/android/Idmap.java
@@ -12,6 +12,7 @@ import static org.robolectric.res.android.Util.dtohs;
 import static org.robolectric.res.android.Util.logError;
 
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
 import org.robolectric.res.android.ResourceTypes.IdmapEntry_header;
 import org.robolectric.res.android.ResourceTypes.Idmap_header;
@@ -54,7 +55,7 @@ class Idmap {
   // A LoadedIdmap can be set alongside the overlay's LoadedArsc to allow the overlay ApkAssets to
   // masquerade as the target ApkAssets resources.
   static class LoadedIdmap {
-    Idmap_header header_ = null;
+    Idmap_header header_;
     String overlay_apk_path_;
     final Map<Byte, IdmapEntry_header> type_map_ = new HashMap<>();
 
@@ -181,6 +182,7 @@ class Idmap {
         if ((data_size - SIZEOF_CPTR) / SIZEOF_INT < dtohs(entry_header.entry_count)) {
           logError(
               String.format(
+                  Locale.getDefault(),
                   "Idmap too small for the number of entries (%d)",
                   (int) dtohs(entry_header.entry_count)));
           return emptyBraces();
diff --git a/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java b/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java
index 47266325a..9fd4ee5c1 100644
--- a/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java
+++ b/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java
@@ -25,6 +25,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
+import javax.annotation.Nonnull;
 import org.robolectric.res.android.Chunk.Iterator;
 import org.robolectric.res.android.Idmap.LoadedIdmap;
 import org.robolectric.res.android.ResourceTypes.IdmapEntry_header;
@@ -80,7 +81,7 @@ public class LoadedArsc {
     }
 
     String package_name;
-    int package_id = 0;
+    int package_id;
   }
 
   // TypeSpec is going to be immediately proceeded by
@@ -225,7 +226,6 @@ public class LoadedArsc {
     IdmapEntry_header idmap_header_;
     final List<ResTable_type> types_ = new ArrayList<>();
   }
-  ;
 
   //  }  // namespace
 
@@ -603,6 +603,7 @@ public class LoadedArsc {
       return 0;
     }
 
+    @Nonnull
     static LoadedPackage Load(
         Chunk chunk, LoadedIdmap loaded_idmap, boolean system, boolean load_as_shared_library) {
       // ATRACE_NAME("LoadedPackage::Load");
@@ -693,10 +694,6 @@ public class LoadedArsc {
             {
               ResTable_typeSpec type_spec =
                   new ResTable_typeSpec(child_chunk.myBuf(), child_chunk.myOffset());
-              if (type_spec == null) {
-                logError("RES_TABLE_TYPE_SPEC_TYPE too small.");
-                return emptyBraces();
-              }
 
               if (type_spec.id == 0) {
                 logError("RES_TABLE_TYPE_SPEC_TYPE has invalid ID 0.");
@@ -903,7 +900,7 @@ public class LoadedArsc {
 
       // Flatten and construct the TypeSpecs.
       for (Entry<Integer, TypeSpecPtrBuilder> entry : type_builder_map.entrySet()) {
-        byte type_idx = (byte) entry.getKey().byteValue();
+        byte type_idx = entry.getKey().byteValue();
         TypeSpec type_spec_ptr = entry.getValue().Build();
         if (type_spec_ptr == null) {
           logError("Too many type configurations, overflow detected.");
@@ -1061,9 +1058,6 @@ public class LoadedArsc {
 
             LoadedPackage loaded_package =
                 LoadedPackage.Load(child_chunk, loaded_idmap, system_, load_as_shared_library);
-            if (!isTruthy(loaded_package)) {
-              return false;
-            }
             packages_.add(loaded_package);
           }
           break;
@@ -1076,9 +1070,7 @@ public class LoadedArsc {
 
     if (iter.HadError()) {
       logError(iter.GetLastError());
-      if (iter.HadFatalError()) {
-        return false;
-      }
+      return !iter.HadFatalError();
     }
     return true;
   }
@@ -1093,6 +1085,7 @@ public class LoadedArsc {
   // If `load_as_shared_library` is set to true, the application package (0x7f) is treated
   // as a shared library (0x00). When loaded into an AssetManager, the package will be assigned an
   // ID.
+  @Nonnull
   static LoadedArsc Load(
       StringPiece data,
       LoadedIdmap loaded_idmap /* = null */,
diff --git a/resources/src/main/java/org/robolectric/res/android/LocaleData.java b/resources/src/main/java/org/robolectric/res/android/LocaleData.java
index 4ec1be9d2..bab1b54d6 100644
--- a/resources/src/main/java/org/robolectric/res/android/LocaleData.java
+++ b/resources/src/main/java/org/robolectric/res/android/LocaleData.java
@@ -154,9 +154,9 @@ public class LocaleData {
     }
 
     int[] request_ancestors = new int[MAX_PARENT_DEPTH + 1];
-    final Ref<Long> left_right_indexRef = new Ref<Long>(null);
+    final Ref<Long> left_right_indexRef = new Ref<>(null);
     // Find the parents of the request, but stop as soon as we saw left or right
-    final int left_and_right[] = {left, right};
+    final int[] left_and_right = {left, right};
     final int ancestor_count =
         findAncestors(
             request_ancestors, left_right_indexRef,
@@ -177,7 +177,7 @@ public class LocaleData {
     final int right_distance =
         findDistance(right, requested_script, request_ancestors, ancestor_count);
     if (left_distance != right_distance) {
-      return (int) right_distance - (int) left_distance; // smaller distance is better
+      return right_distance - left_distance; // smaller distance is better
     }
     // If we are here, left and right are equidistant from the request. We will
     // try and see if any of them is a representative locale.
@@ -215,7 +215,6 @@ public class LocaleData {
       // We don't know anything about the locale
       //      memset(out, '\0', SCRIPT_LENGTH);
       Arrays.fill(out, (byte) 0);
-      return;
     } else {
       // We found the locale.
       //      memcpy(out, SCRIPT_CODES[lookup_result.second], SCRIPT_LENGTH);
diff --git a/resources/src/main/java/org/robolectric/res/android/NativeObjRegistry.java b/resources/src/main/java/org/robolectric/res/android/NativeObjRegistry.java
index 2b675c1fe..8e27fb1ab 100644
--- a/resources/src/main/java/org/robolectric/res/android/NativeObjRegistry.java
+++ b/resources/src/main/java/org/robolectric/res/android/NativeObjRegistry.java
@@ -1,6 +1,6 @@
 package org.robolectric.res.android;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.collect.BiMap;
 import com.google.common.collect.HashBiMap;
@@ -50,7 +50,7 @@ public class NativeObjRegistry<T> {
    */
   @Deprecated
   public synchronized long getNativeObjectId(T o) {
-    checkNotNull(o);
+    requireNonNull(o);
     Long nativeId = nativeObjToIdMap.inverse().get(o);
     if (nativeId == null) {
       nativeId = nextId;
@@ -69,7 +69,7 @@ public class NativeObjRegistry<T> {
    * @throws IllegalStateException if the object was previously registered
    */
   public synchronized long register(T o) {
-    checkNotNull(o);
+    requireNonNull(o);
     Long nativeId = nativeObjToIdMap.inverse().get(o);
     if (nativeId != null) {
       if (debug) {
diff --git a/resources/src/main/java/org/robolectric/res/android/ResStringPool.java b/resources/src/main/java/org/robolectric/res/android/ResStringPool.java
index 0b6d1e731..7ef379b31 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResStringPool.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResStringPool.java
@@ -31,7 +31,7 @@ import org.robolectric.res.android.ResourceTypes.WithOffset;
 @SuppressWarnings("NewApi")
 public class ResStringPool {
 
-  private static boolean kDebugStringPoolNoisy = false;
+  private static final boolean kDebugStringPoolNoisy = false;
 
   private final long myNativePtr;
 
@@ -163,7 +163,7 @@ public class ResStringPool {
     if (mHeader.header.headerSize > mHeader.header.size || mHeader.header.size > size) {
       ALOGW(
           "Bad string block: header size %d or total size %d is larger than data size %d\n",
-          (int) mHeader.header.headerSize, (int) mHeader.header.size, (int) size);
+          (int) mHeader.header.headerSize, mHeader.header.size, size);
       return (mError = BAD_TYPE);
     }
     mSize = mHeader.header.size;
@@ -174,8 +174,7 @@ public class ResStringPool {
           || (mHeader.header.headerSize + (mHeader.stringCount * 4 /*sizeof(uint32_t)*/)) > size) {
         ALOGW(
             "Bad string block: entry of %d items extends past data size %d\n",
-            (int) (mHeader.header.headerSize + (mHeader.stringCount * 4 /*sizeof(uint32_t)*/)),
-            (int) size);
+            (mHeader.header.headerSize + (mHeader.stringCount * 4 /*sizeof(uint32_t)*/)), size);
         return (mError = BAD_TYPE);
       }
 
@@ -191,7 +190,7 @@ public class ResStringPool {
       if (mHeader.stringsStart >= (mSize - 2 /*sizeof(uint16_t)*/)) {
         ALOGW(
             "Bad string block: string pool starts at %d, after total size %d\n",
-            (int) mHeader.stringsStart, (int) mHeader.header.size);
+            mHeader.stringsStart, mHeader.header.size);
         return (mError = BAD_TYPE);
       }
 
@@ -204,14 +203,14 @@ public class ResStringPool {
         if (mHeader.stylesStart >= (mSize - 2 /*sizeof(uint16_t)*/)) {
           ALOGW(
               "Bad style block: style block starts at %d past data size of %d\n",
-              (int) mHeader.stylesStart, (int) mHeader.header.size);
+              mHeader.stylesStart, mHeader.header.size);
           return (mError = BAD_TYPE);
         }
         // check invariant: styles follow the strings
         if (mHeader.stylesStart <= mHeader.stringsStart) {
           ALOGW(
               "Bad style block: style block starts at %d, before strings at %d\n",
-              (int) mHeader.stylesStart, (int) mHeader.stringsStart);
+              mHeader.stylesStart, mHeader.stringsStart);
           return (mError = BAD_TYPE);
         }
         mStringPoolSize = (mHeader.stylesStart - mHeader.stringsStart) / charSize;
@@ -219,8 +218,7 @@ public class ResStringPool {
 
       // check invariant: stringCount > 0 requires a string pool to exist
       if (mStringPoolSize == 0) {
-        ALOGW(
-            "Bad string block: stringCount is %d but pool size is 0\n", (int) mHeader.stringCount);
+        ALOGW("Bad string block: stringCount is %d but pool size is 0\n", mHeader.stringCount);
         return (mError = BAD_TYPE);
       }
 
@@ -266,17 +264,17 @@ public class ResStringPool {
       }
 
       //      if (((const uint8_t*)mEntryStyles-(const uint8_t*)mHeader) > (int)size) {
-      if ((mEntryStyles.myOffset() - mHeader.myOffset()) > (int) size) {
+      if ((mEntryStyles.myOffset() - mHeader.myOffset()) > size) {
         ALOGW(
             "Bad string block: entry of %d styles extends past data size %d\n",
-            (int) mEntryStyles.myOffset(), (int) size);
+            mEntryStyles.myOffset(), size);
         return (mError = BAD_TYPE);
       }
       mStyles = mHeader.stylesStart;
       if (mHeader.stylesStart >= mHeader.header.size) {
         ALOGW(
             "Bad string block: style pool starts %d, after total size %d\n",
-            (int) mHeader.stylesStart, (int) mHeader.header.size);
+            mHeader.stylesStart, mHeader.header.size);
         return (mError = BAD_TYPE);
       }
       mStylePoolSize = (mHeader.header.size - mHeader.stylesStart) /* / sizeof(uint32_t)*/;
@@ -446,9 +444,7 @@ public class ResStringPool {
       } else {
         ALOGW(
             "Bad string block: string #%d entry is at %d, past end at %d\n",
-            (int) idx,
-            (int) (off * 2 /*sizeof(uint16_t)*/),
-            (int) (mStringPoolSize * 2 /*sizeof(uint16_t)*/));
+            idx, (off * 2 /*sizeof(uint16_t)*/), (mStringPoolSize * 2 /*sizeof(uint16_t)*/));
       }
     }
     return null;
@@ -481,7 +477,7 @@ public class ResStringPool {
       } else {
         ALOGW(
             "Bad string block: style #%d entry is at %d, past end at %d\n",
-            (int) idx, (int) (off * SIZEOF_INT), (int) (mStylePoolSize * SIZEOF_INT));
+            idx, (off * SIZEOF_INT), (mStylePoolSize * SIZEOF_INT));
       }
     }
     return null;
@@ -511,7 +507,7 @@ public class ResStringPool {
         String s = stringAt(mid);
         int c = s != null ? s.compareTo(str) : -1;
         if (kDebugStringPoolNoisy) {
-          ALOGI("Looking at %s, cmp=%d, l/mid/h=%d/%d/%d\n", s, c, (int) l, (int) mid, (int) h);
+          ALOGI("Looking at %s, cmp=%d, l/mid/h=%d/%d/%d\n", s, c, l, mid, h);
         }
         if (c == 0) {
           if (kDebugStringPoolNoisy) {
diff --git a/resources/src/main/java/org/robolectric/res/android/ResTable.java b/resources/src/main/java/org/robolectric/res/android/ResTable.java
index 1b93be631..8ded58491 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResTable.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResTable.java
@@ -195,9 +195,7 @@ public class ResTable {
   int add(ResTable src, boolean isSystemAsset) {
     mError = src.mError;
 
-    for (int i = 0; i < src.mHeaders.size(); i++) {
-      mHeaders.add(src.mHeaders.get(i));
-    }
+    mHeaders.addAll(src.mHeaders);
 
     for (PackageGroup srcPg : src.mPackageGroups.values()) {
       PackageGroup pg =
@@ -208,9 +206,7 @@ public class ResTable {
               false /* appAsLib */,
               isSystemAsset || srcPg.isSystemAsset,
               srcPg.isDynamic);
-      for (int j = 0; j < srcPg.packages.size(); j++) {
-        pg.packages.add(srcPg.packages.get(j));
-      }
+      pg.packages.addAll(srcPg.packages);
 
       for (Integer typeId : srcPg.types.keySet()) {
         List<Type> typeList = computeIfAbsent(pg.types, typeId, key -> new ArrayList<>());
@@ -266,7 +262,7 @@ public class ResTable {
     if (dataSize < ResTable_header.SIZEOF) {
       ALOGE(
           "Invalid data. Size(%d) is smaller than a ResTable_header(%d).",
-          (int) dataSize, (int) ResTable_header.SIZEOF);
+          dataSize, ResTable_header.SIZEOF);
       return UNKNOWN_ERROR;
     }
 
@@ -316,13 +312,13 @@ public class ResTable {
     if (dtohs(header.header.header.headerSize) > header.size || header.size > dataSize) {
       ALOGW(
           "Bad resource table: header size 0x%x or total size 0x%x is larger than data size 0x%x\n",
-          (int) dtohs(header.header.header.headerSize), (int) header.size, (int) dataSize);
+          (int) dtohs(header.header.header.headerSize), header.size, dataSize);
       return (mError = BAD_TYPE);
     }
     if (((dtohs(header.header.header.headerSize) | header.size) & 0x3) != 0) {
       ALOGW(
           "Bad resource table: header size 0x%x or total size 0x%x is not on an integer boundary\n",
-          (int) dtohs(header.header.header.headerSize), (int) header.size);
+          (int) dtohs(header.header.header.headerSize), header.size);
       return (mError = BAD_TYPE);
     }
     //    header->dataEnd = ((const uint8_t*)header->header) + header->size;
@@ -348,7 +344,7 @@ public class ResTable {
             dtohs(chunk.type),
             dtohs(chunk.headerSize),
             dtohl(chunk.size),
-            (Object) (chunk.myOffset() - header.header.myOffset()));
+            chunk.myOffset() - header.header.myOffset());
       }
       final int csize = dtohl(chunk.size);
       final int ctype = dtohs(chunk.type);
@@ -394,7 +390,7 @@ public class ResTable {
     if (curPackage < dtohl(header.header.packageCount)) {
       ALOGW(
           "Fewer package chunks (%d) were found than the %d declared in the header.",
-          (int) curPackage, dtohl(header.header.packageCount));
+          curPackage, dtohl(header.header.packageCount));
       return (mError = BAD_TYPE);
     }
     mError = header.values.getError();
@@ -533,7 +529,7 @@ public class ResTable {
       if (kDebugTableTheme) {
         ALOGI(
             "Resolving reference 0x%x: newIndex=%d, type=0x%x, data=0x%x\n",
-            value.get().data, (int) newIndex, (int) value.get().dataType, value.get().data);
+            value.get().data, newIndex, (int) value.get().dataType, value.get().data);
       }
       // printf("Getting reference 0x%08x: newIndex=%d\n", value.data, newIndex);
       if (inoutTypeSpecFlags != null) {
@@ -623,12 +619,12 @@ public class ResTable {
       // Check that the entry idx is within range of the declared entry count (ResTable_typeSpec).
       // Particular types (ResTable_type) may be encoded with sparse entries, and so their
       // entryCount do not need to match.
-      if (((int) realEntryIndex) >= typeSpec.entryCount) {
+      if (realEntryIndex >= typeSpec.entryCount) {
         ALOGW(
             "For resource 0x%08x, entry index(%d) is beyond type entryCount(%d)",
             Res_MAKEID(packageGroup.id - 1, typeIndex, entryIndex),
             entryIndex,
-            ((int) typeSpec.entryCount));
+            typeSpec.entryCount);
         // We should normally abort here, but some legacy apps declare
         // resources in the 'android' package (old bug in AAPT).
         continue;
@@ -853,7 +849,7 @@ public class ResTable {
       isDynamic = true;
     }
 
-    PackageGroup group = null;
+    PackageGroup group;
     ResTablePackage _package = new ResTablePackage(this, header, pkg);
     if (_package == NULL) {
       return (mError = NO_MEMORY);
@@ -1001,7 +997,7 @@ public class ResTable {
               if (existingType.entryCount != newEntryCount && idmapEntry == null) {
                 ALOGW(
                     "ResTable_typeSpec entry count inconsistent: given %d, previously %d",
-                    (int) newEntryCount, (int) existingType.entryCount);
+                    newEntryCount, existingType.entryCount);
                 // We should normally abort here, but some legacy apps declare
                 // resources in the 'android' package (old bug in AAPT).
               }
@@ -1036,13 +1032,12 @@ public class ResTable {
         final int newEntryCount = dtohl(type.entryCount);
 
         if (kDebugLoadTableNoisy) {
-          System.out.println(
-              String.format(
-                  "Type off 0x%x: type=0x%x, headerSize=0x%x, size=%d\n",
-                  base - chunk.myOffset(),
-                  dtohs(type.header.type),
-                  dtohs(type.header.headerSize),
-                  typeSize));
+          System.out.printf(
+              "Type off 0x%x: type=0x%x, headerSize=0x%x, size=%d\n%n",
+              base - chunk.myOffset(),
+              dtohs(type.header.type),
+              dtohs(type.header.headerSize),
+              typeSize);
         }
         // Check if the table uses compact encoding.
         int bytesPerEntry = isTruthy(type.flags & ResTable_type.FLAG_OFFSET16) ? 2 : 4;
@@ -1327,7 +1322,7 @@ public class ResTable {
     for (PackageGroup group : mPackageGroups.values()) {
       if (!Objects.equals(packageName.trim(), group.name.trim())) {
         if (kDebugTableNoisy) {
-          System.out.println(String.format("Skipping package group: %s\n", group.name));
+          System.out.printf("Skipping package group: %s\n%n", group.name);
         }
         continue;
       }
@@ -2465,8 +2460,8 @@ public class ResTable {
     LOG_FATAL_IF(
         idx >= mPackageGroups.size(),
         "Requested package index %d past package count %d",
-        (int) idx,
-        (int) mPackageGroups.size());
+        idx,
+        mPackageGroups.size());
     return mPackageGroups.get(keyFor(idx)).name;
   }
 
@@ -2477,8 +2472,8 @@ public class ResTable {
     LOG_FATAL_IF(
         idx >= mPackageGroups.size(),
         "Requested package index %d past package count %d",
-        (int) idx,
-        (int) mPackageGroups.size());
+        idx,
+        mPackageGroups.size());
     return mPackageGroups.get(keyFor(idx)).id;
   }
 
@@ -2489,8 +2484,8 @@ public class ResTable {
     LOG_FATAL_IF(
         idx >= mPackageGroups.size(),
         "Requested package index %d past package count %d",
-        (int) idx,
-        (int) mPackageGroups.size());
+        idx,
+        mPackageGroups.size());
     PackageGroup group = mPackageGroups.get(keyFor(idx));
     return group.largestTypeId;
   }
@@ -2559,11 +2554,7 @@ public class ResTable {
       return false;
     }
     outName.name = entry.keyStr.string();
-    if (outName.name == null) {
-      return false;
-    }
-
-    return true;
+    return outName.name != null;
   }
 
   String getResourceName(int resId) {
@@ -2741,7 +2732,6 @@ public class ResTable {
     int[] resourceIDMap;
     int resourceIDMapSize;
   }
-  ;
 
   public static class Entry {
     ResTable_config config;
@@ -2803,7 +2793,6 @@ public class ResTable {
 
     int typeIdOffset;
   }
-  ;
 
   public static class bag_entry {
     public int stringBlock;
@@ -2861,10 +2850,10 @@ public class ResTable {
     }
 
     final int NENTRY = typeConfigs.get(0).entryCount;
-    if (e >= (int) NENTRY) {
+    if (e >= NENTRY) {
       ALOGW(
           "Entry identifier 0x%x is larger than entry count 0x%x",
-          e, (int) typeConfigs.get(0).entryCount);
+          e, typeConfigs.get(0).entryCount);
       return BAD_INDEX;
     }
 
@@ -2953,7 +2942,7 @@ public class ResTable {
       final Ref<bag_entry[]> parentBag = new Ref<>(null);
       final Ref<Integer> parentTypeSpecFlags = new Ref<>(0);
       final int NP = getBagLocked(resolvedParent.get(), parentBag, parentTypeSpecFlags);
-      final int NT = ((NP >= 0) ? NP : 0) + N;
+      final int NT = Math.max(NP, 0) + N;
       set = new bag_set(NT);
       if (NP > 0) {
         set.copyFrom(parentBag.get(), NP);
@@ -3000,7 +2989,7 @@ public class ResTable {
       if (curOff > (dtohl(entry.type.header.size) - ResTable_map.SIZEOF)) {
         ALOGW(
             "ResTable_map at %d is beyond type chunk data %d",
-            (int) curOff, dtohl(entry.type.header.size));
+            curOff, dtohl(entry.type.header.size));
         return BAD_TYPE;
       }
       //      map = (const ResTable_map*)(((const uint8_t*)entry.type) + curOff);
@@ -3014,7 +3003,7 @@ public class ResTable {
         if (grp.dynamicRefTable.lookupResourceId(newName) != NO_ERROR) {
           ALOGE(
               "Failed resolving ResTable_map name at %d with ident 0x%08x",
-              (int) curEntry, (int) newName.get());
+              curEntry, newName.get());
           return UNKNOWN_ERROR;
         }
       }
@@ -3099,7 +3088,6 @@ public class ResTable {
       //      curOff += size + sizeof(*map)-sizeof(map->value);
       curOff += size + ResTable_map.SIZEOF - Res_value.SIZEOF;
     }
-    ;
 
     if (curEntry > set.numAttrs) {
       set.numAttrs = curEntry;
@@ -3137,8 +3125,8 @@ public class ResTable {
     }
 
     public void copyFrom(bag_entry[] parentBag, int count) {
-      for (int i = 0; i < count; i++) {
-        bag_entries[i] = parentBag[i];
+      if (count >= 0) {
+        System.arraycopy(parentBag, 0, bag_entries, 0, count);
       }
     }
 
@@ -3148,7 +3136,6 @@ public class ResTable {
       bag_entries = newEntries;
     }
   }
-  ;
 
   /**
    * Configuration dependent cached data. This must be cleared when the configuration is changed
@@ -3165,7 +3152,6 @@ public class ResTable {
     // ResTable.
     List<List<ResTable_type>> filteredConfigs;
   }
-  ;
 
   private int Res_MAKEID(int packageId, int typeId, int entryId) {
     return (((packageId + 1) << 24) | (((typeId + 1) & 0xFF) << 16) | (entryId & 0xFFFF));
diff --git a/resources/src/main/java/org/robolectric/res/android/ResTableTheme.java b/resources/src/main/java/org/robolectric/res/android/ResTableTheme.java
index 6bfac637c..d7dcc695a 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResTableTheme.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResTableTheme.java
@@ -28,7 +28,7 @@ import org.robolectric.res.android.ResourceTypes.Res_value;
 public class ResTableTheme {
 
   private final List<AppliedStyle> styles = new ArrayList<>();
-  private static boolean styleDebug = false;
+  private static final boolean styleDebug = false;
   private static final type_info EMPTY_TYPE_INFO = new type_info();
   private static final theme_entry EMPTY_THEME_ENTRY = new theme_entry();
 
@@ -54,14 +54,14 @@ public class ResTableTheme {
     if (styles.isEmpty()) {
       return "theme with no applied styles";
     } else {
-      return "theme with applied styles: " + styles + "";
+      return "theme with applied styles: " + styles;
     }
   }
 
-  private ResTable mTable;
-  private boolean kDebugTableTheme = false;
-  private boolean kDebugTableNoisy = false;
-  private package_info[] mPackages = new package_info[Res_MAXPACKAGE];
+  private final ResTable mTable;
+  private final boolean kDebugTableTheme = false;
+  private final boolean kDebugTableNoisy = false;
+  private final package_info[] mPackages = new package_info[Res_MAXPACKAGE];
   private Ref<Integer> mTypeSpecFlags = new Ref<>(0);
 
   public ResTableTheme(ResTable resources) {
@@ -152,7 +152,7 @@ public class ResTableTheme {
       if (kDebugTableTheme) {
         ALOGI(
             "Resolving attr reference: blockIndex=%d, type=0x%x, data=0x%x\n",
-            (int) blockIndex, (int) inOutValue.get().dataType, inOutValue.get().data);
+            blockIndex, (int) inOutValue.get().dataType, inOutValue.get().data);
       }
       if (inoutTypeSpecFlags != null)
         inoutTypeSpecFlags.set(inoutTypeSpecFlags.get() | newTypeSpecFlags.get());
@@ -193,9 +193,8 @@ public class ResTableTheme {
     int numEntries = 0;
     theme_entry[] curEntries = null;
 
-    final int end = N;
     int bagIndex = 0;
-    while (bagIndex < end) {
+    while (bagIndex < N) {
       bag_entry bagEntry = bag.get()[bagIndex];
       final int attrRes = bagEntry.map.name.ident;
       final int p = Res_GETPACKAGE(attrRes);
@@ -377,7 +376,6 @@ public class ResTableTheme {
       }
     }
   }
-  ;
 
   static class type_info {
     int numEntries;
@@ -398,7 +396,6 @@ public class ResTableTheme {
       }
     }
   }
-  ;
 
   static class package_info {
     type_info[] types = new type_info[Res_MAXTYPE + 1];
@@ -416,7 +413,6 @@ public class ResTableTheme {
       }
     }
   }
-  ;
 
   static final int Res_MAXPACKAGE = 255;
   static final int Res_MAXTYPE = 255;
diff --git a/resources/src/main/java/org/robolectric/res/android/ResTable_config.java b/resources/src/main/java/org/robolectric/res/android/ResTable_config.java
index 9778051f9..7c4f5b02f 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResTable_config.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResTable_config.java
@@ -1001,7 +1001,7 @@ public class ResTable_config {
     //    screenHeightDp = htods(screenHeightDp);
   }
 
-  static final int compareLocales(final ResTable_config l, final ResTable_config r) {
+  static int compareLocales(final ResTable_config l, final ResTable_config r) {
     if (l.locale() != r.locale()) {
       // NOTE: This is the old behaviour with respect to comparison orders.
       // The diff value here doesn't make much sense (given our bit packing scheme)
@@ -1014,7 +1014,7 @@ public class ResTable_config {
     // systems should happen very infrequently (if at all.)
     // The comparison code relies on memcmp low-level optimizations that make it
     // more efficient than strncmp.
-    final byte emptyScript[] = {'\0', '\0', '\0', '\0'};
+    final byte[] emptyScript = {'\0', '\0', '\0', '\0'};
     final byte[] lScript = l.localeScriptWasComputed ? emptyScript : l.localeScript;
     final byte[] rScript = r.localeScriptWasComputed ? emptyScript : r.localeScript;
     //    int script = memcmp(lScript, rScript);
@@ -1353,12 +1353,9 @@ public class ResTable_config {
           if (fixedMySL == fixedOSL) {
             // If the two are the same, but 'this' is actually
             // undefined, then the other is really a better match.
-            if (mySL == 0) return false;
-            return true;
-          }
-          if (fixedMySL != fixedOSL) {
-            return fixedMySL > fixedOSL;
+            return mySL != 0;
           }
+          return fixedMySL > fixedOSL;
         }
         if (((screenLayout ^ o.screenLayout) & MASK_SCREENLONG) != 0
             && isTruthy(requested.screenLayout & MASK_SCREENLONG)) {
@@ -1715,9 +1712,7 @@ public class ResTable_config {
       if (sdkVersion != 0 && sdkVersion > settings.sdkVersion) {
         return false;
       }
-      if (minorVersion != 0 && minorVersion != settings.minorVersion) {
-        return false;
-      }
+      return minorVersion == 0 || minorVersion == settings.minorVersion;
     }
     return true;
   }
@@ -1993,8 +1988,7 @@ public class ResTable_config {
       final int size = separator - start;
       state = assignLocaleComponent(this, in.substring(start), size, state);
       if (state.parserState == State.IGNORE_THE_REST) {
-
-        System.err.println(String.format("Invalid BCP-47 locale string: %s", in));
+        System.err.printf("Invalid BCP-47 locale string: %s%n", in);
         break;
       }
 
@@ -2027,9 +2021,7 @@ public class ResTable_config {
   }
 
   private void clear(byte[] bytes) {
-    for (int i = 0; i < bytes.length; i++) {
-      bytes[i] = 0;
-    }
+    Arrays.fill(bytes, (byte) 0);
   }
 
   /**
@@ -2146,7 +2138,7 @@ public class ResTable_config {
       //
       // The exception is that we consider no-language resources a better match
       // for US English and similar locales than locales that are a descendant
-      // of Internatinal English (en-001), since no-language resources are
+      // of International English (en-001), since no-language resources are
       // where the US English resource have traditionally lived for most apps.
       if (areIdentical(requested.language, kEnglish)) {
         if (areIdentical(requested.country, kUnitedStates)) {
@@ -2206,12 +2198,8 @@ public class ResTable_config {
     // Finally, the languages, although equivalent, may still be different
     // (like for Tagalog and Filipino). Identical is better than just
     // equivalent.
-    if (areIdentical(language, requested.language)
-        && !areIdentical(o.language, requested.language)) {
-      return true;
-    }
-
-    return false;
+    return areIdentical(language, requested.language)
+        && !areIdentical(o.language, requested.language);
   }
 
   private String str(byte[] country) {
@@ -2371,7 +2359,7 @@ public class ResTable_config {
       }
       if (minorVersion != o.minorVersion) {
         if (!isTruthy(minorVersion)) return false;
-        if (!isTruthy(o.minorVersion)) return true;
+        return !isTruthy(o.minorVersion);
       }
     }
     return false;
diff --git a/resources/src/main/java/org/robolectric/res/android/ResXMLParser.java b/resources/src/main/java/org/robolectric/res/android/ResXMLParser.java
index 175082ffb..cf34b1c94 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResXMLParser.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResXMLParser.java
@@ -207,7 +207,7 @@ public class ResXMLParser {
     int id = getAttributeNamespaceID(idx);
     // printf("attribute namespace=%d  idx=%d  event=%s\n", id, idx, mEventCode);
     if (kDebugXMLNoisy) {
-      System.out.println(String.format("getAttributeNamespace 0x%x=0x%x\n", idx, id));
+      System.out.printf("getAttributeNamespace 0x%x=0x%x\n%n", idx, id);
     }
     return id >= 0 ? mTree.mStrings.stringAt(id, outLen) : null;
   }
@@ -216,7 +216,7 @@ public class ResXMLParser {
     int id = getAttributeNamespaceID(idx);
     // printf("attribute namespace=%d  idx=%d  event=%s\n", id, idx, mEventCode);
     if (kDebugXMLNoisy) {
-      System.out.println(String.format("getAttributeNamespace 0x%x=0x%x\n", idx, id));
+      System.out.printf("getAttributeNamespace 0x%x=0x%x\n%n", idx, id);
     }
     return id >= 0 ? mTree.mStrings.string8At(id, outLen) : null;
   }
@@ -240,7 +240,7 @@ public class ResXMLParser {
     int id = getAttributeNameID(idx);
     // printf("attribute name=%d  idx=%d  event=%s\n", id, idx, mEventCode);
     if (kDebugXMLNoisy) {
-      System.out.println(String.format("getAttributeName 0x%x=0x%x\n", idx, id));
+      System.out.printf("getAttributeName 0x%x=0x%x\n%n", idx, id);
     }
     return id >= 0 ? mTree.mStrings.stringAt(id, outLen) : null;
   }
@@ -249,14 +249,14 @@ public class ResXMLParser {
     int id = getAttributeNameID(idx);
     // printf("attribute name=%d  idx=%d  event=%s\n", id, idx, mEventCode);
     if (kDebugXMLNoisy) {
-      System.out.println(String.format("getAttributeName 0x%x=0x%x\n", idx, id));
+      System.out.printf("getAttributeName 0x%x=0x%x\n%n", idx, id);
     }
     return id >= 0 ? mTree.mStrings.string8At(id, outLen) : null;
   }
 
   public int getAttributeNameResID(int idx) {
     int id = getAttributeNameID(idx);
-    if (id >= 0 && (int) id < mTree.mNumResIds) {
+    if (id >= 0 && id < mTree.mNumResIds) {
       int resId = dtohl(mTree.mResIds[id]);
       if (mTree.mDynamicRefTable != null) {
         final Ref<Integer> resIdRef = new Ref<>(resId);
@@ -286,7 +286,7 @@ public class ResXMLParser {
   final String getAttributeStringValue(int idx, Ref<Integer> outLen) {
     int id = getAttributeValueStringID(idx);
     if (kDebugXMLNoisy) {
-      System.out.println(String.format("getAttributeValue 0x%x=0x%x\n", idx, id));
+      System.out.printf("getAttributeValue 0x%x=0x%x\n%n", idx, id);
     }
     return id >= 0 ? mTree.mStrings.stringAt(id, outLen) : null;
   }
@@ -358,9 +358,8 @@ public class ResXMLParser {
 
   int indexOfAttribute(final String ns, final String attr) {
     String nsStr = ns != null ? ns : "";
-    String attrStr = attr;
     return indexOfAttribute(
-        isTruthy(ns) ? nsStr : null, isTruthy(ns) ? nsStr.length() : 0, attrStr, attrStr.length());
+        isTruthy(ns) ? nsStr : null, isTruthy(ns) ? nsStr.length() : 0, attr, attr.length());
   }
 
   public int indexOfAttribute(final String ns, int nsLen, final String attr, int attrLen) {
@@ -529,7 +528,7 @@ public class ResXMLParser {
       final int headerSize = dtohs(next.header.headerSize);
       final int totalSize = dtohl(next.header.size);
       mCurExt = next.myOffset() + headerSize;
-      int minExtSize = 0;
+      int minExtSize;
       int eventCode = dtohs(next.header.type);
       switch ((mEventCode = eventCode)) {
         case RES_XML_START_NAMESPACE_TYPE:
@@ -557,8 +556,8 @@ public class ResXMLParser {
             "Bad XML block: header type 0x%x in node at 0x%x has size %d, need %d\n",
             (int) dtohs(next.header.type),
             (next.myOffset() - mTree.mHeader.myOffset()),
-            (int) (totalSize - headerSize),
-            (int) minExtSize);
+            (totalSize - headerSize),
+            minExtSize);
         return (mEventCode = BAD_DOCUMENT);
       }
 
@@ -594,5 +593,4 @@ public class ResXMLParser {
     ResXMLTree_node curNode;
     int curExt;
   }
-  ;
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/ResXMLTree.java b/resources/src/main/java/org/robolectric/res/android/ResXMLTree.java
index a48d893c2..d2c94312b 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResXMLTree.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResXMLTree.java
@@ -102,7 +102,7 @@ public class ResXMLTree {
     if (dtohs(mHeader.header.headerSize) > mSize || mSize > size) {
       ALOGW(
           "Bad XML block: header size %d or total size %d is larger than data size %d\n",
-          (int) dtohs(mHeader.header.headerSize), (int) dtohl(mHeader.header.size), (int) size);
+          (int) dtohs(mHeader.header.headerSize), dtohl(mHeader.header.size), size);
       mError = BAD_TYPE;
       mParser.restart();
       return mError;
@@ -190,7 +190,6 @@ public class ResXMLTree {
 
     mError = mStrings.getError();
 
-    done:
     mParser.restart();
     return mError;
   }
@@ -240,11 +239,9 @@ public class ResXMLTree {
         }
         ALOGW(
             "Bad XML block: node attributes use 0x%x bytes, only have 0x%x bytes\n",
-            (int) (dtohs(attrExt.attributeStart) + attrSize), (int) (size - headerSize));
+            (dtohs(attrExt.attributeStart) + attrSize), (size - headerSize));
       } else {
-        ALOGW(
-            "Bad XML start block: node header size 0x%x, size 0x%x\n",
-            (int) headerSize, (int) size);
+        ALOGW("Bad XML start block: node header size 0x%x, size 0x%x\n", (int) headerSize, size);
       }
       return BAD_TYPE;
     }
diff --git a/resources/src/main/java/org/robolectric/res/android/ResourceString.java b/resources/src/main/java/org/robolectric/res/android/ResourceString.java
index 714592c5a..404d1c5d8 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResourceString.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResourceString.java
@@ -137,7 +137,7 @@ public final class ResourceString {
 
   /** Builds a string from a null-terminated char data. */
   public static String buildString(char[] data) {
-    int count = 0;
+    int count;
     for (count = 0; count < data.length; count++) {
       if (data[count] == 0) {
         break;
diff --git a/resources/src/main/java/org/robolectric/res/android/ResourceTable.java b/resources/src/main/java/org/robolectric/res/android/ResourceTable.java
index 6146763da..34ae65f31 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResourceTable.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResourceTable.java
@@ -14,7 +14,6 @@ public class ResourceTable {
       this.description = description;
     }
   }
-  ;
 
   public static flag_entry[] gFormatFlags = {
     new flag_entry(
diff --git a/resources/src/main/java/org/robolectric/res/android/ResourceTypes.java b/resources/src/main/java/org/robolectric/res/android/ResourceTypes.java
index b6da37e1d..4848c4e8b 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResourceTypes.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResourceTypes.java
@@ -46,7 +46,7 @@ public class ResourceTypes {
         }
         ALOGW(
             "%s size 0x%x or headerSize 0x%x is not on an integer boundary.",
-            name, (int) size, (int) headerSize);
+            name, size, (int) headerSize);
         return BAD_TYPE;
       }
       ALOGW("%s size 0x%x is smaller than header size 0x%x.", name, size, headerSize);
@@ -395,7 +395,6 @@ public class ResourceTypes {
       return "ResTable_ref{ident=" + ident + '}';
     }
   }
-  ;
 
   /** Reference to a string in a string pool. */
   public static class ResStringPool_ref {
@@ -624,7 +623,6 @@ public class ResourceTypes {
       return name.index == END && firstChar == END && lastChar == END;
     }
   }
-  ;
 
   /**
    * ******************************************************************** XML Tree
@@ -701,7 +699,6 @@ public class ResourceTypes {
           contents);
     }
   }
-  ;
 
   /**
    * Extended XML tree node for CDATA tags -- includes the CDATA string. Appears header.headerSize
@@ -722,7 +719,6 @@ public class ResourceTypes {
       this.typedData = new Res_value((byte) dataType, data);
     }
   }
-  ;
 
   /**
    * Extended XML tree node for namespace start/end nodes. Appears header.headerSize bytes after a
@@ -740,7 +736,6 @@ public class ResourceTypes {
       this.uri = new ResStringPool_ref(buf, offset + 4);
     }
   }
-  ;
 
   /**
    * Extended XML tree node for element start/end nodes. Appears header.headerSize bytes after a
@@ -779,7 +774,6 @@ public class ResourceTypes {
       }
     }
   }
-  ;
 
   /**
    * Extended XML tree node for start tags -- includes attribute information. Appears
@@ -916,7 +910,6 @@ public class ResourceTypes {
       }
     }
   }
-  ;
 
   static class ResXMLTree_attribute {
     public static final int SIZEOF = 12 + ResourceTypes.Res_value.SIZEOF;
@@ -948,7 +941,6 @@ public class ResourceTypes {
       ResourceTypes.Res_value.write(buf, resValueDataType, resValueData);
     }
   }
-  ;
 
   /**
    * ******************************************************************** RESOURCE TABLE
@@ -1029,7 +1021,6 @@ public class ResourceTypes {
       typeIdOffset = buf.getInt(offset + ResChunk_header.SIZEOF + 4 + 256 + 16);
     }
   }
-  ;
 
   // The most specific locale can consist of:
   //
@@ -1099,7 +1090,6 @@ public class ResourceTypes {
       return ints;
     }
   }
-  ;
 
   /**
    * A collection of resource entries for a particular resource data type.
@@ -1112,7 +1102,7 @@ public class ResourceTypes {
    * <p>If the flag FLAG_SPARSE is set in `flags`, then this struct is followed by an array of
    * ResTable_sparseTypeEntry defining only the entries that have values for this type. Each entry
    * is sorted by their entry ID such that a binary search can be performed over the entries. The ID
-   * and offset are encoded in a uint32_t. See ResTabe_sparseTypeEntry.
+   * and offset are encoded in a uint32_t. See ResTable_sparseTypeEntry.
    *
    * <p>There may be multiple of these chunks for a particular resource type, supply different
    * configuration variations for the resource values of that type.
@@ -1240,7 +1230,6 @@ public class ResourceTypes {
       return dtohl(byteBuffer.getInt(offset + entriesStart + entryOffset + STRING_POOL_REF_OFFSET));
     }
   }
-  ;
 
   // The minimum size required to read any version of ResTable_type.
   //   constexpr size_t kResTableTypeMinSize =
@@ -1275,7 +1264,6 @@ public class ResourceTypes {
       this.offset = buf.getShort(offset + 2);
     }
   }
-  ;
 
   /**
    * This is the beginning of information about an entry in the resource table. It holds the
@@ -1295,7 +1283,7 @@ public class ResourceTypes {
     // If set, this resource has been declared public, so libraries
     // are allowed to reference it.
     public static final int FLAG_PUBLIC = 0x0002;
-    // If set, this is a weak resource and may be overriden by strong
+    // If set, this is a weak resource and may be overridden by strong
     // resources of the same name/type. This is only useful during
     // linking with other resource tables.
     public static final int FLAG_WEAK = 0x0004;
@@ -1376,7 +1364,6 @@ public class ResourceTypes {
       count = buf.getInt(offset + ResTable_entry.SIZEOF + ResTable_ref.SIZEOF);
     }
   }
-  ;
 
   /** A single name/value mapping that is part of a complex resource entry. */
   public static class ResTable_map extends WithOffset {
@@ -1482,7 +1469,6 @@ public class ResourceTypes {
       return "ResTable_map{" + "name=" + name + ", value=" + value + '}';
     }
   }
-  ;
 
   /**
    * A package-id to package name mapping for any shared libraries used in this resource table. The
@@ -1504,7 +1490,6 @@ public class ResourceTypes {
       count = buf.getInt(offset + ResChunk_header.SIZEOF);
     }
   }
-  ;
 
   /** A shared library package-id to package name entry. */
   static class ResTable_lib_entry extends WithOffset {
@@ -1527,7 +1512,6 @@ public class ResourceTypes {
       }
     }
   }
-  ;
 
   /**
    * A map that allows rewriting staged (non-finalized) resource ids to their finalized
@@ -1607,7 +1591,7 @@ public class ResourceTypes {
     short overlay_type_id;
     short entry_count;
     short entry_id_offset;
-    int entries[];
+    int[] entries;
 
     IdmapEntry_header(ByteBuffer buf, int offset) {
       super(buf, offset);
diff --git a/resources/src/main/java/org/robolectric/res/android/ResourceUtils.java b/resources/src/main/java/org/robolectric/res/android/ResourceUtils.java
index 6b8bfac38..f54a1fc57 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResourceUtils.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResourceUtils.java
@@ -28,7 +28,7 @@ class ResourceUtils {
 
   static int get_entry_id(int resid) {
     //    return static_cast<uint16_t>(resid & 0x0000ffff);
-    return (short) (resid & 0x0000FFFF);
+    return resid & 0x0000FFFF;
   }
 
   static boolean is_internal_resid(int resid) {
@@ -83,11 +83,11 @@ class ResourceUtils {
     int end = start + str.length();
     int current = start;
     while (current != end) {
-      if (out_type.get().length() == 0 && str.charAt(current) == '/') {
+      if (out_type.get().isEmpty() && str.charAt(current) == '/') {
         has_type_separator = true;
         out_type.set(str.substring(start, current));
         start = current + 1;
-      } else if (out_package.get().length() == 0 && str.charAt(current) == ':') {
+      } else if (out_package.get().isEmpty() && str.charAt(current) == ':') {
         has_package_separator = true;
         out_package.set(str.substring(start, current));
         start = current + 1;
diff --git a/resources/src/main/java/org/robolectric/res/android/SortedVector.java b/resources/src/main/java/org/robolectric/res/android/SortedVector.java
index a52e54895..914a4ffeb 100644
--- a/resources/src/main/java/org/robolectric/res/android/SortedVector.java
+++ b/resources/src/main/java/org/robolectric/res/android/SortedVector.java
@@ -2,7 +2,6 @@ package org.robolectric.res.android;
 
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.List;
 
 // roughly transliterated from system/core/libutils/include/utils/SortedVector.h and
@@ -10,7 +9,7 @@ import java.util.List;
 public class SortedVector<T extends Comparable<T>> {
 
   // internal storage for the data. Re-sorted on insertion
-  private List<T> mStorage;
+  private final List<T> mStorage;
 
   SortedVector(int itemSize) {
     mStorage = new ArrayList<>(itemSize);
@@ -22,14 +21,7 @@ public class SortedVector<T extends Comparable<T>> {
 
   public void add(T info) {
     mStorage.add(info);
-    Collections.sort(
-        mStorage,
-        new Comparator<T>() {
-          @Override
-          public int compare(T t, T t1) {
-            return t.compareTo(t1);
-          }
-        });
+    Collections.sort(mStorage, Comparable::compareTo);
   }
 
   public int size() {
diff --git a/resources/src/main/java/org/robolectric/res/android/String8.java b/resources/src/main/java/org/robolectric/res/android/String8.java
index 676a887f3..00cf8af79 100644
--- a/resources/src/main/java/org/robolectric/res/android/String8.java
+++ b/resources/src/main/java/org/robolectric/res/android/String8.java
@@ -11,7 +11,7 @@ import org.robolectric.res.Fs;
 @SuppressWarnings("NewApi")
 public class String8 {
 
-  private StringBuilder mString;
+  private final StringBuilder mString;
 
   public String8() {
     this("");
@@ -382,7 +382,7 @@ public class String8 {
   }
 
   public String8 appendPath(String name) {
-    if (name.length() == 0) {
+    if (name.isEmpty()) {
       // nothing to do
       return this;
     }
@@ -431,7 +431,7 @@ public class String8 {
     String8 string8 = (String8) o;
 
     return mString != null
-        ? mString.toString().equals(string8.mString.toString())
+        ? mString.toString().contentEquals(string8.mString)
         : string8.mString == null;
   }
 
diff --git a/resources/src/main/java/org/robolectric/res/android/StringPoolRef.java b/resources/src/main/java/org/robolectric/res/android/StringPoolRef.java
index 0fc8bfa07..bceb69203 100644
--- a/resources/src/main/java/org/robolectric/res/android/StringPoolRef.java
+++ b/resources/src/main/java/org/robolectric/res/android/StringPoolRef.java
@@ -9,7 +9,7 @@ package org.robolectric.res.android;
 class StringPoolRef {
 
   private final ResStringPool mPool;
-  private int mIndex;
+  private final int mIndex;
 
   StringPoolRef(final ResStringPool pool, int index) {
     this.mPool = pool;
diff --git a/resources/src/main/java/org/robolectric/res/android/Util.java b/resources/src/main/java/org/robolectric/res/android/Util.java
index 947fd8b7a..1f0cd8e91 100644
--- a/resources/src/main/java/org/robolectric/res/android/Util.java
+++ b/resources/src/main/java/org/robolectric/res/android/Util.java
@@ -12,7 +12,7 @@ public class Util {
   public static final int SIZEOF_SHORT = 2;
   public static final int SIZEOF_INT = 4;
   public static final int SIZEOF_CPTR = 4;
-  private static boolean littleEndian = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN;
+  private static final boolean littleEndian = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN;
 
   private static final boolean DEBUG = false;
 
diff --git a/resources/src/main/java/org/robolectric/res/android/ZipFileRO.java b/resources/src/main/java/org/robolectric/res/android/ZipFileRO.java
index 93bb28a4d..2227bbc8a 100644
--- a/resources/src/main/java/org/robolectric/res/android/ZipFileRO.java
+++ b/resources/src/main/java/org/robolectric/res/android/ZipFileRO.java
@@ -43,7 +43,6 @@ public class ZipFileRO {
     //    ZipEntryRO(final ZipEntryRO& other);
     //    ZipEntryRO& operator=(final ZipEntryRO& other);
   }
-  ;
 
   //  ~ZipFileRO() {
   @Override
@@ -250,7 +249,7 @@ public class ZipFileRO {
    * Create a new FileMap object that spans the data in "entry".
    */
   /*FileMap*/ ZipFileRO(org.robolectric.res.android.ZipFileRO.ZipEntryRO entry) {
-    throw new UnsupportedOperationException("Implememnt me");
+    throw new UnsupportedOperationException("Implement me");
 
     //    final ZipEntryRO *zipEntry = reinterpret_cast<ZipEntryRO*>(entry);
     //    final ZipEntry& ze = zipEntry.entry;
@@ -303,7 +302,7 @@ public class ZipFileRO {
    */
   boolean uncompressEntry(
       org.robolectric.res.android.ZipFileRO.ZipEntryRO entry, Object buffer, int size) {
-    throw new UnsupportedOperationException("Implememnt me");
+    throw new UnsupportedOperationException("Implement me");
     //    ZipEntryRO *zipEntry = reinterpret_cast<ZipEntryRO*>(entry);
     //    final int error = ExtractToMemory(mHandle, &(zipEntry.entry),
     //    (uint8_t*) buffer, size);
@@ -321,7 +320,7 @@ public class ZipFileRO {
    * This doesn't verify the data's CRC, but probably should.
    */
   boolean uncompressEntry(org.robolectric.res.android.ZipFileRO.ZipEntryRO entry, int fd) {
-    throw new UnsupportedOperationException("Implememnt me");
+    throw new UnsupportedOperationException("Implement me");
     //    ZipEntryRO *zipEntry = reinterpret_cast<ZipEntryRO*>(entry);
     //    final int error = ExtractEntryToFile(mHandle, &(zipEntry.entry), fd);
     //    if (error) {
diff --git a/resources/src/test/java/org/robolectric/RoboSettingsTest.java b/resources/src/test/java/org/robolectric/RoboSettingsTest.java
deleted file mode 100644
index 5de517df1..000000000
--- a/resources/src/test/java/org/robolectric/RoboSettingsTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.robolectric;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class RoboSettingsTest {
-
-  private boolean originalUseGlobalScheduler;
-
-  @Before
-  public void setUp() {
-    originalUseGlobalScheduler = RoboSettings.isUseGlobalScheduler();
-  }
-
-  @After
-  public void tearDown() {
-    RoboSettings.setUseGlobalScheduler(originalUseGlobalScheduler);
-  }
-
-  @Test
-  public void isUseGlobalScheduler_defaultFalse() {
-    assertFalse(RoboSettings.isUseGlobalScheduler());
-  }
-
-  @Test
-  public void setUseGlobalScheduler() {
-    RoboSettings.setUseGlobalScheduler(true);
-    assertTrue(RoboSettings.isUseGlobalScheduler());
-  }
-}
diff --git a/resources/src/test/java/org/robolectric/manifest/ActivityDataTest.java b/resources/src/test/java/org/robolectric/manifest/ActivityDataTest.java
index 1b9c52096..68b49f8bb 100644
--- a/resources/src/test/java/org/robolectric/manifest/ActivityDataTest.java
+++ b/resources/src/test/java/org/robolectric/manifest/ActivityDataTest.java
@@ -15,8 +15,7 @@ public class ActivityDataTest {
   public void test_non_android_namespace() {
     HashMap<String, String> attrs = new HashMap<>();
     attrs.put("testns:name", ".test.TestActivity");
-    ActivityData activityData =
-        new ActivityData("testns", attrs, new ArrayList<IntentFilterData>());
+    ActivityData activityData = new ActivityData("testns", attrs, new ArrayList<>());
 
     assertThat(activityData.getName()).isEqualTo(".test.TestActivity");
     assertThat(activityData.getAllAttributes().get("android:name")).isNull();
@@ -26,7 +25,7 @@ public class ActivityDataTest {
   public void test_config_changes() {
     HashMap<String, String> attrs = new HashMap<>();
     attrs.put("android:configChanges", "mcc|screenLayout|orientation");
-    ActivityData activityData = new ActivityData(attrs, new ArrayList<IntentFilterData>());
+    ActivityData activityData = new ActivityData(attrs, new ArrayList<>());
 
     assertThat(activityData.getConfigChanges()).isEqualTo("mcc|screenLayout|orientation");
   }
diff --git a/resources/src/test/java/org/robolectric/manifest/MetaDataTest.java b/resources/src/test/java/org/robolectric/manifest/MetaDataTest.java
index c5c3be342..15113635a 100644
--- a/resources/src/test/java/org/robolectric/manifest/MetaDataTest.java
+++ b/resources/src/test/java/org/robolectric/manifest/MetaDataTest.java
@@ -6,6 +6,7 @@ import com.google.common.collect.ImmutableList;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,24 +15,29 @@ import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.res.ResourceTable;
 import org.w3c.dom.Element;
-import org.w3c.dom.Node;
 
 /** Tests for {@link MetaData} */
 @RunWith(JUnit4.class)
 public class MetaDataTest {
 
   @Mock private ResourceTable resourceProvider;
+  private AutoCloseable mock;
 
   @Before
   public void setUp() {
-    MockitoAnnotations.initMocks(this);
+    mock = MockitoAnnotations.openMocks(this);
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    mock.close();
   }
 
   @Test
-  public void testNonExistantResource_throwsResourceNotFoundException() throws Exception {
-    Element metaDataElement = createMetaDataNode("aName", "@xml/non_existant_resource");
+  public void testNonExistentResource_throwsResourceNotFoundException() {
+    Element metaDataElement = createMetaDataNode("aName", "@xml/non_existent_resource");
 
-    MetaData metaData = new MetaData(ImmutableList.<Node>of(metaDataElement));
+    MetaData metaData = new MetaData(ImmutableList.of(metaDataElement));
 
     assertThrows(RoboNotFoundException.class, () -> metaData.init(resourceProvider, "a.package"));
   }
diff --git a/resources/src/test/java/org/robolectric/res/QualifiersTest.java b/resources/src/test/java/org/robolectric/res/QualifiersTest.java
index 73dc0cd8b..035ddea97 100644
--- a/resources/src/test/java/org/robolectric/res/QualifiersTest.java
+++ b/resources/src/test/java/org/robolectric/res/QualifiersTest.java
@@ -13,12 +13,12 @@ import org.robolectric.res.android.ResTable_config;
 @RunWith(JUnit4.class)
 public class QualifiersTest {
   @Test
-  public void testQualifiers() throws Exception {
+  public void testQualifiers() {
     assertThat(configFrom("values-land-finger")).isEqualTo("land-finger");
   }
 
   @Test
-  public void testWhenQualifiersFailToParse() throws Exception {
+  public void testWhenQualifiersFailToParse() {
     try {
       configFrom("values-unknown-v23");
       fail("Expected exception");
@@ -34,71 +34,4 @@ public class QualifiersTest {
     ResTable_config config = new XmlContext("package", xmlFile, qualifiers).getConfig();
     return config.toString();
   }
-
-  ///////// deprecated stuff...
-
-  @Test
-  public void addSmallestScreenWidth() throws Exception {
-    assertThat(Qualifiers.addSmallestScreenWidth("", 320)).isEqualTo("sw320dp");
-    assertThat(Qualifiers.addSmallestScreenWidth("sw160dp", 320)).isEqualTo("sw160dp");
-    assertThat(Qualifiers.addSmallestScreenWidth("sw480dp", 320)).isEqualTo("sw480dp");
-    assertThat(Qualifiers.addSmallestScreenWidth("en-v23", 320))
-        .isEqualTo("en-v23-sw320dp"); // todo: order is wrong here
-    assertThat(Qualifiers.addSmallestScreenWidth("en-sw160dp-v23", 320))
-        .isEqualTo("en-sw160dp-v23");
-    assertThat(Qualifiers.addSmallestScreenWidth("en-sw480dp-v23", 320))
-        .isEqualTo("en-sw480dp-v23");
-  }
-
-  @Test
-  public void addScreenWidth() throws Exception {
-    assertThat(Qualifiers.addScreenWidth("", 320)).isEqualTo("w320dp");
-    assertThat(Qualifiers.addScreenWidth("w160dp", 320)).isEqualTo("w160dp");
-    assertThat(Qualifiers.addScreenWidth("w480dp", 320)).isEqualTo("w480dp");
-    assertThat(Qualifiers.addScreenWidth("en-v23", 320))
-        .isEqualTo("en-v23-w320dp"); // todo: order is wrong here
-    assertThat(Qualifiers.addScreenWidth("en-w160dp-v23", 320)).isEqualTo("en-w160dp-v23");
-    assertThat(Qualifiers.addScreenWidth("en-w480dp-v23", 320)).isEqualTo("en-w480dp-v23");
-  }
-
-  @Test
-  public void getSmallestScreenWidth() {
-    assertThat(Qualifiers.getSmallestScreenWidth("sw320dp")).isEqualTo(320);
-    assertThat(Qualifiers.getSmallestScreenWidth("sw320dp-v7")).isEqualTo(320);
-    assertThat(Qualifiers.getSmallestScreenWidth("en-rUS-sw320dp")).isEqualTo(320);
-    assertThat(Qualifiers.getSmallestScreenWidth("en-rUS-sw320dp-v7")).isEqualTo(320);
-    assertThat(Qualifiers.getSmallestScreenWidth("en-rUS-v7")).isEqualTo(-1);
-    assertThat(Qualifiers.getSmallestScreenWidth("en-rUS-w320dp-v7")).isEqualTo(-1);
-  }
-
-  @Test
-  public void getAddSmallestScreenWidth() {
-    assertThat(Qualifiers.addSmallestScreenWidth("v7", 320)).isEqualTo("v7-sw320dp");
-    assertThat(Qualifiers.addSmallestScreenWidth("sw320dp-v7", 480)).isEqualTo("sw320dp-v7");
-  }
-
-  @Test
-  public void getScreenWidth() {
-    assertThat(Qualifiers.getScreenWidth("w320dp")).isEqualTo(320);
-    assertThat(Qualifiers.getScreenWidth("w320dp-v7")).isEqualTo(320);
-    assertThat(Qualifiers.getScreenWidth("en-rUS-w320dp")).isEqualTo(320);
-    assertThat(Qualifiers.getScreenWidth("en-rUS-w320dp-v7")).isEqualTo(320);
-    assertThat(Qualifiers.getScreenWidth("en-rUS-v7")).isEqualTo(-1);
-    assertThat(Qualifiers.getScreenWidth("de-v23-sw320dp-w1024dp")).isEqualTo(1024);
-    assertThat(Qualifiers.getScreenWidth("en-rUS-sw320dp-v7")).isEqualTo(-1);
-  }
-
-  @Test
-  public void getAddScreenWidth() {
-    assertThat(Qualifiers.addScreenWidth("v7", 320)).isEqualTo("v7-w320dp");
-    assertThat(Qualifiers.addScreenWidth("w320dp-v7", 480)).isEqualTo("w320dp-v7");
-  }
-
-  @Test
-  public void getOrientation() {
-    assertThat(Qualifiers.getOrientation("land")).isEqualTo("land");
-    assertThat(Qualifiers.getOrientation("en-rUs-land")).isEqualTo("land");
-    assertThat(Qualifiers.getOrientation("port")).isEqualTo("port");
-    assertThat(Qualifiers.getOrientation("port-v7")).isEqualTo("port");
-  }
 }
diff --git a/resources/src/test/java/org/robolectric/res/ResourceIdsTest.java b/resources/src/test/java/org/robolectric/res/ResourceIdsTest.java
index e9d522fb0..5db4258ad 100644
--- a/resources/src/test/java/org/robolectric/res/ResourceIdsTest.java
+++ b/resources/src/test/java/org/robolectric/res/ResourceIdsTest.java
@@ -35,7 +35,7 @@ public class ResourceIdsTest {
 
   @Test
   public void testMakeIdentifier() {
-    assertThat(ResourceIds.makeIdentifer(0x01, 0x01, 0x9876)).isEqualTo(0x01019876);
-    assertThat(ResourceIds.makeIdentifer(0x7F, 0x78, 0x1234)).isEqualTo(0x7F781234);
+    assertThat(ResourceIds.makeIdentifier(0x01, 0x01, 0x9876)).isEqualTo(0x01019876);
+    assertThat(ResourceIds.makeIdentifier(0x7F, 0x78, 0x1234)).isEqualTo(0x7F781234);
   }
 }
diff --git a/resources/src/test/java/org/robolectric/res/StaxValueLoaderTest.java b/resources/src/test/java/org/robolectric/res/StaxValueLoaderTest.java
index e2507fba6..c1fd4d5f2 100644
--- a/resources/src/test/java/org/robolectric/res/StaxValueLoaderTest.java
+++ b/resources/src/test/java/org/robolectric/res/StaxValueLoaderTest.java
@@ -23,7 +23,7 @@ public class StaxValueLoaderTest {
   private StaxDocumentLoader staxDocumentLoader;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     resourceTable = new PackageResourceTable("pkg");
 
     topLevelNodeHandler = new NodeHandler();
diff --git a/resources/src/test/java/org/robolectric/res/StyleDataTest.java b/resources/src/test/java/org/robolectric/res/StyleDataTest.java
index 88730b082..dc57e387a 100644
--- a/resources/src/test/java/org/robolectric/res/StyleDataTest.java
+++ b/resources/src/test/java/org/robolectric/res/StyleDataTest.java
@@ -3,6 +3,7 @@ package org.robolectric.res;
 import static com.google.common.truth.Truth.assertThat;
 import static java.util.Arrays.asList;
 
+import java.util.Collections;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -22,7 +23,8 @@ public class StyleDataTest {
             "library.resource",
             "Theme_MyApp",
             "Theme_Material",
-            asList(new AttributeResource(myLibSearchViewStyle, "lib_value", "library.resource")));
+            Collections.singletonList(
+                new AttributeResource(myLibSearchViewStyle, "lib_value", "library.resource")));
 
     assertThat(styleData.getAttrValue(myAppSearchViewStyle).value).isEqualTo("lib_value");
     assertThat(styleData.getAttrValue(myLibSearchViewStyle).value).isEqualTo("lib_value");
@@ -37,7 +39,8 @@ public class StyleDataTest {
             "android",
             "Theme_Material",
             "Theme",
-            asList(new AttributeResource(androidSearchViewStyle, "android_value", "android")));
+            Collections.singletonList(
+                new AttributeResource(androidSearchViewStyle, "android_value", "android")));
 
     assertThat(styleData.getAttrValue(androidSearchViewStyle).value).isEqualTo("android_value");
 
@@ -64,13 +67,13 @@ public class StyleDataTest {
   }
 
   @Test
-  public void getAttrValue_willReturnTrimmedAttributeValues() throws Exception {
+  public void getAttrValue_willReturnTrimmedAttributeValues() {
     StyleData styleData =
         new StyleData(
             "library.resource",
             "Theme_MyApp",
             "Theme_Material",
-            asList(
+            Collections.singletonList(
                 new AttributeResource(myLibSearchViewStyle, "\n lib_value ", "library.resource")));
 
     assertThat(styleData.getAttrValue(myAppSearchViewStyle).value).isEqualTo("\n lib_value ");
diff --git a/resources/src/test/java/org/robolectric/res/ThemeStyleSetTest.java b/resources/src/test/java/org/robolectric/res/ThemeStyleSetTest.java
index 21b0d7f79..be2e6a138 100644
--- a/resources/src/test/java/org/robolectric/res/ThemeStyleSetTest.java
+++ b/resources/src/test/java/org/robolectric/res/ThemeStyleSetTest.java
@@ -14,12 +14,12 @@ public class ThemeStyleSetTest {
   private ThemeStyleSet themeStyleSet;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     themeStyleSet = new ThemeStyleSet();
   }
 
   @Test
-  public void shouldFindAttributesFromAnAppliedStyle() throws Exception {
+  public void shouldFindAttributesFromAnAppliedStyle() {
     themeStyleSet = new ThemeStyleSet();
     themeStyleSet.apply(
         createStyle(
@@ -36,7 +36,7 @@ public class ThemeStyleSetTest {
   }
 
   @Test
-  public void shouldFindAttributesFromAnAppliedFromForcedStyle() throws Exception {
+  public void shouldFindAttributesFromAnAppliedFromForcedStyle() {
     themeStyleSet.apply(
         createStyle(
             "style1",
diff --git a/resources/src/test/java/org/robolectric/res/android/ResTable_configTest.java b/resources/src/test/java/org/robolectric/res/android/ResTable_configTest.java
index 7ba8f01d5..fa167198e 100644
--- a/resources/src/test/java/org/robolectric/res/android/ResTable_configTest.java
+++ b/resources/src/test/java/org/robolectric/res/android/ResTable_configTest.java
@@ -10,7 +10,7 @@ import org.junit.runners.JUnit4;
 public class ResTable_configTest {
 
   @Test
-  public void testLocale() throws Exception {
+  public void testLocale() {
     ResTable_config resTable_config = new ResTable_config();
     resTable_config.language[0] = 'e';
     resTable_config.language[1] = 'n';
diff --git a/resources/src/test/java/org/robolectric/res/android/ZipFileROTest.java b/resources/src/test/java/org/robolectric/res/android/ZipFileROTest.java
index cf48b2109..2139f4cdd 100644
--- a/resources/src/test/java/org/robolectric/res/android/ZipFileROTest.java
+++ b/resources/src/test/java/org/robolectric/res/android/ZipFileROTest.java
@@ -1,6 +1,7 @@
 package org.robolectric.res.android;
 
 import static com.google.common.truth.Truth.assertThat;
+import static java.nio.file.Files.newOutputStream;
 
 import com.google.common.io.ByteStreams;
 import com.google.common.io.Files;
@@ -61,7 +62,7 @@ public final class ZipFileROTest {
   public void open_emptyZip() throws Exception {
     // ensure ZipFileRO cam handle an empty zip file with no central directory
     File blob = File.createTempFile("prefix", "zip");
-    try (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(blob))) {}
+    try (ZipOutputStream zip = new ZipOutputStream(newOutputStream(blob.toPath()))) {}
 
     ZipFileRO zipFile = ZipFileRO.open(blob.toString());
     assertThat(zipFile).isNotNull();
diff --git a/robolectric/build.gradle.kts b/robolectric/build.gradle.kts
index 843ff8df9..705cbf4ca 100644
--- a/robolectric/build.gradle.kts
+++ b/robolectric/build.gradle.kts
@@ -48,7 +48,8 @@ dependencies {
   testImplementation(libs.junit4)
   testImplementation(libs.truth)
   testImplementation(libs.mockito)
-  testImplementation(libs.hamcrest.junit)
+  testImplementation(libs.mockito.subclass)
+  testImplementation(libs.hamcrest)
   testImplementation("androidx.test:core:$axtCoreVersion@aar")
   testImplementation("androidx.test.ext:junit:$axtJunitVersion@aar")
   testImplementation("androidx.test.ext:truth:$axtTruthVersion@aar")
diff --git a/robolectric/src/main/java/org/robolectric/ConfigMerger.java b/robolectric/src/main/java/org/robolectric/ConfigMerger.java
deleted file mode 100644
index 053f0e1d4..000000000
--- a/robolectric/src/main/java/org/robolectric/ConfigMerger.java
+++ /dev/null
@@ -1,155 +0,0 @@
-package org.robolectric;
-
-import static com.google.common.collect.Lists.reverse;
-
-import com.google.common.annotations.VisibleForTesting;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
-import org.robolectric.annotation.Config;
-
-/**
- * Computes the effective Robolectric configuration for a given test method.
- *
- * <p>This class is no longer used directly by Robolectric, but is left for convenience during
- * migration.
- *
- * @deprecated Provide an implementation of {@link javax.inject.Provider<Config>}. This class will
- *     be removed in Robolectric 4.3.
- * @see <a href="http://robolectric.org/migrating/#migrating-to-40">Migration Notes</a> for more
- *     details.
- */
-@Deprecated
-public class ConfigMerger {
-  private final Map<String, Config> packageConfigCache =
-      new LinkedHashMap<String, Config>() {
-        @Override
-        protected boolean removeEldestEntry(Map.Entry eldest) {
-          return size() > 10;
-        }
-      };
-
-  /**
-   * Calculate the {@link Config} for the given test.
-   *
-   * @param testClass the class containing the test
-   * @param method the test method
-   * @param globalConfig global configuration values
-   * @return the effective configuration
-   * @since 3.2
-   */
-  public Config getConfig(Class<?> testClass, Method method, Config globalConfig) {
-    Config config = Config.Builder.defaults().build();
-    config = override(config, globalConfig);
-
-    for (String packageName : reverse(packageHierarchyOf(testClass))) {
-      Config packageConfig = cachedPackageConfig(packageName);
-      config = override(config, packageConfig);
-    }
-
-    for (Class clazz : reverse(parentClassesFor(testClass))) {
-      Config classConfig = (Config) clazz.getAnnotation(Config.class);
-      config = override(config, classConfig);
-    }
-
-    Config methodConfig = method.getAnnotation(Config.class);
-    config = override(config, methodConfig);
-
-    return config;
-  }
-
-  /**
-   * Generate {@link Config} for the specified package.
-   *
-   * <p>More specific packages, test classes, and test method configurations will override values
-   * provided here.
-   *
-   * <p>The default implementation uses properties provided by {@link #getConfigProperties(String)}.
-   *
-   * <p>The returned object is likely to be reused for many tests.
-   *
-   * @param packageName the name of the package, or empty string ({@code ""}) for the top level
-   *     package
-   * @return {@link Config} object for the specified package
-   * @since 3.2
-   */
-  @Nullable
-  private Config buildPackageConfig(String packageName) {
-    return Config.Implementation.fromProperties(getConfigProperties(packageName));
-  }
-
-  /**
-   * Return a {@link Properties} file for the given package name, or {@code null} if none is
-   * available.
-   *
-   * @since 3.2
-   */
-  protected Properties getConfigProperties(String packageName) {
-    List<String> packageParts = new ArrayList<>(Arrays.asList(packageName.split("\\.")));
-    packageParts.add(RobolectricTestRunner.CONFIG_PROPERTIES);
-    final String resourceName = String.join("/", packageParts);
-    try (InputStream resourceAsStream = getResourceAsStream(resourceName)) {
-      if (resourceAsStream == null) return null;
-      Properties properties = new Properties();
-      properties.load(resourceAsStream);
-      return properties;
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  @Nonnull
-  @VisibleForTesting
-  List<String> packageHierarchyOf(Class<?> javaClass) {
-    Package aPackage = javaClass.getPackage();
-    String testPackageName = aPackage == null ? "" : aPackage.getName();
-    List<String> packageHierarchy = new ArrayList<>();
-    while (!testPackageName.isEmpty()) {
-      packageHierarchy.add(testPackageName);
-      int lastDot = testPackageName.lastIndexOf('.');
-      testPackageName = lastDot > 1 ? testPackageName.substring(0, lastDot) : "";
-    }
-    packageHierarchy.add("");
-    return packageHierarchy;
-  }
-
-  @Nonnull
-  private List<Class> parentClassesFor(Class testClass) {
-    List<Class> testClassHierarchy = new ArrayList<>();
-    while (testClass != null && !testClass.equals(Object.class)) {
-      testClassHierarchy.add(testClass);
-      testClass = testClass.getSuperclass();
-    }
-    return testClassHierarchy;
-  }
-
-  private Config override(Config config, Config classConfig) {
-    return classConfig != null ? new Config.Builder(config).overlay(classConfig).build() : config;
-  }
-
-  @Nullable
-  private Config cachedPackageConfig(String packageName) {
-    synchronized (packageConfigCache) {
-      Config config = packageConfigCache.get(packageName);
-      if (config == null && !packageConfigCache.containsKey(packageName)) {
-        config = buildPackageConfig(packageName);
-        packageConfigCache.put(packageName, config);
-      }
-      return config;
-    }
-  }
-
-  // visible for testing
-  @SuppressWarnings("WeakerAccess")
-  InputStream getResourceAsStream(String resourceName) {
-    return getClass().getClassLoader().getResourceAsStream(resourceName);
-  }
-}
diff --git a/robolectric/src/main/java/org/robolectric/ParameterizedRobolectricTestRunner.java b/robolectric/src/main/java/org/robolectric/ParameterizedRobolectricTestRunner.java
index 33b7dbd31..555959d31 100644
--- a/robolectric/src/main/java/org/robolectric/ParameterizedRobolectricTestRunner.java
+++ b/robolectric/src/main/java/org/robolectric/ParameterizedRobolectricTestRunner.java
@@ -101,7 +101,7 @@ public final class ParameterizedRobolectricTestRunner extends Suite {
       this.name = name;
     }
 
-    private Object createTestInstance(Class bootstrappedClass) throws Exception {
+    private Object createTestInstance(Class<?> bootstrappedClass) throws Exception {
       Constructor<?>[] constructors = bootstrappedClass.getConstructors();
       Assert.assertEquals(1, constructors.length);
       if (!fieldsAreAnnotated()) {
@@ -177,7 +177,7 @@ public final class ParameterizedRobolectricTestRunner extends Suite {
                 Locale.US,
                 "Provided %d parameters, but only found fields for parameters: %s",
                 parameters.length,
-                parameterFieldsFound.toString()));
+                parameterFieldsFound));
       }
     }
 
@@ -241,7 +241,8 @@ public final class ParameterizedRobolectricTestRunner extends Suite {
     }
 
     @Override
-    protected SandboxTestRunner.HelperTestRunner getHelperTestRunner(Class bootstrappedTestClass) {
+    protected SandboxTestRunner.HelperTestRunner getHelperTestRunner(
+        Class<?> bootstrappedTestClass) {
       try {
         return new HelperTestRunner(bootstrappedTestClass) {
           @Override
@@ -262,7 +263,7 @@ public final class ParameterizedRobolectricTestRunner extends Suite {
 
           @Override
           public String toString() {
-            return "HelperTestRunner for " + TestClassRunnerForParameters.this.toString();
+            return "HelperTestRunner for " + TestClassRunnerForParameters.this;
           }
         };
       } catch (InitializationError initializationError) {
@@ -285,7 +286,7 @@ public final class ParameterizedRobolectricTestRunner extends Suite {
    * Only called reflectively. Do not use programmatically.
    */
   public ParameterizedRobolectricTestRunner(Class<?> klass) throws Throwable {
-    super(klass, Collections.<Runner>emptyList());
+    super(klass, Collections.emptyList());
     TestClass testClass = getTestClass();
     ClassLoader classLoader = getClass().getClassLoader();
     Parameters parameters =
diff --git a/robolectric/src/main/java/org/robolectric/Robolectric.java b/robolectric/src/main/java/org/robolectric/Robolectric.java
index 41f312daf..edd19d2b7 100644
--- a/robolectric/src/main/java/org/robolectric/Robolectric.java
+++ b/robolectric/src/main/java/org/robolectric/Robolectric.java
@@ -16,10 +16,13 @@ import android.app.backup.BackupAgent;
 import android.content.ContentProvider;
 import android.content.Context;
 import android.content.Intent;
+import android.content.res.XmlResourceParser;
 import android.os.Bundle;
 import android.os.Looper;
 import android.util.AttributeSet;
+import android.util.Xml;
 import android.view.View;
+import java.io.IOException;
 import java.lang.reflect.Modifier;
 import javax.annotation.Nullable;
 import org.robolectric.android.AttributeSetBuilderImpl;
@@ -34,6 +37,8 @@ import org.robolectric.shadows.ShadowApplication;
 import org.robolectric.util.Logger;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.Scheduler;
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
 
 public class Robolectric {
 
@@ -137,7 +142,7 @@ public class Robolectric {
    */
   @Deprecated
   @SuppressWarnings("InlineMeSuggester")
-  public static final <T extends Activity> T setupActivity(Class<T> activityClass) {
+  public static <T extends Activity> T setupActivity(Class<T> activityClass) {
     return buildActivity(activityClass).setup().get();
   }
 
@@ -317,17 +322,33 @@ public class Robolectric {
    * Allows for the programmatic creation of an {@link AttributeSet}.
    *
    * <p>Useful for testing {@link View} classes without the need for creating XML snippets.
+   *
+   * @deprecated use {@link #getAttributeSetFromXml(int)} instead
    */
+  @Deprecated
   public static org.robolectric.android.AttributeSetBuilder buildAttributeSet() {
 
     return new AttributeSetBuilderImpl(
         new ArscResourceResolver(RuntimeEnvironment.getApplication())) {};
   }
 
+  /** Helper method for obtaining an {@link AttributeSet} from an xml resource id */
+  public static AttributeSet getAttributeSetFromXml(int xmlResId) {
+    try {
+      XmlResourceParser parser =
+          RuntimeEnvironment.getApplication().getResources().getXml(xmlResId);
+      while (parser.next() != XmlPullParser.START_TAG) {
+      }
+      return Xml.asAttributeSet(parser);
+    } catch (XmlPullParserException | IOException e) {
+      throw new RuntimeException("Failed to parse XML resource " + xmlResId, e);
+    }
+  }
+
   /**
    * Builder of {@link AttributeSet}s.
    *
-   * @deprecated Use {@link org.robolectric.android.AttributeSetBuilder} instead.
+   * @deprecated Use {@link Xml#asAttributeSet(XmlPullParser)} instead.
    */
   @Deprecated
   public interface AttributeSetBuilder {
@@ -364,12 +385,21 @@ public class Robolectric {
    * Return the foreground scheduler (e.g. the UI thread scheduler).
    *
    * @return Foreground scheduler.
+   * @deprecated The {@link Scheduler} APIs are designed for LEGACY Looper mode. It is strongly
+   *     recommended to migrate tests to PAUSED Looper mode to avoid the need for this API.
    */
+  @Deprecated
   public static Scheduler getForegroundThreadScheduler() {
     return RuntimeEnvironment.getMasterScheduler();
   }
 
-  /** Execute all runnables that have been enqueued on the foreground scheduler. */
+  /**
+   * Execute all runnables that have been enqueued on the foreground scheduler.
+   *
+   * @deprecated The {@link Scheduler} APIs are designed for LEGACY Looper mode. Use {@link
+   *     org.robolectric.shadows.ShadowLooper#runToEndOfTasks} instead.
+   */
+  @Deprecated
   public static void flushForegroundThreadScheduler() {
     getForegroundThreadScheduler().advanceToLastPostedRunnable();
   }
@@ -378,12 +408,21 @@ public class Robolectric {
    * Return the background scheduler.
    *
    * @return Background scheduler.
+   * @deprecated The {@link Scheduler} APIs are designed for LEGACY Looper mode. It is strongly
+   *     recommended to migrate tests to PAUSED Looper mode to avoid the need for this API.
    */
+  @Deprecated
   public static Scheduler getBackgroundThreadScheduler() {
     return ShadowApplication.getInstance().getBackgroundThreadScheduler();
   }
 
-  /** Execute all runnables that have been enqueued on the background scheduler. */
+  /**
+   * Execute all runnables that have been enqueued on the background scheduler.
+   *
+   * @deprecated The {@link Scheduler} APIs are designed for LEGACY Looper mode. Use {@link
+   *     org.robolectric.shadows.ShadowLooper#runToEndOfTasks} instead.
+   */
+  @Deprecated
   public static void flushBackgroundThreadScheduler() {
     getBackgroundThreadScheduler().advanceToLastPostedRunnable();
   }
@@ -398,7 +437,7 @@ public class Robolectric {
           Service instance =
               factory.instantiateService(
                   loadedApk.getClassLoader(), serviceClass.getName(), intent);
-          if (instance != null && serviceClass.isAssignableFrom(instance.getClass())) {
+          if (serviceClass.isAssignableFrom(instance.getClass())) {
             return (T) instance;
           }
         } catch (ReflectiveOperationException e) {
@@ -418,7 +457,7 @@ public class Robolectric {
         try {
           ContentProvider instance =
               factory.instantiateProvider(loadedApk.getClassLoader(), providerClass.getName());
-          if (instance != null && providerClass.isAssignableFrom(instance.getClass())) {
+          if (providerClass.isAssignableFrom(instance.getClass())) {
             return (T) instance;
           }
         } catch (ReflectiveOperationException e) {
@@ -439,7 +478,7 @@ public class Robolectric {
           Activity instance =
               factory.instantiateActivity(
                   loadedApk.getClassLoader(), activityClass.getName(), intent);
-          if (instance != null && activityClass.isAssignableFrom(instance.getClass())) {
+          if (activityClass.isAssignableFrom(instance.getClass())) {
             return (T) instance;
           }
         } catch (ReflectiveOperationException e) {
diff --git a/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java b/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java
index f2d69ff1d..7f2b236fe 100644
--- a/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java
+++ b/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java
@@ -27,7 +27,6 @@ import org.robolectric.android.AndroidSdkShadowMatcher;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.GraphicsMode;
 import org.robolectric.annotation.LooperMode;
-import org.robolectric.annotation.LooperMode.Mode;
 import org.robolectric.annotation.ResourcesMode;
 import org.robolectric.annotation.SQLiteMode;
 import org.robolectric.config.AndroidConfigurer;
@@ -64,8 +63,6 @@ import org.robolectric.util.inject.Injector;
  */
 @SuppressWarnings("NewApi")
 public class RobolectricTestRunner extends SandboxTestRunner {
-
-  public static final String CONFIG_PROPERTIES = "robolectric.properties";
   private static final int MAX_DATA_DIR_NAME_LENGTH = 120;
   private static final Injector DEFAULT_INJECTOR = defaultInjector().build();
   private static final Map<ManifestIdentifier, AndroidManifest> appManifestsCache = new HashMap<>();
@@ -108,7 +105,7 @@ public class RobolectricTestRunner extends SandboxTestRunner {
   private final ConfigurationStrategy configurationStrategy;
   private final AndroidConfigurer androidConfigurer;
 
-  private boolean alwaysIncludeVariantMarkersInName =
+  private final boolean alwaysIncludeVariantMarkersInName =
       Boolean.parseBoolean(
           System.getProperty("robolectric.alwaysIncludeVariantMarkersInTestName", "false"));
 
@@ -256,26 +253,10 @@ public class RobolectricTestRunner extends SandboxTestRunner {
     Sdk sdk = roboMethod.getSdk();
 
     InstrumentationConfiguration classLoaderConfig = createClassLoaderConfig(method);
-    ResourcesMode.Mode resourcesMode =
-        roboMethod.configuration == null
-            ? ResourcesMode.Mode.BINARY
-            : roboMethod.configuration.get(ResourcesMode.Mode.class);
-    ;
-
-    LooperMode.Mode looperMode =
-        roboMethod.configuration == null
-            ? Mode.LEGACY
-            : roboMethod.configuration.get(LooperMode.Mode.class);
-
-    SQLiteMode.Mode sqliteMode =
-        roboMethod.configuration == null
-            ? SQLiteMode.Mode.LEGACY
-            : roboMethod.configuration.get(SQLiteMode.Mode.class);
-
-    GraphicsMode.Mode graphicsMode =
-        roboMethod.configuration == null
-            ? GraphicsMode.Mode.LEGACY
-            : roboMethod.configuration.get(GraphicsMode.Mode.class);
+    ResourcesMode.Mode resourcesMode = roboMethod.configuration.get(ResourcesMode.Mode.class);
+    LooperMode.Mode looperMode = roboMethod.configuration.get(LooperMode.Mode.class);
+    SQLiteMode.Mode sqliteMode = roboMethod.configuration.get(SQLiteMode.Mode.class);
+    GraphicsMode.Mode graphicsMode = roboMethod.configuration.get(GraphicsMode.Mode.class);
 
     sdk.verifySupportedSdk(method.getDeclaringClass().getName());
     return sandboxManager.getAndroidSandbox(
@@ -512,9 +493,6 @@ public class RobolectricTestRunner extends SandboxTestRunner {
     return extraShadows.toArray(new Class<?>[] {});
   }
 
-  @Override
-  protected void afterClass() {}
-
   @Override
   public Object createTest() throws Exception {
     throw new UnsupportedOperationException(
@@ -567,7 +545,7 @@ public class RobolectricTestRunner extends SandboxTestRunner {
     private final boolean alwaysIncludeVariantMarkersInName;
 
     private boolean includeVariantMarkersInTestName = true;
-    TestLifecycle<?> testLifecycle;
+    TestLifecycle testLifecycle;
     Sandbox sandbox;
     TestEnvironment testEnvironment;
 
diff --git a/robolectric/src/main/java/org/robolectric/SdkPicker.java b/robolectric/src/main/java/org/robolectric/SdkPicker.java
deleted file mode 100644
index afa0aa1b2..000000000
--- a/robolectric/src/main/java/org/robolectric/SdkPicker.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package org.robolectric;
-
-import java.util.Properties;
-import javax.annotation.Nonnull;
-import javax.inject.Inject;
-import org.robolectric.plugins.DefaultSdkPicker;
-import org.robolectric.plugins.SdkCollection;
-
-/**
- * @deprecated use {@link org.robolectric.plugins.DefaultSdkPicker} instead.
- */
-@Deprecated
-public class SdkPicker extends DefaultSdkPicker {
-
-  @Inject
-  public SdkPicker(@Nonnull SdkCollection sdkCollection, Properties systemProperties) {
-    super(sdkCollection, systemProperties);
-  }
-}
diff --git a/robolectric/src/main/java/org/robolectric/TestLifecycle.java b/robolectric/src/main/java/org/robolectric/TestLifecycle.java
index d5abd6be0..cff1219c0 100644
--- a/robolectric/src/main/java/org/robolectric/TestLifecycle.java
+++ b/robolectric/src/main/java/org/robolectric/TestLifecycle.java
@@ -2,7 +2,7 @@ package org.robolectric;
 
 import java.lang.reflect.Method;
 
-public interface TestLifecycle<T> {
+public interface TestLifecycle {
 
   /**
    * Called before each test method is run.
diff --git a/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilder.java b/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilder.java
index 186ddcc03..facb0bf54 100644
--- a/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilder.java
+++ b/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilder.java
@@ -2,13 +2,15 @@ package org.robolectric.android;
 
 import android.annotation.IdRes;
 import android.util.AttributeSet;
+import android.util.Xml;
 import org.robolectric.Robolectric;
+import org.xmlpull.v1.XmlPullParser;
 
 /**
  * Builder of {@link AttributeSet}s.
  *
- * @deprecated use Xml.asAttributeSet instead. Not supported in {@link
- *     org.robolectric.annotation.ResourcesMode.Mode.NATIVE}
+ * @deprecated use {@link Xml#asAttributeSet(XmlPullParser)} instead. Not supported in {@link
+ *     org.robolectric.annotation.ResourcesMode.Mode#NATIVE}
  */
 @Deprecated
 public interface AttributeSetBuilder extends Robolectric.AttributeSetBuilder {
diff --git a/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilderImpl.java b/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilderImpl.java
index 21b684182..d497f7223 100644
--- a/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilderImpl.java
+++ b/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilderImpl.java
@@ -11,6 +11,7 @@ import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.content.Context;
 import android.content.res.AssetManager;
+import android.os.Build;
 import android.util.AttributeSet;
 import android.util.SparseArray;
 import android.util.TypedValue;
@@ -86,7 +87,9 @@ public class AttributeSetBuilderImpl implements AttributeSetBuilder {
         this.resTable = ((ShadowAssetManager.ArscBase) shadowAssetManager).getCompileTimeResTable();
       } else {
         throw new IllegalStateException(
-            "AttributeSetBuilder is only supported in BINARY resources mode");
+            "AttributeSetBuilder is only supported in BINARY resources mode BINARY resources "
+                + "mode is only supported for Android V (35) or earlier. SDK was "
+                + Build.VERSION.SDK_INT);
       }
     }
 
diff --git a/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java b/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java
index e38a41df6..642002d79 100644
--- a/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java
+++ b/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java
@@ -107,6 +107,7 @@ public class AndroidTestEnvironment implements TestEnvironment {
   private final int apiLevel;
 
   private boolean loggingInitialized = false;
+  private FakeMediaProvider fakeMediaProvider;
   private final Path sdkJarPath;
   private final ShadowProvider[] shadowProviders;
   private final TestEnvironmentLifecyclePlugin[] testEnvironmentLifecyclePlugins;
@@ -334,73 +335,71 @@ public class AndroidTestEnvironment implements TestEnvironment {
 
     RuntimeEnvironment.application = application;
 
-    if (application != null) {
-      final Class<?> appBindDataClass;
-      try {
-        appBindDataClass = Class.forName("android.app.ActivityThread$AppBindData");
-      } catch (ClassNotFoundException e) {
-        throw new RuntimeException(e);
-      }
-      final Object appBindData = ReflectionHelpers.callConstructor(appBindDataClass);
-      final _AppBindData_ _appBindData_ = reflector(_AppBindData_.class, appBindData);
-      _appBindData_.setProcessName(parsedPackage.packageName);
-      _appBindData_.setAppInfo(applicationInfo);
-      activityThreadReflector.setBoundApplication(appBindData);
-
-      final LoadedApk loadedApk =
-          activityThread.getPackageInfo(applicationInfo, null, Context.CONTEXT_INCLUDE_CODE);
-      final _LoadedApk_ _loadedApk_ = reflector(_LoadedApk_.class, loadedApk);
-
-      Context contextImpl =
-          reflector(_ContextImpl_.class).createAppContext(activityThread, loadedApk);
-      ShadowPackageManager shadowPackageManager = Shadow.extract(contextImpl.getPackageManager());
-      shadowPackageManager.addPackageInternal(parsedPackage);
-      activityThreadReflector.setInitialApplication(application);
-      ShadowApplication shadowApplication = Shadow.extract(application);
-      shadowApplication.callAttach(contextImpl);
-      reflector(_ContextImpl_.class, contextImpl).setOuterContext(application);
-      if (apiLevel >= VERSION_CODES.O) {
-        reflector(_ContextImpl_.class, contextImpl)
-            .setClassLoader(this.getClass().getClassLoader());
-      }
-
-      Resources appResources = application.getResources();
-      _loadedApk_.setResources(appResources);
-      _loadedApk_.setApplication(application);
-      if (RuntimeEnvironment.getApiLevel() >= VERSION_CODES.O) {
-        // Preload fonts resources
-        FontsContract.setApplicationContextForResources(application);
-      }
-      registerBroadcastReceivers(application, appManifest, loadedApk);
-
-      appResources.updateConfiguration(androidConfiguration, Bootstrap.getDisplayMetrics());
-
-      // Circumvent the 'No Compatibility callbacks set!' log. See #8509
-      if (apiLevel >= AndroidVersions.V.SDK_INT) {
-        // Adds loggableChanges parameter.
-        ReflectionHelpers.callStaticMethod(
-            AppCompatCallbacks.class,
-            "install",
-            ClassParameter.from(long[].class, new long[0]),
-            ClassParameter.from(long[].class, new long[0]));
-      } else if (apiLevel >= AndroidVersions.R.SDK_INT) {
-        // Invoke the previous version.
-        ReflectionHelpers.callStaticMethod(
-            AppCompatCallbacks.class, "install", ClassParameter.from(long[].class, new long[0]));
-      }
+    final Class<?> appBindDataClass;
+    try {
+      appBindDataClass = Class.forName("android.app.ActivityThread$AppBindData");
+    } catch (ClassNotFoundException e) {
+      throw new RuntimeException(e);
+    }
+    final Object appBindData = ReflectionHelpers.callConstructor(appBindDataClass);
+    final _AppBindData_ _appBindData_ = reflector(_AppBindData_.class, appBindData);
+    _appBindData_.setProcessName(parsedPackage.packageName);
+    _appBindData_.setAppInfo(applicationInfo);
+    activityThreadReflector.setBoundApplication(appBindData);
+
+    final LoadedApk loadedApk =
+        activityThread.getPackageInfo(applicationInfo, null, Context.CONTEXT_INCLUDE_CODE);
+    final _LoadedApk_ _loadedApk_ = reflector(_LoadedApk_.class, loadedApk);
+
+    Context contextImpl =
+        reflector(_ContextImpl_.class).createAppContext(activityThread, loadedApk);
+    ShadowPackageManager shadowPackageManager = Shadow.extract(contextImpl.getPackageManager());
+    shadowPackageManager.addPackageInternal(parsedPackage);
+    activityThreadReflector.setInitialApplication(application);
+    ShadowApplication shadowApplication = Shadow.extract(application);
+    shadowApplication.callAttach(contextImpl);
+    reflector(_ContextImpl_.class, contextImpl).setOuterContext(application);
+    if (apiLevel >= VERSION_CODES.O) {
+      reflector(_ContextImpl_.class, contextImpl).setClassLoader(this.getClass().getClassLoader());
+    }
 
-      if (RuntimeEnvironment.getApiLevel() >= Q
-          && Boolean.parseBoolean(
-              System.getProperty("robolectric.installFakeMediaProvider", "true"))) {
-        Robolectric.setupContentProvider(FakeMediaProvider.class, MediaStore.AUTHORITY);
-      }
+    Resources appResources = application.getResources();
+    _loadedApk_.setResources(appResources);
+    _loadedApk_.setApplication(application);
+    if (RuntimeEnvironment.getApiLevel() >= VERSION_CODES.O) {
+      // Preload fonts resources
+      FontsContract.setApplicationContextForResources(application);
+    }
+    registerBroadcastReceivers(application, appManifest, loadedApk);
+
+    appResources.updateConfiguration(androidConfiguration, Bootstrap.getDisplayMetrics());
+
+    // Circumvent the 'No Compatibility callbacks set!' log. See #8509
+    if (apiLevel >= AndroidVersions.V.SDK_INT) {
+      // Adds loggableChanges parameter.
+      ReflectionHelpers.callStaticMethod(
+          AppCompatCallbacks.class,
+          "install",
+          ClassParameter.from(long[].class, new long[0]),
+          ClassParameter.from(long[].class, new long[0]));
+    } else if (apiLevel >= AndroidVersions.R.SDK_INT) {
+      // Invoke the previous version.
+      ReflectionHelpers.callStaticMethod(
+          AppCompatCallbacks.class, "install", ClassParameter.from(long[].class, new long[0]));
+    }
 
-      PerfStatsCollector.getInstance()
-          .measure(
-              "application onCreate()",
-              () -> androidInstrumentation.callApplicationOnCreate(application));
+    if (RuntimeEnvironment.getApiLevel() >= Q
+        && Boolean.parseBoolean(
+            System.getProperty("robolectric.installFakeMediaProvider", "true"))) {
+      this.fakeMediaProvider =
+          Robolectric.setupContentProvider(FakeMediaProvider.class, MediaStore.AUTHORITY);
     }
 
+    PerfStatsCollector.getInstance()
+        .measure(
+            "application onCreate()",
+            () -> androidInstrumentation.callApplicationOnCreate(application));
+
     return application;
   }
 
@@ -422,13 +421,12 @@ public class AndroidTestEnvironment implements TestEnvironment {
       parsedPackage = ShadowPackageParser.callParsePackage(packageFile);
     } else {
       parsedPackage = new Package("org.robolectric.default");
-      parsedPackage.applicationInfo.targetSdkVersion = appManifest.getTargetSdkVersion();
     }
-
-    if (parsedPackage != null
-        && parsedPackage.applicationInfo != null
-        && RuntimeEnvironment.getApiLevel() >= P) {
-      parsedPackage.applicationInfo.appComponentFactory = appManifest.getAppComponentFactory();
+    if (parsedPackage != null && parsedPackage.applicationInfo != null) {
+      parsedPackage.applicationInfo.targetSdkVersion = appManifest.getTargetSdkVersion();
+      if (RuntimeEnvironment.getApiLevel() >= P) {
+        parsedPackage.applicationInfo.appComponentFactory = appManifest.getAppComponentFactory();
+      }
     }
     return parsedPackage;
   }
@@ -591,6 +589,10 @@ public class AndroidTestEnvironment implements TestEnvironment {
   @Override
   public void resetState() {
     Locale.setDefault(initialLocale);
+    if (fakeMediaProvider != null) {
+      fakeMediaProvider.shutdown();
+      fakeMediaProvider = null;
+    }
     List<Throwable> exceptions = new ArrayList<>();
     for (ShadowProvider provider : shadowProviders) {
       try {
@@ -668,8 +670,20 @@ public class AndroidTestEnvironment implements TestEnvironment {
       }
       String receiverClassName = receiver.getName();
       if (loadedApk != null && RuntimeEnvironment.getApiLevel() >= P) {
-        application.registerReceiver(
-            newBroadcastReceiverFromP(receiverClassName, loadedApk), filter);
+        if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
+          // In Robolectric, we simulate server in the client part, and we need to inject
+          // receiver exported flags based on the definition in the AndroidManifest.xml
+          // to avoid receiver exported flags checking reporting error for system's
+          // registration of static receivers in AndroidManifest.xml as Robolectric reuses
+          // common APIs to simulate server's behavior and behave for client APIs.
+          application.registerReceiver(
+              newBroadcastReceiverFromP(receiverClassName, loadedApk),
+              filter,
+              receiver.isExported() ? Context.RECEIVER_EXPORTED : Context.RECEIVER_NOT_EXPORTED);
+        } else {
+          application.registerReceiver(
+              newBroadcastReceiverFromP(receiverClassName, loadedApk), filter);
+        }
       } else {
         application.registerReceiver((BroadcastReceiver) newInstanceOf(receiverClassName), filter);
       }
diff --git a/robolectric/src/main/java/org/robolectric/android/internal/IdlingResourceTimeoutException.java b/robolectric/src/main/java/org/robolectric/android/internal/IdlingResourceTimeoutException.java
index 4329e8c3e..9c2ea5c69 100644
--- a/robolectric/src/main/java/org/robolectric/android/internal/IdlingResourceTimeoutException.java
+++ b/robolectric/src/main/java/org/robolectric/android/internal/IdlingResourceTimeoutException.java
@@ -1,6 +1,6 @@
 package org.robolectric.android.internal;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import androidx.test.internal.platform.util.TestOutputEmitter;
 import com.google.common.annotations.Beta;
@@ -21,7 +21,7 @@ public final class IdlingResourceTimeoutException extends RuntimeException {
   public IdlingResourceTimeoutException(List<String> resourceNames) {
     super(
         String.format(
-            Locale.ROOT, "Wait for %s to become idle timed out", checkNotNull(resourceNames)));
+            Locale.ROOT, "Wait for %s to become idle timed out", requireNonNull(resourceNames)));
     TestOutputEmitter.dumpThreadStates("ThreadState-IdlingResTimeoutExcep.txt");
   }
 }
diff --git a/robolectric/src/main/java/org/robolectric/android/internal/LocalActivityInvoker.java b/robolectric/src/main/java/org/robolectric/android/internal/LocalActivityInvoker.java
index 1f5f1e0d3..cd95625df 100644
--- a/robolectric/src/main/java/org/robolectric/android/internal/LocalActivityInvoker.java
+++ b/robolectric/src/main/java/org/robolectric/android/internal/LocalActivityInvoker.java
@@ -1,7 +1,7 @@
 package org.robolectric.android.internal;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 
 import android.app.Activity;
 import android.app.Instrumentation.ActivityResult;
@@ -62,7 +62,7 @@ public class LocalActivityInvoker implements ActivityInvoker {
           "You must start Activity first. Make sure you are using launchActivityForResult() to"
               + " launch an Activity.");
     }
-    checkNotNull(controller);
+    requireNonNull(controller);
     checkState(controller.get().isFinishing(), "You must finish your Activity first");
     ShadowActivity shadowActivity = Shadow.extract(controller.get());
     return new ActivityResult(shadowActivity.getResultCode(), shadowActivity.getResultIntent());
@@ -70,7 +70,7 @@ public class LocalActivityInvoker implements ActivityInvoker {
 
   @Override
   public void resumeActivity(Activity activity) {
-    checkNotNull(controller);
+    requireNonNull(controller);
     checkState(controller.get() == activity);
     ShadowInstrumentation.runOnMainSyncNoIdle(
         () -> {
@@ -95,7 +95,7 @@ public class LocalActivityInvoker implements ActivityInvoker {
 
   @Override
   public void pauseActivity(Activity activity) {
-    checkNotNull(controller);
+    requireNonNull(controller);
     checkState(controller.get() == activity);
     ShadowInstrumentation.runOnMainSyncNoIdle(
         () -> {
@@ -116,7 +116,7 @@ public class LocalActivityInvoker implements ActivityInvoker {
 
   @Override
   public void stopActivity(Activity activity) {
-    checkNotNull(controller);
+    requireNonNull(controller);
     checkState(controller.get() == activity);
     ShadowInstrumentation.runOnMainSyncNoIdle(
         () -> {
@@ -141,14 +141,14 @@ public class LocalActivityInvoker implements ActivityInvoker {
 
   @Override
   public void recreateActivity(Activity activity) {
-    checkNotNull(controller);
+    requireNonNull(controller);
     checkState(controller.get() == activity);
     ShadowInstrumentation.runOnMainSyncNoIdle(() -> controller.recreate());
   }
 
   @Override
   public void finishActivity(Activity activity) {
-    checkNotNull(controller);
+    requireNonNull(controller);
     checkState(controller.get() == activity);
     ShadowInstrumentation.runOnMainSyncNoIdle(
         () -> {
diff --git a/robolectric/src/main/java/org/robolectric/android/internal/LocalPermissionGranter.java b/robolectric/src/main/java/org/robolectric/android/internal/LocalPermissionGranter.java
index ecf021e6e..534547649 100644
--- a/robolectric/src/main/java/org/robolectric/android/internal/LocalPermissionGranter.java
+++ b/robolectric/src/main/java/org/robolectric/android/internal/LocalPermissionGranter.java
@@ -1,10 +1,11 @@
 package org.robolectric.android.internal;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import android.app.Application;
 import androidx.test.internal.platform.content.PermissionGranter;
 import androidx.test.platform.app.InstrumentationRegistry;
+import javax.annotation.Nonnull;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowApplication;
 
@@ -15,13 +16,13 @@ public class LocalPermissionGranter implements PermissionGranter {
   private String[] permissions;
 
   @Override
-  public void addPermissions(String... permissions) {
+  public void addPermissions(@Nonnull String... permissions) {
     this.permissions = permissions;
   }
 
   @Override
   public void requestPermissions() {
-    checkNotNull(permissions);
+    requireNonNull(permissions);
     Application application =
         (Application) InstrumentationRegistry.getInstrumentation().getTargetContext();
     ShadowApplication shadowApplication = Shadow.extract(application);
diff --git a/robolectric/src/main/java/org/robolectric/android/internal/LocalUiController.java b/robolectric/src/main/java/org/robolectric/android/internal/LocalUiController.java
index 7bfd8a2f0..d56316112 100644
--- a/robolectric/src/main/java/org/robolectric/android/internal/LocalUiController.java
+++ b/robolectric/src/main/java/org/robolectric/android/internal/LocalUiController.java
@@ -1,7 +1,7 @@
 package org.robolectric.android.internal;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static java.util.stream.Collectors.toList;
@@ -80,7 +80,7 @@ public class LocalUiController implements UiController {
   // location
   @Override
   public boolean injectString(String str) throws InjectEventSecurityException {
-    checkNotNull(str);
+    requireNonNull(str);
     checkState(Looper.myLooper() == Looper.getMainLooper(), "Expecting to be on main thread!");
 
     // No-op if string is empty.
@@ -108,7 +108,7 @@ public class LocalUiController implements UiController {
     Log.d(TAG, String.format("Injecting string: \"%s\"", str));
 
     for (KeyEvent event : events) {
-      checkNotNull(
+      requireNonNull(
           event,
           String.format(
               "Failed to get event for character (%c) with key code (%s)",
diff --git a/robolectric/src/main/java/org/robolectric/android/internal/RoboMonitoringInstrumentation.java b/robolectric/src/main/java/org/robolectric/android/internal/RoboMonitoringInstrumentation.java
index a3d13b542..145183c3c 100644
--- a/robolectric/src/main/java/org/robolectric/android/internal/RoboMonitoringInstrumentation.java
+++ b/robolectric/src/main/java/org/robolectric/android/internal/RoboMonitoringInstrumentation.java
@@ -33,7 +33,6 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.FutureTask;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -157,7 +156,7 @@ public class RoboMonitoringInstrumentation extends Instrumentation {
   /**
    * Executes a runnable on the main thread, blocking until it is complete.
    *
-   * <p>When in INSTUMENTATION_TEST Looper mode, the runnable is posted to the main handler and the
+   * <p>When in INSTRUMENTATION_TEST Looper mode, the runnable is posted to the main handler and the
    * caller's thread blocks until that runnable has finished. When a Throwable is thrown in the
    * runnable, the exception is propagated back to the caller's thread. If it is an unchecked
    * throwable, it will be rethrown as is. If it is a checked exception, it will be rethrown as a
@@ -272,13 +271,9 @@ public class RoboMonitoringInstrumentation extends Instrumentation {
       ShadowActivity shadowActivity, String target, int requestCode, ActivityResult ar) {
     new Handler(Looper.getMainLooper())
         .post(
-            new Runnable() {
-              @Override
-              public void run() {
+            () ->
                 shadowActivity.internalCallDispatchActivityResult(
-                    target, requestCode, ar.getResultCode(), ar.getResultData());
-              }
-            });
+                    target, requestCode, ar.getResultCode(), ar.getResultData()));
   }
 
   private ActivityResult stubResultFor(Intent intent) {
@@ -287,13 +282,8 @@ public class RoboMonitoringInstrumentation extends Instrumentation {
     }
 
     FutureTask<ActivityResult> task =
-        new FutureTask<ActivityResult>(
-            new Callable<ActivityResult>() {
-              @Override
-              public ActivityResult call() throws Exception {
-                return IntentStubberRegistry.getInstance().getActivityResultForIntent(intent);
-              }
-            });
+        new FutureTask<>(
+            () -> IntentStubberRegistry.getInstance().getActivityResultForIntent(intent));
     ShadowInstrumentation.runOnMainSyncNoIdle(task);
 
     try {
diff --git a/robolectric/src/main/java/org/robolectric/android/internal/RobolectricThreadChecker.java b/robolectric/src/main/java/org/robolectric/android/internal/RobolectricThreadChecker.java
index b11e3d8cb..4a2b91e11 100644
--- a/robolectric/src/main/java/org/robolectric/android/internal/RobolectricThreadChecker.java
+++ b/robolectric/src/main/java/org/robolectric/android/internal/RobolectricThreadChecker.java
@@ -8,7 +8,7 @@ import org.robolectric.annotation.LooperMode;
 import org.robolectric.shadows.ShadowLooper;
 
 /**
- * Performs thread checking when in INSTRUMENTAION_TEST Looper Mode where the test thread is
+ * Performs thread checking when in INSTRUMENTATION_TEST Looper Mode where the test thread is
  * distinct from the main thread. No-op for other modes because everything is executed on the main
  * thread (except for manually created worker threads).
  */
diff --git a/robolectric/src/main/java/org/robolectric/internal/DefaultManifestFactory.java b/robolectric/src/main/java/org/robolectric/internal/DefaultManifestFactory.java
index 225dce86e..cc697389f 100644
--- a/robolectric/src/main/java/org/robolectric/internal/DefaultManifestFactory.java
+++ b/robolectric/src/main/java/org/robolectric/internal/DefaultManifestFactory.java
@@ -12,7 +12,7 @@ import org.robolectric.util.Logger;
 
 @SuppressWarnings("NewApi")
 public class DefaultManifestFactory implements ManifestFactory {
-  private Properties properties;
+  private final Properties properties;
 
   public DefaultManifestFactory(Properties properties) {
     this.properties = properties;
diff --git a/robolectric/src/main/java/org/robolectric/internal/ManifestIdentifier.java b/robolectric/src/main/java/org/robolectric/internal/ManifestIdentifier.java
index 93f7d4c4e..b5e1ec229 100644
--- a/robolectric/src/main/java/org/robolectric/internal/ManifestIdentifier.java
+++ b/robolectric/src/main/java/org/robolectric/internal/ManifestIdentifier.java
@@ -1,11 +1,10 @@
 package org.robolectric.internal;
 
 import java.nio.file.Path;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Objects;
 import javax.annotation.Nonnull;
-import org.robolectric.annotation.Config;
 
 @SuppressWarnings("NewApi")
 public class ManifestIdentifier {
@@ -40,33 +39,6 @@ public class ManifestIdentifier {
     this.apkFile = apkFile;
   }
 
-  /**
-   * @deprecated Use {@link #ManifestIdentifier(String, Path, Path, Path, List)} instead.
-   */
-  @Deprecated
-  public ManifestIdentifier(
-      Path manifestFile, Path resDir, Path assetDir, String packageName, List<Path> libraryDirs) {
-    this.manifestFile = manifestFile;
-    this.resDir = resDir;
-    this.assetDir = assetDir;
-    this.packageName = packageName;
-
-    List<ManifestIdentifier> libraries = new ArrayList<>();
-    if (libraryDirs != null) {
-      for (Path libraryDir : libraryDirs) {
-        libraries.add(
-            new ManifestIdentifier(
-                null,
-                libraryDir.resolve(Config.DEFAULT_MANIFEST_NAME),
-                libraryDir.resolve(Config.DEFAULT_RES_FOLDER),
-                libraryDir.resolve(Config.DEFAULT_ASSET_FOLDER),
-                null));
-      }
-    }
-    this.libraries = Collections.unmodifiableList(libraries);
-    this.apkFile = null;
-  }
-
   public Path getManifestFile() {
     return manifestFile;
   }
@@ -103,24 +75,22 @@ public class ManifestIdentifier {
 
     ManifestIdentifier that = (ManifestIdentifier) o;
 
-    if (manifestFile != null
-        ? !manifestFile.equals(that.manifestFile)
-        : that.manifestFile != null) {
+    if (!Objects.equals(manifestFile, that.manifestFile)) {
       return false;
     }
-    if (resDir != null ? !resDir.equals(that.resDir) : that.resDir != null) {
+    if (!Objects.equals(resDir, that.resDir)) {
       return false;
     }
-    if (assetDir != null ? !assetDir.equals(that.assetDir) : that.assetDir != null) {
+    if (!Objects.equals(assetDir, that.assetDir)) {
       return false;
     }
-    if (packageName != null ? !packageName.equals(that.packageName) : that.packageName != null) {
+    if (!Objects.equals(packageName, that.packageName)) {
       return false;
     }
-    if (libraries != null ? !libraries.equals(that.libraries) : that.libraries != null) {
+    if (!Objects.equals(libraries, that.libraries)) {
       return false;
     }
-    return apkFile != null ? apkFile.equals(that.apkFile) : that.apkFile == null;
+    return Objects.equals(apkFile, that.apkFile);
   }
 
   @Override
diff --git a/robolectric/src/main/java/org/robolectric/internal/MavenManifestFactory.java b/robolectric/src/main/java/org/robolectric/internal/MavenManifestFactory.java
index 6d08b9145..ea1f3845c 100644
--- a/robolectric/src/main/java/org/robolectric/internal/MavenManifestFactory.java
+++ b/robolectric/src/main/java/org/robolectric/internal/MavenManifestFactory.java
@@ -119,7 +119,7 @@ public class MavenManifestFactory implements ManifestFactory {
         if (Files.isDirectory(libraryDir)) {
           // Ignore directories without any files
           Path[] libraryBaseDirFiles = Fs.listFiles(libraryDir);
-          if (libraryBaseDirFiles != null && libraryBaseDirFiles.length > 0) {
+          if (libraryBaseDirFiles.length > 0) {
             List<ManifestIdentifier> libraries =
                 findLibraries(libraryDir.resolve(Config.DEFAULT_RES_FOLDER));
             libraryBaseDirs.add(
diff --git a/robolectric/src/main/java/org/robolectric/internal/dependency/LocalDependencyResolver.java b/robolectric/src/main/java/org/robolectric/internal/dependency/LocalDependencyResolver.java
index 5002efb61..7a6326f2a 100644
--- a/robolectric/src/main/java/org/robolectric/internal/dependency/LocalDependencyResolver.java
+++ b/robolectric/src/main/java/org/robolectric/internal/dependency/LocalDependencyResolver.java
@@ -6,7 +6,7 @@ import java.net.URL;
 import org.robolectric.util.Logger;
 
 public class LocalDependencyResolver implements DependencyResolver {
-  private File offlineJarDir;
+  private final File offlineJarDir;
 
   public LocalDependencyResolver(File offlineJarDir) {
     super();
diff --git a/robolectric/src/main/java/org/robolectric/internal/dependency/PropertiesDependencyResolver.java b/robolectric/src/main/java/org/robolectric/internal/dependency/PropertiesDependencyResolver.java
index 25b7e19b9..5b4997912 100644
--- a/robolectric/src/main/java/org/robolectric/internal/dependency/PropertiesDependencyResolver.java
+++ b/robolectric/src/main/java/org/robolectric/internal/dependency/PropertiesDependencyResolver.java
@@ -14,7 +14,7 @@ import org.robolectric.res.Fs;
 public class PropertiesDependencyResolver implements DependencyResolver {
   private final Properties properties;
   private final Path baseDir;
-  private DependencyResolver delegate;
+  private final DependencyResolver delegate;
 
   public PropertiesDependencyResolver(Path propertiesFile) {
     this(propertiesFile, null);
diff --git a/robolectric/src/main/java/org/robolectric/junit/rules/BackgroundTestRule.java b/robolectric/src/main/java/org/robolectric/junit/rules/BackgroundTestRule.java
index 359cb554e..2346c6d32 100644
--- a/robolectric/src/main/java/org/robolectric/junit/rules/BackgroundTestRule.java
+++ b/robolectric/src/main/java/org/robolectric/junit/rules/BackgroundTestRule.java
@@ -60,14 +60,11 @@ public final class BackgroundTestRule implements TestRule {
         // application loading in the future
         RuntimeEnvironment.getApplication();
         BackgroundExecutor.runInBackground(
-            new Runnable() {
-              @Override
-              public void run() {
-                try {
-                  base.evaluate();
-                } catch (Throwable t) {
-                  throwable.set(t);
-                }
+            () -> {
+              try {
+                base.evaluate();
+              } catch (Throwable t) {
+                throwable.set(t);
               }
             });
         if (throwable.get() != null) {
diff --git a/robolectric/src/main/java/org/robolectric/junit/rules/ExpectedLogMessagesRule.java b/robolectric/src/main/java/org/robolectric/junit/rules/ExpectedLogMessagesRule.java
index 0e39f78e0..843a8f0c7 100644
--- a/robolectric/src/main/java/org/robolectric/junit/rules/ExpectedLogMessagesRule.java
+++ b/robolectric/src/main/java/org/robolectric/junit/rules/ExpectedLogMessagesRule.java
@@ -166,8 +166,7 @@ public final class ExpectedLogMessagesRule implements TestRule {
    * will fail.
    *
    * <p>This will also match any log statement which contains a throwable as well. For verifying the
-   * throwable, please see {@link #expectLogMessageWithThrowable(int, String, Matcher<String>,
-   * Matcher<Throwable>)}.
+   * throwable, please see {@link #expectLogMessageWithThrowable(int, String, Matcher, Matcher)}}.
    *
    * <p>Do not use this to suppress failures. Use this to test that expected error cases in your
    * code cause log messages to be printed.
@@ -194,7 +193,7 @@ public final class ExpectedLogMessagesRule implements TestRule {
 
   /**
    * Adds an expected log statement using a regular expression. If this log is not printed during
-   * test execution, the test case will fail. When possible, log output should be made determinstic
+   * test execution, the test case will fail. When possible, log output should be made deterministic
    * and {@link #expectLogMessage(int, String, String)} used instead.
    *
    * <p>This will also match any log statement which contain a throwable as well. For verifying the
@@ -336,7 +335,7 @@ public final class ExpectedLogMessagesRule implements TestRule {
 
       ExpectedLogItem log = (ExpectedLogItem) o;
       return type == log.type
-          && !(tag != null ? !tag.equals(log.tag) : log.tag != null)
+          && Objects.equals(tag, log.tag)
           && Objects.equals(msgMatcher, log.msgMatcher)
           && Objects.equals(throwableMatcher, log.throwableMatcher);
     }
@@ -370,8 +369,7 @@ public final class ExpectedLogMessagesRule implements TestRule {
 
     @Override
     public boolean matches(Object other) {
-      // Allow direct cast since we only use this matcher in a type-safe way.
-      return msg.equals((String) other);
+      return msg.equals(other);
     }
 
     // Designed to match legacy toString() behaviour - do not modify.
@@ -419,7 +417,7 @@ public final class ExpectedLogMessagesRule implements TestRule {
     // This matches legacy behaviour to allow ExpectedLogItem to de-duplicate regex expectations.
     @Override
     public boolean equals(Object other) {
-      return other instanceof MsgRegex ? isEqual(pattern, ((MsgRegex) other).pattern) : false;
+      return other instanceof MsgRegex && isEqual(pattern, ((MsgRegex) other).pattern);
     }
 
     @Override
diff --git a/robolectric/src/main/java/org/robolectric/junit/rules/SetSystemPropertyRule.java b/robolectric/src/main/java/org/robolectric/junit/rules/SetSystemPropertyRule.java
index bfa0dc93f..c335cead3 100644
--- a/robolectric/src/main/java/org/robolectric/junit/rules/SetSystemPropertyRule.java
+++ b/robolectric/src/main/java/org/robolectric/junit/rules/SetSystemPropertyRule.java
@@ -1,8 +1,8 @@
 package org.robolectric.junit.rules;
 
-import com.google.common.base.Preconditions;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Objects;
 import org.junit.rules.TestRule;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
@@ -18,13 +18,21 @@ public class SetSystemPropertyRule implements TestRule {
   public SetSystemPropertyRule() {}
 
   public void set(String key, String value) {
-    Preconditions.checkNotNull(key);
+    Objects.requireNonNull(key);
     if (!originalProperties.containsKey(key)) {
       originalProperties.put(key, System.getProperty(key));
     }
     System.setProperty(key, value);
   }
 
+  public void clear(String key) {
+    Objects.requireNonNull(key);
+    if (!originalProperties.containsKey(key)) {
+      originalProperties.put(key, System.getProperty(key));
+    }
+    System.clearProperty(key);
+  }
+
   @Override
   public Statement apply(Statement base, Description description) {
     return new Statement() {
diff --git a/robolectric/src/main/java/org/robolectric/plugins/DefaultSdkProvider.java b/robolectric/src/main/java/org/robolectric/plugins/DefaultSdkProvider.java
index 48b6d70ef..a43513720 100644
--- a/robolectric/src/main/java/org/robolectric/plugins/DefaultSdkProvider.java
+++ b/robolectric/src/main/java/org/robolectric/plugins/DefaultSdkProvider.java
@@ -1,13 +1,13 @@
 package org.robolectric.plugins;
 
 import com.google.auto.service.AutoService;
-import com.google.common.base.Preconditions;
 import java.net.URL;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Locale;
+import java.util.Objects;
 import java.util.SortedMap;
 import java.util.TreeMap;
 import javax.annotation.Priority;
@@ -54,7 +54,7 @@ public class DefaultSdkProvider implements SdkProvider {
 
   @Inject
   public DefaultSdkProvider(DependencyResolver dependencyResolver) {
-    this.dependencyResolver = Preconditions.checkNotNull(dependencyResolver);
+    this.dependencyResolver = Objects.requireNonNull(dependencyResolver);
     TreeMap<Integer, Sdk> tmpKnownSdks = new TreeMap<>();
     populateSdks(tmpKnownSdks);
 
@@ -104,7 +104,7 @@ public class DefaultSdkProvider implements SdkProvider {
       this.robolectricVersion = robolectricVersion;
       this.codeName = codeName;
       this.requiredJavaVersion = requiredJavaVersion;
-      Preconditions.checkNotNull(dependencyResolver);
+      Objects.requireNonNull(dependencyResolver);
     }
 
     @Override
diff --git a/robolectric/src/main/java/org/robolectric/plugins/LegacyDependencyResolver.java b/robolectric/src/main/java/org/robolectric/plugins/LegacyDependencyResolver.java
index b82d656a9..fee451e8f 100644
--- a/robolectric/src/main/java/org/robolectric/plugins/LegacyDependencyResolver.java
+++ b/robolectric/src/main/java/org/robolectric/plugins/LegacyDependencyResolver.java
@@ -95,11 +95,6 @@ public class LegacyDependencyResolver implements DependencyResolver {
     return delegate.getLocalArtifactUrl(dependency);
   }
 
-  @Override
-  public URL[] getLocalArtifactUrls(DependencyJar dependency) {
-    return delegate.getLocalArtifactUrls(dependency);
-  }
-
   interface DefinitelyNotAClassLoader {
 
     URL getResource(String name);
diff --git a/robolectric/src/main/java/org/robolectric/plugins/PackagePropertiesLoader.java b/robolectric/src/main/java/org/robolectric/plugins/PackagePropertiesLoader.java
index 145053932..56d769ed7 100644
--- a/robolectric/src/main/java/org/robolectric/plugins/PackagePropertiesLoader.java
+++ b/robolectric/src/main/java/org/robolectric/plugins/PackagePropertiesLoader.java
@@ -36,12 +36,11 @@ public class PackagePropertiesLoader {
       buf.append(packageName.replace('.', '/'));
       buf.append('/');
     }
-    String propsFile = buf.toString() + propFileName + ".properties";
+    String propsFile = buf + propFileName + ".properties";
     return cache.computeIfAbsent(
         propsFile,
         s -> {
-          final String resourceName = propsFile;
-          try (InputStream resourceAsStream = getResourceAsStream(resourceName)) {
+          try (InputStream resourceAsStream = getResourceAsStream(propsFile)) {
             if (resourceAsStream == null) {
               return null;
             }
diff --git a/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java b/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java
index 8a420ad3e..beb1b13c1 100644
--- a/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java
+++ b/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java
@@ -2,12 +2,9 @@ package org.robolectric.plugins;
 
 import com.google.auto.service.AutoService;
 import java.util.Properties;
-import javax.annotation.Nonnull;
 import org.robolectric.annotation.SQLiteMode;
-import org.robolectric.annotation.SQLiteMode.Mode;
 import org.robolectric.pluginapi.config.Configurer;
 import org.robolectric.plugins.config.SingleValueConfigurer;
-import org.robolectric.util.OsUtil;
 
 /** Provides configuration to Robolectric for its @{@link SQLiteMode} annotation. */
 @AutoService(Configurer.class)
@@ -18,7 +15,7 @@ public class SQLiteModeConfigurer extends SingleValueConfigurer<SQLiteMode, SQLi
     super(
         SQLiteMode.class,
         SQLiteMode.Mode.class,
-        defaultValue(),
+        SQLiteMode.Mode.NATIVE,
         propertyFileLoader,
         systemProperties);
   }
@@ -27,13 +24,4 @@ public class SQLiteModeConfigurer extends SingleValueConfigurer<SQLiteMode, SQLi
   protected String propertyName() {
     return "sqliteMode";
   }
-
-  @Nonnull
-  private static final SQLiteMode.Mode defaultValue() {
-    // NATIVE SQLite mode not supported on Windows
-    if (OsUtil.isWindows()) {
-      return Mode.LEGACY;
-    }
-    return Mode.NATIVE;
-  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/AttributeSetBuilderTest.java b/robolectric/src/test/java/org/robolectric/AttributeSetBuilderTest.java
index 3c07cad03..eb4e35fb0 100644
--- a/robolectric/src/test/java/org/robolectric/AttributeSetBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/AttributeSetBuilderTest.java
@@ -27,7 +27,7 @@ public class AttributeSetBuilderTest {
   private static final String APP_NS = RES_AUTO_NS_URI;
 
   @Test
-  public void getAttributeResourceValue_shouldReturnTheResourceValue() throws Exception {
+  public void getAttributeResourceValue_shouldReturnTheResourceValue() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet()
             .addAttribute(android.R.attr.text, "@android:string/ok")
@@ -38,8 +38,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeResourceValueWithLeadingWhitespace_shouldReturnTheResourceValue()
-      throws Exception {
+  public void getAttributeResourceValueWithLeadingWhitespace_shouldReturnTheResourceValue() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet()
             .addAttribute(android.R.attr.text, " @android:string/ok")
@@ -50,8 +49,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getSystemAttributeResourceValue_shouldReturnDefaultValueForNullResourceId()
-      throws Exception {
+  public void getSystemAttributeResourceValue_shouldReturnDefaultValueForNullResourceId() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet()
             .addAttribute(android.R.attr.text, AttributeResource.NULL_VALUE)
@@ -64,8 +62,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getSystemAttributeResourceValue_shouldReturnDefaultValueForNonMatchingNamespaceId()
-      throws Exception {
+  public void getSystemAttributeResourceValue_shouldReturnDefaultValueForNonMatchingNamespaceId() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().addAttribute(android.R.attr.id, "@+id/text1").build();
 
@@ -76,7 +73,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void shouldCopeWithDefiningLocalIds() throws Exception {
+  public void shouldCopeWithDefiningLocalIds() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().addAttribute(android.R.attr.id, "@+id/text1").build();
 
@@ -85,8 +82,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeResourceValue_withNamespace_shouldReturnTheResourceValue()
-      throws Exception {
+  public void getAttributeResourceValue_withNamespace_shouldReturnTheResourceValue() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().addAttribute(R.attr.message, "@string/howdy").build();
 
@@ -95,8 +91,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeResourceValue_shouldReturnDefaultValueWhenAttributeIsNull()
-      throws Exception {
+  public void getAttributeResourceValue_shouldReturnDefaultValueWhenAttributeIsNull() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet()
             .addAttribute(android.R.attr.text, AttributeResource.NULL_VALUE)
@@ -106,15 +101,14 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeResourceValue_shouldReturnDefaultValueWhenNotInAttributeSet()
-      throws Exception {
+  public void getAttributeResourceValue_shouldReturnDefaultValueWhenNotInAttributeSet() {
     AttributeSet roboAttributeSet = Robolectric.buildAttributeSet().build();
 
     assertThat(roboAttributeSet.getAttributeResourceValue(APP_NS, "message", -1)).isEqualTo(-1);
   }
 
   @Test
-  public void getAttributeBooleanValue_shouldGetBooleanValuesFromAttributes() throws Exception {
+  public void getAttributeBooleanValue_shouldGetBooleanValuesFromAttributes() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().addAttribute(R.attr.isSugary, "true").build();
 
@@ -122,8 +116,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeBooleanValue_withNamespace_shouldGetBooleanValuesFromAttributes()
-      throws Exception {
+  public void getAttributeBooleanValue_withNamespace_shouldGetBooleanValuesFromAttributes() {
     // org.robolectric.lib1.R values should be reconciled to match org.robolectric.R values.
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().addAttribute(R.attr.isSugary, "true").build();
@@ -132,8 +125,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeBooleanValue_shouldReturnDefaultBooleanValueWhenNotInAttributeSet()
-      throws Exception {
+  public void getAttributeBooleanValue_shouldReturnDefaultBooleanValueWhenNotInAttributeSet() {
     AttributeSet roboAttributeSet = Robolectric.buildAttributeSet().build();
 
     assertThat(
@@ -143,20 +135,17 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeValue_byName_shouldReturnValueFromAttribute() throws Exception {
+  public void getAttributeValue_byName_shouldReturnValueFromAttribute() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().addAttribute(R.attr.isSugary, "oh heck yeah").build();
 
     assertThat(roboAttributeSet.getAttributeValue(APP_NS, "isSugary")).isEqualTo("false");
-    assertThat(roboAttributeSet.getAttributeBooleanValue(APP_NS, "isSugary", true))
-        .isEqualTo(false);
-    assertThat(roboAttributeSet.getAttributeBooleanValue(APP_NS, "animalStyle", true))
-        .isEqualTo(true);
+    assertThat(roboAttributeSet.getAttributeBooleanValue(APP_NS, "isSugary", true)).isFalse();
+    assertThat(roboAttributeSet.getAttributeBooleanValue(APP_NS, "animalStyle", true)).isTrue();
   }
 
   @Test
-  public void getAttributeValue_byNameWithReference_shouldReturnFullyQualifiedValueFromAttribute()
-      throws Exception {
+  public void getAttributeValue_byNameWithReference_shouldReturnFullyQualifiedValueFromAttribute() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().addAttribute(R.attr.isSugary, "@string/ok").build();
 
@@ -164,7 +153,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeValue_byId_shouldReturnValueFromAttribute() throws Exception {
+  public void getAttributeValue_byId_shouldReturnValueFromAttribute() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().addAttribute(R.attr.isSugary, "oh heck yeah").build();
 
@@ -172,8 +161,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeValue_byIdWithReference_shouldReturnValueFromAttribute()
-      throws Exception {
+  public void getAttributeValue_byIdWithReference_shouldReturnValueFromAttribute() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().addAttribute(R.attr.isSugary, "@string/ok").build();
 
@@ -181,7 +169,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeIntValue_shouldReturnValueFromAttribute() throws Exception {
+  public void getAttributeIntValue_shouldReturnValueFromAttribute() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().addAttribute(R.attr.sugarinessPercent, "100").build();
 
@@ -190,7 +178,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeIntValue_shouldReturnHexValueFromAttribute() throws Exception {
+  public void getAttributeIntValue_shouldReturnHexValueFromAttribute() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().addAttribute(R.attr.sugarinessPercent, "0x10").build();
 
@@ -198,8 +186,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeIntValue_whenTypeAllowsIntOrEnum_withInt_shouldReturnInt()
-      throws Exception {
+  public void getAttributeIntValue_whenTypeAllowsIntOrEnum_withInt_shouldReturnInt() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().addAttribute(R.attr.numColumns, "3").build();
 
@@ -207,8 +194,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeIntValue_shouldReturnValueFromAttributeWhenNotInAttributeSet()
-      throws Exception {
+  public void getAttributeIntValue_shouldReturnValueFromAttributeWhenNotInAttributeSet() {
     AttributeSet roboAttributeSet = Robolectric.buildAttributeSet().build();
 
     assertThat(roboAttributeSet.getAttributeIntValue(APP_NS, "sugarinessPercent", 42))
@@ -216,16 +202,14 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeIntValue_shouldReturnEnumValuesForEnumAttributesWhenNotInAttributeSet()
-      throws Exception {
+  public void getAttributeIntValue_shouldReturnEnumValuesForEnumAttributesWhenNotInAttributeSet() {
     AttributeSet roboAttributeSet = Robolectric.buildAttributeSet().build();
 
     assertThat(roboAttributeSet.getAttributeIntValue(APP_NS, "itemType", 24)).isEqualTo(24);
   }
 
   @Test
-  public void getAttributeIntValue_shouldReturnEnumValuesForEnumAttributesInAttributeSet()
-      throws Exception {
+  public void getAttributeIntValue_shouldReturnEnumValuesForEnumAttributesInAttributeSet() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().addAttribute(R.attr.itemType, "ungulate").build();
 
@@ -238,7 +222,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void shouldFailOnMissingEnumValue() throws Exception {
+  public void shouldFailOnMissingEnumValue() {
     try {
       Robolectric.buildAttributeSet().addAttribute(R.attr.itemType, "simian").build();
       fail("should fail");
@@ -249,7 +233,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void shouldFailOnMissingFlagValue() throws Exception {
+  public void shouldFailOnMissingFlagValue() {
     try {
       Robolectric.buildAttributeSet().addAttribute(R.attr.scrollBars, "temporal").build();
       fail("should fail");
@@ -260,8 +244,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeIntValue_shouldReturnFlagValuesForFlagAttributesInAttributeSet()
-      throws Exception {
+  public void getAttributeIntValue_shouldReturnFlagValuesForFlagAttributesInAttributeSet() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet()
             .addAttribute(R.attr.scrollBars, "horizontal|vertical")
@@ -272,7 +255,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeFloatValue_shouldGetFloatValuesFromAttributes() throws Exception {
+  public void getAttributeFloatValue_shouldGetFloatValuesFromAttributes() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().addAttribute(R.attr.aspectRatio, "1234.456").build();
 
@@ -281,8 +264,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeFloatValue_shouldReturnDefaultFloatValueWhenNotInAttributeSet()
-      throws Exception {
+  public void getAttributeFloatValue_shouldReturnDefaultFloatValueWhenNotInAttributeSet() {
     AttributeSet roboAttributeSet = Robolectric.buildAttributeSet().build();
 
     assertThat(roboAttributeSet.getAttributeFloatValue(APP_NS, "aspectRatio", 78.9f))
@@ -290,14 +272,14 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getClassAndIdAttribute_returnsZeroWhenNotSpecified() throws Exception {
+  public void getClassAndIdAttribute_returnsZeroWhenNotSpecified() {
     AttributeSet roboAttributeSet = Robolectric.buildAttributeSet().build();
     assertThat(roboAttributeSet.getClassAttribute()).isNull();
     assertThat(roboAttributeSet.getIdAttribute()).isNull();
   }
 
   @Test
-  public void getClassAndIdAttribute_returnsAttr() throws Exception {
+  public void getClassAndIdAttribute_returnsAttr() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet()
             .setIdAttribute("the id")
@@ -308,14 +290,14 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getStyleAttribute_returnsZeroWhenNoStyle() throws Exception {
+  public void getStyleAttribute_returnsZeroWhenNoStyle() {
     AttributeSet roboAttributeSet = Robolectric.buildAttributeSet().build();
 
     assertThat(roboAttributeSet.getStyleAttribute()).isEqualTo(0);
   }
 
   @Test
-  public void getStyleAttribute_returnsCorrectValue() throws Exception {
+  public void getStyleAttribute_returnsCorrectValue() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().setStyleAttribute("@style/Gastropod").build();
 
@@ -323,7 +305,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getStyleAttribute_whenStyleIsBogus() throws Exception {
+  public void getStyleAttribute_whenStyleIsBogus() {
     try {
       Robolectric.buildAttributeSet().setStyleAttribute("@style/non_existent_style").build();
       fail();
@@ -335,7 +317,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeNameResource() throws Exception {
+  public void getAttributeNameResource() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet().addAttribute(R.attr.aspectRatio, "1").build();
 
@@ -343,7 +325,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void shouldReturnAttributesInOrderOfNameResId() throws Exception {
+  public void shouldReturnAttributesInOrderOfNameResId() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet()
             .addAttribute(android.R.attr.height, "1px")
@@ -367,7 +349,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void whenAttrSetAttrSpecifiesUnknownStyle_throwsException() throws Exception {
+  public void whenAttrSetAttrSpecifiesUnknownStyle_throwsException() {
     try {
       Robolectric.buildAttributeSet()
           .addAttribute(R.attr.string2, "?org.robolectric:attr/noSuchAttr")
@@ -380,7 +362,7 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void whenAttrSetAttrSpecifiesUnknownReference_throwsException() throws Exception {
+  public void whenAttrSetAttrSpecifiesUnknownReference_throwsException() {
     try {
       Robolectric.buildAttributeSet()
           .addAttribute(R.attr.string2, "@org.robolectric:attr/noSuchRes")
diff --git a/robolectric/src/test/java/org/robolectric/BootstrapWrapper.java b/robolectric/src/test/java/org/robolectric/BootstrapWrapper.java
index ed1f70d1c..1edcd1671 100644
--- a/robolectric/src/test/java/org/robolectric/BootstrapWrapper.java
+++ b/robolectric/src/test/java/org/robolectric/BootstrapWrapper.java
@@ -12,7 +12,6 @@ import org.robolectric.pluginapi.config.ConfigurationStrategy.Configuration;
 /** Wrapper for testing use of AndroidTestEnvironment. */
 public class BootstrapWrapper extends AndroidTestEnvironment implements BootstrapWrapperI {
   public AndroidTestEnvironment wrappedTestEnvironment;
-  public boolean legacyResources;
   public String tmpDirName;
   public Configuration config;
   public AndroidManifest appManifest;
diff --git a/robolectric/src/test/java/org/robolectric/ConfigTest.java b/robolectric/src/test/java/org/robolectric/ConfigTest.java
index a13e4eea9..59dcb261a 100644
--- a/robolectric/src/test/java/org/robolectric/ConfigTest.java
+++ b/robolectric/src/test/java/org/robolectric/ConfigTest.java
@@ -15,7 +15,7 @@ import org.robolectric.annotation.Config;
 @RunWith(JUnit4.class)
 public class ConfigTest {
   @Test
-  public void testDefaults() throws Exception {
+  public void testDefaults() {
     Config defaults = Config.Builder.defaults().build();
     assertThat(defaults.manifest()).isEqualTo("AndroidManifest.xml");
     assertThat(defaults.resourceDir()).isEqualTo("res");
@@ -23,7 +23,7 @@ public class ConfigTest {
   }
 
   @Test
-  public void withOverlay_withBaseSdk() throws Exception {
+  public void withOverlay_withBaseSdk() {
     Config.Implementation base = new Config.Builder().setSdk(16, 17, 18).build();
 
     assertThat(sdksIn(overlay(base, new Config.Builder().build())))
@@ -43,7 +43,7 @@ public class ConfigTest {
   }
 
   @Test
-  public void withOverlay_withBaseMinSdk() throws Exception {
+  public void withOverlay_withBaseMinSdk() {
     Config.Implementation base = new Config.Builder().setMinSdk(18).build();
 
     assertThat(sdksIn(overlay(base, new Config.Builder().build())))
@@ -63,7 +63,7 @@ public class ConfigTest {
   }
 
   @Test
-  public void withOverlay_withBaseMaxSdk() throws Exception {
+  public void withOverlay_withBaseMaxSdk() {
     Config.Implementation base = new Config.Builder().setMaxSdk(18).build();
 
     assertThat(sdksIn(overlay(base, new Config.Builder().build())))
@@ -83,7 +83,7 @@ public class ConfigTest {
   }
 
   @Test
-  public void withOverlay_withBaseMinAndMaxSdk() throws Exception {
+  public void withOverlay_withBaseMinAndMaxSdk() {
     Config.Implementation base = new Config.Builder().setMinSdk(17).setMaxSdk(18).build();
 
     assertThat(sdksIn(overlay(base, new Config.Builder().build())))
@@ -103,22 +103,19 @@ public class ConfigTest {
   }
 
   @Test
-  public void withOverlay_withShadows_maintainsOrder() throws Exception {
+  public void withOverlay_withShadows_maintainsOrder() {
     Config.Implementation base = new Config.Builder().build();
 
-    Config withString =
-        overlay(base, new Config.Builder().setShadows(new Class[] {String.class}).build());
+    Config withString = overlay(base, new Config.Builder().setShadows(String.class).build());
     assertThat(withString.shadows()).asList().contains(String.class);
 
     Config withMore =
-        overlay(
-            withString,
-            new Config.Builder().setShadows(new Class[] {Map.class, String.class}).build());
+        overlay(withString, new Config.Builder().setShadows(Map.class, String.class).build());
     assertThat(withMore.shadows()).asList().containsAtLeast(String.class, Map.class, String.class);
   }
 
   @Test
-  public void shouldAppendQualifiersStartingWithPlus() throws Exception {
+  public void shouldAppendQualifiersStartingWithPlus() {
     Config config = new Config.Builder().setQualifiers("w100dp").build();
     config = overlay(config, new Config.Builder().setQualifiers("w101dp").build());
     assertThat(config.qualifiers()).isEqualTo("w101dp");
@@ -133,7 +130,7 @@ public class ConfigTest {
   }
 
   @Test
-  public void sdksFromProperties() throws Exception {
+  public void sdksFromProperties() {
     Properties properties = new Properties();
     properties.setProperty("sdk", "1, 2, ALL_SDKS, TARGET_SDK, OLDEST_SDK, NEWEST_SDK, 666");
     Config config = Config.Implementation.fromProperties(properties);
@@ -141,7 +138,7 @@ public class ConfigTest {
   }
 
   @Test
-  public void minMaxSdksFromProperties() throws Exception {
+  public void minMaxSdksFromProperties() {
     Properties properties = new Properties();
     properties.setProperty("minSdk", "OLDEST_SDK");
     properties.setProperty("maxSdk", "NEWEST_SDK");
@@ -150,7 +147,7 @@ public class ConfigTest {
   }
 
   @Test
-  public void testIllegalArguments_sdkMutualExclusion() throws Exception {
+  public void testIllegalArguments_sdkMutualExclusion() {
     try {
       new Config.Builder().setSdk(16, 17, 18).setMinSdk(16).setMaxSdk(18).build();
       fail();
@@ -163,7 +160,7 @@ public class ConfigTest {
   }
 
   @Test
-  public void testIllegalArguments_minMaxSdkRange() throws Exception {
+  public void testIllegalArguments_minMaxSdkRange() {
     try {
       new Config.Builder().setMinSdk(18).setMaxSdk(16).build();
       fail();
diff --git a/robolectric/src/test/java/org/robolectric/CustomAppComponentFactory.java b/robolectric/src/test/java/org/robolectric/CustomAppComponentFactory.java
index 0cf46eae2..5ae4cee79 100644
--- a/robolectric/src/test/java/org/robolectric/CustomAppComponentFactory.java
+++ b/robolectric/src/test/java/org/robolectric/CustomAppComponentFactory.java
@@ -6,6 +6,7 @@ import android.app.Service;
 import android.content.BroadcastReceiver;
 import android.content.ContentProvider;
 import android.content.Intent;
+import javax.annotation.Nonnull;
 import org.robolectric.CustomConstructorReceiverWrapper.CustomConstructorWithEmptyActionReceiver;
 import org.robolectric.CustomConstructorReceiverWrapper.CustomConstructorWithOneActionReceiver;
 import org.robolectric.CustomConstructorServices.CustomConstructorIntentService;
@@ -13,52 +14,51 @@ import org.robolectric.CustomConstructorServices.CustomConstructorJobService;
 import org.robolectric.CustomConstructorServices.CustomConstructorService;
 
 public final class CustomAppComponentFactory extends AppComponentFactory {
+  @Nonnull
   @Override
-  public BroadcastReceiver instantiateReceiver(ClassLoader cl, String className, Intent intent)
+  public BroadcastReceiver instantiateReceiver(
+      @Nonnull ClassLoader cl, @Nonnull String className, Intent intent)
       throws InstantiationException, IllegalAccessException, ClassNotFoundException {
-    if (className != null) {
-      if (className.contains(CustomConstructorWithOneActionReceiver.class.getName())) {
-        return new CustomConstructorWithOneActionReceiver(100);
-      } else if (className.contains(CustomConstructorWithEmptyActionReceiver.class.getName())) {
-        return new CustomConstructorWithEmptyActionReceiver(100);
-      }
+    if (className.contains(CustomConstructorWithOneActionReceiver.class.getName())) {
+      return new CustomConstructorWithOneActionReceiver(100);
+    } else if (className.contains(CustomConstructorWithEmptyActionReceiver.class.getName())) {
+      return new CustomConstructorWithEmptyActionReceiver(100);
     }
     return super.instantiateReceiver(cl, className, intent);
   }
 
+  @Nonnull
   @Override
-  public Service instantiateService(ClassLoader cl, String className, Intent intent)
+  public Service instantiateService(
+      @Nonnull ClassLoader cl, @Nonnull String className, Intent intent)
       throws InstantiationException, IllegalAccessException, ClassNotFoundException {
-    if (className != null) {
-      if (className.contains(CustomConstructorService.class.getName())) {
-        return new CustomConstructorService(100);
-      } else if (className.contains(CustomConstructorIntentService.class.getName())) {
-        return new CustomConstructorIntentService(100);
-      } else if (className.contains(CustomConstructorJobService.class.getName())) {
-        return new CustomConstructorJobService(100);
-      }
+    if (className.contains(CustomConstructorService.class.getName())) {
+      return new CustomConstructorService(100);
+    } else if (className.contains(CustomConstructorIntentService.class.getName())) {
+      return new CustomConstructorIntentService(100);
+    } else if (className.contains(CustomConstructorJobService.class.getName())) {
+      return new CustomConstructorJobService(100);
     }
     return super.instantiateService(cl, className, intent);
   }
 
+  @Nonnull
   @Override
-  public ContentProvider instantiateProvider(ClassLoader cl, String className)
+  public ContentProvider instantiateProvider(@Nonnull ClassLoader cl, @Nonnull String className)
       throws InstantiationException, IllegalAccessException, ClassNotFoundException {
-    if (className != null) {
-      if (className.contains(CustomConstructorContentProvider.class.getName())) {
-        return new CustomConstructorContentProvider(100);
-      }
+    if (className.contains(CustomConstructorContentProvider.class.getName())) {
+      return new CustomConstructorContentProvider(100);
     }
     return super.instantiateProvider(cl, className);
   }
 
+  @Nonnull
   @Override
-  public Activity instantiateActivity(ClassLoader cl, String className, Intent intent)
+  public Activity instantiateActivity(
+      @Nonnull ClassLoader cl, @Nonnull String className, Intent intent)
       throws InstantiationException, IllegalAccessException, ClassNotFoundException {
-    if (className != null) {
-      if (className.contains(CustomConstructorActivity.class.getName())) {
-        return new CustomConstructorActivity(100);
-      }
+    if (className.contains(CustomConstructorActivity.class.getName())) {
+      return new CustomConstructorActivity(100);
     }
     return super.instantiateActivity(cl, className, intent);
   }
diff --git a/robolectric/src/test/java/org/robolectric/CustomAppComponentFactoryTest.java b/robolectric/src/test/java/org/robolectric/CustomAppComponentFactoryTest.java
index da7f4eb6c..3dcf24dc0 100644
--- a/robolectric/src/test/java/org/robolectric/CustomAppComponentFactoryTest.java
+++ b/robolectric/src/test/java/org/robolectric/CustomAppComponentFactoryTest.java
@@ -13,6 +13,7 @@ import android.os.Build;
 import android.os.Bundle;
 import android.os.IBinder;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import javax.annotation.Nonnull;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.CustomConstructorServices.CustomConstructorIntentService;
@@ -124,27 +125,28 @@ public class CustomAppComponentFactoryTest {
     }
 
     @Override
-    public Cursor query(Uri uri, String[] strings, String s, String[] strings1, String s1) {
+    public Cursor query(
+        @Nonnull Uri uri, String[] strings, String s, String[] strings1, String s1) {
       return null;
     }
 
     @Override
-    public String getType(Uri uri) {
+    public String getType(@Nonnull Uri uri) {
       return null;
     }
 
     @Override
-    public Uri insert(Uri uri, ContentValues contentValues) {
+    public Uri insert(@Nonnull Uri uri, ContentValues contentValues) {
       return null;
     }
 
     @Override
-    public int delete(Uri uri, String s, String[] strings) {
+    public int delete(@Nonnull Uri uri, String s, String[] strings) {
       return 0;
     }
 
     @Override
-    public int update(Uri uri, ContentValues contentValues, String s, String[] strings) {
+    public int update(@Nonnull Uri uri, ContentValues contentValues, String s, String[] strings) {
       return 0;
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/CustomConstructorContentProvider.java b/robolectric/src/test/java/org/robolectric/CustomConstructorContentProvider.java
index 8848f7d9f..268c9d9e1 100644
--- a/robolectric/src/test/java/org/robolectric/CustomConstructorContentProvider.java
+++ b/robolectric/src/test/java/org/robolectric/CustomConstructorContentProvider.java
@@ -4,6 +4,7 @@ import android.content.ContentProvider;
 import android.content.ContentValues;
 import android.database.Cursor;
 import android.net.Uri;
+import javax.annotation.Nonnull;
 
 public class CustomConstructorContentProvider extends ContentProvider {
   private final int intValue;
@@ -22,27 +23,27 @@ public class CustomConstructorContentProvider extends ContentProvider {
   }
 
   @Override
-  public Cursor query(Uri uri, String[] strings, String s, String[] strings1, String s1) {
+  public Cursor query(@Nonnull Uri uri, String[] strings, String s, String[] strings1, String s1) {
     return null;
   }
 
   @Override
-  public String getType(Uri uri) {
+  public String getType(@Nonnull Uri uri) {
     return null;
   }
 
   @Override
-  public Uri insert(Uri uri, ContentValues contentValues) {
+  public Uri insert(@Nonnull Uri uri, ContentValues contentValues) {
     return null;
   }
 
   @Override
-  public int delete(Uri uri, String s, String[] strings) {
+  public int delete(@Nonnull Uri uri, String s, String[] strings) {
     return 0;
   }
 
   @Override
-  public int update(Uri uri, ContentValues contentValues, String s, String[] strings) {
+  public int update(@Nonnull Uri uri, ContentValues contentValues, String s, String[] strings) {
     return 0;
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerConfigTest.java b/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerConfigTest.java
index 97c340e3a..3d4aeddb9 100644
--- a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerConfigTest.java
+++ b/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerConfigTest.java
@@ -39,7 +39,7 @@ public final class ParameterizedRobolectricTestRunnerConfigTest {
   }
 
   @ParameterizedRobolectricTestRunner.Parameters(name = "ConfigTest: {0}")
-  public static Collection getTestData() {
+  public static Collection<?> getTestData() {
     Object[][] data = {{1}, {2}, {3}, {4}};
     return Arrays.asList(data);
   }
diff --git a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerNormalTest.java b/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerNormalTest.java
index 975c4b6e9..e59d04051 100644
--- a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerNormalTest.java
+++ b/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerNormalTest.java
@@ -63,7 +63,7 @@ public final class ParameterizedRobolectricTestRunnerNormalTest {
   }
 
   @ParameterizedRobolectricTestRunner.Parameters(name = "Java Math Test: {0}, {1}")
-  public static Collection getTestData() {
+  public static Collection<?> getTestData() {
     Object[][] data = {
       {1, 1, 2, 0, 1, 1},
       {2, 1, 3, 1, 2, 2},
diff --git a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerUriTest.java b/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerUriTest.java
index 2e06614f6..aaf173ff3 100644
--- a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerUriTest.java
+++ b/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerUriTest.java
@@ -35,7 +35,7 @@ public final class ParameterizedRobolectricTestRunnerUriTest {
   }
 
   @ParameterizedRobolectricTestRunner.Parameters(name = "URI Test: {0} + {1}")
-  public static Collection getTestData() {
+  public static Collection<?> getTestData() {
     Object[][] data = {
       {"http://host", "resource", "http://host/resource"},
       {"http://host/", "resource", "http://host/resource"},
diff --git a/robolectric/src/test/java/org/robolectric/QualifiersTest.java b/robolectric/src/test/java/org/robolectric/QualifiersTest.java
index b2cdc16a4..5425fdd61 100644
--- a/robolectric/src/test/java/org/robolectric/QualifiersTest.java
+++ b/robolectric/src/test/java/org/robolectric/QualifiersTest.java
@@ -29,7 +29,7 @@ public class QualifiersTest {
 
   @Test
   @Config(sdk = 26)
-  public void testDefaultQualifiers() throws Exception {
+  public void testDefaultQualifiers() {
     assertThat(RuntimeEnvironment.getQualifiers())
         .isEqualTo(
             "en-rUS-ldltr-sw320dp-w320dp-h470dp-normal-notlong-notround-nowidecg-lowdr-port-notnight-mdpi-finger-keyssoft-nokeys-navhidden-nonav");
@@ -37,7 +37,7 @@ public class QualifiersTest {
 
   @Test
   @Config(qualifiers = "en", sdk = 26)
-  public void testDefaultQualifiers_withoutRegion() throws Exception {
+  public void testDefaultQualifiers_withoutRegion() {
     assertThat(RuntimeEnvironment.getQualifiers())
         .isEqualTo(
             "en-ldltr-sw320dp-w320dp-h470dp-normal-notlong-notround-nowidecg-lowdr-port-notnight-mdpi-finger-keyssoft-nokeys-navhidden-nonav");
@@ -73,19 +73,19 @@ public class QualifiersTest {
 
   @Test
   @Config(qualifiers = "fr")
-  public void shouldGetFromMethod() throws Exception {
+  public void shouldGetFromMethod() {
     assertThat(RuntimeEnvironment.getQualifiers()).contains("fr");
   }
 
   @Test
   @Config(qualifiers = "de")
-  public void getQuantityString() throws Exception {
+  public void getQuantityString() {
     assertThat(resources.getQuantityString(R.plurals.minute, 2))
         .isEqualTo(resources.getString(R.string.minute_plural));
   }
 
   @Test
-  public void inflateLayout_defaultsTo_sw320dp() throws Exception {
+  public void inflateLayout_defaultsTo_sw320dp() {
     View view =
         Robolectric.setupActivity(Activity.class)
             .getLayoutInflater()
@@ -98,7 +98,7 @@ public class QualifiersTest {
 
   @Test
   @Config(qualifiers = "sw720dp")
-  public void inflateLayout_overridesTo_sw720dp() throws Exception {
+  public void inflateLayout_overridesTo_sw720dp() {
     View view =
         Robolectric.setupActivity(Activity.class)
             .getLayoutInflater()
@@ -111,7 +111,7 @@ public class QualifiersTest {
 
   @Test
   @Config(qualifiers = "b+sr+Latn")
-  public void supportsBcp47() throws Exception {
+  public void supportsBcp47() {
     assertThat(resources.getString(R.string.hello)).isEqualTo("Zdravo");
   }
 
@@ -123,7 +123,7 @@ public class QualifiersTest {
 
   @Test
   @Config(qualifiers = "land")
-  public void setQualifiers_updatesSystemAndAppResources() throws Exception {
+  public void setQualifiers_updatesSystemAndAppResources() {
     Resources systemResources = Resources.getSystem();
     Resources appResources = getApplicationContext().getResources();
 
@@ -140,12 +140,12 @@ public class QualifiersTest {
   }
 
   @Test
-  public void setQualifiers_allowsSameSdkVersion() throws Exception {
+  public void setQualifiers_allowsSameSdkVersion() {
     RuntimeEnvironment.setQualifiers("v" + RuntimeEnvironment.getApiLevel());
   }
 
   @Test
-  public void setQualifiers_disallowsOtherSdkVersions() throws Exception {
+  public void setQualifiers_disallowsOtherSdkVersions() {
     try {
       RuntimeEnvironment.setQualifiers("v13");
       fail();
@@ -157,7 +157,7 @@ public class QualifiersTest {
 
   @Test
   @Config(minSdk = O, qualifiers = "widecg-highdr-vrheadset")
-  public void testQualifiersNewIn26() throws Exception {
+  public void testQualifiersNewIn26() {
     assertThat(RuntimeEnvironment.getQualifiers()).contains("-widecg-highdr-");
     assertThat(RuntimeEnvironment.getQualifiers()).contains("-vrheadset-");
   }
diff --git a/robolectric/src/test/java/org/robolectric/R.java b/robolectric/src/test/java/org/robolectric/R.java
index 9f3708e69..0e8c1ffb6 100644
--- a/robolectric/src/test/java/org/robolectric/R.java
+++ b/robolectric/src/test/java/org/robolectric/R.java
@@ -624,17 +624,19 @@ containing a value of this type.
     }
     public static final class xml {
         public static final int app_restrictions=0x7f070000;
-        public static final int dialog_preferences=0x7f070001;
-        public static final int has_attribute_resource_value=0x7f070002;
-        public static final int has_id=0x7f070003;
-        public static final int has_parent_style_reference=0x7f070004;
-        public static final int has_style_attribute_reference=0x7f070005;
-        public static final int preferences=0x7f070006;
-        public static final int shortcuts=0x7f070007;
-        public static final int temp=0x7f070008;
-        public static final int temp_parent=0x7f070009;
-        public static final int test_wallpaper=0x7f07000a;
-        public static final int xml_attrs=0x7f07000b;
+        public static final int attr_set=0x7f070001;
+        public static final int dialog_preferences=0x7f070002;
+        public static final int empty=0x7f070003;
+        public static final int has_attribute_resource_value=0x7f070004;
+        public static final int has_id=0x7f070005;
+        public static final int has_parent_style_reference=0x7f070006;
+        public static final int has_style_attribute_reference=0x7f070007;
+        public static final int preferences=0x7f070008;
+        public static final int shortcuts=0x7f070009;
+        public static final int temp=0x7f07000a;
+        public static final int temp_parent=0x7f07000b;
+        public static final int test_wallpaper=0x7f07000c;
+        public static final int xml_attrs=0x7f07000d;
     }
     public static final class styleable {
         /** Attributes that can be used with a CustomStateView.
diff --git a/robolectric/src/test/java/org/robolectric/ReflectorObjectTest.java b/robolectric/src/test/java/org/robolectric/ReflectorObjectTest.java
index a0b837716..e6503793f 100644
--- a/robolectric/src/test/java/org/robolectric/ReflectorObjectTest.java
+++ b/robolectric/src/test/java/org/robolectric/ReflectorObjectTest.java
@@ -25,12 +25,11 @@ public class ReflectorObjectTest {
 
   static final String TEST_STRING = "A test string.";
 
-  private SomeClass someClass;
   private ShadowClass shadowClass;
 
   @Before
   public void setUp() throws Exception {
-    someClass = new SomeClass();
+    SomeClass someClass = new SomeClass();
     shadowClass = Shadow.extract(someClass);
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/RobolectricTest.java b/robolectric/src/test/java/org/robolectric/RobolectricTest.java
index 57136aa4e..6ed6b17ec 100644
--- a/robolectric/src/test/java/org/robolectric/RobolectricTest.java
+++ b/robolectric/src/test/java/org/robolectric/RobolectricTest.java
@@ -8,14 +8,18 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.annotation.LooperMode.Mode.LEGACY;
+import static org.robolectric.res.AttributeResource.ANDROID_NS;
+import static org.robolectric.res.AttributeResource.RES_AUTO_NS_URI;
 
 import android.app.Activity;
 import android.app.Application;
 import android.content.ActivityNotFoundException;
 import android.content.Context;
 import android.content.Intent;
+import android.content.res.Resources;
 import android.os.Bundle;
 import android.os.Handler;
+import android.util.AttributeSet;
 import android.view.View;
 import android.view.View.OnClickListener;
 import android.view.ViewParent;
@@ -36,10 +40,10 @@ import org.robolectric.util.ReflectionHelpers;
 @RunWith(AndroidJUnit4.class)
 public class RobolectricTest {
 
-  private Application context = ApplicationProvider.getApplicationContext();
+  private final Application context = ApplicationProvider.getApplicationContext();
 
   @Test
-  public void clickOn_shouldThrowIfViewIsDisabled() throws Exception {
+  public void clickOn_shouldThrowIfViewIsDisabled() {
     View view = new View(context);
     view.setEnabled(false);
     assertThrows(RuntimeException.class, () -> ShadowView.clickOn(view));
@@ -47,14 +51,14 @@ public class RobolectricTest {
 
   @Test
   @LooperMode(LEGACY)
-  public void shouldResetBackgroundSchedulerBeforeTests() throws Exception {
+  public void shouldResetBackgroundSchedulerBeforeTests() {
     assertThat(Robolectric.getBackgroundThreadScheduler().isPaused()).isFalse();
     Robolectric.getBackgroundThreadScheduler().pause();
   }
 
   @Test
   @LooperMode(LEGACY)
-  public void shouldResetBackgroundSchedulerAfterTests() throws Exception {
+  public void shouldResetBackgroundSchedulerAfterTests() {
     assertThat(Robolectric.getBackgroundThreadScheduler().isPaused()).isFalse();
     Robolectric.getBackgroundThreadScheduler().pause();
   }
@@ -72,7 +76,7 @@ public class RobolectricTest {
   }
 
   @Test
-  public void clickOn_shouldCallClickListener() throws Exception {
+  public void clickOn_shouldCallClickListener() {
     View view = new View(context);
     shadowOf(view).setMyParent(ReflectionHelpers.createNullProxy(ViewParent.class));
     OnClickListener testOnClickListener = mock(OnClickListener.class);
@@ -83,7 +87,7 @@ public class RobolectricTest {
   }
 
   @Test
-  public void checkActivities_shouldSetValueOnShadowApplication() throws Exception {
+  public void checkActivities_shouldSetValueOnShadowApplication() {
     ShadowApplication.getInstance().checkActivities(true);
     assertThrows(
         ActivityNotFoundException.class,
@@ -94,7 +98,7 @@ public class RobolectricTest {
 
   @Test
   @Config(sdk = Config.NEWEST_SDK)
-  public void setupActivity_returnsAVisibleActivity() throws Exception {
+  public void setupActivity_returnsAVisibleActivity() {
     LifeCycleActivity activity = Robolectric.setupActivity(LifeCycleActivity.class);
 
     assertThat(activity.isCreated()).isTrue();
@@ -103,6 +107,34 @@ public class RobolectricTest {
     assertThat(activity.isVisible()).isTrue();
   }
 
+  @Test
+  public void getAttributeSetFromXml_androidNs() {
+    AttributeSet roboAttributeSet = Robolectric.getAttributeSetFromXml(R.xml.attr_set);
+
+    assertThat(roboAttributeSet.getAttributeCount()).isEqualTo(2);
+    assertThat(roboAttributeSet.getAttributeResourceValue(ANDROID_NS, "text", 0))
+        .isEqualTo(android.R.string.ok);
+  }
+
+  @Test
+  public void getAttributeSetFromXml_appNs() {
+    AttributeSet roboAttributeSet = Robolectric.getAttributeSetFromXml(R.xml.attr_set);
+
+    assertThat(roboAttributeSet.getAttributeValue(RES_AUTO_NS_URI, "title")).isEqualTo("my title");
+  }
+
+  @Test
+  public void getAttributeSetFromXml_invalidXmlResId() {
+    assertThrows(Resources.NotFoundException.class, () -> Robolectric.getAttributeSetFromXml(1234));
+  }
+
+  @Test
+  public void getAttributeSetFromXml_emptyXml() {
+    AttributeSet emptySet = Robolectric.getAttributeSetFromXml(R.xml.empty);
+    assertThat(emptySet).isNotNull();
+    assertThat(emptySet.getAttributeCount()).isEqualTo(0);
+  }
+
   @Implements(View.class)
   public static class TestShadowView {
     @Implementation
diff --git a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerCleanupTest.java b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerCleanupTest.java
index 876d61357..81c511121 100644
--- a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerCleanupTest.java
+++ b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerCleanupTest.java
@@ -51,6 +51,6 @@ public class RobolectricTestRunnerCleanupTest {
   @Ignore
   public static class TestWithEmptyTest {
     @Test
-    public void emptyTest() throws Exception {}
+    public void emptyTest() {}
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerMultiApiTest.java b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerMultiApiTest.java
index ea96e0ddc..caae4b929 100644
--- a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerMultiApiTest.java
+++ b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerMultiApiTest.java
@@ -17,8 +17,8 @@ import java.util.Arrays;
 import java.util.List;
 import java.util.stream.Collectors;
 import javax.annotation.Nonnull;
-import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.Description;
 import org.junit.runner.RunWith;
@@ -28,6 +28,7 @@ import org.junit.runners.JUnit4;
 import org.junit.runners.model.FrameworkMethod;
 import org.junit.runners.model.InitializationError;
 import org.robolectric.annotation.Config;
+import org.robolectric.junit.rules.SetSystemPropertyRule;
 import org.robolectric.pluginapi.Sdk;
 import org.robolectric.pluginapi.SdkPicker;
 import org.robolectric.plugins.DefaultSdkPicker;
@@ -46,15 +47,13 @@ public class RobolectricTestRunnerMultiApiTest {
           .bind(SdkPicker.class, (config, usesSdk) -> delegateSdkPicker.selectSdks(config, usesSdk))
           .build();
 
+  @Rule public SetSystemPropertyRule setSystemPropertyRule = new SetSystemPropertyRule();
+
   private RobolectricTestRunner runner;
   private RunNotifier runNotifier;
   private MyRunListener runListener;
 
   private int numSupportedApis;
-  private String priorResourcesMode;
-  private String priorAlwaysInclude;
-
-  private SdkCollection sdkCollection;
 
   @Before
   public void setUp() {
@@ -63,19 +62,9 @@ public class RobolectricTestRunnerMultiApiTest {
     runListener = new MyRunListener();
     runNotifier = new RunNotifier();
     runNotifier.addListener(runListener);
-    sdkCollection = new SdkCollection(() -> map(APIS_FOR_TEST));
+    SdkCollection sdkCollection = new SdkCollection(() -> map(APIS_FOR_TEST));
     delegateSdkPicker = new DefaultSdkPicker(sdkCollection, null);
-
-    priorResourcesMode = System.getProperty("robolectric.resourcesMode");
-
-    priorAlwaysInclude = System.getProperty("robolectric.alwaysIncludeVariantMarkersInTestName");
-    System.clearProperty("robolectric.alwaysIncludeVariantMarkersInTestName");
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    TestUtil.resetSystemProperty(
-        "robolectric.alwaysIncludeVariantMarkersInTestName", priorAlwaysInclude);
+    setSystemPropertyRule.clear("robolectric.alwaysIncludeVariantMarkersInTestName");
   }
 
   @Test
@@ -337,22 +326,22 @@ public class RobolectricTestRunnerMultiApiTest {
   }
 
   private static class MyRunListener extends RunListener {
-    private List<String> started = new ArrayList<>();
-    private List<String> finished = new ArrayList<>();
-    private List<String> ignored = new ArrayList<>();
+    private final List<String> started = new ArrayList<>();
+    private final List<String> finished = new ArrayList<>();
+    private final List<String> ignored = new ArrayList<>();
 
     @Override
-    public void testStarted(Description description) throws Exception {
+    public void testStarted(Description description) {
       started.add(description.getDisplayName());
     }
 
     @Override
-    public void testFinished(Description description) throws Exception {
+    public void testFinished(Description description) {
       finished.add(description.getDisplayName());
     }
 
     @Override
-    public void testIgnored(Description description) throws Exception {
+    public void testIgnored(Description description) {
       ignored.add(description.getDisplayName());
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerSelfTest.java b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerSelfTest.java
index 6601076e6..c495b64a0 100644
--- a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerSelfTest.java
+++ b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerSelfTest.java
@@ -81,7 +81,7 @@ public class RobolectricTestRunnerSelfTest {
   }
 
   @Test
-  public void hamcrestMatchersDontBlowUpDuringLinking() throws Exception {
+  public void hamcrestMatchersDontBlowUpDuringLinking() {
     org.hamcrest.MatcherAssert.assertThat(true, CoreMatchers.is(true));
   }
 
@@ -102,8 +102,7 @@ public class RobolectricTestRunnerSelfTest {
 
     @Override
     public void onTerminate() {
-      onTerminateCalledFromMain =
-          Boolean.valueOf(Looper.getMainLooper().getThread() == Thread.currentThread());
+      onTerminateCalledFromMain = Looper.getMainLooper().getThread() == Thread.currentThread();
     }
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerTest.java b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerTest.java
index 4a539dcfc..0a820f930 100644
--- a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerTest.java
+++ b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerTest.java
@@ -11,9 +11,9 @@ import android.app.Application;
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
-import java.io.FileOutputStream;
 import java.lang.reflect.Method;
 import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.spi.FileSystemProvider;
@@ -26,7 +26,6 @@ import java.util.jar.JarOutputStream;
 import javax.annotation.Nonnull;
 import javax.inject.Inject;
 import javax.inject.Named;
-import org.junit.After;
 import org.junit.AfterClass;
 import org.junit.AssumptionViolatedException;
 import org.junit.Before;
@@ -69,8 +68,6 @@ public class RobolectricTestRunnerTest {
 
   private RunNotifier notifier;
   private List<String> events;
-  private String priorEnabledSdks;
-  private String priorAlwaysInclude;
   private SdkCollection sdkCollection;
 
   @Rule public SetSystemPropertyRule setSystemPropertyRule = new SetSystemPropertyRule();
@@ -80,23 +77,11 @@ public class RobolectricTestRunnerTest {
     notifier = new RunNotifier();
     events = new ArrayList<>();
     notifier.addListener(new MyRunListener());
-
-    priorEnabledSdks = System.getProperty("robolectric.enabledSdks");
-    System.clearProperty("robolectric.enabledSdks");
-
-    priorAlwaysInclude = System.getProperty("robolectric.alwaysIncludeVariantMarkersInTestName");
-    System.clearProperty("robolectric.alwaysIncludeVariantMarkersInTestName");
-
+    setSystemPropertyRule.clear("robolectric.enabledSdks");
+    setSystemPropertyRule.clear("robolectric.alwaysIncludeVariantMarkersInTestName");
     sdkCollection = TestUtil.getSdkCollection();
   }
 
-  @After
-  public void tearDown() throws Exception {
-    TestUtil.resetSystemProperty(
-        "robolectric.alwaysIncludeVariantMarkersInTestName", priorAlwaysInclude);
-    TestUtil.resetSystemProperty("robolectric.enabledSdks", priorEnabledSdks);
-  }
-
   @Test
   public void ignoredTestCanSpecifyUnsupportedSdkWithoutExploding() throws Exception {
     RobolectricTestRunner runner =
@@ -352,14 +337,14 @@ public class RobolectricTestRunnerTest {
   public static class TestWithOldSdk {
     @Config(sdk = Build.VERSION_CODES.HONEYCOMB)
     @Test
-    public void oldSdkMethod() throws Exception {
+    public void oldSdkMethod() {
       fail("I should not be run!");
     }
 
     @Ignore("This test shouldn't run, and shouldn't cause the test runner to fail")
     @Config(sdk = Build.VERSION_CODES.HONEYCOMB)
     @Test
-    public void ignoredOldSdkMethod() throws Exception {
+    public void ignoredOldSdkMethod() {
       fail("I should not be run!");
     }
   }
@@ -438,7 +423,7 @@ public class RobolectricTestRunnerTest {
 
       try {
         Path jarPath = tempDirectory.create("some-jar").resolve("some.jar");
-        try (JarOutputStream out = new JarOutputStream(new FileOutputStream(jarPath.toFile()))) {
+        try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(jarPath))) {
           out.putNextEntry(new JarEntry("README.txt"));
           out.write("hi!".getBytes(StandardCharsets.UTF_8));
         }
@@ -534,12 +519,14 @@ public class RobolectricTestRunnerTest {
     @Override
     public void testFailure(Failure failure) {
       Throwable exception = failure.getException();
-      String message = exception.getMessage();
-      if (message == null) {
-        message = exception.toString();
+      StringBuilder message = new StringBuilder();
+      if (exception.getMessage() == null) {
+        message.append(exception);
+      } else {
+        message.append(exception.getMessage());
       }
       for (Throwable suppressed : exception.getSuppressed()) {
-        message += "\nSuppressed: " + suppressed.getMessage();
+        message.append("\nSuppressed: ").append(suppressed.getMessage());
       }
       events.add("failure: " + message);
     }
diff --git a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerThreadTest.java b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerThreadTest.java
index d1f85466a..efd15892e 100644
--- a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerThreadTest.java
+++ b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerThreadTest.java
@@ -16,7 +16,7 @@ public class RobolectricTestRunnerThreadTest {
   private static ClassLoader sClassLoader;
 
   @BeforeClass
-  public static void beforeClass() throws Exception {
+  public static void beforeClass() {
     sThread = Thread.currentThread();
     sClassLoader = Thread.currentThread().getContextClassLoader();
   }
@@ -46,7 +46,7 @@ public class RobolectricTestRunnerThreadTest {
   }
 
   @AfterClass
-  public static void afterClass() throws Exception {
+  public static void afterClass() {
     assertThat(Thread.currentThread()).isEqualTo(sThread);
     assertThat(Thread.currentThread().getContextClassLoader()).isEqualTo(sClassLoader);
   }
diff --git a/robolectric/src/test/java/org/robolectric/RuntimeEnvironmentTest.java b/robolectric/src/test/java/org/robolectric/RuntimeEnvironmentTest.java
index de5cf5ee7..326c155c5 100644
--- a/robolectric/src/test/java/org/robolectric/RuntimeEnvironmentTest.java
+++ b/robolectric/src/test/java/org/robolectric/RuntimeEnvironmentTest.java
@@ -45,13 +45,11 @@ public class RuntimeEnvironmentTest {
     final AtomicBoolean res = new AtomicBoolean();
     final CountDownLatch finished = new CountDownLatch(1);
     Thread t =
-        new Thread() {
-          @Override
-          public void run() {
-            res.set(RuntimeEnvironment.isMainThread());
-            finished.countDown();
-          }
-        };
+        new Thread(
+            () -> {
+              res.set(RuntimeEnvironment.isMainThread());
+              finished.countDown();
+            });
     RuntimeEnvironment.setMainThread(Thread.currentThread());
     t.start();
     if (!finished.await(1000, MILLISECONDS)) {
@@ -83,7 +81,7 @@ public class RuntimeEnvironmentTest {
 
   @Test
   @LooperMode(LEGACY)
-  public void isMainThread_withArg_forNewThread_withSwitch() throws InterruptedException {
+  public void isMainThread_withArg_forNewThread_withSwitch() {
     Thread t = new Thread();
     RuntimeEnvironment.setMainThread(t);
     assertThat(RuntimeEnvironment.isMainThread(t)).isTrue();
diff --git a/robolectric/src/test/java/org/robolectric/TemporaryBindingsTest.java b/robolectric/src/test/java/org/robolectric/TemporaryBindingsTest.java
index a8ae53cdd..8ce62526d 100644
--- a/robolectric/src/test/java/org/robolectric/TemporaryBindingsTest.java
+++ b/robolectric/src/test/java/org/robolectric/TemporaryBindingsTest.java
@@ -20,7 +20,7 @@ public class TemporaryBindingsTest {
 
   @Test
   @Config(shadows = TemporaryShadowView.class)
-  public void overridingShadowBindingsShouldNotAffectBindingsInLaterTests() throws Exception {
+  public void overridingShadowBindingsShouldNotAffectBindingsInLaterTests() {
     TemporaryShadowView shadowView =
         Shadow.extract(new View(ApplicationProvider.getApplicationContext()));
     assertThat(shadowView.getClass().getSimpleName())
@@ -28,7 +28,7 @@ public class TemporaryBindingsTest {
   }
 
   @Test
-  public void overridingShadowBindingsShouldNotAffectBindingsInLaterTestsAgain() throws Exception {
+  public void overridingShadowBindingsShouldNotAffectBindingsInLaterTestsAgain() {
     assertThat(
             shadowOf(new View(ApplicationProvider.getApplicationContext()))
                 .getClass()
diff --git a/robolectric/src/test/java/org/robolectric/android/AndroidTranslatorClassInstrumentedTest.java b/robolectric/src/test/java/org/robolectric/android/AndroidTranslatorClassInstrumentedTest.java
index 4aa4a44b1..7c7a0867c 100644
--- a/robolectric/src/test/java/org/robolectric/android/AndroidTranslatorClassInstrumentedTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/AndroidTranslatorClassInstrumentedTest.java
@@ -18,7 +18,7 @@ public class AndroidTranslatorClassInstrumentedTest {
 
   @Test
   @Config(shadows = ShadowPaintForTests.class)
-  public void testNativeMethodsAreDelegated() throws Exception {
+  public void testNativeMethodsAreDelegated() {
     Paint paint = new Paint();
     paint.setColor(1234);
 
@@ -45,7 +45,7 @@ public class AndroidTranslatorClassInstrumentedTest {
    */
   @Test
   @Config(shadows = {ShadowCustomPaint.class, ShadowPaintForTests.class})
-  public void testCustomMethodShadowed() throws Exception {
+  public void testCustomMethodShadowed() {
     CustomPaint customPaint = new CustomPaint();
     assertThat(customPaint.getColor()).isEqualTo(10);
     assertThat(customPaint.getColorName()).isEqualTo("rainbow");
diff --git a/robolectric/src/test/java/org/robolectric/android/BootstrapTest.java b/robolectric/src/test/java/org/robolectric/android/BootstrapTest.java
index d3f302cb7..a57c480e6 100644
--- a/robolectric/src/test/java/org/robolectric/android/BootstrapTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/BootstrapTest.java
@@ -75,7 +75,7 @@ public class BootstrapTest {
 
   @Test
   @Config(qualifiers = "w480dp-h640dp")
-  public void shouldSetUpRealisticDisplay() throws Exception {
+  public void shouldSetUpRealisticDisplay() {
     DisplayManager displayManager =
         (DisplayManager)
             ApplicationProvider.getApplicationContext().getSystemService(Context.DISPLAY_SERVICE);
@@ -106,7 +106,7 @@ public class BootstrapTest {
 
   @Test
   @Config(qualifiers = "w480dp-h640dp-land-hdpi")
-  public void shouldSetUpRealisticDisplay_landscapeHighDensity() throws Exception {
+  public void shouldSetUpRealisticDisplay_landscapeHighDensity() {
     DisplayManager displayManager =
         (DisplayManager)
             ApplicationProvider.getApplicationContext().getSystemService(Context.DISPLAY_SERVICE);
@@ -228,7 +228,7 @@ public class BootstrapTest {
   }
 
   @Test
-  public void applyQualifiers_longShouldMakeScreenTaller() throws Exception {
+  public void applyQualifiers_longShouldMakeScreenTaller() {
     Bootstrap.applyQualifiers(
         "long", RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
     assertThat(configuration.smallestScreenWidthDp).isEqualTo(320);
@@ -239,8 +239,7 @@ public class BootstrapTest {
   }
 
   @Test
-  public void whenScreenRationGreatherThan175Percent_applyQualifiers_ShouldSetLong()
-      throws Exception {
+  public void whenScreenRationGreaterThan175Percent_applyQualifiers_ShouldSetLong() {
     Bootstrap.applyQualifiers(
         "w400dp-h200dp", RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
     assertThat(configuration.screenWidthDp).isEqualTo(400);
@@ -301,7 +300,7 @@ public class BootstrapTest {
   }
 
   @Test
-  public void applyQualifiers_shouldSetLocaleScript() throws Exception {
+  public void applyQualifiers_shouldSetLocaleScript() {
     Bootstrap.applyQualifiers(
         "b+sr+Latn", RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
     String outQualifiers = ConfigurationV25.resourceQualifierString(configuration, displayMetrics);
@@ -319,7 +318,7 @@ public class BootstrapTest {
   }
 
   @Test
-  public void spaceSeparated_applyQualifiers_shouldReplaceQualifiers() throws Exception {
+  public void spaceSeparated_applyQualifiers_shouldReplaceQualifiers() {
     Bootstrap.applyQualifiers(
         "ru-rRU-h123dp-large fr-w321dp",
         RuntimeEnvironment.getApiLevel(),
@@ -331,7 +330,7 @@ public class BootstrapTest {
   }
 
   @Test
-  public void whenPrefixedWithPlus_applyQualifiers_shouldOverlayQualifiers() throws Exception {
+  public void whenPrefixedWithPlus_applyQualifiers_shouldOverlayQualifiers() {
     Bootstrap.applyQualifiers(
         "+en ru-rRU-h123dp-large +fr-w321dp-small",
         RuntimeEnvironment.getApiLevel(),
@@ -343,7 +342,7 @@ public class BootstrapTest {
   }
 
   @Test
-  public void whenAllPrefixedWithPlus_applyQualifiers_shouldOverlayQualifiers() throws Exception {
+  public void whenAllPrefixedWithPlus_applyQualifiers_shouldOverlayQualifiers() {
     Bootstrap.applyQualifiers(
         "+xxhdpi +ru-rRU-h123dp-large +fr-w321dp-small",
         RuntimeEnvironment.getApiLevel(),
diff --git a/robolectric/src/test/java/org/robolectric/android/DefaultPackageManagerIntentComparatorTest.java b/robolectric/src/test/java/org/robolectric/android/DefaultPackageManagerIntentComparatorTest.java
index 16a3880f4..beefe63d4 100644
--- a/robolectric/src/test/java/org/robolectric/android/DefaultPackageManagerIntentComparatorTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/DefaultPackageManagerIntentComparatorTest.java
@@ -29,8 +29,8 @@ public class DefaultPackageManagerIntentComparatorTest {
   public void canSustainConcurrentModification() {
     final IntentComparator intentComparator = new IntentComparator();
 
-    Intent intent1 = new Intent("actionstring0");
-    Intent intent2 = new Intent("actionstring1");
+    Intent intent1 = new Intent("actionString0");
+    Intent intent2 = new Intent("actionString1");
     assertThat(intentComparator.compare(intent1, intent2)).isEqualTo(-1);
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/android/DeviceConfigTest.java b/robolectric/src/test/java/org/robolectric/android/DeviceConfigTest.java
index b65a630ab..1f85d348e 100644
--- a/robolectric/src/test/java/org/robolectric/android/DeviceConfigTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/DeviceConfigTest.java
@@ -120,7 +120,7 @@ public class DeviceConfigTest {
   }
 
   @Test
-  public void applyRules_heightWidthOrientation() throws Exception {
+  public void applyRules_heightWidthOrientation() {
     applyQualifiers("w800dp-h400dp-port");
     DeviceConfig.applyRules(configuration, displayMetrics, apiLevel);
 
diff --git a/robolectric/src/test/java/org/robolectric/android/PreferenceIntegrationTest.java b/robolectric/src/test/java/org/robolectric/android/PreferenceIntegrationTest.java
index 14b07ec1d..1766ee24f 100644
--- a/robolectric/src/test/java/org/robolectric/android/PreferenceIntegrationTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/PreferenceIntegrationTest.java
@@ -24,7 +24,7 @@ import org.robolectric.Robolectric;
 public class PreferenceIntegrationTest {
 
   @Test
-  public void inflate_shouldCreateCorrectClasses() throws Exception {
+  public void inflate_shouldCreateCorrectClasses() {
     final PreferenceScreen screen = inflatePreferenceActivity();
     assertThat(screen.getPreference(0)).isInstanceOf(PreferenceCategory.class);
 
@@ -47,7 +47,7 @@ public class PreferenceIntegrationTest {
   }
 
   @Test
-  public void inflate_shouldParseIntentContainedInPreference() throws Exception {
+  public void inflate_shouldParseIntentContainedInPreference() {
     final PreferenceScreen screen = inflatePreferenceActivity();
     final Preference intentPreference = screen.findPreference("intent");
 
@@ -61,14 +61,14 @@ public class PreferenceIntegrationTest {
   }
 
   @Test
-  public void inflate_shouldBindPreferencesToPreferenceManager() throws Exception {
+  public void inflate_shouldBindPreferencesToPreferenceManager() {
     final PreferenceScreen screen = inflatePreferenceActivity();
     final Preference preference = screen.findPreference("preference");
     assertThat(preference.getPreferenceManager().findPreference("preference")).isNotNull();
   }
 
   @Test
-  public void setPersistent_shouldMarkThePreferenceAsPersistent() throws Exception {
+  public void setPersistent_shouldMarkThePreferenceAsPersistent() {
     final PreferenceScreen screen = inflatePreferenceActivity();
     final Preference preference = screen.findPreference("preference");
 
@@ -80,7 +80,7 @@ public class PreferenceIntegrationTest {
   }
 
   @Test
-  public void setEnabled_shouldEnableThePreference() throws Exception {
+  public void setEnabled_shouldEnableThePreference() {
     final PreferenceScreen screen = inflatePreferenceActivity();
     final Preference preference = screen.findPreference("preference");
 
@@ -92,7 +92,7 @@ public class PreferenceIntegrationTest {
   }
 
   @Test
-  public void setOrder_shouldSetOrderOnPreference() throws Exception {
+  public void setOrder_shouldSetOrderOnPreference() {
     final PreferenceScreen screen = inflatePreferenceActivity();
     final Preference preference = screen.findPreference("preference");
 
@@ -104,7 +104,7 @@ public class PreferenceIntegrationTest {
   }
 
   @Test
-  public void setDependency_shouldSetDependencyBetweenPreferences() throws Exception {
+  public void setDependency_shouldSetDependencyBetweenPreferences() {
     final PreferenceScreen screen = inflatePreferenceActivity();
     final Preference dependant = screen.findPreference("dependant");
     assertThat(dependant.getDependency()).isEqualTo("preference");
@@ -114,18 +114,15 @@ public class PreferenceIntegrationTest {
   }
 
   @Test
-  public void click_shouldCallPreferenceClickListener() throws Exception {
+  public void click_shouldCallPreferenceClickListener() {
     final PreferenceScreen screen = inflatePreferenceActivity();
     final Preference preference = screen.findPreference("preference");
 
     boolean[] holder = new boolean[1];
     preference.setOnPreferenceClickListener(
-        new Preference.OnPreferenceClickListener() {
-          @Override
-          public boolean onPreferenceClick(Preference preference) {
-            holder[0] = true;
-            return true;
-          }
+        clickedPreference -> {
+          holder[0] = true;
+          return true;
         });
 
     shadowOf(preference).click();
diff --git a/robolectric/src/test/java/org/robolectric/android/ShadowingTest.java b/robolectric/src/test/java/org/robolectric/android/ShadowingTest.java
index abfb5a15a..6610f617e 100644
--- a/robolectric/src/test/java/org/robolectric/android/ShadowingTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/ShadowingTest.java
@@ -1,7 +1,7 @@
 package org.robolectric.android;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
 
 import android.util.Log;
 import android.view.View;
@@ -16,23 +16,23 @@ import org.junit.runner.RunWith;
 public class ShadowingTest {
 
   @Test
-  public void testPrintlnWorks() throws Exception {
+  public void testPrintlnWorks() {
     Log.println(1, "tag", "msg");
   }
 
   @Test
-  public void shouldDelegateToObjectToStringIfShadowHasNone() throws Exception {
+  public void shouldDelegateToObjectToStringIfShadowHasNone() {
     assertThat(new Toast(ApplicationProvider.getApplicationContext()).toString())
         .startsWith("android.widget.Toast@");
   }
 
   @Test
-  public void shouldDelegateToObjectHashCodeIfShadowHasNone() throws Exception {
-    assertFalse(new View(ApplicationProvider.getApplicationContext()).hashCode() == 0);
+  public void shouldDelegateToObjectHashCodeIfShadowHasNone() {
+    assertNotEquals(0, new View(ApplicationProvider.getApplicationContext()).hashCode());
   }
 
   @Test
-  public void shouldDelegateToObjectEqualsIfShadowHasNone() throws Exception {
+  public void shouldDelegateToObjectEqualsIfShadowHasNone() {
     View view = new View(ApplicationProvider.getApplicationContext());
     new EqualsTester().addEqualityGroup(view).testEquals();
   }
diff --git a/robolectric/src/test/java/org/robolectric/android/XmlResourceParserImplTest.java b/robolectric/src/test/java/org/robolectric/android/XmlResourceParserImplTest.java
index db087a50d..bd8b0441b 100644
--- a/robolectric/src/test/java/org/robolectric/android/XmlResourceParserImplTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/XmlResourceParserImplTest.java
@@ -240,12 +240,8 @@ public class XmlResourceParserImplTest {
     List<Integer> actualDepths = new ArrayList<>();
     int evt;
     while ((evt = parser.next()) != XmlResourceParser.END_DOCUMENT) {
-      switch (evt) {
-        case (XmlResourceParser.START_TAG):
-          {
-            actualDepths.add(parser.getDepth());
-            break;
-          }
+      if (evt == XmlResourceParser.START_TAG) {
+        actualDepths.add(parser.getDepth());
       }
     }
     assertThat(actualDepths).isEqualTo(expectedDepths);
@@ -349,17 +345,17 @@ public class XmlResourceParserImplTest {
   public void testIsEmptyElementTag() throws Exception {
     assertWithMessage("Before START_DOCUMENT should return false.")
         .that(parser.isEmptyElementTag())
-        .isEqualTo(false);
+        .isFalse();
 
     forgeAndOpenDocument("<foo><bar/></foo>");
     assertWithMessage("Not empty tag should return false.")
         .that(parser.isEmptyElementTag())
-        .isEqualTo(false);
+        .isFalse();
 
     forgeAndOpenDocument("<foo/>");
     assertWithMessage("In the Android implementation this method always return false.")
         .that(parser.isEmptyElementTag())
-        .isEqualTo(false);
+        .isFalse();
   }
 
   @Test
@@ -388,7 +384,7 @@ public class XmlResourceParserImplTest {
   @Test
   public void testGetAttributeEscapedValue() {
     forgeAndOpenDocument("<foo bar=\"\\'\"/>");
-    assertThat(parser.getAttributeValue(0)).isEqualTo("\'");
+    assertThat(parser.getAttributeValue(0)).isEqualTo("'");
   }
 
   @Test
@@ -399,8 +395,8 @@ public class XmlResourceParserImplTest {
 
   @Test
   public void testGetNodeTextEscapedValue() {
-    forgeAndOpenDocument("<foo>\'</foo>");
-    assertThat(parser.getText()).isEqualTo("\'");
+    forgeAndOpenDocument("<foo>'</foo>");
+    assertThat(parser.getText()).isEqualTo("'");
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/android/controller/ActivityControllerTest.java b/robolectric/src/test/java/org/robolectric/android/controller/ActivityControllerTest.java
index 6fe75980f..c6eec92d0 100644
--- a/robolectric/src/test/java/org/robolectric/android/controller/ActivityControllerTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/controller/ActivityControllerTest.java
@@ -28,6 +28,7 @@ import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -101,14 +102,14 @@ public class ActivityControllerTest {
   }
 
   @Test
-  public void shouldSetIntent() throws Exception {
+  public void shouldSetIntent() {
     MyActivity myActivity = controller.create().get();
     assertThat(myActivity.getIntent()).isNotNull();
     assertThat(myActivity.getIntent().getComponent()).isEqualTo(componentName);
   }
 
   @Test
-  public void shouldSetIntentComponentWithCustomIntentWithoutComponentSet() throws Exception {
+  public void shouldSetIntentComponentWithCustomIntentWithoutComponentSet() {
     MyActivity myActivity =
         Robolectric.buildActivity(MyActivity.class, new Intent(Intent.ACTION_VIEW)).create().get();
     assertThat(myActivity.getIntent().getAction()).isEqualTo(Intent.ACTION_VIEW);
@@ -116,7 +117,7 @@ public class ActivityControllerTest {
   }
 
   @Test
-  public void shouldSetIntentForGivenActivityInstance() throws Exception {
+  public void shouldSetIntentForGivenActivityInstance() {
     ActivityController<MyActivity> activityController =
         ActivityController.of(new MyActivity()).create();
     assertThat(activityController.get().getIntent()).isNotNull();
@@ -124,7 +125,7 @@ public class ActivityControllerTest {
 
   @Test
   @LooperMode(LEGACY)
-  public void whenLooperIsNotPaused_shouldCreateWithMainLooperPaused() throws Exception {
+  public void whenLooperIsNotPaused_shouldCreateWithMainLooperPaused() {
     ShadowLooper.unPauseMainLooper();
     controller.create();
     assertThat(shadowOf(Looper.getMainLooper()).isPaused()).isFalse();
@@ -132,7 +133,7 @@ public class ActivityControllerTest {
   }
 
   @Test
-  public void whenLooperIsAlreadyPaused_shouldCreateWithMainLooperPaused() throws Exception {
+  public void whenLooperIsAlreadyPaused_shouldCreateWithMainLooperPaused() {
     shadowMainLooper().pause();
     controller.create();
     assertThat(transcript).contains("finishedOnCreate");
@@ -448,7 +449,6 @@ public class ActivityControllerTest {
   public void close_transitionsActivityStateToDestroyed() {
     Robolectric.buildActivity(MyActivity.class).close();
     assertThat(transcript).isEmpty();
-    transcript.clear();
 
     Robolectric.buildActivity(MyActivity.class).create().close();
     assertThat(transcript)
@@ -551,14 +551,14 @@ public class ActivityControllerTest {
 
   public static class MyActivity extends Activity {
     @Override
-    protected void onRestoreInstanceState(Bundle savedInstanceState) {
+    protected void onRestoreInstanceState(@Nonnull Bundle savedInstanceState) {
       super.onRestoreInstanceState(savedInstanceState);
       transcribeWhilePaused("onRestoreInstanceState");
       transcript.add("finishedOnRestoreInstanceState");
     }
 
     @Override
-    protected void onSaveInstanceState(Bundle outState) {
+    protected void onSaveInstanceState(@Nonnull Bundle outState) {
       super.onSaveInstanceState(outState);
       transcribeWhilePaused("onSaveInstanceState");
       transcript.add("finishedOnSaveInstanceState");
@@ -651,7 +651,7 @@ public class ActivityControllerTest {
     }
 
     @Override
-    public void onConfigurationChanged(Configuration newConfig) {
+    public void onConfigurationChanged(@Nonnull Configuration newConfig) {
       super.onConfigurationChanged(newConfig);
       transcribeWhilePaused("onConfigurationChanged");
       transcript.add("finishedOnConfigurationChanged");
@@ -687,13 +687,13 @@ public class ActivityControllerTest {
     }
 
     @Override
-    public void onSaveInstanceState(Bundle outState) {
+    public void onSaveInstanceState(@Nonnull Bundle outState) {
       super.onSaveInstanceState(outState);
       outState.putSerializable("test", new Exception());
     }
 
     @Override
-    public void onConfigurationChanged(Configuration newConfig) {
+    public void onConfigurationChanged(@Nonnull Configuration newConfig) {
       this.newConfig = new Configuration(newConfig);
       super.onConfigurationChanged(newConfig);
     }
diff --git a/robolectric/src/test/java/org/robolectric/android/controller/BackupAgentControllerTest.java b/robolectric/src/test/java/org/robolectric/android/controller/BackupAgentControllerTest.java
index e293d6ac4..8dc117cbc 100644
--- a/robolectric/src/test/java/org/robolectric/android/controller/BackupAgentControllerTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/controller/BackupAgentControllerTest.java
@@ -20,7 +20,7 @@ public class BackupAgentControllerTest {
       Robolectric.buildBackupAgent(MyBackupAgent.class);
 
   @Test
-  public void shouldSetBaseContext() throws Exception {
+  public void shouldSetBaseContext() {
     MyBackupAgent myBackupAgent = backupAgentController.get();
     assertThat(myBackupAgent.getBaseContext())
         .isEqualTo(((Application) ApplicationProvider.getApplicationContext()).getBaseContext());
diff --git a/robolectric/src/test/java/org/robolectric/android/controller/ContentProviderControllerTest.java b/robolectric/src/test/java/org/robolectric/android/controller/ContentProviderControllerTest.java
index 3981356b9..1f56a7259 100644
--- a/robolectric/src/test/java/org/robolectric/android/controller/ContentProviderControllerTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/controller/ContentProviderControllerTest.java
@@ -33,14 +33,14 @@ public class ContentProviderControllerTest {
   }
 
   @Test
-  public void shouldSetBaseContext() throws Exception {
+  public void shouldSetBaseContext() {
     TestContentProvider1 myContentProvider = controller.create().get();
     assertThat(myContentProvider.getContext())
         .isEqualTo(((Application) ApplicationProvider.getApplicationContext()).getBaseContext());
   }
 
   @Test
-  public void shouldInitializeFromManifestProviderInfo() throws Exception {
+  public void shouldInitializeFromManifestProviderInfo() {
     TestContentProvider1 myContentProvider = controller.create().get();
     assertThat(myContentProvider.getReadPermission()).isEqualTo("READ_PERMISSION");
     assertThat(myContentProvider.getWritePermission()).isEqualTo("WRITE_PERMISSION");
@@ -77,7 +77,7 @@ public class ContentProviderControllerTest {
   }
 
   @Test
-  public void whenNoProviderManifestEntryFound_shouldStillInitialize() throws Exception {
+  public void whenNoProviderManifestEntryFound_shouldStillInitialize() {
     TestContentProvider1 myContentProvider =
         Robolectric.buildContentProvider(NotInManifestContentProvider.class).create().get();
     assertThat(myContentProvider.getReadPermission()).isNull();
@@ -86,13 +86,13 @@ public class ContentProviderControllerTest {
   }
 
   @Test
-  public void create_shouldCallOnCreate() throws Exception {
+  public void create_shouldCallOnCreate() {
     TestContentProvider1 myContentProvider = controller.create().get();
     assertThat(myContentProvider.transcript).containsExactly("onCreate");
   }
 
   @Test
-  public void shutdown_shouldCallShutdown() throws Exception {
+  public void shutdown_shouldCallShutdown() {
     TestContentProvider1 myContentProvider = controller.shutdown().get();
     assertThat(myContentProvider.transcript).containsExactly("shutdown");
   }
@@ -111,7 +111,7 @@ public class ContentProviderControllerTest {
   }
 
   @Test
-  public void contentProviderShouldBeCreatedBeforeBeingRegistered() throws Exception {
+  public void contentProviderShouldBeCreatedBeforeBeingRegistered() {
     XContentProvider xContentProvider =
         Robolectric.setupContentProvider(XContentProvider.class, "x-authority");
     assertThat(xContentProvider.transcript).containsExactly("x-authority not registered yet");
@@ -122,7 +122,7 @@ public class ContentProviderControllerTest {
   }
 
   @Test
-  public void createContentProvider_nullAuthority() throws Exception {
+  public void createContentProvider_nullAuthority() {
     assertThrows(
         IllegalArgumentException.class,
         () ->
diff --git a/robolectric/src/test/java/org/robolectric/android/controller/IntentServiceControllerTest.java b/robolectric/src/test/java/org/robolectric/android/controller/IntentServiceControllerTest.java
index 04820ac82..beff28ad2 100644
--- a/robolectric/src/test/java/org/robolectric/android/controller/IntentServiceControllerTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/controller/IntentServiceControllerTest.java
@@ -35,21 +35,21 @@ public class IntentServiceControllerTest {
   }
 
   @Test
-  public void onBindShouldSetIntent() throws Exception {
+  public void onBindShouldSetIntent() {
     MyService myService = controller.create().bind().get();
     assertThat(myService.boundIntent).isNotNull();
     assertThat(myService.boundIntent.getComponent()).isEqualTo(componentName);
   }
 
   @Test
-  public void onStartCommandShouldSetIntent() throws Exception {
+  public void onStartCommandShouldSetIntent() {
     MyService myService = controller.create().startCommand(3, 4).get();
     assertThat(myService.startIntent).isNotNull();
     assertThat(myService.startIntent.getComponent()).isEqualTo(componentName);
   }
 
   @Test
-  public void onBindShouldSetIntentComponentWithCustomIntentWithoutComponentSet() throws Exception {
+  public void onBindShouldSetIntentComponentWithCustomIntentWithoutComponentSet() {
     MyService myService =
         Robolectric.buildIntentService(MyService.class, new Intent(Intent.ACTION_VIEW))
             .bind()
@@ -59,7 +59,7 @@ public class IntentServiceControllerTest {
   }
 
   @Test
-  public void shouldSetIntentForGivenServiceInstance() throws Exception {
+  public void shouldSetIntentForGivenServiceInstance() {
     IntentServiceController<MyService> intentServiceController =
         IntentServiceController.of(new MyService(), null).bind();
     assertThat(intentServiceController.get().boundIntent).isNotNull();
@@ -67,7 +67,7 @@ public class IntentServiceControllerTest {
 
   @Test
   @LooperMode(LEGACY)
-  public void whenLooperIsNotPaused_shouldCreateWithMainLooperPaused() throws Exception {
+  public void whenLooperIsNotPaused_shouldCreateWithMainLooperPaused() {
     ShadowLooper.unPauseMainLooper();
     controller.create();
     assertThat(shadowOf(Looper.getMainLooper()).isPaused()).isFalse();
@@ -75,7 +75,7 @@ public class IntentServiceControllerTest {
   }
 
   @Test
-  public void whenLooperIsAlreadyPaused_shouldCreateWithMainLooperPaused() throws Exception {
+  public void whenLooperIsAlreadyPaused_shouldCreateWithMainLooperPaused() {
     shadowMainLooper().pause();
     controller.create();
     assertThat(transcript).contains("finishedOnCreate");
@@ -115,7 +115,7 @@ public class IntentServiceControllerTest {
   }
 
   public static class MyService extends IntentService {
-    private Handler handler = new Handler(Looper.getMainLooper());
+    private final Handler handler = new Handler(Looper.getMainLooper());
 
     public Intent boundIntent;
 
diff --git a/robolectric/src/test/java/org/robolectric/android/controller/ServiceControllerTest.java b/robolectric/src/test/java/org/robolectric/android/controller/ServiceControllerTest.java
index a9fd2f90e..fa73929fc 100644
--- a/robolectric/src/test/java/org/robolectric/android/controller/ServiceControllerTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/controller/ServiceControllerTest.java
@@ -34,14 +34,14 @@ public class ServiceControllerTest {
   }
 
   @Test
-  public void onBindShouldSetIntent() throws Exception {
+  public void onBindShouldSetIntent() {
     MyService myService = controller.create().bind().get();
     assertThat(myService.boundIntent).isNotNull();
     assertThat(myService.boundIntent.getComponent()).isEqualTo(componentName);
   }
 
   @Test
-  public void onStartCommandShouldSetIntentAndFlags() throws Exception {
+  public void onStartCommandShouldSetIntentAndFlags() {
     MyService myService = controller.create().startCommand(3, 4).get();
     assertThat(myService.startIntent).isNotNull();
     assertThat(myService.startIntent.getComponent()).isEqualTo(componentName);
@@ -50,7 +50,7 @@ public class ServiceControllerTest {
   }
 
   @Test
-  public void onBindShouldSetIntentComponentWithCustomIntentWithoutComponentSet() throws Exception {
+  public void onBindShouldSetIntentComponentWithCustomIntentWithoutComponentSet() {
     MyService myService =
         Robolectric.buildService(MyService.class, new Intent(Intent.ACTION_VIEW)).bind().get();
     assertThat(myService.boundIntent.getAction()).isEqualTo(Intent.ACTION_VIEW);
@@ -58,7 +58,7 @@ public class ServiceControllerTest {
   }
 
   @Test
-  public void shouldSetIntentForGivenServiceInstance() throws Exception {
+  public void shouldSetIntentForGivenServiceInstance() {
     ServiceController<MyService> serviceController =
         ServiceController.of(new MyService(), null).bind();
     assertThat(serviceController.get().boundIntent).isNotNull();
@@ -66,7 +66,7 @@ public class ServiceControllerTest {
 
   @Test
   @LooperMode(LEGACY)
-  public void whenLooperIsNotPaused_shouldCreateWithMainLooperPaused() throws Exception {
+  public void whenLooperIsNotPaused_shouldCreateWithMainLooperPaused() {
     ShadowLooper.unPauseMainLooper();
     controller.create();
     assertThat(shadowOf(Looper.getMainLooper()).isPaused()).isFalse();
@@ -74,7 +74,7 @@ public class ServiceControllerTest {
   }
 
   @Test
-  public void whenLooperIsAlreadyPaused_shouldCreateWithMainLooperPaused() throws Exception {
+  public void whenLooperIsAlreadyPaused_shouldCreateWithMainLooperPaused() {
     shadowMainLooper().pause();
     controller.create();
     assertThat(transcript).contains("finishedOnCreate");
@@ -115,7 +115,7 @@ public class ServiceControllerTest {
 
   public static class MyService extends Service {
 
-    private Handler handler = new Handler(Looper.getMainLooper());
+    private final Handler handler = new Handler(Looper.getMainLooper());
 
     public Intent boundIntent;
 
diff --git a/robolectric/src/test/java/org/robolectric/android/internal/AndroidTestEnvironmentCreateApplicationTest.java b/robolectric/src/test/java/org/robolectric/android/internal/AndroidTestEnvironmentCreateApplicationTest.java
index 0e6874c65..3a27bc4e4 100644
--- a/robolectric/src/test/java/org/robolectric/android/internal/AndroidTestEnvironmentCreateApplicationTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/internal/AndroidTestEnvironmentCreateApplicationTest.java
@@ -34,7 +34,7 @@ public class AndroidTestEnvironmentCreateApplicationTest {
   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();
 
   @Test
-  public void shouldThrowWhenManifestContainsBadApplicationClassName() throws Exception {
+  public void shouldThrowWhenManifestContainsBadApplicationClassName() {
     assertThrows(
         RuntimeException.class,
         () ->
diff --git a/robolectric/src/test/java/org/robolectric/android/internal/AndroidTestEnvironmentTest.java b/robolectric/src/test/java/org/robolectric/android/internal/AndroidTestEnvironmentTest.java
index 90517a740..0573b08b9 100644
--- a/robolectric/src/test/java/org/robolectric/android/internal/AndroidTestEnvironmentTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/internal/AndroidTestEnvironmentTest.java
@@ -1,6 +1,7 @@
 package org.robolectric.android.internal;
 
 import static android.os.Build.VERSION_CODES.O;
+import static android.os.Build.VERSION_CODES.Q;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 import static org.robolectric.annotation.ConscryptMode.Mode.OFF;
@@ -8,11 +9,15 @@ import static org.robolectric.annotation.ConscryptMode.Mode.ON;
 import static org.robolectric.annotation.LooperMode.Mode.LEGACY;
 
 import android.app.Application;
+import android.content.ContentResolver;
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.res.Configuration;
 import android.content.res.Resources;
+import android.database.Cursor;
+import android.net.Uri;
 import android.os.Build;
+import android.provider.MediaStore;
 import android.util.DisplayMetrics;
 import androidx.test.core.app.ApplicationProvider;
 import java.io.File;
@@ -29,12 +34,12 @@ import java.util.Map.Entry;
 import java.util.concurrent.atomic.AtomicBoolean;
 import javax.crypto.Cipher;
 import org.bouncycastle.jce.provider.BouncyCastleProvider;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.BootstrapDeferringRobolectricTestRunner;
 import org.robolectric.BootstrapDeferringRobolectricTestRunner.BootstrapWrapperI;
 import org.robolectric.BootstrapDeferringRobolectricTestRunner.RoboInject;
-import org.robolectric.RoboSettings;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.android.DeviceConfig;
 import org.robolectric.android.DeviceConfig.ScreenSize;
@@ -44,6 +49,7 @@ import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.experimental.LazyApplication;
 import org.robolectric.annotation.experimental.LazyApplication.LazyLoad;
 import org.robolectric.internal.ShadowProvider;
+import org.robolectric.junit.rules.SetSystemPropertyRule;
 import org.robolectric.manifest.AndroidManifest;
 import org.robolectric.manifest.RoboNotFoundException;
 import org.robolectric.pluginapi.TestEnvironmentLifecyclePlugin;
@@ -58,6 +64,8 @@ import org.robolectric.shadows.ShadowLooper;
 @LooperMode(LEGACY)
 public class AndroidTestEnvironmentTest {
 
+  @Rule public SetSystemPropertyRule setSystemPropertyRule = new SetSystemPropertyRule();
+
   @RoboInject BootstrapWrapperI bootstrapWrapper;
 
   @Test
@@ -73,18 +81,15 @@ public class AndroidTestEnvironmentTest {
   @Test
   public void
       setUpApplicationState_setsBackgroundScheduler_toBeSameAsForeground_whenAdvancedScheduling() {
-    RoboSettings.setUseGlobalScheduler(true);
-    try {
-      bootstrapWrapper.callSetUpApplicationState();
-      final ShadowApplication shadowApplication =
-          Shadow.extract(ApplicationProvider.getApplicationContext());
-      assertThat(shadowApplication.getBackgroundThreadScheduler())
-          .isSameInstanceAs(shadowApplication.getForegroundThreadScheduler());
-      assertThat(RuntimeEnvironment.getMasterScheduler())
-          .isSameInstanceAs(RuntimeEnvironment.getMasterScheduler());
-    } finally {
-      RoboSettings.setUseGlobalScheduler(false);
-    }
+    setSystemPropertyRule.set("robolectric.scheduling.global", "true");
+
+    bootstrapWrapper.callSetUpApplicationState();
+    final ShadowApplication shadowApplication =
+        Shadow.extract(ApplicationProvider.getApplicationContext());
+    assertThat(shadowApplication.getBackgroundThreadScheduler())
+        .isSameInstanceAs(shadowApplication.getForegroundThreadScheduler());
+    assertThat(RuntimeEnvironment.getMasterScheduler())
+        .isSameInstanceAs(RuntimeEnvironment.getMasterScheduler());
   }
 
   @Test
@@ -364,12 +369,35 @@ public class AndroidTestEnvironmentTest {
             new StubSdk(RuntimeEnvironment.getApiLevel(), true),
             shadowProviders,
             telpArray);
-    RuntimeException e =
-        assertThrows(RuntimeException.class, () -> androidTestEnvironment.resetState());
+    RuntimeException e = assertThrows(RuntimeException.class, androidTestEnvironment::resetState);
     assertThat(e).hasMessageThat().contains("Reset failed");
     assertThat(workingShadowProvider.wasReset).isTrue();
   }
 
+  @Config(minSdk = Q)
+  @Test
+  public void fakeMediaProvider_closesSQLiteDatabase() {
+    setSystemPropertyRule.set("robolectric.fake.media.provider", "true");
+    bootstrapWrapper.callSetUpApplicationState();
+    final Context context = ApplicationProvider.getApplicationContext();
+
+    assertThat(getExternalImageCount(context)).isEqualTo(0);
+    bootstrapWrapper.resetState();
+    assertThat(getExternalImageCount(context)).isEqualTo(-1);
+  }
+
+  private int getExternalImageCount(Context context) {
+    ContentResolver contentResolver = context.getContentResolver();
+    Uri queryUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
+    String[] projection = {MediaStore.Images.Media._ID};
+    try (Cursor cursor = contentResolver.query(queryUri, projection, null, null, null)) {
+      if (cursor == null) {
+        return -1;
+      }
+      return cursor.getCount();
+    }
+  }
+
   private static class ThrowingShadowProvider implements ShadowProvider {
     @Override
     public void reset() {
diff --git a/robolectric/src/test/java/org/robolectric/android/internal/ClassNameResolverTest.java b/robolectric/src/test/java/org/robolectric/android/internal/ClassNameResolverTest.java
index c30037bd8..8f4212084 100644
--- a/robolectric/src/test/java/org/robolectric/android/internal/ClassNameResolverTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/internal/ClassNameResolverTest.java
@@ -41,8 +41,7 @@ public class ClassNameResolverTest {
   }
 
   @Test
-  public void shouldNotResolveClassesByUndottedPartiallyQualifiedNameBecauseAndroidDoesnt()
-      throws Exception {
+  public void shouldNotResolveClassesByUndottedPartiallyQualifiedNameBecauseAndroidDoesnt() {
     assertThrows(
         ClassNotFoundException.class,
         () -> ClassNameResolver.resolve("org", "robolectric.shadows.testing.TestApplication"));
diff --git a/robolectric/src/test/java/org/robolectric/android/util/concurrent/BackgroundExecutorTest.java b/robolectric/src/test/java/org/robolectric/android/util/concurrent/BackgroundExecutorTest.java
index d73298812..cde4ba875 100644
--- a/robolectric/src/test/java/org/robolectric/android/util/concurrent/BackgroundExecutorTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/util/concurrent/BackgroundExecutorTest.java
@@ -26,7 +26,7 @@ public class BackgroundExecutorTest {
   }
 
   @Test
-  public void forRunnable_exceptionsPropogated() {
+  public void forRunnable_exceptionsPropagated() {
     try {
       runInBackground(
           (Runnable)
@@ -53,7 +53,7 @@ public class BackgroundExecutorTest {
   }
 
   @Test
-  public void forCallable_runtimeExceptionsPropogated() {
+  public void forCallable_runtimeExceptionsPropagated() {
     try {
       runInBackground(
           (Callable<?>)
diff --git a/robolectric/src/test/java/org/robolectric/android/util/concurrent/InlineExecutorServiceTest.java b/robolectric/src/test/java/org/robolectric/android/util/concurrent/InlineExecutorServiceTest.java
index 6c8724ab3..44d50c62d 100644
--- a/robolectric/src/test/java/org/robolectric/android/util/concurrent/InlineExecutorServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/util/concurrent/InlineExecutorServiceTest.java
@@ -29,12 +29,9 @@ public class InlineExecutorServiceTest {
   public void executionRunsInBackgroundThread() {
     final Thread testThread = Thread.currentThread();
     executorService.execute(
-        new Runnable() {
-          @Override
-          public void run() {
-            assertThat(Thread.currentThread()).isNotSameInstanceAs(testThread);
-            executedTasksRecord.add("task ran");
-          }
+        () -> {
+          assertThat(Thread.currentThread()).isNotSameInstanceAs(testThread);
+          executedTasksRecord.add("task ran");
         });
     assertThat(executedTasksRecord).containsExactly("task ran");
   }
@@ -84,12 +81,8 @@ public class InlineExecutorServiceTest {
   @Test
   public void exceptionsPropagated() {
     Callable<Void> throwingCallable =
-        new Callable<Void>() {
-
-          @Override
-          public Void call() throws Exception {
-            throw new IllegalStateException("I failed");
-          }
+        () -> {
+          throw new IllegalStateException("I failed");
         };
     try {
       executorService.submit(throwingCallable);
@@ -100,15 +93,12 @@ public class InlineExecutorServiceTest {
   }
 
   @Test
-  public void postingTasks() throws Exception {
+  public void postingTasks() {
     Runnable postingRunnable =
-        new Runnable() {
-          @Override
-          public void run() {
-            executedTasksRecord.add("first");
-            executorService.execute(() -> executedTasksRecord.add("third"));
-            executedTasksRecord.add("second");
-          }
+        () -> {
+          executedTasksRecord.add("first");
+          executorService.execute(() -> executedTasksRecord.add("third"));
+          executedTasksRecord.add("second");
         };
     executorService.execute(postingRunnable);
 
diff --git a/robolectric/src/test/java/org/robolectric/android/util/concurrent/PausedExecutorServiceTest.java b/robolectric/src/test/java/org/robolectric/android/util/concurrent/PausedExecutorServiceTest.java
index 34ea673ff..88359c29d 100644
--- a/robolectric/src/test/java/org/robolectric/android/util/concurrent/PausedExecutorServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/util/concurrent/PausedExecutorServiceTest.java
@@ -6,7 +6,6 @@ import static org.junit.Assert.fail;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import org.junit.Before;
@@ -27,7 +26,7 @@ public class PausedExecutorServiceTest {
   }
 
   @Test
-  public void executionRunsInBackgroundThread() throws ExecutionException, InterruptedException {
+  public void executionRunsInBackgroundThread() {
     final Thread testThread = Thread.currentThread();
     executorService.execute(
         () -> {
@@ -39,7 +38,7 @@ public class PausedExecutorServiceTest {
   }
 
   @Test
-  public void runAll() throws Exception {
+  public void runAll() {
     executorService.execute(() -> executedTasksRecord.add("background event ran"));
 
     assertThat(executedTasksRecord).isEmpty();
@@ -49,7 +48,7 @@ public class PausedExecutorServiceTest {
   }
 
   @Test
-  public void runAll_inOrder() throws Exception {
+  public void runAll_inOrder() {
     executorService.execute(() -> executedTasksRecord.add("first"));
     executorService.execute(() -> executedTasksRecord.add("second"));
     assertThat(executedTasksRecord).isEmpty();
@@ -59,7 +58,7 @@ public class PausedExecutorServiceTest {
   }
 
   @Test
-  public void runNext() throws Exception {
+  public void runNext() {
     executorService.execute(() -> executedTasksRecord.add("first"));
     executorService.execute(() -> executedTasksRecord.add("second"));
     assertThat(executedTasksRecord).isEmpty();
@@ -72,7 +71,7 @@ public class PausedExecutorServiceTest {
   }
 
   @Test
-  public void runAll_clearsQueuedTasks() throws Exception {
+  public void runAll_clearsQueuedTasks() {
     executorService.execute(() -> executedTasksRecord.add("background event ran"));
 
     assertThat(executedTasksRecord).isEmpty();
@@ -124,8 +123,7 @@ public class PausedExecutorServiceTest {
   }
 
   @Test
-  public void whenShutdownBeforeSubmittedTasksAreExecuted_TaskIsNotInTranscript()
-      throws ExecutionException, InterruptedException {
+  public void whenShutdownBeforeSubmittedTasksAreExecuted_TaskIsNotInTranscript() {
     executorService.execute(() -> executedTasksRecord.add("background event ran"));
 
     executorService.shutdown();
@@ -135,8 +133,7 @@ public class PausedExecutorServiceTest {
   }
 
   @Test
-  public void whenShutdownNow_ReturnedListContainsOneRunnable()
-      throws ExecutionException, InterruptedException {
+  public void whenShutdownNow_ReturnedListContainsOneRunnable() {
     executorService.execute(() -> executedTasksRecord.add("background event ran"));
 
     List<Runnable> notExecutedRunnables = executorService.shutdownNow();
@@ -163,7 +160,7 @@ public class PausedExecutorServiceTest {
 
   @Test
   @SuppressWarnings("FutureReturnValueIgnored")
-  public void exceptionsPropagated() throws ExecutionException, InterruptedException {
+  public void exceptionsPropagated() {
     Callable<Void> throwingCallable =
         () -> {
           throw new IllegalStateException("I failed");
@@ -178,15 +175,12 @@ public class PausedExecutorServiceTest {
   }
 
   @Test
-  public void postingTasks() throws Exception {
+  public void postingTasks() {
     Runnable postingRunnable =
-        new Runnable() {
-          @Override
-          public void run() {
-            executedTasksRecord.add("first");
-            executorService.execute(() -> executedTasksRecord.add("third"));
-            executedTasksRecord.add("second");
-          }
+        () -> {
+          executedTasksRecord.add("first");
+          executorService.execute(() -> executedTasksRecord.add("third"));
+          executedTasksRecord.add("second");
         };
     executorService.execute(postingRunnable);
     executorService.runAll();
diff --git a/robolectric/src/test/java/org/robolectric/android/util/concurrent/RoboExecutorServiceTest.java b/robolectric/src/test/java/org/robolectric/android/util/concurrent/RoboExecutorServiceTest.java
index 23bcc72b8..2d13b8909 100644
--- a/robolectric/src/test/java/org/robolectric/android/util/concurrent/RoboExecutorServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/util/concurrent/RoboExecutorServiceTest.java
@@ -21,7 +21,6 @@ import org.robolectric.util.Scheduler;
 public class RoboExecutorServiceTest {
   private List<String> transcript;
   private RoboExecutorService executorService;
-  private Scheduler backgroundScheduler;
   private Runnable runnable;
 
   @Before
@@ -29,14 +28,14 @@ public class RoboExecutorServiceTest {
     transcript = new ArrayList<>();
     executorService = new RoboExecutorService();
 
-    backgroundScheduler = Robolectric.getBackgroundThreadScheduler();
-
+    Scheduler backgroundScheduler = Robolectric.getBackgroundThreadScheduler();
     backgroundScheduler.pause();
+
     runnable = () -> transcript.add("background event ran");
   }
 
   @Test
-  public void execute_shouldRunStuffOnBackgroundThread() throws Exception {
+  public void execute_shouldRunStuffOnBackgroundThread() {
     executorService.execute(runnable);
 
     assertThat(transcript).isEmpty();
diff --git a/robolectric/src/test/java/org/robolectric/fakes/FakeMediaProviderTest.java b/robolectric/src/test/java/org/robolectric/fakes/FakeMediaProviderTest.java
new file mode 100644
index 000000000..25964eb65
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/fakes/FakeMediaProviderTest.java
@@ -0,0 +1,70 @@
+package org.robolectric.fakes;
+
+import static android.os.Build.VERSION_CODES.Q;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.os.Environment;
+import android.provider.MediaStore;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.io.OutputStream;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+@RunWith(AndroidJUnit4.class)
+@Config(minSdk = Q)
+public final class FakeMediaProviderTest {
+
+  private final Context context = ApplicationProvider.getApplicationContext();
+
+  @Test
+  public void getExternalImageCount_zeroWhenNoImages() {
+    assertThat(getExternalImageCount(context)).isEqualTo(0);
+  }
+
+  @Test
+  public void saveImageToMediaStore_savesImage() throws Exception {
+    Uri savedImageUri = saveImageToMediaStore(context, "Test.jpg");
+    assertThat(savedImageUri).isNotNull();
+    assertThat(getExternalImageCount(context)).isEqualTo(1);
+  }
+
+  private static int getExternalImageCount(Context context) {
+    ContentResolver contentResolver = context.getContentResolver();
+    Uri queryUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
+    String[] projection = {MediaStore.Images.Media._ID};
+    try (Cursor cursor = contentResolver.query(queryUri, projection, null, null, null)) {
+      if (cursor == null) {
+        return -1;
+      }
+      return cursor.getCount();
+    }
+  }
+
+  public static Uri saveImageToMediaStore(Context context, String displayName) throws Exception {
+    ContentResolver resolver = context.getContentResolver();
+    ContentValues contentValues = new ContentValues();
+    contentValues.put(MediaStore.Images.Media.DISPLAY_NAME, displayName);
+    contentValues.put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg");
+    contentValues.put(
+        MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES + "/test");
+    contentValues.put(MediaStore.Images.Media.IS_PENDING, 1);
+    Uri imageCollectionUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
+    Uri imageUri = resolver.insert(imageCollectionUri, contentValues);
+    assertThat(imageUri).isNotNull();
+    OutputStream outputStream = resolver.openOutputStream(imageUri);
+    assertThat(outputStream).isNotNull();
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    assertThat(bitmap.compress(Bitmap.CompressFormat.JPEG, /* quality= */ 95, outputStream))
+        .isTrue();
+    outputStream.close();
+    return imageUri;
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/fakes/RoboCursorTest.java b/robolectric/src/test/java/org/robolectric/fakes/RoboCursorTest.java
index ffb208e5c..4041a90d9 100644
--- a/robolectric/src/test/java/org/robolectric/fakes/RoboCursorTest.java
+++ b/robolectric/src/test/java/org/robolectric/fakes/RoboCursorTest.java
@@ -48,7 +48,7 @@ public class RoboCursorTest {
   }
 
   @Test
-  public void query_shouldMakeQueryParamsAvailable() throws Exception {
+  public void query_shouldMakeQueryParamsAvailable() {
     contentResolver.query(
         uri, new String[] {"projection"}, "selection", new String[] {"selection"}, "sortOrder");
     assertThat(cursor.uri).isEqualTo(uri);
@@ -59,8 +59,7 @@ public class RoboCursorTest {
   }
 
   @Test
-  public void getColumnCount_whenSetColumnNamesHasntBeenCalled_shouldReturnCountFromData()
-      throws Exception {
+  public void getColumnCount_whenSetColumnNamesHasntBeenCalled_shouldReturnCountFromData() {
     RoboCursor cursor = new RoboCursor();
     cursor.setResults(
         new Object[][] {
@@ -74,14 +73,14 @@ public class RoboCursorTest {
   }
 
   @Test
-  public void getColumnName_shouldReturnColumnName() throws Exception {
+  public void getColumnName_shouldReturnColumnName() {
     assertThat(cursor.getColumnCount()).isEqualTo(8);
     assertThat(cursor.getColumnName(0)).isEqualTo(STRING_COLUMN);
     assertThat(cursor.getColumnName(1)).isEqualTo(LONG_COLUMN);
   }
 
   @Test
-  public void getType_shouldReturnColumnType() throws Exception {
+  public void getType_shouldReturnColumnType() {
     cursor.setResults(
         new Object[][] {
           new Object[] {"aString", 1234L, 42, new byte[] {1, 2, 3}, 255, 1.25f, 2.5d, null}
@@ -98,7 +97,7 @@ public class RoboCursorTest {
   }
 
   @Test
-  public void get_shouldReturnColumnValue() throws Exception {
+  public void get_shouldReturnColumnValue() {
     cursor.setResults(
         new Object[][] {
           new Object[] {"aString", 1234L, 42, new byte[] {1, 2, 3}, 255, 1.25f, 2.5d, null}
@@ -118,7 +117,7 @@ public class RoboCursorTest {
   }
 
   @Test
-  public void get_shouldConvert() throws Exception {
+  public void get_shouldConvert() {
     cursor.setResults(
         new Object[][] {
           new Object[] {"aString", "1234", "42", new byte[] {1, 2, 3}, 255, "1.25", 2.5d, null}
@@ -133,7 +132,7 @@ public class RoboCursorTest {
   }
 
   @Test
-  public void moveToNext_advancesToNextRow() throws Exception {
+  public void moveToNext_advancesToNextRow() {
     cursor.setResults(
         new Object[][] {
           new Object[] {"aString", 1234L, 41}, new Object[] {"anotherString", 5678L, 42}
@@ -152,7 +151,7 @@ public class RoboCursorTest {
   }
 
   @Test
-  public void moveToPosition_movesToAppropriateRow() throws Exception {
+  public void moveToPosition_movesToAppropriateRow() {
     cursor.setResults(
         new Object[][] {
           new Object[] {"aString", 1234L, 41}, new Object[] {"anotherString", 5678L, 42}
@@ -189,7 +188,7 @@ public class RoboCursorTest {
   }
 
   @Test
-  public void close_isRemembered() throws Exception {
+  public void close_isRemembered() {
     cursor.close();
     assertThat(cursor.getCloseWasCalled()).isTrue();
   }
diff --git a/robolectric/src/test/java/org/robolectric/fakes/RoboMenuTest.java b/robolectric/src/test/java/org/robolectric/fakes/RoboMenuTest.java
index 9dd4d4c0c..bf9696da4 100644
--- a/robolectric/src/test/java/org/robolectric/fakes/RoboMenuTest.java
+++ b/robolectric/src/test/java/org/robolectric/fakes/RoboMenuTest.java
@@ -3,13 +3,13 @@ package org.robolectric.fakes;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 
 import android.app.Activity;
 import android.content.Intent;
 import android.view.MenuItem;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
-import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
@@ -31,7 +31,7 @@ public class RoboMenuTest {
     menu.removeItem(10);
 
     item = (RoboMenuItem) menu.findItem(10);
-    Assert.assertNull(item);
+    assertNull(item);
   }
 
   @Test
@@ -52,13 +52,13 @@ public class RoboMenuTest {
     menu.add(0, 10, 0, org.robolectric.R.string.ok);
 
     RoboMenuItem item = (RoboMenuItem) menu.findItem(10);
-    Assert.assertNull(item.getIntent());
+    assertNull(item.getIntent());
 
     Intent intent = new Intent(a, Activity.class);
     item.setIntent(intent);
     item.click();
 
-    Assert.assertNotNull(item);
+    assertNotNull(item);
 
     Intent startedIntent = ShadowApplication.getInstance().getNextStartedActivity();
     assertNotNull(startedIntent);
diff --git a/robolectric/src/test/java/org/robolectric/fakes/RoboWebSettingsTest.java b/robolectric/src/test/java/org/robolectric/fakes/RoboWebSettingsTest.java
index 10e7a70f9..245709e60 100644
--- a/robolectric/src/test/java/org/robolectric/fakes/RoboWebSettingsTest.java
+++ b/robolectric/src/test/java/org/robolectric/fakes/RoboWebSettingsTest.java
@@ -158,7 +158,7 @@ public class RoboWebSettingsTest {
   }
 
   @Test
-  public void testMediaPlaybackRequiresUserGesture() throws Exception {
+  public void testMediaPlaybackRequiresUserGesture() {
     for (boolean value : TRUE_AND_FALSE) {
       webSettings.setMediaPlaybackRequiresUserGesture(value);
       assertThat(webSettings.getMediaPlaybackRequiresUserGesture()).isEqualTo(value);
@@ -207,13 +207,13 @@ public class RoboWebSettingsTest {
   }
 
   @Test
-  public void testSetCacheMode() throws Exception {
+  public void testSetCacheMode() {
     webSettings.setCacheMode(7);
     assertThat(webSettings.getCacheMode()).isEqualTo(7);
   }
 
   @Test
-  public void testSetUseWideViewPort() throws Exception {
+  public void testSetUseWideViewPort() {
     for (boolean value : TRUE_AND_FALSE) {
       webSettings.setUseWideViewPort(value);
       assertThat(webSettings.getUseWideViewPort()).isEqualTo(value);
@@ -221,7 +221,7 @@ public class RoboWebSettingsTest {
   }
 
   @Test
-  public void testSetAppCacheEnabled() throws Exception {
+  public void testSetAppCacheEnabled() {
     for (boolean value : TRUE_AND_FALSE) {
       webSettings.setAppCacheEnabled(value);
       assertThat(webSettings.getAppCacheEnabled()).isEqualTo(value);
@@ -229,7 +229,7 @@ public class RoboWebSettingsTest {
   }
 
   @Test
-  public void testSetGeolocationEnabled() throws Exception {
+  public void testSetGeolocationEnabled() {
     for (boolean value : TRUE_AND_FALSE) {
       webSettings.setGeolocationEnabled(value);
       assertThat(webSettings.getGeolocationEnabled()).isEqualTo(value);
@@ -237,7 +237,7 @@ public class RoboWebSettingsTest {
   }
 
   @Test
-  public void testSetSaveFormData() throws Exception {
+  public void testSetSaveFormData() {
     for (boolean value : TRUE_AND_FALSE) {
       webSettings.setSaveFormData(value);
       assertThat(webSettings.getSaveFormData()).isEqualTo(value);
@@ -245,49 +245,49 @@ public class RoboWebSettingsTest {
   }
 
   @Test
-  public void testSetDatabasePath() throws Exception {
+  public void testSetDatabasePath() {
     webSettings.setDatabasePath("new_path");
     assertThat(webSettings.getDatabasePath()).isEqualTo("new_path");
   }
 
   @Test
-  public void testSetRenderPriority() throws Exception {
+  public void testSetRenderPriority() {
     webSettings.setRenderPriority(WebSettings.RenderPriority.HIGH);
     assertThat(webSettings.getRenderPriority()).isEqualTo(WebSettings.RenderPriority.HIGH);
   }
 
   @Test
-  public void testSetAppCachePath() throws Exception {
+  public void testSetAppCachePath() {
     webSettings.setAppCachePath("new_path");
     assertThat(webSettings.getAppCachePath()).isEqualTo("new_path");
   }
 
   @Test
-  public void testSetAppCacheMaxSize() throws Exception {
+  public void testSetAppCacheMaxSize() {
     webSettings.setAppCacheMaxSize(100);
     assertThat(webSettings.getAppCacheMaxSize()).isEqualTo(100);
   }
 
   @Test
-  public void testSetGeolocationDatabasePath() throws Exception {
+  public void testSetGeolocationDatabasePath() {
     webSettings.setGeolocationDatabasePath("new_path");
     assertThat(webSettings.getGeolocationDatabasePath()).isEqualTo("new_path");
   }
 
   @Test
-  public void testSetJavascriptCanOpenWindowsAutomaticallyIsTrue() throws Exception {
+  public void testSetJavascriptCanOpenWindowsAutomaticallyIsTrue() {
     webSettings.setJavaScriptCanOpenWindowsAutomatically(true);
     assertThat(webSettings.getJavaScriptCanOpenWindowsAutomatically()).isTrue();
   }
 
   @Test
-  public void testSetJavascriptCanOpenWindowsAutomaticallyIsFalse() throws Exception {
+  public void testSetJavascriptCanOpenWindowsAutomaticallyIsFalse() {
     webSettings.setJavaScriptCanOpenWindowsAutomatically(false);
     assertThat(webSettings.getJavaScriptCanOpenWindowsAutomatically()).isFalse();
   }
 
   @Test
-  public void testSetTextZoom() throws Exception {
+  public void testSetTextZoom() {
     webSettings.setTextZoom(50);
     assertThat(webSettings.getTextZoom()).isEqualTo(50);
   }
diff --git a/robolectric/src/test/java/org/robolectric/interceptors/AndroidInterceptorsTest.java b/robolectric/src/test/java/org/robolectric/interceptors/AndroidInterceptorsTest.java
index b9685341c..74be08d9a 100644
--- a/robolectric/src/test/java/org/robolectric/interceptors/AndroidInterceptorsTest.java
+++ b/robolectric/src/test/java/org/robolectric/interceptors/AndroidInterceptorsTest.java
@@ -11,7 +11,7 @@ import org.robolectric.internal.bytecode.MethodRef;
 @RunWith(JUnit4.class)
 public class AndroidInterceptorsTest {
   @Test
-  public void allMethodRefs() throws Exception {
+  public void allMethodRefs() {
     assertThat(new Interceptors(AndroidInterceptors.all()).getAllMethodRefs())
         .containsAtLeast(
             new MethodRef("java.util.LinkedHashMap", "eldest"),
@@ -31,7 +31,7 @@ public class AndroidInterceptorsTest {
   }
 
   @Test
-  public void localeAdjustCodeInterceptor() throws Exception {
+  public void localeAdjustCodeInterceptor() {
     assertThat(adjust("EN")).isEqualTo("en");
     assertThat(adjust("he")).isEqualTo("iw");
     assertThat(adjust("yi")).isEqualTo("ji");
diff --git a/robolectric/src/test/java/org/robolectric/internal/DefaultManifestFactoryTest.java b/robolectric/src/test/java/org/robolectric/internal/DefaultManifestFactoryTest.java
index 026d675b4..24086ac8e 100644
--- a/robolectric/src/test/java/org/robolectric/internal/DefaultManifestFactoryTest.java
+++ b/robolectric/src/test/java/org/robolectric/internal/DefaultManifestFactoryTest.java
@@ -66,7 +66,7 @@ public class DefaultManifestFactoryTest {
   }
 
   @Test
-  public void identify_configNoneShouldBeIgnored() throws Exception {
+  public void identify_configNoneShouldBeIgnored() {
     Properties properties = new Properties();
     properties.put("android_merged_manifest", "gradle/AndroidManifest.xml");
     properties.put("android_merged_resources", "gradle/res");
@@ -85,7 +85,7 @@ public class DefaultManifestFactoryTest {
   }
 
   @Test
-  public void identify_packageCanBeOverridenFromConfig() throws Exception {
+  public void identify_packageCanBeOverriddenFromConfig() {
     Properties properties = new Properties();
     properties.put("android_merged_manifest", "gradle/AndroidManifest.xml");
     properties.put("android_merged_resources", "gradle/res");
diff --git a/robolectric/src/test/java/org/robolectric/internal/MavenManifestFactoryTest.java b/robolectric/src/test/java/org/robolectric/internal/MavenManifestFactoryTest.java
index 60b064894..d51107fdd 100644
--- a/robolectric/src/test/java/org/robolectric/internal/MavenManifestFactoryTest.java
+++ b/robolectric/src/test/java/org/robolectric/internal/MavenManifestFactoryTest.java
@@ -23,7 +23,7 @@ public class MavenManifestFactoryTest {
   }
 
   @Test
-  public void identify() throws Exception {
+  public void identify() {
     ManifestIdentifier manifestIdentifier = myMavenManifestFactory.identify(configBuilder.build());
     assertThat(manifestIdentifier.getManifestFile())
         .isEqualTo(Paths.get("_fakefs_path").resolve("to").resolve("DifferentManifest.xml"));
@@ -31,7 +31,7 @@ public class MavenManifestFactoryTest {
   }
 
   @Test
-  public void withDotSlashManifest_identify() throws Exception {
+  public void withDotSlashManifest_identify() {
     configBuilder.setManifest("./DifferentManifest.xml");
 
     ManifestIdentifier manifestIdentifier = myMavenManifestFactory.identify(configBuilder.build());
@@ -42,7 +42,7 @@ public class MavenManifestFactoryTest {
   }
 
   @Test
-  public void withDotDotSlashManifest_identify() throws Exception {
+  public void withDotDotSlashManifest_identify() {
     configBuilder.setManifest("../DifferentManifest.xml");
 
     ManifestIdentifier manifestIdentifier = myMavenManifestFactory.identify(configBuilder.build());
diff --git a/robolectric/src/test/java/org/robolectric/internal/bytecode/InstrumentationConfigurationTest.java b/robolectric/src/test/java/org/robolectric/internal/bytecode/InstrumentationConfigurationTest.java
index 467726d63..056e7ed35 100644
--- a/robolectric/src/test/java/org/robolectric/internal/bytecode/InstrumentationConfigurationTest.java
+++ b/robolectric/src/test/java/org/robolectric/internal/bytecode/InstrumentationConfigurationTest.java
@@ -25,7 +25,7 @@ public class InstrumentationConfigurationTest {
   }
 
   @Test
-  public void shouldNotInstrumentAndroidAppClasses() throws Exception {
+  public void shouldNotInstrumentAndroidAppClasses() {
     assertThat(config.shouldInstrument(wrap("com.google.android.apps.Foo"))).isFalse();
   }
 
@@ -35,13 +35,13 @@ public class InstrumentationConfigurationTest {
   }
 
   @Test
-  public void shouldNotInstrumentCoreJdkClasses() throws Exception {
+  public void shouldNotInstrumentCoreJdkClasses() {
     assertThat(config.shouldInstrument(wrap("java.lang.Object"))).isFalse();
     assertThat(config.shouldInstrument(wrap("java.lang.String"))).isFalse();
   }
 
   @Test
-  public void shouldInstrumentAndroidCoreClasses() throws Exception {
+  public void shouldInstrumentAndroidCoreClasses() {
     assertThat(config.shouldInstrument(wrap("android.content.Intent"))).isTrue();
     assertThat(config.shouldInstrument(wrap("android.and.now.for.something.completely.different")))
         .isTrue();
@@ -58,7 +58,7 @@ public class InstrumentationConfigurationTest {
   }
 
   @Test
-  public void shouldAcquireAndroidRClasses() throws Exception {
+  public void shouldAcquireAndroidRClasses() {
     assertThat(config.shouldAcquire("android.Rfoo")).isTrue();
     assertThat(config.shouldAcquire("android.fooR")).isTrue();
     assertThat(config.shouldAcquire("android.R")).isTrue();
@@ -67,7 +67,7 @@ public class InstrumentationConfigurationTest {
   }
 
   @Test
-  public void shouldAcquireRClasses() throws Exception {
+  public void shouldAcquireRClasses() {
     assertThat(config.shouldAcquire("com.whatever.Rfoo")).isTrue();
     assertThat(config.shouldAcquire("com.whatever.fooR")).isTrue();
     assertThat(config.shouldAcquire("com.whatever.R")).isTrue();
@@ -76,7 +76,7 @@ public class InstrumentationConfigurationTest {
   }
 
   @Test
-  public void shouldNotAcquireExcludedPackages() throws Exception {
+  public void shouldNotAcquireExcludedPackages() {
     assertThat(config.shouldAcquire("scala.Test")).isFalse();
     assertThat(config.shouldAcquire("scala.util.Test")).isFalse();
     assertThat(config.shouldAcquire("org.specs2.whatever.foo")).isFalse();
@@ -85,22 +85,22 @@ public class InstrumentationConfigurationTest {
   }
 
   @Test
-  public void shouldNotAcquireShadowClass() throws Exception {
+  public void shouldNotAcquireShadowClass() {
     assertThat(config.shouldAcquire("org.robolectric.shadow.api.Shadow")).isTrue();
   }
 
   @Test
-  public void shouldAcquireDistinguishedNameParser_Issue1864() throws Exception {
+  public void shouldAcquireDistinguishedNameParser_Issue1864() {
     assertThat(config.shouldAcquire("javax.net.ssl.DistinguishedNameParser")).isTrue();
   }
 
   @Test
-  public void shouldAcquireOpenglesGL_Issue2960() throws Exception {
+  public void shouldAcquireOpenglesGL_Issue2960() {
     assertThat(config.shouldAcquire("javax.microedition.khronos.opengles.GL")).isTrue();
   }
 
   @Test
-  public void shouldInstrumentCustomClasses() throws Exception {
+  public void shouldInstrumentCustomClasses() {
     String instrumentName = "com.whatever.SomeClassNameToInstrument";
     String notInstrumentName = "com.whatever.DoNotInstrumentMe";
     InstrumentationConfiguration customConfig =
@@ -110,7 +110,7 @@ public class InstrumentationConfigurationTest {
   }
 
   @Test
-  public void equals_ShouldCheckClassNames() throws Exception {
+  public void equals_ShouldCheckClassNames() {
     String instrumentName = "com.whatever.SomeClassNameToInstrument";
     InstrumentationConfiguration baseConfig = InstrumentationConfiguration.newBuilder().build();
     InstrumentationConfiguration customConfig =
@@ -120,7 +120,7 @@ public class InstrumentationConfigurationTest {
   }
 
   @Test
-  public void shouldNotInstrumentListedClasses() throws Exception {
+  public void shouldNotInstrumentListedClasses() {
     String instrumentName = "android.foo.bar";
     InstrumentationConfiguration customConfig =
         InstrumentationConfiguration.newBuilder().doNotInstrumentClass(instrumentName).build();
@@ -129,7 +129,7 @@ public class InstrumentationConfigurationTest {
   }
 
   @Test
-  public void shouldNotInstrumentPackages() throws Exception {
+  public void shouldNotInstrumentPackages() {
     String includedClass = "android.foo.Bar";
     String excludedClass = "androidx.test.foo.Bar";
     InstrumentationConfiguration customConfig =
@@ -143,7 +143,7 @@ public class InstrumentationConfigurationTest {
   }
 
   @Test
-  public void shouldNotInstrumentClassNamesWithNullRegex() throws Exception {
+  public void shouldNotInstrumentClassNamesWithNullRegex() {
     InstrumentationConfiguration customConfig =
         InstrumentationConfiguration.newBuilder()
             .addInstrumentedPackage("com.random")
@@ -155,7 +155,7 @@ public class InstrumentationConfigurationTest {
   }
 
   @Test
-  public void shouldNotInstrumentClassNamesWithRegex() throws Exception {
+  public void shouldNotInstrumentClassNamesWithRegex() {
     InstrumentationConfiguration customConfig =
         InstrumentationConfiguration.newBuilder()
             .addInstrumentedPackage("com.random")
@@ -167,7 +167,7 @@ public class InstrumentationConfigurationTest {
   }
 
   @Test
-  public void shouldNotInstrumentClassNamesWithMultiRegex() throws Exception {
+  public void shouldNotInstrumentClassNamesWithMultiRegex() {
     InstrumentationConfiguration customConfig =
         InstrumentationConfiguration.newBuilder()
             .addInstrumentedPackage("com.random")
@@ -183,7 +183,7 @@ public class InstrumentationConfigurationTest {
   }
 
   @Test
-  public void removesRedundantPackageAndClassConfig() throws Exception {
+  public void removesRedundantPackageAndClassConfig() {
     InstrumentationConfiguration config1 =
         InstrumentationConfiguration.newBuilder()
             .addInstrumentedPackage("a.b")
diff --git a/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowMapTest.java b/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowMapTest.java
index 4db08a531..f9cf61cb8 100644
--- a/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowMapTest.java
+++ b/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowMapTest.java
@@ -59,13 +59,13 @@ public class ShadowMapTest {
   }
 
   @Test
-  public void shouldLookUpShadowClassesByNamingConvention() throws Exception {
+  public void shouldLookUpShadowClassesByNamingConvention() {
     ShadowMap map = baseShadowMap.newBuilder().build();
     assertThat(map.getShadowInfo(Activity.class, ShadowMatcher.MATCH_ALL)).isNull();
   }
 
   @Test
-  public void shouldNotReturnMismatchedClassesJustBecauseTheSimpleNameMatches() throws Exception {
+  public void shouldNotReturnMismatchedClassesJustBecauseTheSimpleNameMatches() {
     ShadowMap map = baseShadowMap.newBuilder().addShadowClasses(ShadowActivity.class).build();
     assertThat(
             map.getShadowInfo(android.app.Activity.class, ShadowMatcher.MATCH_ALL).shadowClassName)
@@ -73,7 +73,7 @@ public class ShadowMapTest {
   }
 
   @Test
-  public void getInvalidatedClasses_disjoin() {
+  public void getInvalidatedClasses_disjoint() {
     ShadowMap current =
         baseShadowMap.newBuilder().addShadowClass(A1, A2, true, false, false).build();
     ShadowMap previous =
@@ -101,7 +101,7 @@ public class ShadowMapTest {
   }
 
   @Test
-  public void equalsHashCode() throws Exception {
+  public void equalsHashCode() {
     ShadowMap a = baseShadowMap.newBuilder().addShadowClass(A, B, true, false, false).build();
     ShadowMap b = baseShadowMap.newBuilder().addShadowClass(A, B, true, false, false).build();
     assertThat(a).isEqualTo(b);
diff --git a/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowWranglerUnitTest.java b/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowWranglerUnitTest.java
index d7e457b55..506a2ce80 100644
--- a/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowWranglerUnitTest.java
+++ b/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowWranglerUnitTest.java
@@ -18,7 +18,7 @@ import org.robolectric.util.Function;
 public class ShadowWranglerUnitTest {
   private ShadowWrangler shadowWrangler;
   private Interceptors interceptors;
-  private ShadowMatcher sdk23 = new AndroidSdkShadowMatcher(23);
+  private final ShadowMatcher sdk23 = new AndroidSdkShadowMatcher(23);
 
   @Before
   public void setup() throws Exception {
@@ -27,8 +27,7 @@ public class ShadowWranglerUnitTest {
   }
 
   @Test
-  public void getInterceptionHandler_whenCallIsNotRecognized_shouldReturnDoNothingHandler()
-      throws Exception {
+  public void getInterceptionHandler_whenCallIsNotRecognized_shouldReturnDoNothingHandler() {
     MethodSignature methodSignature = MethodSignature.parse("java/lang/Object/unknownMethod()V");
     Function<Object, Object> handler = interceptors.getInterceptionHandler(methodSignature);
 
@@ -37,8 +36,7 @@ public class ShadowWranglerUnitTest {
 
   @Test
   public void
-      getInterceptionHandler_whenInterceptingElderOnLinkedHashMap_shouldReturnNonDoNothingHandler()
-          throws Exception {
+      getInterceptionHandler_whenInterceptingElderOnLinkedHashMap_shouldReturnNonDoNothingHandler() {
     MethodSignature methodSignature =
         MethodSignature.parse("java/util/LinkedHashMap/eldest()Ljava/lang/Object;");
     Function<Object, Object> handler = interceptors.getInterceptionHandler(methodSignature);
diff --git a/robolectric/src/test/java/org/robolectric/junit/rules/BackgroundTestRuleTest.java b/robolectric/src/test/java/org/robolectric/junit/rules/BackgroundTestRuleTest.java
index d9f4e16af..1e12e8040 100644
--- a/robolectric/src/test/java/org/robolectric/junit/rules/BackgroundTestRuleTest.java
+++ b/robolectric/src/test/java/org/robolectric/junit/rules/BackgroundTestRuleTest.java
@@ -1,41 +1,33 @@
 package org.robolectric.junit.rules;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.hamcrest.Matchers.is;
 
 import android.os.Looper;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
-import org.junit.rules.RuleChain;
 import org.junit.runner.RunWith;
 
 /** Tests for {@link BackgroundTestRule}. */
 @RunWith(AndroidJUnit4.class)
 public final class BackgroundTestRuleTest {
 
-  private final BackgroundTestRule rule = new BackgroundTestRule();
-  private final ExpectedException expectedException = ExpectedException.none();
-
-  @Rule public RuleChain chain = RuleChain.outerRule(expectedException).around(rule);
+  @Rule public final BackgroundTestRule rule = new BackgroundTestRule();
 
   @Test
   @BackgroundTestRule.BackgroundTest
-  public void testRunsInBackground() throws Exception {
+  public void testRunsInBackground() {
     assertThat(Looper.myLooper()).isNotEqualTo(Looper.getMainLooper());
   }
 
   @Test
-  public void testNoAnnotation_runsOnMainThread() throws Exception {
+  public void testNoAnnotation_runsOnMainThread() {
     assertThat(Looper.myLooper()).isEqualTo(Looper.getMainLooper());
   }
 
-  @Test
+  @Test(expected = Exception.class)
   @BackgroundTestRule.BackgroundTest
   public void testFailInBackground() throws Exception {
-    Exception exception = new Exception("Fail!");
-    expectedException.expect(is(exception));
-    throw exception;
+    throw new Exception("Fail!");
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/junit/rules/ExpectedLogMessagesRuleTest.java b/robolectric/src/test/java/org/robolectric/junit/rules/ExpectedLogMessagesRuleTest.java
index 5821af5ac..38c134d03 100644
--- a/robolectric/src/test/java/org/robolectric/junit/rules/ExpectedLogMessagesRuleTest.java
+++ b/robolectric/src/test/java/org/robolectric/junit/rules/ExpectedLogMessagesRuleTest.java
@@ -25,64 +25,64 @@ public final class ExpectedLogMessagesRuleTest {
 
   @Test
   public void testExpectErrorLogDoesNotFail() {
-    Log.e("Mytag", "What's up");
-    rule.expectLogMessage(Log.ERROR, "Mytag", "What's up");
+    Log.e("MyTag", "What's up");
+    rule.expectLogMessage(Log.ERROR, "MyTag", "What's up");
   }
 
   @Test
   public void testExpectWarnLogDoesNotFail() {
-    Log.w("Mytag", "What's up");
-    rule.expectLogMessage(Log.WARN, "Mytag", "What's up");
+    Log.w("MyTag", "What's up");
+    rule.expectLogMessage(Log.WARN, "MyTag", "What's up");
   }
 
   @Test
   public void testAndroidExpectedLogMessagesFailsWithMessage() {
     expectedException.expect(AssertionError.class);
-    Log.e("Mytag", "What's up");
+    Log.e("MyTag", "What's up");
   }
 
   @Test
   public void testAndroidExpectedLogMessagesDoesNotFailWithExpected() {
-    rule.expectErrorsForTag("Mytag");
-    Log.e("Mytag", "What's up");
+    rule.expectErrorsForTag("MyTag");
+    Log.e("MyTag", "What's up");
   }
 
   @Test
   public void testNoExpectedMessageFailsTest() {
     expectedException.expect(AssertionError.class);
-    rule.expectLogMessage(Log.ERROR, "Mytag", "What's up");
+    rule.expectLogMessage(Log.ERROR, "MyTag", "What's up");
   }
 
   @Test
   public void testNoExpectedTagFailsTest() {
     expectedException.expect(AssertionError.class);
-    rule.expectErrorsForTag("Mytag");
+    rule.expectErrorsForTag("MyTag");
   }
 
   @Test
   public void testExpectLogMessageWithThrowable() {
     final Throwable throwable = new Throwable("lorem ipsum");
-    Log.e("Mytag", "What's up", throwable);
-    rule.expectLogMessageWithThrowable(Log.ERROR, "Mytag", "What's up", throwable);
+    Log.e("MyTag", "What's up", throwable);
+    rule.expectLogMessageWithThrowable(Log.ERROR, "MyTag", "What's up", throwable);
   }
 
   @Test
   public void testExpectLogMessageWithThrowableMatcher() {
     final IllegalArgumentException exception = new IllegalArgumentException("lorem ipsum");
-    Log.e("Mytag", "What's up", exception);
+    Log.e("MyTag", "What's up", exception);
     rule.expectLogMessageWithThrowableMatcher(
-        Log.ERROR, "Mytag", "What's up", instanceOf(IllegalArgumentException.class));
+        Log.ERROR, "MyTag", "What's up", instanceOf(IllegalArgumentException.class));
   }
 
   @Test
   public void testMultipleExpectLogMessagee() {
     final Throwable throwable = new Throwable("lorem ipsum");
-    Log.e("Mytag", "What's up", throwable);
-    Log.e("Mytag", "Message 2");
-    Log.e("Mytag", "Message 3", throwable);
-    rule.expectLogMessageWithThrowable(Log.ERROR, "Mytag", "What's up", throwable);
-    rule.expectLogMessage(Log.ERROR, "Mytag", "Message 2");
-    rule.expectLogMessage(Log.ERROR, "Mytag", "Message 3");
+    Log.e("MyTag", "What's up", throwable);
+    Log.e("MyTag", "Message 2");
+    Log.e("MyTag", "Message 3", throwable);
+    rule.expectLogMessageWithThrowable(Log.ERROR, "MyTag", "What's up", throwable);
+    rule.expectLogMessage(Log.ERROR, "MyTag", "Message 2");
+    rule.expectLogMessage(Log.ERROR, "MyTag", "Message 3");
   }
 
   @Test
@@ -108,10 +108,10 @@ public final class ExpectedLogMessagesRuleTest {
 
   @Test
   public void testExpectedLogMessageFailureOutput() {
-    Log.e("Mytag", "message1");
-    Log.e("Mytag", "message2"); // Not expected
-    rule.expectLogMessage(Log.ERROR, "Mytag", "message1");
-    rule.expectLogMessage(Log.ERROR, "Mytag", "message3"); // Not logged
+    Log.e("MyTag", "message1");
+    Log.e("MyTag", "message2"); // Not expected
+    rule.expectLogMessage(Log.ERROR, "MyTag", "message1");
+    rule.expectLogMessage(Log.ERROR, "MyTag", "message3"); // Not logged
 
     expectedException.expect(
         new TypeSafeMatcher<AssertionError>() {
@@ -123,7 +123,7 @@ public final class ExpectedLogMessagesRuleTest {
                         "[\\s\\S]*Expected, and observed:\\s+\\[LogItem\\{"
                             + "\\s+timeString='.+'"
                             + "\\s+type=6"
-                            + "\\s+tag='Mytag'"
+                            + "\\s+tag='MyTag'"
                             + "\\s+msg='message1'"
                             + "\\s+throwable=null"
                             + "\\s+}]"
@@ -134,7 +134,7 @@ public final class ExpectedLogMessagesRuleTest {
                         "[\\s\\S]*Observed, but not expected:\\s+\\[LogItem\\{"
                             + "\\s+timeString='.+'"
                             + "\\s+type=6"
-                            + "\\s+tag='Mytag'"
+                            + "\\s+tag='MyTag'"
                             + "\\s+msg='message2'"
                             + "\\s+throwable=null"
                             + "\\s+}][\\s\\S]*")
@@ -142,7 +142,7 @@ public final class ExpectedLogMessagesRuleTest {
                     .getMessage()
                     .matches(
                         "[\\s\\S]*Expected, but not observed: \\[ExpectedLogItem\\{timeString='.+',"
-                            + " type=6, tag='Mytag', msg='message3'}]"
+                            + " type=6, tag='MyTag', msg='message3'}]"
                             + "[\\s\\S]*");
           }
 
@@ -155,12 +155,12 @@ public final class ExpectedLogMessagesRuleTest {
 
   @Test
   public void testExpectedLogMessageWithMatcherFailureOutput() {
-    Log.e("Mytag", "message1");
-    Log.e("Mytag", "message2", new IllegalArgumentException()); // Not expected
-    rule.expectLogMessage(Log.ERROR, "Mytag", "message1");
+    Log.e("MyTag", "message1");
+    Log.e("MyTag", "message2", new IllegalArgumentException()); // Not expected
+    rule.expectLogMessage(Log.ERROR, "MyTag", "message1");
     rule.expectLogMessageWithThrowableMatcher(
         Log.ERROR,
-        "Mytag",
+        "MyTag",
         "message2",
         instanceOf(UnsupportedOperationException.class)); // Not logged
 
@@ -168,7 +168,7 @@ public final class ExpectedLogMessagesRuleTest {
         "[\\s\\S]*Expected, and observed:\\s+\\[LogItem\\{"
             + "\\s+timeString='.+'"
             + "\\s+type=6"
-            + "\\s+tag='Mytag'"
+            + "\\s+tag='MyTag'"
             + "\\s+msg='message1'"
             + "\\s+throwable=null"
             + "\\s+}]"
@@ -177,7 +177,7 @@ public final class ExpectedLogMessagesRuleTest {
         "[\\s\\S]*Observed, but not expected:\\s+\\[LogItem\\{"
             + "\\s+timeString='.+'"
             + "\\s+type=6"
-            + "\\s+tag='Mytag'"
+            + "\\s+tag='MyTag'"
             + "\\s+msg='message2'"
             + "\\s+throwable=java.lang.IllegalArgumentException"
             + "(\\s+at .*\\)\\R)+"
@@ -185,7 +185,7 @@ public final class ExpectedLogMessagesRuleTest {
     String expectedNotObservedPattern =
         "[\\s\\S]*Expected, but not observed:"
             + " \\[ExpectedLogItem\\{timeString='.+',"
-            + " type=6, tag='Mytag', msg='message2', throwable="
+            + " type=6, tag='MyTag', msg='message2', throwable="
             + ".*UnsupportedOperationException.*}][\\s\\S]*";
     expectedException.expect(
         new TypeSafeMatcher<AssertionError>() {
@@ -210,24 +210,24 @@ public final class ExpectedLogMessagesRuleTest {
   }
 
   @Test
-  public void expectLogMessage_duplicateExpectatedValues_areDeduplicated() {
-    Log.e("Mytag", "message1");
-    rule.expectLogMessage(Log.ERROR, "Mytag", "message1");
-    rule.expectLogMessage(Log.ERROR, "Mytag", "message1");
+  public void expectLogMessage_duplicateExpectedValues_areDeduplicated() {
+    Log.e("MyTag", "message1");
+    rule.expectLogMessage(Log.ERROR, "MyTag", "message1");
+    rule.expectLogMessage(Log.ERROR, "MyTag", "message1");
   }
 
   @Test
-  public void expectLogMessageWithPattern_duplicateExpectatedValues_areDeduplicated() {
-    Log.e("Mytag", "message1");
-    rule.expectLogMessagePattern(Log.ERROR, "Mytag", Pattern.compile("message1"));
-    rule.expectLogMessagePattern(Log.ERROR, "Mytag", Pattern.compile("message1"));
+  public void expectLogMessageWithPattern_duplicateExpectedValues_areDeduplicated() {
+    Log.e("MyTag", "message1");
+    rule.expectLogMessagePattern(Log.ERROR, "MyTag", Pattern.compile("message1"));
+    rule.expectLogMessagePattern(Log.ERROR, "MyTag", Pattern.compile("message1"));
   }
 
   @Test
   public void expectLogMessage_duplicateMatchers_areNotDeduplicated() {
-    Log.e("Mytag", "message1");
-    rule.expectLogMessage(Log.ERROR, "Mytag", Matchers.equalTo("message1"));
-    rule.expectLogMessage(Log.ERROR, "Mytag", Matchers.equalTo("message1"));
+    Log.e("MyTag", "message1");
+    rule.expectLogMessage(Log.ERROR, "MyTag", Matchers.equalTo("message1"));
+    rule.expectLogMessage(Log.ERROR, "MyTag", Matchers.equalTo("message1"));
     expectedException.expect(Matchers.isA(AssertionError.class));
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/manifest/AndroidManifestTest.java b/robolectric/src/test/java/org/robolectric/manifest/AndroidManifestTest.java
index 826b107c0..ba6a3b051 100644
--- a/robolectric/src/test/java/org/robolectric/manifest/AndroidManifestTest.java
+++ b/robolectric/src/test/java/org/robolectric/manifest/AndroidManifestTest.java
@@ -126,21 +126,20 @@ public class AndroidManifestTest {
     AndroidManifest config = newConfig("TestAndroidManifestWithServices.xml");
     assertThat(config.getServices()).hasSize(2);
 
-    assertThat(config.getServices().get(0).getClassName()).isEqualTo("com.foo.Service");
+    assertThat(config.getServices().get(0).getName()).isEqualTo("com.foo.Service");
     assertThat(config.getServices().get(0).getActions())
         .contains("org.robolectric.ACTION_DIFFERENT_PACKAGE");
     assertThat(config.getServices().get(0).getIntentFilters()).isNotEmpty();
     assertThat(config.getServices().get(0).getIntentFilters().get(0).getMimeTypes())
         .containsExactly("image/jpeg");
 
-    assertThat(config.getServices().get(1).getClassName())
+    assertThat(config.getServices().get(1).getName())
         .isEqualTo("com.bar.ServiceWithoutIntentFilter");
     assertThat(config.getServices().get(1).getActions()).isEmpty();
     assertThat(config.getServices().get(1).getIntentFilters()).isEmpty();
 
-    assertThat(config.getServiceData("com.foo.Service").getClassName())
-        .isEqualTo("com.foo.Service");
-    assertThat(config.getServiceData("com.bar.ServiceWithoutIntentFilter").getClassName())
+    assertThat(config.getServiceData("com.foo.Service").getName()).isEqualTo("com.foo.Service");
+    assertThat(config.getServiceData("com.bar.ServiceWithoutIntentFilter").getName())
         .isEqualTo("com.bar.ServiceWithoutIntentFilter");
     assertThat(config.getServiceData("com.foo.Service").getPermission())
         .isEqualTo("com.foo.Permission");
@@ -240,6 +239,35 @@ public class AndroidManifestTest {
         .isEqualTo(VERSION_CODES.LOLLIPOP);
   }
 
+  @Test
+  public void shouldReadUnfinlizedSdkVersionFromAndroidManifest() throws Exception {
+    assertThat(
+            newConfigWith("minSdkBaklavaShortNameSdk.xml", "android:minSdkVersion=\"Baklava\"")
+                .getMinSdkVersion())
+        .isEqualTo(36);
+    assertThat(
+            newConfigWith(
+                    "targetSdkBaklavaShortNameSdk.xml", "android:targetSdkVersion=\"Baklava\"")
+                .getTargetSdkVersion())
+        .isEqualTo(36);
+    assertThat(
+            newConfigWith("maxSdkBaklavaShortNameSdk.xml", "android:maxSdkVersion=\"Baklava\"")
+                .getMaxSdkVersion())
+        .isEqualTo(36);
+  }
+
+  @Test
+  public void shouldReadUnknownSdkVersionFromAndroidManifestDefaultToLollipop() throws Exception {
+    assertThat(
+            newConfigWith("UnknownStringMinSdk.xml", "android:minSdkVersion=\"Unknown\"")
+                .getMinSdkVersion())
+        .isEqualTo(VERSION_CODES.LOLLIPOP);
+    assertThat(
+            newConfigWith("UnknownStringTargetSdk.xml", "android:targetSdkVersion=\"Unknown\"")
+                .getTargetSdkVersion())
+        .isEqualTo(VERSION_CODES.LOLLIPOP);
+  }
+
   @Test
   public void shouldReadProcessFromAndroidManifest() {
     assertThat(newConfig("TestAndroidManifestWithProcess.xml").getProcessName())
@@ -345,12 +373,12 @@ public class AndroidManifestTest {
     ActivityData activityData = appManifest.getActivityData("org.robolectric.shadows.TestActivity");
     final List<IntentFilterData> ifd = activityData.getIntentFilters();
     assertThat(ifd).isNotNull();
-    assertThat(ifd.size()).isEqualTo(1);
+    assertThat(ifd).hasSize(1);
 
     final IntentFilterData data = ifd.get(0);
-    assertThat(data.getActions().size()).isEqualTo(1);
+    assertThat(data.getActions()).hasSize(1);
     assertThat(data.getActions().get(0)).isEqualTo(Intent.ACTION_MAIN);
-    assertThat(data.getCategories().size()).isEqualTo(1);
+    assertThat(data.getCategories()).hasSize(1);
     assertThat(data.getCategories().get(0)).isEqualTo(Intent.CATEGORY_LAUNCHER);
   }
 
@@ -363,21 +391,21 @@ public class AndroidManifestTest {
     ActivityData activityData = appManifest.getActivityData("org.robolectric.shadows.TestActivity");
     final List<IntentFilterData> ifd = activityData.getIntentFilters();
     assertThat(ifd).isNotNull();
-    assertThat(ifd.size()).isEqualTo(2);
+    assertThat(ifd).hasSize(2);
 
     IntentFilterData data = ifd.get(0);
-    assertThat(data.getActions().size()).isEqualTo(1);
+    assertThat(data.getActions()).hasSize(1);
     assertThat(data.getActions().get(0)).isEqualTo(Intent.ACTION_MAIN);
-    assertThat(data.getCategories().size()).isEqualTo(1);
+    assertThat(data.getCategories()).hasSize(1);
     assertThat(data.getCategories().get(0)).isEqualTo(Intent.CATEGORY_LAUNCHER);
 
     data = ifd.get(1);
-    assertThat(data.getActions().size()).isEqualTo(3);
+    assertThat(data.getActions()).hasSize(3);
     assertThat(data.getActions().get(0)).isEqualTo(Intent.ACTION_VIEW);
     assertThat(data.getActions().get(1)).isEqualTo(Intent.ACTION_EDIT);
     assertThat(data.getActions().get(2)).isEqualTo(Intent.ACTION_PICK);
 
-    assertThat(data.getCategories().size()).isEqualTo(3);
+    assertThat(data.getCategories()).hasSize(3);
     assertThat(data.getCategories().get(0)).isEqualTo(Intent.CATEGORY_DEFAULT);
     assertThat(data.getCategories().get(1)).isEqualTo(Intent.CATEGORY_ALTERNATIVE);
     assertThat(data.getCategories().get(2)).isEqualTo(Intent.CATEGORY_SELECTED_ALTERNATIVE);
@@ -431,20 +459,20 @@ public class AndroidManifestTest {
     ActivityData activityData = appManifest.getActivityData("org.robolectric.shadows.TestActivity");
     final List<IntentFilterData> ifd = activityData.getIntentFilters();
     assertThat(ifd).isNotNull();
-    assertThat(ifd.size()).isEqualTo(1);
+    assertThat(ifd).hasSize(1);
 
     final IntentFilterData intentFilterData = ifd.get(0);
-    assertThat(intentFilterData.getActions().size()).isEqualTo(1);
+    assertThat(intentFilterData.getActions()).hasSize(1);
     assertThat(intentFilterData.getActions().get(0)).isEqualTo(Intent.ACTION_VIEW);
-    assertThat(intentFilterData.getCategories().size()).isEqualTo(1);
+    assertThat(intentFilterData.getCategories()).hasSize(1);
     assertThat(intentFilterData.getCategories().get(0)).isEqualTo(Intent.CATEGORY_DEFAULT);
 
-    assertThat(intentFilterData.getSchemes().size()).isEqualTo(3);
-    assertThat(intentFilterData.getAuthorities().size()).isEqualTo(3);
-    assertThat(intentFilterData.getMimeTypes().size()).isEqualTo(3);
-    assertThat(intentFilterData.getPaths().size()).isEqualTo(1);
-    assertThat(intentFilterData.getPathPatterns().size()).isEqualTo(1);
-    assertThat(intentFilterData.getPathPrefixes().size()).isEqualTo(1);
+    assertThat(intentFilterData.getSchemes()).hasSize(3);
+    assertThat(intentFilterData.getAuthorities()).hasSize(3);
+    assertThat(intentFilterData.getMimeTypes()).hasSize(3);
+    assertThat(intentFilterData.getPaths()).hasSize(1);
+    assertThat(intentFilterData.getPathPatterns()).hasSize(1);
+    assertThat(intentFilterData.getPathPrefixes()).hasSize(1);
 
     assertThat(intentFilterData.getSchemes().get(0)).isEqualTo("content");
     assertThat(intentFilterData.getPaths().get(0)).isEqualTo("/testPath/test.jpeg");
diff --git a/robolectric/src/test/java/org/robolectric/plugins/CustomConfigurerTest.java b/robolectric/src/test/java/org/robolectric/plugins/CustomConfigurerTest.java
index d397d3609..f0c638ac8 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/CustomConfigurerTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/CustomConfigurerTest.java
@@ -48,7 +48,7 @@ public class CustomConfigurerTest {
 
     @Test
     @SomeConfig(value = "the value")
-    public void shouldHaveValue() throws Exception {
+    public void shouldHaveValue() {
       SomeConfig someConfig = ConfigurationRegistry.get(SomeConfig.class);
       fail("someConfig value is " + someConfig.value());
     }
diff --git a/robolectric/src/test/java/org/robolectric/plugins/DefaultSdkPickerTest.java b/robolectric/src/test/java/org/robolectric/plugins/DefaultSdkPickerTest.java
index f588e93f9..e60ab9e9b 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/DefaultSdkPickerTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/DefaultSdkPickerTest.java
@@ -37,14 +37,14 @@ public class DefaultSdkPickerTest {
   }
 
   @Test
-  public void withDefaultSdk_shouldUseTargetSdkFromAndroidManifest() throws Exception {
+  public void withDefaultSdk_shouldUseTargetSdkFromAndroidManifest() {
     when(usesSdk.getTargetSdkVersion()).thenReturn(22);
     assertThat(sdkPicker.selectSdks(buildConfig(new Config.Builder()), usesSdk))
         .containsExactly(sdkCollection.getSdk(22));
   }
 
   @Test
-  public void withAllSdksConfig_shouldUseFullSdkRangeFromAndroidManifest() throws Exception {
+  public void withAllSdksConfig_shouldUseFullSdkRangeFromAndroidManifest() {
     when(usesSdk.getTargetSdkVersion()).thenReturn(22);
     when(usesSdk.getMinSdkVersion()).thenReturn(19);
     when(usesSdk.getMaxSdkVersion()).thenReturn(23);
@@ -59,8 +59,7 @@ public class DefaultSdkPickerTest {
   }
 
   @Test
-  public void withAllSdksConfigAndNoMinSdkVersion_shouldUseFullSdkRangeFromAndroidManifest()
-      throws Exception {
+  public void withAllSdksConfigAndNoMinSdkVersion_shouldUseFullSdkRangeFromAndroidManifest() {
     when(usesSdk.getTargetSdkVersion()).thenReturn(22);
     when(usesSdk.getMinSdkVersion()).thenReturn(1);
     when(usesSdk.getMaxSdkVersion()).thenReturn(22);
@@ -77,8 +76,7 @@ public class DefaultSdkPickerTest {
   }
 
   @Test
-  public void withAllSdksConfigAndNoMaxSdkVersion_shouldUseFullSdkRangeFromAndroidManifest()
-      throws Exception {
+  public void withAllSdksConfigAndNoMaxSdkVersion_shouldUseFullSdkRangeFromAndroidManifest() {
     when(usesSdk.getTargetSdkVersion()).thenReturn(22);
     when(usesSdk.getMinSdkVersion()).thenReturn(19);
     when(usesSdk.getMaxSdkVersion()).thenReturn(null);
@@ -93,7 +91,7 @@ public class DefaultSdkPickerTest {
   }
 
   @Test
-  public void withMinSdkHigherThanSupportedRange_shouldReturnNone() throws Exception {
+  public void withMinSdkHigherThanSupportedRange_shouldReturnNone() {
     when(usesSdk.getTargetSdkVersion()).thenReturn(23);
     when(usesSdk.getMinSdkVersion()).thenReturn(1);
     when(usesSdk.getMaxSdkVersion()).thenReturn(null);
@@ -102,7 +100,7 @@ public class DefaultSdkPickerTest {
   }
 
   @Test
-  public void withMinSdkHigherThanMaxSdk_shouldThrowError() throws Exception {
+  public void withMinSdkHigherThanMaxSdk_shouldThrowError() {
     when(usesSdk.getTargetSdkVersion()).thenReturn(23);
     when(usesSdk.getMinSdkVersion()).thenReturn(1);
     when(usesSdk.getMaxSdkVersion()).thenReturn(null);
@@ -118,7 +116,7 @@ public class DefaultSdkPickerTest {
   }
 
   @Test
-  public void withTargetSdkLessThanMinSdk_shouldThrowError() throws Exception {
+  public void withTargetSdkLessThanMinSdk_shouldThrowError() {
     when(usesSdk.getMinSdkVersion()).thenReturn(23);
     when(usesSdk.getTargetSdkVersion()).thenReturn(22);
 
@@ -131,7 +129,7 @@ public class DefaultSdkPickerTest {
   }
 
   @Test
-  public void withTargetSdkGreaterThanMaxSdk_shouldThrowError() throws Exception {
+  public void withTargetSdkGreaterThanMaxSdk_shouldThrowError() {
     when(usesSdk.getMaxSdkVersion()).thenReturn(21);
     when(usesSdk.getTargetSdkVersion()).thenReturn(22);
     try {
@@ -143,7 +141,7 @@ public class DefaultSdkPickerTest {
   }
 
   @Test
-  public void shouldClipSdkRangeFromAndroidManifest() throws Exception {
+  public void shouldClipSdkRangeFromAndroidManifest() {
     when(usesSdk.getTargetSdkVersion()).thenReturn(1);
     when(usesSdk.getMinSdkVersion()).thenReturn(1);
     when(usesSdk.getMaxSdkVersion()).thenReturn(null);
@@ -152,7 +150,7 @@ public class DefaultSdkPickerTest {
   }
 
   @Test
-  public void withMinSdk_shouldClipSdkRangeFromAndroidManifest() throws Exception {
+  public void withMinSdk_shouldClipSdkRangeFromAndroidManifest() {
     when(usesSdk.getTargetSdkVersion()).thenReturn(22);
     when(usesSdk.getMinSdkVersion()).thenReturn(19);
     when(usesSdk.getMaxSdkVersion()).thenReturn(23);
@@ -162,7 +160,7 @@ public class DefaultSdkPickerTest {
   }
 
   @Test
-  public void withMaxSdk_shouldUseSdkRangeFromAndroidManifest() throws Exception {
+  public void withMaxSdk_shouldUseSdkRangeFromAndroidManifest() {
     when(usesSdk.getTargetSdkVersion()).thenReturn(22);
     when(usesSdk.getMinSdkVersion()).thenReturn(19);
     when(usesSdk.getMaxSdkVersion()).thenReturn(23);
@@ -171,7 +169,7 @@ public class DefaultSdkPickerTest {
   }
 
   @Test
-  public void withExplicitSdk_selectSdks() throws Exception {
+  public void withExplicitSdk_selectSdks() {
     when(usesSdk.getTargetSdkVersion()).thenReturn(21);
     when(usesSdk.getMinSdkVersion()).thenReturn(19);
     when(usesSdk.getMaxSdkVersion()).thenReturn(22);
@@ -198,7 +196,7 @@ public class DefaultSdkPickerTest {
   }
 
   @Test
-  public void withEnabledSdks_shouldRestrictAsSpecified() throws Exception {
+  public void withEnabledSdks_shouldRestrictAsSpecified() {
     when(usesSdk.getMinSdkVersion()).thenReturn(16);
     when(usesSdk.getMaxSdkVersion()).thenReturn(23);
     sdkPicker = new DefaultSdkPicker(sdkCollection, "17,18");
@@ -209,7 +207,7 @@ public class DefaultSdkPickerTest {
   }
 
   @Test
-  public void shouldParseSdkSpecs() throws Exception {
+  public void shouldParseSdkSpecs() {
     assertThat(ConfigUtils.parseSdkArrayProperty("17,18"))
         .asList()
         .containsExactly(VERSION_CODES.JELLY_BEAN_MR1, VERSION_CODES.JELLY_BEAN_MR2);
diff --git a/robolectric/src/test/java/org/robolectric/plugins/HierarchicalConfigurationStrategyTest.java b/robolectric/src/test/java/org/robolectric/plugins/HierarchicalConfigurationStrategyTest.java
index 76abbc940..ebaeb004b 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/HierarchicalConfigurationStrategyTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/HierarchicalConfigurationStrategyTest.java
@@ -31,13 +31,13 @@ import org.robolectric.shadows.testing.TestApplication;
 public class HierarchicalConfigurationStrategyTest {
 
   @Test
-  public void defaultValuesAreMerged() throws Exception {
+  public void defaultValuesAreMerged() {
     assertThat(configFor(Test2.class, "withoutAnnotation").manifest())
         .isEqualTo("AndroidManifest.xml");
   }
 
   @Test
-  public void globalValuesAreMerged() throws Exception {
+  public void globalValuesAreMerged() {
     assertThat(
             configFor(
                     Test2.class,
@@ -48,8 +48,7 @@ public class HierarchicalConfigurationStrategyTest {
   }
 
   @Test
-  public void whenClassHasConfigAnnotation_getConfig_shouldMergeClassAndMethodConfig()
-      throws Exception {
+  public void whenClassHasConfigAnnotation_getConfig_shouldMergeClassAndMethodConfig() {
     assertConfig(
         configFor(Test1.class, "withoutAnnotation"),
         new int[] {1},
@@ -91,8 +90,7 @@ public class HierarchicalConfigurationStrategyTest {
   }
 
   @Test
-  public void whenClassDoesntHaveConfigAnnotation_getConfig_shouldUseMethodConfig()
-      throws Exception {
+  public void whenClassDoesntHaveConfigAnnotation_getConfig_shouldUseMethodConfig() {
     assertConfig(
         configFor(Test2.class, "withoutAnnotation"),
         new int[0],
@@ -134,8 +132,8 @@ public class HierarchicalConfigurationStrategyTest {
   }
 
   @Test
-  public void whenClassDoesntHaveConfigAnnotation_getConfig_shouldMergeParentClassAndMethodConfig()
-      throws Exception {
+  public void
+      whenClassDoesntHaveConfigAnnotation_getConfig_shouldMergeParentClassAndMethodConfig() {
     assertConfig(
         configFor(Test1B.class, "withoutAnnotation"),
         new int[] {1},
@@ -178,8 +176,7 @@ public class HierarchicalConfigurationStrategyTest {
 
   @Test
   public void
-      whenClassAndParentClassHaveConfigAnnotation_getConfig_shouldMergeParentClassAndMethodConfig()
-          throws Exception {
+      whenClassAndParentClassHaveConfigAnnotation_getConfig_shouldMergeParentClassAndMethodConfig() {
     assertConfig(
         configFor(Test1C.class, "withoutAnnotation"),
         new int[] {1},
@@ -222,8 +219,7 @@ public class HierarchicalConfigurationStrategyTest {
 
   @Test
   public void
-      whenClassAndSubclassHaveConfigAnnotation_getConfig_shouldMergeClassSubclassAndMethodConfig()
-          throws Exception {
+      whenClassAndSubclassHaveConfigAnnotation_getConfig_shouldMergeClassSubclassAndMethodConfig() {
     assertConfig(
         configFor(Test1A.class, "withoutAnnotation"),
         new int[] {1},
@@ -266,8 +262,7 @@ public class HierarchicalConfigurationStrategyTest {
 
   @Test
   public void
-      whenClassDoesntHaveConfigAnnotationButSubclassDoes_getConfig_shouldMergeSubclassAndMethodConfig()
-          throws Exception {
+      whenClassDoesntHaveConfigAnnotationButSubclassDoes_getConfig_shouldMergeSubclassAndMethodConfig() {
     assertConfig(
         configFor(Test2A.class, "withoutAnnotation"),
         new int[0],
@@ -309,7 +304,7 @@ public class HierarchicalConfigurationStrategyTest {
   }
 
   @Test
-  public void shouldLoadDefaultsFromGlobalPropertiesFile() throws Exception {
+  public void shouldLoadDefaultsFromGlobalPropertiesFile() {
     String properties =
         "sdk: 432\n"
             + "manifest: --none\n"
@@ -341,7 +336,7 @@ public class HierarchicalConfigurationStrategyTest {
   }
 
   @Test
-  public void shouldMergeConfigFromTestClassPackageProperties() throws Exception {
+  public void shouldMergeConfigFromTestClassPackageProperties() {
     assertConfig(
         configFor(
             Test2.class,
@@ -360,7 +355,7 @@ public class HierarchicalConfigurationStrategyTest {
   }
 
   @Test
-  public void shouldMergeConfigUpPackageHierarchy() throws Exception {
+  public void shouldMergeConfigUpPackageHierarchy() {
     assertConfig(
         configFor(
             Test2.class,
@@ -385,7 +380,7 @@ public class HierarchicalConfigurationStrategyTest {
   }
 
   @Test
-  public void withEmptyShadowList_shouldLoadDefaultsFromGlobalPropertiesFile() throws Exception {
+  public void withEmptyShadowList_shouldLoadDefaultsFromGlobalPropertiesFile() {
     assertConfig(
         configFor(
             Test2.class,
@@ -572,11 +567,11 @@ public class HierarchicalConfigurationStrategyTest {
       assetDir = "test/assets")
   public static class Test1 {
     @Test
-    public void withoutAnnotation() throws Exception {}
+    public void withoutAnnotation() {}
 
     @Test
     @Config
-    public void withDefaultsAnnotation() throws Exception {}
+    public void withDefaultsAnnotation() {}
 
     @Test
     @Config(
@@ -590,17 +585,17 @@ public class HierarchicalConfigurationStrategyTest {
         qualifiers = "from-method",
         resourceDir = "method/res",
         assetDir = "method/assets")
-    public void withOverrideAnnotation() throws Exception {}
+    public void withOverrideAnnotation() {}
   }
 
   @Ignore
   public static class Test2 {
     @Test
-    public void withoutAnnotation() throws Exception {}
+    public void withoutAnnotation() {}
 
     @Test
     @Config
-    public void withDefaultsAnnotation() throws Exception {}
+    public void withDefaultsAnnotation() {}
 
     @Test
     @Config(
@@ -614,7 +609,7 @@ public class HierarchicalConfigurationStrategyTest {
         qualifiers = "from-method",
         resourceDir = "method/res",
         assetDir = "method/assets")
-    public void withOverrideAnnotation() throws Exception {}
+    public void withOverrideAnnotation() {}
   }
 
   @Ignore
@@ -629,12 +624,12 @@ public class HierarchicalConfigurationStrategyTest {
   public static class Test1B extends Test1 {
     @Override
     @Test
-    public void withoutAnnotation() throws Exception {}
+    public void withoutAnnotation() {}
 
     @Override
     @Test
     @Config
-    public void withDefaultsAnnotation() throws Exception {}
+    public void withDefaultsAnnotation() {}
 
     @Override
     @Test
@@ -645,7 +640,7 @@ public class HierarchicalConfigurationStrategyTest {
         packageName = "com.example.test",
         qualifiers = "from-method5",
         assetDir = "method5/assets")
-    public void withOverrideAnnotation() throws Exception {}
+    public void withOverrideAnnotation() {}
   }
 
   @Ignore
diff --git a/robolectric/src/test/java/org/robolectric/plugins/LazyApplicationConfigurerTest.java b/robolectric/src/test/java/org/robolectric/plugins/LazyApplicationConfigurerTest.java
index b5cca4f82..3fca36d7d 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/LazyApplicationConfigurerTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/LazyApplicationConfigurerTest.java
@@ -13,7 +13,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public class LazyApplicationConfigurerTest {
 
-  private LazyApplicationConfigurer configurer =
+  private final LazyApplicationConfigurer configurer =
       new LazyApplicationConfigurer(new Properties(), new PackagePropertiesLoader());
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/plugins/LegacyDependencyResolverTest.java b/robolectric/src/test/java/org/robolectric/plugins/LegacyDependencyResolverTest.java
index e628be5cd..88b000ed8 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/LegacyDependencyResolverTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/LegacyDependencyResolverTest.java
@@ -44,7 +44,7 @@ public class LegacyDependencyResolverTest {
   }
 
   @Test
-  public void whenRobolectricDepsPropertiesProperty() throws Exception {
+  public void whenRobolectricDepsPropertiesProperty() {
     Path depsPath =
         tempDirectory.createFile(
             "deps.properties", "org.robolectric\\:android-all\\:" + VERSION + ": file-123.jar");
@@ -59,7 +59,7 @@ public class LegacyDependencyResolverTest {
   }
 
   @Test
-  public void whenRobolectricDepsPropertiesPropertyAndOfflineProperty() throws Exception {
+  public void whenRobolectricDepsPropertiesPropertyAndOfflineProperty() {
     Path depsPath =
         tempDirectory.createFile(
             "deps.properties", "org.robolectric\\:android-all\\:" + VERSION + ": file-123.jar");
@@ -75,7 +75,7 @@ public class LegacyDependencyResolverTest {
   }
 
   @Test
-  public void whenRobolectricDepsPropertiesResource() throws Exception {
+  public void whenRobolectricDepsPropertiesResource() {
     Path depsPath =
         tempDirectory.createFile(
             "deps.properties", "org.robolectric\\:android-all\\:" + VERSION + ": file-123.jar");
@@ -88,7 +88,7 @@ public class LegacyDependencyResolverTest {
   }
 
   @Test
-  public void whenRobolectricDependencyDirProperty() throws Exception {
+  public void whenRobolectricDependencyDirProperty() {
     Path jarsPath = tempDirectory.create("jars");
     Path sdkJarPath = tempDirectory.createFile("jars/android-all-" + VERSION + ".jar", "...");
 
diff --git a/robolectric/src/test/java/org/robolectric/plugins/SQLiteModeConfigurerTest.java b/robolectric/src/test/java/org/robolectric/plugins/SQLiteModeConfigurerTest.java
index 21966034e..99439648e 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/SQLiteModeConfigurerTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/SQLiteModeConfigurerTest.java
@@ -1,6 +1,5 @@
 package org.robolectric.plugins;
 
-import static com.google.common.base.StandardSystemProperty.OS_NAME;
 import static com.google.common.truth.Truth.assertThat;
 
 import java.util.Properties;
@@ -29,23 +28,4 @@ public class SQLiteModeConfigurerTest {
     systemProperties2.setProperty("robolectric.sqliteMode", "NATIVE");
     assertThat(configurer2.defaultConfig()).isSameInstanceAs(Mode.NATIVE);
   }
-
-  @Test
-  public void osArchSpecificConfig() {
-    String oldName = OS_NAME.value();
-    try {
-      System.setProperty("os.name", "Mac OS X");
-      SQLiteModeConfigurer configurer1 =
-          new SQLiteModeConfigurer(System.getProperties(), new PackagePropertiesLoader());
-      assertThat(configurer1.defaultConfig()).isSameInstanceAs(Mode.NATIVE);
-
-      System.setProperty("os.name", "Windows 7");
-      SQLiteModeConfigurer configurer2 =
-          new SQLiteModeConfigurer(System.getProperties(), new PackagePropertiesLoader());
-
-      assertThat(configurer2.defaultConfig()).isSameInstanceAs(Mode.LEGACY);
-    } finally {
-      System.setProperty("os.name", oldName);
-    }
-  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/plugins/SdkCollectionTest.java b/robolectric/src/test/java/org/robolectric/plugins/SdkCollectionTest.java
index a7781f127..401d21dce 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/SdkCollectionTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/SdkCollectionTest.java
@@ -40,7 +40,7 @@ public class SdkCollectionTest {
   }
 
   @Test
-  public void shouldComplainAboutDupes() throws Exception {
+  public void shouldComplainAboutDupes() {
     try {
       new SdkCollection(() -> Arrays.asList(fakeSdk1234, fakeSdk1234));
       fail();
@@ -50,7 +50,7 @@ public class SdkCollectionTest {
   }
 
   @Test
-  public void shouldCacheSdks() throws Exception {
+  public void shouldCacheSdks() {
     assertThat(sdkCollection.getSdk(1234)).isSameInstanceAs(fakeSdk1234);
     assertThat(sdkCollection.getSdk(1234)).isSameInstanceAs(fakeSdk1234);
 
@@ -58,25 +58,25 @@ public class SdkCollectionTest {
   }
 
   @Test
-  public void getMaxSupportedSdk() throws Exception {
+  public void getMaxSupportedSdk() {
     assertThat(sdkCollection.getMaxSupportedSdk()).isSameInstanceAs(fakeSdk1236);
   }
 
   @Test
-  public void getSdk_shouldReturnNullObjectForUnknownSdks() throws Exception {
+  public void getSdk_shouldReturnNullObjectForUnknownSdks() {
     assertThat(sdkCollection.getSdk(4321)).isNotNull();
     assertThat(sdkCollection.getSdk(4321).isKnown()).isFalse();
   }
 
   @Test
-  public void getKnownSdks_shouldReturnAll() throws Exception {
+  public void getKnownSdks_shouldReturnAll() {
     assertThat(sdkCollection.getKnownSdks())
         .containsExactly(fakeSdk1234, fakeSdk1235, fakeSdk1236, fakeUnsupportedSdk1237)
         .inOrder();
   }
 
   @Test
-  public void getSupportedSdks_shouldReturnOnlySupported() throws Exception {
+  public void getSupportedSdks_shouldReturnOnlySupported() {
     assertThat(sdkCollection.getSupportedSdks())
         .containsExactly(fakeSdk1234, fakeSdk1235, fakeSdk1236)
         .inOrder();
diff --git a/robolectric/src/test/java/org/robolectric/plugins/config/SingleValueConfigurerTest.java b/robolectric/src/test/java/org/robolectric/plugins/config/SingleValueConfigurerTest.java
index 1a88e89ec..85f663018 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/config/SingleValueConfigurerTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/config/SingleValueConfigurerTest.java
@@ -13,13 +13,13 @@ import org.robolectric.plugins.PackagePropertiesLoader;
 @RunWith(JUnit4.class)
 public final class SingleValueConfigurerTest {
 
-  public static enum Value {
+  public enum Value {
     ON,
-    OFF;
+    OFF,
   }
 
-  public static @interface ValueConfig {
-    public Value value() default Value.ON;
+  public @interface ValueConfig {
+    Value value() default Value.ON;
   }
 
   public static class ValueConfigReader extends SingleValueConfigurer<ValueConfig, Value> {
diff --git a/robolectric/src/test/java/org/robolectric/res/RawResourceLoaderTest.java b/robolectric/src/test/java/org/robolectric/res/RawResourceLoaderTest.java
index 219a2fad2..1a72eb8c8 100644
--- a/robolectric/src/test/java/org/robolectric/res/RawResourceLoaderTest.java
+++ b/robolectric/src/test/java/org/robolectric/res/RawResourceLoaderTest.java
@@ -24,7 +24,7 @@ public class RawResourceLoaderTest {
   }
 
   @Test
-  public void shouldReturnRawResourcesWithExtensions() throws Exception {
+  public void shouldReturnRawResourcesWithExtensions() {
     String f = (String) resourceTable.getValue(R.raw.raw_resource, new ResTable_config()).getData();
     assertThat(f)
         .isEqualTo(
@@ -36,7 +36,7 @@ public class RawResourceLoaderTest {
   }
 
   @Test
-  public void shouldReturnRawResourcesWithoutExtensions() throws Exception {
+  public void shouldReturnRawResourcesWithoutExtensions() {
     String f = (String) resourceTable.getValue(R.raw.raw_no_ext, new ResTable_config()).getData();
     assertThat(f)
         .isEqualTo(
diff --git a/robolectric/src/test/java/org/robolectric/res/ResBundleTest.java b/robolectric/src/test/java/org/robolectric/res/ResBundleTest.java
index b1feb4240..4215bfe99 100644
--- a/robolectric/src/test/java/org/robolectric/res/ResBundleTest.java
+++ b/robolectric/src/test/java/org/robolectric/res/ResBundleTest.java
@@ -17,7 +17,7 @@ import org.robolectric.res.android.ResTable_config;
 
 @RunWith(JUnit4.class)
 public class ResBundleTest {
-  private ResBundle.ResMap resMap = new ResBundle.ResMap();
+  private final ResBundle.ResMap resMap = new ResBundle.ResMap();
   private ResName resName;
 
   @Before
@@ -129,7 +129,7 @@ public class ResBundleTest {
   }
 
   @Test
-  public void shouldMatchQualifiersPerAndroidSpec() throws Exception {
+  public void shouldMatchQualifiersPerAndroidSpec() {
     assertEquals(
         "en-port",
         asResMap(
@@ -145,7 +145,7 @@ public class ResBundleTest {
   }
 
   @Test
-  public void shouldMatchQualifiersInSizeRange() throws Exception {
+  public void shouldMatchQualifiersInSizeRange() {
     assertEquals(
         "sw300dp-port",
         asResMap("", "sw200dp", "sw350dp-port", "sw300dp-port", "sw300dp")
@@ -154,7 +154,7 @@ public class ResBundleTest {
   }
 
   @Test
-  public void shouldPreferWidthOverHeight() throws Exception {
+  public void shouldPreferWidthOverHeight() {
     assertEquals(
         "sw300dp-w200dp",
         asResMap("", "sw200dp", "sw200dp-w300dp", "sw300dp-w200dp", "w300dp")
diff --git a/robolectric/src/test/java/org/robolectric/res/ResNameTest.java b/robolectric/src/test/java/org/robolectric/res/ResNameTest.java
index c0c0ee84a..e2a095afb 100644
--- a/robolectric/src/test/java/org/robolectric/res/ResNameTest.java
+++ b/robolectric/src/test/java/org/robolectric/res/ResNameTest.java
@@ -9,7 +9,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public class ResNameTest {
   @Test
-  public void shouldQualify() throws Exception {
+  public void shouldQualify() {
     assertThat(ResName.qualifyResourceName("some.package:type/name", null, null))
         .isEqualTo("some.package:type/name");
     assertThat(ResName.qualifyResourceName("some.package:type/name", "default.package", "deftype"))
@@ -26,7 +26,7 @@ public class ResNameTest {
   }
 
   @Test
-  public void shouldQualifyResNameFromString() throws Exception {
+  public void shouldQualifyResNameFromString() {
     assertThat(ResName.qualifyResName("some.package:type/name", "default_package", "default_type"))
         .isEqualTo(new ResName("some.package", "type", "name"));
     assertThat(ResName.qualifyResName("some.package:name", "default_package", "default_type"))
diff --git a/robolectric/src/test/java/org/robolectric/res/ResourceTableFactoryTest.java b/robolectric/src/test/java/org/robolectric/res/ResourceTableFactoryTest.java
index b97f9f75b..a9acd41f8 100644
--- a/robolectric/src/test/java/org/robolectric/res/ResourceTableFactoryTest.java
+++ b/robolectric/src/test/java/org/robolectric/res/ResourceTableFactoryTest.java
@@ -31,7 +31,7 @@ public class ResourceTableFactoryTest {
   }
 
   @Test
-  public void shouldHandleStyleable() throws Exception {
+  public void shouldHandleStyleable() {
     assertThat(appResourceTable.getResourceId(new ResName("org.robolectric:id/burritos")))
         .isEqualTo(R.id.burritos);
     assertThat(
@@ -41,13 +41,13 @@ public class ResourceTableFactoryTest {
   }
 
   @Test
-  public void shouldPrefixAllSystemResourcesWithAndroid() throws Exception {
+  public void shouldPrefixAllSystemResourcesWithAndroid() {
     assertThat(systemResourceTable.getResourceId(new ResName("android:id/text1")))
         .isEqualTo(android.R.id.text1);
   }
 
   @Test
-  public void shouldRetainPackageNameForFullyQualifiedQueries() throws Exception {
+  public void shouldRetainPackageNameForFullyQualifiedQueries() {
     assertThat(systemResourceTable.getResName(android.R.id.text1).getFullyQualifiedName())
         .isEqualTo("android:id/text1");
     assertThat(appResourceTable.getResName(R.id.burritos).getFullyQualifiedName())
diff --git a/robolectric/src/test/java/org/robolectric/res/ResourceTableTest.java b/robolectric/src/test/java/org/robolectric/res/ResourceTableTest.java
index 6ccca6432..aba089929 100644
--- a/robolectric/src/test/java/org/robolectric/res/ResourceTableTest.java
+++ b/robolectric/src/test/java/org/robolectric/res/ResourceTableTest.java
@@ -26,7 +26,7 @@ public class ResourceTableTest {
   }
 
   @Test
-  public void getPackageIdentifier_shouldReturnPackageIdentiferOfItsResources() {
+  public void getPackageIdentifier_shouldReturnPackageIdentifierOfItsResources() {
     resourceTable.addResource(0x02999999, "type", "name");
 
     assertThat(resourceTable.getPackageIdentifier()).isEqualTo(0x02);
diff --git a/robolectric/src/test/java/org/robolectric/res/ResourceTestUtil.java b/robolectric/src/test/java/org/robolectric/res/ResourceTestUtil.java
deleted file mode 100644
index fa3866ab3..000000000
--- a/robolectric/src/test/java/org/robolectric/res/ResourceTestUtil.java
+++ /dev/null
@@ -1,89 +0,0 @@
-package org.robolectric.res;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.TreeMap;
-import java.util.TreeSet;
-
-public class ResourceTestUtil {
-  void time(String message, Runnable runnable) {
-    long startTime = System.nanoTime();
-    for (int i = 0; i < 10; i++) {
-      runnable.run();
-    }
-    long elapsed = System.nanoTime() - startTime;
-    System.out.println("elapsed " + message + ": " + (elapsed / 1000000.0) + "ms");
-  }
-
-  @SuppressWarnings("rawtypes")
-  static String stringify(ResourceTable resourceTable) {
-    final HashMap<String, List<TypedResource>> map = new HashMap<>();
-    resourceTable.receive(
-        new ResourceTable.Visitor() {
-          @Override
-          public void visit(ResName key, Iterable<TypedResource> values) {
-            List<TypedResource> v = new ArrayList<>();
-            for (TypedResource value : values) {
-              v.add(value);
-            }
-            map.put(key.getFullyQualifiedName(), v);
-          }
-        });
-    StringBuilder buf = new StringBuilder();
-    TreeSet<String> keys = new TreeSet<>(map.keySet());
-    for (String key : keys) {
-      buf.append(key).append(":\n");
-      for (TypedResource typedResource : map.get(key)) {
-        Object data = typedResource.getData();
-        if (data instanceof List) {
-          ArrayList<String> newList = new ArrayList<>();
-          for (Object item : ((List) data)) {
-            if (item.getClass().equals(TypedResource.class)) {
-              TypedResource typedResourceItem = (TypedResource) item;
-              newList.add(
-                  typedResourceItem.getData().toString()
-                      + " ("
-                      + typedResourceItem.getResType()
-                      + ")");
-            } else {
-              newList.add(item.toString());
-            }
-          }
-          data = newList.toString();
-        } else if (data instanceof StyleData) {
-          StyleData styleData = (StyleData) data;
-          final Map<String, String> attrs = new TreeMap<>();
-          styleData.visit(
-              new StyleData.Visitor() {
-                @Override
-                public void visit(AttributeResource attributeResource) {
-                  attrs.put(
-                      attributeResource.resName.getFullyQualifiedName(), attributeResource.value);
-                }
-              });
-          data = data.toString() + "^" + styleData.getParent() + " " + attrs;
-        }
-        buf.append("  ")
-            .append(data)
-            .append(" {")
-            .append(typedResource.getResType())
-            .append("/")
-            .append(typedResource.getConfig())
-            .append(": ")
-            .append(shortContext(typedResource))
-            .append("}")
-            .append("\n");
-      }
-    }
-    return buf.toString();
-  }
-
-  static String shortContext(TypedResource<?> typedResource) {
-    return typedResource
-        .getXmlContext()
-        .toString()
-        .replaceAll("jar:/usr/local/google/home/.*\\.jar\\!", "jar:");
-  }
-}
diff --git a/robolectric/src/test/java/org/robolectric/res/StringResourcesTest.java b/robolectric/src/test/java/org/robolectric/res/StringResourcesTest.java
index 5977fb668..c545cea54 100644
--- a/robolectric/src/test/java/org/robolectric/res/StringResourcesTest.java
+++ b/robolectric/src/test/java/org/robolectric/res/StringResourcesTest.java
@@ -47,10 +47,10 @@ public class StringResourcesTest {
   @Test
   public void shouldTrimWhitespace() {
     assertThat(StringResources.processStringResources("    ")).isEmpty();
-    assertThat(StringResources.processStringResources("Trailingwhitespace    "))
-        .isEqualTo("Trailingwhitespace");
-    assertThat(StringResources.processStringResources("Leadingwhitespace    "))
-        .isEqualTo("Leadingwhitespace");
+    assertThat(StringResources.processStringResources("TrailingWhitespace    "))
+        .isEqualTo("TrailingWhitespace");
+    assertThat(StringResources.processStringResources("    LeadingWhitespace"))
+        .isEqualTo("LeadingWhitespace");
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/AdapterViewBehavior.java b/robolectric/src/test/java/org/robolectric/shadows/AdapterViewBehavior.java
index d45f613d6..90f10e047 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/AdapterViewBehavior.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/AdapterViewBehavior.java
@@ -49,7 +49,7 @@ public abstract class AdapterViewBehavior {
   }
 
   @Test
-  public void testSetAdapter_shouldCauseViewsToBeRenderedAsynchronously() throws Exception {
+  public void testSetAdapter_shouldCauseViewsToBeRenderedAsynchronously() {
     adapterView.setAdapter(new ShadowCountingAdapter(2));
 
     assertThat(adapterView.getCount()).isEqualTo(2);
@@ -62,7 +62,7 @@ public abstract class AdapterViewBehavior {
   }
 
   @Test
-  public void testSetEmptyView_shouldHideAdapterViewIfAdapterIsNull() throws Exception {
+  public void testSetEmptyView_shouldHideAdapterViewIfAdapterIsNull() {
     adapterView.setAdapter(null);
 
     View emptyView = new View(adapterView.getContext());
@@ -73,7 +73,7 @@ public abstract class AdapterViewBehavior {
   }
 
   @Test
-  public void testSetEmptyView_shouldHideAdapterViewIfAdapterViewIsEmpty() throws Exception {
+  public void testSetEmptyView_shouldHideAdapterViewIfAdapterViewIsEmpty() {
     adapterView.setAdapter(new ShadowCountingAdapter(0));
 
     View emptyView = new View(adapterView.getContext());
@@ -84,7 +84,7 @@ public abstract class AdapterViewBehavior {
   }
 
   @Test
-  public void testSetEmptyView_shouldHideEmptyViewIfAdapterViewIsNotEmpty() throws Exception {
+  public void testSetEmptyView_shouldHideEmptyViewIfAdapterViewIsNotEmpty() {
     adapterView.setAdapter(new ShadowCountingAdapter(1));
 
     View emptyView = new View(adapterView.getContext());
@@ -95,7 +95,7 @@ public abstract class AdapterViewBehavior {
   }
 
   @Test
-  public void testSetEmptyView_shouldHideEmptyViewWhenAdapterGetsNewItem() throws Exception {
+  public void testSetEmptyView_shouldHideEmptyViewWhenAdapterGetsNewItem() {
     ShadowCountingAdapter adapter = new ShadowCountingAdapter(0);
     adapterView.setAdapter(adapter);
 
@@ -114,7 +114,7 @@ public abstract class AdapterViewBehavior {
   }
 
   @Test
-  public void testSetEmptyView_shouldHideAdapterViewWhenAdapterBecomesEmpty() throws Exception {
+  public void testSetEmptyView_shouldHideAdapterViewWhenAdapterBecomesEmpty() {
     ShadowCountingAdapter adapter = new ShadowCountingAdapter(1);
     adapterView.setAdapter(adapter);
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/AssociationInfoBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/AssociationInfoBuilderTest.java
index 5eff850b0..c0c3c82d4 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/AssociationInfoBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/AssociationInfoBuilderTest.java
@@ -25,7 +25,7 @@ public final class AssociationInfoBuilderTest {
   private static final long APPROVED_MS = 1234L;
   private static final boolean REVOKED = true;
   private static final long LAST_TIME_CONNECTED_MS = 5678L;
-  private static final int SYSTEM_DATA_SYNC_FALGS = 7;
+  private static final int SYSTEM_DATA_SYNC_FLAGS = 7;
 
   @Test
   @Config(minSdk = VERSION_CODES.TIRAMISU)
@@ -53,7 +53,7 @@ public final class AssociationInfoBuilderTest {
             .setApprovedMs(APPROVED_MS)
             .setRevoked(REVOKED)
             .setLastTimeConnectedMs(LAST_TIME_CONNECTED_MS)
-            .setSystemDataSyncFlags(SYSTEM_DATA_SYNC_FALGS)
+            .setSystemDataSyncFlags(SYSTEM_DATA_SYNC_FLAGS)
             .build();
 
     assertThat(info.getId()).isEqualTo(ID);
@@ -73,7 +73,7 @@ public final class AssociationInfoBuilderTest {
       assertThat(associatedDevice).isEqualTo(associatedDeviceValue);
       int systemDataSyncFlags =
           ReflectionHelpers.callInstanceMethod(info, "getSystemDataSyncFlags");
-      assertThat(systemDataSyncFlags).isEqualTo(SYSTEM_DATA_SYNC_FALGS);
+      assertThat(systemDataSyncFlags).isEqualTo(SYSTEM_DATA_SYNC_FLAGS);
     }
 
     if (ReflectionHelpers.hasField(AssociationInfo.class, "mRevoked")) {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/BarringInfoBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/BarringInfoBuilderTest.java
index 3831c12b9..3efc2f1a0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/BarringInfoBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/BarringInfoBuilderTest.java
@@ -64,7 +64,7 @@ public final class BarringInfoBuilderTest {
   }
 
   @Test
-  public void buildBarringInfo_fromSdkR() throws Exception {
+  public void buildBarringInfo_fromSdkR() {
     BarringServiceInfo barringServiceInfo =
         BarringServiceInfoBuilder.newBuilder()
             .setBarringType(BARRING_TYPE_CONDITIONAL)
diff --git a/robolectric/src/test/java/org/robolectric/shadows/BluetoothConnectionManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/BluetoothConnectionManagerTest.java
index 45e377b62..c3552d151 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/BluetoothConnectionManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/BluetoothConnectionManagerTest.java
@@ -79,28 +79,28 @@ public final class BluetoothConnectionManagerTest {
   }
 
   @Test
-  public void test_isConnected_gattClientandServerConnection() {
+  public void test_isConnected_gattClientAndServerConnection() {
     this.manager.registerGattClientConnection(REMOTE_ADDRESS1);
     this.manager.registerGattServerConnection(REMOTE_ADDRESS1);
     assertThat(this.manager.isConnected(REMOTE_ADDRESS1)).isTrue();
   }
 
   @Test
-  public void test_isNotConnected_unregistedGattClientConnection() {
+  public void test_isNotConnected_unregisteredGattClientConnection() {
     this.manager.registerGattClientConnection(REMOTE_ADDRESS1);
     this.manager.unregisterGattClientConnection(REMOTE_ADDRESS1);
     assertThat(this.manager.isConnected(REMOTE_ADDRESS1)).isFalse();
   }
 
   @Test
-  public void test_isNotConnected_unregistedGattServerConnection() {
+  public void test_isNotConnected_unregisteredGattServerConnection() {
     this.manager.registerGattServerConnection(REMOTE_ADDRESS1);
     this.manager.unregisterGattServerConnection(REMOTE_ADDRESS1);
     assertThat(this.manager.isConnected(REMOTE_ADDRESS1)).isFalse();
   }
 
   @Test
-  public void test_isConnected_gattClientConnection_unregistedGattServerConnection() {
+  public void test_isConnected_gattClientConnection_unregisteredGattServerConnection() {
     this.manager.registerGattClientConnection(REMOTE_ADDRESS1);
     this.manager.registerGattServerConnection(REMOTE_ADDRESS1);
     this.manager.unregisterGattServerConnection(REMOTE_ADDRESS1);
@@ -108,7 +108,7 @@ public final class BluetoothConnectionManagerTest {
   }
 
   @Test
-  public void test_isConnected_gattServerConnection_unregistedGattClientConnection() {
+  public void test_isConnected_gattServerConnection_unregisteredGattClientConnection() {
     this.manager.registerGattServerConnection(REMOTE_ADDRESS1);
     this.manager.registerGattClientConnection(REMOTE_ADDRESS1);
     this.manager.unregisterGattClientConnection(REMOTE_ADDRESS1);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/CompatibilityTest.java b/robolectric/src/test/java/org/robolectric/shadows/CompatibilityTest.java
index 0bf3215c5..4fbbe16ad 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/CompatibilityTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/CompatibilityTest.java
@@ -40,7 +40,7 @@ public class CompatibilityTest {
   }
 
   @Test
-  public void edgeToEdgeEncorcement_minSdk() {
+  public void edgeToEdgeEnforcement_minSdk() {
     assertThat(ShadowCompatibility.isEnabled(ENFORCE_EDGE_TO_EDGE, U.SDK_INT)).isFalse();
     assertThat(ShadowCompatibility.isEnabled(ENFORCE_EDGE_TO_EDGE, V.SDK_INT)).isTrue();
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/HealthStatsBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/HealthStatsBuilderTest.java
index c860357c8..f8788358c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/HealthStatsBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/HealthStatsBuilderTest.java
@@ -9,6 +9,7 @@ import android.util.ArrayMap;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.primitives.Ints;
 import java.util.HashSet;
+import javax.annotation.Nonnull;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
@@ -151,7 +152,7 @@ public class HealthStatsBuilderTest {
     assertThat(Ints.asList(reversedSetAsSortedArray)).isInStrictOrder();
   }
 
-  private final void compareTimers(TimerStat timer1, TimerStat timer2) {
+  private void compareTimers(TimerStat timer1, TimerStat timer2) {
     assertThat(timer1.getCount()).isEqualTo(timer2.getCount());
     assertThat(timer1.getTime()).isEqualTo(timer2.getTime());
   }
@@ -162,6 +163,7 @@ public class HealthStatsBuilderTest {
       super(c);
     }
 
+    @Nonnull
     @Override
     public Object[] toArray() {
       Object[] forward = super.toArray();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/InputDeviceBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/InputDeviceBuilderTest.java
index 0d4feb557..5c49e6e70 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/InputDeviceBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/InputDeviceBuilderTest.java
@@ -44,8 +44,8 @@ public class InputDeviceBuilderTest {
 
     assertThat(device.getSources()).isEqualTo(InputDevice.SOURCE_HDMI);
     assertThat(device.getKeyboardType()).isEqualTo(InputDevice.KEYBOARD_TYPE_NON_ALPHABETIC);
-    assertThat(device.getVibrator().hasVibrator()).isEqualTo(true);
-    assertThat(device.hasMicrophone()).isEqualTo(true);
+    assertThat(device.getVibrator().hasVibrator()).isTrue();
+    assertThat(device.hasMicrophone()).isTrue();
   }
 
   // regression test that directly using the platform InputDevice.Builder is functioning correctly.
diff --git a/robolectric/src/test/java/org/robolectric/shadows/NetworkRegistrationInfoTestBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/NetworkRegistrationInfoTestBuilderTest.java
index 0944ae35f..c9f10046d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/NetworkRegistrationInfoTestBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/NetworkRegistrationInfoTestBuilderTest.java
@@ -69,7 +69,7 @@ public class NetworkRegistrationInfoTestBuilderTest {
   public void testSetEmergencyOnly_isSetInResultingObject() {
     NetworkRegistrationInfo networkRegistrationInfo =
         NetworkRegistrationInfoTestBuilder.newBuilder().setEmergencyOnly(true).build();
-    assertThat(networkRegistrationInfo.isEmergencyEnabled()).isEqualTo(true);
+    assertThat(networkRegistrationInfo.isEmergencyEnabled()).isTrue();
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ResponderLocationBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ResponderLocationBuilderTest.java
index 0478046fd..7d2b66ba2 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ResponderLocationBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ResponderLocationBuilderTest.java
@@ -41,7 +41,7 @@ public final class ResponderLocationBuilderTest {
 
     assertThat(responderLocation.isLciSubelementValid()).isTrue();
     assertThat(responderLocation.isZaxisSubelementValid()).isFalse();
-    assertThrows(IllegalStateException.class, () -> responderLocation.getFloorNumber());
+    assertThrows(IllegalStateException.class, responderLocation::getFloorNumber);
   }
 
   @Test
@@ -62,8 +62,8 @@ public final class ResponderLocationBuilderTest {
 
     assertThat(responderLocation.isLciSubelementValid()).isFalse();
     assertThat(responderLocation.isZaxisSubelementValid()).isFalse();
-    assertThrows(IllegalStateException.class, () -> responderLocation.getAltitude());
-    assertThrows(IllegalStateException.class, () -> responderLocation.getFloorNumber());
+    assertThrows(IllegalStateException.class, responderLocation::getAltitude);
+    assertThrows(IllegalStateException.class, responderLocation::getFloorNumber);
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/SQLiteCursorTest.java b/robolectric/src/test/java/org/robolectric/shadows/SQLiteCursorTest.java
index 95e936341..c754f48e3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/SQLiteCursorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/SQLiteCursorTest.java
@@ -51,7 +51,7 @@ public class SQLiteCursorTest {
   }
 
   @Test
-  public void testGetColumnNamesEmpty() throws Exception {
+  public void testGetColumnNamesEmpty() {
     setupEmptyResult();
     String[] columnNames = cursor.getColumnNames();
 
@@ -72,7 +72,7 @@ public class SQLiteCursorTest {
   }
 
   @Test
-  public void testGetColumnIndexEmpty() throws Exception {
+  public void testGetColumnIndexEmpty() {
     setupEmptyResult();
 
     assertThat(cursor.getColumnIndex("id")).isEqualTo(0);
@@ -91,14 +91,14 @@ public class SQLiteCursorTest {
   }
 
   @Test
-  public void testGetColumnIndexOrThrowEmpty() throws Exception {
+  public void testGetColumnIndexOrThrowEmpty() {
     setupEmptyResult();
 
     assertThat(cursor.getColumnIndexOrThrow("name")).isEqualTo(1);
   }
 
   @Test(expected = IllegalArgumentException.class)
-  public void testGetColumnIndexOrThrowNotFoundEmpty() throws Exception {
+  public void testGetColumnIndexOrThrowNotFoundEmpty() {
     setupEmptyResult();
 
     cursor.getColumnIndexOrThrow("Fred");
@@ -112,7 +112,7 @@ public class SQLiteCursorTest {
   }
 
   @Test
-  public void testMoveToFirstEmpty() throws Exception {
+  public void testMoveToFirstEmpty() {
     setupEmptyResult();
 
     assertThat(cursor.moveToFirst()).isFalse();
@@ -159,7 +159,7 @@ public class SQLiteCursorTest {
   }
 
   @Test
-  public void testMoveToNextEmpty() throws Exception {
+  public void testMoveToNextEmpty() {
     setupEmptyResult();
 
     assertThat(cursor.moveToFirst()).isFalse();
@@ -185,7 +185,7 @@ public class SQLiteCursorTest {
   }
 
   @Test
-  public void testMoveToPreviousEmpty() throws Exception {
+  public void testMoveToPreviousEmpty() {
     setupEmptyResult();
     assertThat(cursor.moveToFirst()).isFalse();
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/SQLiteDatabaseTest.java b/robolectric/src/test/java/org/robolectric/shadows/SQLiteDatabaseTest.java
index b1c496cc0..e1ca6d6c5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/SQLiteDatabaseTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/SQLiteDatabaseTest.java
@@ -26,7 +26,7 @@ import org.junit.runner.RunWith;
 @RunWith(AndroidJUnit4.class)
 public class SQLiteDatabaseTest {
   private SQLiteDatabase database;
-  private List<SQLiteDatabase> openDatabases = new ArrayList<>();
+  private final List<SQLiteDatabase> openDatabases = new ArrayList<>();
   private static final String ANY_VALID_SQL = "SELECT 1";
   private File databasePath;
 
@@ -785,7 +785,7 @@ public class SQLiteDatabaseTest {
   }
 
   @Test
-  public void testCreateAndDropTable() throws Exception {
+  public void testCreateAndDropTable() {
     SQLiteDatabase db = openOrCreateDatabase("db1");
     db.execSQL("CREATE TABLE foo(id INTEGER PRIMARY KEY AUTOINCREMENT, data TEXT);");
     Cursor c = db.query("FOO", null, null, null, null, null, null);
@@ -880,18 +880,17 @@ public class SQLiteDatabaseTest {
     final CountDownLatch sync = new CountDownLatch(1);
     final Throwable[] error = {null};
 
-    new Thread() {
-      @Override
-      public void run() {
-        try (Cursor c = executeQuery("select * from table_name")) {
-        } catch (Throwable e) {
-          e.printStackTrace();
-          error[0] = e;
-        } finally {
-          sync.countDown();
-        }
-      }
-    }.start();
+    new Thread(
+            () -> {
+              try (Cursor c = executeQuery("select * from table_name")) {
+              } catch (Throwable e) {
+                e.printStackTrace();
+                error[0] = e;
+              } finally {
+                sync.countDown();
+              }
+            })
+        .start();
 
     try {
       sync.await();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ServiceStateBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ServiceStateBuilderTest.java
index 620ce51a4..bb2b456c4 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ServiceStateBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ServiceStateBuilderTest.java
@@ -15,7 +15,7 @@ import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 import org.robolectric.util.ReflectionHelpers;
 
-/** Test for {@link ShadowServiceState}. */
+/** Test for {@link ServiceState}. */
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = P)
 public class ServiceStateBuilderTest {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsSpinnerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsSpinnerTest.java
index 1c1474f7f..cd2d8a44b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsSpinnerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsSpinnerTest.java
@@ -16,6 +16,7 @@ import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -127,8 +128,9 @@ public class ShadowAbsSpinnerTest {
       super(context, android.R.layout.simple_spinner_item, testItems);
     }
 
+    @Nonnull
     @Override
-    public View getView(int position, View convertView, ViewGroup parent) {
+    public View getView(int position, View convertView, @Nonnull ViewGroup parent) {
       return new View(getContext());
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsoluteLayoutTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsoluteLayoutTest.java
index d3101ad2d..32407bd8a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsoluteLayoutTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsoluteLayoutTest.java
@@ -13,7 +13,7 @@ import org.junit.runner.RunWith;
 public class ShadowAbsoluteLayoutTest {
 
   @Test
-  public void getLayoutParams_shouldReturnAbsoluteLayoutParams() throws Exception {
+  public void getLayoutParams_shouldReturnAbsoluteLayoutParams() {
     ViewGroup.LayoutParams layoutParams =
         new AbsoluteLayout(ApplicationProvider.getApplicationContext()) {
           @Override
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityButtonControllerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityButtonControllerTest.java
index 43d9cc174..8f69af22d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityButtonControllerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityButtonControllerTest.java
@@ -5,14 +5,13 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.accessibilityservice.AccessibilityButtonController;
-import android.accessibilityservice.AccessibilityService;
-import android.view.accessibility.AccessibilityEvent;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.testing.TestAccessibilityService;
 
 /** Unit tests for {@link ShadowAccessibilityButtonController}. */
 @RunWith(AndroidJUnit4.class)
@@ -25,7 +24,7 @@ public class ShadowAccessibilityButtonControllerTest {
 
   @Before
   public void setUp() {
-    MyService service = Robolectric.setupService(MyService.class);
+    TestAccessibilityService service = Robolectric.setupService(TestAccessibilityService.class);
     accessibilityButtonController = service.getAccessibilityButtonController();
   }
 
@@ -47,22 +46,4 @@ public class ShadowAccessibilityButtonControllerTest {
         };
     accessibilityButtonController.registerAccessibilityButtonCallback(accessibilityButtonCallback);
   }
-
-  /** AccessibilityService for {@link ShadowAccessibilityButtonControllerTest} */
-  public static class MyService extends AccessibilityService {
-    @Override
-    public void onDestroy() {
-      super.onDestroy();
-    }
-
-    @Override
-    public void onAccessibilityEvent(AccessibilityEvent arg0) {
-      // Do nothing
-    }
-
-    @Override
-    public void onInterrupt() {
-      // Do nothing
-    }
-  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityInputConnectionTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityInputConnectionTest.java
new file mode 100644
index 000000000..ea6a130b3
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityInputConnectionTest.java
@@ -0,0 +1,157 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static com.google.common.truth.Truth.assertThat;
+import static org.robolectric.Shadows.shadowOf;
+
+import android.accessibilityservice.AccessibilityServiceInfo;
+import android.accessibilityservice.InputMethod;
+import android.accessibilityservice.InputMethod.AccessibilityInputConnection;
+import android.util.Pair;
+import android.view.KeyEvent;
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.SurroundingText;
+import android.view.inputmethod.TextAttribute;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadow.api.Shadow;
+import org.robolectric.shadows.testing.TestAccessibilityService;
+
+@RunWith(AndroidJUnit4.class)
+@Config(minSdk = TIRAMISU)
+public final class ShadowAccessibilityInputConnectionTest {
+  private AccessibilityInputConnection inputConnection;
+  private ShadowAccessibilityInputConnection shadow;
+  private TestAccessibilityService service;
+
+  @Before
+  public void setUp() {
+    service = Robolectric.setupService(TestAccessibilityService.class);
+    AccessibilityServiceInfo serviceInfo = new AccessibilityServiceInfo();
+    serviceInfo.flags |= AccessibilityServiceInfo.FLAG_INPUT_METHOD_EDITOR;
+    service.setServiceInfo(serviceInfo);
+    shadowOf(service).startInput(new EditorInfo());
+    InputMethod inputMethod = service.getInputMethod();
+    inputConnection = inputMethod.getCurrentInputConnection();
+    shadow = Shadow.extract(inputConnection);
+  }
+
+  @Test
+  public void commitText_recordsArguments() {
+    assertThat(shadow.getCommitTextArguments()).isEmpty();
+
+    TextAttribute textAttribute = new TextAttribute.Builder().build();
+    inputConnection.commitText("Hello", 0, textAttribute);
+    assertThat(shadow.getCommitTextArguments()).hasSize(1);
+    ShadowAccessibilityInputConnection.CommitTextArgs args = shadow.getCommitTextArguments().get(0);
+    assertThat(args.text().toString()).isEqualTo("Hello");
+    assertThat(args.newCursorPosition()).isEqualTo(0);
+    assertThat(args.textAttribute()).isEqualTo(textAttribute);
+
+    List<String> suggestions = Arrays.asList("Suggestion 1", "Suggestion 2", "Suggestion 3");
+    TextAttribute textAttribute2 =
+        new TextAttribute.Builder().setTextConversionSuggestions(suggestions).build();
+    inputConnection.commitText("World", 1, textAttribute2);
+    assertThat(shadow.getCommitTextArguments()).hasSize(2);
+    args = shadow.getCommitTextArguments().get(1);
+    assertThat(args.text().toString()).isEqualTo("World");
+    assertThat(args.newCursorPosition()).isEqualTo(1);
+    assertThat(args.textAttribute()).isEqualTo(textAttribute2);
+  }
+
+  @Test
+  public void getSurroundingText_returnsNullIfNotSet() {
+    assertThat(inputConnection.getSurroundingText(0, 0, 0)).isNull();
+  }
+
+  @Test
+  public void getSurroundingText_returnsSetSurroundingText() {
+    SurroundingText surroundingText = new SurroundingText("And to institute new", 0, 42, 70);
+    shadow.setSurroundingText(surroundingText);
+    assertThat(inputConnection.getSurroundingText(0, 0, 0)).isEqualTo(surroundingText);
+  }
+
+  @Test
+  public void getSurroundingText_recordsArguments() {
+    assertThat(shadow.getSurroundingTextArguments()).isEmpty();
+
+    inputConnection.getSurroundingText(0, 0, 0);
+    assertThat(shadow.getSurroundingTextArguments()).hasSize(1);
+    ShadowAccessibilityInputConnection.SurroundingTextArgs args =
+        shadow.getSurroundingTextArguments().get(0);
+    assertThat(args.beforeLength()).isEqualTo(0);
+    assertThat(args.afterLength()).isEqualTo(0);
+    assertThat(args.flags()).isEqualTo(0);
+
+    inputConnection.getSurroundingText(1, 22, 1973);
+    assertThat(shadow.getSurroundingTextArguments()).hasSize(2);
+    args = shadow.getSurroundingTextArguments().get(1);
+    assertThat(args.beforeLength()).isEqualTo(1);
+    assertThat(args.afterLength()).isEqualTo(22);
+    assertThat(args.flags()).isEqualTo(1973);
+  }
+
+  @Test
+  public void performContextMenuAction_recordsActions() {
+    assertThat(shadow.getContextMenuActions()).isEmpty();
+
+    inputConnection.performContextMenuAction(android.R.id.cut);
+    assertThat(shadow.getContextMenuActions()).containsExactly(android.R.id.cut);
+
+    inputConnection.performContextMenuAction(android.R.id.paste);
+    assertThat(shadow.getContextMenuActions())
+        .containsExactly(android.R.id.cut, android.R.id.paste);
+  }
+
+  @Test
+  public void performEditorAction_recordsActions() {
+    assertThat(shadow.getEditorActions()).isEmpty();
+
+    inputConnection.performEditorAction(EditorInfo.IME_ACTION_SEARCH);
+    assertThat(shadow.getEditorActions()).containsExactly(EditorInfo.IME_ACTION_SEARCH);
+
+    inputConnection.performEditorAction(EditorInfo.IME_ACTION_NEXT);
+    assertThat(shadow.getEditorActions())
+        .containsExactly(EditorInfo.IME_ACTION_SEARCH, EditorInfo.IME_ACTION_NEXT);
+  }
+
+  @Test
+  public void sendKeyEvent_recordsEvents() {
+    assertThat(shadow.getKeyEvents()).isEmpty();
+
+    KeyEvent firstEvent = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER);
+    inputConnection.sendKeyEvent(firstEvent);
+    assertThat(shadow.getKeyEvents()).containsExactly(firstEvent);
+
+    KeyEvent secondEvent = new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_ENTER);
+    inputConnection.sendKeyEvent(secondEvent);
+    assertThat(shadow.getKeyEvents()).containsExactly(firstEvent, secondEvent);
+  }
+
+  @Test
+  public void setSelection_recordsSelections() {
+    assertThat(shadow.getSetSelections()).isEmpty();
+
+    inputConnection.setSelection(0, 1);
+    assertThat(shadow.getSetSelections()).containsExactly(Pair.create(0, 1));
+
+    inputConnection.setSelection(1, 2);
+    assertThat(shadow.getSetSelections()).containsExactly(Pair.create(0, 1), Pair.create(1, 2));
+  }
+
+  @Test
+  public void secondInputConnection_sharesState() {
+    // Perform an action on a second input connection from the same service (and thus the same
+    // InputMethod).
+    service.getInputMethod().getCurrentInputConnection().performContextMenuAction(android.R.id.cut);
+
+    // The shadow of the first input connection should be updated.
+    assertThat(shadow.getContextMenuActions()).containsExactly(android.R.id.cut);
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityInputMethodTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityInputMethodTest.java
new file mode 100644
index 000000000..9f069f5bc
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityInputMethodTest.java
@@ -0,0 +1,64 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static com.google.common.truth.Truth.assertThat;
+import static org.robolectric.Shadows.shadowOf;
+
+import android.accessibilityservice.AccessibilityServiceInfo;
+import android.accessibilityservice.InputMethod;
+import android.view.inputmethod.EditorInfo;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.testing.TestAccessibilityService;
+
+@RunWith(AndroidJUnit4.class)
+@Config(minSdk = TIRAMISU)
+public final class ShadowAccessibilityInputMethodTest {
+  private InputMethod inputMethod;
+  private ShadowAccessibilityService shadowService;
+
+  @Before
+  public void setUp() {
+    TestAccessibilityService service = Robolectric.setupService(TestAccessibilityService.class);
+    shadowService = shadowOf(service);
+    AccessibilityServiceInfo serviceInfo = new AccessibilityServiceInfo();
+    serviceInfo.flags |= AccessibilityServiceInfo.FLAG_INPUT_METHOD_EDITOR;
+    service.setServiceInfo(serviceInfo);
+    inputMethod = service.getInputMethod();
+  }
+
+  @Test
+  public void getCurrentInputConnection_returnsNullIfNotConnected() {
+    assertThat(inputMethod.getCurrentInputConnection()).isNull();
+  }
+
+  @Test
+  public void getCurrentInputConnection_returnsConnectionIfConnected() {
+    shadowService.startInput(new EditorInfo());
+    InputMethod.AccessibilityInputConnection connection = inputMethod.getCurrentInputConnection();
+    assertThat(connection).isNotNull();
+  }
+
+  @Test
+  public void getCurrentEditorInfo_returnsNullIfNotSet() {
+    shadowService.startInput(null);
+    assertThat(inputMethod.getCurrentInputEditorInfo()).isNull();
+  }
+
+  @Test
+  public void getCurrentEditorInfo_returnsNullIfNotConnected() {
+    assertThat(inputMethod.getCurrentInputEditorInfo()).isNull();
+  }
+
+  @Test
+  public void getCurrentEditorInfo_returnsEditorInfoIfSetAndConnected() {
+    EditorInfo editorInfo = new EditorInfo();
+    editorInfo.hintText = "Watermelon";
+    shadowService.startInput(editorInfo);
+    assertThat(inputMethod.getCurrentInputEditorInfo()).isEqualTo(editorInfo);
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityManagerTest.java
index 115882b37..093723b56 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityManagerTest.java
@@ -194,11 +194,11 @@ public class ShadowAccessibilityManagerTest {
   @Test
   public void setTouchExplorationEnabled_invokesCallbacks() {
     AtomicBoolean enabled = new AtomicBoolean(false);
-    accessibilityManager.addTouchExplorationStateChangeListener(val -> enabled.set(val));
+    accessibilityManager.addTouchExplorationStateChangeListener(enabled::set);
     shadowOf(accessibilityManager).setTouchExplorationEnabled(true);
-    assertThat(enabled.get()).isEqualTo(true);
+    assertThat(enabled.get()).isTrue();
     shadowOf(accessibilityManager).setTouchExplorationEnabled(false);
-    assertThat(enabled.get()).isEqualTo(false);
+    assertThat(enabled.get()).isFalse();
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityNodeInfoTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityNodeInfoTest.java
index 869e9359d..8c347531d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityNodeInfoTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityNodeInfoTest.java
@@ -15,6 +15,7 @@ import android.os.Parcel;
 import android.view.View;
 import android.view.accessibility.AccessibilityNodeInfo;
 import android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction;
+import android.view.accessibility.AccessibilityNodeInfo.CollectionInfo;
 import android.view.accessibility.AccessibilityWindowInfo;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -105,7 +106,7 @@ public class ShadowAccessibilityNodeInfoTest {
     node = AccessibilityNodeInfo.obtain();
     node.setClickable(false);
     shadow = shadowOf(node);
-    assertThat(node.isClickable()).isEqualTo(false);
+    assertThat(node.isClickable()).isFalse();
     node.setText("Test");
     node.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
     node.setTextSelection(0, 1);
@@ -121,7 +122,7 @@ public class ShadowAccessibilityNodeInfoTest {
     node.addAction(AccessibilityNodeInfo.ACTION_PASTE);
     assertThat(node.getActions()).isEqualTo(AccessibilityNodeInfo.ACTION_PASTE);
     node.setClickable(true);
-    assertThat(node.isClickable()).isEqualTo(true);
+    assertThat(node.isClickable()).isTrue();
     node.setClickable(false);
     node.removeAction(AccessibilityNodeInfo.ACTION_PASTE);
     node.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
@@ -138,12 +139,12 @@ public class ShadowAccessibilityNodeInfoTest {
         (action, arguments) -> action == AccessibilityNodeInfo.ACTION_CLICK);
 
     boolean clickResult = node.performAction(AccessibilityNodeInfo.ACTION_CLICK);
-    assertThat(clickResult).isEqualTo(true);
-    assertThat(shadow.getPerformedActions().isEmpty()).isEqualTo(false);
+    assertThat(clickResult).isTrue();
+    assertThat(shadow.getPerformedActions().isEmpty()).isFalse();
     assertThat(shadow.getPerformedActions().get(0)).isEqualTo(AccessibilityNodeInfo.ACTION_CLICK);
     boolean longClickResult = node.performAction(AccessibilityNodeInfo.ACTION_LONG_CLICK);
-    assertThat(longClickResult).isEqualTo(false);
-    assertThat(shadow.getPerformedActions().size()).isEqualTo(2);
+    assertThat(longClickResult).isFalse();
+    assertThat(shadow.getPerformedActions()).hasSize(2);
     assertThat(shadow.getPerformedActions().get(1))
         .isEqualTo(AccessibilityNodeInfo.ACTION_LONG_CLICK);
   }
@@ -315,4 +316,29 @@ public class ShadowAccessibilityNodeInfoTest {
     AccessibilityNodeInfo node2 = AccessibilityNodeInfo.obtain(node);
     assertThat(node2.isSealed()).isTrue();
   }
+
+  @Test
+  public void obtainCollectionInfo_doesNotCrash() {
+    // See https://github.com/robolectric/robolectric/issues/3384
+    CollectionInfo collectionInfo = CollectionInfo.obtain(12, 0, false);
+
+    assertThat(collectionInfo).isNotNull();
+    assertThat(collectionInfo.getSelectionMode()).isEqualTo(CollectionInfo.SELECTION_MODE_NONE);
+    assertThat(collectionInfo.getRowCount()).isEqualTo(12);
+    assertThat(collectionInfo.getColumnCount()).isEqualTo(0);
+    assertThat(collectionInfo.isHierarchical()).isFalse();
+  }
+
+  @Test
+  public void obtainCollectionInfo_withSelectionMode_doesNotCrash() {
+    // See https://github.com/robolectric/robolectric/issues/3384
+    CollectionInfo collectionInfo =
+        CollectionInfo.obtain(12, 0, false, CollectionInfo.SELECTION_MODE_MULTIPLE);
+
+    assertThat(collectionInfo).isNotNull();
+    assertThat(collectionInfo.getSelectionMode()).isEqualTo(CollectionInfo.SELECTION_MODE_MULTIPLE);
+    assertThat(collectionInfo.getRowCount()).isEqualTo(12);
+    assertThat(collectionInfo.getColumnCount()).isEqualTo(0);
+    assertThat(collectionInfo.isHierarchical()).isFalse();
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityServiceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityServiceTest.java
index 4b8643447..54ef84a14 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityServiceTest.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
+import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 
@@ -10,13 +11,14 @@ import android.accessibilityservice.AccessibilityService;
 import android.accessibilityservice.AccessibilityService.GestureResultCallback;
 import android.accessibilityservice.AccessibilityService.ScreenshotResult;
 import android.accessibilityservice.AccessibilityService.TakeScreenshotCallback;
+import android.accessibilityservice.AccessibilityServiceInfo;
 import android.accessibilityservice.GestureDescription;
 import android.accessibilityservice.GestureDescription.StrokeDescription;
 import android.graphics.Path;
 import android.view.Display;
-import android.view.accessibility.AccessibilityEvent;
 import android.view.accessibility.AccessibilityNodeInfo;
 import android.view.accessibility.AccessibilityWindowInfo;
+import android.view.inputmethod.EditorInfo;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.MoreExecutors;
@@ -28,15 +30,16 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.testing.TestAccessibilityService;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowAccessibilityServiceTest {
-  private MyService service;
+  private TestAccessibilityService service;
   private ShadowAccessibilityService shadow;
 
   @Before
   public void setUp() {
-    service = Robolectric.setupService(MyService.class);
+    service = Robolectric.setupService(TestAccessibilityService.class);
     shadow = shadowOf(service);
   }
 
@@ -44,7 +47,7 @@ public class ShadowAccessibilityServiceTest {
   @Test
   public void shouldRecordPerformedAction() {
     service.performGlobalAction(AccessibilityService.GLOBAL_ACTION_BACK);
-    assertThat(shadow.getGlobalActionsPerformed().size()).isEqualTo(1);
+    assertThat(shadow.getGlobalActionsPerformed()).hasSize(1);
     assertThat(shadow.getGlobalActionsPerformed().get(0)).isEqualTo(1);
   }
 
@@ -132,6 +135,29 @@ public class ShadowAccessibilityServiceTest {
         .isTrue();
   }
 
+  @Test
+  @Config(minSdk = TIRAMISU)
+  public void startInput_startsInputMethod() {
+    assertThat(service.getInputMethod()).isNull();
+
+    // Set flags to get an InputMethod.
+    AccessibilityServiceInfo serviceInfo = new AccessibilityServiceInfo();
+    serviceInfo.flags |= AccessibilityServiceInfo.FLAG_INPUT_METHOD_EDITOR;
+    service.setServiceInfo(serviceInfo);
+    assertThat(service.getInputMethod()).isNotNull();
+    assertThat(service.getInputMethod().getCurrentInputStarted()).isFalse();
+    assertThat(service.getInputMethod().getCurrentInputConnection()).isNull();
+
+    // Start input.
+    EditorInfo editorInfo = new EditorInfo();
+    editorInfo.hintText = "Watermelon";
+    shadow.startInput(editorInfo);
+    assertThat(service.getInputMethod()).isNotNull();
+    assertThat(service.getInputMethod().getCurrentInputStarted()).isTrue();
+    assertThat(service.getInputMethod().getCurrentInputConnection()).isNotNull();
+    assertThat(service.getInputMethod().getCurrentInputEditorInfo()).isEqualTo(editorInfo);
+  }
+
   @Test
   @Config(minSdk = R)
   public void takeScreenshot_byDefault_immediatelyReturnsSuccessfully() {
@@ -225,13 +251,13 @@ public class ShadowAccessibilityServiceTest {
 
   @Test
   @Config(minSdk = R)
-  public void getWindowsforDefaultDisplay_returnEmptyList() {
+  public void getWindowsForDefaultDisplay_returnEmptyList() {
     assertThat(service.getWindowsOnAllDisplays().get(Display.DEFAULT_DISPLAY)).isEmpty();
   }
 
   @Test
   @Config(minSdk = R)
-  public void getWindowsforNonDefaultDisplay_returnNullList() {
+  public void getWindowsForNonDefaultDisplay_returnNullList() {
     assertThat(service.getWindowsOnAllDisplays().get(Display.DEFAULT_DISPLAY + 1)).isNull();
   }
 
@@ -348,21 +374,4 @@ public class ShadowAccessibilityServiceTest {
       public void onCancelled(GestureDescription description) {}
     };
   }
-
-  public static class MyService extends AccessibilityService {
-    @Override
-    public void onDestroy() {
-      super.onDestroy();
-    }
-
-    @Override
-    public void onAccessibilityEvent(AccessibilityEvent arg0) {
-      // Do nothing
-    }
-
-    @Override
-    public void onInterrupt() {
-      // Do nothing
-    }
-  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityWindowInfoTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityWindowInfoTest.java
index 54f632d48..b3619a19d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityWindowInfoTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityWindowInfoTest.java
@@ -27,7 +27,7 @@ public class ShadowAccessibilityWindowInfoTest {
 
   @Test
   public void shouldNotHaveRootNode() {
-    assertThat(shadow.getRoot() == null).isEqualTo(true);
+    assertThat(shadow.getRoot() == null).isTrue();
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccountManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccountManagerTest.java
index 3f6583c66..1f0caf194 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccountManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccountManagerTest.java
@@ -408,7 +408,7 @@ public class ShadowAccountManagerTest {
   }
 
   @Test
-  public void removeAccount_doesNotNotifyIfUnuccessful() {
+  public void removeAccount_doesNotNotifyIfUnsuccessful() {
     Account account = new Account("name", "type");
 
     TestOnAccountsUpdateListener listener = new TestOnAccountsUpdateListener();
@@ -794,7 +794,7 @@ public class ShadowAccountManagerTest {
   }
 
   @Test
-  public void addAccount_withOptionsShouldSupportGetNextAddAccountOptions() throws Exception {
+  public void addAccount_withOptionsShouldSupportGetNextAddAccountOptions() {
     assertThat(shadowOf(am).getNextAddAccountOptions()).isNull();
 
     shadowOf(am).addAuthenticator("google.com");
@@ -811,7 +811,7 @@ public class ShadowAccountManagerTest {
   }
 
   @Test
-  public void addAccount_withOptionsShouldSupportPeekNextAddAccountOptions() throws Exception {
+  public void addAccount_withOptionsShouldSupportPeekNextAddAccountOptions() {
     assertThat(shadowOf(am).peekNextAddAccountOptions()).isNull();
 
     shadowOf(am).addAuthenticator("google.com");
@@ -847,7 +847,7 @@ public class ShadowAccountManagerTest {
   }
 
   @Test
-  public void testGetAsSystemService() throws Exception {
+  public void testGetAsSystemService() {
     AccountManager systemService =
         (AccountManager)
             ApplicationProvider.getApplicationContext().getSystemService(Context.ACCOUNT_SERVICE);
@@ -970,7 +970,7 @@ public class ShadowAccountManagerTest {
         am.hasFeatures(account, new String[] {"FEATURE_1", "FEATURE_2"}, callback, new Handler());
 
     assertThat(future.isDone()).isTrue();
-    assertThat(future.getResult().booleanValue()).isEqualTo(true);
+    assertThat(future.getResult()).isTrue();
 
     shadowMainLooper().idle();
     assertThat(callback.hasBeenCalled()).isTrue();
@@ -987,7 +987,7 @@ public class ShadowAccountManagerTest {
         am.hasFeatures(account, new String[] {"FEATURE_1", "FEATURE_2"}, callback, new Handler());
 
     assertThat(future.isDone()).isTrue();
-    assertThat(future.getResult().booleanValue()).isEqualTo(false);
+    assertThat(future.getResult()).isFalse();
     shadowMainLooper().idle();
     assertThat(callback.hasBeenCalled()).isTrue();
   }
@@ -1090,7 +1090,7 @@ public class ShadowAccountManagerTest {
   }
 
   @Test
-  public void removeAllAccounts() throws Exception {
+  public void removeAllAccounts() {
 
     Account account = new Account("name@gmail.com", "gmail.com");
     shadowOf(am).addAccount(account);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java
index 45902ef43..133fe1541 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java
@@ -134,7 +134,7 @@ public class ShadowActivityManagerTest {
     final ActivityManager.RunningAppProcessInfo process2 =
         buildProcessInfo(new ComponentName("org.robolectric", "Process 2"));
 
-    assertThat(activityManager.getRunningAppProcesses().size()).isEqualTo(1);
+    assertThat(activityManager.getRunningAppProcesses()).hasSize(1);
     ActivityManager.RunningAppProcessInfo myInfo = activityManager.getRunningAppProcesses().get(0);
     assertThat(myInfo.pid).isEqualTo(android.os.Process.myPid());
     assertThat(myInfo.uid).isEqualTo(android.os.Process.myUid());
@@ -326,7 +326,7 @@ public class ShadowActivityManagerTest {
 
   @Config(minSdk = R)
   @Test
-  public void getHistoricalProcessExitReasons_recordsRetunredInCorrectOrder() {
+  public void getHistoricalProcessExitReasons_recordsReturnedInCorrectOrder() {
     addApplicationExitInfo(/* pid= */ 1);
     addApplicationExitInfo(/* pid= */ 2);
     addApplicationExitInfo(/* pid= */ 3);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityTest.java
index 56b7cec6f..caf50e7c3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityTest.java
@@ -73,6 +73,7 @@ import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
+import javax.annotation.Nonnull;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.R;
@@ -93,14 +94,14 @@ public class ShadowActivityTest {
   private Activity activity;
 
   @Test
-  public void shouldUseApplicationLabelFromManifestAsTitleForActivity() throws Exception {
+  public void shouldUseApplicationLabelFromManifestAsTitleForActivity() {
     activity = Robolectric.setupActivity(LabelTestActivity1.class);
     assertThat(activity.getTitle()).isNotNull();
     assertThat(activity.getTitle().toString()).isEqualTo(activity.getString(R.string.app_name));
   }
 
   @Test
-  public void shouldUseActivityLabelFromManifestAsTitleForActivity() throws Exception {
+  public void shouldUseActivityLabelFromManifestAsTitleForActivity() {
     activity = Robolectric.setupActivity(LabelTestActivity2.class);
     assertThat(activity.getTitle()).isNotNull();
     assertThat(activity.getTitle().toString())
@@ -108,7 +109,7 @@ public class ShadowActivityTest {
   }
 
   @Test
-  public void shouldUseActivityLabelFromManifestAsTitleForActivityWithShortName() throws Exception {
+  public void shouldUseActivityLabelFromManifestAsTitleForActivityWithShortName() {
     activity = Robolectric.setupActivity(LabelTestActivity3.class);
     assertThat(activity.getTitle()).isNotNull();
     assertThat(activity.getTitle().toString())
@@ -223,8 +224,7 @@ public class ShadowActivityTest {
 
   @Test
   public void
-      shouldNotComplainIfActivityIsDestroyedWhileAnotherActivityHasRegisteredBroadcastReceivers()
-          throws Exception {
+      shouldNotComplainIfActivityIsDestroyedWhileAnotherActivityHasRegisteredBroadcastReceivers() {
     try (ActivityController<DialogCreatingActivity> controller =
         Robolectric.buildActivity(DialogCreatingActivity.class)) {
       activity = controller.get();
@@ -1047,7 +1047,8 @@ public class ShadowActivityTest {
 
     @Override
     public void onGetDirectActions(
-        CancellationSignal cancellationSignal, Consumer<List<DirectAction>> callback) {
+        @Nonnull CancellationSignal cancellationSignal,
+        @Nonnull Consumer<List<DirectAction>> callback) {
       if (returnMalformedDirectAction) {
         callback.accept(Collections.singletonList(getMalformedDirectAction()));
       } else {
@@ -1629,7 +1630,7 @@ public class ShadowActivityTest {
       TestActivity testActivity = controller.setup().get();
       Consumer<List<DirectAction>> testConsumer =
           (directActions) -> {
-            assertThat(directActions.size()).isEqualTo(1);
+            assertThat(directActions).hasSize(1);
             DirectAction action = directActions.get(0);
             assertThat(action.getId()).isEqualTo(testActivity.getDirectActionForTesting().getId());
             ComponentName componentName = action.getExtras().getParcelable("componentName");
@@ -1649,9 +1650,9 @@ public class ShadowActivityTest {
       testActivity.setReturnMalformedDirectAction(true);
       assertThrows(
           NullPointerException.class,
-          () -> {
-            shadowOf(testActivity).callOnGetDirectActions(new CancellationSignal(), (unused) -> {});
-          });
+          () ->
+              shadowOf(testActivity)
+                  .callOnGetDirectActions(new CancellationSignal(), (unused) -> {}));
     }
   }
 
@@ -1862,37 +1863,37 @@ public class ShadowActivityTest {
     }
 
     @Override
-    public void onActivityCreated(Activity activity, Bundle bundle) {
+    public void onActivityCreated(@Nonnull Activity activity, Bundle bundle) {
       transcript.add("onActivityCreated");
     }
 
     @Override
-    public void onActivityStarted(Activity activity) {
+    public void onActivityStarted(@Nonnull Activity activity) {
       transcript.add("onActivityStarted");
     }
 
     @Override
-    public void onActivityResumed(Activity activity) {
+    public void onActivityResumed(@Nonnull Activity activity) {
       transcript.add("onActivityResumed");
     }
 
     @Override
-    public void onActivityPaused(Activity activity) {
+    public void onActivityPaused(@Nonnull Activity activity) {
       transcript.add("onActivityPaused");
     }
 
     @Override
-    public void onActivityStopped(Activity activity) {
+    public void onActivityStopped(@Nonnull Activity activity) {
       transcript.add("onActivityStopped");
     }
 
     @Override
-    public void onActivitySaveInstanceState(Activity activity, Bundle bundle) {
+    public void onActivitySaveInstanceState(@Nonnull Activity activity, @Nonnull Bundle bundle) {
       transcript.add("onActivitySaveInstanceState");
     }
 
     @Override
-    public void onActivityDestroyed(Activity activity) {
+    public void onActivityDestroyed(@Nonnull Activity activity) {
       transcript.add("onActivityDestroyed");
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientContextManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientContextManagerTest.java
index 9a8e280f6..080981efb 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientContextManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientContextManagerTest.java
@@ -43,7 +43,7 @@ public class ShadowAmbientContextManagerTest {
   }
 
   @Test
-  public void default_shouldNotStoreAnyRequest() throws Exception {
+  public void default_shouldNotStoreAnyRequest() {
     assertThat(
             ((ShadowAmbientContextManager)
                     Shadow.extract(context.getSystemService(AmbientContextManager.class)))
@@ -52,7 +52,7 @@ public class ShadowAmbientContextManagerTest {
   }
 
   @Test
-  public void registerObserver_shouldStoreLastRequest() throws Exception {
+  public void registerObserver_shouldStoreLastRequest() {
     AmbientContextManager ambientContextManager =
         context.getSystemService(AmbientContextManager.class);
     AmbientContextEventRequest request =
@@ -79,7 +79,7 @@ public class ShadowAmbientContextManagerTest {
   }
 
   @Test
-  public void registerObserver_thenUnregister_shouldClearLastRequest() throws Exception {
+  public void registerObserver_thenUnregister_shouldClearLastRequest() {
     AmbientContextManager ambientContextManager =
         context.getSystemService(AmbientContextManager.class);
     AmbientContextEventRequest request =
@@ -165,8 +165,7 @@ public class ShadowAmbientContextManagerTest {
 
   @Test
   public void
-      getLastRequestedEventCodesForConsentActivity_consentActivityNeverStarted_shouldReturnNull()
-          throws Exception {
+      getLastRequestedEventCodesForConsentActivity_consentActivityNeverStarted_shouldReturnNull() {
     Set<Integer> lastRequestedEventCodes =
         ((ShadowAmbientContextManager)
                 Shadow.extract(context.getSystemService(AmbientContextManager.class)))
@@ -177,8 +176,7 @@ public class ShadowAmbientContextManagerTest {
 
   @Test
   public void
-      getLastRequestedEventCodesForConsentActivity_consentActivityStarted_shouldReturnRequestedEventCodes()
-          throws Exception {
+      getLastRequestedEventCodesForConsentActivity_consentActivityStarted_shouldReturnRequestedEventCodes() {
     AmbientContextManager ambientContextManager =
         context.getSystemService(AmbientContextManager.class);
     ImmutableSet<Integer> requestedEventCodes =
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientDisplayConfigurationTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientDisplayConfigurationTest.java
index 20632d2d7..4ccaaeac0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientDisplayConfigurationTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientDisplayConfigurationTest.java
@@ -29,7 +29,7 @@ public final class ShadowAmbientDisplayConfigurationTest {
   }
 
   @Test
-  public void ambientDisplayComponent_shouldReturnNullByDefault() throws Exception {
+  public void ambientDisplayComponent_shouldReturnNullByDefault() {
     String component =
         ReflectionHelpers.callInstanceMethod(
             instanceAmbientDisplayConfiguration, "ambientDisplayComponent");
@@ -37,8 +37,7 @@ public final class ShadowAmbientDisplayConfigurationTest {
   }
 
   @Test
-  public void ambientDisplayComponent_whenValidDozeComponentIsSet_shouldReturnDozeComponent()
-      throws Exception {
+  public void ambientDisplayComponent_whenValidDozeComponentIsSet_shouldReturnDozeComponent() {
     ShadowAmbientDisplayConfiguration.setDozeComponent(
         "com.google.android.aod/.TestDozeAlwaysOnDisplay");
 
@@ -49,8 +48,7 @@ public final class ShadowAmbientDisplayConfigurationTest {
   }
 
   @Test
-  public void ambientDisplayAvailable_whenValidDozeComponentIsSet_shouldReturnTrue()
-      throws Exception {
+  public void ambientDisplayAvailable_whenValidDozeComponentIsSet_shouldReturnTrue() {
     ShadowAmbientDisplayConfiguration.setDozeComponent(
         "com.google.android.aod/.TestDozeAlwaysOnDisplay");
 
@@ -62,8 +60,7 @@ public final class ShadowAmbientDisplayConfigurationTest {
   }
 
   @Test
-  public void ambientDisplayAvailable_whenInvalidDozeComponentIsSet_shouldReturnFalse()
-      throws Exception {
+  public void ambientDisplayAvailable_whenInvalidDozeComponentIsSet_shouldReturnFalse() {
     ShadowAmbientDisplayConfiguration.setDozeComponent("");
 
     assertThat(
@@ -75,8 +72,7 @@ public final class ShadowAmbientDisplayConfigurationTest {
 
   @Test
   public void
-      alwaysOnDisplayAvailable_whenOverrideDozeAlwaysOnDisplayAvailableStateToTrue_shouldReturnTrue()
-          throws Exception {
+      alwaysOnDisplayAvailable_whenOverrideDozeAlwaysOnDisplayAvailableStateToTrue_shouldReturnTrue() {
     ShadowAmbientDisplayConfiguration.setDozeAlwaysOnDisplayAvailable(
         /* dozeAlwaysOnDisplayAvailable= */ true);
 
@@ -89,8 +85,7 @@ public final class ShadowAmbientDisplayConfigurationTest {
 
   @Test
   public void
-      alwaysOnDisplayAvailable_whenOverrideDozeAlwaysOnDisplayAvailableStateToFalse_shouldReturnFalse()
-          throws Exception {
+      alwaysOnDisplayAvailable_whenOverrideDozeAlwaysOnDisplayAvailableStateToFalse_shouldReturnFalse() {
     ShadowAmbientDisplayConfiguration.setDozeAlwaysOnDisplayAvailable(
         /* dozeAlwaysOnDisplayAvailable= */ false);
 
@@ -103,8 +98,7 @@ public final class ShadowAmbientDisplayConfigurationTest {
 
   @Test
   public void
-      alwaysOnDisplayDebuggingEnabled_whenBothDebuggableAndAodSystemPropertyAreSet_shouldReturnTrue()
-          throws Exception {
+      alwaysOnDisplayDebuggingEnabled_whenBothDebuggableAndAodSystemPropertyAreSet_shouldReturnTrue() {
     ShadowSystemProperties.override("ro.debuggable", "1");
     ShadowSystemProperties.override("debug.doze.aod", "true");
 
@@ -117,8 +111,7 @@ public final class ShadowAmbientDisplayConfigurationTest {
 
   @Test
   public void
-      alwaysOnDisplayDebuggingEnabled_whenOnlyDebuggableSystemPropertyIsSet_shouldReturnFalse()
-          throws Exception {
+      alwaysOnDisplayDebuggingEnabled_whenOnlyDebuggableSystemPropertyIsSet_shouldReturnFalse() {
     ShadowSystemProperties.override("ro.debuggable", "1");
 
     assertThat(
@@ -129,8 +122,7 @@ public final class ShadowAmbientDisplayConfigurationTest {
   }
 
   @Test
-  public void alwaysOnDisplayDebuggingEnabled_whenOnlyAodSystemPropertyIsSet_shouldReturnFalse()
-      throws Exception {
+  public void alwaysOnDisplayDebuggingEnabled_whenOnlyAodSystemPropertyIsSet_shouldReturnFalse() {
     ShadowSystemProperties.override("debug.doze.aod", "true");
 
     assertThat(
@@ -142,8 +134,7 @@ public final class ShadowAmbientDisplayConfigurationTest {
 
   @Test
   public void
-      alwaysOnAvailable_whenValidSystemPropertiesAndValidDozeComponentAreSet_shouldReturnTrue()
-          throws Exception {
+      alwaysOnAvailable_whenValidSystemPropertiesAndValidDozeComponentAreSet_shouldReturnTrue() {
     ShadowSystemProperties.override("ro.debuggable", "1");
     ShadowSystemProperties.override("debug.doze.aod", "true");
 
@@ -161,8 +152,7 @@ public final class ShadowAmbientDisplayConfigurationTest {
 
   @Test
   public void
-      alwaysOnAvailable_whenOverrideDozeAlwaysOnDisplayAvailableStateAndValidDozeComponentAreSet_shouldReturnTrue()
-          throws Exception {
+      alwaysOnAvailable_whenOverrideDozeAlwaysOnDisplayAvailableStateAndValidDozeComponentAreSet_shouldReturnTrue() {
     ShadowSystemProperties.override("ro.debuggable", "0");
     ShadowSystemProperties.override("debug.doze.aod", "false");
 
@@ -179,7 +169,7 @@ public final class ShadowAmbientDisplayConfigurationTest {
   }
 
   @Test
-  public void alwaysOnAvailable_whenInvalidDozeComponentIsSet_shouldReturnFalse() throws Exception {
+  public void alwaysOnAvailable_whenInvalidDozeComponentIsSet_shouldReturnFalse() {
     ShadowSystemProperties.override("ro.debuggable", "1");
     ShadowSystemProperties.override("debug.doze.aod", "true");
 
@@ -196,8 +186,7 @@ public final class ShadowAmbientDisplayConfigurationTest {
 
   @Test
   public void
-      alwaysOnAvailable_whenInvalidSystemPropertiesAreSetAndOverrideDozeAlwaysOnDisplayAvailableStateToFalse_shouldReturnFalse()
-          throws Exception {
+      alwaysOnAvailable_whenInvalidSystemPropertiesAreSetAndOverrideDozeAlwaysOnDisplayAvailableStateToFalse_shouldReturnFalse() {
     ShadowSystemProperties.override("ro.debuggable", "0");
     ShadowSystemProperties.override("debug.doze.aod", "false");
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java
index 78212cd1e..c16d61c43 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java
@@ -137,7 +137,7 @@ public class ShadowAppOpsManagerTest {
 
   @Test
   @Config(sdk = VERSION_CODES.Q)
-  public void noModeSet_q_noteProxyOpNoThrow_withproxiedUid_shouldReturnModeAllowed() {
+  public void noModeSet_q_noteProxyOpNoThrow_withProxiedUid_shouldReturnModeAllowed() {
     int result = appOps.noteProxyOpNoThrow(OPSTR_GPS, PACKAGE_NAME1, Binder.getCallingUid());
     assertThat(result).isEqualTo(MODE_ALLOWED);
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java
index 4a8f7e07f..3849ccd83 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java
@@ -24,6 +24,7 @@ import android.appwidget.AppWidgetProviderInfo;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.Context;
+import android.content.ContextWrapper;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.res.Resources.NotFoundException;
@@ -60,6 +61,14 @@ public class ShadowAppWidgetManagerTest {
     shadowAppWidgetManager = shadowOf(appWidgetManager);
   }
 
+  @Test
+  public void getInstance_shouldReturnSameInstance() {
+    assertNotNull(appWidgetManager);
+    assertSame(appWidgetManager, AppWidgetManager.getInstance(context));
+    assertSame(appWidgetManager, AppWidgetManager.getInstance(new ContextWrapper(context)));
+    assertSame(appWidgetManager, context.getSystemService(Context.APPWIDGET_SERVICE));
+  }
+
   @Test
   public void createWidget_shouldInflateViewAndAssignId() {
     int widgetId =
@@ -332,7 +341,7 @@ public class ShadowAppWidgetManagerTest {
   }
 
   @Test
-  public void updateAppWidget_landscapeAndPortrait_doesntReapplyDifferntViews() {
+  public void updateAppWidget_landscapeAndPortrait_doesntReapplyDifferentViews() {
     ComponentName provider = new ComponentName(context, SpanishTestAppWidgetProvider.class);
     appWidgetManager.bindAppWidgetIdIfAllowed(789, provider);
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java
index 359cbad6c..3c54332c0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java
@@ -9,14 +9,17 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.annotation.LooperMode.Mode.LEGACY;
 import static org.robolectric.shadows.ShadowLooper.shadowMainLooper;
 
+import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.app.Application;
+import android.app.DownloadManager;
 import android.content.ActivityNotFoundException;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
@@ -50,6 +53,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
@@ -57,12 +61,15 @@ import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.LooperMode;
+import org.robolectric.junit.rules.SetSystemPropertyRule;
 import org.robolectric.shadows.testing.TestActivity;
 import org.robolectric.util.Scheduler;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowApplicationTest {
 
+  @Rule public SetSystemPropertyRule setSystemPropertyRule = new SetSystemPropertyRule();
+
   private Application context;
 
   @Before
@@ -71,7 +78,7 @@ public class ShadowApplicationTest {
   }
 
   @Test
-  public void shouldBeAContext() throws Exception {
+  public void shouldBeAContext() {
     assertThat(Robolectric.setupActivity(Activity.class).getApplication())
         .isSameInstanceAs(ApplicationProvider.getApplicationContext());
     assertThat(Robolectric.setupActivity(Activity.class).getApplication().getApplicationContext())
@@ -79,7 +86,7 @@ public class ShadowApplicationTest {
   }
 
   @Test
-  public void shouldProvideServices() throws Exception {
+  public void shouldProvideServices() {
     assertThat(context.getSystemService(Context.ACTIVITY_SERVICE))
         .isInstanceOf(android.app.ActivityManager.class);
     assertThat(context.getSystemService(Context.POWER_SERVICE))
@@ -125,7 +132,7 @@ public class ShadowApplicationTest {
   }
 
   @Test
-  public void shouldProvideServicesAvailableInAllSdKs() throws Exception {
+  public void shouldProvideServicesAvailableInAllSdKs() {
     assertThat(context.getSystemService(Context.DISPLAY_SERVICE))
         .isInstanceOf(android.hardware.display.DisplayManager.class);
     assertThat(context.getSystemService(Context.USER_SERVICE)).isInstanceOf(UserManager.class);
@@ -142,21 +149,21 @@ public class ShadowApplicationTest {
 
   @Test
   @Config(minSdk = LOLLIPOP_MR1)
-  public void shouldProvideServicesIntroducedInLollipopMr1() throws Exception {
+  public void shouldProvideServicesIntroducedInLollipopMr1() {
     assertThat(context.getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE))
         .isInstanceOf(SubscriptionManager.class);
   }
 
   @Test
   @Config(minSdk = M)
-  public void shouldProvideServicesIntroducedMarshmallow() throws Exception {
+  public void shouldProvideServicesIntroducedMarshmallow() {
     assertThat(context.getSystemService(Context.FINGERPRINT_SERVICE))
         .isInstanceOf(FingerprintManager.class);
   }
 
   @Test
   @Config(minSdk = O)
-  public void shouldProvideServicesIntroducedOreo() throws Exception {
+  public void shouldProvideServicesIntroducedOreo() {
     // Context.AUTOFILL_MANAGER_SERVICE is marked @hide and this is the documented way to obtain
     // this service.
     AutofillManager autofillManager = context.getSystemService(AutofillManager.class);
@@ -167,13 +174,13 @@ public class ShadowApplicationTest {
   }
 
   @Test
-  public void shouldProvideLayoutInflater() throws Exception {
+  public void shouldProvideLayoutInflater() {
     Object systemService = context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
     assertThat(systemService).isInstanceOf(LayoutInflater.class);
   }
 
   @Test
-  public void shouldCorrectlyInstantiatedAccessibilityService() throws Exception {
+  public void shouldCorrectlyInstantiatedAccessibilityService() {
     AccessibilityManager accessibilityManager =
         (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
 
@@ -699,7 +706,7 @@ public class ShadowApplicationTest {
   }
 
   @Test
-  public void canFindAllReceiversForAnIntent() throws Exception {
+  public void canFindAllReceiversForAnIntent() {
     BroadcastReceiver expectedReceiver = new TestBroadcastReceiver();
     assertFalse(shadowOf(context).hasReceiverForIntent(new Intent("Foo")));
     context.registerReceiver(expectedReceiver, new IntentFilter("Foo"));
@@ -723,7 +730,7 @@ public class ShadowApplicationTest {
     Activity activity = Robolectric.setupActivity(Activity.class);
     activity.registerReceiver(new TestBroadcastReceiver(), new IntentFilter("Foo"));
 
-    assertThat(shadowOf(context).getRegisteredReceivers().size()).isAtLeast(1);
+    assertThat(shadowOf(context).getRegisteredReceivers()).isNotEmpty();
 
     shadowOf(context).clearRegisteredReceivers();
 
@@ -770,13 +777,90 @@ public class ShadowApplicationTest {
     assertThat(receiverWithPermission.intent).isEqualTo(broadcastIntent);
   }
 
+  @SuppressLint("UnspecifiedRegisterReceiverFlag")
+  @Test
+  @Config(
+      manifest = "TestAndroidManifestWithTargetSdk34.xml",
+      minSdk = VERSION_CODES.UPSIDE_DOWN_CAKE)
+  public void
+      registerReceiver_withoutAnyExportedFlagsAndTargetSdk34OnAndroidFromU_throwsSecurityException() {
+    setSystemPropertyRule.set("robolectric.validateReceiverExportFlags", "true");
+
+    IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
+
+    assertThrows(
+        SecurityException.class,
+        () -> context.registerReceiver(new TestBroadcastReceiver(), filter));
+  }
+
+  @Test
+  @Config(
+      manifest = "TestAndroidManifestWithTargetSdk34.xml",
+      minSdk = VERSION_CODES.UPSIDE_DOWN_CAKE)
+  public void registerReceiver_withReceiverExportedFlagAndTargetSdk34OnAndroidFromU_succeed() {
+    setSystemPropertyRule.set("robolectric.validateReceiverExportFlags", "true");
+    IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
+    context.registerReceiver(new TestBroadcastReceiver(), filter, Context.RECEIVER_EXPORTED);
+  }
+
+  @Test
+  @Config(
+      manifest = "TestAndroidManifestWithTargetSdk34.xml",
+      minSdk = VERSION_CODES.UPSIDE_DOWN_CAKE)
+  public void registerReceiver_withReceiverNotExportedFlagAndTargetSdk34OnAndroidFromU_succeed() {
+    setSystemPropertyRule.set("robolectric.validateReceiverExportFlags", "true");
+    IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
+    context.registerReceiver(new TestBroadcastReceiver(), filter, Context.RECEIVER_NOT_EXPORTED);
+  }
+
+  @Test
+  @Config(manifest = "TestAndroidManifest.xml", minSdk = VERSION_CODES.UPSIDE_DOWN_CAKE)
+  public void
+      registerReceiver_withoutAnyExportedFlagsAndTargetSdk23OnAndroidFromU_notThrowsSecurityException() {
+    setSystemPropertyRule.set("robolectric.validateReceiverExportFlags", "true");
+    IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
+    context.registerReceiver(new TestBroadcastReceiver(), filter);
+  }
+
+  @Test
+  @Config(
+      manifest = "TestAndroidManifestWithTargetSdk34.xml",
+      minSdk = VERSION_CODES.UPSIDE_DOWN_CAKE)
+  public void
+      registerReceiver_withBothExportedFlagsAndTargetSdk34OnAndroidFromU_throwsIllegalArgumentException() {
+    setSystemPropertyRule.set("robolectric.validateReceiverExportFlags", "true");
+    IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
+    assertThrows(
+        IllegalArgumentException.class,
+        () ->
+            context.registerReceiver(
+                new TestBroadcastReceiver(),
+                filter,
+                Context.RECEIVER_EXPORTED | Context.RECEIVER_NOT_EXPORTED));
+  }
+
+  @Test
+  @Config(manifest = "TestAndroidManifest.xml", minSdk = VERSION_CODES.UPSIDE_DOWN_CAKE)
+  public void
+      registerReceiver_withBothExportedFlagsAndTargetSdk23OnAndroidFromU_throwsIllegalArgumentException() {
+    setSystemPropertyRule.set("robolectric.validateReceiverExportFlags", "true");
+    IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
+    assertThrows(
+        IllegalArgumentException.class,
+        () ->
+            context.registerReceiver(
+                new TestBroadcastReceiver(),
+                filter,
+                Context.RECEIVER_EXPORTED | Context.RECEIVER_NOT_EXPORTED));
+  }
+
   @Test
-  public void shouldRememberResourcesAfterLazilyLoading() throws Exception {
+  public void shouldRememberResourcesAfterLazilyLoading() {
     assertSame(context.getResources(), context.getResources());
   }
 
   @Test
-  public void startActivity_whenActivityCheckingEnabled_doesntFindResolveInfo() throws Exception {
+  public void startActivity_whenActivityCheckingEnabled_doesntFindResolveInfo() {
     shadowOf(context).checkActivities(true);
 
     String action = "com.does.not.exist.android.app.v2.mobile";
@@ -791,7 +875,7 @@ public class ShadowApplicationTest {
   }
 
   @Test
-  public void startActivity_whenActivityCheckingEnabled_findsResolveInfo() throws Exception {
+  public void startActivity_whenActivityCheckingEnabled_findsResolveInfo() {
     shadowOf(context).checkActivities(true);
 
     context.startActivity(
@@ -806,7 +890,7 @@ public class ShadowApplicationTest {
   public void bindServiceShouldAddServiceConnectionToListOfBoundServiceConnections() {
     final ServiceConnection expectedServiceConnection = new EmptyServiceConnection();
 
-    assertThat(Shadows.shadowOf(context).getBoundServiceConnections()).hasSize(0);
+    assertThat(Shadows.shadowOf(context).getBoundServiceConnections()).isEmpty();
     assertThat(
             context.bindService(
                 new Intent("connect").setPackage("dummy.package"), expectedServiceConnection, 0))
@@ -823,7 +907,7 @@ public class ShadowApplicationTest {
     final String unboundableAction = "refuse";
     final Intent serviceIntent = new Intent(unboundableAction).setPackage("dummy.package");
     Shadows.shadowOf(context).declareActionUnbindable(unboundableAction);
-    assertThat(Shadows.shadowOf(context).getBoundServiceConnections()).hasSize(0);
+    assertThat(Shadows.shadowOf(context).getBoundServiceConnections()).isEmpty();
     assertThat(context.bindService(serviceIntent, expectedServiceConnection, 0)).isFalse();
     assertThat(Shadows.shadowOf(context).getBoundServiceConnections()).hasSize(1);
     assertThat(Shadows.shadowOf(context).getBoundServiceConnections().get(0))
@@ -839,9 +923,9 @@ public class ShadowApplicationTest {
                 new Intent("connect").setPackage("dummy.package"), expectedServiceConnection, 0))
         .isTrue();
     assertThat(Shadows.shadowOf(context).getBoundServiceConnections()).hasSize(1);
-    assertThat(Shadows.shadowOf(context).getUnboundServiceConnections()).hasSize(0);
+    assertThat(Shadows.shadowOf(context).getUnboundServiceConnections()).isEmpty();
     context.unbindService(expectedServiceConnection);
-    assertThat(Shadows.shadowOf(context).getBoundServiceConnections()).hasSize(0);
+    assertThat(Shadows.shadowOf(context).getBoundServiceConnections()).isEmpty();
     assertThat(Shadows.shadowOf(context).getUnboundServiceConnections()).hasSize(1);
     assertThat(Shadows.shadowOf(context).getUnboundServiceConnections().get(0))
         .isSameInstanceAs(expectedServiceConnection);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowArrayAdapterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowArrayAdapterTest.java
index f2c0feff9..72c8d3dbe 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowArrayAdapterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowArrayAdapterTest.java
@@ -88,6 +88,20 @@ public class ShadowArrayAdapterTest {
     assertThat(Shadows.shadowOf(arrayAdapter3).getTextViewResourceId()).isEqualTo(0);
   }
 
+  @Test
+  public void setDropDownViewResource() {
+    ArrayAdapter<String> arrayAdapter = new ArrayAdapter<>(context, R.layout.main);
+    ShadowArrayAdapter<String> shadow = Shadows.shadowOf(arrayAdapter);
+
+    assertThat(shadow.getResourceId()).isEqualTo(R.layout.main);
+    assertThat(shadow.getDropDownViewResourceId()).isEqualTo(R.layout.main);
+
+    arrayAdapter.setDropDownViewResource(R.layout.activity_list_item);
+
+    assertThat(shadow.getResourceId()).isEqualTo(R.layout.main);
+    assertThat(shadow.getDropDownViewResourceId()).isEqualTo(R.layout.activity_list_item);
+  }
+
   @Test
   public void shouldClear() {
     arrayAdapter.clear();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAssetManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAssetManagerTest.java
index b00adbf0e..88f8bcf94 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAssetManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAssetManagerTest.java
@@ -1,6 +1,7 @@
 package org.robolectric.shadows;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.fail;
 
 import android.content.res.AssetManager;
@@ -14,9 +15,7 @@ import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import org.junit.Before;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.robolectric.R;
 import org.robolectric.Robolectric;
@@ -27,8 +26,6 @@ import org.robolectric.annotation.ResourcesMode.Mode;
 @ResourcesMode(Mode.BINARY)
 public class ShadowAssetManagerTest {
 
-  @Rule public ExpectedException expectedException = ExpectedException.none();
-
   private AssetManager assetManager;
   private Resources resources;
 
@@ -39,12 +36,12 @@ public class ShadowAssetManagerTest {
   }
 
   @Test
-  public void openFd_shouldProvideFileDescriptorForDeflatedAsset() throws Exception {
-    expectedException.expect(FileNotFoundException.class);
-    expectedException.expectMessage(
-        "This file can not be opened as a file descriptor; it is probably compressed");
-
-    assetManager.openFd("deflatedAsset.xml");
+  public void openFd_shouldProvideFileDescriptorForDeflatedAsset() {
+    FileNotFoundException exception =
+        assertThrows(FileNotFoundException.class, () -> assetManager.openFd("deflatedAsset.xml"));
+    assertThat(exception)
+        .hasMessageThat()
+        .isEqualTo("This file can not be opened as a file descriptor; it is probably compressed");
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioEffectTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioEffectTest.java
index 7c53a7377..69da57f4c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioEffectTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioEffectTest.java
@@ -42,9 +42,10 @@ public class ShadowAudioEffectTest {
   public void getAudioEffects_newAudioEffect_returnsAudioEffect() {
     int priority = 100;
     int audioSession = 500;
-    new AudioEffect(
-        AudioEffect.EFFECT_TYPE_AEC, /* uuid= */ EFFECT_TYPE_NULL, priority, audioSession);
-
+    assertThat(
+            new AudioEffect(
+                AudioEffect.EFFECT_TYPE_AEC, /* uuid= */ EFFECT_TYPE_NULL, priority, audioSession))
+        .isNotNull();
     ImmutableList<AudioEffect> actualEffects = ShadowAudioEffect.getAudioEffects();
 
     assertThat(actualEffects).hasSize(1);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java
index d59095ce0..4545c29f5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java
@@ -101,12 +101,12 @@ public class ShadowAudioManagerTest {
   public void requestAudioFocus2_shouldRecordArgumentsOfMostRecentCall() {
     assertThat(shadowOf(audioManager).getLastAudioFocusRequest()).isNull();
 
-    AudioAttributes atts =
+    AudioAttributes attrs =
         new AudioAttributes.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
     android.media.AudioFocusRequest request =
         new android.media.AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)
             .setOnAudioFocusChangeListener(listener)
-            .setAudioAttributes(atts)
+            .setAudioAttributes(attrs)
             .build();
 
     audioManager.requestAudioFocus(request);
@@ -1642,7 +1642,7 @@ public class ShadowAudioManagerTest {
   @Test
   @Config(minSdk = S)
   public void
-      onCommunicationDeviceChangedListener_oneOfSeveralListenerRemoved_onlyRegisterdGetCalls()
+      onCommunicationDeviceChangedListener_oneOfSeveralListenerRemoved_onlyRegisteredGetCalls()
           throws Exception {
     AudioManager.OnCommunicationDeviceChangedListener mockListener1 =
         mock(AudioManager.OnCommunicationDeviceChangedListener.class);
@@ -1661,8 +1661,7 @@ public class ShadowAudioManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void onCommunicationDeviceChangedListener_callWithNullAudioDeviceInfo_receiveNull()
-      throws Exception {
+  public void onCommunicationDeviceChangedListener_callWithNullAudioDeviceInfo_receiveNull() {
     AudioManager.OnCommunicationDeviceChangedListener mockListener =
         mock(AudioManager.OnCommunicationDeviceChangedListener.class);
 
@@ -1674,8 +1673,7 @@ public class ShadowAudioManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void onCommunicationDeviceChangedListener_removeBeforeAddingListener_throwsException()
-      throws Exception {
+  public void onCommunicationDeviceChangedListener_removeBeforeAddingListener_throwsException() {
     AudioManager.OnCommunicationDeviceChangedListener mockListener =
         mock(AudioManager.OnCommunicationDeviceChangedListener.class);
 
@@ -1686,7 +1684,7 @@ public class ShadowAudioManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void onCommunicationDeviceChangedListener_addSameTwice_throwsException() throws Exception {
+  public void onCommunicationDeviceChangedListener_addSameTwice_throwsException() {
     AudioManager.OnCommunicationDeviceChangedListener mockListener =
         mock(AudioManager.OnCommunicationDeviceChangedListener.class);
 
@@ -1698,8 +1696,7 @@ public class ShadowAudioManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void onCommunicationDeviceChangedListener_addNullListener_throwsException()
-      throws Exception {
+  public void onCommunicationDeviceChangedListener_addNullListener_throwsException() {
     Assert.assertThrows(
         NullPointerException.class,
         () -> audioManager.addOnCommunicationDeviceChangedListener(directExecutor(), null));
@@ -1707,8 +1704,7 @@ public class ShadowAudioManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void onCommunicationDeviceChangedListener_addNullExecutor_throwsException()
-      throws Exception {
+  public void onCommunicationDeviceChangedListener_addNullExecutor_throwsException() {
     AudioManager.OnCommunicationDeviceChangedListener mockListener =
         mock(AudioManager.OnCommunicationDeviceChangedListener.class);
 
@@ -1719,7 +1715,7 @@ public class ShadowAudioManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void onCommunicationDeviceChangedListener_removeNull_throwsException() throws Exception {
+  public void onCommunicationDeviceChangedListener_removeNull_throwsException() {
     Assert.assertThrows(
         NullPointerException.class,
         () -> audioManager.removeOnCommunicationDeviceChangedListener(null));
@@ -1740,7 +1736,7 @@ public class ShadowAudioManagerTest {
   }
 
   private static class LocalOnModeChangedListener implements OnModeChangedListener {
-    private List<Integer> modes = new ArrayList<>();
+    private final List<Integer> modes = new ArrayList<>();
 
     @Override
     public void onModeChanged(int mode) {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioTrackTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioTrackTest.java
index 04bba7e42..e7d5e763c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioTrackTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioTrackTest.java
@@ -4,7 +4,6 @@ import static android.media.AudioAttributes.USAGE_MEDIA;
 import static android.media.AudioTrack.ERROR_BAD_VALUE;
 import static android.media.AudioTrack.WRITE_BLOCKING;
 import static android.media.AudioTrack.WRITE_NON_BLOCKING;
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.Q;
@@ -682,8 +681,8 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
   }
 
   @Test
-  @Config(minSdk = LOLLIPOP)
-  public void getLatency_withoutSetLatencyMs_returnsZero() throws Exception {
+  @Config
+  public void getLatency_withoutSetLatencyMs_returnsZero() {
     AudioTrack audioTrack = getSampleAudioTrack();
 
     assertThat((Integer) ReflectionHelpers.callInstanceMethod(audioTrack, "getLatency"))
@@ -691,8 +690,8 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
   }
 
   @Test
-  @Config(minSdk = LOLLIPOP)
-  public void getLatency_afterSetLatencyMs_returnsSetLatency() throws Exception {
+  @Config
+  public void getLatency_afterSetLatencyMs_returnsSetLatency() {
     AudioTrack audioTrack = getSampleAudioTrack();
     shadowOf(audioTrack).setLatency(200);
 
@@ -702,7 +701,7 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
 
   @Test
   @Config(minSdk = M)
-  public void getBufferSizeInFrames_withPcm_returnsBufferSizeInFrames() throws Exception {
+  public void getBufferSizeInFrames_withPcm_returnsBufferSizeInFrames() {
     AudioTrack audioTrack = getSampleAudioTrack();
 
     assertThat(audioTrack.getBufferSizeInFrames()).isEqualTo(1);
@@ -710,8 +709,7 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
 
   @Test
   @Config(minSdk = Q, maxSdk = R)
-  public void getBufferSizeInFrames_withOffloadUntilApi30_returnsBufferSizeInBytes()
-      throws Exception {
+  public void getBufferSizeInFrames_withOffloadUntilApi30_returnsBufferSizeInBytes() {
     AudioFormat audioFormat =
         new AudioFormat.Builder()
             .setEncoding(AudioFormat.ENCODING_AC3)
@@ -734,7 +732,7 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
 
   @Test
   @Config(sdk = S)
-  public void getBufferSizeInFrames_withOffloadApi31_returnsBufferSizeInBytes() throws Exception {
+  public void getBufferSizeInFrames_withOffloadApi31_returnsBufferSizeInBytes() {
     ShadowAudioTrack.addAllowedNonPcmEncoding(AudioFormat.ENCODING_AC3);
     AudioFormat audioFormat =
         new AudioFormat.Builder()
@@ -759,8 +757,7 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
 
   @Test
   @Config(minSdk = TIRAMISU)
-  public void getBufferSizeInFrames_withOffloadPostApi31_returnsBufferSizeInBytes()
-      throws Exception {
+  public void getBufferSizeInFrames_withOffloadPostApi31_returnsBufferSizeInBytes() {
     ShadowAudioTrack.addAllowedNonPcmEncoding(AudioFormat.ENCODING_AC3);
     AudioFormat audioFormat =
         new AudioFormat.Builder()
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAutoCompleteTextViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAutoCompleteTextViewTest.java
index 898caf604..e4c6bf471 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAutoCompleteTextViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAutoCompleteTextViewTest.java
@@ -13,6 +13,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import javax.annotation.Nonnull;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -37,6 +38,7 @@ public class ShadowAutoCompleteTextViewTest {
       super(context, android.R.layout.simple_list_item_1);
     }
 
+    @Nonnull
     @Override
     public Filter getFilter() {
       return new AutoCompleteFilter();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBackupManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBackupManagerTest.java
index 5335f9cd2..cb0cf6a4e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBackupManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBackupManagerTest.java
@@ -1,6 +1,7 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.M;
+import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
@@ -13,6 +14,7 @@ import android.app.backup.BackupTransport;
 import android.app.backup.RestoreObserver;
 import android.app.backup.RestoreSession;
 import android.app.backup.RestoreSet;
+import android.os.UserHandle;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.collect.ImmutableList;
@@ -93,6 +95,13 @@ public class ShadowBackupManagerTest {
     assertThrows(SecurityException.class, () -> backupManager.isBackupEnabled());
   }
 
+  @Test
+  @Config(minSdk = P)
+  public void setBackupS_setToFalse_shouldDisableBackup() {
+    shadowOf(backupManager).setBackupServiceActive(UserHandle.of(0), false);
+    assertThat(backupManager.isBackupServiceActive(UserHandle.of(0))).isFalse();
+  }
+
   @Test
   public void getAvailableRestoreSets_shouldCallbackToRestoreSetsAvailable() {
     RestoreSession restoreSession = backupManager.beginRestoreSession();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBinderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBinderTest.java
index 8ff9dc789..1034b927a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBinderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBinderTest.java
@@ -15,6 +15,7 @@ import android.os.UserHandle;
 import android.os.UserManager;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -47,7 +48,7 @@ public class ShadowBinderTest {
   }
 
   @Test
-  public void testLinkToDeath() throws Exception {
+  public void testLinkToDeath() {
     Binder binder = new Binder();
     DeathRecipient recipient = () -> {};
     binder.linkToDeath(recipient, 0);
@@ -55,7 +56,7 @@ public class ShadowBinderTest {
   }
 
   @Test
-  public void testLinkToDeath_unlink() throws Exception {
+  public void testLinkToDeath_unlink() {
     Binder binder = new Binder();
     DeathRecipient recipient = () -> {};
     // recipient doesn't exist, returns false.
@@ -68,7 +69,7 @@ public class ShadowBinderTest {
   }
 
   @Test
-  public void testLinkToDeath_twice() throws Exception {
+  public void testLinkToDeath_twice() {
     Binder binder = new Binder();
     DeathRecipient recipient = () -> {};
     binder.linkToDeath(recipient, 0);
@@ -80,8 +81,9 @@ public class ShadowBinderTest {
   }
 
   @Test
-  public void testLinkToDeath_weakReference() throws Exception {
+  public void testLinkToDeath_weakReference() {
     Binder binder = new Binder();
+    //noinspection Convert2Lambda
     binder.linkToDeath(
         new DeathRecipient() {
           @Override
@@ -128,7 +130,7 @@ public class ShadowBinderTest {
   static class TestThrowingBinder extends Binder {
 
     @Override
-    protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) {
+    protected boolean onTransact(int code, @Nonnull Parcel data, Parcel reply, int flags) {
       throw new SecurityException("Halt! Who goes there?");
     }
   }
@@ -174,7 +176,7 @@ public class ShadowBinderTest {
   public void testGetCallingUidOrThrowWithValueNotSet() {
     ShadowBinder.reset();
     IllegalStateException ex =
-        assertThrows(IllegalStateException.class, () -> Binder.getCallingUidOrThrow());
+        assertThrows(IllegalStateException.class, Binder::getCallingUidOrThrow);
 
     // Typo in "transaction" is intentional to match platform
     assertThat(ex).hasMessageThat().isEqualTo("Thread is not in a binder transcation");
@@ -200,7 +202,7 @@ public class ShadowBinderTest {
     ShadowBinder.setCallingUid(123);
     ShadowBinder.reset();
 
-    assertThrows(IllegalStateException.class, () -> Binder.getCallingUidOrThrow());
+    assertThrows(IllegalStateException.class, Binder::getCallingUidOrThrow);
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBiometricManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBiometricManagerTest.java
index aa121e1f1..04144eed3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBiometricManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBiometricManagerTest.java
@@ -83,7 +83,7 @@ public class ShadowBiometricManagerTest {
   @Test
   @Config(minSdk = R)
   public void
-      testCanAuthenticateBiometricWeak_serviceConnected_noWeakButHaveStrongEntrolled_canAuthenticate() {
+      testCanAuthenticateBiometricWeak_serviceConnected_noWeakButHaveStrongEnrolled_canAuthenticate() {
     ShadowBiometricManager shadowBiometricManager = Shadow.extract(biometricManager);
     shadowBiometricManager.setCanAuthenticate(true);
     shadowBiometricManager.setAuthenticatorType(BiometricManager.Authenticators.BIOMETRIC_STRONG);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapFactoryTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapFactoryTest.java
index 57c44d959..234dd784c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapFactoryTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapFactoryTest.java
@@ -4,6 +4,7 @@ import static com.google.common.io.Resources.toByteArray;
 import static com.google.common.truth.Truth.assertThat;
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.app.Application;
@@ -134,8 +135,8 @@ public class ShadowBitmapFactoryTest {
   }
 
   @Test
-  public void decodeBytes_shouldSetDescriptionAndCreatedFrom() throws Exception {
-    byte[] yummyBites = "Hi!".getBytes("UTF-8");
+  public void decodeBytes_shouldSetDescriptionAndCreatedFrom() {
+    byte[] yummyBites = "Hi!".getBytes(UTF_8);
     Bitmap bitmap = BitmapFactory.decodeByteArray(yummyBites, 100, 100);
     ShadowBitmap shadowBitmap = shadowOf(bitmap);
     assertEquals("Bitmap for 3 bytes 100..100", shadowBitmap.getDescription());
@@ -145,8 +146,8 @@ public class ShadowBitmapFactoryTest {
   }
 
   @Test
-  public void decodeBytes_shouldSetDescriptionAndCreatedFromWithOptions() throws Exception {
-    byte[] yummyBites = "Hi!".getBytes("UTF-8");
+  public void decodeBytes_shouldSetDescriptionAndCreatedFromWithOptions() {
+    byte[] yummyBites = "Hi!".getBytes(UTF_8);
     BitmapFactory.Options options = new BitmapFactory.Options();
     Bitmap bitmap = BitmapFactory.decodeByteArray(yummyBites, 100, 100, options);
     ShadowBitmap shadowBitmap = shadowOf(bitmap);
@@ -183,7 +184,7 @@ public class ShadowBitmapFactoryTest {
     options.inSampleSize = 100;
     Bitmap bitmap =
         BitmapFactory.decodeResource(context.getResources(), R.drawable.an_image, options);
-    assertEquals(true, shadowOf(bitmap).getDescription().contains("inSampleSize=100"));
+    assertTrue(shadowOf(bitmap).getDescription().contains("inSampleSize=100"));
   }
 
   @Test
@@ -195,7 +196,7 @@ public class ShadowBitmapFactoryTest {
     Bitmap bitmap =
         BitmapFactory.decodeResourceStream(
             context.getResources(), null, inputStream, null, options);
-    assertEquals(true, shadowOf(bitmap).getDescription().contains("inSampleSize=100"));
+    assertTrue(shadowOf(bitmap).getDescription().contains("inSampleSize=100"));
   }
 
   @Test
@@ -528,7 +529,7 @@ public class ShadowBitmapFactoryTest {
     InputStream inputStream = com.google.common.io.Resources.getResource(imagePath).openStream();
     File tempFile = Files.createTempFile("ShadowBitmapFactoryTest", null).toFile();
     tempFile.deleteOnExit();
-    ByteStreams.copy(inputStream, new FileOutputStream(tempFile));
+    ByteStreams.copy(inputStream, Files.newOutputStream(tempFile.toPath()));
     return tempFile;
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapTest.java
index d8c2629dc..3964420c3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapTest.java
@@ -165,7 +165,7 @@ public class ShadowBitmapTest {
     assertThat(shadowBitmap.getCreatedFromWidth()).isEqualTo(100);
     assertThat(shadowBitmap.getCreatedFromHeight()).isEqualTo(50);
     assertThat(shadowBitmap.getCreatedFromMatrix()).isEqualTo(m);
-    assertThat(shadowBitmap.getCreatedFromFilter()).isEqualTo(true);
+    assertThat(shadowBitmap.getCreatedFromFilter()).isTrue();
     assertThat(shadowBitmap.getWidth()).isEqualTo(50);
     assertThat(shadowBitmap.getHeight()).isEqualTo(100);
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothAdapterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothAdapterTest.java
index 286a11323..72dfd2cfd 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothAdapterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothAdapterTest.java
@@ -125,7 +125,7 @@ public class ShadowBluetoothAdapterTest {
   }
 
   @Test
-  public void canGetAndSetAddress() throws Exception {
+  public void canGetAndSetAddress() {
     BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
     shadowOf(adapter).setAddress("expected");
     assertThat(adapter.getAddress()).isEqualTo("expected");
@@ -163,7 +163,7 @@ public class ShadowBluetoothAdapterTest {
   }
 
   @Test
-  public void canGetBluetoothLeAdvertiser() throws Exception {
+  public void canGetBluetoothLeAdvertiser() {
     // bluetooth needs to be ON in APIS 21 and 22 for getBluetoothLeAdvertiser to return a
     // non null value
     bluetoothAdapter.enable();
@@ -172,7 +172,7 @@ public class ShadowBluetoothAdapterTest {
 
   @Test
   @Config(minSdk = M)
-  public void canGetAndSetBleScanAlwaysAvailable() throws Exception {
+  public void canGetAndSetBleScanAlwaysAvailable() {
     BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
 
     // By default, scanning with BT is not supported.
@@ -184,7 +184,7 @@ public class ShadowBluetoothAdapterTest {
   }
 
   @Test
-  public void canGetAndSetMultipleAdvertisementSupport() throws Exception {
+  public void canGetAndSetMultipleAdvertisementSupport() {
     BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
 
     // By default, multiple advertising is supported.
@@ -196,7 +196,7 @@ public class ShadowBluetoothAdapterTest {
   }
 
   @Test
-  public void canEnable_withAndroidApi() throws Exception {
+  public void canEnable_withAndroidApi() {
     bluetoothAdapter.enable();
     assertThat(bluetoothAdapter.isEnabled()).isTrue();
   }
@@ -219,14 +219,14 @@ public class ShadowBluetoothAdapterTest {
   }
 
   @Test
-  public void canDisable_withAndroidApi() throws Exception {
+  public void canDisable_withAndroidApi() {
     shadowOf(bluetoothAdapter).setEnabled(true);
     bluetoothAdapter.disable();
     assertThat(bluetoothAdapter.isEnabled()).isFalse();
   }
 
   @Test
-  public void name_getAndSet() throws Exception {
+  public void name_getAndSet() {
     // The name shouldn't be null, even before we set anything.
     assertThat(bluetoothAdapter.getName()).isNotNull();
 
@@ -261,7 +261,7 @@ public class ShadowBluetoothAdapterTest {
 
   @Test
   @Config(maxSdk = S_V2)
-  public void scanMode_getAndSet_none() throws Exception {
+  public void scanMode_getAndSet_none() {
     boolean result =
         ReflectionHelpers.callInstanceMethod(
             bluetoothAdapter,
@@ -273,7 +273,7 @@ public class ShadowBluetoothAdapterTest {
 
   @Test
   @Config(maxSdk = S_V2)
-  public void scanMode_getAndSet_invalid() throws Exception {
+  public void scanMode_getAndSet_invalid() {
     boolean result =
         ReflectionHelpers.callInstanceMethod(
             bluetoothAdapter, "setScanMode", ClassParameter.from(int.class, 9999));
@@ -329,7 +329,7 @@ public class ShadowBluetoothAdapterTest {
 
   @Config(minSdk = TIRAMISU)
   @Test
-  public void scanMode_getAndSet_connectable_T() throws Exception {
+  public void scanMode_getAndSet_connectable_T() {
     assertThat(bluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE))
         .isEqualTo(BluetoothStatusCodes.SUCCESS);
     assertThat(bluetoothAdapter.getScanMode()).isEqualTo(BluetoothAdapter.SCAN_MODE_CONNECTABLE);
@@ -337,7 +337,7 @@ public class ShadowBluetoothAdapterTest {
 
   @Config(minSdk = TIRAMISU)
   @Test
-  public void scanMode_getAndSet_discoverable_T() throws Exception {
+  public void scanMode_getAndSet_discoverable_T() {
     assertThat(bluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE))
         .isEqualTo(BluetoothStatusCodes.SUCCESS);
     assertThat(bluetoothAdapter.getScanMode())
@@ -346,7 +346,7 @@ public class ShadowBluetoothAdapterTest {
 
   @Config(minSdk = TIRAMISU)
   @Test
-  public void scanMode_getAndSet_none_T() throws Exception {
+  public void scanMode_getAndSet_none_T() {
     assertThat(bluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_NONE))
         .isEqualTo(BluetoothStatusCodes.SUCCESS);
     assertThat(bluetoothAdapter.getScanMode()).isEqualTo(BluetoothAdapter.SCAN_MODE_NONE);
@@ -354,13 +354,13 @@ public class ShadowBluetoothAdapterTest {
 
   @Config(minSdk = TIRAMISU)
   @Test
-  public void scanMode_getAndSet_invalid_T() throws Exception {
+  public void scanMode_getAndSet_invalid_T() {
     assertThat(bluetoothAdapter.setScanMode(9999)).isEqualTo(BluetoothStatusCodes.ERROR_UNKNOWN);
   }
 
   @Test
   @Config(minSdk = M)
-  public void isLeEnabled() throws Exception {
+  public void isLeEnabled() {
     // Le is enabled when either BT or BLE is enabled. Check all states.
     BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
 
@@ -461,7 +461,7 @@ public class ShadowBluetoothAdapterTest {
   }
 
   @Test
-  public void canGetProfileConnectionState() throws Exception {
+  public void canGetProfileConnectionState() {
     BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
     assertThat(adapter.getProfileConnectionState(BluetoothProfile.HEADSET))
         .isEqualTo(BluetoothProfile.STATE_DISCONNECTED);
@@ -772,7 +772,7 @@ public class ShadowBluetoothAdapterTest {
   @Config(minSdk = TIRAMISU)
   @Test
   @SuppressWarnings("JdkImmutableCollections")
-  public void getResgisteredUuids_returnsRegisteredServers() {
+  public void getRegisteredUuids_returnsRegisteredServers() {
     PendingIntent rfcommServerIntent = createTestPendingIntent(testIntent);
 
     Set<UUID> serverUuids = Set.of(UUID1, UUID2, UUID3, UUID4, UUID5);
@@ -900,6 +900,7 @@ public class ShadowBluetoothAdapterTest {
   }
 
   private BluetoothAdapter.LeScanCallback newLeScanCallback() {
+    //noinspection Convert2Lambda
     return new BluetoothAdapter.LeScanCallback() {
       @Override
       public void onLeScan(BluetoothDevice bluetoothDevice, int i, byte[] bytes) {}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothDeviceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothDeviceTest.java
index 5f50b3a42..f4523db4f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothDeviceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothDeviceTest.java
@@ -43,7 +43,7 @@ public class ShadowBluetoothDeviceTest {
   private final Application application = ApplicationProvider.getApplicationContext();
 
   @Test
-  public void canCreateBluetoothDeviceViaNewInstance() throws Exception {
+  public void canCreateBluetoothDeviceViaNewInstance() {
     // This test passes as long as no Exception is thrown. It tests if the constructor can be
     // executed without throwing an Exception when getService() is called inside.
     BluetoothDevice bluetoothDevice = ShadowBluetoothDevice.newInstance(MOCK_MAC_ADDRESS);
@@ -51,7 +51,7 @@ public class ShadowBluetoothDeviceTest {
   }
 
   @Test
-  public void canSetAndGetUuids() throws Exception {
+  public void canSetAndGetUuids() {
     shadowOf(application).grantPermissions(BLUETOOTH_CONNECT);
     BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(MOCK_MAC_ADDRESS);
     ParcelUuid[] uuids =
@@ -93,6 +93,17 @@ public class ShadowBluetoothDeviceTest {
     assertThat(device.createBond()).isTrue();
   }
 
+  @Test
+  public void canSetAndGetCreatedBondLe() {
+    shadowOf(application).grantPermissions(BLUETOOTH_CONNECT);
+    BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(MOCK_MAC_ADDRESS);
+
+    assertThat(device.createBond(BluetoothDevice.TRANSPORT_LE)).isFalse();
+
+    shadowOf(device).setCreatedBond(true);
+    assertThat(device.createBond(BluetoothDevice.TRANSPORT_LE)).isTrue();
+  }
+
   @Test
   public void canSetAndGetPin() {
     shadowOf(application).grantPermissions(BLUETOOTH_CONNECT);
@@ -282,6 +293,7 @@ public class ShadowBluetoothDeviceTest {
         implements ShadowBluetoothDevice.BluetoothGattConnectionInterceptor {
       @Nullable private BluetoothGatt interceptedGatt = null;
 
+      @Nullable
       public BluetoothGatt getInterceptedGatt() {
         return interceptedGatt;
       }
@@ -446,6 +458,17 @@ public class ShadowBluetoothDeviceTest {
     assertThrows(SecurityException.class, device::createBond);
   }
 
+  @Test
+  @Config(minSdk = VERSION_CODES.S)
+  public void createBondLe_noBluetoothConnectPermission_throwsException() {
+    shadowOf(application).denyPermissions(BLUETOOTH_CONNECT);
+    BluetoothDevice device = ShadowBluetoothDevice.newInstance(MOCK_MAC_ADDRESS);
+    ShadowBluetoothDevice shadowDevice = shadowOf(device);
+    shadowDevice.setShouldThrowSecurityExceptions(true);
+
+    assertThrows(SecurityException.class, () -> device.createBond(BluetoothDevice.TRANSPORT_LE));
+  }
+
   @Test
   @Config(minSdk = VERSION_CODES.S)
   public void createInsecureL2capChannel_noBluetoothConnectPermission_throwsException() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothGattServerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothGattServerTest.java
index c31cb92d3..d9a51bde8 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothGattServerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothGattServerTest.java
@@ -58,8 +58,6 @@ public class ShadowBluetoothGattServerTest {
           UUID.fromString("00000000-0000-0000-0001-0000000000A1"),
           BluetoothGattService.SERVICE_TYPE_PRIMARY);
 
-  private BluetoothManager manager;
-  private Context context;
   private BluetoothGattServer server;
   private BluetoothDevice device;
 
@@ -97,8 +95,9 @@ public class ShadowBluetoothGattServerTest {
   @Before
   @Config()
   public void setUp() {
-    context = ApplicationProvider.getApplicationContext();
-    manager = (BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE);
+    Context context = ApplicationProvider.getApplicationContext();
+    BluetoothManager manager =
+        (BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE);
     server = manager.openGattServer(context, new BluetoothGattServerCallback() {}, 0);
     device = ShadowBluetoothDevice.newInstance(MOCK_MAC_ADDRESS);
   }
@@ -387,7 +386,7 @@ public class ShadowBluetoothGattServerTest {
   }
 
   @Test
-  public void test_isConnectionCancelled_afterCancelConnection_aftereNotifyConnection() {
+  public void test_isConnectionCancelled_afterCancelConnection_afterNotifyConnection() {
     shadowOf(server).setGattServerCallback(callback);
     shadowOf(server).notifyConnection(device);
     server.cancelConnection(device);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothGattTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothGattTest.java
index f405847c8..45fabff3f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothGattTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothGattTest.java
@@ -195,12 +195,12 @@ public class ShadowBluetoothGattTest {
   }
 
   @Test
-  public void isNotClosedbeforeClose() {
+  public void isNotClosedBeforeClose() {
     assertThat(shadowOf(bluetoothGatt).isClosed()).isFalse();
   }
 
   @Test
-  public void isClosedafterClose() {
+  public void isClosedAfterClose() {
     bluetoothGatt.close();
     assertThat(shadowOf(bluetoothGatt).isClosed()).isTrue();
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothHeadsetTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothHeadsetTest.java
index 97065ac33..6282f2ec5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothHeadsetTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothHeadsetTest.java
@@ -188,7 +188,7 @@ public class ShadowBluetoothHeadsetTest {
   }
 
   @Test
-  public void startVoiceRecogntion_shouldEmitBroadcast() {
+  public void startVoiceRecognition_shouldEmitBroadcast() {
     shadowOf(bluetoothHeadset).addConnectedDevice(device1);
     IntentFilter intentFilter = new IntentFilter(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
     List<Integer> extraStateList = new ArrayList<>();
@@ -210,7 +210,7 @@ public class ShadowBluetoothHeadsetTest {
   }
 
   @Test
-  public void startVoiceRecogniton_returnsFalseIfAlreadyStarted() {
+  public void startVoiceRecognition_returnsFalseIfAlreadyStarted() {
     shadowOf(bluetoothHeadset).addConnectedDevice(device1);
     shadowOf(bluetoothHeadset).addConnectedDevice(device2);
 
@@ -220,7 +220,7 @@ public class ShadowBluetoothHeadsetTest {
   }
 
   @Test
-  public void startVoiceRecogntion_stopsAlreadyStartedRecognition() {
+  public void startVoiceRecognition_stopsAlreadyStartedRecognition() {
     shadowOf(bluetoothHeadset).addConnectedDevice(device1);
     shadowOf(bluetoothHeadset).addConnectedDevice(device2);
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothLeAdvertiserTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothLeAdvertiserTest.java
index 744fa6f77..e1491bd2c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothLeAdvertiserTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothLeAdvertiserTest.java
@@ -66,7 +66,7 @@ public class ShadowBluetoothLeAdvertiserTest {
 
   private Optional<Integer> advertisingSetStartStatusOptional;
   private boolean advertisingSetStopped;
-  private AdvertisingSetCallback advertisingSetCallback =
+  private final AdvertisingSetCallback advertisingSetCallback =
       new AdvertisingSetCallback() {
         @Override
         public void onAdvertisingSetStarted(
@@ -206,6 +206,7 @@ public class ShadowBluetoothLeAdvertiserTest {
     idleMainLooper();
     assertThat(shadowOf(bluetoothLeAdvertiser).getAdvertisementRequestCount()).isEqualTo(1);
     assertThat(result).isEqualTo(CALLBACK1_SUCCESS_RESULT);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(advertiseData1);
   }
 
   @Test
@@ -227,6 +228,7 @@ public class ShadowBluetoothLeAdvertiserTest {
     assertThat(shadowOf(bluetoothLeAdvertiser).getAdvertisementRequestCount()).isEqualTo(2);
     assertThat(result).isEqualTo(CALLBACK2_SUCCESS_RESULT);
     assertThat(settings).isEqualTo(advertiseSettings2);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(advertiseData2);
   }
 
   @Test
@@ -237,6 +239,7 @@ public class ShadowBluetoothLeAdvertiserTest {
     idleMainLooper();
     assertThat(error).isEqualTo(AdvertiseCallback.ADVERTISE_FAILED_ALREADY_STARTED);
     assertThat(shadowOf(bluetoothLeAdvertiser).getAdvertisementRequestCount()).isEqualTo(1);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(advertiseData2);
   }
 
   @Test
@@ -254,6 +257,7 @@ public class ShadowBluetoothLeAdvertiserTest {
         advertiseSettings1, oversizedData, null, advertiseCallback1);
     idleMainLooper();
     assertThat(error).isEqualTo(AdvertiseCallback.ADVERTISE_FAILED_DATA_TOO_LARGE);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(null);
   }
 
   @Test
@@ -281,6 +285,7 @@ public class ShadowBluetoothLeAdvertiserTest {
     idleMainLooper();
     assertThat(result).isEqualTo(CALLBACK1_SUCCESS_RESULT);
     assertThat(shadowOf(bluetoothLeAdvertiser).getAdvertisementRequestCount()).isEqualTo(1);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(data);
   }
 
   @Test
@@ -301,6 +306,7 @@ public class ShadowBluetoothLeAdvertiserTest {
     idleMainLooper();
     assertThat(result).isEqualTo(CALLBACK1_SUCCESS_RESULT);
     assertThat(shadowOf(bluetoothLeAdvertiser).getAdvertisementRequestCount()).isEqualTo(1);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(data);
   }
 
   @Test
@@ -313,6 +319,7 @@ public class ShadowBluetoothLeAdvertiserTest {
     idleMainLooper();
     assertThat(result).isEqualTo(CALLBACK1_SUCCESS_RESULT);
     assertThat(shadowOf(bluetoothLeAdvertiser).getAdvertisementRequestCount()).isEqualTo(1);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(data);
   }
 
   @Test
@@ -341,6 +348,7 @@ public class ShadowBluetoothLeAdvertiserTest {
     idleMainLooper();
     assertThat(error).isEqualTo(AdvertiseCallback.ADVERTISE_FAILED_DATA_TOO_LARGE);
     assertThat(shadowOf(bluetoothLeAdvertiser).getAdvertisementRequestCount()).isEqualTo(0);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(oversizedData);
   }
 
   @Test
@@ -362,6 +370,7 @@ public class ShadowBluetoothLeAdvertiserTest {
     idleMainLooper();
     assertThat(error).isEqualTo(AdvertiseCallback.ADVERTISE_FAILED_DATA_TOO_LARGE);
     assertThat(shadowOf(bluetoothLeAdvertiser).getAdvertisementRequestCount()).isEqualTo(0);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(oversizedData);
   }
 
   @Test
@@ -382,6 +391,7 @@ public class ShadowBluetoothLeAdvertiserTest {
     idleMainLooper();
     assertThat(error).isEqualTo(AdvertiseCallback.ADVERTISE_FAILED_DATA_TOO_LARGE);
     assertThat(shadowOf(bluetoothLeAdvertiser).getAdvertisementRequestCount()).isEqualTo(0);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(data);
   }
 
   @Test
@@ -395,6 +405,7 @@ public class ShadowBluetoothLeAdvertiserTest {
     idleMainLooper();
     assertThat(error).isEqualTo(AdvertiseCallback.ADVERTISE_FAILED_DATA_TOO_LARGE);
     assertThat(shadowOf(bluetoothLeAdvertiser).getAdvertisementRequestCount()).isEqualTo(0);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(oversizedData);
   }
 
   @Test
@@ -422,6 +433,7 @@ public class ShadowBluetoothLeAdvertiserTest {
     idleMainLooper();
     assertThat(error).isEqualTo(AdvertiseCallback.ADVERTISE_FAILED_DATA_TOO_LARGE);
     assertThat(shadowOf(bluetoothLeAdvertiser).getAdvertisementRequestCount()).isEqualTo(0);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(data);
   }
 
   @Test
@@ -436,6 +448,7 @@ public class ShadowBluetoothLeAdvertiserTest {
     idleMainLooper();
     assertThat(result).isEqualTo(CALLBACK1_SUCCESS_RESULT);
     assertThat(shadowOf(bluetoothLeAdvertiserNameSet).getAdvertisementRequestCount()).isEqualTo(1);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(data);
   }
 
   @Test
@@ -456,6 +469,7 @@ public class ShadowBluetoothLeAdvertiserTest {
     idleMainLooper();
     assertThat(shadowOf(bluetoothLeAdvertiserNameSet).getAdvertisementRequestCount()).isEqualTo(0);
     assertThat(error).isEqualTo(AdvertiseCallback.ADVERTISE_FAILED_DATA_TOO_LARGE);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(data);
   }
 
   @Test
@@ -477,6 +491,7 @@ public class ShadowBluetoothLeAdvertiserTest {
     idleMainLooper();
     assertThat(shadowOf(bluetoothLeAdvertiserNameSet).getAdvertisementRequestCount()).isEqualTo(0);
     assertThat(error).isEqualTo(AdvertiseCallback.ADVERTISE_FAILED_DATA_TOO_LARGE);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(data);
   }
 
   @Test
@@ -845,6 +860,49 @@ public class ShadowBluetoothLeAdvertiserTest {
     assertThat(shadowOf(bluetoothLeAdvertiser).getAdvertisingSetRequestCount()).isEqualTo(0);
   }
 
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void startAdvertisingSet_oneAdvertisement_withNoScanResponse() {
+    bluetoothLeAdvertiser.startAdvertisingSet(
+        buildAdvertisingSetParams(
+            true, true, true, BluetoothDevice.PHY_LE_CODED, BluetoothDevice.PHY_LE_CODED),
+        advertiseData1,
+        null,
+        null,
+        null,
+        advertisingSetCallback);
+    idleMainLooper();
+    assertThat(advertisingSetStartStatusOptional.get())
+        .isEqualTo(AdvertisingSetCallback.ADVERTISE_SUCCESS);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getAdvertisingSetRequestCount()).isEqualTo(1);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(advertiseData1);
+  }
+
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void startAdvertisingSet_oversizedAdvertisement_advertisementFails() {
+    AdvertiseData oversizedData =
+        new AdvertiseData.Builder()
+            .addServiceUuid(ParcelUuid.fromString("FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"))
+            .addServiceUuid(ParcelUuid.fromString("EEEEEEEE-FFFF-FFFF-FFFF-FFFFFFFFFFFF"))
+            .build();
+    assertThrows(
+        IllegalArgumentException.class,
+        () ->
+            bluetoothLeAdvertiser.startAdvertisingSet(
+                buildAdvertisingSetParams(
+                    true, true, true, BluetoothDevice.PHY_LE_CODED, BluetoothDevice.PHY_LE_CODED),
+                oversizedData,
+                null,
+                null,
+                null,
+                advertisingSetCallback));
+
+    idleMainLooper();
+    assertThat(shadowOf(bluetoothLeAdvertiser).getAdvertisingSetRequestCount()).isEqualTo(0);
+    assertThat(shadowOf(bluetoothLeAdvertiser).getLastAdvertisingData()).isEqualTo(null);
+  }
+
   @Test
   @Config(minSdk = UPSIDE_DOWN_CAKE)
   public void stopAdvertisingSet() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothLeScannerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothLeScannerTest.java
index 022c1f718..dc3c70dd1 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothLeScannerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothLeScannerTest.java
@@ -17,7 +17,6 @@ import android.content.Intent;
 import android.os.ParcelUuid;
 import androidx.test.core.app.ApplicationProvider;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.UUID;
@@ -237,7 +236,8 @@ public class ShadowBluetoothLeScannerTest {
     shadowBluetoothLeScanner.addScanResult(scanResultTwo);
 
     ScanFilter filter = new ScanFilter.Builder().setDeviceAddress(addressOne).build();
-    bluetoothLeScanner.startScan(Arrays.asList(filter), /* settings= */ null, scanCallback);
+    bluetoothLeScanner.startScan(
+        Collections.singletonList(filter), /* settings= */ null, scanCallback);
 
     assertThat(scanCallback.scanResults).containsExactly(scanResultOne);
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothSocketTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothSocketTest.java
index 4e2c6cb6f..d49f2c778 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothSocketTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothSocketTest.java
@@ -1,7 +1,8 @@
 package org.robolectric.shadows;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertThrows;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.bluetooth.BluetoothSocket;
@@ -10,6 +11,10 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.io.PipedOutputStream;
 import java.util.Arrays;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicBoolean;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -68,20 +73,128 @@ public class ShadowBluetoothSocketTest {
   public void close() throws Exception {
     bluetoothSocket.close();
 
-    try {
-      bluetoothSocket.connect();
-      fail();
-    } catch (IOException expected) {
-      // Expected.
-    }
+    assertThrows(IOException.class, () -> bluetoothSocket.connect());
+  }
+
+  @Test
+  public void unblockConnect_withoutBlocking_throws() throws Exception {
+    assertThrows(IllegalStateException.class, () -> shadowOf(bluetoothSocket).unblockConnect());
+  }
+
+  @Test
+  public void blockConnect_afterAlreadyBlocking_throws() throws Exception {
+    shadowOf(bluetoothSocket).blockConnect();
+    assertThrows(IllegalStateException.class, () -> shadowOf(bluetoothSocket).blockConnect());
+  }
+
+  @Test
+  public void blockConnect_afterUnblocked_throws() throws Exception {
+    shadowOf(bluetoothSocket).blockConnect();
+    shadowOf(bluetoothSocket).unblockConnect();
+    assertThrows(IllegalStateException.class, () -> shadowOf(bluetoothSocket).blockConnect());
+  }
+
+  @Test
+  public void blockConnect_afterConnectAlreadyDone_completesWithoutBlocking() throws Exception {
+    bluetoothSocket.connect();
+    shadowOf(bluetoothSocket).blockConnect();
+    // Test succeeds if blockConnect() completes.
   }
 
   @Test
-  public void connect() throws Exception {
+  public void connect_withoutBlocking_succeeds() throws Exception {
     assertThat(bluetoothSocket.isConnected()).isFalse();
     bluetoothSocket.connect();
     assertThat(bluetoothSocket.isConnected()).isTrue();
     bluetoothSocket.close();
     assertThat(bluetoothSocket.isConnected()).isFalse();
   }
+
+  @Test
+  public void connect_afterUnblocking_succeeds() throws Exception {
+    shadowOf(bluetoothSocket).blockConnect();
+    shadowOf(bluetoothSocket).unblockConnect();
+
+    bluetoothSocket.connect();
+    assertThat(bluetoothSocket.isConnected()).isTrue();
+    bluetoothSocket.close();
+    assertThat(bluetoothSocket.isConnected()).isFalse();
+  }
+
+  @Test
+  public void unblockConnect_isIdempotent() throws Exception {
+    shadowOf(bluetoothSocket).blockConnect();
+    shadowOf(bluetoothSocket).unblockConnect();
+    shadowOf(bluetoothSocket).unblockConnect();
+
+    bluetoothSocket.connect();
+    assertThat(bluetoothSocket.isConnected()).isTrue();
+  }
+
+  @Test
+  public void connect_whileBlocked_blockedUntilShadowUnblocksAndDoesNotThrow() throws Exception {
+    shadowOf(bluetoothSocket).blockConnect();
+
+    AtomicBoolean connectCompletedExceptionally = new AtomicBoolean(false);
+    CountDownLatch aboutToConnectLatch = new CountDownLatch(1);
+    CountDownLatch completedConnectLatch = new CountDownLatch(1);
+    Future<?> unused =
+        Executors.newSingleThreadExecutor()
+            .submit(
+                () -> {
+                  aboutToConnectLatch.countDown();
+                  try {
+                    bluetoothSocket.connect();
+                  } catch (IOException e) {
+                    connectCompletedExceptionally.set(true);
+                  }
+                  completedConnectLatch.countDown();
+                });
+    aboutToConnectLatch.await();
+
+    assertThat(completedConnectLatch.await(100, MILLISECONDS)).isFalse();
+    shadowOf(bluetoothSocket).unblockConnect();
+    assertThat(completedConnectLatch.await(100, MILLISECONDS)).isTrue();
+    assertThat(connectCompletedExceptionally.get()).isFalse();
+    assertThat(bluetoothSocket.isConnected()).isTrue();
+  }
+
+  @Test
+  public void connect_whileBlocked_blockedUntilCloseAndThrows() throws Exception {
+    shadowOf(bluetoothSocket).blockConnect();
+
+    AtomicBoolean connectCompletedExceptionally = new AtomicBoolean(false);
+    CountDownLatch aboutToConnectLatch = new CountDownLatch(1);
+    CountDownLatch completedConnectLatch = new CountDownLatch(1);
+    Future<?> unused =
+        Executors.newSingleThreadExecutor()
+            .submit(
+                () -> {
+                  aboutToConnectLatch.countDown();
+                  try {
+                    bluetoothSocket.connect();
+                  } catch (IOException e) {
+                    connectCompletedExceptionally.set(true);
+                  }
+                  completedConnectLatch.countDown();
+                });
+    aboutToConnectLatch.await();
+
+    assertThat(completedConnectLatch.await(100, MILLISECONDS)).isFalse();
+    bluetoothSocket.close();
+    assertThat(completedConnectLatch.await(100, MILLISECONDS)).isTrue();
+    assertThat(connectCompletedExceptionally.get()).isTrue();
+    assertThat(bluetoothSocket.isConnected()).isFalse();
+  }
+
+  @Test
+  public void connect_customException_throws() throws Exception {
+    IOException customException = new IOException("custom exception");
+    shadowOf(bluetoothSocket).setConnectException(customException);
+
+    bluetoothSocket.close();
+    IOException thrownException = assertThrows(IOException.class, () -> bluetoothSocket.connect());
+
+    assertThat(thrownException).isSameInstanceAs(customException);
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBroadcastReceiverTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBroadcastReceiverTest.java
index e4bb93350..d629f079a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBroadcastReceiverTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBroadcastReceiverTest.java
@@ -41,6 +41,19 @@ public class ShadowBroadcastReceiverTest {
     assertThat(shadowOf(receiver).getOriginalPendingResult()).isSameInstanceAs(pendingResult);
   }
 
+  @Test
+  public void testAbortBroadcast() {
+    receiver = new MyBroadcastReceiver();
+    receiver.abortBroadcast();
+    assertThat(shadowOf(receiver).isBroadcastAborted()).isTrue();
+  }
+
+  @Test
+  public void testDefaultBroadcast() {
+    receiver = new MyBroadcastReceiver();
+    assertThat(shadowOf(receiver).isBroadcastAborted()).isFalse();
+  }
+
   private static class MyBroadcastReceiver extends BroadcastReceiver {
     @Override
     public void onReceive(Context context, Intent intent) {}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBugreportManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBugreportManagerTest.java
index 1a5be062a..decc93a6e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBugreportManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBugreportManagerTest.java
@@ -70,7 +70,7 @@ public final class ShadowBugreportManagerTest {
     shadowBugreportManager.requestBugreport(
         new BugreportParams(BugreportParams.BUGREPORT_MODE_INTERACTIVE), title, description);
 
-    // executeOnFInished() will call resetParams(), which should not crash from referencing any null
+    // executeOnFinished() will call resetParams(), which should not crash from referencing any null
     // values.
     shadowBugreportManager.executeOnFinished();
   }
@@ -93,20 +93,19 @@ public final class ShadowBugreportManagerTest {
   }
 
   @Test
-  public void startBugreport_noPermission() throws Exception {
+  public void startBugreport_noPermission() {
     BugreportCallback callback = mock(BugreportCallback.class);
     shadowBugreportManager.setHasPermission(false);
 
     assertThrows(
         SecurityException.class,
-        () -> {
-          shadowBugreportManager.startBugreport(
-              createWriteFile("bugreport"),
-              createWriteFile("screenshot"),
-              new BugreportParams(BugreportParams.BUGREPORT_MODE_FULL),
-              directExecutor(),
-              callback);
-        });
+        () ->
+            shadowBugreportManager.startBugreport(
+                createWriteFile("bugreport"),
+                createWriteFile("screenshot"),
+                new BugreportParams(BugreportParams.BUGREPORT_MODE_FULL),
+                directExecutor(),
+                callback));
     shadowMainLooper().idle();
 
     assertThat(shadowBugreportManager.isBugreportInProgress()).isFalse();
@@ -167,7 +166,7 @@ public final class ShadowBugreportManagerTest {
 
   @Test
   @Config(minSdk = UPSIDE_DOWN_CAKE)
-  public void retrieveBugreport_noPermission() throws Exception {
+  public void retrieveBugreport_noPermission() {
     BugreportCallback callback = mock(BugreportCallback.class);
     shadowBugreportManager.setHasPermission(false);
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBuildTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBuildTest.java
index b5b7b09c2..15b4295dc 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBuildTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBuildTest.java
@@ -178,6 +178,13 @@ public class ShadowBuildTest {
     assertThat(Build.ODM_SKU).isEqualTo("odm_sku");
   }
 
+  @Test
+  @Config(minSdk = S)
+  public void setSku() {
+    ShadowBuild.setSku("sku");
+    assertThat(Build.SKU).isEqualTo("sku");
+  }
+
   /** Verifies that each test gets a fresh set of Build values. */
   private void checkValues() {
     assertThat(Build.FINGERPRINT).isEqualTo("robolectric");
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCallRedirectionServiceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCallRedirectionServiceTest.java
new file mode 100644
index 000000000..a27050772
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCallRedirectionServiceTest.java
@@ -0,0 +1,112 @@
+package org.robolectric.shadows;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.ComponentName;
+import android.net.Uri;
+import android.os.Build.VERSION_CODES;
+import android.telecom.CallRedirectionService;
+import android.telecom.PhoneAccountHandle;
+import androidx.annotation.NonNull;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.util.Optional;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadow.api.Shadow;
+import org.robolectric.shadows.ShadowCallRedirectionService.RedirectionResult;
+import org.robolectric.shadows.ShadowCallRedirectionService.RedirectionResult.RedirectCallArgs;
+import org.robolectric.shadows.ShadowCallRedirectionService.RedirectionResult.RedirectionResultType;
+
+/** Unit test for {@link ShadowCallRedirectionService}. */
+@RunWith(AndroidJUnit4.class)
+@Config(minSdk = VERSION_CODES.Q)
+public class ShadowCallRedirectionServiceTest {
+
+  private static final PhoneAccountHandle PHONE_ACCOUNT_HANDLE =
+      new PhoneAccountHandle(
+          new ComponentName(ApplicationProvider.getApplicationContext(), Object.class), "handle");
+  private static final Uri REDIRECT_URI = Uri.parse("tel:1234567890");
+  private TestCallRedirectionService callRedirectionService;
+
+  @Before
+  public void setUp() {
+    callRedirectionService = Robolectric.setupService(TestCallRedirectionService.class);
+  }
+
+  @Test
+  public void placeCall_withCallUnmodified_capturesPlaceCallUnmodifiedResult() {
+    ShadowCallRedirectionService shadowService = Shadow.extract(callRedirectionService);
+    callRedirectionService.setResultType(RedirectionResultType.PLACE_CALL_UNMODIFIED);
+
+    shadowService.placeCall(Uri.EMPTY, PHONE_ACCOUNT_HANDLE, true);
+    ShadowLooper.idleMainLooper();
+
+    Optional<RedirectionResult> result = shadowService.getRedirectionResult();
+    assertThat(result.map(RedirectionResult::getRedirectionResultType))
+        .hasValue(RedirectionResultType.PLACE_CALL_UNMODIFIED);
+    assertThat(result.flatMap(RedirectionResult::getRedirectCallArgs)).isEmpty();
+  }
+
+  @Test
+  public void placeCall_withCallCancelled_capturesCancelCallResult() {
+    ShadowCallRedirectionService shadowService = Shadow.extract(callRedirectionService);
+    callRedirectionService.setResultType(RedirectionResultType.CANCEL_CALL);
+
+    shadowService.placeCall(Uri.EMPTY, PHONE_ACCOUNT_HANDLE, true);
+    ShadowLooper.idleMainLooper();
+
+    Optional<RedirectionResult> result = shadowService.getRedirectionResult();
+    assertThat(result.map(RedirectionResult::getRedirectionResultType))
+        .hasValue(RedirectionResultType.CANCEL_CALL);
+    assertThat(result.flatMap(RedirectionResult::getRedirectCallArgs)).isEmpty();
+  }
+
+  @Test
+  public void placeCall_withCallRedirected_capturesRedirectCallResult() {
+    ShadowCallRedirectionService shadowService = Shadow.extract(callRedirectionService);
+    callRedirectionService.setResultType(RedirectionResultType.REDIRECT_CALL);
+
+    shadowService.placeCall(Uri.EMPTY, PHONE_ACCOUNT_HANDLE, true);
+    ShadowLooper.idleMainLooper();
+
+    Optional<RedirectionResult> result = shadowService.getRedirectionResult();
+    assertThat(result.map(RedirectionResult::getRedirectionResultType))
+        .hasValue(RedirectionResultType.REDIRECT_CALL);
+    Optional<RedirectCallArgs> redirectCallArgs =
+        result.flatMap(RedirectionResult::getRedirectCallArgs);
+    assertThat(redirectCallArgs).isPresent();
+    assertThat(redirectCallArgs.get().getHandle()).isEqualTo(REDIRECT_URI);
+    assertThat(redirectCallArgs.get().getTargetPhoneAccount()).isEqualTo(PHONE_ACCOUNT_HANDLE);
+    assertThat(redirectCallArgs.get().getConfirmFirst()).isTrue();
+  }
+
+  private static class TestCallRedirectionService extends CallRedirectionService {
+    private RedirectionResultType resultType = RedirectionResultType.PLACE_CALL_UNMODIFIED;
+
+    private void setResultType(RedirectionResultType resultType) {
+      this.resultType = resultType;
+    }
+
+    @Override
+    public void onPlaceCall(
+        @NonNull Uri handle,
+        @NonNull PhoneAccountHandle initialPhoneAccount,
+        boolean allowInteractiveResponse) {
+      switch (resultType) {
+        case PLACE_CALL_UNMODIFIED:
+          placeCallUnmodified();
+          break;
+        case CANCEL_CALL:
+          cancelCall();
+          break;
+        case REDIRECT_CALL:
+          redirectCall(REDIRECT_URI, initialPhoneAccount, true);
+          break;
+      }
+    }
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCallScreeningServiceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCallScreeningServiceTest.java
index 523545afb..99346f9d2 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCallScreeningServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCallScreeningServiceTest.java
@@ -7,6 +7,7 @@ import android.telecom.Call;
 import android.telecom.CallScreeningService;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.Optional;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,7 +31,7 @@ public class ShadowCallScreeningServiceTest {
   public void getLastRespondToCallInput_whenRespondToCallNotCalled_shouldReturnEmptyOptional() {
     Optional<ShadowCallScreeningService.RespondToCallInput> lastRespondToCallInputOptional =
         shadowCallScreeningService.getLastRespondToCallInput();
-    assertThat(lastRespondToCallInputOptional.isPresent()).isFalse();
+    assertThat(lastRespondToCallInputOptional).isEmpty();
   }
 
   @Test
@@ -41,10 +42,8 @@ public class ShadowCallScreeningServiceTest {
 
     Optional<ShadowCallScreeningService.RespondToCallInput> lastRespondToCallInputOptional =
         shadowCallScreeningService.getLastRespondToCallInput();
-    assertThat(lastRespondToCallInputOptional.isPresent()).isTrue();
-    ShadowCallScreeningService.RespondToCallInput respondToCallInput =
-        shadowCallScreeningService.getLastRespondToCallInput().get();
-    assertThat(respondToCallInput.getCallDetails()).isNull();
+    assertThat(lastRespondToCallInputOptional).isPresent();
+    assertThat(lastRespondToCallInputOptional.get().getCallDetails()).isNull();
   }
 
   @Test
@@ -52,15 +51,15 @@ public class ShadowCallScreeningServiceTest {
     Call.Details testCallDetails = null;
     callScreeningService.onScreenCall(testCallDetails);
 
-    assertThat(shadowCallScreeningService.getLastRespondToCallInput().isPresent()).isTrue();
-    ShadowCallScreeningService.RespondToCallInput respondToCallInput =
-        shadowCallScreeningService.getLastRespondToCallInput().get();
-    assertThat(respondToCallInput.getCallResponse().getRejectCall()).isTrue();
+    Optional<ShadowCallScreeningService.RespondToCallInput> lastRespondToCallInputOptional =
+        shadowCallScreeningService.getLastRespondToCallInput();
+    assertThat(lastRespondToCallInputOptional).isPresent();
+    assertThat(lastRespondToCallInputOptional.get().getCallResponse().getRejectCall()).isTrue();
   }
 
   private static class TestCallScreeningService extends CallScreeningService {
     @Override
-    public void onScreenCall(Call.Details details) {
+    public void onScreenCall(@Nonnull Call.Details details) {
       CallResponse callResponse =
           new CallResponse.Builder()
               .setDisallowCall(true)
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraCharacteristicsTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraCharacteristicsTest.java
index a3738cae3..5b490b490 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraCharacteristicsTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraCharacteristicsTest.java
@@ -13,8 +13,8 @@ import org.junit.runner.RunWith;
 @RunWith(AndroidJUnit4.class)
 public class ShadowCameraCharacteristicsTest {
 
-  private final CameraCharacteristics.Key key0 =
-      new CameraCharacteristics.Key("key0", Integer.class);
+  private final CameraCharacteristics.Key<Integer> key0 =
+      new CameraCharacteristics.Key<>("key0", Integer.class);
   private final CameraCharacteristics cameraCharacteristics =
       ShadowCameraCharacteristics.newCameraCharacteristics();
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraDeviceImplTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraDeviceImplTest.java
index 4a0c635b5..b6a7b232f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraDeviceImplTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraDeviceImplTest.java
@@ -31,6 +31,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.util.concurrent.MoreExecutors;
 import java.util.ArrayList;
 import java.util.Collections;
+import javax.annotation.Nonnull;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -78,8 +79,7 @@ public final class ShadowCameraDeviceImplTest {
 
   @Test
   @Config(sdk = VERSION_CODES.P)
-  public void createCaptureRequest_throwsIllegalStateExceptionAfterClose()
-      throws CameraAccessException {
+  public void createCaptureRequest_throwsIllegalStateExceptionAfterClose() {
     cameraDevice.close();
 
     IllegalStateException thrown =
@@ -114,8 +114,7 @@ public final class ShadowCameraDeviceImplTest {
 
   @Test
   @Config(sdk = VERSION_CODES.P)
-  public void createCaptureSession_throwsIllegalStateExceptionAfterClose()
-      throws CameraAccessException {
+  public void createCaptureSession_throwsIllegalStateExceptionAfterClose() {
     cameraDevice.close();
 
     IllegalStateException thrown =
@@ -131,8 +130,7 @@ public final class ShadowCameraDeviceImplTest {
 
   @Test
   @Config(sdk = VERSION_CODES.P)
-  public void createCaptureSession_configuration_throwsIllegalStateExceptionAfterClose()
-      throws CameraAccessException {
+  public void createCaptureSession_configuration_throwsIllegalStateExceptionAfterClose() {
     cameraDevice.close();
 
     SessionConfiguration configuration =
@@ -195,7 +193,7 @@ public final class ShadowCameraDeviceImplTest {
     }
 
     @Override
-    public void onConfigured(CameraCaptureSession cameraCaptureSession) {
+    public void onConfigured(@Nonnull CameraCaptureSession cameraCaptureSession) {
       captureSession = cameraCaptureSession;
       assertThat(captureSession.getDevice().getId()).isEqualTo(CAMERA_ID_0);
 
@@ -203,7 +201,9 @@ public final class ShadowCameraDeviceImplTest {
           new CaptureCallback() {
             @Override
             public void onCaptureCompleted(
-                CameraCaptureSession session, CaptureRequest request, TotalCaptureResult result) {}
+                @Nonnull CameraCaptureSession session,
+                @Nonnull CaptureRequest request,
+                @Nonnull TotalCaptureResult result) {}
           };
 
       try {
@@ -238,7 +238,7 @@ public final class ShadowCameraDeviceImplTest {
     }
 
     @Override
-    public void onConfigureFailed(final CameraCaptureSession cameraCaptureSession) {
+    public void onConfigureFailed(@Nonnull final CameraCaptureSession cameraCaptureSession) {
       fail();
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java
index df0687015..6f547fa0e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java
@@ -202,7 +202,7 @@ public class ShadowCameraManagerTest {
   }
 
   @Test
-  public void triggerDisconnect_noCameraOpen() throws CameraAccessException {
+  public void triggerDisconnect_noCameraOpen() {
     shadowOf(cameraManager).addCamera(CAMERA_ID_0, characteristics);
     shadowOf(cameraManager).triggerDisconnect();
     // Nothing should happen - just make sure we don't crash.
@@ -263,7 +263,7 @@ public class ShadowCameraManagerTest {
   }
 
   @Test
-  public void registerCallbackAvailable() throws CameraAccessException {
+  public void registerCallbackAvailable() {
     CameraManager.AvailabilityCallback mockCallback =
         mock(CameraManager.AvailabilityCallback.class);
     // Verify adding the camera triggers the callback
@@ -274,7 +274,7 @@ public class ShadowCameraManagerTest {
   }
 
   @Test
-  public void unregisterCallbackAvailable() throws CameraAccessException {
+  public void unregisterCallbackAvailable() {
     CameraManager.AvailabilityCallback mockCallback =
         mock(CameraManager.AvailabilityCallback.class);
 
@@ -289,7 +289,7 @@ public class ShadowCameraManagerTest {
   }
 
   @Test
-  public void registerCallbackUnavailable() throws CameraAccessException {
+  public void registerCallbackUnavailable() {
     CameraManager.AvailabilityCallback mockCallback =
         mock(CameraManager.AvailabilityCallback.class);
 
@@ -302,7 +302,7 @@ public class ShadowCameraManagerTest {
   }
 
   @Test
-  public void unregisterCallbackUnavailable() throws CameraAccessException {
+  public void unregisterCallbackUnavailable() {
     CameraManager.AvailabilityCallback mockCallback =
         mock(CameraManager.AvailabilityCallback.class);
 
@@ -316,7 +316,7 @@ public class ShadowCameraManagerTest {
   }
 
   @Test
-  public void registerCallbackUnavailableInvalidCameraId() throws CameraAccessException {
+  public void registerCallbackUnavailableInvalidCameraId() {
     CameraManager.AvailabilityCallback mockCallback =
         mock(CameraManager.AvailabilityCallback.class);
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraParametersTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraParametersTest.java
index 06d9c2067..583acb845 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraParametersTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraParametersTest.java
@@ -79,7 +79,7 @@ public class ShadowCameraParametersTest {
   public void testGetSupportedPreviewFormats() {
     List<Integer> supportedFormats = parameters.getSupportedPreviewFormats();
     assertThat(supportedFormats).isNotNull();
-    assertThat(supportedFormats.size()).isNotEqualTo(0);
+    assertThat(supportedFormats).isNotEmpty();
     assertThat(supportedFormats).contains(ImageFormat.NV21);
   }
 
@@ -87,7 +87,7 @@ public class ShadowCameraParametersTest {
   public void testGetSupportedPictureFormats() {
     List<Integer> supportedFormats = parameters.getSupportedPictureFormats();
     assertThat(supportedFormats).isNotNull();
-    assertThat(supportedFormats.size()).isEqualTo(2);
+    assertThat(supportedFormats).hasSize(2);
     assertThat(supportedFormats).contains(ImageFormat.NV21);
   }
 
@@ -95,7 +95,7 @@ public class ShadowCameraParametersTest {
   public void testGetSupportedPictureSizes() {
     List<Camera.Size> supportedSizes = parameters.getSupportedPictureSizes();
     assertThat(supportedSizes).isNotNull();
-    assertThat(supportedSizes.size()).isEqualTo(3);
+    assertThat(supportedSizes).hasSize(3);
     assertThat(supportedSizes.get(0).width).isEqualTo(320);
     assertThat(supportedSizes.get(0).height).isEqualTo(240);
   }
@@ -104,7 +104,7 @@ public class ShadowCameraParametersTest {
   public void testGetSupportedPreviewSizes() {
     List<Camera.Size> supportedSizes = parameters.getSupportedPreviewSizes();
     assertThat(supportedSizes).isNotNull();
-    assertThat(supportedSizes.size()).isEqualTo(2);
+    assertThat(supportedSizes).hasSize(2);
     assertThat(supportedSizes.get(0).width).isEqualTo(320);
     assertThat(supportedSizes.get(0).height).isEqualTo(240);
   }
@@ -130,7 +130,7 @@ public class ShadowCameraParametersTest {
   public void testGetSupportedPreviewFpsRange() {
     List<int[]> supportedRanges = parameters.getSupportedPreviewFpsRange();
     assertThat(supportedRanges).isNotNull();
-    assertThat(supportedRanges.size()).isEqualTo(2);
+    assertThat(supportedRanges).hasSize(2);
     assertThat(supportedRanges.get(0)[0]).isEqualTo(15000);
     assertThat(supportedRanges.get(0)[1]).isEqualTo(15000);
     assertThat(supportedRanges.get(1)[0]).isEqualTo(10000);
@@ -141,7 +141,7 @@ public class ShadowCameraParametersTest {
   public void testGetSupportedPreviewFrameRates() {
     List<Integer> supportedRates = parameters.getSupportedPreviewFrameRates();
     assertThat(supportedRates).isNotNull();
-    assertThat(supportedRates.size()).isEqualTo(3);
+    assertThat(supportedRates).hasSize(3);
     assertThat(supportedRates.get(0)).isEqualTo(10);
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraTest.java
index c79d135a2..9da277c19 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraTest.java
@@ -67,7 +67,7 @@ public class ShadowCameraTest {
     Camera.Parameters parameters = camera.getParameters();
     assertThat(parameters).isNotNull();
     assertThat(parameters.getSupportedPreviewFormats()).isNotNull();
-    assertThat(parameters.getSupportedPreviewFormats().size()).isNotEqualTo(0);
+    assertThat(parameters.getSupportedPreviewFormats()).isNotEmpty();
   }
 
   @Test
@@ -213,7 +213,7 @@ public class ShadowCameraTest {
 
     assertThat(shadowCamera.hasRequestedAutoFocus()).isTrue();
     shadowCamera.invokeAutoFocusCallback(true, camera);
-    assertThat(callback.success).isEqualTo(true);
+    assertThat(callback.success).isTrue();
     assertThat(callback.camera).isEqualTo(camera);
 
     assertThat(shadowCamera.hasRequestedAutoFocus()).isFalse();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCanvasTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCanvasTest.java
index 4ccb81aba..724093cd9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCanvasTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCanvasTest.java
@@ -37,7 +37,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void shouldDescribeBitmapDrawing() throws Exception {
+  public void shouldDescribeBitmapDrawing() {
     Canvas canvas = new Canvas(targetBitmap);
     canvas.drawBitmap(imageBitmap, 1, 2, new Paint());
     canvas.drawBitmap(imageBitmap, 100, 200, new Paint());
@@ -52,7 +52,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void shouldDescribeBitmapDrawing_withDestinationRect() throws Exception {
+  public void shouldDescribeBitmapDrawing_withDestinationRect() {
     Canvas canvas = new Canvas(targetBitmap);
     canvas.drawBitmap(imageBitmap, new Rect(1, 2, 3, 4), new Rect(5, 6, 7, 8), new Paint());
 
@@ -63,7 +63,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void shouldDescribeBitmapDrawing_withDestinationRectF() throws Exception {
+  public void shouldDescribeBitmapDrawing_withDestinationRectF() {
     Canvas canvas = new Canvas(targetBitmap);
     canvas.drawBitmap(
         imageBitmap, new Rect(1, 2, 3, 4), new RectF(5.0f, 6.0f, 7.5f, 8.5f), new Paint());
@@ -75,7 +75,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void shouldDescribeBitmapDrawing_WithMatrix() throws Exception {
+  public void shouldDescribeBitmapDrawing_WithMatrix() {
     Canvas canvas = new Canvas(targetBitmap);
     canvas.drawBitmap(imageBitmap, new Matrix(), new Paint());
     canvas.drawBitmap(imageBitmap, new Matrix(), new Paint());
@@ -94,7 +94,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void visualize_shouldReturnDescription() throws Exception {
+  public void visualize_shouldReturnDescription() {
     Canvas canvas = new Canvas(targetBitmap);
     canvas.drawBitmap(imageBitmap, new Matrix(), new Paint());
     canvas.drawBitmap(imageBitmap, new Matrix(), new Paint());
@@ -107,7 +107,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void drawColor_shouldReturnDescription() throws Exception {
+  public void drawColor_shouldReturnDescription() {
     Canvas canvas = new Canvas(targetBitmap);
     canvas.drawColor(Color.WHITE);
     canvas.drawColor(Color.GREEN);
@@ -117,7 +117,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void drawPath_shouldRecordThePathAndThePaint() throws Exception {
+  public void drawPath_shouldRecordThePathAndThePaint() {
     Canvas canvas = new Canvas(targetBitmap);
     Path path = new Path();
     path.lineTo(10, 10);
@@ -134,15 +134,14 @@ public class ShadowCanvasTest {
     ShadowCanvas shadow = shadowOf(canvas);
     assertThat(shadow.getPathPaintHistoryCount()).isEqualTo(1);
     ShadowPath drawnPath = shadowOf(shadow.getDrawnPath(0));
-    assertEquals(drawnPath.getPoints().get(0), new ShadowPath.Point(10, 10, LINE_TO));
+    assertEquals(new ShadowPath.Point(10, 10, LINE_TO), drawnPath.getPoints().get(0));
     Paint drawnPathPaint = shadow.getDrawnPathPaint(0);
     assertThat(drawnPathPaint.getColor()).isEqualTo(Color.RED);
     assertThat(drawnPathPaint.getAlpha()).isEqualTo(7);
   }
 
   @Test
-  public void drawPath_shouldRecordThePointsOfEachPathEvenWhenItIsTheSameInstance()
-      throws Exception {
+  public void drawPath_shouldRecordThePointsOfEachPathEvenWhenItIsTheSameInstance() {
     Canvas canvas = new Canvas(targetBitmap);
     Paint paint = new Paint();
     Path path = new Path();
@@ -157,13 +156,13 @@ public class ShadowCanvasTest {
     ShadowCanvas shadow = shadowOf(canvas);
     assertThat(shadow.getPathPaintHistoryCount()).isEqualTo(2);
     assertEquals(
-        shadowOf(shadow.getDrawnPath(0)).getPoints().get(0), new ShadowPath.Point(10, 10, LINE_TO));
+        new ShadowPath.Point(10, 10, LINE_TO), shadowOf(shadow.getDrawnPath(0)).getPoints().get(0));
     assertEquals(
-        shadowOf(shadow.getDrawnPath(1)).getPoints().get(0), new ShadowPath.Point(20, 20, LINE_TO));
+        new ShadowPath.Point(20, 20, LINE_TO), shadowOf(shadow.getDrawnPath(1)).getPoints().get(0));
   }
 
   @Test
-  public void drawPath_shouldAppendDescriptionToBitmap() throws Exception {
+  public void drawPath_shouldAppendDescriptionToBitmap() {
     Canvas canvas = new Canvas(targetBitmap);
     Path path1 = new Path();
     path1.lineTo(10, 10);
@@ -194,7 +193,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void resetCanvasHistory_shouldClearTheHistoryAndDescription() throws Exception {
+  public void resetCanvasHistory_shouldClearTheHistoryAndDescription() {
     Canvas canvas = new Canvas();
     canvas.drawPath(new Path(), new Paint());
     canvas.drawText("hi", 1, 2, new Paint());
@@ -208,7 +207,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void shouldGetAndSetHeightAndWidth() throws Exception {
+  public void shouldGetAndSetHeightAndWidth() {
     Canvas canvas = new Canvas();
     shadowOf(canvas).setWidth(99);
     shadowOf(canvas).setHeight(42);
@@ -218,7 +217,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void shouldRecordText() throws Exception {
+  public void shouldRecordText() {
     Canvas canvas = new Canvas();
     Paint paint = new Paint();
     Paint paint2 = new Paint();
@@ -243,7 +242,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void shouldRecordText_charArrayOverload() throws Exception {
+  public void shouldRecordText_charArrayOverload() {
     Canvas canvas = new Canvas();
     Paint paint = new Paint();
     paint.setColor(1);
@@ -261,7 +260,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void shouldRecordText_stringWithRangeOverload() throws Exception {
+  public void shouldRecordText_stringWithRangeOverload() {
     Canvas canvas = new Canvas();
     Paint paint = new Paint();
     paint.setColor(1);
@@ -279,7 +278,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void shouldRecordText_charSequenceOverload() throws Exception {
+  public void shouldRecordText_charSequenceOverload() {
     Canvas canvas = new Canvas();
     Paint paint = new Paint();
     paint.setColor(1);
@@ -298,7 +297,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void drawCircle_shouldRecordCirclePaintHistoryEvents() throws Exception {
+  public void drawCircle_shouldRecordCirclePaintHistoryEvents() {
     Canvas canvas = new Canvas();
     Paint paint0 = new Paint();
     Paint paint1 = new Paint();
@@ -318,7 +317,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void drawArc_shouldRecordArcHistoryEvents() throws Exception {
+  public void drawArc_shouldRecordArcHistoryEvents() {
     Canvas canvas = new Canvas();
     RectF oval0 = new RectF();
     RectF oval1 = new RectF();
@@ -342,7 +341,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void getArcHistoryCount_shouldReturnTotalNumberOfDrawArcEvents() throws Exception {
+  public void getArcHistoryCount_shouldReturnTotalNumberOfDrawArcEvents() {
     Canvas canvas = new Canvas();
     canvas.drawArc(new RectF(), 0f, 0f, true, new Paint());
     canvas.drawArc(new RectF(), 0f, 0f, true, new Paint());
@@ -351,7 +350,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void getRectHistoryCount_shouldReturnTotalNumberOfDrawRectEvents() throws Exception {
+  public void getRectHistoryCount_shouldReturnTotalNumberOfDrawRectEvents() {
     Canvas canvas = new Canvas();
     canvas.drawRect(1f, 2f, 3f, 4f, new Paint());
     canvas.drawRect(1f, 2f, 3f, 4f, new Paint());
@@ -369,7 +368,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void getOvalHistoryCount_shouldReturnTotalNumberOfDrawOvalEvents() throws Exception {
+  public void getOvalHistoryCount_shouldReturnTotalNumberOfDrawOvalEvents() {
     Canvas canvas = new Canvas();
     canvas.drawOval(new RectF(), new Paint());
     canvas.drawOval(new RectF(), new Paint());
@@ -378,7 +377,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void getLineHistoryCount_shouldReturnTotalNumberOfDrawLineEvents() throws Exception {
+  public void getLineHistoryCount_shouldReturnTotalNumberOfDrawLineEvents() {
     Canvas canvas = new Canvas();
     canvas.drawLine(0f, 1f, 2f, 3f, new Paint());
     canvas.drawLine(0f, 1f, 2f, 3f, new Paint());
@@ -387,7 +386,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void drawLine_shouldRecordLineHistoryEvents() throws Exception {
+  public void drawLine_shouldRecordLineHistoryEvents() {
     Canvas canvas = new Canvas();
     Paint paint0 = new Paint();
     paint0.setColor(Color.RED);
@@ -416,7 +415,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void drawOval_shouldRecordOvalHistoryEvents() throws Exception {
+  public void drawOval_shouldRecordOvalHistoryEvents() {
     Canvas canvas = new Canvas();
     RectF oval0 = new RectF();
     RectF oval1 = new RectF();
@@ -437,7 +436,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void drawRect_shouldRecordRectHistoryEvents() throws Exception {
+  public void drawRect_shouldRecordRectHistoryEvents() {
     Canvas canvas = new Canvas();
     Paint paint0 = new Paint();
     paint0.setColor(Color.WHITE);
@@ -570,7 +569,7 @@ public class ShadowCanvasTest {
   }
 
   @Test
-  public void drawRect_withRectF() throws Exception {
+  public void drawRect_withRectF() {
     Canvas canvas = new Canvas();
     Paint paint = new Paint();
     paint.setColor(Color.WHITE);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptioningManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptioningManagerTest.java
index 778f96c35..682e4b18b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptioningManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptioningManagerTest.java
@@ -18,6 +18,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.Locale;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -32,7 +33,7 @@ import org.robolectric.annotation.Config;
 @Config(minSdk = KITKAT)
 public final class ShadowCaptioningManagerTest {
 
-  private TestCaptioningChangeListener captioningChangeListener =
+  private final TestCaptioningChangeListener captioningChangeListener =
       new TestCaptioningChangeListener();
 
   private static final int ENABLED = 1;
@@ -40,8 +41,9 @@ public final class ShadowCaptioningManagerTest {
 
   private CaptioningManager captioningManager;
   private Context context;
+  private AutoCloseable mock;
 
-  public class TestCaptioningChangeListener extends CaptioningChangeListener {
+  public static class TestCaptioningChangeListener extends CaptioningChangeListener {
     public boolean isEnabled = false;
     @Nullable public CaptionStyle captionStyle = null;
     @Nullable public Locale locale = null;
@@ -82,7 +84,7 @@ public final class ShadowCaptioningManagerTest {
 
   @Before
   public void setUp() {
-    MockitoAnnotations.initMocks(this);
+    mock = MockitoAnnotations.openMocks(this);
     captioningManager =
         (CaptioningManager)
             ApplicationProvider.getApplicationContext()
@@ -90,6 +92,11 @@ public final class ShadowCaptioningManagerTest {
     context = RuntimeEnvironment.getApplication();
   }
 
+  @After
+  public void tearDown() throws Exception {
+    mock.close();
+  }
+
   @Test
   public void isEnabled_enabledKeyTrue_returnsTrue() {
     Settings.Secure.putInt(
@@ -200,7 +207,7 @@ public final class ShadowCaptioningManagerTest {
   public void setSystemAudioCaptioningEnabled_updatesValue() {
     captioningManager.setSystemAudioCaptioningEnabled(true);
 
-    assertThat(captioningManager.isSystemAudioCaptioningEnabled()).isEqualTo(true);
+    assertThat(captioningManager.isSystemAudioCaptioningEnabled()).isTrue();
   }
 
   @Test
@@ -209,7 +216,7 @@ public final class ShadowCaptioningManagerTest {
     captioningManager.setSystemAudioCaptioningEnabled(false);
 
     shadowOf(Looper.getMainLooper()).idle();
-    assertThat(captioningChangeListener.systemAudioCaptioningEnabled).isEqualTo(false);
+    assertThat(captioningChangeListener.systemAudioCaptioningEnabled).isFalse();
   }
 
   @Test
@@ -217,7 +224,7 @@ public final class ShadowCaptioningManagerTest {
   public void setSystemAudioCaptioningUiEnabled_updatesValue() {
     captioningManager.setSystemAudioCaptioningUiEnabled(true);
 
-    assertThat(captioningManager.isSystemAudioCaptioningUiEnabled()).isEqualTo(true);
+    assertThat(captioningManager.isSystemAudioCaptioningUiEnabled()).isTrue();
   }
 
   @Test
@@ -226,7 +233,7 @@ public final class ShadowCaptioningManagerTest {
     captioningManager.setSystemAudioCaptioningUiEnabled(false);
 
     shadowOf(Looper.getMainLooper()).idle();
-    assertThat(captioningChangeListener.systemAudioCaptioningUiEnabled).isEqualTo(false);
+    assertThat(captioningChangeListener.systemAudioCaptioningUiEnabled).isFalse();
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureRequestBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureRequestBuilderTest.java
index 3364ebe71..4059c7f5d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureRequestBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureRequestBuilderTest.java
@@ -15,6 +15,7 @@ import android.os.Handler;
 import android.os.Looper;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -56,17 +57,17 @@ public class ShadowCaptureRequestBuilderTest {
 
   private class CameraStateCallback extends CameraDevice.StateCallback {
     @Override
-    public void onOpened(CameraDevice camera) {
+    public void onOpened(@Nonnull CameraDevice camera) {
       cameraDevice = camera;
     }
 
     @Override
-    public void onDisconnected(CameraDevice camera) {
+    public void onDisconnected(@Nonnull CameraDevice camera) {
       fail();
     }
 
     @Override
-    public void onError(CameraDevice camera, int error) {
+    public void onError(@Nonnull CameraDevice camera, int error) {
       fail();
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureResultTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureResultTest.java
index b77e8e5f5..fd551e866 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureResultTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureResultTest.java
@@ -28,7 +28,7 @@ public class ShadowCaptureResultTest {
   }
 
   @Test
-  public void testGetUnrecongizedKey() {
+  public void testGetUnrecognizedKey() {
     assertThat(captureResult.get(timestampKey)).isNull();
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowChoreographerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowChoreographerTest.java
index 20f2f9db2..7266b81da 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowChoreographerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowChoreographerTest.java
@@ -43,7 +43,7 @@ public class ShadowChoreographerTest {
   }
 
   @Test
-  public void setPaused_isPaused_doesntRunWhenClockAdancedLessThanFrameDelay() {
+  public void setPaused_isPaused_doesntRunWhenClockAdvancedLessThanFrameDelay() {
     ShadowChoreographer.setPaused(true);
     ShadowChoreographer.setFrameDelay(Duration.ofMillis(15));
     AtomicBoolean didRun = new AtomicBoolean();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowColorDisplayManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowColorDisplayManagerTest.java
index 96e5df550..3814acd41 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowColorDisplayManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowColorDisplayManagerTest.java
@@ -27,7 +27,7 @@ public class ShadowColorDisplayManagerTest {
   private static final String PACKAGE_NAME = "test_package_name";
 
   // Must be optional to avoid ClassNotFoundException
-  Optional<ColorDisplayManager> instance;
+  private Optional<ColorDisplayManager> instance;
 
   @Before
   public void setUp() throws Exception {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCompanionDeviceManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCompanionDeviceManagerTest.java
index 3f2ba4985..3e0d737eb 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCompanionDeviceManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCompanionDeviceManagerTest.java
@@ -18,6 +18,7 @@ import android.net.MacAddress;
 import android.os.Build.VERSION_CODES;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.concurrent.Executors;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -103,7 +104,7 @@ public class ShadowCompanionDeviceManagerTest {
     CompanionDeviceManager.Callback callback =
         new CompanionDeviceManager.Callback() {
           @Override
-          public void onDeviceFound(IntentSender chooserLauncher) {}
+          public void onDeviceFound(@Nonnull IntentSender chooserLauncher) {}
 
           @Override
           public void onFailure(CharSequence error) {}
@@ -166,7 +167,7 @@ public class ShadowCompanionDeviceManagerTest {
             .setNotifyOnDeviceNearby(false)
             .setApprovedMs(0)
             .setLastTimeConnectedMs(0);
-    Object associatedDeviceValue = null;
+    Object associatedDeviceValue;
     if (ReflectionHelpers.hasField(AssociationInfo.class, "mAssociatedDevice")) {
       try {
         Class<?> associatedDeviceClazz = Class.forName("android.companion.AssociatedDevice");
@@ -367,7 +368,7 @@ public class ShadowCompanionDeviceManagerTest {
   private CompanionDeviceManager.Callback createCallback() {
     return new CompanionDeviceManager.Callback() {
       @Override
-      public void onDeviceFound(IntentSender chooserLauncher) {}
+      public void onDeviceFound(@Nonnull IntentSender chooserLauncher) {}
 
       @Override
       public void onFailure(CharSequence error) {}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectionTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectionTest.java
index f92c651ce..4d8276939 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectionTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectionTest.java
@@ -24,9 +24,8 @@ public class ShadowConnectionTest {
 
     Optional<String> eventOptional = shadowOf(connection).getLastConnectionEvent();
 
-    assertThat(eventOptional.isPresent()).isTrue();
-
-    assertThat(eventOptional.get()).isEqualTo("TEST_EVENT");
+    assertThat(eventOptional).isPresent();
+    assertThat(eventOptional).hasValue("TEST_EVENT");
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java
index 49a6215b3..d63c575b3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java
@@ -35,6 +35,7 @@ import android.telephony.TelephonyManager;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.Arrays;
 import java.util.Map;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -299,13 +300,13 @@ public class ShadowConnectivityManagerTest {
 
     Map<Network, Boolean> reportedNetworks =
         shadowOf(connectivityManager).getReportedNetworkConnectivity();
-    assertThat(reportedNetworks.size()).isEqualTo(1);
+    assertThat(reportedNetworks).hasSize(1);
     assertThat(reportedNetworks.get(wifiNetwork)).isTrue();
 
     // Update the status.
     connectivityManager.reportNetworkConnectivity(wifiNetwork, false);
     reportedNetworks = shadowOf(connectivityManager).getReportedNetworkConnectivity();
-    assertThat(reportedNetworks.size()).isEqualTo(1);
+    assertThat(reportedNetworks).hasSize(1);
     assertThat(reportedNetworks.get(wifiNetwork)).isFalse();
   }
 
@@ -326,10 +327,10 @@ public class ShadowConnectivityManagerTest {
   private static ConnectivityManager.NetworkCallback createSimpleCallback() {
     return new ConnectivityManager.NetworkCallback() {
       @Override
-      public void onAvailable(Network network) {}
+      public void onAvailable(@Nonnull Network network) {}
 
       @Override
-      public void onLost(Network network) {}
+      public void onLost(@Nonnull Network network) {}
     };
   }
 
@@ -516,6 +517,7 @@ public class ShadowConnectivityManagerTest {
   }
 
   private static ConnectivityManager.OnNetworkActiveListener createSimpleOnNetworkActiveListener() {
+    //noinspection Convert2Lambda
     return new ConnectivityManager.OnNetworkActiveListener() {
       @Override
       public void onNetworkActive() {}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderOperationBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderOperationBuilderTest.java
index fab469528..c65904452 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderOperationBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderOperationBuilderTest.java
@@ -8,6 +8,7 @@ import android.content.ContentValues;
 import android.database.Cursor;
 import android.net.Uri;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import javax.annotation.Nonnull;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -39,7 +40,7 @@ public class ShadowContentProviderOperationBuilderTest {
 
           @Override
           public Cursor query(
-              Uri uri,
+              @Nonnull Uri uri,
               String[] projection,
               String selection,
               String[] selectionArgs,
@@ -48,23 +49,23 @@ public class ShadowContentProviderOperationBuilderTest {
           }
 
           @Override
-          public String getType(Uri uri) {
+          public String getType(@Nonnull Uri uri) {
             return null;
           }
 
           @Override
-          public Uri insert(Uri uri, ContentValues values) {
+          public Uri insert(@Nonnull Uri uri, ContentValues values) {
             return null;
           }
 
           @Override
-          public int delete(Uri uri, String selection, String[] selectionArgs) {
+          public int delete(@Nonnull Uri uri, String selection, String[] selectionArgs) {
             return 0;
           }
 
           @Override
           public int update(
-              Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+              @Nonnull Uri uri, ContentValues values, String selection, String[] selectionArgs) {
             request.uri = uri;
             request.values = values;
             request.selection = selection;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java
index e0ad9cb4a..620afbf62 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java
@@ -37,6 +37,7 @@ import android.database.ContentObserver;
 import android.database.Cursor;
 import android.database.MatrixCursor;
 import android.net.Uri;
+import android.os.Build;
 import android.os.Bundle;
 import android.os.CancellationSignal;
 import android.os.Handler;
@@ -55,9 +56,11 @@ import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -69,11 +72,13 @@ import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.fakes.BaseCursor;
+import org.robolectric.junit.rules.SetSystemPropertyRule;
 import org.robolectric.util.NamedStream;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowContentResolverTest {
   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();
+  @Rule public final SetSystemPropertyRule setSystemPropertyRule = new SetSystemPropertyRule();
 
   private static final Uri FAKE_URI =
       Uri.parse("content://robolectric").buildUpon().appendPath("fakepath").build();
@@ -90,8 +95,8 @@ public class ShadowContentResolverTest {
   public void setUp() {
     contentResolver = ApplicationProvider.getApplicationContext().getContentResolver();
     shadowContentResolver = shadowOf(contentResolver);
-    uri21 = Uri.parse(FAKE_URI.toString() + "/21");
-    uri22 = Uri.parse(FAKE_URI.toString() + "/22");
+    uri21 = Uri.parse(FAKE_URI + "/21");
+    uri22 = Uri.parse(FAKE_URI + "/22");
 
     a = new Account("a", "type");
     b = new Account("b", "type");
@@ -122,7 +127,7 @@ public class ShadowContentResolverTest {
 
           @Override
           public Cursor query(
-              Uri uri,
+              @Nonnull Uri uri,
               String[] projection,
               String selection,
               String[] selectionArgs,
@@ -131,23 +136,23 @@ public class ShadowContentResolverTest {
           }
 
           @Override
-          public Uri insert(Uri uri, ContentValues values) {
+          public Uri insert(@Nonnull Uri uri, ContentValues values) {
             return null;
           }
 
           @Override
-          public int delete(Uri uri, String selection, String[] selectionArgs) {
+          public int delete(@Nonnull Uri uri, String selection, String[] selectionArgs) {
             return -1;
           }
 
           @Override
           public int update(
-              Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+              @Nonnull Uri uri, ContentValues values, String selection, String[] selectionArgs) {
             return -1;
           }
 
           @Override
-          public String getType(Uri uri) {
+          public String getType(@Nonnull Uri uri) {
             return "mytype";
           }
         });
@@ -160,7 +165,7 @@ public class ShadowContentResolverTest {
     ContentValues contentValues = new ContentValues();
     contentValues.put("foo", "bar");
     contentResolver.insert(FAKE_URI, contentValues);
-    assertThat(shadowContentResolver.getInsertStatements().size()).isEqualTo(1);
+    assertThat(shadowContentResolver.getInsertStatements()).hasSize(1);
     assertThat(shadowContentResolver.getInsertStatements().get(0).getUri()).isEqualTo(FAKE_URI);
     assertThat(
             shadowContentResolver
@@ -173,7 +178,7 @@ public class ShadowContentResolverTest {
     contentValues = new ContentValues();
     contentValues.put("hello", "world");
     contentResolver.insert(FAKE_URI, contentValues);
-    assertThat(shadowContentResolver.getInsertStatements().size()).isEqualTo(2);
+    assertThat(shadowContentResolver.getInsertStatements()).hasSize(2);
     assertThat(
             shadowContentResolver
                 .getInsertStatements()
@@ -188,7 +193,7 @@ public class ShadowContentResolverTest {
     ContentValues contentValues = new ContentValues();
     contentValues.put("foo", "bar");
     contentResolver.update(FAKE_URI, contentValues, "robolectric", new String[] {"awesome"});
-    assertThat(shadowContentResolver.getUpdateStatements().size()).isEqualTo(1);
+    assertThat(shadowContentResolver.getUpdateStatements()).hasSize(1);
     assertThat(shadowContentResolver.getUpdateStatements().get(0).getUri()).isEqualTo(FAKE_URI);
     assertThat(
             shadowContentResolver
@@ -205,7 +210,7 @@ public class ShadowContentResolverTest {
     contentValues = new ContentValues();
     contentValues.put("hello", "world");
     contentResolver.update(FAKE_URI, contentValues, null, null);
-    assertThat(shadowContentResolver.getUpdateStatements().size()).isEqualTo(2);
+    assertThat(shadowContentResolver.getUpdateStatements()).hasSize(2);
     assertThat(shadowContentResolver.getUpdateStatements().get(1).getUri()).isEqualTo(FAKE_URI);
     assertThat(
             shadowContentResolver
@@ -232,23 +237,23 @@ public class ShadowContentResolverTest {
 
   @Test
   public void delete_shouldTrackDeletedUris() {
-    assertThat(shadowContentResolver.getDeletedUris().size()).isEqualTo(0);
+    assertThat(shadowContentResolver.getDeletedUris()).isEmpty();
 
     assertThat(contentResolver.delete(uri21, null, null)).isEqualTo(1);
     assertThat(shadowContentResolver.getDeletedUris()).contains(uri21);
-    assertThat(shadowContentResolver.getDeletedUris().size()).isEqualTo(1);
+    assertThat(shadowContentResolver.getDeletedUris()).hasSize(1);
 
     assertThat(contentResolver.delete(uri22, null, null)).isEqualTo(1);
     assertThat(shadowContentResolver.getDeletedUris()).contains(uri22);
-    assertThat(shadowContentResolver.getDeletedUris().size()).isEqualTo(2);
+    assertThat(shadowContentResolver.getDeletedUris()).hasSize(2);
   }
 
   @Test
   public void delete_shouldTrackDeletedStatements() {
-    assertThat(shadowContentResolver.getDeleteStatements().size()).isEqualTo(0);
+    assertThat(shadowContentResolver.getDeleteStatements()).isEmpty();
 
     assertThat(contentResolver.delete(uri21, "id", new String[] {"5"})).isEqualTo(1);
-    assertThat(shadowContentResolver.getDeleteStatements().size()).isEqualTo(1);
+    assertThat(shadowContentResolver.getDeleteStatements()).hasSize(1);
     assertThat(shadowContentResolver.getDeleteStatements().get(0).getUri()).isEqualTo(uri21);
     assertThat(shadowContentResolver.getDeleteStatements().get(0).getContentProvider()).isNull();
     assertThat(shadowContentResolver.getDeleteStatements().get(0).getWhere()).isEqualTo("id");
@@ -256,7 +261,7 @@ public class ShadowContentResolverTest {
         .isEqualTo("5");
 
     assertThat(contentResolver.delete(uri21, "foo", new String[] {"bar"})).isEqualTo(1);
-    assertThat(shadowContentResolver.getDeleteStatements().size()).isEqualTo(2);
+    assertThat(shadowContentResolver.getDeleteStatements()).hasSize(2);
     assertThat(shadowContentResolver.getDeleteStatements().get(1).getUri()).isEqualTo(uri21);
     assertThat(shadowContentResolver.getDeleteStatements().get(1).getWhere()).isEqualTo("foo");
     assertThat(shadowContentResolver.getDeleteStatements().get(1).getSelectionArgs()[0])
@@ -268,8 +273,7 @@ public class ShadowContentResolverTest {
     assertThat(shadowContentResolver.query(null, null, null, null, null)).isNull();
     BaseCursor cursor = new BaseCursor();
     shadowContentResolver.setCursor(cursor);
-    assertThat((BaseCursor) shadowContentResolver.query(null, null, null, null, null))
-        .isSameInstanceAs(cursor);
+    assertThat(shadowContentResolver.query(null, null, null, null, null)).isSameInstanceAs(cursor);
   }
 
   @Test
@@ -278,9 +282,7 @@ public class ShadowContentResolverTest {
         .isNull();
     BaseCursor cursor = new BaseCursor();
     shadowContentResolver.setCursor(cursor);
-    assertThat(
-            (BaseCursor)
-                shadowContentResolver.query(null, null, null, null, null, new CancellationSignal()))
+    assertThat(shadowContentResolver.query(null, null, null, null, null, new CancellationSignal()))
         .isSameInstanceAs(cursor);
   }
 
@@ -294,9 +296,9 @@ public class ShadowContentResolverTest {
     shadowContentResolver.setCursor(uri21, cursor21);
     shadowContentResolver.setCursor(uri22, cursor22);
 
-    assertThat((BaseCursor) shadowContentResolver.query(uri21, null, null, null, null))
+    assertThat(shadowContentResolver.query(uri21, null, null, null, null))
         .isSameInstanceAs(cursor21);
-    assertThat((BaseCursor) shadowContentResolver.query(uri22, null, null, null, null))
+    assertThat(shadowContentResolver.query(uri22, null, null, null, null))
         .isSameInstanceAs(cursor22);
   }
 
@@ -312,7 +314,7 @@ public class ShadowContentResolverTest {
     shadowContentResolver.setCursor(testCursor);
     Cursor cursor =
         shadowContentResolver.query(uri21, projection, selection, selectionArgs, sortOrder);
-    assertThat((QueryParamTrackingCursor) cursor).isEqualTo(testCursor);
+    assertThat(cursor).isEqualTo(testCursor);
     assertThat(testCursor.uri).isEqualTo(uri21);
     assertThat(testCursor.projection).isEqualTo(projection);
     assertThat(testCursor.selection).isEqualTo(selection);
@@ -335,7 +337,7 @@ public class ShadowContentResolverTest {
     QueryParamTrackingCursor testCursor = new QueryParamTrackingCursor();
     shadowContentResolver.setCursor(testCursor);
     Cursor cursor = shadowContentResolver.query(uri21, projection, queryArgs, null);
-    assertThat((QueryParamTrackingCursor) cursor).isEqualTo(testCursor);
+    assertThat(cursor).isEqualTo(testCursor);
     assertThat(testCursor.uri).isEqualTo(uri21);
     assertThat(testCursor.projection).isEqualTo(projection);
     assertThat(testCursor.selection).isEqualTo(selection);
@@ -397,7 +399,7 @@ public class ShadowContentResolverTest {
     ProviderInfo providerInfo = captor.getValue();
 
     assertThat(providerInfo.authority).isEqualTo("the-authority");
-    assertThat(providerInfo.grantUriPermissions).isEqualTo(true);
+    assertThat(providerInfo.grantUriPermissions).isTrue();
   }
 
   @Test(expected = UnsupportedOperationException.class)
@@ -488,17 +490,35 @@ public class ShadowContentResolverTest {
 
   @Test
   public void openOutputStream_withNoRealOrRegisteredProvider_doesNotThrow() throws Exception {
+    setSystemPropertyRule.set("robolectric.useLegacyContentProviderOpenOutputStream", "true");
     Uri uri = Uri.parse("content://invalidauthority/test/1");
     assertThat(contentResolver.openOutputStream(uri)).isNotNull();
   }
 
+  @Test
+  public void openOutputStream_noRegisteredContentProvider_canThrowOnSupply() {
+    final Uri uri = Uri.parse("content://unregisteredProvider/path");
+
+    assertThrows(FileNotFoundException.class, () -> contentResolver.openOutputStream(uri));
+  }
+
+  @Test
+  public void openOutputStream_withRealContentProvider_canThrowFileNotFoundException()
+      throws Exception {
+    File file = temporaryFolder.newFile();
+    file.setWritable(false);
+
+    Uri uri = Uri.fromFile(file);
+    assertThrows(FileNotFoundException.class, () -> contentResolver.openOutputStream(uri));
+  }
+
   @Test
   public void openOutputStream_withRealContentProvider_canReadBytesWrittenToOutputStream()
-      throws IOException, RemoteException {
+      throws IOException {
     Robolectric.setupContentProvider(MyContentProvider.class, AUTHORITY);
     Uri uri = Uri.parse("content://" + AUTHORITY + "/test/1");
 
-    // Write content through given outputstream
+    // Write content through given outputStream
     try (OutputStream outputStream = contentResolver.openOutputStream(uri)) {
       outputStream.write("foo".getBytes(UTF_8));
     }
@@ -523,7 +543,7 @@ public class ShadowContentResolverTest {
 
           @Override
           public String toString() {
-            return "outputstream for " + uri;
+            return "outputStream for " + uri;
           }
         };
 
@@ -533,7 +553,35 @@ public class ShadowContentResolverTest {
     contentResolver.openOutputStream(uri).write(5);
     assertThat(callCount.get()).isEqualTo(1);
 
-    contentResolver.openOutputStream(uri21).write(5);
+    // Write to a different uri should not increment the call count.
+    contentResolver.openOutputStream(Uri.fromFile(temporaryFolder.newFile())).write(5);
+    assertThat(callCount.get()).isEqualTo(1);
+  }
+
+  @Test
+  public void openOutputStream_withRegisteredContentProvider_canThrowFileNotFoundException() {
+    final Uri uri = Uri.parse("content://registeredProvider/path");
+
+    AtomicInteger callCount = new AtomicInteger();
+    OutputStream outputStream =
+        new OutputStream() {
+
+          @Override
+          public void write(int arg0) throws IOException {
+            callCount.incrementAndGet();
+            throw new FileNotFoundException();
+          }
+
+          @Override
+          public String toString() {
+            return "outputstream for " + uri;
+          }
+        };
+
+    shadowOf(contentResolver).registerOutputStream(uri, outputStream);
+
+    assertThat(callCount.get()).isEqualTo(0);
+    assertThrows(FileNotFoundException.class, () -> contentResolver.openOutputStream(uri).write(5));
     assertThat(callCount.get()).isEqualTo(1);
   }
 
@@ -549,26 +597,24 @@ public class ShadowContentResolverTest {
               streamCreateCount.incrementAndGet();
               AtomicBoolean isClosed = new AtomicBoolean();
               isClosed.set(false);
-              OutputStream outputStream =
-                  new OutputStream() {
-                    @Override
-                    public void close() {
-                      isClosed.set(true);
-                    }
-
-                    @Override
-                    public void write(int arg0) throws IOException {
-                      if (isClosed.get()) {
-                        throw new IOException();
-                      }
-                    }
-
-                    @Override
-                    public String toString() {
-                      return "outputstream for " + uri;
-                    }
-                  };
-              return outputStream;
+              return new OutputStream() {
+                @Override
+                public void close() {
+                  isClosed.set(true);
+                }
+
+                @Override
+                public void write(int arg0) throws IOException {
+                  if (isClosed.get()) {
+                    throw new IOException();
+                  }
+                }
+
+                @Override
+                public String toString() {
+                  return "outputStream for " + uri;
+                }
+              };
             });
 
     assertThat(streamCreateCount.get()).isEqualTo(0);
@@ -588,11 +634,11 @@ public class ShadowContentResolverTest {
 
   @Test
   public void openOutputStream_withModeWithRealContentProvider_canReadBytesWrittenToOutputStream()
-      throws IOException, RemoteException {
+      throws IOException {
     Robolectric.setupContentProvider(MyContentProvider.class, AUTHORITY);
     Uri uri = Uri.parse("content://" + AUTHORITY + "/test/1");
 
-    // Write content through given outputstream
+    // Write content through given outputStream
     try (OutputStream outputStream = contentResolver.openOutputStream(uri, "wt")) {
       outputStream.write("foo".getBytes(UTF_8));
     }
@@ -617,7 +663,7 @@ public class ShadowContentResolverTest {
 
           @Override
           public String toString() {
-            return "outputstream for " + uri;
+            return "outputStream for " + uri;
           }
         };
 
@@ -641,26 +687,24 @@ public class ShadowContentResolverTest {
               streamCreateCount.incrementAndGet();
               AtomicBoolean isClosed = new AtomicBoolean();
               isClosed.set(false);
-              OutputStream outputStream =
-                  new OutputStream() {
-                    @Override
-                    public void close() {
-                      isClosed.set(true);
-                    }
-
-                    @Override
-                    public void write(int arg0) throws IOException {
-                      if (isClosed.get()) {
-                        throw new IOException();
-                      }
-                    }
-
-                    @Override
-                    public String toString() {
-                      return "outputstream for " + uri;
-                    }
-                  };
-              return outputStream;
+              return new OutputStream() {
+                @Override
+                public void close() {
+                  isClosed.set(true);
+                }
+
+                @Override
+                public void write(int arg0) throws IOException {
+                  if (isClosed.get()) {
+                    throw new IOException();
+                  }
+                }
+
+                @Override
+                public String toString() {
+                  return "outputStream for " + uri;
+                }
+              };
             });
 
     assertThat(streamCreateCount.get()).isEqualTo(0);
@@ -674,20 +718,20 @@ public class ShadowContentResolverTest {
 
   @Test
   public void shouldTrackNotifiedUris() {
-    contentResolver.notifyChange(Uri.parse("foo"), null, true);
+    contentResolver.notifyChange(Uri.parse("foo"), null, false);
     contentResolver.notifyChange(Uri.parse("bar"), null);
 
-    assertThat(shadowContentResolver.getNotifiedUris().size()).isEqualTo(2);
+    assertThat(shadowContentResolver.getNotifiedUris()).hasSize(2);
     ShadowContentResolver.NotifiedUri uri = shadowContentResolver.getNotifiedUris().get(0);
 
     assertThat(uri.uri.toString()).isEqualTo("foo");
-    assertThat(uri.syncToNetwork).isTrue();
+    assertThat(uri.syncToNetwork).isFalse();
     assertThat(uri.observer).isNull();
 
     uri = shadowContentResolver.getNotifiedUris().get(1);
 
     assertThat(uri.uri.toString()).isEqualTo("bar");
-    assertThat(uri.syncToNetwork).isFalse();
+    assertThat(uri.syncToNetwork).isTrue();
     assertThat(uri.observer).isNull();
   }
 
@@ -697,7 +741,7 @@ public class ShadowContentResolverTest {
     contentResolver.notifyChange(Uri.parse("foo"), null, ContentResolver.NOTIFY_SYNC_TO_NETWORK);
     contentResolver.notifyChange(Uri.parse("bar"), null, ContentResolver.NOTIFY_UPDATE);
 
-    assertThat(shadowContentResolver.getNotifiedUris().size()).isEqualTo(2);
+    assertThat(shadowContentResolver.getNotifiedUris()).hasSize(2);
 
     ShadowContentResolver.NotifiedUri uri = shadowContentResolver.getNotifiedUris().get(0);
 
@@ -714,7 +758,38 @@ public class ShadowContentResolverTest {
     assertThat(uri.flags).isEqualTo(ContentResolver.NOTIFY_UPDATE);
   }
 
-  @SuppressWarnings("serial")
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.R)
+  public void notifyChangeCollection_shouldTrackNotifiedUris() {
+    contentResolver.notifyChange(
+        Arrays.asList(Uri.parse("foo"), Uri.parse("bar")), null, ContentResolver.NOTIFY_UPDATE);
+
+    List<ShadowContentResolver.NotifiedUri> notifiedUris = shadowContentResolver.getNotifiedUris();
+    assertThat(notifiedUris).hasSize(2);
+
+    ShadowContentResolver.NotifiedUri uri = notifiedUris.get(0);
+
+    assertThat(uri.uri.toString()).isEqualTo("foo");
+    assertThat(uri.syncToNetwork).isFalse();
+    assertThat(uri.observer).isNull();
+    assertThat(uri.flags).isEqualTo(ContentResolver.NOTIFY_UPDATE);
+
+    uri = notifiedUris.get(1);
+
+    assertThat(uri.uri.toString()).isEqualTo("bar");
+    assertThat(uri.syncToNetwork).isFalse();
+    assertThat(uri.observer).isNull();
+    assertThat(uri.flags).isEqualTo(ContentResolver.NOTIFY_UPDATE);
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.R)
+  public void notifyChangeEmptyCollection_shouldNotTrackNotifiedUris() {
+    contentResolver.notifyChange(Collections.emptyList(), null, ContentResolver.NOTIFY_UPDATE);
+
+    assertThat(shadowContentResolver.getNotifiedUris()).isEmpty();
+  }
+
   @Test
   public void applyBatchForRegisteredProvider()
       throws RemoteException, OperationApplicationException {
@@ -729,7 +804,7 @@ public class ShadowContentResolverTest {
 
           @Override
           public Cursor query(
-              Uri uri,
+              @Nonnull Uri uri,
               String[] projection,
               String selection,
               String[] selectionArgs,
@@ -741,25 +816,25 @@ public class ShadowContentResolverTest {
           }
 
           @Override
-          public String getType(Uri uri) {
+          public String getType(@Nonnull Uri uri) {
             return null;
           }
 
           @Override
-          public Uri insert(Uri uri, ContentValues values) {
+          public Uri insert(@Nonnull Uri uri, ContentValues values) {
             operations.add("insert");
             return ContentUris.withAppendedId(uri, 1);
           }
 
           @Override
-          public int delete(Uri uri, String selection, String[] selectionArgs) {
+          public int delete(@Nonnull Uri uri, String selection, String[] selectionArgs) {
             operations.add("delete");
             return 0;
           }
 
           @Override
           public int update(
-              Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+              @Nonnull Uri uri, ContentValues values, String selection, String[] selectionArgs) {
             operations.add("update");
             return 0;
           }
@@ -783,7 +858,7 @@ public class ShadowContentResolverTest {
     List<ContentProviderOperation> resultOperations =
         shadowContentResolver.getContentProviderOperations(AUTHORITY);
     assertThat(resultOperations).isNotNull();
-    assertThat(resultOperations.size()).isEqualTo(0);
+    assertThat(resultOperations).isEmpty();
 
     Uri uri = Uri.parse("content://org.robolectric");
     ArrayList<ContentProviderOperation> operations = new ArrayList<>();
@@ -831,7 +906,7 @@ public class ShadowContentResolverTest {
     ContentResolver.requestSync(b, AUTHORITY, new Bundle());
 
     List<SyncInfo> syncs = ContentResolver.getCurrentSyncs();
-    assertThat(syncs.size()).isEqualTo(2);
+    assertThat(syncs).hasSize(2);
 
     SyncInfo syncA = Iterables.find(syncs, s -> s.account.equals(a));
     assertThat(syncA.account).isEqualTo(a);
@@ -843,7 +918,7 @@ public class ShadowContentResolverTest {
 
     ContentResolver.cancelSync(a, AUTHORITY);
     List<SyncInfo> syncsAgain = ContentResolver.getCurrentSyncs();
-    assertThat(syncsAgain.size()).isEqualTo(1);
+    assertThat(syncsAgain).hasSize(1);
 
     SyncInfo firstAgain = syncsAgain.get(0);
     assertThat(firstAgain.account).isEqualTo(b);
@@ -851,7 +926,7 @@ public class ShadowContentResolverTest {
 
     ContentResolver.cancelSync(b, AUTHORITY);
     List<SyncInfo> s = ContentResolver.getCurrentSyncs();
-    assertThat(s.size()).isEqualTo(0);
+    assertThat(s).isEmpty();
   }
 
   @Test
@@ -962,11 +1037,11 @@ public class ShadowContentResolverTest {
 
   @Test
   public void shouldGetPeriodSyncs() {
-    assertThat(ContentResolver.getPeriodicSyncs(a, AUTHORITY).size()).isEqualTo(0);
+    assertThat(ContentResolver.getPeriodicSyncs(a, AUTHORITY)).isEmpty();
     ContentResolver.addPeriodicSync(a, AUTHORITY, new Bundle(), 6000L);
 
     List<PeriodicSync> syncs = ContentResolver.getPeriodicSyncs(a, AUTHORITY);
-    assertThat(syncs.size()).isEqualTo(1);
+    assertThat(syncs).hasSize(1);
 
     PeriodicSync first = syncs.get(0);
     assertThat(first.account).isEqualTo(a);
@@ -1013,7 +1088,7 @@ public class ShadowContentResolverTest {
 
           @Override
           public Cursor query(
-              Uri uri,
+              @Nonnull Uri uri,
               String[] projection,
               String selection,
               String[] selectionArgs,
@@ -1022,23 +1097,23 @@ public class ShadowContentResolverTest {
           }
 
           @Override
-          public Uri insert(Uri uri, ContentValues values) {
+          public Uri insert(@Nonnull Uri uri, ContentValues values) {
             return null;
           }
 
           @Override
-          public int delete(Uri uri, String selection, String[] selectionArgs) {
+          public int delete(@Nonnull Uri uri, String selection, String[] selectionArgs) {
             return -1;
           }
 
           @Override
           public int update(
-              Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+              @Nonnull Uri uri, ContentValues values, String selection, String[] selectionArgs) {
             return -1;
           }
 
           @Override
-          public String getType(Uri uri) {
+          public String getType(@Nonnull Uri uri) {
             return null;
           }
         });
@@ -1112,7 +1187,7 @@ public class ShadowContentResolverTest {
   }
 
   @Test
-  public void shouldNotifyChildContentObservers() throws Exception {
+  public void shouldNotifyChildContentObservers() {
     TestContentObserver co1 = new TestContentObserver(null);
     TestContentObserver co2 = new TestContentObserver(null);
 
@@ -1179,8 +1254,7 @@ public class ShadowContentResolverTest {
   }
 
   @Test
-  public void openTypedAssetFileDescriptor_shouldOpenDescriptor()
-      throws IOException, RemoteException {
+  public void openTypedAssetFileDescriptor_shouldOpenDescriptor() throws IOException {
     Robolectric.setupContentProvider(MyContentProvider.class, AUTHORITY);
 
     try (AssetFileDescriptor afd =
@@ -1290,32 +1364,34 @@ public class ShadowContentResolverTest {
     }
 
     @Override
-    public Cursor query(Uri uri, String[] strings, String s, String[] strings1, String s1) {
+    public Cursor query(
+        @Nonnull Uri uri, String[] strings, String s, String[] strings1, String s1) {
       return null;
     }
 
     @Override
-    public String getType(Uri uri) {
+    public String getType(@Nonnull Uri uri) {
       return null;
     }
 
     @Override
-    public Uri insert(Uri uri, ContentValues contentValues) {
+    public Uri insert(@Nonnull Uri uri, ContentValues contentValues) {
       return null;
     }
 
     @Override
-    public int delete(Uri uri, String s, String[] strings) {
+    public int delete(@Nonnull Uri uri, String s, String[] strings) {
       return 0;
     }
 
     @Override
-    public int update(Uri uri, ContentValues contentValues, String s, String[] strings) {
+    public int update(@Nonnull Uri uri, ContentValues contentValues, String s, String[] strings) {
       return 0;
     }
 
     @Override
-    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
+    public ParcelFileDescriptor openFile(@Nonnull Uri uri, @Nonnull String mode)
+        throws FileNotFoundException {
       final File file =
           new File(ApplicationProvider.getApplicationContext().getFilesDir(), "test_file");
       try {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubClientTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubClientTest.java
index d2d663eae..0630b45ff 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubClientTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubClientTest.java
@@ -101,8 +101,6 @@ public final class ShadowContextHubClientTest {
     ContextHubManager contextHubManager = context.getSystemService(ContextHubManager.class);
     ContextHubInfo contextHubInfo = contextHubManager.getContextHubs().get(0);
     ContextHubClientCallback contextHubClientCallback = new ContextHubClientCallback();
-    ContextHubClient contextHubClient =
-        contextHubManager.createClient(contextHubInfo, contextHubClientCallback);
-    return contextHubClient;
+    return contextHubManager.createClient(contextHubInfo, contextHubClientCallback);
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextWrapperTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextWrapperTest.java
index fb7ded1fd..26f30dc7a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextWrapperTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextWrapperTest.java
@@ -7,7 +7,6 @@ import static android.os.Build.VERSION_CODES.P;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertTrue;
 import static org.robolectric.Robolectric.buildActivity;
 import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.annotation.LooperMode.Mode.LEGACY;
@@ -27,6 +26,7 @@ import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.net.Uri;
+import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.HandlerThread;
@@ -75,7 +75,16 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void sendBroadcast_shouldSendToManifestReceiver() throws Exception {
+  @Config(manifest = "TestAndroidManifestWithTargetSdk34.xml")
+  public void shouldReturnTargetSdkVersionFromConfigManifest() {
+    assertThat(RuntimeEnvironment.getApplication().getApplicationInfo().targetSdkVersion)
+        .isEqualTo(34);
+    assertThat(ApplicationProvider.getApplicationContext().getApplicationInfo().targetSdkVersion)
+        .isEqualTo(34);
+  }
+
+  @Test
+  public void sendBroadcast_shouldSendToManifestReceiver() {
     ConfigTestReceiver receiver = getReceiverOfClass(ConfigTestReceiver.class);
 
     contextWrapper.sendBroadcast(new Intent(context, ConfigTestReceiver.class));
@@ -85,7 +94,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void sendBroadcastWithData_shouldSendToManifestReceiver() throws Exception {
+  public void sendBroadcastWithData_shouldSendToManifestReceiver() {
     ConfigTestReceiver receiver = getReceiverOfClass(ConfigTestReceiver.class);
 
     contextWrapper.sendBroadcast(
@@ -110,7 +119,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void registerReceiver_shouldRegisterForAllIntentFilterActions() throws Exception {
+  public void registerReceiver_shouldRegisterForAllIntentFilterActions() {
     BroadcastReceiver receiver = broadcastReceiver("Larry");
     contextWrapper.registerReceiver(receiver, intentFilter("foo", "baz"));
 
@@ -126,7 +135,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void sendBroadcast_shouldSendIntentToEveryInterestedReceiver() throws Exception {
+  public void sendBroadcast_shouldSendIntentToEveryInterestedReceiver() {
     BroadcastReceiver larryReceiver = broadcastReceiver("Larry");
     contextWrapper.registerReceiver(larryReceiver, intentFilter("foo", "baz"));
 
@@ -172,18 +181,36 @@ public class ShadowContextWrapperTest {
   @Test
   public void sendBroadcast_shouldOnlySendIntentWhenReceiverHasPermission() throws Exception {
     Context receiverWithPermission = contextWithPermission("larryPackage", "larryPermission");
-    receiverWithPermission.registerReceiver(
-        broadcastReceiver("Larry"),
-        intentFilter("foo"),
-        /* broadcastPermission= */ null,
-        /* scheduler= */ null);
+    if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
+      receiverWithPermission.registerReceiver(
+          broadcastReceiver("Larry"),
+          intentFilter("foo"),
+          /* broadcastPermission= */ null,
+          /* scheduler= */ null,
+          Context.RECEIVER_NOT_EXPORTED);
+    } else {
+      receiverWithPermission.registerReceiver(
+          broadcastReceiver("Larry"),
+          intentFilter("foo"),
+          /* broadcastPermission= */ null,
+          /* scheduler= */ null);
+    }
 
     Context receiverWithoutPermission = contextWithPermission("bobPackage", "bobPermission");
-    receiverWithoutPermission.registerReceiver(
-        broadcastReceiver("Bob"),
-        intentFilter("foo"),
-        /* broadcastPermission= */ null,
-        /* scheduler= */ null);
+    if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
+      receiverWithoutPermission.registerReceiver(
+          broadcastReceiver("Bob"),
+          intentFilter("foo"),
+          /* broadcastPermission= */ null,
+          /* scheduler= */ null,
+          Context.RECEIVER_NOT_EXPORTED);
+    } else {
+      receiverWithoutPermission.registerReceiver(
+          broadcastReceiver("Bob"),
+          intentFilter("foo"),
+          /* broadcastPermission= */ null,
+          /* scheduler= */ null);
+    }
 
     contextWrapper.sendBroadcast(new Intent("foo"), /* receiverPermission= */ "larryPermission");
 
@@ -241,8 +268,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void sendBroadcast_shouldSendIntentUsingHandlerIfOneIsProvided()
-      throws InterruptedException {
+  public void sendBroadcast_shouldSendIntentUsingHandlerIfOneIsProvided() {
     HandlerThread handlerThread = new HandlerThread("test");
     handlerThread.start();
 
@@ -273,7 +299,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void sendBroadcast_withClassSet_shouldSendIntentToSpecifiedReceiver() throws Exception {
+  public void sendBroadcast_withClassSet_shouldSendIntentToSpecifiedReceiver() {
     BroadcastReceiver larryReceiver =
         new BroadcastReceiver() {
           @Override
@@ -293,7 +319,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void sendOrderedBroadcast_shouldReturnValues() throws Exception {
+  public void sendOrderedBroadcast_shouldReturnValues() {
     String action = "test";
 
     IntentFilter lowFilter = new IntentFilter(action);
@@ -314,7 +340,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void sendOrderedBroadcastAsUser_shouldReturnValues() throws Exception {
+  public void sendOrderedBroadcastAsUser_shouldReturnValues() {
     String action = "test";
 
     IntentFilter lowFilter = new IntentFilter(action);
@@ -336,7 +362,7 @@ public class ShadowContextWrapperTest {
 
   @Test
   @Config(minSdk = M)
-  public void sendOrderedBroadcastAsUser_withAppOp_shouldReturnValues() throws Exception {
+  public void sendOrderedBroadcastAsUser_withAppOp_shouldReturnValues() {
     String action = "test";
 
     IntentFilter lowFilter = new IntentFilter(action);
@@ -370,7 +396,7 @@ public class ShadowContextWrapperTest {
 
   @Test
   @Config(minSdk = M)
-  public void sendOrderedBroadcastAsUser_withAppOpAndOptions_shouldReturnValues() throws Exception {
+  public void sendOrderedBroadcastAsUser_withAppOpAndOptions_shouldReturnValues() {
     String action = "test";
 
     IntentFilter lowFilter = new IntentFilter(action);
@@ -405,7 +431,7 @@ public class ShadowContextWrapperTest {
 
   private static final class FooReceiver extends BroadcastReceiver {
     private int resultCode;
-    private SettableFuture<Void> settableFuture = SettableFuture.create();
+    private final SettableFuture<Void> settableFuture = SettableFuture.create();
 
     @Override
     public void onReceive(Context context, Intent intent) {
@@ -458,7 +484,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void sendOrderedBroadcast_shouldSendByPriority() throws Exception {
+  public void sendOrderedBroadcast_shouldSendByPriority() {
     String action = "test";
 
     IntentFilter lowFilter = new IntentFilter(action);
@@ -477,7 +503,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void orderedBroadcasts_shouldAbort() throws Exception {
+  public void orderedBroadcasts_shouldAbort() {
     String action = "test";
 
     IntentFilter lowFilter = new IntentFilter(action);
@@ -502,7 +528,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void unregisterReceiver_shouldUnregisterReceiver() throws Exception {
+  public void unregisterReceiver_shouldUnregisterReceiver() {
     BroadcastReceiver receiver = broadcastReceiver("Larry");
 
     contextWrapper.registerReceiver(receiver, intentFilter("foo", "baz"));
@@ -513,14 +539,12 @@ public class ShadowContextWrapperTest {
   }
 
   @Test(expected = IllegalArgumentException.class)
-  public void unregisterReceiver_shouldThrowExceptionWhenReceiverIsNotRegistered()
-      throws Exception {
+  public void unregisterReceiver_shouldThrowExceptionWhenReceiverIsNotRegistered() {
     contextWrapper.unregisterReceiver(new AppWidgetProvider());
   }
 
   @Test
-  public void broadcastReceivers_shouldBeSharedAcrossContextsPerApplicationContext()
-      throws Exception {
+  public void broadcastReceivers_shouldBeSharedAcrossContextsPerApplicationContext() {
     BroadcastReceiver receiver = broadcastReceiver("Larry");
 
     Application application = ApplicationProvider.getApplicationContext();
@@ -543,7 +567,7 @@ public class ShadowContextWrapperTest {
     contextWrapper.sendBroadcast(broadcastIntent);
 
     List<Intent> broadcastIntents = shadowOf(contextWrapper).getBroadcastIntents();
-    assertTrue(broadcastIntents.size() == 1);
+    assertEquals(1, broadcastIntents.size());
     assertEquals(broadcastIntent, broadcastIntents.get(0));
   }
 
@@ -605,7 +629,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void shouldReturnSameApplicationEveryTime() throws Exception {
+  public void shouldReturnSameApplicationEveryTime() {
     Activity activity = new Activity();
     assertThat(activity.getApplication()).isSameInstanceAs(activity.getApplication());
 
@@ -613,7 +637,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void shouldReturnSameApplicationContextEveryTime() throws Exception {
+  public void shouldReturnSameApplicationContextEveryTime() {
     Activity activity = Robolectric.setupActivity(Activity.class);
     assertThat(activity.getApplicationContext()).isSameInstanceAs(activity.getApplicationContext());
 
@@ -622,8 +646,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void shouldReturnApplicationContext_forViewContextInflatedWithApplicationContext()
-      throws Exception {
+  public void shouldReturnApplicationContext_forViewContextInflatedWithApplicationContext() {
     View view =
         LayoutInflater.from(ApplicationProvider.getApplicationContext())
             .inflate(R.layout.custom_layout, null);
@@ -633,7 +656,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void shouldReturnSameContentResolverEveryTime() throws Exception {
+  public void shouldReturnSameContentResolverEveryTime() {
     Activity activity = Robolectric.setupActivity(Activity.class);
     assertThat(activity.getContentResolver()).isSameInstanceAs(activity.getContentResolver());
 
@@ -642,93 +665,93 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void shouldReturnSameLocationManagerEveryTime() throws Exception {
+  public void shouldReturnSameLocationManagerEveryTime() {
     assertSameInstanceEveryTime(Context.LOCATION_SERVICE);
   }
 
   @Test
-  public void shouldReturnSameWifiManagerEveryTime() throws Exception {
+  public void shouldReturnSameWifiManagerEveryTime() {
     assertSameInstanceEveryTime(Context.WIFI_SERVICE);
   }
 
   @Test
-  public void shouldReturnSameAlarmServiceEveryTime() throws Exception {
+  public void shouldReturnSameAlarmServiceEveryTime() {
     assertSameInstanceEveryTime(Context.ALARM_SERVICE);
   }
 
   @Test
   @Config(minSdk = 23)
   public void checkSelfPermission() {
-    assertThat(contextWrapper.checkSelfPermission("MY_PERMISSON"))
+    assertThat(contextWrapper.checkSelfPermission("MY_PERMISSION"))
         .isEqualTo(PackageManager.PERMISSION_DENIED);
 
-    shadowContextWrapper.grantPermissions("MY_PERMISSON");
+    shadowContextWrapper.grantPermissions("MY_PERMISSION");
 
-    assertThat(contextWrapper.checkSelfPermission("MY_PERMISSON"))
+    assertThat(contextWrapper.checkSelfPermission("MY_PERMISSION"))
         .isEqualTo(PackageManager.PERMISSION_GRANTED);
-    assertThat(contextWrapper.checkSelfPermission("UNKNOWN_PERMISSON"))
+    assertThat(contextWrapper.checkSelfPermission("UNKNOWN_PERMISSION"))
         .isEqualTo(PackageManager.PERMISSION_DENIED);
   }
 
   @Test
   public void checkPermission_denied() {
-    assertThat(contextWrapper.checkPermission("MY_PERMISSON", /* pid= */ 1, /* uid= */ 1))
+    assertThat(contextWrapper.checkPermission("MY_PERMISSION", /* pid= */ 1, /* uid= */ 1))
         .isEqualTo(PackageManager.PERMISSION_DENIED);
 
-    assertThat(contextWrapper.checkPermission("MY_PERMISSON", /* pid= */ -1, /* uid= */ 1))
+    assertThat(contextWrapper.checkPermission("MY_PERMISSION", /* pid= */ -1, /* uid= */ 1))
         .isEqualTo(PackageManager.PERMISSION_DENIED);
   }
 
   @Test
   public void checkPermission_granted() {
-    shadowContextWrapper.grantPermissions(1, 1, "MY_PERMISSON");
+    shadowContextWrapper.grantPermissions(1, 1, "MY_PERMISSION");
 
-    assertThat(contextWrapper.checkPermission("MY_PERMISSON", /* pid= */ 1, /* uid= */ 1))
+    assertThat(contextWrapper.checkPermission("MY_PERMISSION", /* pid= */ 1, /* uid= */ 1))
         .isEqualTo(PackageManager.PERMISSION_GRANTED);
 
-    assertThat(contextWrapper.checkPermission("MY_PERMISSON", /* pid= */ 2, /* uid= */ 1))
+    assertThat(contextWrapper.checkPermission("MY_PERMISSION", /* pid= */ 2, /* uid= */ 1))
         .isEqualTo(PackageManager.PERMISSION_DENIED);
 
-    assertThat(contextWrapper.checkPermission("MY_PERMISSON", /* pid= */ -1, /* uid= */ 1))
+    assertThat(contextWrapper.checkPermission("MY_PERMISSION", /* pid= */ -1, /* uid= */ 1))
         .isEqualTo(PackageManager.PERMISSION_GRANTED);
   }
 
   @Test
   @Config(minSdk = 23)
   public void checkAdditionalSelfPermission() {
-    shadowContextWrapper.grantPermissions("MY_PERMISSON");
-    assertThat(contextWrapper.checkSelfPermission("MY_PERMISSON"))
+    shadowContextWrapper.grantPermissions("MY_PERMISSION");
+    assertThat(contextWrapper.checkSelfPermission("MY_PERMISSION"))
         .isEqualTo(PackageManager.PERMISSION_GRANTED);
-    assertThat(contextWrapper.checkSelfPermission("ANOTHER_PERMISSON"))
+    assertThat(contextWrapper.checkSelfPermission("ANOTHER_PERMISSION"))
         .isEqualTo(PackageManager.PERMISSION_DENIED);
 
-    shadowContextWrapper.grantPermissions("ANOTHER_PERMISSON");
-    assertThat(contextWrapper.checkSelfPermission("ANOTHER_PERMISSON"))
+    shadowContextWrapper.grantPermissions("ANOTHER_PERMISSION");
+    assertThat(contextWrapper.checkSelfPermission("ANOTHER_PERMISSION"))
         .isEqualTo(PackageManager.PERMISSION_GRANTED);
   }
 
   @Test
   @Config(minSdk = 23)
   public void revokeSelfPermission() {
-    shadowContextWrapper.grantPermissions("MY_PERMISSON");
+    shadowContextWrapper.grantPermissions("MY_PERMISSION");
 
-    assertThat(contextWrapper.checkSelfPermission("MY_PERMISSON"))
+    assertThat(contextWrapper.checkSelfPermission("MY_PERMISSION"))
         .isEqualTo(PackageManager.PERMISSION_GRANTED);
-    shadowContextWrapper.denyPermissions("MY_PERMISSON");
+    shadowContextWrapper.denyPermissions("MY_PERMISSION");
 
-    assertThat(contextWrapper.checkSelfPermission("MY_PERMISSON"))
+    assertThat(contextWrapper.checkSelfPermission("MY_PERMISSION"))
         .isEqualTo(PackageManager.PERMISSION_DENIED);
   }
 
   @Test
   public void revokePermissionUidPid() {
-    shadowContextWrapper.grantPermissions(1, 1, "MY_PERMISSON");
+    shadowContextWrapper.grantPermissions(1, 1, "MY_PERMISSION");
 
-    assertThat(contextWrapper.checkPermission("MY_PERMISSON", 1, 1))
+    assertThat(contextWrapper.checkPermission("MY_PERMISSION", 1, 1))
         .isEqualTo(PackageManager.PERMISSION_GRANTED);
-    shadowContextWrapper.denyPermissions(1, 1, "MY_PERMISSON");
+    shadowContextWrapper.denyPermissions(1, 1, "MY_PERMISSION");
 
-    assertThat(contextWrapper.checkPermission("MY_PERMISSON", 1, 1))
+    assertThat(contextWrapper.checkPermission("MY_PERMISSION", 1, 1))
         .isEqualTo(PackageManager.PERMISSION_DENIED);
   }
 
@@ -849,8 +872,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void checkCallingPermissionsShouldReturnPermissionGrantedToAddedPermissions()
-      throws Exception {
+  public void checkCallingPermissionsShouldReturnPermissionGrantedToAddedPermissions() {
     shadowOf(contextWrapper).grantPermissions("foo", "bar");
     assertThat(contextWrapper.checkCallingPermission("foo")).isEqualTo(PERMISSION_GRANTED);
     assertThat(contextWrapper.checkCallingPermission("bar")).isEqualTo(PERMISSION_GRANTED);
@@ -858,8 +880,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void checkCallingOrSelfPermissionsShouldReturnPermissionGrantedToAddedPermissions()
-      throws Exception {
+  public void checkCallingOrSelfPermissionsShouldReturnPermissionGrantedToAddedPermissions() {
     shadowOf(contextWrapper).grantPermissions("foo", "bar");
     assertThat(contextWrapper.checkCallingOrSelfPermission("foo")).isEqualTo(PERMISSION_GRANTED);
     assertThat(contextWrapper.checkCallingOrSelfPermission("bar")).isEqualTo(PERMISSION_GRANTED);
@@ -867,8 +888,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void checkCallingPermission_shouldReturnPermissionDeniedForRemovedPermissions()
-      throws Exception {
+  public void checkCallingPermission_shouldReturnPermissionDeniedForRemovedPermissions() {
     shadowOf(contextWrapper).grantPermissions("foo", "bar");
     shadowOf(contextWrapper).denyPermissions("foo", "qux");
     assertThat(contextWrapper.checkCallingPermission("foo")).isEqualTo(PERMISSION_DENIED);
@@ -878,8 +898,7 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  public void checkCallingOrSelfPermission_shouldReturnPermissionDeniedForRemovedPermissions()
-      throws Exception {
+  public void checkCallingOrSelfPermission_shouldReturnPermissionDeniedForRemovedPermissions() {
     shadowOf(contextWrapper).grantPermissions("foo", "bar");
     shadowOf(contextWrapper).denyPermissions("foo", "qux");
     assertThat(contextWrapper.checkCallingOrSelfPermission("foo")).isEqualTo(PERMISSION_DENIED);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCookieManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCookieManagerTest.java
index 07d1eb08a..944793622 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCookieManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCookieManagerTest.java
@@ -124,12 +124,12 @@ public class ShadowCookieManagerTest {
   @Test
   public void shouldHaveCookieWhenCookieIsSet() {
     cookieManager.setCookie(url, "name=value; Expires=Wed, 09 Jun 2121 10:18:14 GMT");
-    assertThat(cookieManager.hasCookies()).isEqualTo(true);
+    assertThat(cookieManager.hasCookies()).isTrue();
   }
 
   @Test
   public void shouldNotHaveCookieWhenCookieIsNotSet() {
-    assertThat(cookieManager.hasCookies()).isEqualTo(false);
+    assertThat(cookieManager.hasCookies()).isFalse();
   }
 
   @Test
@@ -169,7 +169,7 @@ public class ShadowCookieManagerTest {
   }
 
   @Test
-  public void shouldSetCookieWithInvalidExpiesValue() {
+  public void shouldSetCookieWithInvalidExpiresValue() {
     cookieManager.setCookie(httpUrl, "name=value; Expires=3234asdfasdf10:18:14 GMT");
     assertThat(cookieManager.getCookie(url)).isEqualTo("name=value");
   }
@@ -191,7 +191,7 @@ public class ShadowCookieManagerTest {
     cookieManager.setAcceptCookie(false);
     cookieManager.setCookie(httpUrl, "name=value; Expires=3234asdfasdf10:18:14 GMT");
     assertThat(cookieManager.getCookie(url)).isEqualTo("name=value");
-    assertThat(cookieManager.acceptCookie()).isEqualTo(false);
+    assertThat(cookieManager.acceptCookie()).isFalse();
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCountDownTimerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCountDownTimerTest.java
index ded004594..2f580b92e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCountDownTimerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCountDownTimerTest.java
@@ -43,7 +43,7 @@ public class ShadowCountDownTimerTest {
           }
 
           @Override
-          public void onTick(long millisUnitilFinished) {
+          public void onTick(long millisUntilFinished) {
             message = MESSAGE_TICK;
           }
         };
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorAdapterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorAdapterTest.java
index 598ec2579..4d5f034d0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorAdapterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorAdapterTest.java
@@ -88,7 +88,7 @@ public class ShadowCursorAdapterTest {
   }
 
   @Test
-  public void shouldNotErrorOnCursorChangeWhenNoFlagsAreSet() throws Exception {
+  public void shouldNotErrorOnCursorChangeWhenNoFlagsAreSet() {
     try (Cursor newCursor = database.rawQuery("SELECT * FROM table_name;", null)) {
       adapter = new TestAdapterWithFlags(curs, 0);
       adapter.changeCursor(newCursor);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDeviceConfigTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDeviceConfigTest.java
index 909c4b52b..d796c6b24 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDeviceConfigTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDeviceConfigTest.java
@@ -52,20 +52,12 @@ public class ShadowDeviceConfigTest {
 
   @Test
   public void getProperty_nullNamespace() {
-    assertThrows(
-        NullPointerException.class,
-        () -> {
-          DeviceConfig.getProperty(null, KEY);
-        });
+    assertThrows(NullPointerException.class, () -> DeviceConfig.getProperty(null, KEY));
   }
 
   @Test
   public void getProperty_nullName() {
-    assertThrows(
-        NullPointerException.class,
-        () -> {
-          DeviceConfig.getProperty(NAMESPACE, null);
-        });
+    assertThrows(NullPointerException.class, () -> DeviceConfig.getProperty(NAMESPACE, null));
   }
 
   @Test
@@ -104,10 +96,7 @@ public class ShadowDeviceConfigTest {
   @Test
   public void getString_nullName() {
     assertThrows(
-        NullPointerException.class,
-        () -> {
-          DeviceConfig.getString(NAMESPACE, null, "defaultValue");
-        });
+        NullPointerException.class, () -> DeviceConfig.getString(NAMESPACE, null, "defaultValue"));
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java
index f6c1bd9f0..54f4e62ea 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java
@@ -28,6 +28,7 @@ import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static android.os.Build.VERSION_CODES.VANILLA_ICE_CREAM;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.fail;
@@ -505,7 +506,7 @@ public final class ShadowDevicePolicyManagerTest {
 
     // Delegate DELEGATION_PACKAGE_ACCESS scope to an app but not caller
     String delegatedApp = "com.example.not.caller";
-    List<String> scopes = Arrays.asList(DevicePolicyManager.DELEGATION_PACKAGE_ACCESS);
+    List<String> scopes = Collections.singletonList(DevicePolicyManager.DELEGATION_PACKAGE_ACCESS);
     devicePolicyManager.setDelegatedScopes(testComponent, delegatedApp, scopes);
 
     // Then DevicePolicyManager#setApplicationHidden should fail with SecurityException
@@ -534,7 +535,7 @@ public final class ShadowDevicePolicyManagerTest {
     // Delegate DELEGATION_PACKAGE_ACCESS scope to another app such that the delegated app
     // has the access to call setApplicationHidden
     String delegatedApp = context.getPackageName();
-    List<String> scopes = Arrays.asList(DevicePolicyManager.DELEGATION_PACKAGE_ACCESS);
+    List<String> scopes = Collections.singletonList(DevicePolicyManager.DELEGATION_PACKAGE_ACCESS);
     devicePolicyManager.setDelegatedScopes(testComponent, delegatedApp, scopes);
 
     // Then DevicePolicyManager#setApplicationHidden is called to hide the app,
@@ -790,7 +791,8 @@ public final class ShadowDevicePolicyManagerTest {
 
     // Delegate DELEGATION_APP_RESTRICTIONS scope to an app but not caller
     String delegatedApp = "com.example.not.caller";
-    List<String> scopes = Arrays.asList(DevicePolicyManager.DELEGATION_APP_RESTRICTIONS);
+    List<String> scopes =
+        Collections.singletonList(DevicePolicyManager.DELEGATION_APP_RESTRICTIONS);
     devicePolicyManager.setDelegatedScopes(testComponent, delegatedApp, scopes);
 
     // Then DevicePolicyManager#setApplicationRestrictions should fail with SecurityException
@@ -817,7 +819,8 @@ public final class ShadowDevicePolicyManagerTest {
     // Delegate DELEGATION_APP_RESTRICTIONS scope to another app such that the delegated app
     // has the access to call setApplicationRestriction
     String delegatedApp = context.getPackageName();
-    List<String> scopes = Arrays.asList(DevicePolicyManager.DELEGATION_APP_RESTRICTIONS);
+    List<String> scopes =
+        Collections.singletonList(DevicePolicyManager.DELEGATION_APP_RESTRICTIONS);
     devicePolicyManager.setDelegatedScopes(testComponent, delegatedApp, scopes);
 
     // WHEN DevicePolicyManager#setApplicationRestrictions is called to set the restrictions
@@ -851,11 +854,13 @@ public final class ShadowDevicePolicyManagerTest {
     shadowOf(devicePolicyManager).setDeviceOwner(testComponent);
 
     // GIVEN the caller has delegated scopes
-    List<String> initialScopes = Arrays.asList(DevicePolicyManager.DELEGATION_APP_RESTRICTIONS);
+    List<String> initialScopes =
+        Collections.singletonList(DevicePolicyManager.DELEGATION_APP_RESTRICTIONS);
     devicePolicyManager.setDelegatedScopes(testComponent, "com.example.app", initialScopes);
 
     // WHEN setDelegatedScopes is called again
-    List<String> newScopes = Arrays.asList(DevicePolicyManager.DELEGATION_ENABLE_SYSTEM_APP);
+    List<String> newScopes =
+        Collections.singletonList(DevicePolicyManager.DELEGATION_ENABLE_SYSTEM_APP);
     devicePolicyManager.setDelegatedScopes(testComponent, "com.example.app", newScopes);
 
     // THEN the new scopes should be set
@@ -954,7 +959,7 @@ public final class ShadowDevicePolicyManagerTest {
   }
 
   @Test
-  public void getAccountTypesWithManagementDisabledShouldReturnNothingWhenNoAccountIsDislabed() {
+  public void getAccountTypesWithManagementDisabledShouldReturnNothingWhenNoAccountIsDisabled() {
     // GIVEN no account type has ever been disabled
 
     // WHEN get disabled account types using
@@ -1810,7 +1815,7 @@ public final class ShadowDevicePolicyManagerTest {
 
   @Test
   @Config(minSdk = N)
-  public void setPackagesSuspended_suspendsPossible() throws Exception {
+  public void setPackagesSuspended_suspendsPossible() {
     shadowOf(devicePolicyManager).setProfileOwner(testComponent);
     shadowOf(packageManager).addPackage("installed");
     String[] packages = new String[] {"installed", "not.installed"};
@@ -1910,7 +1915,7 @@ public final class ShadowDevicePolicyManagerTest {
 
     // Delegate DELEGATION_PACKAGE_ACCESS scope to an app but not caller
     String delegatedApp = "com.example.not.caller";
-    List<String> scopes = Arrays.asList(DevicePolicyManager.DELEGATION_PACKAGE_ACCESS);
+    List<String> scopes = Collections.singletonList(DevicePolicyManager.DELEGATION_PACKAGE_ACCESS);
     devicePolicyManager.setDelegatedScopes(testComponent, delegatedApp, scopes);
 
     // Then DevicePolicyManager#setPackagesSuspended should fail with SecurityException
@@ -1939,7 +1944,7 @@ public final class ShadowDevicePolicyManagerTest {
     // Delegate DELEGATION_PACKAGE_ACCESS scope to another app such that the delegated app
     // has the access to call setPackageSuspended
     String delegatedApp = context.getPackageName();
-    List<String> scopes = Arrays.asList(DevicePolicyManager.DELEGATION_PACKAGE_ACCESS);
+    List<String> scopes = Collections.singletonList(DevicePolicyManager.DELEGATION_PACKAGE_ACCESS);
     devicePolicyManager.setDelegatedScopes(testComponent, delegatedApp, scopes);
 
     // Then DevicePolicyManager#setPackageSuspended is called to suspend the package
@@ -1969,7 +1974,7 @@ public final class ShadowDevicePolicyManagerTest {
 
   @Test
   @Config(minSdk = N)
-  public void isPackagesSuspended_notInstalledPackage() throws Exception {
+  public void isPackagesSuspended_notInstalledPackage() {
     shadowOf(devicePolicyManager).setProfileOwner(testComponent);
 
     try {
@@ -2008,7 +2013,7 @@ public final class ShadowDevicePolicyManagerTest {
   }
 
   @Test
-  public void setPersistentPreferrecActivity_exists() {
+  public void setPersistentPreferredActivity_exists() {
     ComponentName randomActivity = new ComponentName("random.package", "Activity");
     shadowOf(devicePolicyManager).setDeviceOwner(testComponent);
 
@@ -2607,6 +2612,14 @@ public final class ShadowDevicePolicyManagerTest {
     assertThat(devicePolicyManager.isUsbDataSignalingEnabled()).isFalse();
   }
 
+  @Config(minSdk = VANILLA_ICE_CREAM)
+  @Test
+  public void isMtePolicyEnforced_shouldReturnSetValue() {
+    assertThat(DevicePolicyManager.isMtePolicyEnforced()).isFalse();
+    ShadowDevicePolicyManager.setIsMtePolicyEnforced(true);
+    assertThat(DevicePolicyManager.isMtePolicyEnforced()).isTrue();
+  }
+
   @Config(minSdk = TIRAMISU)
   @Test
   public void getDevicePolicyManagementRoleHolderPackage_shouldReturnSetValue() {
@@ -2678,7 +2691,7 @@ public final class ShadowDevicePolicyManagerTest {
   @Config(minSdk = TIRAMISU)
   @Test
   public void getPolicyManagedProfiles_shouldReturnSetVal() {
-    List<UserHandle> policyManagedProfiles = Arrays.asList(UserHandle.SYSTEM);
+    List<UserHandle> policyManagedProfiles = Collections.singletonList(UserHandle.SYSTEM);
     shadowDevicePolicyManager.setPolicyManagedProfiles(policyManagedProfiles);
     assertThat(devicePolicyManager.getPolicyManagedProfiles(UserHandle.SYSTEM))
         .isEqualTo(policyManagedProfiles);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerTest.java
index 44913ae0f..5cddf976e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerTest.java
@@ -346,7 +346,7 @@ public class ShadowDisplayManagerTest {
 
   @Test
   @Config(minSdk = P)
-  public void setSaturationLevel_setToNegativevalueViaShadow_shouldThrow() {
+  public void setSaturationLevel_setToNegativeValueViaShadow_shouldThrow() {
     try {
       shadowOf(instance).setSaturationLevel(-0.1f);
       fail("Expected IllegalArgumentException thrown");
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDrawableTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDrawableTest.java
index 9232b0bcc..95b5fa165 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDrawableTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDrawableTest.java
@@ -17,6 +17,7 @@ import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -135,7 +136,7 @@ public class ShadowDrawableTest {
     public boolean boundsChanged;
 
     @Override
-    public void draw(Canvas canvas) {}
+    public void draw(@Nonnull Canvas canvas) {}
 
     @Override
     public void setAlpha(int alpha) {}
@@ -149,7 +150,7 @@ public class ShadowDrawableTest {
     }
 
     @Override
-    protected void onBoundsChange(Rect bounds) {
+    protected void onBoundsChange(@Nonnull Rect bounds) {
       boundsChanged = true;
       super.onBoundsChange(bounds);
     }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTTest.java
index fdf4ad0a9..0b83b5630 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTTest.java
@@ -12,6 +12,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Locale;
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import org.junit.Before;
 import org.junit.Test;
@@ -65,7 +66,7 @@ public class ShadowGeocoderTTest {
     Geocoder.GeocodeListener geocodeListener =
         new Geocoder.GeocodeListener() {
           @Override
-          public void onGeocode(List<Address> list) {
+          public void onGeocode(@Nonnull List<Address> list) {
             decodedAddresses = list;
           }
 
@@ -109,7 +110,7 @@ public class ShadowGeocoderTTest {
     Geocoder.GeocodeListener geocodeListener = addresses -> decodedAddresses = addresses;
     shadowGeocoder.getFromLocationName("test", 1, geocodeListener);
 
-    assertThat(decodedAddresses).hasSize(0);
+    assertThat(decodedAddresses).isEmpty();
   }
 
   @Test
@@ -125,7 +126,7 @@ public class ShadowGeocoderTTest {
     Geocoder.GeocodeListener geocodeListener =
         new Geocoder.GeocodeListener() {
           @Override
-          public void onGeocode(List<Address> list) {
+          public void onGeocode(@Nonnull List<Address> list) {
             decodedAddresses = list;
           }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTest.java
index 00b5ac2e3..c1ebd3269 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTest.java
@@ -42,7 +42,7 @@ public class ShadowGeocoderTest {
 
   @Test
   public void getFromLocationReturnsAnEmptyArrayByDefault() throws IOException {
-    assertThat(geocoder.getFromLocation(90.0, 90.0, 1)).hasSize(0);
+    assertThat(geocoder.getFromLocation(90.0, 90.0, 1)).isEmpty();
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowGestureDetectorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowGestureDetectorTest.java
index 5e31a4e30..7417ce607 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowGestureDetectorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowGestureDetectorTest.java
@@ -12,6 +12,7 @@ import android.view.MotionEvent;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.core.view.MotionEventBuilder;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -70,17 +71,17 @@ public class ShadowGestureDetectorTest {
     GestureDetector.OnDoubleTapListener onDoubleTapListener =
         new GestureDetector.OnDoubleTapListener() {
           @Override
-          public boolean onSingleTapConfirmed(MotionEvent e) {
+          public boolean onSingleTapConfirmed(@Nonnull MotionEvent e) {
             return false;
           }
 
           @Override
-          public boolean onDoubleTap(MotionEvent e) {
+          public boolean onDoubleTap(@Nonnull MotionEvent e) {
             return false;
           }
 
           @Override
-          public boolean onDoubleTapEvent(MotionEvent e) {
+          public boolean onDoubleTapEvent(@Nonnull MotionEvent e) {
             return false;
           }
         };
@@ -102,28 +103,30 @@ public class ShadowGestureDetectorTest {
 
   private static class TestOnGestureListener implements GestureDetector.OnGestureListener {
     @Override
-    public boolean onDown(MotionEvent e) {
+    public boolean onDown(@Nonnull MotionEvent e) {
       return false;
     }
 
     @Override
-    public void onShowPress(MotionEvent e) {}
+    public void onShowPress(@Nonnull MotionEvent e) {}
 
     @Override
-    public boolean onSingleTapUp(MotionEvent e) {
+    public boolean onSingleTapUp(@Nonnull MotionEvent e) {
       return false;
     }
 
     @Override
-    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
+    public boolean onScroll(
+        MotionEvent e1, @Nonnull MotionEvent e2, float distanceX, float distanceY) {
       return false;
     }
 
     @Override
-    public void onLongPress(MotionEvent e) {}
+    public void onLongPress(@Nonnull MotionEvent e) {}
 
     @Override
-    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
+    public boolean onFling(
+        MotionEvent e1, @Nonnull MotionEvent e2, float velocityX, float velocityY) {
       return false;
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowHandlerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowHandlerTest.java
index e139cab41..f7b8cf34d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowHandlerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowHandlerTest.java
@@ -8,16 +8,19 @@ import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.annotation.LooperMode.Mode.LEGACY;
 
 import android.os.Handler;
+import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.Message;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.Shadows;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
@@ -33,7 +36,7 @@ public class ShadowHandlerTest {
   private final Handler.Callback callback =
       new Handler.Callback() {
         @Override
-        public boolean handleMessage(Message msg) {
+        public boolean handleMessage(@Nonnull Message msg) {
           hasHandlerCallbackHandledMessage = true;
           return false;
         }
@@ -348,7 +351,7 @@ public class ShadowHandlerTest {
     Handler handler =
         new Handler() {
           @Override
-          public void handleMessage(Message msg) {
+          public void handleMessage(@Nonnull Message msg) {
             wasRun[0] = true;
           }
         };
@@ -365,7 +368,7 @@ public class ShadowHandlerTest {
     Handler handler =
         new Handler() {
           @Override
-          public void handleMessage(Message msg) {
+          public void handleMessage(@Nonnull Message msg) {
             runAt.add(shadowOf(Looper.myLooper()).getScheduler().getCurrentTime());
           }
         };
@@ -390,7 +393,7 @@ public class ShadowHandlerTest {
     Handler handler =
         new Handler() {
           @Override
-          public void handleMessage(Message msg) {
+          public void handleMessage(@Nonnull Message msg) {
             wasRun[0] = true;
           }
         };
@@ -465,7 +468,7 @@ public class ShadowHandlerTest {
 
     Message m2 = new Handler().obtainMessage(1, "foo");
     assertThat(m2.what).isEqualTo(1);
-    assertThat(m2.obj).isEqualTo((Object) "foo");
+    assertThat(m2.obj).isEqualTo("foo");
 
     Message m3 = new Handler().obtainMessage(1, 2, 3);
     assertThat(m3.what).isEqualTo(1);
@@ -477,7 +480,7 @@ public class ShadowHandlerTest {
     assertThat(m4.what).isEqualTo(1);
     assertThat(m4.arg1).isEqualTo(2);
     assertThat(m4.arg2).isEqualTo(3);
-    assertThat(m4.obj).isEqualTo((Object) "foo");
+    assertThat(m4.obj).isEqualTo("foo");
   }
 
   @Test
@@ -507,7 +510,7 @@ public class ShadowHandlerTest {
     Handler h =
         new Handler(Looper.myLooper()) {
           @Override
-          public void handleMessage(Message msg) {
+          public void handleMessage(@Nonnull Message msg) {
             assertFalse(hasMessages(0));
           }
         };
@@ -515,8 +518,20 @@ public class ShadowHandlerTest {
     h.sendMessageAtFrontOfQueue(h.obtainMessage());
   }
 
+  @Test
+  public void runToEndOfTasks_shouldRunAllTasks() {
+    HandlerThread handlerThread = new HandlerThread("name");
+    handlerThread.start();
+    Handler handler = new Handler(handlerThread.getLooper());
+    handler.postDelayed(new Say("one"), 2000);
+    Shadows.shadowOf(handler.getLooper()).runToEndOfTasks();
+    handler.post(new Say("two"));
+    Shadows.shadowOf(handler.getLooper()).runToEndOfTasks();
+    assertThat(transcript).containsExactly("one", "two");
+  }
+
   private class Say implements Runnable {
-    private String event;
+    private final String event;
 
     public Say(String event) {
       this.event = event;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowImsMmTelManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowImsMmTelManagerTest.java
index cffc091b9..b8990a12d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowImsMmTelManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowImsMmTelManagerTest.java
@@ -20,6 +20,7 @@ import android.telephony.ims.stub.ImsRegistrationImplBase;
 import android.util.ArraySet;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -296,7 +297,7 @@ public class ShadowImsMmTelManagerTest {
     CapabilityCallback capabilityCallback =
         new CapabilityCallback() {
           @Override
-          public void onCapabilitiesStatusChanged(MmTelCapabilities capabilities) {
+          public void onCapabilitiesStatusChanged(@Nonnull MmTelCapabilities capabilities) {
             super.onCapabilitiesStatusChanged(capabilities);
             mmTelCapabilities[0] = capabilities;
           }
@@ -328,7 +329,7 @@ public class ShadowImsMmTelManagerTest {
     CapabilityCallback capabilityCallback =
         new CapabilityCallback() {
           @Override
-          public void onCapabilitiesStatusChanged(MmTelCapabilities capabilities) {
+          public void onCapabilitiesStatusChanged(@Nonnull MmTelCapabilities capabilities) {
             super.onCapabilitiesStatusChanged(capabilities);
             mmTelCapabilities[0] = capabilities;
           }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowInputMethodManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowInputMethodManagerTest.java
index 76fc35358..eaf6421c1 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowInputMethodManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowInputMethodManagerTest.java
@@ -64,7 +64,7 @@ public class ShadowInputMethodManagerTest {
   }
 
   @Test
-  public void hideSoftInputFromWindow_shouldNotifiyResult_alreadyHidden() {
+  public void hideSoftInputFromWindow_shouldNotifyResult_alreadyHidden() {
     CapturingResultReceiver resultReceiver =
         new CapturingResultReceiver(new Handler(Looper.getMainLooper()));
     manager.hideSoftInputFromWindow(null, 0, resultReceiver);
@@ -142,13 +142,10 @@ public class ShadowInputMethodManagerTest {
     Bundle expectedBundle = new Bundle();
 
     ShadowInputMethodManager.PrivateCommandListener listener =
-        new ShadowInputMethodManager.PrivateCommandListener() {
-          @Override
-          public void onPrivateCommand(View view, String action, Bundle data) {
-            assertThat(view).isEqualTo(expectedView);
-            assertThat(action).isEqualTo(expectedAction);
-            assertThat(data).isEqualTo(expectedBundle);
-          }
+        (view, action, data) -> {
+          assertThat(view).isEqualTo(expectedView);
+          assertThat(action).isEqualTo(expectedAction);
+          assertThat(data).isEqualTo(expectedBundle);
         };
 
     shadow.setAppPrivateCommandListener(listener);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowInstrumentationTestLooperTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowInstrumentationTestLooperTest.java
index 8dde29729..5221ec18a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowInstrumentationTestLooperTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowInstrumentationTestLooperTest.java
@@ -11,14 +11,13 @@ import static org.robolectric.Shadows.shadowOf;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
-import com.google.common.base.Preconditions;
 import java.time.Duration;
+import java.util.Objects;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.LooperMode.Mode;
 import org.robolectric.shadow.api.Shadow;
@@ -28,7 +27,6 @@ import org.robolectric.shadow.api.Shadow;
 public class ShadowInstrumentationTestLooperTest {
 
   @Test
-  @Config(minSdk = 18)
   public void testThreadIsNotMainThread() {
     assertFalse(Looper.getMainLooper().isCurrentThread());
   }
@@ -91,7 +89,7 @@ public class ShadowInstrumentationTestLooperTest {
         () -> {
           throw new RuntimeException("Exception should be propagated!");
         });
-    assertThrows(RuntimeException.class, () -> shadowMainLooper.idle());
+    assertThrows(RuntimeException.class, shadowMainLooper::idle);
 
     // Restore main looper and main thread to avoid error at tear down
     ShadowPausedLooper.resetLoopers();
@@ -127,12 +125,9 @@ public class ShadowInstrumentationTestLooperTest {
     } catch (RuntimeException e) {
       exception = e;
     }
-    Preconditions.checkNotNull(exception);
+    Objects.requireNonNull(exception);
     ShadowPausedLooper.resetLoopers();
-    handler.post(
-        () -> {
-          didRun.set(true);
-        });
+    handler.post(() -> didRun.set(true));
     shadowLooper.idle();
 
     assertThat(didRun.get()).isTrue();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentTest.java
index 47c772532..12514b076 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentTest.java
@@ -24,6 +24,7 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Objects;
 import java.util.Set;
+import javax.annotation.Nonnull;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -46,7 +47,7 @@ public class ShadowIntentTest {
   @Test
   public void testGetExtraReturnsNull_whenThereAreNoExtrasAdded() {
     Intent intent = new Intent();
-    assertEquals(intent.getExtras(), null);
+    assertNull(intent.getExtras());
   }
 
   @Test
@@ -341,7 +342,7 @@ public class ShadowIntentTest {
     assertEquals("com.foobar.app", intentA.getPackage());
     assertSame(cn, intentA.getComponent());
     assertEquals(23, intentA.getIntExtra("FOO", -1));
-    assertEquals(result, flags);
+    assertEquals(flags, result);
   }
 
   @Test
@@ -476,7 +477,7 @@ public class ShadowIntentTest {
   }
 
   private static class TestSerializable implements Serializable {
-    private String someValue;
+    private final String someValue;
 
     public TestSerializable(String someValue) {
       this.someValue = someValue;
@@ -515,6 +516,7 @@ public class ShadowIntentTest {
       return s.length();
     }
 
+    @Nonnull
     @Override
     public CharSequence subSequence(int start, int end) {
       return s.subSequence(start, end);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowJobServiceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowJobServiceTest.java
index eb563b99a..dfc81a803 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowJobServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowJobServiceTest.java
@@ -7,6 +7,7 @@ import android.app.Notification;
 import android.app.job.JobParameters;
 import android.app.job.JobService;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -21,9 +22,11 @@ public class ShadowJobServiceTest {
   private JobService jobService;
   @Mock private JobParameters params;
 
+  private AutoCloseable mock;
+
   @Before
   public void setUp() {
-    MockitoAnnotations.initMocks(this);
+    mock = MockitoAnnotations.openMocks(this);
     jobService =
         new JobService() {
           @Override
@@ -38,6 +41,11 @@ public class ShadowJobServiceTest {
         };
   }
 
+  @After
+  public void tearDown() throws Exception {
+    mock.close();
+  }
+
   @Test
   @Config(minSdk = 34)
   public void updateEstimatedNetworkBytes() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java
index 3b2e465f3..9a33c0132 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java
@@ -52,7 +52,7 @@ public class ShadowKeyguardManagerTest {
   }
 
   @Test
-  public void testShouldBeAbleToDisableTheKeyguardLock() throws Exception {
+  public void testShouldBeAbleToDisableTheKeyguardLock() {
     KeyguardManager.KeyguardLock lock = manager.newKeyguardLock(KEYGUARD_SERVICE);
     assertThat(shadowOf(lock).isEnabled()).isTrue();
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java
index aa578bc98..d80c8ba0e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java
@@ -42,6 +42,7 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -219,7 +220,7 @@ public class ShadowLauncherAppsTest {
 
   @Test
   @Config(minSdk = O)
-  public void testGetApplicationInfo_packageNotFound() throws Exception {
+  public void testGetApplicationInfo_packageNotFound() {
     Throwable throwable =
         assertThrows(
             NameNotFoundException.class,
@@ -232,7 +233,7 @@ public class ShadowLauncherAppsTest {
   }
 
   @Test
-  public void testGetApplicationInfo_incorrectPackage() throws Exception {
+  public void testGetApplicationInfo_incorrectPackage() {
     ApplicationInfo applicationInfo = new ApplicationInfo();
     applicationInfo.name = "Test app";
     shadowOf(launcherApps).addApplicationInfo(USER_HANDLE, TEST_PACKAGE_NAME_2, applicationInfo);
@@ -273,7 +274,9 @@ public class ShadowLauncherAppsTest {
           new DefaultCallback() {
             @Override
             public void onShortcutsChanged(
-                String packageName, List<ShortcutInfo> shortcuts, UserHandle user) {
+                @Nonnull String packageName,
+                List<ShortcutInfo> shortcuts,
+                @Nonnull UserHandle user) {
               assertEquals(shortcuts.get(0).getPackage(), packageName);
               wasCalled[0] = true;
               latch1.countDown();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskTest.java
index eecf070ec..f6b07493b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskTest.java
@@ -53,7 +53,7 @@ public class ShadowLegacyAsyncTaskTest {
   }
 
   @Test
-  public void testCancelBeforeBackground() throws Exception {
+  public void testCancelBeforeBackground() {
     AsyncTask<String, String, String> asyncTask = new MyAsyncTask();
 
     asyncTask.execute("a", "b");
@@ -132,7 +132,7 @@ public class ShadowLegacyAsyncTaskTest {
   }
 
   @Test
-  public void shouldGetStatusForAsyncTask() throws Exception {
+  public void shouldGetStatusForAsyncTask() {
     AsyncTask<String, String, String> asyncTask = new MyAsyncTask();
     assertThat(asyncTask.getStatus()).isEqualTo(AsyncTask.Status.PENDING);
     asyncTask.execute("a");
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyLooperTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyLooperTest.java
index 88fd2578e..5f431a137 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyLooperTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyLooperTest.java
@@ -22,15 +22,14 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
-import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestName;
 import org.junit.runner.RunWith;
-import org.robolectric.RoboSettings;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.LooperMode;
+import org.robolectric.junit.rules.SetSystemPropertyRule;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.Scheduler;
@@ -39,6 +38,8 @@ import org.robolectric.util.Scheduler;
 @LooperMode(LEGACY)
 public class ShadowLegacyLooperTest {
 
+  @Rule public SetSystemPropertyRule setSystemPropertyRule = new SetSystemPropertyRule();
+
   // testName is used when creating background threads. Makes it
   // easier to debug exceptions on background threads when you
   // know what test they are associated with.
@@ -57,7 +58,7 @@ public class ShadowLegacyLooperTest {
   private class QuitThread extends Thread {
     private boolean hasContinued = false;
     private Looper looper;
-    private CountDownLatch started = new CountDownLatch(1);
+    private final CountDownLatch started = new CountDownLatch(1);
 
     public QuitThread() {
       super(testName.getMethodName());
@@ -125,15 +126,7 @@ public class ShadowLegacyLooperTest {
   @Test
   public void idleMainLooper_executesScheduledTasks() {
     final boolean[] wasRun = new boolean[] {false};
-    new Handler()
-        .postDelayed(
-            new Runnable() {
-              @Override
-              public void run() {
-                wasRun[0] = true;
-              }
-            },
-            2000);
+    new Handler().postDelayed(() -> wasRun[0] = true, 2000);
 
     assertWithMessage("first").that(wasRun[0]).isFalse();
     ShadowLooper.idleMainLooper(1999, TimeUnit.MILLISECONDS);
@@ -146,15 +139,7 @@ public class ShadowLegacyLooperTest {
   public void idleConstantly_runsPostDelayedTasksImmediately() {
     ShadowLooper.idleMainLooperConstantly(true);
     final boolean[] wasRun = new boolean[] {false};
-    new Handler()
-        .postDelayed(
-            new Runnable() {
-              @Override
-              public void run() {
-                wasRun[0] = true;
-              }
-            },
-            2000);
+    new Handler().postDelayed(() -> wasRun[0] = true, 2000);
 
     assertThat(wasRun[0]).isTrue();
   }
@@ -170,25 +155,10 @@ public class ShadowLegacyLooperTest {
     Looper looper = ht.getLooper();
     looper.quit();
     assertWithMessage("hasQuit").that(shadowOf(looper).hasQuit()).isTrue();
-    assertWithMessage("post")
-        .that(
-            shadowOf(looper)
-                .post(
-                    new Runnable() {
-                      @Override
-                      public void run() {}
-                    },
-                    0))
-        .isFalse();
+    assertWithMessage("post").that(shadowOf(looper).post(() -> {}, 0)).isFalse();
 
     assertWithMessage("postAtFrontOfQueue")
-        .that(
-            shadowOf(looper)
-                .postAtFrontOfQueue(
-                    new Runnable() {
-                      @Override
-                      public void run() {}
-                    }))
+        .that(shadowOf(looper).postAtFrontOfQueue(() -> {}))
         .isFalse();
     assertWithMessage("areAnyRunnable")
         .that(shadowOf(looper).getScheduler().areAnyRunnable())
@@ -200,13 +170,7 @@ public class ShadowLegacyLooperTest {
     HandlerThread ht = getHandlerThread();
     Looper looper = ht.getLooper();
     shadowOf(looper).pause();
-    shadowOf(looper)
-        .post(
-            new Runnable() {
-              @Override
-              public void run() {}
-            },
-            0);
+    shadowOf(looper).post(() -> {}, 0);
     looper.quit();
     assertWithMessage("hasQuit").that(shadowOf(looper).hasQuit()).isTrue();
     assertWithMessage("areAnyRunnable")
@@ -231,11 +195,7 @@ public class ShadowLegacyLooperTest {
     Handler h = new Handler(looper);
     ShadowLooper sLooper = shadowOf(looper);
     sLooper.pause();
-    h.post(
-        new Runnable() {
-          @Override
-          public void run() {}
-        });
+    h.post(() -> {});
     assertWithMessage("queue").that(shadowOf(looper.getQueue()).getHead()).isNotNull();
     sLooper.reset();
     assertWithMessage("areAnyRunnable").that(sLooper.getScheduler().areAnyRunnable()).isFalse();
@@ -270,16 +230,14 @@ public class ShadowLegacyLooperTest {
   public void resetThreadLoopers_fromNonMainThread_doesNotThrow() throws InterruptedException {
     final AtomicReference<Throwable> ex = new AtomicReference<>();
     Thread t =
-        new Thread() {
-          @Override
-          public void run() {
-            try {
-              ShadowLooper.resetThreadLoopers();
-            } catch (Throwable t) {
-              ex.set(t);
-            }
-          }
-        };
+        new Thread(
+            () -> {
+              try {
+                ShadowLooper.resetThreadLoopers();
+              } catch (Throwable t1) {
+                ex.set(t1);
+              }
+            });
     t.start();
     t.join();
     assertThat(ex.get()).isNull();
@@ -326,7 +284,7 @@ public class ShadowLegacyLooperTest {
   }
 
   private void setAdvancedScheduling() {
-    RoboSettings.setUseGlobalScheduler(true);
+    setSystemPropertyRule.set("robolectric.scheduling.global", "true");
   }
 
   @Test
@@ -375,11 +333,7 @@ public class ShadowLegacyLooperTest {
     backgroundThread.start();
     Looper backgroundLooper = backgroundThread.getLooper();
     Handler handler = new Handler(backgroundLooper);
-    Runnable empty =
-        new Runnable() {
-          @Override
-          public void run() {}
-        };
+    Runnable empty = () -> {};
     // There should be at least two iterations of this loop because resetThreadLoopers calls
     // 'quit' on background loopers once, which also resets the scheduler.
     for (int i = 0; i < 5; i++) {
@@ -423,12 +377,9 @@ public class ShadowLegacyLooperTest {
 
     Thread backgroundThread =
         new Thread(
-            new Runnable() {
-              @Override
-              public void run() {
-                Looper mainLooper = Looper.getMainLooper();
-                mainLooperAtomicReference.set(mainLooper);
-              }
+            () -> {
+              Looper mainLooper = Looper.getMainLooper();
+              mainLooperAtomicReference.set(mainLooper);
             },
             testName.getMethodName());
     backgroundThread.start();
@@ -463,22 +414,8 @@ public class ShadowLegacyLooperTest {
     Handler handler1 = new Handler(ht.getLooper());
     Handler handler2 = new Handler();
     final ArrayList<String> events = new ArrayList<>();
-    handler1.postDelayed(
-        new Runnable() {
-          @Override
-          public void run() {
-            events.add("handler1");
-          }
-        },
-        100);
-    handler2.postDelayed(
-        new Runnable() {
-          @Override
-          public void run() {
-            events.add("handler2");
-          }
-        },
-        200);
+    handler1.postDelayed(() -> events.add("handler1"), 100);
+    handler2.postDelayed(() -> events.add("handler2"), 200);
     assertWithMessage("start").that(events).isEmpty();
     Scheduler s = ShadowLooper.getShadowMainLooper().getScheduler();
     assertThat(s).isSameInstanceAs(RuntimeEnvironment.getMasterScheduler());
@@ -549,9 +486,4 @@ public class ShadowLegacyLooperTest {
     Robolectric.flushBackgroundThreadScheduler();
     assertThat(ran.get()).isTrue();
   }
-
-  @After
-  public void tearDown() {
-    RoboSettings.setUseGlobalScheduler(false);
-  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageQueueTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageQueueTest.java
index 48a5053f4..41eca0cc1 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageQueueTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageQueueTest.java
@@ -18,6 +18,7 @@ import android.os.SystemClock;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -50,7 +51,7 @@ public class ShadowLegacyMessageQueueTest {
     }
 
     @Override
-    public void handleMessage(Message msg) {
+    public void handleMessage(@Nonnull Message msg) {
       handled.add(msg);
     }
   }
@@ -162,7 +163,7 @@ public class ShadowLegacyMessageQueueTest {
     Handler handler =
         new Handler(looper) {
           @Override
-          public void handleMessage(Message msg) {
+          public void handleMessage(@Nonnull Message msg) {
             boolean inUse = callInstanceMethod(msg, "isInUse");
             assertWithMessage(msg.what + ":inUse").that(inUse).isTrue();
             Message next = reflector(MessageReflector.class, msg).getNext();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowListPreferenceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowListPreferenceTest.java
index f438f01a6..36a267dff 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowListPreferenceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowListPreferenceTest.java
@@ -1,10 +1,9 @@
 package org.robolectric.shadows;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.robolectric.Robolectric.buildActivity;
 
-import android.app.Activity;
 import android.preference.ListPreference;
+import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
@@ -18,7 +17,7 @@ public class ShadowListPreferenceTest {
 
   @Before
   public void setUp() throws Exception {
-    listPreference = new ListPreference(buildActivity(Activity.class).create().get());
+    listPreference = new ListPreference(ApplicationProvider.getApplicationContext());
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowListViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowListViewTest.java
index 38b075e59..4df727de8 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowListViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowListViewTest.java
@@ -191,7 +191,7 @@ public class ShadowListViewTest {
   @Test(expected = IllegalArgumentException.class)
   public void clickItemContainingText_shouldThrowExceptionIfNotFound() {
     ShadowListView shadowListView = prepareListWithThreeItems();
-    shadowListView.clickFirstItemContainingText("Non-existant item");
+    shadowListView.clickFirstItemContainingText("Non-existent item");
   }
 
   @Test(expected = UnsupportedOperationException.class)
@@ -228,7 +228,7 @@ public class ShadowListViewTest {
   }
 
   @Test
-  public void shouldRecordLatestCallToSmoothScrollToPostion() {
+  public void shouldRecordLatestCallToSmoothScrollToPosition() {
     listView.smoothScrollToPosition(10);
     assertThat(shadowOf(listView).getSmoothScrolledPosition()).isEqualTo(10);
   }
@@ -255,7 +255,7 @@ public class ShadowListViewTest {
   }
 
   @Test
-  public void givenNoItemsChecked_whenGettingCheckedItemOisition_thenReturnInvalidPosition() {
+  public void givenNoItemsChecked_whenGettingCheckedItemPosition_thenReturnInvalidPosition() {
     prepareListAdapter().withChoiceMode(ListView.CHOICE_MODE_SINGLE);
 
     assertThat(listView.getCheckedItemPosition()).isEqualTo(ListView.INVALID_POSITION);
@@ -346,11 +346,10 @@ public class ShadowListViewTest {
     return new ListAdapterBuilder();
   }
 
-  private ListAdapter prepareWithListAdapter() {
+  private void prepareWithListAdapter() {
     ListAdapter adapter = new ListAdapter("a", "b", "c");
     listView.setAdapter(adapter);
     shadowOf(listView).populateItems();
-    return adapter;
   }
 
   private ShadowListView prepareListWithThreeItems() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleDataTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleDataTest.java
index f1c4deb4d..d8454fefe 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleDataTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleDataTest.java
@@ -23,7 +23,7 @@ import org.robolectric.util.reflector.ForType;
 public class ShadowLocaleDataTest {
 
   @Test
-  public void shouldSupportLocaleEn_US() throws NoSuchFieldException, IllegalAccessException {
+  public void shouldSupportLocaleEn_US() {
     LocaleData localeData = LocaleData.get(Locale.US);
     LocaleDataReflector localeDataReflector = reflector(LocaleDataReflector.class, localeData);
     assertThat(localeData.amPm).isEqualTo(new String[] {"AM", "PM"});
@@ -125,7 +125,7 @@ public class ShadowLocaleDataTest {
   }
 
   @Test
-  public void shouldSupportLocaleEn_US_since() throws NoSuchFieldException, IllegalAccessException {
+  public void shouldSupportLocaleEn_US_since() {
     LocaleData localeData = LocaleData.get(Locale.US);
     LocaleDataReflector localeDataReflector = reflector(LocaleDataReflector.class, localeData);
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleManagerTest.java
index bbd2985d1..b47608ad3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleManagerTest.java
@@ -24,13 +24,12 @@ public final class ShadowLocaleManagerTest {
   private static final String DEFAULT_PACKAGE_NAME = "my.app";
   private static final LocaleList DEFAULT_LOCALES = LocaleList.forLanguageTags("en-XC,ar-XB");
 
-  private Context context;
   private LocaleManager localeManager;
   private ShadowLocaleManager shadowLocaleManager;
 
   @Before
   public void setUp() {
-    context = ApplicationProvider.getApplicationContext();
+    Context context = ApplicationProvider.getApplicationContext();
     localeManager = context.getSystemService(LocaleManager.class);
     shadowLocaleManager = Shadow.extract(localeManager);
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLocationManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLocationManagerTest.java
index 6841b8c99..abedbde27 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLocationManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLocationManagerTest.java
@@ -57,6 +57,7 @@ import java.util.List;
 import java.util.Random;
 import java.util.Set;
 import java.util.function.Consumer;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -110,7 +111,7 @@ public class ShadowLocationManagerTest {
   public void testGetAllProviders() {
     assertThat(locationManager.getAllProviders())
         .containsExactly(GPS_PROVIDER, NETWORK_PROVIDER, PASSIVE_PROVIDER);
-    shadowLocationManager.setProviderProperties(MY_PROVIDER, (ProviderProperties) null);
+    shadowLocationManager.setProviderProperties(MY_PROVIDER, null);
     assertThat(locationManager.getAllProviders())
         .containsExactly(MY_PROVIDER, GPS_PROVIDER, NETWORK_PROVIDER, PASSIVE_PROVIDER);
   }
@@ -1762,7 +1763,7 @@ public class ShadowLocationManagerTest {
     final ArrayList<Integer> flushes = new ArrayList<>();
 
     @Override
-    public void onLocationChanged(Location location) {
+    public void onLocationChanged(@Nonnull Location location) {
       locations.add(location);
     }
 
@@ -1770,12 +1771,12 @@ public class ShadowLocationManagerTest {
     public void onStatusChanged(String s, int i, Bundle bundle) {}
 
     @Override
-    public void onProviderEnabled(String s) {
+    public void onProviderEnabled(@Nonnull String s) {
       providerEnableds.add(true);
     }
 
     @Override
-    public void onProviderDisabled(String s) {
+    public void onProviderDisabled(@Nonnull String s) {
       providerEnableds.add(false);
     }
 
@@ -1794,7 +1795,7 @@ public class ShadowLocationManagerTest {
     }
 
     @Override
-    public void onLocationChanged(Location location) {
+    public void onLocationChanged(@Nonnull Location location) {
       locationManager.removeUpdates(this);
       super.onLocationChanged(location);
     }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLogTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLogTest.java
index e1169fd77..62c4233e0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLogTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLogTest.java
@@ -193,14 +193,14 @@ public class ShadowLogTest {
   }
 
   @Test
-  public void shouldLogToProvidedStream() throws Exception {
+  public void shouldLogToProvidedStream() {
     final ByteArrayOutputStream bos = new ByteArrayOutputStream();
     PrintStream old = ShadowLog.stream;
     try {
       ShadowLog.stream = new PrintStream(bos);
       Log.d("tag", "msg");
       assertThat(new String(bos.toByteArray(), UTF_8))
-          .isEqualTo("D/tag: msg" + System.getProperty("line.separator"));
+          .isEqualTo("D/tag: msg" + System.lineSeparator());
 
       Log.w("tag", new RuntimeException());
       assertTrue(new String(bos.toByteArray(), UTF_8).contains("RuntimeException"));
@@ -214,7 +214,7 @@ public class ShadowLogTest {
   }
 
   @Test
-  public void shouldLogAccordingToTag() throws Exception {
+  public void shouldLogAccordingToTag() {
     ShadowLog.reset();
     Log.d("tag1", "1");
     Log.i("tag2", "2");
@@ -225,7 +225,7 @@ public class ShadowLogTest {
     Log.d("throwable", "7", specificMethodName());
 
     List<LogItem> allItems = ShadowLog.getLogs();
-    assertThat(allItems.size()).isEqualTo(7);
+    assertThat(allItems).hasSize(7);
     int i = 1;
     for (LogItem item : allItems) {
       assertThat(item.msg).isEqualTo(Integer.toString(i));
@@ -240,7 +240,7 @@ public class ShadowLogTest {
 
   private static void assertUniformLogsForTag(String tag, int count) {
     List<LogItem> tag1Items = ShadowLog.getLogsForTag(tag);
-    assertThat(tag1Items.size()).isEqualTo(count);
+    assertThat(tag1Items).hasSize(count);
     int last = -1;
     for (LogItem item : tag1Items) {
       assertThat(item.tag).isEqualTo(tag);
@@ -251,7 +251,7 @@ public class ShadowLogTest {
   }
 
   @Test
-  public void infoIsDefaultLoggableLevel() throws Exception {
+  public void infoIsDefaultLoggableLevel() {
     PrintStream old = ShadowLog.stream;
     ShadowLog.stream = null;
     assertFalse(Log.isLoggable("FOO", Log.VERBOSE));
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLooperResetterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLooperResetterTest.java
index bf0ea60c0..efd552890 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLooperResetterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLooperResetterTest.java
@@ -1,9 +1,9 @@
 package org.robolectric.shadows;
 
 import static android.os.Looper.getMainLooper;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.truth.Truth.assertThat;
+import static java.util.Objects.requireNonNull;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.os.Handler;
@@ -52,7 +52,7 @@ public class ShadowLooperResetterTest {
   public static class BasicLooperTest {
 
     private void doPostToLooperTest() {
-      checkNotNull(getMainLooper());
+      requireNonNull(getMainLooper());
 
       AtomicBoolean didRun = new AtomicBoolean(false);
       new Handler(getMainLooper()).post(() -> didRun.set(true));
@@ -167,7 +167,7 @@ public class ShadowLooperResetterTest {
     }
 
     private void doDelayedPostToLooperTest() {
-      checkNotNull(handlerThread.getLooper());
+      requireNonNull(handlerThread.getLooper());
 
       AtomicBoolean didRun = new AtomicBoolean(false);
       new Handler(handlerThread.getLooper()).postDelayed(() -> didRun.set(true), 100);
@@ -217,7 +217,7 @@ public class ShadowLooperResetterTest {
     }
 
     private void doPostToChoreographerTest() {
-      checkNotNull(handlerThread.getLooper());
+      requireNonNull(handlerThread.getLooper());
       Handler handler = new Handler(handlerThread.getLooper());
 
       AtomicLong frameTimeNanosResult = new AtomicLong(-1);
@@ -276,19 +276,13 @@ public class ShadowLooperResetterTest {
     }
 
     @After
-    public void shutDown() throws InterruptedException {
+    public void shutDown() {
       // asynchronously quit handler thread to try to expose race conditions
-      executor.execute(
-          new Runnable() {
-            @Override
-            public void run() {
-              handlerThread.quit();
-            }
-          });
+      executor.execute(() -> handlerThread.quit());
     }
 
     private void doPostToChoreographerTest() {
-      checkNotNull(handlerThread.getLooper());
+      requireNonNull(handlerThread.getLooper());
       Handler handler = new Handler(handlerThread.getLooper());
 
       AtomicLong frameTimeNanosResult = new AtomicLong(-1);
@@ -325,7 +319,7 @@ public class ShadowLooperResetterTest {
     }
   }
 
-  /** Tests for potentially race conditions where Looper is quit asynchrounously at end of test */
+  /** Tests for potentially race conditions where Looper is quit asynchronously at end of test */
   @Test
   public void choreographerQuitPost() throws InitializationError {
     Runner runner = new RobolectricTestRunner(ChoreographerResetQuitTest.class);
@@ -355,12 +349,9 @@ public class ShadowLooperResetterTest {
         CountDownLatch latch = new CountDownLatch(1);
         new Handler(handlerThread.getLooper())
             .post(
-                new Runnable() {
-                  @Override
-                  public void run() {
-                    choreographer = Choreographer.getInstance();
-                    latch.countDown();
-                  }
+                () -> {
+                  choreographer = Choreographer.getInstance();
+                  latch.countDown();
                 });
         latch.await();
       }
@@ -373,7 +364,7 @@ public class ShadowLooperResetterTest {
     }
 
     private void doPostToChoreographerTest() {
-      checkNotNull(handlerThread.getLooper());
+      requireNonNull(handlerThread.getLooper());
       Handler handler = new Handler(handlerThread.getLooper());
 
       AtomicLong frameTimeNanosResult = new AtomicLong(-1);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMagnificationControllerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMagnificationControllerTest.java
index 26b187928..013206137 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMagnificationControllerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMagnificationControllerTest.java
@@ -3,19 +3,19 @@ package org.robolectric.shadows;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 
-import android.accessibilityservice.AccessibilityService;
 import android.accessibilityservice.AccessibilityService.MagnificationController;
 import android.accessibilityservice.MagnificationConfig;
 import android.graphics.Region;
 import android.os.Build.VERSION_CODES;
 import android.os.Looper;
-import android.view.accessibility.AccessibilityEvent;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.testing.TestAccessibilityService;
 
 /** Test for ShadowMagnificationController. */
 @RunWith(AndroidJUnit4.class)
@@ -26,7 +26,7 @@ public final class ShadowMagnificationControllerTest {
 
   @Before
   public void setUp() {
-    MyService myService = Robolectric.setupService(MyService.class);
+    TestAccessibilityService myService = Robolectric.setupService(TestAccessibilityService.class);
     magnificationController = myService.getMagnificationController();
   }
 
@@ -186,8 +186,8 @@ public final class ShadowMagnificationControllerTest {
 
     @Override
     public void onMagnificationChanged(
-        MagnificationController controller,
-        Region region,
+        @Nonnull MagnificationController controller,
+        @Nonnull Region region,
         float scale,
         float centerX,
         float centerY) {
@@ -197,18 +197,4 @@ public final class ShadowMagnificationControllerTest {
       this.centerY = centerY;
     }
   }
-
-  /** Empty implementation of AccessibilityService, for test purposes. */
-  private static class MyService extends AccessibilityService {
-
-    @Override
-    public void onAccessibilityEvent(AccessibilityEvent arg0) {
-      // Do nothing
-    }
-
-    @Override
-    public void onInterrupt() {
-      // Do nothing
-    }
-  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaActionSoundTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaActionSoundTest.java
index d58130f14..3e78431a8 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaActionSoundTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaActionSoundTest.java
@@ -82,7 +82,7 @@ public final class ShadowMediaActionSoundTest {
 
   @Test
   @Config(minSdk = VERSION_CODES.TIRAMISU)
-  public void mustPlayShutterSound_overrident_correctValue() {
+  public void mustPlayShutterSound_overridden_correctValue() {
     ShadowMediaActionSound.setMustPlayShutterSound(true);
 
     assertThat(MediaActionSound.mustPlayShutterSound()).isTrue();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaCodecTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaCodecTest.java
index 442aa8608..df91d8db7 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaCodecTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaCodecTest.java
@@ -30,6 +30,7 @@ import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import javax.annotation.Nonnull;
 import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -157,8 +158,8 @@ public final class ShadowMediaCodecTest {
 
     codec.releaseOutputBuffer(bufferIndex, /* render= */ false);
     // We should be able to dequeue the corresponding input buffer.
-    int dequeuedInputbufferIndex = codec.dequeueInputBuffer(/* timeoutUs= */ 0);
-    assertThat(dequeuedInputbufferIndex).isEqualTo(bufferIndex);
+    int dequeuedInputBufferIndex = codec.dequeueInputBuffer(/* timeoutUs= */ 0);
+    assertThat(dequeuedInputBufferIndex).isEqualTo(bufferIndex);
   }
 
   @Test
@@ -167,7 +168,7 @@ public final class ShadowMediaCodecTest {
     MediaCodecCallback callback =
         new MediaCodecCallback() {
           @Override
-          public void onInputBufferAvailable(MediaCodec codec, int inputBufferId) {
+          public void onInputBufferAvailable(@Nonnull MediaCodec codec, int inputBufferId) {
             inputBuffers.add(inputBufferId);
           }
         };
@@ -183,7 +184,7 @@ public final class ShadowMediaCodecTest {
     MediaCodecCallback callback =
         new MediaCodecCallback() {
           @Override
-          public void onInputBufferAvailable(MediaCodec codec, int inputBufferId) {
+          public void onInputBufferAvailable(@Nonnull MediaCodec codec, int inputBufferId) {
             inputBuffers.add(inputBufferId);
           }
         };
@@ -782,16 +783,17 @@ public final class ShadowMediaCodecTest {
   public static class MediaCodecCallback extends MediaCodec.Callback {
 
     @Override
-    public void onInputBufferAvailable(MediaCodec codec, int inputBufferId) {}
+    public void onInputBufferAvailable(@Nonnull MediaCodec codec, int inputBufferId) {}
 
     @Override
-    public void onOutputBufferAvailable(MediaCodec codec, int outputBufferId, BufferInfo info) {}
+    public void onOutputBufferAvailable(
+        @Nonnull MediaCodec codec, int outputBufferId, @Nonnull BufferInfo info) {}
 
     @Override
-    public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) {}
+    public void onOutputFormatChanged(@Nonnull MediaCodec codec, @Nonnull MediaFormat format) {}
 
     @Override
-    public void onError(MediaCodec codec, MediaCodec.CodecException e) {}
+    public void onError(@Nonnull MediaCodec codec, @Nonnull MediaCodec.CodecException e) {}
   }
 
   /**
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaControllerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaControllerTest.java
index 58ba79717..faaba14a2 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaControllerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaControllerTest.java
@@ -5,6 +5,7 @@ import static android.os.Looper.getMainLooper;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -40,14 +41,13 @@ public final class ShadowMediaControllerTest {
 
   private MediaController mediaController;
   private ShadowMediaController shadowMediaController;
-  private final String testPackageName = "FOO";
 
   @Before
   public void setUp() {
     Context context = ApplicationProvider.getApplicationContext();
     ISessionController binder = mock(ISessionController.class);
 
-    MediaSession.Token token = null;
+    MediaSession.Token token;
     if (RuntimeEnvironment.getApiLevel() <= Q) {
       token =
           ReflectionHelpers.callConstructor(
@@ -65,6 +65,7 @@ public final class ShadowMediaControllerTest {
 
   @Test
   public void setPackageName() {
+    String testPackageName = "FOO";
     shadowMediaController.setPackageName(testPackageName);
     assertEquals(testPackageName, mediaController.getPackageName());
   }
@@ -139,7 +140,7 @@ public final class ShadowMediaControllerTest {
     Bundle extras = new Bundle();
     extras.putBoolean(extraKey, true);
     shadowMediaController.setExtras(extras);
-    assertEquals(true, mediaController.getExtras().getBoolean(extraKey, false));
+    assertTrue(mediaController.getExtras().getBoolean(extraKey, false));
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaMetadataRetrieverTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaMetadataRetrieverTest.java
index 9cbd7dfad..0f6781b40 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaMetadataRetrieverTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaMetadataRetrieverTest.java
@@ -38,7 +38,7 @@ public class ShadowMediaMetadataRetrieverTest {
   private final MediaMetadataRetriever retriever2 = new MediaMetadataRetriever();
   private final Bitmap bitmap = Bitmap.createBitmap(10, 10, Bitmap.Config.ARGB_8888);
   private final Bitmap bitmap2 = Bitmap.createBitmap(11, 11, Bitmap.Config.ARGB_8888);
-  private FileDescriptor fd = new FileDescriptor();
+  private final FileDescriptor fd = new FileDescriptor();
 
   @Test
   public void extractMetadata_shouldReturnValue() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaPlayerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaPlayerTest.java
index 84a1540cb..e94caa113 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaPlayerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaPlayerTest.java
@@ -728,10 +728,10 @@ public class ShadowMediaPlayerTest {
         .isNotEqualTo(0);
   }
 
-  private Tester onErrorTester = new OnErrorTester(-38, 0);
-  private Tester iseTester = new ExceptionTester(IllegalStateException.class);
-  private Tester logTester = new LogTester(null);
-  private Tester assertTester = new ExceptionTester(AssertionError.class);
+  private final Tester onErrorTester = new OnErrorTester(-38, 0);
+  private final Tester iseTester = new ExceptionTester(IllegalStateException.class);
+  private final Tester logTester = new LogTester(null);
+  private final Tester assertTester = new ExceptionTester(AssertionError.class);
 
   private void testStates(String methodName, EnumSet<State> invalidStates, State nextState) {
     testStates(new MethodSpec(methodName), invalidStates, iseTester, nextState);
@@ -744,7 +744,7 @@ public class ShadowMediaPlayerTest {
     public Object[] args;
 
     public MethodSpec(String method) {
-      this(method, (Class<?>[]) null, (Object[]) null);
+      this(method, null, (Object[]) null);
     }
 
     public MethodSpec(String method, Class<?>[] argTypes, Object[] args) {
@@ -864,8 +864,8 @@ public class ShadowMediaPlayerTest {
   }
 
   private class OnErrorTester implements Tester {
-    private int what;
-    private int extra;
+    private final int what;
+    private final int extra;
 
     public OnErrorTester(int what, int extra) {
       this.what = what;
@@ -899,7 +899,7 @@ public class ShadowMediaPlayerTest {
   }
 
   private class ExceptionTester implements Tester {
-    private Class<? extends Throwable> eClass;
+    private final Class<? extends Throwable> eClass;
 
     public ExceptionTester(Class<? extends Throwable> eClass) {
       this.eClass = eClass;
@@ -924,7 +924,7 @@ public class ShadowMediaPlayerTest {
   }
 
   private class LogTester implements Tester {
-    private State next;
+    private final State next;
 
     public LogTester(State next) {
       this.next = next;
@@ -1135,7 +1135,7 @@ public class ShadowMediaPlayerTest {
   }
 
   @Test
-  public void testSimulatenousEventsAllRun() {
+  public void testSimultaneousEventsAllRun() {
     // Simultaneous events should all run even if
     // one of them stops playback.
     MediaEvent e1 = (mp, smp) -> smp.doStop();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMergeCursorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMergeCursorTest.java
index 405b67e4f..3be811aa2 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMergeCursorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMergeCursorTest.java
@@ -22,14 +22,14 @@ public class ShadowMergeCursorTest {
   private SQLiteCursor dbCursor1;
   private SQLiteCursor dbCursor2;
 
-  private static String[] TABLE_1_INSERTS = {
+  private static final String[] TABLE_1_INSERTS = {
     "INSERT INTO table_1 (id, name_1, value_1, float_value_1, double_value_1) VALUES(1234,"
         + " 'Chuck', 3463, 1.5, 3.14159);",
     "INSERT INTO table_1 (id, name_1) VALUES(1235, 'Julie');",
     "INSERT INTO table_1 (id, name_1) VALUES(1236, 'Chris');"
   };
 
-  private static String[] TABLE_2_INSERTS = {
+  private static final String[] TABLE_2_INSERTS = {
     "INSERT INTO table_2 (id, name_2, value_2, float_value_2, double_value_2) VALUES(4321, 'Mary',"
         + " 3245, 5.4, 2.7818);",
     "INSERT INTO table_2 (id, name_2) VALUES(4322, 'Elizabeth');",
@@ -158,7 +158,7 @@ public class ShadowMergeCursorTest {
   }
 
   @Test
-  public void testGetDataSingleCursor() throws Exception {
+  public void testGetDataSingleCursor() {
     Cursor[] cursors = new Cursor[1];
     cursors[0] = dbCursor1;
     cursor = new MergeCursor(cursors);
@@ -168,7 +168,7 @@ public class ShadowMergeCursorTest {
   }
 
   @Test
-  public void testGetDataMultipleCursor() throws Exception {
+  public void testGetDataMultipleCursor() {
     Cursor[] cursors = new Cursor[2];
     cursors[0] = dbCursor1;
     cursors[1] = dbCursor2;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNfcAdapterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNfcAdapterTest.java
index a636fc7c8..f061a930f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowNfcAdapterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNfcAdapterTest.java
@@ -40,7 +40,7 @@ public class ShadowNfcAdapterTest {
   }
 
   @Test
-  public void setNdefPushMesageCallback_shouldUseCallback() {
+  public void setNdefPushMessageCallback_shouldUseCallback() {
     final NfcAdapter.CreateNdefMessageCallback callback =
         mock(NfcAdapter.CreateNdefMessageCallback.class);
     final Activity activity = Robolectric.setupActivity(Activity.class);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationBuilderTestBase.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationBuilderTestBase.java
index 39fb9235c..fa481a863 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationBuilderTestBase.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationBuilderTestBase.java
@@ -211,7 +211,7 @@ public abstract class ShadowNotificationBuilderTestBase {
   }
 
   @Test
-  public void build_addsActionToNotification() throws Exception {
+  public void build_addsActionToNotification() {
     PendingIntent action =
         PendingIntent.getBroadcast(ApplicationProvider.getApplicationContext(), 0, null, 0);
     Notification notification = builder.addAction(0, "Action", action).build();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationListenerServiceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationListenerServiceTest.java
index 6c8f0e630..db7277aed 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationListenerServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationListenerServiceTest.java
@@ -67,10 +67,9 @@ public final class ShadowNotificationListenerServiceTest {
     ImmutableList<Notification> dummyNotifications =
         ImmutableList.of(
             createDummyNotification(), createDummyNotification(), createDummyNotification());
-    dummyNotifications.stream()
-        .forEach(
-            notification ->
-                shadowService.addActiveNotification(DEFAULT_PACKAGE, DEFAULT_ID, notification));
+    dummyNotifications.forEach(
+        notification ->
+            shadowService.addActiveNotification(DEFAULT_PACKAGE, DEFAULT_ID, notification));
 
     StatusBarNotification[] activeNotifications = service.getActiveNotifications();
 
@@ -159,10 +158,9 @@ public final class ShadowNotificationListenerServiceTest {
     ImmutableList<Notification> dummyNotifications =
         ImmutableList.of(
             createDummyNotification(), createDummyNotification(), createDummyNotification());
-    dummyNotifications.stream()
-        .forEach(
-            notification ->
-                shadowService.addActiveNotification(DEFAULT_PACKAGE, DEFAULT_ID, notification));
+    dummyNotifications.forEach(
+        notification ->
+            shadowService.addActiveNotification(DEFAULT_PACKAGE, DEFAULT_ID, notification));
 
     service.cancelAllNotifications();
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java
index 83536007c..99a73f3cc 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java
@@ -40,8 +40,8 @@ import org.robolectric.annotation.Config;
 @RunWith(AndroidJUnit4.class)
 public class ShadowNotificationManagerTest {
   private NotificationManager notificationManager;
-  private Notification notification1 = new Notification();
-  private Notification notification2 = new Notification();
+  private final Notification notification1 = new Notification();
+  private final Notification notification2 = new Notification();
 
   @Before
   public void setUp() {
@@ -89,8 +89,7 @@ public class ShadowNotificationManagerTest {
     notificationManager.createNotificationChannel(new NotificationChannel("id", "name", 1));
 
     assertThat(shadowOf(notificationManager).getNotificationChannels()).hasSize(1);
-    NotificationChannel channel =
-        (NotificationChannel) shadowOf(notificationManager).getNotificationChannel("id");
+    NotificationChannel channel = shadowOf(notificationManager).getNotificationChannel("id");
     assertThat(channel.getName().toString()).isEqualTo("name");
     assertThat(channel.getImportance()).isEqualTo(1);
   }
@@ -120,8 +119,7 @@ public class ShadowNotificationManagerTest {
     notificationManager.createNotificationChannel(channelUpdate);
 
     assertThat(shadowOf(notificationManager).getNotificationChannels()).hasSize(1);
-    NotificationChannel resultChannel =
-        (NotificationChannel) shadowOf(notificationManager).getNotificationChannel("id");
+    NotificationChannel resultChannel = shadowOf(notificationManager).getNotificationChannel("id");
     assertThat(resultChannel.getName().toString()).isEqualTo("newName");
     assertThat(resultChannel.getDescription()).isEqualTo("newDescription");
     // No importance upgrade.
@@ -146,8 +144,7 @@ public class ShadowNotificationManagerTest {
     notificationManager.createNotificationChannel(channelUpdate);
 
     assertThat(shadowOf(notificationManager).getNotificationChannels()).hasSize(1);
-    NotificationChannel resultChannel =
-        (NotificationChannel) shadowOf(notificationManager).getNotificationChannel("id");
+    NotificationChannel resultChannel = shadowOf(notificationManager).getNotificationChannel("id");
     assertThat(resultChannel.getName().toString()).isEqualTo("newName");
     assertThat(resultChannel.getDescription()).isEqualTo("newDescription");
     assertThat(resultChannel.getImportance()).isEqualTo(0);
@@ -161,7 +158,7 @@ public class ShadowNotificationManagerTest {
 
     assertThat(shadowOf(notificationManager).getNotificationChannelGroups()).hasSize(1);
     NotificationChannelGroup group =
-        (NotificationChannelGroup) shadowOf(notificationManager).getNotificationChannelGroup("id");
+        shadowOf(notificationManager).getNotificationChannelGroup("id");
     assertThat(group.getName().toString()).isEqualTo("name");
   }
 
@@ -174,11 +171,10 @@ public class ShadowNotificationManagerTest {
     notificationManager.createNotificationChannels(ImmutableList.of(channel1, channel2));
 
     assertThat(shadowOf(notificationManager).getNotificationChannels()).hasSize(2);
-    NotificationChannel channel =
-        (NotificationChannel) shadowOf(notificationManager).getNotificationChannel("id");
+    NotificationChannel channel = shadowOf(notificationManager).getNotificationChannel("id");
     assertThat(channel.getName().toString()).isEqualTo("name");
     assertThat(channel.getImportance()).isEqualTo(1);
-    channel = (NotificationChannel) shadowOf(notificationManager).getNotificationChannel("id2");
+    channel = shadowOf(notificationManager).getNotificationChannel("id2");
     assertThat(channel.getName().toString()).isEqualTo("name2");
     assertThat(channel.getImportance()).isEqualTo(1);
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNsdManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNsdManagerTest.java
new file mode 100644
index 000000000..d597747cd
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNsdManagerTest.java
@@ -0,0 +1,353 @@
+package org.robolectric.shadows;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.app.Application;
+import android.content.Context;
+import android.net.Network;
+import android.net.nsd.NsdManager;
+import android.net.nsd.NsdManager.DiscoveryListener;
+import android.net.nsd.NsdManager.RegistrationListener;
+import android.net.nsd.NsdManager.ResolveListener;
+import android.net.nsd.NsdServiceInfo;
+import android.os.Build.VERSION_CODES;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.util.List;
+import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadow.api.Shadow;
+
+@RunWith(AndroidJUnit4.class)
+public final class ShadowNsdManagerTest {
+
+  private Application context;
+  private NsdManager nsdManager;
+  private ShadowNsdManager shadowNsdManager;
+  private FakeExecutor fakeExecutor;
+  @Mock private RegistrationListener registrationListener;
+  @Mock private DiscoveryListener discoveryListener;
+  @Mock private ResolveListener resolveListener;
+
+  @Rule(order = 0)
+  public final MockitoRule mockito = MockitoJUnit.rule();
+
+  @Before
+  public void setUp() {
+    context = ApplicationProvider.getApplicationContext();
+    nsdManager = (NsdManager) context.getSystemService(Context.NSD_SERVICE);
+    shadowNsdManager = Shadow.extract(nsdManager);
+    fakeExecutor = new FakeExecutor();
+  }
+
+  @Config(minSdk = VERSION_CODES.TIRAMISU)
+  @Test
+  public void registerService_withExecutor_invokesListener() {
+    // First register a service.
+    NsdServiceInfo serviceInfo = new NsdServiceInfo();
+    serviceInfo.setServiceName("test_service");
+    serviceInfo.setServiceType("foo.bar");
+    serviceInfo.setAttribute("abc", "def");
+    serviceInfo.setPort(1234);
+
+    nsdManager.registerService(
+        serviceInfo, NsdManager.PROTOCOL_DNS_SD, fakeExecutor, registrationListener);
+
+    // See if executor was used for callback.
+    assertThat(fakeExecutor.command).isNotNull();
+    // Check that the shadow provides the registered listener.
+    RegistrationListener registeredListener = shadowNsdManager.getRegistrationListener(serviceInfo);
+    assertThat(registeredListener).isNotNull();
+    assertThat(registeredListener).isEqualTo(registrationListener);
+
+    // Check that the shadow provides the registered service info by listener.
+    assertThat(shadowNsdManager.getRegisteredServiceInfo(registrationListener))
+        .isEqualTo(serviceInfo);
+    // Now we can run the callback.
+    fakeExecutor.command.run();
+    // Check that the listener was properly notified of the (successful) registration.
+    verify(registrationListener).onServiceRegistered(serviceInfo);
+  }
+
+  @Config(minSdk = VERSION_CODES.TIRAMISU)
+  @Test
+  public void registerService_withExecutor_failsOnBadProtocol() {
+    // Try to register a service.
+    NsdServiceInfo serviceInfo = new NsdServiceInfo();
+    serviceInfo.setServiceName("test_service");
+    serviceInfo.setServiceType("foo.bar");
+    serviceInfo.setAttribute("abc", "def");
+    serviceInfo.setPort(1234);
+
+    nsdManager.registerService(serviceInfo, -1, fakeExecutor, registrationListener);
+
+    // See if executor was used for callback.
+    assertThat(fakeExecutor.command).isNotNull();
+    // Now we can run the callback.
+    fakeExecutor.command.run();
+    // Check that the listener was properly notified of the registration failure.
+    verify(registrationListener)
+        .onRegistrationFailed(serviceInfo, NsdManager.FAILURE_BAD_PARAMETERS);
+  }
+
+  @Test
+  public void registerService_invokesListener() {
+    // First register a service.
+    NsdServiceInfo serviceInfo = new NsdServiceInfo();
+    serviceInfo.setServiceName("test_service");
+    serviceInfo.setServiceType("foo.bar");
+    serviceInfo.setAttribute("abc", "def");
+    serviceInfo.setPort(1234);
+
+    nsdManager.registerService(serviceInfo, NsdManager.PROTOCOL_DNS_SD, registrationListener);
+
+    // Check that the shadow provides the registered listener.
+    RegistrationListener registeredListener = shadowNsdManager.getRegistrationListener(serviceInfo);
+    assertThat(registeredListener).isNotNull();
+    assertThat(registeredListener).isEqualTo(registrationListener);
+
+    // Check that the shadow provides the registered service info by listener.
+    assertThat(shadowNsdManager.getRegisteredServiceInfo(registrationListener))
+        .isEqualTo(serviceInfo);
+    // Check that the listener was properly notified of the (successful) registration.
+    verify(registrationListener).onServiceRegistered(serviceInfo);
+  }
+
+  @Test
+  public void registerService_withBadProtocolType_invokesFailureCallback() {
+    // Create a test registration listener.
+    // First register a service.
+    NsdServiceInfo serviceInfo = new NsdServiceInfo();
+    serviceInfo.setServiceName("test_service");
+    serviceInfo.setServiceType("foo.bar");
+    serviceInfo.setAttribute("abc", "def");
+    serviceInfo.setPort(1234);
+
+    nsdManager.registerService(serviceInfo, NsdManager.PROTOCOL_DNS_SD - 1, registrationListener);
+
+    // Check that the listener was properly notified of the failed registration.
+    verify(registrationListener)
+        .onRegistrationFailed(serviceInfo, NsdManager.FAILURE_BAD_PARAMETERS);
+  }
+
+  @Test
+  public void registerService_withRegisteredListener_throwsException() {
+    // Register a service.
+    NsdServiceInfo serviceInfo = createTestServiceInfo();
+
+    nsdManager.registerService(serviceInfo, NsdManager.PROTOCOL_DNS_SD, registrationListener);
+
+    verify(registrationListener).onServiceRegistered(serviceInfo);
+
+    // Try to register the same listener for a different service.
+    NsdServiceInfo serviceInfo2 = createTestServiceInfo();
+    serviceInfo2.setServiceName("test_service2");
+    serviceInfo2.setServiceType("foo.baz");
+    assertThrows(
+        UnsupportedOperationException.class,
+        () ->
+            nsdManager.registerService(
+                serviceInfo2, NsdManager.PROTOCOL_DNS_SD, registrationListener));
+  }
+
+  @Test
+  public void unregisterService_withUnregisteredListener_throwsException() {
+    // Try to unregister without ever registering.
+    assertThrows(
+        UnsupportedOperationException.class,
+        () -> nsdManager.unregisterService(registrationListener));
+    // No callbacks should happen.
+    verify(registrationListener, never()).onServiceRegistered(any());
+    verify(registrationListener, never()).onServiceUnregistered(any());
+    verify(registrationListener, never()).onUnregistrationFailed(any(), anyInt());
+  }
+
+  @Test
+  public void unregisterService_withRegisteredListener_invokesListener() {
+    // Create a test registration listener.
+    NsdServiceInfo serviceInfo = createTestServiceInfo();
+
+    nsdManager.registerService(serviceInfo, NsdManager.PROTOCOL_DNS_SD, registrationListener);
+
+    verify(registrationListener).onServiceRegistered(serviceInfo);
+    verify(registrationListener, never()).onServiceUnregistered(any());
+
+    nsdManager.unregisterService(registrationListener);
+
+    verify(registrationListener).onServiceUnregistered(serviceInfo);
+  }
+
+  @Config(minSdk = VERSION_CODES.TIRAMISU)
+  @Test
+  public void discoverServices_withExecutor_invokesListener() {
+    // First register for service discovery.
+    String serviceType = "foo.bar";
+
+    nsdManager.discoverServices(
+        serviceType, NsdManager.PROTOCOL_DNS_SD, (Network) null, fakeExecutor, discoveryListener);
+
+    // See if executor was used for callback.
+    assertThat(fakeExecutor.command).isNotNull();
+    // Now we can run the callback.
+    fakeExecutor.command.run();
+
+    // Check that the listener was notified of discovery start.
+    verify(discoveryListener).onDiscoveryStarted(serviceType);
+  }
+
+  @Test
+  public void discoverServices_invokesListener() {
+    // First register for service discovery.
+    String serviceType = "foo.bar";
+
+    nsdManager.discoverServices(serviceType, NsdManager.PROTOCOL_DNS_SD, discoveryListener);
+
+    // Check that the shadow provides the discovery listener.
+    List<DiscoveryListener> discoveryListeners =
+        shadowNsdManager.getDiscoveryListeners(serviceType);
+    assertThat(discoveryListeners).isNotNull();
+    assertThat(discoveryListeners).containsExactly(discoveryListener);
+
+    // Check that the shadow provides the service info by discovery listener.
+    assertThat(shadowNsdManager.getDiscoveryListenerServiceType(discoveryListener))
+        .isEqualTo(serviceType);
+    // Check that the listener was notified of discovery start.
+    verify(discoveryListener).onDiscoveryStarted(serviceType);
+  }
+
+  @Test
+  public void discoverServices_sameListener_throwsException() {
+    // First register for service discovery.
+    String serviceType = "foo.bar";
+
+    nsdManager.discoverServices(serviceType, NsdManager.PROTOCOL_DNS_SD, discoveryListener);
+
+    // Now try to register same listener again.
+    assertThrows(
+        UnsupportedOperationException.class,
+        () ->
+            nsdManager.discoverServices(
+                serviceType, NsdManager.PROTOCOL_DNS_SD, discoveryListener));
+  }
+
+  @Test
+  public void getDiscoveryListeners_getsCorrectListener() {
+    // First register for service discovery.
+    String serviceType = "foo.bar";
+
+    nsdManager.discoverServices(serviceType, NsdManager.PROTOCOL_DNS_SD, discoveryListener);
+
+    // Discovery started but nothing discovered yet.
+    verify(discoveryListener).onDiscoveryStarted(serviceType);
+    verify(discoveryListener, never()).onServiceFound(any());
+
+    // Now try to fetch the same listener.
+    DiscoveryListener listener = shadowNsdManager.getDiscoveryListeners(serviceType).get(0);
+    // Perform fake discovery callback.
+    listener.onServiceFound(createTestServiceInfo());
+    verify(discoveryListener).onServiceFound(any());
+  }
+
+  @Test
+  public void getDiscoveryListenerServiceType_getsCorrectServiceType() {
+    // First register for service discovery.
+    String serviceType = "foo.bar";
+
+    nsdManager.discoverServices(serviceType, NsdManager.PROTOCOL_DNS_SD, discoveryListener);
+    assertThat(shadowNsdManager.getDiscoveryListenerServiceType(discoveryListener))
+        .isEqualTo(serviceType);
+  }
+
+  @Test
+  public void stopServiceDiscovery_invokesListener() {
+    // First register for service discovery.
+    String serviceType = "foo.bar";
+
+    nsdManager.discoverServices(serviceType, NsdManager.PROTOCOL_DNS_SD, discoveryListener);
+
+    // Stop discovery.
+    nsdManager.stopServiceDiscovery(discoveryListener);
+
+    // Check that the shadow made callbacks.
+    verify(discoveryListener).onDiscoveryStopped(serviceType);
+    // Check that listener is no longer registered.
+    assertThat(shadowNsdManager.getDiscoveryListeners(serviceType)).isNull();
+  }
+
+  @Test
+  public void stopServiceDiscovery_withUnregisteredListener_throwsException() {
+    assertThrows(
+        UnsupportedOperationException.class,
+        () -> nsdManager.stopServiceDiscovery(discoveryListener));
+
+    // Check that the shadow made no callbacks.
+    verify(discoveryListener, never()).onDiscoveryStopped(any());
+    verify(discoveryListener, never()).onDiscoveryStarted(any());
+    verify(discoveryListener, never()).onServiceFound(any());
+  }
+
+  @Test
+  public void resolveService_savesListener() {
+    // First register for service resolution.
+    NsdServiceInfo serviceInfo = createTestServiceInfo();
+    nsdManager.resolveService(serviceInfo, resolveListener);
+    assertThat(shadowNsdManager.getResolveListeners(serviceInfo)).containsExactly(resolveListener);
+    assertThat(shadowNsdManager.getResolveListenerServiceInfo(resolveListener))
+        .isEqualTo(serviceInfo);
+  }
+
+  @Test
+  public void resolveService_withRegisteredListener_throwsException() {
+    // First register for service resolution.
+    NsdServiceInfo serviceInfo = createTestServiceInfo();
+    nsdManager.resolveService(serviceInfo, resolveListener);
+    assertThat(shadowNsdManager.getResolveListeners(serviceInfo)).containsExactly(resolveListener);
+    assertThat(shadowNsdManager.getResolveListenerServiceInfo(resolveListener))
+        .isEqualTo(serviceInfo);
+  }
+
+  @Test
+  public void removeResolveListener_removesListener() {
+    // First register for service resolution.
+    NsdServiceInfo serviceInfo = createTestServiceInfo();
+    nsdManager.resolveService(serviceInfo, resolveListener);
+    assertThat(shadowNsdManager.getResolveListeners(serviceInfo)).containsExactly(resolveListener);
+    assertThat(shadowNsdManager.getResolveListenerServiceInfo(resolveListener))
+        .isEqualTo(serviceInfo);
+    // Now remove the listener.
+    shadowNsdManager.removeResolveListener(resolveListener);
+    assertThat(shadowNsdManager.getResolveListeners(serviceInfo)).isEmpty();
+    assertThat(shadowNsdManager.getResolveListenerServiceInfo(resolveListener)).isNull();
+  }
+
+  public static class FakeExecutor implements Executor {
+    @Nullable public Runnable command = null;
+
+    @Override
+    public void execute(Runnable command) {
+      this.command = command;
+    }
+  }
+
+  private NsdServiceInfo createTestServiceInfo() {
+    NsdServiceInfo serviceInfo = new NsdServiceInfo();
+    serviceInfo.setServiceName("test_service");
+    serviceInfo.setServiceType("foo.bar");
+    serviceInfo.setAttribute("abc", "def");
+    serviceInfo.setPort(1234);
+    return serviceInfo;
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowObjectAnimatorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowObjectAnimatorTest.java
index b078f4cb3..9cfe3ceff 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowObjectAnimatorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowObjectAnimatorTest.java
@@ -9,33 +9,34 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.time.Duration;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nonnull;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowObjectAnimatorTest {
   private final AnimatorTarget target = new AnimatorTarget();
-  private List<String> listenerEvents = new ArrayList<>();
+  private final List<String> listenerEvents = new ArrayList<>();
 
   private final Animator.AnimatorListener listener =
       new Animator.AnimatorListener() {
         @Override
-        public void onAnimationStart(Animator animation) {
+        public void onAnimationStart(@Nonnull Animator animation) {
           listenerEvents.add("started");
         }
 
         @Override
-        public void onAnimationEnd(Animator animation) {
+        public void onAnimationEnd(@Nonnull Animator animation) {
           listenerEvents.add("ended");
         }
 
         @Override
-        public void onAnimationCancel(Animator animation) {
+        public void onAnimationCancel(@Nonnull Animator animation) {
           listenerEvents.add("cancelled");
         }
 
         @Override
-        public void onAnimationRepeat(Animator animation) {
+        public void onAnimationRepeat(@Nonnull Animator animation) {
           listenerEvents.add("repeated");
         }
       };
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageInstallerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageInstallerTest.java
index 5c21f36f7..7165df1f9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageInstallerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageInstallerTest.java
@@ -145,7 +145,7 @@ public class ShadowPackageInstallerTest {
   }
 
   @Test(expected = SecurityException.class)
-  public void packageInstallerOpenSession_nonExistantSessionThrowsException() throws Exception {
+  public void packageInstallerOpenSession_nonExistentSessionThrowsException() throws Exception {
     packageInstaller.openSession(-99);
   }
 
@@ -320,7 +320,7 @@ public class ShadowPackageInstallerTest {
   }
 
   @Test
-  public void uninstallMaxVersion() throws Exception {
+  public void uninstallMaxVersion() {
     packageInstaller.uninstall("packageName", /* statusReceiver */ null);
 
     assertThat(shadowOf(packageInstaller).getLastUninstalledVersion("packageName"))
@@ -329,7 +329,7 @@ public class ShadowPackageInstallerTest {
   }
 
   @Test
-  public void uninstallMaxVersionWithStatusReceiver() throws Exception {
+  public void uninstallMaxVersionWithStatusReceiver() {
     IntentSender intentSender = createStatusReceiver();
     packageInstaller.uninstall("packageName", intentSender);
 
@@ -341,7 +341,7 @@ public class ShadowPackageInstallerTest {
 
   @Config(sdk = O)
   @Test
-  public void uninstallVersion() throws Exception {
+  public void uninstallVersion() {
     packageInstaller.uninstall(new VersionedPackage("packageName", 1), /* statusReceiver */ null);
 
     assertThat(shadowOf(packageInstaller).getLastUninstalledVersion("packageName")).isEqualTo(1);
@@ -350,7 +350,7 @@ public class ShadowPackageInstallerTest {
 
   @Config(sdk = UPSIDE_DOWN_CAKE)
   @Test
-  public void uninstallVersionWithFlags() throws Exception {
+  public void uninstallVersionWithFlags() {
     packageInstaller.uninstall(
         new VersionedPackage("packageName", 1), /* flags= */ 0, /* statusReceiver= */ null);
 
@@ -360,7 +360,7 @@ public class ShadowPackageInstallerTest {
 
   @Config(sdk = S)
   @Test
-  public void uninstallExtistingPackage() throws Exception {
+  public void uninstallExistingPackage() {
     packageInstaller.uninstallExistingPackage("packageName", /* IntentSender */ null);
 
     assertThat(shadowOf(packageInstaller).getLastUninstalledVersion("packageName"))
@@ -369,7 +369,7 @@ public class ShadowPackageInstallerTest {
   }
 
   @Test
-  public void nothingUninstalled() throws Exception {
+  public void nothingUninstalled() {
     assertThat(shadowOf(packageInstaller).getLastUninstalledVersion("packageName")).isNull();
     assertThat(shadowOf(packageInstaller).getLastUninstalledStatusReceiver("packageName")).isNull();
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageManagerTest.java
index e27e27bf5..d134c5918 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageManagerTest.java
@@ -135,6 +135,7 @@ import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.GetInstallerPackageNameMode;
 import org.robolectric.annotation.GetInstallerPackageNameMode.Mode;
+import org.robolectric.junit.rules.SetSystemPropertyRule;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowPackageManager.PackageSetting;
 import org.robolectric.shadows.ShadowPackageManager.ResolveInfoComparator;
@@ -162,6 +163,7 @@ public class ShadowPackageManagerTest {
   public static final String ORIGINATING_PACKAGE_NAME = "originating.package";
   public static final String UPDATE_OWNER_PACKAGE_NAME = "update.owner.package";
 
+  @Rule public final SetSystemPropertyRule setSystemPropertyRule = new SetSystemPropertyRule();
   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();
   private Context context;
   private PackageManager packageManager;
@@ -871,15 +873,13 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void getGroupOfPlatformPermission_fromManifest() throws Exception {
+  public void getGroupOfPlatformPermission_fromManifest() {
     String[] permissionGroupArg = new String[1];
 
     packageManager.getGroupOfPlatformPermission(
         "org.robolectric.some_permission",
         context.getMainExecutor(),
-        (group) -> {
-          permissionGroupArg[0] = group;
-        });
+        (group) -> permissionGroupArg[0] = group);
     shadowMainLooper().idle();
 
     assertThat(permissionGroupArg[0]).isNull();
@@ -887,7 +887,7 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void getGroupOfPlatformPermission_fromExtraPermissions() throws Exception {
+  public void getGroupOfPlatformPermission_fromExtraPermissions() {
     String permissionName = "some_other_permission";
     String permissionGroupName = "some_other_permission_group";
     PermissionInfo permissionInfo = new PermissionInfo();
@@ -897,11 +897,7 @@ public class ShadowPackageManagerTest {
     String[] permissionGroupArg = new String[1];
 
     packageManager.getGroupOfPlatformPermission(
-        permissionName,
-        context.getMainExecutor(),
-        (group) -> {
-          permissionGroupArg[0] = group;
-        });
+        permissionName, context.getMainExecutor(), (group) -> permissionGroupArg[0] = group);
     shadowMainLooper().idle();
 
     assertThat(permissionGroupArg[0]).isNull();
@@ -909,7 +905,7 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void getGroupOfPlatformPermission_fromExtraPermissionsPlatformPrefix() throws Exception {
+  public void getGroupOfPlatformPermission_fromExtraPermissionsPlatformPrefix() {
     String permissionName = "android.permission.some_other_permission";
     String permissionGroupName = "some_other_permission_group";
     PermissionInfo permissionInfo = new PermissionInfo();
@@ -919,11 +915,7 @@ public class ShadowPackageManagerTest {
     String[] permissionGroupArg = new String[1];
 
     packageManager.getGroupOfPlatformPermission(
-        permissionName,
-        context.getMainExecutor(),
-        (group) -> {
-          permissionGroupArg[0] = group;
-        });
+        permissionName, context.getMainExecutor(), (group) -> permissionGroupArg[0] = group);
     shadowMainLooper().idle();
 
     assertThat(permissionGroupArg[0]).isEqualTo(permissionGroupName);
@@ -931,15 +923,11 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void getGroupOfPlatformPermission_unknown() throws Exception {
+  public void getGroupOfPlatformPermission_unknown() {
     String[] permissionGroupArg = new String[1];
 
     packageManager.getGroupOfPlatformPermission(
-        "unknown_permission",
-        context.getMainExecutor(),
-        (group) -> {
-          permissionGroupArg[0] = group;
-        });
+        "unknown_permission", context.getMainExecutor(), (group) -> permissionGroupArg[0] = group);
     shadowMainLooper().idle();
 
     assertThat(permissionGroupArg[0]).isNull();
@@ -947,15 +935,11 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void getGroupOfPlatformPermission_fromPlatform() throws Exception {
+  public void getGroupOfPlatformPermission_fromPlatform() {
     String[] permissionGroupArg = new String[1];
 
     packageManager.getGroupOfPlatformPermission(
-        READ_CONTACTS,
-        context.getMainExecutor(),
-        (group) -> {
-          permissionGroupArg[0] = group;
-        });
+        READ_CONTACTS, context.getMainExecutor(), (group) -> permissionGroupArg[0] = group);
     shadowMainLooper().idle();
 
     assertThat(permissionGroupArg[0]).isEqualTo(permission_group.CONTACTS);
@@ -963,7 +947,7 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void getGroupOfPlatformPermission_overriddenPlatformPermission() throws Exception {
+  public void getGroupOfPlatformPermission_overriddenPlatformPermission() {
     PermissionInfo permissionInfo = new PermissionInfo();
     permissionInfo.name = READ_CONTACTS;
     permissionInfo.group = permission_group.CALENDAR;
@@ -971,11 +955,7 @@ public class ShadowPackageManagerTest {
     String[] permissionGroupArg = new String[1];
 
     packageManager.getGroupOfPlatformPermission(
-        READ_CONTACTS,
-        context.getMainExecutor(),
-        (group) -> {
-          permissionGroupArg[0] = group;
-        });
+        READ_CONTACTS, context.getMainExecutor(), (group) -> permissionGroupArg[0] = group);
     shadowMainLooper().idle();
 
     assertThat(permissionGroupArg[0]).isEqualTo(permission_group.CALENDAR);
@@ -983,15 +963,11 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void getPlatformPermissionsForGroup_fromManifest() throws Exception {
+  public void getPlatformPermissionsForGroup_fromManifest() {
     List<List<String>> permissionsArg = new ArrayList<>();
 
     packageManager.getPlatformPermissionsForGroup(
-        "my_permission_group",
-        context.getMainExecutor(),
-        (permissions) -> {
-          permissionsArg.add(permissions);
-        });
+        "my_permission_group", context.getMainExecutor(), permissionsArg::add);
     shadowMainLooper().idle();
 
     assertThat(permissionsArg).hasSize(1);
@@ -1000,7 +976,7 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void getPlatformPermissionsForGroup_fromExtraPermissions() throws Exception {
+  public void getPlatformPermissionsForGroup_fromExtraPermissions() {
     String permissionName1 = "some_other_permission";
     String permissionName2 = "android.permission.my_calendar_permission";
     String permissionGroupName = permission_group.CALENDAR;
@@ -1015,11 +991,7 @@ public class ShadowPackageManagerTest {
     List<List<String>> permissionsArg = new ArrayList<>();
 
     packageManager.getPlatformPermissionsForGroup(
-        permissionGroupName,
-        context.getMainExecutor(),
-        (permissions) -> {
-          permissionsArg.add(permissions);
-        });
+        permissionGroupName, context.getMainExecutor(), permissionsArg::add);
     shadowMainLooper().idle();
 
     assertThat(permissionsArg).hasSize(1);
@@ -1029,15 +1001,11 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void getPlatformPermissionsForGroup_unknown() throws Exception {
+  public void getPlatformPermissionsForGroup_unknown() {
     List<List<String>> permissionsArg = new ArrayList<>();
 
     packageManager.getPlatformPermissionsForGroup(
-        "unknown_permission_group",
-        context.getMainExecutor(),
-        (permissions) -> {
-          permissionsArg.add(permissions);
-        });
+        "unknown_permission_group", context.getMainExecutor(), permissionsArg::add);
     shadowMainLooper().idle();
 
     assertThat(permissionsArg).hasSize(1);
@@ -1046,15 +1014,11 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void getPlatformPermissionsForGroup_fromPlatform() throws Exception {
+  public void getPlatformPermissionsForGroup_fromPlatform() {
     List<List<String>> permissionsArg = new ArrayList<>();
 
     packageManager.getPlatformPermissionsForGroup(
-        permission_group.CALENDAR,
-        context.getMainExecutor(),
-        (permissions) -> {
-          permissionsArg.add(permissions);
-        });
+        permission_group.CALENDAR, context.getMainExecutor(), permissionsArg::add);
     shadowMainLooper().idle();
 
     assertThat(permissionsArg).hasSize(1);
@@ -1063,7 +1027,7 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void getPlatformPermissionsForGroup_overriddenPlatformPermission() throws Exception {
+  public void getPlatformPermissionsForGroup_overriddenPlatformPermission() {
     PermissionInfo permissionInfo = new PermissionInfo();
     permissionInfo.name = READ_CONTACTS;
     permissionInfo.group = permission_group.CALENDAR;
@@ -1071,11 +1035,7 @@ public class ShadowPackageManagerTest {
     List<List<String>> permissionsArg = new ArrayList<>();
 
     packageManager.getPlatformPermissionsForGroup(
-        permission_group.CALENDAR,
-        context.getMainExecutor(),
-        (permissions) -> {
-          permissionsArg.add(permissions);
-        });
+        permission_group.CALENDAR, context.getMainExecutor(), permissionsArg::add);
     shadowMainLooper().idle();
 
     assertThat(permissionsArg).hasSize(1);
@@ -1702,7 +1662,7 @@ public class ShadowPackageManagerTest {
   }
 
   @Test
-  public void addIntentFilterForComponent() throws Exception {
+  public void addIntentFilterForComponent() {
     ComponentName testComponent = new ComponentName("package", "name");
     IntentFilter intentFilter = new IntentFilter("ACTION");
     intentFilter.addCategory(Intent.CATEGORY_DEFAULT);
@@ -1778,7 +1738,7 @@ public class ShadowPackageManagerTest {
   }
 
   @Test
-  public void resolveExplicitIntent_sameApp() throws Exception {
+  public void resolveExplicitIntent_sameApp() {
     ComponentName testComponent = new ComponentName(RuntimeEnvironment.getApplication(), "name");
     IntentFilter intentFilter = new IntentFilter("ACTION");
 
@@ -1792,7 +1752,7 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = TIRAMISU)
-  public void resolveExplicitIntent_filterMatch() throws Exception {
+  public void resolveExplicitIntent_filterMatch() {
     ComponentName testComponent = new ComponentName("some.other.package", "name");
     IntentFilter intentFilter = new IntentFilter("ACTION");
 
@@ -1807,7 +1767,7 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = TIRAMISU)
-  public void resolveExplicitIntent_noFilterMatch() throws Exception {
+  public void resolveExplicitIntent_noFilterMatch() {
     ComponentName testComponent = new ComponentName("some.other.package", "name");
     IntentFilter intentFilter = new IntentFilter("ACTION");
 
@@ -1819,7 +1779,7 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(maxSdk = S)
-  public void resolveExplicitIntent_noFilterMatch_belowT() throws Exception {
+  public void resolveExplicitIntent_noFilterMatch_belowT() {
     ComponentName testComponent = new ComponentName("some.other.package", "name");
     IntentFilter intentFilter = new IntentFilter("ACTION");
 
@@ -1831,7 +1791,7 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = TIRAMISU)
-  public void resolveExplicitIntent_noFilterMatch_targetBelowT() throws Exception {
+  public void resolveExplicitIntent_noFilterMatch_targetBelowT() {
     PackageInfo testPackage =
         PackageInfoBuilder.newBuilder().setPackageName("some.other.package").build();
     testPackage.applicationInfo.targetSdkVersion = S;
@@ -1847,7 +1807,7 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = TIRAMISU)
-  public void resolveExplicitIntent_noAction() throws Exception {
+  public void resolveExplicitIntent_noAction() {
     ComponentName testComponent = new ComponentName("some.other.package", "name");
     IntentFilter intentFilter = new IntentFilter("ACTION");
 
@@ -2198,6 +2158,23 @@ public class ShadowPackageManagerTest {
     assertThat(packageManager.getApplicationIcon(applicationInfo)).isSameInstanceAs(d);
   }
 
+  @Test
+  public void getApplicationIcon_fromInfoNoShadow_returnsDrawable() {
+    setSystemPropertyRule.set("robolectric.useValidGetApplicationIcon", "true");
+    ApplicationInfo applicationInfo = new ApplicationInfo();
+    applicationInfo.packageName = TEST_PACKAGE_NAME;
+
+    Drawable d = packageManager.getApplicationIcon(applicationInfo);
+    assertThat(d).isNotNull();
+  }
+
+  @Test
+  public void getApplicationIcon_fromPackageNoShadow_throws() {
+    setSystemPropertyRule.set("robolectric.useValidGetApplicationIcon", "true");
+    assertThrows(
+        NameNotFoundException.class, () -> packageManager.getApplicationIcon(TEST_PACKAGE_NAME));
+  }
+
   @Test
   public void hasSystemFeature() {
     // uninitialized
@@ -2237,7 +2214,7 @@ public class ShadowPackageManagerTest {
     ActivityInfo activityInfoWithFilters =
         findActivity(packageInfo.activities, ActivityWithFilters.class.getName());
     assertThat(activityInfoWithFilters.packageName).isEqualTo("org.robolectric");
-    assertThat(activityInfoWithFilters.exported).isEqualTo(true);
+    assertThat(activityInfoWithFilters.exported).isTrue();
     assertThat(activityInfoWithFilters.permission).isEqualTo("com.foo.MY_PERMISSION");
   }
 
@@ -2567,9 +2544,9 @@ public class ShadowPackageManagerTest {
     int filterCount = packageManager.getPreferredActivities(filters, activities, null);
 
     assertThat(filterCount).isEqualTo(1);
-    assertThat(activities.size()).isEqualTo(1);
+    assertThat(activities).hasSize(1);
     assertThat(activities.get(0).getPackageName()).isEqualTo(packageName);
-    assertThat(filters.size()).isEqualTo(1);
+    assertThat(filters).hasSize(1);
 
     filterCount = packageManager.getPreferredActivities(filters, activities, "other");
 
@@ -2669,8 +2646,8 @@ public class ShadowPackageManagerTest {
     assertThat(meta.getString("org.robolectric.metaName1")).isEqualTo("metaValue1");
     assertThat(meta.getString("org.robolectric.metaName2")).isEqualTo("metaValue2");
 
-    assertThat(meta.getBoolean("org.robolectric.metaFalseLiteral")).isEqualTo(false);
-    assertThat(meta.getBoolean("org.robolectric.metaTrueLiteral")).isEqualTo(true);
+    assertThat(meta.getBoolean("org.robolectric.metaFalseLiteral")).isFalse();
+    assertThat(meta.getBoolean("org.robolectric.metaTrueLiteral")).isTrue();
 
     assertThat(meta.getInt("org.robolectric.metaInt")).isEqualTo(123);
     assertThat(meta.getFloat("org.robolectric.metaFloat")).isEqualTo(1.23f);
@@ -2921,7 +2898,7 @@ public class ShadowPackageManagerTest {
   public void getPackagesForUid() {
     assertThat(packageManager.getPackagesForUid(10)).isNull();
 
-    shadowOf(packageManager).setPackagesForUid(10, new String[] {"a_name"});
+    shadowOf(packageManager).setPackagesForUid(10, "a_name");
 
     assertThat(packageManager.getPackagesForUid(10)).asList().containsExactly("a_name");
   }
@@ -2929,7 +2906,7 @@ public class ShadowPackageManagerTest {
   @Test
   @Config(minSdk = N)
   public void getPackageUid() throws NameNotFoundException {
-    shadowOf(packageManager).setPackagesForUid(10, new String[] {"a_name"});
+    shadowOf(packageManager).setPackagesForUid(10, "a_name");
     assertThat(packageManager.getPackageUid("a_name", 0)).isEqualTo(10);
   }
 
@@ -2947,7 +2924,7 @@ public class ShadowPackageManagerTest {
   @Test
   @Config(minSdk = TIRAMISU)
   public void getPackageUid_sdkT() throws NameNotFoundException {
-    shadowOf(packageManager).setPackagesForUid(10, new String[] {"a_name"});
+    shadowOf(packageManager).setPackagesForUid(10, "a_name");
     assertThat(packageManager.getPackageUid("a_name", PackageInfoFlags.of(0))).isEqualTo(10);
   }
 
@@ -2964,7 +2941,7 @@ public class ShadowPackageManagerTest {
 
   @Test
   public void getPackagesForUid_shouldReturnSetPackageName() {
-    shadowOf(packageManager).setPackagesForUid(10, new String[] {"a_name"});
+    shadowOf(packageManager).setPackagesForUid(10, "a_name");
     assertThat(packageManager.getPackagesForUid(10)).asList().containsExactly("a_name");
   }
 
@@ -3389,7 +3366,7 @@ public class ShadowPackageManagerTest {
   @Test
   public void getPermissionInfo_notFound() {
     try {
-      packageManager.getPermissionInfo("non_existant_permission", 0);
+      packageManager.getPermissionInfo("non_existent_permission", 0);
       fail("should have thrown NameNotFoundException");
     } catch (NameNotFoundException e) {
       // expected
@@ -3607,7 +3584,7 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = VERSION_CODES.R)
-  public void getInstallerSourceInfo_notExists_throwsException() throws Exception {
+  public void getInstallerSourceInfo_notExists_throwsException() {
     assertThrows(
         NameNotFoundException.class,
         () -> packageManager.getInstallSourceInfo("nonExistTarget.package"));
@@ -3953,7 +3930,7 @@ public class ShadowPackageManagerTest {
 
     shadowOf(packageManager).doPendingUninstallCallbacks();
 
-    assertThat(shadowOf(packageManager).getDeletedPackages()).hasSize(0);
+    assertThat(shadowOf(packageManager).getDeletedPackages()).isEmpty();
     verify(mockObserver)
         .packageDeleted(packageInfo.packageName, PackageManager.DELETE_FAILED_INTERNAL_ERROR);
   }
@@ -3961,7 +3938,7 @@ public class ShadowPackageManagerTest {
   private static class ActivityWithFilters extends Activity {}
 
   @Test
-  public void getIntentFiltersForComponent() throws Exception {
+  public void getIntentFiltersForComponent() {
     List<IntentFilter> intentFilters =
         shadowOf(packageManager)
             .getIntentFiltersForActivity(new ComponentName(context, ActivityWithFilters.class));
@@ -4103,7 +4080,7 @@ public class ShadowPackageManagerTest {
         /* suspended= */ true,
         /* appExtras= */ null,
         /* launcherExtras= */ null,
-        /* dialogMessage= */ (String) null);
+        /* dialogMessage= */ null);
     assertThat(packageManager.isPackageSuspended(TEST_PACKAGE_NAME)).isTrue();
   }
 
@@ -4131,13 +4108,13 @@ public class ShadowPackageManagerTest {
         /* suspended= */ true,
         /* appExtras= */ null,
         /* launcherExtras= */ null,
-        /* dialogMessage= */ (String) null);
+        /* dialogMessage= */ null);
     setPackagesSuspended(
         new String[] {TEST_PACKAGE_NAME},
         /* suspended= */ false,
         /* appExtras= */ null,
         /* launcherExtras= */ null,
-        /* dialogMessage= */ (String) null);
+        /* dialogMessage= */ null);
     assertThat(packageManager.isPackageSuspended(TEST_PACKAGE_NAME)).isFalse();
   }
 
@@ -4174,7 +4151,7 @@ public class ShadowPackageManagerTest {
           /* suspended= */ true,
           /* appExtras= */ null,
           /* launcherExtras= */ null,
-          /* dialogMessage= */ (String) null);
+          /* dialogMessage= */ null);
       fail("Should have thrown UnsupportedOperationException");
     } catch (UnsupportedOperationException expected) {
     }
@@ -4235,7 +4212,7 @@ public class ShadowPackageManagerTest {
           /* suspended= */ true,
           /* appExtras= */ null,
           /* launcherExtras= */ null,
-          /* dialogMessage= */ (String) null);
+          /* dialogMessage= */ null);
       fail("Should have thrown UnsupportedOperationException");
     } catch (UnsupportedOperationException expected) {
     }
@@ -4305,7 +4282,7 @@ public class ShadowPackageManagerTest {
                 /* suspended= */ true,
                 /* appExtras= */ null,
                 /* launcherExtras= */ null,
-                /* dialogMessage= */ (String) null))
+                /* dialogMessage= */ null))
         .asList()
         .containsExactly("com.nonexistent.package", "android", context.getPackageName());
 
@@ -4430,7 +4407,7 @@ public class ShadowPackageManagerTest {
         /* suspended= */ false,
         /* appExtras= */ null,
         /* launcherExtras= */ null,
-        /* dialogMessage= */ (String) null);
+        /* dialogMessage= */ null);
 
     assertThat(
             setPackagesSuspended(
@@ -4444,7 +4421,7 @@ public class ShadowPackageManagerTest {
                 /* suspended= */ false,
                 /* appExtras= */ null,
                 /* launcherExtras= */ null,
-                /* dialogMessage= */ (String) null))
+                /* dialogMessage= */ null))
         .asList()
         .containsExactly("com.nonexistent.package", "android", context.getPackageName());
 
@@ -4982,7 +4959,7 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = S)
-  public void getProperty_component() throws NameNotFoundException {
+  public void getProperty_component() {
     final ComponentName componentName =
         new ComponentName(RuntimeEnvironment.getApplication().getPackageName(), "mycomponentname");
     assertThrows(
@@ -5092,6 +5069,46 @@ public class ShadowPackageManagerTest {
     }
   }
 
+  @Test
+  public void addPackageInternal_platformPermissionGroupWithPropertySet_succeeds() {
+    setSystemPropertyRule.set("robolectric.allowPlatformPermissions", "true");
+    Package pkg = new Package(TEST_PACKAGE_NAME);
+    ApplicationInfo appInfo = pkg.applicationInfo;
+    appInfo.flags = ApplicationInfo.FLAG_INSTALLED;
+    appInfo.packageName = TEST_PACKAGE_NAME;
+    appInfo.sourceDir = TEST_APP_PATH;
+    appInfo.name = TEST_PACKAGE_LABEL;
+    PermissionGroupInfo pgi = new PermissionGroupInfo();
+    pgi.name = permission_group.CALENDAR;
+    PermissionGroup pg = new PermissionGroup(pkg, pgi);
+    pkg.permissionGroups.add(pg);
+
+    shadowOf(packageManager).addPackageInternal(pkg); // should not throw
+  }
+
+  @Test
+  public void addPackage_platformPermission_throws() {
+    PackageInfo packageInfo = generateTestPackageInfo();
+    PermissionInfo permissionInfo = new PermissionInfo();
+    permissionInfo.name = "android.permission.READ_CONTACTS";
+    packageInfo.permissions = new PermissionInfo[] {permissionInfo};
+
+    assertThrows(
+        IllegalArgumentException.class,
+        () -> shadowOf(packageManager).addPackageNoDefaults(packageInfo));
+  }
+
+  @Test
+  public void addPackage_platformPermissionWhenAllowed_succeeds() {
+    setSystemPropertyRule.set("robolectric.allowPlatformPermissions", "true");
+    PackageInfo packageInfo = generateTestPackageInfo();
+    PermissionInfo permissionInfo = new PermissionInfo();
+    permissionInfo.name = "android.permission.READ_CONTACTS";
+    packageInfo.permissions = new PermissionInfo[] {permissionInfo};
+
+    shadowOf(packageManager).addPackageNoDefaults(packageInfo); // should not throw
+  }
+
   public String[] setPackagesSuspended(
       String[] packageNames,
       boolean suspended,
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelFileDescriptorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelFileDescriptorTest.java
index 3d852a08a..5273205d0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelFileDescriptorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelFileDescriptorTest.java
@@ -89,15 +89,8 @@ public class ShadowParcelFileDescriptorTest {
   }
 
   @Test
-  public void testOpenWithOnCloseListener_nullHandler() throws Exception {
-    final AtomicBoolean onCloseCalled = new AtomicBoolean(false);
-    ParcelFileDescriptor.OnCloseListener onCloseListener =
-        new ParcelFileDescriptor.OnCloseListener() {
-          @Override
-          public void onClose(IOException e) {
-            onCloseCalled.set(true);
-          }
-        };
+  public void testOpenWithOnCloseListener_nullHandler() {
+    ParcelFileDescriptor.OnCloseListener onCloseListener = e -> {};
     assertThrows(
         IllegalArgumentException.class,
         () ->
@@ -106,7 +99,7 @@ public class ShadowParcelFileDescriptorTest {
   }
 
   @Test
-  public void testOpenWithOnCloseListener_nullOnCloseListener() throws Exception {
+  public void testOpenWithOnCloseListener_nullOnCloseListener() {
     HandlerThread handlerThread = new HandlerThread("test");
     handlerThread.start();
     Handler handler = new Handler(handlerThread.getLooper());
@@ -122,13 +115,7 @@ public class ShadowParcelFileDescriptorTest {
     handlerThread.start();
     Handler handler = new Handler(handlerThread.getLooper());
     final AtomicBoolean onCloseCalled = new AtomicBoolean(false);
-    ParcelFileDescriptor.OnCloseListener onCloseListener =
-        new ParcelFileDescriptor.OnCloseListener() {
-          @Override
-          public void onClose(IOException e) {
-            onCloseCalled.set(true);
-          }
-        };
+    ParcelFileDescriptor.OnCloseListener onCloseListener = e -> onCloseCalled.set(true);
     pfd =
         ParcelFileDescriptor.open(
             file, ParcelFileDescriptor.MODE_READ_WRITE, handler, onCloseListener);
@@ -393,8 +380,7 @@ public class ShadowParcelFileDescriptorTest {
     ParcelFileDescriptor clone2 = ParcelFileDescriptor.CREATOR.createFromParcel(parcel);
     pfd.close();
     assertThat(readLine(clone1.getFileDescriptor())).isEqualTo("bar");
-    assertThrows(
-        FileDescriptorFromParcelUnavailableException.class, () -> clone2.getFileDescriptor());
+    assertThrows(FileDescriptorFromParcelUnavailableException.class, clone2::getFileDescriptor);
     parcel.recycle();
   }
 
@@ -410,19 +396,59 @@ public class ShadowParcelFileDescriptorTest {
     pfd.close(); // Makes our data available to anyone downstream on the chain.
 
     assertThat(readLine(pfd3.getFileDescriptor())).isEqualTo("foo");
-    assertThrows(
-        FileDescriptorFromParcelUnavailableException.class, () -> pfd2.getFileDescriptor());
+    assertThrows(FileDescriptorFromParcelUnavailableException.class, pfd2::getFileDescriptor);
   }
 
   @Test
   public void testDup_retainsFd() throws Exception {
     ParcelFileDescriptor fd = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_WRITE);
     ParcelFileDescriptor dupFd = fd.dup();
-    FileDescriptor file = fd.getFileDescriptor();
-    FileDescriptor dupFile = dupFd.getFileDescriptor();
-    assertThat(file).isEqualTo(dupFile);
-    assertThat(file.valid()).isTrue();
-    assertThat(dupFile.valid()).isTrue();
+    FileDescriptor fileDescriptor = fd.getFileDescriptor();
+    FileDescriptor dupFileDescriptor = dupFd.getFileDescriptor();
+
+    // The file descriptors should be valid, but they may not be the same.
+    assertThat(fileDescriptor.valid()).isTrue();
+    assertThat(dupFileDescriptor.valid()).isTrue();
+  }
+
+  @Test
+  public void testDup_sameContents() throws Exception {
+    Files.asCharSink(file, defaultCharset()).write("foo");
+    ParcelFileDescriptor fd = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_WRITE);
+    ParcelFileDescriptor dupFd = fd.dup();
+
+    // Duplicated file descriptor should have the same contents.
+    assertThat(readLine(fd.getFileDescriptor())).isEqualTo("foo");
+    assertThat(readLine(dupFd.getFileDescriptor())).isEqualTo("foo");
+  }
+
+  @Test
+  public void testDup_createPipe_independentClose() throws Exception {
+    ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe();
+
+    // Write to the write side.
+    ParcelFileDescriptor writeSide = pipe[1];
+    byte[] dataToWrite = new byte[] {0, 1, 2, 3, 4};
+    ParcelFileDescriptor.AutoCloseOutputStream outputStream =
+        new ParcelFileDescriptor.AutoCloseOutputStream(writeSide);
+    outputStream.write(dataToWrite);
+    outputStream.close();
+
+    // Prepare a dup of the read side.
+    ParcelFileDescriptor readSide = pipe[0];
+    ParcelFileDescriptor readSideDup = readSide.dup();
+
+    // Close the read side.
+    readSide.close();
+
+    // The read side's dup is still open and can read.
+    ParcelFileDescriptor.AutoCloseInputStream inputStream =
+        new ParcelFileDescriptor.AutoCloseInputStream(readSideDup);
+    byte[] read = new byte[dataToWrite.length];
+    int byteCount = inputStream.read(read);
+    inputStream.close();
+    assertThat(byteCount).isEqualTo(dataToWrite.length);
+    assertThat(read).isEqualTo(dataToWrite);
   }
 
   @Test
@@ -497,7 +523,7 @@ public class ShadowParcelFileDescriptorTest {
 
   @Test
   public void testClose_afterDup_doesNotCloseOriginalFd() throws Exception {
-    ParcelFileDescriptor pfd = null;
+    ParcelFileDescriptor pfd;
     File tempFile = File.createTempFile("testFile", ".txt");
     String content = "abc123";
     Files.asCharSink(tempFile, UTF_8).write(content);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelTest.java
index 1cd088544..ed2665a02 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelTest.java
@@ -3,8 +3,8 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.M;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import android.accounts.Account;
@@ -395,7 +395,7 @@ public class ShadowParcelTest {
   }
 
   @Test
-  public void testReadWriteIntArray() throws Exception {
+  public void testReadWriteIntArray() {
     final int[] ints = {1, 2};
     parcel.writeIntArray(ints);
     // Make sure a copy was stored.
@@ -408,24 +408,24 @@ public class ShadowParcelTest {
   }
 
   @Test
-  public void testWriteAndCreateNullIntArray() throws Exception {
+  public void testWriteAndCreateNullIntArray() {
     parcel.writeIntArray(null);
     parcel.setDataPosition(0);
     assertThat(parcel.createIntArray()).isNull();
   }
 
   @Test
-  public void testReadWriteLongArray() throws Exception {
+  public void testReadWriteLongArray() {
     final long[] longs = {1, 2};
     parcel.writeLongArray(longs);
     parcel.setDataPosition(0);
     final long[] longs2 = new long[longs.length];
     parcel.readLongArray(longs2);
-    assertTrue(Arrays.equals(longs, longs2));
+    assertArrayEquals(longs, longs2);
   }
 
   @Test
-  public void testWriteAndCreateNullLongArray() throws Exception {
+  public void testWriteAndCreateNullLongArray() {
     parcel.writeLongArray(null);
     parcel.setDataPosition(0);
     assertThat(parcel.createLongArray()).isNull();
@@ -440,51 +440,51 @@ public class ShadowParcelTest {
   }
 
   @Test
-  public void testReadWriteFloatArray() throws Exception {
+  public void testReadWriteFloatArray() {
     final float[] floats = {1.1f, 2.0f};
     parcel.writeFloatArray(floats);
     parcel.setDataPosition(0);
     final float[] floats2 = new float[floats.length];
     parcel.readFloatArray(floats2);
-    assertTrue(Arrays.equals(floats, floats2));
+    assertArrayEquals(floats, floats2, 0f);
   }
 
   @Test
-  public void testWriteAndCreateNullFloatArray() throws Exception {
+  public void testWriteAndCreateNullFloatArray() {
     parcel.writeFloatArray(null);
     parcel.setDataPosition(0);
     assertThat(parcel.createFloatArray()).isNull();
   }
 
   @Test
-  public void testReadWriteDoubleArray() throws Exception {
+  public void testReadWriteDoubleArray() {
     final double[] doubles = {1.1f, 2.0f};
     parcel.writeDoubleArray(doubles);
     parcel.setDataPosition(0);
     final double[] doubles2 = new double[doubles.length];
     parcel.readDoubleArray(doubles2);
-    assertTrue(Arrays.equals(doubles, doubles2));
+    assertArrayEquals(doubles, doubles2, 0.0);
   }
 
   @Test
-  public void testWriteAndCreateNullDoubleArray() throws Exception {
+  public void testWriteAndCreateNullDoubleArray() {
     parcel.writeDoubleArray(null);
     parcel.setDataPosition(0);
     assertThat(parcel.createDoubleArray()).isNull();
   }
 
   @Test
-  public void testReadWriteStringArray() throws Exception {
+  public void testReadWriteStringArray() {
     final String[] strings = {"foo", "bar"};
     parcel.writeStringArray(strings);
     parcel.setDataPosition(0);
     final String[] strings2 = new String[strings.length];
     parcel.readStringArray(strings2);
-    assertTrue(Arrays.equals(strings, strings2));
+    assertArrayEquals(strings, strings2);
   }
 
   @Test
-  public void testWriteAndCreateNullStringArray() throws Exception {
+  public void testWriteAndCreateNullStringArray() {
     parcel.writeStringArray(null);
     parcel.setDataPosition(0);
     assertThat(parcel.createStringArray()).isNull();
@@ -575,7 +575,7 @@ public class ShadowParcelTest {
   }
 
   @Test
-  public void testWriteAndCreateNullByteArray() throws Exception {
+  public void testWriteAndCreateNullByteArray() {
     parcel.writeByteArray(null);
     assertThat(parcel.dataSize()).isEqualTo(4);
     parcel.setDataPosition(0);
@@ -589,7 +589,7 @@ public class ShadowParcelTest {
     assertThat(parcel.dataSize()).isEqualTo(4);
     parcel.setDataPosition(0);
     byte[] actualBytes = parcel.createByteArray();
-    assertTrue(Arrays.equals(bytes, actualBytes));
+    assertArrayEquals(bytes, actualBytes);
   }
 
   @Test
@@ -639,7 +639,7 @@ public class ShadowParcelTest {
     parcel.setDataPosition(0);
     byte[] actualBytes = new byte[bytes.length];
     parcel.readByteArray(actualBytes);
-    assertTrue(Arrays.equals(bytes, actualBytes));
+    assertArrayEquals(bytes, actualBytes);
   }
 
   @Test(expected = RuntimeException.class)
@@ -828,7 +828,7 @@ public class ShadowParcelTest {
   }
 
   @Test
-  public void testCreateStringArrayList() throws Exception {
+  public void testCreateStringArrayList() {
     parcel.writeStringList(Arrays.asList("str1", "str2"));
     parcel.setDataPosition(0);
 
@@ -839,7 +839,7 @@ public class ShadowParcelTest {
   }
 
   @Test
-  public void testWriteTypedListAndCreateTypedArrayList() throws Exception {
+  public void testWriteTypedListAndCreateTypedArrayList() {
     TestParcelable normal = new TestParcelable(23);
     ArrayList<TestParcelable> normals = new ArrayList<>();
     normals.add(normal);
@@ -854,7 +854,7 @@ public class ShadowParcelTest {
   }
 
   @Test
-  public void testParcelableWithPackageProtected() throws Exception {
+  public void testParcelableWithPackageProtected() {
     TestParcelablePackage normal = new TestParcelablePackage(23);
 
     parcel.writeParcelable(normal, 0);
@@ -867,7 +867,7 @@ public class ShadowParcelTest {
   }
 
   @Test
-  public void testParcelableWithBase() throws Exception {
+  public void testParcelableWithBase() {
     TestParcelableImpl normal = new TestParcelableImpl(23);
 
     parcel.writeParcelable(normal, 0);
@@ -880,7 +880,7 @@ public class ShadowParcelTest {
   }
 
   @Test
-  public void testParcelableWithPublicClass() throws Exception {
+  public void testParcelableWithPublicClass() {
     TestParcelable normal = new TestParcelable(23);
 
     parcel.writeParcelable(normal, 0);
@@ -892,7 +892,7 @@ public class ShadowParcelTest {
   }
 
   @Test
-  public void testReadAndWriteStringList() throws Exception {
+  public void testReadAndWriteStringList() {
     ArrayList<String> original = new ArrayList<>();
     List<String> rehydrated = new ArrayList<>();
     original.add("str1");
@@ -906,7 +906,7 @@ public class ShadowParcelTest {
   }
 
   @Test
-  public void testReadWriteMap() throws Exception {
+  public void testReadWriteMap() {
     HashMap<String, String> original = new HashMap<>();
     original.put("key", "value");
     parcel.writeMap(original);
@@ -922,7 +922,7 @@ public class ShadowParcelTest {
     parcel.writeStringArray(strs);
     parcel.setDataPosition(0);
     String[] newStrs = parcel.createStringArray();
-    assertTrue(Arrays.equals(strs, newStrs));
+    assertArrayEquals(strs, newStrs);
   }
 
   @Test
@@ -1128,7 +1128,7 @@ public class ShadowParcelTest {
     try {
       assertThat(parcel2.readString()).isEqualTo("hello world");
 
-      Intent unmarshalledIntent = (Intent) parcel2.readParcelable(Intent.class.getClassLoader());
+      Intent unmarshalledIntent = parcel2.readParcelable(Intent.class.getClassLoader());
       assertThat(unmarshalledIntent.getAction()).isEqualTo("action.foo");
       assertThat(unmarshalledIntent.getStringExtra("key1")).isEqualTo("str1");
       assertThat(unmarshalledIntent.getIntExtra("key2", -1)).isEqualTo(2);
@@ -1189,7 +1189,7 @@ public class ShadowParcelTest {
   }
 
   @Test
-  public void testUnmarshallZeroes() throws IOException {
+  public void testUnmarshallZeroes() {
     // This tests special-case handling of zeroes in marshalling.  A few tests rely on the rather
     // well-defined behavior that Parcel will interpret a byte array of all zeroes as zero
     // primitives and empty arrays.  When unmarshalling, this can be easily disambiguated from an
@@ -1232,7 +1232,7 @@ public class ShadowParcelTest {
   }
 
   @Test
-  public void testUnmarshallEmpty() throws IOException {
+  public void testUnmarshallEmpty() {
     // Unmarshall an zero-length byte string, although, pass a non-empty array to make sure the
     // length/offset are respected.
     parcel.unmarshall(new byte[] {1, 2, 3}, 1, 0);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java
index 9dfb69203..3ae4899e4 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java
@@ -32,7 +32,7 @@ public class ShadowPausedAsyncTaskTest {
     transcript = new ArrayList<>();
   }
 
-  /** Test uses AsyncTask without overridding executor. */
+  /** Test uses AsyncTask without overriding executor. */
   @Test
   public void testNormalFlow() throws Exception {
     AsyncTask<String, String, String> asyncTask = new RecordingAsyncTask();
@@ -180,7 +180,7 @@ public class ShadowPausedAsyncTaskTest {
           @Override
           protected Void doInBackground(Void... params) {
             boolean isMainLooper = Looper.getMainLooper().getThread() == Thread.currentThread();
-            transcript.add("doInBackground on main looper " + Boolean.toString(isMainLooper));
+            transcript.add("doInBackground on main looper " + isMainLooper);
             return null;
           }
         };
@@ -243,7 +243,7 @@ public class ShadowPausedAsyncTaskTest {
 
   private static class BlockingAsyncTask extends AsyncTask<Void, Void, Void> {
 
-    private CountDownLatch latch = new CountDownLatch(1);
+    private final CountDownLatch latch = new CountDownLatch(1);
 
     @Override
     protected Void doInBackground(Void... voids) {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedLooperTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedLooperTest.java
index 7123b696c..462d4cd9c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedLooperTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedLooperTest.java
@@ -105,7 +105,7 @@ public class ShadowPausedLooperTest {
   }
 
   @Test
-  public void postedBackgroundLooperTasksAreExecuted() throws InterruptedException {
+  public void postedBackgroundLooperTasksAreExecuted() {
     Runnable mockRunnable = mock(Runnable.class);
     Handler handler = new Handler(handlerThread.getLooper());
     handler.post(mockRunnable);
@@ -115,7 +115,7 @@ public class ShadowPausedLooperTest {
   }
 
   @Test
-  public void postedBackgroundLooperTasksWhenPaused() throws InterruptedException {
+  public void postedBackgroundLooperTasksWhenPaused() {
     Runnable mockRunnable = mock(Runnable.class);
     shadowOf(handlerThread.getLooper()).pause();
     new Handler(handlerThread.getLooper()).post(mockRunnable);
@@ -155,8 +155,7 @@ public class ShadowPausedLooperTest {
   }
 
   @Test
-  public void postedDelayedBackgroundLooperTasksAreExecutedOnlyWhenSystemClockAdvanced()
-      throws InterruptedException {
+  public void postedDelayedBackgroundLooperTasksAreExecutedOnlyWhenSystemClockAdvanced() {
     Runnable mockRunnable = mock(Runnable.class);
     new Handler(handlerThread.getLooper()).postDelayed(mockRunnable, 10);
     ShadowPausedLooper shadowLooper = Shadow.extract(handlerThread.getLooper());
@@ -368,10 +367,7 @@ public class ShadowPausedLooperTest {
     final Handler mainHandler = new Handler();
 
     Runnable mockRunnable = mock(Runnable.class);
-    Runnable postingRunnable =
-        () -> {
-          mainHandler.postDelayed(mockRunnable, 100);
-        };
+    Runnable postingRunnable = () -> mainHandler.postDelayed(mockRunnable, 100);
     mainHandler.postDelayed(postingRunnable, 100);
 
     verify(mockRunnable, times(0)).run();
@@ -467,7 +463,7 @@ public class ShadowPausedLooperTest {
   }
 
   @Test
-  public void isIdle_paused() throws InterruptedException {
+  public void isIdle_paused() {
     ShadowLooper shadowLooper = shadowOf(handlerThread.getLooper());
     shadowLooper.pause();
     assertThat(shadowLooper.isIdle()).isTrue();
@@ -540,13 +536,12 @@ public class ShadowPausedLooperTest {
     shadowOf(looper).pause();
     new Handler(looper)
         .post(
-            () -> {
-              Looper.myQueue()
-                  .addIdleHandler(
-                      () -> {
-                        throw new IllegalStateException();
-                      });
-            });
+            () ->
+                Looper.myQueue()
+                    .addIdleHandler(
+                        () -> {
+                          throw new IllegalStateException();
+                        }));
     assertThrows(IllegalStateException.class, () -> shadowOf(looper).idle());
     handlerThread.join(5_000);
     assertThat(handlerThread.getState()).isEqualTo(Thread.State.TERMINATED);
@@ -678,7 +673,7 @@ public class ShadowPausedLooperTest {
       t.start();
       Looper looper = future.get();
       shadowOf(looper).pause();
-      new Handler(looper).post(() -> looper.quitSafely());
+      new Handler(looper).post(looper::quitSafely);
       shadowOf(looper).idle();
       ((ShadowPausedLooper) shadowOf(looper)).resetLooperToInitialState();
       countDownLatch.countDown();
@@ -719,23 +714,17 @@ public class ShadowPausedLooperTest {
     handler.post(
         () -> {
           token.set(postSyncBarrierCompat(handlerThread.getLooper()));
-          handler.post(
-              () -> {
-                wasRun.set(true);
-              });
+          handler.post(() -> wasRun.set(true));
         });
     shadowLooper.idle();
     assertThat(token.get()).isNotEqualTo(-1);
-    assertThat(wasRun.get()).isEqualTo(false);
+    assertThat(wasRun.get()).isFalse();
     // should be effectively a no-op and not deadlock
     shadowLooper.idle();
     // remove sync barriers messages need to get posted as async
-    asyncHandler.post(
-        () -> {
-          removeSyncBarrierCompat(handlerThread.getLooper(), token.get());
-        });
+    asyncHandler.post(() -> removeSyncBarrierCompat(handlerThread.getLooper(), token.get()));
     shadowLooper.idle();
-    assertThat(wasRun.get()).isEqualTo(true);
+    assertThat(wasRun.get()).isTrue();
   }
 
   /** Similar to previous test but with a running aka unpaused looper. */
@@ -750,23 +739,17 @@ public class ShadowPausedLooperTest {
     handler.post(
         () -> {
           token.set(postSyncBarrierCompat(handlerThread.getLooper()));
-          handler.post(
-              () -> {
-                wasRun.set(true);
-              });
+          handler.post(() -> wasRun.set(true));
         });
     shadowLooper.idle();
     assertThat(token.get()).isNotEqualTo(-1);
-    assertThat(wasRun.get()).isEqualTo(false);
+    assertThat(wasRun.get()).isFalse();
     // should be effectively a no-op and not deadlock
     shadowLooper.idle();
     // remove sync barriers messages need to get posted as async
-    asyncHandler.post(
-        () -> {
-          removeSyncBarrierCompat(handlerThread.getLooper(), token.get());
-        });
+    asyncHandler.post(() -> removeSyncBarrierCompat(handlerThread.getLooper(), token.get()));
     shadowLooper.idle();
-    assertThat(wasRun.get()).isEqualTo(true);
+    assertThat(wasRun.get()).isTrue();
   }
 
   private static class BlockingRunnable implements Runnable {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPendingIntentTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPendingIntentTest.java
index 682536893..5b3f2effc 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPendingIntentTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPendingIntentTest.java
@@ -781,17 +781,8 @@ public class ShadowPendingIntentTest {
       throws CanceledException {
     final AtomicBoolean onSendFinishedCalled = new AtomicBoolean(false);
     PendingIntent.OnFinished onFinished =
-        new PendingIntent.OnFinished() {
-          @Override
-          public void onSendFinished(
-              PendingIntent pendingIntent,
-              Intent intent,
-              int resultCode,
-              String resultData,
-              Bundle resultExtras) {
+        (pendingIntent, intent, resultCode, resultData, resultExtras) ->
             onSendFinishedCalled.set(true);
-          }
-        };
     Intent intent = new Intent();
     PendingIntent pendingIntent =
         PendingIntent.getBroadcast(context, /* requestCode= */ 0, intent, /* flags= */ 0);
@@ -814,17 +805,8 @@ public class ShadowPendingIntentTest {
     Handler handler = new Handler(handlerThread.getLooper());
     final AtomicBoolean onSendFinishedCalled = new AtomicBoolean(false);
     PendingIntent.OnFinished onFinished =
-        new PendingIntent.OnFinished() {
-          @Override
-          public void onSendFinished(
-              PendingIntent pendingIntent,
-              Intent intent,
-              int resultCode,
-              String resultData,
-              Bundle resultExtras) {
+        (pendingIntent, intent, resultCode, resultData, resultExtras) ->
             onSendFinishedCalled.set(true);
-          }
-        };
     Intent intent = new Intent();
     PendingIntent pendingIntent =
         PendingIntent.getBroadcast(context, /* requestCode= */ 0, intent, /* flags= */ 0);
@@ -845,17 +827,8 @@ public class ShadowPendingIntentTest {
   public void send_withOutOnFinishedCallback_onFinishedCallbackReset() throws CanceledException {
     final AtomicBoolean onSendFinishedCalled = new AtomicBoolean(false);
     PendingIntent.OnFinished onFinished =
-        new PendingIntent.OnFinished() {
-          @Override
-          public void onSendFinished(
-              PendingIntent pendingIntent,
-              Intent intent,
-              int resultCode,
-              String resultData,
-              Bundle resultExtras) {
+        (pendingIntent, intent, resultCode, resultData, resultExtras) ->
             onSendFinishedCalled.set(true);
-          }
-        };
     Intent intent = new Intent();
     PendingIntent pendingIntent =
         PendingIntent.getBroadcast(context, /* requestCode= */ 0, intent, /* flags= */ 0);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPersistableBundleTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPersistableBundleTest.java
new file mode 100644
index 000000000..0f8304039
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPersistableBundleTest.java
@@ -0,0 +1,172 @@
+package org.robolectric.shadows;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Build;
+import android.os.PersistableBundle;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+@RunWith(AndroidJUnit4.class)
+public class ShadowPersistableBundleTest {
+  private final PersistableBundle bundle = new PersistableBundle();
+
+  @Test
+  public void containsKey() {
+    assertThat(bundle.containsKey("foo")).isFalse();
+    bundle.putString("foo", "bar");
+    assertThat(bundle.containsKey("foo")).isTrue();
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.LOLLIPOP_MR1)
+  public void putBoolean() {
+    bundle.putBoolean("foo", true);
+    assertThat(bundle.getBoolean("foo")).isTrue();
+    assertThat(bundle.getBoolean("bar")).isFalse();
+    assertThat(bundle.getBoolean("bar", true)).isTrue();
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.LOLLIPOP_MR1)
+  public void putBooleanArray() {
+    boolean[] array = {false, true};
+    bundle.putBooleanArray("foo", array);
+    assertThat(bundle.getBooleanArray("foo")).isEqualTo(array);
+    assertThat(bundle.getBooleanArray("bar")).isNull();
+  }
+
+  @Test
+  public void putDouble() {
+    bundle.putDouble("foo", 1.23);
+    assertThat(bundle.getDouble("foo")).isEqualTo(1.23);
+    assertThat(bundle.getDouble("bar")).isEqualTo(0.0);
+    assertThat(bundle.getDouble("bar", 4.56)).isEqualTo(4.56);
+  }
+
+  @Test
+  public void putDoubleArray() {
+    double[] array = new double[] {1.23, 4.56};
+    bundle.putDoubleArray("foo", array);
+    assertThat(bundle.getDoubleArray("foo")).isEqualTo(array);
+    assertThat(bundle.getDoubleArray("bar")).isNull();
+  }
+
+  @Test
+  public void putInt() {
+    bundle.putInt("foo", 1);
+    assertThat(bundle.getInt("foo")).isEqualTo(1);
+    assertThat(bundle.getInt("bar")).isEqualTo(0);
+    assertThat(bundle.getInt("bar", 5)).isEqualTo(5);
+  }
+
+  @Test
+  public void putIntArray() {
+    int[] array = new int[] {1, 2};
+    bundle.putIntArray("foo", array);
+    assertThat(bundle.getIntArray("foo")).isEqualTo(array);
+    assertThat(bundle.getIntArray("bar")).isNull();
+  }
+
+  @Test
+  public void putLong() {
+    bundle.putLong("foo", 1L);
+    assertThat(bundle.getLong("foo")).isEqualTo(1L);
+    assertThat(bundle.getLong("bar")).isEqualTo(0L);
+    assertThat(bundle.getLong("bar", 5L)).isEqualTo(5L);
+  }
+
+  @Test
+  public void putLongArray() {
+    long[] array = new long[] {1L, 2L};
+    bundle.putLongArray("foo", array);
+    assertThat(bundle.getLongArray("foo")).isEqualTo(array);
+    assertThat(bundle.getLongArray("bar")).isNull();
+  }
+
+  @Test
+  public void putString() {
+    bundle.putString("foo", "abc");
+    assertThat(bundle.getString("foo")).isEqualTo("abc");
+    assertThat(bundle.getString("bar")).isNull();
+    assertThat(bundle.getString("bar", "def")).isEqualTo("def");
+  }
+
+  @Test
+  public void putStringArray() {
+    String[] array = new String[] {"abc", "def"};
+    bundle.putStringArray("foo", array);
+    assertThat(bundle.getStringArray("foo")).isEqualTo(array);
+    assertThat(bundle.getStringArray("bar")).isNull();
+  }
+
+  @Test
+  public void putPersistableBundle() {
+    PersistableBundle nested = new PersistableBundle();
+    nested.putInt("foo", 1);
+    bundle.putPersistableBundle("foo", nested);
+    assertThat(bundle.getPersistableBundle("foo")).isEqualTo(nested);
+    assertThat(bundle.getPersistableBundle("bar")).isNull();
+  }
+
+  @Test
+  public void remove() {
+    bundle.putInt("foo", 1);
+    bundle.putInt("bar", 2);
+    bundle.remove("foo");
+
+    assertThat(bundle.containsKey("foo")).isFalse();
+    assertThat(bundle.containsKey("bar")).isTrue();
+  }
+
+  @Test
+  public void clear() {
+    bundle.putInt("foo", 1);
+    bundle.clear();
+
+    assertThat(bundle.containsKey("foo")).isFalse();
+    assertThat(bundle.size()).isEqualTo(0);
+  }
+
+  @Test
+  public void isEmpty() {
+    assertThat(bundle.isEmpty()).isTrue();
+    bundle.putInt("foo", 1);
+    assertThat(bundle.isEmpty()).isFalse();
+  }
+
+  @Test
+  public void size() {
+    assertThat(bundle.size()).isEqualTo(0);
+
+    bundle.putInt("foo", 5);
+    assertThat(bundle.size()).isEqualTo(1);
+
+    bundle.putInt("bar", 5);
+    assertThat(bundle.size()).isEqualTo(2);
+  }
+
+  @Test
+  public void getWrongType() {
+    bundle.putInt("foo", 1);
+
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1) {
+      assertThat(bundle.getBoolean("foo")).isFalse();
+      assertThat(bundle.getBooleanArray("foo")).isNull();
+    }
+
+    assertThat(bundle.getDouble("foo")).isEqualTo(0.0);
+    assertThat(bundle.getDoubleArray("foo")).isNull();
+    assertThat(bundle.getIntArray("foo")).isNull();
+    assertThat(bundle.getLong("foo")).isEqualTo(0);
+    assertThat(bundle.getLongArray("foo")).isNull();
+    assertThat(bundle.getString("foo")).isNull();
+    assertThat(bundle.getStringArray("foo")).isNull();
+    assertThat(bundle.getPersistableBundle("foo")).isNull();
+
+    bundle.putDouble("foo", 1.23);
+    assertThat(bundle.getInt("foo")).isEqualTo(0);
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPowerManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPowerManagerTest.java
index 345b62431..a8d4be256 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPowerManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPowerManagerTest.java
@@ -219,10 +219,7 @@ public class ShadowPowerManagerTest {
   @Config(minSdk = Q)
   public void addThermalStatusListener() {
     int[] listenerValue = new int[] {-1};
-    powerManager.addThermalStatusListener(
-        level -> {
-          listenerValue[0] = level;
-        });
+    powerManager.addThermalStatusListener(level -> listenerValue[0] = level);
     shadowOf(powerManager).setCurrentThermalStatus(PowerManager.THERMAL_STATUS_MODERATE);
     assertThat(listenerValue[0]).isEqualTo(PowerManager.THERMAL_STATUS_MODERATE);
   }
@@ -696,8 +693,7 @@ public class ShadowPowerManagerTest {
 
     LowPowerStandbyPortsLock lock = powerManager.newLowPowerStandbyPortsLock(ports);
 
-    ShadowLowPowerStandbyPortsLock shadowLock =
-        (ShadowLowPowerStandbyPortsLock) Shadow.extract(lock);
+    ShadowLowPowerStandbyPortsLock shadowLock = Shadow.extract(lock);
     assertThat(shadowLock.getPorts()).isEqualTo(ports);
   }
 
@@ -709,8 +705,7 @@ public class ShadowPowerManagerTest {
     ImmutableList<LowPowerStandbyPortDescription> portDescriptions = ImmutableList.of(defaultPort);
 
     LowPowerStandbyPortsLock lock = powerManager.newLowPowerStandbyPortsLock(portDescriptions);
-    ShadowLowPowerStandbyPortsLock shadowLock =
-        (ShadowLowPowerStandbyPortsLock) Shadow.extract(lock);
+    ShadowLowPowerStandbyPortsLock shadowLock = Shadow.extract(lock);
     lock.acquire();
     lock.acquire();
     assertThat(shadowLock.getAcquireCount()).isEqualTo(2);
@@ -724,8 +719,7 @@ public class ShadowPowerManagerTest {
     ImmutableList<LowPowerStandbyPortDescription> portDescriptions = ImmutableList.of(defaultPort);
 
     LowPowerStandbyPortsLock lock = powerManager.newLowPowerStandbyPortsLock(portDescriptions);
-    ShadowLowPowerStandbyPortsLock shadowLock =
-        (ShadowLowPowerStandbyPortsLock) Shadow.extract(lock);
+    ShadowLowPowerStandbyPortsLock shadowLock = Shadow.extract(lock);
     lock.acquire();
     assertThat(shadowLock.isAcquired()).isTrue();
   }
@@ -738,8 +732,7 @@ public class ShadowPowerManagerTest {
     ImmutableList<LowPowerStandbyPortDescription> portDescriptions = ImmutableList.of(defaultPort);
 
     LowPowerStandbyPortsLock lock = powerManager.newLowPowerStandbyPortsLock(portDescriptions);
-    ShadowLowPowerStandbyPortsLock shadowLock =
-        (ShadowLowPowerStandbyPortsLock) Shadow.extract(lock);
+    ShadowLowPowerStandbyPortsLock shadowLock = Shadow.extract(lock);
     lock.acquire();
     lock.release();
     assertThat(shadowLock.isAcquired()).isFalse();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceActivityTestWithFragment.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceActivityTestWithFragment.java
index 99a046f8c..e7139807a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceActivityTestWithFragment.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceActivityTestWithFragment.java
@@ -21,7 +21,8 @@ import org.robolectric.Robolectric;
  */
 @RunWith(AndroidJUnit4.class)
 public class ShadowPreferenceActivityTestWithFragment {
-  private TestPreferenceActivity activity = Robolectric.setupActivity(TestPreferenceActivity.class);
+  private final TestPreferenceActivity activity =
+      Robolectric.setupActivity(TestPreferenceActivity.class);
   private TestPreferenceFragment fragment;
   private static final String FRAGMENT_TAG = "fragmentPreferenceTag";
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowProcessTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowProcessTest.java
index a91c42069..d0942030e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowProcessTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowProcessTest.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.truth.Truth.assertThat;
 
+import android.os.Process;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -20,38 +21,38 @@ public class ShadowProcessTest {
 
   @Test
   public void shouldBeZeroWhenNotSet() {
-    assertThat(android.os.Process.myPid()).isEqualTo(0);
+    assertThat(Process.myPid()).isEqualTo(0);
   }
 
   @Test
   public void shouldGetMyPidAsSet() {
     ShadowProcess.setPid(3);
-    assertThat(android.os.Process.myPid()).isEqualTo(3);
+    assertThat(Process.myPid()).isEqualTo(3);
   }
 
   @Test
   public void shouldGetMyUidAsSet() {
     ShadowProcess.setUid(123);
-    assertThat(android.os.Process.myUid()).isEqualTo(123);
+    assertThat(Process.myUid()).isEqualTo(123);
   }
 
   @Test
   public void shouldGetKilledProcess() {
     ShadowProcess.clearKilledProcesses();
-    android.os.Process.killProcess(999);
+    Process.killProcess(999);
     assertThat(ShadowProcess.wasKilled(999)).isTrue();
   }
 
   @Test
   public void shouldClearKilledProcessesOnReset() {
-    android.os.Process.killProcess(999);
+    Process.killProcess(999);
     ShadowProcess.reset();
     assertThat(ShadowProcess.wasKilled(999)).isFalse();
   }
 
   @Test
   public void shouldClearKilledProcesses() {
-    android.os.Process.killProcess(999);
+    Process.killProcess(999);
     ShadowProcess.clearKilledProcesses();
     assertThat(ShadowProcess.wasKilled(999)).isFalse();
   }
@@ -59,23 +60,22 @@ public class ShadowProcessTest {
   @Test
   public void shouldGetMultipleKilledProcesses() {
     ShadowProcess.clearKilledProcesses();
-    android.os.Process.killProcess(999);
-    android.os.Process.killProcess(123);
+    Process.killProcess(999);
+    Process.killProcess(123);
     assertThat(ShadowProcess.wasKilled(999)).isTrue();
     assertThat(ShadowProcess.wasKilled(123)).isTrue();
   }
 
   @Test
   public void myTid_mainThread_returnsCurrentThreadId() {
-    assertThat(android.os.Process.myTid()).isEqualTo(Thread.currentThread().getId());
+    assertThat(Process.myTid()).isEqualTo(Thread.currentThread().getId());
   }
 
   @Test
   public void myTid_backgroundThread_returnsCurrentThreadId() throws Exception {
     AtomicBoolean ok = new AtomicBoolean(false);
 
-    Thread thread =
-        new Thread(() -> ok.set(android.os.Process.myTid() == Thread.currentThread().getId()));
+    Thread thread = new Thread(() -> ok.set(Process.myTid() == Thread.currentThread().getId()));
     thread.start();
     thread.join();
 
@@ -87,16 +87,8 @@ public class ShadowProcessTest {
     AtomicInteger tid1 = new AtomicInteger(0);
     AtomicInteger tid2 = new AtomicInteger(0);
 
-    Thread thread1 =
-        new Thread(
-            () -> {
-              tid1.set(android.os.Process.myTid());
-            });
-    Thread thread2 =
-        new Thread(
-            () -> {
-              tid2.set(android.os.Process.myTid());
-            });
+    Thread thread1 = new Thread(() -> tid1.set(Process.myTid()));
+    Thread thread2 = new Thread(() -> tid2.set(Process.myTid()));
     thread1.start();
     thread2.start();
     thread1.join();
@@ -107,47 +99,43 @@ public class ShadowProcessTest {
 
   @Test
   public void getThreadPriority_notSet_returnsZero() {
-    assertThat(android.os.Process.getThreadPriority(123)).isEqualTo(0);
+    assertThat(Process.getThreadPriority(123)).isEqualTo(0);
   }
 
   @Test
   public void getThreadPriority_returnsThreadPriority() {
-    android.os.Process.setThreadPriority(123, android.os.Process.THREAD_PRIORITY_VIDEO);
+    Process.setThreadPriority(123, Process.THREAD_PRIORITY_VIDEO);
 
-    assertThat(android.os.Process.getThreadPriority(123))
-        .isEqualTo(android.os.Process.THREAD_PRIORITY_VIDEO);
+    assertThat(Process.getThreadPriority(123)).isEqualTo(Process.THREAD_PRIORITY_VIDEO);
   }
 
   @Test
   public void getThreadPriority_currentThread_returnsCurrentThreadPriority() {
-    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_AUDIO);
+    Process.setThreadPriority(Process.THREAD_PRIORITY_AUDIO);
 
-    assertThat(android.os.Process.getThreadPriority(/* tid= */ 0))
-        .isEqualTo(android.os.Process.THREAD_PRIORITY_AUDIO);
+    assertThat(Process.getThreadPriority(/* tid= */ 0)).isEqualTo(Process.THREAD_PRIORITY_AUDIO);
   }
 
   @Test
   public void setThreadPriorityOneArgument_setsCurrentThreadPriority() {
-    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_AUDIO);
+    Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_AUDIO);
 
-    assertThat(android.os.Process.getThreadPriority(android.os.Process.myTid()))
-        .isEqualTo(android.os.Process.THREAD_PRIORITY_URGENT_AUDIO);
+    assertThat(Process.getThreadPriority(Process.myTid()))
+        .isEqualTo(Process.THREAD_PRIORITY_URGENT_AUDIO);
   }
 
   @Test
   public void setThreadPriorityOneArgument_setsCurrentThreadPriority_highestPriority() {
-    android.os.Process.setThreadPriority(THREAD_PRIORITY_HIGHEST);
+    Process.setThreadPriority(THREAD_PRIORITY_HIGHEST);
 
-    assertThat(android.os.Process.getThreadPriority(android.os.Process.myTid()))
-        .isEqualTo(THREAD_PRIORITY_HIGHEST);
+    assertThat(Process.getThreadPriority(Process.myTid())).isEqualTo(THREAD_PRIORITY_HIGHEST);
   }
 
   @Test
   public void setThreadPriorityOneArgument_setsCurrentThreadPriority_lowestPriority() {
-    android.os.Process.setThreadPriority(THREAD_PRIORITY_LOWEST);
+    Process.setThreadPriority(THREAD_PRIORITY_LOWEST);
 
-    assertThat(android.os.Process.getThreadPriority(android.os.Process.myTid()))
-        .isEqualTo(THREAD_PRIORITY_LOWEST);
+    assertThat(Process.getThreadPriority(Process.myTid())).isEqualTo(THREAD_PRIORITY_LOWEST);
   }
 
   @Test
@@ -155,7 +143,7 @@ public class ShadowProcessTest {
   public void shouldGetProcessNameAsSet() {
     ShadowProcess.setProcessName("com.foo.bar:baz");
 
-    assertThat(android.os.Process.myProcessName()).isEqualTo("com.foo.bar:baz");
+    assertThat(Process.myProcessName()).isEqualTo("com.foo.bar:baz");
   }
 
   @Test
@@ -165,6 +153,6 @@ public class ShadowProcessTest {
 
     ShadowProcess.reset();
 
-    assertThat(android.os.Process.myProcessName()).isEmpty();
+    assertThat(Process.myProcessName()).isEmpty();
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowProgressBarTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowProgressBarTest.java
index c4e7cdc58..4c3c4f8bd 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowProgressBarTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowProgressBarTest.java
@@ -20,7 +20,7 @@ import org.robolectric.annotation.ResourcesMode.Mode;
 @ResourcesMode(Mode.BINARY)
 public class ShadowProgressBarTest {
 
-  private int[] testValues = {0, 1, 2, 100};
+  private final int[] testValues = {0, 1, 2, 100};
   private ProgressBar progressBar;
 
   @Before
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowQueuedWorkResetterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowQueuedWorkResetterTest.java
index c0955c347..ab82ed57b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowQueuedWorkResetterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowQueuedWorkResetterTest.java
@@ -44,7 +44,7 @@ public class ShadowQueuedWorkResetterTest {
 
     private static final AtomicInteger initialLooperCount = new AtomicInteger(-1);
 
-    private void doPostToQueuedWorkTest() throws InterruptedException {
+    private void doPostToQueuedWorkTest() {
       AtomicBoolean wasRun = new AtomicBoolean(false);
       if (RuntimeEnvironment.getApiLevel() < O) {
         reflector(QueuedWorkReflector.class).add(() -> wasRun.set(true));
@@ -59,12 +59,12 @@ public class ShadowQueuedWorkResetterTest {
     }
 
     @Test
-    public void postToQueuedTest() throws InterruptedException {
+    public void postToQueuedTest() {
       doPostToQueuedWorkTest();
     }
 
     @Test
-    public void anotherPostToQueuedWorkTest() throws InterruptedException {
+    public void anotherPostToQueuedWorkTest() {
       doPostToQueuedWorkTest();
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRadioGroupTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRadioGroupTest.java
index ef5d44a8e..feb941337 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRadioGroupTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRadioGroupTest.java
@@ -3,7 +3,7 @@ package org.robolectric.shadows;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 
-import android.app.Application;
+import android.content.Context;
 import android.widget.RadioGroup;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -16,12 +16,11 @@ import org.junit.runner.RunWith;
 @RunWith(AndroidJUnit4.class)
 public class ShadowRadioGroupTest {
   private static final int BUTTON_ID = 3245;
-  private Application context;
   private RadioGroup radioGroup;
 
   @Before
   public void setUp() throws Exception {
-    context = ApplicationProvider.getApplicationContext();
+    Context context = ApplicationProvider.getApplicationContext();
     radioGroup = new RadioGroup(context);
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRemoteCallbackListTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRemoteCallbackListTest.java
index 74dc68161..20e6e14fa 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRemoteCallbackListTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRemoteCallbackListTest.java
@@ -10,7 +10,6 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowRemoteCallbackListTest {
@@ -33,7 +32,6 @@ public class ShadowRemoteCallbackListTest {
   }
 
   @Test
-  @Config(minSdk = 17)
   public void getRegisteredCallbackCount_callbackRegistered_reflectsInReturnValue() {
     fooRemoteCallbackList.register(new Foo());
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRemoteViewsAdapterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRemoteViewsAdapterTest.java
new file mode 100644
index 000000000..47f6965f9
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRemoteViewsAdapterTest.java
@@ -0,0 +1,145 @@
+package org.robolectric.shadows;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Build.VERSION_CODES;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import android.widget.RemoteViews;
+import android.widget.RemoteViewsAdapter;
+import android.widget.RemoteViewsAdapter.RemoteAdapterConnectionCallback;
+import android.widget.RemoteViewsService;
+import android.widget.RemoteViewsService.RemoteViewsFactory;
+import android.widget.TextView;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.common.collect.ImmutableList;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+@RunWith(AndroidJUnit4.class)
+public class ShadowRemoteViewsAdapterTest {
+
+  private static final ImmutableList<String> LIST_ITEMS = ImmutableList.of("one", "two", "three");
+  private static final String TEST_EXTRA_KEY = "test_extra_key";
+  private static final String TEST_EXTRA_VALUE = "test_extra_value";
+
+  private Context context;
+  private ViewGroup parent;
+
+  @SuppressWarnings("NonFinalStaticField")
+  private static Intent capturedIntent = null;
+
+  @Before
+  public void setUp() {
+    context = ApplicationProvider.getApplicationContext();
+    parent = new FrameLayout(context);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.O)
+  public void getViewApi26AndLater_populatedWithExpectedItems() {
+    RemoteViewsAdapter adapter =
+        new RemoteViewsAdapter(
+            context, createTestIntent(), new FakeRemoteAdapterConnectionCallback(), false);
+
+    assertThat(adapter.getCount()).isEqualTo(3);
+    assertThat(((TextView) adapter.getView(0, null, parent)).getText().toString()).isEqualTo("one");
+    assertThat(((TextView) adapter.getView(1, null, parent)).getText().toString()).isEqualTo("two");
+    assertThat(((TextView) adapter.getView(2, null, parent)).getText().toString())
+        .isEqualTo("three");
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.O)
+  public void constructorApi26AndLater_intentPassedToService() {
+    RemoteViewsAdapter unused =
+        new RemoteViewsAdapter(
+            context, createTestIntent(), new FakeRemoteAdapterConnectionCallback(), false);
+
+    assertThat(capturedIntent.getComponent().getClassName())
+        .isEqualTo(TestRemoteViewsService.class.getName());
+    assertThat(capturedIntent.getStringExtra(TEST_EXTRA_KEY)).isEqualTo(TEST_EXTRA_VALUE);
+  }
+
+  private Intent createTestIntent() {
+    return new Intent(context, TestRemoteViewsService.class)
+        .putExtra(TEST_EXTRA_KEY, TEST_EXTRA_VALUE);
+  }
+
+  private static class TestRemoteViewsService extends RemoteViewsService {
+    @Override
+    public RemoteViewsFactory onGetViewFactory(Intent intent) {
+      capturedIntent = intent;
+      return new TestRemoteViewsFactory();
+    }
+  }
+
+  private static class TestRemoteViewsFactory implements RemoteViewsFactory {
+
+    @Override
+    public void onCreate() {}
+
+    @Override
+    public void onDataSetChanged() {}
+
+    @Override
+    public void onDestroy() {}
+
+    @Override
+    public int getCount() {
+      return LIST_ITEMS.size();
+    }
+
+    @Override
+    public RemoteViews getViewAt(int position) {
+      RemoteViews remoteViews =
+          new RemoteViews(
+              ApplicationProvider.getApplicationContext().getPackageName(),
+              android.R.layout.simple_list_item_1);
+      remoteViews.setTextViewText(android.R.id.text1, LIST_ITEMS.get(position));
+      return remoteViews;
+    }
+
+    @Override
+    public RemoteViews getLoadingView() {
+      return null;
+    }
+
+    @Override
+    public int getViewTypeCount() {
+      return 1;
+    }
+
+    @Override
+    public long getItemId(int position) {
+      return 0;
+    }
+
+    @Override
+    public boolean hasStableIds() {
+      return true;
+    }
+  }
+
+  private static class FakeRemoteAdapterConnectionCallback
+      implements RemoteAdapterConnectionCallback {
+    @Override
+    public boolean onRemoteAdapterConnected() {
+      return false;
+    }
+
+    @Override
+    public void onRemoteAdapterDisconnected() {}
+
+    @Override
+    public void deferNotifyDataSetChanged() {}
+
+    @Override
+    public void setRemoteViewsAdapter(Intent intent, boolean b) {}
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowResourcesTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowResourcesTest.java
index f9ad43163..c6ce39d15 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowResourcesTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowResourcesTest.java
@@ -301,7 +301,7 @@ public class ShadowResourcesTest {
 
   @Test
   @Config(minSdk = S)
-  public void getColor_shouldReturnCorrectMaterialYouColor() throws Exception {
+  public void getColor_shouldReturnCorrectMaterialYouColor() {
     SparseIntArray sparseArray =
         new SparseIntArray(LAST_RESOURCE_COLOR_ID - FIRST_RESOURCE_COLOR_ID + 1);
     IntStream.range(0, greenBlueColorBase.length)
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowResultReceiverTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowResultReceiverTest.java
index 3ee8135ca..3296606b7 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowResultReceiverTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowResultReceiverTest.java
@@ -12,7 +12,7 @@ import org.junit.runner.RunWith;
 @RunWith(AndroidJUnit4.class)
 public class ShadowResultReceiverTest {
   @Test
-  public void callingSend_shouldCallOverridenOnReceiveResultWithTheSameArguments() {
+  public void callingSend_shouldCallOverriddenOnReceiveResultWithTheSameArguments() {
     TestResultReceiver testResultReceiver = new TestResultReceiver(null);
     Bundle bundle = new Bundle();
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRingtoneManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRingtoneManagerTest.java
index 2df75bf66..697bdb639 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRingtoneManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRingtoneManagerTest.java
@@ -30,17 +30,15 @@ public final class ShadowRingtoneManagerTest {
   @Test
   public void getRingtone_noUriSet_returnNull() {
     Context appContext = ApplicationProvider.getApplicationContext();
-    int type = TYPE_RINGTONE;
 
-    assertThat(RingtoneManager.getActualDefaultRingtoneUri(appContext, type)).isNull();
+    assertThat(RingtoneManager.getActualDefaultRingtoneUri(appContext, TYPE_RINGTONE)).isNull();
   }
 
   @Test
   public void getRingtone_uriSetForDifferentType() {
     Context appContext = ApplicationProvider.getApplicationContext();
-    int type = TYPE_RINGTONE;
     Uri uri = Uri.parse("content://media/external/330");
-    RingtoneManager.setActualDefaultRingtoneUri(appContext, type, uri);
+    RingtoneManager.setActualDefaultRingtoneUri(appContext, TYPE_RINGTONE, uri);
 
     assertThat(RingtoneManager.getActualDefaultRingtoneUri(appContext, TYPE_ALARM)).isNull();
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRoleManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRoleManagerTest.java
index c0c2fd210..bfad7eb53 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRoleManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRoleManagerTest.java
@@ -3,17 +3,22 @@ package org.robolectric.shadows;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static org.junit.Assert.assertThrows;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
 import static org.robolectric.RuntimeEnvironment.getApplication;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.app.Activity;
+import android.app.role.OnRoleHoldersChangedListener;
 import android.app.role.RoleManager;
 import android.content.Context;
 import android.os.Build;
+import android.os.UserHandle;
 import androidx.test.core.content.pm.PackageInfoBuilder;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.concurrent.atomic.AtomicBoolean;
-import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
@@ -24,12 +29,8 @@ import org.robolectric.annotation.Config;
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = Build.VERSION_CODES.Q)
 public final class ShadowRoleManagerTest {
-  private RoleManager roleManager;
 
-  @Before
-  public void setUp() {
-    roleManager = (RoleManager) getApplication().getSystemService(Context.ROLE_SERVICE);
-  }
+  private final RoleManager roleManager = getApplication().getSystemService(RoleManager.class);
 
   @Test
   public void isRoleHeld_shouldThrowWithNullArgument() {
@@ -94,11 +95,7 @@ public final class ShadowRoleManagerTest {
     AtomicBoolean resultHolder = new AtomicBoolean(false);
     shadowOf(roleManager)
         .setDefaultApplication(
-            RoleManager.ROLE_SMS,
-            "test.app",
-            0,
-            directExecutor(),
-            result -> resultHolder.set(result));
+            RoleManager.ROLE_SMS, "test.app", 0, directExecutor(), resultHolder::set);
     assertThat(roleManager.getDefaultApplication(RoleManager.ROLE_SMS)).isEqualTo("test.app");
     assertThat(resultHolder.get()).isTrue();
   }
@@ -109,11 +106,7 @@ public final class ShadowRoleManagerTest {
     AtomicBoolean resultHolder = new AtomicBoolean(true);
     shadowOf(roleManager)
         .setDefaultApplication(
-            RoleManager.ROLE_SMS,
-            "test.app",
-            0,
-            directExecutor(),
-            result -> resultHolder.set(result));
+            RoleManager.ROLE_SMS, "test.app", 0, directExecutor(), resultHolder::set);
     assertThat(resultHolder.get()).isFalse();
     assertThat(roleManager.getDefaultApplication(RoleManager.ROLE_SMS)).isNull();
   }
@@ -153,4 +146,113 @@ public final class ShadowRoleManagerTest {
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
+
+  @Test
+  public void addRoleHolder_whenListened_notifysListeners() {
+    UserHandle user = UserHandle.of(10);
+    OnRoleHoldersChangedListener listener = mock(OnRoleHoldersChangedListener.class);
+    roleManager.addOnRoleHoldersChangedListenerAsUser(directExecutor(), listener, user);
+
+    ShadowRoleManager.addRoleHolder(RoleManager.ROLE_SMS, "test.app", user);
+
+    verify(listener).onRoleHoldersChanged(RoleManager.ROLE_SMS, user);
+    assertThat(roleManager.getRoleHoldersAsUser(RoleManager.ROLE_SMS, user))
+        .containsExactly("test.app");
+  }
+
+  @Test
+  public void addRoleHolder_whenListenedOnAllUser_notifysListeners() {
+    UserHandle user = UserHandle.of(10);
+    OnRoleHoldersChangedListener listener = mock(OnRoleHoldersChangedListener.class);
+    roleManager.addOnRoleHoldersChangedListenerAsUser(directExecutor(), listener, UserHandle.ALL);
+
+    ShadowRoleManager.addRoleHolder(RoleManager.ROLE_SMS, "test.app", user);
+
+    verify(listener).onRoleHoldersChanged(RoleManager.ROLE_SMS, user);
+  }
+
+  @Test
+  public void removeRoleHolder_whenListened_notifysListeners() {
+    UserHandle user = UserHandle.of(10);
+    OnRoleHoldersChangedListener listener = mock(OnRoleHoldersChangedListener.class);
+    ShadowRoleManager.addRoleHolder(RoleManager.ROLE_SMS, "test.app", user);
+    roleManager.addOnRoleHoldersChangedListenerAsUser(directExecutor(), listener, user);
+
+    ShadowRoleManager.removeRoleHolder(RoleManager.ROLE_SMS, "test.app", user);
+
+    verify(listener).onRoleHoldersChanged(RoleManager.ROLE_SMS, user);
+    assertThat(roleManager.getRoleHoldersAsUser(RoleManager.ROLE_SMS, user)).isEmpty();
+  }
+
+  @Test
+  public void addRoleHolder_whenNoLongerListened_dontNotifysListeners() {
+    UserHandle user = UserHandle.of(10);
+    OnRoleHoldersChangedListener listener = mock(OnRoleHoldersChangedListener.class);
+    roleManager.addOnRoleHoldersChangedListenerAsUser(directExecutor(), listener, user);
+    roleManager.removeOnRoleHoldersChangedListenerAsUser(listener, user);
+
+    ShadowRoleManager.addRoleHolder(RoleManager.ROLE_SMS, "test.app", user);
+
+    verify(listener, never()).onRoleHoldersChanged(any(), any());
+  }
+
+  @Test
+  public void addRoleHolder_whenNoLongerListenedOnAllUser_dontNotifysListeners() {
+    UserHandle user = UserHandle.of(10);
+    OnRoleHoldersChangedListener listener = mock(OnRoleHoldersChangedListener.class);
+    roleManager.addOnRoleHoldersChangedListenerAsUser(directExecutor(), listener, UserHandle.ALL);
+    roleManager.removeOnRoleHoldersChangedListenerAsUser(listener, UserHandle.ALL);
+
+    ShadowRoleManager.addRoleHolder(RoleManager.ROLE_SMS, "test.app", user);
+
+    verify(listener, never()).onRoleHoldersChanged(any(), any());
+  }
+
+  @Test
+  public void getRoleHoldersAsUser_noHolders_returnEmpty() {
+    UserHandle user = UserHandle.of(10);
+
+    assertThat(roleManager.getRoleHoldersAsUser(RoleManager.ROLE_SMS, user)).isEmpty();
+  }
+
+  @Test
+  public void getRoleHolders_noHolders_returnEmpty() {
+    assertThat(roleManager.getRoleHolders(RoleManager.ROLE_SMS)).isEmpty();
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.R) // createContextAsUser is only available on R+
+  public void getRoleHolders_holdersSet_returnRoleHolders() {
+    UserHandle user = UserHandle.of(10);
+    String roleHolder = "test.app";
+    ShadowRoleManager.addRoleHolder(RoleManager.ROLE_SMS, roleHolder, user);
+    RoleManager userRoleManager =
+        getApplication()
+            .createContextAsUser(user, /* flags= */ 0)
+            .getSystemService(RoleManager.class);
+    assertThat(userRoleManager.getRoleHolders(RoleManager.ROLE_SMS)).containsExactly(roleHolder);
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.R) // createContextAsUser is only available on R+
+  public void getRoleHolders_holdersSetOnAnotherUser_returnEmpty() {
+    UserHandle user = UserHandle.of(10);
+    UserHandle anotherUser = UserHandle.of(11);
+    String roleHolder = "test.app";
+    ShadowRoleManager.addRoleHolder(RoleManager.ROLE_SMS, roleHolder, anotherUser);
+    RoleManager userRoleManager =
+        getApplication()
+            .createContextAsUser(user, /* flags= */ 0)
+            .getSystemService(RoleManager.class);
+    assertThat(userRoleManager.getRoleHolders(RoleManager.ROLE_SMS)).isEmpty();
+  }
+
+  @Test
+  public void getRoleHoldersAsUser_holdersSet_returnRoleHolders() {
+    UserHandle user = UserHandle.of(10);
+    String roleHolder = "test.app";
+    ShadowRoleManager.addRoleHolder(RoleManager.ROLE_SMS, roleHolder, user);
+    assertThat(roleManager.getRoleHoldersAsUser(RoleManager.ROLE_SMS, user))
+        .containsExactly(roleHolder);
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSafetyCenterManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSafetyCenterManagerTest.java
index 72feaded8..b95c8a61f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSafetyCenterManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSafetyCenterManagerTest.java
@@ -444,6 +444,7 @@ public final class ShadowSafetyCenterManagerTest {
   }
 
   @Test
+  @SuppressWarnings("Convert2Lambda")
   public void throwOnSafetySourceId_safetyCenterEnabled_throwsForGivenIds() {
     SafetyCenterManager safetyCenterManager =
         getApplicationContext().getSystemService(SafetyCenterManager.class);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowScaleGestureDetectorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowScaleGestureDetectorTest.java
index 9fcd775d2..8977bad12 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowScaleGestureDetectorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowScaleGestureDetectorTest.java
@@ -9,6 +9,7 @@ import android.view.MotionEvent;
 import android.view.ScaleGestureDetector;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -79,16 +80,16 @@ public class ShadowScaleGestureDetectorTest {
   private static class TestOnGestureListener
       implements ScaleGestureDetector.OnScaleGestureListener {
     @Override
-    public boolean onScale(ScaleGestureDetector detector) {
+    public boolean onScale(@Nonnull ScaleGestureDetector detector) {
       return false;
     }
 
     @Override
-    public boolean onScaleBegin(ScaleGestureDetector detector) {
+    public boolean onScaleBegin(@Nonnull ScaleGestureDetector detector) {
       return false;
     }
 
     @Override
-    public void onScaleEnd(ScaleGestureDetector detector) {}
+    public void onScaleEnd(@Nonnull ScaleGestureDetector detector) {}
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSensorManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSensorManagerTest.java
index a65f7294a..70e3ecfbc 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSensorManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSensorManagerTest.java
@@ -136,7 +136,9 @@ public class ShadowSensorManagerTest {
 
     shadow.sendSensorEventToListeners(event);
 
-    assertThat(listener.getLatestSensorEvent().get()).isEqualTo(event);
+    Optional<SensorEvent> latestSensorEvent = listener.getLatestSensorEvent();
+    assertThat(latestSensorEvent).isPresent();
+    assertThat(latestSensorEvent).hasValue(event);
   }
 
   @Test
@@ -150,8 +152,13 @@ public class ShadowSensorManagerTest {
 
     shadow.sendSensorEventToListeners(event);
 
-    assertThat(listener1.getLatestSensorEvent().get()).isEqualTo(event);
-    assertThat(listener2.getLatestSensorEvent().get()).isEqualTo(event);
+    Optional<SensorEvent> latestSensorEvent1 = listener1.getLatestSensorEvent();
+    assertThat(latestSensorEvent1).isPresent();
+    assertThat(latestSensorEvent1).hasValue(event);
+
+    Optional<SensorEvent> latestSensorEvent2 = listener2.getLatestSensorEvent();
+    assertThat(latestSensorEvent2).isPresent();
+    assertThat(latestSensorEvent2).hasValue(event);
   }
 
   @Test
@@ -309,9 +316,39 @@ public class ShadowSensorManagerTest {
     assertThat(listener3.getOnFlushCompletedCalls()).isEmpty();
   }
 
+  @Test
+  public void getDefaultSensorWithNoSensorAdded_shouldReturnNull() {
+    assertThat(sensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE)).isNull();
+    assertThat(sensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE, true)).isNull();
+    assertThat(sensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE, false)).isNull();
+    assertThat(sensorManager.getSensorList(Sensor.TYPE_HEART_RATE)).isEmpty();
+  }
+
+  @Test
+  public void getDefaultSensorWithWakeUpSensor_shouldReturnCorrectSensorAndWakeUpValue() {
+    Sensor sensor = ShadowSensor.newInstance(Sensor.TYPE_HEART_RATE);
+    shadowOf(sensor).setWakeUpFlag(true);
+    shadowOf(sensorManager).addSensor(sensor);
+
+    assertThat(sensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE)).isEqualTo(sensor);
+    assertThat(sensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE, true)).isEqualTo(sensor);
+    assertThat(sensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE, false)).isNull();
+  }
+
+  @Test
+  public void getDefaultSensorWithNoWakeUpSensor_shouldReturnCorrectSensorAndWakeUpValue() {
+    Sensor sensor = ShadowSensor.newInstance(Sensor.TYPE_HEART_RATE);
+    shadowOf(sensor).setWakeUpFlag(false);
+    shadowOf(sensorManager).addSensor(sensor);
+
+    assertThat(sensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE)).isEqualTo(sensor);
+    assertThat(sensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE, false)).isEqualTo(sensor);
+    assertThat(sensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE, true)).isNull();
+  }
+
   private static class TestSensorEventListener implements SensorEventListener2 {
     private Optional<SensorEvent> latestSensorEvent = Optional.absent();
-    private List<Sensor> onFlushCompletedCalls = new ArrayList<>();
+    private final List<Sensor> onFlushCompletedCalls = new ArrayList<>();
 
     @Override
     public void onAccuracyChanged(Sensor sensor, int accuracy) {}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowServiceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowServiceTest.java
index ec8c0cd0a..ac9251a43 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowServiceTest.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.Q;
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
 
@@ -95,6 +96,14 @@ public class ShadowServiceTest {
     assertThat(service.getForegroundServiceType()).isEqualTo(64);
   }
 
+  @Test
+  public void startForegroundWithException() {
+    shadowOf(service).setThrowInStartForeground(new RuntimeException("test"));
+    Notification n = notBuilder.build();
+    RuntimeException e = assertThrows(RuntimeException.class, () -> service.startForeground(23, n));
+    assertThat(e).hasMessageThat().isEqualTo("test");
+  }
+
   @Test
   public void stopForeground() {
     service.stopForeground(true);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSharedPreferencesTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSharedPreferencesTest.java
index cf3c34ac0..889c01494 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSharedPreferencesTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSharedPreferencesTest.java
@@ -39,7 +39,7 @@ public class ShadowSharedPreferencesTest {
 
     sharedPreferences = context.getSharedPreferences(FILENAME, Context.MODE_PRIVATE);
     // Ensure no shared preferences have leaked from previous tests.
-    assertThat(sharedPreferences.getAll()).hasSize(0);
+    assertThat(sharedPreferences.getAll()).isEmpty();
 
     editor = sharedPreferences.edit();
     editor.putBoolean("boolean", true);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSmsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSmsManagerTest.java
index a3a3fa8cd..7118c4ac8 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSmsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSmsManagerTest.java
@@ -304,8 +304,7 @@ public class ShadowSmsManagerTest {
 
   @Test
   @Config(minSdk = R)
-  public void getSmscAddress_shouldThrowSecurityExceptionWhenReadPhoneStatePermissionNotGranted()
-      throws Exception {
+  public void getSmscAddress_shouldThrowSecurityExceptionWhenReadPhoneStatePermissionNotGranted() {
     shadowOf(smsManager).setSmscAddressPermission(false);
     assertThrows(SecurityException.class, () -> smsManager.getSmscAddress());
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSoftKeyboardControllerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSoftKeyboardControllerTest.java
index 7c0a994c9..366650828 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSoftKeyboardControllerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSoftKeyboardControllerTest.java
@@ -7,25 +7,25 @@ import static org.robolectric.Shadows.shadowOf;
 import android.accessibilityservice.AccessibilityService;
 import android.accessibilityservice.AccessibilityService.SoftKeyboardController;
 import android.os.Looper;
-import android.view.accessibility.AccessibilityEvent;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.testing.TestAccessibilityService;
 
 /** Test for ShadowSoftKeyboardController. */
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = N)
 public final class ShadowSoftKeyboardControllerTest {
 
-  private MyService myService;
   private SoftKeyboardController softKeyboardController;
 
   @Before
   public void setUp() {
-    myService = Robolectric.setupService(MyService.class);
+    TestAccessibilityService myService = Robolectric.setupService(TestAccessibilityService.class);
     softKeyboardController = myService.getSoftKeyboardController();
   }
 
@@ -92,23 +92,9 @@ public final class ShadowSoftKeyboardControllerTest {
     private int showMode = -1;
 
     @Override
-    public void onShowModeChanged(SoftKeyboardController controller, int showMode) {
+    public void onShowModeChanged(@Nonnull SoftKeyboardController controller, int showMode) {
       this.invoked = true;
       this.showMode = showMode;
     }
   }
-
-  /** Empty implementation of AccessibilityService, for test purposes. */
-  private static class MyService extends AccessibilityService {
-
-    @Override
-    public void onAccessibilityEvent(AccessibilityEvent arg0) {
-      // Do nothing
-    }
-
-    @Override
-    public void onInterrupt() {
-      // Do nothing
-    }
-  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSoundTriggerManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSoundTriggerManagerTest.java
index a5c8a612f..804fb991f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSoundTriggerManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSoundTriggerManagerTest.java
@@ -29,14 +29,14 @@ public final class ShadowSoundTriggerManagerTest {
 
   @Config(sdk = VERSION_CODES.S)
   @Test
-  public void getModuleProperties_nullModuleProperties() throws Exception {
+  public void getModuleProperties_nullModuleProperties() {
     SoundTrigger.ModuleProperties moduleProperties = instance.getModuleProperties();
     assertThat(moduleProperties).isNull();
   }
 
   @Config(sdk = VERSION_CODES.R)
   @Test
-  public void getModuleProperties_nullPointExceptionAtAndroidR() throws Exception {
+  public void getModuleProperties_nullPointExceptionAtAndroidR() {
     try {
       SoundTrigger.ModuleProperties unused = instance.getModuleProperties();
       fail("Expect NullPointException");
@@ -47,7 +47,7 @@ public final class ShadowSoundTriggerManagerTest {
 
   @Config(sdk = VERSION_CODES.R)
   @Test
-  public void getModuleProperties_nonNullProperties() throws Exception {
+  public void getModuleProperties_nonNullProperties() {
     instance.setModuleProperties(
         (SoundTrigger.ModuleProperties) getModuleProperties("supportedModelArch", 1234));
     SoundTrigger.ModuleProperties moduleProperties = instance.getModuleProperties();
@@ -56,7 +56,7 @@ public final class ShadowSoundTriggerManagerTest {
     assertThat(moduleProperties.getVersion()).isEqualTo(1234);
   }
 
-  // Construct a dummuy {@code SoundTrigger.ModuleProperties}. Return Object because {@code
+  // Construct a dummy {@code SoundTrigger.ModuleProperties}. Return Object because {@code
   // SoundTrigger.ModuleProperties} is not exist in public Android SDK.
   private Object getModuleProperties(String supportedModelArch, int version) {
     return new SoundTrigger.ModuleProperties(
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSpeechRecognizerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSpeechRecognizerTest.java
index 25c7ed722..e4ec68817 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSpeechRecognizerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSpeechRecognizerTest.java
@@ -18,6 +18,7 @@ import android.speech.SpeechRecognizer;
 import android.util.Log;
 import androidx.test.core.app.ApplicationProvider;
 import java.util.ArrayList;
+import javax.annotation.Nonnull;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -148,7 +149,7 @@ public class ShadowSpeechRecognizerTest {
     speechRecognizer =
         SpeechRecognizer.createSpeechRecognizer(
             ApplicationProvider.getApplicationContext(),
-            new ComponentName("org.robolectrc", "FakeComponent"));
+            new ComponentName("org.robolectric", "FakeComponent"));
     speechRecognizer.setRecognitionListener(listener);
     speechRecognizer.startListening(new Intent());
     shadowOf(getMainLooper()).idle();
@@ -272,7 +273,7 @@ public class ShadowSpeechRecognizerTest {
         new RecognitionSupport.Builder().addInstalledOnDeviceLanguage("en-US").build();
     speechRecognizer.checkRecognitionSupport(new Intent(), executor, supportCallback);
 
-    ((ShadowSpeechRecognizer) shadowOf(speechRecognizer)).triggerSupportResult(recognitionSupport);
+    shadowOf(speechRecognizer).triggerSupportResult(recognitionSupport);
     executor.runAll();
 
     assertThat(supportCallback.recognitionSupportReceived).isEqualTo(recognitionSupport);
@@ -285,7 +286,7 @@ public class ShadowSpeechRecognizerTest {
     TestRecognitionSupportCallback supportCallback = new TestRecognitionSupportCallback();
     speechRecognizer.checkRecognitionSupport(new Intent(), executor, supportCallback);
 
-    ((ShadowSpeechRecognizer) shadowOf(speechRecognizer)).triggerSupportError(1);
+    shadowOf(speechRecognizer).triggerSupportError(1);
     executor.runAll();
 
     assertThat(supportCallback.errorReceived).isEqualTo(1);
@@ -297,7 +298,7 @@ public class ShadowSpeechRecognizerTest {
     Intent modelDownloadIntent = new Intent();
     speechRecognizer.triggerModelDownload(modelDownloadIntent);
 
-    assertThat(((ShadowSpeechRecognizer) shadowOf(speechRecognizer)).getLatestModelDownloadIntent())
+    assertThat(shadowOf(speechRecognizer).getLatestModelDownloadIntent())
         .isSameInstanceAs(modelDownloadIntent);
   }
 
@@ -307,7 +308,7 @@ public class ShadowSpeechRecognizerTest {
     RecognitionSupport recognitionSupportReceived;
 
     @Override
-    public void onSupportResult(RecognitionSupport recognitionSupport) {
+    public void onSupportResult(@Nonnull RecognitionSupport recognitionSupport) {
       recognitionSupportReceived = recognitionSupport;
     }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowStateListDrawableTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowStateListDrawableTest.java
index 59272b9e4..8ab0812b1 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowStateListDrawableTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowStateListDrawableTest.java
@@ -30,7 +30,7 @@ public class ShadowStateListDrawableTest {
     Drawable drawableForState = shadow.getDrawableForState(states);
 
     assertNotNull(drawableForState);
-    assertThat(((ShadowBitmapDrawable) shadowOf(drawableForState)).getCreatedFromResId())
+    assertThat(shadowOf(drawableForState).getCreatedFromResId())
         .isEqualTo(android.R.drawable.ic_delete);
   }
 
@@ -47,7 +47,7 @@ public class ShadowStateListDrawableTest {
     ShadowStateListDrawable shadow = shadowOf(stateListDrawable);
     Drawable drawableForState = shadow.getDrawableForState(StateSet.WILD_CARD);
     assertNotNull(drawableForState);
-    assertThat(((ShadowBitmapDrawable) shadowOf(drawableForState)).getCreatedFromResId())
+    assertThat(shadowOf(drawableForState).getCreatedFromResId())
         .isEqualTo(android.R.drawable.ic_delete);
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsLogTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsLogTest.java
index f58d6dbe2..47c0834f5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsLogTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsLogTest.java
@@ -34,7 +34,7 @@ public final class ShadowStatsLogTest {
     final int expectedAtomId = 0;
 
     assertEquals(1, ShadowStatsLog.getStatsLogs().size());
-    assertEquals((int) expectedAtomId, (int) ShadowStatsLog.getStatsLogs().get(0).atomId());
+    assertEquals(expectedAtomId, ShadowStatsLog.getStatsLogs().get(0).atomId());
 
     final ByteBuffer buffer =
         ByteBuffer.wrap(ShadowStatsLog.getStatsLogs().get(0).bytes())
@@ -88,7 +88,7 @@ public final class ShadowStatsLogTest {
     long maxTimestamp = SystemClock.elapsedRealtimeNanos();
 
     assertEquals(1, ShadowStatsLog.getStatsLogs().size());
-    assertEquals((int) expectedAtomId, (int) ShadowStatsLog.getStatsLogs().get(0).atomId());
+    assertEquals(expectedAtomId, ShadowStatsLog.getStatsLogs().get(0).atomId());
 
     final ByteBuffer buffer =
         ByteBuffer.wrap(ShadowStatsLog.getStatsLogs().get(0).bytes())
@@ -196,7 +196,7 @@ public final class ShadowStatsLogTest {
     long maxTimestamp = SystemClock.elapsedRealtimeNanos();
 
     assertEquals(1, ShadowStatsLog.getStatsLogs().size());
-    assertEquals((int) expectedAtomId, (int) ShadowStatsLog.getStatsLogs().get(0).atomId());
+    assertEquals(expectedAtomId, ShadowStatsLog.getStatsLogs().get(0).atomId());
 
     final ByteBuffer buffer =
         ByteBuffer.wrap(ShadowStatsLog.getStatsLogs().get(0).bytes())
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsManagerTest.java
index 69d40fe85..86f1c742b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsManagerTest.java
@@ -18,7 +18,7 @@ import org.robolectric.annotation.Config;
 public final class ShadowStatsManagerTest {
 
   @Test
-  public void testGetMetadata() throws Exception {
+  public void testGetMetadata() {
     StatsManager statsManager =
         ApplicationProvider.getApplicationContext().getSystemService(StatsManager.class);
     byte[] metadataBytes = new byte[] {1, 2, 3, 4, 5};
@@ -109,7 +109,7 @@ public final class ShadowStatsManagerTest {
   }
 
   @Test
-  public void testReset_clearsMetadata() throws Exception {
+  public void testReset_clearsMetadata() {
     StatsManager statsManager =
         ApplicationProvider.getApplicationContext().getSystemService(StatsManager.class);
     byte[] metadataBytes = new byte[] {1, 2, 3, 4, 5};
@@ -188,4 +188,16 @@ public final class ShadowStatsManagerTest {
         ShadowStatsManager.BroadcastSubscriberKey.create(configId, subscriberId);
     assertThat(ShadowStatsManager.getBroadcastSubscriberMap().get(key)).isNull();
   }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.Q)
+  public void testGetRegisteredExperimentIds_returnsRegisteredExperimentIds() throws Exception {
+    StatsManager statsManager =
+        ApplicationProvider.getApplicationContext().getSystemService(StatsManager.class);
+    long[] experimentIds = new long[] {1L, 2L, 3L};
+
+    ShadowStatsManager.setRegisteredExperimentIds(experimentIds);
+
+    assertThat(statsManager.getRegisteredExperimentIds()).isEqualTo(experimentIds);
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageManagerTest.java
index 3d047e38c..23411e672 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageManagerTest.java
@@ -115,7 +115,7 @@ public class ShadowStorageManagerTest {
   public void getStorageVolumeFromAnUserContext() {
     File file1 = new File(internalStorage);
     shadowOf(storageManager).addStorageVolume(buildAndGetStorageVolume(file1, "internal"));
-    Context userContext = getApplication();
+    Context userContext;
 
     try {
       userContext =
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageStatsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageStatsManagerTest.java
index 376529d87..8a43bd2b0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageStatsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageStatsManagerTest.java
@@ -20,6 +20,7 @@ import java.util.UUID;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 /** Tests for {@link ShadowStorageStatsManager}. */
@@ -75,7 +76,7 @@ public final class ShadowStorageStatsManagerTest {
 
   @Test
   public void getFreeBytes_afterRemoveStorageDevice_throwsException() {
-    // Arange
+    // Arrange
     shadowOf(storageStatsManager).removeStorageDevice(StorageManager.UUID_DEFAULT);
 
     // Act & Assert
@@ -124,7 +125,7 @@ public final class ShadowStorageStatsManagerTest {
 
   @Test
   public void getTotalBytes_afterRemoveStorageDevice_throwsException() {
-    // Arange
+    // Arrange
     shadowOf(storageStatsManager).removeStorageDevice(StorageManager.UUID_DEFAULT);
 
     // Act & Assert
@@ -155,10 +156,11 @@ public final class ShadowStorageStatsManagerTest {
   @Test
   public void queryPackageWithCorrectArguments_shouldReturnSetupValue() throws Exception {
     // Arrange
-    StorageStats expected = buildStorageStats();
     UUID uuid = UUID.randomUUID();
     String packageName = "somePackageName";
     UserHandle userHandle = Process.myUserHandle();
+    StorageStats expected =
+        buildStorageStats(packageName, uuid.hashCode(), userHandle.getIdentifier());
     shadowOf(storageStatsManager).addStorageStats(uuid, packageName, userHandle, expected);
 
     // Act
@@ -172,10 +174,11 @@ public final class ShadowStorageStatsManagerTest {
   @Test
   public void queryUserWithCorrectArguments_shouldReturnSetupValue() throws Exception {
     // Arrange
-    StorageStats expected = buildStorageStats();
     UUID uuid = UUID.randomUUID();
     String packageName = "somePackageName";
     UserHandle userHandle = Process.myUserHandle();
+    StorageStats expected =
+        buildStorageStats(packageName, uuid.hashCode(), userHandle.getIdentifier());
     shadowOf(storageStatsManager).addStorageStats(uuid, packageName, userHandle, expected);
 
     // Act
@@ -188,18 +191,27 @@ public final class ShadowStorageStatsManagerTest {
   @Test
   public void queryUser_shouldReturnAccumulatedStats() throws Exception {
     // Arrange
-    StorageStats storageStats = buildStorageStats();
     UUID uuid1 = UUID.randomUUID();
     UUID uuid2 = UUID.randomUUID();
     String packageName1 = "somePackageName1";
     String packageName2 = "somePackageName2";
     String packageName3 = "somePackageName3";
     UserHandle userHandle = Process.myUserHandle();
-    shadowOf(storageStatsManager).addStorageStats(uuid1, packageName1, userHandle, storageStats);
-    shadowOf(storageStatsManager).addStorageStats(uuid1, packageName2, userHandle, storageStats);
-    shadowOf(storageStatsManager).addStorageStats(uuid1, packageName3, userHandle, storageStats);
-    shadowOf(storageStatsManager).addStorageStats(uuid2, packageName1, userHandle, storageStats);
-    shadowOf(storageStatsManager).addStorageStats(uuid2, packageName2, userHandle, storageStats);
+    StorageStats storageStats11 =
+        buildStorageStats(packageName1, uuid1.hashCode(), userHandle.getIdentifier());
+    StorageStats storageStats12 =
+        buildStorageStats(packageName2, uuid1.hashCode(), userHandle.getIdentifier());
+    StorageStats storageStats13 =
+        buildStorageStats(packageName3, uuid1.hashCode(), userHandle.getIdentifier());
+    StorageStats storageStats21 =
+        buildStorageStats(packageName1, uuid2.hashCode(), userHandle.getIdentifier());
+    StorageStats storageStats22 =
+        buildStorageStats(packageName2, uuid2.hashCode(), userHandle.getIdentifier());
+    shadowOf(storageStatsManager).addStorageStats(uuid1, packageName1, userHandle, storageStats11);
+    shadowOf(storageStatsManager).addStorageStats(uuid1, packageName2, userHandle, storageStats12);
+    shadowOf(storageStatsManager).addStorageStats(uuid1, packageName3, userHandle, storageStats13);
+    shadowOf(storageStatsManager).addStorageStats(uuid2, packageName1, userHandle, storageStats21);
+    shadowOf(storageStatsManager).addStorageStats(uuid2, packageName2, userHandle, storageStats22);
 
     // Act
     StorageStats actual1 = shadowOf(storageStatsManager).queryStatsForUser(uuid1, userHandle);
@@ -222,16 +234,29 @@ public final class ShadowStorageStatsManagerTest {
     String packageName2 = "somePackageName2";
     UserHandle userHandle = Process.myUserHandle();
     shadowOf(storageStatsManager)
-        .addStorageStats(uuid, packageName1, userHandle, buildStorageStats());
+        .addStorageStats(
+            uuid,
+            packageName1,
+            userHandle,
+            buildStorageStats(packageName1, uuid.hashCode(), userHandle.getIdentifier()));
     shadowOf(storageStatsManager)
-        .addStorageStats(uuid, packageName2, userHandle, buildStorageStats());
+        .addStorageStats(
+            uuid,
+            packageName2,
+            userHandle,
+            buildStorageStats(packageName2, uuid.hashCode(), userHandle.getIdentifier()));
     shadowOf(storageStatsManager)
         .addStorageStats(
             uuid,
             packageName2,
             userHandle,
             buildStorageStats(
-                /* codeSize= */ 2000L, /* dataSize= */ 1000L, /* cacheSize= */ 3000L));
+                packageName1,
+                uuid.hashCode(),
+                userHandle.getIdentifier(),
+                /* codeSize= */ 2000L,
+                /* dataSize= */ 1000L,
+                /* cacheSize= */ 3000L));
 
     // Act
     StorageStats actual = shadowOf(storageStatsManager).queryStatsForUser(uuid, userHandle);
@@ -249,14 +274,23 @@ public final class ShadowStorageStatsManagerTest {
     String packageName = "somePackageName1";
     UserHandle userHandle = Process.myUserHandle();
     shadowOf(storageStatsManager)
-        .addStorageStats(uuid, packageName, userHandle, buildStorageStats());
+        .addStorageStats(
+            uuid,
+            packageName,
+            userHandle,
+            buildStorageStats(packageName, uuid.hashCode(), userHandle.getIdentifier()));
     shadowOf(storageStatsManager)
         .addStorageStats(
             uuid,
             packageName,
             userHandle,
             buildStorageStats(
-                /* codeSize= */ 2000L, /* dataSize= */ 1000L, /* cacheSize= */ 3000L));
+                packageName,
+                uuid.hashCode(),
+                userHandle.getIdentifier(),
+                /* codeSize= */ 2000L,
+                /* dataSize= */ 1000L,
+                /* cacheSize= */ 3000L));
 
     // Act
     StorageStats actual = shadowOf(storageStatsManager).queryStatsForUser(uuid, userHandle);
@@ -270,7 +304,6 @@ public final class ShadowStorageStatsManagerTest {
   @Test
   public void queryPackageWithWrongArguments_shouldFail() {
     // Arrange
-    StorageStats expected = buildStorageStats();
     UUID uuid = UUID.randomUUID();
     UUID differentUUID = UUID.randomUUID();
     String packageName = "somePackageName";
@@ -278,6 +311,8 @@ public final class ShadowStorageStatsManagerTest {
     // getUserHandleForUid will divide uid by 100000. Pass in some arbitrary number > 100000 to be
     // different from system uid 0.
     UserHandle differentUserHandle = UserHandle.getUserHandleForUid(1200000);
+    StorageStats expected =
+        buildStorageStats(packageName, uuid.hashCode(), userHandle.getIdentifier());
 
     assertThat(uuid).isNotEqualTo(differentUUID);
     assertThat(userHandle).isNotEqualTo(differentUserHandle);
@@ -308,20 +343,21 @@ public final class ShadowStorageStatsManagerTest {
   @Test
   public void queryUserWithWrongArguments_shouldFail() {
     // Arrange
-    StorageStats expected = buildStorageStats();
     UUID uuid = UUID.randomUUID();
     UUID differentUUID = UUID.randomUUID();
     UserHandle userHandle = UserHandle.getUserHandleForUid(0);
+    String packageName = "somePackageName";
     // getUserHandleForUid will divide uid by 100000. Pass in some arbitrary number > 100000 to be
     // different from system uid 0.
     UserHandle differentUserHandle = UserHandle.getUserHandleForUid(1200000);
+    StorageStats expected =
+        buildStorageStats(packageName, uuid.hashCode(), userHandle.getIdentifier());
 
     assertThat(uuid).isNotEqualTo(differentUUID);
     assertThat(userHandle).isNotEqualTo(differentUserHandle);
 
     // Act
-    shadowOf(storageStatsManager)
-        .addStorageStats(uuid, /* packageName= */ "somePackageName", userHandle, expected);
+    shadowOf(storageStatsManager).addStorageStats(uuid, packageName, userHandle, expected);
 
     // Assert
     assertThrows(
@@ -336,10 +372,11 @@ public final class ShadowStorageStatsManagerTest {
   @Test
   public void queryPackageAfterClearSetup_shouldFail() {
     // Arrange
-    StorageStats expected = buildStorageStats();
     UUID uuid = UUID.randomUUID();
     String packageName = "somePackageName";
     UserHandle userHandle = Process.myUserHandle();
+    StorageStats expected =
+        buildStorageStats(packageName, uuid.hashCode(), userHandle.getIdentifier());
     shadowOf(storageStatsManager).addStorageStats(uuid, packageName, userHandle, expected);
 
     // Act
@@ -354,10 +391,11 @@ public final class ShadowStorageStatsManagerTest {
   @Test
   public void queryUserAfterClearSetup_shouldFail() {
     // Arrange
-    StorageStats expected = buildStorageStats();
     UUID uuid = UUID.randomUUID();
     String packageName = "somePackageName";
     UserHandle userHandle = Process.myUserHandle();
+    StorageStats expected =
+        buildStorageStats(packageName, uuid.hashCode(), userHandle.getIdentifier());
     shadowOf(storageStatsManager).addStorageStats(uuid, packageName, userHandle, expected);
 
     // Act
@@ -369,12 +407,24 @@ public final class ShadowStorageStatsManagerTest {
         () -> shadowOf(storageStatsManager).queryStatsForUser(uuid, userHandle));
   }
 
-  private static StorageStats buildStorageStats() {
-    return buildStorageStats(/* codeSize= */ 3000L, /* dataSize= */ 2000L, /* cacheSize= */ 1000L);
+  private static StorageStats buildStorageStats(String packageName, int uid, int userId) {
+    return buildStorageStats(
+        packageName,
+        /* uid= */ uid,
+        /* userId= */ userId,
+        /* codeSize= */ 3000L,
+        /* dataSize= */ 2000L,
+        /* cacheSize= */ 1000L);
   }
 
-  private static StorageStats buildStorageStats(long codeSize, long dataSize, long cacheSize) {
+  private static StorageStats buildStorageStats(
+      String packageName, int uid, int userId, long codeSize, long dataSize, long cacheSize) {
     Parcel parcel = Parcel.obtain();
+    if (RuntimeEnvironment.getApiLevel() > Build.VERSION_CODES.VANILLA_ICE_CREAM) {
+      parcel.writeString(packageName);
+      parcel.writeInt(userId);
+      parcel.writeInt(uid);
+    }
     parcel.writeLong(codeSize);
     parcel.writeLong(dataSize);
     parcel.writeLong(cacheSize);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSubscriptionManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSubscriptionManagerTest.java
index 3d9f36ba0..182c7ef4d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSubscriptionManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSubscriptionManagerTest.java
@@ -350,6 +350,27 @@ public class ShadowSubscriptionManagerTest {
         .isSameInstanceAs(expectedSubscriptionInfo);
   }
 
+  @Test
+  public void getAllSubscriptionInfoList_default_isEmpty() {
+    assertThat(shadowOf(subscriptionManager).getAllSubscriptionInfoList()).isEmpty();
+  }
+
+  @Test
+  public void getAllSubscriptionInfoList_nullCondition_isEmpty() {
+    shadowOf(subscriptionManager).setAllSubscriptionInfos();
+    assertThat(shadowOf(subscriptionManager).getAllSubscriptionInfoList()).isEmpty();
+  }
+
+  @Test
+  public void getAllSubscriptionInfoList_setSpecificSubscription_returnsList() {
+    SubscriptionInfo expectedSubscriptionInfo =
+        SubscriptionInfoBuilder.newBuilder().setId(123).buildSubscriptionInfo();
+    shadowOf(subscriptionManager).setAllSubscriptionInfos(expectedSubscriptionInfo);
+    assertThat(shadowOf(subscriptionManager).getAllSubscriptionInfoList()).hasSize(1);
+    assertThat(shadowOf(subscriptionManager).getAllSubscriptionInfoList().get(0))
+        .isSameInstanceAs(expectedSubscriptionInfo);
+  }
+
   @Test
   public void setAvailableSubscriptionInfoList_triggersSubscriptionsChanged() {
     DummySubscriptionsChangedListener listener = new DummySubscriptionsChangedListener();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceTest.java
index ecc7f2344..ae65ef34f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceTest.java
@@ -150,7 +150,7 @@ public class ShadowSurfaceTest {
    */
   @Config(minSdk = Q)
   @Test
-  public void copyFrom_surfaceControl_lockHardwareCavnvas() {
+  public void copyFrom_surfaceControl_lockHardwareCanvas() {
     SurfaceSession session = new SurfaceSession();
     SurfaceControl surfaceControl =
         new SurfaceControl.Builder(session).setBufferSize(100, 100).setName("").build();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceViewTest.java
index be36a9504..55982dbba 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceViewTest.java
@@ -10,6 +10,7 @@ import android.view.SurfaceHolder;
 import android.view.SurfaceView;
 import android.view.Window;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import javax.annotation.Nonnull;
 import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -53,7 +54,7 @@ public class ShadowSurfaceViewTest {
     surfaceHolder.addCallback(callback1);
     surfaceHolder.addCallback(callback2);
 
-    assertThat(fakeSurfaceHolder.getCallbacks().size()).isEqualTo(2);
+    assertThat(fakeSurfaceHolder.getCallbacks()).hasSize(2);
 
     surfaceHolder.removeCallback(callback1);
 
@@ -86,15 +87,35 @@ public class ShadowSurfaceViewTest {
     assertThat(fakeSurfaceHolder.getRequestedFormat()).isEqualTo(PixelFormat.RGB_565);
   }
 
+  @Test
+  public void emitSurfaceChanged_invokesCallback() {
+    TestCallback testCallback = new TestCallback();
+    surfaceHolder.addCallback(testCallback);
+
+    fakeSurfaceHolder.emitSurfaceChanged(/* format= */ 1, /* width= */ 2, /* height= */ 3);
+
+    assertThat(testCallback.updatedFormat).isEqualTo(1);
+    assertThat(testCallback.updatedWidth).isEqualTo(2);
+    assertThat(testCallback.updatedHeight).isEqualTo(3);
+  }
+
   private static class TestCallback implements SurfaceHolder.Callback {
+    int updatedFormat;
+    int updatedWidth;
+    int updatedHeight;
+
     @Override
-    public void surfaceCreated(SurfaceHolder holder) {}
+    public void surfaceCreated(@Nonnull SurfaceHolder holder) {}
 
     @Override
-    public void surfaceDestroyed(SurfaceHolder holder) {}
+    public void surfaceDestroyed(@Nonnull SurfaceHolder holder) {}
 
     @Override
-    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {}
+    public void surfaceChanged(@Nonnull SurfaceHolder holder, int format, int w, int h) {
+      updatedFormat = format;
+      updatedWidth = w;
+      updatedHeight = h;
+    }
   }
 
   private static class TestActivity extends Activity {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSystemHealthManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSystemHealthManagerTest.java
index 2a3410353..a80cad5d5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSystemHealthManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSystemHealthManagerTest.java
@@ -35,7 +35,6 @@ public final class ShadowSystemHealthManagerTest {
       HealthStatsBuilder.newBuilder().setDataType("other_uid_2_stats").build();
 
   private SystemHealthManager systemHealthManager;
-  private ShadowSystemHealthManager shadowSystemHealthManager;
 
   @Before
   public void setUp() {
@@ -43,22 +42,22 @@ public final class ShadowSystemHealthManagerTest {
         (SystemHealthManager)
             ApplicationProvider.getApplicationContext()
                 .getSystemService(Context.SYSTEM_HEALTH_SERVICE);
-    shadowSystemHealthManager = Shadow.extract(systemHealthManager);
 
+    ShadowSystemHealthManager shadowSystemHealthManager = Shadow.extract(systemHealthManager);
     shadowSystemHealthManager.addHealthStats(MY_UID_HEALTH_STATS);
     shadowSystemHealthManager.addHealthStatsForUid(OTHER_UID_1, OTHER_UID_1_HEALTH_STATS);
     shadowSystemHealthManager.addHealthStatsForUid(OTHER_UID_2, OTHER_UID_2_HEALTH_STATS);
   }
 
   @Test
-  public void snapshotForMyUid_expectedResult() throws Exception {
+  public void snapshotForMyUid_expectedResult() {
     HealthStats stats = systemHealthManager.takeMyUidSnapshot();
 
     assertThat(stats).isEqualTo(MY_UID_HEALTH_STATS);
   }
 
   @Test
-  public void snapshotForOtherUids_expectedResult() throws Exception {
+  public void snapshotForOtherUids_expectedResult() {
     HealthStats stats1 = systemHealthManager.takeUidSnapshot(OTHER_UID_1);
     HealthStats stats2 = systemHealthManager.takeUidSnapshot(OTHER_UID_2);
 
@@ -67,7 +66,7 @@ public final class ShadowSystemHealthManagerTest {
   }
 
   @Test
-  public void snapshotForAllUids_expectedResult() throws Exception {
+  public void snapshotForAllUids_expectedResult() {
     int[] uids = {OTHER_UID_1, MY_UID, OTHER_UID_2};
 
     HealthStats[] stats = systemHealthManager.takeUidSnapshots(uids);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTabSpecTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTabSpecTest.java
index 9d387d034..65b978f8c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTabSpecTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTabSpecTest.java
@@ -13,6 +13,7 @@ import android.widget.TabHost;
 import android.widget.TextView;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -100,7 +101,7 @@ public class ShadowTabSpecTest {
   private static class TestIcon extends Drawable {
 
     @Override
-    public void draw(Canvas canvas) {}
+    public void draw(@Nonnull Canvas canvas) {}
 
     @Override
     public void setAlpha(int alpha) {}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java
index 17ff1b259..fcb49433b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java
@@ -20,7 +20,6 @@ import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
-import android.content.pm.PackageManager.NameNotFoundException;
 import android.net.Uri;
 import android.os.Build;
 import android.os.Bundle;
@@ -78,7 +77,7 @@ public class ShadowTelecomManagerTest {
   @Test
   public void registerAndUnRegister() {
     assertThat(shadowOf(telecomService).getAllPhoneAccountsCount()).isEqualTo(0);
-    assertThat(shadowOf(telecomService).getAllPhoneAccounts()).hasSize(0);
+    assertThat(shadowOf(telecomService).getAllPhoneAccounts()).isEmpty();
 
     PhoneAccountHandle handler = createHandle("id");
     PhoneAccount phoneAccount = PhoneAccount.builder(handler, "main_account").build();
@@ -94,13 +93,13 @@ public class ShadowTelecomManagerTest {
     telecomService.unregisterPhoneAccount(handler);
 
     assertThat(shadowOf(telecomService).getAllPhoneAccountsCount()).isEqualTo(0);
-    assertThat(shadowOf(telecomService).getAllPhoneAccounts()).hasSize(0);
-    assertThat(telecomService.getAllPhoneAccountHandles()).hasSize(0);
+    assertThat(shadowOf(telecomService).getAllPhoneAccounts()).isEmpty();
+    assertThat(telecomService.getAllPhoneAccountHandles()).isEmpty();
   }
 
   @Test
   @Config(minSdk = UPSIDE_DOWN_CAKE)
-  public void registerWithTransactionalCapabilites_addsSelfManagedCapability() {
+  public void registerWithTransactionalCapabilities_addsSelfManagedCapability() {
     PhoneAccountHandle handle = createHandle("id");
     PhoneAccount phoneAccount =
         PhoneAccount.builder(handle, "main_account")
@@ -299,7 +298,7 @@ public class ShadowTelecomManagerTest {
     verifyNoMoreInteractions(connectionServiceListener);
 
     List<ConnectionRequest> values = requestCaptor.getAllValues();
-    assertThat(values.size()).isEqualTo(2);
+    assertThat(values).hasSize(2);
     ConnectionRequest request1 = values.get(0);
     ConnectionRequest request2 = values.get(1);
     assertThat(request1.getAddress()).isEqualTo(address1);
@@ -590,8 +589,7 @@ public class ShadowTelecomManagerTest {
 
   @Config(minSdk = R)
   @Test
-  public void createLaunchEmergencyDialerIntent_whenPackageAvailable_shouldContainPackage()
-      throws NameNotFoundException {
+  public void createLaunchEmergencyDialerIntent_whenPackageAvailable_shouldContainPackage() {
     ComponentName componentName = new ComponentName("com.android.phone", "EmergencyDialer");
     shadowOf(context.getPackageManager()).addActivityIfNotPresent(componentName);
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTelephonyManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTelephonyManagerTest.java
index ae84b65c5..c9f4aee4a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTelephonyManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTelephonyManagerTest.java
@@ -10,6 +10,7 @@ import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
+import static android.os.Build.VERSION_CODES.VANILLA_ICE_CREAM;
 import static android.telephony.PhoneStateListener.LISTEN_CALL_STATE;
 import static android.telephony.PhoneStateListener.LISTEN_CELL_INFO;
 import static android.telephony.PhoneStateListener.LISTEN_CELL_LOCATION;
@@ -33,6 +34,7 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.mock;
@@ -86,8 +88,8 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nonnull;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -238,7 +240,7 @@ public class ShadowTelephonyManagerTest {
   public void setImei_withSlotId_acceptsNull() {
     shadowOf(telephonyManager).setImei(0, "imei0");
     shadowOf(telephonyManager).setImei(0, null);
-    assertEquals(null, telephonyManager.getImei(0));
+    assertNull(telephonyManager.getImei(0));
   }
 
   @Test
@@ -274,8 +276,7 @@ public class ShadowTelephonyManagerTest {
 
   @Test(expected = SecurityException.class)
   public void
-      getSimSerialNumber_shouldThrowSecurityExceptionWhenReadPhoneStatePermissionNotGranted()
-          throws Exception {
+      getSimSerialNumber_shouldThrowSecurityExceptionWhenReadPhoneStatePermissionNotGranted() {
     shadowOf(telephonyManager).setReadPhoneStatePermission(false);
     telephonyManager.getSimSerialNumber();
   }
@@ -341,15 +342,10 @@ public class ShadowTelephonyManagerTest {
     CountDownLatch callbackLatch = new CountDownLatch(1);
     shadowOf(telephonyManager)
         .requestCellInfoUpdate(
-            new Executor() {
-              @Override
-              public void execute(Runnable r) {
-                r.run();
-              }
-            },
+            Runnable::run,
             new CellInfoCallback() {
               @Override
-              public void onCellInfo(List<CellInfo> list) {
+              public void onCellInfo(@Nonnull List<CellInfo> list) {
                 assertEquals(callbackCellInfo, list);
                 callbackLatch.countDown();
               }
@@ -402,8 +398,7 @@ public class ShadowTelephonyManagerTest {
   }
 
   @Test(expected = SecurityException.class)
-  public void getDeviceId_shouldThrowSecurityExceptionWhenReadPhoneStatePermissionNotGranted()
-      throws Exception {
+  public void getDeviceId_shouldThrowSecurityExceptionWhenReadPhoneStatePermissionNotGranted() {
     shadowOf(telephonyManager).setReadPhoneStatePermission(false);
     telephonyManager.getDeviceId();
   }
@@ -411,16 +406,14 @@ public class ShadowTelephonyManagerTest {
   @Test
   @Config(minSdk = M)
   public void
-      getDeviceIdForSlot_shouldThrowSecurityExceptionWhenReadPhoneStatePermissionNotGranted()
-          throws Exception {
+      getDeviceIdForSlot_shouldThrowSecurityExceptionWhenReadPhoneStatePermissionNotGranted() {
     shadowOf(telephonyManager).setReadPhoneStatePermission(false);
     assertThrows(SecurityException.class, () -> telephonyManager.getDeviceId(1));
   }
 
   @Test
   public void
-      getDeviceSoftwareVersion_shouldThrowSecurityExceptionWhenReadPhoneStatePermissionNotGranted()
-          throws Exception {
+      getDeviceSoftwareVersion_shouldThrowSecurityExceptionWhenReadPhoneStatePermissionNotGranted() {
     shadowOf(telephonyManager).setReadPhoneStatePermission(false);
     assertThrows(SecurityException.class, () -> telephonyManager.getDeviceSoftwareVersion());
   }
@@ -901,9 +894,8 @@ public class ShadowTelephonyManagerTest {
   }
 
   private String callGetSimCountryIso(TelephonyManager telephonyManager, int subId) {
-    return (String)
-        ReflectionHelpers.callInstanceMethod(
-            telephonyManager, "getSimCountryIso", ClassParameter.from(int.class, subId));
+    return ReflectionHelpers.callInstanceMethod(
+        telephonyManager, "getSimCountryIso", ClassParameter.from(int.class, subId));
   }
 
   @Test
@@ -1165,6 +1157,65 @@ public class ShadowTelephonyManagerTest {
     verify((SignalStrengthsListener) callback).onSignalStrengthsChanged(ss);
   }
 
+  @Test
+  @Config(minSdk = P)
+  public void shouldGiveVoiceActivationState() {
+    shadowOf(telephonyManager)
+        .setVoiceActivationState(TelephonyManager.SIM_ACTIVATION_STATE_ACTIVATED);
+    assertThat(telephonyManager.getVoiceActivationState())
+        .isEqualTo(TelephonyManager.SIM_ACTIVATION_STATE_ACTIVATED);
+  }
+
+  @Test
+  @Config(minSdk = P)
+  public void shouldGiveVoiceActivationState_unknownByDefault() {
+    assertThat(telephonyManager.getVoiceActivationState())
+        .isEqualTo(TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN);
+  }
+
+  @Test
+  @Config(minSdk = P)
+  public void shouldGiveDataActivationState() {
+    shadowOf(telephonyManager)
+        .setDataActivationState(TelephonyManager.SIM_ACTIVATION_STATE_ACTIVATED);
+    assertThat(telephonyManager.getDataActivationState())
+        .isEqualTo(TelephonyManager.SIM_ACTIVATION_STATE_ACTIVATED);
+  }
+
+  @Test
+  @Config(minSdk = P)
+  public void shouldGiveDataActivationState_unknownByDefault() {
+    assertThat(telephonyManager.getDataActivationState())
+        .isEqualTo(TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN);
+  }
+
+  @Test
+  @Config(minSdk = VANILLA_ICE_CREAM)
+  public void shouldGiveDeviceVoiceCapableTrue() {
+    shadowOf(telephonyManager).setDeviceVoiceCapable(true);
+    assertThat(telephonyManager.isDeviceVoiceCapable()).isTrue();
+  }
+
+  @Test
+  @Config(minSdk = VANILLA_ICE_CREAM)
+  public void shouldGiveDeviceVoiceCapableFalse() {
+    shadowOf(telephonyManager).setDeviceVoiceCapable(false);
+    assertThat(telephonyManager.isDeviceVoiceCapable()).isFalse();
+  }
+
+  @Test
+  @Config(minSdk = VANILLA_ICE_CREAM)
+  public void shouldGiveDeviceSmsCapableTrue() {
+    shadowOf(telephonyManager).setDeviceSmsCapable(true);
+    assertThat(telephonyManager.isDeviceSmsCapable()).isTrue();
+  }
+
+  @Config(minSdk = VANILLA_ICE_CREAM)
+  public void shouldGiveDeviceSmsCapableFalse() {
+    shadowOf(telephonyManager).setDeviceSmsCapable(false);
+    assertThat(telephonyManager.isDeviceSmsCapable()).isFalse();
+  }
+
   @Test
   @Config(minSdk = O)
   public void setDataEnabledChangesIsDataEnabled() {
@@ -1231,8 +1282,7 @@ public class ShadowTelephonyManagerTest {
   @Test
   @Config(minSdk = M)
   public void
-      isTtyModeSupported_shouldThrowSecurityExceptionWhenReadPhoneStatePermissionNotGranted()
-          throws Exception {
+      isTtyModeSupported_shouldThrowSecurityExceptionWhenReadPhoneStatePermissionNotGranted() {
     shadowOf(telephonyManager).setReadPhoneStatePermission(false);
     assertThrows(SecurityException.class, () -> telephonyManager.isTtyModeSupported());
   }
@@ -1645,4 +1695,15 @@ public class ShadowTelephonyManagerTest {
       System.setProperty("robolectric.createActivityContexts", originalProperty);
     }
   }
+
+  @Test
+  @Config(minSdk = N)
+  public void shouldGetIccAuthentication() {
+    shadowOf(telephonyManager).setIccAuthentication("iccAuth");
+
+    assertThat(
+            telephonyManager.getIccAuthentication(
+                /* appType= */ 1, /* authType= */ 1, /* data= */ "data"))
+        .isEqualTo("iccAuth");
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java
index 2a261076d..ae494bd5c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java
@@ -369,7 +369,7 @@ public class ShadowTextViewTest {
 
   @Test
   public void
-      testSetCompountDrawablesWithIntrinsicBounds_int_shouldCreateDrawablesWithResourceIds() {
+      testSetCompoundDrawablesWithIntrinsicBounds_int_shouldCreateDrawablesWithResourceIds() {
     textView.setCompoundDrawablesWithIntrinsicBounds(
         R.drawable.an_image,
         R.drawable.an_other_image,
@@ -389,7 +389,7 @@ public class ShadowTextViewTest {
   }
 
   @Test
-  public void testSetCompountDrawablesWithIntrinsicBounds_int_shouldNotCreateDrawablesForZero() {
+  public void testSetCompoundDrawablesWithIntrinsicBounds_int_shouldNotCreateDrawablesForZero() {
     textView.setCompoundDrawablesWithIntrinsicBounds(0, 0, 0, 0);
 
     assertNull(textView.getCompoundDrawables()[0]);
@@ -530,9 +530,10 @@ public class ShadowTextViewTest {
   }
 
   private void assertEachTextWatcherEventWasInvoked(MockTextWatcher mockTextWatcher) {
-    assertTrue(
+    assertEquals(
         "Expected each TextWatcher event to" + " have" + " been" + " invoked" + " once",
-        mockTextWatcher.methodsCalled.size() == 3);
+        3,
+        mockTextWatcher.methodsCalled.size());
 
     assertThat(mockTextWatcher.methodsCalled.get(0)).isEqualTo("beforeTextChanged");
     assertThat(mockTextWatcher.methodsCalled.get(1)).isEqualTo("onTextChanged");
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTimePickerDialogTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTimePickerDialogTest.java
index bee55cb92..c2fa99cdd 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTimePickerDialogTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTimePickerDialogTest.java
@@ -20,7 +20,7 @@ public class ShadowTimePickerDialogTest {
     ShadowTimePickerDialog shadow = shadowOf(timePickerDialog);
     assertThat(shadow.getHourOfDay()).isEqualTo(6);
     assertThat(shadow.getMinute()).isEqualTo(55);
-    assertThat(shadow.getIs24HourView()).isEqualTo(true);
+    assertThat(shadow.getIs24HourView()).isTrue();
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTraceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTraceTest.java
index a0d5b35de..8500b60a8 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTraceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTraceTest.java
@@ -263,7 +263,7 @@ public class ShadowTraceTest {
   }
 
   @Test
-  public void reset_resetsInternalState() throws Exception {
+  public void reset_resetsInternalState() {
     Trace.beginSection(/* sectionName= */ "section1");
     Trace.endSection();
     Trace.beginSection(/* sectionName= */ "section2");
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUIModeManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUIModeManagerTest.java
index 14ed09a07..22211d472 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUIModeManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUIModeManagerTest.java
@@ -34,7 +34,7 @@ public class ShadowUIModeManagerTest {
   public void setUp() {
     context = ApplicationProvider.getApplicationContext();
     uiModeManager = (UiModeManager) context.getSystemService(Context.UI_MODE_SERVICE);
-    shadowUiModeManager = (ShadowUIModeManager) Shadow.extract(uiModeManager);
+    shadowUiModeManager = Shadow.extract(uiModeManager);
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUiAutomationTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUiAutomationTest.java
index afef6eed3..faab02702 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUiAutomationTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUiAutomationTest.java
@@ -4,8 +4,11 @@ import static com.google.common.truth.Truth.assertThat;
 
 import android.app.UiAutomation;
 import android.content.ContentResolver;
+import android.content.Context;
+import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.content.res.Resources;
+import android.os.Build.VERSION_CODES;
 import android.provider.Settings;
 import android.view.Surface;
 import androidx.test.core.app.ApplicationProvider;
@@ -13,11 +16,29 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.platform.app.InstrumentationRegistry;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 import org.robolectric.annotation.LooperMode;
 
 /** Test for {@link ShadowUiAutomation}. */
 @RunWith(AndroidJUnit4.class)
 public class ShadowUiAutomationTest {
+
+  @Test
+  @Config(minSdk = VERSION_CODES.P)
+  public void grantRuntimePermission_grantsPermission() {
+    UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+    Context context = ApplicationProvider.getApplicationContext();
+    String packageName = context.getPackageName();
+
+    uiAutomation.grantRuntimePermission(android.Manifest.permission.READ_MEDIA_IMAGES, packageName);
+    uiAutomation.grantRuntimePermission(android.Manifest.permission.READ_MEDIA_VIDEO, packageName);
+
+    assertThat(context.checkSelfPermission(android.Manifest.permission.READ_MEDIA_IMAGES))
+        .isEqualTo(PackageManager.PERMISSION_GRANTED);
+    assertThat(context.checkSelfPermission(android.Manifest.permission.READ_MEDIA_VIDEO))
+        .isEqualTo(PackageManager.PERMISSION_GRANTED);
+  }
+
   @Test
   public void setAnimationScale_zero() throws Exception {
     ShadowUiAutomation.setAnimationScaleCompat(0);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java
index 5a7622756..8812f24de 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java
@@ -66,7 +66,7 @@ public class ShadowUsageStatsManagerTest {
   }
 
   @Test
-  public void testQueryEvents_emptyEvents() throws Exception {
+  public void testQueryEvents_emptyEvents() {
     UsageEvents events = usageStatsManager.queryEvents(1000L, 2000L);
     Event event = new Event();
 
@@ -75,7 +75,7 @@ public class ShadowUsageStatsManagerTest {
   }
 
   @Test
-  public void testQueryEvents_overlappingEvents() throws Exception {
+  public void testQueryEvents_overlappingEvents() {
     shadowOf(usageStatsManager).addEvent(TEST_PACKAGE_NAME1, 1000L, Event.MOVE_TO_BACKGROUND);
     shadowOf(usageStatsManager)
         .addEvent(
@@ -108,7 +108,7 @@ public class ShadowUsageStatsManagerTest {
   }
 
   @Test
-  public void testQueryEvents_appendEventData_shouldCombineWithPreviousData() throws Exception {
+  public void testQueryEvents_appendEventData_shouldCombineWithPreviousData() {
     shadowOf(usageStatsManager).addEvent(TEST_PACKAGE_NAME1, 500L, Event.MOVE_TO_FOREGROUND);
     shadowOf(usageStatsManager).addEvent(TEST_PACKAGE_NAME1, 1000L, Event.MOVE_TO_BACKGROUND);
     shadowOf(usageStatsManager)
@@ -150,8 +150,7 @@ public class ShadowUsageStatsManagerTest {
   }
 
   @Test
-  public void testQueryEvents_appendEventData_simulateTimeChange_shouldAddOffsetToPreviousData()
-      throws Exception {
+  public void testQueryEvents_appendEventData_simulateTimeChange_shouldAddOffsetToPreviousData() {
     shadowOf(usageStatsManager).addEvent(TEST_PACKAGE_NAME1, 500L, Event.MOVE_TO_FOREGROUND);
     shadowOf(usageStatsManager).addEvent(TEST_PACKAGE_NAME1, 1000L, Event.MOVE_TO_BACKGROUND);
     shadowOf(usageStatsManager)
@@ -195,7 +194,7 @@ public class ShadowUsageStatsManagerTest {
 
   @Test
   @Config(minSdk = Build.VERSION_CODES.P)
-  public void testGetAppStandbyBucket_withPackageName() throws Exception {
+  public void testGetAppStandbyBucket_withPackageName() {
     assertThat(shadowOf(usageStatsManager).getAppStandbyBuckets()).isEmpty();
 
     shadowOf(usageStatsManager).setAppStandbyBucket("app1", UsageStatsManager.STANDBY_BUCKET_RARE);
@@ -211,7 +210,7 @@ public class ShadowUsageStatsManagerTest {
 
   @Test
   @Config(minSdk = Build.VERSION_CODES.P)
-  public void testSetAppStandbyBuckets() throws Exception {
+  public void testSetAppStandbyBuckets() {
     assertThat(shadowOf(usageStatsManager).getAppStandbyBuckets()).isEmpty();
     assertThat(shadowOf(usageStatsManager).getAppStandbyBucket("app1"))
         .isEqualTo(UsageStatsManager.STANDBY_BUCKET_ACTIVE);
@@ -227,7 +226,7 @@ public class ShadowUsageStatsManagerTest {
 
   @Test
   @Config(minSdk = Build.VERSION_CODES.P)
-  public void testGetAppStandbyBucket_currentApp() throws Exception {
+  public void testGetAppStandbyBucket_currentApp() {
     shadowOf(usageStatsManager).setCurrentAppStandbyBucket(UsageStatsManager.STANDBY_BUCKET_RARE);
     assertThat(shadowOf(usageStatsManager).getAppStandbyBucket())
         .isEqualTo(UsageStatsManager.STANDBY_BUCKET_RARE);
@@ -1067,7 +1066,7 @@ public class ShadowUsageStatsManagerTest {
 
   @Test
   @Config(minSdk = V.SDK_INT)
-  public void testQueryEvents_newApiV_shouldReturn() throws Exception {
+  public void testQueryEvents_newApiV_shouldReturn() {
     // These events should be returned.
     shadowOf(usageStatsManager)
         .addEvent(
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbDeviceConnectionTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbDeviceConnectionTest.java
index 00f30bfd9..df6dca696 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbDeviceConnectionTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbDeviceConnectionTest.java
@@ -20,6 +20,7 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.util.Arrays;
 import javax.annotation.Nullable;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,13 +34,15 @@ public class ShadowUsbDeviceConnectionTest {
 
   private UsbManager usbManager;
 
+  private AutoCloseable mock;
+
   @Mock private UsbDevice usbDevice;
   @Mock private UsbConfiguration usbConfiguration;
   @Mock private UsbInterface usbInterface;
 
   @Before
   public void setUp() {
-    MockitoAnnotations.initMocks(this);
+    mock = MockitoAnnotations.openMocks(this);
     usbManager =
         (UsbManager)
             ApplicationProvider.getApplicationContext().getSystemService(Context.USB_SERVICE);
@@ -51,6 +54,11 @@ public class ShadowUsbDeviceConnectionTest {
     when(usbConfiguration.getInterface(0)).thenReturn(usbInterface);
   }
 
+  @After
+  public void tearDown() throws Exception {
+    mock.close();
+  }
+
   @Test
   public void claimInterface() {
     UsbDeviceConnection usbDeviceConnection = usbManager.openDevice(usbDevice);
@@ -126,7 +134,7 @@ public class ShadowUsbDeviceConnectionTest {
   }
 
   @Test
-  public void releaseInterface_closesOutgoingDataStream() throws Exception {
+  public void releaseInterface_closesOutgoingDataStream() {
     UsbDeviceConnection usbDeviceConnection = usbManager.openDevice(usbDevice);
     UsbInterface usbInterface = selectInterface(usbDevice);
     UsbEndpoint usbEndpointOut = getEndpoint(usbInterface, UsbConstants.USB_DIR_OUT);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java
index 6fc08b390..d13d3ecc7 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java
@@ -28,6 +28,7 @@ import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.stream.Collectors;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -48,13 +49,15 @@ public class ShadowUsbManagerTest {
 
   private UsbManager usbManager;
 
+  private AutoCloseable mock;
+
   @Mock UsbDevice usbDevice1;
   @Mock UsbDevice usbDevice2;
   @Mock UsbAccessory usbAccessory;
 
   @Before
   public void setUp() {
-    MockitoAnnotations.initMocks(this);
+    mock = MockitoAnnotations.openMocks(this);
     usbManager =
         (UsbManager)
             ApplicationProvider.getApplicationContext().getSystemService(Context.USB_SERVICE);
@@ -63,6 +66,11 @@ public class ShadowUsbManagerTest {
     when(usbDevice2.getDeviceName()).thenReturn(DEVICE_NAME_2);
   }
 
+  @After
+  public void tearDown() throws Exception {
+    mock.close();
+  }
+
   @Test
   public void getDeviceList() {
     assertThat(usbManager.getDeviceList()).isEmpty();
@@ -213,7 +221,7 @@ public class ShadowUsbManagerTest {
   }
 
   @Test
-  public void openDevice() throws Exception {
+  public void openDevice() {
     shadowOf(usbManager).addOrUpdateUsbDevice(usbDevice1, true);
     UsbDeviceConnection connection = usbManager.openDevice(usbDevice1);
     assertThat(connection).isNotNull();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbRequestTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbRequestTest.java
index 48ceba327..462e9eb73 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbRequestTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbRequestTest.java
@@ -35,13 +35,15 @@ public class ShadowUsbRequestTest {
   private UsbManager usbManager;
   private UsbRequest dataRequest;
 
+  private AutoCloseable mock;
+
   @Mock private UsbDevice usbDevice;
   @Mock private UsbConfiguration usbConfiguration;
   @Mock private UsbInterface usbInterface;
 
   @Before
   public void setUp() {
-    MockitoAnnotations.initMocks(this);
+    mock = MockitoAnnotations.openMocks(this);
     usbManager =
         (UsbManager)
             ApplicationProvider.getApplicationContext().getSystemService(Context.USB_SERVICE);
@@ -58,8 +60,9 @@ public class ShadowUsbRequestTest {
   }
 
   @After
-  public void tearDown() {
+  public void tearDown() throws Exception {
     dataRequest.close();
+    mock.close();
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUserManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUserManagerTest.java
index 22600b67f..ce403e1fa 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUserManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUserManagerTest.java
@@ -8,6 +8,7 @@ import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
@@ -269,6 +270,34 @@ public class ShadowUserManagerTest {
     assertThat(userManager.isProfile()).isTrue();
   }
 
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void isAdminUser_nonAdminUser_returnsFalse() {
+    UserHandle nonAdminHandle =
+        shadowOf(userManager).addUser(TEST_USER_HANDLE, "", ShadowUserManager.FLAG_FULL);
+
+    setUserIdInContext(nonAdminHandle.getIdentifier());
+    assertThat(userManager.isAdminUser()).isFalse();
+  }
+
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void isAdminUser_firstUser_returnsTrue() {
+    assertThat(userManager.isAdminUser()).isTrue();
+  }
+
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void isAdminUser_secondaryAdminUser_returnsTrue() {
+    UserHandle secondaryAdminHandle =
+        shadowOf(userManager)
+            .addUser(
+                TEST_USER_HANDLE, "", ShadowUserManager.FLAG_ADMIN | ShadowUserManager.FLAG_FULL);
+
+    setUserIdInContext(secondaryAdminHandle.getIdentifier());
+    assertThat(userManager.isAdminUser()).isTrue();
+  }
+
   @Test
   public void enforcePermissionChecks() {
     shadowOf(userManager).enforcePermissionChecks(true);
@@ -347,12 +376,12 @@ public class ShadowUserManagerTest {
   @Test
   @Config(minSdk = R)
   public void getUserHandles() {
-    assertThat(shadowOf(userManager).getUserHandles(/* excludeDying= */ true).size()).isEqualTo(1);
+    assertThat(shadowOf(userManager).getUserHandles(/* excludeDying= */ true)).hasSize(1);
     shadowOf(userManager).getUserHandles(/* excludeDying= */ true).get(0);
     assertThat(UserHandle.myUserId()).isEqualTo(UserHandle.USER_SYSTEM);
 
     UserHandle expectedUserHandle = shadowOf(userManager).addUser(10, "secondary_user", 0);
-    assertThat(shadowOf(userManager).getUserHandles(/* excludeDying= */ true).size()).isEqualTo(2);
+    assertThat(shadowOf(userManager).getUserHandles(/* excludeDying= */ true)).hasSize(2);
     assertThat(shadowOf(userManager).getUserHandles(/* excludeDying= */ true).get(1))
         .isEqualTo(expectedUserHandle);
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowVibratorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowVibratorTest.java
index ff426934d..956bab26f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowVibratorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowVibratorTest.java
@@ -201,7 +201,7 @@ public class ShadowVibratorTest {
 
   @Config(minSdk = R)
   @Test
-  public void areAllPrimitivesSupported_oneUnsupportedPrimitivie_shouldReturnFalse() {
+  public void areAllPrimitivesSupported_oneUnsupportedPrimitive_shouldReturnFalse() {
     shadowOf(vibrator)
         .setSupportedPrimitives(ImmutableList.of(EFFECT_CLICK, EFFECT_TICK, EFFECT_HEAVY_CLICK));
 
@@ -240,7 +240,7 @@ public class ShadowVibratorTest {
 
   @Config(minSdk = O, maxSdk = R)
   @Test
-  public void getAudioAttribues_vibrateWithAudioAttributes_shouldReturnAudioAttributes() {
+  public void getAudioAttributes_vibrateWithAudioAttributes_shouldReturnAudioAttributes() {
     AudioAttributes audioAttributes =
         new AudioAttributes.Builder()
             .setUsage(AudioAttributes.USAGE_NOTIFICATION_COMMUNICATION_REQUEST)
@@ -249,9 +249,10 @@ public class ShadowVibratorTest {
 
     vibrator.vibrate(/* delay= */ 200, audioAttributes);
 
-    AudioAttributes actualAudioAttriubes = shadowOf(vibrator).getAudioAttributesFromLastVibration();
-    assertThat(actualAudioAttriubes.getAllFlags()).isEqualTo(audioAttributes.getAllFlags());
-    assertThat(actualAudioAttriubes.getUsage()).isEqualTo(audioAttributes.getUsage());
+    AudioAttributes actualAudioAttributes =
+        shadowOf(vibrator).getAudioAttributesFromLastVibration();
+    assertThat(actualAudioAttributes.getAllFlags()).isEqualTo(audioAttributes.getAllFlags());
+    assertThat(actualAudioAttributes.getUsage()).isEqualTo(audioAttributes.getUsage());
   }
 
   @Config(minSdk = S)
@@ -278,7 +279,7 @@ public class ShadowVibratorTest {
 
   @Config(minSdk = S)
   @Test
-  public void getPrimitiveDurations_mulitpleNonDefaultsSupplied_returnsNonDefaultValues() {
+  public void getPrimitiveDurations_multipleNonDefaultsSupplied_returnsNonDefaultValues() {
     shadowOf(vibrator).setPrimitiveDurations(EFFECT_CLICK, 10);
     shadowOf(vibrator).setPrimitiveDurations(EFFECT_TICK, 20);
 
@@ -290,7 +291,7 @@ public class ShadowVibratorTest {
 
   @Config(minSdk = S)
   @Test
-  public void getPrimitiveDurations_mulitpleNonDefaultsSupplied_returnsOnlyRequestedValues() {
+  public void getPrimitiveDurations_multipleNonDefaultsSupplied_returnsOnlyRequestedValues() {
     shadowOf(vibrator).setPrimitiveDurations(EFFECT_CLICK, 10);
     shadowOf(vibrator).setPrimitiveDurations(EFFECT_TICK, 20);
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewConfigurationTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewConfigurationTest.java
index 0f240e7f4..e73313e2c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewConfigurationTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewConfigurationTest.java
@@ -4,7 +4,6 @@ import static android.os.Build.VERSION_CODES.O_MR1;
 import static android.os.Build.VERSION_CODES.Q;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
-import static org.robolectric.Shadows.shadowOf;
 
 import android.app.Application;
 import android.view.ViewConfiguration;
@@ -98,8 +97,7 @@ public class ShadowViewConfigurationTest {
   public void testHasPermanentMenuKey() {
     assertThat(viewConfiguration.hasPermanentMenuKey()).isTrue();
 
-    ShadowViewConfiguration shadowViewConfiguration = shadowOf(viewConfiguration);
-    shadowViewConfiguration.setHasPermanentMenuKey(false);
+    ShadowViewConfiguration.setHasPermanentMenuKey(false);
     assertThat(viewConfiguration.hasPermanentMenuKey()).isFalse();
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java
index a0654813c..784855ef5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java
@@ -28,6 +28,7 @@ import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.io.ByteArrayOutputStream;
 import java.io.PrintStream;
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import org.junit.After;
 import org.junit.Before;
@@ -35,7 +36,6 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.R;
 import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
 import org.robolectric.annotation.GraphicsMode;
 import org.robolectric.annotation.GraphicsMode.Mode;
 
@@ -70,7 +70,7 @@ public class ShadowViewGroupTest {
     child3.addView(child3a);
     child3.addView(child3b);
 
-    defaultLineSeparator = System.getProperty("line.separator");
+    defaultLineSeparator = System.lineSeparator();
     System.setProperty("line.separator", "\n");
   }
 
@@ -162,7 +162,7 @@ public class ShadowViewGroupTest {
   }
 
   @Test
-  public void shouldfindViewWithTagFromCorrectViewGroup() {
+  public void shouldFindViewWithTagFromCorrectViewGroup() {
     root.removeAllViews();
     child1.setTag("tag1");
     child2.setTag("tag2");
@@ -185,7 +185,6 @@ public class ShadowViewGroupTest {
   }
 
   @Test
-  @Config(minSdk = 17) // TODO: mysteriously fails on github CI on API 16
   public void hasFocus_shouldReturnTrueIfAnyChildHasFocus() {
     ContainerActivity containerActivity = Robolectric.setupActivity(ContainerActivity.class);
     makeFocusable(
@@ -540,7 +539,7 @@ public class ShadowViewGroupTest {
     }
 
     @Override
-    public void draw(Canvas canvas) {
+    public void draw(@Nonnull Canvas canvas) {
       super.draw(canvas);
       wasDrawn = true;
     }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java
index 780b3cd4b..db62299a4 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java
@@ -52,6 +52,7 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -76,7 +77,7 @@ public class ShadowViewTest {
     InstrumentationRegistry.getInstrumentation().setInTouchMode(false);
     transcript = new ArrayList<>();
     context = ApplicationProvider.getApplicationContext();
-    view = Robolectric.setupActivity(ContainerActivity.class).getView();
+    view = setupActivity(ContainerActivity.class).getView();
   }
 
   public static class ContainerActivity extends Activity {
@@ -105,14 +106,14 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void layout_shouldAffectWidthAndHeight() throws Exception {
+  public void layout_shouldAffectWidthAndHeight() {
     view.layout(100, 200, 303, 404);
     assertThat(view.getWidth()).isEqualTo(303 - 100);
     assertThat(view.getHeight()).isEqualTo(404 - 200);
   }
 
   @Test
-  public void measuredDimensions() throws Exception {
+  public void measuredDimensions() {
     View view1 =
         new View(context) {
           {
@@ -124,7 +125,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void layout_shouldCallOnLayoutOnlyIfChanged() throws Exception {
+  public void layout_shouldCallOnLayoutOnlyIfChanged() {
     View view1 =
         new View(context) {
           @Override
@@ -143,16 +144,11 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldFocus() throws Exception {
+  public void shouldFocus() {
     final List<String> transcript = new ArrayList<>();
 
     view.setOnFocusChangeListener(
-        new View.OnFocusChangeListener() {
-          @Override
-          public void onFocusChange(View v, boolean hasFocus) {
-            transcript.add(hasFocus ? "Gained focus" : "Lost focus");
-          }
-        });
+        (v, hasFocus) -> transcript.add(hasFocus ? "Gained focus" : "Lost focus"));
 
     assertFalse(view.isFocused());
     assertFalse(view.hasFocus());
@@ -180,7 +176,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldNotBeFocusableByDefault() throws Exception {
+  public void shouldNotBeFocusableByDefault() {
     assertFalse(view.isFocusable());
 
     view.setFocusable(true);
@@ -188,7 +184,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldKnowIfThisOrAncestorsAreVisible() throws Exception {
+  public void shouldKnowIfThisOrAncestorsAreVisible() {
     assertThat(view.isShown()).isTrue();
     shadowOf(view).setMyParent(null);
 
@@ -204,7 +200,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldInflateMergeRootedLayoutAndNotCreateReferentialLoops() throws Exception {
+  public void shouldInflateMergeRootedLayoutAndNotCreateReferentialLoops() {
     LinearLayout root = new LinearLayout(context);
     LinearLayout.inflate(context, R.layout.inner_merge, root);
     for (int i = 0; i < root.getChildCount(); i++) {
@@ -214,7 +210,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void performLongClick_shouldClickOnView() throws Exception {
+  public void performLongClick_shouldClickOnView() {
     OnLongClickListener clickListener = mock(OnLongClickListener.class);
     view.setOnLongClickListener(clickListener);
     view.performLongClick();
@@ -223,7 +219,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void checkedClick_shouldClickOnView() throws Exception {
+  public void checkedClick_shouldClickOnView() {
     OnClickListener clickListener = mock(OnClickListener.class);
     view.setOnClickListener(clickListener);
     shadowOf(view).checkedPerformClick();
@@ -232,7 +228,7 @@ public class ShadowViewTest {
   }
 
   @Test(expected = RuntimeException.class)
-  public void checkedClick_shouldThrowIfViewIsNotVisible() throws Exception {
+  public void checkedClick_shouldThrowIfViewIsNotVisible() {
     ViewGroup grandParent = new LinearLayout(context);
     ViewGroup parent = new LinearLayout(context);
     grandParent.addView(parent);
@@ -243,13 +239,13 @@ public class ShadowViewTest {
   }
 
   @Test(expected = RuntimeException.class)
-  public void checkedClick_shouldThrowIfViewIsDisabled() throws Exception {
+  public void checkedClick_shouldThrowIfViewIsDisabled() {
     view.setEnabled(false);
     shadowOf(view).checkedPerformClick();
   }
 
   @Test
-  public void getBackground_shouldReturnNullIfNoBackgroundHasBeenSet() throws Exception {
+  public void getBackground_shouldReturnNullIfNoBackgroundHasBeenSet() {
     assertThat(view.getBackground()).isNull();
   }
 
@@ -262,14 +258,14 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldSetBackgroundResource() throws Exception {
+  public void shouldSetBackgroundResource() {
     view.setBackgroundResource(R.drawable.an_image);
     assertThat(shadowOf((BitmapDrawable) view.getBackground()).getCreatedFromResId())
         .isEqualTo(R.drawable.an_image);
   }
 
   @Test
-  public void shouldClearBackgroundResource() throws Exception {
+  public void shouldClearBackgroundResource() {
     view.setBackgroundResource(R.drawable.an_image);
     view.setBackgroundResource(0);
     assertThat(view.getBackground()).isEqualTo(null);
@@ -295,7 +291,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldPostActionsToTheMessageQueue() throws Exception {
+  public void shouldPostActionsToTheMessageQueue() {
     shadowMainLooper().pause();
 
     TestRunnable runnable = new TestRunnable();
@@ -307,7 +303,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldPostInvalidateDelayed() throws Exception {
+  public void shouldPostInvalidateDelayed() {
     shadowMainLooper().pause();
     ShadowView shadowView = shadowOf(view);
     shadowView.clearWasInvalidated();
@@ -321,7 +317,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldPostActionsToTheMessageQueueWithDelay() throws Exception {
+  public void shouldPostActionsToTheMessageQueueWithDelay() {
     shadowMainLooper().pause();
 
     TestRunnable runnable = new TestRunnable();
@@ -333,7 +329,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldRemovePostedCallbacksFromMessageQueue() throws Exception {
+  public void shouldRemovePostedCallbacksFromMessageQueue() {
     TestRunnable runnable = new TestRunnable();
     assertThat(view.postDelayed(runnable, 1)).isTrue();
 
@@ -344,7 +340,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldSupportAllConstructors() throws Exception {
+  public void shouldSupportAllConstructors() {
     new View(context);
     new View(context, null);
     new View(context, null, 0);
@@ -360,7 +356,7 @@ public class ShadowViewTest {
 
   @Test
   @ResourcesMode(ResourcesMode.Mode.BINARY)
-  public void shouldAddOnClickListenerFromAttribute() throws Exception {
+  public void shouldAddOnClickListenerFromAttribute() {
     AttributeSet attrs =
         Robolectric.buildAttributeSet().addAttribute(android.R.attr.onClick, "clickMe").build();
 
@@ -370,7 +366,7 @@ public class ShadowViewTest {
 
   @Test
   @ResourcesMode(ResourcesMode.Mode.BINARY)
-  public void shouldCallOnClickWithAttribute() throws Exception {
+  public void shouldCallOnClickWithAttribute() {
     MyActivity myActivity = buildActivity(MyActivity.class).create().get();
 
     AttributeSet attrs =
@@ -382,7 +378,7 @@ public class ShadowViewTest {
   }
 
   @Test(expected = RuntimeException.class)
-  public void shouldThrowExceptionWithBadMethodName() throws Exception {
+  public void shouldThrowExceptionWithBadMethodName() {
     MyActivity myActivity = buildActivity(MyActivity.class).create().get();
 
     AttributeSet attrs =
@@ -393,14 +389,14 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldSetAnimation() throws Exception {
+  public void shouldSetAnimation() {
     Animation anim = new TestAnimation();
     view.setAnimation(anim);
     assertThat(view.getAnimation()).isSameInstanceAs(anim);
   }
 
   @Test
-  public void clearAnimation_cancelsAnimation() throws Exception {
+  public void clearAnimation_cancelsAnimation() {
     AtomicInteger numTicks = new AtomicInteger();
     final Animation anim =
         new Animation() {
@@ -424,7 +420,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void scrollTo_shouldStoreTheScrolledCoordinates() throws Exception {
+  public void scrollTo_shouldStoreTheScrolledCoordinates() {
     // This test depends on broken scrolling behavior.
     System.setProperty("robolectric.useRealScrolling", "false");
     try {
@@ -436,7 +432,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldScrollTo() throws Exception {
+  public void shouldScrollTo() {
     view.scrollTo(7, 6);
 
     assertEquals(7, view.getScrollX());
@@ -444,7 +440,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void scrollBy_shouldStoreTheScrolledCoordinates() throws Exception {
+  public void scrollBy_shouldStoreTheScrolledCoordinates() {
     // This test depends on broken scrolling behavior.
     System.setProperty("robolectric.useRealScrolling", "false");
     try {
@@ -466,14 +462,14 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void getViewTreeObserver_shouldReturnTheSameObserverFromMultipleCalls() throws Exception {
+  public void getViewTreeObserver_shouldReturnTheSameObserverFromMultipleCalls() {
     ViewTreeObserver observer = view.getViewTreeObserver();
     assertThat(observer).isInstanceOf(ViewTreeObserver.class);
     assertThat(view.getViewTreeObserver()).isSameInstanceAs(observer);
   }
 
   @Test
-  public void dispatchTouchEvent_sendsMotionEventToOnTouchEvent() throws Exception {
+  public void dispatchTouchEvent_sendsMotionEventToOnTouchEvent() {
     TouchableView touchableView = new TouchableView(context);
     MotionEvent event = MotionEvent.obtain(0L, 0L, MotionEvent.ACTION_DOWN, 12f, 34f, 0);
     touchableView.dispatchTouchEvent(event);
@@ -483,15 +479,12 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void dispatchTouchEvent_listensToFalseFromListener() throws Exception {
+  public void dispatchTouchEvent_listensToFalseFromListener() {
     final AtomicBoolean called = new AtomicBoolean(false);
     view.setOnTouchListener(
-        new View.OnTouchListener() {
-          @Override
-          public boolean onTouch(View view, MotionEvent motionEvent) {
-            called.set(true);
-            return false;
-          }
+        (view, motionEvent) -> {
+          called.set(true);
+          return false;
         });
     MotionEvent event = MotionEvent.obtain(0L, 0L, MotionEvent.ACTION_DOWN, 12f, 34f, 0);
     view.dispatchTouchEvent(event);
@@ -500,7 +493,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void test_nextFocusDownId() throws Exception {
+  public void test_nextFocusDownId() {
     assertEquals(View.NO_ID, view.getNextFocusDownId());
 
     view.setNextFocusDownId(R.id.icon);
@@ -589,7 +582,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldGetAndSetTranslations() throws Exception {
+  public void shouldGetAndSetTranslations() {
     view = new TestView(buildActivity(Activity.class).create().get());
     view.setTranslationX(8.9f);
     view.setTranslationY(4.6f);
@@ -599,7 +592,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldGetAndSetAlpha() throws Exception {
+  public void shouldGetAndSetAlpha() {
     view = new TestView(buildActivity(Activity.class).create().get());
     view.setAlpha(9.1f);
 
@@ -622,7 +615,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldTrackRequestLayoutCalls() throws Exception {
+  public void shouldTrackRequestLayoutCalls() {
     shadowOf(view).setDidRequestLayout(false);
     assertThat(shadowOf(view).didRequestLayout()).isFalse();
     view.requestLayout();
@@ -632,36 +625,24 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldClickAndNotClick() throws Exception {
+  public void shouldClickAndNotClick() {
     assertThat(view.isClickable()).isFalse();
     view.setClickable(true);
     assertThat(view.isClickable()).isTrue();
     view.setClickable(false);
     assertThat(view.isClickable()).isFalse();
-    view.setOnClickListener(
-        new OnClickListener() {
-          @Override
-          public void onClick(View v) {
-            ;
-          }
-        });
+    view.setOnClickListener(v -> {});
     assertThat(view.isClickable()).isTrue();
   }
 
   @Test
-  public void shouldLongClickAndNotLongClick() throws Exception {
+  public void shouldLongClickAndNotLongClick() {
     assertThat(view.isLongClickable()).isFalse();
     view.setLongClickable(true);
     assertThat(view.isLongClickable()).isTrue();
     view.setLongClickable(false);
     assertThat(view.isLongClickable()).isFalse();
-    view.setOnLongClickListener(
-        new OnLongClickListener() {
-          @Override
-          public boolean onLongClick(View v) {
-            return false;
-          }
-        });
+    view.setOnLongClickListener(v -> false);
     assertThat(view.isLongClickable()).isTrue();
   }
 
@@ -746,7 +727,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void performHapticFeedback_shouldSetLastPerformedHapticFeedback() throws Exception {
+  public void performHapticFeedback_shouldSetLastPerformedHapticFeedback() {
     assertThat(shadowOf(view).lastHapticFeedbackPerformed()).isEqualTo(-1);
     view.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
     assertThat(shadowOf(view).lastHapticFeedbackPerformed())
@@ -754,7 +735,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void canAssertThatSuperDotOnLayoutWasCalledFromViewSubclasses() throws Exception {
+  public void canAssertThatSuperDotOnLayoutWasCalledFromViewSubclasses() {
     TestView2 view = new TestView2(setupActivity(Activity.class), 1111, 1112);
     assertThat(shadowOf(view).onLayoutWasCalled()).isFalse();
     view.onLayout(true, 1, 2, 3, 4);
@@ -762,7 +743,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void setScrolls_canBeAskedFor() throws Exception {
+  public void setScrolls_canBeAskedFor() {
     view.setScrollX(234);
     view.setScrollY(544);
     assertThat(view.getScrollX()).isEqualTo(234);
@@ -770,7 +751,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void setScrolls_firesOnScrollChanged() throws Exception {
+  public void setScrolls_firesOnScrollChanged() {
     TestView testView = new TestView(buildActivity(Activity.class).create().get());
     testView.setScrollX(122);
     testView.setScrollY(150);
@@ -783,7 +764,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void layerType() throws Exception {
+  public void layerType() {
     assertThat(view.getLayerType()).isEqualTo(View.LAYER_TYPE_NONE);
     view.setLayerType(View.LAYER_TYPE_SOFTWARE, null);
     assertThat(view.getLayerType()).isEqualTo(View.LAYER_TYPE_SOFTWARE);
@@ -833,8 +814,8 @@ public class ShadowViewTest {
 
   private static class TestView2 extends View {
 
-    private int minWidth;
-    private int minHeight;
+    private final int minWidth;
+    private final int minHeight;
 
     public TestView2(Context context, int minWidth, int minHeight) {
       super(context);
@@ -854,12 +835,12 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void shouldCallOnAttachedToAndDetachedFromWindow() throws Exception {
+  public void shouldCallOnAttachedToAndDetachedFromWindow() {
     MyView parent = new MyView("parent", transcript);
     parent.addView(new MyView("child", transcript));
     assertThat(transcript).isEmpty();
 
-    Activity activity = Robolectric.buildActivity(ContentViewActivity.class).setup().get();
+    Activity activity = buildActivity(ContentViewActivity.class).setup().get();
     activity.getWindowManager().addView(parent, new WindowManager.LayoutParams(100, 100));
     shadowMainLooper().idle();
     assertThat(transcript).containsExactly("parent attached", "child attached");
@@ -881,7 +862,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void getWindowId_shouldReturnValidObjectWhenAttached() throws Exception {
+  public void getWindowId_shouldReturnValidObjectWhenAttached() {
     MyView parent = new MyView("parent", transcript);
     MyView child = new MyView("child", transcript);
     parent.addView(child);
@@ -889,7 +870,7 @@ public class ShadowViewTest {
     assertThat(parent.getWindowId()).isNull();
     assertThat(child.getWindowId()).isNull();
 
-    Activity activity = Robolectric.buildActivity(ContentViewActivity.class).create().get();
+    Activity activity = buildActivity(ContentViewActivity.class).create().get();
     activity.getWindowManager().addView(parent, new WindowManager.LayoutParams(100, 100));
     shadowMainLooper().idle();
 
@@ -908,9 +889,9 @@ public class ShadowViewTest {
 
   // todo looks like this is flaky...
   @Test
-  public void removeAllViews_shouldCallOnAttachedToAndDetachedFromWindow() throws Exception {
+  public void removeAllViews_shouldCallOnAttachedToAndDetachedFromWindow() {
     MyView parent = new MyView("parent", transcript);
-    Activity activity = Robolectric.buildActivity(ContentViewActivity.class).create().get();
+    Activity activity = buildActivity(ContentViewActivity.class).create().get();
     activity.getWindowManager().addView(parent, new WindowManager.LayoutParams(100, 100));
 
     parent.addView(new MyView("child", transcript));
@@ -923,7 +904,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void capturesOnSystemUiVisibilityChangeListener() throws Exception {
+  public void capturesOnSystemUiVisibilityChangeListener() {
     TestView testView = new TestView(buildActivity(Activity.class).create().get());
     View.OnSystemUiVisibilityChangeListener changeListener =
         new View.OnSystemUiVisibilityChangeListener() {
@@ -937,7 +918,7 @@ public class ShadowViewTest {
   }
 
   @Test
-  public void capturesOnCreateContextMenuListener() throws Exception {
+  public void capturesOnCreateContextMenuListener() {
     TestView testView = new TestView(buildActivity(Activity.class).create().get());
     assertThat(shadowOf(testView).getOnCreateContextMenuListener()).isNull();
 
@@ -963,19 +944,19 @@ public class ShadowViewTest {
     View.OnAttachStateChangeListener attachListener1 =
         new View.OnAttachStateChangeListener() {
           @Override
-          public void onViewAttachedToWindow(View v) {}
+          public void onViewAttachedToWindow(@Nonnull View v) {}
 
           @Override
-          public void onViewDetachedFromWindow(View v) {}
+          public void onViewDetachedFromWindow(@Nonnull View v) {}
         };
 
     View.OnAttachStateChangeListener attachListener2 =
         new View.OnAttachStateChangeListener() {
           @Override
-          public void onViewAttachedToWindow(View v) {}
+          public void onViewAttachedToWindow(@Nonnull View v) {}
 
           @Override
-          public void onViewDetachedFromWindow(View v) {}
+          public void onViewDetachedFromWindow(@Nonnull View v) {}
         };
 
     testView.addOnAttachStateChangeListener(attachListener1);
@@ -1013,8 +994,7 @@ public class ShadowViewTest {
   @Test
   public void usesDefaultGlobalVisibleRect() {
 
-    final ActivityController<Activity> activityController =
-        Robolectric.buildActivity(Activity.class);
+    final ActivityController<Activity> activityController = buildActivity(Activity.class);
     final Activity activity = activityController.get();
     TextView fooView = new TextView(activity);
     activity.setContentView(
@@ -1161,8 +1141,8 @@ public class ShadowViewTest {
   }
 
   public static class MyView extends LinearLayout {
-    private String name;
-    private List<String> transcript;
+    private final String name;
+    private final List<String> transcript;
 
     public MyView(String name, List<String> transcript) {
       super(ApplicationProvider.getApplicationContext());
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowVoiceInteractionServiceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowVoiceInteractionServiceTest.java
index 7a935f489..f7702faed 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowVoiceInteractionServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowVoiceInteractionServiceTest.java
@@ -74,11 +74,7 @@ public class ShadowVoiceInteractionServiceTest {
   @Test
   @Config(minSdk = M)
   public void showSessionInvokedBeforeServiceReady_throwsException() {
-    assertThrows(
-        IllegalStateException.class,
-        () -> {
-          service.showSession(new Bundle(), 0);
-        });
+    assertThrows(IllegalStateException.class, () -> service.showSession(new Bundle(), 0));
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowVoiceInteractorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowVoiceInteractorTest.java
index 7b4daae3a..46682bcb9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowVoiceInteractorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowVoiceInteractorTest.java
@@ -138,7 +138,7 @@ public final class ShadowVoiceInteractorTest {
   }
 
   private void assertValues(List<String> promptMessage) {
-    assertThat(shadowVoiceInteractor.getVoiceInteractions().size()).isEqualTo(promptMessage.size());
+    assertThat(shadowVoiceInteractor.getVoiceInteractions()).hasSize(promptMessage.size());
     assertThat(shadowVoiceInteractor.getVoiceInteractions()).isEqualTo(promptMessage);
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java
index 77a83444d..ef2906595 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java
@@ -5,7 +5,7 @@ import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.truth.Truth.assertThat;
-import static junit.framework.Assert.fail;
+import static org.junit.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.app.Activity;
@@ -116,11 +116,11 @@ public class ShadowWallpaperManagerTest {
 
   @Test
   public void hasResourceWallpaper_wallpaperResourceSet_returnsTrue() throws IOException {
-    int resid = 5;
-    manager.setResource(resid);
+    int resId = 5;
+    manager.setResource(resId);
 
     assertThat(manager.hasResourceWallpaper(1)).isFalse();
-    assertThat(manager.hasResourceWallpaper(resid)).isTrue();
+    assertThat(manager.hasResourceWallpaper(resId)).isTrue();
   }
 
   @Test
@@ -341,7 +341,7 @@ public class ShadowWallpaperManagerTest {
 
   @Test
   @Config(minSdk = N)
-  public void getWallpaperFile_flagSystem_nothingCached_shouldReturnNull() throws Exception {
+  public void getWallpaperFile_flagSystem_nothingCached_shouldReturnNull() {
     assertThat(manager.getWallpaperFile(WallpaperManager.FLAG_SYSTEM)).isNull();
   }
 
@@ -364,7 +364,7 @@ public class ShadowWallpaperManagerTest {
 
   @Test
   @Config(minSdk = N)
-  public void getWallpaperFile_flagLock_nothingCached_shouldReturnNull() throws Exception {
+  public void getWallpaperFile_flagLock_nothingCached_shouldReturnNull() {
     assertThat(manager.getWallpaperFile(WallpaperManager.FLAG_LOCK)).isNull();
   }
 
@@ -387,7 +387,7 @@ public class ShadowWallpaperManagerTest {
 
   @Test
   @Config(minSdk = N)
-  public void getWallpaperFile_unsupportedFlag_shouldReturnNull() throws Exception {
+  public void getWallpaperFile_unsupportedFlag_shouldReturnNull() {
     assertThat(manager.getWallpaperFile(UNSUPPORTED_FLAG)).isNull();
   }
 
@@ -540,8 +540,7 @@ public class ShadowWallpaperManagerTest {
   @Test
   @Config(minSdk = M)
   public void
-      setWallpaperComponent_liveWallpaperSet_shouldReturnLiveWallpaperComponentAndUnsetStaticWallpapers()
-          throws Exception {
+      setWallpaperComponent_liveWallpaperSet_shouldReturnLiveWallpaperComponentAndUnsetStaticWallpapers() {
     manager.setWallpaperComponent(TEST_WALLPAPER_SERVICE);
 
     assertThat(manager.getWallpaperInfo().getComponent()).isEqualTo(TEST_WALLPAPER_SERVICE);
@@ -551,7 +550,7 @@ public class ShadowWallpaperManagerTest {
 
   @Test
   @Config(minSdk = M)
-  public void getWallpaperInfo_noLiveWallpaperSet_shouldReturnNull() throws Exception {
+  public void getWallpaperInfo_noLiveWallpaperSet_shouldReturnNull() {
     assertThat(manager.getWallpaperInfo()).isNull();
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java
index c50cda771..abbbe6aaa 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java
@@ -113,7 +113,7 @@ public class ShadowWearableSensingManagerTest {
   }
 
   @Test
-  public void getLastDataBundle_noDataProvided_doesNotThrow() throws Exception {
+  public void getLastDataBundle_noDataProvided_doesNotThrow() {
     WearableSensingManager wearableSensingManager =
         (WearableSensingManager)
             getApplicationContext().getSystemService(Context.WEARABLE_SENSING_SERVICE);
@@ -124,7 +124,7 @@ public class ShadowWearableSensingManagerTest {
   }
 
   @Test
-  public void getLastSharedMemory_noDataProvided_doesNotThrow() throws Exception {
+  public void getLastSharedMemory_noDataProvided_doesNotThrow() {
     WearableSensingManager wearableSensingManager =
         (WearableSensingManager)
             getApplicationContext().getSystemService(Context.WEARABLE_SENSING_SERVICE);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWebViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWebViewTest.java
index a11de5faf..76f5a55c9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWebViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWebViewTest.java
@@ -23,6 +23,7 @@ import android.webkit.WebSettings;
 import android.webkit.WebView;
 import android.webkit.WebView.HitTestResult;
 import android.webkit.WebViewClient;
+import android.webkit.WebViewProvider;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.HashMap;
@@ -49,6 +50,14 @@ public class ShadowWebViewTest {
     assertThat(shadowOf(webView).getLastLoadedUrl()).isEqualTo("http://example.com");
   }
 
+  @Test
+  public void testProvider() {
+    shadowOf(webView).ensureProviderCreated();
+    WebViewProvider provider = (WebViewProvider) webView.getWebViewProvider();
+    assertThat(provider.getScrollDelegate()).isNotNull();
+    assertThat(provider.getScale()).isInstanceOf(Float.class);
+  }
+
   @Test
   @Config(minSdk = O)
   public void shouldPerformPageLoadCallbacksOnLoadUrl() {
@@ -453,7 +462,6 @@ public class ShadowWebViewTest {
 
   @Test
   @SuppressWarnings("unchecked")
-  @Config(minSdk = 19)
   public void evaluateJavascript() {
     ValueCallback<String> callback = mock(ValueCallback.class);
     assertThat(shadowOf(webView).getLastEvaluatedJavascript()).isNull();
@@ -660,7 +668,6 @@ public class ShadowWebViewTest {
   }
 
   @Test
-  @Config(minSdk = 19)
   public void canSetWebContentsDebuggingEnabled() {
     WebView.setWebContentsDebuggingEnabled(false);
     WebView.setWebContentsDebuggingEnabled(true);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiAwareManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiAwareManagerTest.java
index bcd29984e..590b33204 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiAwareManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiAwareManagerTest.java
@@ -20,6 +20,7 @@ import android.os.Handler;
 import android.os.Looper;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import javax.annotation.Nonnull;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -73,8 +74,7 @@ public final class ShadowWifiAwareManagerTest {
   }
 
   @Test
-  public void attach_shouldNotAttachSessionIfSessionDetachedAndWifiAwareUnavailable()
-      throws Exception {
+  public void attach_shouldNotAttachSessionIfSessionDetachedAndWifiAwareUnavailable() {
     shadowOf(wifiAwareManager).setAvailable(false);
     shadowOf(wifiAwareManager).setSessionDetached(true);
     TestAttachCallback testAttachCallback = new TestAttachCallback();
@@ -188,12 +188,12 @@ public final class ShadowWifiAwareManagerTest {
     private boolean subscribeSuccess;
 
     @Override
-    public void onPublishStarted(PublishDiscoverySession publishDiscoverySession) {
+    public void onPublishStarted(@Nonnull PublishDiscoverySession publishDiscoverySession) {
       publishSuccess = true;
     }
 
     @Override
-    public void onSubscribeStarted(SubscribeDiscoverySession subscribeDiscoverySession) {
+    public void onSubscribeStarted(@Nonnull SubscribeDiscoverySession subscribeDiscoverySession) {
       subscribeSuccess = true;
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiManagerTest.java
index 7f453b634..9349d11aa 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiManagerTest.java
@@ -49,6 +49,7 @@ import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
+import javax.annotation.Nonnull;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -149,10 +150,10 @@ public class ShadowWifiManagerTest {
   @Test
   public void getIsScanAlwaysAvailable() {
     shadowOf(wifiManager).setIsScanAlwaysAvailable(true);
-    assertThat(wifiManager.isScanAlwaysAvailable()).isEqualTo(true);
+    assertThat(wifiManager.isScanAlwaysAvailable()).isTrue();
 
     shadowOf(wifiManager).setIsScanAlwaysAvailable(false);
-    assertThat(wifiManager.isScanAlwaysAvailable()).isEqualTo(false);
+    assertThat(wifiManager.isScanAlwaysAvailable()).isFalse();
   }
 
   @Test
@@ -230,7 +231,7 @@ public class ShadowWifiManagerTest {
 
     assertThat(wifiManager.updateNetwork(configuration)).isEqualTo(networkId);
     List<WifiConfiguration> configuredNetworks = wifiManager.getConfiguredNetworks();
-    assertThat(configuredNetworks.size()).isEqualTo(2);
+    assertThat(configuredNetworks).hasSize(2);
     assertThat(configuration.priority).isEqualTo(44);
     assertThat(configuredNetworks.get(1).priority).isEqualTo(44);
   }
@@ -260,12 +261,12 @@ public class ShadowWifiManagerTest {
     wifiManager.addNetwork(wifiConfiguration);
 
     List<WifiConfiguration> list = wifiManager.getConfiguredNetworks();
-    assertThat(list.size()).isEqualTo(1);
+    assertThat(list).hasSize(1);
 
     wifiManager.removeNetwork(0);
 
     list = wifiManager.getConfiguredNetworks();
-    assertThat(list.size()).isEqualTo(0);
+    assertThat(list).isEmpty();
   }
 
   @Test
@@ -356,16 +357,16 @@ public class ShadowWifiManagerTest {
     wifiManager.addNetwork(wifiConfiguration);
 
     List<WifiConfiguration> list = wifiManager.getPrivilegedConfiguredNetworks();
-    assertThat(list.size()).isEqualTo(1);
+    assertThat(list).hasSize(1);
 
     wifiManager.removeNetwork(0);
 
     list = wifiManager.getPrivilegedConfiguredNetworks();
-    assertThat(list.size()).isEqualTo(0);
+    assertThat(list).isEmpty();
   }
 
   @Test
-  public void updateNetwork_shouldRejectNullandNewConfigs() {
+  public void updateNetwork_shouldRejectNullAndNewConfigs() {
     WifiConfiguration config = new WifiConfiguration();
     config.networkId = -1;
     assertThat(wifiManager.updateNetwork(config)).isEqualTo(-1);
@@ -406,7 +407,7 @@ public class ShadowWifiManagerTest {
   }
 
   @Test
-  public void shouldAcquireAndReleaseWifilockRefCounted() {
+  public void shouldAcquireAndReleaseWifiLockRefCounted() {
     WifiManager.WifiLock lock = wifiManager.createWifiLock("TAG");
     lock.acquire();
     lock.acquire();
@@ -418,7 +419,7 @@ public class ShadowWifiManagerTest {
   }
 
   @Test
-  public void shouldAcquireAndReleaseWifilockNonRefCounted() {
+  public void shouldAcquireAndReleaseWifiLockNonRefCounted() {
     WifiManager.WifiLock lock = wifiManager.createWifiLock("TAG");
     lock.setReferenceCounted(false);
     lock.acquire();
@@ -430,7 +431,7 @@ public class ShadowWifiManagerTest {
   }
 
   @Test
-  public void shouldThrowRuntimeExceptionIfWifiLockisUnderlocked() {
+  public void shouldThrowRuntimeExceptionIfWifiLockIsUnderlocked() {
     WifiManager.WifiLock lock = wifiManager.createWifiLock("TAG");
     try {
       lock.release();
@@ -441,7 +442,7 @@ public class ShadowWifiManagerTest {
   }
 
   @Test
-  public void shouldThrowUnsupportedOperationIfWifiLockisOverlocked() {
+  public void shouldThrowUnsupportedOperationIfWifiLockIsOverlocked() {
     WifiManager.WifiLock lock = wifiManager.createWifiLock("TAG");
     try {
       for (int i = 0; i < ShadowWifiManager.ShadowWifiLock.MAX_ACTIVE_LOCKS; i++) {
@@ -483,18 +484,17 @@ public class ShadowWifiManagerTest {
   }
 
   @Test
-  public void shouldThrowRuntimeExceptionIfMulticastLockisUnderlocked() {
+  public void shouldThrowRuntimeExceptionIfMulticastLockIsUnderlocked() {
     MulticastLock lock = wifiManager.createMulticastLock("TAG");
     try {
       lock.release();
       fail("Expected exception");
     } catch (RuntimeException expected) {
     }
-    ;
   }
 
   @Test
-  public void shouldThrowUnsupportedOperationIfMulticastLockisOverlocked() {
+  public void shouldThrowUnsupportedOperationIfMulticastLockIsOverlocked() {
     MulticastLock lock = wifiManager.createMulticastLock("TAG");
     try {
       for (int i = 0; i < ShadowWifiManager.ShadowMulticastLock.MAX_ACTIVE_LOCKS; i++) {
@@ -1387,7 +1387,7 @@ public class ShadowWifiManagerTest {
     private final BlockingQueue<IncomingFailure> incomingFailures = new LinkedBlockingQueue<>();
 
     @Override
-    public void onConnectionFailed(WifiNetworkSpecifier wifiNetworkSpecifier, int i) {
+    public void onConnectionFailed(@Nonnull WifiNetworkSpecifier wifiNetworkSpecifier, int i) {
       incomingFailures.add(new IncomingFailure(wifiNetworkSpecifier, i));
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiP2pManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiP2pManagerTest.java
index a5314d724..76a2121ce 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiP2pManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiP2pManagerTest.java
@@ -16,6 +16,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.Objects;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,10 +34,11 @@ public class ShadowWifiP2pManagerTest {
   private ShadowWifiP2pManager shadowManager;
   @Mock private WifiP2pManager.ChannelListener mockListener;
   private WifiP2pManager.Channel channel;
+  private AutoCloseable mock;
 
   @Before
   public void setUp() {
-    MockitoAnnotations.initMocks(this);
+    mock = MockitoAnnotations.openMocks(this);
     context = ApplicationProvider.getApplicationContext();
     manager = (WifiP2pManager) context.getSystemService(Context.WIFI_P2P_SERVICE);
     shadowManager = shadowOf(manager);
@@ -44,6 +46,11 @@ public class ShadowWifiP2pManagerTest {
     assertThat(channel).isNotNull();
   }
 
+  @After
+  public void tearDown() throws Exception {
+    mock.close();
+  }
+
   @Test
   public void createGroup_success() {
     TestActionListener testListener = new TestActionListener();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiScannerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiScannerTest.java
index e4ddbff35..19ee3d32f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiScannerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiScannerTest.java
@@ -105,7 +105,7 @@ public class ShadowWifiScannerTest {
   }
 
   private static ImmutableList<ScanResult> createFakeScanResults() {
-    ScanResult scanResult = null;
+    ScanResult scanResult;
 
     if (Build.VERSION.SDK_INT >= VERSION_CODES.R) {
       // informationElements added in R
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalTest.java
index 97d7a8a4b..49c605505 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalTest.java
@@ -4,6 +4,7 @@ import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
+import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
@@ -23,7 +24,6 @@ import android.view.Display;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.View.DragShadowBuilder;
-import android.view.View.OnTouchListener;
 import android.view.ViewConfiguration;
 import android.view.Window;
 import android.view.WindowInsets;
@@ -192,12 +192,9 @@ public class ShadowWindowManagerGlobalTest {
       activity
           .findViewById(android.R.id.content)
           .setOnTouchListener(
-              new OnTouchListener() {
-                @Override
-                public boolean onTouch(View v, MotionEvent event) {
-                  touchEvents.add(event);
-                  return true;
-                }
+              (v, event) -> {
+                touchEvents.add(event);
+                return true;
               });
 
       ShadowWindowManagerGlobal.startPredictiveBackGesture(BackEvent.EDGE_LEFT).close();
@@ -337,7 +334,7 @@ public class ShadowWindowManagerGlobalTest {
         .isFalse();
   }
 
-  @Config(minSdk = R)
+  @Config(minSdk = S) // TODO(hoisie): investigate why this fails on R on GitHub CI.
   @Test
   public void windowInsetsController_toggleStatusBar() {
     ActivityController<WindowInsetsActivity> controller = buildActivity(WindowInsetsActivity.class);
@@ -349,8 +346,7 @@ public class ShadowWindowManagerGlobalTest {
     controller.get().getWindow().getInsetsController().show(WindowInsets.Type.statusBars());
     idleMainLooper();
 
-    assertThat(controller.get().windowInsets.isVisible(WindowInsets.Type.statusBars()))
-        .isEqualTo(true);
+    assertThat(controller.get().windowInsets.isVisible(WindowInsets.Type.statusBars())).isTrue();
   }
 
   @Config(minSdk = R)
@@ -367,8 +363,7 @@ public class ShadowWindowManagerGlobalTest {
     controller2.get().getWindow().getInsetsController().hide(WindowInsets.Type.statusBars());
     idleMainLooper();
 
-    assertThat(controller2.get().windowInsets.isVisible(WindowInsets.Type.statusBars()))
-        .isEqualTo(false);
+    assertThat(controller2.get().windowInsets.isVisible(WindowInsets.Type.statusBars())).isFalse();
   }
 
   public static final class WindowInsetsActivity extends Activity {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowTest.java
index 93a679ef5..74682e3a9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowTest.java
@@ -58,7 +58,7 @@ public class ShadowWindowTest {
 
   @Test
   @Config(minSdk = Q)
-  public void getSystemFlag_shouldReturnFlagsSetViaAddSystemFlags() throws Exception {
+  public void getSystemFlag_shouldReturnFlagsSetViaAddSystemFlags() {
     Activity activity = Robolectric.buildActivity(Activity.class).create().get();
     Window window = activity.getWindow();
     int fakeSystemFlag1 = 0b1;
@@ -70,7 +70,7 @@ public class ShadowWindowTest {
 
   @Test
   @Config(minSdk = Q)
-  public void getSystemFlag_callingAddSystemFlagsShouldNotOverrideExistingFlags() throws Exception {
+  public void getSystemFlag_callingAddSystemFlagsShouldNotOverrideExistingFlags() {
     Activity activity = Robolectric.buildActivity(Activity.class).create().get();
     Window window = activity.getWindow();
     int fakeSystemFlag1 = 0b1;
@@ -84,7 +84,7 @@ public class ShadowWindowTest {
 
   @Test
   @Config(maxSdk = VERSION_CODES.R)
-  public void getSystemFlag_shouldReturnFlagsSetViaAddPrivateFlags() throws Exception {
+  public void getSystemFlag_shouldReturnFlagsSetViaAddPrivateFlags() {
     Activity activity = Robolectric.buildActivity(Activity.class).create().get();
     Window window = activity.getWindow();
     int fakeSystemFlag1 = 0b1;
@@ -96,8 +96,7 @@ public class ShadowWindowTest {
 
   @Test
   @Config(maxSdk = VERSION_CODES.R)
-  public void getSystemFlag_callingAddPrivateFlagsShouldNotOverrideExistingFlags()
-      throws Exception {
+  public void getSystemFlag_callingAddPrivateFlagsShouldNotOverrideExistingFlags() {
     Activity activity = Robolectric.buildActivity(Activity.class).create().get();
     Window window = activity.getWindow();
     int fakeSystemFlag1 = 0b1;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/SignalStrengthBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/SignalStrengthBuilderTest.java
new file mode 100644
index 000000000..825a39367
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/SignalStrengthBuilderTest.java
@@ -0,0 +1,65 @@
+package org.robolectric.shadows;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Build;
+import android.telephony.CellSignalStrength;
+import android.telephony.CellSignalStrengthGsm;
+import android.telephony.CellSignalStrengthLte;
+import android.telephony.CellSignalStrengthNr;
+import android.telephony.CellSignalStrengthWcdma;
+import android.telephony.SignalStrength;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.common.collect.ImmutableList;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+/** Test for {@link SignalStrengthBuilder} */
+@RunWith(AndroidJUnit4.class)
+@Config(minSdk = Build.VERSION_CODES.ECLAIR_MR1)
+public class SignalStrengthBuilderTest {
+
+  @Test
+  @Config(maxSdk = Build.VERSION_CODES.P)
+  public void build_noArguments_toSdkP() {
+    SignalStrength signalStrength = SignalStrengthBuilder.newBuilder().build();
+
+    assertThat(signalStrength.getCdmaDbm()).isEqualTo(-1);
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.Q)
+  public void build_noArguments_fromSdkQ() {
+    SignalStrength signalStrength = SignalStrengthBuilder.newBuilder().build();
+
+    assertThat(signalStrength.getCdmaDbm()).isEqualTo(SignalStrength.INVALID);
+  }
+
+  @Test
+  @Config(sdk = {Build.VERSION_CODES.Q, Config.NEWEST_SDK})
+  public void build_setCellSignalStrengths() {
+    CellSignalStrengthGsm cellSignalStrengthGsm =
+        CellSignalStrengthGsmBuilder.newBuilder().setRssi(-100).build();
+    CellSignalStrengthWcdma cellSignalStrengthWcdma =
+        CellSignalStrengthWcdmaBuilder.newBuilder().setRssi(-100).build();
+    CellSignalStrengthLte cellSignalStrengthLte =
+        CellSignalStrengthLteBuilder.newBuilder().setRsrp(-100).build();
+    CellSignalStrengthNr cellSignalStrengthNr =
+        CellSignalStrengthNrBuilder.newBuilder().setSsRsrp(-100).build();
+    ImmutableList<CellSignalStrength> cellSignalStrengths =
+        ImmutableList.of(
+            cellSignalStrengthGsm,
+            cellSignalStrengthWcdma,
+            cellSignalStrengthLte,
+            cellSignalStrengthNr);
+
+    // CellSignalStrengthCdma & CellSignalStrengthTdscdma will use the default instance which will
+    // be considered invalid and thus won't be returned by the method.
+    SignalStrength signalStrength =
+        SignalStrengthBuilder.newBuilder().setCellSignalStrengths(cellSignalStrengths).build();
+
+    assertThat(signalStrength.getCellSignalStrengths())
+        .containsExactlyElementsIn(cellSignalStrengths);
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/UiccSlotInfoBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/UiccSlotInfoBuilderTest.java
index 16aca808e..308be3d22 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/UiccSlotInfoBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/UiccSlotInfoBuilderTest.java
@@ -9,6 +9,7 @@ import static com.google.common.truth.Truth.assertThat;
 import android.telephony.UiccPortInfo;
 import android.telephony.UiccSlotInfo;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.util.Optional;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RuntimeEnvironment;
@@ -32,10 +33,10 @@ public class UiccSlotInfoBuilderTest {
     assertThat(slotInfo).isNotNull();
     assertThat(slotInfo.getCardId()).isEqualTo("cardId");
     assertThat(slotInfo.getIsEuicc()).isTrue();
-    assertThat(slotInfo.getIsExtendedApduSupported()).isEqualTo(true);
+    assertThat(slotInfo.getIsExtendedApduSupported()).isTrue();
     assertThat(slotInfo.getCardStateInfo()).isEqualTo(CARD_STATE_INFO_PRESENT);
     if (RuntimeEnvironment.getApiLevel() >= Q) {
-      assertThat(slotInfo.isRemovable()).isEqualTo(true);
+      assertThat(slotInfo.isRemovable()).isTrue();
     }
   }
 
@@ -54,13 +55,15 @@ public class UiccSlotInfoBuilderTest {
     assertThat(slotInfo).isNotNull();
     assertThat(slotInfo.getCardId()).isEqualTo("cardId");
     assertThat(slotInfo.getIsEuicc()).isTrue();
-    assertThat(slotInfo.getIsExtendedApduSupported()).isEqualTo(true);
+    assertThat(slotInfo.getIsExtendedApduSupported()).isTrue();
     assertThat(slotInfo.getCardStateInfo()).isEqualTo(CARD_STATE_INFO_PRESENT);
     assertThat(slotInfo.getPorts()).hasSize(1);
-    UiccPortInfo portInfo = slotInfo.getPorts().stream().findFirst().get();
+    Optional<UiccPortInfo> portInfoOptional = slotInfo.getPorts().stream().findFirst();
+    assertThat(portInfoOptional).isPresent();
+    UiccPortInfo portInfo = portInfoOptional.get();
     assertThat(portInfo.getIccId()).isEqualTo("iccId");
     assertThat(portInfo.getPortIndex()).isEqualTo(1);
     assertThat(portInfo.getLogicalSlotIndex()).isEqualTo(1);
-    assertThat(portInfo.isActive()).isEqualTo(true);
+    assertThat(portInfo.isActive()).isTrue();
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ViewAnimationTest.java b/robolectric/src/test/java/org/robolectric/shadows/ViewAnimationTest.java
new file mode 100644
index 000000000..96fb9c578
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ViewAnimationTest.java
@@ -0,0 +1,76 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.O;
+import static com.google.common.truth.Truth.assertThat;
+import static org.robolectric.Shadows.shadowOf;
+
+import android.app.Activity;
+import android.app.UiAutomation;
+import android.graphics.Bitmap;
+import android.os.Looper;
+import android.os.SystemClock;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.animation.Transformation;
+import android.view.animation.TranslateAnimation;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.platform.app.InstrumentationRegistry;
+import java.time.Instant;
+import java.util.concurrent.TimeUnit;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
+
+@RunWith(AndroidJUnit4.class)
+@Config(minSdk = O)
+@GraphicsMode(Mode.NATIVE)
+public class ViewAnimationTest {
+  @Test
+  public void viewAnimations_interpolateWhenDrawIsCalled() {
+    try {
+      ShadowView.setUseRealViewAnimations(true);
+      Activity activity = Robolectric.setupActivity(Activity.class);
+      View view = new View(activity);
+      ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(100, 100);
+      view.setLayoutParams(params);
+      ((ViewGroup) activity.findViewById(android.R.id.content)).addView(view);
+
+      shadowOf(Looper.getMainLooper()).runToEndOfTasks();
+
+      long startTime = SystemClock.uptimeMillis();
+
+      final TestTranslateAnimation animation = new TestTranslateAnimation(0, 100, 0, 0);
+      animation.setDuration(1000);
+      view.startAnimation(animation);
+
+      shadowOf(Looper.getMainLooper()).idleFor(500, TimeUnit.MILLISECONDS);
+      UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+      Bitmap bitmap = uiAutomation.takeScreenshot();
+      assertThat(bitmap).isNotNull();
+      assertThat(animation.lastAnimationTime.toEpochMilli()).isEqualTo(startTime + 500);
+    } finally {
+      ShadowView.setUseRealViewAnimations(false);
+    }
+  }
+
+  public static class TestTranslateAnimation extends TranslateAnimation {
+
+    public Instant lastAnimationTime;
+
+    public TestTranslateAnimation(
+        float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) {
+      super(fromXDelta, toXDelta, fromYDelta, toYDelta);
+    }
+
+    @Override
+    public boolean getTransformation(
+        long currentTime, Transformation outTransformation, float scale) {
+      boolean result = super.getTransformation(currentTime, outTransformation, scale);
+      lastAnimationTime = Instant.ofEpochMilli(currentTime);
+      return result;
+    }
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/testing/OnMethodTestActivity.java b/robolectric/src/test/java/org/robolectric/shadows/testing/OnMethodTestActivity.java
index 56704d1e8..5a5c5a79f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/testing/OnMethodTestActivity.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/testing/OnMethodTestActivity.java
@@ -4,6 +4,7 @@ import android.app.Activity;
 import android.content.Intent;
 import android.os.Bundle;
 import java.util.List;
+import javax.annotation.Nonnull;
 
 public class OnMethodTestActivity extends Activity {
   private final List<String> transcript;
@@ -23,7 +24,7 @@ public class OnMethodTestActivity extends Activity {
   }
 
   @Override
-  protected void onRestoreInstanceState(Bundle savedInstanceState) {
+  protected void onRestoreInstanceState(@Nonnull Bundle savedInstanceState) {
     transcript.add("onRestoreInstanceState was called");
   }
 
@@ -53,7 +54,7 @@ public class OnMethodTestActivity extends Activity {
   }
 
   @Override
-  protected void onSaveInstanceState(Bundle outState) {
+  protected void onSaveInstanceState(@Nonnull Bundle outState) {
     transcript.add("onSaveInstanceState was called");
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/testing/TestAccessibilityService.java b/robolectric/src/test/java/org/robolectric/shadows/testing/TestAccessibilityService.java
new file mode 100644
index 000000000..159fdaa82
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/testing/TestAccessibilityService.java
@@ -0,0 +1,17 @@
+package org.robolectric.shadows.testing;
+
+import android.accessibilityservice.AccessibilityService;
+import android.view.accessibility.AccessibilityEvent;
+
+/** An accessibility service that does nothing */
+public class TestAccessibilityService extends AccessibilityService {
+  @Override
+  public void onAccessibilityEvent(AccessibilityEvent arg0) {
+    // Do nothing
+  }
+
+  @Override
+  public void onInterrupt() {
+    // Do nothing
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider1.java b/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider1.java
index 9f5013d5e..f024c31db 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider1.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider1.java
@@ -6,6 +6,7 @@ import android.database.Cursor;
 import android.net.Uri;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nonnull;
 
 public class TestContentProvider1 extends ContentProvider {
 
@@ -25,28 +26,33 @@ public class TestContentProvider1 extends ContentProvider {
 
   @Override
   public Cursor query(
-      Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
+      @Nonnull Uri uri,
+      String[] projection,
+      String selection,
+      String[] selectionArgs,
+      String sortOrder) {
     transcript.add("query for " + uri);
     return null;
   }
 
   @Override
-  public String getType(Uri uri) {
+  public String getType(@Nonnull Uri uri) {
     return null;
   }
 
   @Override
-  public Uri insert(Uri uri, ContentValues values) {
+  public Uri insert(@Nonnull Uri uri, ContentValues values) {
     return null;
   }
 
   @Override
-  public int delete(Uri uri, String selection, String[] selectionArgs) {
+  public int delete(@Nonnull Uri uri, String selection, String[] selectionArgs) {
     return 0;
   }
 
   @Override
-  public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+  public int update(
+      @Nonnull Uri uri, ContentValues values, String selection, String[] selectionArgs) {
     return 0;
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider2.java b/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider2.java
index fb4ae20eb..395351255 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider2.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider2.java
@@ -4,21 +4,22 @@ import android.content.ContentProvider;
 import android.content.ContentValues;
 import android.database.Cursor;
 import android.net.Uri;
+import javax.annotation.Nonnull;
 
 public class TestContentProvider2 extends ContentProvider {
 
   @Override
-  public int delete(Uri arg0, String arg1, String[] arg2) {
+  public int delete(@Nonnull Uri arg0, String arg1, String[] arg2) {
     return 0;
   }
 
   @Override
-  public String getType(Uri arg0) {
+  public String getType(@Nonnull Uri arg0) {
     return null;
   }
 
   @Override
-  public Uri insert(Uri arg0, ContentValues arg1) {
+  public Uri insert(@Nonnull Uri arg0, ContentValues arg1) {
     return null;
   }
 
@@ -28,12 +29,12 @@ public class TestContentProvider2 extends ContentProvider {
   }
 
   @Override
-  public Cursor query(Uri arg0, String[] arg1, String arg2, String[] arg3, String arg4) {
+  public Cursor query(@Nonnull Uri arg0, String[] arg1, String arg2, String[] arg3, String arg4) {
     return null;
   }
 
   @Override
-  public int update(Uri arg0, ContentValues arg1, String arg2, String[] arg3) {
+  public int update(@Nonnull Uri arg0, ContentValues arg1, String arg2, String[] arg3) {
     return 0;
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider3And4.java b/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider3And4.java
index f9c6666d0..57ef227bd 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider3And4.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider3And4.java
@@ -6,6 +6,7 @@ import android.database.Cursor;
 import android.net.Uri;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nonnull;
 
 /** Test class for a ContentProvider with multiple authorities */
 public class TestContentProvider3And4 extends ContentProvider {
@@ -26,28 +27,33 @@ public class TestContentProvider3And4 extends ContentProvider {
 
   @Override
   public Cursor query(
-      Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
+      @Nonnull Uri uri,
+      String[] projection,
+      String selection,
+      String[] selectionArgs,
+      String sortOrder) {
     transcript.add("query for " + uri);
     return null;
   }
 
   @Override
-  public String getType(Uri uri) {
+  public String getType(@Nonnull Uri uri) {
     return null;
   }
 
   @Override
-  public Uri insert(Uri uri, ContentValues values) {
+  public Uri insert(@Nonnull Uri uri, ContentValues values) {
     return null;
   }
 
   @Override
-  public int delete(Uri uri, String selection, String[] selectionArgs) {
+  public int delete(@Nonnull Uri uri, String selection, String[] selectionArgs) {
     return 0;
   }
 
   @Override
-  public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+  public int update(
+      @Nonnull Uri uri, ContentValues values, String selection, String[] selectionArgs) {
     return 0;
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/util/TestUtil.java b/robolectric/src/test/java/org/robolectric/util/TestUtil.java
index 7fdc0618b..ca3ba58c6 100644
--- a/robolectric/src/test/java/org/robolectric/util/TestUtil.java
+++ b/robolectric/src/test/java/org/robolectric/util/TestUtil.java
@@ -1,10 +1,6 @@
 package org.robolectric.util;
 
-import com.google.common.io.CharStreams;
 import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.nio.file.Path;
 import java.util.Properties;
 import org.robolectric.R;
@@ -57,31 +53,10 @@ public abstract class TestUtil {
     return SYSTEM_RESOURCE_PATH;
   }
 
-  public static ResourcePath sdkResources(int apiLevel) {
-    Path path = getSdkCollection().getSdk(apiLevel).getJarPath();
-    return new ResourcePath(null, path.resolve("raw-res/res"), null, null);
-  }
-
-  public static String readString(InputStream is) throws IOException {
-    return CharStreams.toString(new InputStreamReader(is, "UTF-8"));
-  }
-
   public static synchronized SdkCollection getSdkCollection() {
     if (sdkCollection == null) {
-      sdkCollection = getInjectedInstance(SdkCollection.class);
+      sdkCollection = injector.getInstance(SdkCollection.class);
     }
     return sdkCollection;
   }
-
-  public static void resetSystemProperty(String name, String value) {
-    if (value == null) {
-      System.clearProperty(name);
-    } else {
-      System.setProperty(name, value);
-    }
-  }
-
-  private static <T> T getInjectedInstance(Class<T> clazz) {
-    return injector.getInstance(clazz);
-  }
 }
diff --git a/robolectric/src/test/resources/TestAndroidManifestWithTargetSdk34.xml b/robolectric/src/test/resources/TestAndroidManifestWithTargetSdk34.xml
new file mode 100644
index 000000000..9cf9553cc
--- /dev/null
+++ b/robolectric/src/test/resources/TestAndroidManifestWithTargetSdk34.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="org.robolectric"
+    android:versionCode="123"
+    android:versionName="aVersionName">
+  <uses-sdk android:targetSdkVersion="34"/>
+
+  <application android:name="org.robolectric.shadows.testing.TestApplication"
+         android:theme="@style/Theme.Robolectric"
+         android:label="@string/app_name">
+  </application>
+</manifest>
diff --git a/robolectric/src/test/resources/res/xml/attr_set.xml b/robolectric/src/test/resources/res/xml/attr_set.xml
new file mode 100644
index 000000000..ed9b07cad
--- /dev/null
+++ b/robolectric/src/test/resources/res/xml/attr_set.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<attrs xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:app="http://schemas.android.com/apk/res-auto"
+  android:text="@android:string/ok"
+  app:title="my title" >
+</attrs>
\ No newline at end of file
diff --git a/robolectric/src/test/resources/res/xml/empty.xml b/robolectric/src/test/resources/res/xml/empty.xml
new file mode 100644
index 000000000..573de5007
--- /dev/null
+++ b/robolectric/src/test/resources/res/xml/empty.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<whatever/>
\ No newline at end of file
diff --git a/robolectric/src/test/resources/resources.ap_ b/robolectric/src/test/resources/resources.ap_
index 11170d3fe..8f4952e3a 100644
Binary files a/robolectric/src/test/resources/resources.ap_ and b/robolectric/src/test/resources/resources.ap_ differ
diff --git a/sandbox/build.gradle.kts b/sandbox/build.gradle.kts
index 50dc26fb5..b52d36871 100644
--- a/sandbox/build.gradle.kts
+++ b/sandbox/build.gradle.kts
@@ -20,8 +20,15 @@ dependencies {
   api(libs.guava)
   compileOnly(libs.findbugs.jsr305)
 
+  testImplementation(libs.findbugs.jsr305)
   testImplementation(libs.junit4)
   testImplementation(libs.truth)
-  testImplementation(libs.mockito)
+
+  // ShadowingTest.testStaticMethodsAreDelegated fails with a combination of Mockito 5.x and the
+  // sandbox grouping commit (234dc80c2df61c15504c288cd62acdec8e3dca5c).
+  //
+  // TODO(hoisie): figure out why this is happening and upgrade to Mockito 5.x.
+  testImplementation("org.mockito:mockito-core:4.11.0")
+
   testImplementation(project(":junit"))
 }
diff --git a/sandbox/src/main/java/org/robolectric/interceptors/AndroidInterceptors.java b/sandbox/src/main/java/org/robolectric/interceptors/AndroidInterceptors.java
index e75beb577..552cf6c65 100644
--- a/sandbox/src/main/java/org/robolectric/interceptors/AndroidInterceptors.java
+++ b/sandbox/src/main/java/org/robolectric/interceptors/AndroidInterceptors.java
@@ -135,16 +135,13 @@ public class AndroidInterceptors {
 
     @Override
     public Function<Object, Object> handle(MethodSignature methodSignature) {
-      return new Function<Object, Object>() {
-        @Override
-        public Object call(Class<?> theClass, Object value, Object[] params) {
-          if ("release$".equals(methodSignature.methodName)) {
-            return release((FileDescriptor) value);
-          } else if ("getInt$".equals(methodSignature.methodName)) {
-            return getInt((FileDescriptor) value);
-          } else {
-            return setInt((FileDescriptor) value, (int) params[0]);
-          }
+      return (theClass, value, params) -> {
+        if ("release$".equals(methodSignature.methodName)) {
+          return release((FileDescriptor) value);
+        } else if ("getInt$".equals(methodSignature.methodName)) {
+          return getInt((FileDescriptor) value);
+        } else {
+          return setInt((FileDescriptor) value, (int) params[0]);
         }
       };
     }
@@ -171,18 +168,13 @@ public class AndroidInterceptors {
     }
 
     @Nullable
-    static Object eldest(LinkedHashMap map) {
+    static Object eldest(LinkedHashMap<?, ?> map) {
       return map.isEmpty() ? null : map.entrySet().iterator().next();
     }
 
     @Override
     public Function<Object, Object> handle(MethodSignature methodSignature) {
-      return new Function<Object, Object>() {
-        @Override
-        public Object call(Class<?> theClass, Object value, Object[] params) {
-          return eldest((LinkedHashMap) value);
-        }
-      };
+      return (theClass, value, params) -> eldest((LinkedHashMap<?, ?>) value);
     }
 
     @Override
@@ -201,16 +193,13 @@ public class AndroidInterceptors {
 
     @Override
     public Function<Object, Object> handle(final MethodSignature methodSignature) {
-      return new Function<Object, Object>() {
-        @Override
-        public Object call(Class<?> theClass, Object value, Object[] params) {
-          ClassLoader cl = theClass.getClassLoader();
-          try {
-            Class<?> shadowSystemClass = cl.loadClass("org.robolectric.shadows.ShadowSystem");
-            return callStaticMethod(shadowSystemClass, methodSignature.methodName);
-          } catch (ClassNotFoundException e) {
-            throw new RuntimeException(e);
-          }
+      return (theClass, value, params) -> {
+        ClassLoader cl = theClass.getClassLoader();
+        try {
+          Class<?> shadowSystemClass = cl.loadClass("org.robolectric.shadows.ShadowSystem");
+          return callStaticMethod(shadowSystemClass, methodSignature.methodName);
+        } catch (ClassNotFoundException e) {
+          throw new RuntimeException(e);
         }
       };
     }
@@ -242,14 +231,11 @@ public class AndroidInterceptors {
 
     @Override
     public Function<Object, Object> handle(MethodSignature methodSignature) {
-      return new Function<Object, Object>() {
-        @Override
-        public Object call(Class<?> theClass, Object value, Object[] params) {
-          //noinspection SuspiciousSystemArraycopy
-          System.arraycopy(
-              params[0], (Integer) params[1], params[2], (Integer) params[3], (Integer) params[4]);
-          return null;
-        }
+      return (theClass, value, params) -> {
+        //noinspection SuspiciousSystemArraycopy
+        System.arraycopy(
+            params[0], (Integer) params[1], params[2], (Integer) params[3], (Integer) params[4]);
+        return null;
       };
     }
 
@@ -285,12 +271,7 @@ public class AndroidInterceptors {
 
     @Override
     public Function<Object, Object> handle(MethodSignature methodSignature) {
-      return new Function<Object, Object>() {
-        @Override
-        public Object call(Class<?> theClass, Object value, Object[] params) {
-          return adjustLanguageCode((String) params[0]);
-        }
-      };
+      return (theClass, value, params) -> adjustLanguageCode((String) params[0]);
     }
 
     @Override
@@ -428,8 +409,7 @@ public class AndroidInterceptors {
     }
 
     @Override
-    public MethodHandle getMethodHandle(String methodName, MethodType type)
-        throws NoSuchMethodException, IllegalAccessException {
+    public MethodHandle getMethodHandle(String methodName, MethodType type) {
       MethodHandle nothing = constant(Void.class, null).asType(methodType(void.class));
 
       if (type.parameterCount() != 0) {
@@ -453,12 +433,7 @@ public class AndroidInterceptors {
 
     @Override
     public Function<Object, Object> handle(MethodSignature methodSignature) {
-      return new Function<Object, Object>() {
-        @Override
-        public Object call(Class<?> theClass, Object value, Object[] params) {
-          return getFileDescriptor((Socket) value);
-        }
-      };
+      return (theClass, value, params) -> getFileDescriptor((Socket) value);
     }
 
     @Override
@@ -480,13 +455,13 @@ public class AndroidInterceptors {
           new MethodRef(PhantomReference.class.getName(), METHOD));
     }
 
-    static boolean refersTo(Reference ref, Object obj) {
+    static boolean refersTo(Reference<?> ref, Object obj) {
       return ref.get() == obj;
     }
 
     @Override
     public Function<Object, Object> handle(MethodSignature methodSignature) {
-      return (theClass, value, params) -> refersTo((Reference) value, params[0]);
+      return (theClass, value, params) -> refersTo((Reference<?>) value, params[0]);
     }
 
     @Override
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassHandler.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassHandler.java
index 125441c3d..e699f774c 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassHandler.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassHandler.java
@@ -18,7 +18,7 @@ public interface ClassHandler {
    *
    * @param clazz the class being loaded
    */
-  void classInitializing(Class clazz);
+  void classInitializing(Class<?> clazz);
 
   /**
    * Called by Robolectric to determine how to create and initialize a shadow object when a new
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java
index 9f4178bbb..71270e88d 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java
@@ -275,7 +275,7 @@ public class ClassInstrumentor {
 
   /**
    * Adds a call $$robo$init, which instantiates a shadow object if required. This is to support
-   * custom shadows for Jacoco-instrumented classes (except cnstructor shadows).
+   * custom shadows for Jacoco-instrumented classes (except constructor shadows).
    */
   protected void addCallToRoboInit(MutableClass mutableClass, MethodNode ctor) {
     AbstractInsnNode returnNode =
@@ -618,7 +618,7 @@ public class ClassInstrumentor {
 
   protected String[] exceptionArray(MethodNode method) {
     List<String> exceptions = method.exceptions;
-    return exceptions.toArray(new String[exceptions.size()]);
+    return exceptions.toArray(new String[0]);
   }
 
   /** Filters methods that might need special treatment because of various reasons */
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java
index 59597001f..f6741c157 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java
@@ -69,7 +69,7 @@ public class InstrumentationConfiguration {
       Collection<String> instrumentedPackages,
       Collection<String> instrumentedClasses,
       Collection<String> classesToNotAcquire,
-      Collection<String> packagesToNotAquire,
+      Collection<String> packagesToNotAcquire,
       Collection<String> classesToNotInstrument,
       Collection<String> packagesToNotInstrument,
       String classesToNotInstrumentRegex) {
@@ -78,7 +78,7 @@ public class InstrumentationConfiguration {
     this.instrumentedPackages = ImmutableList.copyOf(instrumentedPackages);
     this.instrumentedClasses = ImmutableSet.copyOf(instrumentedClasses);
     this.classesToNotAcquire = ImmutableSet.copyOf(classesToNotAcquire);
-    this.packagesToNotAcquire = ImmutableSet.copyOf(packagesToNotAquire);
+    this.packagesToNotAcquire = ImmutableSet.copyOf(packagesToNotAcquire);
     this.classesToNotInstrument = ImmutableSet.copyOf(classesToNotInstrument);
     this.packagesToNotInstrument = ImmutableSet.copyOf(packagesToNotInstrument);
     this.classesToNotInstrumentRegex = classesToNotInstrumentRegex;
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/Interceptor.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/Interceptor.java
index 62deab45a..cfbb6a2d7 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/Interceptor.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/Interceptor.java
@@ -7,7 +7,7 @@ import org.robolectric.util.Function;
 import org.robolectric.util.ReflectionHelpers;
 
 public abstract class Interceptor {
-  private MethodRef[] methodRefs;
+  private final MethodRef[] methodRefs;
 
   public Interceptor(MethodRef... methodRefs) {
     this.methodRefs = methodRefs;
@@ -25,11 +25,7 @@ public abstract class Interceptor {
   @Nonnull
   protected static Function<Object, Object> returnDefaultValue(
       final MethodSignature methodSignature) {
-    return new Function<Object, Object>() {
-      @Override
-      public Object call(Class<?> theClass, Object value, Object[] params) {
-        return ReflectionHelpers.defaultValueForType(methodSignature.returnType);
-      }
-    };
+    return (theClass, value, params) ->
+        ReflectionHelpers.defaultValueForType(methodSignature.returnType);
   }
 }
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/InvokeDynamicClassInstrumentor.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/InvokeDynamicClassInstrumentor.java
deleted file mode 100644
index 1eb5e4a88..000000000
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/InvokeDynamicClassInstrumentor.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.robolectric.internal.bytecode;
-
-/**
- * @deprecated The invoke-dynamic case has been moved to ClassInstrumentor. Classes previously
- *     extending this class should extend {@link ClassInstrumentor} directly.
- */
-@Deprecated
-public class InvokeDynamicClassInstrumentor extends ClassInstrumentor {
-  public InvokeDynamicClassInstrumentor(Decorator decorator) {
-    super(decorator);
-  }
-}
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/InvokeDynamicSupport.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/InvokeDynamicSupport.java
index fa53caec0..c95a40b4e 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/InvokeDynamicSupport.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/InvokeDynamicSupport.java
@@ -133,8 +133,7 @@ public class InvokeDynamicSupport {
 
   @SuppressWarnings("UnusedDeclaration")
   public static CallSite bootstrapIntrinsic(
-      MethodHandles.Lookup caller, String name, MethodType type, String callee)
-      throws IllegalAccessException {
+      MethodHandles.Lookup caller, String name, MethodType type, String callee) {
     return PerfStatsCollector.getInstance()
         .measure(
             "invokedynamic bootstrap intrinsic",
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/RoboType.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/RoboType.java
index d966b2582..806e61f09 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/RoboType.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/RoboType.java
@@ -12,13 +12,13 @@ enum RoboType {
   DOUBLE(Double.TYPE),
   OBJECT(null);
 
-  RoboType(Class type) {
+  RoboType(Class<?> type) {
     this.type = type;
   }
 
-  private final Class type;
+  private final Class<?> type;
 
-  public static Class findPrimitiveClass(String name) {
+  public static Class<?> findPrimitiveClass(String name) {
     for (RoboType type : RoboType.values()) {
       if (type.type != null && type.type.getName().equals(name)) {
         return type.type;
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/RobolectricInternals.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/RobolectricInternals.java
index e5eda6af1..2be0647be 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/RobolectricInternals.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/RobolectricInternals.java
@@ -17,7 +17,7 @@ public class RobolectricInternals {
   private static ClassLoader classLoader;
 
   @SuppressWarnings("UnusedDeclaration")
-  public static void classInitializing(Class clazz) throws Exception {
+  public static void classInitializing(Class<?> clazz) {
     classHandler.classInitializing(clazz);
   }
 
@@ -36,8 +36,8 @@ public class RobolectricInternals {
     return classHandler.stripStackTrace(exception);
   }
 
-  public static Object intercept(String signature, Object instance, Object[] params, Class theClass)
-      throws Throwable {
+  public static Object intercept(
+      String signature, Object instance, Object[] params, Class<?> theClass) throws Throwable {
     try {
       return classHandler.intercept(signature, instance, params, theClass);
     } catch (java.lang.LinkageError e) {
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java
index 7f359d0b0..425b43a83 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java
@@ -10,6 +10,8 @@ import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.URLClassLoader;
 import java.nio.file.Files;
@@ -95,9 +97,9 @@ public class SandboxClassLoader extends URLClassLoader {
         try {
           urls.add(new File(entry).toURI().toURL());
         } catch (SecurityException e) { // File.toURI checks to see if the file is a directory
-          urls.add(new URL("file", null, new File(entry).getAbsolutePath()));
+          urls.add(new URI("file", null, new File(entry).getAbsolutePath()).toURL());
         }
-      } catch (MalformedURLException e) {
+      } catch (MalformedURLException | URISyntaxException e) {
         Logger.strict("malformed classpath entry: " + entry, e);
       }
     }
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowImpl.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowImpl.java
index 62c75635b..74f499533 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowImpl.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowImpl.java
@@ -40,32 +40,32 @@ public class ShadowImpl implements IShadow {
   }
 
   @Override
-  @SuppressWarnings(value = {"unchecked", "TypeParameterUnusedInFormals"})
+  @SuppressWarnings("TypeParameterUnusedInFormals")
   public <R, T> R directlyOn(
       T shadowedObject,
       Class<T> clazz,
       String methodName,
       ReflectionHelpers.ClassParameter<?>... paramValues) {
     String directMethodName = directMethodName(clazz.getName(), methodName);
-    return (R)
-        ReflectionHelpers.callInstanceMethod(clazz, shadowedObject, directMethodName, paramValues);
+    return ReflectionHelpers.callInstanceMethod(
+        clazz, shadowedObject, directMethodName, paramValues);
   }
 
   @Override
-  @SuppressWarnings(value = {"unchecked", "TypeParameterUnusedInFormals"})
+  @SuppressWarnings("TypeParameterUnusedInFormals")
   public <R, T> R directlyOn(
       Class<T> clazz, String methodName, ReflectionHelpers.ClassParameter<?>... paramValues) {
     String directMethodName = directMethodName(clazz.getName(), methodName);
-    return (R) ReflectionHelpers.callStaticMethod(clazz, directMethodName, paramValues);
+    return ReflectionHelpers.callStaticMethod(clazz, directMethodName, paramValues);
   }
 
   @Override
-  @SuppressWarnings(value = {"unchecked", "TypeParameterUnusedInFormals"})
+  @SuppressWarnings("TypeParameterUnusedInFormals")
   public <R> R invokeConstructor(
       Class<? extends R> clazz, R instance, ReflectionHelpers.ClassParameter<?>... paramValues) {
     String directMethodName =
         directMethodName(clazz.getName(), ShadowConstants.CONSTRUCTOR_METHOD_NAME);
-    return (R) ReflectionHelpers.callInstanceMethod(clazz, instance, directMethodName, paramValues);
+    return ReflectionHelpers.callInstanceMethod(clazz, instance, directMethodName, paramValues);
   }
 
   @Override
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowInvalidator.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowInvalidator.java
index a1a7343a1..2b82d9dd2 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowInvalidator.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowInvalidator.java
@@ -12,7 +12,7 @@ public class ShadowInvalidator {
     SwitchPoint.invalidateAll(new SwitchPoint[] {DUMMY});
   }
 
-  private Map<String, SwitchPoint> switchPoints;
+  private final Map<String, SwitchPoint> switchPoints;
 
   public ShadowInvalidator() {
     this.switchPoints = new HashMap<>();
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowMap.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowMap.java
index 54467f9cb..95d36e65c 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowMap.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowMap.java
@@ -183,17 +183,6 @@ public class ShadowMap {
     return invalidated.keySet();
   }
 
-  /**
-   * @deprecated do not use
-   */
-  @Deprecated
-  public static String convertToShadowName(String className) {
-    String shadowClassName =
-        "org.robolectric.shadows.Shadow" + className.substring(className.lastIndexOf(".") + 1);
-    shadowClassName = shadowClassName.replaceAll("\\$", "\\$Shadow");
-    return shadowClassName;
-  }
-
   public Builder newBuilder() {
     return new Builder(this);
   }
@@ -205,9 +194,7 @@ public class ShadowMap {
 
     ShadowMap shadowMap = (ShadowMap) o;
 
-    if (!overriddenShadows.equals(shadowMap.overriddenShadows)) return false;
-
-    return true;
+    return overriddenShadows.equals(shadowMap.overriddenShadows);
   }
 
   @Override
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowWrangler.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowWrangler.java
index 1ca60f529..aef5f2779 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowWrangler.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowWrangler.java
@@ -49,12 +49,7 @@ import org.robolectric.util.PerfStatsCollector;
 @Priority(Integer.MIN_VALUE)
 public class ShadowWrangler implements ClassHandler {
   public static final Function<Object, Object> DO_NOTHING_HANDLER =
-      new Function<Object, Object>() {
-        @Override
-        public Object call(Class<?> theClass, Object value, Object[] params) {
-          return null;
-        }
-      };
+      (theClass, value, params) -> null;
   public static final Method CALL_REAL_CODE = null;
   public static final MethodHandle DO_NOTHING =
       constant(Void.class, null).asType(methodType(void.class));
@@ -119,7 +114,7 @@ public class ShadowWrangler implements ClassHandler {
 
   @SuppressWarnings("ReferenceEquality")
   @Override
-  public void classInitializing(Class clazz) {
+  public void classInitializing(Class<?> clazz) {
     try {
       Method method =
           pickShadowMethod(clazz, ShadowConstants.STATIC_INITIALIZER_METHOD_NAME, NO_ARGS);
@@ -385,7 +380,7 @@ public class ShadowWrangler implements ClassHandler {
   }
 
   @Override
-  public Object intercept(String signature, Object instance, Object[] params, Class theClass)
+  public Object intercept(String signature, Object instance, Object[] params, Class<?> theClass)
       throws Throwable {
     final MethodSignature methodSignature = MethodSignature.parse(signature);
     return interceptors.getInterceptionHandler(methodSignature).call(theClass, instance, params);
@@ -436,7 +431,7 @@ public class ShadowWrangler implements ClassHandler {
         previousMethodName = methodName;
         previousFileName = fileName;
       }
-      throwable.setStackTrace(stackTrace.toArray(new StackTraceElement[stackTrace.size()]));
+      throwable.setStackTrace(stackTrace.toArray(new StackTraceElement[0]));
     }
     return throwable;
   }
diff --git a/sandbox/src/main/java/org/robolectric/util/JavaVersion.java b/sandbox/src/main/java/org/robolectric/util/JavaVersion.java
index 641368764..90c4d6594 100644
--- a/sandbox/src/main/java/org/robolectric/util/JavaVersion.java
+++ b/sandbox/src/main/java/org/robolectric/util/JavaVersion.java
@@ -9,7 +9,7 @@ public class JavaVersion implements Comparable<JavaVersion> {
 
   public JavaVersion(String version) {
     versions = new ArrayList<>();
-    Scanner s = new Scanner(version).useDelimiter("[^\\d]+");
+    Scanner s = new Scanner(version).useDelimiter("\\D+");
     while (s.hasNext()) {
       versions.add(s.nextInt());
     }
diff --git a/sandbox/src/test/java/org/robolectric/ClassicSuperHandlingTest.java b/sandbox/src/test/java/org/robolectric/ClassicSuperHandlingTest.java
index d0c85290c..9200716be 100644
--- a/sandbox/src/test/java/org/robolectric/ClassicSuperHandlingTest.java
+++ b/sandbox/src/test/java/org/robolectric/ClassicSuperHandlingTest.java
@@ -13,13 +13,13 @@ import org.robolectric.internal.bytecode.SandboxConfig;
 public class ClassicSuperHandlingTest {
   @Test
   @SandboxConfig(shadows = {ChildShadow.class, ParentShadow.class, GrandparentShadow.class})
-  public void uninstrumentedSubclassesShouldBeAbleToCallSuperWithoutLooping() throws Exception {
+  public void uninstrumentedSubclassesShouldBeAbleToCallSuperWithoutLooping() {
     assertEquals("4-3s-2s-1s-boof", new BabiesHavingBabies().method("boof"));
   }
 
   @Test
   @SandboxConfig(shadows = {ChildShadow.class, ParentShadow.class, GrandparentShadow.class})
-  public void shadowInvocationWhenAllAreShadowed() throws Exception {
+  public void shadowInvocationWhenAllAreShadowed() {
     assertEquals("3s-2s-1s-boof", new Child().method("boof"));
     assertEquals("2s-1s-boof", new Parent().method("boof"));
     assertEquals("1s-boof", new Grandparent().method("boof"));
diff --git a/sandbox/src/test/java/org/robolectric/RealApisTest.java b/sandbox/src/test/java/org/robolectric/RealApisTest.java
index 600a791d0..168362d4c 100644
--- a/sandbox/src/test/java/org/robolectric/RealApisTest.java
+++ b/sandbox/src/test/java/org/robolectric/RealApisTest.java
@@ -14,8 +14,7 @@ import org.robolectric.testing.Pony;
 public class RealApisTest {
   @Test
   @SandboxConfig(shadows = {ShimmeryShadowPony.class})
-  public void whenShadowHandlerIsInRealityBasedMode_shouldNotCallRealForUnshadowedMethod()
-      throws Exception {
+  public void whenShadowHandlerIsInRealityBasedMode_shouldNotCallRealForUnshadowedMethod() {
     assertEquals("Off I saunter to the salon!", new Pony().saunter("the salon"));
   }
 
@@ -24,7 +23,7 @@ public class RealApisTest {
 
   @Test
   @SandboxConfig(shadows = {ShadowOfClassWithSomeConstructors.class})
-  public void shouldCallOriginalConstructorBodySomehow() throws Exception {
+  public void shouldCallOriginalConstructorBodySomehow() {
     ClassWithSomeConstructors o = new ClassWithSomeConstructors("my name");
     assertEquals("my name", o.name);
   }
diff --git a/sandbox/src/test/java/org/robolectric/RobolectricInternalsTest.java b/sandbox/src/test/java/org/robolectric/RobolectricInternalsTest.java
index 0c74c8d45..399bc193a 100644
--- a/sandbox/src/test/java/org/robolectric/RobolectricInternalsTest.java
+++ b/sandbox/src/test/java/org/robolectric/RobolectricInternalsTest.java
@@ -172,7 +172,7 @@ public class RobolectricInternalsTest {
 
   @Instrument
   static class Outer {
-    public String outerParam = null;
+    public String outerParam;
 
     public Outer(String param) {
       this.outerParam = param;
diff --git a/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java b/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java
index c5e499318..69d62b442 100644
--- a/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java
+++ b/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java
@@ -139,7 +139,7 @@ public class ShadowWranglerIntegrationTest {
 
   @Instrument
   public static class ThrowInShadowMethod {
-    public void method() throws IOException {}
+    public void method() {}
   }
 
   @Implements(ThrowInShadowMethod.class)
@@ -278,11 +278,11 @@ public class ShadowWranglerIntegrationTest {
   }
 
   private ShadowFoo shadowOf(Foo foo) {
-    return (ShadowFoo) Shadow.extract(foo);
+    return Shadow.extract(foo);
   }
 
   private ShadowTextFoo shadowOf(TextFoo foo) {
-    return (ShadowTextFoo) Shadow.extract(foo);
+    return Shadow.extract(foo);
   }
 
   @Implements(Foo.class)
@@ -357,11 +357,11 @@ public class ShadowWranglerIntegrationTest {
   @Instrument
   public static class AClassWithGenericFunctionParam {
     public CharSequence aMethod(List<CharSequence> strs) {
-      String ret = "";
+      StringBuilder ret = new StringBuilder();
       for (CharSequence s : strs) {
-        ret = ret + s;
+        ret.append(s);
       }
-      return ret;
+      return ret.toString();
     }
   }
 
diff --git a/sandbox/src/test/java/org/robolectric/ShadowingTest.java b/sandbox/src/test/java/org/robolectric/ShadowingTest.java
index 5d6c5c84b..3c1c6ea91 100644
--- a/sandbox/src/test/java/org/robolectric/ShadowingTest.java
+++ b/sandbox/src/test/java/org/robolectric/ShadowingTest.java
@@ -27,7 +27,7 @@ public class ShadowingTest {
 
   @Test
   @SandboxConfig(shadows = {ShadowAccountManagerForTests.class})
-  public void testStaticMethodsAreDelegated() throws Exception {
+  public void testStaticMethodsAreDelegated() {
     Object arg = mock(Object.class);
     AccountManager.get(arg);
     assertThat(ShadowAccountManagerForTests.wasCalled).isTrue();
@@ -56,7 +56,7 @@ public class ShadowingTest {
 
   @Test
   @SandboxConfig(shadows = {ShadowClassWithProtectedMethod.class})
-  public void testProtectedMethodsAreDelegated() throws Exception {
+  public void testProtectedMethodsAreDelegated() {
     ClassWithProtectedMethod overlay = new ClassWithProtectedMethod();
     assertEquals("shadow name", overlay.getName());
   }
@@ -78,7 +78,7 @@ public class ShadowingTest {
 
   @Test
   @SandboxConfig(shadows = {ShadowPaintForTests.class})
-  public void testNativeMethodsAreDelegated() throws Exception {
+  public void testNativeMethodsAreDelegated() {
     Paint paint = new Paint();
     paint.setColor(1234);
 
@@ -130,7 +130,7 @@ public class ShadowingTest {
 
   @Test
   @SandboxConfig(shadows = {Pony.ShadowPony.class})
-  public void directlyOn_shouldCallThroughToOriginalMethodBody() throws Exception {
+  public void directlyOn_shouldCallThroughToOriginalMethodBody() {
     Pony pony = new Pony();
 
     assertEquals("Fake whinny! You're on my neck!", pony.ride("neck"));
@@ -143,7 +143,7 @@ public class ShadowingTest {
 
   @Test
   @SandboxConfig(shadows = {Pony.ShadowPony.class})
-  public void shouldCallRealForUnshadowedMethod() throws Exception {
+  public void shouldCallRealForUnshadowedMethod() {
     assertEquals("Off I saunter to the salon!", new Pony().saunter("the salon"));
   }
 
@@ -192,7 +192,7 @@ public class ShadowingTest {
 
   @Test
   @SandboxConfig(shadows = {ShadowApiImplementedClass.class})
-  public void withNonApiSubclassesWhichExtendApi_shouldStillBeInvoked() throws Exception {
+  public void withNonApiSubclassesWhichExtendApi_shouldStillBeInvoked() {
     assertEquals("did foo", new NonApiSubclass().doSomething("foo"));
   }
 
diff --git a/sandbox/src/test/java/org/robolectric/StaticInitializerTest.java b/sandbox/src/test/java/org/robolectric/StaticInitializerTest.java
index bedda49fa..c250a290d 100644
--- a/sandbox/src/test/java/org/robolectric/StaticInitializerTest.java
+++ b/sandbox/src/test/java/org/robolectric/StaticInitializerTest.java
@@ -2,6 +2,7 @@ package org.robolectric;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
 import org.junit.Test;
@@ -16,7 +17,7 @@ import org.robolectric.internal.bytecode.SandboxConfig;
 @RunWith(SandboxTestRunner.class)
 public class StaticInitializerTest {
   @Test
-  public void whenClassIsUnshadowed_shouldPerformStaticInitialization() throws Exception {
+  public void whenClassIsUnshadowed_shouldPerformStaticInitialization() {
     assertEquals("Floyd", ClassWithStaticInitializerA.name);
   }
 
@@ -48,7 +49,7 @@ public class StaticInitializerTest {
   public void whenClassHasShadowWithOverrideMethod_shouldDeferStaticInitialization()
       throws Exception {
     assertFalse(ShadowClassWithStaticInitializerOverride.initialized);
-    assertEquals(null, ClassWithStaticInitializerC.name);
+    assertNull(ClassWithStaticInitializerC.name);
     assertTrue(ShadowClassWithStaticInitializerOverride.initialized);
 
     RobolectricInternals.performStaticInitialization(ClassWithStaticInitializerC.class);
diff --git a/sandbox/src/test/java/org/robolectric/internal/bytecode/ClassInstrumentorTest.java b/sandbox/src/test/java/org/robolectric/internal/bytecode/ClassInstrumentorTest.java
index f0f0c22a9..0a6570606 100644
--- a/sandbox/src/test/java/org/robolectric/internal/bytecode/ClassInstrumentorTest.java
+++ b/sandbox/src/test/java/org/robolectric/internal/bytecode/ClassInstrumentorTest.java
@@ -73,7 +73,7 @@ public class ClassInstrumentorTest {
     // Side effect: original method has been made private.
     assertThat(methodNode.access & Opcodes.ACC_PRIVATE).isNotEqualTo(0);
     // Side effect: instructions have been rewritten to return 0.
-    assertThat(methodNode.instructions.size()).isEqualTo(2);
+    assertThat(methodNode.instructions).hasSize(2);
     assertThat(methodNode.instructions.get(0).getOpcode()).isEqualTo(Opcodes.ICONST_0);
     assertThat(methodNode.instructions.get(1).getOpcode()).isEqualTo(Opcodes.IRETURN);
   }
diff --git a/sandbox/src/test/java/org/robolectric/internal/bytecode/SandboxClassLoaderTest.java b/sandbox/src/test/java/org/robolectric/internal/bytecode/SandboxClassLoaderTest.java
index 0188f7bad..4b759e644 100644
--- a/sandbox/src/test/java/org/robolectric/internal/bytecode/SandboxClassLoaderTest.java
+++ b/sandbox/src/test/java/org/robolectric/internal/bytecode/SandboxClassLoaderTest.java
@@ -73,12 +73,12 @@ import org.robolectric.util.Util;
 public class SandboxClassLoaderTest {
 
   private ClassLoader classLoader;
-  private List<String> transcript = new ArrayList<>();
-  private MyClassHandler classHandler = new MyClassHandler(transcript);
+  private final List<String> transcript = new ArrayList<>();
+  private final MyClassHandler classHandler = new MyClassHandler(transcript);
   private ShadowImpl shadow;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     shadow = new ShadowImpl();
   }
 
@@ -121,9 +121,10 @@ public class SandboxClassLoaderTest {
     InstrumentationConfiguration config = mock(InstrumentationConfiguration.class);
     when(config.shouldAcquire(anyString())).thenReturn(false);
     when(config.shouldInstrument(any(ClassDetails.class))).thenReturn(false);
-    ClassLoader classLoader = new SandboxClassLoader(config);
-    Class<?> exampleClass = classLoader.loadClass(AnExampleClass.class.getName());
-    assertSame(getClass().getClassLoader(), exampleClass.getClassLoader());
+    try (SandboxClassLoader classLoader = new SandboxClassLoader(config)) {
+      Class<?> exampleClass = classLoader.loadClass(AnExampleClass.class.getName());
+      assertSame(getClass().getClassLoader(), exampleClass.getClassLoader());
+    }
   }
 
   @Test
@@ -353,8 +354,8 @@ public class SandboxClassLoaderTest {
                 + " hortense)");
 
     // should not run constructor bodies...
-    assertEquals(null, getDeclaredFieldValue(aClass, o, "name"));
-    assertEquals(null, getDeclaredFieldValue(aClass, o, "uninstrumentedParent"));
+    assertNull(getDeclaredFieldValue(aClass, o, "name"));
+    assertNull(getDeclaredFieldValue(aClass, o, "uninstrumentedParent"));
   }
 
   @Test
@@ -381,10 +382,10 @@ public class SandboxClassLoaderTest {
         findDirectMethod(aClass, "__constructor__", uninstrumentedParentClass, String.class);
     Object uninstrumentedParentIn =
         uninstrumentedParentClass.getDeclaredConstructor(String.class).newInstance("hortense");
-    assertEquals(null, directMethod.invoke(instance, uninstrumentedParentIn, "foo"));
+    assertNull(directMethod.invoke(instance, uninstrumentedParentIn, "foo"));
     assertThat(transcript).isEmpty();
 
-    assertEquals(null, getDeclaredFieldValue(aClass, instance, "name"));
+    assertNull(getDeclaredFieldValue(aClass, instance, "name"));
     Object uninstrumentedParentOut =
         getDeclaredFieldValue(aClass, instance, "uninstrumentedParent");
     assertEquals(
@@ -392,7 +393,7 @@ public class SandboxClassLoaderTest {
         getDeclaredFieldValue(uninstrumentedParentClass, uninstrumentedParentOut, "parentName"));
 
     Method directMethod2 = findDirectMethod(aClass, "__constructor__", String.class);
-    assertEquals(null, directMethod2.invoke(instance, "hortense"));
+    assertNull(directMethod2.invoke(instance, "hortense"));
     assertThat(transcript).isEmpty();
 
     assertEquals("hortense", getDeclaredFieldValue(aClass, instance, "name"));
@@ -546,7 +547,7 @@ public class SandboxClassLoaderTest {
   }
 
   @Test
-  public void shouldReverseAnArray() throws Exception {
+  public void shouldReverseAnArray() {
     assertArrayEquals(new Integer[] {5, 4, 3, 2, 1}, Util.reverse(new Integer[] {1, 2, 3, 4, 5}));
     assertArrayEquals(new Integer[] {4, 3, 2, 1}, Util.reverse(new Integer[] {1, 2, 3, 4}));
     assertArrayEquals(new Integer[] {1}, Util.reverse(new Integer[] {1}));
@@ -564,16 +565,15 @@ public class SandboxClassLoaderTest {
 
   public static class MyClassHandler implements ClassHandler {
     private static final Object GENERATE_YOUR_OWN_VALUE = new Object();
-    private List<String> transcript;
+    private final List<String> transcript;
     private Object valueToReturn = GENERATE_YOUR_OWN_VALUE;
-    private Object valueToReturnFromIntercept = null;
 
     public MyClassHandler(List<String> transcript) {
       this.transcript = transcript;
     }
 
     @Override
-    public void classInitializing(Class clazz) {}
+    public void classInitializing(Class<?> clazz) {}
 
     public Object methodInvoked(
         String simpleClassName,
@@ -597,7 +597,7 @@ public class SandboxClassLoaderTest {
       transcript.add(buf.toString());
 
       if (valueToReturn != GENERATE_YOUR_OWN_VALUE) return valueToReturn;
-      return "response from " + buf.toString();
+      return "response from " + buf;
     }
 
     @Override
@@ -658,8 +658,7 @@ public class SandboxClassLoaderTest {
     }
 
     @Override
-    public Object intercept(String signature, Object instance, Object[] params, Class theClass)
-        throws Throwable {
+    public Object intercept(String signature, Object instance, Object[] params, Class<?> theClass) {
       StringBuilder buf = new StringBuilder();
       buf.append("intercept: ").append(signature).append(" with params (");
       for (int i = 0; i < params.length; i++) {
@@ -670,7 +669,7 @@ public class SandboxClassLoaderTest {
       }
       buf.append(")");
       transcript.add(buf.toString());
-      return valueToReturnFromIntercept;
+      return null;
     }
 
     @Override
@@ -691,7 +690,7 @@ public class SandboxClassLoaderTest {
     setStaticField(
         classLoader.loadClass(InvokeDynamicSupport.class.getName()),
         "INTERCEPTORS",
-        new Interceptors(Collections.<Interceptor>emptyList()));
+        new Interceptors(Collections.emptyList()));
     setStaticField(
         classLoader.loadClass(Shadow.class.getName()),
         "SHADOW_IMPL",
@@ -712,17 +711,19 @@ public class SandboxClassLoaderTest {
   public void shouldDumpClassesWhenConfigured() throws Exception {
     Path tempDir = Files.createTempDirectory("SandboxClassLoaderTest");
     System.setProperty("robolectric.dumpClassesDirectory", tempDir.toAbsolutePath().toString());
-    ClassLoader classLoader = new SandboxClassLoader(configureBuilder().build());
-    classLoader.loadClass(AnExampleClass.class.getName());
-    try (Stream<Path> stream = Files.list(tempDir)) {
-      List<Path> files = stream.collect(Collectors.toList());
-      assertThat(files).hasSize(1);
-      assertThat(files.get(0).toAbsolutePath().toString())
-          .containsMatch("org.robolectric.testing.AnExampleClass-robo-instrumented-\\d+.class");
-      Files.delete(files.get(0));
-    } finally {
-      Files.delete(tempDir);
-      System.clearProperty("robolectric.dumpClassesDirectory");
+    try (SandboxClassLoader classLoader = new SandboxClassLoader(configureBuilder().build())) {
+      classLoader.loadClass(AnExampleClass.class.getName());
+
+      try (Stream<Path> stream = Files.list(tempDir)) {
+        List<Path> files = stream.collect(Collectors.toList());
+        assertThat(files).hasSize(1);
+        assertThat(files.get(0).toAbsolutePath().toString())
+            .containsMatch("org.robolectric.testing.AnExampleClass-robo-instrumented-\\d+.class");
+        Files.delete(files.get(0));
+      } finally {
+        Files.delete(tempDir);
+        System.clearProperty("robolectric.dumpClassesDirectory");
+      }
     }
   }
 }
diff --git a/settings.gradle.kts b/settings.gradle.kts
index 812cc3b2a..1bc9dddf9 100644
--- a/settings.gradle.kts
+++ b/settings.gradle.kts
@@ -36,6 +36,7 @@ include(
   ":integration_tests:nativegraphics",
   ":integration_tests:play_services",
   ":integration_tests:powermock",
+  ":integration_tests:rap",
   ":integration_tests:roborazzi",
   ":integration_tests:room",
   ":integration_tests:sdkcompat",
@@ -56,6 +57,8 @@ include(
   ":shadows:framework",
   ":shadows:httpclient",
   ":shadows:playservices",
+  ":simulator",
+  ":simulator-gradle-plugin",
   ":testapp",
   ":utils",
   ":utils:reflector",
diff --git a/shadowapi/build.gradle.kts b/shadowapi/build.gradle.kts
index c5f5595a7..3ac1cc266 100644
--- a/shadowapi/build.gradle.kts
+++ b/shadowapi/build.gradle.kts
@@ -8,7 +8,7 @@ dependencies {
 
   api(project(":annotations"))
   api(project(":utils"))
+  testImplementation(libs.findbugs.jsr305)
   testImplementation(libs.junit4)
   testImplementation(libs.truth)
-  testImplementation(libs.mockito)
 }
diff --git a/shadowapi/src/main/java/org/robolectric/shadow/api/Shadow.java b/shadowapi/src/main/java/org/robolectric/shadow/api/Shadow.java
index f57228411..186ed95c1 100644
--- a/shadowapi/src/main/java/org/robolectric/shadow/api/Shadow.java
+++ b/shadowapi/src/main/java/org/robolectric/shadow/api/Shadow.java
@@ -4,7 +4,7 @@ import org.robolectric.internal.IShadow;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
 public class Shadow {
-  @SuppressWarnings("unused")
+  @SuppressWarnings({"unused", "FieldMayBeFinal"})
   private static IShadow SHADOW_IMPL;
 
   static {
@@ -42,30 +42,33 @@ public class Shadow {
     }
   }
 
-  public static <T> T newInstance(Class<T> clazz, Class[] parameterTypes, Object[] params) {
+  public static <T> T newInstance(Class<T> clazz, Class<?>[] parameterTypes, Object[] params) {
     return SHADOW_IMPL.newInstance(clazz, parameterTypes, params);
   }
 
   @SuppressWarnings("TypeParameterUnusedInFormals")
   public static <R> R directlyOn(
-      Object shadowedObject, String clazzName, String methodName, ClassParameter... paramValues) {
+      Object shadowedObject,
+      String clazzName,
+      String methodName,
+      ClassParameter<?>... paramValues) {
     return SHADOW_IMPL.directlyOn(shadowedObject, clazzName, methodName, paramValues);
   }
 
   @SuppressWarnings("TypeParameterUnusedInFormals")
   public static <R, T> R directlyOn(
-      T shadowedObject, Class<T> clazz, String methodName, ClassParameter... paramValues) {
+      T shadowedObject, Class<T> clazz, String methodName, ClassParameter<?>... paramValues) {
     return SHADOW_IMPL.directlyOn(shadowedObject, clazz, methodName, paramValues);
   }
 
   @SuppressWarnings("TypeParameterUnusedInFormals")
   public static <R, T> R directlyOn(
-      Class<T> clazz, String methodName, ClassParameter... paramValues) {
+      Class<T> clazz, String methodName, ClassParameter<?>... paramValues) {
     return SHADOW_IMPL.directlyOn(clazz, methodName, paramValues);
   }
 
   public static <R> R invokeConstructor(
-      Class<? extends R> clazz, R instance, ClassParameter... paramValues) {
+      Class<? extends R> clazz, R instance, ClassParameter<?>... paramValues) {
     return SHADOW_IMPL.invokeConstructor(clazz, instance, paramValues);
   }
 
diff --git a/shadowapi/src/main/java/org/robolectric/util/ReflectionHelpers.java b/shadowapi/src/main/java/org/robolectric/util/ReflectionHelpers.java
index a4a9b1cb1..c984125a9 100644
--- a/shadowapi/src/main/java/org/robolectric/util/ReflectionHelpers.java
+++ b/shadowapi/src/main/java/org/robolectric/util/ReflectionHelpers.java
@@ -86,12 +86,12 @@ public class ReflectionHelpers {
    *
    * @param clazz the class to provide a proxy instance of.
    * @param delegate the object to delegate matching method calls to. A 'matching method' must have
-   *     exactlu the same method name and parameter class names as the desired method.
+   *     exactly the same method name and parameter class names as the desired method.
    *     The @ClassName annotation can be applied to provide a custom class name.
    * @return a new "Delegating Proxy" instance of the given class.
    */
   public static <T> T createDelegatingProxy(Class<T> clazz, final Object delegate) {
-    final Class delegateClass = delegate.getClass();
+    final Class<?> delegateClass = delegate.getClass();
     return (T)
         Proxy.newProxyInstance(
             clazz.getClassLoader(),
@@ -241,7 +241,8 @@ public class ReflectionHelpers {
   public static boolean hasField(Class<?> clazz, String fieldName) {
     try {
       Field field = clazz.getDeclaredField(fieldName);
-      return (field != null);
+      //noinspection ConstantValue
+      return field != null;
     } catch (NoSuchFieldException e) {
       return false;
     }
diff --git a/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java b/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java
index e678051ed..4ec19f079 100644
--- a/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java
+++ b/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java
@@ -114,7 +114,7 @@ public class ReflectionHelpersTest {
   }
 
   @Test
-  public void getFinalStaticFieldReflectively_withFieldName_getsStaticField() throws Exception {
+  public void getFinalStaticFieldReflectively_withFieldName_getsStaticField() {
     assertThat((int) ReflectionHelpers.getStaticField(ExampleBase.class, "BASE")).isEqualTo(8);
   }
 
@@ -125,7 +125,7 @@ public class ReflectionHelpersTest {
 
     ReflectionHelpers.setStaticField(field, 7);
     assertWithMessage("startingValue").that(startingValue).isEqualTo(6);
-    assertWithMessage("DESCENDENT").that(ExampleDescendant.DESCENDANT).isEqualTo(7);
+    assertWithMessage("DESCENDANT").that(ExampleDescendant.DESCENDANT).isEqualTo(7);
 
     /// Reset the value to avoid test pollution
     ReflectionHelpers.setStaticField(field, startingValue);
@@ -137,7 +137,7 @@ public class ReflectionHelpersTest {
 
     ReflectionHelpers.setStaticField(ExampleDescendant.class, "DESCENDANT", 7);
     assertWithMessage("startingValue").that(startingValue).isEqualTo(6);
-    assertWithMessage("DESCENDENT").that(ExampleDescendant.DESCENDANT).isEqualTo(7);
+    assertWithMessage("DESCENDANT").that(ExampleDescendant.DESCENDANT).isEqualTo(7);
 
     // Reset the value to avoid test pollution
     ReflectionHelpers.setStaticField(ExampleDescendant.class, "DESCENDANT", startingValue);
@@ -313,14 +313,14 @@ public class ReflectionHelpersTest {
   }
 
   @Test
-  public void callHasField_withstaticandregularmember() {
+  public void callHasField_withStaticAndRegularMember() {
     assertWithMessage("has field failed for member: unusedName")
         .that(ReflectionHelpers.hasField(FieldTestClass.class, "unusedName"))
         .isTrue();
     assertWithMessage("has field failed for member: unusedStaticName")
         .that(ReflectionHelpers.hasField(FieldTestClass.class, "unusedStaticName"))
         .isTrue();
-    assertWithMessage("has field failed for non existant member: noname")
+    assertWithMessage("has field failed for non existent member: noname")
         .that(ReflectionHelpers.hasField(FieldTestClass.class, "noname"))
         .isFalse();
   }
@@ -376,13 +376,10 @@ public class ReflectionHelpersTest {
     assertThat(fixture.delegateMethod("value", "value2")).isEqualTo("called valuevalue2");
   }
 
-  @SuppressWarnings("serial")
   private static class TestError extends Error {}
 
-  @SuppressWarnings("serial")
   private static class TestException extends Exception {}
 
-  @SuppressWarnings("serial")
   private static class TestRuntimeException extends RuntimeException {}
 
   @SuppressWarnings("unused")
diff --git a/shadows/framework/src/main/java/android/webkit/RoboCookieManager.java b/shadows/framework/src/main/java/android/webkit/RoboCookieManager.java
index e867a2fac..d88f65310 100644
--- a/shadows/framework/src/main/java/android/webkit/RoboCookieManager.java
+++ b/shadows/framework/src/main/java/android/webkit/RoboCookieManager.java
@@ -89,7 +89,7 @@ public class RoboCookieManager extends CookieManager {
   @Override
   public String getCookie(String url) {
     // Return null value for empty url
-    if (url == null || url.equals("")) {
+    if (url == null || url.isEmpty()) {
       return null;
     }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java b/shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java
index 756160826..40be4db9c 100644
--- a/shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java
+++ b/shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java
@@ -266,7 +266,10 @@ public class RuntimeEnvironment {
    * @see #setMasterScheduler(Scheduler) see
    *     org.robolectric.Robolectric#getForegroundThreadScheduler() see
    *     org.robolectric.Robolectric#getBackgroundThreadScheduler()
+   * @deprecated The {@link Scheduler} APIs are designed for LEGACY Looper mode. Prefer to migrate
+   *     tests to PAUSED Looper mode to avoid the need for this API.
    */
+  @Deprecated
   public static Scheduler getMasterScheduler() {
     return masterScheduler;
   }
@@ -279,7 +282,10 @@ public class RuntimeEnvironment {
    * @param masterScheduler the new master scheduler.
    * @see #getMasterScheduler() see org.robolectric.Robolectric#getForegroundThreadScheduler() see
    *     org.robolectric.Robolectric#getBackgroundThreadScheduler()
+   * @deprecated The {@link Scheduler} APIs are designed for LEGACY Looper mode. Prefer to migrate
+   *     tests to PAUSED Looper mode to avoid the need for this API.
    */
+  @Deprecated
   public static void setMasterScheduler(Scheduler masterScheduler) {
     RuntimeEnvironment.masterScheduler = masterScheduler;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/android/Bootstrap.java b/shadows/framework/src/main/java/org/robolectric/android/Bootstrap.java
index 50a775669..a1cf0bfd1 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/Bootstrap.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/Bootstrap.java
@@ -4,12 +4,15 @@ import android.content.res.AssetManager;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.util.DisplayMetrics;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 import org.robolectric.res.Qualifiers;
 import org.robolectric.shadows.ShadowDateUtils;
 import org.robolectric.shadows.ShadowDisplayManager;
 import org.robolectric.shadows.ShadowDisplayManagerGlobal;
 
 public class Bootstrap {
+  private static final Pattern VERSION_QUALIFIER_PATTERN = Pattern.compile("(v)([0-9]+)$");
 
   private static Configuration configuration = new Configuration();
   private static DisplayMetrics displayMetrics = new DisplayMetrics();
@@ -88,9 +91,9 @@ public class Bootstrap {
       }
     }
 
-    for (i = (i < 0) ? 0 : i; i < qualifiersParts.length; i++) {
+    for (i = Math.max(i, 0); i < qualifiersParts.length; i++) {
       String qualifiersStr = qualifiersParts[i];
-      int platformVersion = Qualifiers.getPlatformVersion(qualifiersStr);
+      int platformVersion = getPlatformVersion(qualifiersStr);
       if (platformVersion != -1 && platformVersion != apiLevel) {
         throw new IllegalArgumentException(
             "Cannot specify conflicting platform version in qualifiers: \"" + qualifiersStr + "\"");
@@ -106,4 +109,12 @@ public class Bootstrap {
     // DateUtils has a static cache of the last Configuration, so it may need to be reset.
     ShadowDateUtils.resetLastConfig();
   }
+
+  private static int getPlatformVersion(String qualifiers) {
+    Matcher m = VERSION_QUALIFIER_PATTERN.matcher(qualifiers);
+    if (m.find()) {
+      return Integer.parseInt(m.group(2));
+    }
+    return -1;
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/android/ConfigurationV25.java b/shadows/framework/src/main/java/org/robolectric/android/ConfigurationV25.java
index e372a7108..7e8fb84c8 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/ConfigurationV25.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/ConfigurationV25.java
@@ -63,7 +63,7 @@ public class ConfigurationV25 {
 
   public static String resourceQualifierString(
       Configuration config, DisplayMetrics displayMetrics) {
-    ArrayList<String> parts = new ArrayList<String>();
+    ArrayList<String> parts = new ArrayList<>();
 
     if (config.mcc != 0) {
       parts.add("mcc" + config.mcc);
diff --git a/shadows/framework/src/main/java/org/robolectric/android/DeviceConfig.java b/shadows/framework/src/main/java/org/robolectric/android/DeviceConfig.java
index 0995033a3..c55c26a1c 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/DeviceConfig.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/DeviceConfig.java
@@ -201,7 +201,7 @@ public class DeviceConfig {
     configuration.uiMode = uiModeType | uiModeNight;
 
     if (resTab.density != ResTable_config.DENSITY_DEFAULT) {
-      setDensity(resTab.density, apiLevel, configuration, displayMetrics);
+      setDensity(resTab.density, configuration, displayMetrics);
     }
     setDimensions(apiLevel, configuration, displayMetrics);
 
@@ -237,7 +237,7 @@ public class DeviceConfig {
   }
 
   private static void setDensity(
-      int densityDpi, int apiLevel, Configuration configuration, DisplayMetrics displayMetrics) {
+      int densityDpi, Configuration configuration, DisplayMetrics displayMetrics) {
     configuration.densityDpi = densityDpi;
     displayMetrics.densityDpi = densityDpi;
     displayMetrics.density = displayMetrics.densityDpi * DisplayMetrics.DENSITY_DEFAULT_SCALE;
@@ -361,7 +361,7 @@ public class DeviceConfig {
         throw new IllegalArgumentException("'nodpi' isn't actually a dpi");
       case ResTable_config.DENSITY_DPI_UNDEFINED:
         // DisplayMetrics.DENSITY_DEFAULT is mdpi
-        setDensity(DEFAULT_DENSITY, apiLevel, configuration, displayMetrics);
+        setDensity(DEFAULT_DENSITY, configuration, displayMetrics);
     }
     setDimensions(apiLevel, configuration, displayMetrics);
 
@@ -440,11 +440,6 @@ public class DeviceConfig {
     return configuration.screenLayout & Configuration.SCREENLAYOUT_LAYOUTDIR_MASK;
   }
 
-  private static void setScreenLayoutLayoutDir(Configuration configuration, int value) {
-    configuration.screenLayout =
-        (configuration.screenLayout & ~Configuration.SCREENLAYOUT_LAYOUTDIR_MASK) | value;
-  }
-
   private static int getScreenLayoutRound(Configuration configuration) {
     return configuration.screenLayout & Configuration.SCREENLAYOUT_ROUND_MASK;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/android/XmlResourceParserImpl.java b/shadows/framework/src/main/java/org/robolectric/android/XmlResourceParserImpl.java
index 012f0ceb8..92f20a010 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/XmlResourceParserImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/XmlResourceParserImpl.java
@@ -13,7 +13,6 @@ import java.nio.file.Path;
 import java.util.Arrays;
 import java.util.List;
 import org.robolectric.res.AttributeResource;
-import org.robolectric.res.Fs;
 import org.robolectric.res.ResName;
 import org.robolectric.res.ResourceTable;
 import org.robolectric.res.StringResources;
@@ -21,6 +20,7 @@ import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.NamedNodeMap;
 import org.w3c.dom.Node;
+import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 
 /**
@@ -59,20 +59,6 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   private int mDepth = 0;
   private int mEventType = START_DOCUMENT;
 
-  /**
-   * @deprecated use {@link XmlResourceParserImpl#XmlResourceParserImpl(Document, Path, String,
-   *     String, ResourceTable)} instead.
-   */
-  @Deprecated
-  public XmlResourceParserImpl(
-      Document document,
-      String fileName,
-      String packageName,
-      String applicationPackageName,
-      ResourceTable resourceTable) {
-    this(document, Fs.fromUrl(fileName), packageName, applicationPackageName, resourceTable);
-  }
-
   public XmlResourceParserImpl(
       Document document,
       Path fileName,
@@ -190,7 +176,7 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   }
 
   /*package*/
-  public boolean isWhitespace(String text) throws XmlPullParserException {
+  public boolean isWhitespace(String text) {
     if (text == null) {
       return false;
     }
@@ -418,6 +404,7 @@ public class XmlResourceParserImpl implements XmlResourceParser {
           throw new IllegalArgumentException("END_DOCUMENT should not be found here.");
         }
       case (END_TAG):
+      case (TEXT):
         {
           return navigateToNextNode(currentNode);
         }
@@ -444,15 +431,11 @@ public class XmlResourceParserImpl implements XmlResourceParser {
             return END_TAG;
           }
         }
-      case (TEXT):
-        {
-          return navigateToNextNode(currentNode);
-        }
       default:
         {
           // This can only happen if mEventType is
           // assigned with an unmapped integer.
-          throw new RuntimeException("Robolectric-> Uknown XML event type: " + mEventType);
+          throw new RuntimeException("Robolectric-> Unknown XML event type: " + mEventType);
         }
     }
   }
@@ -464,9 +447,6 @@ public class XmlResourceParserImpl implements XmlResourceParser {
           throw new IllegalArgumentException("ATTRIBUTE_NODE");
         }
       case (Node.CDATA_SECTION_NODE):
-        {
-          return navigateToNextNode(node);
-        }
       case (Node.COMMENT_NODE):
         {
           return navigateToNextNode(node);
@@ -480,6 +460,8 @@ public class XmlResourceParserImpl implements XmlResourceParser {
           throw new IllegalArgumentException("DOCUMENT_NODE");
         }
       case (Node.DOCUMENT_TYPE_NODE):
+      case (Node.NOTATION_NODE):
+      case (Node.PROCESSING_INSTRUCTION_NODE):
         {
           throw new IllegalArgumentException("DOCUMENT_TYPE_NODE");
         }
@@ -496,14 +478,6 @@ public class XmlResourceParserImpl implements XmlResourceParser {
         {
           throw new IllegalArgumentException("ENTITY_REFERENCE_NODE");
         }
-      case (Node.NOTATION_NODE):
-        {
-          throw new IllegalArgumentException("DOCUMENT_TYPE_NODE");
-        }
-      case (Node.PROCESSING_INSTRUCTION_NODE):
-        {
-          throw new IllegalArgumentException("DOCUMENT_TYPE_NODE");
-        }
       case (Node.TEXT_NODE):
         {
           if (isWhitespace(node.getNodeValue())) {
@@ -529,9 +503,9 @@ public class XmlResourceParserImpl implements XmlResourceParser {
    * parent.
    *
    * @param node the node which was just explored.
-   * @return {@link XmlPullParserException#START_TAG} if the given node has siblings, {@link
-   *     XmlPullParserException#END_TAG} if the node has no unexplored siblings or {@link
-   *     XmlPullParserException#END_DOCUMENT} if the explored was the root document.
+   * @return {@link XmlPullParser#START_TAG} if the given node has siblings, {@link
+   *     XmlPullParser#END_TAG} if the node has no unexplored siblings or {@link
+   *     XmlPullParser#END_DOCUMENT} if the explored was the root document.
    * @throws XmlPullParserException if the parser fails to parse the next node.
    */
   int navigateToNextNode(Node node) throws XmlPullParserException {
@@ -712,9 +686,7 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   public int getAttributeIntValue(int idx, int defaultValue) {
     try {
       return Integer.parseInt(getAttributeValue(idx));
-    } catch (NumberFormatException ex) {
-      return defaultValue;
-    } catch (IndexOutOfBoundsException ex) {
+    } catch (IndexOutOfBoundsException | NumberFormatException ex) {
       return defaultValue;
     }
   }
@@ -732,9 +704,7 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   public float getAttributeFloatValue(int idx, float defaultValue) {
     try {
       return Float.parseFloat(getAttributeValue(idx));
-    } catch (NumberFormatException ex) {
-      return defaultValue;
-    } catch (IndexOutOfBoundsException ex) {
+    } catch (IndexOutOfBoundsException | NumberFormatException ex) {
       return defaultValue;
     }
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/android/controller/ActivityController.java b/shadows/framework/src/main/java/org/robolectric/android/controller/ActivityController.java
index 6463bace8..22415ea5e 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/controller/ActivityController.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/controller/ActivityController.java
@@ -6,7 +6,7 @@ import static android.os.Build.VERSION_CODES.O_MR1;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 import static org.robolectric.shadow.api.Shadow.extract;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
@@ -253,7 +253,7 @@ public class ActivityController<T extends Activity>
       // root can be null if looper was paused during visible. Flush the looper and try again
       shadowMainLooper.idle();
 
-      root = checkNotNull(getViewRoot());
+      root = requireNonNull(getViewRoot());
       callDispatchResized(root);
     }
 
@@ -530,7 +530,7 @@ public class ActivityController<T extends Activity>
             _component_ = _recreatedActivity_;
 
             // TODO: Because robolectric is currently not creating unique context objects per
-            //  activity and that the app copmat framework uses weak maps to cache resources per
+            //  activity and that the app compat framework uses weak maps to cache resources per
             //  context the caches end up with stale objects between activity creations (which would
             //  typically be flushed by an onConfigurationChanged when running in real android). To
             //  workaround this we can invoke a gc after running the configuration change and
@@ -721,7 +721,7 @@ public class ActivityController<T extends Activity>
     return changedConfig;
   }
 
-  /** Accessor interface for android.app.Activity.NonConfigurationInstances's internals. */
+  /** Accessor interface for android.app.Activity.NonConfigurationInstances' internals. */
   @ForType(className = "android.app.Activity$NonConfigurationInstances")
   interface _NonConfigurationInstances_ {
 
diff --git a/shadows/framework/src/main/java/org/robolectric/android/controller/ContentProviderController.java b/shadows/framework/src/main/java/org/robolectric/android/controller/ContentProviderController.java
index a779d3467..451298e09 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/controller/ContentProviderController.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/controller/ContentProviderController.java
@@ -13,7 +13,7 @@ import org.robolectric.shadows.ShadowContentResolver;
 import org.robolectric.util.Logger;
 
 public class ContentProviderController<T extends ContentProvider> {
-  private T contentProvider;
+  private final T contentProvider;
 
   private ContentProviderController(T contentProvider) {
     this.contentProvider = contentProvider;
diff --git a/shadows/framework/src/main/java/org/robolectric/android/controller/FragmentController.java b/shadows/framework/src/main/java/org/robolectric/android/controller/FragmentController.java
index 634ab7fd6..16e493136 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/controller/FragmentController.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/controller/FragmentController.java
@@ -86,18 +86,14 @@ public class FragmentController<F extends Fragment>
    */
   public FragmentController<F> create(final int contentViewId, final Bundle bundle) {
     shadowMainLooper.runPaused(
-        new Runnable() {
-          @Override
-          public void run() {
+        () ->
             activityController
                 .create(bundle)
                 .get()
                 .getFragmentManager()
                 .beginTransaction()
                 .add(contentViewId, fragment)
-                .commit();
-          }
-        });
+                .commit());
     return this;
   }
 
@@ -116,79 +112,37 @@ public class FragmentController<F extends Fragment>
 
   @Override
   public FragmentController<F> destroy() {
-    shadowMainLooper.runPaused(
-        new Runnable() {
-          @Override
-          public void run() {
-            activityController.destroy();
-          }
-        });
+    shadowMainLooper.runPaused(activityController::destroy);
     return this;
   }
 
   public FragmentController<F> start() {
-    shadowMainLooper.runPaused(
-        new Runnable() {
-          @Override
-          public void run() {
-            activityController.start();
-          }
-        });
+    shadowMainLooper.runPaused(activityController::start);
     return this;
   }
 
   public FragmentController<F> resume() {
-    shadowMainLooper.runPaused(
-        new Runnable() {
-          @Override
-          public void run() {
-            activityController.resume();
-          }
-        });
+    shadowMainLooper.runPaused(activityController::resume);
     return this;
   }
 
   public FragmentController<F> pause() {
-    shadowMainLooper.runPaused(
-        new Runnable() {
-          @Override
-          public void run() {
-            activityController.pause();
-          }
-        });
+    shadowMainLooper.runPaused(activityController::pause);
     return this;
   }
 
   public FragmentController<F> visible() {
-    shadowMainLooper.runPaused(
-        new Runnable() {
-          @Override
-          public void run() {
-            activityController.visible();
-          }
-        });
+    shadowMainLooper.runPaused(activityController::visible);
     return this;
   }
 
   public FragmentController<F> stop() {
-    shadowMainLooper.runPaused(
-        new Runnable() {
-          @Override
-          public void run() {
-            activityController.stop();
-          }
-        });
+    shadowMainLooper.runPaused(activityController::stop);
     return this;
   }
 
   public FragmentController<F> saveInstanceState(final Bundle outState) {
-    shadowMainLooper.runPaused(
-        new Runnable() {
-          @Override
-          public void run() {
-            activityController.saveInstanceState(outState);
-          }
-        });
+    shadowMainLooper.runPaused(() -> activityController.saveInstanceState(outState));
     return this;
   }
 
@@ -198,29 +152,20 @@ public class FragmentController<F extends Fragment>
 
   public FragmentController<F> recreate(final F recreatedFragment, final int contentViewId) {
     ActivityLifecycleCallback fragmentCreateCallback =
-        new ActivityLifecycleCallback() {
-          @Override
-          public void onActivityLifecycleChanged(Activity activity, Stage stage) {
-            if (Stage.CREATED.equals(stage)) {
-              activity
-                  .getFragmentManager()
-                  .beginTransaction()
-                  .add(contentViewId, recreatedFragment)
-                  .commit();
-              FragmentController.this.fragment = recreatedFragment;
-              FragmentController.this.component = recreatedFragment;
-            }
+        (activity, stage) -> {
+          if (Stage.CREATED.equals(stage)) {
+            activity
+                .getFragmentManager()
+                .beginTransaction()
+                .add(contentViewId, recreatedFragment)
+                .commit();
+            FragmentController.this.fragment = recreatedFragment;
+            FragmentController.this.component = recreatedFragment;
           }
         };
     ActivityLifecycleMonitorRegistry.getInstance().addLifecycleCallback(fragmentCreateCallback);
 
-    shadowMainLooper.runPaused(
-        new Runnable() {
-          @Override
-          public void run() {
-            activityController.recreate();
-          }
-        });
+    shadowMainLooper.runPaused(activityController::recreate);
 
     ActivityLifecycleMonitorRegistry.getInstance().removeLifecycleCallback(fragmentCreateCallback);
     return this;
diff --git a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/InlineExecutorService.java b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/InlineExecutorService.java
index 439ff76e8..ae652df11 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/InlineExecutorService.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/InlineExecutorService.java
@@ -41,6 +41,7 @@ public class InlineExecutorService implements ExecutorService {
     delegateService.shutdown();
   }
 
+  @Nonnull
   @Override
   public List<Runnable> shutdownNow() {
     return delegateService.shutdownNow();
@@ -57,7 +58,7 @@ public class InlineExecutorService implements ExecutorService {
   }
 
   @Override
-  public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {
+  public boolean awaitTermination(long l, @Nonnull TimeUnit timeUnit) throws InterruptedException {
     // If not shut down first, timeout would occur with normal behavior.
     return delegateService.awaitTermination(l, timeUnit);
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/PausedExecutorService.java b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/PausedExecutorService.java
index 9a96c9a93..160266dc4 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/PausedExecutorService.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/PausedExecutorService.java
@@ -21,7 +21,7 @@ import org.robolectric.util.Logger;
 /**
  * Executor service that queues any posted tasks.
  *
- * <p>Users must explicitly call {@link runAll()} to execute all pending tasks.
+ * <p>Users must explicitly call {@link #runAll()} to execute all pending tasks.
  *
  * <p>Intended to be a replacement for {@link RoboExecutorService} when using {@link
  * LooperMode.Mode#PAUSED}. Unlike {@link RoboExecutorService}, will execute tasks on a background
@@ -134,6 +134,7 @@ public class PausedExecutorService extends AbstractExecutorService {
     deferredTasks.clear();
   }
 
+  @Nonnull
   @Override
   public List<Runnable> shutdownNow() {
     realService.shutdownNow();
@@ -153,7 +154,7 @@ public class PausedExecutorService extends AbstractExecutorService {
   }
 
   @Override
-  public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {
+  public boolean awaitTermination(long l, @Nonnull TimeUnit timeUnit) throws InterruptedException {
     // If not shut down first, timeout would occur with normal behavior.
     return realService.awaitTermination(l, timeUnit);
   }
@@ -174,6 +175,6 @@ public class PausedExecutorService extends AbstractExecutorService {
 
   @Override
   protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
-    return new DeferredTask<T>(callable, realService);
+    return new DeferredTask<>(callable, realService);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/RoboExecutorService.java b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/RoboExecutorService.java
index a1247cefd..291293e59 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/RoboExecutorService.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/RoboExecutorService.java
@@ -1,5 +1,6 @@
 package org.robolectric.android.util.concurrent;
 
+import com.google.common.util.concurrent.MoreExecutors;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
@@ -11,16 +12,17 @@ import java.util.concurrent.Future;
 import java.util.concurrent.FutureTask;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
+import javax.annotation.Nonnull;
+import org.robolectric.annotation.LooperMode;
 import org.robolectric.shadows.ShadowApplication;
 import org.robolectric.util.Scheduler;
 
 /**
  * Executor service that runs all operations on the background scheduler.
  *
- * @deprecated only works when used in conjunction with the deprecated {@link LooperMode.LEGACY}
- *     mode. Consider using guava's {@link MoreExecutors#directExecutor()} or {@link
- *     org.robolectric.android.util.concurrent.PausedExecutorService} or {@link
- *     org.robolectric.android.util.concurrent.InlineExecutorService}.
+ * @deprecated only works when used in conjunction with the deprecated {@link
+ *     LooperMode.Mode#LEGACY} mode. Consider using guava's {@link MoreExecutors#directExecutor()}
+ *     or {@link PausedExecutorService} or {@link InlineExecutorService}.
  */
 @Deprecated
 public class RoboExecutorService implements ExecutorService {
@@ -59,6 +61,7 @@ public class RoboExecutorService implements ExecutorService {
     shutdownNow();
   }
 
+  @Nonnull
   @Override
   public List<Runnable> shutdownNow() {
     isShutdown = true;
@@ -82,23 +85,26 @@ public class RoboExecutorService implements ExecutorService {
   }
 
   @Override
-  public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {
+  public boolean awaitTermination(long l, @Nonnull TimeUnit timeUnit) throws InterruptedException {
     // If not shut down first, timeout would occur with normal behavior.
     return isShutdown();
   }
 
+  @Nonnull
   @Override
-  public <T> Future<T> submit(Callable<T> tCallable) {
-    return schedule(new AdvancingFutureTask<T>(scheduler, tCallable));
+  public <T> Future<T> submit(@Nonnull Callable<T> tCallable) {
+    return schedule(new AdvancingFutureTask<>(scheduler, tCallable));
   }
 
+  @Nonnull
   @Override
-  public <T> Future<T> submit(Runnable runnable, T t) {
-    return schedule(new AdvancingFutureTask<T>(scheduler, runnable, t));
+  public <T> Future<T> submit(@Nonnull Runnable runnable, T t) {
+    return schedule(new AdvancingFutureTask<>(scheduler, runnable, t));
   }
 
+  @Nonnull
   @Override
-  public Future<?> submit(Runnable runnable) {
+  public Future<?> submit(@Nonnull Runnable runnable) {
     return submit(runnable, null);
   }
 
@@ -117,33 +123,37 @@ public class RoboExecutorService implements ExecutorService {
     return futureTask;
   }
 
+  @Nonnull
   @Override
-  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> callables)
+  public <T> List<Future<T>> invokeAll(@Nonnull Collection<? extends Callable<T>> callables)
       throws InterruptedException {
     throw new UnsupportedOperationException();
   }
 
+  @Nonnull
   @Override
   public <T> List<Future<T>> invokeAll(
-      Collection<? extends Callable<T>> callables, long l, TimeUnit timeUnit)
+      @Nonnull Collection<? extends Callable<T>> callables, long l, @Nonnull TimeUnit timeUnit)
       throws InterruptedException {
     throw new UnsupportedOperationException();
   }
 
+  @Nonnull
   @Override
-  public <T> T invokeAny(Collection<? extends Callable<T>> callables)
+  public <T> T invokeAny(@Nonnull Collection<? extends Callable<T>> callables)
       throws InterruptedException, ExecutionException {
     throw new UnsupportedOperationException();
   }
 
   @Override
-  public <T> T invokeAny(Collection<? extends Callable<T>> callables, long l, TimeUnit timeUnit)
+  public <T> T invokeAny(
+      @Nonnull Collection<? extends Callable<T>> callables, long l, @Nonnull TimeUnit timeUnit)
       throws InterruptedException, ExecutionException, TimeoutException {
     throw new UnsupportedOperationException();
   }
 
   @Override
-  public void execute(Runnable runnable) {
+  public void execute(@Nonnull Runnable runnable) {
     @SuppressWarnings({"unused", "nullness"})
     Future<?> possiblyIgnoredError = submit(runnable);
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/FakeMediaProvider.java b/shadows/framework/src/main/java/org/robolectric/fakes/FakeMediaProvider.java
index 9b0be8ffd..bf3270e36 100644
--- a/shadows/framework/src/main/java/org/robolectric/fakes/FakeMediaProvider.java
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/FakeMediaProvider.java
@@ -1,7 +1,7 @@
 package org.robolectric.fakes;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 import static org.robolectric.fakes.MediaUriMatcher.AUDIO_ALBUMART;
 import static org.robolectric.fakes.MediaUriMatcher.AUDIO_ALBUMART_FILE_ID;
 import static org.robolectric.fakes.MediaUriMatcher.AUDIO_ALBUMART_ID;
@@ -55,6 +55,7 @@ import android.webkit.MimeTypeMap;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Supplier;
 import com.google.common.base.Suppliers;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.io.Files;
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -62,7 +63,7 @@ import java.io.IOException;
 import java.nio.file.Paths;
 import java.util.Arrays;
 import java.util.Random;
-import java.util.Set;
+import java.util.concurrent.atomic.AtomicBoolean;
 import org.robolectric.RuntimeEnvironment;
 
 /**
@@ -89,6 +90,7 @@ public final class FakeMediaProvider extends ContentProvider {
 
   private final Random displayNameRandom = new Random();
   private final MediaUriMatcher uriMatcher = new MediaUriMatcher(MediaStore.AUTHORITY);
+  private final AtomicBoolean initialized = new AtomicBoolean();
   private static final String TAG = "FakeMediaProvider";
 
   @Override
@@ -102,6 +104,7 @@ public final class FakeMediaProvider extends ContentProvider {
             () -> {
               SQLiteDatabase db = SQLiteDatabase.create(null);
               db.execSQL(createTableStatement());
+              initialized.set(true);
               return db;
             });
 
@@ -122,7 +125,7 @@ public final class FakeMediaProvider extends ContentProvider {
       String[] selectionArgs,
       String sortOrder,
       CancellationSignal cancellationSignal) {
-    checkNotNull(uri);
+    requireNonNull(uri);
     final SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
 
     qb.setTables(TABLE_NAME);
@@ -227,7 +230,7 @@ public final class FakeMediaProvider extends ContentProvider {
 
   @Override
   public Uri insert(Uri uri, ContentValues originalValues) {
-    ContentValues values = new ContentValues(checkNotNull(originalValues));
+    ContentValues values = new ContentValues(requireNonNull(originalValues));
 
     final int match = uriMatcher.matchUri(uri);
     checkState(match != UriMatcher.NO_MATCH, "Unrecognized uri " + uri.toString());
@@ -253,7 +256,7 @@ public final class FakeMediaProvider extends ContentProvider {
       // Real media provider uses System.currentTimeMillis() as default name
       // This could be problematic for Robolectric where clock is fixed, so just use
       // a random number.
-      displayName = String.valueOf(Math.abs(displayNameRandom.nextInt()));
+      displayName = String.valueOf(displayNameRandom.nextInt());
       values.put(MediaColumns.DISPLAY_NAME, displayName);
     }
     if (TextUtils.isEmpty(mimeType)) {
@@ -328,7 +331,7 @@ public final class FakeMediaProvider extends ContentProvider {
   // guard against two entries with same displayname and relative path being inserted by adding a
   // random number to each entry
   private String makeUniqueFileName(String baseName, String ext) {
-    return String.format("%s-%d.%s", baseName, Math.abs(displayNameRandom.nextInt()), ext);
+    return String.format("%s-%d.%s", baseName, displayNameRandom.nextInt(), ext);
   }
 
   private String getDefaultRelativePath(int match) {
@@ -396,7 +399,7 @@ public final class FakeMediaProvider extends ContentProvider {
   private void validateRelativePath(String mimeType, String relativePath) {
     if (mimeType.startsWith("video")) {
       String primaryDir = relativePath.split("/")[0];
-      Set<String> allowedPaths = Set.of("DCIM", "Movies", "Pictures");
+      ImmutableSet<String> allowedPaths = ImmutableSet.of("DCIM", "Movies", "Pictures");
       if (!allowedPaths.contains(primaryDir)) {
         throw new IllegalArgumentException(
             String.format(
@@ -558,30 +561,11 @@ public final class FakeMediaProvider extends ContentProvider {
         + ")";
   }
 
-  private static String extractFileName(String data) {
-    if (data == null) {
-      return null;
-    }
-    data = extractDisplayName(data);
-
-    final int lastDot = data.lastIndexOf('.');
-    if (lastDot == -1) {
-      return data;
-    } else {
-      return data.substring(0, lastDot);
-    }
-  }
 
-  private static String extractDisplayName(String data) {
-    if (data == null) {
-      return null;
-    }
-    if (data.indexOf('/') == -1) {
-      return data;
-    }
-    if (data.endsWith("/")) {
-      data = data.substring(0, data.length() - 1);
+  @Override
+  public void shutdown() {
+    if (initialized.get()) {
+      dbSupplier.get().close();
     }
-    return data.substring(data.lastIndexOf('/') + 1);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/RoboCursor.java b/shadows/framework/src/main/java/org/robolectric/fakes/RoboCursor.java
index 8cb5d5776..64e03c1b9 100644
--- a/shadows/framework/src/main/java/org/robolectric/fakes/RoboCursor.java
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/RoboCursor.java
@@ -205,7 +205,7 @@ public class RoboCursor extends BaseCursor {
 
   @Override
   public String[] getColumnNames() {
-    return columnNames.toArray(new String[columnNames.size()]);
+    return columnNames.toArray(new String[0]);
   }
 
   @Override
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/RoboIntentSender.java b/shadows/framework/src/main/java/org/robolectric/fakes/RoboIntentSender.java
index df70dda34..2f9fb9337 100644
--- a/shadows/framework/src/main/java/org/robolectric/fakes/RoboIntentSender.java
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/RoboIntentSender.java
@@ -11,7 +11,7 @@ import java.util.Objects;
 /** Robolectric implementation of {@link android.content.IntentSender}. */
 public class RoboIntentSender extends IntentSender {
   public Intent intent;
-  private PendingIntent pendingIntent;
+  private final PendingIntent pendingIntent;
 
   public RoboIntentSender(PendingIntent pendingIntent) {
     super((IIntentSender) null);
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenu.java b/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenu.java
index f3001d994..007c426c7 100644
--- a/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenu.java
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenu.java
@@ -15,8 +15,8 @@ import org.robolectric.RuntimeEnvironment;
 
 /** Robolectric implementation of {@link android.view.Menu}. */
 public class RoboMenu implements Menu {
-  private List<MenuItem> menuItems = new ArrayList<>();
-  private Context context;
+  private final List<MenuItem> menuItems = new ArrayList<>();
+  private final Context context;
 
   public RoboMenu() {
     this(RuntimeEnvironment.getApplication());
@@ -203,13 +203,7 @@ public class RoboMenu implements Menu {
 
     @Override
     public int compare(MenuItem a, MenuItem b) {
-      if (a.getOrder() == b.getOrder()) {
-        return 0;
-      } else if (a.getOrder() > b.getOrder()) {
-        return 1;
-      } else {
-        return -1;
-      }
+      return Integer.compare(a.getOrder(), b.getOrder());
     }
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/RoboSplashScreen.java b/shadows/framework/src/main/java/org/robolectric/fakes/RoboSplashScreen.java
index 93b30dbbd..0483c47aa 100644
--- a/shadows/framework/src/main/java/org/robolectric/fakes/RoboSplashScreen.java
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/RoboSplashScreen.java
@@ -4,6 +4,7 @@ import android.annotation.RequiresApi;
 import android.annotation.StyleRes;
 import android.os.Build;
 import android.window.SplashScreen;
+import javax.annotation.Nonnull;
 
 /** Robolectric implementation of {@link android.window.SplashScreen}. */
 @RequiresApi(api = Build.VERSION_CODES.S)
@@ -12,7 +13,7 @@ public class RoboSplashScreen implements SplashScreen {
   @StyleRes private int themeId;
 
   @Override
-  public void setOnExitAnimationListener(SplashScreen.OnExitAnimationListener listener) {}
+  public void setOnExitAnimationListener(@Nonnull SplashScreen.OnExitAnimationListener listener) {}
 
   @Override
   public void clearOnExitAnimationListener() {}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java
index 5683dc701..c24678f77 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java
@@ -29,7 +29,6 @@ public class AssociationInfoBuilder {
   // We have two different constructors for AssociationInfo across
   // T branches. aosp has the constructor that takes a new "revoked" parameter.
   private boolean revoked;
-  private boolean pending;
   private long lastTimeConnectedMs;
   private int systemDataSyncFlags;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/BackupDataEntity.java b/shadows/framework/src/main/java/org/robolectric/shadows/BackupDataEntity.java
index 38bf3f0cb..ecc32f2e7 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/BackupDataEntity.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/BackupDataEntity.java
@@ -1,7 +1,7 @@
 package org.robolectric.shadows;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Objects.requireNonNull;
 
 import com.google.auto.value.AutoValue;
 import java.nio.charset.StandardCharsets;
@@ -28,7 +28,7 @@ public abstract class BackupDataEntity {
    */
   public static BackupDataEntity createDeletedEntity(String key) {
     return new AutoValue_BackupDataEntity(
-        checkNotNull(key), /* dataSize= */ -1, /* data= */ new byte[0]);
+        requireNonNull(key), /* dataSize= */ -1, /* data= */ new byte[0]);
   }
 
   /**
@@ -53,6 +53,6 @@ public abstract class BackupDataEntity {
    */
   public static BackupDataEntity create(String key, byte[] data, int dataSize) {
     return new AutoValue_BackupDataEntity(
-        checkNotNull(key), dataSize, Arrays.copyOf(data, dataSize));
+        requireNonNull(key), dataSize, Arrays.copyOf(data, dataSize));
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/BluetoothAdvertiseProxyDelegate.java b/shadows/framework/src/main/java/org/robolectric/shadows/BluetoothAdvertiseProxyDelegate.java
index d61d599f2..a76bf25c3 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/BluetoothAdvertiseProxyDelegate.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/BluetoothAdvertiseProxyDelegate.java
@@ -2,6 +2,7 @@ package org.robolectric.shadows;
 
 import static org.robolectric.util.reflector.Reflector.reflector;
 
+import android.bluetooth.IBluetoothGattServerCallback;
 import android.bluetooth.le.AdvertiseData;
 import android.bluetooth.le.AdvertisingSetCallback;
 import android.bluetooth.le.AdvertisingSetParameters;
@@ -55,6 +56,30 @@ class BluetoothAdvertiseProxyDelegate {
             AdvertisingSetCallback.ADVERTISE_SUCCESS);
   }
 
+  public void startAdvertisingSet(
+      AdvertisingSetParameters parameters,
+      AdvertiseData advertiseData,
+      AdvertiseData scanResponse,
+      PeriodicAdvertisingParameters periodicParameters,
+      AdvertiseData periodicData,
+      int duration,
+      int maxExtAdvEvents,
+      IBluetoothGattServerCallback gattServerCallback, // new in post-Baklava, ignored
+      IAdvertisingSetCallback callback,
+      AttributionSource attributionSource) {
+    startAdvertisingSet(
+        parameters,
+        advertiseData,
+        scanResponse,
+        periodicParameters,
+        periodicData,
+        duration,
+        maxExtAdvEvents,
+        0,
+        callback,
+        attributionSource);
+  }
+
   public void stopAdvertisingSet(
       IAdvertisingSetCallback callback, AttributionSource attributionSource) {
     try {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/CachedPathIteratorFactory.java b/shadows/framework/src/main/java/org/robolectric/shadows/CachedPathIteratorFactory.java
index 7ef10bb5e..10ca18459 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/CachedPathIteratorFactory.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/CachedPathIteratorFactory.java
@@ -206,7 +206,7 @@ public class CachedPathIteratorFactory {
    * PathIterator#SEG_LINETO} this method will fail.
    */
   private static float getFlatPathLength(PathIterator iterator) {
-    float segment[] = new float[6];
+    float[] segment = new float[6];
     float totalLength = 0;
     float[] previousPoint = new float[2];
     boolean isFirstPoint = true;
@@ -279,7 +279,7 @@ public class CachedPathIteratorFactory {
      *
      * @see PathIterator
      */
-    private float[] mCurrentCoords = new float[6];
+    private final float[] mCurrentCoords = new float[6];
 
     private float mCurrentSegmentLength;
 
@@ -293,7 +293,7 @@ public class CachedPathIteratorFactory {
     private float mOffsetLength;
 
     /** Point where the current segment started */
-    private float[] mLastPoint = new float[2];
+    private final float[] mLastPoint = new float[2];
 
     private boolean isIteratorDone;
 
@@ -388,7 +388,7 @@ public class CachedPathIteratorFactory {
       }
 
       float accLength = 0;
-      float lastPoint[] = new float[2];
+      float[] lastPoint = new float[2];
       for (mNextIndex = 0; mNextIndex < mTypes.length; mNextIndex++) {
         float segmentLength = mSegmentsLength[mNextIndex];
         if (accLength + segmentLength >= length && mTypes[mNextIndex] != SEG_MOVETO) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/CellIdentityGsmBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/CellIdentityGsmBuilder.java
new file mode 100644
index 000000000..05f8f0377
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/CellIdentityGsmBuilder.java
@@ -0,0 +1,162 @@
+package org.robolectric.shadows;
+
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.annotation.RequiresApi;
+import android.os.Build;
+import android.telephony.CellIdentityGsm;
+import android.telephony.CellInfo;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import javax.annotation.Nullable;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.util.reflector.Constructor;
+import org.robolectric.util.reflector.ForType;
+
+/** Builder for {@link android.telephony.CellIdentityGsm}. */
+@RequiresApi(Build.VERSION_CODES.Q)
+public class CellIdentityGsmBuilder {
+
+  private int lac = CellInfo.UNAVAILABLE;
+  private int cid = CellInfo.UNAVAILABLE;
+  private int bsic = CellInfo.UNAVAILABLE;
+  private int arfcn = CellInfo.UNAVAILABLE;
+  private List<String> additionalPlmns = new ArrayList<>();
+  @Nullable private String mccStr = null;
+  @Nullable private String mncStr = null;
+  @Nullable private String alphal = null;
+  @Nullable private String alphas = null;
+
+  private CellIdentityGsmBuilder() {}
+
+  public static CellIdentityGsmBuilder newBuilder() {
+    return new CellIdentityGsmBuilder();
+  }
+
+  // An empty constructor is not available on Q.
+  @RequiresApi(Build.VERSION_CODES.R)
+  protected static CellIdentityGsm getDefaultInstance() {
+    return reflector(CellIdentityGsmReflector.class).newCellIdentityGsm();
+  }
+
+  public CellIdentityGsmBuilder setLac(int lac) {
+    this.lac = lac;
+    return this;
+  }
+
+  public CellIdentityGsmBuilder setCid(int cid) {
+    this.cid = cid;
+    return this;
+  }
+
+  public CellIdentityGsmBuilder setBsic(int bsic) {
+    this.bsic = bsic;
+    return this;
+  }
+
+  public CellIdentityGsmBuilder setArfcn(int arfcn) {
+    this.arfcn = arfcn;
+    return this;
+  }
+
+  public CellIdentityGsmBuilder setMcc(String mcc) {
+    this.mccStr = mcc;
+    return this;
+  }
+
+  public CellIdentityGsmBuilder setMnc(String mnc) {
+    this.mncStr = mnc;
+    return this;
+  }
+
+  public CellIdentityGsmBuilder setOperatorAlphaLong(String operatorAlphaLong) {
+    this.alphal = operatorAlphaLong;
+    return this;
+  }
+
+  public CellIdentityGsmBuilder setOperatorAlphaShort(String operatorAlphaShort) {
+    this.alphas = operatorAlphaShort;
+    return this;
+  }
+
+  public CellIdentityGsmBuilder setAdditionalPlmns(List<String> additionalPlmns) {
+    this.additionalPlmns = additionalPlmns;
+    return this;
+  }
+
+  public CellIdentityGsm build() {
+    CellIdentityGsmReflector cellIdentityReflector = reflector(CellIdentityGsmReflector.class);
+
+    if (RuntimeEnvironment.getApiLevel() < Build.VERSION_CODES.N) {
+      int mcc = parseInt(mccStr, Integer.MAX_VALUE);
+      int mnc = parseInt(mncStr, Integer.MAX_VALUE);
+
+      return cellIdentityReflector.newCellIdentityGsm(mcc, mnc, lac, cid);
+    } else if (RuntimeEnvironment.getApiLevel() < Build.VERSION_CODES.P) {
+      int mcc = parseInt(mccStr, Integer.MAX_VALUE);
+      int mnc = parseInt(mncStr, Integer.MAX_VALUE);
+
+      return cellIdentityReflector.newCellIdentityGsm(mcc, mnc, lac, cid, arfcn, bsic);
+    } else if (RuntimeEnvironment.getApiLevel() < Build.VERSION_CODES.R) {
+      return cellIdentityReflector.newCellIdentityGsm(
+          lac, cid, arfcn, bsic, mccStr, mncStr, alphal, alphas);
+    } else {
+
+      return cellIdentityReflector.newCellIdentityGsm(
+          lac, cid, arfcn, bsic, mccStr, mncStr, alphal, alphas, additionalPlmns);
+    }
+  }
+
+  /**
+   * Parses a string to an integer. Throws an {@link IllegalArgumentException} if the string cannot
+   * be parsed as an integer. This returns {@code defaultValue} if the string is null.
+   */
+  private static int parseInt(String str, int defaultValue) {
+    if (str == null) {
+      return defaultValue;
+    }
+
+    try {
+      return Integer.parseInt(str);
+    } catch (NumberFormatException e) {
+      throw new IllegalArgumentException("Failed to parse integer from string: " + str, e);
+    }
+  }
+
+  @ForType(CellIdentityGsm.class)
+  private interface CellIdentityGsmReflector {
+
+    @Constructor
+    CellIdentityGsm newCellIdentityGsm();
+
+    @Constructor
+    CellIdentityGsm newCellIdentityGsm(int mcc, int mnc, int lac, int cid);
+
+    @Constructor
+    CellIdentityGsm newCellIdentityGsm(int mcc, int mnc, int lac, int cid, int arfcn, int bsic);
+
+    @Constructor
+    CellIdentityGsm newCellIdentityGsm(
+        int lac,
+        int cid,
+        int arfcn,
+        int bsic,
+        String mcc,
+        String mnc,
+        String alphal,
+        String alphas);
+
+    @Constructor
+    CellIdentityGsm newCellIdentityGsm(
+        int lac,
+        int cid,
+        int arfcn,
+        int bsic,
+        String mcc,
+        String mnc,
+        String alphal,
+        String alphas,
+        Collection<String> additionalPlmns);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/CellIdentityNrBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/CellIdentityNrBuilder.java
index f103b2bb4..f16eeeff7 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/CellIdentityNrBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/CellIdentityNrBuilder.java
@@ -24,7 +24,7 @@ public class CellIdentityNrBuilder {
   private int[] bands = new int[0];
   @Nullable private String mcc = null;
   @Nullable private String mnc = null;
-  private long nci = CellInfo.UNAVAILABLE;
+  private long nci = CellInfo.UNAVAILABLE_LONG;
   @Nullable private String alphal = null;
   @Nullable private String alphas = null;
   private List<String> additionalPlmns = new ArrayList<>();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/CellIdentityWcdmaBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/CellIdentityWcdmaBuilder.java
new file mode 100644
index 000000000..d5425ce17
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/CellIdentityWcdmaBuilder.java
@@ -0,0 +1,169 @@
+package org.robolectric.shadows;
+
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.annotation.RequiresApi;
+import android.os.Build;
+import android.telephony.CellIdentityWcdma;
+import android.telephony.CellInfo;
+import android.telephony.ClosedSubscriberGroupInfo;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import javax.annotation.Nullable;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.util.reflector.Constructor;
+import org.robolectric.util.reflector.ForType;
+
+/** Builder for {@link android.telephony.CellIdentityWcdma}. */
+@RequiresApi(Build.VERSION_CODES.Q)
+public class CellIdentityWcdmaBuilder {
+
+  private int lac = CellInfo.UNAVAILABLE;
+  private int cid = CellInfo.UNAVAILABLE;
+  private int psc = CellInfo.UNAVAILABLE;
+  private int uarfcn = CellInfo.UNAVAILABLE;
+  private List<String> additionalPlmns = new ArrayList<>();
+  @Nullable private String mccStr = null;
+  @Nullable private String mncStr = null;
+  @Nullable private String alphal = null;
+  @Nullable private String alphas = null;
+  @Nullable private ClosedSubscriberGroupInfo csgInfo = null;
+
+  private CellIdentityWcdmaBuilder() {}
+
+  public static CellIdentityWcdmaBuilder newBuilder() {
+    return new CellIdentityWcdmaBuilder();
+  }
+
+  // An empty constructor is not available on Q.
+  @RequiresApi(Build.VERSION_CODES.R)
+  protected static CellIdentityWcdma getDefaultInstance() {
+    return reflector(CellIdentityWcdmaReflector.class).newCellIdentityWcdma();
+  }
+
+  public CellIdentityWcdmaBuilder setLac(int lac) {
+    this.lac = lac;
+    return this;
+  }
+
+  public CellIdentityWcdmaBuilder setCid(int cid) {
+    this.cid = cid;
+    return this;
+  }
+
+  public CellIdentityWcdmaBuilder setPsc(int psc) {
+    this.psc = psc;
+    return this;
+  }
+
+  public CellIdentityWcdmaBuilder setUarfcn(int uarfcn) {
+    this.uarfcn = uarfcn;
+    return this;
+  }
+
+  public CellIdentityWcdmaBuilder setMcc(String mcc) {
+    this.mccStr = mcc;
+    return this;
+  }
+
+  public CellIdentityWcdmaBuilder setMnc(String mnc) {
+    this.mncStr = mnc;
+    return this;
+  }
+
+  public CellIdentityWcdmaBuilder setOperatorAlphaLong(String operatorAlphaLong) {
+    this.alphal = operatorAlphaLong;
+    return this;
+  }
+
+  public CellIdentityWcdmaBuilder setOperatorAlphaShort(String operatorAlphaShort) {
+    this.alphas = operatorAlphaShort;
+    return this;
+  }
+
+  public CellIdentityWcdmaBuilder setAdditionalPlmns(List<String> additionalPlmns) {
+    this.additionalPlmns = additionalPlmns;
+    return this;
+  }
+
+  public CellIdentityWcdmaBuilder setCsgInfo(ClosedSubscriberGroupInfo csgInfo) {
+    this.csgInfo = csgInfo;
+    return this;
+  }
+
+  public CellIdentityWcdma build() {
+    CellIdentityWcdmaReflector cellIdentityReflector = reflector(CellIdentityWcdmaReflector.class);
+
+    if (RuntimeEnvironment.getApiLevel() < Build.VERSION_CODES.N) {
+      int mcc = parseInt(mccStr, Integer.MAX_VALUE);
+      int mnc = parseInt(mncStr, Integer.MAX_VALUE);
+
+      return cellIdentityReflector.newCellIdentityWcdma(mcc, mnc, lac, cid, psc);
+    } else if (RuntimeEnvironment.getApiLevel() < Build.VERSION_CODES.P) {
+      int mcc = parseInt(mccStr, Integer.MAX_VALUE);
+      int mnc = parseInt(mncStr, Integer.MAX_VALUE);
+
+      return cellIdentityReflector.newCellIdentityWcdma(mcc, mnc, lac, cid, psc, uarfcn);
+    } else if (RuntimeEnvironment.getApiLevel() < Build.VERSION_CODES.R) {
+      return cellIdentityReflector.newCellIdentityWcdma(
+          lac, cid, psc, uarfcn, mccStr, mncStr, alphal, alphas);
+    } else {
+      return cellIdentityReflector.newCellIdentityWcdma(
+          lac, cid, psc, uarfcn, mccStr, mncStr, alphal, alphas, additionalPlmns, csgInfo);
+    }
+  }
+
+  /**
+   * Parses a string to an integer. Throws an {@link IllegalArgumentException} if the string cannot
+   * be parsed as an integer. This returns {@code defaultValue} if the string is null.
+   */
+  private static int parseInt(String str, int defaultValue) {
+    if (str == null) {
+      return defaultValue;
+    }
+
+    try {
+      return Integer.parseInt(str);
+    } catch (NumberFormatException e) {
+      throw new IllegalArgumentException("Failed to parse integer from string: " + str, e);
+    }
+  }
+
+  @ForType(CellIdentityWcdma.class)
+  private interface CellIdentityWcdmaReflector {
+
+    @Constructor
+    CellIdentityWcdma newCellIdentityWcdma();
+
+    @Constructor
+    CellIdentityWcdma newCellIdentityWcdma(int mcc, int mnc, int lac, int cid, int psc);
+
+    @Constructor
+    CellIdentityWcdma newCellIdentityWcdma(int mcc, int mnc, int lac, int cid, int psc, int uarfcn);
+
+    @Constructor
+    CellIdentityWcdma newCellIdentityWcdma(
+        int lac,
+        int cid,
+        int psc,
+        int uarfcn,
+        String mcc,
+        String mnc,
+        String alphal,
+        String alphas);
+
+    @Constructor
+    CellIdentityWcdma newCellIdentityWcdma(
+        int lac,
+        int cid,
+        int psc,
+        int uarfcn,
+        String mcc,
+        String mnc,
+        String alphal,
+        String alphas,
+        Collection<String> additionalPlmns,
+        ClosedSubscriberGroupInfo csgInfo);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/CellInfoGsmBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/CellInfoGsmBuilder.java
new file mode 100644
index 000000000..378c68a5a
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/CellInfoGsmBuilder.java
@@ -0,0 +1,94 @@
+package org.robolectric.shadows;
+
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.annotation.RequiresApi;
+import android.os.Build;
+import android.os.Parcel;
+import android.telephony.CellIdentityGsm;
+import android.telephony.CellInfo;
+import android.telephony.CellInfoGsm;
+import android.telephony.CellSignalStrengthGsm;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.util.reflector.Constructor;
+import org.robolectric.util.reflector.ForType;
+
+/** Builder for {@link android.telephony.CellInfoWdcma}. */
+@RequiresApi(Build.VERSION_CODES.Q)
+public class CellInfoGsmBuilder {
+
+  private boolean isRegistered = false;
+  private long timeStamp = 0L;
+  private int cellConnectionStatus = 0;
+  private CellIdentityGsm cellIdentity;
+  private CellSignalStrengthGsm cellSignalStrength;
+
+  private CellInfoGsmBuilder() {}
+
+  public static CellInfoGsmBuilder newBuilder() {
+    return new CellInfoGsmBuilder();
+  }
+
+  public CellInfoGsmBuilder setRegistered(boolean isRegistered) {
+    this.isRegistered = isRegistered;
+    return this;
+  }
+
+  public CellInfoGsmBuilder setTimeStampNanos(long timeStamp) {
+    this.timeStamp = timeStamp;
+    return this;
+  }
+
+  public CellInfoGsmBuilder setCellConnectionStatus(int cellConnectionStatus) {
+    this.cellConnectionStatus = cellConnectionStatus;
+    return this;
+  }
+
+  public CellInfoGsmBuilder setCellIdentity(CellIdentityGsm cellIdentity) {
+    this.cellIdentity = cellIdentity;
+    return this;
+  }
+
+  public CellInfoGsmBuilder setCellSignalStrength(CellSignalStrengthGsm cellSignalStrength) {
+    this.cellSignalStrength = cellSignalStrength;
+    return this;
+  }
+
+  public CellInfoGsm build() {
+    if (cellIdentity == null) {
+      cellIdentity = CellIdentityGsmBuilder.getDefaultInstance();
+    }
+    if (cellSignalStrength == null) {
+      cellSignalStrength = CellSignalStrengthGsmBuilder.getDefaultInstance();
+    }
+    // CellInfoGsm has no default constructor below T so we write it to a Parcel.
+    if (RuntimeEnvironment.getApiLevel() <= Build.VERSION_CODES.TIRAMISU) {
+      Parcel p = Parcel.obtain();
+      p.writeInt(CellInfo.TYPE_GSM);
+      p.writeInt(isRegistered ? 1 : 0);
+      p.writeLong(timeStamp);
+      p.writeInt(cellConnectionStatus);
+      cellIdentity.writeToParcel(p, 0);
+      cellSignalStrength.writeToParcel(p, 0);
+      p.setDataPosition(0);
+      CellInfoGsm cellInfoGsm = CellInfoGsm.CREATOR.createFromParcel(p);
+      p.recycle();
+      return cellInfoGsm;
+    } else {
+      return reflector(CellInfoGsmReflector.class)
+          .newCellInfoGsm(
+              cellConnectionStatus, isRegistered, timeStamp, cellIdentity, cellSignalStrength);
+    }
+  }
+
+  @ForType(CellInfoGsm.class)
+  private interface CellInfoGsmReflector {
+    @Constructor
+    CellInfoGsm newCellInfoGsm(
+        int cellConnectionStatus,
+        boolean isRegistered,
+        long timeStamp,
+        CellIdentityGsm cellIdentity,
+        CellSignalStrengthGsm cellSignalStrength);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/CellInfoLteBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/CellInfoLteBuilder.java
index 9a3af30ee..749fb0f6a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/CellInfoLteBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/CellInfoLteBuilder.java
@@ -83,7 +83,7 @@ public class CellInfoLteBuilder {
       try {
         // This reflection is highly brittle but there is currently no choice as CellConfigLte is
         // entirely @hide.
-        Class cellConfigLteClass = Class.forName("android.telephony.CellConfigLte");
+        Class<?> cellConfigLteClass = Class.forName("android.telephony.CellConfigLte");
         return cellInfoLteReflector.newCellInfoLte(
             cellConnectionStatus,
             isRegistered,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/CellInfoWcdmaBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/CellInfoWcdmaBuilder.java
new file mode 100644
index 000000000..7a37dc004
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/CellInfoWcdmaBuilder.java
@@ -0,0 +1,93 @@
+package org.robolectric.shadows;
+
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.annotation.RequiresApi;
+import android.os.Build;
+import android.os.Parcel;
+import android.telephony.CellIdentityWcdma;
+import android.telephony.CellInfoWcdma;
+import android.telephony.CellSignalStrengthWcdma;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.util.reflector.Constructor;
+import org.robolectric.util.reflector.ForType;
+
+/** Builder for {@link android.telephony.CellInfoWdcma}. */
+@RequiresApi(Build.VERSION_CODES.Q)
+public class CellInfoWcdmaBuilder {
+
+  private boolean isRegistered = false;
+  private long timeStamp = 0L;
+  private int cellConnectionStatus = 0;
+  private CellIdentityWcdma cellIdentity;
+  private CellSignalStrengthWcdma cellSignalStrength;
+
+  private CellInfoWcdmaBuilder() {}
+
+  public static CellInfoWcdmaBuilder newBuilder() {
+    return new CellInfoWcdmaBuilder();
+  }
+
+  public CellInfoWcdmaBuilder setRegistered(boolean isRegistered) {
+    this.isRegistered = isRegistered;
+    return this;
+  }
+
+  public CellInfoWcdmaBuilder setTimeStampNanos(long timeStamp) {
+    this.timeStamp = timeStamp;
+    return this;
+  }
+
+  public CellInfoWcdmaBuilder setCellConnectionStatus(int cellConnectionStatus) {
+    this.cellConnectionStatus = cellConnectionStatus;
+    return this;
+  }
+
+  public CellInfoWcdmaBuilder setCellIdentity(CellIdentityWcdma cellIdentity) {
+    this.cellIdentity = cellIdentity;
+    return this;
+  }
+
+  public CellInfoWcdmaBuilder setCellSignalStrength(CellSignalStrengthWcdma cellSignalStrength) {
+    this.cellSignalStrength = cellSignalStrength;
+    return this;
+  }
+
+  public CellInfoWcdma build() {
+    if (cellIdentity == null) {
+      cellIdentity = CellIdentityWcdmaBuilder.getDefaultInstance();
+    }
+    if (cellSignalStrength == null) {
+      cellSignalStrength = CellSignalStrengthWcdmaBuilder.getDefaultInstance();
+    }
+    // CellInfoWcdma has no default constructor below T so we write it to a Parcel.
+    if (RuntimeEnvironment.getApiLevel() <= Build.VERSION_CODES.TIRAMISU) {
+      Parcel p = Parcel.obtain();
+      p.writeInt(/* CellInfo#TYPE_WCDMA */ 4);
+      p.writeInt(isRegistered ? 1 : 0);
+      p.writeLong(timeStamp);
+      p.writeInt(cellConnectionStatus);
+      cellIdentity.writeToParcel(p, 0);
+      cellSignalStrength.writeToParcel(p, 0);
+      p.setDataPosition(0);
+      CellInfoWcdma cellInfoWcdma = CellInfoWcdma.CREATOR.createFromParcel(p);
+      p.recycle();
+      return cellInfoWcdma;
+    } else {
+      return reflector(CellInfoWcdmaReflector.class)
+          .newCellInfoWcdma(
+              cellConnectionStatus, isRegistered, timeStamp, cellIdentity, cellSignalStrength);
+    }
+  }
+
+  @ForType(CellInfoWcdma.class)
+  private interface CellInfoWcdmaReflector {
+    @Constructor
+    CellInfoWcdma newCellInfoWcdma(
+        int cellConnectionStatus,
+        boolean isRegistered,
+        long timeStamp,
+        CellIdentityWcdma cellIdentity,
+        CellSignalStrengthWcdma cellSignalStrength);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/CellSignalStrengthGsmBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/CellSignalStrengthGsmBuilder.java
new file mode 100644
index 000000000..e24227557
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/CellSignalStrengthGsmBuilder.java
@@ -0,0 +1,59 @@
+package org.robolectric.shadows;
+
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.annotation.RequiresApi;
+import android.os.Build;
+import android.telephony.CellInfo;
+import android.telephony.CellSignalStrengthGsm;
+import org.robolectric.util.reflector.Constructor;
+import org.robolectric.util.reflector.ForType;
+
+/** Builder for {@link android.telephony.CellSignalStrengthGsm} */
+@RequiresApi(Build.VERSION_CODES.Q)
+public class CellSignalStrengthGsmBuilder {
+
+  private int rssi = CellInfo.UNAVAILABLE;
+  private int ber = CellInfo.UNAVAILABLE;
+  private int timingAdvance = CellInfo.UNAVAILABLE;
+
+  private CellSignalStrengthGsmBuilder() {}
+
+  public static CellSignalStrengthGsmBuilder newBuilder() {
+    return new CellSignalStrengthGsmBuilder();
+  }
+
+  protected static CellSignalStrengthGsm getDefaultInstance() {
+    return reflector(CellSignalStrengthGsmReflector.class).newCellSignalStrength();
+  }
+
+  /** This is equivalent to {@code signalStrength} pre SDK Q. */
+  public CellSignalStrengthGsmBuilder setRssi(int rssi) {
+    this.rssi = rssi;
+    return this;
+  }
+
+  public CellSignalStrengthGsmBuilder setBer(int ber) {
+    this.ber = ber;
+    return this;
+  }
+
+  public CellSignalStrengthGsmBuilder setTimingAdvance(int timingAdvance) {
+    this.timingAdvance = timingAdvance;
+    return this;
+  }
+
+  public CellSignalStrengthGsm build() {
+    return reflector(CellSignalStrengthGsmReflector.class)
+        .newCellSignalStrength(rssi, ber, timingAdvance);
+  }
+
+  @ForType(CellSignalStrengthGsm.class)
+  private interface CellSignalStrengthGsmReflector {
+    @Constructor
+    CellSignalStrengthGsm newCellSignalStrength();
+
+    @Constructor
+    CellSignalStrengthGsm newCellSignalStrength(int rssi, int ber, int timingAdvance);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/CellSignalStrengthWcdmaBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/CellSignalStrengthWcdmaBuilder.java
new file mode 100644
index 000000000..9e7359966
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/CellSignalStrengthWcdmaBuilder.java
@@ -0,0 +1,65 @@
+package org.robolectric.shadows;
+
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.annotation.RequiresApi;
+import android.os.Build;
+import android.telephony.CellInfo;
+import android.telephony.CellSignalStrengthWcdma;
+import org.robolectric.util.reflector.Constructor;
+import org.robolectric.util.reflector.ForType;
+
+/** Builder for {@link android.telephony.CellSignalStrengthWcdma} */
+@RequiresApi(Build.VERSION_CODES.Q)
+public class CellSignalStrengthWcdmaBuilder {
+
+  private int rssi = CellInfo.UNAVAILABLE;
+  private int ber = CellInfo.UNAVAILABLE;
+  private int rscp = CellInfo.UNAVAILABLE;
+  private int ecno = CellInfo.UNAVAILABLE;
+
+  private CellSignalStrengthWcdmaBuilder() {}
+
+  public static CellSignalStrengthWcdmaBuilder newBuilder() {
+    return new CellSignalStrengthWcdmaBuilder();
+  }
+
+  protected static CellSignalStrengthWcdma getDefaultInstance() {
+    return reflector(CellSignalStrengthWcdmaReflector.class).newCellSignalStrength();
+  }
+
+  /** This is equivalent to {@code signalStrength} pre SDK Q. */
+  public CellSignalStrengthWcdmaBuilder setRssi(int rssi) {
+    this.rssi = rssi;
+    return this;
+  }
+
+  public CellSignalStrengthWcdmaBuilder setBer(int ber) {
+    this.ber = ber;
+    return this;
+  }
+
+  public CellSignalStrengthWcdmaBuilder setRscp(int rscp) {
+    this.rscp = rscp;
+    return this;
+  }
+
+  public CellSignalStrengthWcdmaBuilder setEcno(int ecno) {
+    this.ecno = ecno;
+    return this;
+  }
+
+  public CellSignalStrengthWcdma build() {
+    return reflector(CellSignalStrengthWcdmaReflector.class)
+        .newCellSignalStrength(rssi, ber, rscp, ecno);
+  }
+
+  @ForType(CellSignalStrengthWcdma.class)
+  private interface CellSignalStrengthWcdmaReflector {
+    @Constructor
+    CellSignalStrengthWcdma newCellSignalStrength();
+
+    @Constructor
+    CellSignalStrengthWcdma newCellSignalStrength(int rssi, int ber, int rscp, int ecno);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ClassNameResolver.java b/shadows/framework/src/main/java/org/robolectric/shadows/ClassNameResolver.java
index e88d8c09a..4bab144f9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ClassNameResolver.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ClassNameResolver.java
@@ -1,6 +1,6 @@
 package org.robolectric.shadows;
 
-public class ClassNameResolver<T> {
+public class ClassNameResolver {
 
   public static <T> Class<T> resolve(String packageName, String className)
       throws ClassNotFoundException {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/EmergencyNumberBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/EmergencyNumberBuilder.java
index 45ede54c0..1cf2b5dfa 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/EmergencyNumberBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/EmergencyNumberBuilder.java
@@ -19,7 +19,7 @@ public class EmergencyNumberBuilder {
   private final String number;
   private final String countryIso;
   private final String mnc;
-  private final List<String> emergencyUrns = new ArrayList<String>();
+  private final List<String> emergencyUrns = new ArrayList<>();
   private int emergencyServiceCategories = EmergencyNumber.EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED;
   private int emergencyNumberSources = EmergencyNumber.EMERGENCY_NUMBER_SOURCE_DEFAULT;
   private int emergencyCallRouting = EmergencyNumber.EMERGENCY_CALL_ROUTING_UNKNOWN;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/EpsBearerQosSessionAttributesBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/EpsBearerQosSessionAttributesBuilder.java
index d3288c198..37c2983be 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/EpsBearerQosSessionAttributesBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/EpsBearerQosSessionAttributesBuilder.java
@@ -1,6 +1,6 @@
 package org.robolectric.shadows;
 
-import android.annotation.TargetApi;
+import android.annotation.RequiresApi;
 import android.os.Build.VERSION_CODES;
 import android.telephony.data.EpsBearerQosSessionAttributes;
 import java.net.InetSocketAddress;
@@ -8,7 +8,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 /** Class to build {@link EpsBearerQosSessionAttributes}. */
-@TargetApi(VERSION_CODES.S)
+@RequiresApi(VERSION_CODES.S)
 public final class EpsBearerQosSessionAttributesBuilder {
 
   private int qci;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/FrameMetricsBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/FrameMetricsBuilder.java
index 6cbff6d0a..25b8c2a62 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/FrameMetricsBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/FrameMetricsBuilder.java
@@ -75,7 +75,7 @@ public final class FrameMetricsBuilder {
     timingData[getStartIndexForMetric(FrameMetrics.SYNC_DURATION)] =
         timingData[getEndIndexForMetric(FrameMetrics.DRAW_DURATION)] + syncDelayTimeNanos;
 
-    // Finally we calculate the remainder of the durations after enqueing the sync.
+    // Finally we calculate the remainder of the durations after enqueuing the sync.
     // Note that we don't directly compute the value for TOTAL_DURATION, as it's generated from the
     // start of UNKNOWN_DELAY_DURATION to the end of SWAP_BUFFERS_DURATION.
     for (@Metric int metric = FrameMetrics.SYNC_DURATION; metric < getMetricsCount(); metric++) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/HardwareRenderingScreenshot.java b/shadows/framework/src/main/java/org/robolectric/shadows/HardwareRenderingScreenshot.java
index e01930a4e..031a213b7 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/HardwareRenderingScreenshot.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/HardwareRenderingScreenshot.java
@@ -19,10 +19,11 @@ import android.view.Surface;
 import android.view.View;
 import android.view.ViewRootImpl;
 import com.android.internal.R;
-import com.google.common.base.Preconditions;
+import java.util.Objects;
 import java.util.WeakHashMap;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
 
 /**
@@ -38,6 +39,8 @@ public final class HardwareRenderingScreenshot {
 
   static final String PIXEL_COPY_RENDER_MODE = "robolectric.pixelCopyRenderMode";
 
+  static final String USE_EMBEDDED_VIEW_ROOT = "robolectric.useEmbeddedViewRoot";
+
   private HardwareRenderingScreenshot() {}
 
   /**
@@ -65,13 +68,23 @@ public final class HardwareRenderingScreenshot {
     try (ImageReader imageReader =
         ImageReader.newInstance(width, height, PixelFormat.RGBA_8888, 1)) {
       ViewRootImpl viewRootImpl = view.getViewRootImpl();
-      Preconditions.checkNotNull(viewRootImpl, "View not attached");
+      Objects.requireNonNull(viewRootImpl, "View not attached");
       Surface surface = imageReader.getSurface();
 
       if (RuntimeEnvironment.getApiLevel() >= Q) {
         // HardwareRenderer is only available on API 29+ (Q).
         HardwareRenderer renderer =
-            hardwareRenderers.computeIfAbsent(viewRootImpl, k -> new HardwareRenderer());
+            hardwareRenderers.computeIfAbsent(
+                viewRootImpl,
+                k -> {
+                  if (Boolean.parseBoolean(System.getProperty(USE_EMBEDDED_VIEW_ROOT, "false"))) {
+                    ShadowViewRootImpl shadowViewRootImpl = Shadow.extract(viewRootImpl);
+                    return shadowViewRootImpl.getThreadedRenderer();
+                  } else {
+                    return new HardwareRenderer();
+                  }
+                });
+
         renderer.setSurface(surface);
         setupRendererShadowProperties(renderer, view);
         RenderNode node = getRenderNode(view);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/HealthStatsBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/HealthStatsBuilder.java
index 300a21b79..de59e20bd 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/HealthStatsBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/HealthStatsBuilder.java
@@ -72,7 +72,7 @@ final class HealthStatsBuilder {
    */
   @CanIgnoreReturnValue
   public HealthStatsBuilder addStats(int key, ArrayMap<String, HealthStats> value) {
-    statsMap.put(key, new ArrayMap<String, HealthStats>(value));
+    statsMap.put(key, new ArrayMap<>(value));
     return this;
   }
 
@@ -82,7 +82,7 @@ final class HealthStatsBuilder {
    */
   @CanIgnoreReturnValue
   public HealthStatsBuilder addTimers(int key, ArrayMap<String, TimerStat> value) {
-    timersMap.put(key, new ArrayMap<String, TimerStat>(value));
+    timersMap.put(key, new ArrayMap<>(value));
     return this;
   }
 
@@ -92,7 +92,7 @@ final class HealthStatsBuilder {
    */
   @CanIgnoreReturnValue
   public HealthStatsBuilder addMeasurements(int key, ArrayMap<String, Long> value) {
-    measurementsMap.put(key, new ArrayMap<String, Long>(value));
+    measurementsMap.put(key, new ArrayMap<>(value));
     return this;
   }
 
@@ -201,7 +201,7 @@ final class HealthStatsBuilder {
   }
 
   @VisibleForTesting
-  static final int[] toSortedIntArray(Set<Integer> set) {
+  static int[] toSortedIntArray(Set<Integer> set) {
     int[] result = new int[set.size()];
     Object[] inputObjArray = set.toArray();
     for (int i = 0; i < inputObjArray.length; i++) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/IBluetoothManagerDelegates.java b/shadows/framework/src/main/java/org/robolectric/shadows/IBluetoothManagerDelegates.java
index f15d560a9..6a07c5d0b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/IBluetoothManagerDelegates.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/IBluetoothManagerDelegates.java
@@ -1,7 +1,7 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.TIRAMISU;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothProfile;
@@ -47,8 +47,8 @@ class IBluetoothManagerDelegates {
   private static class IBluetoothManagerDelegateS extends IBluetoothManagerDelegateBase {
 
     public IBluetooth registerAdapter(IBluetoothManagerCallback callback) {
-      IBinder btBinder = checkNotNull(ServiceManager.getService(Context.BLUETOOTH_SERVICE));
-      IBluetooth btService = checkNotNull(IBluetooth.Stub.asInterface(btBinder));
+      IBinder btBinder = requireNonNull(ServiceManager.getService(Context.BLUETOOTH_SERVICE));
+      IBluetooth btService = requireNonNull(IBluetooth.Stub.asInterface(btBinder));
       Reflector.reflector(IBluetoothManagerCallbackReflectorS.class, callback)
           .onBluetoothServiceUp(btService);
       return btService;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/LauncherAppsDelegate.java b/shadows/framework/src/main/java/org/robolectric/shadows/LauncherAppsDelegate.java
index 431c7e81e..0741fc427 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/LauncherAppsDelegate.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/LauncherAppsDelegate.java
@@ -1,5 +1,6 @@
 package org.robolectric.shadows;
 
+import android.content.pm.ILauncherApps;
 import android.os.UserHandle;
 import android.os.UserManager;
 import java.util.List;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/LooperShadowPicker.java b/shadows/framework/src/main/java/org/robolectric/shadows/LooperShadowPicker.java
index 56a8fc9ee..5ac07b15f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/LooperShadowPicker.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/LooperShadowPicker.java
@@ -4,8 +4,8 @@ import org.robolectric.shadow.api.ShadowPicker;
 
 public class LooperShadowPicker<T> implements ShadowPicker<T> {
 
-  private Class<? extends T> legacyShadowClass;
-  private Class<? extends T> pausedShadowClass;
+  private final Class<? extends T> legacyShadowClass;
+  private final Class<? extends T> pausedShadowClass;
 
   public LooperShadowPicker(
       Class<? extends T> legacyShadowClass, Class<? extends T> pausedShadowClass) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/MediaCodecInfoBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/MediaCodecInfoBuilder.java
index 9d3afb373..06ab01a34 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/MediaCodecInfoBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/MediaCodecInfoBuilder.java
@@ -2,6 +2,7 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.Q;
 import static java.util.Arrays.asList;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.media.MediaCodecInfo;
 import android.media.MediaCodecInfo.AudioCapabilities;
@@ -13,13 +14,15 @@ import android.media.MediaFormat;
 import android.util.Range;
 import com.google.common.base.Preconditions;
 import java.util.HashSet;
+import java.util.Objects;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
-import org.robolectric.util.reflector.Reflector;
 import org.robolectric.util.reflector.Static;
+import org.robolectric.util.reflector.WithType;
+import org.robolectric.versioning.AndroidVersions.Baklava;
 
 /** Builder for {@link MediaCodecInfo}. */
 public class MediaCodecInfoBuilder {
@@ -45,7 +48,7 @@ public class MediaCodecInfoBuilder {
    * @throws NullPointerException if name is null.
    */
   public MediaCodecInfoBuilder setName(String name) {
-    this.name = Preconditions.checkNotNull(name);
+    this.name = Objects.requireNonNull(name);
     return this;
   }
 
@@ -72,7 +75,7 @@ public class MediaCodecInfoBuilder {
   }
 
   /**
-   * Sets whether the codec is softwrare only or not.
+   * Sets whether the codec is software only or not.
    *
    * @param isSoftwareOnly a boolean to indicate whether the codec is software only {@code true} or
    *     not {@code false}. Default value is {@code false}.
@@ -108,7 +111,7 @@ public class MediaCodecInfoBuilder {
   }
 
   public MediaCodecInfo build() {
-    Preconditions.checkNotNull(name, "Codec name is not set.");
+    Objects.requireNonNull(name, "Codec name is not set.");
 
     if (RuntimeEnvironment.getApiLevel() >= Q) {
       int flags = getCodecFlags();
@@ -150,8 +153,7 @@ public class MediaCodecInfoBuilder {
 
   /** Convert the boolean flags describing codec to values recognized by {@link MediaCodecInfo}. */
   private int getCodecFlags() {
-    MediaCodecInfoReflector mediaCodecInfoReflector =
-        Reflector.reflector(MediaCodecInfoReflector.class);
+    MediaCodecInfoReflector mediaCodecInfoReflector = reflector(MediaCodecInfoReflector.class);
 
     int flags = 0;
 
@@ -190,18 +192,17 @@ public class MediaCodecInfoBuilder {
      * Sets media format.
      *
      * @param mediaFormat a {@link MediaFormat} supported by the codec. It is a requirement for
-     *     mediaFormat to have {@link MediaFormat.KEY_MIME} set. Other keys are optional. Setting
-     *     {@link MediaFormat.KEY_WIDTH}, {@link MediaFormat.KEY_MAX_WIDTH} and {@link
-     *     MediaFormat.KEY_HEIGHT}, {@link MediaFormat.KEY_MAX_HEIGHT} will set the minimum and
+     *     mediaFormat to have {@link MediaFormat#KEY_MIME} set. Other keys are optional. Setting
+     *     {@link MediaFormat#KEY_WIDTH}, {@link MediaFormat#KEY_MAX_WIDTH} and {@link
+     *     MediaFormat#KEY_HEIGHT}, {@link MediaFormat#KEY_MAX_HEIGHT} will set the minimum and
      *     maximum width, height respectively. For backwards compatibility, setting only {@link
-     *     MediaFormat.KEY_WIDTH}, {@link MediaFormat.KEY_HEIGHT} will only set the maximum width,
+     *     MediaFormat#KEY_WIDTH}, {@link MediaFormat#KEY_HEIGHT} will only set the maximum width,
      *     height respectively.
-     * @throws {@link NullPointerException} if mediaFormat is null.
-     * @throws {@link IllegalArgumentException} if mediaFormat does not have {@link
-     *     MediaFormat.KEY_MIME}.
+     * @throws NullPointerException if mediaFormat is null.
+     * @throws IllegalArgumentException if mediaFormat does not have {@link MediaFormat#KEY_MIME}.
      */
     public CodecCapabilitiesBuilder setMediaFormat(MediaFormat mediaFormat) {
-      Preconditions.checkNotNull(mediaFormat);
+      Objects.requireNonNull(mediaFormat);
       Preconditions.checkArgument(
           mediaFormat.getString(MediaFormat.KEY_MIME) != null,
           "MIME type of the format is not set.");
@@ -238,7 +239,7 @@ public class MediaCodecInfoBuilder {
      * @throws NullPointerException if profileLevels is null.
      */
     public CodecCapabilitiesBuilder setProfileLevels(CodecProfileLevel[] profileLevels) {
-      this.profileLevels = Preconditions.checkNotNull(profileLevels);
+      this.profileLevels = Objects.requireNonNull(profileLevels);
       return this;
     }
 
@@ -283,8 +284,15 @@ public class MediaCodecInfoBuilder {
 
       @Accessor("mFlagsRequired")
       void setFlagsRequired(int flagsRequired);
+
+      @Accessor("mImpl")
+      Object getImpl();
     }
 
+    // for post-Baklava
+    @ForType(className = "android.media.MediaCodecInfo$CodecCapabilities$CodecCapsLegacyImpl")
+    interface CodecCapabilitiesLegacyImplReflector extends CodecCapabilitiesReflector {}
+
     /** Accessor interface for {@link VideoCapabilities}'s internals. */
     @ForType(VideoCapabilities.class)
     interface VideoCapabilitiesReflector {
@@ -294,28 +302,76 @@ public class MediaCodecInfoBuilder {
 
       @Accessor("mHeightRange")
       void setHeightRange(Range<Integer> range);
+
+      @Static
+      VideoCapabilities create(MediaFormat mediaFormat, CodecCapabilities parent);
+
+      // for post-Baklava
+      @Static
+      VideoCapabilities create(
+          MediaFormat info,
+          @WithType("android.media.MediaCodecInfo$CodecCapabilities$CodecCapsLegacyImpl")
+              Object capabilitiesImpl);
+
+      @Accessor("mImpl")
+      Object getImpl();
+    }
+
+    // for post-Baklava
+    @ForType(className = "android.media.MediaCodecInfo$VideoCapabilities$VideoCapsLegacyImpl")
+    interface VideoCapsLegacyImplReflector extends VideoCapabilitiesReflector {}
+
+    @ForType(AudioCapabilities.class)
+    interface AudioCapabilitiesReflector {
+      @Static
+      AudioCapabilities create(MediaFormat info, CodecCapabilities capabilities);
+
+      // for post-Baklava
+      @Static
+      AudioCapabilities create(
+          MediaFormat info,
+          @WithType("android.media.MediaCodecInfo$CodecCapabilities$CodecCapsLegacyImpl")
+              Object capabilitiesImpl);
+    }
+
+    @ForType(EncoderCapabilities.class)
+    interface EncoderCapabilitiesReflector {
+      @Static
+      EncoderCapabilities create(MediaFormat info, CodecCapabilities capabilities);
+
+      // for post-Baklava
+      @Static
+      EncoderCapabilities create(
+          MediaFormat info,
+          @WithType("android.media.MediaCodecInfo$CodecCapabilities$CodecCapsLegacyImpl")
+              Object capabilitiesImpl);
     }
 
     public CodecCapabilities build() {
-      Preconditions.checkNotNull(mediaFormat, "mediaFormat is not set.");
-      Preconditions.checkNotNull(profileLevels, "profileLevels is not set.");
+      Objects.requireNonNull(mediaFormat, "mediaFormat is not set.");
+      Objects.requireNonNull(profileLevels, "profileLevels is not set.");
 
       final String mime = mediaFormat.getString(MediaFormat.KEY_MIME);
       final boolean isVideoCodec = mime.startsWith("video/");
 
       CodecCapabilities caps = new CodecCapabilities();
-      CodecCapabilitiesReflector capsReflector =
-          Reflector.reflector(CodecCapabilitiesReflector.class, caps);
-
       caps.profileLevels = profileLevels;
       if (isVideoCodec) {
-        Preconditions.checkNotNull(colorFormats, "colorFormats should not be null for video codec");
+        Objects.requireNonNull(colorFormats, "colorFormats should not be null for video codec");
         caps.colorFormats = colorFormats;
       } else {
         Preconditions.checkArgument(
             colorFormats == null || colorFormats.length == 0,
             "colorFormats should not be set for audio codec");
-        caps.colorFormats = new int[0]; // To prevet crash in CodecCapabilities.dup().
+        caps.colorFormats = new int[0]; // To prevent crash in CodecCapabilities.dup().
+      }
+      CodecCapabilitiesReflector capsReflector = reflector(CodecCapabilitiesReflector.class, caps);
+      if (RuntimeEnvironment.getApiLevel() > Baklava.SDK_INT) {
+        // data has moved to an Impl class
+        Object impl = capsReflector.getImpl();
+        capsReflector = reflector(CodecCapabilitiesLegacyImplReflector.class, impl);
+        ReflectionHelpers.setField(impl, "mProfileLevels", profileLevels);
+        ReflectionHelpers.setField(impl, "mColorFormats", caps.colorFormats);
       }
 
       capsReflector.setMime(mime);
@@ -329,7 +385,12 @@ public class MediaCodecInfoBuilder {
       if (isVideoCodec) {
         VideoCapabilities videoCaps = createDefaultVideoCapabilities(caps, mediaFormat);
         VideoCapabilitiesReflector videoCapsReflector =
-            Reflector.reflector(VideoCapabilitiesReflector.class, videoCaps);
+            reflector(VideoCapabilitiesReflector.class, videoCaps);
+        if (RuntimeEnvironment.getApiLevel() > Baklava.SDK_INT) {
+          // data has moved to an Impl class
+          Object impl = videoCapsReflector.getImpl();
+          videoCapsReflector = reflector(VideoCapsLegacyImplReflector.class, impl);
+        }
         if (mediaFormat.containsKey(MediaFormat.KEY_MAX_WIDTH)
             && mediaFormat.containsKey(MediaFormat.KEY_WIDTH)) {
           videoCapsReflector.setWidthRange(
@@ -376,31 +437,34 @@ public class MediaCodecInfoBuilder {
     /** Create a default {@link AudioCapabilities} for a given {@link MediaFormat}. */
     private static AudioCapabilities createDefaultAudioCapabilities(
         CodecCapabilities parent, MediaFormat mediaFormat) {
-      return ReflectionHelpers.callStaticMethod(
-          AudioCapabilities.class,
-          "create",
-          ClassParameter.from(MediaFormat.class, mediaFormat),
-          ClassParameter.from(CodecCapabilities.class, parent));
+      if (RuntimeEnvironment.getApiLevel() <= Baklava.SDK_INT) {
+        return reflector(AudioCapabilitiesReflector.class).create(mediaFormat, parent);
+      } else {
+        Object impl = reflector(CodecCapabilitiesReflector.class, parent).getImpl();
+        return reflector(AudioCapabilitiesReflector.class).create(mediaFormat, impl);
+      }
     }
 
     /** Create a default {@link VideoCapabilities} for a given {@link MediaFormat}. */
     private static VideoCapabilities createDefaultVideoCapabilities(
         CodecCapabilities parent, MediaFormat mediaFormat) {
-      return ReflectionHelpers.callStaticMethod(
-          VideoCapabilities.class,
-          "create",
-          ClassParameter.from(MediaFormat.class, mediaFormat),
-          ClassParameter.from(CodecCapabilities.class, parent));
+      if (RuntimeEnvironment.getApiLevel() <= Baklava.SDK_INT) {
+        return reflector(VideoCapabilitiesReflector.class).create(mediaFormat, parent);
+      } else {
+        Object impl = reflector(CodecCapabilitiesReflector.class, parent).getImpl();
+        return reflector(VideoCapabilitiesReflector.class).create(mediaFormat, impl);
+      }
     }
 
     /** Create a default {@link EncoderCapabilities} for a given {@link MediaFormat}. */
     private static EncoderCapabilities createDefaultEncoderCapabilities(
         CodecCapabilities parent, MediaFormat mediaFormat) {
-      return ReflectionHelpers.callStaticMethod(
-          EncoderCapabilities.class,
-          "create",
-          ClassParameter.from(MediaFormat.class, mediaFormat),
-          ClassParameter.from(CodecCapabilities.class, parent));
+      if (RuntimeEnvironment.getApiLevel() <= Baklava.SDK_INT) {
+        return reflector(EncoderCapabilitiesReflector.class).create(mediaFormat, parent);
+      } else {
+        Object impl = reflector(CodecCapabilitiesReflector.class, parent).getImpl();
+        return reflector(EncoderCapabilitiesReflector.class).create(mediaFormat, impl);
+      }
     }
 
     /**
@@ -409,10 +473,10 @@ public class MediaCodecInfoBuilder {
      */
     private static int getSupportedFeatures(CodecCapabilities parent, MediaFormat mediaFormat) {
       int flagsSupported = 0;
-      Object[] validFeatures = ReflectionHelpers.callInstanceMethod(parent, "getValidFeatures");
+      Object[] validFeatures = getValidFeatures(parent);
       for (Object validFeature : validFeatures) {
-        String featureName = (String) ReflectionHelpers.getField(validFeature, "mName");
-        int featureValue = (int) ReflectionHelpers.getField(validFeature, "mValue");
+        String featureName = ReflectionHelpers.getField(validFeature, "mName");
+        int featureValue = ReflectionHelpers.getField(validFeature, "mValue");
         if (mediaFormat.containsFeature(featureName)
             && mediaFormat.getFeatureEnabled(featureName)) {
           flagsSupported |= featureValue;
@@ -427,16 +491,27 @@ public class MediaCodecInfoBuilder {
      */
     private static int getRequiredFeatures(CodecCapabilities parent, String[] requiredFeatures) {
       int flagsRequired = 0;
-      Object[] validFeatures = ReflectionHelpers.callInstanceMethod(parent, "getValidFeatures");
+      Object[] validFeatures = getValidFeatures(parent);
       HashSet<String> requiredFeaturesSet = new HashSet<>(asList(requiredFeatures));
       for (Object validFeature : validFeatures) {
-        String featureName = (String) ReflectionHelpers.getField(validFeature, "mName");
-        int featureValue = (int) ReflectionHelpers.getField(validFeature, "mValue");
+        String featureName = ReflectionHelpers.getField(validFeature, "mName");
+        int featureValue = ReflectionHelpers.getField(validFeature, "mValue");
         if (requiredFeaturesSet.contains(featureName)) {
           flagsRequired |= featureValue;
         }
       }
       return flagsRequired;
     }
+
+    private static Object[] getValidFeatures(CodecCapabilities parent) {
+      Object[] validFeatures;
+      if (RuntimeEnvironment.getApiLevel() <= Baklava.SDK_INT) {
+        validFeatures = ReflectionHelpers.callInstanceMethod(parent, "getValidFeatures");
+      } else {
+        Object impl = reflector(CodecCapabilitiesReflector.class, parent).getImpl();
+        validFeatures = ReflectionHelpers.callInstanceMethod(impl, "getValidFeatures");
+      }
+      return validFeatures;
+    }
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ModuleInfoBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/ModuleInfoBuilder.java
index 1f9ade2ee..83daa5a7a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ModuleInfoBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ModuleInfoBuilder.java
@@ -1,6 +1,6 @@
 package org.robolectric.shadows;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import android.content.pm.ModuleInfo;
 import javax.annotation.Nullable;
@@ -50,8 +50,8 @@ public final class ModuleInfoBuilder {
    */
   public ModuleInfo build() {
     // Check mandatory fields.
-    checkNotNull(name, "Mandatory field 'name' missing.");
-    checkNotNull(packageName, "Mandatory field 'packageName' missing.");
+    requireNonNull(name, "Mandatory field 'name' missing.");
+    requireNonNull(packageName, "Mandatory field 'packageName' missing.");
 
     ModuleInfo moduleInfo = new ModuleInfo();
     moduleInfo.setName(name);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/NativeAndroidInput.java b/shadows/framework/src/main/java/org/robolectric/shadows/NativeAndroidInput.java
index 83fa45aa4..f14ec0da9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/NativeAndroidInput.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/NativeAndroidInput.java
@@ -332,7 +332,7 @@ public class NativeAndroidInput {
    * relation to the maximum detectable size for the device. The value is normalized to a range from
    * 0 (smallest detectable size) to 1 (largest detectable size); although it is not a linear scale.
    * This value is of limited use. To obtain calibrated size information; see {@link
-   * AMOTION_EVENT_AXIS_TOUCH_MAJOR} or {@link AMOTION_EVENT_AXIS_TOOL_MAJOR}.
+   * #AMOTION_EVENT_AXIS_TOUCH_MAJOR} or {@link #AMOTION_EVENT_AXIS_TOOL_MAJOR}.
    */
   static final int AMOTION_EVENT_AXIS_SIZE = 3;
 
@@ -400,7 +400,7 @@ public class NativeAndroidInput {
    * a stylus; the orientation indicates the direction in which the stylus is pointing in relation
    * to the vertical axis of the current orientation of the screen. The range is from -PI radians to
    * PI radians; where 0 is pointing up; -PI/2 radians is pointing left; -PI or PI radians is
-   * pointing down; and PI/2 radians is pointing right. See also {@link AMOTION_EVENT_AXIS_TILT}.
+   * pointing down; and PI/2 radians is pointing right. See also {@link #AMOTION_EVENT_AXIS_TILT}.
    */
   static final int AMOTION_EVENT_AXIS_ORIENTATION = 8;
 
@@ -568,7 +568,7 @@ public class NativeAndroidInput {
   /**
    * Axis constant: The movement of y position of a motion event.
    *
-   * <p>Same as {@link RELATIVE_X}; but for y position.
+   * <p>Same as {@link #AMOTION_EVENT_AXIS_RELATIVE_X}; but for y position.
    */
   static final int AMOTION_EVENT_AXIS_RELATIVE_Y = 28;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/NativeInput.java b/shadows/framework/src/main/java/org/robolectric/shadows/NativeInput.java
index 408f94aea..329997744 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/NativeInput.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/NativeInput.java
@@ -51,7 +51,7 @@ public class NativeInput {
   /*
    * Maximum number of pointers supported per motion event.
    * Smallest number of pointers is 1.
-   * (We want at least 10 but some touch controllers obstensibly configured for 10 pointers
+   * (We want at least 10 but some touch controllers ostensibly configured for 10 pointers
    * will occasionally emit 11.  There is not much harm making this ant bigger.)
    */
   private static final int MAX_POINTERS = 16;
@@ -89,7 +89,7 @@ public class NativeInput {
     }
 
     // Values of axes that are stored in this structure
-    private float[] values = new float[MAX_AXES];
+    private final float[] values = new float[MAX_AXES];
 
     public void clear() {
       bits.clear();
@@ -188,8 +188,8 @@ public class NativeInput {
     public void copyFrom(PointerCoords other) {
       bits = new NativeBitSet64(other.bits);
       int count = bits.count();
-      for (int i = 0; i < count; i++) {
-        values[i] = other.values[i];
+      if (count >= 0) {
+        System.arraycopy(other.values, 0, values, 0, count);
       }
     }
 
@@ -653,23 +653,21 @@ public class NativeInput {
           resolveActionForSplitMotionEvent(
               getAction(), getFlags(), pp, splitPointerPropertiesArray);
 
-      android.view.MotionEvent newEvent =
-          android.view.MotionEvent.obtain(
-              getDownTime(),
-              getEventTime(),
-              splitAction,
-              splitPointerProperties.size(),
-              splitPointerPropertiesArray,
-              splitPointerCoordsArray,
-              getMetaState(),
-              getButtonState(),
-              getXPrecision(),
-              getYPrecision(),
-              getDeviceId(),
-              getEdgeFlags(),
-              getSource(),
-              getFlags());
-      return newEvent;
+      return android.view.MotionEvent.obtain(
+          getDownTime(),
+          getEventTime(),
+          splitAction,
+          splitPointerProperties.size(),
+          splitPointerPropertiesArray,
+          splitPointerCoordsArray,
+          getMetaState(),
+          getButtonState(),
+          getXPrecision(),
+          getYPrecision(),
+          getDeviceId(),
+          getEdgeFlags(),
+          getSource(),
+          getFlags());
     }
 
     public int findPointerIndex(int pointerId) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/NetworkRegistrationInfoTestBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/NetworkRegistrationInfoTestBuilder.java
index c3e1eac10..00570203b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/NetworkRegistrationInfoTestBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/NetworkRegistrationInfoTestBuilder.java
@@ -130,9 +130,9 @@ public class NetworkRegistrationInfoTestBuilder {
   private interface NetworkRegistrationInfoReflector {
 
     @Accessor("mDataSpecificInfo")
-    public void setDataSpecificInfo(DataSpecificRegistrationInfo value);
+    void setDataSpecificInfo(DataSpecificRegistrationInfo value);
 
     @Accessor("mVoiceSpecificInfo")
-    public void setVoiceSpecificInfo(VoiceSpecificRegistrationInfo value);
+    void setVoiceSpecificInfo(VoiceSpecificRegistrationInfo value);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/NrQosSessionAttributesBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/NrQosSessionAttributesBuilder.java
index 38d19901c..e49fea69c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/NrQosSessionAttributesBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/NrQosSessionAttributesBuilder.java
@@ -1,6 +1,6 @@
 package org.robolectric.shadows;
 
-import android.annotation.TargetApi;
+import android.annotation.RequiresApi;
 import android.os.Build.VERSION_CODES;
 import android.telephony.data.NrQosSessionAttributes;
 import java.net.InetSocketAddress;
@@ -8,7 +8,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 /** Class to build {@link NrQosSessionAttributes}. */
-@TargetApi(VERSION_CODES.S)
+@RequiresApi(VERSION_CODES.S)
 public final class NrQosSessionAttributesBuilder {
 
   private int fiveQi;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/PackageRollbackInfoBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/PackageRollbackInfoBuilder.java
index 5f371f6df..d488970a7 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/PackageRollbackInfoBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/PackageRollbackInfoBuilder.java
@@ -1,7 +1,7 @@
 package org.robolectric.shadows;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 
 import android.content.pm.VersionedPackage;
 import android.content.rollback.PackageRollbackInfo;
@@ -93,7 +93,7 @@ public final class PackageRollbackInfoBuilder {
 
   /** Sets ce snapshot inodes. */
   public PackageRollbackInfoBuilder setCeSnapshotInodes(SparseLongArray ceSnapshotInodes) {
-    checkNotNull(ceSnapshotInodes, "Field 'packageRolledBackFrom' not allowed to be null.");
+    requireNonNull(ceSnapshotInodes, "Field 'packageRolledBackFrom' not allowed to be null.");
     this.ceSnapshotInodes = ceSnapshotInodes;
     return this;
   }
@@ -117,8 +117,8 @@ public final class PackageRollbackInfoBuilder {
   /** Returns a {@link PackageRollbackInfo} with the data that was given. */
   public PackageRollbackInfo build() {
     // Check mandatory fields.
-    checkNotNull(packageRolledBackFrom, "Mandatory field 'packageRolledBackFrom' missing.");
-    checkNotNull(packageRolledBackTo, "Mandatory field 'packageRolledBackTo' missing.");
+    requireNonNull(packageRolledBackFrom, "Mandatory field 'packageRolledBackFrom' missing.");
+    requireNonNull(packageRolledBackTo, "Mandatory field 'packageRolledBackTo' missing.");
     checkState(RuntimeEnvironment.getApiLevel() >= VERSION_CODES.Q);
 
     int apiLevel = RuntimeEnvironment.getApiLevel();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/PolicyStateBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/PolicyStateBuilder.java
index ad035bf15..026413037 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/PolicyStateBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/PolicyStateBuilder.java
@@ -13,13 +13,12 @@ import org.robolectric.util.reflector.ForType;
 
 /** Builder for {@link PolicyState} */
 public class PolicyStateBuilder {
-  private Map<EnforcingAdmin, PolicyValue<?>> policiesSetByAdmins =
-      new LinkedHashMap<EnforcingAdmin, PolicyValue<?>>();
+  private final Map<EnforcingAdmin, PolicyValue<?>> policiesSetByAdmins = new LinkedHashMap<>();
   private PolicyValue<?> currentResolvedPolicy;
 
   private PolicyStateBuilder() {}
 
-  private PolicyState<?> policyState = reflector(PolicyStateReflector.class).newPolicyState();
+  private final PolicyState<?> policyState = reflector(PolicyStateReflector.class).newPolicyState();
 
   public static PolicyStateBuilder newBuilder() {
     return new PolicyStateBuilder();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/Provider.java b/shadows/framework/src/main/java/org/robolectric/shadows/Provider.java
deleted file mode 100644
index 41a364603..000000000
--- a/shadows/framework/src/main/java/org/robolectric/shadows/Provider.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package org.robolectric.shadows;
-
-public interface Provider<T> {
-  T get();
-}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper.java b/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper.java
index 53c2d6556..2f12e66db 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper.java
@@ -48,7 +48,7 @@ public final class ResourceHelper {
    */
   public static int getColor(String value) {
     if (value != null) {
-      if (value.startsWith("#") == false) {
+      if (!value.startsWith("#")) {
         throw new NumberFormatException(String.format("Color value '%s' must start with #", value));
       }
 
@@ -182,13 +182,13 @@ public final class ResourceHelper {
    */
   public static boolean parseFloatAttribute(
       String attribute, String value, TypedValue outValue, boolean requireUnit) {
-    assert requireUnit == false || attribute != null;
+    assert !requireUnit || attribute != null;
 
     // remove the space before and after
     value = value.trim();
     int len = value.length();
 
-    if (len <= 0) {
+    if (len == 0) {
       return false;
     }
 
@@ -230,7 +230,7 @@ public final class ResourceHelper {
         return false;
       }
 
-      if (end.length() > 0 && end.charAt(0) != ' ') {
+      if (!end.isEmpty() && end.charAt(0) != ' ') {
         // Might be a unit...
         if (parseUnit(end, outValue, sFloatOut)) {
           computeTypedValue(outValue, f, sFloatOut[0]);
@@ -242,12 +242,12 @@ public final class ResourceHelper {
       // make sure it's only spaces at the end.
       end = end.trim();
 
-      if (end.length() == 0) {
+      if (end.isEmpty()) {
         if (outValue != null) {
           outValue.assetCookie = 0;
           outValue.string = null;
 
-          if (requireUnit == false) {
+          if (!requireUnit) {
             outValue.type = TypedValue.TYPE_FLOAT;
             outValue.data = Float.floatToIntBits(f);
           } else {
@@ -255,9 +255,8 @@ public final class ResourceHelper {
             applyUnit(sUnitNames[1], outValue, sFloatOut);
             computeTypedValue(outValue, f, sFloatOut[0]);
 
-            System.out.println(
-                String.format(
-                    "Dimension \"%1$s\" in attribute \"%2$s\" is missing unit!", value, attribute));
+            System.out.printf(
+                "Dimension \"%1$s\" in attribute \"%2$s\" is missing unit!%n", value, attribute);
           }
           return true;
         }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper2.java b/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper2.java
index d47ef69e9..27233a1c2 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper2.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper2.java
@@ -93,7 +93,7 @@ public final class ResourceHelper2 {
     value = value.trim();
     int len = value.length();
 
-    if (len <= 0) {
+    if (len == 0) {
       return false;
     }
 
@@ -124,7 +124,7 @@ public final class ResourceHelper2 {
         return false;
       }
 
-      if (end.length() > 0 && end.charAt(0) != ' ') {
+      if (!end.isEmpty() && end.charAt(0) != ' ') {
         // Might be a unit...
         if (parseUnit(end, outValue, sFloatOut)) {
           computeTypedValue(outValue, f, sFloatOut[0], end);
@@ -136,12 +136,12 @@ public final class ResourceHelper2 {
       // make sure it's only spaces at the end.
       end = end.trim();
 
-      if (end.length() == 0) {
+      if (end.isEmpty()) {
         if (outValue != null) {
           outValue.assetCookie = 0;
           outValue.string = null;
 
-          if (requireUnit == false) {
+          if (!requireUnit) {
             outValue.type = TypedValue.TYPE_FLOAT;
             outValue.data = Float.floatToIntBits(f);
           } else {
@@ -149,10 +149,9 @@ public final class ResourceHelper2 {
             applyUnit(sUnitNames[1], outValue, sFloatOut);
             computeTypedValue(outValue, f, sFloatOut[0], "dp");
 
-            System.out.println(
-                String.format(
-                    "Dimension \"%1$s\" in attribute \"%2$s\" is missing unit!",
-                    value, attribute == null ? "(unknown)" : attribute));
+            System.out.printf(
+                "Dimension \"%1$s\" in attribute \"%2$s\" is missing unit!%n",
+                value, attribute == null ? "(unknown)" : attribute);
           }
           return true;
         }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ResourceModeShadowPicker.java b/shadows/framework/src/main/java/org/robolectric/shadows/ResourceModeShadowPicker.java
index 7e88a6eec..c58735e53 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ResourceModeShadowPicker.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ResourceModeShadowPicker.java
@@ -11,10 +11,10 @@ import org.robolectric.versioning.AndroidVersions.V;
 
 public class ResourceModeShadowPicker<T> implements ShadowPicker<T> {
 
-  private Class<? extends T> binaryShadowClass;
-  private Class<? extends T> binary9ShadowClass;
-  private Class<? extends T> binary10ShadowClass;
-  private Class<? extends T> binary14ShadowClass;
+  private final Class<? extends T> binaryShadowClass;
+  private final Class<? extends T> binary9ShadowClass;
+  private final Class<? extends T> binary10ShadowClass;
+  private final Class<? extends T> binary14ShadowClass;
   private Class<? extends T> nativeShadowClass;
 
   public ResourceModeShadowPicker(
@@ -59,7 +59,7 @@ public class ResourceModeShadowPicker<T> implements ShadowPicker<T> {
       return binary14ShadowClass;
     } else if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.Q) {
       return binary10ShadowClass;
-    } else if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.P) {
+    } else if (RuntimeEnvironment.getApiLevel() == Build.VERSION_CODES.P) {
       return binary9ShadowClass;
     } else {
       return binaryShadowClass;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/RollbackInfoBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/RollbackInfoBuilder.java
index 9ac04930a..c851278eb 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/RollbackInfoBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/RollbackInfoBuilder.java
@@ -1,7 +1,7 @@
 package org.robolectric.shadows;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 
 import android.content.pm.VersionedPackage;
 import android.content.rollback.PackageRollbackInfo;
@@ -42,7 +42,7 @@ public final class RollbackInfoBuilder {
 
   /** Sets the packages of the rollback. */
   public RollbackInfoBuilder setPackages(List<PackageRollbackInfo> packages) {
-    checkNotNull(packages, "Field 'packages' not allowed to be null.");
+    requireNonNull(packages, "Field 'packages' not allowed to be null.");
     this.packages = packages;
     return this;
   }
@@ -55,7 +55,7 @@ public final class RollbackInfoBuilder {
 
   /** Sets the cause packages of the rollback. */
   public RollbackInfoBuilder setCausePackages(List<VersionedPackage> causePackages) {
-    checkNotNull(causePackages, "Field 'causePackages' not allowed to be null.");
+    requireNonNull(causePackages, "Field 'causePackages' not allowed to be null.");
     this.causePackages = causePackages;
     return this;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/RoundRectangle.java b/shadows/framework/src/main/java/org/robolectric/shadows/RoundRectangle.java
index c92729d6e..e5d147687 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/RoundRectangle.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/RoundRectangle.java
@@ -322,7 +322,7 @@ public class RoundRectangle extends RectangularShape {
           throw new NoSuchElementException("roundrect iterator out of bounds");
         }
         int nc = 0;
-        double ctrls[] = ctrlpts[index];
+        double[] ctrls = ctrlpts[index];
         for (int i = 0; i < ctrls.length; i += 4) {
           coords[nc++] = (float) (x + ctrls[i] * width + ctrls[i + 1] / 2d);
           coords[nc++] = (float) (y + ctrls[i + 2] * height + ctrls[i + 3] / 2d);
@@ -339,7 +339,7 @@ public class RoundRectangle extends RectangularShape {
           throw new NoSuchElementException("roundrect iterator out of bounds");
         }
         int nc = 0;
-        double ctrls[] = ctrlpts[index];
+        double[] ctrls = ctrlpts[index];
         for (int i = 0; i < ctrls.length; i += 4) {
           coords[nc++] = x + ctrls[i] * width + ctrls[i + 1] / 2d;
           coords[nc++] = y + ctrls[i + 2] * height + ctrls[i + 3] / 2d;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ServiceStateBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/ServiceStateBuilder.java
index 736b698a5..f31ce889a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ServiceStateBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ServiceStateBuilder.java
@@ -78,7 +78,7 @@ public class ServiceStateBuilder {
 
   /**
    * Use this method to control return value of {@link ServiceState#isUsingCarrierAggregation()} (up
-   * to P). On APIs > P, use {@link ServiceStateBuilder#setNetworkRegistrationInfoList()}.
+   * to P). On APIs > P, use {@link #setNetworkRegistrationInfoList(List)}.
    */
   public ServiceStateBuilder setIsUsingCarrierAggregation(boolean value) {
     assertIsAtLeast(P);
@@ -133,9 +133,9 @@ public class ServiceStateBuilder {
   private interface ServiceStateReflector {
 
     @Accessor("mIsUsingCarrierAggregation")
-    public void setIsUsingCarrierAggregation(boolean value);
+    void setIsUsingCarrierAggregation(boolean value);
 
     @Accessor("mNetworkRegistrationInfos")
-    public void setNetworkRegistrationInfos(List<NetworkRegistrationInfo> value);
+    void setNetworkRegistrationInfos(List<NetworkRegistrationInfo> value);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAbsListView.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAbsListView.java
index 279448e79..c101b30be 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAbsListView.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAbsListView.java
@@ -1,30 +1,39 @@
 package org.robolectric.shadows;
 
+import static org.robolectric.util.reflector.Reflector.reflector;
+
 import android.widget.AbsListView;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.Direct;
+import org.robolectric.util.reflector.ForType;
 
 @Implements(AbsListView.class)
 public class ShadowAbsListView extends ShadowAdapterView {
-  private AbsListView.OnScrollListener onScrollListener;
+  @RealObject private AbsListView realAbsListView;
+
   private int smoothScrolledPosition;
   private int lastSmoothScrollByDistance;
   private int lastSmoothScrollByDuration;
 
   @Implementation
   protected void setOnScrollListener(AbsListView.OnScrollListener l) {
-    onScrollListener = l;
+    reflector(AbsListViewReflector.class, realAbsListView).setOnScrollListener(l);
   }
 
   @Implementation
   protected void smoothScrollToPosition(int position) {
     smoothScrolledPosition = position;
+    reflector(AbsListViewReflector.class, realAbsListView).smoothScrollToPosition(position);
   }
 
   @Implementation
   protected void smoothScrollBy(int distance, int duration) {
     this.lastSmoothScrollByDistance = distance;
     this.lastSmoothScrollByDuration = duration;
+    reflector(AbsListViewReflector.class, realAbsListView).smoothScrollBy(distance, duration);
   }
 
   /**
@@ -33,7 +42,7 @@ public class ShadowAbsListView extends ShadowAdapterView {
    * @return AbsListView.OnScrollListener
    */
   public AbsListView.OnScrollListener getOnScrollListener() {
-    return onScrollListener;
+    return reflector(AbsListViewReflector.class, realAbsListView).getOnScrollListener();
   }
 
   /**
@@ -62,4 +71,19 @@ public class ShadowAbsListView extends ShadowAdapterView {
   public int getLastSmoothScrollByDuration() {
     return lastSmoothScrollByDuration;
   }
+
+  @ForType(AbsListView.class)
+  interface AbsListViewReflector {
+    @Direct
+    void setOnScrollListener(AbsListView.OnScrollListener l);
+
+    @Direct
+    void smoothScrollToPosition(int position);
+
+    @Direct
+    void smoothScrollBy(int distance, int duration);
+
+    @Accessor("mOnScrollListener")
+    AbsListView.OnScrollListener getOnScrollListener();
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityInputConnection.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityInputConnection.java
new file mode 100644
index 000000000..72fdeb93d
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityInputConnection.java
@@ -0,0 +1,126 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.accessibilityservice.InputMethod.AccessibilityInputConnection;
+import android.util.Pair;
+import android.view.KeyEvent;
+import android.view.inputmethod.SurroundingText;
+import android.view.inputmethod.TextAttribute;
+import com.android.internal.inputmethod.RemoteAccessibilityInputConnection;
+import com.google.auto.value.AutoValue;
+import java.util.List;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.ForType;
+
+/**
+ * Shadow of AccessibilityInputConnection that provides a mechanism to simulate text input for
+ * Accessibility services using InputConnection APIs. You can get an AccessibilityInputConnection to
+ * shadow by calling {@code ShadowAccessibilityInputMethod#setIsConnected(true)} and then calling
+ * {@code InputMethod#getCurrentInputConnection()} on the shadowed InputMethod.
+ *
+ * <p>All AccessibilityInputConnection objects which share the same remote will return the same
+ * values from their shadow methods. This is equivalent to the behavior of the real
+ * AccessibilityInputConnections.
+ */
+@Implements(value = AccessibilityInputConnection.class, minSdk = TIRAMISU, isInAndroidSdk = false)
+public class ShadowAccessibilityInputConnection {
+
+  @RealObject private AccessibilityInputConnection realInputConnection;
+
+  /** A class that holds the arguments passed to {@link #getSurroundingText(int, int, int)}. */
+  @AutoValue
+  public abstract static class SurroundingTextArgs {
+    static SurroundingTextArgs create(int beforeLength, int afterLength, int flags) {
+      return new AutoValue_ShadowAccessibilityInputConnection_SurroundingTextArgs(
+          beforeLength, afterLength, flags);
+    }
+
+    public abstract int beforeLength();
+
+    public abstract int afterLength();
+
+    public abstract int flags();
+  }
+
+  /**
+   * A class that holds the arguments passed to {@link #commitText(CharSequence, int,
+   * TextAttribute)}.
+   */
+  @AutoValue
+  public abstract static class CommitTextArgs {
+    static CommitTextArgs create(
+        CharSequence text, int newCursorPosition, TextAttribute textAttribute) {
+      return new AutoValue_ShadowAccessibilityInputConnection_CommitTextArgs(
+          text, newCursorPosition, textAttribute);
+    }
+
+    public abstract CharSequence text();
+
+    public abstract int newCursorPosition();
+
+    public abstract TextAttribute textAttribute();
+  }
+
+  /**
+   * Returns the list of arguments passed to {@link #commitText(CharSequence, int, TextAttribute)}.
+   */
+  public List<CommitTextArgs> getCommitTextArguments() {
+    return getRemote().getCommitTextArguments();
+  }
+
+  /** Sets the surrounding text to be returned by {@link #getSurroundingText(int, int, int)}. */
+  public void setSurroundingText(SurroundingText surroundingText) {
+    getRemote().setSurroundingText(surroundingText);
+  }
+
+  /** Returns the list of arguments passed to {@link #getSurroundingText(int, int, int)}. */
+  public List<SurroundingTextArgs> getSurroundingTextArguments() {
+    return getRemote().getSurroundingTextArguments();
+  }
+
+  /**
+   * Returns the list of context menu actions performed on this input connection in the order they
+   * were received..
+   */
+  public List<Integer> getContextMenuActions() {
+    return getRemote().getContextMenuActions();
+  }
+
+  /**
+   * Returns the list of editor actions performed on this input connection in the order they were
+   * received.
+   */
+  public List<Integer> getEditorActions() {
+    return getRemote().getEditorActions();
+  }
+
+  /**
+   * Returns the list of key events sent to this input connection in the order they were received.
+   */
+  public List<KeyEvent> getKeyEvents() {
+    return getRemote().getKeyEvents();
+  }
+
+  /**
+   * Returns the list of selections sent to this input connection in the order they were received.
+   */
+  public List<Pair<Integer, Integer>> getSetSelections() {
+    return getRemote().getSetSelections();
+  }
+
+  private ShadowRemoteAccessibilityInputConnection getRemote() {
+    return Shadow.extract(
+        reflector(AccessibilityInputConnectionReflector.class, realInputConnection).getIc());
+  }
+
+  @ForType(AccessibilityInputConnection.class)
+  interface AccessibilityInputConnectionReflector {
+    @Accessor("mIc")
+    RemoteAccessibilityInputConnection getIc();
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityInputMethod.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityInputMethod.java
new file mode 100644
index 000000000..4c094729a
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityInputMethod.java
@@ -0,0 +1,37 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.accessibilityservice.InputMethod;
+import android.view.inputmethod.EditorInfo;
+import com.android.internal.inputmethod.CancellationGroup;
+import com.android.internal.inputmethod.IRemoteAccessibilityInputConnection;
+import com.android.internal.inputmethod.RemoteAccessibilityInputConnection;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.reflector.ForType;
+
+/**
+ * Shadow of Accessibility's InputMethod that provides a mechanism to get an accessibility input
+ * connection and editor info.
+ */
+@Implements(value = InputMethod.class, minSdk = TIRAMISU, isInAndroidSdk = false)
+public class ShadowAccessibilityInputMethod {
+
+  @RealObject private InputMethod realInputMethod;
+
+  void startInput(EditorInfo editorInfo) {
+    RemoteAccessibilityInputConnection cxn =
+        new RemoteAccessibilityInputConnection(
+            ReflectionHelpers.createNullProxy(IRemoteAccessibilityInputConnection.class),
+            new CancellationGroup());
+    reflector(InputMethodReflector.class, realInputMethod).startInput(cxn, editorInfo);
+  }
+
+  @ForType(InputMethod.class)
+  interface InputMethodReflector {
+    void startInput(RemoteAccessibilityInputConnection ic, EditorInfo attribute);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityManager.java
index 558574434..b9ef80db2 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityManager.java
@@ -21,13 +21,14 @@ import android.view.accessibility.AccessibilityManager.AccessibilityStateChangeL
 import android.view.accessibility.AccessibilityManager.TouchExplorationStateChangeListener;
 import android.view.accessibility.IAccessibilityManager;
 import android.view.accessibility.IAccessibilityManager.WindowTransformationSpec;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Objects;
 import java.util.concurrent.CopyOnWriteArrayList;
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
@@ -138,8 +139,8 @@ public class ShadowAccessibilityManager {
   }
 
   public void setAccessibilityServiceList(List<ServiceInfo> accessibilityServiceList) {
-    Preconditions.checkNotNull(accessibilityServiceList);
-    this.accessibilityServiceList = new ArrayList<>(accessibilityServiceList);
+    Objects.requireNonNull(accessibilityServiceList);
+    ShadowAccessibilityManager.accessibilityServiceList = new ArrayList<>(accessibilityServiceList);
   }
 
   @Nullable
@@ -151,8 +152,9 @@ public class ShadowAccessibilityManager {
 
   public void setEnabledAccessibilityServiceList(
       List<AccessibilityServiceInfo> enabledAccessibilityServiceList) {
-    Preconditions.checkNotNull(enabledAccessibilityServiceList);
-    this.enabledAccessibilityServiceList = new ArrayList<>(enabledAccessibilityServiceList);
+    Objects.requireNonNull(enabledAccessibilityServiceList);
+    ShadowAccessibilityManager.enabledAccessibilityServiceList =
+        new ArrayList<>(enabledAccessibilityServiceList);
   }
 
   @Implementation
@@ -162,8 +164,9 @@ public class ShadowAccessibilityManager {
 
   public void setInstalledAccessibilityServiceList(
       List<AccessibilityServiceInfo> installedAccessibilityServiceList) {
-    Preconditions.checkNotNull(installedAccessibilityServiceList);
-    this.installedAccessibilityServiceList = new ArrayList<>(installedAccessibilityServiceList);
+    Objects.requireNonNull(installedAccessibilityServiceList);
+    ShadowAccessibilityManager.installedAccessibilityServiceList =
+        new ArrayList<>(installedAccessibilityServiceList);
   }
 
   @Implementation
@@ -187,7 +190,7 @@ public class ShadowAccessibilityManager {
   }
 
   public void setEnabled(boolean enabled) {
-    this.enabled = enabled;
+    ShadowAccessibilityManager.enabled = enabled;
     ReflectionHelpers.setField(realAccessibilityManager, "mIsEnabled", enabled);
     for (AccessibilityStateChangeListener l : onAccessibilityStateChangeListeners.keySet()) {
       if (l != null) {
@@ -202,8 +205,8 @@ public class ShadowAccessibilityManager {
   }
 
   public void setTouchExplorationEnabled(boolean touchExplorationEnabled) {
-    this.touchExplorationEnabled = touchExplorationEnabled;
-    List<TouchExplorationStateChangeListener> listeners = new ArrayList<>();
+    ShadowAccessibilityManager.touchExplorationEnabled = touchExplorationEnabled;
+    List<TouchExplorationStateChangeListener> listeners;
     if (getApiLevel() >= O) {
       listeners =
           new ArrayList<>(
@@ -270,14 +273,12 @@ public class ShadowAccessibilityManager {
     }
 
     @Override
-    public void handleMessage(Message message) {
-      switch (message.what) {
-        case DO_SET_STATE:
-          ReflectionHelpers.callInstanceMethod(
-              accessibilityManager, "setState", ClassParameter.from(int.class, message.arg1));
-          return;
-        default:
-          Log.w("AccessibilityManager", "Unknown message type: " + message.what);
+    public void handleMessage(@Nonnull Message message) {
+      if (message.what == DO_SET_STATE) {
+        ReflectionHelpers.callInstanceMethod(
+            accessibilityManager, "setState", ClassParameter.from(int.class, message.arg1));
+      } else {
+        Log.w("AccessibilityManager", "Unknown message type: " + message.what);
       }
     }
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityNodeInfo.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityNodeInfo.java
index 195ef089f..7168ef38d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityNodeInfo.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityNodeInfo.java
@@ -13,7 +13,6 @@ import android.view.accessibility.AccessibilityWindowInfo;
 import com.google.common.base.Preconditions;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Iterator;
 import java.util.List;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
@@ -554,9 +553,8 @@ public class ShadowAccessibilityNodeInfo {
 
     // Here we take the actions out of the pairs and stick them into a separate LinkedList to return
     List<Integer> actionsOnly = new ArrayList<>();
-    Iterator<Pair<Integer, Bundle>> iter = performedActionAndArgsList.iterator();
-    while (iter.hasNext()) {
-      actionsOnly.add(iter.next().first);
+    for (Pair<Integer, Bundle> integerBundlePair : performedActionAndArgsList) {
+      actionsOnly.add(integerBundlePair.first);
     }
 
     return Collections.unmodifiableList(actionsOnly);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityService.java
index 68a18be4c..42ee8e252 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityService.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityService.java
@@ -8,8 +8,8 @@ import android.accessibilityservice.AccessibilityService;
 import android.accessibilityservice.AccessibilityService.GestureResultCallback;
 import android.accessibilityservice.AccessibilityService.ScreenshotErrorCode;
 import android.accessibilityservice.AccessibilityService.ScreenshotResult;
-import android.accessibilityservice.AccessibilityService.TakeScreenshotCallback;
 import android.accessibilityservice.GestureDescription;
+import android.accessibilityservice.InputMethod;
 import android.graphics.ColorSpace;
 import android.graphics.ColorSpace.Named;
 import android.hardware.HardwareBuffer;
@@ -19,6 +19,7 @@ import android.util.SparseArray;
 import android.view.Display;
 import android.view.accessibility.AccessibilityNodeInfo;
 import android.view.accessibility.AccessibilityWindowInfo;
+import android.view.inputmethod.EditorInfo;
 import com.google.common.collect.ArrayListMultimap;
 import java.util.ArrayList;
 import java.util.List;
@@ -26,6 +27,8 @@ import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
@@ -35,6 +38,7 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
  */
 @Implements(AccessibilityService.class)
 public class ShadowAccessibilityService extends ShadowService {
+  @RealObject private AccessibilityService realObject;
 
   private final List<Integer> globalActionsPerformed = new ArrayList<>();
   private List<AccessibilityNodeInfo.AccessibilityAction> systemActions;
@@ -71,17 +75,12 @@ public class ShadowAccessibilityService extends ShadowService {
 
   /**
    * Returns a representation of interactive windows shown on the device's default display. Mirrors
-   * the values provided to {@link #setWindows(List<AccessibilityWindowInfo>)}. Returns an empty
-   * list if not set.
+   * the values provided to {@link #setWindows(List)}. Returns an empty list if not set.
    */
   @Implementation
   protected List<AccessibilityWindowInfo> getWindows() {
     List<AccessibilityWindowInfo> windowInfos = windows.get(Display.DEFAULT_DISPLAY);
-    if (windowInfos != null) {
-      return new ArrayList<>(windowInfos);
-    } else {
-      return new ArrayList<>();
-    }
+    return new ArrayList<>(windowInfos);
   }
 
   /**
@@ -200,6 +199,15 @@ public class ShadowAccessibilityService extends ShadowService {
     this.canDispatchGestures = canDispatchGestures;
   }
 
+  public void startInput(EditorInfo editorInfo) {
+    InputMethod inputMethod = realObject.getInputMethod();
+    if (inputMethod == null) {
+      return;
+    }
+    ShadowAccessibilityInputMethod shadowInputMethod = Shadow.extract(inputMethod);
+    shadowInputMethod.startInput(editorInfo);
+  }
+
   /**
    * Represents a gesture that has been dispatched through the accessibility service.
    *
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccountManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccountManager.java
index 725c4ed8c..c72a15a71 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccountManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccountManager.java
@@ -39,23 +39,23 @@ import org.robolectric.util.Scheduler.IdleState;
 @Implements(AccountManager.class)
 public class ShadowAccountManager {
 
-  private List<Account> accounts = new ArrayList<>();
-  private Map<Account, Map<String, String>> authTokens = new HashMap<>();
-  private Map<String, AuthenticatorDescription> authenticators = new LinkedHashMap<>();
+  private final List<Account> accounts = new ArrayList<>();
+  private final Map<Account, Map<String, String>> authTokens = new HashMap<>();
+  private final Map<String, AuthenticatorDescription> authenticators = new LinkedHashMap<>();
 
   /**
    * Maps listeners to a set of account types. If null, the listener should be notified for changes
    * to accounts of any type. Otherwise, the listener is only notified of changes to accounts of the
    * given type.
    */
-  private Map<OnAccountsUpdateListener, Set<String>> listeners = new LinkedHashMap<>();
+  private final Map<OnAccountsUpdateListener, Set<String>> listeners = new LinkedHashMap<>();
 
-  private Map<Account, Map<String, String>> userData = new HashMap<>();
-  private Map<Account, String> passwords = new HashMap<>();
-  private Map<Account, Set<String>> accountFeatures = new HashMap<>();
-  private Map<Account, Set<String>> packageVisibleAccounts = new HashMap<>();
+  private final Map<Account, Map<String, String>> userData = new HashMap<>();
+  private final Map<Account, String> passwords = new HashMap<>();
+  private final Map<Account, Set<String>> accountFeatures = new HashMap<>();
+  private final Map<Account, Set<String>> packageVisibleAccounts = new HashMap<>();
 
-  private List<Bundle> addAccountOptionsList = new ArrayList<>();
+  private final List<Bundle> addAccountOptionsList = new ArrayList<>();
   private static Handler mainHandler;
   private static RoboAccountManagerFuture pendingAddFuture;
   private static boolean authenticationErrorOnNextResponse = false;
@@ -88,7 +88,7 @@ public class ShadowAccountManager {
 
   @Implementation
   protected Account[] getAccounts() {
-    return accounts.toArray(new Account[accounts.size()]);
+    return accounts.toArray(new Account[0]);
   }
 
   @Implementation
@@ -104,7 +104,7 @@ public class ShadowAccountManager {
       }
     }
 
-    return accountsByType.toArray(new Account[accountsByType.size()]);
+    return accountsByType.toArray(new Account[0]);
   }
 
   @Implementation
@@ -244,7 +244,7 @@ public class ShadowAccountManager {
 
   @Implementation
   protected AuthenticatorDescription[] getAuthenticatorTypes() {
-    return authenticators.values().toArray(new AuthenticatorDescription[authenticators.size()]);
+    return authenticators.values().toArray(new AuthenticatorDescription[0]);
   }
 
   @Implementation
@@ -309,7 +309,7 @@ public class ShadowAccountManager {
     }
 
     if (!userData.containsKey(account)) {
-      userData.put(account, new HashMap<String, String>());
+      userData.put(account, new HashMap<>());
     }
 
     Map<String, String> userDataMap = userData.get(account);
@@ -368,8 +368,8 @@ public class ShadowAccountManager {
   /**
    * Returns a bundle that contains the account session bundle under {@link
    * AccountManager#KEY_ACCOUNT_SESSION_BUNDLE} to later be passed on to {@link
-   * AccountManager#finishSession(Bundle,Activity,AccountManagerCallback<Bundle>,Handler)}. The
-   * session bundle simply propagates the given {@code accountType} so as not to be empty and is not
+   * AccountManager#finishSession(Bundle, Activity, AccountManagerCallback, Handler)}. The session
+   * bundle simply propagates the given {@code accountType} so as not to be empty and is not
    * encrypted as it would be in the real implementation. If an activity isn't provided, resulting
    * bundle will only have a dummy {@link Intent} under {@link AccountManager#KEY_INTENT}.
    *
@@ -592,8 +592,7 @@ public class ShadowAccountManager {
   }
 
   public void setFeatures(Account account, String[] accountFeatures) {
-    HashSet<String> featureSet = new HashSet<>();
-    featureSet.addAll(Arrays.asList(accountFeatures));
+    HashSet<String> featureSet = new HashSet<>(Arrays.asList(accountFeatures));
     this.accountFeatures.put(account, featureSet);
   }
 
@@ -608,7 +607,7 @@ public class ShadowAccountManager {
     addAuthenticator(AuthenticatorDescription.newKey(type));
   }
 
-  private Map<Account, String> previousNames = new HashMap<Account, String>();
+  private final Map<Account, String> previousNames = new HashMap<>();
 
   /**
    * Sets the previous name for an account, which will be returned by {@link
@@ -734,7 +733,7 @@ public class ShadowAccountManager {
                 result.add(account);
               }
             }
-            return result.toArray(new Account[result.size()]);
+            return result.toArray(new Account[0]);
           }
         });
   }
@@ -756,7 +755,7 @@ public class ShadowAccountManager {
       }
     }
 
-    return result.toArray(new Account[result.size()]);
+    return result.toArray(new Account[0]);
   }
 
   /**
@@ -766,7 +765,7 @@ public class ShadowAccountManager {
    *     response.
    */
   public void setAuthenticationErrorOnNextResponse(boolean authenticationErrorOnNextResponse) {
-    this.authenticationErrorOnNextResponse = authenticationErrorOnNextResponse;
+    ShadowAccountManager.authenticationErrorOnNextResponse = authenticationErrorOnNextResponse;
   }
 
   /**
@@ -775,14 +774,14 @@ public class ShadowAccountManager {
    * @param removeAccountIntent the intent to surface as {@link AccountManager#KEY_INTENT}.
    */
   public void setRemoveAccountIntent(Intent removeAccountIntent) {
-    this.removeAccountIntent = removeAccountIntent;
+    ShadowAccountManager.removeAccountIntent = removeAccountIntent;
   }
 
   public Map<OnAccountsUpdateListener, Set<String>> getListeners() {
     return listeners;
   }
 
-  private abstract class BaseRoboAccountManagerFuture<T> implements AccountManagerFuture<T> {
+  private abstract static class BaseRoboAccountManagerFuture<T> implements AccountManagerFuture<T> {
     protected final AccountManagerCallback<T> callback;
     private final Handler handler;
     protected T result;
@@ -805,13 +804,7 @@ public class ShadowAccountManager {
       }
 
       if (callback != null) {
-        handler.post(
-            new Runnable() {
-              @Override
-              public void run() {
-                callback.run(BaseRoboAccountManagerFuture.this);
-              }
-            });
+        handler.post(() -> callback.run(BaseRoboAccountManagerFuture.this));
       }
     }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivity.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivity.java
index 317985e6e..e7b58dad6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivity.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivity.java
@@ -93,11 +93,11 @@ public class ShadowActivity extends ShadowContextThemeWrapper {
   private Integer lastShownDialogId = null;
   private int pendingTransitionEnterAnimResId = -1;
   private int pendingTransitionExitAnimResId = -1;
-  private SparseArray<OverriddenActivityTransition> overriddenActivityTransitions =
+  private final SparseArray<OverriddenActivityTransition> overriddenActivityTransitions =
       new SparseArray<>();
   private Object lastNonConfigurationInstance;
-  private Map<Integer, Dialog> dialogForId = new HashMap<>();
-  private ArrayList<Cursor> managedCursors = new ArrayList<>();
+  private final Map<Integer, Dialog> dialogForId = new HashMap<>();
+  private final ArrayList<Cursor> managedCursors = new ArrayList<>();
   private int mDefaultKeyMode = Activity.DEFAULT_KEYS_DISABLE;
   private SpannableStringBuilder mDefaultKeySsb = null;
   private int streamType = -1;
@@ -400,8 +400,8 @@ public class ShadowActivity extends ShadowContextThemeWrapper {
   }
 
   /**
-   * Constructs a new Window (a {@link com.android.internal.policy.impl.PhoneWindow}) if no window
-   * has previously been set.
+   * Constructs a new Window (a {@link com.android.internal.policy.PhoneWindow}) if no window has
+   * previously been set.
    *
    * @return the window associated with this Activity
    */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java
index 894e5cb1b..1fe4d910b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java
@@ -240,8 +240,8 @@ public class ShadowActivityManager {
    * @param tasks List of running tasks.
    */
   public void setTasks(List<ActivityManager.RunningTaskInfo> tasks) {
-    this.tasks.clear();
-    this.tasks.addAll(tasks);
+    ShadowActivityManager.tasks.clear();
+    ShadowActivityManager.tasks.addAll(tasks);
   }
 
   /**
@@ -251,27 +251,27 @@ public class ShadowActivityManager {
    * @param appTasks List of app tasks.
    */
   public void setAppTasks(List<ActivityManager.AppTask> appTasks) {
-    this.appTasks.clear();
-    this.appTasks.addAll(appTasks);
+    ShadowActivityManager.appTasks.clear();
+    ShadowActivityManager.appTasks.addAll(appTasks);
   }
 
   /**
-   * Sets the values to be returned by {@link #getRecentTasks()}.
+   * Sets the values to be returned by {@link #getRecentTasks(int, int)}.
    *
-   * @see #getRecentTasks()
+   * @see #getRecentTasks(int, int)
    * @param recentTasks List of recent tasks.
    */
   public void setRecentTasks(List<ActivityManager.RecentTaskInfo> recentTasks) {
-    this.recentTasks.clear();
-    this.recentTasks.addAll(recentTasks);
+    ShadowActivityManager.recentTasks.clear();
+    ShadowActivityManager.recentTasks.addAll(recentTasks);
   }
 
   /**
    * @param services List of running services.
    */
   public void setServices(List<ActivityManager.RunningServiceInfo> services) {
-    this.services.clear();
-    this.services.addAll(services);
+    ShadowActivityManager.services.clear();
+    ShadowActivityManager.services.addAll(services);
   }
 
   /**
@@ -300,7 +300,7 @@ public class ShadowActivityManager {
    * @param memoryInfo Set the application's memory info.
    */
   public void setMemoryInfo(ActivityManager.MemoryInfo memoryInfo) {
-    this.memoryInfo = memoryInfo;
+    ShadowActivityManager.memoryInfo = memoryInfo;
   }
 
   @Implementation(minSdk = O)
@@ -325,7 +325,7 @@ public class ShadowActivityManager {
   protected void addOnUidImportanceListener(
       @ClassName("android.app.ActivityManager$OnUidImportanceListener") Object listener,
       int importanceCutpoint) {
-    importanceListeners.add(new ImportanceListener(listener, (Integer) importanceCutpoint));
+    importanceListeners.add(new ImportanceListener(listener, importanceCutpoint));
   }
 
   @Implementation(minSdk = O)
@@ -412,10 +412,8 @@ public class ShadowActivityManager {
   protected List</*android.app.ApplicationExitInfo*/ ?> getHistoricalProcessExitReasons(
       String packageName, int pid, int maxNum) {
     return appExitInfoList.stream()
-        .filter(
-            appExitInfo ->
-                (int) pid == 0 || ((ApplicationExitInfo) appExitInfo).getPid() == (int) pid)
-        .limit((int) maxNum == 0 ? appExitInfoList.size() : (int) maxNum)
+        .filter(appExitInfo -> pid == 0 || ((ApplicationExitInfo) appExitInfo).getPid() == pid)
+        .limit(maxNum == 0 ? appExitInfoList.size() : maxNum)
         .collect(toCollection(ArrayList::new));
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityThread.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityThread.java
index 38d7845dd..a1a60570d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityThread.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityThread.java
@@ -24,13 +24,10 @@ import android.content.pm.PackageManager.ComponentInfoFlags;
 import android.content.res.Configuration;
 import android.os.IBinder;
 import com.android.internal.content.ReferrerIntent;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import javax.annotation.Nonnull;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
@@ -63,53 +60,49 @@ public class ShadowActivityThread {
     return Proxy.newProxyInstance(
         classLoader,
         new Class[] {iPackageManagerClass},
-        new InvocationHandler() {
-          @Override
-          public Object invoke(Object proxy, @Nonnull Method method, Object[] args)
-              throws Exception {
-            if (method.getName().equals("getApplicationInfo")) {
-              String packageName = (String) args[0];
-              int flags = ((Number) args[1]).intValue();
-              if (packageName.equals(ShadowActivityThread.applicationInfo.packageName)) {
-                return ShadowActivityThread.applicationInfo;
-              }
-
-              try {
-                return RuntimeEnvironment.getApplication()
-                    .getPackageManager()
-                    .getApplicationInfo(packageName, flags);
-              } catch (PackageManager.NameNotFoundException e) {
-                return null;
-              }
-            } else if (method.getName().equals("notifyPackageUse")) {
+        (proxy, method, args) -> {
+          if (method.getName().equals("getApplicationInfo")) {
+            String packageName = (String) args[0];
+            int flags = ((Number) args[1]).intValue();
+            if (packageName.equals(ShadowActivityThread.applicationInfo.packageName)) {
+              return ShadowActivityThread.applicationInfo;
+            }
+
+            try {
+              return RuntimeEnvironment.getApplication()
+                  .getPackageManager()
+                  .getApplicationInfo(packageName, flags);
+            } catch (PackageManager.NameNotFoundException e) {
               return null;
-            } else if (method.getName().equals("getPackageInstaller")) {
-              try {
-                Class<?> iPackageInstallerClass =
-                    classLoader.loadClass("android.content.pm.IPackageInstaller");
-                return ReflectionHelpers.createNullProxy(iPackageInstallerClass);
-              } catch (ClassNotFoundException e) {
-                throw new RuntimeException(e);
-              }
-            } else if (method.getName().equals("hasSystemFeature")) {
-              String featureName = (String) args[0];
+            }
+          } else if (method.getName().equals("notifyPackageUse")) {
+            return null;
+          } else if (method.getName().equals("getPackageInstaller")) {
+            try {
+              Class<?> iPackageInstallerClass =
+                  classLoader.loadClass("android.content.pm.IPackageInstaller");
+              return ReflectionHelpers.createNullProxy(iPackageInstallerClass);
+            } catch (ClassNotFoundException e) {
+              throw new RuntimeException(e);
+            }
+          } else if (method.getName().equals("hasSystemFeature")) {
+            String featureName = (String) args[0];
+            return RuntimeEnvironment.getApplication()
+                .getPackageManager()
+                .hasSystemFeature(featureName);
+          } else if (method.getName().equals("getServiceInfo")) {
+            ComponentName componentName = (ComponentName) args[0];
+            if (args[1] instanceof ComponentInfoFlags) {
+              return RuntimeEnvironment.getApplication()
+                  .getPackageManager()
+                  .getServiceInfo(componentName, (ComponentInfoFlags) args[1]);
+            } else {
               return RuntimeEnvironment.getApplication()
                   .getPackageManager()
-                  .hasSystemFeature(featureName);
-            } else if (method.getName().equals("getServiceInfo")) {
-              ComponentName componentName = (ComponentName) args[0];
-              if (args[1] instanceof ComponentInfoFlags) {
-                return RuntimeEnvironment.getApplication()
-                    .getPackageManager()
-                    .getServiceInfo(componentName, (ComponentInfoFlags) args[1]);
-              } else {
-                return RuntimeEnvironment.getApplication()
-                    .getPackageManager()
-                    .getServiceInfo(componentName, ((Number) args[1]).intValue());
-              }
+                  .getServiceInfo(componentName, ((Number) args[1]).intValue());
             }
-            throw new UnsupportedOperationException("sorry, not supporting " + method + " yet!");
           }
+          throw new UnsupportedOperationException("sorry, not supporting " + method + " yet!");
         });
   }
 
@@ -147,18 +140,13 @@ public class ShadowActivityThread {
     return Proxy.newProxyInstance(
         classLoader,
         new Class<?>[] {iPermissionManagerClass},
-        new InvocationHandler() {
-          @Override
-          public Object invoke(Object proxy, @Nonnull Method method, Object[] args)
-              throws Exception {
-            if (method.getName().equals("getSplitPermissions")) {
-              return Collections.emptyList();
-            }
-            if (method.getName().equals("getPermissionRequestState")) {
-              return PERMISSION_GRANTED;
-            }
-            return method.getDefaultValue();
+        (proxy, method, args) -> {
+          if (method.getName().equals("getSplitPermissions")) {
+            return Collections.emptyList();
+          } else if (method.getName().equals("getPermissionRequestState")) {
+            return PERMISSION_GRANTED;
           }
+          return method.getDefaultValue();
         });
   }
 
@@ -238,8 +226,6 @@ public class ShadowActivityThread {
           configController,
           "setCompatConfiguration",
           from(Configuration.class, androidConfiguration));
-      androidConfiguration =
-          ReflectionHelpers.callInstanceMethod(configController, "getCompatConfiguration");
       ReflectionHelpers.setField(realActivityThread, "mConfigurationController", configController);
     } else {
       reflector(_ActivityThread_.class, realActivityThread)
@@ -263,7 +249,7 @@ public class ShadowActivityThread {
     @Accessor("mInitialApplication")
     void setInitialApplication(Application application);
 
-    /** internal use only. Tests should use {@link ActivityThread.getApplication} */
+    /** internal use only. Tests should use {@link ActivityThread#getApplication()} */
     @Accessor("mInitialApplication")
     Application getInitialApplication();
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAdapterView.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAdapterView.java
index abb81c33d..5afb1e268 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAdapterView.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAdapterView.java
@@ -16,7 +16,7 @@ import org.robolectric.util.reflector.ForType;
 @SuppressWarnings({"UnusedDeclaration"})
 @Implements(AdapterView.class)
 public class ShadowAdapterView<T extends Adapter> extends ShadowViewGroup {
-  private static int ignoreRowsAtEndOfList = 0;
+  private static final int ignoreRowsAtEndOfList = 0;
 
   @RealObject private AdapterView<T> realAdapterView;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlarmManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlarmManager.java
index dbdb2b949..55573b136 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlarmManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlarmManager.java
@@ -23,6 +23,7 @@ import java.util.PriorityQueue;
 import java.util.TimeZone;
 import java.util.concurrent.Executor;
 import java.util.concurrent.RejectedExecutionException;
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -651,7 +652,7 @@ public class ShadowAlarmManager {
     }
 
     @Override
-    public int compareTo(ScheduledAlarm scheduledAlarm) {
+    public int compareTo(@Nonnull ScheduledAlarm scheduledAlarm) {
       return Long.compare(triggerAtTime, scheduledAlarm.triggerAtTime);
     }
   }
@@ -762,7 +763,7 @@ public class ShadowAlarmManager {
     }
 
     @Override
-    public void execute(Runnable command) {
+    public void execute(@Nonnull Runnable command) {
       if (!handler.post(command)) {
         throw new RejectedExecutionException(handler + " is shutting down");
       }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlertDialog.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlertDialog.java
index bf6854719..c2d2c2906 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlertDialog.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlertDialog.java
@@ -1,10 +1,8 @@
 package org.robolectric.shadows;
 
 import android.app.AlertDialog;
-import android.content.DialogInterface;
 import android.view.View;
 import android.widget.Adapter;
-import android.widget.FrameLayout;
 import com.android.internal.app.AlertController;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -17,13 +15,6 @@ import org.robolectric.util.ReflectionHelpers;
 public class ShadowAlertDialog extends ShadowDialog {
   @RealObject private AlertDialog realAlertDialog;
 
-  private CharSequence[] items;
-  private DialogInterface.OnClickListener clickListener;
-  private boolean isMultiItem;
-  private boolean isSingleItem;
-  private DialogInterface.OnMultiChoiceClickListener multiChoiceClickListener;
-  private FrameLayout custom;
-
   private static ShadowAlertDialog latestAlertDialog;
 
   /**
@@ -34,13 +25,6 @@ public class ShadowAlertDialog extends ShadowDialog {
     return latestAlertDialog == null ? null : latestAlertDialog.realAlertDialog;
   }
 
-  public FrameLayout getCustomView() {
-    if (custom == null) {
-      custom = new FrameLayout(context);
-    }
-    return custom;
-  }
-
   /** Resets the tracking of the most recently created {@code AlertDialog} */
   @Resetter
   public static void reset() {
@@ -117,9 +101,6 @@ public class ShadowAlertDialog extends ShadowDialog {
 
   private ShadowAlertController getShadowAlertController() {
     AlertController alertController = ReflectionHelpers.getField(realAlertDialog, "mAlert");
-    return (ShadowAlertController) Shadow.extract(alertController);
+    return Shadow.extract(alertController);
   }
-
-  @Implements(AlertDialog.Builder.class)
-  public static class ShadowBuilder {}
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlwaysOnHotwordDetector.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlwaysOnHotwordDetector.java
index 7c9201b03..f3830f3aa 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlwaysOnHotwordDetector.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlwaysOnHotwordDetector.java
@@ -161,15 +161,16 @@ public class ShadowAlwaysOnHotwordDetector {
     }
   }
 
-  /** Shadow for AsyncTask kicked off in the constructor of AlwaysOnHotwordDetector. */
+  /**
+   * Shadow for AsyncTask kicked off in the constructor of AlwaysOnHotwordDetector for T and below.
+   */
   @Implements(
       className = "android.service.voice.AlwaysOnHotwordDetector$RefreshAvailabiltyTask",
       maxSdk = TIRAMISU,
       isInAndroidSdk = false)
   @SuppressWarnings("robolectric.mismatchedTypes")
-  public static class ShadowRefreshAvailabilityTask<Params, Progress, Result>
+  public static class ShadowRefreshAvailabilityTaskPreU<Params, Progress, Result>
       extends ShadowPausedAsyncTask<Params, Progress, Result> {
-
     @Implementation
     protected int internalGetInitialAvailability() {
       return STATE_KEYPHRASE_ENROLLED;
@@ -186,6 +187,24 @@ public class ShadowAlwaysOnHotwordDetector {
     }
   }
 
+  /** Shadow for AsyncTask kicked off in the constructor of AlwaysOnHotwordDetector for U+. */
+  @Implements(
+      className = "android.service.voice.AlwaysOnHotwordDetector$RefreshAvailabilityTask",
+      minSdk = UPSIDE_DOWN_CAKE,
+      isInAndroidSdk = false)
+  @SuppressWarnings("robolectric.mismatchedTypes")
+  public static class ShadowRefreshAvailabilityTask<Params, Progress, Result> {
+    @Implementation
+    protected int internalGetInitialAvailability() {
+      return STATE_KEYPHRASE_ENROLLED;
+    }
+
+    @Implementation(minSdk = R)
+    protected void internalUpdateEnrolledKeyphraseMetadata() {
+      // No-op, we already set this field in #setEnrollmentFields()
+    }
+  }
+
   /** Invokes the normally hidden EventPayload constructor for passing to Callback#onDetected(). */
   public static EventPayload createEventPayload(
       boolean triggerAvailable,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAnimationBridge.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAnimationBridge.java
index fecf1db91..428bc679f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAnimationBridge.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAnimationBridge.java
@@ -9,7 +9,7 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
 /** Bridge between shadows and {@link android.view.animation.Animation}. */
 @DoNotInstrument
 public class ShadowAnimationBridge {
-  private Animation realAnimation;
+  private final Animation realAnimation;
 
   public ShadowAnimationBridge(Animation realAnimation) {
     this.realAnimation = realAnimation;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppIntegrityManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppIntegrityManager.java
index aec31bb36..a00c0dc77 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppIntegrityManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppIntegrityManager.java
@@ -36,7 +36,7 @@ public class ShadowAppIntegrityManager {
    */
   @Implementation
   protected String getCurrentRuleSetVersion() {
-    return recordedRuleSet.isPresent() ? recordedRuleSet.get().getVersion() : "None";
+    return recordedRuleSet.map(RuleSet::getVersion).orElse("None");
   }
 
   /**
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java
index 3ce43c969..7d7d8ae21 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java
@@ -228,7 +228,7 @@ public class ShadowAppOpsManager {
   @SystemApi
   @Nonnull
   protected List<PackageOps> getPackagesForOps(@Nullable String[] ops) {
-    List<PackageOps> result = null;
+    List<PackageOps> result;
 
     if (ops == null) {
       int[] intOps = null;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java
index ad56acb28..7cebcc1e4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java
@@ -53,7 +53,7 @@ public class ShadowAppWidgetManager {
   private static boolean validWidgetProviderComponentName = true;
   private final Map<Integer, RemoteViews> widgetPreviews = new HashMap<>();
   private final ArrayList<AppWidgetProviderInfo> installedProviders = new ArrayList<>();
-  private Multimap<UserHandle, AppWidgetProviderInfo> installedProvidersForProfile =
+  private final Multimap<UserHandle, AppWidgetProviderInfo> installedProvidersForProfile =
       HashMultimap.create();
   private Context context;
   private final Map<Integer, WidgetInfo> widgetInfos = new HashMap<>();
@@ -130,7 +130,7 @@ public class ShadowAppWidgetManager {
         idList.add(id);
       }
     }
-    int ids[] = new int[idList.size()];
+    int[] ids = new int[idList.size()];
     for (int i = 0; i < idList.size(); i++) {
       ids[i] = idList.get(i);
     }
@@ -261,7 +261,7 @@ public class ShadowAppWidgetManager {
     }
   }
 
-  /** Returns true if {@link setSupportedToRequestPinAppWidget} is called with {@code true} */
+  /** Returns true if {@link #setRequestPinAppWidgetSupported} is called with {@code true} */
   @Implementation(minSdk = O)
   protected boolean isRequestPinAppWidgetSupported() {
     return requestPinAppWidgetSupported;
@@ -438,7 +438,7 @@ public class ShadowAppWidgetManager {
   }
 
   public void setValidWidgetProviderComponentName(boolean validWidgetProviderComponentName) {
-    this.validWidgetProviderComponentName = validWidgetProviderComponentName;
+    ShadowAppWidgetManager.validWidgetProviderComponentName = validWidgetProviderComponentName;
   }
 
   private static class WidgetInfo {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplication.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplication.java
index 35efdf2b4..ee2153dee 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplication.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplication.java
@@ -7,8 +7,6 @@ import android.app.ActivityThread;
 import android.app.AlertDialog;
 import android.app.Application;
 import android.app.Dialog;
-import android.appwidget.AppWidgetManager;
-import android.bluetooth.BluetoothAdapter;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.Context;
@@ -19,15 +17,12 @@ import android.content.ServiceConnection;
 import android.os.Build;
 import android.os.Handler;
 import android.os.IBinder;
-import android.os.PowerManager;
 import android.widget.ListPopupWindow;
 import android.widget.PopupWindow;
 import android.widget.Toast;
 import com.google.common.collect.ImmutableList;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -42,13 +37,13 @@ import org.robolectric.util.reflector.Reflector;
 public class ShadowApplication extends ShadowContextWrapper {
   @RealObject private Application realApplication;
 
-  private List<android.widget.Toast> shownToasts = new ArrayList<>();
+  private final List<android.widget.Toast> shownToasts = new ArrayList<>();
   private ShadowPopupMenu latestPopupMenu;
   private PopupWindow latestPopupWindow;
   private ListPopupWindow latestListPopupWindow;
 
   /**
-   * @deprecated Use {@code shadowOf({@link ApplicationProvider#getApplicationContext()})} instead.
+   * @deprecated Use {@code shadowOf(ApplicationProvider#getApplicationContext())} instead.
    */
   @Deprecated
   public static ShadowApplication getInstance() {
@@ -59,7 +54,10 @@ public class ShadowApplication extends ShadowContextWrapper {
    * Runs any background tasks previously queued by {@link android.os.AsyncTask#execute(Object[])}.
    *
    * <p>Note: calling this method does not pause or un-pause the scheduler.
+   *
+   * @deprecated This is only for LEGACY Looper mode. Use PAUSED Looper mode instead.
    */
+  @Deprecated
   public static void runBackgroundTasks() {
     getInstance().getBackgroundThreadScheduler().advanceBy(0);
   }
@@ -196,14 +194,6 @@ public class ShadowApplication extends ShadowContextWrapper {
     getShadowInstrumentation().clearRegisteredReceivers();
   }
 
-  /**
-   * @deprecated Please use {@link Context#getSystemService(Context.APPWIDGET_SERVICE)} intstead.
-   */
-  @Deprecated
-  public AppWidgetManager getAppWidgetManager() {
-    return (AppWidgetManager) realApplication.getSystemService(Context.APPWIDGET_SERVICE);
-  }
-
   /**
    * @deprecated Use {@link ShadowAlertDialog#getLatestAlertDialog()} instead.
    */
@@ -222,14 +212,6 @@ public class ShadowApplication extends ShadowContextWrapper {
     return dialog == null ? null : Shadow.extract(dialog);
   }
 
-  /**
-   * @deprecated Use {@link BluetoothAdapter#getDefaultAdapter()} ()} instead.
-   */
-  @Deprecated
-  public BluetoothAdapter getBluetoothAdapter() {
-    return BluetoothAdapter.getDefaultAdapter();
-  }
-
   public void declareActionUnbindable(String action) {
     getShadowInstrumentation().declareActionUnbindable(action);
   }
@@ -242,43 +224,6 @@ public class ShadowApplication extends ShadowContextWrapper {
     getShadowInstrumentation().declareComponentUnbindable(component);
   }
 
-  /**
-   * @deprecated use ShadowPowerManager.getLatestWakeLock
-   */
-  @Deprecated
-  public PowerManager.WakeLock getLatestWakeLock() {
-    return ShadowPowerManager.getLatestWakeLock();
-  }
-
-  /**
-   * @deprecated use PowerManager APIs instead
-   */
-  @Deprecated
-  public void addWakeLock(PowerManager.WakeLock wl) {
-    ShadowPowerManager.addWakeLock(wl);
-  }
-
-  /**
-   * @deprecated use ShadowPowerManager.clearWakeLocks
-   */
-  @Deprecated
-  public void clearWakeLocks() {
-    ShadowPowerManager.clearWakeLocks();
-  }
-
-  private final Map<String, Object> singletons = new HashMap<>();
-
-  public <T> T getSingleton(Class<T> clazz, Provider<T> provider) {
-    synchronized (singletons) {
-      //noinspection unchecked
-      T item = (T) singletons.get(clazz.getName());
-      if (item == null) {
-        singletons.put(clazz.getName(), item = provider.get());
-      }
-      return item;
-    }
-  }
-
   /**
    * Set to true if you'd like Robolectric to strictly simulate the real Android behavior when
    * calling {@link Context#startActivity(android.content.Intent)}. Real Android throws a {@link
@@ -375,7 +320,7 @@ public class ShadowApplication extends ShadowContextWrapper {
 
   /**
    * @deprecated Do not depend on this method to override services as it will be removed in a future
-   *     update. The preferered method is use the shadow of the corresponding service.
+   *     update. The preferred method is use the shadow of the corresponding service.
    */
   @Deprecated
   public void setSystemService(String key, Object service) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java
index ea7abe12b..8cebc8ea0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java
@@ -32,7 +32,7 @@ import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.S_V2;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 import static org.robolectric.annotation.GetInstallerPackageNameMode.Mode.REALISTIC;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
@@ -161,7 +161,7 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   private List<PackageInfo> getInstalledPackages(long flags) {
     List<PackageInfo> result = new ArrayList<>();
     synchronized (lock) {
-      Set<String> packageNames = null;
+      Set<String> packageNames;
       if ((flags & MATCH_UNINSTALLED_PACKAGES) == 0) {
         packageNames = packageInfos.keySet();
       } else {
@@ -314,7 +314,7 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
       }
     }
 
-    return results.isEmpty() ? null : results.toArray(new String[results.size()]);
+    return results.isEmpty() ? null : results.toArray(new String[0]);
   }
 
   @Implementation
@@ -702,7 +702,6 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
         } catch (NameNotFoundException e) {
           Log.d(TAG, "ComponentInfo doesn't match flags:" + e.getMessage());
           iterator.remove();
-          continue;
         }
       }
       Collections.sort(result, new ResolveInfoComparator());
@@ -1011,7 +1010,7 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
     }
     // Android don't override the enabled field of component with the actual value.
     boolean isEnabledForFiltering =
-        isComponentEnabled && (Build.VERSION.SDK_INT >= 24 ? isApplicationEnabled : true);
+        isComponentEnabled && (VERSION.SDK_INT < 24 || isApplicationEnabled);
     if ((flags & MATCH_DISABLED_COMPONENTS) == 0 && !isEnabledForFiltering) {
       throw new NameNotFoundException("Disabled component: " + componentInfo);
     }
@@ -1159,7 +1158,7 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   protected FeatureInfo[] getSystemAvailableFeatures() {
     return systemAvailableFeatures.isEmpty()
         ? null
-        : systemAvailableFeatures.toArray(new FeatureInfo[systemAvailableFeatures.size()]);
+        : systemAvailableFeatures.toArray(new FeatureInfo[0]);
   }
 
   @Implementation
@@ -1223,7 +1222,7 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
       String pkgName,
       int uid,
       final @ClassName("android.content.pm.IPackageStatsObserver") Object observer) {
-    final PackageStats packageStats = packageStatsMap.get((String) pkgName);
+    final PackageStats packageStats = packageStatsMap.get(pkgName);
     new Handler(Looper.getMainLooper())
         .post(
             () -> {
@@ -1285,12 +1284,26 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
 
   @Implementation
   protected Drawable getApplicationIcon(String packageName) throws NameNotFoundException {
-    return applicationIcons.get(packageName);
+    Drawable result = applicationIcons.get(packageName);
+    if (useValidGetApplicationIcon() && result == null) {
+      throw new NameNotFoundException(packageName);
+    }
+    return result;
+  }
+
+  private static boolean useValidGetApplicationIcon() {
+    return Boolean.parseBoolean(
+        System.getProperty("robolectric.useValidGetApplicationIcon", "true"));
   }
 
   @Implementation
   protected Drawable getApplicationIcon(ApplicationInfo info) throws NameNotFoundException {
-    return getApplicationIcon(info.packageName);
+    try {
+      return getApplicationIcon(info.packageName);
+    } catch (NameNotFoundException e) {
+      // This method should not return null. Return a default icon instead.
+      return getDefaultActivityIcon();
+    }
   }
 
   @Implementation
@@ -1574,7 +1587,7 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
    */
   @Implementation
   protected String[] getSystemSharedLibraryNames() {
-    return systemSharedLibraryNames.toArray(new String[systemSharedLibraryNames.size()]);
+    return systemSharedLibraryNames.toArray(new String[0]);
   }
 
   @Implementation(minSdk = N)
@@ -1720,7 +1733,7 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
       @PackageManager.PermissionFlags int flagValues,
       UserHandle user) {
     if (!permissionFlags.containsKey(packageName)) {
-      permissionFlags.put(packageName, new HashMap<String, Integer>());
+      permissionFlags.put(packageName, new HashMap<>());
     }
 
     int existingFlags =
@@ -2400,7 +2413,7 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   @Implementation(minSdk = Q)
   @RequiresPermission(permission.SUSPEND_APPS)
   protected String[] getUnsuspendablePackages(String[] packageNames) {
-    checkNotNull(packageNames, "packageNames cannot be null");
+    requireNonNull(packageNames, "packageNames cannot be null");
     if (getContext().checkSelfPermission(permission.SUSPEND_APPS)
         != PackageManager.PERMISSION_GRANTED) {
       throw new SecurityException("Current process does not have " + permission.SUSPEND_APPS);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArrayAdapter.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArrayAdapter.java
index 92e0c3ba5..7a4c71991 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArrayAdapter.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArrayAdapter.java
@@ -17,4 +17,8 @@ public class ShadowArrayAdapter<T> extends ShadowBaseAdapter {
   public int getResourceId() {
     return ReflectionHelpers.getField(realArrayAdapter, "mResource");
   }
+
+  public int getDropDownViewResourceId() {
+    return ReflectionHelpers.getField(realArrayAdapter, "mDropDownResource");
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java
index 90cac3cd8..02b8ebda0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java
@@ -218,7 +218,7 @@ public class ShadowArscApkAssets9 extends ShadowApkAssets {
       int propertyFlags,
       @ClassName("android.content.res.loader.AssetsProvider") Object assetsProvider)
       throws IOException {
-    CppApkAssets apkAssets = CppApkAssets.loadArscFromFd((FileDescriptor) fileDescriptor);
+    CppApkAssets apkAssets = CppApkAssets.loadArscFromFd(fileDescriptor);
     if (apkAssets == null) {
       String errorMessage =
           String.format("Failed to load from the file descriptor %s", fileDescriptor);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager.java
index fd9e5534a..ea56fc9d5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager.java
@@ -20,7 +20,6 @@ import android.os.ParcelFileDescriptor;
 import android.util.SparseArray;
 import android.util.TypedValue;
 import com.google.common.annotations.VisibleForTesting;
-import com.google.common.base.Preconditions;
 import com.google.common.base.Strings;
 import dalvik.system.VMRuntime;
 import java.io.FileDescriptor;
@@ -33,6 +32,7 @@ import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
@@ -97,15 +97,14 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
   protected String[] list(String path) throws IOException {
     CppAssetManager am = assetManagerForJavaObject();
 
-    String fileName8 = path;
-    if (fileName8 == null) {
+    if (path == null) {
       return null;
     }
 
-    AssetDir dir = am.openDir(fileName8);
+    AssetDir dir = am.openDir(path);
 
     if (dir == null) {
-      throw new FileNotFoundException(fileName8);
+      throw new FileNotFoundException(path);
     }
 
     int N = dir.getFileCount();
@@ -347,9 +346,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
       return 0;
     }
 
-    int ident = am.getResources().identifierForName(name, defType, defPackage);
-
-    return ident;
+    return am.getResources().identifierForName(name, defType, defPackage);
   }
 
   @HiddenApi
@@ -359,8 +356,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
 
     ALOGV("openAsset in %s", am);
 
-    String fileName8 = fileName;
-    if (fileName8 == null) {
+    if (fileName == null) {
       throw new IllegalArgumentException("Empty file name");
     }
 
@@ -371,10 +367,10 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
       throw new IllegalArgumentException("Bad access mode");
     }
 
-    Asset a = am.open(fileName8, AccessMode.fromInt(mode));
+    Asset a = am.open(fileName, AccessMode.fromInt(mode));
 
     if (a == null) {
-      throw new FileNotFoundException(fileName8);
+      throw new FileNotFoundException(fileName);
     }
 
     // printf("Created Asset Stream: %p\n", a);
@@ -390,15 +386,14 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
 
     ALOGV("openAssetFd in %s", am);
 
-    String fileName8 = fileName;
-    if (fileName8 == null) {
+    if (fileName == null) {
       return null;
     }
 
-    Asset a = am.open(fileName8, Asset.AccessMode.ACCESS_RANDOM);
+    Asset a = am.open(fileName, Asset.AccessMode.ACCESS_RANDOM);
 
     if (a == null) {
-      throw new FileNotFoundException(fileName8);
+      throw new FileNotFoundException(fileName);
     }
 
     return returnParcelFileDescriptor(a, outOffsets);
@@ -413,8 +408,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
       return 0;
     }
     ALOGV("openNonAssetNative in %s (Java object %s)\n", am, AssetManager.class);
-    String fileName8 = fileName;
-    if (fileName8 == null) {
+    if (fileName == null) {
       return -1;
     }
     AccessMode mode = AccessMode.fromInt(accessMode);
@@ -426,10 +420,10 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     }
     Asset a =
         isTruthy(cookie)
-            ? am.openNonAsset(cookie, fileName8, mode)
-            : am.openNonAsset(fileName8, mode, null);
+            ? am.openNonAsset(cookie, fileName, mode)
+            : am.openNonAsset(fileName, mode, null);
     if (a == null) {
-      throw new FileNotFoundException(fileName8);
+      throw new FileNotFoundException(fileName);
     }
     long assetId = Registries.NATIVE_ASSET_REGISTRY.register(a);
     // todo: something better than this [xw]
@@ -497,8 +491,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
       throw new IndexOutOfBoundsException();
     }
 
-    byte[] b = bArray;
-    int res = a.read(b, off, len);
+    int res = a.read(bArray, off, len);
 
     if (res > 0) return res;
 
@@ -783,14 +776,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     //      return JNI_FALSE;
     //    }
 
-    int[] srcValues = inValues;
-    final int NSV = srcValues == null ? 0 : inValues.length;
-
-    int[] baseDest = outValues;
-    int destOffset = 0;
-    if (baseDest == null) {
-      return false;
-    }
+    final int NSV = inValues == null ? 0 : inValues.length;
 
     int[] indices = null;
     if (outIndices != null) {
@@ -803,7 +789,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
 
     boolean result =
         AttributeResolution.ResolveAttrs(
-            theme, defStyleAttr, defStyleRes, srcValues, NSV, src, NI, baseDest, indices);
+            theme, defStyleAttr, defStyleRes, inValues, NSV, src, NI, outValues, indices);
 
     if (indices != null) {
       //      env.ReleasePrimitiveArrayCritical(outIndices, indices, 0);
@@ -1052,7 +1038,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
   protected static int loadThemeAttributeValue(
       long themeHandle, int ident, TypedValue outValue, boolean resolve) {
     ResTableTheme theme =
-        Preconditions.checkNotNull(Registries.NATIVE_THEME_REGISTRY.getNativeObject(themeHandle));
+        Objects.requireNonNull(Registries.NATIVE_THEME_REGISTRY.getNativeObject(themeHandle));
     ResTable res = theme.getResTable();
 
     final Ref<Res_value> value = new Ref<>(null);
@@ -1086,23 +1072,22 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
 
     ALOGV("openXmlAsset in %s (Java object %s)\n", am, ShadowArscAssetManager.class);
 
-    String fileName8 = fileName;
-    if (fileName8 == null) {
+    if (fileName == null) {
       return 0;
     }
 
     int assetCookie = cookie;
     Asset a;
     if (isTruthy(assetCookie)) {
-      a = am.openNonAsset(assetCookie, fileName8, AccessMode.ACCESS_BUFFER);
+      a = am.openNonAsset(assetCookie, fileName, AccessMode.ACCESS_BUFFER);
     } else {
       final Ref<Integer> assetCookieRef = new Ref<>(assetCookie);
-      a = am.openNonAsset(fileName8, AccessMode.ACCESS_BUFFER, assetCookieRef);
+      a = am.openNonAsset(fileName, AccessMode.ACCESS_BUFFER, assetCookieRef);
       assetCookie = assetCookieRef.get();
     }
 
     if (a == null) {
-      throw new FileNotFoundException(fileName8);
+      throw new FileNotFoundException(fileName);
     }
 
     final DynamicRefTable dynamicRefTable =
@@ -1139,9 +1124,9 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     final Ref<Res_value> valueRef = new Ref<>(null);
     final bag_entry[] bag = startOfBag.get();
     int strLen = 0;
-    for (int i = 0; ((int) i) < N; i++) {
+    for (int i = 0; i < N; i++) {
       valueRef.set(bag[i].map.value);
-      String str = null;
+      String str;
 
       // Take care of resolving the found resource to its final value.
       int block = res.resolveReference(valueRef, bag[i].stringBlock, null);
@@ -1206,11 +1191,10 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     bag_entry[] bag = startOfBag.get();
     for (int i = 0, j = 0; i < N; i++) {
       int stringIndex = -1;
-      int stringBlock = 0;
       value.set(bag[i].map.value);
 
       // Take care of resolving the found resource to its final value.
-      stringBlock = res.resolveReference(value, bag[i].stringBlock, null);
+      int stringBlock = res.resolveReference(value, bag[i].stringBlock, null);
       if (value.get().dataType == DataType.STRING.code()) {
         stringIndex = value.get().data;
       }
@@ -1292,7 +1276,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     //  }
 
     Path androidFrameworkJarPath = RuntimeEnvironment.getAndroidFrameworkJarPath();
-    Preconditions.checkNotNull(androidFrameworkJarPath);
+    Objects.requireNonNull(androidFrameworkJarPath);
 
     if (isSystem) {
       synchronized (ShadowArscAssetManager.class) {
@@ -1356,9 +1340,8 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
 
   static ParcelFileDescriptor returnParcelFileDescriptor(Asset a, long[] outOffsets)
       throws FileNotFoundException {
-    final Ref<Long> startOffset = new Ref<Long>(-1L);
-    final Ref<Long> length = new Ref<Long>(-1L);
-    ;
+    final Ref<Long> startOffset = new Ref<>(-1L);
+    final Ref<Long> length = new Ref<>(-1L);
     FileDescriptor fd = a.openFileDescriptor(startOffset, length);
 
     if (fd == null) {
@@ -1366,14 +1349,13 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
           "This file can not be opened as a file descriptor; it is probably compressed");
     }
 
-    long[] offsets = outOffsets;
-    if (offsets == null) {
+    if (outOffsets == null) {
       // fd.close();
       return null;
     }
 
-    offsets[0] = startOffset.get();
-    offsets[1] = length.get();
+    outOffsets[0] = startOffset.get();
+    outOffsets[1] = length.get();
 
     // FileDescriptor fileDesc = jniCreateFileDescriptor(fd);
     // if (fileDesc == null) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager10.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager10.java
index 612ee9919..5590e9bc0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager10.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager10.java
@@ -81,9 +81,8 @@ import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
 import org.robolectric.versioning.AndroidVersions.U;
 
-// TODO: update path to released version.
 // transliterated from
-// https://android.googlesource.com/platform/frameworks/base/+/android-10.0.0_rXX/core/jni/android_util_AssetManager.cpp
+// https://android.googlesource.com/platform/frameworks/base/+/android-10.0.0_r47/core/jni/android_util_AssetManager.cpp
 
 @Implements(
     value = AssetManager.class,
@@ -349,7 +348,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
     if (config != null) {
       out_typed_value.density = config.density;
     }
-    return (int) (ApkAssetsCookieToJavaCookie(cookie));
+    return ApkAssetsCookieToJavaCookie(cookie);
   }
 
   //  @Override
@@ -605,9 +604,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
     configuration.sdkVersion = (short) (major_version);
 
     if (locale != null) {
-      String locale_utf8 = locale;
-      CHECK(locale_utf8 != null);
-      configuration.setBcp47Locale(locale_utf8);
+      configuration.setBcp47Locale(locale);
     }
 
     // Constants duplicated from Java class android.content.res.Configuration.
@@ -661,16 +658,15 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   @Implementation(minSdk = P)
   protected static @Nullable String[] nativeList(long ptr, @Nonnull String path)
       throws IOException {
-    String path_utf8 = path;
-    if (path_utf8 == null) {
+    if (path == null) {
       // This will throw NPE.
       return null;
     }
 
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
-    AssetDir asset_dir = assetmanager.OpenDir(path_utf8);
+    AssetDir asset_dir = assetmanager.OpenDir(path);
     if (asset_dir == null) {
-      throw new FileNotFoundException(path_utf8);
+      throw new FileNotFoundException(path);
     }
 
     int file_count = asset_dir.getFileCount();
@@ -703,13 +699,12 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   @Implementation(minSdk = P)
   protected static long nativeOpenAsset(long ptr, @Nonnull String asset_path, int access_mode)
       throws FileNotFoundException {
-    String asset_path_utf8 = asset_path;
-    if (asset_path_utf8 == null) {
+    if (asset_path == null) {
       // This will throw NPE.
       return 0;
     }
 
-    ATRACE_NAME(String.format("AssetManager::OpenAsset(%s)", asset_path_utf8));
+    ATRACE_NAME(String.format("AssetManager::OpenAsset(%s)", asset_path));
 
     if (access_mode != Asset.AccessMode.ACCESS_UNKNOWN.mode()
         && access_mode != Asset.AccessMode.ACCESS_RANDOM.mode()
@@ -719,9 +714,9 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
     }
 
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
-    Asset asset = assetmanager.Open(asset_path_utf8, Asset.AccessMode.fromInt(access_mode));
+    Asset asset = assetmanager.Open(asset_path, Asset.AccessMode.fromInt(access_mode));
     if (!isTruthy(asset)) {
-      throw new FileNotFoundException(asset_path_utf8);
+      throw new FileNotFoundException(asset_path);
     }
     return Registries.NATIVE_ASSET_REGISTRY.register(asset);
   }
@@ -731,18 +726,17 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   @Implementation(minSdk = P)
   protected static ParcelFileDescriptor nativeOpenAssetFd(
       long ptr, @Nonnull String asset_path, long[] out_offsets) throws IOException {
-    String asset_path_utf8 = asset_path;
-    if (asset_path_utf8 == null) {
+    if (asset_path == null) {
       // This will throw NPE.
       return null;
     }
 
-    ATRACE_NAME(String.format("AssetManager::OpenAssetFd(%s)", asset_path_utf8));
+    ATRACE_NAME(String.format("AssetManager::OpenAssetFd(%s)", asset_path));
 
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
-    Asset asset = assetmanager.Open(asset_path_utf8, Asset.AccessMode.ACCESS_RANDOM);
+    Asset asset = assetmanager.Open(asset_path, Asset.AccessMode.ACCESS_RANDOM);
     if (!isTruthy(asset)) {
-      throw new FileNotFoundException(asset_path_utf8);
+      throw new FileNotFoundException(asset_path);
     }
     return ReturnParcelFileDescriptor(asset, out_offsets);
   }
@@ -754,13 +748,12 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
       long ptr, int jcookie, @Nonnull String asset_path, int access_mode)
       throws FileNotFoundException {
     ApkAssetsCookie cookie = JavaCookieToApkAssetsCookie(jcookie);
-    String asset_path_utf8 = asset_path;
-    if (asset_path_utf8 == null) {
+    if (asset_path == null) {
       // This will throw NPE.
       return 0;
     }
 
-    ATRACE_NAME(String.format("AssetManager::OpenNonAsset(%s)", asset_path_utf8));
+    ATRACE_NAME(String.format("AssetManager::OpenNonAsset(%s)", asset_path));
 
     if (access_mode != Asset.AccessMode.ACCESS_UNKNOWN.mode()
         && access_mode != Asset.AccessMode.ACCESS_RANDOM.mode()
@@ -772,14 +765,13 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
     Asset asset;
     if (cookie.intValue() != kInvalidCookie) {
-      asset =
-          assetmanager.OpenNonAsset(asset_path_utf8, cookie, Asset.AccessMode.fromInt(access_mode));
+      asset = assetmanager.OpenNonAsset(asset_path, cookie, Asset.AccessMode.fromInt(access_mode));
     } else {
-      asset = assetmanager.OpenNonAsset(asset_path_utf8, Asset.AccessMode.fromInt(access_mode));
+      asset = assetmanager.OpenNonAsset(asset_path, Asset.AccessMode.fromInt(access_mode));
     }
 
     if (!isTruthy(asset)) {
-      throw new FileNotFoundException(asset_path_utf8);
+      throw new FileNotFoundException(asset_path);
     }
     return Registries.NATIVE_ASSET_REGISTRY.register(asset);
   }
@@ -791,24 +783,23 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
       long ptr, int jcookie, @Nonnull String asset_path, @Nonnull long[] out_offsets)
       throws IOException {
     ApkAssetsCookie cookie = JavaCookieToApkAssetsCookie(jcookie);
-    String asset_path_utf8 = asset_path;
-    if (asset_path_utf8 == null) {
+    if (asset_path == null) {
       // This will throw NPE.
       return null;
     }
 
-    ATRACE_NAME(String.format("AssetManager::OpenNonAssetFd(%s)", asset_path_utf8));
+    ATRACE_NAME(String.format("AssetManager::OpenNonAssetFd(%s)", asset_path));
 
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
     Asset asset;
     if (cookie.intValue() != kInvalidCookie) {
-      asset = assetmanager.OpenNonAsset(asset_path_utf8, cookie, Asset.AccessMode.ACCESS_RANDOM);
+      asset = assetmanager.OpenNonAsset(asset_path, cookie, Asset.AccessMode.ACCESS_RANDOM);
     } else {
-      asset = assetmanager.OpenNonAsset(asset_path_utf8, Asset.AccessMode.ACCESS_RANDOM);
+      asset = assetmanager.OpenNonAsset(asset_path, Asset.AccessMode.ACCESS_RANDOM);
     }
 
     if (!isTruthy(asset)) {
-      throw new FileNotFoundException(asset_path_utf8);
+      throw new FileNotFoundException(asset_path);
     }
     return ReturnParcelFileDescriptor(asset, out_offsets);
   }
@@ -819,26 +810,25 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   protected static long nativeOpenXmlAsset(long ptr, int jcookie, @Nonnull String asset_path)
       throws FileNotFoundException {
     ApkAssetsCookie cookie = JavaCookieToApkAssetsCookie(jcookie);
-    String asset_path_utf8 = asset_path;
-    if (asset_path_utf8 == null) {
+    if (asset_path == null) {
       // This will throw NPE.
       return 0;
     }
 
-    ATRACE_NAME(String.format("AssetManager::OpenXmlAsset(%s)", asset_path_utf8));
+    ATRACE_NAME(String.format("AssetManager::OpenXmlAsset(%s)", asset_path));
 
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
     Asset asset;
     if (cookie.intValue() != kInvalidCookie) {
-      asset = assetmanager.OpenNonAsset(asset_path_utf8, cookie, Asset.AccessMode.ACCESS_RANDOM);
+      asset = assetmanager.OpenNonAsset(asset_path, cookie, Asset.AccessMode.ACCESS_RANDOM);
     } else {
       Ref<ApkAssetsCookie> cookieRef = new Ref<>(cookie);
-      asset = assetmanager.OpenNonAsset(asset_path_utf8, Asset.AccessMode.ACCESS_RANDOM, cookieRef);
+      asset = assetmanager.OpenNonAsset(asset_path, Asset.AccessMode.ACCESS_RANDOM, cookieRef);
       cookie = cookieRef.get();
     }
 
     if (!isTruthy(asset)) {
-      throw new FileNotFoundException(asset_path_utf8);
+      throw new FileNotFoundException(asset_path);
     }
 
     // May be nullptr.
@@ -874,12 +864,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
               final Ref<Integer> flags = new Ref<>(0);
               ApkAssetsCookie cookie =
                   assetmanager.GetResource(
-                      resid,
-                      false /*may_be_bag*/,
-                      (short) (density),
-                      value,
-                      selected_config,
-                      flags);
+                      resid, false /*may_be_bag*/, density, value, selected_config, flags);
               if (cookie.intValue() == kInvalidCookie) {
                 return ApkAssetsCookieToJavaCookie(K_INVALID_COOKIE);
               }
@@ -911,7 +896,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
     ApkAssetsCookie cookie = K_INVALID_COOKIE;
     Res_value bag_value = null;
     for (ResolvedBag.Entry entry : bag.entries) {
-      if (entry.key == (int) (bag_entry_id)) {
+      if (entry.key == bag_entry_id) {
         cookie = entry.cookie;
         bag_value = entry.value;
 
@@ -990,13 +975,12 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
         CppApkAssets apk_assets = assetmanager.GetApkAssets().get(cookie.intValue());
         ResStringPool pool = apk_assets.GetLoadedArsc().GetStringPool();
 
-        String java_string = null;
+        String java_string;
         String str_utf8 = pool.stringAt(value.get().data);
         if (str_utf8 != null) {
           java_string = str_utf8;
         } else {
-          String str_utf16 = pool.stringAt(value.get().data);
-          java_string = str_utf16;
+          java_string = pool.stringAt(value.get().data);
         }
 
         // // Check for errors creating the strings (if malformed or no memory).
@@ -1050,7 +1034,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
 
       int string_index = -1;
       if (value.get().dataType == Res_value.TYPE_STRING) {
-        string_index = (int) (value.get().data);
+        string_index = value.get().data;
       }
 
       buffer[i * 2] = ApkAssetsCookieToJavaCookie(cookie);
@@ -1095,7 +1079,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
 
       if (value.get().dataType >= Res_value.TYPE_FIRST_INT
           && value.get().dataType <= Res_value.TYPE_LAST_INT) {
-        buffer[i] = (int) (value.get().data);
+        buffer[i] = value.get().data;
       }
     }
     // env.ReleasePrimitiveArrayCritical(array, buffer, 0);
@@ -1111,7 +1095,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
     if (bag == null) {
       return -1;
     }
-    return (int) (bag.entry_count);
+    return bag.entry_count;
   }
 
   // static jint NativeGetResourceArray(JNIEnv* env, jclass /*clazz*/, jlong ptr, jint resid,
@@ -1130,7 +1114,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
     //   return -1;
     // }
 
-    if ((int) (bag.entry_count) > out_data_length * STYLE_NUM_ENTRIES) {
+    if (bag.entry_count > out_data_length * STYLE_NUM_ENTRIES) {
       throw new IllegalArgumentException("Input array is not large enough");
     }
 
@@ -1140,7 +1124,6 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
       return -1;
     }
 
-    int[] cursor = buffer;
     for (int i = 0; i < bag.entry_count; i++) {
       ResolvedBag.Entry entry = bag.entries[i];
       final Ref<Res_value> value = new Ref<>(entry.value);
@@ -1161,16 +1144,16 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
       }
 
       int offset = i * STYLE_NUM_ENTRIES;
-      cursor[offset + STYLE_TYPE] = (int) (value.get().dataType);
-      cursor[offset + STYLE_DATA] = (int) (value.get().data);
-      cursor[offset + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
-      cursor[offset + STYLE_RESOURCE_ID] = (int) (ref.get());
-      cursor[offset + STYLE_CHANGING_CONFIGURATIONS] = (int) (flags.get());
-      cursor[offset + STYLE_DENSITY] = (int) (selected_config.get().density);
+      buffer[offset + STYLE_TYPE] = value.get().dataType;
+      buffer[offset + STYLE_DATA] = value.get().data;
+      buffer[offset + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
+      buffer[offset + STYLE_RESOURCE_ID] = ref.get();
+      buffer[offset + STYLE_CHANGING_CONFIGURATIONS] = flags.get();
+      buffer[offset + STYLE_DENSITY] = selected_config.get().density;
       // cursor += STYLE_NUM_ENTRIES;
     }
     // env.ReleasePrimitiveArrayCritical(out_data, buffer, 0);
-    return (int) (bag.entry_count);
+    return bag.entry_count;
   }
 
   // static jint NativeGetResourceIdentifier(JNIEnv* env, jclass /*clazz*/, jlong ptr, jstring name,
@@ -1178,27 +1161,13 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   @Implementation(minSdk = P)
   protected static @AnyRes int nativeGetResourceIdentifier(
       long ptr, @Nonnull String name, @Nullable String def_type, @Nullable String def_package) {
-    String name_utf8 = name;
-    if (name_utf8 == null) {
+    if (name == null) {
       // This will throw NPE.
       return 0;
     }
 
-    String type = null;
-    if (def_type != null) {
-      String type_utf8 = def_type;
-      CHECK(type_utf8 != null);
-      type = type_utf8;
-    }
-
-    String package_ = null;
-    if (def_package != null) {
-      String package_utf8 = def_package;
-      CHECK(package_utf8 != null);
-      package_ = package_utf8;
-    }
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
-    return (int) (assetmanager.GetResourceId(name_utf8, type, package_));
+    return assetmanager.GetResourceId(name, def_type, def_package);
   }
 
   // static jstring NativeGetResourceName(JNIEnv* env, jclass /*clazz*/, jlong ptr, jint resid) {
@@ -1311,12 +1280,11 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
 
     int idx = 0;
     for (String locale : locales) {
-      String java_string = locale;
-      if (java_string == null) {
+      if (locale == null) {
         return null;
       }
       // env.SetObjectArrayElement(array, idx++, java_string);
-      array[idx++] = java_string;
+      array[idx++] = locale;
       // env.DeleteLocalRef(java_string);
     }
     return array;
@@ -1424,8 +1392,8 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
     ApplyStyle(
         theme,
         xml_parser,
-        (int) (def_style_attr),
-        (int) (def_style_resid),
+        def_style_attr,
+        def_style_resid,
         attrs,
         attrs_len,
         out_values,
@@ -1507,8 +1475,8 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
     boolean result =
         ResolveAttrs(
             theme,
-            (int) (def_style_attr),
-            (int) (def_style_resid),
+            def_style_attr,
+            def_style_resid,
             values,
             values_len,
             attrs,
@@ -1718,7 +1686,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
   @Implementation(minSdk = P)
   protected static @NativeConfig int nativeThemeGetChangingConfigurations(long theme_ptr) {
     Theme theme = Registries.NATIVE_THEME9_REGISTRY.getNativeObject(theme_ptr);
-    return (int) (theme.GetChangingConfigurations());
+    return theme.GetChangingConfigurations();
   }
 
   // static void NativeAssetDestroy(JNIEnv* /*env*/, jclass /*clazz*/, jlong asset_ptr) {
@@ -1766,7 +1734,7 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
     if (res < 0) {
       throw new IOException();
     }
-    return res > 0 ? (int) (res) : -1;
+    return res > 0 ? res : -1;
   }
 
   // static jlong NativeAssetSeek(JNIEnv* env, jclass /*clazz*/, jlong asset_ptr, jlong offset,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager14.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager14.java
index e2585c651..69d222801 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager14.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager14.java
@@ -7,12 +7,12 @@ import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.InDevelopment;
+import org.robolectric.versioning.AndroidVersions.Baklava;
 import org.robolectric.versioning.AndroidVersions.U;
 import org.robolectric.versioning.AndroidVersions.V;
 
-// TODO: update path to released version.
 // transliterated from
-// https://android.googlesource.com/platform/frameworks/base/+/android-10.0.0_rXX/core/jni/android_util_AssetManager.cpp
+// https://android.googlesource.com/platform/frameworks/base/+/android-10.0.0_r47/core/jni/android_util_AssetManager.cpp
 
 @Implements(
     value = AssetManager.class,
@@ -130,6 +130,59 @@ public class ShadowArscAssetManager14 extends ShadowArscAssetManager10 {
         majorVersion);
   }
 
+  @Implementation(minSdk = Baklava.SDK_INT)
+  @InDevelopment
+  protected static void nativeSetConfiguration(
+      long ptr,
+      int mcc,
+      int mnc,
+      /* Used only when locales is null or empty. */
+      @Nullable String defaultLocale,
+      /* At this moment, only the first element in locales is used and others are ignored. */
+      @Nonnull String[] locales,
+      int orientation,
+      int touchscreen,
+      int density,
+      int keyboard,
+      int keyboardHidden,
+      int navigation,
+      int screenWidth,
+      int screenHeight,
+      int smallestScreenWidthDp,
+      int screenWidthDp,
+      int screenHeightDp,
+      int screenLayout,
+      int uiMode,
+      int colorMode,
+      int grammaticalGender,
+      int majorVersion,
+      int minorVersion, // ignore for now
+      boolean forceRefresh) {
+    nativeSetConfiguration(
+        ptr,
+        mcc,
+        mnc,
+        defaultLocale,
+        locales,
+        orientation,
+        touchscreen,
+        density,
+        keyboard,
+        keyboardHidden,
+        navigation,
+        screenWidth,
+        screenHeight,
+        smallestScreenWidthDp,
+        screenWidthDp,
+        screenHeightDp,
+        screenLayout,
+        uiMode,
+        colorMode,
+        grammaticalGender,
+        majorVersion,
+        forceRefresh);
+  }
+
   @Implementation(minSdk = V.SDK_INT)
   @InDevelopment
   protected static void nativeSetApkAssets(
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager9.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager9.java
index 70adee336..876a5b7bf 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager9.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager9.java
@@ -343,7 +343,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
     if (config != null) {
       out_typed_value.density = config.density;
     }
-    return (int) (ApkAssetsCookieToJavaCookie(cookie));
+    return ApkAssetsCookieToJavaCookie(cookie);
   }
 
   //  @Override
@@ -600,9 +600,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
     configuration.sdkVersion = (short) (major_version);
 
     if (locale != null) {
-      String locale_utf8 = locale;
-      CHECK(locale_utf8 != null);
-      configuration.setBcp47Locale(locale_utf8);
+      configuration.setBcp47Locale(locale);
     }
 
     // Constants duplicated from Java class android.content.res.Configuration.
@@ -650,16 +648,15 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   @Implementation(minSdk = P)
   protected static @Nullable String[] nativeList(long ptr, @Nonnull String path)
       throws IOException {
-    String path_utf8 = path;
-    if (path_utf8 == null) {
+    if (path == null) {
       // This will throw NPE.
       return null;
     }
 
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
-    AssetDir asset_dir = assetmanager.OpenDir(path_utf8);
+    AssetDir asset_dir = assetmanager.OpenDir(path);
     if (asset_dir == null) {
-      throw new FileNotFoundException(path_utf8);
+      throw new FileNotFoundException(path);
     }
 
     int file_count = asset_dir.getFileCount();
@@ -692,13 +689,12 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   @Implementation(minSdk = P)
   protected static long nativeOpenAsset(long ptr, @Nonnull String asset_path, int access_mode)
       throws FileNotFoundException {
-    String asset_path_utf8 = asset_path;
-    if (asset_path_utf8 == null) {
+    if (asset_path == null) {
       // This will throw NPE.
       return 0;
     }
 
-    ATRACE_NAME(String.format("AssetManager::OpenAsset(%s)", asset_path_utf8));
+    ATRACE_NAME(String.format("AssetManager::OpenAsset(%s)", asset_path));
 
     if (access_mode != Asset.AccessMode.ACCESS_UNKNOWN.mode()
         && access_mode != Asset.AccessMode.ACCESS_RANDOM.mode()
@@ -708,9 +704,9 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
     }
 
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
-    Asset asset = assetmanager.Open(asset_path_utf8, Asset.AccessMode.fromInt(access_mode));
+    Asset asset = assetmanager.Open(asset_path, Asset.AccessMode.fromInt(access_mode));
     if (!isTruthy(asset)) {
-      throw new FileNotFoundException(asset_path_utf8);
+      throw new FileNotFoundException(asset_path);
     }
     return Registries.NATIVE_ASSET_REGISTRY.register(asset);
   }
@@ -720,18 +716,17 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   @Implementation(minSdk = P)
   protected static ParcelFileDescriptor nativeOpenAssetFd(
       long ptr, @Nonnull String asset_path, long[] out_offsets) throws IOException {
-    String asset_path_utf8 = asset_path;
-    if (asset_path_utf8 == null) {
+    if (asset_path == null) {
       // This will throw NPE.
       return null;
     }
 
-    ATRACE_NAME(String.format("AssetManager::OpenAssetFd(%s)", asset_path_utf8));
+    ATRACE_NAME(String.format("AssetManager::OpenAssetFd(%s)", asset_path));
 
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
-    Asset asset = assetmanager.Open(asset_path_utf8, Asset.AccessMode.ACCESS_RANDOM);
+    Asset asset = assetmanager.Open(asset_path, Asset.AccessMode.ACCESS_RANDOM);
     if (!isTruthy(asset)) {
-      throw new FileNotFoundException(asset_path_utf8);
+      throw new FileNotFoundException(asset_path);
     }
     return ReturnParcelFileDescriptor(asset, out_offsets);
   }
@@ -743,13 +738,12 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
       long ptr, int jcookie, @Nonnull String asset_path, int access_mode)
       throws FileNotFoundException {
     ApkAssetsCookie cookie = JavaCookieToApkAssetsCookie(jcookie);
-    String asset_path_utf8 = asset_path;
-    if (asset_path_utf8 == null) {
+    if (asset_path == null) {
       // This will throw NPE.
       return 0;
     }
 
-    ATRACE_NAME(String.format("AssetManager::OpenNonAsset(%s)", asset_path_utf8));
+    ATRACE_NAME(String.format("AssetManager::OpenNonAsset(%s)", asset_path));
 
     if (access_mode != Asset.AccessMode.ACCESS_UNKNOWN.mode()
         && access_mode != Asset.AccessMode.ACCESS_RANDOM.mode()
@@ -761,14 +755,13 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
     Asset asset;
     if (cookie.intValue() != kInvalidCookie) {
-      asset =
-          assetmanager.OpenNonAsset(asset_path_utf8, cookie, Asset.AccessMode.fromInt(access_mode));
+      asset = assetmanager.OpenNonAsset(asset_path, cookie, Asset.AccessMode.fromInt(access_mode));
     } else {
-      asset = assetmanager.OpenNonAsset(asset_path_utf8, Asset.AccessMode.fromInt(access_mode));
+      asset = assetmanager.OpenNonAsset(asset_path, Asset.AccessMode.fromInt(access_mode));
     }
 
     if (!isTruthy(asset)) {
-      throw new FileNotFoundException(asset_path_utf8);
+      throw new FileNotFoundException(asset_path);
     }
     return Registries.NATIVE_ASSET_REGISTRY.register(asset);
   }
@@ -780,24 +773,23 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
       long ptr, int jcookie, @Nonnull String asset_path, @Nonnull long[] out_offsets)
       throws IOException {
     ApkAssetsCookie cookie = JavaCookieToApkAssetsCookie(jcookie);
-    String asset_path_utf8 = asset_path;
-    if (asset_path_utf8 == null) {
+    if (asset_path == null) {
       // This will throw NPE.
       return null;
     }
 
-    ATRACE_NAME(String.format("AssetManager::OpenNonAssetFd(%s)", asset_path_utf8));
+    ATRACE_NAME(String.format("AssetManager::OpenNonAssetFd(%s)", asset_path));
 
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
     Asset asset;
     if (cookie.intValue() != kInvalidCookie) {
-      asset = assetmanager.OpenNonAsset(asset_path_utf8, cookie, Asset.AccessMode.ACCESS_RANDOM);
+      asset = assetmanager.OpenNonAsset(asset_path, cookie, Asset.AccessMode.ACCESS_RANDOM);
     } else {
-      asset = assetmanager.OpenNonAsset(asset_path_utf8, Asset.AccessMode.ACCESS_RANDOM);
+      asset = assetmanager.OpenNonAsset(asset_path, Asset.AccessMode.ACCESS_RANDOM);
     }
 
     if (!isTruthy(asset)) {
-      throw new FileNotFoundException(asset_path_utf8);
+      throw new FileNotFoundException(asset_path);
     }
     return ReturnParcelFileDescriptor(asset, out_offsets);
   }
@@ -808,26 +800,25 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   protected static long nativeOpenXmlAsset(long ptr, int jcookie, @Nonnull String asset_path)
       throws FileNotFoundException {
     ApkAssetsCookie cookie = JavaCookieToApkAssetsCookie(jcookie);
-    String asset_path_utf8 = asset_path;
-    if (asset_path_utf8 == null) {
+    if (asset_path == null) {
       // This will throw NPE.
       return 0;
     }
 
-    ATRACE_NAME(String.format("AssetManager::OpenXmlAsset(%s)", asset_path_utf8));
+    ATRACE_NAME(String.format("AssetManager::OpenXmlAsset(%s)", asset_path));
 
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
     Asset asset;
     if (cookie.intValue() != kInvalidCookie) {
-      asset = assetmanager.OpenNonAsset(asset_path_utf8, cookie, Asset.AccessMode.ACCESS_RANDOM);
+      asset = assetmanager.OpenNonAsset(asset_path, cookie, Asset.AccessMode.ACCESS_RANDOM);
     } else {
       Ref<ApkAssetsCookie> cookieRef = new Ref<>(cookie);
-      asset = assetmanager.OpenNonAsset(asset_path_utf8, Asset.AccessMode.ACCESS_RANDOM, cookieRef);
+      asset = assetmanager.OpenNonAsset(asset_path, Asset.AccessMode.ACCESS_RANDOM, cookieRef);
       cookie = cookieRef.get();
     }
 
     if (!isTruthy(asset)) {
-      throw new FileNotFoundException(asset_path_utf8);
+      throw new FileNotFoundException(asset_path);
     }
 
     // May be nullptr.
@@ -859,7 +850,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
     final Ref<Integer> flags = new Ref<>(0);
     ApkAssetsCookie cookie =
         assetmanager.GetResource(
-            resid, false /*may_be_bag*/, (short) (density), value, selected_config, flags);
+            resid, false /*may_be_bag*/, density, value, selected_config, flags);
     if (cookie.intValue() == kInvalidCookie) {
       return ApkAssetsCookieToJavaCookie(K_INVALID_COOKIE);
     }
@@ -890,7 +881,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
     ApkAssetsCookie cookie = K_INVALID_COOKIE;
     Res_value bag_value = null;
     for (ResolvedBag.Entry entry : bag.entries) {
-      if (entry.key == (int) (bag_entry_id)) {
+      if (entry.key == bag_entry_id) {
         cookie = entry.cookie;
         bag_value = entry.value;
 
@@ -969,14 +960,13 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
         CppApkAssets apk_assets = assetmanager.GetApkAssets().get(cookie.intValue());
         ResStringPool pool = apk_assets.GetLoadedArsc().GetStringPool();
 
-        String java_string = null;
+        String java_string;
         int str_len;
         String str_utf8 = pool.stringAt(value.get().data);
         if (str_utf8 != null) {
           java_string = str_utf8;
         } else {
-          String str_utf16 = pool.stringAt(value.get().data);
-          java_string = str_utf16;
+          java_string = pool.stringAt(value.get().data);
         }
 
         // // Check for errors creating the strings (if malformed or no memory).
@@ -1030,7 +1020,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
 
       int string_index = -1;
       if (value.get().dataType == Res_value.TYPE_STRING) {
-        string_index = (int) (value.get().data);
+        string_index = value.get().data;
       }
 
       buffer[i * 2] = ApkAssetsCookieToJavaCookie(cookie);
@@ -1075,7 +1065,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
 
       if (value.get().dataType >= Res_value.TYPE_FIRST_INT
           && value.get().dataType <= Res_value.TYPE_LAST_INT) {
-        buffer[i] = (int) (value.get().data);
+        buffer[i] = value.get().data;
       }
     }
     // env.ReleasePrimitiveArrayCritical(array, buffer, 0);
@@ -1091,7 +1081,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
     if (bag == null) {
       return -1;
     }
-    return (int) (bag.entry_count);
+    return bag.entry_count;
   }
 
   // static jint NativeGetResourceArray(JNIEnv* env, jclass /*clazz*/, jlong ptr, jint resid,
@@ -1110,7 +1100,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
     //   return -1;
     // }
 
-    if ((int) (bag.entry_count) > out_data_length * STYLE_NUM_ENTRIES) {
+    if (bag.entry_count > out_data_length * STYLE_NUM_ENTRIES) {
       throw new IllegalArgumentException("Input array is not large enough");
     }
 
@@ -1120,7 +1110,6 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
       return -1;
     }
 
-    int[] cursor = buffer;
     for (int i = 0; i < bag.entry_count; i++) {
       ResolvedBag.Entry entry = bag.entries[i];
       final Ref<Res_value> value = new Ref<>(entry.value);
@@ -1141,16 +1130,16 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
       }
 
       int offset = i * STYLE_NUM_ENTRIES;
-      cursor[offset + STYLE_TYPE] = (int) (value.get().dataType);
-      cursor[offset + STYLE_DATA] = (int) (value.get().data);
-      cursor[offset + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
-      cursor[offset + STYLE_RESOURCE_ID] = (int) (ref.get());
-      cursor[offset + STYLE_CHANGING_CONFIGURATIONS] = (int) (flags.get());
-      cursor[offset + STYLE_DENSITY] = (int) (selected_config.get().density);
+      buffer[offset + STYLE_TYPE] = value.get().dataType;
+      buffer[offset + STYLE_DATA] = value.get().data;
+      buffer[offset + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
+      buffer[offset + STYLE_RESOURCE_ID] = ref.get();
+      buffer[offset + STYLE_CHANGING_CONFIGURATIONS] = flags.get();
+      buffer[offset + STYLE_DENSITY] = selected_config.get().density;
       // cursor += STYLE_NUM_ENTRIES;
     }
     // env.ReleasePrimitiveArrayCritical(out_data, buffer, 0);
-    return (int) (bag.entry_count);
+    return bag.entry_count;
   }
 
   // static jint NativeGetResourceIdentifier(JNIEnv* env, jclass /*clazz*/, jlong ptr, jstring name,
@@ -1158,27 +1147,13 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   @Implementation(minSdk = P)
   protected static @AnyRes int nativeGetResourceIdentifier(
       long ptr, @Nonnull String name, @Nullable String def_type, @Nullable String def_package) {
-    String name_utf8 = name;
-    if (name_utf8 == null) {
+    if (name == null) {
       // This will throw NPE.
       return 0;
     }
 
-    String type = null;
-    if (def_type != null) {
-      String type_utf8 = def_type;
-      CHECK(type_utf8 != null);
-      type = type_utf8;
-    }
-
-    String package_ = null;
-    if (def_package != null) {
-      String package_utf8 = def_package;
-      CHECK(package_utf8 != null);
-      package_ = package_utf8;
-    }
     CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
-    return (int) (assetmanager.GetResourceId(name_utf8, type, package_));
+    return assetmanager.GetResourceId(name, def_type, def_package);
   }
 
   // static jstring NativeGetResourceName(JNIEnv* env, jclass /*clazz*/, jlong ptr, jint resid) {
@@ -1291,12 +1266,11 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
 
     int idx = 0;
     for (String locale : locales) {
-      String java_string = locale;
-      if (java_string == null) {
+      if (locale == null) {
         return null;
       }
       // env.SetObjectArrayElement(array, idx++, java_string);
-      array[idx++] = java_string;
+      array[idx++] = locale;
       // env.DeleteLocalRef(java_string);
     }
     return array;
@@ -1404,8 +1378,8 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
     ApplyStyle(
         theme,
         xml_parser,
-        (int) (def_style_attr),
-        (int) (def_style_resid),
+        def_style_attr,
+        def_style_resid,
         attrs,
         attrs_len,
         out_values,
@@ -1487,8 +1461,8 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
     boolean result =
         ResolveAttrs(
             theme,
-            (int) (def_style_attr),
-            (int) (def_style_resid),
+            def_style_attr,
+            def_style_resid,
             values,
             values_len,
             attrs,
@@ -1691,7 +1665,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
   @Implementation(minSdk = P)
   protected static @NativeConfig int nativeThemeGetChangingConfigurations(long theme_ptr) {
     Theme theme = Registries.NATIVE_THEME9_REGISTRY.getNativeObject(theme_ptr);
-    return (int) (theme.GetChangingConfigurations());
+    return theme.GetChangingConfigurations();
   }
 
   // static void NativeAssetDestroy(JNIEnv* /*env*/, jclass /*clazz*/, jlong asset_ptr) {
@@ -1739,7 +1713,7 @@ public class ShadowArscAssetManager9 extends ShadowAssetManager.ArscBase {
     if (res < 0) {
       throw new IOException();
     }
-    return res > 0 ? (int) (res) : -1;
+    return res > 0 ? res : -1;
   }
 
   // static jlong NativeAssetSeek(JNIEnv* env, jclass /*clazz*/, jlong asset_ptr, jlong offset,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscResourcesImpl.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscResourcesImpl.java
index 5ca7947fa..b9ea772e4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscResourcesImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscResourcesImpl.java
@@ -67,7 +67,6 @@ public class ShadowArscResourcesImpl extends ShadowResourcesImpl {
   public AssetFileDescriptor openRawResourceFd(int id) throws Resources.NotFoundException {
     InputStream inputStream =
         reflector(ResourcesImplReflector.class, realResourcesImpl).openRawResource(id);
-    ;
     if (!(inputStream instanceof FileInputStream)) {
       // todo fixme
       return null;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAsyncTask.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAsyncTask.java
index d60580ef6..eb6f081aa 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAsyncTask.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAsyncTask.java
@@ -3,7 +3,12 @@ package org.robolectric.shadows;
 import android.os.AsyncTask;
 import org.robolectric.annotation.Implements;
 
-/** The shadow API for {@link android.os.AsyncTask}. */
+/**
+ * The shadow API for {@link AsyncTask}.
+ *
+ * @deprecated {@link AsyncTask} is deprecated in the Android SDK.
+ */
+@Deprecated
 @Implements(value = AsyncTask.class, shadowPicker = ShadowAsyncTask.Picker.class)
 public abstract class ShadowAsyncTask<Params, Progress, Result> {
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAsyncTaskLoader.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAsyncTaskLoader.java
index 17357d66e..12adf280c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAsyncTaskLoader.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAsyncTaskLoader.java
@@ -2,15 +2,18 @@ package org.robolectric.shadows;
 
 import android.content.AsyncTaskLoader;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.LooperMode;
 
 /**
  * The shadow API for {@link AsyncTaskLoader}.
  *
  * <p>Different shadow implementations will be used based on the current {@link LooperMode.Mode}.
  *
+ * @deprecated {@link AsyncTaskLoader} is deprecated in the Android SDK.
  * @see ShadowLegacyAsyncTaskLoader
  * @see ShadowPausedAsyncTaskLoader
  */
+@Deprecated
 @Implements(value = AsyncTaskLoader.class, shadowPicker = ShadowAsyncTaskLoader.Picker.class)
 public abstract class ShadowAsyncTaskLoader<D> {
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioEffect.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioEffect.java
index f98a8e875..96ab46690 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioEffect.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioEffect.java
@@ -171,8 +171,8 @@ public class ShadowAudioEffect {
   /**
    * Sets the error code to override setter methods in this class.
    *
-   * <p>When the error code is set to anything other than {@link SUCCESS} setters in the AudioEffect
-   * will early-out and return that error code.
+   * <p>When the error code is set to anything other than {@link AudioEffect#SUCCESS} setters in the
+   * AudioEffect will early-out and return that error code.
    */
   public void setErrorCode(int errorCode) {
     this.errorCode = errorCode;
@@ -195,7 +195,7 @@ public class ShadowAudioEffect {
    */
   @Implementation
   protected static AudioEffect.Descriptor[] queryEffects() {
-    return descriptors.toArray(new AudioEffect.Descriptor[descriptors.size()]);
+    return descriptors.toArray(new AudioEffect.Descriptor[0]);
   }
 
   /** Returns all effects created with an {@code AudioEffect} constructor. */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java
index 5b7014bde..a2bddb469 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java
@@ -12,8 +12,8 @@ import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
+import android.annotation.RequiresApi;
 import android.annotation.RequiresPermission;
-import android.annotation.TargetApi;
 import android.media.AudioAttributes;
 import android.media.AudioDeviceCallback;
 import android.media.AudioDeviceInfo;
@@ -29,7 +29,6 @@ import android.os.Build.VERSION_CODES;
 import android.os.Handler;
 import android.os.Parcel;
 import android.view.KeyEvent;
-import com.android.internal.util.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import java.util.ArrayList;
@@ -83,7 +82,7 @@ public class ShadowAudioManager {
   private int nextResponseValue = AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
   private AudioManager.OnAudioFocusChangeListener lastAbandonedAudioFocusListener;
   private android.media.AudioFocusRequest lastAbandonedAudioFocusRequest;
-  private HashMap<Integer, AudioStream> streamStatus = new HashMap<>();
+  private final HashMap<Integer, AudioStream> streamStatus = new HashMap<>();
   private List<AudioPlaybackConfiguration> activePlaybackConfigurations = Collections.emptyList();
   private List<AudioRecordingConfiguration> activeRecordingConfigurations = ImmutableList.of();
   private final HashSet<AudioManager.AudioRecordingCallback> audioRecordingCallbacks =
@@ -215,7 +214,7 @@ public class ShadowAudioManager {
     if (!AudioManager.isValidRingerMode(ringerMode)) {
       return;
     }
-    this.ringerMode = ringerMode;
+    ShadowAudioManager.ringerMode = ringerMode;
   }
 
   @Implementation
@@ -225,14 +224,14 @@ public class ShadowAudioManager {
             <= (int) ReflectionHelpers.getStaticField(AudioManager.class, "RINGER_MODE_MAX");
   }
 
-  /** Note that this method can silently fail. See {@link lockMode}. */
+  /** Note that this method can silently fail. See {@link #lockMode}. */
   @Implementation
   protected void setMode(int mode) {
     if (lockMode) {
       return;
     }
-    int previousMode = this.mode;
-    this.mode = mode;
+    int previousMode = ShadowAudioManager.mode;
+    ShadowAudioManager.mode = mode;
     if (RuntimeEnvironment.getApiLevel() >= S && mode != previousMode) {
       dispatchModeChangedListeners(mode);
     }
@@ -262,14 +261,14 @@ public class ShadowAudioManager {
         .dispatchAudioModeChanged(newMode);
   }
 
-  /** Sets whether subsequent calls to {@link setMode} will succeed or not. */
+  /** Sets whether subsequent calls to {@link #setMode} will succeed or not. */
   public void lockMode(boolean lockMode) {
-    this.lockMode = lockMode;
+    ShadowAudioManager.lockMode = lockMode;
   }
 
   @Implementation
   protected int getMode() {
-    return this.mode;
+    return mode;
   }
 
   @ForType(className = "android.media.AudioManager$ModeDispatcherStub")
@@ -335,7 +334,7 @@ public class ShadowAudioManager {
 
   @Implementation
   protected void setBluetoothScoOn(boolean isBluetoothScoOn) {
-    this.isBluetoothScoOn = isBluetoothScoOn;
+    ShadowAudioManager.isBluetoothScoOn = isBluetoothScoOn;
   }
 
   @Implementation
@@ -439,7 +438,7 @@ public class ShadowAudioManager {
   }
 
   public void setIsBluetoothScoAvailableOffCall(boolean isBluetoothScoAvailableOffCall) {
-    this.isBluetoothScoAvailableOffCall = isBluetoothScoAvailableOffCall;
+    ShadowAudioManager.isBluetoothScoAvailableOffCall = isBluetoothScoAvailableOffCall;
   }
 
   public void setIsStreamMute(int streamType, boolean isMuted) {
@@ -448,7 +447,7 @@ public class ShadowAudioManager {
 
   /**
    * Registers callback that will receive changes made to the list of active playback configurations
-   * by {@link setActivePlaybackConfigurationsFor}.
+   * by {@link #setActivePlaybackConfigurationsFor)}.
    */
   @Implementation(minSdk = O)
   protected void registerAudioPlaybackCallback(
@@ -599,7 +598,7 @@ public class ShadowAudioManager {
    * #addOutputDevice(AudioDeviceInfo, boolean)}, {@link #removeOutputDevice(AudioDeviceInfo,
    * boolean)}.
    */
-  @TargetApi(VERSION_CODES.S)
+  @RequiresApi(VERSION_CODES.S)
   public void setAvailableCommunicationDevices(
       List<AudioDeviceInfo> availableCommunicationDevices) {
     this.availableCommunicationDevices = new ArrayList<>(availableCommunicationDevices);
@@ -656,7 +655,7 @@ public class ShadowAudioManager {
    * AudioDeviceCallback} if the device was not present before and indicated by {@code
    * notifyAudioDeviceCallbacks}.
    */
-  @TargetApi(VERSION_CODES.S)
+  @RequiresApi(VERSION_CODES.S)
   public void addAvailableCommunicationDevice(
       AudioDeviceInfo communicationDevice, boolean notifyAudioDeviceCallbacks) {
     boolean changed =
@@ -672,7 +671,7 @@ public class ShadowAudioManager {
    * AudioDeviceCallback} if the device was present before and indicated by {@code
    * notifyAudioDeviceCallbacks}.
    */
-  @TargetApi(VERSION_CODES.S)
+  @RequiresApi(VERSION_CODES.S)
   public void removeAvailableCommunicationDevice(
       AudioDeviceInfo communicationDevice, boolean notifyAudioDeviceCallbacks) {
     boolean changed = this.availableCommunicationDevices.remove(communicationDevice);
@@ -740,7 +739,7 @@ public class ShadowAudioManager {
     return outputDevices;
   }
 
-  /** Note that this method can silently fail. See {@link lockCommunicationDevice}. */
+  /** Note that this method can silently fail. See {@link #lockCommunicationDevice}. */
   @Implementation(minSdk = S)
   protected boolean setCommunicationDevice(AudioDeviceInfo communicationDevice) {
     if (!lockCommunicationDevice) {
@@ -749,9 +748,9 @@ public class ShadowAudioManager {
     return !lockCommunicationDevice;
   }
 
-  /** Sets whether subsequent calls to {@link setCommunicationDevice} will succeed. */
+  /** Sets whether subsequent calls to {@link #setCommunicationDevice} will succeed. */
   public void lockCommunicationDevice(boolean lockCommunicationDevice) {
-    this.lockCommunicationDevice = lockCommunicationDevice;
+    ShadowAudioManager.lockCommunicationDevice = lockCommunicationDevice;
   }
 
   @Implementation(minSdk = S)
@@ -804,7 +803,7 @@ public class ShadowAudioManager {
    * <p>Note that there is no public {@link AudioPlaybackConfiguration} constructor, so the
    * configurations returned are specified by their audio attributes only.
    */
-  @TargetApi(VERSION_CODES.O)
+  @RequiresApi(VERSION_CODES.O)
   public void setActivePlaybackConfigurationsFor(List<AudioAttributes> audioAttributes) {
     setActivePlaybackConfigurationsFor(audioAttributes, /* notifyCallbackListeners= */ false);
   }
@@ -813,7 +812,7 @@ public class ShadowAudioManager {
    * Same as {@link #setActivePlaybackConfigurationsFor(List)}, but also notifies callbacks if
    * notifyCallbackListeners is true.
    */
-  @TargetApi(VERSION_CODES.O)
+  @RequiresApi(VERSION_CODES.O)
   public void setActivePlaybackConfigurationsFor(
       List<AudioAttributes> audioAttributes, boolean notifyCallbackListeners) {
     if (RuntimeEnvironment.getApiLevel() < O) {
@@ -875,7 +874,7 @@ public class ShadowAudioManager {
   }
 
   public void setIsMusicActive(boolean isMusicActive) {
-    this.isMusicActive = isMusicActive;
+    ShadowAudioManager.isMusicActive = isMusicActive;
   }
 
   public AudioFocusRequest getLastAudioFocusRequest() {
@@ -905,7 +904,7 @@ public class ShadowAudioManager {
 
   /**
    * Registers callback that will receive changes made to the list of active recording
-   * configurations by {@link setActiveRecordingConfigurations}.
+   * configurations by {@link #setActiveRecordingConfigurations}.
    */
   @Implementation(minSdk = N)
   protected void registerAudioRecordingCallback(
@@ -966,15 +965,15 @@ public class ShadowAudioManager {
    * <p>Note: this implementation does NOT ensure that we have the permissions necessary to register
    * the given {@link AudioPolicy}.
    *
-   * @return {@link AudioManager.ERROR} if the given policy has already been registered, and {@link
-   *     AudioManager.SUCCESS} otherwise.
+   * @return {@link AudioManager#ERROR} if the given policy has already been registered, and {@link
+   *     AudioManager#SUCCESS} otherwise.
    */
   @HiddenApi
   @Implementation(minSdk = P)
   @RequiresPermission(android.Manifest.permission.MODIFY_AUDIO_ROUTING)
   protected int registerAudioPolicy(
       @Nonnull @ClassName("android.media.audiopolicy.AudioPolicy") Object audioPolicy) {
-    Preconditions.checkNotNull(audioPolicy, "Illegal null AudioPolicy argument");
+    Objects.requireNonNull(audioPolicy, "Illegal null AudioPolicy argument");
     AudioPolicy policy = (AudioPolicy) audioPolicy;
     String id = getIdForAudioPolicy(audioPolicy);
     if (registeredAudioPolicies.containsKey(id)) {
@@ -989,7 +988,7 @@ public class ShadowAudioManager {
   @Implementation(minSdk = Q)
   protected void unregisterAudioPolicy(
       @Nonnull @ClassName("android.media.audiopolicy.AudioPolicy") Object audioPolicy) {
-    Preconditions.checkNotNull(audioPolicy, "Illegal null AudioPolicy argument");
+    Objects.requireNonNull(audioPolicy, "Illegal null AudioPolicy argument");
     AudioPolicy policy = (AudioPolicy) audioPolicy;
     registeredAudioPolicies.remove(getIdForAudioPolicy(policy));
     policy.setRegistration(null);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioSystem.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioSystem.java
index 630160ad9..4037602b5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioSystem.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioSystem.java
@@ -4,7 +4,7 @@ import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import android.media.AudioAttributes;
 import android.media.AudioFormat;
@@ -96,8 +96,8 @@ public class ShadowAudioSystem {
    */
   public static void setDirectPlaybackSupport(
       @Nonnull AudioFormat format, @Nonnull AudioAttributes attr, int directPlaybackSupport) {
-    checkNotNull(format, "Illegal null AudioFormat");
-    checkNotNull(attr, "Illegal null AudioAttributes");
+    requireNonNull(format, "Illegal null AudioFormat");
+    requireNonNull(attr, "Illegal null AudioAttributes");
     directPlaybackSupportTable.put(format, attr.getUsage(), directPlaybackSupport);
   }
 
@@ -130,8 +130,8 @@ public class ShadowAudioSystem {
    */
   public static void setOffloadPlaybackSupport(
       @Nonnull AudioFormat format, @Nonnull AudioAttributes attr, int offloadSupport) {
-    checkNotNull(format, "Illegal null AudioFormat");
-    checkNotNull(attr, "Illegal null AudioAttributes");
+    requireNonNull(format, "Illegal null AudioFormat");
+    requireNonNull(attr, "Illegal null AudioAttributes");
     offloadPlaybackSupportTable.put(
         new OffloadSupportFormat(
             format.getEncoding(),
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java
index 7e02b6ade..4067cc342 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java
@@ -1,7 +1,6 @@
 package org.robolectric.shadows;
 
 import static android.media.AudioTrack.ERROR_DEAD_OBJECT;
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.O_MR1;
@@ -11,7 +10,7 @@ import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 import static org.robolectric.shadow.api.Shadow.directlyOn;
 
 import android.annotation.RequiresApi;
@@ -132,8 +131,8 @@ public class ShadowAudioTrack {
    */
   public static void addDirectPlaybackSupport(
       @Nonnull AudioFormat format, @Nonnull AudioAttributes attr) {
-    checkNotNull(format);
-    checkNotNull(attr);
+    requireNonNull(format);
+    requireNonNull(attr);
     checkArgument(!isPcm(format.getEncoding()));
 
     directSupportedFormats.put(
@@ -439,20 +438,19 @@ public class ShadowAudioTrack {
 
   @Implementation(minSdk = M)
   public void setPlaybackParams(@Nonnull PlaybackParams params) {
-    playbackParams = checkNotNull(params, "Illegal null params");
+    playbackParams = requireNonNull(params, "Illegal null params");
   }
 
   /**
    * Sets the estimated latency of this {@link AudioTrack} that will be returned by {@code
    * AudioTrack.getLatency()}, in milliseconds.
    */
-  @RequiresApi(LOLLIPOP)
   public void setLatency(int latencyMs) {
     this.latencyMs = latencyMs;
   }
 
   /** Returns the estimated latency of this {@link AudioTrack}, in milliseconds. */
-  @Implementation(minSdk = LOLLIPOP)
+  @Implementation
   protected int native_get_latency() {
     return latencyMs;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java
index 5a4b465b9..6397904d1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java
@@ -11,7 +11,7 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
 
-/** Robolectric implementation of {@link android.os.AutofillManager}. */
+/** Robolectric implementation of {@link AutofillManager}. */
 @Implements(value = AutofillManager.class, minSdk = O)
 public class ShadowAutofillManager {
   @Nullable private static ComponentName autofillServiceComponentName = null;
@@ -56,7 +56,7 @@ public class ShadowAutofillManager {
    * AutofillManager#getAutofillServiceComponentName()}.
    */
   public void setAutofillServiceComponentName(@Nullable ComponentName componentName) {
-    this.autofillServiceComponentName = componentName;
+    autofillServiceComponentName = componentName;
   }
 
   /**
@@ -64,7 +64,7 @@ public class ShadowAutofillManager {
    * AutofillManager#isAutofillSupported()}.
    */
   public void setAutofillSupported(boolean supported) {
-    this.autofillSupported = supported;
+    autofillSupported = supported;
   }
 
   /**
@@ -72,6 +72,6 @@ public class ShadowAutofillManager {
    * AutofillManager#isEnabled()}.
    */
   public void setEnabled(boolean enabled) {
-    this.enabled = enabled;
+    ShadowAutofillManager.enabled = enabled;
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackupManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackupManager.java
index e40c61fc6..22acfee60 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackupManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackupManager.java
@@ -1,6 +1,7 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.M;
+import static android.os.Build.VERSION_CODES.P;
 
 import android.app.backup.BackupManager;
 import android.app.backup.BackupTransport;
@@ -14,6 +15,7 @@ import android.os.Handler;
 import android.os.IBinder;
 import android.os.Looper;
 import android.os.RemoteException;
+import android.os.UserHandle;
 import com.google.common.collect.ArrayListMultimap;
 import com.google.common.collect.ListMultimap;
 import java.util.ArrayList;
@@ -88,6 +90,17 @@ public class ShadowBackupManager {
     return serviceState.backupEnabled;
   }
 
+  @Implementation(minSdk = P)
+  @HiddenApi // SystemApi
+  protected boolean isBackupServiceActive(UserHandle user) {
+    enforceBackupPermission("isBackupServiceActive");
+    return serviceState.backupServiceActive;
+  }
+
+  public void setBackupServiceActive(UserHandle user, boolean makeActive) {
+    serviceState.backupServiceActive = makeActive;
+  }
+
   @Implementation
   @HiddenApi // SystemApi
   protected RestoreSession beginRestoreSession() {
@@ -263,6 +276,7 @@ public class ShadowBackupManager {
   }
 
   private static class BackupManagerServiceState {
+    boolean backupServiceActive = true;
     boolean backupEnabled = true;
     boolean nullRestoreData;
     long lastRestoreToken = 0L;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBatteryManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBatteryManager.java
index 6484674ba..fa276b32d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBatteryManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBatteryManager.java
@@ -63,6 +63,6 @@ public class ShadowBatteryManager {
     Preconditions.checkArgument(
         chargeTimeRemaining == -1 || chargeTimeRemaining >= 0,
         "chargeTimeRemaining must be -1 or non-negative.");
-    this.chargeTimeRemaining = chargeTimeRemaining;
+    ShadowBatteryManager.chargeTimeRemaining = chargeTimeRemaining;
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinderBridge.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinderBridge.java
index b5e594c55..a181895af 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinderBridge.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinderBridge.java
@@ -10,7 +10,7 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
 /** Bridge between shadow and {@link android.os.Binder}. */
 @DoNotInstrument
 public class ShadowBinderBridge {
-  private Binder realBinder;
+  private final Binder realBinder;
 
   public ShadowBinderBridge(Binder realBinder) {
     this.realBinder = realBinder;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBiometricManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBiometricManager.java
index 4f8286a5c..b2edd2420 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBiometricManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBiometricManager.java
@@ -35,7 +35,6 @@ public class ShadowBiometricManager {
     authenticatorType = BiometricManager.Authenticators.EMPTY_SET;
   }
 
-  @SuppressWarnings("deprecation")
   @RequiresPermission(USE_BIOMETRIC)
   @Implementation
   protected int canAuthenticate() {
@@ -97,8 +96,8 @@ public class ShadowBiometricManager {
 
   /**
    * Sets the value {@code true} to allow {@link #canAuthenticate()} return {@link
-   * BIOMETRIC_SUCCESS} If sets the value to {@code false}, result will depend on {@link
-   * BiometricManager#hasBiometrics(Context context)}
+   * BiometricManager#BIOMETRIC_SUCCESS} If sets the value to {@code false}, result will depend on
+   * {@link BiometricManager#hasBiometrics(Context)}
    *
    * @param flag to set can authenticate or not
    */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java
index ce857ff4d..51c52c5d1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java
@@ -9,6 +9,7 @@ import android.content.res.AssetManager.AssetInputStream;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
+import android.graphics.BitmapFactory.Options;
 import android.graphics.Point;
 import android.graphics.Rect;
 import android.net.Uri;
@@ -43,7 +44,7 @@ import org.robolectric.util.reflector.Static;
 @SuppressWarnings({"UnusedDeclaration"})
 @Implements(BitmapFactory.class)
 public class ShadowBitmapFactory {
-  private static Map<String, Point> widthAndHeightMap = new HashMap<>();
+  private static final Map<String, Point> widthAndHeightMap = new HashMap<>();
 
   // Determines whether BitmapFactory.decode methods should allow invalid bitmap data and always
   // return a Bitmap object. Currently defaults to true to preserve legacy behavior. A
@@ -127,7 +128,7 @@ public class ShadowBitmapFactory {
     // If a real FileDescriptor is used, attempt to get the image size.
     if (fd != null && fd.valid()) {
       try (FileInputStream fileInputStream = new FileInputStream(fd);
-          BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream); ) {
+          BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream)) {
         image = getImageFromStream(bufferedInputStream);
       } catch (IOException e) {
         Logger.warn("Error getting size of bitmap file", e);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothA2dp.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothA2dp.java
index eac7525f4..3e06bc3ae 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothA2dp.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothA2dp.java
@@ -15,6 +15,8 @@ import android.bluetooth.BluetoothProfile;
 import android.content.Intent;
 import android.util.Log;
 import com.google.common.collect.ImmutableList;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -28,11 +30,13 @@ import org.robolectric.annotation.RealObject;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.versioning.AndroidVersions;
+import org.robolectric.versioning.AndroidVersions.Baklava;
 
 /** Shadow of {@link BluetoothA2dp}. */
 @Implements(BluetoothA2dp.class)
 public class ShadowBluetoothA2dp {
   private static final String TAG = "BluetoothA2dp";
+  private static final boolean VERIFY_DEVICE_NOT_NULL_IS_STATIC = verifyDeviceNotNullIsStatic();
 
   @RealObject protected BluetoothA2dp realObject;
 
@@ -200,15 +204,34 @@ public class ShadowBluetoothA2dp {
     void verifyDeviceNotNull(BluetoothDevice device, String methodName);
   }
 
+  private static boolean verifyDeviceNotNullIsStatic() {
+    Method m = null;
+    try {
+      m =
+          BluetoothA2dp.class.getDeclaredMethod(
+              "verifyDeviceNotNull", BluetoothDevice.class, String.class);
+      return Modifier.isStatic(m.getModifiers());
+    } catch (NoSuchMethodException e) {
+      if (AndroidVersions.CURRENT.getSdkInt() >= AndroidVersions.R.SDK_INT) {
+        throw new RuntimeException("Method verifyDeviceNotNull not found in BluetoothA2dp", e);
+      }
+    }
+    return false; // never used since less than minSdk of R.
+  }
+
   @InDevelopment
-  @Implementation(minSdk = R, maxSdk = AndroidVersions.V.SDK_INT, methodName = "verifyDeviceNotNull")
-  protected void verifyDeviceNotNullPreBaklava(BluetoothDevice device, String methodName) {
-    reflector(BluetoothA2dpReflector.class, realObject).verifyDeviceNotNull(device, methodName);
+  @Implementation(minSdk = R, maxSdk = Baklava.SDK_INT, methodName = "verifyDeviceNotNull")
+  protected void verifyDeviceNotNull(BluetoothDevice device, String methodName) {
+    if (VERIFY_DEVICE_NOT_NULL_IS_STATIC) {
+      reflector(BluetoothA2dpReflector.class).verifyDeviceNotNull(device, methodName);
+    } else {
+      reflector(BluetoothA2dpReflector.class, realObject).verifyDeviceNotNull(device, methodName);
+    }
   }
 
   @InDevelopment
-  @Implementation(minSdk = AndroidVersions.Baklava.SDK_INT)
-  protected static void verifyDeviceNotNull(BluetoothDevice device, String methodName) {
+  @Implementation(minSdk = Baklava.SDK_INT, methodName = "verifyDeviceNotNull")
+  protected static void verifyDeviceNotNullBaklava(BluetoothDevice device, String methodName) {
     reflector(BluetoothA2dpReflector.class).verifyDeviceNotNull(device, methodName);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java
index f9d5732aa..52d333487 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java
@@ -92,9 +92,9 @@ public class ShadowBluetoothAdapter {
   private static boolean isBluetoothSupported = true;
 
   private static final Map<String, BluetoothDevice> deviceCache = new HashMap<>();
-  private Set<BluetoothDevice> bondedDevices = new HashSet<BluetoothDevice>();
+  private Set<BluetoothDevice> bondedDevices = new HashSet<>();
   private List<BluetoothDevice> mostRecentlyConnectedDevices = new ArrayList<>();
-  private Set<LeScanCallback> leScanCallbacks = new HashSet<LeScanCallback>();
+  private final Set<LeScanCallback> leScanCallbacks = new HashSet<>();
   private boolean isDiscovering;
   private String address;
   private int state;
@@ -371,38 +371,34 @@ public class ShadowBluetoothAdapter {
     return true;
   }
 
-  /**
-   * Needs looseSignatures because in Android T the return value of this method was changed from
-   * bool to int.
-   */
-  @Implementation(maxSdk = S_V2)
-  protected boolean setScanMode(int scanMode) {
-    boolean result =
-        scanMode == BluetoothAdapter.SCAN_MODE_CONNECTABLE
-            || scanMode == BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE
-            || scanMode == BluetoothAdapter.SCAN_MODE_NONE;
+  @SuppressWarnings("ProtectedImplementationLintCheck")
+  @Implementation(minSdk = TIRAMISU)
+  public int setScanMode(int scanMode) {
     this.scanMode = scanMode;
-    return result;
-  }
-
-  @Implementation(minSdk = TIRAMISU, methodName = "setScanMode")
-  protected int setScanModeFromT(int scanMode) {
-    return setScanMode(scanMode)
+    return (scanMode == BluetoothAdapter.SCAN_MODE_CONNECTABLE
+            || scanMode == BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE
+            || scanMode == BluetoothAdapter.SCAN_MODE_NONE)
         ? BluetoothStatusCodes.SUCCESS
         : BluetoothStatusCodes.ERROR_UNKNOWN;
   }
 
+  /** Needs `methodName` because in Android T the return value was changed from bool to int. */
+  @Implementation(maxSdk = S_V2, methodName = "setScanMode")
+  protected boolean setScanModeSV2(int scanMode) {
+    return setScanMode(scanMode) == BluetoothStatusCodes.SUCCESS;
+  }
+
   @Implementation(maxSdk = Q)
   protected boolean setScanMode(int scanMode, int discoverableTimeout) {
     setDiscoverableTimeout(discoverableTimeout);
-    return (boolean) setScanMode(scanMode);
+    return setScanMode(scanMode) == BluetoothStatusCodes.SUCCESS;
   }
 
   @Implementation(minSdk = R, maxSdk = S_V2)
   protected boolean setScanMode(int scanMode, long durationMillis) {
-    int durationSeconds = Math.toIntExact(durationMillis / 1000);
+    int durationSeconds = (int) Duration.ofMillis(durationMillis).toSeconds();
     setDiscoverableTimeout(durationSeconds);
-    return (boolean) setScanMode(scanMode);
+    return setScanMode(scanMode) == BluetoothStatusCodes.SUCCESS;
   }
 
   @Implementation
@@ -478,7 +474,7 @@ public class ShadowBluetoothAdapter {
 
   /**
    * Returns the connection state for the given Bluetooth {@code profile}, defaulting to {@link
-   * BluetoothProfile.STATE_DISCONNECTED} if the profile's connection state was never set.
+   * BluetoothProfile#STATE_DISCONNECTED} if the profile's connection state was never set.
    *
    * <p>Set a Bluetooth profile's connection state via {@link #setProfileConnectionState(int, int)}.
    */
@@ -499,10 +495,7 @@ public class ShadowBluetoothAdapter {
     this.state = state;
   }
 
-  /**
-   * @deprecated Use {@link BluetoothAdapter#enable()} or {@link BluetoothAdapter#disable()}.
-   */
-  @Deprecated
+  /** Sets the enabled state of the adapter. */
   public void setEnabled(boolean enabled) {
     if (enabled) {
       enable();
@@ -512,14 +505,14 @@ public class ShadowBluetoothAdapter {
   }
 
   /**
-   * Sets the value for {@link isBleScanAlwaysAvailable}. If true, {@link getLeState} will always
+   * Sets the value for {@link #isBleScanAlwaysAvailable}. If true, {@link #getLeState} will always
    * return true.
    */
   public void setBleScanAlwaysAvailable(boolean alwaysAvailable) {
     isBleScanAlwaysAvailable = alwaysAvailable;
   }
 
-  /** Sets the value for {@link isMultipleAdvertisementSupported}. */
+  /** Sets the value for {@link #isMultipleAdvertisementSupported}. */
   public void setIsMultipleAdvertisementSupported(boolean supported) {
     isMultipleAdvertisementSupported = supported;
   }
@@ -557,14 +550,14 @@ public class ShadowBluetoothAdapter {
   }
 
   /**
-   * Overrides behavior of {@link getProfileProxy} if {@link ShadowBluetoothAdapter#setProfileProxy}
-   * has been previously called.
+   * Overrides behavior of {@link #getProfileProxy} if {@link
+   * ShadowBluetoothAdapter#setProfileProxy} has been previously called.
    *
-   * <p>If active (non-null) proxy has been set by {@link setProfileProxy} for the given {@code
-   * profile}, {@link getProfileProxy} will immediately call {@code onServiceConnected} of the given
-   * BluetoothProfile.ServiceListener {@code listener}.
+   * <p>If active (non-null) proxy has been set by {@link #setProfileProxy} for the given {@code
+   * profile}, {@link #getProfileProxy} will immediately call {@code onServiceConnected} of the
+   * given BluetoothProfile.ServiceListener {@code listener}.
    *
-   * @return 'true' if a proxy object has been set by {@link setProfileProxy} for the given
+   * @return 'true' if a proxy object has been set by {@link #setProfileProxy} for the given
    *     BluetoothProfile {@code profile}
    */
   @Implementation
@@ -592,7 +585,7 @@ public class ShadowBluetoothAdapter {
   }
 
   /**
-   * Overrides behavior of {@link closeProfileProxy} if {@link
+   * Overrides behavior of {@link #closeProfileProxy} if {@link
    * ShadowBluetoothAdapter#setProfileProxy} has been previously called.
    *
    * <p>If the given non-null BluetoothProfile {@code proxy} was previously set for the given {@code
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothDevice.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothDevice.java
index 84f201404..fbbec4408 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothDevice.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothDevice.java
@@ -49,10 +49,10 @@ public class ShadowBluetoothDevice {
   /**
    * Interceptor interface for {@link BluetoothGatt} objects. Tests that require configuration of
    * their ShadowBluetoothGatt's may inject an interceptor, which will be called with the newly
-   * constructed BluetoothGatt before {@link ShadowBluetoothGatt#connectGatt} returns.
+   * constructed BluetoothGatt before {@link ShadowBluetoothDevice#connectGatt} returns.
    */
-  public static interface BluetoothGattConnectionInterceptor {
-    public void onNewGattConnection(BluetoothGatt gatt);
+  public interface BluetoothGattConnectionInterceptor {
+    void onNewGattConnection(BluetoothGatt gatt);
   }
 
   @Deprecated // Prefer {@link android.bluetooth.BluetoothAdapter#getRemoteDevice}
@@ -88,7 +88,7 @@ public class ShadowBluetoothDevice {
   private boolean isInSilenceMode = false;
   private boolean isConnected = false;
   @Nullable private BluetoothGattConnectionInterceptor bluetoothGattConnectionInterceptor = null;
-  private Map<Integer, Integer> connectionHandlesByTransportType = new HashMap<>();
+  private final Map<Integer, Integer> connectionHandlesByTransportType = new HashMap<>();
 
   /**
    * Implements getService() in the same way the original method does, but ignores any Exceptions
@@ -281,6 +281,13 @@ public class ShadowBluetoothDevice {
     return createdBond;
   }
 
+  /** Returns whether this device has been bonded with. */
+  @Implementation
+  protected boolean createBond(int transport) {
+    checkForBluetoothConnectPermission();
+    return createdBond;
+  }
+
   @Implementation(minSdk = Q)
   protected BluetoothSocket createInsecureL2capChannel(int psm) throws IOException {
     checkForBluetoothConnectPermission();
@@ -502,7 +509,7 @@ public class ShadowBluetoothDevice {
   }
 
   /**
-   * Allows tests to intercept the {@link BluetoothDevice.connectGatt} method and set state on both
+   * Allows tests to intercept the {@link BluetoothDevice#connectGatt} method and set state on both
    * BluetoothDevice and BluetoothGatt objects. This is useful for e2e testing situations where the
    * fine-grained execution of Bluetooth connection logic is onerous.
    */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothGatt.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothGatt.java
index ba0e34be8..616d1b745 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothGatt.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothGatt.java
@@ -53,7 +53,6 @@ public class ShadowBluetoothGatt {
   @ReflectorObject protected BluetoothGattReflector bluetoothGattReflector;
 
   @SuppressLint("PrivateApi")
-  @SuppressWarnings("unchecked")
   public static BluetoothGatt newInstance(BluetoothDevice device) {
     try {
       Class<?> iBluetoothGattClass =
@@ -86,7 +85,7 @@ public class ShadowBluetoothGatt {
                   Integer.TYPE
                 },
                 new Object[] {null, device, 0, false, 0});
-      } else if (apiLevel >= O) {
+      } else if (apiLevel == O) {
         bluetoothGatt =
             Shadow.newInstance(
                 BluetoothGatt.class,
@@ -177,7 +176,7 @@ public class ShadowBluetoothGatt {
 
   /**
    * Overrides {@link BluetoothGatt#requestMtu} to always fail before {@link
-   * ShadowBlueoothGatt.setGattCallback} is called, and always succeed after.
+   * ShadowBluetoothGatt#setGattCallback} is called, and always succeed after.
    */
   @Implementation(minSdk = O)
   protected boolean requestMtu(int mtu) {
@@ -225,7 +224,7 @@ public class ShadowBluetoothGatt {
   }
 
   /**
-   * Overrides {@link BluetoothGatt#getService} to return a service with given UUID.
+   * Overrides {@link BluetoothGatt#getService(UUID)} to return a service with given UUID.
    *
    * @return a service with given UUID that have been discovered through {@link
    *     ShadowBluetoothGatt#discoverServices}.
@@ -385,8 +384,8 @@ public class ShadowBluetoothGatt {
   }
 
   /**
-   * Simulate a successful Gatt Client Conection with {@link BluetoothConnectionManager}. Performs a
-   * {@link BluetoothGattCallback#onConnectionStateChange} if available.
+   * Simulate a successful Gatt Client Connection with {@link BluetoothConnectionManager}. Performs
+   * a {@link BluetoothGattCallback#onConnectionStateChange} if available.
    *
    * @param remoteAddress address of Gatt client
    */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothGattServer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothGattServer.java
index b75885367..6321f922c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothGattServer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothGattServer.java
@@ -5,6 +5,7 @@ import static android.os.Build.VERSION_CODES.O;
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCallback;
 import android.bluetooth.BluetoothGattCharacteristic;
 import android.bluetooth.BluetoothGattServer;
 import android.bluetooth.BluetoothGattServerCallback;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothHeadset.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothHeadset.java
index f0158dc70..547d561c9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothHeadset.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothHeadset.java
@@ -34,8 +34,8 @@ public class ShadowBluetoothHeadset {
   private boolean isVoiceRecognitionSupported = true;
 
   /**
-   * Overrides behavior of {@link getConnectedDevices}. Returns list of devices that is set up by
-   * call(s) to {@link ShadowBluetoothHeadset#addConnectedDevice} or {@link connect}. Returns an
+   * Overrides behavior of {@link #getConnectedDevices}. Returns list of devices that is set up by
+   * call(s) to {@link ShadowBluetoothHeadset#addConnectedDevice} or {@link #connect}. Returns an
    * empty list by default.
    */
   @Implementation
@@ -66,10 +66,10 @@ public class ShadowBluetoothHeadset {
   }
 
   /**
-   * Overrides behavior of {@link getConnectionState}.
+   * Overrides behavior of {@link #getConnectionState}.
    *
    * @return {@code BluetoothProfile.STATE_CONNECTED} if the given device has been previously added
-   *     by a call to {@link ShadowBluetoothHeadset#addConnectedDevice} or {@link connect}, and
+   *     by a call to {@link ShadowBluetoothHeadset#addConnectedDevice} or {@link #connect}, and
    *     {@code BluetoothProfile.STATE_DISCONNECTED} otherwise.
    */
   @Implementation
@@ -90,7 +90,7 @@ public class ShadowBluetoothHeadset {
   }
 
   /**
-   * Overrides behavior of {@link connect}. Returns {@code true} and adds {@code device} to the
+   * Overrides behavior of {@link #connect}. Returns {@code true} and adds {@code device} to the
    * shadow profile's connected device list if {@code device} is currently disconnected, and returns
    * {@code false} otherwise.
    */
@@ -104,7 +104,7 @@ public class ShadowBluetoothHeadset {
   }
 
   /**
-   * Overrides behavior of {@link disconnect}. Returns {@code true} and removes {@code device} from
+   * Overrides behavior of {@link #disconnect}. Returns {@code true} and removes {@code device} from
    * the shadow profile's connected device list if {@code device} is currently connected, and
    * returns {@code false} otherwise.
    */
@@ -118,11 +118,12 @@ public class ShadowBluetoothHeadset {
   }
 
   /**
-   * Overrides behavior of {@link startVoiceRecognition}. Returns false if 'bluetoothDevice' is null
-   * or voice recognition is already started. Users can listen to {@link
-   * ACTION_AUDIO_STATE_CHANGED}. If this function returns true, this intent will be broadcasted
-   * once with {@link BluetoothProfile.EXTRA_STATE} set to {@link STATE_AUDIO_CONNECTING} and once
-   * set to {@link STATE_AUDIO_CONNECTED}.
+   * Overrides behavior of {@link #startVoiceRecognition}. Returns false if 'bluetoothDevice' is
+   * null or voice recognition is already started. Users can listen to {@link
+   * BluetoothHeadset#ACTION_AUDIO_STATE_CHANGED}. If this function returns true, this intent will
+   * be broadcasted once with {@link BluetoothProfile#EXTRA_STATE} set to {@link
+   * BluetoothHeadset#STATE_AUDIO_CONNECTING} and once set to {@link
+   * BluetoothHeadset#STATE_AUDIO_CONNECTED}.
    */
   @Implementation
   protected boolean startVoiceRecognition(BluetoothDevice bluetoothDevice) {
@@ -141,10 +142,10 @@ public class ShadowBluetoothHeadset {
   }
 
   /**
-   * Overrides the behavior of {@link stopVoiceRecognition}. Returns false if voice recognition was
+   * Overrides the behavior of {@link #stopVoiceRecognition}. Returns false if voice recognition was
    * not started or voice recognition has already ended on this headset. If this function returns
-   * true, {@link ACTION_AUDIO_STATE_CHANGED} intent is broadcasted with {@link
-   * BluetoothProfile.EXTRA_STATE} set to {@link STATE_DISCONNECTED}.
+   * true, {@link BluetoothHeadset#ACTION_AUDIO_STATE_CHANGED} intent is broadcasted with {@link
+   * BluetoothProfile#EXTRA_STATE} set to {@link BluetoothHeadset#STATE_DISCONNECTED}.
    */
   @Implementation
   protected boolean stopVoiceRecognition(BluetoothDevice bluetoothDevice) {
@@ -162,10 +163,10 @@ public class ShadowBluetoothHeadset {
   }
 
   /**
-   * Overrides behavior of {@link sendVendorSpecificResultCode}.
+   * Overrides behavior of {@link #sendVendorSpecificResultCode}.
    *
    * @return 'true' only if the given device has been previously added by a call to {@link
-   *     ShadowBluetoothHeadset#addConnectedDevice} or {@link connect}, and {@link
+   *     ShadowBluetoothHeadset#addConnectedDevice} or {@link #connect}, and {@link
    *     ShadowBluetoothHeadset#setAllowsSendVendorSpecificResultCode} has not been called with
    *     'false' argument.
    * @throws IllegalArgumentException if 'command' argument is null, per Android API
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothLeAdvertiser.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothLeAdvertiser.java
index b3c8db249..66accba7b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothLeAdvertiser.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothLeAdvertiser.java
@@ -3,12 +3,18 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.O;
 
 import android.bluetooth.le.AdvertiseCallback;
+import android.bluetooth.le.AdvertiseData;
+import android.bluetooth.le.AdvertiseSettings;
 import android.bluetooth.le.AdvertisingSetCallback;
+import android.bluetooth.le.AdvertisingSetParameters;
 import android.bluetooth.le.BluetoothLeAdvertiser;
+import android.bluetooth.le.PeriodicAdvertisingParameters;
 import java.util.Map;
+import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.ReflectorObject;
 import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 
 /** Shadow implementation of {@link BluetoothLeAdvertiser}. */
@@ -16,6 +22,8 @@ import org.robolectric.util.reflector.ForType;
 public class ShadowBluetoothLeAdvertiser {
   @ReflectorObject protected BluetoothLeAdvertiserReflector bluetoothLeAdvertiserReflector;
 
+  private AdvertiseData lastAdvertiseData;
+
   /** Returns the count of current ongoing Bluetooth LE advertising requests. */
   public int getAdvertisementRequestCount() {
     return bluetoothLeAdvertiserReflector.getLegacyAdvertisers().size();
@@ -26,6 +34,30 @@ public class ShadowBluetoothLeAdvertiser {
     return bluetoothLeAdvertiserReflector.getAdvertisingSets().size();
   }
 
+  @Implementation
+  protected void startAdvertising(
+      AdvertiseSettings settings, AdvertiseData advertiseData, AdvertiseCallback callback) {
+    bluetoothLeAdvertiserReflector.startAdvertising(settings, advertiseData, callback);
+    this.lastAdvertiseData = advertiseData;
+  }
+
+  @Implementation
+  protected void startAdvertisingSet(
+      AdvertisingSetParameters parameters,
+      AdvertiseData advertiseData,
+      AdvertiseData scanResponse,
+      PeriodicAdvertisingParameters periodicParameters,
+      AdvertiseData periodicData,
+      AdvertisingSetCallback callback) {
+    bluetoothLeAdvertiserReflector.startAdvertisingSet(
+        parameters, advertiseData, scanResponse, periodicParameters, periodicData, callback);
+    this.lastAdvertiseData = advertiseData;
+  }
+
+  public AdvertiseData getLastAdvertisingData() {
+    return lastAdvertiseData;
+  }
+
   @ForType(BluetoothLeAdvertiser.class)
   private interface BluetoothLeAdvertiserReflector {
     @Accessor("mLegacyAdvertisers")
@@ -33,5 +65,18 @@ public class ShadowBluetoothLeAdvertiser {
 
     @Accessor("mAdvertisingSets")
     Map<?, ?> getAdvertisingSets();
+
+    @Direct
+    void startAdvertisingSet(
+        AdvertisingSetParameters parameters,
+        AdvertiseData advertiseData,
+        AdvertiseData scanResponse,
+        PeriodicAdvertisingParameters periodicParameters,
+        AdvertiseData periodicData,
+        AdvertisingSetCallback callback);
+
+    @Direct
+    void startAdvertising(
+        AdvertiseSettings settings, AdvertiseData advertiseData, AdvertiseCallback callback);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothLeScanner.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothLeScanner.java
index e57379a0d..d1cce47da 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothLeScanner.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothLeScanner.java
@@ -1,8 +1,8 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.O;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Collections.unmodifiableList;
+import static java.util.Objects.requireNonNull;
 
 import android.app.PendingIntent;
 import android.bluetooth.le.BluetoothLeScanner;
@@ -72,7 +72,7 @@ public class ShadowBluetoothLeScanner {
    */
   @Implementation
   protected void startScan(List<ScanFilter> filters, ScanSettings settings, ScanCallback callback) {
-    checkNotNull(callback);
+    requireNonNull(callback);
 
     if (filters != null) {
       filters = unmodifiableList(filters);
@@ -135,7 +135,7 @@ public class ShadowBluetoothLeScanner {
   }
 
   public void addScanResult(ScanResult scanResult) {
-    checkNotNull(scanResult);
+    requireNonNull(scanResult);
     this.scanResults.add(scanResult);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothManager.java
index b5ef6211f..c59ca3d79 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothManager.java
@@ -133,7 +133,7 @@ public class ShadowBluetoothManager {
   }
 
   /**
-   * Overrides behavior of {@link openGattServer} and returns {@link ShadowBluetoothGattServer}
+   * Overrides behavior of {@link #openGattServer} and returns {@link ShadowBluetoothGattServer}
    * after creating and using a nullProxy for {@link IBluetoothGatt}.
    */
   @Implementation(minSdk = S)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothSocket.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothSocket.java
index 90cdd2322..5d9e2e6a4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothSocket.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothSocket.java
@@ -6,6 +6,9 @@ import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.PipedInputStream;
 import java.io.PipedOutputStream;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.atomic.AtomicBoolean;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
@@ -16,13 +19,18 @@ public class ShadowBluetoothSocket {
   private OutputStream outputStream;
   private final InputStream inputStream;
 
+  // One permit allows connect() without a prior blockConnect() to complete immediately.
+  private final Semaphore connectSemaphore = new Semaphore(1);
+  private final AtomicBoolean wasBlockRequested = new AtomicBoolean(false);
+
   private enum SocketState {
     INIT,
     CONNECTED,
     CLOSED,
   }
 
-  private SocketState state = SocketState.INIT;
+  private volatile SocketState state = SocketState.INIT;
+  @Nullable private IOException connectExceptionOverride = null;
 
   public ShadowBluetoothSocket() {
     try {
@@ -58,6 +66,43 @@ public class ShadowBluetoothSocket {
     return outputStreamSink;
   }
 
+  /**
+   * Causes calls to {@link #connect()} to block until either {@link #unblockConnect()} or {@link
+   * #close()} are called. Note that the real implementation of {@link #connect()} is expected to
+   * unblock when the socket is closed from a different thread.
+   *
+   * <p>This method may only be called once per instance (a socket is only expected to be connected
+   * once).
+   */
+  public void blockConnect() {
+    if (!wasBlockRequested.compareAndSet(/* expectedValue= */ false, /* newValue= */ true)) {
+      throw new IllegalStateException("blockConnect() was previously called");
+    }
+    acquireConnectSemaphore();
+  }
+
+  /**
+   * Causes calls to {@link #connect()} to unblock. This may be called while {@link #connect()} is
+   * being called from another thread, or before {@link #connect()} is called.
+   *
+   * <p>{@link #blockConnect()} must be called before calling this method (otherwise, the socket is
+   * already unblocked, so there is no need to call this method).
+   */
+  public void unblockConnect() {
+    if (!wasBlockRequested.get()) {
+      throw new IllegalStateException("blockConnect() was not called");
+    }
+    connectSemaphore.release();
+  }
+
+  /**
+   * Set the exception that {@link #connect()} will throw if the socket is closed. This can be used
+   * to test situations where {@link android.bluetooth.BluetoothSocketException} is thrown.
+   */
+  public void setConnectException(IOException connectException) {
+    this.connectExceptionOverride = connectException;
+  }
+
   @Implementation
   protected InputStream getInputStream() {
     return inputStream;
@@ -73,17 +118,46 @@ public class ShadowBluetoothSocket {
     return state == SocketState.CONNECTED;
   }
 
-  /** This method doesn't perform an actual connection and returns immediately */
   @Implementation
   protected void connect() throws IOException {
+    // If already closed, throw immediately. The state cannot become CONNECTED again.
+    throwIfClosed();
+
+    // Set state before blocking so if the client calls close() to unblock connect(), the final
+    // state will be CLOSED.
+    state = SocketState.CONNECTED;
+
+    // If blockConnect() was called, execution will halt until the semaphore has been released.
+    // Release is called right afterward to avoid side effects on a later call to blockConnect().
+    acquireConnectSemaphore();
+    connectSemaphore.release();
+
+    // Throw if the socket was closed while waiting for the connect to complete. This reflects the
+    // behavior of the real BluetoothSocket.
+    throwIfClosed();
+  }
+
+  private void acquireConnectSemaphore() {
+    try {
+      connectSemaphore.acquire();
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+      throw new RuntimeException("Interrupted while waiting for connect semaphore", e);
+    }
+  }
+
+  private void throwIfClosed() throws IOException {
     if (state == SocketState.CLOSED) {
+      if (connectExceptionOverride != null) {
+        throw connectExceptionOverride;
+      }
       throw new IOException("socket closed");
     }
-    state = SocketState.CONNECTED;
   }
 
   @Implementation
   protected void close() throws IOException {
     state = SocketState.CLOSED;
+    connectSemaphore.release();
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBroadcastReceiver.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBroadcastReceiver.java
index 05ed662d9..428138d98 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBroadcastReceiver.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBroadcastReceiver.java
@@ -58,6 +58,10 @@ public class ShadowBroadcastReceiver {
     return wentAsync;
   }
 
+  public boolean isBroadcastAborted() {
+    return abort.get();
+  }
+
   public PendingResult getOriginalPendingResult() {
     if (wentAsync) {
       return originalPendingResult;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBuild.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBuild.java
index ae0506afe..59aba694a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBuild.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBuild.java
@@ -5,7 +5,7 @@ import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.S;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.TargetApi;
+import android.annotation.RequiresApi;
 import android.os.Build;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -141,7 +141,7 @@ public class ShadowBuild {
    *
    * <p>It will be reset for the next test.
    */
-  @TargetApi(S)
+  @RequiresApi(S)
   public static void setVersionMediaPerformanceClass(int performanceClass) {
     ReflectionHelpers.setStaticField(
         Build.VERSION.class, "MEDIA_PERFORMANCE_CLASS", performanceClass);
@@ -161,7 +161,7 @@ public class ShadowBuild {
    *
    * <p>It will be reset for the next test.
    */
-  @TargetApi(M)
+  @RequiresApi(M)
   public static void setVersionSecurityPatch(String securityPatch) {
     ReflectionHelpers.setStaticField(Build.VERSION.class, "SECURITY_PATCH", securityPatch);
   }
@@ -253,6 +253,17 @@ public class ShadowBuild {
     reflector(_Build_.class).setOdmSku(odmSku);
   }
 
+  /**
+   * Sets the value of the {@link Build#SKU} field.
+   *
+   * <p>It will be reset for the next test.
+   *
+   * <p>Added in API level 31.
+   */
+  public static void setSku(String sku) {
+    reflector(_Build_.class).setSku(sku);
+  }
+
   @Implementation
   protected static String getRadioVersion() {
     if (radioVersionOverride != null) {
@@ -285,6 +296,10 @@ public class ShadowBuild {
     @Accessor("ODM_SKU")
     void setOdmSku(String odmSku);
 
+    @Static
+    @Accessor("SKU")
+    void setSku(String sku);
+
     @Static
     @Direct
     String getRadioVersion();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCallRedirectionService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCallRedirectionService.java
new file mode 100644
index 000000000..bb4c98a66
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCallRedirectionService.java
@@ -0,0 +1,159 @@
+package org.robolectric.shadows;
+
+import android.content.Intent;
+import android.net.Uri;
+import android.os.RemoteException;
+import android.telecom.CallRedirectionService;
+import android.telecom.PhoneAccountHandle;
+import com.android.internal.telecom.ICallRedirectionAdapter;
+import com.android.internal.telecom.ICallRedirectionService;
+import java.util.Optional;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.ReflectorObject;
+import org.robolectric.annotation.Resetter;
+import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.reflector.Direct;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions.Q;
+
+/** Robolectric shadow to support {@link CallRedirectionService}. */
+@Implements(value = CallRedirectionService.class, minSdk = Q.SDK_INT)
+public class ShadowCallRedirectionService {
+  @RealObject CallRedirectionService callRedirectionService;
+  @ReflectorObject protected CallRedirectionServiceReflector callRedirectionServiceReflector;
+
+  private static Optional<RedirectionResult> lastRedirectionResult = Optional.empty();
+
+  /**
+   * Place a call to be processed by the {@link CallRedirectionService}. This will trigger the
+   * {@link CallRedirectionService#onPlaceCall} method with the provided arguments.
+   */
+  public void placeCall(
+      Uri uri, PhoneAccountHandle phoneAccountHandle, boolean allowInteractiveResponse) {
+    ICallRedirectionService.Stub binder =
+        (ICallRedirectionService.Stub) callRedirectionService.onBind(new Intent());
+    try {
+      binder.placeCall(
+          ReflectionHelpers.createNullProxy(ICallRedirectionAdapter.class),
+          uri,
+          phoneAccountHandle,
+          allowInteractiveResponse);
+    } catch (RemoteException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  /** Returns the last captured {@link RedirectionResult}. */
+  public Optional<RedirectionResult> getRedirectionResult() {
+    return lastRedirectionResult;
+  }
+
+  private void setRedirectionResult(RedirectionResult redirectionResult) {
+    lastRedirectionResult = Optional.of(redirectionResult);
+  }
+
+  @Resetter
+  public static void reset() {
+    lastRedirectionResult = Optional.empty();
+  }
+
+  @Implementation
+  protected void redirectCall(
+      Uri handle, PhoneAccountHandle initialPhoneAccount, boolean isInteractiveResponseAllowed) {
+    setRedirectionResult(
+        new RedirectionResult(
+            new RedirectionResult.RedirectCallArgs(
+                handle, initialPhoneAccount, isInteractiveResponseAllowed)));
+    callRedirectionServiceReflector.redirectCall(
+        handle, initialPhoneAccount, isInteractiveResponseAllowed);
+  }
+
+  @Implementation
+  protected void placeCallUnmodified() {
+    setRedirectionResult(
+        new RedirectionResult(RedirectionResult.RedirectionResultType.PLACE_CALL_UNMODIFIED));
+    callRedirectionServiceReflector.placeCallUnmodified();
+  }
+
+  @Implementation
+  protected void cancelCall() {
+    setRedirectionResult(
+        new RedirectionResult(RedirectionResult.RedirectionResultType.CANCEL_CALL));
+    callRedirectionServiceReflector.cancelCall();
+  }
+
+  @ForType(CallRedirectionService.class)
+  private interface CallRedirectionServiceReflector {
+    @Direct
+    public void redirectCall(
+        Uri handle, PhoneAccountHandle initialPhoneAccount, boolean isInteractiveResponseAllowed);
+
+    @Direct
+    public void placeCallUnmodified();
+
+    @Direct
+    public void cancelCall();
+  }
+
+  /** The result of the redirection attempt. */
+  public static class RedirectionResult {
+    private final RedirectionResultType redirectionResultType;
+    private final Optional<RedirectCallArgs> redirectCallArgsOptional;
+
+    private RedirectionResult(RedirectionResultType redirectionResultType) {
+      this.redirectionResultType = redirectionResultType;
+      this.redirectCallArgsOptional = Optional.empty();
+    }
+
+    private RedirectionResult(RedirectCallArgs redirectCallArgs) {
+      this.redirectionResultType = RedirectionResultType.REDIRECT_CALL;
+      this.redirectCallArgsOptional = Optional.of(redirectCallArgs);
+    }
+
+    public RedirectionResultType getRedirectionResultType() {
+      return redirectionResultType;
+    }
+
+    public Optional<RedirectCallArgs> getRedirectCallArgs() {
+      return redirectCallArgsOptional;
+    }
+
+    /** The type of the redirection result. */
+    public enum RedirectionResultType {
+      /** The call is placed unmodified. */
+      PLACE_CALL_UNMODIFIED,
+      /** The call is cancelled. */
+      CANCEL_CALL,
+      /** The call is requested to be redirected. */
+      REDIRECT_CALL,
+    }
+
+    /** The captured arguments for a call that is requested to be redirected. */
+    public static class RedirectCallArgs {
+      private final Uri handle;
+      private final PhoneAccountHandle targetPhoneAccount;
+      private final boolean confirmFirst;
+
+      private RedirectCallArgs(
+          Uri handle, PhoneAccountHandle targetPhoneAccount, boolean confirmFirst) {
+        this.handle = handle;
+        this.targetPhoneAccount = targetPhoneAccount;
+        this.confirmFirst = confirmFirst;
+      }
+
+      public Uri getHandle() {
+        return handle;
+      }
+
+      public PhoneAccountHandle getTargetPhoneAccount() {
+        return targetPhoneAccount;
+      }
+
+      public boolean getConfirmFirst() {
+        return confirmFirst;
+      }
+    }
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCallScreeningService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCallScreeningService.java
index 2f6e58d2d..fdf06ff08 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCallScreeningService.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCallScreeningService.java
@@ -20,8 +20,8 @@ import org.robolectric.util.reflector.ForType;
 public final class ShadowCallScreeningService {
   /** Contains the parameters used to call {@link CallScreeningService#respondToCall}. */
   public static final class RespondToCallInput {
-    private Call.Details callDetails;
-    private CallResponse callResponse;
+    private final Call.Details callDetails;
+    private final CallResponse callResponse;
 
     public RespondToCallInput(Call.Details callDetails, CallResponse callResponse) {
       this.callDetails = callDetails;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCamera.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCamera.java
index dc36d919c..c90075966 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCamera.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCamera.java
@@ -24,36 +24,39 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
 public class ShadowCamera {
   // These are completely arbitrary and likely outdated default parameters that have been added long
   // ago.
-  private static final ImmutableMap<String, String> DEFAULT_PARAMS =
-      ImmutableMap.<String, String>builder()
-          .put("picture-size", "1280x960")
-          .put("preview-size", "640x480")
-          .put("preview-fps-range", "10,30")
-          .put("preview-frame-rate", "30")
-          .put("preview-format", "yuv420sp")
-          .put("picture-format-values", "yuv420sp,jpeg")
-          .put("preview-format-values", "yuv420sp,jpeg")
-          .put("picture-size-values", "320x240,640x480,800x600")
-          .put("preview-size-values", "320x240,640x480")
-          .put("preview-fps-range-values", "(15000,15000),(10000,30000)")
-          .put("preview-frame-rate-values", "10,15,30")
-          .put("exposure-compensation", "0")
-          .put("exposure-compensation-step", "0.5")
-          .put("min-exposure-compensation", "-6")
-          .put("max-exposure-compensation", "6")
-          .put("focus-mode-values", Camera.Parameters.FOCUS_MODE_AUTO)
-          .put("focus-mode", Camera.Parameters.FOCUS_MODE_AUTO)
-          .put(
-              "flash-mode-values",
-              Camera.Parameters.FLASH_MODE_AUTO
-                  + ","
-                  + Camera.Parameters.FLASH_MODE_ON
-                  + ","
-                  + Camera.Parameters.FLASH_MODE_OFF)
-          .put("flash-mode", Camera.Parameters.FLASH_MODE_AUTO)
-          .put("max-num-focus-areas", "1")
-          .put("max-num-metering-areas", "1")
-          .build();
+  private static final ImmutableMap<String, String> DEFAULT_PARAMS;
+
+  static {
+    Map<String, String> defaultParams = new HashMap<>();
+    defaultParams.put("picture-size", "1280x960");
+    defaultParams.put("preview-size", "640x480");
+    defaultParams.put("preview-fps-range", "10,30");
+    defaultParams.put("preview-frame-rate", "30");
+    defaultParams.put("preview-format", "yuv420sp");
+    defaultParams.put("picture-format-values", "yuv420sp,jpeg");
+    defaultParams.put("preview-format-values", "yuv420sp,jpeg");
+    defaultParams.put("picture-size-values", "320x240,640x480,800x600");
+    defaultParams.put("preview-size-values", "320x240,640x480");
+    defaultParams.put("preview-fps-range-values", "(15000,15000),(10000,30000)");
+    defaultParams.put("preview-frame-rate-values", "10,15,30");
+    defaultParams.put("exposure-compensation", "0");
+    defaultParams.put("exposure-compensation-step", "0.5");
+    defaultParams.put("min-exposure-compensation", "-6");
+    defaultParams.put("max-exposure-compensation", "6");
+    defaultParams.put("focus-mode-values", Camera.Parameters.FOCUS_MODE_AUTO);
+    defaultParams.put("focus-mode", Camera.Parameters.FOCUS_MODE_AUTO);
+    defaultParams.put(
+        "flash-mode-values",
+        Camera.Parameters.FLASH_MODE_AUTO
+            + ","
+            + Camera.Parameters.FLASH_MODE_ON
+            + ","
+            + Camera.Parameters.FLASH_MODE_OFF);
+    defaultParams.put("flash-mode", Camera.Parameters.FLASH_MODE_AUTO);
+    defaultParams.put("max-num-focus-areas", "1");
+    defaultParams.put("max-num-metering-areas", "1");
+    DEFAULT_PARAMS = ImmutableMap.copyOf(defaultParams);
+  }
 
   private static int lastOpenedCameraId;
 
@@ -63,7 +66,7 @@ public class ShadowCamera {
   private boolean released;
   private Camera.Parameters parameters;
   private Camera.PreviewCallback previewCallback;
-  private List<byte[]> callbackBuffers = new ArrayList<>();
+  private final List<byte[]> callbackBuffers = new ArrayList<>();
   private SurfaceHolder surfaceHolder;
   private int displayOrientation;
   private Camera.AutoFocusCallback autoFocusCallback;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraDeviceImpl.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraDeviceImpl.java
index 6e079d4f5..d72b002e8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraDeviceImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraDeviceImpl.java
@@ -31,6 +31,7 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.WithType;
+import org.robolectric.versioning.AndroidVersions.Baklava;
 import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow class for {@link CameraDeviceImpl} */
@@ -75,8 +76,7 @@ public class ShadowCameraDeviceImpl {
         .setDeviceExecutor(MoreExecutors.directExecutor());
   }
 
-  // TODO(congxiliu) Change minsdk to Baklava once Baklava is fully released in AOSP
-  @Implementation(minSdk = V.SDK_INT)
+  @Implementation(minSdk = Baklava.SDK_INT)
   @InDevelopment
   protected void __constructor__(
       String cameraId,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java
index d469e48b6..313df52ac 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java
@@ -19,6 +19,7 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 import java.util.WeakHashMap;
 import java.util.concurrent.Executor;
@@ -98,7 +99,7 @@ public class ShadowCameraManager {
   @Implementation
   @Nonnull
   protected CameraCharacteristics getCameraCharacteristics(@Nonnull String cameraId) {
-    Preconditions.checkNotNull(cameraId);
+    Objects.requireNonNull(cameraId);
     CameraCharacteristics characteristics = cameraIdToCharacteristics.get(cameraId);
     Preconditions.checkArgument(characteristics != null);
     return characteristics;
@@ -106,7 +107,7 @@ public class ShadowCameraManager {
 
   @Implementation(minSdk = VERSION_CODES.M)
   protected void setTorchMode(@Nonnull String cameraId, boolean enabled) {
-    Preconditions.checkNotNull(cameraId);
+    Objects.requireNonNull(cameraId);
     Preconditions.checkArgument(cameraIdToCharacteristics.keySet().contains(cameraId));
     cameraTorches.put(cameraId, enabled);
     for (Object callback : torchCallbacks) {
@@ -258,25 +259,25 @@ public class ShadowCameraManager {
   @Implementation
   protected void registerAvailabilityCallback(
       CameraManager.AvailabilityCallback callback, Handler handler) {
-    Preconditions.checkNotNull(callback);
+    Objects.requireNonNull(callback);
     registeredCallbacks.add(callback);
   }
 
   @Implementation
   protected void unregisterAvailabilityCallback(CameraManager.AvailabilityCallback callback) {
-    Preconditions.checkNotNull(callback);
+    Objects.requireNonNull(callback);
     registeredCallbacks.remove(callback);
   }
 
   @Implementation(minSdk = VERSION_CODES.M)
   protected void registerTorchCallback(CameraManager.TorchCallback callback, Handler handler) {
-    Preconditions.checkNotNull(callback);
+    Objects.requireNonNull(callback);
     torchCallbacks.add(callback);
   }
 
   @Implementation(minSdk = VERSION_CODES.M)
   protected void unregisterTorchCallback(CameraManager.TorchCallback callback) {
-    Preconditions.checkNotNull(callback);
+    Objects.requireNonNull(callback);
     torchCallbacks.remove(callback);
   }
 
@@ -329,7 +330,7 @@ public class ShadowCameraManager {
    * registered.
    */
   private void triggerOnCameraAvailable(@Nonnull String cameraId) {
-    Preconditions.checkNotNull(cameraId);
+    Objects.requireNonNull(cameraId);
     for (CameraManager.AvailabilityCallback callback : registeredCallbacks) {
       callback.onCameraAvailable(cameraId);
     }
@@ -340,7 +341,7 @@ public class ShadowCameraManager {
    * are registered.
    */
   private void triggerOnCameraUnavailable(@Nonnull String cameraId) {
-    Preconditions.checkNotNull(cameraId);
+    Objects.requireNonNull(cameraId);
     for (CameraManager.AvailabilityCallback callback : registeredCallbacks) {
       callback.onCameraUnavailable(cameraId);
     }
@@ -354,8 +355,8 @@ public class ShadowCameraManager {
    * @throws IllegalArgumentException if there's already an existing camera with the given id.
    */
   public void addCamera(@Nonnull String cameraId, @Nonnull CameraCharacteristics characteristics) {
-    Preconditions.checkNotNull(cameraId);
-    Preconditions.checkNotNull(characteristics);
+    Objects.requireNonNull(cameraId);
+    Objects.requireNonNull(characteristics);
     Preconditions.checkArgument(!cameraIdToCharacteristics.containsKey(cameraId));
 
     cameraIdToCharacteristics.put(cameraId, characteristics);
@@ -368,7 +369,7 @@ public class ShadowCameraManager {
    * @throws IllegalArgumentException if there is not an existing camera with the given id.
    */
   public void removeCamera(@Nonnull String cameraId) {
-    Preconditions.checkNotNull(cameraId);
+    Objects.requireNonNull(cameraId);
     Preconditions.checkArgument(cameraIdToCharacteristics.containsKey(cameraId));
 
     cameraIdToCharacteristics.remove(cameraId);
@@ -377,10 +378,9 @@ public class ShadowCameraManager {
 
   /** Returns what the supplied camera's torch is set to. */
   public boolean getTorchMode(@Nonnull String cameraId) {
-    Preconditions.checkNotNull(cameraId);
+    Objects.requireNonNull(cameraId);
     Preconditions.checkArgument(cameraIdToCharacteristics.keySet().contains(cameraId));
-    Boolean torchState = cameraTorches.get(cameraId);
-    return torchState;
+    return cameraTorches.get(cameraId);
   }
 
   /**
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java
index ea45b1c00..57a1c8331 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java
@@ -95,12 +95,12 @@ public class ShadowCarrierConfigManager {
   }
 
   public void setReadPhoneStatePermission(boolean readPhoneStatePermission) {
-    this.readPhoneStatePermission = readPhoneStatePermission;
+    ShadowCarrierConfigManager.readPhoneStatePermission = readPhoneStatePermission;
   }
 
   /**
    * Sets that the {@code config} PersistableBundle for a particular {@code subId}; controls the
-   * return value of {@link CarrierConfigManager#getConfigForSubId()}.
+   * return value of {@link CarrierConfigManager#getConfigForSubId(int, String...)}.
    */
   public void setConfigForSubId(int subId, PersistableBundle config) {
     bundles.put(subId, config);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java
index ac38d3d91..a9586068e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java
@@ -121,10 +121,11 @@ public abstract class ShadowChoreographer {
   }
 
   /**
-   * Allows application to specify a fixed amount of delay when {@link #postCallback(int, Runnable,
-   * Object)} is invoked. The default delay value is 0. This can be used to avoid infinite animation
-   * tasks to be spawned when the Robolectric {@link org.robolectric.util.Scheduler} is in {@link
-   * org.robolectric.util.Scheduler.IdleState#PAUSED} mode.
+   * Allows application to specify a fixed amount of delay when {@link
+   * Choreographer#postCallback(int, Runnable, Object)} is invoked. The default delay value is 0.
+   * This can be used to avoid infinite animation tasks to be spawned when the Robolectric {@link
+   * org.robolectric.util.Scheduler} is in {@link org.robolectric.util.Scheduler.IdleState#PAUSED}
+   * mode.
    *
    * <p>Only supported in {@link LooperMode.Mode#LEGACY}
    *
@@ -138,8 +139,8 @@ public abstract class ShadowChoreographer {
 
   /**
    * Allows application to specify a fixed amount of delay when {@link
-   * #postFrameCallback(FrameCallback)} is invoked. The default delay value is 0. This can be used
-   * to avoid infinite animation tasks to be spawned when in LooperMode PAUSED or {@link
+   * Choreographer#postFrameCallback(FrameCallback)} is invoked. The default delay value is 0. This
+   * can be used to avoid infinite animation tasks to be spawned when in LooperMode PAUSED or {@link
    * org.robolectric.util.Scheduler.IdleState#PAUSED} and displaying an animation.
    *
    * @deprecated Use the {@link Mode#PAUSED} looper and {@link #setPaused(boolean)} and {@link
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowClipboardManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowClipboardManager.java
index 3150f1f4f..2a7ad195c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowClipboardManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowClipboardManager.java
@@ -25,7 +25,7 @@ import org.robolectric.util.reflector.ForType;
 @Implements(ClipboardManager.class)
 public class ShadowClipboardManager {
   private static final Collection<OnPrimaryClipChangedListener> listeners =
-      new CopyOnWriteArrayList<OnPrimaryClipChangedListener>();
+      new CopyOnWriteArrayList<>();
   private static ClipData clip;
   @RealObject private ClipboardManager realClipboardManager;
 
@@ -70,7 +70,7 @@ public class ShadowClipboardManager {
       }
     }
 
-    this.clip = clip;
+    ShadowClipboardManager.clip = clip;
 
     for (OnPrimaryClipChangedListener listener : listeners) {
       listener.onPrimaryClipChanged();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCodecCapabilities.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCodecCapabilities.java
new file mode 100644
index 000000000..5a1fbe948
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCodecCapabilities.java
@@ -0,0 +1,58 @@
+package org.robolectric.shadows;
+
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.media.MediaCodecInfo.CodecCapabilities;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
+import org.robolectric.util.reflector.Direct;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.util.reflector.Static;
+import org.robolectric.versioning.AndroidVersions.Baklava;
+
+/**
+ * Shadow for {@link CodecCapabilities}.
+ *
+ * <p>This is needed to force the java implementation (as opposed to the unsupported native
+ * implementation) on post-baklava SDKs.
+ */
+@Implements(value = CodecCapabilities.class)
+public class ShadowCodecCapabilities {
+
+  // TODO: figure out why minSdk = PostBaklava doesn't work
+  @Implementation(minSdk = Baklava.SDK_INT)
+  protected static CodecCapabilities createFromProfileLevel(String mime, int profile, int level) {
+    if (RuntimeEnvironment.getApiLevel() <= Baklava.SDK_INT) {
+      return reflector(CodecCapabiltiesReflector.class)
+          .createFromProfileLevel(mime, profile, level);
+    }
+    // force LegacyImpl not native which is unsupported
+    Object impl =
+        reflector(CodecCapsLegacyImplReflector.class).createFromProfileLevel(mime, profile, level);
+    try {
+      return ReflectionHelpers.callConstructor(
+          CodecCapabilities.class,
+          ClassParameter.from(
+              Class.forName("android.media.MediaCodecInfo$CodecCapabilities$CodecCapsIntf"), impl));
+    } catch (ClassNotFoundException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @ForType(CodecCapabilities.class)
+  interface CodecCapabiltiesReflector {
+    @Direct
+    @Static
+    CodecCapabilities createFromProfileLevel(String mime, int profile, int level);
+  }
+
+  @ForType(className = "android.media.MediaCodecInfo$CodecCapabilities$CodecCapsLegacyImpl")
+  interface CodecCapsLegacyImplReflector {
+
+    @Static
+    Object createFromProfileLevel(String mime, int profile, int level);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowColor.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowColor.java
index f18cf22ba..65c684a9c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowColor.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowColor.java
@@ -22,13 +22,13 @@ public class ShadowColor {
    * @param hsv Array to store HSV components
    */
   @Implementation
-  protected static void RGBToHSV(int red, int green, int blue, float hsv[]) {
+  protected static void RGBToHSV(int red, int green, int blue, float[] hsv) {
     java.awt.Color.RGBtoHSB(red, green, blue, hsv);
     hsv[0] = hsv[0] * 360;
   }
 
   @Implementation
-  protected static int HSVToColor(int alpha, float hsv[]) {
+  protected static int HSVToColor(int alpha, float[] hsv) {
     int rgb = java.awt.Color.HSBtoRGB(hsv[0] / 360, pin(hsv[1]), pin(hsv[2]));
     return Color.argb(alpha, Color.red(rgb), Color.green(rgb), Color.blue(rgb));
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowColorDisplayManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowColorDisplayManager.java
index c47ef3439..d22f91ff7 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowColorDisplayManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowColorDisplayManager.java
@@ -16,7 +16,7 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.WithType;
 
-/** Shadow for {@link ColorDisplayManager}. */
+/** Shadow for {@link android.hardware.display.ColorDisplayManager}. */
 @Implements(
     className = "android.hardware.display.ColorDisplayManager",
     isInAndroidSdk = false,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompanionDeviceManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompanionDeviceManager.java
index 5fdf1faec..4459eaecf 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompanionDeviceManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompanionDeviceManager.java
@@ -283,7 +283,7 @@ public class ShadowCompanionDeviceManager {
         revoked,
         info.getTimeApprovedMs(),
         // return value of getLastTimeConnectedMs changed from a long to a Long
-        (long) ReflectionHelpers.callInstanceMethod(info, "getLastTimeConnectedMs"),
+        ReflectionHelpers.callInstanceMethod(info, "getLastTimeConnectedMs"),
         systemDataSyncFlags);
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompatibility.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompatibility.java
index 30c679f13..fb81253a4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompatibility.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompatibility.java
@@ -15,7 +15,7 @@ import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
 
-/** Shadow for {@link Compatability}. */
+/** Shadow for {@link Compatibility}. */
 @Implements(value = Compatibility.class, isInAndroidSdk = false, minSdk = R)
 public class ShadowCompatibility {
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnectivityManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnectivityManager.java
index 2e9a116ba..daaab89e1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnectivityManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnectivityManager.java
@@ -41,17 +41,18 @@ public class ShadowConnectivityManager {
   private static int networkPreference = ConnectivityManager.DEFAULT_NETWORK_PREFERENCE;
   private static final Map<Integer, NetworkInfo> networkTypeToNetworkInfo = new HashMap<>();
 
-  private static HashSet<ConnectivityManager.NetworkCallback> networkCallbacks = new HashSet<>();
+  private static final HashSet<ConnectivityManager.NetworkCallback> networkCallbacks =
+      new HashSet<>();
   private static final HashSet<PendingIntent> networkCallbackPendingIntents = new HashSet<>();
 
   private static final Map<Integer, Network> netIdToNetwork = new HashMap<>();
   private static final Map<Integer, NetworkInfo> netIdToNetworkInfo = new HashMap<>();
   private static Network processBoundNetwork;
   private static boolean defaultNetworkActive = true;
-  private static HashSet<ConnectivityManager.OnNetworkActiveListener> onNetworkActiveListeners =
-      new HashSet<>();
-  private static Map<Network, Boolean> reportedNetworkConnectivity = new HashMap<>();
-  private static Map<Network, NetworkCapabilities> networkCapabilitiesMap = new HashMap<>();
+  private static final HashSet<ConnectivityManager.OnNetworkActiveListener>
+      onNetworkActiveListeners = new HashSet<>();
+  private static final Map<Network, Boolean> reportedNetworkConnectivity = new HashMap<>();
+  private static final Map<Network, NetworkCapabilities> networkCapabilitiesMap = new HashMap<>();
   private static String captivePortalServerUrl = "http://10.0.0.2";
   private static final Map<Network, LinkProperties> linkPropertiesMap = new HashMap<>();
   private static final Map<Network, ProxyInfo> proxyInfoMap = new HashMap<>();
@@ -213,9 +214,7 @@ public class ShadowConnectivityManager {
     if (networkCallback == null) {
       throw new IllegalArgumentException("Invalid NetworkCallback");
     }
-    if (networkCallbacks.contains(networkCallback)) {
-      networkCallbacks.remove(networkCallback);
-    }
+    networkCallbacks.remove(networkCallback);
   }
 
   @Implementation(minSdk = M)
@@ -223,9 +222,7 @@ public class ShadowConnectivityManager {
     if (pendingIntent == null) {
       throw new IllegalArgumentException("Invalid NetworkCallback");
     }
-    if (networkCallbackPendingIntents.contains(pendingIntent)) {
-      networkCallbackPendingIntents.remove(pendingIntent);
-    }
+    networkCallbackPendingIntents.remove(pendingIntent);
   }
 
   @Implementation
@@ -253,9 +250,7 @@ public class ShadowConnectivityManager {
   protected NetworkInfo[] getAllNetworkInfo() {
     // todo(xian): is `defaultNetworkActive` really relevant here?
     if (defaultNetworkActive) {
-      return networkTypeToNetworkInfo
-          .values()
-          .toArray(new NetworkInfo[networkTypeToNetworkInfo.size()]);
+      return networkTypeToNetworkInfo.values().toArray(new NetworkInfo[0]);
     }
     return null;
   }
@@ -276,7 +271,7 @@ public class ShadowConnectivityManager {
 
   @Implementation
   protected Network[] getAllNetworks() {
-    return netIdToNetwork.values().toArray(new Network[netIdToNetwork.size()]);
+    return netIdToNetwork.values().toArray(new Network[0]);
   }
 
   @Implementation
@@ -338,7 +333,7 @@ public class ShadowConnectivityManager {
    * @param captivePortalServerUrl the url of captive portal.
    */
   public void setCaptivePortalServerUrl(String captivePortalServerUrl) {
-    this.captivePortalServerUrl = captivePortalServerUrl;
+    ShadowConnectivityManager.captivePortalServerUrl = captivePortalServerUrl;
   }
 
   @HiddenApi
@@ -467,9 +462,7 @@ public class ShadowConnectivityManager {
     if (l == null) {
       throw new IllegalArgumentException("Invalid OnNetworkActiveListener");
     }
-    if (onNetworkActiveListeners.contains(l)) {
-      onNetworkActiveListeners.remove(l);
-    }
+    onNetworkActiveListeners.remove(l);
   }
 
   @Implementation(minSdk = M)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentCaptureManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentCaptureManager.java
index 34abfc068..bc35c5f83 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentCaptureManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentCaptureManager.java
@@ -3,7 +3,7 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 
-import android.annotation.TargetApi;
+import android.annotation.RequiresApi;
 import android.content.ComponentName;
 import android.os.ParcelFileDescriptor;
 import android.view.contentcapture.ContentCaptureCondition;
@@ -14,6 +14,7 @@ import android.view.contentcapture.DataShareRequest;
 import android.view.contentcapture.DataShareWriteAdapter;
 import java.util.Set;
 import java.util.concurrent.Executor;
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -33,7 +34,8 @@ public class ShadowContentCaptureManager {
    * Configures the set of {@link ContentCaptureCondition} that will be returned when calling {@link
    * #getContentCaptureConditions()}.
    */
-  public void setContentCaptureConditions(Set<ContentCaptureCondition> contentCaptureConditions) {
+  public void setContentCaptureConditions(
+      @Nonnull Set<ContentCaptureCondition> contentCaptureConditions) {
     this.contentCaptureConditions = contentCaptureConditions;
   }
 
@@ -41,7 +43,7 @@ public class ShadowContentCaptureManager {
    * Configures the {@link ComponentName} that will be returned when calling {@link
    * #getServiceComponentName()}.
    */
-  public void setServiceComponentName(ComponentName serviceComponentName) {
+  public void setServiceComponentName(@Nonnull ComponentName serviceComponentName) {
     this.serviceComponentName = serviceComponentName;
   }
 
@@ -54,7 +56,7 @@ public class ShadowContentCaptureManager {
    * Configures {@link DataShareError} to be raised on calls to {@link #shareData(DataShareRequest,
    * Executor, DataShareWriteAdapter)}.
    */
-  @TargetApi(R)
+  @RequiresApi(R)
   public void setDataShareErrorCode(@DataShareError int dataShareErrorCode) {
     this.dataShareErrorCode = dataShareErrorCode;
   }
@@ -63,7 +65,7 @@ public class ShadowContentCaptureManager {
    * Configures whether or not to raise request rejection on calls to {@link
    * #shareData(DataShareRequest, Executor, DataShareWriteAdapter)}.
    */
-  @TargetApi(R)
+  @RequiresApi(R)
   public void setShouldRejectRequest(boolean shouldRejectRequest) {
     this.shouldRejectRequest = shouldRejectRequest;
   }
@@ -73,16 +75,18 @@ public class ShadowContentCaptureManager {
    * DataShareWriteAdapter#onWrite(ParcelFileDescriptor)} will receive on calls to {@link
    * #shareData(DataShareRequest, Executor, DataShareWriteAdapter)}.
    */
-  @TargetApi(R)
+  @RequiresApi(R)
   public void setShareDataParcelFileDescriptor(ParcelFileDescriptor parcelFileDescriptor) {
     this.parcelFileDescriptor = parcelFileDescriptor;
   }
 
+  @Nullable
   @Implementation
   protected Set<ContentCaptureCondition> getContentCaptureConditions() {
     return contentCaptureConditions;
   }
 
+  @Nullable
   @Implementation
   protected ComponentName getServiceComponentName() {
     return serviceComponentName;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java
index e2a81bf86..e0f7ba63d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java
@@ -9,6 +9,7 @@ import static android.content.ContentResolver.SCHEME_FILE;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.Q;
+import static android.os.Build.VERSION_CODES.R;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.accounts.Account;
@@ -201,19 +202,27 @@ public class ShadowContentResolver {
 
   @Implementation
   protected OutputStream openOutputStream(final Uri uri) throws FileNotFoundException {
+
+    boolean swallowException =
+        Boolean.parseBoolean(
+            System.getProperty("robolectric.useLegacyContentProviderOpenOutputStream", "false"));
     try {
       return openOutputStream(uri, "w");
     } catch (SecurityException | FileNotFoundException e) {
-      // This is legacy behavior is only supported because existing users require it.
-      return new OutputStream() {
-        @Override
-        public void write(int arg0) throws IOException {}
-
-        @Override
-        public String toString() {
-          return "outputstream for " + uri;
-        }
-      };
+      if (swallowException) {
+        // This is legacy behavior is only supported because existing users require it.
+        return new OutputStream() {
+          @Override
+          public void write(int arg0) throws IOException {}
+
+          @Override
+          public String toString() {
+            return "outputstream for " + uri;
+          }
+        };
+      } else {
+        throw e;
+      }
     }
   }
 
@@ -492,6 +501,13 @@ public class ShadowContentResolver {
     }
   }
 
+  @Implementation(minSdk = R)
+  protected void notifyChange(Collection<Uri> uris, ContentObserver observer, int flags) {
+    for (Uri uri : uris) {
+      notifyChange(uri, observer, flags);
+    }
+  }
+
   @Implementation(minSdk = N)
   protected void notifyChange(Uri uri, ContentObserver observer, int flags) {
     notifiedUris.add(new NotifiedUri(uri, observer, flags));
@@ -506,14 +522,18 @@ public class ShadowContentResolver {
     }
   }
 
+  /**
+   * @deprecated Use {@link #notifyChange(Uri, ContentObserver, int)} instead.
+   */
   @Implementation
+  @Deprecated
   protected void notifyChange(Uri uri, ContentObserver observer, boolean syncToNetwork) {
     notifyChange(uri, observer, syncToNetwork ? ContentResolver.NOTIFY_SYNC_TO_NETWORK : 0);
   }
 
   @Implementation
   protected void notifyChange(Uri uri, ContentObserver observer) {
-    notifyChange(uri, observer, false);
+    notifyChange(uri, observer, ContentResolver.NOTIFY_SYNC_TO_NETWORK);
   }
 
   @Implementation
@@ -802,7 +822,9 @@ public class ShadowContentResolver {
 
   /**
    * @deprecated This method affects all calls, and does not work with {@link
-   *     android.content.ContentResolver#acquireContentProviderClient}
+   *     android.content.ContentResolver#acquireContentProviderClient}. Instead, use {@link
+   *     org.robolectric.Robolectric#setupContentProvider(Class, String)} to install a test-specific
+   *     ContentProvider that can return any Cursor.
    */
   @Deprecated
   public void setCursor(BaseCursor cursor) {
@@ -811,7 +833,9 @@ public class ShadowContentResolver {
 
   /**
    * @deprecated This method does not work with {@link
-   *     android.content.ContentResolver#acquireContentProviderClient}
+   *     android.content.ContentResolver#acquireContentProviderClient}. Instead, use {@link
+   *     org.robolectric.Robolectric#setupContentProvider(Class, String)} to install a test-specific
+   *     ContentProvider that can return any Cursor.
    */
   @Deprecated
   public void setCursor(Uri uri, BaseCursor cursorForUri) {
@@ -820,7 +844,9 @@ public class ShadowContentResolver {
 
   /**
    * @deprecated This method affects all calls, and does not work with {@link
-   *     android.content.ContentResolver#acquireContentProviderClient}
+   *     android.content.ContentResolver#acquireContentProviderClient}. Instead, use {@link
+   *     org.robolectric.Robolectric#setupContentProvider(Class, String)} to install a test-specific
+   *     ContentProvider that can return any Cursor.
    */
   @Deprecated
   @SuppressWarnings({"unused", "WeakerAccess"})
@@ -834,7 +860,9 @@ public class ShadowContentResolver {
    *
    * @return a list of statements
    * @deprecated This method does not work with {@link
-   *     android.content.ContentResolver#acquireContentProviderClient}
+   *     android.content.ContentResolver#acquireContentProviderClient}. Instead, use {@link
+   *     org.robolectric.Robolectric#setupContentProvider(Class, String)} to install a test-specific
+   *     ContentProvider that can return any Cursor.
    */
   @Deprecated
   @SuppressWarnings({"unused", "WeakerAccess"})
@@ -849,7 +877,9 @@ public class ShadowContentResolver {
    *
    * @return a list of insert statements
    * @deprecated This method does not work with {@link
-   *     android.content.ContentResolver#acquireContentProviderClient}
+   *     android.content.ContentResolver#acquireContentProviderClient}. Instead, use {@link
+   *     org.robolectric.Robolectric#setupContentProvider(Class, String)} to install a test-specific
+   *     ContentProvider that can return any Cursor.
    */
   @Deprecated
   @SuppressWarnings({"unused", "WeakerAccess"})
@@ -863,7 +893,9 @@ public class ShadowContentResolver {
    *
    * @return a list of update statements
    * @deprecated This method does not work with {@link
-   *     android.content.ContentResolver#acquireContentProviderClient}
+   *     android.content.ContentResolver#acquireContentProviderClient}. Instead, use {@link
+   *     org.robolectric.Robolectric#setupContentProvider(Class, String)} to install a test-specific
+   *     ContentProvider that can return any Cursor.
    */
   @Deprecated
   @SuppressWarnings({"unused", "WeakerAccess"})
@@ -871,6 +903,10 @@ public class ShadowContentResolver {
     return updateStatements;
   }
 
+  /**
+   * @deprecated Use {@link org.robolectric.Robolectric#setupContentProvider(Class, String)} to
+   *     install a test-specific ContentProvider that can return any Cursor instead.
+   */
   @Deprecated
   @SuppressWarnings({"unused", "WeakerAccess"})
   public List<Uri> getDeletedUris() {
@@ -886,6 +922,8 @@ public class ShadowContentResolver {
    * ContentResolver#delete(Uri, String, String[])}.
    *
    * @return a list of delete statements
+   * @deprecated Use {@link org.robolectric.Robolectric#setupContentProvider(Class, String)} to
+   *     install a test-specific ContentProvider that can return any Cursor instead.
    */
   @Deprecated
   @SuppressWarnings({"unused", "WeakerAccess"})
@@ -893,12 +931,20 @@ public class ShadowContentResolver {
     return deleteStatements;
   }
 
+  /**
+   * @deprecated Use {@link org.robolectric.Robolectric#setupContentProvider(Class, String)} to
+   *     install a test-specific ContentProvider that can return any Cursor instead.
+   */
   @Deprecated
   @SuppressWarnings({"unused", "WeakerAccess"})
   public List<NotifiedUri> getNotifiedUris() {
     return notifiedUris;
   }
 
+  /**
+   * @deprecated Use {@link org.robolectric.Robolectric#setupContentProvider(Class, String)} to
+   *     install a test-specific ContentProvider that can return any Cursor instead.
+   */
   @Deprecated
   public List<ContentProviderOperation> getContentProviderOperations(String authority) {
     List<ContentProviderOperation> operations = contentProviderOperations.get(authority);
@@ -1144,13 +1190,13 @@ public class ShadowContentResolver {
     }
 
     @Override
-    public int read(byte[] b) throws IOException {
+    public int read(@Nonnull byte[] b) throws IOException {
       throw new UnsupportedOperationException(
           "You must use ShadowContentResolver.registerInputStream() in order to call read()");
     }
 
     @Override
-    public int read(byte[] b, int off, int len) throws IOException {
+    public int read(@Nonnull byte[] b, int off, int len) throws IOException {
       throw new UnsupportedOperationException(
           "You must use ShadowContentResolver.registerInputStream() in order to call read()");
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubClient.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubClient.java
index 04d264a5d..3750ab26c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubClient.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubClient.java
@@ -3,7 +3,6 @@ package org.robolectric.shadows;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.annotation.RequiresApi;
-import android.annotation.TargetApi;
 import android.hardware.location.ContextHubClient;
 import android.hardware.location.ContextHubInfo;
 import android.hardware.location.ContextHubTransaction;
@@ -60,7 +59,7 @@ public class ShadowContextHubClient {
   @ForType(ContextHubClient.class)
   interface ContextHubClientReflector {
     @Constructor
-    @TargetApi(VERSION_CODES.P)
+    @RequiresApi(VERSION_CODES.P)
     ContextHubClient newContextHubClient();
 
     @Constructor
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java
index 76c39560d..803e493ce 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java
@@ -51,7 +51,7 @@ public class ShadowContextHubManager {
   private static final Map<Integer, NanoAppInstanceInfo> nanoAppUidToInfo =
       new ConcurrentHashMap<>();
   private static final Multimap<ContextHubInfo, Integer> contextHubToNanoappUid =
-      Multimaps.synchronizedMultimap(HashMultimap.<ContextHubInfo, Integer>create());
+      Multimaps.synchronizedMultimap(HashMultimap.create());
   private static final Map<Long, ContextHubInfo> nanoAppIdToInfo = new ConcurrentHashMap<>();
   private static final HashMultimap<String, ContextHubClient> attributionTagToClientMap =
       HashMultimap.create();
@@ -175,8 +175,8 @@ public class ShadowContextHubManager {
     ContextHubClient client =
         reflector(ContextHubClientReflector.class)
             .newContextHubClient((ContextHubInfo) contextHubInfo, false);
-    if (context != null && ((Context) context).getAttributionTag() != null) {
-      attributionTagToClientMap.put(((Context) context).getAttributionTag(), client);
+    if (context != null && context.getAttributionTag() != null) {
+      attributionTagToClientMap.put(context.getAttributionTag(), client);
     }
 
     if (callback != null) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java
index 3f821b7d6..bc002bda9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java
@@ -107,8 +107,8 @@ public class ShadowContextWrapper {
   }
 
   /**
-   * Returns all {@code Intent} started by {@link #startService(android.content.Intent)} without
-   * consuming them.
+   * Returns all {@code Intent} started by {@link Context#startService(Intent)} without consuming
+   * them.
    *
    * @return the list of {@code Intent}
    */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCrossProfileApps.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCrossProfileApps.java
index b52bec927..ec21d69a4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCrossProfileApps.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCrossProfileApps.java
@@ -5,7 +5,7 @@ import static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_UNAWARE;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.Manifest.permission;
@@ -453,8 +453,8 @@ public class ShadowCrossProfileApps {
     private final UserHandle userHandle;
 
     public StartedMainActivity(ComponentName componentName, UserHandle userHandle) {
-      this.componentName = checkNotNull(componentName);
-      this.userHandle = checkNotNull(userHandle);
+      this.componentName = requireNonNull(componentName);
+      this.userHandle = requireNonNull(userHandle);
     }
 
     public ComponentName getComponentName() {
@@ -512,8 +512,8 @@ public class ShadowCrossProfileApps {
         @Nullable Intent intent,
         @Nullable Activity activity,
         @Nullable Bundle options) {
-      this.componentName = checkNotNull(componentName);
-      this.userHandle = checkNotNull(userHandle);
+      this.componentName = requireNonNull(componentName);
+      this.userHandle = requireNonNull(userHandle);
       this.intent = intent;
       this.activity = activity;
       this.options = options;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDateIntervalFormat.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDateIntervalFormat.java
index 6d239723f..aa97cc285 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDateIntervalFormat.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDateIntervalFormat.java
@@ -14,7 +14,8 @@ import org.robolectric.annotation.Implements;
 public class ShadowDateIntervalFormat {
 
   private static long address;
-  private static Map<Long, com.ibm.icu.text.DateIntervalFormat> INTERVAL_CACHE = new HashMap<>();
+  private static final Map<Long, com.ibm.icu.text.DateIntervalFormat> INTERVAL_CACHE =
+      new HashMap<>();
 
   @Implementation(maxSdk = LOLLIPOP_MR1)
   public static long createDateIntervalFormat(String skeleton, String localeName, String tzName) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDebug.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDebug.java
index 19dcbdd39..cc76a2ae4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDebug.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDebug.java
@@ -8,7 +8,7 @@ import com.google.common.collect.ImmutableMap;
 import com.google.common.io.Files;
 import java.io.File;
 import java.io.IOException;
-import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
 import java.util.Map;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
@@ -33,7 +33,7 @@ public class ShadowDebug {
 
   @Implementation(minSdk = M)
   protected static Map<String, String> getRuntimeStats() {
-    return ImmutableMap.<String, String>builder().build();
+    return ImmutableMap.of();
   }
 
   @Implementation
@@ -69,7 +69,7 @@ public class ShadowDebug {
     }
 
     try {
-      Files.asCharSink(new File(tracingFilename), Charset.forName("UTF-8")).write("trace data");
+      Files.asCharSink(new File(tracingFilename), StandardCharsets.UTF_8).write("trace data");
     } catch (IOException e) {
       throw new RuntimeException("Writing trace file failed", e);
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDeviceConfig.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDeviceConfig.java
index 0bc03047a..50031080f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDeviceConfig.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDeviceConfig.java
@@ -16,15 +16,15 @@ public class ShadowDeviceConfig {
     //noinspection SynchronizationOnLocalVariableOrMethodParameter
     synchronized (lock) {
       if (RuntimeEnvironment.getApiLevel() == Build.VERSION_CODES.Q) {
-        Map singleListeners =
+        Map<?, ?> singleListeners =
             ReflectionHelpers.getStaticField(DeviceConfig.class, "sSingleListeners");
         singleListeners.clear();
       }
 
-      Map listeners = ReflectionHelpers.getStaticField(DeviceConfig.class, "sListeners");
+      Map<?, ?> listeners = ReflectionHelpers.getStaticField(DeviceConfig.class, "sListeners");
       listeners.clear();
 
-      Map namespaces = ReflectionHelpers.getStaticField(DeviceConfig.class, "sNamespaces");
+      Map<?, ?> namespaces = ReflectionHelpers.getStaticField(DeviceConfig.class, "sNamespaces");
       namespaces.clear();
     }
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java
index 53d247e1f..20d1639ad 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java
@@ -14,6 +14,7 @@ import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.S_V2;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static android.os.Build.VERSION_CODES.VANILLA_ICE_CREAM;
 import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.shadow.api.Shadow.invokeConstructor;
 import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
@@ -25,12 +26,10 @@ import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.app.ApplicationPackageManager;
 import android.app.KeyguardManager;
-import android.app.admin.DeviceAdminReceiver;
 import android.app.admin.DevicePolicyManager;
 import android.app.admin.DevicePolicyManager.NearbyStreamingPolicy;
 import android.app.admin.DevicePolicyManager.PasswordComplexity;
 import android.app.admin.DevicePolicyManager.UserProvisioningState;
-import android.app.admin.DevicePolicyState;
 import android.app.admin.IDevicePolicyManager;
 import android.app.admin.SystemUpdateInfo;
 import android.app.admin.SystemUpdatePolicy;
@@ -50,9 +49,10 @@ import android.os.PersistableBundle;
 import android.os.Process;
 import android.os.UserHandle;
 import android.text.TextUtils;
-import com.android.internal.util.Preconditions;
+import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.errorprone.annotations.concurrent.GuardedBy;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -115,6 +115,8 @@ public class ShadowDevicePolicyManager {
   private static final Map<UserHandle, Account> finalizedWorkProfileProvisioningMap =
       new HashMap<>();
   private static final Map<Integer, Integer> userProvisioningStatesMap = new HashMap<>();
+  private static final Object lock = new Object();
+
   private static ComponentName deviceOwner;
   private static ComponentName profileOwner;
   private static CharSequence organizationName;
@@ -157,6 +159,10 @@ public class ShadowDevicePolicyManager {
   private static int nearbyAppStreamingPolicy =
       DevicePolicyManager.NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;
   private static boolean isUsbDataSignalingEnabled = true;
+
+  @GuardedBy("ShadowDevicePolicyManager.lock")
+  private static boolean isMtePolicyEnforced = false;
+
   @Nullable private static String devicePolicyManagementRoleHolderPackage;
   private static List<UserHandle> policyManagedProfiles = new ArrayList<>();
   @Nullable private static PersistableBundle lastTransferOwnershipBundle;
@@ -219,6 +225,9 @@ public class ShadowDevicePolicyManager {
         DevicePolicyManager.NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;
     nearbyAppStreamingPolicy = DevicePolicyManager.NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;
     isUsbDataSignalingEnabled = true;
+    synchronized (ShadowDevicePolicyManager.lock) {
+      isMtePolicyEnforced = false;
+    }
     devicePolicyManagementRoleHolderPackage = null;
     finalizedWorkProfileProvisioningMap.clear();
     policyManagedProfiles = new ArrayList<>();
@@ -233,8 +242,8 @@ public class ShadowDevicePolicyManager {
       this.permission = permission;
     }
 
-    private String packageName;
-    private String permission;
+    private final String packageName;
+    private final String permission;
 
     @Override
     public boolean equals(Object o) {
@@ -275,7 +284,7 @@ public class ShadowDevicePolicyManager {
 
   private void init(Context context) {
     this.context = context;
-    this.applicationPackageManager =
+    applicationPackageManager =
         (ApplicationPackageManager) context.getApplicationContext().getPackageManager();
     organizationColor = DEFAULT_ORGANIZATION_COLOR;
     storageEncryptionStatus = DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;
@@ -414,6 +423,20 @@ public class ShadowDevicePolicyManager {
     return isUsbDataSignalingEnabled;
   }
 
+  /** Sets {@link DevicePolicyManager#isMtePolicyEnforced}. */
+  public static void setIsMtePolicyEnforced(boolean isEnabled) {
+    synchronized (ShadowDevicePolicyManager.lock) {
+      isMtePolicyEnforced = isEnabled;
+    }
+  }
+
+  @Implementation(minSdk = VANILLA_ICE_CREAM)
+  protected static boolean isMtePolicyEnforced() {
+    synchronized (ShadowDevicePolicyManager.lock) {
+      return isMtePolicyEnforced;
+    }
+  }
+
   /**
    * @see #setDeviceOwner(ComponentName)
    */
@@ -769,7 +792,7 @@ public class ShadowDevicePolicyManager {
     if (isAutoTimeZoneEnabled) {
       return false;
     }
-    this.timeZone = timeZone;
+    ShadowDevicePolicyManager.timeZone = timeZone;
     return true;
   }
 
@@ -861,7 +884,7 @@ public class ShadowDevicePolicyManager {
   @Implementation
   protected int setStorageEncryption(ComponentName admin, boolean encrypt) {
     enforceActiveAdmin(admin);
-    this.storageEncryptionRequested = encrypt;
+    storageEncryptionRequested = encrypt;
     return storageEncryptionStatus;
   }
 
@@ -1238,7 +1261,7 @@ public class ShadowDevicePolicyManager {
 
   /** Sets the password complexity. */
   public void setPasswordComplexity(@PasswordComplexity int passwordComplexity) {
-    this.passwordComplexity = passwordComplexity;
+    ShadowDevicePolicyManager.passwordComplexity = passwordComplexity;
   }
 
   @PasswordComplexity
@@ -1313,7 +1336,7 @@ public class ShadowDevicePolicyManager {
    */
   public boolean activateResetToken(ComponentName admin) {
     if (!passwordResetTokens.containsKey(admin)) {
-      throw new IllegalArgumentException("No token set for comopnent: " + admin);
+      throw new IllegalArgumentException("No token set for component: " + admin);
     }
     return componentsWithActivatedTokens.add(admin);
   }
@@ -1472,7 +1495,7 @@ public class ShadowDevicePolicyManager {
 
   @Implementation(minSdk = M)
   protected void setSystemUpdatePolicy(ComponentName admin, SystemUpdatePolicy policy) {
-    this.policy = policy;
+    ShadowDevicePolicyManager.policy = policy;
   }
 
   /**
@@ -1638,7 +1661,7 @@ public class ShadowDevicePolicyManager {
 
   /** Sets the value returned by {@link #getPolicyManagedProfiles(UserHandle)}. */
   public void setPolicyManagedProfiles(List<UserHandle> policyManagedProfiles) {
-    this.policyManagedProfiles = policyManagedProfiles;
+    ShadowDevicePolicyManager.policyManagedProfiles = policyManagedProfiles;
   }
 
   /**
@@ -1650,7 +1673,7 @@ public class ShadowDevicePolicyManager {
     return userProvisioningStatesMap.getOrDefault(userId, DevicePolicyManager.STATE_USER_UNMANAGED);
   }
 
-  /** Return a stub value set by {@link #setDevicePolicyState(DevicePolicyState policyState)} */
+  /** Return a stub value set by {@link #setDevicePolicyState(DevicePolicyState)} */
   @Implementation(minSdk = U.SDK_INT)
   protected @ClassName("android.app.admin.DevicePolicyState") Object getDevicePolicyState() {
     return devicePolicyState;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyResourcesManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyResourcesManager.java
index 0a5ae1e64..e8bb50da6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyResourcesManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyResourcesManager.java
@@ -28,7 +28,7 @@ public class ShadowDevicePolicyResourcesManager {
 
   /**
    * Override string returned by the resource identified by {@code stringId}. Reset the override by
-   * providing null as the {@code vaNlue}.
+   * providing null as the {@code value}.
    */
   public void setString(@Nonnull String stringId, String value) {
     stringMappings.put(stringId, value);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplay.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplay.java
index 04cb0fd8f..9016c770a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplay.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplay.java
@@ -254,7 +254,7 @@ public class ShadowDisplay {
    * Set HDR capabilities to the display sourced with displayId. see {@link HdrCapabilities} for
    * supportedHdrTypes.
    *
-   * @throws UnsupportedOperationException if the method is called below Android vesrsion N.
+   * @throws UnsupportedOperationException if the method is called below Android version N.
    */
   public void setDisplayHdrCapabilities(
       int displayId,
@@ -273,11 +273,10 @@ public class ShadowDisplay {
 
     ShadowDisplayManager.changeDisplay(
         displayId,
-        displayConfig -> {
-          displayConfig.hdrCapabilities =
-              new HdrCapabilities(
-                  supportedHdrTypes, maxLuminance, maxAverageLuminance, minLuminance);
-        });
+        displayConfig ->
+            displayConfig.hdrCapabilities =
+                new HdrCapabilities(
+                    supportedHdrTypes, maxLuminance, maxAverageLuminance, minLuminance));
   }
 
   /**
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java
index 09e744d8d..3e69fef24 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java
@@ -50,7 +50,7 @@ import org.robolectric.versioning.AndroidVersions.U;
 @Implements(className = "android.view.DisplayEventReceiver", isInAndroidSdk = false)
 public class ShadowDisplayEventReceiver {
 
-  private static NativeObjRegistry<NativeDisplayEventReceiver> nativeObjRegistry =
+  private static final NativeObjRegistry<NativeDisplayEventReceiver> nativeObjRegistry =
       new NativeObjRegistry<>(NativeDisplayEventReceiver.class);
 
   @RealObject protected DisplayEventReceiver realReceiver;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayHashManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayHashManager.java
index dfa58673a..09d5ba028 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayHashManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayHashManager.java
@@ -5,9 +5,9 @@ import static android.os.Build.VERSION_CODES.S;
 import android.view.displayhash.DisplayHash;
 import android.view.displayhash.DisplayHashManager;
 import android.view.displayhash.VerifiedDisplayHash;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableSet;
 import java.util.Collection;
+import java.util.Objects;
 import java.util.Set;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -43,7 +43,7 @@ public class ShadowDisplayHashManager {
 
   @Implementation(minSdk = S)
   protected Set<String> getSupportedHashAlgorithms() {
-    return Preconditions.checkNotNull(supportedHashAlgorithms);
+    return Objects.requireNonNull(supportedHashAlgorithms);
   }
 
   @Implementation(minSdk = S)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java
index 348c15361..d7b12515d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java
@@ -170,7 +170,7 @@ public class ShadowDisplayManagerGlobal {
     private final TreeMap<Integer, DisplayInfo> displayInfos = new TreeMap<>();
     private final Map<Integer, SystemUi> systemUis = new HashMap<>();
     private int nextDisplayId = 0;
-    private final List<IDisplayManagerCallback> callbacks = new ArrayList<>();
+    private final List<IDisplayManagerCallback> callbacks = new CopyOnWriteArrayList<>();
     private final Map<IVirtualDisplayCallback, Integer> virtualDisplayIds = new HashMap<>();
 
     // @Override
@@ -359,7 +359,7 @@ public class ShadowDisplayManagerGlobal {
   }
 
   /**
-   * Returns the current display saturation level; {@link android.os.Build.VERSION_CODES.P} only.
+   * Returns the current display saturation level; {@link android.os.Build.VERSION_CODES#P} only.
    */
   float getSaturationLevel() {
     return saturationLevel;
@@ -372,7 +372,7 @@ public class ShadowDisplayManagerGlobal {
       int userId,
       String packageName) {
     BrightnessConfiguration config = (BrightnessConfiguration) configObject;
-    brightnessConfiguration.put((int) userId, config);
+    brightnessConfiguration.put(userId, config);
   }
 
   @Implementation(minSdk = P)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDownloadManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDownloadManager.java
index a412ab079..723b87ace 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDownloadManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDownloadManager.java
@@ -30,10 +30,10 @@ public class ShadowDownloadManager {
 
   private static long queueCounter =
       -1; // First request starts at 0 just like in the real DownloadManager
-  private static Map<Long, DownloadManager.Request> requestMap = new TreeMap<>();
+  private static final Map<Long, DownloadManager.Request> requestMap = new TreeMap<>();
 
   private static long completedCounter = -1;
-  private static Map<Long, CompletedDownload> completedDownloadsMap = new HashMap<>();
+  private static final Map<Long, CompletedDownload> completedDownloadsMap = new HashMap<>();
 
   @Resetter
   public static void reset() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDropBoxManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDropBoxManager.java
index cbd681625..f07ddae68 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDropBoxManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDropBoxManager.java
@@ -31,7 +31,7 @@ public class ShadowDropBoxManager {
    * DropBoxManager.Entry#getText} can be used.
    *
    * @param tag can be any arbitrary string
-   * @param timestamp a unique timestamp for the entry, relative to {@link
+   * @param wallTimestamp a unique timestamp for the entry, relative to {@link
    *     System#currentTimeMillis()}
    * @param data must not be null
    */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEnvironment.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEnvironment.java
index f11322b69..dfbf46b7e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEnvironment.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEnvironment.java
@@ -298,7 +298,7 @@ public class ShadowEnvironment {
   /**
    * Sets the {@link #getExternalStorageState(File)} for given directory.
    *
-   * @param externalStorageState Value to return from {@link #getExternalStorageState(File)}.
+   * @param state Value to return from {@link #getExternalStorageState(File)}.
    */
   public static void setExternalStorageState(File directory, String state) {
     storageState.put(directory.toPath(), state);
@@ -309,7 +309,7 @@ public class ShadowEnvironment {
 
     @Implementation(minSdk = M)
     protected File[] getExternalDirs() {
-      return externalDirs.toArray(new File[externalDirs.size()]);
+      return externalDirs.toArray(new File[0]);
     }
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEuiccManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEuiccManager.java
index 62ccce394..280ff3187 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEuiccManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEuiccManager.java
@@ -52,6 +52,6 @@ public class ShadowEuiccManager {
 
   /** Set the value to be returned by {@link EuiccManager#getEid}. */
   public void setEid(String eid) {
-    this.eid = eid;
+    ShadowEuiccManager.eid = eid;
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileIntegrityManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileIntegrityManager.java
index 276fbd54b..f816f315e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileIntegrityManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileIntegrityManager.java
@@ -15,7 +15,7 @@ public class ShadowFileIntegrityManager {
 
   /** Sets the value of {@link #isApkVeritySupported}. */
   public void setIsApkVeritySupported(boolean isApkVeritySupported) {
-    this.isApkVeritySupported = isApkVeritySupported;
+    ShadowFileIntegrityManager.isApkVeritySupported = isApkVeritySupported;
   }
 
   /**
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFingerprintManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFingerprintManager.java
index 88f00f0a4..0a11efa00 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFingerprintManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFingerprintManager.java
@@ -113,14 +113,14 @@ public class ShadowFingerprintManager {
       } else {
         cancel.setOnCancelListener(
             () -> {
-              this.pendingCallback = null;
-              this.pendingCryptoObject = null;
+              pendingCallback = null;
+              pendingCryptoObject = null;
             });
       }
     }
 
-    this.pendingCryptoObject = crypto;
-    this.pendingCallback = callback;
+    pendingCryptoObject = crypto;
+    pendingCallback = callback;
   }
 
   /**
@@ -180,12 +180,12 @@ public class ShadowFingerprintManager {
   }
 
   private void setEnrolledFingerprints(Fingerprint... fingerprints) {
-    this.fingerprints = Arrays.asList(fingerprints);
+    ShadowFingerprintManager.fingerprints = Arrays.asList(fingerprints);
   }
 
   /** Sets the return value of {@link FingerprintManager#isHardwareDetected()}. */
   public void setIsHardwareDetected(boolean isHardwareDetected) {
-    this.isHardwareDetected = isHardwareDetected;
+    ShadowFingerprintManager.isHardwareDetected = isHardwareDetected;
   }
 
   /**
@@ -193,7 +193,7 @@ public class ShadowFingerprintManager {
    */
   @Implementation(minSdk = M)
   protected boolean isHardwareDetected() {
-    return this.isHardwareDetected;
+    return isHardwareDetected;
   }
 
   @Implementation(minSdk = VERSION_CODES.S)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFontBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFontBuilder.java
index cdd96c080..bd1bcc37d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFontBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFontBuilder.java
@@ -8,13 +8,13 @@ import android.annotation.RequiresApi;
 import android.content.res.AssetManager;
 import android.graphics.fonts.Font;
 import android.graphics.fonts.FontStyle;
-import com.google.common.base.Preconditions;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Objects;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
@@ -71,9 +71,9 @@ public class ShadowFontBuilder {
   protected static long nGetNativeAsset(
       AssetManager assetMgr, String path, boolean isAsset, int cookie) {
     // NPE_CHECK_RETURN_ZERO(env, assetMgr);
-    Preconditions.checkNotNull(assetMgr);
+    Objects.requireNonNull(assetMgr);
     // NPE_CHECK_RETURN_ZERO(env, path);
-    Preconditions.checkNotNull(path);
+    Objects.requireNonNull(path);
 
     // Guarded<AssetManager2>* mgr = AssetManagerForJavaObject(env, assetMgr);
     CppAssetManager2 mgr = ShadowArscAssetManager10.AssetManagerForJavaObject(assetMgr);
@@ -130,8 +130,8 @@ public class ShadowFontBuilder {
   @Implementation(minSdk = R)
   protected static ByteBuffer createBuffer(
       AssetManager am, String path, boolean isAsset, int cookie) throws IOException {
-    Preconditions.checkNotNull(am, "assetManager can not be null");
-    Preconditions.checkNotNull(path, "path can not be null");
+    Objects.requireNonNull(am, "assetManager can not be null");
+    Objects.requireNonNull(path, "path can not be null");
 
     try (InputStream assetStream =
         isAsset
@@ -160,9 +160,9 @@ public class ShadowFontBuilder {
       int weight,
       boolean italic,
       int ttcIndex) {
-    Preconditions.checkNotNull(buffer);
-    Preconditions.checkNotNull(filePath);
-    Preconditions.checkNotNull(localeList);
+    Objects.requireNonNull(buffer);
+    Objects.requireNonNull(filePath);
+    Objects.requireNonNull(localeList);
 
     buffer.rewind();
     // If users use one ttf file for different style, for example one ttf for bold and normal,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGainmap.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGainmap.java
index 0fdbf25f3..561ec3c9a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGainmap.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGainmap.java
@@ -196,8 +196,7 @@ public class ShadowGainmap {
         @Override
         public Gainmap createFromParcel(Parcel in) {
           in.setDataPosition(0);
-          Gainmap gm = new Gainmap(in.readTypedObject(Bitmap.CREATOR));
-          return gm;
+          return new Gainmap(in.readTypedObject(Bitmap.CREATOR));
         }
 
         @Override
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowHttpResponseCache.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowHttpResponseCache.java
index 0fb712d4b..1971cdd12 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowHttpResponseCache.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowHttpResponseCache.java
@@ -25,7 +25,10 @@ public class ShadowHttpResponseCache {
   private File directory;
   private long maxSize;
   private int requestCount = 0;
+
+  @SuppressWarnings({"FieldMayBeFinal", "FieldCanBeLocal"})
   private int hitCount = 0;
+
   private int networkCount = 0;
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImsMmTelManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImsMmTelManager.java
index ff53ff828..02b5440f9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImsMmTelManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImsMmTelManager.java
@@ -12,6 +12,7 @@ import android.telephony.SubscriptionManager;
 import android.telephony.ims.ImsException;
 import android.telephony.ims.ImsMmTelManager;
 import android.telephony.ims.ImsMmTelManager.CapabilityCallback;
+import android.telephony.ims.ImsMmTelManager.RegistrationCallback;
 import android.telephony.ims.ImsReasonInfo;
 import android.telephony.ims.ImsRegistrationAttributes;
 import android.telephony.ims.RegistrationManager;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInCallService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInCallService.java
index e68ccac92..74adc1a34 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInCallService.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInCallService.java
@@ -7,7 +7,7 @@ import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static org.robolectric.shadow.api.Shadow.invokeConstructor;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.TargetApi;
+import android.annotation.RequiresApi;
 import android.bluetooth.BluetoothDevice;
 import android.os.Build.VERSION;
 import android.os.Bundle;
@@ -19,6 +19,7 @@ import android.telecom.InCallService;
 import android.telecom.ParcelableCall;
 import android.telecom.Phone;
 import com.android.internal.os.SomeArgs;
+import com.android.internal.telecom.IInCallAdapter;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -167,7 +168,7 @@ public class ShadowInCallService extends ShadowService {
   /**
    * @return the last value provided to {@code requestBluetoothAudio()}.
    */
-  @TargetApi(P)
+  @RequiresApi(P)
   public BluetoothDevice getBluetoothAudio() {
     return bluetoothDevice;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputManager.java
index f8018973f..2bc281ab4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputManager.java
@@ -75,8 +75,8 @@ public class ShadowInputManager {
       final int[] ids = realInputManager.getInputDeviceIds();
 
       SparseArray<InputDevice> inputDevices = new SparseArray<>();
-      for (int i = 0; i < ids.length; i++) {
-        inputDevices.put(ids[i], null);
+      for (int id : ids) {
+        inputDevices.put(id, null);
       }
       setInputDevices(inputDevices);
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputManagerGlobal.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputManagerGlobal.java
index c3f6341da..ff0f38173 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputManagerGlobal.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputManagerGlobal.java
@@ -40,8 +40,8 @@ public class ShadowInputManagerGlobal {
       final int[] ids = realInputManager.getInputDeviceIds();
 
       SparseArray<InputDevice> inputDevices = new SparseArray<>();
-      for (int i = 0; i < ids.length; i++) {
-        inputDevices.put(ids[i], null);
+      for (int id : ids) {
+        inputDevices.put(id, null);
       }
       setInputDevices(inputDevices);
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputMethodManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputMethodManager.java
index 741e98b86..d93fb8175 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputMethodManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputMethodManager.java
@@ -144,8 +144,7 @@ public class ShadowInputMethodManager {
 
   public void setSoftInputVisibilityHandler(
       SoftInputVisibilityChangeHandler visibilityChangeHandler) {
-    this.visibilityChangeHandler =
-        Optional.<SoftInputVisibilityChangeHandler>of(visibilityChangeHandler);
+    ShadowInputMethodManager.visibilityChangeHandler = Optional.of(visibilityChangeHandler);
   }
 
   private void setSoftInputVisibility(boolean visible) {
@@ -181,7 +180,7 @@ public class ShadowInputMethodManager {
    * #getInputMethodList()}.
    */
   public void setInputMethodInfoList(List<InputMethodInfo> inputMethodInfoList) {
-    this.inputMethodInfoList = inputMethodInfoList;
+    ShadowInputMethodManager.inputMethodInfoList = inputMethodInfoList;
   }
 
   /**
@@ -200,7 +199,7 @@ public class ShadowInputMethodManager {
    * #getCurrentInputMethodSubtype()}.
    */
   public void setCurrentInputMethodSubtype(InputMethodSubtype inputMethodSubtype) {
-    this.inputMethodSubtype = Optional.of(inputMethodSubtype);
+    ShadowInputMethodManager.inputMethodSubtype = Optional.of(inputMethodSubtype);
   }
 
   /**
@@ -219,7 +218,7 @@ public class ShadowInputMethodManager {
    * #getEnabledInputMethodList()}.
    */
   public void setEnabledInputMethodInfoList(List<InputMethodInfo> inputMethodInfoList) {
-    this.enabledInputMethodInfoList = inputMethodInfoList;
+    enabledInputMethodInfoList = inputMethodInfoList;
   }
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java
index 787969696..ae4c4816e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java
@@ -9,9 +9,9 @@ import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.N_MR1;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.P;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Futures.immediateFuture;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static java.util.Objects.requireNonNull;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.app.Activity;
@@ -30,6 +30,7 @@ import android.content.Intent;
 import android.content.Intent.FilterComparison;
 import android.content.IntentFilter;
 import android.content.ServiceConnection;
+import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.IBinder;
@@ -39,12 +40,10 @@ import android.os.UserHandle;
 import android.text.TextUtils;
 import android.util.Pair;
 import com.google.common.collect.ImmutableList;
-import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -317,7 +316,7 @@ public class ShadowInstrumentation {
     }
   }
 
-  /** Returns the BroadcaseReceivers wrappers, matching intent's action and permissions. */
+  /** Returns the BroadcastReceivers wrappers, matching intent's action and permissions. */
   private List<Wrapper> getAppropriateWrappers(
       Context context,
       @Nullable UserHandle userHandle,
@@ -409,13 +408,10 @@ public class ShadowInstrumentation {
     final ShadowBroadcastReceiver shReceiver = Shadow.extract(receiver);
     final Intent broadcastIntent = intent;
     scheduler.post(
-        new Runnable() {
-          @Override
-          public void run() {
-            receiver.setPendingResult(
-                ShadowBroadcastPendingResult.create(resultCode, null, null, false));
-            shReceiver.onReceive(context, broadcastIntent, abort);
-          }
+        () -> {
+          receiver.setPendingResult(
+              ShadowBroadcastPendingResult.create(resultCode, null, null, false));
+          shReceiver.onReceive(context, broadcastIntent, abort);
         });
   }
 
@@ -444,23 +440,16 @@ public class ShadowInstrumentation {
     }
     final ListenableFuture<?> finalFuture = future;
     future.addListener(
-        new Runnable() {
-          @Override
-          public void run() {
+        () ->
             getMainHandler(context)
                 .post(
-                    new Runnable() {
-                      @Override
-                      public void run() {
-                        try {
-                          finalFuture.get();
-                        } catch (InterruptedException | ExecutionException e) {
-                          throw new RuntimeException(e);
-                        }
+                    () -> {
+                      try {
+                        finalFuture.get();
+                      } catch (InterruptedException | ExecutionException e) {
+                        throw new RuntimeException(e);
                       }
-                    });
-          }
-        },
+                    }),
         directExecutor());
   }
 
@@ -478,25 +467,21 @@ public class ShadowInstrumentation {
         (wrapper.scheduler != null) ? wrapper.scheduler : getMainHandler(context);
     return Futures.transformAsync(
         oldResult,
-        new AsyncFunction<BroadcastResultHolder, BroadcastResultHolder>() {
-          @Override
-          public ListenableFuture<BroadcastResultHolder> apply(
-              BroadcastResultHolder broadcastResultHolder) throws Exception {
-            final BroadcastReceiver.PendingResult result =
-                ShadowBroadcastPendingResult.create(
-                    broadcastResultHolder.resultCode,
-                    broadcastResultHolder.resultData,
-                    broadcastResultHolder.resultExtras,
-                    true /*ordered */);
-            wrapper.broadcastReceiver.setPendingResult(result);
-            scheduler.post(
-                () -> {
-                  ShadowBroadcastReceiver shadowBroadcastReceiver =
-                      Shadow.extract(wrapper.broadcastReceiver);
-                  shadowBroadcastReceiver.onReceive(context, intent, abort);
-                });
-            return BroadcastResultHolder.transform(result);
-          }
+        broadcastResultHolder -> {
+          final BroadcastReceiver.PendingResult result =
+              ShadowBroadcastPendingResult.create(
+                  broadcastResultHolder.resultCode,
+                  broadcastResultHolder.resultData,
+                  broadcastResultHolder.resultExtras,
+                  true /*ordered */);
+          wrapper.broadcastReceiver.setPendingResult(result);
+          scheduler.post(
+              () -> {
+                ShadowBroadcastReceiver shadowBroadcastReceiver =
+                    Shadow.extract(wrapper.broadcastReceiver);
+                shadowBroadcastReceiver.onReceive(context, intent, abort);
+              });
+          return BroadcastResultHolder.transform(result);
         },
         directExecutor());
   }
@@ -566,13 +551,9 @@ public class ShadowInstrumentation {
   private void sortByPriority(List<Wrapper> wrappers) {
     Collections.sort(
         wrappers,
-        new Comparator<Wrapper>() {
-          @Override
-          public int compare(Wrapper o1, Wrapper o2) {
-            return Integer.compare(
-                o2.getIntentFilter().getPriority(), o1.getIntentFilter().getPriority());
-          }
-        });
+        (o1, o2) ->
+            Integer.compare(
+                o2.getIntentFilter().getPriority(), o1.getIntentFilter().getPriority()));
   }
 
   List<Intent> getBroadcastIntents() {
@@ -654,11 +635,10 @@ public class ShadowInstrumentation {
   }
 
   TargetAndRequestCode getTargetAndRequestCodeForIntent(Intent requestIntent) {
-    return checkNotNull(
+    return requireNonNull(
         intentRequestCodeMap.get(new Intent.FilterComparison(requestIntent)),
-        "No intent matches %s among %s",
-        requestIntent,
-        intentRequestCodeMap.keySet());
+        String.format(
+            "No intent matches %s among %s", requestIntent, intentRequestCodeMap.keySet()));
   }
 
   protected ComponentName startService(Intent intent) {
@@ -807,7 +787,7 @@ public class ShadowInstrumentation {
   }
 
   void declareComponentUnbindable(ComponentName component) {
-    checkNotNull(component);
+    requireNonNull(component);
     unbindableComponents.add(component);
   }
 
@@ -904,6 +884,10 @@ public class ShadowInstrumentation {
         receiver, filter, broadcastPermission, scheduler, flags, context);
   }
 
+  private static boolean validateReceiverExportFlags() {
+    return Boolean.getBoolean("robolectric.validateReceiverExportFlags");
+  }
+
   Intent registerReceiverWithContext(
       BroadcastReceiver receiver,
       IntentFilter filter,
@@ -911,6 +895,30 @@ public class ShadowInstrumentation {
       Handler scheduler,
       int flags,
       Context context) {
+    // See ActivityManagerService#registerReceiverWithFeature.
+    if (validateReceiverExportFlags()
+        && RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
+      final boolean explicitExportStateDefined =
+          (flags & (Context.RECEIVER_EXPORTED | Context.RECEIVER_NOT_EXPORTED)) != 0;
+      if (((flags & Context.RECEIVER_EXPORTED) != 0)
+          && ((flags & Context.RECEIVER_NOT_EXPORTED) != 0)) {
+        throw new IllegalArgumentException(
+            "Receiver can't specify both RECEIVER_EXPORTED and RECEIVER_NOT_EXPORTED flag");
+      }
+      // DYNAMIC_RECEIVER_EXPLICIT_EXPORT_REQUIRED is enabled if targetSdk from UPSIDE_DOWN_CAKE.
+      // See android.server.am.BroadcastController.
+      boolean requireExplicitFlagForDynamicReceivers =
+          context.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
+      if (receiver != null
+          && requireExplicitFlagForDynamicReceivers
+          && !explicitExportStateDefined) {
+        throw new SecurityException(
+            context.getPackageName()
+                + ": One of RECEIVER_EXPORTED or "
+                + "RECEIVER_NOT_EXPORTED should be specified when a receiver "
+                + "isn't being registered exclusively for system broadcasts");
+      }
+    }
     if (receiver != null) {
       synchronized (registeredReceivers) {
         registeredReceivers.add(
@@ -1019,7 +1027,7 @@ public class ShadowInstrumentation {
       }
       return PERMISSION_DENIED;
     } else {
-      Set<String> grantedPermissionsForPidUid = grantedPermissionsMap.get(new Pair(pid, uid));
+      Set<String> grantedPermissionsForPidUid = grantedPermissionsMap.get(new Pair<>(pid, uid));
       return grantedPermissionsForPidUid != null && grantedPermissionsForPidUid.contains(permission)
           ? PERMISSION_GRANTED
           : PERMISSION_DENIED;
@@ -1185,7 +1193,7 @@ public class ShadowInstrumentation {
   public static void runOnMainSyncNoIdle(Runnable runnable) {
     if (ShadowLooper.looperMode() == LooperMode.Mode.INSTRUMENTATION_TEST
         && Looper.myLooper() != Looper.getMainLooper()) {
-      checkNotNull(getInstrumentation()).runOnMainSync(runnable);
+      requireNonNull(getInstrumentation()).runOnMainSync(runnable);
     } else {
       runnable.run();
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIsoDep.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIsoDep.java
index 89b5a8b52..471975d40 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIsoDep.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIsoDep.java
@@ -16,8 +16,8 @@ import org.robolectric.shadow.api.Shadow;
  * but most hardware implementations will have a lower limit. If extended length apdus are not
  * supported, the theoretical max transceive length is 0x105 but, again, may be lower in practice.
  *
- * <p>Dictate the Apdu response returned in {@link transceive} via {@link #setTransceiveResponse} or
- * {@link #setNextTransceiveResponse}. The former will be returned with every call to transceive
+ * <p>Dictate the Apdu response returned in {@link #transceive} via {@link #setTransceiveResponse}
+ * or {@link #setNextTransceiveResponse}. The former will be returned with every call to transceive
  * while the later will be returned only once. If neither is set, transceive will throw an
  * IOException.
  */
@@ -25,7 +25,6 @@ import org.robolectric.shadow.api.Shadow;
 public class ShadowIsoDep extends ShadowBasicTagTechnology {
 
   @SuppressLint("PrivateApi")
-  @SuppressWarnings("unchecked")
   public static IsoDep newInstance() {
     return Shadow.newInstance(IsoDep.class, new Class<?>[] {Tag.class}, new Object[] {null});
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJobScheduler.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJobScheduler.java
index 807e9bbfb..23d860454 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJobScheduler.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJobScheduler.java
@@ -4,8 +4,8 @@ import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.S;
 
+import android.annotation.RequiresApi;
 import android.annotation.SystemApi;
-import android.annotation.TargetApi;
 import android.app.JobSchedulerImpl;
 import android.app.job.JobInfo;
 import android.app.job.JobScheduler;
@@ -126,7 +126,7 @@ public abstract class ShadowJobScheduler {
     }
 
     @Override
-    @TargetApi(S)
+    @RequiresApi(S)
     public void failExpeditedJob(boolean enabled) {
       failExpeditedJobEnabled = enabled;
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowKeyguardManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowKeyguardManager.java
index f1b6383a9..975cc1219 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowKeyguardManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowKeyguardManager.java
@@ -19,8 +19,8 @@ import org.robolectric.annotation.Resetter;
 public class ShadowKeyguardManager {
   // These have to be static because on Android L and below, a new instance of KeyguardManager is
   // created each time it is requested.
-  private static final Set<Integer> deviceLockedForUsers = new HashSet<Integer>();
-  private static final Set<Integer> deviceSecureForUsers = new HashSet<Integer>();
+  private static final Set<Integer> deviceLockedForUsers = new HashSet<>();
+  private static final Set<Integer> deviceSecureForUsers = new HashSet<>();
   private static boolean inRestrictedInputMode;
   private static boolean isKeyguardLocked;
   private static boolean isDeviceLocked;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java
index c1781e865..3ce00acd8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java
@@ -26,9 +26,11 @@ import android.os.Process;
 import android.os.UserHandle;
 import android.util.Pair;
 import com.google.common.collect.HashMultimap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Multimap;
+import com.google.common.collect.Multimaps;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -52,9 +54,9 @@ public class ShadowLauncherApps {
   private static final Multimap<UserHandle, ComponentName> enabledActivities =
       HashMultimap.create();
   private static final Multimap<UserHandle, LauncherActivityInfo> shortcutActivityList =
-      HashMultimap.create();
+      Multimaps.synchronizedMultimap(HashMultimap.create());
   private static final Multimap<UserHandle, LauncherActivityInfo> activityList =
-      HashMultimap.create();
+      Multimaps.synchronizedMultimap(HashMultimap.create());
   private static final Map<UserHandle, Map<String, ApplicationInfo>> applicationInfoList =
       new HashMap<>();
   private static final Map<UserHandle, Map<String, Bundle>> suspendedPackageLauncherExtras =
@@ -197,7 +199,10 @@ public class ShadowLauncherApps {
   @Implementation(minSdk = O)
   protected List<LauncherActivityInfo> getShortcutConfigActivityList(
       @Nullable String packageName, @Nonnull UserHandle user) {
-    return shortcutActivityList.get(user).stream()
+    // Take a snapshot to avoid concurrent modification exceptions.
+    ImmutableSet<LauncherActivityInfo> activityInfosSnapshot =
+        ImmutableSet.copyOf(shortcutActivityList.get(user));
+    return activityInfosSnapshot.stream()
         .filter(matchesPackage(packageName))
         .collect(Collectors.toList());
   }
@@ -216,7 +221,10 @@ public class ShadowLauncherApps {
 
   @Implementation(minSdk = L)
   protected List<LauncherActivityInfo> getActivityList(String packageName, UserHandle user) {
-    return activityList.get(user).stream()
+    // Take a snapshot to avoid concurrent modification exceptions.
+    ImmutableSet<LauncherActivityInfo> activityInfosSnapshot =
+        ImmutableSet.copyOf(activityList.get(user));
+    return activityInfosSnapshot.stream()
         .filter(matchesPackage(packageName))
         .collect(Collectors.toList());
   }
@@ -379,9 +387,9 @@ public class ShadowLauncherApps {
 
   @Implementation
   protected void unregisterCallback(LauncherApps.Callback callback) {
-    int index = Iterables.indexOf(this.callbacks, pair -> pair.first == callback);
+    int index = Iterables.indexOf(callbacks, pair -> pair.first == callback);
     if (index != -1) {
-      this.callbacks.remove(index);
+      callbacks.remove(index);
     }
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyAsyncTask.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyAsyncTask.java
index 597c6d890..db5908217 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyAsyncTask.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyAsyncTask.java
@@ -17,13 +17,19 @@ import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.util.reflector.ForType;
 
-/** A {@link AsyncTask} shadow for {@link LooperMode.Mode.LEGACY}. */
+/**
+ * A {@link AsyncTask} shadow for {@link LooperMode.Mode#LEGACY}.
+ *
+ * @deprecated {@link AsyncTask} is deprecated in the Android SDK.
+ */
+@Deprecated
 @Implements(
     value = AsyncTask.class,
     shadowPicker = ShadowAsyncTask.Picker.class,
     // TODO: turn off shadowOf generation. Figure out why this is needed
     isInAndroidSdk = false)
-public class ShadowLegacyAsyncTask<Params, Progress, Result> extends ShadowAsyncTask {
+public class ShadowLegacyAsyncTask<Params, Progress, Result>
+    extends ShadowAsyncTask<Params, Progress, Result> {
 
   @RealObject private AsyncTask<Params, Progress, Result> realAsyncTask;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyAsyncTaskLoader.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyAsyncTaskLoader.java
index 4384f6590..543bd1af1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyAsyncTaskLoader.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyAsyncTaskLoader.java
@@ -10,12 +10,17 @@ import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.RealObject;
 
-/** The shadow {@link AsyncTaskLoader} for {@link LooperMode.Mode.LEGACY}. */
+/**
+ * The shadow {@link AsyncTaskLoader} for {@link LooperMode.Mode#LEGACY}.
+ *
+ * @deprecated {@link AsyncTaskLoader} is deprecated in the Android SDK.
+ */
+@Deprecated
 @Implements(
     value = AsyncTaskLoader.class,
     shadowPicker = ShadowAsyncTaskLoader.Picker.class,
     isInAndroidSdk = false)
-public class ShadowLegacyAsyncTaskLoader<D> extends ShadowAsyncTaskLoader {
+public class ShadowLegacyAsyncTaskLoader<D> extends ShadowAsyncTaskLoader<D> {
   @RealObject private AsyncTaskLoader<D> realObject;
   private BackgroundWorker worker;
 
@@ -34,13 +39,7 @@ public class ShadowLegacyAsyncTaskLoader<D> extends ShadowAsyncTaskLoader {
               final D result = get();
               ShadowApplication.getInstance()
                   .getForegroundThreadScheduler()
-                  .post(
-                      new Runnable() {
-                        @Override
-                        public void run() {
-                          realObject.deliverResult(result);
-                        }
-                      });
+                  .post(() -> realObject.deliverResult(result));
             } catch (InterruptedException e) {
               // Ignore
             } catch (ExecutionException e) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyBitmap.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyBitmap.java
index b2d897683..26d8a75eb 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyBitmap.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyBitmap.java
@@ -5,9 +5,9 @@ import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.S;
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.lang.Integer.max;
 import static java.lang.Integer.min;
+import static java.util.Objects.requireNonNull;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.graphics.Bitmap;
@@ -95,7 +95,7 @@ public class ShadowLegacyBitmap extends ShadowBitmap {
     if (width <= 0 || height <= 0) {
       throw new IllegalArgumentException("width and height must be > 0");
     }
-    checkNotNull(config);
+    requireNonNull(config);
     Bitmap scaledBitmap = ReflectionHelpers.callConstructor(Bitmap.class);
     ShadowLegacyBitmap shadowBitmap = Shadow.extract(scaledBitmap);
     shadowBitmap.setDescription("Bitmap (" + width + " x " + height + ")");
@@ -213,7 +213,7 @@ public class ShadowLegacyBitmap extends ShadowBitmap {
     if (Math.abs(stride) < width) {
       throw new IllegalArgumentException("abs(stride) must be >= width");
     }
-    checkNotNull(config);
+    requireNonNull(config);
     int lastScanline = offset + (height - 1) * stride;
     int length = colors.length;
     if (offset < 0
@@ -262,7 +262,7 @@ public class ShadowLegacyBitmap extends ShadowBitmap {
     shadowBitmap.appendDescription(shadowSrcBitmap.getDescription());
     shadowBitmap.appendDescription(" scaled to " + dstWidth + " x " + dstHeight);
     if (filter) {
-      shadowBitmap.appendDescription(" with filter " + filter);
+      shadowBitmap.appendDescription(" with filter true");
     }
 
     shadowBitmap.createdFromBitmap = src;
@@ -790,7 +790,7 @@ public class ShadowLegacyBitmap extends ShadowBitmap {
 
   @Implementation(minSdk = Q)
   protected void setColorSpace(ColorSpace colorSpace) {
-    this.colorSpace = checkNotNull(colorSpace);
+    this.colorSpace = requireNonNull(colorSpace);
   }
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyCanvas.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyCanvas.java
index 7e9cad3bb..14a46bb6c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyCanvas.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyCanvas.java
@@ -17,9 +17,9 @@ import android.graphics.Paint;
 import android.graphics.Path;
 import android.graphics.Rect;
 import android.graphics.RectF;
-import com.google.common.base.Preconditions;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Objects;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -46,13 +46,13 @@ public class ShadowLegacyCanvas extends ShadowCanvas {
   @ReflectorObject protected CanvasReflector canvasReflector;
 
   private final List<RoundRectPaintHistoryEvent> roundRectPaintEvents = new ArrayList<>();
-  private List<PathPaintHistoryEvent> pathPaintEvents = new ArrayList<>();
-  private List<CirclePaintHistoryEvent> circlePaintEvents = new ArrayList<>();
-  private List<ArcPaintHistoryEvent> arcPaintEvents = new ArrayList<>();
-  private List<RectPaintHistoryEvent> rectPaintEvents = new ArrayList<>();
-  private List<LinePaintHistoryEvent> linePaintEvents = new ArrayList<>();
-  private List<OvalPaintHistoryEvent> ovalPaintEvents = new ArrayList<>();
-  private List<TextHistoryEvent> drawnTextEventHistory = new ArrayList<>();
+  private final List<PathPaintHistoryEvent> pathPaintEvents = new ArrayList<>();
+  private final List<CirclePaintHistoryEvent> circlePaintEvents = new ArrayList<>();
+  private final List<ArcPaintHistoryEvent> arcPaintEvents = new ArrayList<>();
+  private final List<RectPaintHistoryEvent> rectPaintEvents = new ArrayList<>();
+  private final List<LinePaintHistoryEvent> linePaintEvents = new ArrayList<>();
+  private final List<OvalPaintHistoryEvent> ovalPaintEvents = new ArrayList<>();
+  private final List<TextHistoryEvent> drawnTextEventHistory = new ArrayList<>();
   private Paint drawnPaint;
   private Bitmap targetBitmap = ReflectionHelpers.callConstructor(Bitmap.class);
   private float translateX;
@@ -180,7 +180,7 @@ public class ShadowLegacyCanvas extends ShadowCanvas {
     }
 
     if (src != null) {
-      descriptionBuilder.append(" taken from ").append(src.toString());
+      descriptionBuilder.append(" taken from ").append(src);
     }
     appendDescription(descriptionBuilder.toString());
   }
@@ -203,7 +203,7 @@ public class ShadowLegacyCanvas extends ShadowCanvas {
     }
 
     if (src != null) {
-      descriptionBuilder.append(" taken from ").append(src.toString());
+      descriptionBuilder.append(" taken from ").append(src);
     }
     appendDescription(descriptionBuilder.toString());
   }
@@ -288,7 +288,7 @@ public class ShadowLegacyCanvas extends ShadowCanvas {
   }
 
   private void separateLines() {
-    if (getDescription().length() != 0) {
+    if (!getDescription().isEmpty()) {
       appendDescription("\n");
     }
   }
@@ -315,7 +315,7 @@ public class ShadowLegacyCanvas extends ShadowCanvas {
 
   @Override
   public boolean hasDrawnCircle() {
-    return circlePaintEvents.size() > 0;
+    return !circlePaintEvents.isEmpty();
   }
 
   @Override
@@ -384,7 +384,7 @@ public class ShadowLegacyCanvas extends ShadowCanvas {
 
   @Implementation
   protected boolean getClipBounds(Rect bounds) {
-    Preconditions.checkNotNull(bounds);
+    Objects.requireNonNull(bounds);
     if (targetBitmap == null) {
       return false;
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyChoreographer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyChoreographer.java
index 8d01deb10..7901bf2ae 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyChoreographer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyChoreographer.java
@@ -1,22 +1,24 @@
 package org.robolectric.shadows;
 
+import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.SystemClock;
 import android.view.Choreographer;
 import android.view.Choreographer.FrameCallback;
 import java.time.Duration;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.Resetter;
-import org.robolectric.shadow.api.Shadow;
-import org.robolectric.util.SoftThreadLocal;
+import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
 /**
- * The {@link Choreographer} shadow for {@link LooperMode.Mode.PAUSED}.
+ * The {@link Choreographer} shadow for {@link LooperMode.Mode#PAUSED}.
  *
- * <p>In {@link LooperMode.Mode.PAUSED} mode, Robolectric maintains its own concept of the current
+ * <p>In {@link LooperMode.Mode#PAUSED} mode, Robolectric maintains its own concept of the current
  * time from the Choreographer's point of view, aimed at making animations work correctly. Time
  * starts out at 0 and advances by {@code frameInterval} every time {@link
  * Choreographer#getFrameTimeNanos()} is called.
@@ -29,32 +31,27 @@ public class ShadowLegacyChoreographer extends ShadowChoreographer {
   private long nanoTime = 0;
   private static long FRAME_INTERVAL = Duration.ofMillis(10).toNanos();
   private static final Thread MAIN_THREAD = Thread.currentThread();
-  private static SoftThreadLocal<Choreographer> instance = makeThreadLocal();
-  private Handler handler = new Handler(Looper.myLooper());
+  private static ThreadLocal<Choreographer> instance =
+      ThreadLocal.withInitial(() -> makeChoreographer());
+  private final Handler handler = new Handler(Looper.myLooper());
   private static volatile int postCallbackDelayMillis = 0;
   private static volatile int postFrameCallbackDelayMillis = 0;
 
-  @SuppressWarnings("ReturnValueIgnored")
-  private static SoftThreadLocal<Choreographer> makeThreadLocal() {
-    return new SoftThreadLocal<Choreographer>() {
-      @Override
-      protected Choreographer create() {
-        Looper looper = Looper.myLooper();
-        if (looper == null) {
-          throw new IllegalStateException("The current thread must have a looper!");
-        }
-
-        // Choreographer's constructor changes somewhere in Android O...
-        try {
-          Choreographer.class.getDeclaredConstructor(Looper.class);
-          return Shadow.newInstance(
-              Choreographer.class, new Class[] {Looper.class}, new Object[] {looper});
-        } catch (NoSuchMethodException e) {
-          return Shadow.newInstance(
-              Choreographer.class, new Class[] {Looper.class, int.class}, new Object[] {looper, 0});
-        }
-      }
-    };
+  private static Choreographer makeChoreographer() {
+    Looper looper = Looper.myLooper();
+    if (looper == null) {
+      throw new IllegalStateException("The current thread must have a looper!");
+    }
+    if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.O) {
+      return ReflectionHelpers.callConstructor(
+          Choreographer.class,
+          ClassParameter.from(Looper.class, looper),
+          ClassParameter.from(int.class, 0));
+
+    } else {
+      return ReflectionHelpers.callConstructor(
+          Choreographer.class, ClassParameter.from(Looper.class, looper));
+    }
   }
 
   /**
@@ -133,12 +130,7 @@ public class ShadowLegacyChoreographer extends ShadowChoreographer {
   @Implementation
   protected void postFrameCallbackDelayed(final FrameCallback callback, long delayMillis) {
     handler.postAtTime(
-        new Runnable() {
-          @Override
-          public void run() {
-            callback.doFrame(getFrameTimeNanos());
-          }
-        },
+        () -> callback.doFrame(getFrameTimeNanos()),
         callback,
         SystemClock.uptimeMillis() + delayMillis);
   }
@@ -180,7 +172,7 @@ public class ShadowLegacyChoreographer extends ShadowChoreographer {
     if (Thread.currentThread() != MAIN_THREAD) {
       throw new RuntimeException("You should only call this from the main thread!");
     }
-    instance = makeThreadLocal();
+    instance = ThreadLocal.withInitial(() -> makeChoreographer());
     FRAME_INTERVAL = Duration.ofMillis(10).toNanos();
     postCallbackDelayMillis = 0;
     postFrameCallbackDelayMillis = 0;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyCursorWindow.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyCursorWindow.java
index 90c370c3d..163c93f37 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyCursorWindow.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyCursorWindow.java
@@ -7,17 +7,17 @@ import android.database.CursorWindow;
 import com.almworks.sqlite4java.SQLiteConstants;
 import com.almworks.sqlite4java.SQLiteException;
 import com.almworks.sqlite4java.SQLiteStatement;
-import com.google.common.base.Preconditions;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicLong;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
-/** Legacy shadow for {@link CursowWindow}. */
+/** Legacy shadow for {@link CursorWindow}. */
 @Implements(value = CursorWindow.class, isInAndroidSdk = false)
 public class ShadowLegacyCursorWindow extends ShadowCursorWindow {
   private static final WindowData WINDOW_DATA = new WindowData();
@@ -92,7 +92,7 @@ public class ShadowLegacyCursorWindow extends ShadowCursorWindow {
   @Implementation
   protected static boolean nativePutBlob(long windowPtr, byte[] value, int row, int column) {
     // Real Android will crash in native code if putString is called with a null value.
-    Preconditions.checkNotNull(value);
+    Objects.requireNonNull(value);
     return WINDOW_DATA
         .get(windowPtr)
         .putValue(new Value(value, Cursor.FIELD_TYPE_BLOB), row, column);
@@ -101,7 +101,7 @@ public class ShadowLegacyCursorWindow extends ShadowCursorWindow {
   @Implementation
   protected static boolean nativePutString(long windowPtr, String value, int row, int column) {
     // Real Android will crash in native code if putString is called with a null value.
-    Preconditions.checkNotNull(value);
+    Objects.requireNonNull(value);
     return WINDOW_DATA
         .get(windowPtr)
         .putValue(new Value(value, Cursor.FIELD_TYPE_STRING), row, column);
@@ -178,7 +178,7 @@ public class ShadowLegacyCursorWindow extends ShadowCursorWindow {
 
     public Data(String name, int cursorWindowSize) {
       this.name = name;
-      this.rows = new ArrayList<Row>();
+      this.rows = new ArrayList<>();
     }
 
     public Value value(int rowN, int colN) {
@@ -255,7 +255,7 @@ public class ShadowLegacyCursorWindow extends ShadowCursorWindow {
     private final List<Value> values;
 
     public Row(int length) {
-      values = new ArrayList<Value>(length);
+      values = new ArrayList<>(length);
       for (int i = 0; i < length; i++) {
         values.add(new Value(null, Cursor.FIELD_TYPE_NULL));
       }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyLooper.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyLooper.java
index e7069b480..81808067c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyLooper.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyLooper.java
@@ -14,7 +14,6 @@ import java.util.List;
 import java.util.Map;
 import java.util.WeakHashMap;
 import java.util.concurrent.TimeUnit;
-import org.robolectric.RoboSettings;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -26,7 +25,7 @@ import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.Scheduler;
 
 /**
- * The shadow Looper implementation for {@link LooperMode.Mode.LEGACY}.
+ * The shadow Looper implementation for {@link LooperMode.Mode#LEGACY}.
  *
  * <p>Robolectric enqueues posted {@link Runnable}s to be run (on this thread) later. {@code
  * Runnable}s that are scheduled to run immediately can be triggered by calling {@link #idle()}.
@@ -43,8 +42,8 @@ public class ShadowLegacyLooper extends ShadowLooper {
   // is called. This also allows us to implement the useful getLooperForThread() method.
   // Note that the main looper is handled differently and is not put in this hash, because we need
   // to be able to "switch" the thread that the main looper is associated with.
-  private static Map<Thread, Looper> loopingLoopers =
-      Collections.synchronizedMap(new WeakHashMap<Thread, Looper>());
+  private static final Map<Thread, Looper> loopingLoopers =
+      Collections.synchronizedMap(new WeakHashMap<>());
 
   private static Looper mainLooper;
 
@@ -89,9 +88,7 @@ public class ShadowLegacyLooper extends ShadowLooper {
   /** Internal API to initialize background thread scheduler from AndroidTestEnvironment. */
   public static void internalInitializeBackgroundThreadScheduler() {
     backgroundScheduler =
-        RoboSettings.isUseGlobalScheduler()
-            ? RuntimeEnvironment.getMasterScheduler()
-            : new Scheduler();
+        useGlobalScheduler() ? RuntimeEnvironment.getMasterScheduler() : new Scheduler();
   }
 
   @Implementation
@@ -292,7 +289,7 @@ public class ShadowLegacyLooper extends ShadowLooper {
   @Override
   public void resetScheduler() {
     ShadowMessageQueue shadowMessageQueue = shadowOf(realObject.getQueue());
-    if (realObject == Looper.getMainLooper() || RoboSettings.isUseGlobalScheduler()) {
+    if (realObject == Looper.getMainLooper() || useGlobalScheduler()) {
       shadowMessageQueue.setScheduler(RuntimeEnvironment.getMasterScheduler());
     } else {
       shadowMessageQueue.setScheduler(new Scheduler());
@@ -337,4 +334,8 @@ public class ShadowLegacyLooper extends ShadowLooper {
   private static ShadowMessageQueue shadowOf(MessageQueue mq) {
     return Shadow.extract(mq);
   }
+
+  private static boolean useGlobalScheduler() {
+    return Boolean.getBoolean("robolectric.scheduling.global");
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMatrix.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMatrix.java
index d9bdd6d92..ef61818a5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMatrix.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMatrix.java
@@ -198,7 +198,7 @@ public class ShadowLegacyMatrix extends ShadowMatrix {
 
   @Implementation
   protected boolean preRotate(float degrees) {
-    preOps.addFirst(ROTATE + " " + Float.toString(degrees));
+    preOps.addFirst(ROTATE + " " + degrees);
     return preConcat(SimpleMatrix.rotate(degrees));
   }
 
@@ -246,7 +246,7 @@ public class ShadowLegacyMatrix extends ShadowMatrix {
 
   @Implementation
   protected boolean postRotate(float degrees) {
-    postOps.addLast(ROTATE + " " + Float.toString(degrees));
+    postOps.addLast(ROTATE + " " + degrees);
     return postConcat(SimpleMatrix.rotate(degrees));
   }
 
@@ -571,9 +571,7 @@ public class ShadowLegacyMatrix extends ShadowMatrix {
                 mValues[2] = mValues[3] = mValues[4] = mValues[5] = mValues[6] = mValues[7] = 0;
         mValues[8] = 1;
       } else {
-        float tx = dst.width() / src.width();
         float sx = dst.width() / src.width();
-        float ty = dst.height() / src.height();
         float sy = dst.height() / src.height();
         boolean xLarger = false;
 
@@ -586,8 +584,8 @@ public class ShadowLegacyMatrix extends ShadowMatrix {
           }
         }
 
-        tx = dst.left - src.left * sx;
-        ty = dst.top - src.top * sy;
+        float tx = dst.left - src.left * sx;
+        float ty = dst.top - src.top * sy;
         if (stf == ScaleToFit.CENTER || stf == ScaleToFit.END) {
           float diff;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessage.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessage.java
index 2ba592787..40452c333 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessage.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessage.java
@@ -15,9 +15,9 @@ import org.robolectric.util.Scheduler;
 import org.robolectric.util.reflector.ForType;
 
 /**
- * The shadow {@link Message} for {@link LooperMode.Mode.LEGACY}.
+ * The shadow {@link Message} for {@link LooperMode.Mode#LEGACY}.
  *
- * <p>In {@link LooperMode.Mode.LEGACY}, each Message is associated with a Runnable posted to the
+ * <p>In {@link LooperMode.Mode#LEGACY}, each Message is associated with a Runnable posted to the
  * {@link Scheduler}.
  *
  * @see ShadowLooper
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessageQueue.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessageQueue.java
index 8adee661b..3c5fe8750 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessageQueue.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessageQueue.java
@@ -23,9 +23,9 @@ import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 
 /**
- * The shadow {@link MessageQueue} for {@link LooperMode.Mode.LEGACY}.
+ * The shadow {@link MessageQueue} for {@link LooperMode.Mode#LEGACY}.
  *
- * <p>In {@link LooperMode.Mode.LEGACY} Robolectric puts {@link android.os.Message}s into the
+ * <p>In {@link LooperMode.Mode#LEGACY} Robolectric puts {@link android.os.Message}s into the
  * scheduler queue instead of sending them to be handled on a separate thread. {@link
  * android.os.Message}s that are scheduled to be dispatched can be triggered by calling {@link
  * ShadowLooper#idleMainLooper}.
@@ -90,32 +90,29 @@ public class ShadowLegacyMessageQueue extends ShadowMessageQueue {
         reflector(MessageQueueReflector.class, realQueue).enqueueMessage(msg, when);
     if (retval) {
       final Runnable callback =
-          new Runnable() {
-            @Override
-            public void run() {
-              synchronized (realQueue) {
-                Message m = getHead();
-                if (m == null) {
-                  return;
-                }
+          () -> {
+            synchronized (realQueue) {
+              Message m = getHead();
+              if (m == null) {
+                return;
+              }
 
-                Message n = shadowOf(m).getNext();
-                if (m == msg) {
-                  setHead(n);
-                } else {
-                  while (n != null) {
-                    if (n == msg) {
-                      n = shadowOf(n).getNext();
-                      shadowOf(m).setNext(n);
-                      break;
-                    }
-                    m = n;
-                    n = shadowOf(m).getNext();
+              Message n = shadowOf(m).getNext();
+              if (m == msg) {
+                setHead(n);
+              } else {
+                while (n != null) {
+                  if (n == msg) {
+                    n = shadowOf(n).getNext();
+                    shadowOf(m).setNext(n);
+                    break;
                   }
+                  m = n;
+                  n = shadowOf(m).getNext();
                 }
               }
-              dispatchMessage(msg);
             }
+            dispatchMessage(msg);
           };
       shadowOf(msg).setScheduledRunnable(callback);
       if (when == 0) {
@@ -155,7 +152,7 @@ public class ShadowLegacyMessageQueue extends ShadowMessageQueue {
   }
 
   private static ShadowLegacyMessage shadowOf(Message actual) {
-    return (ShadowLegacyMessage) Shadow.extract(actual);
+    return Shadow.extract(actual);
   }
 
   /** Reflector interface for {@link MessageQueue}'s internals. */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyPath.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyPath.java
index 5455482f9..a9b873e3c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyPath.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyPath.java
@@ -111,9 +111,9 @@ public class ShadowLegacyPath extends ShadowPath {
   protected float[] approximate(float acceptableError) {
     PathIterator iterator = mPath.getPathIterator(null, acceptableError);
 
-    float segment[] = new float[6];
+    float[] segment = new float[6];
     float totalLength = 0;
-    ArrayList<Point2D.Float> points = new ArrayList<Point2D.Float>();
+    ArrayList<Point2D.Float> points = new ArrayList<>();
     Point2D.Float previousPoint = null;
     while (!iterator.isDone()) {
       int type = iterator.currentSegment(segment);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySQLiteConnection.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySQLiteConnection.java
index cbd81e0d1..ec3ba8aa0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySQLiteConnection.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySQLiteConnection.java
@@ -53,8 +53,8 @@ import org.robolectric.annotation.InDevelopment;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.shadows.util.SQLiteLibraryLoader;
 import org.robolectric.util.PerfStatsCollector;
-import org.robolectric.versioning.AndroidVersions.V;
 import org.robolectric.versioning.AndroidVersions.Baklava;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow for {@link android.database.sqlite.SQLiteConnection} that is backed by sqlite4java. */
 @Implements(value = android.database.sqlite.SQLiteConnection.class, isInAndroidSdk = false)
@@ -104,13 +104,13 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
     CONNECTIONS.reset();
   }
 
-  @Implementation(maxSdk=V.SDK_INT)
+  @Implementation(maxSdk = V.SDK_INT)
   protected static void nativeClose(long connectionPtr) {
     CONNECTIONS.close(connectionPtr);
   }
 
   @InDevelopment
-  @Implementation(minSdk=Baklava.SDK_INT)
+  @Implementation(minSdk = Baklava.SDK_INT)
   protected static void nativeClose(long connectionPtr, boolean fast) {
     CONNECTIONS.close(connectionPtr);
   }
@@ -318,17 +318,14 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
       synchronized (lock) {
         final SQLiteConnection dbConnection =
             execute(
-                new Callable<SQLiteConnection>() {
-                  @Override
-                  public SQLiteConnection call() throws Exception {
-                    SQLiteConnection connection =
-                        useInMemoryDatabase.get() || IN_MEMORY_PATH.equals(path)
-                            ? new SQLiteConnection()
-                            : new SQLiteConnection(new File(path));
-
-                    connection.open();
-                    return connection;
-                  }
+                () -> {
+                  SQLiteConnection connection =
+                      useInMemoryDatabase.get() || IN_MEMORY_PATH.equals(path)
+                          ? new SQLiteConnection()
+                          : new SQLiteConnection(new File(path));
+
+                  connection.open();
+                  return connection;
                 });
 
         final long connectionPtr = pointerCounter.incrementAndGet();
@@ -346,14 +343,7 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
 
       synchronized (lock) {
         final SQLiteConnection connection = getConnection(connectionPtr);
-        final SQLiteStatement statement =
-            execute(
-                new Callable<SQLiteStatement>() {
-                  @Override
-                  public SQLiteStatement call() throws Exception {
-                    return connection.prepare(sql);
-                  }
-                });
+        final SQLiteStatement statement = execute(() -> connection.prepare(sql));
 
         final long statementPtr = pointerCounter.incrementAndGet();
         statementsMap.put(statementPtr, statement);
@@ -436,13 +426,11 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
           final SQLiteStatement statement = statementsMap.get(statementPtr);
           if (statement != null) {
             execute(
-                new Callable<Void>() {
-                  @Override
-                  public Void call() throws Exception {
-                    statement.cancel();
-                    return null;
-                  }
-                });
+                (Callable<Void>)
+                    () -> {
+                      statement.cancel();
+                      return null;
+                    });
           }
         }
       }
@@ -454,14 +442,7 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
       }
 
       return executeStatementOperation(
-          connectionPtr,
-          statementPtr,
-          new StatementOperation<Integer>() {
-            @Override
-            public Integer call(final SQLiteStatement statement) throws Exception {
-              return statement.getBindParameterCount();
-            }
-          });
+          connectionPtr, statementPtr, SQLiteStatement::getBindParameterCount);
     }
 
     boolean isReadOnly(final long connectionPtr, final long statementPtr) {
@@ -469,30 +450,18 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
         return true;
       }
 
-      return executeStatementOperation(
-          connectionPtr,
-          statementPtr,
-          new StatementOperation<Boolean>() {
-            @Override
-            public Boolean call(final SQLiteStatement statement) throws Exception {
-              return statement.isReadOnly();
-            }
-          });
+      return executeStatementOperation(connectionPtr, statementPtr, SQLiteStatement::isReadOnly);
     }
 
     long executeForLong(final long connectionPtr, final long statementPtr) {
       return executeStatementOperation(
           connectionPtr,
           statementPtr,
-          new StatementOperation<Long>() {
-            @Override
-            public Long call(final SQLiteStatement statement) throws Exception {
-              if (!statement.step()) {
-                throw new SQLiteException(
-                    SQLiteConstants.SQLITE_DONE, "No rows returned from query");
-              }
-              return statement.columnLong(0);
+          statement -> {
+            if (!statement.step()) {
+              throw new SQLiteException(SQLiteConstants.SQLITE_DONE, "No rows returned from query");
             }
+            return statement.columnLong(0);
           });
     }
 
@@ -504,66 +473,43 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
       executeStatementOperation(
           connectionPtr,
           statementPtr,
-          new StatementOperation<Void>() {
-            @Override
-            public Void call(final SQLiteStatement statement) throws Exception {
-              statement.stepThrough();
-              return null;
-            }
-          });
+          (StatementOperation<Void>)
+              statement -> {
+                statement.stepThrough();
+                return null;
+              });
     }
 
     String executeForString(final long connectionPtr, final long statementPtr) {
       return executeStatementOperation(
           connectionPtr,
           statementPtr,
-          new StatementOperation<String>() {
-            @Override
-            public String call(final SQLiteStatement statement) throws Exception {
-              if (!statement.step()) {
-                throw new SQLiteException(
-                    SQLiteConstants.SQLITE_DONE, "No rows returned from query");
-              }
-              return statement.columnString(0);
+          statement -> {
+            if (!statement.step()) {
+              throw new SQLiteException(SQLiteConstants.SQLITE_DONE, "No rows returned from query");
             }
+            return statement.columnString(0);
           });
     }
 
     int getColumnCount(final long connectionPtr, final long statementPtr) {
-      return executeStatementOperation(
-          connectionPtr,
-          statementPtr,
-          new StatementOperation<Integer>() {
-            @Override
-            public Integer call(final SQLiteStatement statement) throws Exception {
-              return statement.columnCount();
-            }
-          });
+      return executeStatementOperation(connectionPtr, statementPtr, SQLiteStatement::columnCount);
     }
 
     String getColumnName(final long connectionPtr, final long statementPtr, final int index) {
       return executeStatementOperation(
-          connectionPtr,
-          statementPtr,
-          new StatementOperation<String>() {
-            @Override
-            public String call(final SQLiteStatement statement) throws Exception {
-              return statement.getColumnName(index);
-            }
-          });
+          connectionPtr, statementPtr, statement -> statement.getColumnName(index));
     }
 
     void bindNull(final long connectionPtr, final long statementPtr, final int index) {
       executeStatementOperation(
           connectionPtr,
           statementPtr,
-          new StatementOperation<Void>() {
-            @Override
-            public Void call(final SQLiteStatement statement) throws Exception {
-              statement.bindNull(index);
-              return null;
-            }
-          });
+          (StatementOperation<Void>)
+              statement -> {
+                statement.bindNull(index);
+                return null;
+              });
     }
 
     void bindLong(
@@ -571,13 +517,11 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
       executeStatementOperation(
           connectionPtr,
           statementPtr,
-          new StatementOperation<Void>() {
-            @Override
-            public Void call(final SQLiteStatement statement) throws Exception {
-              statement.bind(index, value);
-              return null;
-            }
-          });
+          (StatementOperation<Void>)
+              statement -> {
+                statement.bind(index, value);
+                return null;
+              });
     }
 
     void bindDouble(
@@ -585,13 +529,11 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
       executeStatementOperation(
           connectionPtr,
           statementPtr,
-          new StatementOperation<Void>() {
-            @Override
-            public Void call(final SQLiteStatement statement) throws Exception {
-              statement.bind(index, value);
-              return null;
-            }
-          });
+          (StatementOperation<Void>)
+              statement -> {
+                statement.bind(index, value);
+                return null;
+              });
     }
 
     void bindString(
@@ -599,13 +541,11 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
       executeStatementOperation(
           connectionPtr,
           statementPtr,
-          new StatementOperation<Void>() {
-            @Override
-            public Void call(final SQLiteStatement statement) throws Exception {
-              statement.bind(index, value);
-              return null;
-            }
-          });
+          (StatementOperation<Void>)
+              statement -> {
+                statement.bind(index, value);
+                return null;
+              });
     }
 
     void bindBlob(
@@ -613,13 +553,11 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
       executeStatementOperation(
           connectionPtr,
           statementPtr,
-          new StatementOperation<Void>() {
-            @Override
-            public Void call(final SQLiteStatement statement) throws Exception {
-              statement.bind(index, value);
-              return null;
-            }
-          });
+          (StatementOperation<Void>)
+              statement -> {
+                statement.bind(index, value);
+                return null;
+              });
     }
 
     int executeForChangedRowCount(final long connectionPtr, final long statementPtr) {
@@ -628,16 +566,13 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
         final SQLiteStatement statement = getStatement(connectionPtr, statementPtr);
 
         return execute(
-            new Callable<Integer>() {
-              @Override
-              public Integer call() throws Exception {
-                if (statement.step()) {
-                  throw new android.database.sqlite.SQLiteException(
-                      "Queries can be performed using SQLiteDatabase query or rawQuery methods"
-                          + " only.");
-                }
-                return connection.getChanges();
+            () -> {
+              if (statement.step()) {
+                throw new android.database.sqlite.SQLiteException(
+                    "Queries can be performed using SQLiteDatabase query or rawQuery methods"
+                        + " only.");
               }
+              return connection.getChanges();
             });
       }
     }
@@ -648,12 +583,9 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
         final SQLiteStatement statement = getStatement(connectionPtr, statementPtr);
 
         return execute(
-            new Callable<Long>() {
-              @Override
-              public Long call() throws Exception {
-                statement.stepThrough();
-                return connection.getChanges() > 0 ? connection.getLastInsertId() : -1L;
-              }
+            () -> {
+              statement.stepThrough();
+              return connection.getChanges() > 0 ? connection.getLastInsertId() : -1L;
             });
       }
     }
@@ -663,25 +595,19 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
       return executeStatementOperation(
           connectionPtr,
           statementPtr,
-          new StatementOperation<Integer>() {
-            @Override
-            public Integer call(final SQLiteStatement statement) throws Exception {
-              return ShadowLegacyCursorWindow.setData(windowPtr, statement);
-            }
-          });
+          (StatementOperation<Integer>)
+              statement -> ShadowLegacyCursorWindow.setData(windowPtr, statement));
     }
 
     void resetStatementAndClearBindings(final long connectionPtr, final long statementPtr) {
       executeStatementOperation(
           connectionPtr,
           statementPtr,
-          new StatementOperation<Void>() {
-            @Override
-            public Void call(final SQLiteStatement statement) throws Exception {
-              statement.reset(true);
-              return null;
-            }
-          });
+          (StatementOperation<Void>)
+              statement -> {
+                statement.reset(true);
+                return null;
+              });
     }
 
     interface StatementOperation<T> {
@@ -694,10 +620,7 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
         final StatementOperation<T> statementOperation) {
       synchronized (lock) {
         final SQLiteStatement statement = getStatement(connectionPtr, statementPtr);
-        return execute(
-            () -> {
-              return statementOperation.call(statement);
-            });
+        return execute(() -> statementOperation.call(statement));
       }
     }
 
@@ -733,106 +656,110 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
     }
 
     // These are from android_database_SQLiteCommon.cpp
-    private static final ImmutableMap<Integer, String> ERROR_CODE_MAP =
-        new ImmutableMap.Builder<Integer, String>()
-            .put(4, "SQLITE_ABORT")
-            .put(23, "SQLITE_AUTH")
-            .put(5, "SQLITE_BUSY")
-            .put(14, "SQLITE_CANTOPEN")
-            .put(19, "SQLITE_CONSTRAINT")
-            .put(11, "SQLITE_CORRUPT")
-            .put(101, "SQLITE_DONE")
-            .put(16, "SQLITE_EMPTY")
-            .put(1, "SQLITE_ERROR")
-            .put(24, "SQLITE_FORMAT")
-            .put(13, "SQLITE_FULL")
-            .put(2, "SQLITE_INTERNAL")
-            .put(9, "SQLITE_INTERRUPT")
-            .put(10, "SQLITE_IOERR")
-            .put(6, "SQLITE_LOCKED")
-            .put(20, "SQLITE_MISMATCH")
-            .put(21, "SQLITE_MISUSE")
-            .put(22, "SQLITE_NOLFS")
-            .put(7, "SQLITE_NOMEM")
-            .put(26, "SQLITE_NOTADB")
-            .put(12, "SQLITE_NOTFOUND")
-            .put(27, "SQLITE_NOTICE")
-            .put(0, "SQLITE_OK")
-            .put(3, "SQLITE_PERM")
-            .put(15, "SQLITE_PROTOCOL")
-            .put(25, "SQLITE_RANGE")
-            .put(8, "SQLITE_READONLY")
-            .put(100, "SQLITE_ROW")
-            .put(17, "SQLITE_SCHEMA")
-            .put(18, "SQLITE_TOOBIG")
-            .put(28, "SQLITE_WARNING")
-            // Extended Result Code List
-            .put(516, "SQLITE_ABORT_ROLLBACK")
-            .put(261, "SQLITE_BUSY_RECOVERY")
-            .put(517, "SQLITE_BUSY_SNAPSHOT")
-            .put(1038, "SQLITE_CANTOPEN_CONVPATH")
-            .put(782, "SQLITE_CANTOPEN_FULLPATH")
-            .put(526, "SQLITE_CANTOPEN_ISDIR")
-            .put(270, "SQLITE_CANTOPEN_NOTEMPDIR")
-            .put(275, "SQLITE_CONSTRAINT_CHECK")
-            .put(531, "SQLITE_CONSTRAINT_COMMITHOOK")
-            .put(787, "SQLITE_CONSTRAINT_FOREIGNKEY")
-            .put(1043, "SQLITE_CONSTRAINT_FUNCTION")
-            .put(1299, "SQLITE_CONSTRAINT_NOTNULL")
-            .put(1555, "SQLITE_CONSTRAINT_PRIMARYKEY")
-            .put(2579, "SQLITE_CONSTRAINT_ROWID")
-            .put(1811, "SQLITE_CONSTRAINT_TRIGGER")
-            .put(2067, "SQLITE_CONSTRAINT_UNIQUE")
-            .put(2323, "SQLITE_CONSTRAINT_VTAB")
-            .put(267, "SQLITE_CORRUPT_VTAB")
-            .put(3338, "SQLITE_IOERR_ACCESS")
-            .put(2826, "SQLITE_IOERR_BLOCKED")
-            .put(3594, "SQLITE_IOERR_CHECKRESERVEDLOCK")
-            .put(4106, "SQLITE_IOERR_CLOSE")
-            .put(6666, "SQLITE_IOERR_CONVPATH")
-            .put(2570, "SQLITE_IOERR_DELETE")
-            .put(5898, "SQLITE_IOERR_DELETE_NOENT")
-            .put(4362, "SQLITE_IOERR_DIR_CLOSE")
-            .put(1290, "SQLITE_IOERR_DIR_FSYNC")
-            .put(1802, "SQLITE_IOERR_FSTAT")
-            .put(1034, "SQLITE_IOERR_FSYNC")
-            .put(6410, "SQLITE_IOERR_GETTEMPPATH")
-            .put(3850, "SQLITE_IOERR_LOCK")
-            .put(6154, "SQLITE_IOERR_MMAP")
-            .put(3082, "SQLITE_IOERR_NOMEM")
-            .put(2314, "SQLITE_IOERR_RDLOCK")
-            .put(266, "SQLITE_IOERR_READ")
-            .put(5642, "SQLITE_IOERR_SEEK")
-            .put(5130, "SQLITE_IOERR_SHMLOCK")
-            .put(5386, "SQLITE_IOERR_SHMMAP")
-            .put(4618, "SQLITE_IOERR_SHMOPEN")
-            .put(4874, "SQLITE_IOERR_SHMSIZE")
-            .put(522, "SQLITE_IOERR_SHORT_READ")
-            .put(1546, "SQLITE_IOERR_TRUNCATE")
-            .put(2058, "SQLITE_IOERR_UNLOCK")
-            .put(778, "SQLITE_IOERR_WRITE")
-            .put(262, "SQLITE_LOCKED_SHAREDCACHE")
-            .put(539, "SQLITE_NOTICE_RECOVER_ROLLBACK")
-            .put(283, "SQLITE_NOTICE_RECOVER_WAL")
-            .put(256, "SQLITE_OK_LOAD_PERMANENTLY")
-            .put(520, "SQLITE_READONLY_CANTLOCK")
-            .put(1032, "SQLITE_READONLY_DBMOVED")
-            .put(264, "SQLITE_READONLY_RECOVERY")
-            .put(776, "SQLITE_READONLY_ROLLBACK")
-            .put(284, "SQLITE_WARNING_AUTOINDEX")
-            .build();
+    private static final ImmutableMap<Integer, String> ERROR_CODE_MAP;
+
+    static {
+      Map<Integer, String> errorCodeMap = new HashMap<>();
+      errorCodeMap.put(4, "SQLITE_ABORT");
+      errorCodeMap.put(23, "SQLITE_AUTH");
+      errorCodeMap.put(5, "SQLITE_BUSY");
+      errorCodeMap.put(14, "SQLITE_CANTOPEN");
+      errorCodeMap.put(19, "SQLITE_CONSTRAINT");
+      errorCodeMap.put(11, "SQLITE_CORRUPT");
+      errorCodeMap.put(101, "SQLITE_DONE");
+      errorCodeMap.put(16, "SQLITE_EMPTY");
+      errorCodeMap.put(1, "SQLITE_ERROR");
+      errorCodeMap.put(24, "SQLITE_FORMAT");
+      errorCodeMap.put(13, "SQLITE_FULL");
+      errorCodeMap.put(2, "SQLITE_INTERNAL");
+      errorCodeMap.put(9, "SQLITE_INTERRUPT");
+      errorCodeMap.put(10, "SQLITE_IOERR");
+      errorCodeMap.put(6, "SQLITE_LOCKED");
+      errorCodeMap.put(20, "SQLITE_MISMATCH");
+      errorCodeMap.put(21, "SQLITE_MISUSE");
+      errorCodeMap.put(22, "SQLITE_NOLFS");
+      errorCodeMap.put(7, "SQLITE_NOMEM");
+      errorCodeMap.put(26, "SQLITE_NOTADB");
+      errorCodeMap.put(12, "SQLITE_NOTFOUND");
+      errorCodeMap.put(27, "SQLITE_NOTICE");
+      errorCodeMap.put(0, "SQLITE_OK");
+      errorCodeMap.put(3, "SQLITE_PERM");
+      errorCodeMap.put(15, "SQLITE_PROTOCOL");
+      errorCodeMap.put(25, "SQLITE_RANGE");
+      errorCodeMap.put(8, "SQLITE_READONLY");
+      errorCodeMap.put(100, "SQLITE_ROW");
+      errorCodeMap.put(17, "SQLITE_SCHEMA");
+      errorCodeMap.put(18, "SQLITE_TOOBIG");
+      errorCodeMap.put(28, "SQLITE_WARNING");
+      // Extended Result Code List
+      errorCodeMap.put(516, "SQLITE_ABORT_ROLLBACK");
+      errorCodeMap.put(261, "SQLITE_BUSY_RECOVERY");
+      errorCodeMap.put(517, "SQLITE_BUSY_SNAPSHOT");
+      errorCodeMap.put(1038, "SQLITE_CANTOPEN_CONVPATH");
+      errorCodeMap.put(782, "SQLITE_CANTOPEN_FULLPATH");
+      errorCodeMap.put(526, "SQLITE_CANTOPEN_ISDIR");
+      errorCodeMap.put(270, "SQLITE_CANTOPEN_NOTEMPDIR");
+      errorCodeMap.put(275, "SQLITE_CONSTRAINT_CHECK");
+      errorCodeMap.put(531, "SQLITE_CONSTRAINT_COMMITHOOK");
+      errorCodeMap.put(787, "SQLITE_CONSTRAINT_FOREIGNKEY");
+      errorCodeMap.put(1043, "SQLITE_CONSTRAINT_FUNCTION");
+      errorCodeMap.put(1299, "SQLITE_CONSTRAINT_NOTNULL");
+      errorCodeMap.put(1555, "SQLITE_CONSTRAINT_PRIMARYKEY");
+      errorCodeMap.put(2579, "SQLITE_CONSTRAINT_ROWID");
+      errorCodeMap.put(1811, "SQLITE_CONSTRAINT_TRIGGER");
+      errorCodeMap.put(2067, "SQLITE_CONSTRAINT_UNIQUE");
+      errorCodeMap.put(2323, "SQLITE_CONSTRAINT_VTAB");
+      errorCodeMap.put(267, "SQLITE_CORRUPT_VTAB");
+      errorCodeMap.put(3338, "SQLITE_IOERR_ACCESS");
+      errorCodeMap.put(2826, "SQLITE_IOERR_BLOCKED");
+      errorCodeMap.put(3594, "SQLITE_IOERR_CHECKRESERVEDLOCK");
+      errorCodeMap.put(4106, "SQLITE_IOERR_CLOSE");
+      errorCodeMap.put(6666, "SQLITE_IOERR_CONVPATH");
+      errorCodeMap.put(2570, "SQLITE_IOERR_DELETE");
+      errorCodeMap.put(5898, "SQLITE_IOERR_DELETE_NOENT");
+      errorCodeMap.put(4362, "SQLITE_IOERR_DIR_CLOSE");
+      errorCodeMap.put(1290, "SQLITE_IOERR_DIR_FSYNC");
+      errorCodeMap.put(1802, "SQLITE_IOERR_FSTAT");
+      errorCodeMap.put(1034, "SQLITE_IOERR_FSYNC");
+      errorCodeMap.put(6410, "SQLITE_IOERR_GETTEMPPATH");
+      errorCodeMap.put(3850, "SQLITE_IOERR_LOCK");
+      errorCodeMap.put(6154, "SQLITE_IOERR_MMAP");
+      errorCodeMap.put(3082, "SQLITE_IOERR_NOMEM");
+      errorCodeMap.put(2314, "SQLITE_IOERR_RDLOCK");
+      errorCodeMap.put(266, "SQLITE_IOERR_READ");
+      errorCodeMap.put(5642, "SQLITE_IOERR_SEEK");
+      errorCodeMap.put(5130, "SQLITE_IOERR_SHMLOCK");
+      errorCodeMap.put(5386, "SQLITE_IOERR_SHMMAP");
+      errorCodeMap.put(4618, "SQLITE_IOERR_SHMOPEN");
+      errorCodeMap.put(4874, "SQLITE_IOERR_SHMSIZE");
+      errorCodeMap.put(522, "SQLITE_IOERR_SHORT_READ");
+      errorCodeMap.put(1546, "SQLITE_IOERR_TRUNCATE");
+      errorCodeMap.put(2058, "SQLITE_IOERR_UNLOCK");
+      errorCodeMap.put(778, "SQLITE_IOERR_WRITE");
+      errorCodeMap.put(262, "SQLITE_LOCKED_SHAREDCACHE");
+      errorCodeMap.put(539, "SQLITE_NOTICE_RECOVER_ROLLBACK");
+      errorCodeMap.put(283, "SQLITE_NOTICE_RECOVER_WAL");
+      errorCodeMap.put(256, "SQLITE_OK_LOAD_PERMANENTLY");
+      errorCodeMap.put(520, "SQLITE_READONLY_CANTLOCK");
+      errorCodeMap.put(1032, "SQLITE_READONLY_DBMOVED");
+      errorCodeMap.put(264, "SQLITE_READONLY_RECOVERY");
+      errorCodeMap.put(776, "SQLITE_READONLY_ROLLBACK");
+      errorCodeMap.put(284, "SQLITE_WARNING_AUTOINDEX");
+
+      ERROR_CODE_MAP = ImmutableMap.copyOf(errorCodeMap);
+    }
 
     private static RuntimeException getSqliteException(
         final String sqliteErrorMessage, final int errorCode) {
       final int baseErrorCode = errorCode & 0xff;
       // Remove redundant error code prefix from sqlite4java. The error code is added
       // as a suffix below.
-      String errorMessageWithoutCode = sqliteErrorMessage.replaceAll("^\\[\\d+\\] ?", "");
+      String errorMessageWithoutCode = sqliteErrorMessage.replaceAll("^\\[\\d+] ?", "");
       StringBuilder fullMessage = new StringBuilder(errorMessageWithoutCode);
       fullMessage.append(" (code ");
       fullMessage.append(errorCode);
       String errorCodeMessage = ERROR_CODE_MAP.getOrDefault(errorCode, "");
-      if (MoreObjects.firstNonNull(errorCodeMessage, "").length() > 0) {
+      if (!MoreObjects.firstNonNull(errorCodeMessage, "").isEmpty()) {
         fullMessage.append(" ").append(errorCodeMessage);
       }
       fullMessage.append(")");
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySystemClock.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySystemClock.java
index 319b89586..7e7673597 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySystemClock.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySystemClock.java
@@ -9,10 +9,11 @@ import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.Resetter;
 
 /**
- * A shadow SystemClock for {@link LooperMode.Mode.LEGACY}
+ * A shadow SystemClock for {@link LooperMode.Mode#LEGACY}
  *
  * <p>In LEGACY LooperMode, Robolectric's concept of current time is base on the current time of the
  * UI Scheduler for consistency with previous implementations. This is not ideal, since both
@@ -24,7 +25,7 @@ import org.robolectric.annotation.Resetter;
     // turn off shadowOf generation
     isInAndroidSdk = false)
 public class ShadowLegacySystemClock extends ShadowSystemClock {
-  private static long bootedAt = 0;
+  private static final long bootedAt = 0;
   private static long nanoTime = 0;
   private static final int MILLIS_PER_NANO = 1000000;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleData.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleData.java
index 2dc49ff3d..c537984ab 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleData.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleData.java
@@ -23,9 +23,6 @@ public class ShadowLocaleData {
   @Implementation
   public static LocaleData get(Locale locale) {
     LocaleData localeData = (LocaleData) Shadow.newInstanceOf(REAL_CLASS_NAME);
-    if (locale == null) {
-      locale = Locale.getDefault();
-    }
     setEnUsLocaleData(localeData);
     return localeData;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleManager.java
index 73569da5b..4ce129ce8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleManager.java
@@ -59,7 +59,8 @@ public class ShadowLocaleManager {
    *
    * <p>Starting in Android U, this method just invokes the 3-arg version (below).
    *
-   * <p>Use this method in tests to substitute call for {@link LocaleManager#setApplicationLocales}.
+   * <p>Use this method in tests to substitute call for {@link
+   * LocaleManager#setApplicationLocales(LocaleList)}.
    */
   @Implementation(maxSdk = VERSION_CODES.TIRAMISU)
   protected void setApplicationLocales(String packageName, LocaleList locales) {
@@ -69,7 +70,8 @@ public class ShadowLocaleManager {
   /**
    * Stores the passed locales for the given package in-memory.
    *
-   * <p>Use this method in tests to substitute call for {@link LocaleManager#setApplicationLocales}.
+   * <p>Use this method in tests to substitute call for {@link
+   * LocaleManager#setApplicationLocales(LocaleList)}.
    */
   @Implementation(minSdk = U.SDK_INT)
   protected void setApplicationLocales(
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java
index 9c9e39574..38239b2fd 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java
@@ -55,6 +55,7 @@ import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.function.Consumer;
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
@@ -275,10 +276,7 @@ public class ShadowLocationManager {
       if (criteria.isBearingRequired() && !hasBearingSupport()) {
         return false;
       }
-      if (!criteria.isCostAllowed() && hasMonetaryCost) {
-        return false;
-      }
-      return true;
+      return criteria.isCostAllowed() || !hasMonetaryCost;
     }
   }
 
@@ -1309,8 +1307,8 @@ public class ShadowLocationManager {
   }
 
   /**
-   * A convenience function equivalent to invoking {@link #simulateLocation(String, Location)} with
-   * the provider of the given location.
+   * A convenience function equivalent to invoking {@link #simulateLocation(Location)} with the
+   * provider of the given location.
    */
   public void simulateLocation(Location location) {
     simulateLocation(location.getProvider(), location);
@@ -2257,10 +2255,10 @@ public class ShadowLocationManager {
     public void onStatusChanged(String provider, int status, Bundle extras) {}
 
     @Override
-    public void onProviderEnabled(String provider) {}
+    public void onProviderEnabled(@Nonnull String provider) {}
 
     @Override
-    public void onProviderDisabled(String provider) {
+    public void onProviderDisabled(@Nonnull String provider) {
       onLocationChanged((Location) null);
     }
 
@@ -2396,7 +2394,7 @@ public class ShadowLocationManager {
     }
 
     @Override
-    public void execute(Runnable command) {
+    public void execute(@Nonnull Runnable command) {
       if (!handler.post(command)) {
         throw new RejectedExecutionException(handler + " is shutting down");
       }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLog.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLog.java
index a27c6890a..5dbdb2066 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLog.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLog.java
@@ -14,6 +14,7 @@ import java.io.PrintStream;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Queue;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.function.Supplier;
@@ -36,10 +37,10 @@ public class ShadowLog {
   private static final int EXTRA_LOG_LENGTH = "l/: \n".length();
 
   private static final Map<String, Queue<LogItem>> logsByTag =
-      Collections.synchronizedMap(new HashMap<String, Queue<LogItem>>());
+      Collections.synchronizedMap(new HashMap<>());
   private static final Queue<LogItem> logs = new ConcurrentLinkedQueue<>();
   private static final Map<String, Integer> tagToLevel =
-      Collections.synchronizedMap(new HashMap<String, Integer>());
+      Collections.synchronizedMap(new HashMap<>());
 
   /**
    * Whether calling {@link Log#wtf} will throw {@link TerribleFailure}. This is analogous to
@@ -227,7 +228,7 @@ public class ShadowLog {
       PrintStream ps, String timeString, int level, String tag, String msg, Throwable throwable) {
 
     String outputString;
-    if (timeString != null && timeString.length() > 0) {
+    if (timeString != null && !timeString.isEmpty()) {
       outputString = timeString + " " + levelToChar(level) + "/" + tag + ": " + msg;
     } else {
       outputString = levelToChar(level) + "/" + tag + ": " + msg;
@@ -286,14 +287,7 @@ public class ShadowLog {
         try {
           final PrintStream file = new PrintStream(new FileOutputStream(logging), true);
           stream = file;
-          Runtime.getRuntime()
-              .addShutdownHook(
-                  new Thread() {
-                    @Override
-                    public void run() {
-                      file.close();
-                    }
-                  });
+          Runtime.getRuntime().addShutdownHook(new Thread(file::close));
         } catch (IOException e) {
           e.printStackTrace();
         }
@@ -337,10 +331,10 @@ public class ShadowLog {
 
       LogItem log = (LogItem) o;
       return type == log.type
-          && !(timeString != null ? !timeString.equals(log.timeString) : log.timeString != null)
-          && !(msg != null ? !msg.equals(log.msg) : log.msg != null)
-          && !(tag != null ? !tag.equals(log.tag) : log.tag != null)
-          && !(throwable != null ? !throwable.equals(log.throwable) : log.throwable != null);
+          && Objects.equals(timeString, log.timeString)
+          && Objects.equals(msg, log.msg)
+          && Objects.equals(tag, log.tag)
+          && Objects.equals(throwable, log.throwable);
     }
 
     @Override
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLooper.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLooper.java
index dde258635..9655ecc11 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLooper.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLooper.java
@@ -102,7 +102,7 @@ public abstract class ShadowLooper {
    * Pauses execution of tasks posted to the ShadowLegacyLooper. This means that during tests, tasks
    * sent to the looper will not execute immediately, but will be queued in a way that is similar to
    * how a real looper works. These queued tasks must be executed explicitly by calling {@link
-   * #runToEndOftasks} or a similar method, otherwise they will not run at all before your test
+   * #runToEndOfTasks()} or a similar method, otherwise they will not run at all before your test
    * ends.
    *
    * @param looper the looper to pause
@@ -226,7 +226,7 @@ public abstract class ShadowLooper {
   /** Returns true if there are no pending tasks scheduled to be executed before current time. */
   public abstract boolean isIdle();
 
-  /** Not supported for the main Looper in {@link LooperMode.Mode.PAUSED}. */
+  /** Not supported for the main Looper in {@link LooperMode.Mode#PAUSED}. */
   public abstract void unPause();
 
   public abstract boolean isPaused();
@@ -234,11 +234,11 @@ public abstract class ShadowLooper {
   /**
    * Control the paused state of the Looper.
    *
-   * <p>Not supported for the main Looper in {@link LooperMode.Mode.PAUSED}.
+   * <p>Not supported for the main Looper in {@link LooperMode.Mode#PAUSED}.
    */
   public abstract boolean setPaused(boolean shouldPause);
 
-  /** Only supported for {@link LooperMode.Mode.LEGACY}. */
+  /** Only supported for {@link LooperMode.Mode#LEGACY}. */
   public abstract void resetScheduler();
 
   /** Causes all enqueued tasks to be discarded, and pause state to be reset */
@@ -248,7 +248,7 @@ public abstract class ShadowLooper {
    * Returns the {@link org.robolectric.util.Scheduler} that is being used to manage the enqueued
    * tasks. This scheduler is managed by the Looper's associated queue.
    *
-   * <p>Only supported for {@link LooperMode.Mode.LEGACY}.
+   * <p>Only supported for {@link LooperMode.Mode#LEGACY}.
    *
    * @return the {@link org.robolectric.util.Scheduler} that is being used to manage the enqueued
    *     tasks.
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaActionSound.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaActionSound.java
index 4af14e8b1..788ed194f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaActionSound.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaActionSound.java
@@ -31,7 +31,7 @@ public class ShadowMediaActionSound {
   @SuppressWarnings("NonFinalStaticField")
   private static boolean mustPlayShutterSoundInternal = false;
 
-  private static final HashMap<Integer, AtomicInteger> initializePlayCountMap() {
+  private static HashMap<Integer, AtomicInteger> initializePlayCountMap() {
     HashMap<Integer, AtomicInteger> playCount = new HashMap<>();
     for (int sound : ALL_SOUNDS) {
       playCount.put(sound, new AtomicInteger(0));
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java
index ca8f4d56c..5a1275653 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java
@@ -315,15 +315,15 @@ public class ShadowMediaCodec {
           /* errorCode= */ 0, /* actionCode= */ 0, "Input buffer not owned by client: " + index);
     }
 
+    inputBuffersPendingQueuing.remove(Integer.valueOf(index));
+
     if (VERSION.SDK_INT >= 34 && (flags & MediaCodec.BUFFER_FLAG_DECODE_ONLY) != 0) {
-      inputBuffersPendingQueuing.remove(Integer.valueOf(index));
       makeInputBufferAvailable(index);
     } else {
       BufferInfo info = new BufferInfo();
       info.set(offset, size, presentationTimeUs, flags);
 
       makeOutputBufferAvailable(index, info);
-      inputBuffersPendingQueuing.remove(Integer.valueOf(index));
     }
   }
 
@@ -417,8 +417,8 @@ public class ShadowMediaCodec {
     outputBuffersPendingDequeue.add(index);
 
     if (isAsync) {
-      // Dequeue the buffer to signal its availablility to the client.
-      outputBuffersPendingDequeue.remove(Integer.valueOf(index));
+      // Dequeue the buffer to signal its availability to the client.
+      outputBuffersPendingDequeue.remove(index);
       // Signal output buffer availability.
       postFakeNativeEvent(EVENT_CALLBACK, CB_OUTPUT_AVAILABLE, index, outputBufferInfos[index]);
     }
@@ -473,7 +473,7 @@ public class ShadowMediaCodec {
   protected void validateOutputByteBuffer(
       @Nullable ByteBuffer[] buffers, int index, @Nonnull BufferInfo info) {
     if (buffers != null && index >= 0 && index < buffers.length) {
-      Buffer buffer = (Buffer) buffers[index];
+      Buffer buffer = buffers[index];
       if (buffer != null) {
         buffer.limit(info.offset + info.size).position(info.offset);
       }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodecList.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodecList.java
index ad3634c81..4aae77731 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodecList.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodecList.java
@@ -3,7 +3,7 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.Q;
 
-import android.annotation.TargetApi;
+import android.annotation.RequiresApi;
 import android.media.MediaCodecInfo;
 import android.media.MediaCodecList;
 import java.util.ArrayList;
@@ -34,7 +34,7 @@ public class ShadowMediaCodecList {
    * @param mediaCodecInfo {@link MediaCodecInfo} describing the codec. Use {@link
    *     MediaCodecInfoBuilder} to create an instance of it.
    */
-  @TargetApi(Q)
+  @RequiresApi(Q)
   public static void addCodec(MediaCodecInfo mediaCodecInfo) {
     mediaCodecInfos.add(mediaCodecInfo);
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaExtractor.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaExtractor.java
index 433045ee3..9d10b3cef 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaExtractor.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaExtractor.java
@@ -38,7 +38,7 @@ import org.robolectric.shadows.util.DataSource;
  *       last call to {@link #readSampleData(ByteBuffer, int)}).
  *   <li>{@link MediaExtractor#getSampleTime()} and {@link MediaExtractor#getSampleSize()} are
  *       unimplemented.
- *   <li>{@link MediaExtractor#seekTo()} is unimplemented.
+ *   <li>{@link MediaExtractor#seekTo(long, int)} is unimplemented.
  * </ul>
  */
 @Implements(MediaExtractor.class)
@@ -69,7 +69,7 @@ public class ShadowMediaExtractor {
     TrackInfo trackInfo = new TrackInfo();
     trackInfo.format = format;
     trackInfo.sampleData = sampleData;
-    tracksMap.putIfAbsent(dataSource, new ArrayList<TrackInfo>());
+    tracksMap.putIfAbsent(dataSource, new ArrayList<>());
     List<TrackInfo> tracks = tracksMap.get(dataSource);
     tracks.add(trackInfo);
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMetadataRetriever.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMetadataRetriever.java
index 2110a47cf..05aec75a9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMetadataRetriever.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMetadataRetriever.java
@@ -104,7 +104,7 @@ public class ShadowMediaMetadataRetriever {
 
   public static void addMetadata(DataSource ds, int keyCode, String value) {
     if (!metadata.containsKey(ds)) {
-      metadata.put(ds, new HashMap<Integer, String>());
+      metadata.put(ds, new HashMap<>());
     }
     metadata.get(ds).put(keyCode, value);
   }
@@ -126,7 +126,7 @@ public class ShadowMediaMetadataRetriever {
 
   public static void addFrame(DataSource ds, long time, Bitmap bitmap) {
     if (!frames.containsKey(ds)) {
-      frames.put(ds, new HashMap<Long, Bitmap>());
+      frames.put(ds, new HashMap<>());
     }
     frames.get(ds).put(time, bitmap);
   }
@@ -134,7 +134,7 @@ public class ShadowMediaMetadataRetriever {
   public static void addScaledFrame(
       DataSource ds, long time, int dstWidth, int dstHeight, Bitmap bitmap) {
     if (!scaledFrames.containsKey(ds)) {
-      scaledFrames.put(ds, new HashMap<String, Bitmap>());
+      scaledFrames.put(ds, new HashMap<>());
     }
     scaledFrames.get(ds).put(getScaledFrameKey(time, dstWidth, dstHeight), bitmap);
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java
index f7be05333..428a10c80 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java
@@ -162,7 +162,6 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
    * Class for grouping events that are meant to fire at the same time. Also schedules the next
    * event to run.
    */
-  @SuppressWarnings("serial")
   private static class RunList extends ArrayList<MediaEvent> implements MediaEvent {
 
     public RunList() {
@@ -180,7 +179,7 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
   }
 
   public interface MediaEvent {
-    public void run(MediaPlayer mp, ShadowMediaPlayer smp);
+    void run(MediaPlayer mp, ShadowMediaPlayer smp);
   }
 
   /**
@@ -286,13 +285,7 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
      * @return A reference to the MediaEvent object that was created and scheduled.
      */
     public MediaEvent scheduleInfoAtOffset(int offset, final int what, final int extra) {
-      MediaEvent callback =
-          new MediaEvent() {
-            @Override
-            public void run(MediaPlayer mp, ShadowMediaPlayer smp) {
-              smp.invokeInfoListener(what, extra);
-            }
-          };
+      MediaEvent callback = (mp, smp) -> smp.invokeInfoListener(what, extra);
       scheduleEventAtOffset(offset, callback);
       return callback;
     }
@@ -314,21 +307,15 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
      */
     public MediaEvent scheduleBufferUnderrunAtOffset(int offset, final int length) {
       final MediaEvent restart =
-          new MediaEvent() {
-            @Override
-            public void run(MediaPlayer mp, ShadowMediaPlayer smp) {
-              smp.invokeInfoListener(MediaPlayer.MEDIA_INFO_BUFFERING_END, 0);
-              smp.doStart();
-            }
+          (mp, smp) -> {
+            smp.invokeInfoListener(MediaPlayer.MEDIA_INFO_BUFFERING_END, 0);
+            smp.doStart();
           };
       MediaEvent callback =
-          new MediaEvent() {
-            @Override
-            public void run(MediaPlayer mp, ShadowMediaPlayer smp) {
-              smp.doStop();
-              smp.invokeInfoListener(MediaPlayer.MEDIA_INFO_BUFFERING_START, 0);
-              smp.postEventDelayed(restart, length);
-            }
+          (mp, smp) -> {
+            smp.doStop();
+            smp.invokeInfoListener(MediaPlayer.MEDIA_INFO_BUFFERING_START, 0);
+            smp.postEventDelayed(restart, length);
           };
       scheduleEventAtOffset(offset, callback);
       return callback;
@@ -387,7 +374,7 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
    *
    * @see #setCreateListener
    */
-  public static interface CreateListener {
+  public interface CreateListener {
     /**
      * Method that is invoked when a new {@link MediaPlayer} is created. This method is invoked at
      * the end of the constructor, after all of the default setup has been completed.
@@ -396,7 +383,7 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
      * @param shadow reference to the corresponding shadow object for the newly-created media player
      *     (provided for convenience).
      */
-    public void onCreate(MediaPlayer player, ShadowMediaPlayer shadow);
+    void onCreate(MediaPlayer player, ShadowMediaPlayer shadow);
   }
 
   /** Current state of the media player. */
@@ -453,34 +440,20 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
   private Handler handler;
 
   private static final MediaEvent completionCallback =
-      new MediaEvent() {
-        @Override
-        public void run(MediaPlayer mp, ShadowMediaPlayer smp) {
-          if (mp.isLooping()) {
-            smp.startOffset = 0;
-            smp.doStart();
-          } else {
-            smp.doStop();
-            smp.invokeCompletionListener();
-          }
+      (mp, smp) -> {
+        if (mp.isLooping()) {
+          smp.startOffset = 0;
+          smp.doStart();
+        } else {
+          smp.doStop();
+          smp.invokeCompletionListener();
         }
       };
 
-  private static final MediaEvent preparedCallback =
-      new MediaEvent() {
-        @Override
-        public void run(MediaPlayer mp, ShadowMediaPlayer smp) {
-          smp.invokePreparedListener();
-        }
-      };
+  private static final MediaEvent preparedCallback = (mp, smp) -> smp.invokePreparedListener();
 
   private static final MediaEvent seekCompleteCallback =
-      new MediaEvent() {
-        @Override
-        public void run(MediaPlayer mp, ShadowMediaPlayer smp) {
-          smp.invokeSeekCompleteListener();
-        }
-      };
+      (mp, smp) -> smp.invokeSeekCompleteListener();
 
   /**
    * Callback to use when a method is invoked from an invalid state. Has {@code what = -38} and
@@ -492,8 +465,8 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
 
   /** Callback to use for scheduled errors. */
   private static class ErrorCallback implements MediaEvent {
-    private int what;
-    private int extra;
+    private final int what;
+    private final int extra;
 
     public ErrorCallback(int what, int extra) {
       this.what = what;
@@ -590,7 +563,7 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
   private Handler getHandler(Looper looper) {
     return new Handler(looper) {
       @Override
-      public void handleMessage(Message msg) {
+      public void handleMessage(@Nonnull Message msg) {
         switch (msg.what) {
           case MEDIA_EVENT:
             MediaEvent e = (MediaEvent) msg.obj;
@@ -881,7 +854,7 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
     return state == STARTED;
   }
 
-  private static EnumSet<State> preparableStates = EnumSet.of(INITIALIZED, STOPPED);
+  private static final EnumSet<State> preparableStates = EnumSet.of(INITIALIZED, STOPPED);
 
   /**
    * Simulates {@link MediaPlayer#prepareAsync()}. Sleeps for {@link MediaInfo#getPreparationDelay()
@@ -928,7 +901,7 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
     }
   }
 
-  private static EnumSet<State> startableStates =
+  private static final EnumSet<State> startableStates =
       EnumSet.of(PREPARED, STARTED, PAUSED, PLAYBACK_COMPLETED);
 
   /**
@@ -1488,7 +1461,7 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
     return true;
   }
 
-  private static EnumSet<State> preparedStates =
+  private static final EnumSet<State> preparedStates =
       EnumSet.of(PREPARED, STARTED, PAUSED, PLAYBACK_COMPLETED);
 
   /**
@@ -1543,7 +1516,7 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
   /** Allows test cases to simulate seek completion by invoking callback. */
   public void invokeSeekCompleteListener() {
     int duration = getMediaInfo().duration;
-    setCurrentPosition(pendingSeek > duration ? duration : pendingSeek < 0 ? 0 : pendingSeek);
+    setCurrentPosition(pendingSeek > duration ? duration : Math.max(pendingSeek, 0));
     pendingSeek = -1;
     if (state == STARTED) {
       doStart();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMemoryMappedFile.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMemoryMappedFile.java
index a8f824c29..57cba7bcf 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMemoryMappedFile.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMemoryMappedFile.java
@@ -29,8 +29,7 @@ public class ShadowMemoryMappedFile {
     if (path.endsWith(TZ_DATA_1) || path.endsWith(TZ_DATA_2) || path.endsWith(TZ_DATA_3)) {
       InputStream is = MemoryMappedFile.class.getResourceAsStream(TZ_DATA_2);
       if (is == null) {
-        throw (Throwable)
-            ErrnoException.class.getConstructor(String.class, int.class).newInstance("open", -1);
+        throw ErrnoException.class.getConstructor(String.class, int.class).newInstance("open", -1);
       }
       try {
         MemoryMappedFile memoryMappedFile = new MemoryMappedFile(0L, 0L);
@@ -38,10 +37,9 @@ public class ShadowMemoryMappedFile {
         shadowMemoryMappedFile.bytes = Streams.readFully(is);
         return memoryMappedFile;
       } catch (IOException e) {
-        throw (Throwable)
-            ErrnoException.class
-                .getConstructor(String.class, int.class, Throwable.class)
-                .newInstance("mmap", -1, e);
+        throw ErrnoException.class
+            .getConstructor(String.class, int.class, Throwable.class)
+            .newInstance("mmap", -1, e);
       }
     } else {
       throw new IllegalArgumentException("Unknown file for mmap: '" + path);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMessage.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMessage.java
index ac63bd91b..2646eb5d9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMessage.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMessage.java
@@ -40,14 +40,14 @@ public abstract class ShadowMessage {
    *
    * @param r the {@link Runnable} instance that is scheduled to trigger this message.
    *     <p>#if ($api >= 21) * @see #recycleUnchecked() #else * @see #recycle() #end
-   *     <p>Only supported in {@link LooperMode.Mode.LEGACY}.
+   *     <p>Only supported in {@link LooperMode.Mode#LEGACY}.
    */
   public abstract void setScheduledRunnable(Runnable r);
 
   /**
    * Convenience method to provide getter access to the private field {@code Message.next}.
    *
-   * <p>Only supported in {@link LooperMode.Mode.LEGACY}
+   * <p>Only supported in {@link LooperMode.Mode#LEGACY}
    *
    * @return The next message in the current message chain.
    * @see #setNext(Message)
@@ -57,7 +57,7 @@ public abstract class ShadowMessage {
   /**
    * Convenience method to provide setter access to the private field {@code Message.next}.
    *
-   * <p>Only supported in {@link LooperMode.Mode.LEGACY}
+   * <p>Only supported in {@link LooperMode.Mode#LEGACY}
    *
    * @param next the new next message for the current message.
    * @see #getNext()
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMessageQueue.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMessageQueue.java
index 0891e2780..d1175b38b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMessageQueue.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMessageQueue.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import android.os.Message;
 import android.os.MessageQueue;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.LooperMode;
 import org.robolectric.util.Scheduler;
 
 /**
@@ -25,28 +26,28 @@ public abstract class ShadowMessageQueue {
   /**
    * Return this queue's Scheduler.
    *
-   * <p>Only supported in {@link LooperMode.Mode.LEGACY}.
+   * <p>Only supported in {@link LooperMode.Mode#LEGACY}.
    */
   public abstract Scheduler getScheduler();
 
   /**
    * Set this queue's Scheduler.
    *
-   * <p>Only supported in {@link LooperMode.Mode.LEGACY}.
+   * <p>Only supported in {@link LooperMode.Mode#LEGACY}.
    */
   public abstract void setScheduler(Scheduler scheduler);
 
   /**
    * Retrieves the current Message at the top of the queue.
    *
-   * <p>Only supported in {@link LooperMode.Mode.LEGACY}.
+   * <p>Only supported in {@link LooperMode.Mode#LEGACY}.
    */
   public abstract Message getHead();
 
   /**
    * Sets the current Message at the top of the queue.
    *
-   * <p>Only supported in {@link LooperMode.Mode.LEGACY}.
+   * <p>Only supported in {@link LooperMode.Mode#LEGACY}.
    */
   public abstract void setHead(Message msg);
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMotionEvent.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMotionEvent.java
index f575672a3..12df92c20 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMotionEvent.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMotionEvent.java
@@ -3,8 +3,8 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 import static org.robolectric.shadows.NativeAndroidInput.AMOTION_EVENT_AXIS_ORIENTATION;
 import static org.robolectric.shadows.NativeAndroidInput.AMOTION_EVENT_AXIS_PRESSURE;
 import static org.robolectric.shadows.NativeAndroidInput.AMOTION_EVENT_AXIS_SIZE;
@@ -53,7 +53,7 @@ import org.robolectric.versioning.AndroidVersions.V;
 @Implements(value = MotionEvent.class)
 public class ShadowMotionEvent extends ShadowInputEvent {
 
-  private static NativeObjRegistry<NativeInput.MotionEvent> nativeMotionEventRegistry =
+  private static final NativeObjRegistry<NativeInput.MotionEvent> nativeMotionEventRegistry =
       new NativeObjRegistry<>(NativeInput.MotionEvent.class);
 
   private static final int HISTORY_CURRENT = -0x80000000;
@@ -77,7 +77,7 @@ public class ShadowMotionEvent extends ShadowInputEvent {
 
   private static void validatePointerPropertiesArray(
       PointerProperties[] pointerPropertiesObjArray, int pointerCount) {
-    checkNotNull(pointerPropertiesObjArray, "pointerProperties array must not be null");
+    requireNonNull(pointerPropertiesObjArray, "pointerProperties array must not be null");
     checkState(
         pointerPropertiesObjArray.length >= pointerCount,
         "pointerProperties array must be large enough to hold all pointers");
@@ -85,7 +85,7 @@ public class ShadowMotionEvent extends ShadowInputEvent {
 
   private static void validatePointerCoordsObjArray(
       PointerCoords[] pointerCoordsObjArray, int pointerCount) {
-    checkNotNull(pointerCoordsObjArray, "pointerCoords array must not be null");
+    requireNonNull(pointerCoordsObjArray, "pointerCoords array must not be null");
     checkState(
         pointerCoordsObjArray.length >= pointerCount,
         "pointerCoords array must be large enough to hold all pointers");
@@ -100,11 +100,11 @@ public class ShadowMotionEvent extends ShadowInputEvent {
   }
 
   private static void validatePointerCoords(PointerCoords pointerCoordsObj) {
-    checkNotNull(pointerCoordsObj, "pointerCoords must not be null");
+    requireNonNull(pointerCoordsObj, "pointerCoords must not be null");
   }
 
   private static void validatePointerProperties(PointerProperties pointerPropertiesObj) {
-    checkNotNull(pointerPropertiesObj, "pointerProperties must not be null");
+    requireNonNull(pointerPropertiesObj, "pointerProperties must not be null");
   }
 
   private static NativeInput.PointerCoords pointerCoordsToNative(
@@ -228,7 +228,7 @@ public class ShadowMotionEvent extends ShadowInputEvent {
     NativeInput.PointerCoords[] rawPointerCoords = new NativeInput.PointerCoords[pointerCount];
     for (int i = 0; i < pointerCount; i++) {
       PointerCoords pointerCoordsObj = pointerCoordsObjArray[i];
-      checkNotNull(pointerCoordsObj);
+      requireNonNull(pointerCoordsObj);
       rawPointerCoords[i] = pointerCoordsToNative(pointerCoordsObj, xOffset, yOffset);
     }
 
@@ -312,7 +312,7 @@ public class ShadowMotionEvent extends ShadowInputEvent {
     NativeInput.PointerCoords[] rawPointerCoords = new NativeInput.PointerCoords[pointerCount];
     for (int i = 0; i < pointerCount; i++) {
       PointerCoords pointerCoordsObj = pointerCoordsObjArray[i];
-      checkNotNull(pointerCoordsObj);
+      requireNonNull(pointerCoordsObj);
       rawPointerCoords[i] =
           pointerCoordsToNative(pointerCoordsObj, event.getXOffset(), event.getYOffset());
     }
@@ -715,7 +715,7 @@ public class ShadowMotionEvent extends ShadowInputEvent {
 
   @Implementation
   protected void transform(Matrix matrix) {
-    checkNotNull(matrix);
+    requireNonNull(matrix);
     NativeInput.MotionEvent event = getNativeMotionEvent();
 
     float[] m = new float[9];
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAllocationRegistry.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAllocationRegistry.java
index 509b57066..00a718f22 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAllocationRegistry.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAllocationRegistry.java
@@ -39,7 +39,7 @@ public class ShadowNativeAllocationRegistry {
   @Implementation(minSdk = Baklava.SDK_INT)
   protected void __constructor__(
       ClassLoader classLoader,
-      Class clazz,
+      Class<?> clazz,
       long freeFunction,
       long size,
       boolean mallocAllocation) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeBitmap.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeBitmap.java
index 53eacaf45..5e9d9ae36 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeBitmap.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeBitmap.java
@@ -426,8 +426,7 @@ public class ShadowNativeBitmap extends ShadowBitmap {
         // spaces.
         Map<Integer, ColorSpace> namedColorSpaceMap =
             reflector(ColorSpaceReflector.class).getNamedColorSpaceMap();
-        namedColorSpaces =
-            namedColorSpaceMap.values().toArray(new ColorSpace[namedColorSpaceMap.size()]);
+        namedColorSpaces = namedColorSpaceMap.values().toArray(new ColorSpace[0]);
       } else {
         // Before V, we directly access the color space array.
         namedColorSpaces = reflector(ColorSpaceReflector.class).getNamedColorSpaces();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeColorSpaceRgb.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeColorSpaceRgb.java
index aaaa3b39d..897f588c1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeColorSpaceRgb.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeColorSpaceRgb.java
@@ -43,7 +43,7 @@ public class ShadowNativeColorSpaceRgb {
     }
   }
 
-  /** Shadow for {@link ColorSpace$Rgb$Native} that contains native functions. */
+  /** Shadow for {@link ColorSpace.Rgb.Native} that contains native functions. */
   @Implements(
       className = "android.graphics.ColorSpace$Rgb$Native",
       isInAndroidSdk = false,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeCursorWindow.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeCursorWindow.java
index 860df90d6..14b083abd 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeCursorWindow.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeCursorWindow.java
@@ -4,7 +4,7 @@ import static org.robolectric.RuntimeEnvironment.getApiLevel;
 
 import android.database.CharArrayBuffer;
 import android.database.CursorWindow;
-import com.google.common.base.Preconditions;
+import java.util.Objects;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.nativeruntime.CursorWindowNatives;
@@ -53,7 +53,7 @@ public class ShadowNativeCursorWindow extends ShadowCursorWindow {
   @Implementation
   protected static boolean nativePutBlob(long windowPtr, byte[] value, int row, int column) {
     // Real Android will crash in native code if putBlob is called with a null value.
-    Preconditions.checkNotNull(value);
+    Objects.requireNonNull(value);
     if (getApiLevel() <= U.SDK_INT) {
       return CursorWindowNatives.nativePutBlob(windowPtr, value, row, column);
     } else {
@@ -71,7 +71,7 @@ public class ShadowNativeCursorWindow extends ShadowCursorWindow {
   @Implementation
   protected static boolean nativePutString(long windowPtr, String value, int row, int column) {
     // Real Android will crash in native code if putString is called with a null value.
-    Preconditions.checkNotNull(value);
+    Objects.requireNonNull(value);
     if (getApiLevel() <= U.SDK_INT) {
       return CursorWindowNatives.nativePutString(windowPtr, value, row, column);
     } else {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeFont.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeFont.java
index 2c42b1155..cbeddf3f6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeFont.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeFont.java
@@ -13,12 +13,12 @@ import android.graphics.RectF;
 import android.graphics.fonts.Font;
 import android.util.TypedValue;
 import com.google.common.base.Ascii;
-import com.google.common.base.Preconditions;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
+import java.util.Objects;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -263,8 +263,8 @@ public class ShadowNativeFont {
 
   static ByteBuffer assetToBuffer(AssetManager am, String path, boolean isAsset, int cookie)
       throws IOException {
-    Preconditions.checkNotNull(am, "assetManager can not be null");
-    Preconditions.checkNotNull(path, "path can not be null");
+    Objects.requireNonNull(am, "assetManager can not be null");
+    Objects.requireNonNull(path, "path can not be null");
     try (InputStream assetStream =
         isAsset
             ? am.open(path, AssetManager.ACCESS_BUFFER)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java
index 58308c364..9f040faad 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java
@@ -26,10 +26,12 @@ import java.io.FileDescriptor;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.InDevelopment;
 import org.robolectric.nativeruntime.DefaultNativeRuntimeLoader;
 import org.robolectric.nativeruntime.HardwareRendererNatives;
 import org.robolectric.shadows.ShadowNativeHardwareRenderer.Picker;
 import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions.Baklava;
 import org.robolectric.versioning.AndroidVersions.U;
 import org.robolectric.versioning.AndroidVersions.Baklava;
 import org.robolectric.annotation.InDevelopment;
@@ -48,6 +50,7 @@ public class ShadowNativeHardwareRenderer {
 
   @Implementation(maxSdk = U.SDK_INT)
   protected static void preload() {
+    DefaultNativeRuntimeLoader.injectAndLoad();
     HardwareRendererNatives.preload();
   }
 
@@ -327,14 +330,14 @@ public class ShadowNativeHardwareRenderer {
     HardwareRendererNatives.nSetFrameCompleteCallback(nativeProxy, callback);
   }
 
-  @Implementation(minSdk = R, maxSdk = U.SDK_INT)
+  @Implementation(minSdk = R)
   protected static void nAddObserver(long nativeProxy, long nativeObserver) {
-    HardwareRendererNatives.nAddObserver(nativeProxy, nativeObserver);
+    // Observers are not supported
   }
 
-  @Implementation(minSdk = R, maxSdk = U.SDK_INT)
+  @Implementation(minSdk = R)
   protected static void nRemoveObserver(long nativeProxy, long nativeObserver) {
-    HardwareRendererNatives.nRemoveObserver(nativeProxy, nativeObserver);
+    // Observers are not supported
   }
 
   @Implementation(maxSdk = TIRAMISU)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReader.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReader.java
index 0598c047b..92fd3c68c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReader.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReader.java
@@ -70,8 +70,7 @@ public class ShadowNativeImageReader {
     // In T+, the hal format and data space are provided directly instead.
     // However the format values overlap and the conversion is merely a cast.
     // Reference: android12/.../frameworks/base/libs/hostgraphics/PublicFormat.cpp
-    int fmt = hardwareBufferFormat;
-    natives.nativeInit(weakSelf, w, h, fmt, maxImgs, consumerUsage);
+    natives.nativeInit(weakSelf, w, h, hardwareBufferFormat, maxImgs, consumerUsage);
     imageReaderReflector.setMemberNativeContext(natives.mNativeContext);
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeMatrix.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeMatrix.java
index 7cf77bede..cc32f9ccb 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeMatrix.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeMatrix.java
@@ -267,7 +267,7 @@ public class ShadowNativeMatrix extends ShadowMatrix {
     throw new UnsupportedOperationException("Legacy ShadowMatrix APIs are not supported");
   }
 
-  /** Shadow for {@link Matrix$ExtraNatives} that contains native functions. */
+  /** Shadow for {@link Matrix.ExtraNatives} that contains native functions. */
   @Implements(
       className = "android.graphics.Matrix$ExtraNatives",
       isInAndroidSdk = false,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePaint.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePaint.java
index 2ca0ce80f..7eac90970 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePaint.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePaint.java
@@ -29,7 +29,7 @@ import org.robolectric.versioning.AndroidVersions.U;
 public class ShadowNativePaint {
 
   // nGetTextRunCursor methods are non-static
-  private PaintNatives paintNatives = new PaintNatives();
+  private final PaintNatives paintNatives = new PaintNatives();
 
   @Implementation(minSdk = O, maxSdk = U.SDK_INT)
   protected static long nGetNativeFinalizer() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRecordingCanvasOP.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRecordingCanvasOP.java
index 4d7371214..fff6424f5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRecordingCanvasOP.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRecordingCanvasOP.java
@@ -9,8 +9,8 @@ import org.robolectric.nativeruntime.BaseRecordingCanvasNatives;
 import org.robolectric.shadows.ShadowNativeRecordingCanvasOP.Picker;
 
 /**
- * Shadow for android.view.RecordingCanvas. This class was renamed to {@link BaseRecordingCanvas} in
- * Q.
+ * Shadow for android.view.RecordingCanvas. This class was renamed to {@link
+ * android.graphics.BaseRecordingCanvas} in Q.
  */
 @Implements(
     className = "android.view.RecordingCanvas",
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSystemFonts.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSystemFonts.java
index 12b9bca26..140cbbc0f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSystemFonts.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSystemFonts.java
@@ -21,6 +21,7 @@ import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
 import java.util.ArrayList;
 import java.util.Map;
+import java.util.Objects;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
@@ -51,7 +52,7 @@ public class ShadowNativeSystemFonts {
       long lastModifiedDate,
       int configVersion) {
     String fontDir = System.getProperty("robolectric.nativeruntime.fontdir");
-    Preconditions.checkNotNull(fontDir);
+    Objects.requireNonNull(fontDir);
     Preconditions.checkState(new File(fontDir).isDirectory(), "Missing fonts directory");
     Preconditions.checkState(
         fontDir.endsWith(File.separator), "Fonts directory must end with a slash");
@@ -77,7 +78,7 @@ public class ShadowNativeSystemFonts {
     // loaded, so we must ensure it is loaded for `robolectric.nativeruntime.fontdir` to be defined.
     DefaultNativeRuntimeLoader.injectAndLoad();
     String fontDir = System.getProperty("robolectric.nativeruntime.fontdir");
-    Preconditions.checkNotNull(fontDir);
+    Objects.requireNonNull(fontDir);
     Preconditions.checkState(new File(fontDir).isDirectory(), "Missing fonts directory");
     Preconditions.checkState(
         fontDir.endsWith(File.separator), "Fonts directory must end with a slash");
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeThreadedRenderer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeThreadedRenderer.java
index 73e32653a..a73707961 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeThreadedRenderer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeThreadedRenderer.java
@@ -196,7 +196,7 @@ public class ShadowNativeThreadedRenderer {
       surface.unlockCanvasAndPost(canvas);
       Image nativeImage = imageReader.acquireNextImage();
       Plane[] planes = nativeImage.getPlanes();
-      Bitmap destBitmap = Bitmap.createBitmap((int) width, (int) height, Config.ARGB_8888);
+      Bitmap destBitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
       destBitmap.copyPixelsFromBuffer(planes[0].getBuffer());
       surface.release();
       // Return an immutable copy of the Bitmap, which is what this API expects.
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java
index c8a05d1e6..cbcbc7bda 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java
@@ -24,6 +24,7 @@ import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
@@ -71,7 +72,7 @@ public class ShadowNativeTypeface extends ShadowTypeface {
       ArrayMap<String, Typeface> fontMap,
       ArrayMap<String, FontFamily[]> fallbackMap) {
     String fontDir = System.getProperty("robolectric.nativeruntime.fontdir");
-    Preconditions.checkNotNull(fontDir);
+    Objects.requireNonNull(fontDir);
     Preconditions.checkState(new File(fontDir).isDirectory(), "Missing fonts directory");
     Preconditions.checkState(
         fontDir.endsWith(File.separator), "Fonts directory must end with a slash");
@@ -85,14 +86,13 @@ public class ShadowNativeTypeface extends ShadowTypeface {
     // `robolectric.nativeruntime.fontdir` system property is valid.
     DefaultNativeRuntimeLoader.injectAndLoad();
     String fontDir = System.getProperty("robolectric.nativeruntime.fontdir");
-    Preconditions.checkNotNull(fontDir);
+    Objects.requireNonNull(fontDir);
     Preconditions.checkState(new File(fontDir).isDirectory(), "Missing fonts directory");
     Preconditions.checkState(
         fontDir.endsWith(File.separator), "Fonts directory must end with a slash");
     return new File(fontDir);
   }
 
-  @SuppressWarnings("unchecked")
   @Implementation(minSdk = O, maxSdk = O_MR1)
   protected static @ClassName("android.graphics.FontFamily") Object makeFamilyFromParsed(
       @ClassName("android.text.FontConfig$Family") Object family,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNoopNativeAllocationRegistry.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNoopNativeAllocationRegistry.java
index 8a35a184e..aad36e201 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNoopNativeAllocationRegistry.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNoopNativeAllocationRegistry.java
@@ -41,7 +41,7 @@ public class ShadowNoopNativeAllocationRegistry {
   @Implementation(minSdk = Baklava.SDK_INT)
   protected void __constructor__(
       ClassLoader classLoader,
-      Class clazz,
+      Class<?> clazz,
       long freeFunction,
       long size,
       boolean mallocAllocation) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotification.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotification.java
index 977e029a1..fa3d0a994 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotification.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotification.java
@@ -92,7 +92,7 @@ public class ShadowNotification {
       return realNotification.extras.getParcelable(Notification.EXTRA_PICTURE);
     } else {
       ImageView imageView =
-          (ImageView) applyBigContentView().findViewById(getInternalResourceId("big_picture"));
+          applyBigContentView().findViewById(getInternalResourceId("big_picture"));
       return imageView != null && imageView.getDrawable() != null
           ? ((BitmapDrawable) imageView.getDrawable()).getBitmap()
           : null;
@@ -155,8 +155,7 @@ public class ShadowNotification {
       ByteArrayOutputStream buf = new ByteArrayOutputStream();
       ShadowView shadowView = Shadow.extract(view);
       shadowView.dump(new PrintStream(buf), 4);
-      throw new IllegalArgumentException(
-          "no id." + resourceName + " found in view:\n" + buf.toString());
+      throw new IllegalArgumentException("no id." + resourceName + " found in view:\n" + buf);
     }
     return subView;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationListenerService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationListenerService.java
index c8cc54c45..15cf99c07 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationListenerService.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationListenerService.java
@@ -1,7 +1,5 @@
 package org.robolectric.shadows;
 
-import static java.util.stream.Collectors.toCollection;
-
 import android.app.Notification;
 import android.content.ComponentName;
 import android.os.Build.VERSION;
@@ -116,8 +114,7 @@ public class ShadowNotificationListenerService extends ShadowService {
     ImmutableSet<String> keySet = ImmutableSet.copyOf(keys);
     return activeNotifications.stream()
         .filter(notification -> keySet.contains(notification.getKey()))
-        .collect(toCollection(ArrayList::new))
-        .toArray(new StatusBarNotification[0]);
+        .toArray(StatusBarNotification[]::new);
   }
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java
index d4cd3f3f5..2667a7df4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java
@@ -26,6 +26,7 @@ import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
@@ -102,9 +103,7 @@ public class ShadowNotificationManager {
   @Implementation
   protected void cancel(String tag, int id) {
     Key key = new Key(tag, id);
-    if (notifications.containsKey(key)) {
-      notifications.remove(key);
-    }
+    notifications.remove(key);
   }
 
   @Implementation
@@ -127,7 +126,7 @@ public class ShadowNotificationManager {
   }
 
   public void setImportance(int importance) {
-    this.importance = importance;
+    ShadowNotificationManager.importance = importance;
   }
 
   @Implementation(minSdk = M)
@@ -199,20 +198,19 @@ public class ShadowNotificationManager {
     if (deletedNotificationChannels.containsKey(id)) {
       notificationChannels.put(id, deletedNotificationChannels.remove(id));
     }
-    NotificationChannel existingChannel = (NotificationChannel) notificationChannels.get(id);
+    NotificationChannel existingChannel = notificationChannels.get(id);
     // Per documentation, recreating a channel can change name and description, lower importance or
     // set a group if no group set. Other settings remain unchanged. See
     // https://developer.android.com/reference/android/app/NotificationManager#createNotificationChannel%28android.app.NotificationChannel@29
     // for more info.
     if (existingChannel != null) {
-      NotificationChannel newChannel = (NotificationChannel) channel;
-      existingChannel.setName(newChannel.getName());
-      existingChannel.setDescription(newChannel.getDescription());
-      if (newChannel.getImportance() < existingChannel.getImportance()) {
-        existingChannel.setImportance(newChannel.getImportance());
+      existingChannel.setName(channel.getName());
+      existingChannel.setDescription(channel.getDescription());
+      if (channel.getImportance() < existingChannel.getImportance()) {
+        existingChannel.setImportance(channel.getImportance());
       }
       if (Strings.isNullOrEmpty(existingChannel.getGroup())) {
-        existingChannel.setGroup(newChannel.getGroup());
+        existingChannel.setGroup(channel.getGroup());
       }
       return;
     }
@@ -357,7 +355,7 @@ public class ShadowNotificationManager {
 
   @Implementation(minSdk = N)
   protected AutomaticZenRule getAutomaticZenRule(String id) {
-    Preconditions.checkNotNull(id);
+    Objects.requireNonNull(id);
     enforcePolicyAccess();
 
     return automaticZenRules.get(id);
@@ -367,22 +365,18 @@ public class ShadowNotificationManager {
   protected Map<String, AutomaticZenRule> getAutomaticZenRules() {
     enforcePolicyAccess();
 
-    ImmutableMap.Builder<String, AutomaticZenRule> rules = new ImmutableMap.Builder();
-    for (Map.Entry<String, AutomaticZenRule> entry : automaticZenRules.entrySet()) {
-      rules.put(entry.getKey(), copyAutomaticZenRule(entry.getValue()));
-    }
-    return rules.build();
+    return ImmutableMap.copyOf(automaticZenRules);
   }
 
   @Implementation(minSdk = N)
   protected String addAutomaticZenRule(AutomaticZenRule automaticZenRule) {
-    Preconditions.checkNotNull(automaticZenRule);
-    Preconditions.checkNotNull(automaticZenRule.getName());
+    Objects.requireNonNull(automaticZenRule);
+    Objects.requireNonNull(automaticZenRule.getName());
     Preconditions.checkState(
         automaticZenRule.getOwner() != null || automaticZenRule.getConfigurationActivity() != null,
         "owner/configurationActivity cannot be null at the same time");
 
-    Preconditions.checkNotNull(automaticZenRule.getConditionId());
+    Objects.requireNonNull(automaticZenRule.getConditionId());
     enforcePolicyAccess();
 
     String id = UUID.randomUUID().toString().replace("-", "");
@@ -393,12 +387,12 @@ public class ShadowNotificationManager {
   @Implementation(minSdk = N)
   protected boolean updateAutomaticZenRule(String id, AutomaticZenRule automaticZenRule) {
     // NotificationManagerService doesn't check that id is non-null.
-    Preconditions.checkNotNull(automaticZenRule);
-    Preconditions.checkNotNull(automaticZenRule.getName());
+    Objects.requireNonNull(automaticZenRule);
+    Objects.requireNonNull(automaticZenRule.getName());
     Preconditions.checkState(
         automaticZenRule.getOwner() != null || automaticZenRule.getConfigurationActivity() != null,
         "owner/configurationActivity cannot be null at the same time");
-    Preconditions.checkNotNull(automaticZenRule.getConditionId());
+    Objects.requireNonNull(automaticZenRule.getConditionId());
     enforcePolicyAccess();
 
     // ZenModeHelper throws slightly cryptic exceptions.
@@ -414,7 +408,7 @@ public class ShadowNotificationManager {
 
   @Implementation(minSdk = N)
   protected boolean removeAutomaticZenRule(String id) {
-    Preconditions.checkNotNull(id);
+    Objects.requireNonNull(id);
     enforcePolicyAccess();
     return automaticZenRules.remove(id) != null;
   }
@@ -466,7 +460,7 @@ public class ShadowNotificationManager {
    * the default behavior.
    */
   public void setEnforceMaxNotificationLimit(boolean enforceMaxNotificationLimit) {
-    this.enforceMaxNotificationLimit = enforceMaxNotificationLimit;
+    ShadowNotificationManager.enforceMaxNotificationLimit = enforceMaxNotificationLimit;
   }
 
   /**
@@ -550,8 +544,7 @@ public class ShadowNotificationManager {
     public boolean equals(Object o) {
       if (!(o instanceof Key)) return false;
       Key other = (Key) o;
-      return (this.tag == null ? other.tag == null : this.tag.equals(other.tag))
-          && this.id == other.id;
+      return Objects.equals(this.tag, other.tag) && this.id == other.id;
     }
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNsdManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNsdManager.java
index d85269275..a6d589cb9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNsdManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNsdManager.java
@@ -1,16 +1,246 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.S_V2;
-
+import android.net.Network;
 import android.net.nsd.NsdManager;
+import android.net.nsd.NsdServiceInfo;
+import android.os.Build.VERSION_CODES;
+import com.google.auto.value.AutoValue;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
+import org.robolectric.util.Logger;
 
+/**
+ * Shadow for {@link NsdManager}.
+ *
+ * <p>Note that not all functionality is implemented.
+ */
 @Implements(NsdManager.class)
 public class ShadowNsdManager {
+  private static final Map<NsdServiceKey, NsdManager.RegistrationListener> registeredServices =
+      new HashMap<>();
+  private static final Map<NsdManager.RegistrationListener, NsdServiceInfo> registeredListeners =
+      new HashMap<>();
+  private static final Map<NsdManager.DiscoveryListener, String> discoveryListeners =
+      new HashMap<>();
+  private static final Map<String, ArrayList<NsdManager.DiscoveryListener>> discoveryServiceTypes =
+      new HashMap<>();
+  private static final Map<NsdManager.ResolveListener, NsdServiceInfo> resolveListeners =
+      new HashMap<>();
+  private static final Map<NsdServiceKey, ArrayList<NsdManager.ResolveListener>> resolveServices =
+      new HashMap<>();
+
+  @AutoValue
+  abstract static class NsdServiceKey {
+    public static NsdServiceKey create(String serviceName, String serviceType) {
+      return new AutoValue_ShadowNsdManager_NsdServiceKey(serviceName, serviceType);
+    }
+
+    abstract String serviceName();
+
+    abstract String serviceType();
+  }
 
-  @Implementation(maxSdk = S_V2)
+  @Implementation(maxSdk = VERSION_CODES.S_V2)
   protected void init() {
     // do not blow up.
   }
+
+  /**
+   * Shadows the original {@link #registerService} method available since SDK 16. The recommended
+   * method, available since SDK 33, takes an additional {@link Executor} parameter.
+   */
+  @Implementation(maxSdk = VERSION_CODES.S_V2)
+  protected void registerService(
+      NsdServiceInfo serviceInfo, int protocolType, NsdManager.RegistrationListener listener) {
+    registerService(serviceInfo, protocolType, Runnable::run, listener);
+  }
+
+  @Implementation(minSdk = VERSION_CODES.TIRAMISU)
+  protected void registerService(
+      NsdServiceInfo serviceInfo,
+      int protocolType,
+      Executor executor,
+      NsdManager.RegistrationListener listener) {
+    NsdServiceKey serviceKey =
+        NsdServiceKey.create(serviceInfo.getServiceName(), serviceInfo.getServiceType());
+    if (registeredListeners.containsKey(listener)) {
+      throw new UnsupportedOperationException("registerService: listener already registered");
+    }
+    if (protocolType != NsdManager.PROTOCOL_DNS_SD) {
+      Logger.warn("registerService: invalid protocol type");
+      executor.execute(
+          () -> listener.onRegistrationFailed(serviceInfo, NsdManager.FAILURE_BAD_PARAMETERS));
+      return;
+    }
+    // Registration ok - on success, "register" the service and save the listener.
+    registeredServices.put(serviceKey, listener);
+    registeredListeners.put(listener, serviceInfo);
+    executor.execute(() -> listener.onServiceRegistered(serviceInfo));
+  }
+
+  @Implementation
+  protected void unregisterService(NsdManager.RegistrationListener listener) {
+    if (!registeredListeners.containsKey(listener)) {
+      throw new UnsupportedOperationException("unregisterService: listener not registered");
+    } else {
+      NsdServiceInfo serviceInfo = registeredListeners.get(listener);
+      registeredServices.remove(getServiceKey(serviceInfo));
+      registeredListeners.remove(listener);
+      listener.onServiceUnregistered(serviceInfo);
+    }
+  }
+
+  @Implementation(maxSdk = VERSION_CODES.S_V2)
+  protected void discoverServices(
+      String serviceType, int protocolType, NsdManager.DiscoveryListener listener) {
+    discoverServices(serviceType, protocolType, (Network) null, Runnable::run, listener);
+  }
+
+  @Implementation(minSdk = VERSION_CODES.TIRAMISU)
+  protected void discoverServices(
+      String serviceType,
+      int protocolType,
+      Network network,
+      Executor executor,
+      NsdManager.DiscoveryListener listener) {
+    // Check for existing discovery listeners.
+    if (discoveryListeners.containsKey(listener)) {
+      throw new UnsupportedOperationException("discoverServices: listener already registered");
+    }
+    // Register the listener.
+    discoveryServiceTypes.putIfAbsent(serviceType, new ArrayList<>());
+    discoveryServiceTypes.get(serviceType).add(listener);
+    // Add new listener to listener tracking.
+    discoveryListeners.put(listener, serviceType);
+    // Notify the listener of the successful start of discovery.
+    executor.execute(() -> listener.onDiscoveryStarted(serviceType));
+  }
+
+  @Implementation
+  protected void stopServiceDiscovery(NsdManager.DiscoveryListener listener) {
+    // Check for existing discovery listener.
+    if (!discoveryListeners.containsKey(listener)) {
+      throw new UnsupportedOperationException("stopServiceDiscovery: listener not registered");
+    }
+    // Unregister the listener.
+    String serviceType = discoveryListeners.get(listener);
+    discoveryServiceTypes.remove(serviceType);
+    discoveryListeners.remove(listener);
+    listener.onDiscoveryStopped(serviceType);
+  }
+
+  @Implementation
+  protected void resolveService(NsdServiceInfo serviceInfo, NsdManager.ResolveListener listener) {
+    if (resolveListeners.containsKey(listener)) {
+      throw new UnsupportedOperationException("resolveService: listener already registered");
+    }
+    // Register the resolver.
+    NsdServiceKey serviceKey = getServiceKey(serviceInfo);
+    resolveServices.putIfAbsent(serviceKey, new ArrayList<>());
+
+    if (!resolveServices.containsKey(serviceKey)) {
+      resolveServices.put(serviceKey, new ArrayList<>());
+    }
+    resolveServices.get(serviceKey).add(listener);
+    // Add new listener to listener tracking.
+    resolveListeners.put(listener, serviceInfo);
+  }
+
+  private static NsdServiceKey getServiceKey(NsdServiceInfo serviceInfo) {
+    return NsdServiceKey.create(serviceInfo.getServiceName(), serviceInfo.getServiceType());
+  }
+
+  /** Resets shadow to its initial state with no registered services and no discovery listeners. */
+  @Resetter
+  public static void reset() {
+    registeredServices.clear();
+    registeredListeners.clear();
+    discoveryListeners.clear();
+    discoveryServiceTypes.clear();
+    resolveListeners.clear();
+    resolveServices.clear();
+  }
+
+  /**
+   * Returns the listener for a registered service, or null if no matching service is registered.
+   *
+   * @param serviceInfo The registered service info for the listener to find.
+   */
+  @Nullable
+  public NsdManager.RegistrationListener getRegistrationListener(NsdServiceInfo serviceInfo) {
+    NsdServiceKey serviceKey = getServiceKey(serviceInfo);
+    if (registeredServices.containsKey(serviceKey)) {
+      return registeredServices.get(serviceKey);
+    }
+    return null;
+  }
+
+  /**
+   * Returns the service info for a registered service, or null if no matching service is
+   * registered.
+   *
+   * @param listener The listener for the service to find.
+   */
+  @Nullable
+  public NsdServiceInfo getRegisteredServiceInfo(NsdManager.RegistrationListener listener) {
+    if (registeredListeners.containsKey(listener)) {
+      return registeredListeners.get(listener);
+    }
+    return null;
+  }
+
+  @Nullable
+  public List<NsdManager.DiscoveryListener> getDiscoveryListeners(String serviceType) {
+    if (discoveryServiceTypes.containsKey(serviceType)) {
+      return new ArrayList<>(discoveryServiceTypes.get(serviceType));
+    }
+    return null;
+  }
+
+  /**
+   * Returns the service type that a discovery listener is waiting for, or null if listener is not
+   * discovering.
+   *
+   * @param listener The listener for the service type.
+   */
+  @Nullable
+  public String getDiscoveryListenerServiceType(NsdManager.DiscoveryListener listener) {
+    if (discoveryListeners.containsKey(listener)) {
+      return discoveryListeners.get(listener);
+    }
+    return null;
+  }
+
+  @Nullable
+  public List<NsdManager.ResolveListener> getResolveListeners(NsdServiceInfo serviceInfo) {
+    NsdServiceKey serviceKey = getServiceKey(serviceInfo);
+    if (resolveServices.containsKey(serviceKey)) {
+      return new ArrayList<>(resolveServices.get(serviceKey));
+    }
+    return null;
+  }
+
+  @Nullable
+  public NsdServiceInfo getResolveListenerServiceInfo(NsdManager.ResolveListener listener) {
+    if (resolveListeners.containsKey(listener)) {
+      return resolveListeners.get(listener);
+    }
+    return null;
+  }
+
+  protected void removeResolveListener(NsdManager.ResolveListener listener) {
+    if (resolveListeners.containsKey(listener)) {
+      NsdServiceInfo serviceInfo = resolveListeners.get(listener);
+      NsdServiceKey serviceKey = getServiceKey(serviceInfo);
+      resolveServices.get(serviceKey).remove(listener);
+      resolveListeners.remove(listener);
+    }
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOpenGLMatrix.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOpenGLMatrix.java
index 427c8f78a..4319b467a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOpenGLMatrix.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOpenGLMatrix.java
@@ -112,11 +112,11 @@ public class ShadowOpenGLMatrix {
     if (rhsVecOffset + 4 > rhsVec.length) {
       throw new IllegalArgumentException("rhsVecOffset + 4 > rhsVec.length");
     }
-    final float x = rhsVec[rhsVecOffset + 0];
+    final float x = rhsVec[rhsVecOffset];
     final float y = rhsVec[rhsVecOffset + 1];
     final float z = rhsVec[rhsVecOffset + 2];
     final float w = rhsVec[rhsVecOffset + 3];
-    resultVec[resultVecOffset + 0] =
+    resultVec[resultVecOffset] =
         lhsMat[I(0, 0, lhsMatOffset)] * x
             + lhsMat[I(1, 0, lhsMatOffset)] * y
             + lhsMat[I(2, 0, lhsMatOffset)] * z
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOs.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOs.java
index 9ecd207d8..a626ffa7e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOs.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOs.java
@@ -7,7 +7,7 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
 /** A Shadow for android.system.Os */
-@Implements(value = Os.class, minSdk = 21)
+@Implements(value = Os.class)
 public final class ShadowOs {
 
   private ShadowOs() {}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOsConstants.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOsConstants.java
index bdc6b2ecf..43e707e77 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOsConstants.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOsConstants.java
@@ -5,12 +5,20 @@ import java.io.File;
 import java.lang.reflect.Field;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.shadow.api.Shadow;
 
 /** */
-@Implements(value = OsConstants.class, minSdk = 21)
+@Implements(value = OsConstants.class)
 public final class ShadowOsConstants {
+
   @Implementation
-  protected static void initConstants() {
+  protected static void __staticInitializer__() {
+    // Invoking original static initializer just in case: there might more than static fields.
+    Shadow.directInitialize(OsConstants.class);
+    shadowInitConstants();
+  }
+
+  private static void shadowInitConstants() {
 
     // In real android these constants are populated via reflection in native linux-only code.
     // This shadow performs similar logic here , using the values obtained from
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOverlayManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOverlayManager.java
index b0aec4585..65595ddcb 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOverlayManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOverlayManager.java
@@ -27,12 +27,12 @@ import org.robolectric.versioning.AndroidVersions;
  * <p>This shadow exists because the overlays managed by the OverlayManager require set up at the
  * Android base image level. This is not something that can exist for host level unit tests.
  *
- * <p>To simulate the image configuration, unit tests must call the {@link addOverlayInfo} function
+ * <p>To simulate the image configuration, unit tests must call the {@link #addOverlayInfo} function
  * to define the available overlays.
  *
- * <p>This basic shadow only implements the {@link getOverlayInfo} and {@link setEnabled} functions,
- * enabling a basic workflow for enabling or disabling Runtime Resource Overlays (RROs). It enforces
- * the android.permissions.CHANGE_OVERLAY_PACKAGES permission.
+ * <p>This basic shadow only implements the {@link #getOverlayInfo} and {@link #setEnabled}
+ * functions, enabling a basic workflow for enabling or disabling Runtime Resource Overlays (RROs).
+ * It enforces the android.permissions.CHANGE_OVERLAY_PACKAGES permission.
  *
  * <p>It does not validate the android.permission.INTERACT_ACROSS_USERS or
  * android.INTERACT_ACROSS_USERS_FULL permissions, which are necessary when changing packages owned
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageBackwardCompatibility.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageBackwardCompatibility.java
index 0cdc986df..db3010a31 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageBackwardCompatibility.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageBackwardCompatibility.java
@@ -9,8 +9,8 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
 /**
- * Shadow of {@link PackageBackwardCompatibility} to handle a scenario that can come up when
- * multiple Android versions end up on the classpath.
+ * Shadow of {@link android.content.pm.PackageBackwardCompatibility} to handle a scenario that can
+ * come up when multiple Android versions end up on the classpath.
  */
 @Implements(
     className = "android.content.pm.PackageBackwardCompatibility",
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageInstaller.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageInstaller.java
index d4a24033b..b180a7d90 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageInstaller.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageInstaller.java
@@ -57,9 +57,9 @@ public class ShadowPackageInstaller {
   // According to the documentation, the session ID is always non-zero:
   // https://developer.android.com/reference/android/content/pm/PackageInstaller#createSession(android.content.pm.PackageInstaller.SessionParams)
   private int nextSessionId = 1;
-  private Map<Integer, PackageInstaller.SessionInfo> sessionInfos = new HashMap<>();
-  private Map<Integer, PackageInstaller.Session> sessions = new HashMap<>();
-  private Set<CallbackInfo> callbackInfos = Collections.synchronizedSet(new HashSet<>());
+  private final Map<Integer, PackageInstaller.SessionInfo> sessionInfos = new HashMap<>();
+  private final Map<Integer, PackageInstaller.Session> sessions = new HashMap<>();
+  private final Set<CallbackInfo> callbackInfos = Collections.synchronizedSet(new HashSet<>());
   private final Map<String, UninstalledPackage> uninstalledPackages = new HashMap<>();
 
   private static class CallbackInfo {
@@ -161,13 +161,7 @@ public class ShadowPackageInstaller {
     sessionInfo.appIcon = appIcon;
 
     for (final CallbackInfo callbackInfo : new ArrayList<>(callbackInfos)) {
-      callbackInfo.handler.post(
-          new Runnable() {
-            @Override
-            public void run() {
-              callbackInfo.callback.onBadgingChanged(sessionId);
-            }
-          });
+      callbackInfo.handler.post(() -> callbackInfo.callback.onBadgingChanged(sessionId));
     }
   }
 
@@ -180,13 +174,7 @@ public class ShadowPackageInstaller {
     sessionInfo.appLabel = appLabel;
 
     for (final CallbackInfo callbackInfo : new ArrayList<>(callbackInfos)) {
-      callbackInfo.handler.post(
-          new Runnable() {
-            @Override
-            public void run() {
-              callbackInfo.callback.onBadgingChanged(sessionId);
-            }
-          });
+      callbackInfo.handler.post(() -> callbackInfo.callback.onBadgingChanged(sessionId));
     }
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageManager.java
index b01305bff..d842c2f08 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageManager.java
@@ -97,6 +97,7 @@ import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Objects;
 import java.util.Set;
 import java.util.SortedMap;
 import java.util.TreeMap;
@@ -143,7 +144,7 @@ public class ShadowPackageManager {
   static final SortedMap<ComponentName, List<IntentFilter>> providerFilters = new TreeMap<>();
   static final SortedMap<ComponentName, List<IntentFilter>> receiverFilters = new TreeMap<>();
 
-  private static Map<String, PackageInfo> packageArchiveInfo = new HashMap<>();
+  private static final Map<String, PackageInfo> packageArchiveInfo = new HashMap<>();
   static final Map<String, PackageStats> packageStatsMap = new HashMap<>();
   static final Map<String, String> packageInstallerMap = new HashMap<>();
   static final Map<String, Object> packageInstallSourceInfoMap = new HashMap<>();
@@ -251,11 +252,11 @@ public class ShadowPackageManager {
           permission.WRITE_CALENDAR,
           createPermissionInfo(
               permission.WRITE_CALENDAR,
-              "add or modify calendar events and send email to guests without owners\' knowledge",
+              "add or modify calendar events and send email to guests without owners' knowledge",
               "Allows the app to add, remove, change events that you can modify on your phone,"
                   + " including those of friends or co-workers. This may allow the app to send"
                   + " messages that appear to come from calendar owners, or modify events without"
-                  + " the owners\' knowledge.",
+                  + " the owners' knowledge.",
               PermissionInfo.PROTECTION_DANGEROUS,
               permission_group.CALENDAR),
           permission.GET_ACCOUNTS,
@@ -271,7 +272,7 @@ public class ShadowPackageManager {
               permission.READ_CONTACTS,
               "read your contacts",
               "Allows the app to read data about your contacts stored on your phone, including the"
-                  + " frequency with which you\'ve called, emailed, or communicated in other ways"
+                  + " frequency with which you've called, emailed, or communicated in other ways"
                   + " with specific individuals. This permission allows apps to save your contact"
                   + " data, and malicious apps may share contact data without your knowledge.",
               PermissionInfo.PROTECTION_DANGEROUS,
@@ -281,7 +282,7 @@ public class ShadowPackageManager {
               permission.WRITE_CONTACTS,
               "modify your contacts",
               "Allows the app to modify the data about your contacts stored on your phone,"
-                  + " including the frequency with which you\'ve called, emailed, or communicated"
+                  + " including the frequency with which you've called, emailed, or communicated"
                   + " in other ways with specific contacts. This permission allows apps to delete"
                   + " contact data.",
               PermissionInfo.PROTECTION_DANGEROUS,
@@ -777,7 +778,7 @@ public class ShadowPackageManager {
    */
   @Deprecated
   public void addResolveInfoForIntentNoDefaults(Intent intent, ResolveInfo info) {
-    Preconditions.checkNotNull(info);
+    Objects.requireNonNull(info);
     List<ResolveInfo> infoList = resolveInfoForIntent.get(intent);
     if (infoList == null) {
       infoList = new ArrayList<>();
@@ -817,8 +818,7 @@ public class ShadowPackageManager {
     } else if (resolveInfo.providerInfo != null) {
       return resolveInfo.providerInfo.packageName;
     }
-    throw new IllegalStateException(
-        "Could not find package name for ResolveInfo " + resolveInfo.toString());
+    throw new IllegalStateException("Could not find package name for ResolveInfo " + resolveInfo);
   }
 
   public void addActivityIcon(ComponentName component, Drawable drawable) {
@@ -896,7 +896,7 @@ public class ShadowPackageManager {
    * <p>In order to create PackageInfo objects in a valid state please use {@link
    * androidx.test.core.content.pm.PackageInfoBuilder}.
    *
-   * <p>This method automatically simulates instalation of a package in the system, so it adds a
+   * <p>This method automatically simulates installation of a package in the system, so it adds a
    * flag {@link ApplicationInfo#FLAG_INSTALLED} to the application info and makes sure it exits. It
    * will update applicationInfo in package components as well.
    *
@@ -933,7 +933,6 @@ public class ShadowPackageManager {
       for (ComponentInfo componentInfo : componentInfos) {
         if (componentInfo.name == null) {
           componentInfo.name = appInfo.packageName + ".DefaultName" + uniqueNameCounter++;
-          componentInfo.packageName = packageInfo.packageName;
         }
         componentInfo.applicationInfo = appInfo;
         componentInfo.packageName = appInfo.packageName;
@@ -1001,11 +1000,13 @@ public class ShadowPackageManager {
         for (PermissionInfo permissionInfo : packageInfo.permissions) {
           if (AOSP_PLATFORM_PERMISSIONS.containsKey(permissionInfo.name)
               || permissionInfo.name.startsWith(AOSP_PLATFORM_PERMISSION_PREFIX)) {
-            throw new IllegalArgumentException(
-                "Permission "
-                    + permissionInfo.name
-                    + " is a platform permission. Do not declare it as part of the package or test"
-                    + " app manifest.");
+            if (!allowPlatformPermissions()) {
+              throw new IllegalArgumentException(
+                  "Permission "
+                      + permissionInfo.name
+                      + " is a platform permission. Do not declare it as part of the package or"
+                      + " test app manifest.");
+            }
           }
         }
       }
@@ -1118,7 +1119,7 @@ public class ShadowPackageManager {
   }
 
   public void addDrawableResolution(String packageName, int resourceId, Drawable drawable) {
-    drawables.put(new Pair(packageName, resourceId), drawable);
+    drawables.put(new Pair<>(packageName, resourceId), drawable);
   }
 
   public void setNameForUid(int uid, String name) {
@@ -1267,8 +1268,7 @@ public class ShadowPackageManager {
         }
       }
 
-      List<PackageInfo> packages = result;
-      for (PackageInfo aPackage : packages) {
+      for (PackageInfo aPackage : result) {
         ApplicationInfo appInfo = aPackage.applicationInfo;
         if (appInfo != null && archiveFilePath.equals(appInfo.sourceDir)) {
           return aPackage;
@@ -1395,11 +1395,13 @@ public class ShadowPackageManager {
 
       if (AOSP_PLATFORM_PERMISSION_GROUPS.containsKey(permissionGroupInfo.name)
           || permissionGroupInfo.name.startsWith(AOSP_PLATFORM_PERMISSION_GROUP_PREFIX)) {
-        throw new IllegalArgumentException(
-            "Permission group "
-                + permissionGroupInfo.name
-                + " is a platform permission group. Do not declare it as part of the test app"
-                + " manifest.");
+        if (!allowPlatformPermissions()) {
+          throw new IllegalArgumentException(
+              "Permission group "
+                  + permissionGroupInfo.name
+                  + " is a platform permission group. Do not declare it as part of the test app"
+                  + " manifest.");
+        }
       }
 
       addPermissionGroupInfo(permissionGroupInfo);
@@ -1415,6 +1417,16 @@ public class ShadowPackageManager {
     addFilters(receiverFilters, appPackage.receivers);
   }
 
+  /**
+   * Returns true if the test app is allowed to declare platform permissions or permission groups in
+   * its manifest. Normally this is a bad idea as apps cannot do this. The system property is used
+   * to allow this in tests for the Android framework or other system apps that need to do this.
+   */
+  private static boolean allowPlatformPermissions() {
+    return Boolean.parseBoolean(
+        System.getProperty("robolectric.allowPlatformPermissions", "false"));
+  }
+
   protected PackageInfo generatePackageInfo(Package appPackage, int flags) {
 
     if (RuntimeEnvironment.getApiLevel() >= TIRAMISU) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcel.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcel.java
index f606249a5..cf203a5bc 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcel.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcel.java
@@ -522,7 +522,7 @@ public class ShadowParcel {
    *
    * <ul>
    *   <li>Continuing to read past the end returns zeros/nulls.
-   *   <li>{@link setDataCapacity} never decreases buffer size.
+   *   <li>{@link Parcel#setDataCapacity} never decreases buffer size.
    *   <li>It is possible to partially or completely overwrite byte ranges in the buffer.
    *   <li>Zero bytes can be exchanged between primitive data types and empty array/string.
    * </ul>
@@ -1140,7 +1140,7 @@ public class ShadowParcel {
     // Java version of FileDescriptor instead of the Android version.
     int fd = ReflectionHelpers.getField(val, "fd");
     NATIVE_BYTE_BUFFER_REGISTRY.getNativeObject(nativePtr).writeInt(fd);
-    return (long) nativeDataPosition(nativePtr);
+    return nativeDataPosition(nativePtr);
   }
 
   @Implementation(minSdk = M)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcelFileDescriptor.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcelFileDescriptor.java
index 08cdae467..5b5cc79d6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcelFileDescriptor.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcelFileDescriptor.java
@@ -48,6 +48,8 @@ public class ShadowParcelFileDescriptor {
   private static final AtomicInteger NEXT_FILE_ID = new AtomicInteger();
 
   private RandomAccessFile file;
+  private File origFile;
+  private int origMode;
   private int fileIdPledgedOnClose; // != 0 if 'file' was written to a Parcel.
   private int lazyFileId; // != 0 if we were created from a Parcel but don't own a 'file' yet.
   private boolean closed;
@@ -120,6 +122,8 @@ public class ShadowParcelFileDescriptor {
   protected static ParcelFileDescriptor open(File file, int mode) throws FileNotFoundException {
     ParcelFileDescriptor pfd = newParcelFileDescriptor();
     ShadowParcelFileDescriptor shadowParcelFileDescriptor = Shadow.extract(pfd);
+    shadowParcelFileDescriptor.origMode = mode;
+    shadowParcelFileDescriptor.origFile = file;
     shadowParcelFileDescriptor.file = new RandomAccessFile(file, getFileMode(mode));
     if ((mode & ParcelFileDescriptor.MODE_TRUNCATE) != 0) {
       try {
@@ -271,6 +275,9 @@ public class ShadowParcelFileDescriptor {
 
   @Implementation
   protected ParcelFileDescriptor dup() throws IOException {
+    if (origFile != null) {
+      return open(origFile, origMode);
+    }
     return new ParcelFileDescriptor(realParcelFd);
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPath.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPath.java
index 58f4a1f03..1cf2cac4d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPath.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPath.java
@@ -48,15 +48,13 @@ public abstract class ShadowPath {
 
       if (Float.compare(point.x, x) != 0) return false;
       if (Float.compare(point.y, y) != 0) return false;
-      if (type != point.type) return false;
-
-      return true;
+      return type == point.type;
     }
 
     @Override
     public int hashCode() {
-      int result = (x != +0.0f ? Float.floatToIntBits(x) : 0);
-      result = 31 * result + (y != +0.0f ? Float.floatToIntBits(y) : 0);
+      int result = (x != 0.0f ? Float.floatToIntBits(x) : 0);
+      result = 31 * result + (y != 0.0f ? Float.floatToIntBits(y) : 0);
       result = 31 * result + (type != null ? type.hashCode() : 0);
       return result;
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPathMeasure.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPathMeasure.java
index 408778024..3b31de916 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPathMeasure.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPathMeasure.java
@@ -36,7 +36,7 @@ public class ShadowPathMeasure {
 
   /** Note: This is not mathematically correct. */
   @Implementation
-  protected boolean getPosTan(float distance, float pos[], float tan[]) {
+  protected boolean getPosTan(float distance, float[] pos, float[] tan) {
     if ((pos != null && pos.length < 2) || (tan != null && tan.length < 2)) {
       throw new ArrayIndexOutOfBoundsException();
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPathParser.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPathParser.java
index 21eb62ea3..ba02c354b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPathParser.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPathParser.java
@@ -34,11 +34,11 @@ public class ShadowPathParser {
     int start = 0;
     int end = 1;
 
-    ArrayList<PathDataNode> list = new ArrayList<PathDataNode>();
+    ArrayList<PathDataNode> list = new ArrayList<>();
     while (end < pathData.length()) {
       end = nextStart(pathData, end);
       String s = pathData.substring(start, end).trim();
-      if (s.length() > 0) {
+      if (!s.isEmpty()) {
         float[] val = getFloats(s);
         addNode(list, s.charAt(0), val);
       }
@@ -49,7 +49,7 @@ public class ShadowPathParser {
     if ((end - start) == 1 && start < pathData.length()) {
       addNode(list, pathData.charAt(start), new float[0]);
     }
-    return list.toArray(new PathDataNode[list.size()]);
+    return list.toArray(new PathDataNode[0]);
   }
 
   @Implementation
@@ -95,7 +95,7 @@ public class ShadowPathParser {
       float[] results = new float[s.length()];
       int count = 0;
       int startPosition = 1;
-      int endPosition = 0;
+      int endPosition;
 
       ExtractFloatResult result = new ExtractFloatResult();
       int totalLength = s.length();
@@ -154,8 +154,8 @@ public class ShadowPathParser {
   }
 
   public static class PathDataNode {
-    private char mType;
-    private float[] mParams;
+    private final char mType;
+    private final float[] mParams;
 
     private PathDataNode(char type, float[] params) {
       mType = type;
@@ -171,9 +171,9 @@ public class ShadowPathParser {
     public static void nodesToPath(PathDataNode[] node, Path path) {
       float[] current = new float[4];
       char previousCommand = 'm';
-      for (int i = 0; i < node.length; i++) {
-        addCommand(path, current, previousCommand, node[i].mType, node[i].mParams);
-        previousCommand = node[i].mType;
+      for (PathDataNode pathDataNode : node) {
+        addCommand(path, current, previousCommand, pathDataNode.mType, pathDataNode.mParams);
+        previousCommand = pathDataNode.mType;
       }
     }
 
@@ -240,23 +240,23 @@ public class ShadowPathParser {
       for (int k = 0; k < val.length; k += incr) {
         switch (cmd) {
           case 'm': // moveto - Start a new sub-path (relative)
-            path.rMoveTo(val[k + 0], val[k + 1]);
-            currentX += val[k + 0];
+            path.rMoveTo(val[k], val[k + 1]);
+            currentX += val[k];
             currentY += val[k + 1];
             break;
           case 'M': // moveto - Start a new sub-path
-            path.moveTo(val[k + 0], val[k + 1]);
-            currentX = val[k + 0];
+            path.moveTo(val[k], val[k + 1]);
+            currentX = val[k];
             currentY = val[k + 1];
             break;
           case 'l': // lineto - Draw a line from the current point (relative)
-            path.rLineTo(val[k + 0], val[k + 1]);
-            currentX += val[k + 0];
+            path.rLineTo(val[k], val[k + 1]);
+            currentX += val[k];
             currentY += val[k + 1];
             break;
           case 'L': // lineto - Draw a line from the current point
-            path.lineTo(val[k + 0], val[k + 1]);
-            currentX = val[k + 0];
+            path.lineTo(val[k], val[k + 1]);
+            currentX = val[k];
             currentY = val[k + 1];
             break;
           case 'z': // closepath - Close the current subpath
@@ -264,23 +264,23 @@ public class ShadowPathParser {
             path.close();
             break;
           case 'h': // horizontal lineto - Draws a horizontal line (relative)
-            path.rLineTo(val[k + 0], 0);
-            currentX += val[k + 0];
+            path.rLineTo(val[k], 0);
+            currentX += val[k];
             break;
           case 'H': // horizontal lineto - Draws a horizontal line
-            path.lineTo(val[k + 0], currentY);
-            currentX = val[k + 0];
+            path.lineTo(val[k], currentY);
+            currentX = val[k];
             break;
           case 'v': // vertical lineto - Draws a vertical line from the current point (r)
-            path.rLineTo(0, val[k + 0]);
-            currentY += val[k + 0];
+            path.rLineTo(0, val[k]);
+            currentY += val[k];
             break;
           case 'V': // vertical lineto - Draws a vertical line from the current point
-            path.lineTo(currentX, val[k + 0]);
-            currentY = val[k + 0];
+            path.lineTo(currentX, val[k]);
+            currentY = val[k];
             break;
           case 'c': // curveto - Draws a cubic Bzier curve (relative)
-            path.rCubicTo(val[k + 0], val[k + 1], val[k + 2], val[k + 3], val[k + 4], val[k + 5]);
+            path.rCubicTo(val[k], val[k + 1], val[k + 2], val[k + 3], val[k + 4], val[k + 5]);
 
             ctrlPointX = currentX + val[k + 2];
             ctrlPointY = currentY + val[k + 3];
@@ -289,7 +289,7 @@ public class ShadowPathParser {
 
             break;
           case 'C': // curveto - Draws a cubic Bzier curve
-            path.cubicTo(val[k + 0], val[k + 1], val[k + 2], val[k + 3], val[k + 4], val[k + 5]);
+            path.cubicTo(val[k], val[k + 1], val[k + 2], val[k + 3], val[k + 4], val[k + 5]);
             currentX = val[k + 4];
             currentY = val[k + 5];
             ctrlPointX = val[k + 2];
@@ -308,12 +308,12 @@ public class ShadowPathParser {
             path.rCubicTo(
                 reflectiveCtrlPointX,
                 reflectiveCtrlPointY,
-                val[k + 0],
+                val[k],
                 val[k + 1],
                 val[k + 2],
                 val[k + 3]);
 
-            ctrlPointX = currentX + val[k + 0];
+            ctrlPointX = currentX + val[k];
             ctrlPointY = currentY + val[k + 1];
             currentX += val[k + 2];
             currentY += val[k + 3];
@@ -331,25 +331,25 @@ public class ShadowPathParser {
             path.cubicTo(
                 reflectiveCtrlPointX,
                 reflectiveCtrlPointY,
-                val[k + 0],
+                val[k],
                 val[k + 1],
                 val[k + 2],
                 val[k + 3]);
-            ctrlPointX = val[k + 0];
+            ctrlPointX = val[k];
             ctrlPointY = val[k + 1];
             currentX = val[k + 2];
             currentY = val[k + 3];
             break;
           case 'q': // Draws a quadratic Bzier (relative)
-            path.rQuadTo(val[k + 0], val[k + 1], val[k + 2], val[k + 3]);
-            ctrlPointX = currentX + val[k + 0];
+            path.rQuadTo(val[k], val[k + 1], val[k + 2], val[k + 3]);
+            ctrlPointX = currentX + val[k];
             ctrlPointY = currentY + val[k + 1];
             currentX += val[k + 2];
             currentY += val[k + 3];
             break;
           case 'Q': // Draws a quadratic Bzier
-            path.quadTo(val[k + 0], val[k + 1], val[k + 2], val[k + 3]);
-            ctrlPointX = val[k + 0];
+            path.quadTo(val[k], val[k + 1], val[k + 2], val[k + 3]);
+            ctrlPointX = val[k];
             ctrlPointY = val[k + 1];
             currentX = val[k + 2];
             currentY = val[k + 3];
@@ -364,10 +364,10 @@ public class ShadowPathParser {
               reflectiveCtrlPointX = currentX - ctrlPointX;
               reflectiveCtrlPointY = currentY - ctrlPointY;
             }
-            path.rQuadTo(reflectiveCtrlPointX, reflectiveCtrlPointY, val[k + 0], val[k + 1]);
+            path.rQuadTo(reflectiveCtrlPointX, reflectiveCtrlPointY, val[k], val[k + 1]);
             ctrlPointX = currentX + reflectiveCtrlPointX;
             ctrlPointY = currentY + reflectiveCtrlPointY;
-            currentX += val[k + 0];
+            currentX += val[k];
             currentY += val[k + 1];
             break;
           case 'T': // Draws a quadratic Bzier curve (reflective control point)
@@ -380,10 +380,10 @@ public class ShadowPathParser {
               reflectiveCtrlPointX = 2 * currentX - ctrlPointX;
               reflectiveCtrlPointY = 2 * currentY - ctrlPointY;
             }
-            path.quadTo(reflectiveCtrlPointX, reflectiveCtrlPointY, val[k + 0], val[k + 1]);
+            path.quadTo(reflectiveCtrlPointX, reflectiveCtrlPointY, val[k], val[k + 1]);
             ctrlPointX = reflectiveCtrlPointX;
             ctrlPointY = reflectiveCtrlPointY;
-            currentX = val[k + 0];
+            currentX = val[k];
             currentY = val[k + 1];
             break;
           case 'a': // Draws an elliptical arc
@@ -394,7 +394,7 @@ public class ShadowPathParser {
                 currentY,
                 val[k + 5] + currentX,
                 val[k + 6] + currentY,
-                val[k + 0],
+                val[k],
                 val[k + 1],
                 val[k + 2],
                 val[k + 3] != 0,
@@ -411,7 +411,7 @@ public class ShadowPathParser {
                 currentY,
                 val[k + 5],
                 val[k + 6],
-                val[k + 0],
+                val[k],
                 val[k + 1],
                 val[k + 2],
                 val[k + 3] != 0,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedAsyncTask.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedAsyncTask.java
index 6797cd512..656ab0ea2 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedAsyncTask.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedAsyncTask.java
@@ -7,6 +7,7 @@ import com.google.common.annotations.Beta;
 import java.util.concurrent.Executor;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
@@ -14,17 +15,19 @@ import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 
 /**
- * A {@link AsyncTask} shadow for {@link LooperMode.Mode.PAUSED}
+ * A {@link AsyncTask} shadow for {@link LooperMode.Mode#PAUSED}
  *
- * <p>This is beta API, and will likely be renamed/removed in a future Robolectric release.
+ * @deprecated {@link AsyncTask} is deprecated in the Android SDK.
  */
+@Deprecated
 @Implements(
     value = AsyncTask.class,
     shadowPicker = ShadowAsyncTask.Picker.class,
     // TODO: turn off shadowOf generation. Figure out why this is needed
     isInAndroidSdk = false)
 @Beta
-public class ShadowPausedAsyncTask<Params, Progress, Result> extends ShadowAsyncTask {
+public class ShadowPausedAsyncTask<Params, Progress, Result>
+    extends ShadowAsyncTask<Params, Progress, Result> {
 
   private static Executor executorOverride = null;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedAsyncTaskLoader.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedAsyncTaskLoader.java
index f7e645070..0d19d89f7 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedAsyncTaskLoader.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedAsyncTaskLoader.java
@@ -11,11 +11,14 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 
 /**
- * The shadow {@link AsyncTaskLoader} for {@link LooperMode.Mode.PAUSED}.
+ * The shadow {@link AsyncTaskLoader} for {@link LooperMode.Mode#PAUSED}.
  *
- * <p>In {@link LooperMode.Mode.PAUSED} mode, Robolectric just uses the real AsyncTaskLoader for
+ * <p>In {@link LooperMode.Mode#PAUSED} mode, Robolectric just uses the real AsyncTaskLoader for
  * now.
+ *
+ * @deprecated {@link AsyncTaskLoader} is deprecated in the Android SDK.
  */
+@Deprecated
 @Implements(
     value = AsyncTaskLoader.class,
     shadowPicker = ShadowAsyncTaskLoader.Picker.class,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedChoreographer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedChoreographer.java
index 5fa5bc3e3..f4e802221 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedChoreographer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedChoreographer.java
@@ -28,9 +28,9 @@ import org.robolectric.versioning.AndroidVersions.T;
 import org.robolectric.versioning.AndroidVersions.U;
 
 /**
- * A {@link Choreographer} shadow for {@link LooperMode.Mode.PAUSED}.
+ * A {@link Choreographer} shadow for {@link LooperMode.Mode#PAUSED}.
  *
- * <p>This shadow is largely a no-op. In {@link LooperMode.Mode.PAUSED} mode, the shadowing is done
+ * <p>This shadow is largely a no-op. In {@link LooperMode.Mode#PAUSED} mode, the shadowing is done
  * at a lower level via {@link ShadowDisplayEventReceiver}.
  *
  * <p>This class should not be referenced directly - use {@link ShadowChoreographer} instead.
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java
index d5ed7ea5f..a185245cf 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java
@@ -14,18 +14,19 @@ import android.os.MessageQueue.IdleHandler;
 import android.os.SystemClock;
 import android.util.Log;
 import com.google.common.annotations.VisibleForTesting;
-import com.google.common.base.Preconditions;
 import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
+import java.util.Objects;
 import java.util.Set;
 import java.util.WeakHashMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nonnull;
 import javax.annotation.concurrent.GuardedBy;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
@@ -43,8 +44,7 @@ import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
 
 /**
- * The shadow Looper for {@link LooperMode.Mode.PAUSED and @link
- * LooperMode.Mode.INSTRUMENTATION_TEST}.
+ * The shadow Looper for {@link LooperMode.Mode#PAUSED and {@link LooperMode.Mode#INSTRUMENTATION_TEST}.
  *
  * <p>This shadow differs from the legacy {@link ShadowLegacyLooper} in the following ways:\ - Has
  * no connection to {@link org.robolectric.util.Scheduler}. Its APIs are standalone - The main
@@ -64,8 +64,8 @@ import org.robolectric.util.reflector.Static;
 public final class ShadowPausedLooper extends ShadowLooper {
 
   // Keep reference to all created Loopers so they can be torn down after test
-  private static Set<Looper> loopingLoopers =
-      Collections.synchronizedSet(Collections.newSetFromMap(new WeakHashMap<Looper, Boolean>()));
+  private static final Set<Looper> loopingLoopers =
+      Collections.synchronizedSet(Collections.newSetFromMap(new WeakHashMap<>()));
 
   private static boolean ignoreUncaughtExceptions = false;
 
@@ -472,7 +472,7 @@ public final class ShadowPausedLooper extends ShadowLooper {
     try {
       reflector(LooperReflector.class).loop();
     } catch (Exception e) {
-      Looper realLooper = Preconditions.checkNotNull(Looper.myLooper());
+      Looper realLooper = Objects.requireNonNull(Looper.myLooper());
       ShadowPausedMessageQueue shadowQueue = Shadow.extract(realLooper.getQueue());
 
       if (ignoreUncaughtExceptions) {
@@ -709,7 +709,7 @@ public final class ShadowPausedLooper extends ShadowLooper {
     private final LinkedBlockingQueue<Runnable> executionQueue = new LinkedBlockingQueue<>();
 
     @Override
-    public void execute(Runnable runnable) {
+    public void execute(@Nonnull Runnable runnable) {
       shadowQueue().checkQueueState();
       executionQueue.add(runnable);
     }
@@ -762,7 +762,7 @@ public final class ShadowPausedLooper extends ShadowLooper {
     }
 
     @Override
-    public void execute(Runnable runnable) {
+    public void execute(@Nonnull Runnable runnable) {
       if (!handler.post(runnable)) {
         throw new IllegalStateException(
             String.format("post to %s failed. Is handler thread dead?", handler));
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessage.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessage.java
index dd703bb0d..63c2ce367 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessage.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessage.java
@@ -10,7 +10,7 @@ import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.RealObject;
 
 /**
- * The shadow {@link Message} for {@link LooperMode.Mode.PAUSED}.
+ * The shadow {@link Message} for {@link LooperMode.Mode#PAUSED}.
  *
  * <p>This class should not be referenced directly. Use {@link ShadowMessage} instead.
  */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java
index dd4d5535a..2c90d1589 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java
@@ -30,7 +30,7 @@ import org.robolectric.util.reflector.ForType;
 import org.robolectric.versioning.AndroidVersions.V;
 
 /**
- * The shadow {@link} MessageQueue} for {@link LooperMode.Mode.PAUSED}
+ * The shadow {@link} MessageQueue} for {@link LooperMode.Mode#PAUSED}
  *
  * <p>This class should not be referenced directly. Use {@link ShadowMessageQueue} instead.
  */
@@ -41,8 +41,8 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
   @RealObject private MessageQueue realQueue;
 
   // just use this class as the native object
-  private static NativeObjRegistry<ShadowPausedMessageQueue> nativeQueueRegistry =
-      new NativeObjRegistry<ShadowPausedMessageQueue>(ShadowPausedMessageQueue.class);
+  private static final NativeObjRegistry<ShadowPausedMessageQueue> nativeQueueRegistry =
+      new NativeObjRegistry<>(ShadowPausedMessageQueue.class);
   private boolean isPolling = false;
   private ShadowPausedSystemClock.Listener clockListener;
   private Exception uncaughtException = null;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedSystemClock.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedSystemClock.java
index d9afb7f1d..13b7b29f0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedSystemClock.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedSystemClock.java
@@ -12,6 +12,7 @@ import javax.annotation.concurrent.GuardedBy;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.Resetter;
 
 /**
@@ -20,7 +21,7 @@ import org.robolectric.annotation.Resetter;
  * <p>In this variant, System times (both elapsed realtime and uptime) are controlled by this class.
  * The current times are fixed in place. You can manually advance both by calling {@link
  * SystemClock#setCurrentTimeMillis(long)} or just advance elapsed realtime only by calling {@link
- * deepSleep(long)}.
+ * #deepSleep(long)}.
  *
  * <p>{@link SystemClock#uptimeMillis()} and {@link SystemClock#currentThreadTimeMillis()} are
  * identical.
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java
index d664923c3..7551f331a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java
@@ -24,7 +24,6 @@ import android.content.Intent;
 import android.content.IntentSender;
 import android.os.Bundle;
 import android.os.Handler;
-import android.os.IBinder;
 import android.os.Parcel;
 import android.os.Parcelable.Creator;
 import java.util.ArrayList;
@@ -243,13 +242,7 @@ public class ShadowPendingIntent {
     if (isActivity()) {
       for (Intent intentToSend : intentsToSend) {
         shadowInstrumentation.execStartActivity(
-            context,
-            (IBinder) null,
-            (IBinder) null,
-            (Activity) null,
-            intentToSend,
-            requestCode,
-            options);
+            context, null, null, (Activity) null, intentToSend, requestCode, options);
       }
     } else if (isBroadcast()) {
       for (Intent intentToSend : intentsToSend) {
@@ -425,7 +418,7 @@ public class ShadowPendingIntent {
   }
 
   /**
-   * @return {@true} iff this PendingIntent has been canceled
+   * @return {@code true} iff this PendingIntent has been canceled
    */
   public boolean isCanceled() {
     return canceled;
@@ -503,7 +496,7 @@ public class ShadowPendingIntent {
   public boolean equals(Object o) {
     if (this == o) return true;
     if (o == null || realPendingIntent.getClass() != o.getClass()) return false;
-    ShadowPendingIntent that = Shadow.extract((PendingIntent) o);
+    ShadowPendingIntent that = Shadow.extract(o);
 
     String packageName = savedContext == null ? null : savedContext.getPackageName();
     String thatPackageName = that.savedContext == null ? null : that.savedContext.getPackageName();
@@ -521,10 +514,7 @@ public class ShadowPendingIntent {
       }
     }
 
-    if (this.requestCode != that.requestCode) {
-      return false;
-    }
-    return true;
+    return this.requestCode == that.requestCode;
   }
 
   @Override
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java
index e1a2449b8..5ddee69a1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java
@@ -1,7 +1,7 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.O;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.graphics.Bitmap;
@@ -102,7 +102,7 @@ public class ShadowPixelCopy {
       throw new IllegalArgumentException("sourceRect is empty");
     }
 
-    View view = findViewForSurface(checkNotNull(source));
+    View view = findViewForSurface(requireNonNull(source));
     Rect adjustedSrcRect = null;
     if (srcRect != null) {
       adjustedSrcRect = new Rect(srcRect);
@@ -121,6 +121,7 @@ public class ShadowPixelCopy {
       Consumer</*android.view.PixelCopy$Result*/ ?> listener) {
     PixelCopy.Request request = (PixelCopy.Request) requestObject;
     RequestReflector requestReflector = reflector(RequestReflector.class, request);
+    //noinspection Convert2Lambda
     OnPixelCopyFinishedListener legacyListener =
         new OnPixelCopyFinishedListener() {
           @Override
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java
index 03b09eb8e..726f701de 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java
@@ -16,9 +16,9 @@ import static java.util.Comparator.comparing;
 import static java.util.stream.Collectors.toCollection;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
+import android.annotation.RequiresApi;
 import android.annotation.RequiresPermission;
 import android.annotation.SystemApi;
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.Intent;
 import android.os.Binder;
@@ -87,7 +87,7 @@ public class ShadowPowerManager {
   private static boolean lowPowerStandbyEnabled = false;
   private static boolean lowPowerStandbySupported = false;
   private static boolean exemptFromLowPowerStandby = false;
-  private static final Set<String> allowedFeatures = new HashSet<String>();
+  private static final Set<String> allowedFeatures = new HashSet<>();
 
   @Implementation
   protected PowerManager.WakeLock newWakeLock(int flags, String tag) {
@@ -140,7 +140,7 @@ public class ShadowPowerManager {
     isPowerSaveMode = powerSaveMode;
   }
 
-  private Map<Integer, Boolean> supportedWakeLockLevels = new HashMap<>();
+  private final Map<Integer, Boolean> supportedWakeLockLevels = new HashMap<>();
 
   @Implementation
   protected boolean isWakeLockLevelSupported(int level) {
@@ -161,7 +161,7 @@ public class ShadowPowerManager {
 
   /** Sets the value returned by {@link #isDeviceIdleMode()}. */
   public void setIsDeviceIdleMode(boolean isDeviceIdleMode) {
-    this.isDeviceIdleMode = isDeviceIdleMode;
+    ShadowPowerManager.isDeviceIdleMode = isDeviceIdleMode;
     getContext().sendBroadcast(new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED));
   }
 
@@ -190,7 +190,7 @@ public class ShadowPowerManager {
 
   /**
    * Returns how location features should behave when battery saver is on. When battery saver is
-   * off, this will always return {@link #LOCATION_MODE_NO_CHANGE}.
+   * off, this will always return {@link PowerManager#LOCATION_MODE_NO_CHANGE}.
    */
   @Implementation(minSdk = P)
   @PowerManager.LocationPowerSaveMode
@@ -209,7 +209,7 @@ public class ShadowPowerManager {
     checkState(
         locationMode <= PowerManager.MAX_LOCATION_MODE,
         "Location Power Save Mode must be no more than " + PowerManager.MAX_LOCATION_MODE);
-    this.locationMode = locationMode;
+    ShadowPowerManager.locationMode = locationMode;
   }
 
   /** This function returns the current thermal status of the device. */
@@ -225,12 +225,12 @@ public class ShadowPowerManager {
     checkState(
         listener instanceof PowerManager.OnThermalStatusChangedListener,
         "Listener must implement PowerManager.OnThermalStatusChangedListener");
-    this.thermalListeners.add(listener);
+    thermalListeners.add(listener);
   }
 
   /** This function gets listeners for thermal status change. */
   public ImmutableSet<Object> getThermalStatusListeners() {
-    return ImmutableSet.copyOf(this.thermalListeners);
+    return ImmutableSet.copyOf(thermalListeners);
   }
 
   /** This function removes a listener for thermal status change. */
@@ -240,7 +240,7 @@ public class ShadowPowerManager {
     checkState(
         listener instanceof PowerManager.OnThermalStatusChangedListener,
         "Listener must implement PowerManager.OnThermalStatusChangedListener");
-    this.thermalListeners.remove(listener);
+    thermalListeners.remove(listener);
   }
 
   /** Sets the value returned by {@link #getCurrentThermalStatus()}. */
@@ -251,7 +251,7 @@ public class ShadowPowerManager {
     checkState(
         thermalStatus <= PowerManager.THERMAL_STATUS_SHUTDOWN,
         "Thermal status must be no more than " + PowerManager.THERMAL_STATUS_SHUTDOWN);
-    this.thermalStatus = thermalStatus;
+    ShadowPowerManager.thermalStatus = thermalStatus;
     for (Object listener : thermalListeners) {
       ((PowerManager.OnThermalStatusChangedListener) listener)
           .onThermalStatusChanged(thermalStatus);
@@ -311,11 +311,11 @@ public class ShadowPowerManager {
   @Implementation(minSdk = M)
   protected boolean isIgnoringBatteryOptimizations(String packageName) {
     Boolean result = ignoringBatteryOptimizations.get(packageName);
-    return result == null ? false : result;
+    return result != null && result;
   }
 
   public void setIgnoringBatteryOptimizations(String packageName, boolean value) {
-    ignoringBatteryOptimizations.put(packageName, Boolean.valueOf(value));
+    ignoringBatteryOptimizations.put(packageName, value);
   }
 
   /**
@@ -329,8 +329,8 @@ public class ShadowPowerManager {
   @Implementation(minSdk = S)
   protected void setBatteryDischargePrediction(
       @Nonnull Duration timeRemaining, boolean isPersonalized) {
-    this.batteryDischargePrediction = timeRemaining;
-    this.isBatteryDischargePredictionPersonalized = isPersonalized;
+    batteryDischargePrediction = timeRemaining;
+    isBatteryDischargePredictionPersonalized = isPersonalized;
   }
 
   /**
@@ -345,7 +345,7 @@ public class ShadowPowerManager {
   @Nullable
   @Implementation(minSdk = S)
   protected Duration getBatteryDischargePrediction() {
-    return this.batteryDischargePrediction;
+    return batteryDischargePrediction;
   }
 
   /**
@@ -358,7 +358,7 @@ public class ShadowPowerManager {
    */
   @Implementation(minSdk = S)
   protected boolean isBatteryDischargePredictionPersonalized() {
-    return this.isBatteryDischargePredictionPersonalized;
+    return isBatteryDischargePredictionPersonalized;
   }
 
   @Implementation
@@ -386,12 +386,12 @@ public class ShadowPowerManager {
 
   /** Sets the value returned by {@link #isAmbientDisplayAvailable()}. */
   public void setAmbientDisplayAvailable(boolean available) {
-    this.isAmbientDisplayAvailable = available;
+    isAmbientDisplayAvailable = available;
   }
 
   /** Sets the value returned by {@link #isRebootingUserspaceSupported()}. */
   public void setIsRebootingUserspaceSupported(boolean supported) {
-    this.isRebootingUserspaceSupported = supported;
+    isRebootingUserspaceSupported = supported;
   }
 
   /**
@@ -490,7 +490,7 @@ public class ShadowPowerManager {
 
     @Implementation
     protected synchronized void acquire(long timeout) {
-      Long timeoutMillis = timeout + SystemClock.elapsedRealtime();
+      long timeoutMillis = timeout + SystemClock.elapsedRealtime();
       if (timeoutMillis > 0) {
         acquireInternal(Optional.of(timeoutMillis));
       } else {
@@ -595,9 +595,9 @@ public class ShadowPowerManager {
     return lowPowerStandbySupported;
   }
 
-  @TargetApi(TIRAMISU)
+  @RequiresApi(TIRAMISU)
   public void setLowPowerStandbySupported(boolean lowPowerStandbySupported) {
-    this.lowPowerStandbySupported = lowPowerStandbySupported;
+    ShadowPowerManager.lowPowerStandbySupported = lowPowerStandbySupported;
   }
 
   @Implementation(minSdk = TIRAMISU)
@@ -607,7 +607,7 @@ public class ShadowPowerManager {
 
   @Implementation(minSdk = TIRAMISU)
   public void setLowPowerStandbyEnabled(boolean lowPowerStandbyEnabled) {
-    this.lowPowerStandbyEnabled = lowPowerStandbyEnabled;
+    ShadowPowerManager.lowPowerStandbyEnabled = lowPowerStandbyEnabled;
   }
 
   @Implementation(minSdk = UPSIDE_DOWN_CAKE)
@@ -618,7 +618,7 @@ public class ShadowPowerManager {
     return allowedFeatures.contains(feature);
   }
 
-  @TargetApi(UPSIDE_DOWN_CAKE)
+  @RequiresApi(UPSIDE_DOWN_CAKE)
   public void addAllowedInLowPowerStandby(String feature) {
     allowedFeatures.add(feature);
   }
@@ -631,9 +631,9 @@ public class ShadowPowerManager {
     return exemptFromLowPowerStandby;
   }
 
-  @TargetApi(UPSIDE_DOWN_CAKE)
+  @RequiresApi(UPSIDE_DOWN_CAKE)
   public void setExemptFromLowPowerStandby(boolean exemptFromLowPowerStandby) {
-    this.exemptFromLowPowerStandby = exemptFromLowPowerStandby;
+    ShadowPowerManager.exemptFromLowPowerStandby = exemptFromLowPowerStandby;
   }
 
   @Implementation(minSdk = UPSIDE_DOWN_CAKE)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowProcess.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowProcess.java
index 40a202378..b08431b4b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowProcess.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowProcess.java
@@ -19,7 +19,7 @@ public class ShadowProcess {
   private static int pid;
   private static final int UID = getRandomApplicationUid();
   private static Integer uidOverride;
-  private static int tid = getRandomApplicationUid();
+  private static final int tid = getRandomApplicationUid();
   private static final Object threadPrioritiesLock = new Object();
   private static final Object killedProcessesLock = new Object();
   // The range of thread priority values is specified by
@@ -28,7 +28,7 @@ public class ShadowProcess {
   private static final int THREAD_PRIORITY_LOWEST = 19;
 
   @GuardedBy("threadPrioritiesLock")
-  private static final Map<Integer, Integer> threadPriorities = new HashMap<Integer, Integer>();
+  private static final Map<Integer, Integer> threadPriorities = new HashMap<>();
 
   @GuardedBy("killedProcessesLock")
   private static final Set<Integer> killedProcesses = new HashSet<>();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRemoteAccessibilityInputConnection.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRemoteAccessibilityInputConnection.java
new file mode 100644
index 000000000..21d3df558
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRemoteAccessibilityInputConnection.java
@@ -0,0 +1,111 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.TIRAMISU;
+
+import android.util.Pair;
+import android.view.KeyEvent;
+import android.view.inputmethod.SurroundingText;
+import android.view.inputmethod.TextAttribute;
+import com.android.internal.inputmethod.RemoteAccessibilityInputConnection;
+import com.google.common.collect.ImmutableList;
+import java.util.ArrayList;
+import java.util.List;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowAccessibilityInputConnection.CommitTextArgs;
+import org.robolectric.shadows.ShadowAccessibilityInputConnection.SurroundingTextArgs;
+
+/** Shadow for RemoteAccessibilityInputConnection, used by AccessibilityInputConnection. */
+@Implements(
+    value = RemoteAccessibilityInputConnection.class,
+    minSdk = TIRAMISU,
+    isInAndroidSdk = false)
+public class ShadowRemoteAccessibilityInputConnection {
+
+  private SurroundingText surroundingTextToReturn = null;
+
+  private final List<Integer> contextMenuActions = new ArrayList<>();
+  private final List<Integer> editorActions = new ArrayList<>();
+  private final List<KeyEvent> keyEvents = new ArrayList<>();
+  private final List<Pair<Integer, Integer>> setSelections = new ArrayList<>();
+  private final List<SurroundingTextArgs> surroundingTextArguments = new ArrayList<>();
+  private final List<CommitTextArgs> commitTextArguments = new ArrayList<>();
+
+  @Implementation(minSdk = TIRAMISU)
+  protected void commitText(CharSequence text, int newCursorPosition, TextAttribute textAttribute) {
+    commitTextArguments.add(CommitTextArgs.create(text, newCursorPosition, textAttribute));
+  }
+
+  @Implementation(minSdk = TIRAMISU)
+  protected SurroundingText getSurroundingText(int beforeLength, int afterLength, int flags) {
+    surroundingTextArguments.add(SurroundingTextArgs.create(beforeLength, afterLength, flags));
+    return surroundingTextToReturn;
+  }
+
+  @Implementation(minSdk = TIRAMISU)
+  protected void performContextMenuAction(int id) {
+    contextMenuActions.add(id);
+  }
+
+  @Implementation(minSdk = TIRAMISU)
+  protected void performEditorAction(int editorAction) {
+    editorActions.add(editorAction);
+  }
+
+  @Implementation(minSdk = TIRAMISU)
+  protected void sendKeyEvent(KeyEvent event) {
+    keyEvents.add(event);
+  }
+
+  @Implementation(minSdk = TIRAMISU)
+  protected void setSelection(int start, int end) {
+    setSelections.add(Pair.create(start, end));
+  }
+
+  /**
+   * Returns the list of arguments passed to {@link #commitText(CharSequence, int, TextAttribute)}.
+   */
+  List<CommitTextArgs> getCommitTextArguments() {
+    return ImmutableList.copyOf(commitTextArguments);
+  }
+
+  /** Sets the surrounding text to be returned by {@link #getSurroundingText(int, int, int)}. */
+  void setSurroundingText(SurroundingText surroundingText) {
+    this.surroundingTextToReturn = surroundingText;
+  }
+
+  /** Returns the list of arguments passed to {@link #getSurroundingText(int, int, int)}. */
+  List<SurroundingTextArgs> getSurroundingTextArguments() {
+    return ImmutableList.copyOf(surroundingTextArguments);
+  }
+
+  /**
+   * Returns the list of context menu actions performed on this input connection in the order they
+   * were received..
+   */
+  List<Integer> getContextMenuActions() {
+    return ImmutableList.copyOf(contextMenuActions);
+  }
+
+  /**
+   * Returns the list of editor actions performed on this input connection in the order they were
+   * received..
+   */
+  List<Integer> getEditorActions() {
+    return ImmutableList.copyOf(editorActions);
+  }
+
+  /**
+   * Returns the list of key events sent to this input connection in the order they were received.
+   */
+  List<KeyEvent> getKeyEvents() {
+    return ImmutableList.copyOf(keyEvents);
+  }
+
+  /**
+   * Returns the list of selections sent to this input connection in the order they were received.
+   */
+  List<Pair<Integer, Integer>> getSetSelections() {
+    return ImmutableList.copyOf(setSelections);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRemoteCallbackList.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRemoteCallbackList.java
index b6b7d5227..92804dc45 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRemoteCallbackList.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRemoteCallbackList.java
@@ -94,7 +94,7 @@ public class ShadowRemoteCallbackList<E extends IInterface> {
         throw new IllegalStateException("beginBroadcast() called while already in a broadcast");
       }
       final int N = broadcastCount = callbacks.size();
-      if (N <= 0) {
+      if (N == 0) {
         return 0;
       }
       Object[] active = activeBroadcast;
@@ -134,7 +134,7 @@ public class ShadowRemoteCallbackList<E extends IInterface> {
     broadcastCount = -1;
   }
 
-  @Implementation(minSdk = 17)
+  @Implementation
   protected int getRegisteredCallbackCount() {
     return callbacks.size();
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRemoteViewsAdapter.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRemoteViewsAdapter.java
new file mode 100644
index 000000000..bbab2545c
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRemoteViewsAdapter.java
@@ -0,0 +1,321 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.P;
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.annotation.RequiresApi;
+import android.app.ActivityThread;
+import android.app.AppComponentFactory;
+import android.app.LoadedApk;
+import android.app.Service;
+import android.content.Context;
+import android.content.Intent;
+import android.database.DataSetObserver;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.BaseAdapter;
+import android.widget.RemoteViews;
+import android.widget.RemoteViewsAdapter;
+import android.widget.RemoteViewsService;
+import android.widget.RemoteViewsService.RemoteViewsFactory;
+import javax.annotation.Nullable;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ServiceController;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.reflector.Direct;
+import org.robolectric.util.reflector.ForType;
+
+/** Shadow class for {@link RemoteViewsAdapter}. */
+@Implements(value = RemoteViewsAdapter.class, isInAndroidSdk = false)
+// The framework code for RemoteViewsAdapter does not work well in a Robolectric environment.
+// It uses multiple Handler threads and tries to bind to a service, none of which work well in
+// Robolectric.
+public class ShadowRemoteViewsAdapter {
+
+  private static final String TAG = "ShadowRemoteViewsAdapter";
+
+  @RealObject private RemoteViewsAdapter realRemoteViewsAdapter;
+
+  private BaseAdapter adapter;
+  private boolean hasAttemptedToInitAdapter = false;
+
+  @Implementation
+  protected boolean isDataReady() {
+    BaseAdapter adapter = getAdapter();
+    if (adapter != null) {
+      return true;
+    } else {
+      return reflector(RemoteViewsAdapterReflector.class, realRemoteViewsAdapter).isDataReady();
+    }
+  }
+
+  @Implementation
+  protected int getCount() {
+    BaseAdapter adapter = getAdapter();
+    if (adapter != null) {
+      return adapter.getCount();
+    } else {
+      return reflector(RemoteViewsAdapterReflector.class, realRemoteViewsAdapter).getCount();
+    }
+  }
+
+  @Implementation
+  protected Object getItem(int position) {
+    BaseAdapter adapter = getAdapter();
+    if (adapter != null) {
+      return adapter.getItem(position);
+    } else {
+      return reflector(RemoteViewsAdapterReflector.class, realRemoteViewsAdapter).getItem(position);
+    }
+  }
+
+  @Implementation
+  protected long getItemId(int position) {
+    BaseAdapter adapter = getAdapter();
+    if (adapter != null) {
+      return adapter.getItemId(position);
+    } else {
+      return reflector(RemoteViewsAdapterReflector.class, realRemoteViewsAdapter)
+          .getItemId(position);
+    }
+  }
+
+  @Implementation
+  protected boolean hasStableIds() {
+    BaseAdapter adapter = getAdapter();
+    if (adapter != null) {
+      return adapter.hasStableIds();
+    } else {
+      return reflector(RemoteViewsAdapterReflector.class, realRemoteViewsAdapter).hasStableIds();
+    }
+  }
+
+  @Implementation
+  protected int getItemViewType(int position) {
+    BaseAdapter adapter = getAdapter();
+    if (adapter != null) {
+      return adapter.getItemViewType(position);
+    } else {
+      return reflector(RemoteViewsAdapterReflector.class, realRemoteViewsAdapter)
+          .getItemViewType(position);
+    }
+  }
+
+  @Implementation
+  protected View getView(int position, View convertView, ViewGroup parent) {
+    BaseAdapter adapter = getAdapter();
+    if (adapter != null) {
+      return adapter.getView(position, convertView, parent);
+    } else {
+      return reflector(RemoteViewsAdapterReflector.class, realRemoteViewsAdapter)
+          .getView(position, convertView, parent);
+    }
+  }
+
+  @Implementation
+  protected int getViewTypeCount() {
+    BaseAdapter adapter = getAdapter();
+    if (adapter != null) {
+      return adapter.getViewTypeCount();
+    } else {
+      return reflector(RemoteViewsAdapterReflector.class, realRemoteViewsAdapter)
+          .getViewTypeCount();
+    }
+  }
+
+  @Implementation
+  protected boolean isEmpty() {
+    BaseAdapter adapter = getAdapter();
+    if (adapter != null) {
+      return adapter.isEmpty();
+    } else {
+      return reflector(RemoteViewsAdapterReflector.class, realRemoteViewsAdapter).isEmpty();
+    }
+  }
+
+  @Implementation
+  protected void notifyDataSetChanged() {
+    BaseAdapter adapter = getAdapter();
+    if (adapter != null) {
+      adapter.notifyDataSetChanged();
+    } else {
+      reflector(RemoteViewsAdapterReflector.class, realRemoteViewsAdapter).notifyDataSetChanged();
+    }
+  }
+
+  @Nullable
+  private BaseAdapter getAdapter() {
+    if (adapter == null) {
+      if (hasAttemptedToInitAdapter) {
+        return null;
+      } else {
+        adapter = createAdapterFromIntent(realRemoteViewsAdapter.getRemoteViewsServiceIntent());
+        hasAttemptedToInitAdapter = true;
+      }
+    }
+    return adapter;
+  }
+
+  @Nullable
+  private static BaseAdapter createAdapterFromIntent(Intent intent) {
+    Class<?> clazz = maybeExtractClass(intent);
+    if (clazz == null) {
+      return null;
+    }
+    try {
+      RemoteViewsService remoteViewsService = createRemoteViewsService(intent, clazz);
+      RemoteViewsFactory remoteViewsFactory = remoteViewsService.onGetViewFactory(intent);
+      remoteViewsFactory.onCreate();
+      return convertToAdapter(remoteViewsFactory);
+    } catch (RuntimeException e) {
+      Log.e(TAG, "Could not instantiate RemoteViewsService for class " + clazz, e);
+      return null;
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  private static RemoteViewsService createRemoteViewsService(Intent intent, Class<?> clazz) {
+    return buildService((Class<? extends RemoteViewsService>) clazz, intent).create().bind().get();
+  }
+
+  private static Class<?> maybeExtractClass(Intent intent) {
+    Class<?> clazz;
+    try {
+      clazz = Class.forName(intent.getComponent().getClassName());
+    } catch (ClassNotFoundException e) {
+      Log.e(TAG, "Invalid class name provided for the intent.", e);
+      return null;
+    }
+    return clazz;
+  }
+
+  private static BaseAdapter convertToAdapter(
+      RemoteViewsService.RemoteViewsFactory remoteViewsFactory) {
+    return new BaseAdapter() {
+      @Override
+      public void registerDataSetObserver(DataSetObserver observer) {}
+
+      @Override
+      public void unregisterDataSetObserver(DataSetObserver observer) {}
+
+      @Override
+      public int getCount() {
+        return remoteViewsFactory.getCount();
+      }
+
+      @Override
+      public Object getItem(int position) {
+        return remoteViewsFactory.getViewAt(position);
+      }
+
+      @Override
+      public long getItemId(int position) {
+        return remoteViewsFactory.getItemId(position);
+      }
+
+      @Override
+      public boolean hasStableIds() {
+        return remoteViewsFactory.hasStableIds();
+      }
+
+      @Override
+      public View getView(int position, View convertView, ViewGroup parent) {
+        RemoteViews remoteViews = remoteViewsFactory.getViewAt(position);
+        View view = remoteViews.apply(parent.getContext(), parent);
+        remoteViews.reapply(parent.getContext(), view);
+        return view;
+      }
+
+      @Override
+      public int getViewTypeCount() {
+        return remoteViewsFactory.getViewTypeCount();
+      }
+
+      @Override
+      public boolean isEmpty() {
+        return remoteViewsFactory.getCount() == 0;
+      }
+    };
+  }
+
+  private static <T extends Service> ServiceController<T> buildService(
+      Class<T> serviceClass, Intent intent) {
+    return ServiceController.of(instantiateService(serviceClass, intent), intent);
+  }
+
+  @SuppressWarnings({"NewApi", "unchecked"})
+  private static <T extends Service> T instantiateService(Class<T> serviceClass, Intent intent) {
+    if (RuntimeEnvironment.getApiLevel() >= P) {
+      final LoadedApk loadedApk = getLoadedApk();
+      AppComponentFactory factory = getAppComponentFactory(loadedApk);
+      if (factory != null) {
+        try {
+          Service instance =
+              factory.instantiateService(
+                  loadedApk.getClassLoader(), serviceClass.getName(), intent);
+          if (instance != null && serviceClass.isAssignableFrom(instance.getClass())) {
+            return (T) instance;
+          }
+        } catch (ReflectiveOperationException e) {
+          Log.e(TAG, "Failed to instantiate Service using AppComponentFactory", e);
+        }
+      }
+    }
+    return ReflectionHelpers.callConstructor(serviceClass);
+  }
+
+  @Nullable
+  @RequiresApi(api = P)
+  private static AppComponentFactory getAppComponentFactory(final LoadedApk loadedApk) {
+    if (RuntimeEnvironment.getApiLevel() < P) {
+      return null;
+    }
+    if (loadedApk == null || loadedApk.getApplicationInfo().appComponentFactory == null) {
+      return null;
+    }
+    return loadedApk.getAppFactory();
+  }
+
+  private static LoadedApk getLoadedApk() {
+    final ActivityThread activityThread = (ActivityThread) RuntimeEnvironment.getActivityThread();
+    return activityThread.getPackageInfo(
+        activityThread.getApplication().getApplicationInfo(), null, Context.CONTEXT_INCLUDE_CODE);
+  }
+
+  @ForType(RemoteViewsAdapter.class)
+  interface RemoteViewsAdapterReflector {
+    @Direct
+    boolean isDataReady();
+
+    @Direct
+    int getCount();
+
+    @Direct
+    Object getItem(int position);
+
+    @Direct
+    long getItemId(int position);
+
+    @Direct
+    boolean hasStableIds();
+
+    @Direct
+    int getItemViewType(int position);
+
+    @Direct
+    View getView(int position, View convertView, ViewGroup parent);
+
+    @Direct
+    int getViewTypeCount();
+
+    @Direct
+    boolean isEmpty();
+
+    @Direct
+    void notifyDataSetChanged();
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRenderNodeAnimator.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRenderNodeAnimator.java
index cc7c758c1..7f87e61d6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRenderNodeAnimator.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRenderNodeAnimator.java
@@ -25,7 +25,7 @@ public class ShadowRenderNodeAnimator {
   private static final int STATE_FINISHED = 3;
 
   @RealObject RenderNodeAnimator realObject;
-  private Choreographer choreographer = Choreographer.getInstance();
+  private final Choreographer choreographer = Choreographer.getInstance();
   private boolean scheduled = false;
   private long startTime = -1;
   private boolean isEnding = false;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResourcesManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResourcesManager.java
index 21b5fb395..6dd1f52c4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResourcesManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResourcesManager.java
@@ -21,7 +21,10 @@ public class ShadowResourcesManager {
     reflector(_ResourcesManager_.class).setResourcesManager(null);
   }
 
-  /** Exposes {@link ResourcesManager#applyCompatConfigurationLocked(int, Configuration)}. */
+  /**
+   * Exposes {@link ResourcesManager#applyConfigurationToResources(Configuration,
+   * CompatibilityInfo)}.
+   */
   public boolean callApplyConfigurationToResourcesLocked(
       Configuration configuration, CompatibilityInfo compatibilityInfo) {
     return reflector(_ResourcesManager_.class, realResourcesManager)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRestrictionsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRestrictionsManager.java
index d4c6f28ce..c11dc3bad 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRestrictionsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRestrictionsManager.java
@@ -21,7 +21,7 @@ public class ShadowRestrictionsManager {
    * RestrictionsManager#getApplicationRestrictions()}.
    */
   public void setApplicationRestrictions(Bundle applicationRestrictions) {
-    this.applicationRestrictions = applicationRestrictions;
+    ShadowRestrictionsManager.applicationRestrictions = applicationRestrictions;
   }
 
   /**
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRoleManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRoleManager.java
index 429181563..ce363191d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRoleManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRoleManager.java
@@ -1,17 +1,25 @@
 package org.robolectric.shadows;
 
+import static java.util.Objects.requireNonNull;
 import static org.robolectric.shadow.api.Shadow.invokeConstructor;
-import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
 
+import android.annotation.CallbackExecutor;
 import android.app.role.IRoleManager;
+import android.app.role.OnRoleHoldersChangedListener;
 import android.app.role.RoleManager;
 import android.content.Context;
 import android.content.pm.PackageManager;
 import android.os.Build;
+import android.os.UserHandle;
 import com.android.internal.util.Preconditions;
-import java.util.Arrays;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.function.Consumer;
 import javax.annotation.Nonnull;
@@ -20,6 +28,7 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.annotation.Resetter;
+import org.robolectric.util.ReflectionHelpers;
 
 /** A shadow implementation of {@link android.app.role.RoleManager}. */
 @Implements(value = RoleManager.class, minSdk = Build.VERSION_CODES.Q)
@@ -28,25 +37,25 @@ public class ShadowRoleManager {
   @RealObject protected RoleManager roleManager;
 
   // See RoleService implementation
-  private static final String[] DEFAULT_APPLICATION_ROLES = {
-    RoleManager.ROLE_ASSISTANT,
-    RoleManager.ROLE_BROWSER,
-    RoleManager.ROLE_CALL_REDIRECTION,
-    RoleManager.ROLE_CALL_SCREENING,
-    RoleManager.ROLE_DIALER,
-    RoleManager.ROLE_HOME,
-    RoleManager.ROLE_SMS,
-  };
+  private static final ImmutableSet<String> DEFAULT_APPLICATION_ROLES =
+      ImmutableSet.of(
+          RoleManager.ROLE_ASSISTANT,
+          RoleManager.ROLE_BROWSER,
+          RoleManager.ROLE_CALL_REDIRECTION,
+          RoleManager.ROLE_CALL_SCREENING,
+          RoleManager.ROLE_DIALER,
+          RoleManager.ROLE_HOME,
+          RoleManager.ROLE_SMS);
 
   private Context context;
 
-  // Roles that exist but are currently unavailable have their value set to {@code null}.
-  private static final Map<String, String> roleToHolder = new HashMap<>();
-
   @Implementation(maxSdk = Build.VERSION_CODES.R)
   protected void __constructor__(Context context) {
     this.context = context;
-    invokeConstructor(RoleManager.class, roleManager, from(Context.class, context));
+    invokeConstructor(
+        RoleManager.class,
+        roleManager,
+        ReflectionHelpers.ClassParameter.from(Context.class, context));
   }
 
   @Implementation(minSdk = Build.VERSION_CODES.S)
@@ -55,22 +64,96 @@ public class ShadowRoleManager {
     invokeConstructor(
         RoleManager.class,
         roleManager,
-        from(Context.class, context),
-        from(IRoleManager.class, service));
+        ReflectionHelpers.ClassParameter.from(Context.class, context),
+        ReflectionHelpers.ClassParameter.from(IRoleManager.class, service));
+  }
+
+  private static final Map<UserHandle, RoleUserState> userStates = new HashMap<>();
+
+  private static class RoleUserState {
+    final Map<String, Set<String>> roleHolders = new HashMap<>();
+    final Map<OnRoleHoldersChangedListener, Executor> roleHoldersListener = new HashMap<>();
+    final UserHandle user;
+
+    RoleUserState(UserHandle u) {
+      user = u;
+    }
+
+    void addRoleHolder(String roleName, String roleHolder) {
+      Set<String> holders = roleHolders.computeIfAbsent(roleName, (String k) -> new HashSet<>());
+      if (!roleHolder.isEmpty()) {
+        holders.add(roleHolder);
+      }
+
+      broadcastRoleHoldersChanged(roleName);
+    }
+
+    void removeRoleHolder(String roleName, String roleHolder) {
+      Preconditions.checkArgument(
+          roleHolders.get(roleName) != null, "the supplied roleName was never added for this user");
+      Preconditions.checkArgument(
+          roleHolder.isEmpty() || roleHolders.get(roleName).contains(roleHolder),
+          "the supplied roleHolder does not hold this role for this user.");
+
+      if (!roleHolder.isEmpty()) {
+        roleHolders.get(roleName).remove(roleHolder);
+      }
+
+      if (roleHolders.get(roleName).isEmpty()) {
+        roleHolders.remove(roleName);
+      }
+
+      broadcastRoleHoldersChanged(roleName);
+    }
+
+    private void broadcastRoleHoldersChanged(String roleName) {
+      roleHoldersListener.forEach(
+          (listener, executor) ->
+              executor.execute(() -> listener.onRoleHoldersChanged(roleName, user)));
+
+      getUserState(UserHandle.ALL)
+          .roleHoldersListener
+          .forEach(
+              (listener, executor) ->
+                  executor.execute(() -> listener.onRoleHoldersChanged(roleName, user)));
+    }
+
+    static RoleUserState getUserState(UserHandle u) {
+      return userStates.computeIfAbsent(u, RoleUserState::new);
+    }
   }
 
   /**
-   * Check whether the calling application is holding a particular role.
+   * Add a role that would be held by the given {@code roleHolder} app for the specified user.
    *
-   * <p>Callers can add held roles via {@link #addHeldRole(String)}
+   * <p>This method makes the role available as well.
+   */
+  public static void addRoleHolder(
+      @Nonnull String roleName, @Nonnull String roleHolder, @Nonnull UserHandle user) {
+    Preconditions.checkStringNotEmpty(roleName, "roleName cannot be null or empty");
+    requireNonNull(roleHolder);
+    requireNonNull(user);
+    Preconditions.checkArgument(user.getIdentifier() >= UserHandle.USER_SYSTEM, "Invalid user");
+
+    RoleUserState.getUserState(user).addRoleHolder(roleName, roleHolder);
+  }
+
+  /**
+   * Remove a role that would be held by the given {@code roleHolder} app for the specified user.
    *
-   * @param roleName the name of the role to check for
-   * @return whether the calling application is holding the role
+   * <p>This method makes the role unavailable if no other role holders remain.
    */
-  @Implementation
-  protected boolean isRoleHeld(@Nonnull String roleName) {
+  public static void removeRoleHolder(
+      @Nonnull String roleName, @Nonnull String roleHolder, @Nonnull UserHandle user) {
     Preconditions.checkStringNotEmpty(roleName, "roleName cannot be null or empty");
-    return context.getPackageName().equals(roleToHolder.get(roleName));
+    requireNonNull(roleHolder);
+    requireNonNull(user);
+    Preconditions.checkArgument(user.getIdentifier() >= UserHandle.USER_SYSTEM, "Invalid user");
+    Preconditions.checkArgument(
+        RoleUserState.getUserState(user).roleHolders.containsKey(roleName),
+        "the supplied roleName was never added.");
+
+    RoleUserState.getUserState(user).removeRoleHolder(roleName, roleHolder);
   }
 
   /**
@@ -78,56 +161,69 @@ public class ShadowRoleManager {
    * RoleManager#isRoleHeld(String)}.
    *
    * <p>This method makes the role available as well.
+   *
+   * @deprecated - Please use {@link ShadowRoleManager#addRoleHolder}
    */
+  @Deprecated
   public void addHeldRole(@Nonnull String roleName) {
-    addAvailableRole(roleName);
-    roleToHolder.put(roleName, context.getPackageName());
-  }
-
-  /* Remove a role previously added via {@link #addHeldRole(String)}. */
-  public void removeHeldRole(@Nonnull String roleName) {
-    Preconditions.checkArgument(isRoleHeld(roleName), "the supplied roleName was never added.");
-    roleToHolder.put(roleName, null);
+    addRoleHolder(roleName, context.getPackageName(), context.getUser());
   }
 
   /**
-   * Check whether a particular role is available on the device.
+   * Remove a role previously added via {@link #addHeldRole(String)}.
    *
-   * <p>Ideally available roles would be autodetected based on the state of other services or
-   * features present, but for now callers can add available roles via {@link
-   * #addAvailableRole(String)}.
-   *
-   * @param roleName the name of the role to check for
-   * @return whether the role is available
+   * @deprecated - Please use {@link ShadowRoleManager#removeRoleHolder}
    */
-  @Implementation
-  protected boolean isRoleAvailable(@Nonnull String roleName) {
-    Preconditions.checkStringNotEmpty(roleName, "roleName cannot be null or empty");
-    return roleToHolder.containsKey(roleName);
+  @Deprecated
+  public void removeHeldRole(@Nonnull String roleName) {
+    removeRoleHolder(roleName, context.getPackageName(), context.getUser());
   }
 
   /**
    * Add a role that will be recognized as available when invoking {@link
    * RoleManager#isRoleAvailable(String)}.
+   *
+   * @deprecated - Please use {@link ShadowRoleManager#addRoleHolder}
    */
+  @Deprecated
   public void addAvailableRole(@Nonnull String roleName) {
-    Preconditions.checkStringNotEmpty(roleName, "roleName cannot be null or empty");
-    if (!isRoleAvailable(roleName)) {
-      roleToHolder.put(roleName, null);
-    }
+    addRoleHolder(roleName, "", context.getUser());
   }
 
-  /* Remove a role previously added via {@link #addAvailableRole(String)}. */
+  /**
+   * Remove a role previously added via {@link #addAvailableRole(String)}.
+   *
+   * @deprecated - Please use {@link ShadowRoleManager#removeRoleHolder}
+   */
+  @Deprecated
   public void removeAvailableRole(@Nonnull String roleName) {
-    Preconditions.checkArgument(
-        roleToHolder.containsKey(roleName), "the supplied roleName was never added.");
-    roleToHolder.remove(roleName);
+    removeRoleHolder(roleName, "", context.getUser());
+  }
+
+  @Implementation
+  protected boolean isRoleHeld(@Nonnull String roleName) {
+    Preconditions.checkStringNotEmpty(roleName, "roleName cannot be null or empty");
+    return RoleUserState.getUserState(context.getUser())
+        .roleHolders
+        .getOrDefault(roleName, ImmutableSet.of())
+        .contains(context.getPackageName());
+  }
+
+  @Implementation
+  protected boolean isRoleAvailable(@Nonnull String roleName) {
+    Preconditions.checkStringNotEmpty(roleName, "roleName cannot be null or empty");
+    return RoleUserState.getUserState(context.getUser()).roleHolders.containsKey(roleName);
   }
 
   @Nullable
   @Implementation(minSdk = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
   protected String getDefaultApplication(@Nonnull String roleName) {
-    return roleToHolder.get(roleName);
+    return RoleUserState.getUserState(context.getUser())
+        .roleHolders
+        .getOrDefault(roleName, ImmutableSet.of())
+        .stream()
+        .findFirst()
+        .orElse(null);
   }
 
   @Implementation(minSdk = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
@@ -138,12 +234,12 @@ public class ShadowRoleManager {
       @Nonnull Executor executor,
       @Nonnull Consumer<Boolean> callback) {
     Preconditions.checkArgument(
-        Arrays.asList(DEFAULT_APPLICATION_ROLES).contains(roleName),
+        DEFAULT_APPLICATION_ROLES.contains(roleName),
         "the supplied roleName in not a default app.");
     try {
       context.getPackageManager().getPackageInfo(packageName, 0);
       if (isRoleAvailable(roleName)) {
-        roleToHolder.put(roleName, packageName);
+        RoleUserState.getUserState(context.getUser()).addRoleHolder(roleName, packageName);
         executor.execute(() -> callback.accept(true));
         return;
       }
@@ -153,8 +249,47 @@ public class ShadowRoleManager {
     executor.execute(() -> callback.accept(false));
   }
 
+  @Implementation
+  protected void addOnRoleHoldersChangedListenerAsUser(
+      @CallbackExecutor @Nonnull Executor executor,
+      @Nonnull OnRoleHoldersChangedListener listener,
+      @Nonnull UserHandle user) {
+    requireNonNull(executor);
+    requireNonNull(listener);
+    requireNonNull(user);
+
+    RoleUserState.getUserState(user).roleHoldersListener.put(listener, executor);
+  }
+
+  @Implementation
+  protected void removeOnRoleHoldersChangedListenerAsUser(
+      @Nonnull OnRoleHoldersChangedListener listener, @Nonnull UserHandle user) {
+    requireNonNull(listener);
+    requireNonNull(user);
+
+    RoleUserState.getUserState(user).roleHoldersListener.remove(listener);
+  }
+
+  @Implementation
+  protected List<String> getRoleHolders(@Nonnull String roleName) {
+    Preconditions.checkStringNotEmpty(roleName, "roleName cannot be null or empty");
+    return getRoleHoldersAsUser(roleName, context.getUser());
+  }
+
+  @Implementation
+  protected List<String> getRoleHoldersAsUser(@Nonnull String roleName, @Nonnull UserHandle user) {
+    Preconditions.checkStringNotEmpty(roleName, "roleName cannot be null or empty");
+    requireNonNull(user);
+
+    return ImmutableList.copyOf(
+        new ArrayList<>(
+            RoleUserState.getUserState(user)
+                .roleHolders
+                .getOrDefault(roleName, ImmutableSet.of())));
+  }
+
   @Resetter
   public static void reset() {
-    roleToHolder.clear();
+    userStates.clear();
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSQLiteConnection.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSQLiteConnection.java
index a57bf4012..4050b5b0a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSQLiteConnection.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSQLiteConnection.java
@@ -89,7 +89,7 @@ public class ShadowSQLiteConnection {
    * order to improve SQLite performance. The Android default is <code>PERSIST</code> in SDKs <= 25
    * and <code>TRUNCATE</code> in SDKs > 25.
    *
-   * <p>Similarly to {@link setDefaultSyncMode}, if your test expects SQLite rollback journal to be
+   * <p>Similarly to {@link #setDefaultSyncMode}, if your test expects SQLite rollback journal to be
    * synced to disk, use <code>PERSIST</code> or <code>TRUNCATE</code>.
    */
   public static void setDefaultJournalMode(String value) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSensorManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSensorManager.java
index ddd7bbbcd..922f2d0f5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSensorManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSensorManager.java
@@ -2,7 +2,7 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.O;
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import android.hardware.Sensor;
 import android.hardware.SensorDirectChannel;
@@ -33,7 +33,7 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
 /** Shadow for {@link SensorManager}. */
 @Implements(value = SensorManager.class)
 public class ShadowSensorManager {
-  private static AtomicBoolean forceListenersToFail = new AtomicBoolean();
+  private static final AtomicBoolean forceListenersToFail = new AtomicBoolean();
   private static final Multimap<Integer, Sensor> sensorMap =
       Multimaps.synchronizedMultimap(HashMultimap.create());
   private static final Multimap<SensorEventListener, Sensor> listeners =
@@ -59,18 +59,18 @@ public class ShadowSensorManager {
    */
   @Deprecated
   public void addSensor(int sensorType, Sensor sensor) {
-    checkNotNull(sensor);
+    requireNonNull(sensor);
     sensorMap.put(sensorType, sensor);
   }
 
   /** Adds a {@link Sensor} to the {@link SensorManager} */
   public void addSensor(Sensor sensor) {
-    checkNotNull(sensor);
+    requireNonNull(sensor);
     sensorMap.put(sensor.getType(), sensor);
   }
 
   public void removeSensor(Sensor sensor) {
-    checkNotNull(sensor);
+    requireNonNull(sensor);
     sensorMap.get(sensor.getType()).remove(sensor);
   }
 
@@ -122,12 +122,12 @@ public class ShadowSensorManager {
   }
 
   public void setForceListenersToFail(boolean forceListenersToFail) {
-    this.forceListenersToFail.set(forceListenersToFail);
+    ShadowSensorManager.forceListenersToFail.set(forceListenersToFail);
   }
 
   @Implementation
   protected boolean registerListener(SensorEventListener listener, Sensor sensor, int rate) {
-    if (this.forceListenersToFail.get()) {
+    if (forceListenersToFail.get()) {
       return false;
     }
     listeners.put(listener, sensor);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowService.java
index bbaa76e2d..2e97be3c2 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowService.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowService.java
@@ -24,6 +24,7 @@ public class ShadowService extends ShadowContextWrapper {
   private boolean selfStopped = false;
   private boolean foregroundStopped;
   private boolean notificationShouldRemoved;
+  private Exception exceptionForStartForeground = null;
   private int stopSelfId;
   private int stopSelfResultId;
   private int foregroundServiceType;
@@ -55,7 +56,10 @@ public class ShadowService extends ShadowContextWrapper {
   }
 
   @Implementation
-  protected void startForeground(int id, Notification notification) {
+  protected void startForeground(int id, Notification notification) throws Exception {
+    if (exceptionForStartForeground != null) {
+      throw exceptionForStartForeground;
+    }
     foregroundStopped = false;
     lastForegroundNotificationId = id;
     lastForegroundNotification = notification;
@@ -70,7 +74,8 @@ public class ShadowService extends ShadowContextWrapper {
 
   @Implementation(minSdk = Q)
   protected void startForeground(
-      int id, Notification notification, @ForegroundServiceType int foregroundServiceType) {
+      int id, Notification notification, @ForegroundServiceType int foregroundServiceType)
+      throws Exception {
     startForeground(id, notification);
     this.foregroundServiceType = foregroundServiceType;
   }
@@ -153,4 +158,22 @@ public class ShadowService extends ShadowContextWrapper {
   public int getStopSelfResultId() {
     return stopSelfResultId;
   }
+
+  /**
+   * Configures the ShadowService so that calls to startForeground() will throw the given Exception.
+   * It can throw: {@link android.app.ForegroundServiceStartNotAllowedException}:
+   * https://developer.android.com/reference/android/app/ForegroundServiceStartNotAllowedException
+   * Or {@link android.app.InvalidForegroundServiceTypeException}:
+   * https://developer.android.com/reference/android/app/InvalidForegroundServiceTypeException Or
+   * {@link android.app.MissingForegroundServiceTypeException}:
+   * https://developer.android.com/reference/android/app/MissingForegroundServiceTypeException Or
+   * {@link java.lang.SecurityException}:
+   * https://developer.android.com/reference/java/lang/SecurityException
+   *
+   * <p>Details in:
+   * https://developer.android.com/reference/android/app/Service#startForeground(int,%20android.app.Notification)
+   */
+  public void setThrowInStartForeground(Exception e) {
+    exceptionForStartForeground = e;
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowServiceManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowServiceManager.java
index eeb9b1414..ad1b278ba 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowServiceManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowServiceManager.java
@@ -10,7 +10,7 @@ import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import android.accounts.IAccountManager;
 import android.app.IAlarmManager;
@@ -73,6 +73,7 @@ import android.net.wifi.rtt.IWifiRttManager;
 import android.nfc.INfcAdapter;
 import android.os.BatteryStats;
 import android.os.Binder;
+import android.os.BluetoothServiceManager;
 import android.os.IBatteryPropertiesRegistrar;
 import android.os.IBinder;
 import android.os.IDumpstate;
@@ -168,7 +169,7 @@ public class ShadowServiceManager {
       this.binderType = binderType;
       this.delegate = delegate;
       if (binderType == BinderType.DELEGATING_PROXY || binderType == BinderType.CONCRETE) {
-        checkNotNull(delegate);
+        requireNonNull(delegate);
       }
     }
 
@@ -196,6 +197,22 @@ public class ShadowServiceManager {
     }
   }
 
+  private static String findBlueToothServiceManagerName() {
+    final String bluetoothServiceManager;
+    if (ReflectionHelpers.hasField(BluetoothAdapter.class, "BLUETOOTH_MANAGER_SERVICE")) {
+      bluetoothServiceManager =
+          ReflectionHelpers.getStaticField(BluetoothAdapter.class, "BLUETOOTH_MANAGER_SERVICE");
+    } else {
+      bluetoothServiceManager = BluetoothServiceManager.BLUETOOTH_MANAGER_SERVICE;
+    }
+    if (bluetoothServiceManager == null) {
+      throw new RuntimeException(
+          "The storage location of the name of the BLUETOOTH_MANAGER_SERVICE"
+              + "has changed in framework code, time to update ShadowServiceManager");
+    }
+    return bluetoothServiceManager;
+  }
+
   private static Map<String, BinderService> buildBinderServicesMap() {
     Map<String, BinderService> binderServices = new HashMap<>();
     addBinderService(binderServices, Context.CLIPBOARD_SERVICE, IClipboard.class);
@@ -226,9 +243,10 @@ public class ShadowServiceManager {
     addBinderService(binderServices, Context.WINDOW_SERVICE, IWindowManager.class);
     addBinderService(binderServices, Context.NFC_SERVICE, INfcAdapter.class, BinderType.DEEP_PROXY);
     addBinderService(binderServices, Context.USER_SERVICE, IUserManager.class);
+
     addBinderService(
         binderServices,
-        BluetoothAdapter.BLUETOOTH_MANAGER_SERVICE,
+        findBlueToothServiceManagerName(),
         IBluetoothManager.class,
         BinderType.DELEGATING_PROXY,
         IBluetoothManagerDelegates.createDelegate());
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java
index 5474f0a70..c761cea9d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java
@@ -41,9 +41,7 @@ public class ShadowSettings {
   @Implements(value = Settings.System.class)
   public static class ShadowSystem {
     private static final ImmutableMap<String, Optional<Object>> DEFAULTS =
-        ImmutableMap.<String, Optional<Object>>builder()
-            .put(Settings.System.ANIMATOR_DURATION_SCALE, Optional.of(1))
-            .build();
+        ImmutableMap.of(Settings.System.ANIMATOR_DURATION_SCALE, Optional.of(1));
     private static final Map<String, Optional<Object>> settings = new ConcurrentHashMap<>(DEFAULTS);
 
     @Implementation
@@ -348,9 +346,8 @@ public class ShadowSettings {
   @Implements(value = Settings.Global.class)
   public static class ShadowGlobal {
     private static final ImmutableMap<String, Optional<Object>> DEFAULTS =
-        ImmutableMap.<String, Optional<Object>>builder()
-            .put(Settings.Global.ANIMATOR_DURATION_SCALE, Optional.of(1))
-            .build();
+        ImmutableMap.of(Settings.Global.ANIMATOR_DURATION_SCALE, Optional.of(1));
+
     private static final Map<String, Optional<Object>> settings = new ConcurrentHashMap<>(DEFAULTS);
 
     @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowShortcutManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowShortcutManager.java
index 69256cd41..daf9b34aa 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowShortcutManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowShortcutManager.java
@@ -151,7 +151,7 @@ public class ShadowShortcutManager {
     for (ShortcutInfo shortcutInfo : manifestShortcuts) {
       shortcutInfo.addFlags(ShortcutInfo.FLAG_MANIFEST);
     }
-    this.manifestShortcuts = manifestShortcuts;
+    ShadowShortcutManager.manifestShortcuts = manifestShortcuts;
   }
 
   @Implementation
@@ -183,7 +183,7 @@ public class ShadowShortcutManager {
   }
 
   public void setIsRequestPinShortcutSupported(boolean isRequestPinShortcutSupported) {
-    this.isRequestPinShortcutSupported = isRequestPinShortcutSupported;
+    ShadowShortcutManager.isRequestPinShortcutSupported = isRequestPinShortcutSupported;
   }
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizer.java
index 006e2ada5..3490c1415 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizer.java
@@ -194,7 +194,7 @@ public class ShadowSpeechRecognizer {
     Preconditions.checkArgument(supportListener instanceof RecognitionSupportCallback);
 
     ShadowSpeechRecognizerState shadowState = getState();
-    shadowState.recognitionSupportExecutor = (Executor) executor;
+    shadowState.recognitionSupportExecutor = executor;
     shadowState.recognitionSupportCallback = supportListener;
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatFs.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatFs.java
index 469f623fa..87c030fb5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatFs.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatFs.java
@@ -9,7 +9,7 @@ import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
 
 /**
- * Robolectic doesn't provide actual filesystem stats; rather, it provides the ability to specify
+ * Robolectric doesn't provide actual filesystem stats; rather, it provides the ability to specify
  * stats values in advance.
  *
  * @see #registerStats(File, int, int, int)
@@ -18,7 +18,7 @@ import org.robolectric.annotation.Resetter;
 public class ShadowStatFs {
   public static final int BLOCK_SIZE = 4096;
   private static final Stats DEFAULT_STATS = new Stats(0, 0, 0);
-  private static TreeMap<String, Stats> stats = new TreeMap<>();
+  private static final TreeMap<String, Stats> stats = new TreeMap<>();
   private Stats stat;
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStaticLayout.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStaticLayout.java
index f483c3114..d5a59e6a7 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStaticLayout.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStaticLayout.java
@@ -76,7 +76,7 @@ public class ShadowStaticLayout {
       float[] recycleDescents,
       int[] recycleFlags,
       float[] charWidths) {
-    reflector(LineBreaksReflector.class, recycle).setBreaks(new int[] {((char[]) text).length});
+    reflector(LineBreaksReflector.class, recycle).setBreaks(new int[] {text.length});
     return 1;
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatsManager.java
index 678b6e6c0..58dc30282 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatsManager.java
@@ -1,6 +1,7 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.P;
+import static android.os.Build.VERSION_CODES.Q;
 
 import android.app.PendingIntent;
 import android.app.StatsManager;
@@ -24,6 +25,9 @@ public class ShadowStatsManager {
   private static final Map<BroadcastSubscriberKey, PendingIntent> broadcastSubscriberMap =
       new HashMap<>();
 
+  @SuppressWarnings("NonFinalStaticField")
+  private static long[] registeredExperimentIds = new long[] {};
+
   @Resetter
   public static void reset() {
     reportDataMap.clear();
@@ -32,7 +36,7 @@ public class ShadowStatsManager {
     broadcastSubscriberMap.clear();
   }
 
-  /** Adds metrics data that the shadow should return from {@link StatsManager#getReports()}. */
+  /** Adds metrics data that the shadow should return from {@link StatsManager#getReports(long)}. */
   public static void addReportData(long configKey, byte[] data) {
     reportDataMap.put(configKey, data);
   }
@@ -45,9 +49,17 @@ public class ShadowStatsManager {
     statsMetadata = metadata;
   }
 
+  /**
+   * Sets the registered experiment ids that the shadow should return from {@link
+   * StatsManager#getRegisteredExperimentIds()}.
+   */
+  public static void setRegisteredExperimentIds(long[] experimentIds) {
+    registeredExperimentIds = experimentIds;
+  }
+
   /**
    * Retrieves the statsd configurations stored in the shadow as a result of {@link
-   * StatsManager#addConfig()} and {@link StatsManager#removeConfig()}.
+   * StatsManager#addConfig(long, byte[])} and {@link StatsManager#removeConfig(long)}.
    */
   public static byte[] getConfigData(long configKey) {
     return configDataMap.getOrDefault(configKey, new byte[] {});
@@ -97,6 +109,11 @@ public class ShadowStatsManager {
     }
   }
 
+  @Implementation(minSdk = Q)
+  protected long[] getRegisteredExperimentIds() {
+    return registeredExperimentIds;
+  }
+
   /** A key used to store the configKey and subscriberId in the broadcastSubscriberMap. */
   @AutoValue
   public abstract static class BroadcastSubscriberKey {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageManager.java
index e1033ca97..91fc49c90 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageManager.java
@@ -8,10 +8,10 @@ import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import android.os.UserManager;
 import android.os.storage.StorageManager;
 import android.os.storage.StorageVolume;
-import com.google.common.base.Preconditions;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Objects;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
@@ -44,15 +44,15 @@ public class ShadowStorageManager {
   /**
    * Adds a {@link StorageVolume} to the list returned by {@link #getStorageVolumes()}.
    *
-   * @param StorageVolume to add to list
+   * @param storageVolume to add to list
    */
   public void addStorageVolume(StorageVolume storageVolume) {
-    Preconditions.checkNotNull(storageVolume);
+    Objects.requireNonNull(storageVolume);
     storageVolumeList.add(storageVolume);
   }
 
   /**
-   * Returns the storage volumes configured via {@link #addStorageVolume()}.
+   * Returns the storage volumes configured via {@link #addStorageVolume(StorageVolume)}.
    *
    * @return StorageVolume list
    */
@@ -70,7 +70,7 @@ public class ShadowStorageManager {
    * Checks whether File belongs to any {@link StorageVolume} in the list returned by {@link
    * #getStorageVolumes()}.
    *
-   * @param File to check
+   * @param file to check
    * @return StorageVolume for the file
    */
   @Implementation(minSdk = N)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageStatsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageStatsManager.java
index aee4d14f9..44ba489c6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageStatsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageStatsManager.java
@@ -14,6 +14,7 @@ import java.io.IOException;
 import java.util.Map;
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
@@ -88,6 +89,11 @@ public class ShadowStorageStatsManager {
         moreCacheBytes -= storageStatsForPackage.getCacheBytes();
       }
       Parcel parcel = Parcel.obtain();
+      if (RuntimeEnvironment.getApiLevel() > Build.VERSION_CODES.VANILLA_ICE_CREAM) {
+        parcel.writeString(packageName);
+        parcel.writeInt(userHandle.getIdentifier());
+        parcel.writeInt(storageUuid.hashCode());
+      }
       parcel.writeLong(storageStatsForUser.getAppBytes() + moreAppBytes);
       parcel.writeLong(storageStatsForUser.getDataBytes() + moreDataBytes);
       parcel.writeLong(storageStatsForUser.getCacheBytes() + moreCacheBytes);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java
index f655e9f6c..a5d49f8ac 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java
@@ -124,10 +124,10 @@ public class ShadowSubscriptionManager {
   }
 
   /**
-   * Cache of phone IDs used by {@link getPhoneId}. Managed by {@link putPhoneId} and {@link
-   * removePhoneId}.
+   * Cache of phone IDs used by {@link #getPhoneId}. Managed by {@link #putPhoneId} and {@link
+   * #removePhoneId}.
    */
-  private static Map<Integer, Integer> phoneIds = new HashMap<>();
+  private static final Map<Integer, Integer> phoneIds = new HashMap<>();
 
   /**
    * Cache of {@link SubscriptionInfo} used by {@link #getActiveSubscriptionInfoList}. Managed by
@@ -135,6 +135,12 @@ public class ShadowSubscriptionManager {
    */
   private static List<SubscriptionInfo> subscriptionList = new ArrayList<>();
 
+  /**
+   * Cache of {@link SubscriptionInfo} used by {@link #getAllSubscriptionInfoList}. Managed by
+   * {@link #setAllSubscriptionInfoList}. May be {@code null}.
+   */
+  private static List<SubscriptionInfo> allSubscriptionList = ImmutableList.of();
+
   /**
    * Cache of {@link SubscriptionInfo} used by {@link #getAccessibleSubscriptionInfoList}. Managed
    * by {@link #setAccessibleSubscriptionInfos}. May be {@code null}.
@@ -149,15 +155,15 @@ public class ShadowSubscriptionManager {
 
   /**
    * List of listeners to be notified if the list of {@link SubscriptionInfo} changes. Managed by
-   * {@link #addOnSubscriptionsChangedListener} and {@link removeOnSubscriptionsChangedListener}.
+   * {@link #addOnSubscriptionsChangedListener} and {@link #removeOnSubscriptionsChangedListener}.
    */
-  private List<OnSubscriptionsChangedListener> listeners = new ArrayList<>();
+  private final List<OnSubscriptionsChangedListener> listeners = new ArrayList<>();
 
   /**
    * Cache of subscription ids used by {@link #isNetworkRoaming}. Managed by {@link
    * #setNetworkRoamingStatus} and {@link #clearNetworkRoamingStatus}.
    */
-  private Set<Integer> roamingSimSubscriptionIds = new HashSet<>();
+  private final Set<Integer> roamingSimSubscriptionIds = new HashSet<>();
 
   /**
    * Returns the active list of {@link SubscriptionInfo} that were set via {@link
@@ -169,6 +175,16 @@ public class ShadowSubscriptionManager {
     return subscriptionList;
   }
 
+  /**
+   * Returns the all list of {@link SubscriptionInfo} that were set via {@link
+   * #setAllSubscriptionInfoList}.
+   */
+  @Implementation(minSdk = UPSIDE_DOWN_CAKE)
+  protected List<SubscriptionInfo> getAllSubscriptionInfoList() {
+    checkReadPhoneStatePermission();
+    return ImmutableList.copyOf(allSubscriptionList);
+  }
+
   /**
    * Returns the accessible list of {@link SubscriptionInfo} that were set via {@link
    * #setAccessibleSubscriptionInfoList}.
@@ -268,6 +284,15 @@ public class ShadowSubscriptionManager {
     dispatchOnSubscriptionsChanged();
   }
 
+  /**
+   * Sets the all list of {@link SubscriptionInfo}. This call internally triggers {@link
+   * OnSubscriptionsChangedListener#onSubscriptionsChanged()} to all the listeners.
+   */
+  public void setAllSubscriptionInfoList(List<SubscriptionInfo> list) {
+    allSubscriptionList = ImmutableList.copyOf(list);
+    dispatchOnSubscriptionsChanged();
+  }
+
   /**
    * Sets the accessible list of {@link SubscriptionInfo}. This call internally triggers {@link
    * OnSubscriptionsChangedListener#onSubscriptionsChanged()} to all the listeners.
@@ -277,7 +302,7 @@ public class ShadowSubscriptionManager {
    * SubscriptionManager#canManageSubscription(SubscriptionInfo)}. They may be active, or
    * installed-but-inactive. This is generally intended to be called by carrier apps that directly
    * manage their own eSIM profiles on the device in concert with {@link
-   * android.telephony.EuiccManager}.
+   * android.telephony.euicc.EuiccManager}.
    *
    * @param list - The subscription info list, can be null.
    */
@@ -340,6 +365,18 @@ public class ShadowSubscriptionManager {
     }
   }
 
+  /**
+   * Sets the all list of {@link SubscriptionInfo}. This call internally triggers {@link
+   * OnSubscriptionsChangedListener#onSubscriptionsChanged()} to all the listeners.
+   */
+  public void setAllSubscriptionInfos(SubscriptionInfo... infos) {
+    if (infos == null) {
+      setAllSubscriptionInfoList(ImmutableList.of());
+    } else {
+      setAllSubscriptionInfoList(Arrays.asList(infos));
+    }
+  }
+
   /**
    * Adds a listener to a local list of listeners. Will be triggered by {@link
    * #setActiveSubscriptionInfoList} when the local list of {@link SubscriptionInfo} is updated.
@@ -371,7 +408,7 @@ public class ShadowSubscriptionManager {
   }
 
   /**
-   * Check if a listener exists in the {@link ShadowSubscriptionManager.listeners}.
+   * Check if a listener exists in the {@link ShadowSubscriptionManager#listeners}.
    *
    * @param listener The listener to check.
    * @return boolean True if the listener already added, otherwise false.
@@ -433,13 +470,13 @@ public class ShadowSubscriptionManager {
     return roamingSimSubscriptionIds.contains(simSubscriptionId);
   }
 
-  /** Adds a subscription ID-phone ID mapping to the map used by {@link getPhoneId}. */
+  /** Adds a subscription ID-phone ID mapping to the map used by {@link #getPhoneId}. */
   public static void putPhoneId(int subId, int phoneId) {
     phoneIds.put(subId, phoneId);
   }
 
   /**
-   * Removes a subscription ID-phone ID mapping from the map used by {@link getPhoneId}.
+   * Removes a subscription ID-phone ID mapping from the map used by {@link #getPhoneId}.
    *
    * @return the previous phone ID associated with the subscription ID, or null if there was no
    *     mapping for the subscription ID
@@ -450,15 +487,15 @@ public class ShadowSubscriptionManager {
 
   /**
    * Removes all mappings between subscription IDs and phone IDs from the map used by {@link
-   * getPhoneId}.
+   * #getPhoneId}.
    */
   public static void clearPhoneIds() {
     phoneIds.clear();
   }
 
   /**
-   * Uses the map of subscription IDs to phone IDs managed by {@link putPhoneId} and {@link
-   * removePhoneId} to return the phone ID for a given subscription ID.
+   * Uses the map of subscription IDs to phone IDs managed by {@link #putPhoneId} and {@link
+   * #removePhoneId} to return the phone ID for a given subscription ID.
    */
   @Implementation(minSdk = LOLLIPOP_MR1, maxSdk = P)
   @HiddenApi
@@ -523,12 +560,12 @@ public class ShadowSubscriptionManager {
   }
 
   /**
-   * When set to false methods requiring {@link android.Manifest.permission.READ_PHONE_STATE}
+   * When set to false methods requiring {@link android.Manifest.permission#READ_PHONE_STATE}
    * permission will throw a {@link SecurityException}. By default it's set to true for backwards
    * compatibility.
    */
   public void setReadPhoneStatePermission(boolean readPhoneStatePermission) {
-    this.readPhoneStatePermission = readPhoneStatePermission;
+    ShadowSubscriptionManager.readPhoneStatePermission = readPhoneStatePermission;
   }
 
   private void checkReadPhoneStatePermission() {
@@ -538,12 +575,12 @@ public class ShadowSubscriptionManager {
   }
 
   /**
-   * When set to false methods requiring {@link android.Manifest.permission.READ_PHONE_NUMBERS}
+   * When set to false methods requiring {@link android.Manifest.permission#READ_PHONE_NUMBERS}
    * permission will throw a {@link SecurityException}. By default it's set to true for backwards
    * compatibility.
    */
   public void setReadPhoneNumbersPermission(boolean readPhoneNumbersPermission) {
-    this.readPhoneNumbersPermission = readPhoneNumbersPermission;
+    ShadowSubscriptionManager.readPhoneNumbersPermission = readPhoneNumbersPermission;
   }
 
   private void checkReadPhoneNumbersPermission() {
@@ -590,6 +627,7 @@ public class ShadowSubscriptionManager {
     defaultVoiceSubscriptionId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
     defaultSubscriptionId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
     subscriptionList = new ArrayList<>();
+    allSubscriptionList = ImmutableList.of();
     phoneIds.clear();
     phoneNumberMap.clear();
     readPhoneStatePermission = true;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurfaceView.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurfaceView.java
index d371bf4d0..4482ad09d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurfaceView.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurfaceView.java
@@ -48,6 +48,10 @@ public class ShadowSurfaceView extends ShadowView {
       callbacks.remove(callback);
     }
 
+    public void emitSurfaceChanged(int format, int width, int height) {
+      callbacks.forEach(callback -> callback.surfaceChanged(this, format, width, height));
+    }
+
     @Override
     public boolean isCreating() {
       return false;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSuspendDialogInfo.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSuspendDialogInfo.java
index 0a7baee1e..1e208d0e0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSuspendDialogInfo.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSuspendDialogInfo.java
@@ -67,8 +67,8 @@ public class ShadowSuspendDialogInfo {
   /**
    * Returns the action expected to happen on neutral button tap.
    *
-   * @return {@link SuspendDialogInfo.BUTTON_ACTION_MORE_DETAILS} or {@link
-   *     SuspendDialogInfo.BUTTON_ACTION_UNSUSPEND}
+   * @return {@link SuspendDialogInfo#BUTTON_ACTION_MORE_DETAILS} or {@link
+   *     SuspendDialogInfo#BUTTON_ACTION_UNSUSPEND}
    */
   @Implementation(minSdk = R)
   public int getNeutralButtonAction() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemProperties.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemProperties.java
index d2c713e5b..961e1b175 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemProperties.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemProperties.java
@@ -1,10 +1,10 @@
 package org.robolectric.shadows;
 
 import android.os.SystemProperties;
-import com.google.common.base.Preconditions;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.Objects;
 import java.util.Properties;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
@@ -93,7 +93,7 @@ public class ShadowSystemProperties {
       // load the prop from classpath
       ClassLoader cl = SystemProperties.class.getClassLoader();
       try (InputStream is = cl.getResourceAsStream("build.prop")) {
-        Preconditions.checkNotNull(is, "could not find build.prop");
+        Objects.requireNonNull(is, "could not find build.prop");
         buildProperties = new Properties();
         buildProperties.load(is);
         setDefaults(buildProperties);
@@ -115,7 +115,7 @@ public class ShadowSystemProperties {
     buildProperties.setProperty("ro.hardware", "robolectric");
     buildProperties.setProperty("ro.build.characteristics", "robolectric");
 
-    // for backwards-compatiblity reasons, set CPUS to unknown/ARM
+    // for backwards-compatibility reasons, set CPUS to unknown/ARM
     buildProperties.setProperty("ro.product.cpu.abi", "unknown");
     buildProperties.setProperty("ro.product.cpu.abi2", "unknown");
     buildProperties.setProperty("ro.product.cpu.abilist", "armeabi-v7a");
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemServiceRegistry.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemServiceRegistry.java
index 92564631f..3880a36b3 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemServiceRegistry.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemServiceRegistry.java
@@ -131,7 +131,7 @@ public class ShadowSystemServiceRegistry {
     e.printStackTrace();
   }
 
-  private static Class classForName(String className) {
+  private static Class<?> classForName(String className) {
     try {
       return Class.forName(className);
     } catch (ClassNotFoundException e) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabHost.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabHost.java
index fad0b6933..28fa97e9d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabHost.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabHost.java
@@ -19,7 +19,7 @@ import org.robolectric.shadow.api.Shadow;
 @SuppressWarnings({"UnusedDeclaration"})
 @Implements(TabHost.class)
 public class ShadowTabHost extends ShadowViewGroup {
-  private List<TabHost.TabSpec> tabSpecs = new ArrayList<>();
+  private final List<TabHost.TabSpec> tabSpecs = new ArrayList<>();
   private TabHost.OnTabChangeListener listener;
   private int currentTab = -1;
 
@@ -66,7 +66,7 @@ public class ShadowTabHost extends ShadowViewGroup {
 
   @Implementation
   protected int getCurrentTab() {
-    if (currentTab == -1 && tabSpecs.size() > 0) currentTab = 0;
+    if (currentTab == -1 && !tabSpecs.isEmpty()) currentTab = 0;
     return currentTab;
   }
 
@@ -107,7 +107,7 @@ public class ShadowTabHost extends ShadowViewGroup {
   protected TabWidget getTabWidget() {
     Context context = realView.getContext();
     if (context instanceof Activity) {
-      return (TabWidget) ((Activity) context).findViewById(R.id.tabs);
+      return ((Activity) context).findViewById(R.id.tabs);
     } else {
       return null;
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java
index 4b2b1b0b5..5a2116867 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java
@@ -10,8 +10,8 @@ import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static com.google.common.base.Verify.verifyNotNull;
 
+import android.annotation.RequiresApi;
 import android.annotation.SystemApi;
-import android.annotation.TargetApi;
 import android.bluetooth.BluetoothDevice;
 import android.content.ComponentName;
 import android.content.Context;
@@ -134,7 +134,7 @@ public class ShadowTelecomManager {
   }
 
   public void setCallRequestMode(CallRequestMode callRequestMode) {
-    this.callRequestMode = callRequestMode;
+    ShadowTelecomManager.callRequestMode = callRequestMode;
   }
 
   /**
@@ -152,7 +152,7 @@ public class ShadowTelecomManager {
 
   /** Sets the result of {@link TelecomManager#isOutgoingCallPermitted(PhoneAccountHandle)}. */
   public void setIsOutgoingCallPermitted(boolean isOutgoingCallPermitted) {
-    this.isOutgoingCallPermitted = isOutgoingCallPermitted;
+    ShadowTelecomManager.isOutgoingCallPermitted = isOutgoingCallPermitted;
   }
 
   /**
@@ -352,13 +352,13 @@ public class ShadowTelecomManager {
   @Implementation(minSdk = M)
   @HiddenApi
   public boolean setDefaultDialer(String packageName) {
-    this.defaultDialerPackageName = packageName;
+    defaultDialerPackageName = packageName;
     return true;
   }
 
   /** Set returned value of {@link #getDefaultDialerPackage()}. */
   public void setDefaultDialerPackage(String packageName) {
-    this.defaultDialerPackageName = packageName;
+    defaultDialerPackageName = packageName;
   }
 
   @Implementation(minSdk = M)
@@ -369,7 +369,7 @@ public class ShadowTelecomManager {
 
   /** Set returned value of {@link #getSystemDialerPackage()}. */
   public void setSystemDialerPackage(String packageName) {
-    this.systemDefaultDialerPackageName = packageName;
+    systemDefaultDialerPackageName = packageName;
   }
 
   public void setVoicemailNumber(PhoneAccountHandle accountHandle, String number) {
@@ -398,7 +398,7 @@ public class ShadowTelecomManager {
 
   /** Sets the return value for {@link TelecomManager#isInCall}. */
   public void setIsInCall(boolean isInCall) {
-    this.isInCall = isInCall;
+    ShadowTelecomManager.isInCall = isInCall;
   }
 
   /**
@@ -418,8 +418,8 @@ public class ShadowTelecomManager {
    * TelecomManager#isInCall}.
    */
   public void setIsInEmergencyCall(boolean isInEmergencyCall) {
-    this.isInEmergencyCall = isInEmergencyCall;
-    this.isInCall = isInEmergencyCall;
+    ShadowTelecomManager.isInEmergencyCall = isInEmergencyCall;
+    isInCall = isInEmergencyCall;
   }
 
   /**
@@ -527,7 +527,7 @@ public class ShadowTelecomManager {
    * <p>Specifically, this method sets up the relevant {@link ConnectionService} and returns the
    * result of {@link ConnectionService#onCreateIncomingConnection}.
    */
-  @TargetApi(M)
+  @RequiresApi(M)
   @Nullable
   public Connection allowIncomingCall(IncomingCallRecord call) {
     if (call.isHandled) {
@@ -547,7 +547,7 @@ public class ShadowTelecomManager {
    * <p>Specifically, this method sets up the relevant {@link ConnectionService} and calls {@link
    * ConnectionService#onCreateIncomingConnectionFailed}.
    */
-  @TargetApi(O)
+  @RequiresApi(O)
   public void denyIncomingCall(IncomingCallRecord call) {
     if (call.isHandled) {
       throw new IllegalStateException("Call has already been allowed or denied.");
@@ -606,7 +606,7 @@ public class ShadowTelecomManager {
    * <p>Specifically, this method sets up the relevant {@link ConnectionService} and returns the
    * result of {@link ConnectionService#onCreateOutgoingConnection}.
    */
-  @TargetApi(M)
+  @RequiresApi(M)
   @Nullable
   public Connection allowOutgoingCall(OutgoingCallRecord call) {
     if (call.isHandled) {
@@ -626,7 +626,7 @@ public class ShadowTelecomManager {
    * <p>Specifically, this method sets up the relevant {@link ConnectionService} and calls {@link
    * ConnectionService#onCreateOutgoingConnectionFailed}.
    */
-  @TargetApi(O)
+  @RequiresApi(O)
   public void denyOutgoingCall(OutgoingCallRecord call) {
     if (call.isHandled) {
       throw new IllegalStateException("Call has already been allowed or denied.");
@@ -704,7 +704,7 @@ public class ShadowTelecomManager {
   }
 
   public void setHandleMmiValue(boolean handleMmiValue) {
-    this.handleMmiValue = handleMmiValue;
+    ShadowTelecomManager.handleMmiValue = handleMmiValue;
   }
 
   @Implementation
@@ -742,7 +742,7 @@ public class ShadowTelecomManager {
    */
   @Implementation(minSdk = N)
   protected Intent createManageBlockedNumbersIntent() {
-    return this.manageBlockNumbersIntent;
+    return manageBlockNumbersIntent;
   }
 
   /**
@@ -750,12 +750,12 @@ public class ShadowTelecomManager {
    * ShadowTelecomManager#createManageBlockedNumbersIntent()}
    */
   public void setManageBlockNumbersIntent(Intent intent) {
-    this.manageBlockNumbersIntent = intent;
+    manageBlockNumbersIntent = intent;
   }
 
   @Implementation(maxSdk = LOLLIPOP_MR1)
   public void setSimCallManager(PhoneAccountHandle simCallManager) {
-    this.simCallManager = simCallManager;
+    ShadowTelecomManager.simCallManager = simCallManager;
   }
 
   /**
@@ -796,7 +796,7 @@ public class ShadowTelecomManager {
 
   @Implementation(minSdk = O)
   protected boolean isOutgoingCallPermitted(PhoneAccountHandle phoneAccountHandle) {
-    return this.isOutgoingCallPermitted;
+    return isOutgoingCallPermitted;
   }
 
   /**
@@ -812,7 +812,7 @@ public class ShadowTelecomManager {
     protected boolean isRinging = true;
 
     /**
-     * @deprecated Use {@link extras} instead.
+     * @deprecated Use {@link #extras} instead.
      */
     @Deprecated public final Bundle bundle;
 
@@ -826,12 +826,12 @@ public class ShadowTelecomManager {
   }
 
   /**
-   * When set to false methods requiring {@link android.Manifest.permission.READ_PHONE_STATE}
+   * When set to false methods requiring {@link android.Manifest.permission#READ_PHONE_STATE}
    * permission will throw a {@link SecurityException}. By default it's set to true for backwards
    * compatibility.
    */
   public void setReadPhoneStatePermission(boolean readPhoneStatePermission) {
-    this.readPhoneStatePermission = readPhoneStatePermission;
+    ShadowTelecomManager.readPhoneStatePermission = readPhoneStatePermission;
   }
 
   private void checkReadPhoneStatePermission() {
@@ -841,12 +841,12 @@ public class ShadowTelecomManager {
   }
 
   /**
-   * When set to false methods requiring {@link android.Manifest.permission.CALL_PHONE} permission
+   * When set to false methods requiring {@link android.Manifest.permission#CALL_PHONE} permission
    * will throw a {@link SecurityException}. By default it's set to true for backwards
    * compatibility.
    */
   public void setCallPhonePermission(boolean callPhonePermission) {
-    this.callPhonePermission = callPhonePermission;
+    ShadowTelecomManager.callPhonePermission = callPhonePermission;
   }
 
   private void checkCallPhonePermission() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephony.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephony.java
index 7e3c18f99..cb59dbb3b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephony.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephony.java
@@ -24,7 +24,7 @@ public class ShadowTelephony {
      *
      * <p>This will be reset for the next test.
      */
-    public static void setDefaultSmsPackage(String defaultSmsPackage) {
+    public static void setDefaultSmsPackage(@Nullable String defaultSmsPackage) {
       ShadowSms.defaultSmsPackage = defaultSmsPackage;
     }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephonyManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephonyManager.java
index ec7d5e5bc..277bfd987 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephonyManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephonyManager.java
@@ -11,6 +11,7 @@ import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
+import static android.os.Build.VERSION_CODES.VANILLA_ICE_CREAM;
 import static android.telephony.PhoneStateListener.LISTEN_CALL_STATE;
 import static android.telephony.PhoneStateListener.LISTEN_CELL_INFO;
 import static android.telephony.PhoneStateListener.LISTEN_CELL_LOCATION;
@@ -55,7 +56,6 @@ import android.telephony.emergency.EmergencyNumber;
 import android.text.TextUtils;
 import com.google.common.base.Ascii;
 import com.google.common.base.Preconditions;
-import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -67,6 +67,7 @@ import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -139,11 +140,13 @@ public class ShadowTelephonyManager {
   private String incomingPhoneNumber = null;
   private static volatile boolean isSmsCapable = true;
   private static volatile boolean voiceCapable = true;
+  private static volatile int voiceActivationState = TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
+  private static volatile int dataActivationState = TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
   private String voiceMailNumber;
   private String voiceMailAlphaTag;
   private static volatile int phoneCount = 1;
   private static volatile int activeModemCount = 1;
-  private static volatile Map<Integer, TelephonyManager> subscriptionIdsToTelephonyManagers =
+  private static final Map<Integer, TelephonyManager> subscriptionIdsToTelephonyManagers =
       Collections.synchronizedMap(new LinkedHashMap<>());
   private PersistableBundle carrierConfig;
   private ServiceState serviceState;
@@ -185,6 +188,7 @@ public class ShadowTelephonyManager {
   private static volatile boolean isDataRoamingEnabled;
   private /*CarrierRestrictionRules*/ Object carrierRestrictionRules;
   private final AtomicInteger modemRebootCount = new AtomicInteger();
+  private String iccAuthentication;
 
   /**
    * Should be {@link TelephonyManager.BootstrapAuthenticationCallback} but this object was
@@ -229,6 +233,8 @@ public class ShadowTelephonyManager {
     readPhoneStatePermission = true;
     isSmsCapable = true;
     voiceCapable = true;
+    voiceActivationState = TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
+    dataActivationState = TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
     phoneCount = 1;
     activeModemCount = 1;
     sentDialerSpecialCodes.clear();
@@ -781,7 +787,7 @@ public class ShadowTelephonyManager {
   }
 
   /**
-   * Sets the value to be returned by calls to {@link getVoiceNetworkType}. This <b>should</b>
+   * Sets the value to be returned by calls to {@link #getVoiceNetworkType}. This <b>should</b>
    * correspond to one of the {@code NETWORK_TYPE_*} constants defined on {@link TelephonyManager},
    * but this is not enforced.
    */
@@ -840,16 +846,16 @@ public class ShadowTelephonyManager {
   }
 
   /**
-   * Sets the value to be returned by calls to {@link requestCellInfoUpdate}. Note that it does not
-   * set the value to be returned by calls to {@link getAllCellInfo}; for that, see {@link
-   * setAllCellInfo}.
+   * Sets the value to be returned by calls to {@link #requestCellInfoUpdate}. Note that it does not
+   * set the value to be returned by calls to {@link #getAllCellInfo}; for that, see {@link
+   * #setAllCellInfo}.
    */
   public void setCallbackCellInfos(List<CellInfo> callbackCellInfos) {
     ShadowTelephonyManager.callbackCellInfos = callbackCellInfos;
   }
 
   /**
-   * Sets the values to be returned by a presumed error condition in {@link requestCellInfoUpdate}.
+   * Sets the values to be returned by a presumed error condition in {@link #requestCellInfoUpdate}.
    * These values will persist until cleared: to clear, set (0, null) using this method.
    */
   public void setRequestCellInfoUpdateErrorValues(int errorCode, Throwable detail) {
@@ -946,12 +952,9 @@ public class ShadowTelephonyManager {
   protected Iterable<PhoneStateListener> getListenersForFlags(int flags) {
     return Iterables.filter(
         ImmutableSet.copyOf(phoneStateRegistrations.keySet()),
-        new Predicate<PhoneStateListener>() {
-          @Override
-          public boolean apply(PhoneStateListener input) {
-            // only select PhoneStateListeners with matching flags
-            return (phoneStateRegistrations.get(input) & flags) != 0;
-          }
+        input -> {
+          // only select PhoneStateListeners with matching flags
+          return (phoneStateRegistrations.get(input) & flags) != 0;
         });
   }
 
@@ -977,6 +980,17 @@ public class ShadowTelephonyManager {
     ShadowTelephonyManager.isSmsCapable = isSmsCapable;
   }
 
+  /** Returns true by default, or the value specified via {@link #setDeviceSmsCapable(boolean)}. */
+  @Implementation(minSdk = VANILLA_ICE_CREAM)
+  protected boolean isDeviceSmsCapable() {
+    return isSmsCapable;
+  }
+
+  /** Sets the value returned by {@link #isDeviceSmsCapable()}. */
+  public void setDeviceSmsCapable(boolean isSmsCapable) {
+    ShadowTelephonyManager.isSmsCapable = isSmsCapable;
+  }
+
   /**
    * Returns a new empty {@link PersistableBundle} by default, or the value specified via {@link
    * #setCarrierConfig(PersistableBundle)}.
@@ -1075,6 +1089,52 @@ public class ShadowTelephonyManager {
     ShadowTelephonyManager.voiceCapable = voiceCapable;
   }
 
+  /**
+   * Returns {@code true} by default or the value specified via {@link
+   * #setDeviceVoiceCapable(boolean)}.
+   */
+  @Implementation(minSdk = VANILLA_ICE_CREAM)
+  protected boolean isDeviceVoiceCapable() {
+    return voiceCapable;
+  }
+
+  /** Sets the value returned by {@link #isDeviceVoiceCapable()}. */
+  public void setDeviceVoiceCapable(boolean voiceCapable) {
+    ShadowTelephonyManager.voiceCapable = voiceCapable;
+  }
+
+  /**
+   * Returns {@code TelephonyManager.VOICE_ACTIVATION_STATE_ACTIVATED} by default or the value
+   * specified via {@link #setVoiceActivationState(int)}.
+   */
+  @Implementation(minSdk = P)
+  protected int getVoiceActivationState() {
+    return voiceActivationState;
+  }
+
+  /** Sets the value returned by {@link #getVoiceActivationState()}. */
+  @SuppressWarnings("ProtectedImplementationLintCheck")
+  @Implementation(minSdk = P)
+  public void setVoiceActivationState(int voiceActivationState) {
+    ShadowTelephonyManager.voiceActivationState = voiceActivationState;
+  }
+
+  /**
+   * Returns {@code TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN} by default or the value specified
+   * via {@link #setDataActivationState(int)}.
+   */
+  @Implementation(minSdk = P)
+  protected int getDataActivationState() {
+    return dataActivationState;
+  }
+
+  /** Sets the value returned by {@link #getDataActivationState()}. */
+  @SuppressWarnings("ProtectedImplementationLintCheck")
+  @Implementation(minSdk = P)
+  public void setDataActivationState(int dataActivationState) {
+    ShadowTelephonyManager.dataActivationState = dataActivationState;
+  }
+
   /**
    * Returns {@code null} by default or the value specified via {@link
    * #setVoicemailVibrationEnabled(PhoneAccountHandle, boolean)}.
@@ -1560,7 +1620,7 @@ public class ShadowTelephonyManager {
    * @throws NullPointerException if telephonyDisplayInfo is null.
    */
   public void setTelephonyDisplayInfo(Object telephonyDisplayInfo) {
-    Preconditions.checkNotNull(telephonyDisplayInfo);
+    Objects.requireNonNull(telephonyDisplayInfo);
     this.telephonyDisplayInfo = telephonyDisplayInfo;
 
     for (PhoneStateListener listener :
@@ -1712,4 +1772,13 @@ public class ShadowTelephonyManager {
   public int getModemRebootCount() {
     return modemRebootCount.get();
   }
+
+  @Implementation(minSdk = N)
+  protected String getIccAuthentication(int appType, int authType, String data) {
+    return iccAuthentication;
+  }
+
+  public void setIccAuthentication(String iccAuthentication) {
+    this.iccAuthentication = iccAuthentication;
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java
index f7f9c6d00..bb6ad573f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java
@@ -200,7 +200,7 @@ public class ShadowTextToSpeech {
               Voice.QUALITY_NORMAL,
               Voice.LATENCY_NORMAL,
               /* requiresNetworkConnection= */ false,
-              new HashSet<String>()));
+              new HashSet<>()));
     }
 
     return languageAvailability;
@@ -372,6 +372,6 @@ public class ShadowTextToSpeech {
   interface TextToSpeechReflector {
 
     @Direct
-    int speak(final String text, final int queueMode, final HashMap params);
+    int speak(final String text, final int queueMode, final HashMap<?, ?> params);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextView.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextView.java
index e7d29b4c4..9617b7c60 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextView.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextView.java
@@ -28,9 +28,9 @@ public class ShadowTextView extends ShadowView {
   protected int selectionStart = -1;
   protected int selectionEnd = -1;
 
-  private List<TextWatcher> watchers = new ArrayList<>();
-  private List<Integer> previousKeyCodes = new ArrayList<>();
-  private List<KeyEvent> previousKeyEvents = new ArrayList<>();
+  private final List<TextWatcher> watchers = new ArrayList<>();
+  private final List<Integer> previousKeyCodes = new ArrayList<>();
+  private final List<KeyEvent> previousKeyEvents = new ArrayList<>();
   private int compoundDrawablesWithIntrinsicBoundsLeft;
   private int compoundDrawablesWithIntrinsicBoundsTop;
   private int compoundDrawablesWithIntrinsicBoundsRight;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTime.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTime.java
index c3e234985..abaca03c0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTime.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTime.java
@@ -1,5 +1,6 @@
 package org.robolectric.shadows;
 
+import android.annotation.SuppressLint;
 import android.text.format.Time;
 import android.util.TimeFormatException;
 import org.robolectric.annotation.Implementation;
@@ -27,13 +28,14 @@ public class ShadowTime {
     return -1;
   }
 
+  @SuppressLint("DefaultLocale")
   @Implementation
   protected void checkChar(String s, int spos, char expected) {
     char c = s.charAt(spos);
     if (c != expected) {
       throwTimeFormatException(
           String.format(
-              "Unexpected character 0x%02d at pos=%d.  Expected 0x%02d (\'%c\').",
+              "Unexpected character 0x%02d at pos=%d.  Expected 0x%02d ('%c').",
               (int) c, spos, (int) expected, expected));
     }
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeManager.java
index 744b94ca5..f2bbe298e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeManager.java
@@ -46,7 +46,7 @@ public class ShadowTimeManager {
         throw new IllegalArgumentException("Unrecognized capability=" + capability);
     }
 
-    this.timeZoneCapabilities = builder.build();
+    timeZoneCapabilities = builder.build();
   }
 
   @Implementation
@@ -102,7 +102,7 @@ public class ShadowTimeManager {
   @Implementation
   @SystemApi
   protected boolean updateTimeZoneConfiguration(TimeZoneConfiguration configuration) {
-    this.timeZoneConfiguration = configuration;
+    timeZoneConfiguration = configuration;
     return true;
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowToast.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowToast.java
index 5c2810353..f3c0df002 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowToast.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowToast.java
@@ -211,6 +211,6 @@ public class ShadowToast {
   public static Toast getLatestToast() {
     ShadowApplication shadowApplication = Shadow.extract(RuntimeEnvironment.getApplication());
     List<Toast> shownToasts = shadowApplication.getShownToasts();
-    return (shownToasts.size() == 0) ? null : shownToasts.get(shownToasts.size() - 1);
+    return shownToasts.isEmpty() ? null : shownToasts.get(shownToasts.size() - 1);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTrace.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTrace.java
index 81dfa9c8c..482375324 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTrace.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTrace.java
@@ -30,10 +30,10 @@ public class ShadowTrace {
   private static final String TAG = "ShadowTrace";
 
   private static final ThreadLocal<Deque<String>> currentSections =
-      ThreadLocal.withInitial(() -> new ArrayDeque<>());
+      ThreadLocal.withInitial(ArrayDeque::new);
 
   private static final ThreadLocal<Queue<String>> previousSections =
-      ThreadLocal.withInitial((Supplier<Deque<String>>) () -> new ArrayDeque<>());
+      ThreadLocal.withInitial((Supplier<Deque<String>>) ArrayDeque::new);
 
   private static final Set<AsyncTraceSection> currentAsyncSections = new HashSet<>();
 
@@ -168,7 +168,7 @@ public class ShadowTrace {
    * Do not use this method unless absolutely necessary. Prefer fixing the tests instead.
    *
    * <p>Sets whether to crash on incorrect usage (e.g., calling {@link #endSection()} before {@link
-   * beginSection(String)}. Default value - {@code true}.
+   * #beginSection(String)}. Default value - {@code true}.
    */
   public static void doNotUseSetCrashOnIncorrectUsage(boolean crashOnIncorrectUsage) {
     ShadowTrace.crashOnIncorrectUsage = crashOnIncorrectUsage;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTypeface.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTypeface.java
index 5db6c9d60..9a0bb667e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTypeface.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTypeface.java
@@ -1,6 +1,7 @@
 package org.robolectric.shadows;
 
 import android.graphics.Typeface;
+import java.util.Objects;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowTypeface.Picker;
 
@@ -39,13 +40,7 @@ public abstract class ShadowTypeface {
       if (style != fontDesc.style) {
         return false;
       }
-      if (familyName != null
-          ? !familyName.equals(fontDesc.familyName)
-          : fontDesc.familyName != null) {
-        return false;
-      }
-
-      return true;
+      return Objects.equals(familyName, fontDesc.familyName);
     }
 
     @Override
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUiAutomation.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUiAutomation.java
index 61f70c98b..bb96b3e0d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUiAutomation.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUiAutomation.java
@@ -2,6 +2,7 @@ package org.robolectric.shadows;
 
 import static android.app.UiAutomation.ROTATION_FREEZE_0;
 import static android.app.UiAutomation.ROTATION_FREEZE_180;
+import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static android.view.WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
 import static android.view.WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
@@ -15,6 +16,7 @@ import static java.util.stream.Collectors.toSet;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.app.Activity;
+import android.app.ActivityThread;
 import android.app.UiAutomation;
 import android.content.ContentResolver;
 import android.content.res.Configuration;
@@ -24,6 +26,7 @@ import android.graphics.Canvas;
 import android.graphics.Paint;
 import android.graphics.Point;
 import android.os.IBinder;
+import android.os.SystemClock;
 import android.provider.Settings;
 import android.view.Display;
 import android.view.InputEvent;
@@ -47,6 +50,7 @@ import java.util.function.Predicate;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
 
 /** Shadow for {@link UiAutomation}. */
@@ -71,6 +75,16 @@ public class ShadowUiAutomation {
     Settings.Global.putFloat(cr, Settings.Global.WINDOW_ANIMATION_SCALE, scale);
   }
 
+  @Implementation(minSdk = P)
+  protected void grantRuntimePermission(String permission, String packageName) {
+    getShadowInstrumentation().grantPermissions(permission);
+  }
+
+  static ShadowInstrumentation getShadowInstrumentation() {
+    ActivityThread activityThread = (ActivityThread) RuntimeEnvironment.getActivityThread();
+    return Shadow.extract(activityThread.getInstrumentation());
+  }
+
   @Implementation(minSdk = TIRAMISU)
   protected void setAnimationScale(float scale) {
     setAnimationScaleCompat(scale);
@@ -123,8 +137,12 @@ public class ShadowUiAutomation {
                   Bitmap.createBitmap(displaySize.x, displaySize.y, Bitmap.Config.ARGB_8888);
               Canvas screenshotCanvas = new Canvas(screenshot);
               Paint paint = new Paint();
+              long drawingTime = SystemClock.uptimeMillis();
               for (Root root : getViewRoots().reverse()) {
                 View rootView = root.getRootView();
+                if (ShadowView.useRealViewAnimations()) {
+                  ((ShadowView) Shadow.extract(rootView)).setDrawingTime(drawingTime);
+                }
                 if (rootView.getWidth() <= 0 || rootView.getHeight() <= 0) {
                   continue;
                 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java
index b8f01364f..c3c3fa4dc 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java
@@ -1,9 +1,9 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.TIRAMISU;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
-import android.annotation.TargetApi;
+import android.annotation.RequiresApi;
 import android.app.PendingIntent;
 import android.app.PendingIntent.CanceledException;
 import android.app.usage.BroadcastResponseStats;
@@ -66,7 +66,7 @@ public class ShadowUsageStatsManager {
    * Keys {@link UsageStats} objects by intervalType (e.g. {@link
    * UsageStatsManager#INTERVAL_WEEKLY}).
    */
-  private static SetMultimap<Integer, UsageStats> usageStatsByIntervalType =
+  private static final SetMultimap<Integer, UsageStats> usageStatsByIntervalType =
       Multimaps.synchronizedSetMultimap(HashMultimap.create());
 
   private static final Map<String, Integer> appStandbyBuckets = Maps.newConcurrentMap();
@@ -111,7 +111,7 @@ public class ShadowUsageStatsManager {
 
   /**
    * Usage session observer registered via {@link
-   * UsageStatsManager#registerUsageSessionObserver(int, String[], long, TimeUnit, long, TimeUnit,
+   * UsageStatsManager#registerUsageSessionObserver(int, String[], Duration, Duration,
    * PendingIntent, PendingIntent)}.
    */
   @AutoValue
@@ -173,9 +173,9 @@ public class ShadowUsageStatsManager {
         @Nonnull PendingIntent callbackIntent) {
       this.observerId = observerId;
       this.packageNames = ImmutableList.copyOf(packageNames);
-      this.timeLimit = checkNotNull(timeLimit);
-      this.timeUsed = checkNotNull(timeUsed);
-      this.callbackIntent = checkNotNull(callbackIntent);
+      this.timeLimit = requireNonNull(timeLimit);
+      this.timeUsed = requireNonNull(timeUsed);
+      this.callbackIntent = requireNonNull(callbackIntent);
     }
 
     public int getObserverId() {
@@ -384,7 +384,7 @@ public class ShadowUsageStatsManager {
   /**
    * Returns the current standby bucket of the specified app that is set by {@code
    * setAppStandbyBucket}. If the standby bucket value has never been set, return {@link
-   * UsageStatsManager.STANDBY_BUCKET_ACTIVE}.
+   * UsageStatsManager#STANDBY_BUCKET_ACTIVE}.
    */
   @Implementation(minSdk = Build.VERSION_CODES.P)
   @HiddenApi
@@ -582,7 +582,7 @@ public class ShadowUsageStatsManager {
   /**
    * Returns the current app's standby bucket that is set by {@code setCurrentAppStandbyBucket}. If
    * the standby bucket value has never been set, return {@link
-   * UsageStatsManager.STANDBY_BUCKET_ACTIVE}.
+   * UsageStatsManager#STANDBY_BUCKET_ACTIVE}.
    */
   @Implementation(minSdk = Build.VERSION_CODES.P)
   @StandbyBuckets
@@ -603,7 +603,7 @@ public class ShadowUsageStatsManager {
   }
 
   /** Sets what app usage observers will consider the source of usage for an activity. */
-  @TargetApi(Build.VERSION_CODES.Q)
+  @RequiresApi(Build.VERSION_CODES.Q)
   public void setUsageSource(@UsageSource int usageSource) {
     currentUsageSource = usageSource;
   }
@@ -650,7 +650,7 @@ public class ShadowUsageStatsManager {
     idToResponseStats.keySet().removeIf(id -> id == idToRemove || idToRemove == 0);
   }
 
-  @TargetApi(Build.VERSION_CODES.TIRAMISU)
+  @RequiresApi(Build.VERSION_CODES.TIRAMISU)
   public void addBroadcastResponseStats(Object /*BroadcastResponseStats*/ statsObject) {
     BroadcastResponseStats stats = (BroadcastResponseStats) statsObject;
     Map<Long, Object /*BroadcastResponseStats*/> idToStats =
@@ -679,7 +679,7 @@ public class ShadowUsageStatsManager {
    * of the Android API.
    */
   public static class UsageStatsBuilder {
-    private UsageStats usageStats = new UsageStats();
+    private final UsageStats usageStats = new UsageStats();
 
     // Use {@link #newBuilder} to construct builders.
     private UsageStatsBuilder() {}
@@ -723,7 +723,7 @@ public class ShadowUsageStatsManager {
    * API.
    */
   public static class EventBuilder {
-    private Event event = new Event();
+    private final Event event = new Event();
 
     private EventBuilder() {}
 
@@ -779,32 +779,32 @@ public class ShadowUsageStatsManager {
       return this;
     }
 
-    @TargetApi(Build.VERSION_CODES.Q)
+    @RequiresApi(Build.VERSION_CODES.Q)
     public EventBuilder setInstanceId(int instanceId) {
       event.mInstanceId = instanceId;
       return this;
     }
 
-    @TargetApi(Build.VERSION_CODES.Q)
+    @RequiresApi(Build.VERSION_CODES.Q)
     public EventBuilder setTaskRootPackage(String taskRootPackage) {
       event.mTaskRootPackage = taskRootPackage;
       return this;
     }
 
-    @TargetApi(Build.VERSION_CODES.Q)
+    @RequiresApi(Build.VERSION_CODES.Q)
     public EventBuilder setTaskRootClass(String taskRootClass) {
       event.mTaskRootClass = taskRootClass;
       return this;
     }
 
-    @TargetApi(Build.VERSION_CODES.P)
+    @RequiresApi(Build.VERSION_CODES.P)
     public EventBuilder setAppStandbyBucket(int bucket) {
       event.mBucketAndReason &= 0xFFFF;
       event.mBucketAndReason |= bucket << 16;
       return this;
     }
 
-    @TargetApi(Build.VERSION_CODES.VANILLA_ICE_CREAM)
+    @RequiresApi(Build.VERSION_CODES.VANILLA_ICE_CREAM)
     public EventBuilder setExtras(PersistableBundle extras) {
       event.mExtras = extras;
       return this;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbDeviceConnection.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbDeviceConnection.java
index e691d608e..bc82603d9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbDeviceConnection.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbDeviceConnection.java
@@ -53,7 +53,7 @@ public class ShadowUsbDeviceConnection {
   }
 
   /**
-   * No-op on Robolectrict. The real implementation would return false on Robolectric and make it
+   * No-op on Robolectric. The real implementation would return false on Robolectric and make it
    * impossible to test callers that expect a successful result. Always returns {@code true}.
    */
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbManager.java
index a852bf03e..83f61d92c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbManager.java
@@ -9,7 +9,7 @@ import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
 import static org.robolectric.util.ReflectionHelpers.callConstructor;
 import static org.robolectric.util.ReflectionHelpers.getStaticField;
 
-import android.annotation.TargetApi;
+import android.annotation.RequiresApi;
 import android.content.Intent;
 import android.hardware.usb.UsbAccessory;
 import android.hardware.usb.UsbDevice;
@@ -24,6 +24,7 @@ import java.io.FileNotFoundException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Objects;
 import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
@@ -174,7 +175,7 @@ public class ShadowUsbManager {
 
   /** Sets the currently attached Usb accessory returned in #getAccessoryList. */
   public void setAttachedUsbAccessory(UsbAccessory usbAccessory) {
-    this.attachedUsbAccessory = usbAccessory;
+    attachedUsbAccessory = usbAccessory;
   }
 
   /**
@@ -182,8 +183,8 @@ public class ShadowUsbManager {
    * already exists, updates the USB device with new permission value.
    */
   public void addOrUpdateUsbDevice(UsbDevice usbDevice, boolean hasPermission) {
-    Preconditions.checkNotNull(usbDevice);
-    Preconditions.checkNotNull(usbDevice.getDeviceName());
+    Objects.requireNonNull(usbDevice);
+    Objects.requireNonNull(usbDevice.getDeviceName());
     usbDevices.put(usbDevice.getDeviceName(), usbDevice);
     if (hasPermission) {
       grantPermission(usbDevice);
@@ -194,7 +195,7 @@ public class ShadowUsbManager {
 
   /** Removes a USB device from available USB devices map. */
   public void removeUsbDevice(UsbDevice usbDevice) {
-    Preconditions.checkNotNull(usbDevice);
+    Objects.requireNonNull(usbDevice);
     usbDevices.remove(usbDevice.getDeviceName());
     revokePermission(usbDevice, RuntimeEnvironment.getApplication().getPackageName());
   }
@@ -202,7 +203,7 @@ public class ShadowUsbManager {
   @Implementation(minSdk = M, maxSdk = P)
   @HiddenApi
   protected @ClassName("android.hardware.usb.UsbPort[]") Object getPorts() {
-    return usbPortStatuses.keySet().toArray(new UsbPort[usbPortStatuses.size()]);
+    return usbPortStatuses.keySet().toArray(new UsbPort[0]);
   }
 
   @Implementation(minSdk = Q, methodName = "getPorts")
@@ -246,7 +247,7 @@ public class ShadowUsbManager {
   }
 
   /** Adds a USB port with given ID and {@link UsbPortStatus} parameters to UsbManager for Q+. */
-  @TargetApi(Q)
+  @RequiresApi(Q)
   public void addPort(
       String portId,
       int statusCurrentMode,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUserManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUserManager.java
index e0d2a84f4..d55f367e7 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUserManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUserManager.java
@@ -9,6 +9,7 @@ import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static android.os.UserManager.RESTRICTION_SOURCE_SYSTEM;
 import static android.os.UserManager.USER_TYPE_FULL_GUEST;
 import static android.os.UserManager.USER_TYPE_FULL_RESTRICTED;
@@ -464,6 +465,16 @@ public class ShadowUserManager {
     return getUserInfo(getContext().getUserId()).isProfile();
   }
 
+  @Implementation(minSdk = UPSIDE_DOWN_CAKE)
+  protected boolean isAdminUser() {
+    if (userManagerState.enforcePermissions && !hasManageUsersPermission()) {
+      throw new SecurityException(
+          "You need INTERACT_ACROSS_USERS or MANAGE_USERS permission to: check isAdminUser");
+    }
+
+    return getUserInfo(getContext().getUserId()).isAdmin();
+  }
+
   @Implementation(minSdk = R)
   protected boolean isUserOfType(String userType) {
     if (userManagerState.enforcePermissions && !hasManageUsersPermission()) {
@@ -745,7 +756,7 @@ public class ShadowUserManager {
    */
   @Implementation(minSdk = M)
   protected boolean isSystemUser() {
-    if (userManagerState.isSystemUser == false) {
+    if (!userManagerState.isSystemUser) {
       return false;
     } else {
       return reflector(UserManagerReflector.class, realObject).isSystemUser();
@@ -814,7 +825,7 @@ public class ShadowUserManager {
    * Sets this process running under a restricted profile; controls the return value of {@link
    * UserManager#isRestrictedProfile()}.
    *
-   * @deprecated use {@link ShadowUserManager#addUser()} instead
+   * @deprecated use {@link ShadowUserManager#addUser(int, String, int)} instead
    */
   @Deprecated
   public void setIsRestrictedProfile(boolean isRestrictedProfile) {
@@ -1032,7 +1043,7 @@ public class ShadowUserManager {
 
   /**
    * Sets whether switching users is allowed or not; controls the return value of {@link
-   * UserManager#canSwitchUser()}
+   * UserManager#canSwitchUsers()}
    *
    * @deprecated use {@link #setUserSwitchability} instead
    */
@@ -1123,7 +1134,7 @@ public class ShadowUserManager {
 
   /**
    * Sets whether multiple users are supported; controls the return value of {@link
-   * UserManager#supportsMultipleUser}.
+   * UserManager#supportsMultipleUsers()}.
    */
   public void setSupportsMultipleUsers(boolean isMultiUserSupported) {
     userManagerState.isMultiUserSupported = isMultiUserSupported;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUwbManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUwbManager.java
index c3138e82e..89d1d6c5d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUwbManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUwbManager.java
@@ -37,7 +37,7 @@ public class ShadowUwbManager {
 
   @Implementation
   protected void registerAdapterStateCallback(Executor executor, AdapterStateCallback callback) {
-    this.callback = callback;
+    ShadowUwbManager.callback = callback;
     callback.onStateChanged(adapterState, stateChangedReason);
   }
 
@@ -51,19 +51,20 @@ public class ShadowUwbManager {
    * @throws IllegalArgumentException if the callback is missing.
    */
   public void simulateAdapterStateChange(@AdapterState int state, @StateChangeReason int reason) {
-    if (this.callback == null) {
+    if (callback == null) {
       throw new IllegalArgumentException("AdapterStateCallback should not be null");
     }
 
     adapterState = state;
     stateChangedReason = reason;
 
-    this.callback.onStateChanged(state, reason);
+    callback.onStateChanged(state, reason);
   }
 
   /**
-   * Simply returns the bundle provided by {@link ShadowUwbManager#setSpecificationInfo()}, allowing
-   * the tester to dictate available features.
+   * Simply returns the bundle provided by {@link
+   * ShadowUwbManager#setSpecificationInfo(PersistableBundle)}, allowing the tester to dictate
+   * available features.
    */
   @Implementation
   protected PersistableBundle getSpecificationInfo() {
@@ -71,7 +72,8 @@ public class ShadowUwbManager {
   }
 
   /**
-   * Returns the adapter state provided by {@link ShadowUwbManager#simulateAdapterStateChange()}.
+   * Returns the adapter state provided by {@link ShadowUwbManager#simulateAdapterStateChange(int,
+   * int)}.
    */
   @Implementation
   @AdapterState
@@ -81,7 +83,8 @@ public class ShadowUwbManager {
 
   /**
    * Instantiates a {@link ShadowRangingSession} with the adapter provided by {@link
-   * ShadowUwbManager#setUwbAdapter()}, allowing the tester dictate the results of ranging attempts.
+   * ShadowUwbManager#setUwbAdapter(ShadowRangingSession.Adapter)}, allowing the tester dictate the
+   * results of ranging attempts.
    *
    * @throws IllegalArgumentException if UWB is disabled.
    */
@@ -100,12 +103,12 @@ public class ShadowUwbManager {
 
   /** Sets the UWB adapter to use for new {@link ShadowRangingSession}s. */
   public void setUwbAdapter(ShadowRangingSession.Adapter adapter) {
-    this.adapter = adapter;
+    ShadowUwbManager.adapter = adapter;
   }
 
   /** Sets the bundle to be returned by {@link android.uwb.UwbManager#getSpecificationInfo}. */
   public void setSpecificationInfo(PersistableBundle specificationInfo) {
-    this.specificationInfo = new PersistableBundle(specificationInfo);
+    ShadowUwbManager.specificationInfo = new PersistableBundle(specificationInfo);
   }
 
   /**
@@ -145,8 +148,8 @@ public class ShadowUwbManager {
       stateChanged = true;
     }
 
-    if (this.callback != null && stateChanged) {
-      this.callback.onStateChanged(
+    if (callback != null && stateChanged) {
+      callback.onStateChanged(
           adapterState, AdapterStateCallback.STATE_CHANGED_REASON_SYSTEM_POLICY);
     }
   }
@@ -162,7 +165,7 @@ public class ShadowUwbManager {
 
   /** Sets the list of bundles to be returned by {@link android.uwb.UwbManager#getChipInfos}. */
   public void setChipInfos(List<PersistableBundle> chipInfos) {
-    this.chipInfos = new ArrayList<>(chipInfos);
+    ShadowUwbManager.chipInfos = new ArrayList<>(chipInfos);
   }
 
   @Resetter
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVMRuntime.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVMRuntime.java
index 22fcf33dc..467ed5e8b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVMRuntime.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVMRuntime.java
@@ -159,6 +159,7 @@ public class ShadowVMRuntime {
   }
 
   /** Returns the instruction set of the current runtime. */
+  @Nullable
   @Implementation
   protected static String getCurrentInstructionSet() {
     return currentInstructionSet;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVelocityTracker.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVelocityTracker.java
index aed29a460..69f431fff 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVelocityTracker.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVelocityTracker.java
@@ -18,8 +18,8 @@ public class ShadowVelocityTracker {
   private final Movement[] movements = new Movement[HISTORY_SIZE];
   private int curIndex = 0;
 
-  private SparseArray<Float> computedVelocityX = new SparseArray<>();
-  private SparseArray<Float> computedVelocityY = new SparseArray<>();
+  private final SparseArray<Float> computedVelocityX = new SparseArray<>();
+  private final SparseArray<Float> computedVelocityY = new SparseArray<>();
 
   private void maybeInitialize() {
     if (initialized) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVibrator.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVibrator.java
index 05f50e0ff..e6b4bcae9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVibrator.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVibrator.java
@@ -4,9 +4,10 @@ import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 
 import android.media.AudioAttributes;
+import android.os.VibrationEffect;
 import android.os.Vibrator;
 import android.os.vibrator.PrimitiveSegment;
-import android.util.SparseArray;
+import android.util.SparseIntArray;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
@@ -27,7 +28,7 @@ public class ShadowVibrator {
   protected static final List<Object> vibrationEffectSegments = new ArrayList<>();
   protected static final List<PrimitiveEffect> primitiveEffects = new ArrayList<>();
   protected static final List<Integer> supportedPrimitives = new ArrayList<>();
-  protected static final SparseArray<Integer> primitiveidsToDurationMillis = new SparseArray<>();
+  protected static final SparseIntArray primitiveidsToDurationMillis = new SparseIntArray();
 
   @Nullable protected static Object vibrationAttributesFromLastVibration;
   @Nullable protected static AudioAttributes audioAttributesFromLastVibration;
@@ -107,8 +108,8 @@ public class ShadowVibrator {
 
   @Implementation(minSdk = R)
   protected boolean areAllPrimitivesSupported(int... primitiveIds) {
-    for (int i = 0; i < primitiveIds.length; i++) {
-      if (!supportedPrimitives.contains(primitiveIds[i])) {
+    for (int primitiveId : primitiveIds) {
+      if (!supportedPrimitives.contains(primitiveId)) {
         return false;
       }
     }
@@ -190,7 +191,7 @@ public class ShadowVibrator {
       if (this == o) {
         return true;
       }
-      if (o == null || !getClass().isInstance(o)) {
+      if (!getClass().isInstance(o)) {
         return false;
       }
       PrimitiveEffect that = (PrimitiveEffect) o;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVideoView.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVideoView.java
index 7818e29dc..2e2cae1d6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVideoView.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVideoView.java
@@ -9,7 +9,7 @@ import org.robolectric.annotation.Implements;
 @Implements(VideoView.class)
 @SuppressWarnings({"UnusedDeclaration"})
 public class ShadowVideoView extends ShadowSurfaceView {
-  private MediaPlayer.OnCompletionListener completionListner;
+  private MediaPlayer.OnCompletionListener completionListener;
   private MediaPlayer.OnErrorListener errorListener;
   private MediaPlayer.OnPreparedListener preparedListener;
 
@@ -39,7 +39,7 @@ public class ShadowVideoView extends ShadowSurfaceView {
 
   @Implementation
   protected void setOnCompletionListener(MediaPlayer.OnCompletionListener l) {
-    completionListner = l;
+    completionListener = l;
   }
 
   @Implementation
@@ -127,7 +127,7 @@ public class ShadowVideoView extends ShadowSurfaceView {
    * @return On completion listener.
    */
   public MediaPlayer.OnCompletionListener getOnCompletionListener() {
-    return completionListner;
+    return completionListener;
   }
 
   /**
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowView.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowView.java
index daaec1977..b75ce23da 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowView.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowView.java
@@ -5,6 +5,7 @@ import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static org.robolectric.shadows.ShadowLooper.shadowMainLooper;
+import static org.robolectric.shadows.ShadowView.useRealViewAnimations;
 import static org.robolectric.util.ReflectionHelpers.getField;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
@@ -25,6 +26,7 @@ import android.view.Choreographer;
 import android.view.IWindowFocusObserver;
 import android.view.IWindowId;
 import android.view.MotionEvent;
+import android.view.ThreadedRenderer;
 import android.view.View;
 import android.view.ViewParent;
 import android.view.WindowId;
@@ -39,6 +41,7 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.atomic.AtomicBoolean;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.GraphicsMode;
 import org.robolectric.annotation.GraphicsMode.Mode;
@@ -85,6 +88,7 @@ public class ShadowView {
   private int layerType;
   private final ArrayList<Animation> animations = new ArrayList<>();
   private AnimationRunner animationRunner;
+  private static final AtomicBoolean useRealViewAnimations = new AtomicBoolean(false);
 
   /**
    * Calls {@code performClick()} on a {@code View} after ensuring that it and its ancestors are
@@ -546,14 +550,7 @@ public class ShadowView {
     if (ShadowLooper.looperMode() == LooperMode.Mode.LEGACY) {
       ShadowApplication.getInstance()
           .getForegroundThreadScheduler()
-          .postDelayed(
-              new Runnable() {
-                @Override
-                public void run() {
-                  realView.invalidate();
-                }
-              },
-              delayMilliseconds);
+          .postDelayed(() -> realView.invalidate(), delayMilliseconds);
     } else {
       reflector(_View_.class, realView).postInvalidateDelayed(delayMilliseconds);
     }
@@ -646,14 +643,15 @@ public class ShadowView {
   @Implementation
   protected void setAnimation(final Animation animation) {
     reflector(_View_.class, realView).setAnimation(animation);
-
-    if (animation != null) {
-      animations.add(animation);
-      if (animationRunner != null) {
-        animationRunner.cancel();
+    if (!useRealViewAnimations()) {
+      if (animation != null) {
+        animations.add(animation);
+        if (animationRunner != null) {
+          animationRunner.cancel();
+        }
+        animationRunner = new AnimationRunner(animation);
+        animationRunner.start();
       }
-      animationRunner = new AnimationRunner(animation);
-      animationRunner.start();
     }
   }
 
@@ -661,20 +659,11 @@ public class ShadowView {
   protected void clearAnimation() {
     reflector(_View_.class, realView).clearAnimation();
 
-    if (animationRunner != null) {
-      animationRunner.cancel();
-      animationRunner = null;
-    }
-  }
-
-  @Implementation
-  protected boolean initialAwakenScrollBars() {
-    // Temporarily allow disabling initial awaken of scroll bars to aid in migration of tests to
-    // default to window's being marked visible, this will be removed once migration is complete.
-    if (Boolean.getBoolean("robolectric.disableInitialAwakenScrollBars")) {
-      return false;
-    } else {
-      return viewReflector.initialAwakenScrollBars();
+    if (!useRealViewAnimations()) {
+      if (animationRunner != null) {
+        animationRunner.cancel();
+        animationRunner = null;
+      }
     }
   }
 
@@ -761,6 +750,17 @@ public class ShadowView {
     return reflector(_View_.class, realView).getAttachInfo();
   }
 
+  /**
+   * Sets the drawing time of the view. This is used in the `draw` methods when rendering
+   * animations.
+   */
+  void setDrawingTime(long drawingTime) {
+    Object attachInfo = getAttachInfo();
+    if (attachInfo != null) {
+      reflector(_AttachInfo_.class, attachInfo).setDrawingTime(drawingTime);
+    }
+  }
+
   /** Reflector interface for {@link View}'s internals. */
   @ForType(View.class)
   private interface _View_ {
@@ -864,9 +864,6 @@ public class ShadowView {
     @Direct
     int getSourceLayoutResId();
 
-    @Direct
-    boolean initialAwakenScrollBars();
-
     @Accessor("mScrollX")
     void setMemberScrollX(int value);
 
@@ -891,9 +888,6 @@ public class ShadowView {
     @Direct
     void setScrollY(int value);
 
-    @Direct
-    void __constructor__(Context context, AttributeSet attributeSet, int defStyle);
-
     @Direct
     void __constructor__(
         Context context, AttributeSet attributeSet, int defStyleAttr, int defStyleRes);
@@ -1023,6 +1017,12 @@ public class ShadowView {
 
     @Accessor("mWindowId")
     void setWindowId(WindowId windowId);
+
+    @Accessor("mDrawingTime")
+    void setDrawingTime(long drawingTime);
+
+    @Accessor("mThreadedRenderer")
+    ThreadedRenderer getThreadedRenderer();
   }
 
   /**
@@ -1048,4 +1048,29 @@ public class ShadowView {
     return useRealGraphics()
         || Boolean.parseBoolean(System.getProperty("robolectric.useRealScrolling", "true"));
   }
+
+  /**
+   * This method allows tests to opt-in to use the real View animation code.
+   *
+   * <p>This option is primarily intended for use with the Robolectric {@link
+   * org.robolectric.simulator.Simulator}}.
+   *
+   * <p>Robolectric by default has a low-quality simulation of View animations (i.e. {@link
+   * View#startAnimation(Animation)}). This uses {@link AnimationRunner}. In real Android, View
+   * animations are interpolated during the View's draw method, which is triggered by Choreographer
+   * callbacks in ViewRootImpl objects. However, in Robolectric, Views are not being continually
+   * drawn, which is the reason that {@link AnimationRunner} exists.
+   *
+   * <p>Ths method allows disabling this {@link AnimationRunner} mechanism and instead uses the real
+   * Android code for View animations. Note that to make this work, it requires frame-by-frame
+   * rendering to occur (which happens in the Robolectric simulator).
+   */
+  public static void setUseRealViewAnimations(boolean value) {
+    useRealViewAnimations.set(value);
+  }
+
+  /** Returns whether real Android View animation logic is being used. */
+  static boolean useRealViewAnimations() {
+    return useRealViewAnimations.get();
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewConfiguration.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewConfiguration.java
index 10512159d..688c03347 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewConfiguration.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewConfiguration.java
@@ -38,6 +38,7 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
+import org.robolectric.versioning.AndroidVersions;
 
 @SuppressWarnings({"UnusedDeclaration"})
 @Implements(ViewConfiguration.class)
@@ -189,8 +190,10 @@ public class ShadowViewConfiguration {
 
   @Resetter
   public static void reset() {
-    SparseArray<ViewConfiguration> configurations =
-        reflector(ViewConfigurationReflector.class).getStaticCache();
-    configurations.clear();
+    if (AndroidVersions.CURRENT.getSdkInt() >= AndroidVersions.V.SDK_INT) {
+      ViewConfiguration.resetCacheForTesting();
+    } else {
+      reflector(ViewConfigurationReflector.class).getStaticCache().clear();
+    }
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewGroup.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewGroup.java
index 200c21aa9..f15ba9f19 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewGroup.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewGroup.java
@@ -26,9 +26,7 @@ public class ShadowViewGroup extends ShadowView {
   @Implementation
   protected void addView(final View child, final int index, final ViewGroup.LayoutParams params) {
     Runnable addViewRunnable =
-        () -> {
-          reflector(ViewGroupReflector.class, realViewGroup).addView(child, index, params);
-        };
+        () -> reflector(ViewGroupReflector.class, realViewGroup).addView(child, index, params);
     if (ShadowLooper.looperMode() == Mode.LEGACY) {
       shadowMainLooper().runPaused(addViewRunnable);
     } else {
@@ -49,7 +47,7 @@ public class ShadowViewGroup extends ShadowView {
       View child = realViewGroup.getChildAt(i);
       ShadowView shadowView = Shadow.extract(child);
       String childText = shadowView.innerText();
-      if (childText.length() > 0) {
+      if (!childText.isEmpty()) {
         innerText.append(delimiter);
         delimiter = " ";
       }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewRootImpl.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewRootImpl.java
index 142a73f9e..d5771459c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewRootImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewRootImpl.java
@@ -11,6 +11,7 @@ import android.view.HandlerActionQueue;
 import android.view.IWindow;
 import android.view.Surface;
 import android.view.SurfaceControl;
+import android.view.ThreadedRenderer;
 import android.view.View;
 import android.view.ViewRootImpl;
 import android.view.WindowInsets;
@@ -21,6 +22,7 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.annotation.Resetter;
+import org.robolectric.shadows.ShadowView._AttachInfo_;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
@@ -77,6 +79,11 @@ public class ShadowViewRootImpl {
     return reflector(ViewRootImplReflector.class, realObject).getSurface();
   }
 
+  ThreadedRenderer getThreadedRenderer() {
+    Object attachInfo = reflector(ViewRootImplReflector.class, realObject).getAttachInfo();
+    return reflector(_AttachInfo_.class, attachInfo).getThreadedRenderer();
+  }
+
   /** Reflector interface for {@link ViewRootImpl}'s internals. */
   @ForType(ViewRootImpl.class)
   protected interface ViewRootImplReflector {
@@ -124,6 +131,9 @@ public class ShadowViewRootImpl {
     @Accessor("mWindowAttributes")
     WindowManager.LayoutParams getWindowAttributes();
 
+    @Accessor("mAttachInfo")
+    Object getAttachInfo();
+
     // SDK <= S_V2
     void windowFocusChanged(boolean hasFocus, boolean inTouchMode);
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualDeviceManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualDeviceManager.java
index cd47491ec..487e41ee0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualDeviceManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualDeviceManager.java
@@ -58,7 +58,7 @@ public class ShadowVirtualDeviceManager {
   @Implementation
   protected void __constructor__(IVirtualDeviceManager service, Context context) {
     this.context = context;
-    this.service = service;
+    ShadowVirtualDeviceManager.service = service;
   }
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualRefBasePtr.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualRefBasePtr.java
index 6823a7852..5bdd412d0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualRefBasePtr.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualRefBasePtr.java
@@ -11,7 +11,7 @@ public class ShadowVirtualRefBasePtr {
       new NativeObjRegistry<>(RefHolder.class);
 
   protected static synchronized <T> long put(T object) {
-    return NATIVE_REGISTRY.register(new RefHolder<T>(object));
+    return NATIVE_REGISTRY.register(new RefHolder<>(object));
   }
 
   protected static synchronized <T> T get(long nativePtr, Class<T> clazz) {
@@ -37,7 +37,7 @@ public class ShadowVirtualRefBasePtr {
   }
 
   private static final class RefHolder<T> {
-    private T nativeThing;
+    private final T nativeThing;
     private int refCount;
 
     private RefHolder(T object) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVisualVoicemailSms.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVisualVoicemailSms.java
index 05de496c5..da3d21a3b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVisualVoicemailSms.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVisualVoicemailSms.java
@@ -38,6 +38,7 @@ public class ShadowVisualVoicemailSms {
     return this;
   }
 
+  @Nullable
   @Implementation
   protected String getPrefix() {
     return prefix;
@@ -48,6 +49,7 @@ public class ShadowVisualVoicemailSms {
     return this;
   }
 
+  @Nullable
   @Implementation
   protected Bundle getFields() {
     return fields;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVisualizer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVisualizer.java
index ca559490b..bf15b0357 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVisualizer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVisualizer.java
@@ -131,7 +131,7 @@ public class ShadowVisualizer {
   /**
    * Sets the error code to override setter methods in this class.
    *
-   * <p>When the error code is set to anything other than {@link Visualizer.SUCCESS} setters in the
+   * <p>When the error code is set to anything other than {@link Visualizer#SUCCESS} setters in the
    * Visualizer will early-out and return that error code.
    */
   public void setErrorCode(int errorCode) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVoiceInteractionSession.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVoiceInteractionSession.java
index 4a6f87409..a4f5d7db1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVoiceInteractionSession.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVoiceInteractionSession.java
@@ -136,7 +136,7 @@ public class ShadowVoiceInteractionSession {
    *     href="https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/app/Instrumentation.java;drc=5f8f8ab44b4ac659804a13fb75b6516f86f977e7;l=2225">Instrumentation.checkStartActivityResult</a>
    *     for possible runtime exceptions that can be thrown.
    */
-  public void setStartVoiceActivityException(RuntimeException exception) {
+  public void setStartVoiceActivityException(@Nullable RuntimeException exception) {
     startVoiceActivityException = exception;
   }
 
@@ -148,7 +148,7 @@ public class ShadowVoiceInteractionSession {
    *     href="https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/app/Instrumentation.java;drc=5f8f8ab44b4ac659804a13fb75b6516f86f977e7;l=2225">Instrumentation.checkStartActivityResult</a>
    *     for possible runtime exceptions that can be thrown.
    */
-  public void setStartAssistantActivityException(RuntimeException exception) {
+  public void setStartAssistantActivityException(@Nullable RuntimeException exception) {
     startAssistantActivityException = exception;
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWallpaperManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWallpaperManager.java
index 77adb8ff2..f3681f107 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWallpaperManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWallpaperManager.java
@@ -49,7 +49,7 @@ public class ShadowWallpaperManager {
   private static boolean isWallpaperSupported = true;
   private static WallpaperInfo wallpaperInfo = null;
   private static final List<WallpaperCommandRecord> wallpaperCommandRecords = new ArrayList<>();
-  private static AtomicInteger wallpaperId = new AtomicInteger(0);
+  private static final AtomicInteger wallpaperId = new AtomicInteger(0);
   private static int lockScreenId;
   private static int homeScreenId;
   private static int lockScreenResId;
@@ -102,7 +102,7 @@ public class ShadowWallpaperManager {
    */
   @Implementation
   protected boolean hasResourceWallpaper(int resid) {
-    return resid == this.lockScreenResId || resid == this.homeScreenResId;
+    return resid == lockScreenResId || resid == homeScreenResId;
   }
 
   /**
@@ -313,7 +313,7 @@ public class ShadowWallpaperManager {
 
   /**
    * Throws {@link SecurityException} if the caller doesn't have {@link
-   * permission.SET_WALLPAPER_COMPONENT}.
+   * permission#SET_WALLPAPER_COMPONENT}.
    */
   private static void enforceWallpaperComponentPermission() {
     // Robolectric doesn't stimulate IPC calls. When this code is executed, it will still be running
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java
index 132286619..143f858bf 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java
@@ -1,6 +1,6 @@
 package org.robolectric.shadows;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import android.app.wearable.WearableSensingManager;
 import android.app.wearable.WearableSensingManager.StatusCode;
@@ -65,16 +65,16 @@ public class ShadowWearableSensingManager {
       @Nullable ComponentName targetVisComponentName,
       @Nonnull Executor executor,
       @Nonnull @StatusCode Consumer<Integer> statusConsumer) {
-    checkNotNull(executor);
-    checkNotNull(statusConsumer);
+    requireNonNull(executor);
+    requireNonNull(statusConsumer);
     executor.execute(() -> statusConsumer.accept(startHotwordRecognitionResult));
   }
 
   @Implementation(minSdk = V.SDK_INT)
   protected void stopHotwordRecognition(
       @Nonnull Executor executor, @Nonnull @StatusCode Consumer<Integer> statusConsumer) {
-    checkNotNull(executor);
-    checkNotNull(statusConsumer);
+    requireNonNull(executor);
+    requireNonNull(statusConsumer);
     executor.execute(() -> statusConsumer.accept(stopHotwordRecognitionResult));
   }
 
@@ -92,7 +92,7 @@ public class ShadowWearableSensingManager {
    */
   public void setStartHotwordRecognitionResult(
       @Nonnull @StatusCode Integer startHotwordRecognitionResult) {
-    checkNotNull(startHotwordRecognitionResult);
+    requireNonNull(startHotwordRecognitionResult);
     ShadowWearableSensingManager.startHotwordRecognitionResult = startHotwordRecognitionResult;
   }
 
@@ -102,7 +102,7 @@ public class ShadowWearableSensingManager {
    */
   public void setStopHotwordRecognitionResult(
       @Nonnull @StatusCode Integer stopHotwordRecognitionResult) {
-    checkNotNull(stopHotwordRecognitionResult);
+    requireNonNull(stopHotwordRecognitionResult);
     ShadowWearableSensingManager.stopHotwordRecognitionResult = stopHotwordRecognitionResult;
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWebView.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWebView.java
index 8847b5e2f..42296df62 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWebView.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWebView.java
@@ -21,11 +21,8 @@ import android.webkit.WebView;
 import android.webkit.WebView.HitTestResult;
 import android.webkit.WebViewClient;
 import android.webkit.WebViewFactoryProvider;
+import android.webkit.WebViewProvider;
 import com.google.common.collect.ImmutableList;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -50,11 +47,11 @@ public class ShadowWebView extends ShadowViewGroup {
 
   private static PackageInfo packageInfo = null;
 
-  private List<RoboWebMessagePort[]> allCreatedPorts = new ArrayList<>();
+  private final List<RoboWebMessagePort[]> allCreatedPorts = new ArrayList<>();
   private String lastUrl;
   private Map<String, String> lastAdditionalHttpHeaders;
-  private HashMap<String, Object> javascriptInterfaces = new HashMap<>();
-  private WebSettings webSettings = new RoboWebSettings();
+  private final HashMap<String, Object> javascriptInterfaces = new HashMap<>();
+  private final WebSettings webSettings = new RoboWebSettings();
   private WebViewClient webViewClient = null;
   private boolean clearCacheCalled = false;
   private boolean clearCacheIncludeDiskFiles = false;
@@ -98,46 +95,8 @@ public class ShadowWebView extends ShadowViewGroup {
   @HiddenApi
   @Implementation
   public void ensureProviderCreated() {
-    final ClassLoader classLoader = getClass().getClassLoader();
-    Class<?> webViewProviderClass = getClassNamed("android.webkit.WebViewProvider");
-    Field mProvider;
-    try {
-      mProvider = WebView.class.getDeclaredField("mProvider");
-      mProvider.setAccessible(true);
-      if (mProvider.get(realView) == null) {
-        Object provider =
-            Proxy.newProxyInstance(
-                classLoader,
-                new Class[] {webViewProviderClass},
-                new InvocationHandler() {
-                  @Override
-                  public Object invoke(Object proxy, Method method, Object[] args)
-                      throws Throwable {
-                    if (method.getName().equals("getViewDelegate")
-                        || method.getName().equals("getScrollDelegate")) {
-                      return Proxy.newProxyInstance(
-                          classLoader,
-                          new Class[] {
-                            getClassNamed("android.webkit.WebViewProvider$ViewDelegate"),
-                            getClassNamed("android.webkit.WebViewProvider$ScrollDelegate")
-                          },
-                          new InvocationHandler() {
-                            @Override
-                            public Object invoke(Object proxy, Method method, Object[] args)
-                                throws Throwable {
-                              return nullish(method);
-                            }
-                          });
-                    }
-
-                    return nullish(method);
-                  }
-                });
-        mProvider.set(realView, provider);
-      }
-    } catch (NoSuchFieldException | IllegalAccessException e) {
-      throw new RuntimeException(e);
-    }
+    ReflectionHelpers.setField(
+        realWebView, "mProvider", ReflectionHelpers.createDeepProxy(WebViewProvider.class));
   }
 
   @Implementation
@@ -145,27 +104,6 @@ public class ShadowWebView extends ShadowViewGroup {
     ReflectionHelpers.setField(realWebView, "mLayoutParams", params);
   }
 
-  private Object nullish(Method method) {
-    Class<?> returnType = method.getReturnType();
-    if (returnType.equals(long.class)
-        || returnType.equals(double.class)
-        || returnType.equals(int.class)
-        || returnType.equals(float.class)
-        || returnType.equals(short.class)
-        || returnType.equals(byte.class)) return 0;
-    if (returnType.equals(char.class)) return '\0';
-    if (returnType.equals(boolean.class)) return false;
-    return null;
-  }
-
-  private Class<?> getClassNamed(String className) {
-    try {
-      return getClass().getClassLoader().loadClass(className);
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
   @Implementation
   protected void loadUrl(String url) {
     loadUrl(url, null);
@@ -238,7 +176,7 @@ public class ShadowWebView extends ShadowViewGroup {
 
   /**
    * Performs no callbacks on {@link WebViewClient} and {@link WebChromeClient} when any of {@link
-   * #loadUrl}, {@link loadData} or {@link #loadDataWithBaseURL} is called.
+   * #loadUrl}, {@link #loadData} or {@link #loadDataWithBaseURL} is called.
    */
   public void performNoPageLoadClientCallbacks() {
     this.pageLoadType = PageLoadType.UNDEFINED;
@@ -246,7 +184,7 @@ public class ShadowWebView extends ShadowViewGroup {
 
   /**
    * Performs callbacks on {@link WebViewClient} and {@link WebChromeClient} that simulates a
-   * successful page load when any of {@link #loadUrl}, {@link loadData} or {@link
+   * successful page load when any of {@link #loadUrl}, {@link #loadData} or {@link
    * #loadDataWithBaseURL} is called.
    */
   public void performSuccessfulPageLoadClientCallbacks() {
@@ -597,7 +535,7 @@ public class ShadowWebView extends ShadowViewGroup {
 
   @Implementation
   protected WebBackForwardList saveState(Bundle outState) {
-    if (history.size() > 0) {
+    if (!history.isEmpty()) {
       outState.putStringArrayList(HISTORY_KEY, history);
       outState.putInt(HISTORY_INDEX_KEY, historyIndex);
     }
@@ -614,7 +552,7 @@ public class ShadowWebView extends ShadowViewGroup {
       historyIndex = inState.getInt(HISTORY_INDEX_KEY);
     }
 
-    if (history.size() > 0) {
+    if (!history.isEmpty()) {
       originalUrl = history.get(historyIndex);
       lastUrl = history.get(historyIndex);
       return new BackForwardList(history, historyIndex);
@@ -714,8 +652,8 @@ public class ShadowWebView extends ShadowViewGroup {
    * Defines a type of page load which is associated with a certain order of {@link WebViewClient}
    * and {@link WebChromeClient} callbacks.
    *
-   * <p>A page load is triggered either using {@link #loadUrl}, {@link loadData} or {@link
-   * loadDataWithBaseURL}.
+   * <p>A page load is triggered either using {@link #loadUrl}, {@link #loadData} or {@link
+   * #loadDataWithBaseURL}.
    */
   private enum PageLoadType {
     /** Default type, triggers no {@link WebViewClient} or {@link WebChromeClient} callbacks. */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiAwareManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiAwareManager.java
index 366e598f1..547f0d647 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiAwareManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiAwareManager.java
@@ -84,31 +84,31 @@ public class ShadowWifiAwareManager {
 
   /** Sets the availability of the wifiAwareManager. */
   public void setAvailable(boolean available) {
-    this.available = available;
+    ShadowWifiAwareManager.available = available;
   }
 
   /** Sets parameter to pass to AttachCallback#onAttach(WifiAwareSession session) */
   public void setWifiAwareSession(WifiAwareSession session) {
-    this.session = session;
+    ShadowWifiAwareManager.session = session;
   }
 
   /** Sets the boolean value indicating if a wifiAwareSession has been detached. */
   public void setSessionDetached(boolean sessionDetached) {
-    this.sessionDetached = sessionDetached;
+    ShadowWifiAwareManager.sessionDetached = sessionDetached;
   }
 
   /**
    * Sets parameter to pass to DiscoverySessionCallback#onPublishStarted(PublishDiscoverySession)
    */
   public void setDiscoverySessionToPublish(PublishDiscoverySession publishDiscoverySession) {
-    this.discoverySessionToPublish = publishDiscoverySession;
+    discoverySessionToPublish = publishDiscoverySession;
   }
 
   /**
    * Sets param to pass to DiscoverySessionCallback#onSubscribeStarted(SubscribeDiscoverySession)
    */
   public void setDiscoverySessionToSubscribe(SubscribeDiscoverySession subscribeDiscoverySession) {
-    this.discoverySessionToSubscribe = subscribeDiscoverySession;
+    discoverySessionToSubscribe = subscribeDiscoverySession;
   }
 
   @Resetter
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiManager.java
index 1061fee1e..2ca18197f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiManager.java
@@ -31,7 +31,6 @@ import android.os.Looper;
 import android.provider.Settings;
 import android.util.ArraySet;
 import android.util.Pair;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -42,6 +41,7 @@ import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
@@ -81,7 +81,7 @@ public class ShadowWifiManager {
   private boolean isWpa3SaeH2eSupported = false;
   private boolean isWpa3SaePublicKeySupported = false;
   private boolean isWpa3SuiteBSupported = false;
-  private AtomicInteger activeLockCount = new AtomicInteger(0);
+  private final AtomicInteger activeLockCount = new AtomicInteger(0);
   private final BitSet readOnlyNetworkIds = new BitSet();
   private final ConcurrentHashMap<WifiManager.OnWifiUsabilityStatsListener, Executor>
       wifiUsabilityStatsListeners = new ConcurrentHashMap<>();
@@ -119,7 +119,7 @@ public class ShadowWifiManager {
 
   @Implementation(minSdk = Q)
   protected int addNetworkSuggestions(List<WifiNetworkSuggestion> networkSuggestions) {
-    Preconditions.checkNotNull(networkSuggestions);
+    Objects.requireNonNull(networkSuggestions);
     if (addNetworkSuggestionsResult == WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS) {
       lastAddedSuggestions = ImmutableList.copyOf(networkSuggestions);
     }
@@ -280,11 +280,7 @@ public class ShadowWifiManager {
 
   @Implementation
   protected List<WifiConfiguration> getConfiguredNetworks() {
-    final ArrayList<WifiConfiguration> wifiConfigurations = new ArrayList<>();
-    for (WifiConfiguration wifiConfiguration : networkIdToConfiguredNetworks.values()) {
-      wifiConfigurations.add(wifiConfiguration);
-    }
-    return wifiConfigurations;
+    return new ArrayList<>(networkIdToConfiguredNetworks.values());
   }
 
   @Implementation
@@ -527,7 +523,7 @@ public class ShadowWifiManager {
   }
 
   /**
-   * Prevents a networkId from being updated using the {@link updateNetwork(WifiConfiguration)}
+   * Prevents a networkId from being updated using the {@link #updateNetwork(WifiConfiguration)}
    * method. This is to simulate the case where a separate application creates a network, and the
    * Android security model prevents your application from updating it.
    */
@@ -701,6 +697,7 @@ public class ShadowWifiManager {
     Set<Map.Entry<WifiManager.OnWifiUsabilityStatsListener, Executor>> toNotify = new ArraySet<>();
     toNotify.addAll(wifiUsabilityStatsListeners.entrySet());
     for (Map.Entry<WifiManager.OnWifiUsabilityStatsListener, Executor> entry : toNotify) {
+      //noinspection Convert2Lambda
       entry
           .getValue()
           .execute(
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiP2pManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiP2pManager.java
index 0fc38a726..83a3c419d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiP2pManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiP2pManager.java
@@ -7,9 +7,9 @@ import android.net.wifi.p2p.WifiP2pManager.ActionListener;
 import android.net.wifi.p2p.WifiP2pManager.Channel;
 import android.os.Handler;
 import android.os.Looper;
-import com.google.common.base.Preconditions;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Objects;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
@@ -42,10 +42,10 @@ public class ShadowWifiP2pManager {
   @Implementation
   protected void setWifiP2pChannels(
       Channel c, int listeningChannel, int operatingChannel, ActionListener al) {
-    Preconditions.checkNotNull(c);
-    Preconditions.checkNotNull(al);
-    this.listeningChannel = listeningChannel;
-    this.operatingChannel = operatingChannel;
+    Objects.requireNonNull(c);
+    Objects.requireNonNull(al);
+    ShadowWifiP2pManager.listeningChannel = listeningChannel;
+    ShadowWifiP2pManager.operatingChannel = operatingChannel;
   }
 
   @Implementation
@@ -66,16 +66,13 @@ public class ShadowWifiP2pManager {
     }
 
     handler.post(
-        new Runnable() {
-          @Override
-          public void run() {
-            if (nextActionFailure == -1) {
-              al.onSuccess();
-            } else {
-              al.onFailure(nextActionFailure);
-            }
-            nextActionFailure = NO_FAILURE;
+        () -> {
+          if (nextActionFailure == -1) {
+            al.onSuccess();
+          } else {
+            al.onFailure(nextActionFailure);
           }
+          nextActionFailure = NO_FAILURE;
         });
   }
 
@@ -85,13 +82,7 @@ public class ShadowWifiP2pManager {
       return;
     }
 
-    handler.post(
-        new Runnable() {
-          @Override
-          public void run() {
-            gl.onGroupInfoAvailable(p2pGroupmap.get(c));
-          }
-        });
+    handler.post(() -> gl.onGroupInfoAvailable(p2pGroupmap.get(c)));
   }
 
   @Implementation
@@ -100,7 +91,7 @@ public class ShadowWifiP2pManager {
   }
 
   public void setNextActionFailure(int nextActionFailure) {
-    this.nextActionFailure = nextActionFailure;
+    ShadowWifiP2pManager.nextActionFailure = nextActionFailure;
   }
 
   public void setGroupInfo(Channel channel, WifiP2pGroup wifiP2pGroup) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiScanner.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiScanner.java
index 15e3efc57..c7c9e57f8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiScanner.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiScanner.java
@@ -56,7 +56,7 @@ public class ShadowWifiScanner {
     Map<WifiScanner.ActionListener, IWifiScannerListener.Stub> listenerMap =
         reflector(WifiScannerReflector.class, realWifiScanner).getListenerMap();
 
-    List<IWifiScannerListener.Stub> listeners = null;
+    List<IWifiScannerListener.Stub> listeners;
     synchronized (listenerMapLock) {
       listeners = new ArrayList<>(listenerMap.values());
     }
@@ -73,7 +73,7 @@ public class ShadowWifiScanner {
   private void notifyScanListeners() {
     Object listenerMapLock =
         reflector(WifiScannerReflector.class, realWifiScanner).getListenerMapLock();
-    SparseArray<Object> listenerMap = null;
+    SparseArray<Object> listenerMap;
     SparseArray<Executor> executorMap = null;
 
     synchronized (listenerMapLock) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindow.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindow.java
index e4761f778..c563c71ac 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindow.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindow.java
@@ -117,16 +117,16 @@ public class ShadowWindow {
   }
 
   /**
-   * Calls {@link Window.OnFrameMetrisAvailableListener#onFrameMetricsAvailable()} on each current
-   * listener with 0 as the dropCountSinceLastInvocation.
+   * Calls {@link Window.OnFrameMetricsAvailableListener#onFrameMetricsAvailable(Window,
+   * FrameMetrics, int)} on each current listener with 0 as the dropCountSinceLastInvocation.
    */
   public void reportOnFrameMetricsAvailable(FrameMetrics frameMetrics) {
     reportOnFrameMetricsAvailable(frameMetrics, /* dropCountSinceLastInvocation= */ 0);
   }
 
   /**
-   * Calls {@link Window.OnFrameMetrisAvailableListener#onFrameMetricsAvailable()} on each current
-   * listener.
+   * Calls {@link Window.OnFrameMetricsAvailableListener#onFrameMetricsAvailable(Window,
+   * FrameMetrics, int)} on each current listener.
    *
    * @param frameMetrics the {@link FrameMetrics} instance passed to the listeners.
    * @param dropCountSinceLastInvocation the dropCountSinceLastInvocation passed to the listeners.
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerGlobal.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerGlobal.java
index f376d3b37..b1d15ae57 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerGlobal.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerGlobal.java
@@ -17,11 +17,11 @@ import static android.view.WindowInsets.Type.navigationBars;
 import static android.view.WindowInsets.Type.statusBars;
 import static android.view.WindowInsets.Type.systemBars;
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static java.lang.Math.max;
 import static java.lang.Math.round;
 import static java.util.Arrays.stream;
+import static java.util.Objects.requireNonNull;
 import static org.robolectric.shadows.ShadowView.useRealGraphics;
 import static org.robolectric.shadows.SystemUi.systemUiForDisplay;
 import static org.robolectric.util.ReflectionHelpers.callConstructor;
@@ -29,7 +29,6 @@ import static org.robolectric.util.ReflectionHelpers.callInstanceMethod;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.annotation.FloatRange;
-import android.app.Instrumentation;
 import android.content.ClipData;
 import android.content.Context;
 import android.content.res.Configuration;
@@ -77,6 +76,7 @@ import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map.Entry;
+import java.util.Optional;
 import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.ClassName;
@@ -143,7 +143,7 @@ public class ShadowWindowManagerGlobal {
    * ShadowWindowManagerGlobal#startPredictiveBackGesture}. One or more drag progress events can be
    * dispatched by calling {@link #moveBy}. The gesture must be ended by either calling {@link
    * #cancel()} or {@link #close()}, if {@link #cancel()} is called a subsequent call to {@link
-   * close()} will do nothing to allow using the gesture in a try with resources statement:
+   * #close()} will do nothing to allow using the gesture in a try with resources statement:
    *
    * <pre>
    * try (PredictiveBackGesture backGesture =
@@ -183,7 +183,7 @@ public class ShadowWindowManagerGlobal {
             .onBackInvokedCallbackInfo
             .getCallback()
             .onBackProgressed(
-                BackMotionEvents.newBackMotionEvent(edge, touchX, touchY, caclulateProgress()));
+                BackMotionEvents.newBackMotionEvent(edge, touchX, touchY, calculateProgress()));
         ShadowLooper.idleMainLooper();
       } catch (RemoteException e) {
         throw new RuntimeException(e);
@@ -232,7 +232,7 @@ public class ShadowWindowManagerGlobal {
       }
     }
 
-    private float caclulateProgress() {
+    private float calculateProgress() {
       // The real implementation anchors the progress on the start x and resets it each time the
       // threshold is lost, it also calculates a linear and non linear progress area. This
       // implementation is much simpler.
@@ -452,15 +452,36 @@ public class ShadowWindowManagerGlobal {
       }
       Rect[] rects = findAll(Rect.class, args);
       int rectIdx = 0;
-      configureWindowFrames(
-          windowInfo,
-          /* inAttrs= */ (WindowManager.LayoutParams) args[sdk <= R ? 2 : 1],
-          /* requestedSize= */ null,
-          /* outFrame= */ sdk >= P && rects.length > rectIdx ? rects[rectIdx++] : null,
-          /* outContentInsets= */ sdk <= R ? rects[rectIdx++] : null,
-          /* outVisibleInsets= */ null,
-          /* outStableInsets= */ sdk >= LOLLIPOP_MR1 && sdk <= R ? rects[rectIdx] : null,
-          /* outInsetsState= */ sdk >= Q ? findFirst(InsetsState.class, args) : null);
+      if (sdk <= R) {
+        configureWindowFrames(
+            windowInfo,
+            /* inAttrs= */ (WindowManager.LayoutParams) args[2],
+            /* requestedSize= */ null,
+            /* outFrame= */ sdk >= P && rects.length > rectIdx ? rects[rectIdx++] : null,
+            /* outContentInsets= */ rects[rectIdx++],
+            /* outVisibleInsets= */ null,
+            /* outStableInsets= */ sdk >= LOLLIPOP_MR1 ? rects[rectIdx] : null,
+            /* outInsetsState= */ sdk >= Q ? findFirst(InsetsState.class, args) : null);
+      } else { // post insets migration
+        Optional<WindowRelayoutResult> layout =
+            sdk >= VANILLA_ICE_CREAM
+                ? findFirstOpt(WindowRelayoutResult.class, args)
+                : Optional.empty();
+        configureWindowFrames(
+            windowInfo,
+            /* inAttrs= */ (WindowManager.LayoutParams) args[1],
+            /* requestedSize= */ null,
+            /* outFrame= */ null,
+            /* outContentInsets= */ null,
+            /* outVisibleInsets= */ null,
+            /* outStableInsets= */ null,
+            /* outInsetsState= */ layout.isPresent()
+                ? layout.get().insetsState
+                : findFirst(InsetsState.class, args));
+        if (rects.length > 0) {
+          rects[0].set(0, 0, -1, -1);
+        }
+      }
 
       int res = 0;
       // Temporarily enable this based on a system property to allow for test migration. This will
@@ -492,7 +513,8 @@ public class ShadowWindowManagerGlobal {
       if (sdk >= Q) {
         SurfaceControl surfaceControl =
             sdk >= VANILLA_ICE_CREAM
-                ? windowLayoutResult.surfaceControl
+                    && ReflectionHelpers.hasField(WindowRelayoutResult.class, "surfaceControl")
+                ? ReflectionHelpers.getField(windowLayoutResult, "surfaceControl")
                 : findFirst(SurfaceControl.class, args);
         Shadow.<ShadowSurfaceControl>extract(surfaceControl).initializeNativeObject();
       }
@@ -509,13 +531,13 @@ public class ShadowWindowManagerGlobal {
           if (windowInfo.hasInsetsControl) {
             populateInsetSourceControls(windowInfo, controls);
           } else {
-            Arrays.setAll(controls, i -> null);
+            Arrays.fill(controls, null);
           }
         }
         Rect[] rects = findAll(Rect.class, args);
         int requestedSizeIdx = sdk < S ? 3 : 2;
         configureWindowFrames(
-            checkNotNull(windowInfo),
+            requireNonNull(windowInfo),
             /* inAttrs= */ (WindowManager.LayoutParams) args[sdk <= R ? 2 : 1],
             /* requestedSize= */ new Point(
                 (int) args[requestedSizeIdx], (int) args[requestedSizeIdx + 1]),
@@ -668,7 +690,7 @@ public class ShadowWindowManagerGlobal {
     void sendInsetsControlChanged(
         IWindow window, @Nullable Integer type, boolean hasControlsChanged) {
       int sdk = RuntimeEnvironment.getApiLevel();
-      WindowInfo windowInfo = checkNotNull(windows.get(window));
+      WindowInfo windowInfo = requireNonNull(windows.get(window));
       InsetsState insetsState = new InsetsState(windowInfo.insetsState);
       // On R if we don't remove the sources that aren't changing we'll infinite loop when toggling
       // visibility of multiple bars.
@@ -702,7 +724,7 @@ public class ShadowWindowManagerGlobal {
 
     void sendResize(IWindow window) {
       int sdk = RuntimeEnvironment.getApiLevel();
-      WindowInfo windowInfo = checkNotNull(windows.get(window));
+      WindowInfo windowInfo = requireNonNull(windows.get(window));
       configureWindowFrames(
           windowInfo,
           windowInfo.attrs,
@@ -718,6 +740,33 @@ public class ShadowWindowManagerGlobal {
 
       // The resized method has changed pretty much every other release, this is a canonicalize-d
       // set of all the parameters it has ever taken.
+      if (sdk > UPSIDE_DOWN_CAKE) {
+        if (ReflectionHelpers.hasMethod(
+            IWindow.class,
+            "resized",
+            WindowRelayoutResult.class,
+            boolean.class /* reportDraw */,
+            boolean.class /* forceLayout */,
+            int.class /* displayId */,
+            boolean.class /* syncWithBuffers */,
+            boolean.class /* dragResizing */)) {
+          ClassParameterBuilder rlrArgs = new ClassParameterBuilder();
+          rlrArgs.add(ClientWindowFrames.class, windowInfo.frames);
+          rlrArgs.add(MergedConfiguration.class, new MergedConfiguration(configuration));
+          rlrArgs.add(InsetsState.class, windowInfo.insetsState);
+          rlrArgs.add(InsetsSourceControl.Array.class, new InsetsSourceControl.Array());
+          WindowRelayoutResult layout =
+              ReflectionHelpers.callConstructor(WindowRelayoutResult.class, rlrArgs.build());
+          args.add(WindowRelayoutResult.class, layout);
+          /* reportDraw */ args.add(boolean.class, false);
+          /* forceLayout */ args.add(boolean.class, false);
+          /* displayId */ args.add(int.class, windowInfo.displayId);
+          /* syncWithBuffers */ args.add(boolean.class, false);
+          /* dragResizing */ args.add(boolean.class, false);
+          callInstanceMethod(window, "resized", args.build());
+          return;
+        }
+      }
       if (sdk >= S) {
         /* frames */ args.add(ClientWindowFrames.class, windowInfo.frames);
       } else {
@@ -849,6 +898,11 @@ public class ShadowWindowManagerGlobal {
     return type.cast(stream(args).filter(type::isInstance).findFirst().get());
   }
 
+  private static <T> Optional<T> findFirstOpt(Class<T> type, Object[] args) {
+    return Optional.ofNullable(
+        type.cast(stream(args).filter(type::isInstance).findFirst().orElse(null)));
+  }
+
   private static <T> T[] findAll(Class<T> type, Object[] args) {
     return stream(args).filter(type::isInstance).toArray(len -> (T[]) Array.newInstance(type, len));
   }
@@ -946,8 +1000,8 @@ public class ShadowWindowManagerGlobal {
                 SystemClock.uptimeMillis(), /* frameTime */
                 progress,
                 Boolean.FALSE, // trigger back
-                edge, // swipe edge
-                null);
+                edge,
+                null); // swipe edge
       } else {
         throw new IllegalStateException("Could not find a BackMotionEvent constructor to call");
       }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerImpl.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerImpl.java
index 562095409..4f8a501ea 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerImpl.java
@@ -92,7 +92,6 @@ public class ShadowWindowManagerImpl extends ShadowWindowManager {
           ClassParameter.from(SparseIntArray.class, null));
     } else {
       return new WindowInsets.Builder()
-          .setAlwaysConsumeSystemBars(alwaysConsumeSystemBars)
           .setRound(isScreenRound)
           .setSystemWindowInsets(Insets.of(systemWindowInsets))
           .setStableInsets(Insets.of(stableInsets))
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/SharedLibraryInfoBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/SharedLibraryInfoBuilder.java
index 896abaad7..90a596d4a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/SharedLibraryInfoBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/SharedLibraryInfoBuilder.java
@@ -87,7 +87,7 @@ public final class SharedLibraryInfoBuilder {
           ClassParameter.from(int.class, type),
           ClassParameter.from(VersionedPackage.class, declaringPackage),
           ClassParameter.from(List.class, dependentPackages));
-    } else if (apiLevel <= VERSION_CODES.P) {
+    } else if (apiLevel == VERSION_CODES.P) {
       return ReflectionHelpers.callConstructor(
           SharedLibraryInfo.class,
           ClassParameter.from(String.class, name),
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/SignalStrengthBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/SignalStrengthBuilder.java
new file mode 100644
index 000000000..95e2cd79c
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/SignalStrengthBuilder.java
@@ -0,0 +1,99 @@
+package org.robolectric.shadows;
+
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.annotation.RequiresApi;
+import android.os.Build;
+import android.telephony.CellSignalStrength;
+import android.telephony.CellSignalStrengthCdma;
+import android.telephony.CellSignalStrengthGsm;
+import android.telephony.CellSignalStrengthLte;
+import android.telephony.CellSignalStrengthNr;
+import android.telephony.CellSignalStrengthTdscdma;
+import android.telephony.CellSignalStrengthWcdma;
+import android.telephony.SignalStrength;
+import com.google.common.collect.ImmutableList;
+import java.util.List;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.Constructor;
+import org.robolectric.util.reflector.ForType;
+
+/** Builder for {@link android.telephony.SignalStrength} */
+public class SignalStrengthBuilder {
+
+  private ImmutableList<CellSignalStrength> cellSignalStrengths = ImmutableList.of();
+
+  private SignalStrengthBuilder() {}
+
+  public static SignalStrengthBuilder newBuilder() {
+    return new SignalStrengthBuilder();
+  }
+
+  @RequiresApi(Build.VERSION_CODES.Q)
+  public SignalStrengthBuilder setCellSignalStrengths(
+      List<CellSignalStrength> cellSignalStrengths) {
+    this.cellSignalStrengths = ImmutableList.copyOf(cellSignalStrengths);
+    return this;
+  }
+
+  public SignalStrength build() {
+    int apiLevel = RuntimeEnvironment.getApiLevel();
+    SignalStrength signalStrength = reflector(SignalStrengthReflector.class).newSignalStrength();
+    SignalStrengthReflector signalStrengthReflector =
+        reflector(SignalStrengthReflector.class, signalStrength);
+
+    if (apiLevel > Build.VERSION_CODES.P) {
+      for (CellSignalStrength cellSignalStrength : cellSignalStrengths) {
+        if (cellSignalStrength instanceof CellSignalStrengthCdma) {
+          signalStrengthReflector.setCellSignalStrengthCdma(
+              (CellSignalStrengthCdma) cellSignalStrength);
+        } else if (cellSignalStrength instanceof CellSignalStrengthGsm) {
+          signalStrengthReflector.setCellSignalStrengthGsm(
+              (CellSignalStrengthGsm) cellSignalStrength);
+        } else if (cellSignalStrength instanceof CellSignalStrengthWcdma) {
+          signalStrengthReflector.setCellSignalStrengthWcdma(
+              (CellSignalStrengthWcdma) cellSignalStrength);
+        } else if (cellSignalStrength instanceof CellSignalStrengthTdscdma) {
+          signalStrengthReflector.setCellSignalStrengthTdscdma(
+              (CellSignalStrengthTdscdma) cellSignalStrength);
+        } else if (cellSignalStrength instanceof CellSignalStrengthLte) {
+          signalStrengthReflector.setCellSignalStrengthLte(
+              (CellSignalStrengthLte) cellSignalStrength);
+        } else if (cellSignalStrength instanceof CellSignalStrengthNr) {
+          signalStrengthReflector.setCellSignalStrengthNr(
+              (CellSignalStrengthNr) cellSignalStrength);
+        } else {
+          throw new IllegalArgumentException(
+              "Unsupported CellSignalStrength type: " + cellSignalStrength.getClass().getName());
+        }
+      }
+    }
+
+    return signalStrength;
+  }
+
+  @ForType(SignalStrength.class)
+  private interface SignalStrengthReflector {
+    @Constructor
+    SignalStrength newSignalStrength();
+
+    @Accessor("mCdma")
+    void setCellSignalStrengthCdma(CellSignalStrengthCdma cellSignalStrength);
+
+    @Accessor("mGsm")
+    void setCellSignalStrengthGsm(CellSignalStrengthGsm cellSignalStrength);
+
+    @Accessor("mWcdma")
+    void setCellSignalStrengthWcdma(CellSignalStrengthWcdma cellSignalStrength);
+
+    @Accessor("mTdscdma")
+    void setCellSignalStrengthTdscdma(CellSignalStrengthTdscdma cellSignalStrength);
+
+    @Accessor("mLte")
+    void setCellSignalStrengthLte(CellSignalStrengthLte cellSignalStrength);
+
+    @Accessor("mNr")
+    void setCellSignalStrengthNr(CellSignalStrengthNr cellSignalStrength);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/StreamConfigurationMapBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/StreamConfigurationMapBuilder.java
index 24b36f812..a46e71c2e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/StreamConfigurationMapBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/StreamConfigurationMapBuilder.java
@@ -2,6 +2,8 @@ package org.robolectric.shadows;
 
 import static org.robolectric.util.reflector.Reflector.reflector;
 
+import android.graphics.ImageFormat;
+import android.graphics.PixelFormat;
 import android.hardware.camera2.params.HighSpeedVideoConfiguration;
 import android.hardware.camera2.params.ReprocessFormatsMap;
 import android.hardware.camera2.params.StreamConfiguration;
@@ -66,7 +68,7 @@ public final class StreamConfigurationMapBuilder {
   /**
    * Adds an output size to be returned by {@link StreamConfigurationMap#getOutputSizes}.
    *
-   * <p>Calling this method is equivalent to calling {@link addOutputSize(int, Size)} with format
+   * <p>Calling this method is equivalent to calling {@link #addOutputSize(int, Size)} with format
    * {@link ImageFormat#PRIVATE}.
    */
   public StreamConfigurationMapBuilder addOutputSize(Size outputSize) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/SystemFeatureListInitializer.java b/shadows/framework/src/main/java/org/robolectric/shadows/SystemFeatureListInitializer.java
index bf564aff1..f64f42030 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/SystemFeatureListInitializer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/SystemFeatureListInitializer.java
@@ -7,6 +7,7 @@ import com.google.common.collect.ImmutableMap;
 import java.util.HashMap;
 import java.util.Map;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.versioning.AndroidVersions;
 
 final class SystemFeatureListInitializer {
 
@@ -45,6 +46,9 @@ final class SystemFeatureListInitializer {
       features.put(PackageManager.FEATURE_TELEPHONY_EUICC, true);
       features.put(PackageManager.FEATURE_TELEPHONY_EUICC_MEP, true);
       features.put(PackageManager.FEATURE_TELEPHONY_IMS, true);
+      if (apiLevel >= AndroidVersions.Baklava.SDK_INT) {
+        features.put(PackageManager.FEATURE_TELEPHONY_SATELLITE, true);
+      }
     }
 
     return ImmutableMap.copyOf(features);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/UiccCardInfoBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/UiccCardInfoBuilder.java
index e1bace197..cd81a6508 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/UiccCardInfoBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/UiccCardInfoBuilder.java
@@ -58,7 +58,7 @@ public class UiccCardInfoBuilder {
   }
 
   /**
-   * @deprecated Use {@link setPhysicalSlotIndex} for Android T+ instead.
+   * @deprecated Use {@link #setPhysicalSlotIndex} for Android T+ instead.
    */
   @CanIgnoreReturnValue
   @Deprecated
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/WifiScannerDelegate.java b/shadows/framework/src/main/java/org/robolectric/shadows/WifiScannerDelegate.java
index b1d94bd71..d7825d895 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/WifiScannerDelegate.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/WifiScannerDelegate.java
@@ -24,7 +24,7 @@ class WifiScannerDelegate {
     Bundle bundle = new Bundle();
 
     // Mock available WiFi channels. See https://en.wikipedia.org/wiki/List_of_WLAN_channels
-    List<Integer> availableChannels = new ArrayList<>();
+    List<Integer> availableChannels;
 
     switch (band) {
       case WifiScanner.WIFI_BAND_24_GHZ:
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/_Activity_.java b/shadows/framework/src/main/java/org/robolectric/shadows/_Activity_.java
index 9c25209e8..f35b3da4a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/_Activity_.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/_Activity_.java
@@ -255,7 +255,7 @@ public interface _Activity_ {
           null,
           null,
           null);
-    } else if (apiLevel > Build.VERSION_CODES.R) {
+    } else {
       attach(
           baseContext,
           activityThread,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/util/DataSource.java b/shadows/framework/src/main/java/org/robolectric/shadows/util/DataSource.java
index b3128e563..fd2b3fd3e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/util/DataSource.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/util/DataSource.java
@@ -18,7 +18,7 @@ import java.util.Map;
  * @author Fr Jeremy Krieg
  */
 public class DataSource {
-  private String dataSource;
+  private final String dataSource;
 
   @SuppressWarnings("ObjectToString")
   private static final FileDescriptorTransform DEFAULT_FD_TRANSFORM =
@@ -99,17 +99,14 @@ public class DataSource {
     if (this == obj) {
       return true;
     }
-    if (obj == null || !(obj instanceof DataSource)) {
+    if (!(obj instanceof DataSource)) {
       return false;
     }
     final DataSource other = (DataSource) obj;
     if (dataSource == null) {
-      if (other.dataSource != null) {
-        return false;
-      }
-    } else if (!dataSource.equals(other.dataSource)) {
-      return false;
+      return other.dataSource == null;
+    } else {
+      return dataSource.equals(other.dataSource);
     }
-    return true;
   }
 }
diff --git a/shadows/httpclient/build.gradle.kts b/shadows/httpclient/build.gradle.kts
index 35a4c8be7..99cff8830 100644
--- a/shadows/httpclient/build.gradle.kts
+++ b/shadows/httpclient/build.gradle.kts
@@ -25,7 +25,6 @@ dependencies {
   testImplementation(project(":robolectric"))
   testImplementation(libs.junit4)
   testImplementation(libs.truth)
-  testImplementation(libs.mockito)
   testImplementation("androidx.test.ext:junit:$axtJunitVersion@aar")
 
   testCompileOnly(AndroidSdk.LOLLIPOP_MR1.coordinates)
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/ShadowAndroidHttpClient.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/ShadowAndroidHttpClient.java
index 88c5d3b4c..14e7e9c48 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/ShadowAndroidHttpClient.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/ShadowAndroidHttpClient.java
@@ -6,7 +6,6 @@ import java.io.IOException;
 import org.apache.http.HttpHost;
 import org.apache.http.HttpRequest;
 import org.apache.http.HttpResponse;
-import org.apache.http.client.ClientProtocolException;
 import org.apache.http.client.HttpClient;
 import org.apache.http.client.ResponseHandler;
 import org.apache.http.client.methods.HttpUriRequest;
@@ -21,7 +20,7 @@ import org.robolectric.util.ReflectionHelpers;
 @Implements(AndroidHttpClient.class)
 public class ShadowAndroidHttpClient {
 
-  private HttpClient httpClient = new DefaultHttpClient();
+  private final HttpClient httpClient = new DefaultHttpClient();
 
   @Implementation
   protected static AndroidHttpClient newInstance(String userAgent) {
@@ -44,34 +43,31 @@ public class ShadowAndroidHttpClient {
   }
 
   @Implementation
-  protected HttpResponse execute(HttpUriRequest httpUriRequest)
-      throws IOException, ClientProtocolException {
+  protected HttpResponse execute(HttpUriRequest httpUriRequest) throws IOException {
     return httpClient.execute(httpUriRequest);
   }
 
   @Implementation
   protected HttpResponse execute(HttpUriRequest httpUriRequest, HttpContext httpContext)
-      throws IOException, ClientProtocolException {
+      throws IOException {
     return httpClient.execute(httpUriRequest, httpContext);
   }
 
   @Implementation
-  protected HttpResponse execute(HttpHost httpHost, HttpRequest httpRequest)
-      throws IOException, ClientProtocolException {
+  protected HttpResponse execute(HttpHost httpHost, HttpRequest httpRequest) throws IOException {
     return httpClient.execute(httpHost, httpRequest);
   }
 
   @Implementation
   protected HttpResponse execute(
-      HttpHost httpHost, HttpRequest httpRequest, HttpContext httpContext)
-      throws IOException, ClientProtocolException {
+      HttpHost httpHost, HttpRequest httpRequest, HttpContext httpContext) throws IOException {
     return httpClient.execute(httpHost, httpRequest, httpContext);
   }
 
   @Implementation
   protected <T> T execute(
       HttpUriRequest httpUriRequest, ResponseHandler<? extends T> responseHandler)
-      throws IOException, ClientProtocolException {
+      throws IOException {
     return httpClient.execute(httpUriRequest, responseHandler);
   }
 
@@ -80,14 +76,14 @@ public class ShadowAndroidHttpClient {
       HttpUriRequest httpUriRequest,
       ResponseHandler<? extends T> responseHandler,
       HttpContext httpContext)
-      throws IOException, ClientProtocolException {
+      throws IOException {
     return httpClient.execute(httpUriRequest, responseHandler, httpContext);
   }
 
   @Implementation
   protected <T> T execute(
       HttpHost httpHost, HttpRequest httpRequest, ResponseHandler<? extends T> responseHandler)
-      throws IOException, ClientProtocolException {
+      throws IOException {
     return httpClient.execute(httpHost, httpRequest, responseHandler);
   }
 
@@ -97,7 +93,7 @@ public class ShadowAndroidHttpClient {
       HttpRequest httpRequest,
       ResponseHandler<? extends T> responseHandler,
       HttpContext httpContext)
-      throws IOException, ClientProtocolException {
+      throws IOException {
     return httpClient.execute(httpHost, httpRequest, responseHandler, httpContext);
   }
 }
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/DefaultRequestDirector.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/DefaultRequestDirector.java
index 0c4699ce1..d58007d79 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/DefaultRequestDirector.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/DefaultRequestDirector.java
@@ -181,7 +181,7 @@ public class DefaultRequestDirector implements RequestDirector {
 
   private int redirectCount;
 
-  private int maxRedirects;
+  private final int maxRedirects;
 
   private HttpHost virtualHost;
 
@@ -328,12 +328,11 @@ public class DefaultRequestDirector implements RequestDirector {
   public HttpResponse execute(HttpHost target, HttpRequest request, HttpContext context)
       throws HttpException, IOException {
 
-    HttpRequest orig = request;
-    RequestWrapper origWrapper = wrapRequest(orig);
+    RequestWrapper origWrapper = wrapRequest(request);
     origWrapper.setParams(params);
     HttpRoute origRoute = determineRoute(target, origWrapper, context);
 
-    virtualHost = (HttpHost) orig.getParams().getParameter(ClientPNames.VIRTUAL_HOST);
+    virtualHost = (HttpHost) request.getParams().getParameter(ClientPNames.VIRTUAL_HOST);
 
     RoutedRequest roureq = new RoutedRequest(origWrapper, origRoute);
 
@@ -361,8 +360,8 @@ public class DefaultRequestDirector implements RequestDirector {
         // Allocate connection if needed
         if (managedConn == null) {
           ClientConnectionRequest connRequest = connManager.requestConnection(route, userToken);
-          if (orig instanceof AbortableHttpRequest) {
-            ((AbortableHttpRequest) orig).setConnectionRequest(connRequest);
+          if (request instanceof AbortableHttpRequest) {
+            ((AbortableHttpRequest) request).setConnectionRequest(connRequest);
           }
 
           try {
@@ -385,8 +384,8 @@ public class DefaultRequestDirector implements RequestDirector {
           }
         }
 
-        if (orig instanceof AbortableHttpRequest) {
-          ((AbortableHttpRequest) orig).setReleaseTrigger(managedConn);
+        if (request instanceof AbortableHttpRequest) {
+          ((AbortableHttpRequest) request).setReleaseTrigger(managedConn);
         }
 
         // Reopen connection if needed
@@ -581,8 +580,8 @@ public class DefaultRequestDirector implements RequestDirector {
     // it is released.
     try {
       managedConn.releaseConnection();
-    } catch (IOException ignored) {
-      this.log.debug("IOException releasing connection", ignored);
+    } catch (IOException exception) {
+      this.log.debug("IOException releasing connection", exception);
     }
     managedConn = null;
   }
@@ -843,23 +842,17 @@ public class DefaultRequestDirector implements RequestDirector {
       port = scheme.getDefaultPort();
     }
 
-    StringBuilder buffer = new StringBuilder(host.length() + 6);
-    buffer.append(host);
-    buffer.append(':');
-    buffer.append(Integer.toString(port));
-
-    String authority = buffer.toString();
+    String authority = host + ':' + port;
     ProtocolVersion ver = HttpProtocolParams.getVersion(params);
-    HttpRequest req = new BasicHttpRequest("CONNECT", authority, ver);
 
-    return req;
+    return new BasicHttpRequest("CONNECT", authority, ver);
   }
 
   /**
    * Analyzes a response to check need for a followup.
    *
    * @param roureq the request and route.
-   * @param response the response to analayze
+   * @param response the response to analyze
    * @param context the context used for the current request execution
    * @return the followup request and route if there is a followup, or {@code null} if the response
    *     should be returned as is
@@ -1006,8 +999,8 @@ public class DefaultRequestDirector implements RequestDirector {
       // ensure the connection manager properly releases this connection
       try {
         mcc.releaseConnection();
-      } catch (IOException ignored) {
-        this.log.debug("Error releasing connection", ignored);
+      } catch (IOException exception) {
+        this.log.debug("Error releasing connection", exception);
       }
     }
   } // abortConnection
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttp.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttp.java
index 7710b0c76..0f32e1924 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttp.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttp.java
@@ -36,7 +36,7 @@ public class FakeHttp {
           "FakeHttp.getFakeHttpLayer().addPendingHttpResponse(statusCode, responseBody,"
               + " contentType)",
       imports = "org.robolectric.shadows.httpclient.FakeHttp")
-  public static final void addPendingHttpResponseWithContentType(
+  public static void addPendingHttpResponseWithContentType(
       int statusCode, String responseBody, Header contentType) {
     getFakeHttpLayer().addPendingHttpResponse(statusCode, responseBody, contentType);
   }
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttpLayer.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttpLayer.java
index 243413180..598d1d106 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttpLayer.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttpLayer.java
@@ -28,7 +28,7 @@ public class FakeHttpLayer {
   private HttpResponse defaultHttpResponse;
   private boolean interceptHttpRequests = true;
   private boolean logHttpRequests = false;
-  private List<byte[]> httpResposeContent = new ArrayList<>();
+  private final List<byte[]> httpResponseContent = new ArrayList<>();
   private boolean interceptResponseContent;
 
   public HttpRequestInfo getLastSentHttpRequestInfo() {
@@ -44,13 +44,7 @@ public class FakeHttpLayer {
   }
 
   public void addPendingHttpResponse(final HttpResponse httpResponse) {
-    addPendingHttpResponse(
-        new HttpResponseGenerator() {
-          @Override
-          public HttpResponse getResponse(HttpRequest request) {
-            return httpResponse;
-          }
-        });
+    addPendingHttpResponse(request -> httpResponse);
   }
 
   public void addPendingHttpResponse(HttpResponseGenerator httpResponseGenerator) {
@@ -194,7 +188,7 @@ public class FakeHttpLayer {
   }
 
   public HttpRequestInfo getNextSentHttpRequestInfo() {
-    return httpRequestInfos.size() > 0 ? httpRequestInfos.remove(0) : null;
+    return !httpRequestInfos.isEmpty() ? httpRequestInfos.remove(0) : null;
   }
 
   public void logHttpRequests() {
@@ -242,11 +236,11 @@ public class FakeHttpLayer {
   }
 
   public void addHttpResponseContent(byte[] content) {
-    this.httpResposeContent.add(content);
+    this.httpResponseContent.add(content);
   }
 
   public List<byte[]> getHttpResposeContentList() {
-    return httpResposeContent;
+    return httpResponseContent;
   }
 
   /**
@@ -290,7 +284,7 @@ public class FakeHttpLayer {
   }
 
   public static class RequestMatcherResponseRule implements HttpEntityStub.ResponseRule {
-    private RequestMatcher requestMatcher;
+    private final RequestMatcher requestMatcher;
     private HttpResponse responseToGive;
     private IOException ioException;
     private HttpException httpException;
@@ -338,8 +332,8 @@ public class FakeHttpLayer {
   }
 
   public static class DefaultRequestMatcher implements RequestMatcher {
-    private String method;
-    private String uri;
+    private final String method;
+    private final String uri;
 
     public DefaultRequestMatcher(String method, String uri) {
       this.method = method;
@@ -354,7 +348,7 @@ public class FakeHttpLayer {
   }
 
   public static class UriRequestMatcher implements RequestMatcher {
-    private String uri;
+    private final String uri;
 
     public UriRequestMatcher(String uri) {
       this.uri = uri;
@@ -369,8 +363,8 @@ public class FakeHttpLayer {
   public static class RequestMatcherBuilder implements RequestMatcher {
     private String method, hostname, path;
     private boolean noParams;
-    private Map<String, String> params = new HashMap<>();
-    private Map<String, String> headers = new HashMap<>();
+    private final Map<String, String> params = new HashMap<>();
+    private final Map<String, String> headers = new HashMap<>();
     private PostBodyMatcher postBodyMatcher;
 
     public interface PostBodyMatcher {
@@ -438,13 +432,13 @@ public class FakeHttpLayer {
       if (noParams && uri.getRawQuery() != null) {
         return false;
       }
-      if (params.size() > 0) {
+      if (!params.isEmpty()) {
         Map<String, String> requestParams = ParamsParser.parseParams(request);
         if (!requestParams.equals(params)) {
           return false;
         }
       }
-      if (headers.size() > 0) {
+      if (!headers.isEmpty()) {
         Map<String, String> actualRequestHeaders = new HashMap<>();
         for (Header header : request.getAllHeaders()) {
           actualRequestHeaders.put(header.getName(), header.getValue());
@@ -495,7 +489,7 @@ public class FakeHttpLayer {
   }
 
   public static class UriRegexMatcher implements RequestMatcher {
-    private String method;
+    private final String method;
     private final Pattern uriRegex;
 
     public UriRegexMatcher(String method, String uriRegex) {
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpEntityStub.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpEntityStub.java
index b1b6ae267..0341ad761 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpEntityStub.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpEntityStub.java
@@ -55,7 +55,7 @@ public class HttpEntityStub implements HttpEntity {
     throw new UnsupportedOperationException();
   }
 
-  public static interface ResponseRule {
+  public interface ResponseRule {
     boolean matches(HttpRequest request);
 
     HttpResponse getResponse() throws HttpException, IOException;
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpRedirect.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpRedirect.java
index 7071c8e89..45d659411 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpRedirect.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpRedirect.java
@@ -40,7 +40,7 @@ import org.apache.http.client.methods.HttpRequestBase;
  */
 class HttpRedirect extends HttpRequestBase {
 
-  private String method;
+  private final String method;
 
   public HttpRedirect(final String method, final URI uri) {
     super();
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpResponseGenerator.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpResponseGenerator.java
index 23405a9e8..47bb80b45 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpResponseGenerator.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpResponseGenerator.java
@@ -4,5 +4,5 @@ import org.apache.http.HttpRequest;
 import org.apache.http.HttpResponse;
 
 public interface HttpResponseGenerator {
-  public HttpResponse getResponse(HttpRequest request);
+  HttpResponse getResponse(HttpRequest request);
 }
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/RequestMatcher.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/RequestMatcher.java
index 332a8fa5c..2f145be94 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/RequestMatcher.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/RequestMatcher.java
@@ -3,5 +3,5 @@ package org.robolectric.shadows.httpclient;
 import org.apache.http.HttpRequest;
 
 public interface RequestMatcher {
-  public boolean matches(HttpRequest request);
+  boolean matches(HttpRequest request);
 }
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/TestHttpResponse.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/TestHttpResponse.java
index ac7d9efd1..01ee70213 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/TestHttpResponse.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/TestHttpResponse.java
@@ -21,10 +21,10 @@ import org.apache.http.params.HttpParams;
 
 public class TestHttpResponse extends HttpResponseStub {
 
-  private int statusCode;
+  private final int statusCode;
   private byte[] responseBody;
-  private TestStatusLine statusLine = new TestStatusLine();
-  private TestHttpEntity httpEntity = new TestHttpEntity();
+  private final TestStatusLine statusLine = new TestStatusLine();
+  private final TestHttpEntity httpEntity = new TestHttpEntity();
   private int openEntityContentStreamCount = 0;
   private Header[] headers = new Header[0];
   private HttpParams params = new BasicHttpParams();
@@ -94,7 +94,7 @@ public class TestHttpResponse extends HttpResponseStub {
     for (Header h : headers) {
       if (h.getName().equalsIgnoreCase(s)) found.add(h);
     }
-    return found.toArray(new Header[found.size()]);
+    return found.toArray(new Header[0]);
   }
 
   @Override
@@ -102,7 +102,7 @@ public class TestHttpResponse extends HttpResponseStub {
     List<Header> temp = new ArrayList<>();
     Collections.addAll(temp, headers);
     temp.add(header);
-    headers = temp.toArray(new Header[temp.size()]);
+    headers = temp.toArray(new Header[0]);
   }
 
   @Override
@@ -203,8 +203,6 @@ public class TestHttpResponse extends HttpResponseStub {
 
   public class TestHttpEntity extends HttpEntityStub {
 
-    private ByteArrayInputStream inputStream;
-
     @Override
     public long getContentLength() {
       return responseBody.length;
@@ -226,22 +224,15 @@ public class TestHttpResponse extends HttpResponseStub {
     }
 
     @Override
-    public boolean isRepeatable() {
-      return true;
-    }
-
-    @Override
-    public InputStream getContent() throws IOException, IllegalStateException {
+    public InputStream getContent() throws IllegalStateException {
       openEntityContentStreamCount++;
-      inputStream =
-          new ByteArrayInputStream(responseBody) {
-            @Override
-            public void close() throws IOException {
-              openEntityContentStreamCount--;
-              super.close();
-            }
-          };
-      return inputStream;
+      return new ByteArrayInputStream(responseBody) {
+        @Override
+        public void close() throws IOException {
+          openEntityContentStreamCount--;
+          super.close();
+        }
+      };
     }
 
     @Override
@@ -250,7 +241,7 @@ public class TestHttpResponse extends HttpResponseStub {
     }
 
     @Override
-    public void consumeContent() throws IOException {}
+    public void consumeContent() {}
   }
 
   public class TestStatusLine extends StatusLineStub {
diff --git a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/AndroidHttpClientTest.java b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/AndroidHttpClientTest.java
index 0c62d8cbd..6316791e7 100644
--- a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/AndroidHttpClientTest.java
+++ b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/AndroidHttpClientTest.java
@@ -19,13 +19,13 @@ import org.robolectric.RuntimeEnvironment;
 public class AndroidHttpClientTest {
 
   @Test
-  public void testNewInstance() throws Exception {
+  public void testNewInstance() {
     AndroidHttpClient client = AndroidHttpClient.newInstance("foo");
     assertThat(client).isNotNull();
   }
 
   @Test
-  public void testNewInstanceWithContext() throws Exception {
+  public void testNewInstanceWithContext() {
     AndroidHttpClient client =
         AndroidHttpClient.newInstance("foo", RuntimeEnvironment.getApplication());
     assertThat(client).isNotNull();
diff --git a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/FakeHttpLayerTest.java b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/FakeHttpLayerTest.java
index 163892560..15e96b157 100644
--- a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/FakeHttpLayerTest.java
+++ b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/FakeHttpLayerTest.java
@@ -19,42 +19,42 @@ public class FakeHttpLayerTest {
   private FakeHttpLayer.RequestMatcherBuilder requestMatcherBuilder;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     requestMatcherBuilder = new FakeHttpLayer.RequestMatcherBuilder();
   }
 
   @Test
-  public void requestMatcherBuilder_shouldAddHost() throws Exception {
+  public void requestMatcherBuilder_shouldAddHost() {
     requestMatcherBuilder.host("example.com");
     assertThat(requestMatcherBuilder.getHostname()).isEqualTo("example.com");
   }
 
   @Test
-  public void requestMatcherBuilder_shouldAddMethod() throws Exception {
+  public void requestMatcherBuilder_shouldAddMethod() {
     requestMatcherBuilder.method("POST");
     assertThat(requestMatcherBuilder.getMethod()).isEqualTo("POST");
   }
 
   @Test
-  public void requestMatcherBuilder_shouldAddPath() throws Exception {
+  public void requestMatcherBuilder_shouldAddPath() {
     requestMatcherBuilder.path("foo/bar");
     assertThat(requestMatcherBuilder.getPath()).isEqualTo("/foo/bar");
   }
 
   @Test
-  public void requestMatcherBuilder_shouldAddParams() throws Exception {
+  public void requestMatcherBuilder_shouldAddParams() {
     requestMatcherBuilder.param("param1", "param one");
     assertThat(requestMatcherBuilder.getParam("param1")).isEqualTo("param one");
   }
 
   @Test
-  public void requestMatcherBuilder_shouldAddHeaders() throws Exception {
+  public void requestMatcherBuilder_shouldAddHeaders() {
     requestMatcherBuilder.header("header1", "header one");
     assertThat(requestMatcherBuilder.getHeader("header1")).isEqualTo("header one");
   }
 
   @Test
-  public void matches_shouldMatchHeaders() throws Exception {
+  public void matches_shouldMatchHeaders() {
     requestMatcherBuilder.header("header1", "header one");
     HttpGet match = new HttpGet("example.com");
     HttpGet noMatch = new HttpGet("example.com");
diff --git a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/FakeHttpTest.java b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/FakeHttpTest.java
index 7e2ba4f83..618de07b6 100644
--- a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/FakeHttpTest.java
+++ b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/FakeHttpTest.java
@@ -6,11 +6,9 @@ import static org.junit.Assert.assertTrue;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.io.IOException;
 import org.apache.http.HttpException;
-import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.conn.ConnectionKeepAliveStrategy;
 import org.apache.http.impl.client.DefaultRequestDirector;
-import org.apache.http.protocol.HttpContext;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -47,13 +45,7 @@ public class FakeHttpTest {
   private void makeRequest(String uri) throws HttpException, IOException {
     FakeHttp.addPendingHttpResponse(200, "a happy response body");
 
-    ConnectionKeepAliveStrategy connectionKeepAliveStrategy =
-        new ConnectionKeepAliveStrategy() {
-          @Override
-          public long getKeepAliveDuration(HttpResponse httpResponse, HttpContext httpContext) {
-            return 0;
-          }
-        };
+    ConnectionKeepAliveStrategy connectionKeepAliveStrategy = (httpResponse, httpContext) -> 0;
     DefaultRequestDirector requestDirector =
         new DefaultRequestDirector(
             null,
diff --git a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/ParamsParserTest.java b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/ParamsParserTest.java
index 8a1ff729b..a472e71e4 100644
--- a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/ParamsParserTest.java
+++ b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/ParamsParserTest.java
@@ -36,22 +36,22 @@ public class ParamsParserTest {
   }
 
   @Test
-  public void parseParams_shouldDoNothingForEmptyEntity() throws Exception {
+  public void parseParams_shouldDoNothingForEmptyEntity() {
     HttpPut put = new HttpPut("example.com");
     Map<String, String> params = ParamsParser.parseParams(put);
     assertThat(params).isEmpty();
   }
 
   @Test
-  public void parseParams_shouldParseParamsFromGetRequests() throws Exception {
+  public void parseParams_shouldParseParamsFromGetRequests() {
     HttpGet httpGet = new HttpGet("http://example.com/path?foo=bar");
     Map<String, String> parsed = ParamsParser.parseParams(httpGet);
-    assertThat(parsed.size()).isEqualTo(1);
+    assertThat(parsed).hasSize(1);
     assertThat(parsed.get("foo")).isEqualTo("bar");
   }
 
   @Test
-  public void parseParams_returnsNullForUnsupportedOperations() throws Exception {
+  public void parseParams_returnsNullForUnsupportedOperations() {
     HttpDelete httpDelete = new HttpDelete("http://example.com/deleteme");
     assertThat(ParamsParser.parseParams(httpDelete)).isEmpty();
   }
diff --git a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/TestHttpResponseTest.java b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/TestHttpResponseTest.java
index bd53bd67f..dd2086be0 100644
--- a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/TestHttpResponseTest.java
+++ b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/TestHttpResponseTest.java
@@ -15,7 +15,7 @@ import org.junit.runner.RunWith;
 public class TestHttpResponseTest {
 
   @Test
-  public void shouldSupportGetFirstHeader() throws Exception {
+  public void shouldSupportGetFirstHeader() {
     HttpResponse resp =
         new TestHttpResponse(304, "REDIRECTED", new BasicHeader("Location", "http://bar.com"));
 
@@ -28,7 +28,7 @@ public class TestHttpResponseTest {
   }
 
   @Test
-  public void shouldSupportGetLastHeader() throws Exception {
+  public void shouldSupportGetLastHeader() {
     HttpResponse resp =
         new TestHttpResponse(
             304,
@@ -44,7 +44,7 @@ public class TestHttpResponseTest {
   }
 
   @Test
-  public void shouldSupportContainsHeader() throws Exception {
+  public void shouldSupportContainsHeader() {
     HttpResponse resp =
         new TestHttpResponse(304, "ZOMBO", new BasicHeader("X-Zombo-Com", "Welcome"));
 
@@ -53,7 +53,7 @@ public class TestHttpResponseTest {
   }
 
   @Test
-  public void shouldSupportHeaderIterator() throws Exception {
+  public void shouldSupportHeaderIterator() {
     HttpResponse resp =
         new TestHttpResponse(
             304,
@@ -70,7 +70,7 @@ public class TestHttpResponseTest {
   }
 
   @Test
-  public void shouldSupportHeaderIteratorWithArg() throws Exception {
+  public void shouldSupportHeaderIteratorWithArg() {
     HttpResponse resp =
         new TestHttpResponse(
             304,
@@ -89,7 +89,7 @@ public class TestHttpResponseTest {
   }
 
   @Test
-  public void shouldSupportGetHeadersWithArg() throws Exception {
+  public void shouldSupportGetHeadersWithArg() {
     HttpResponse resp =
         new TestHttpResponse(
             304,
diff --git a/shadows/httpclient/src/test/resources/AndroidManifest.xml b/shadows/httpclient/src/test/resources/AndroidManifest.xml
index 1180b52f2..6af673d2f 100644
--- a/shadows/httpclient/src/test/resources/AndroidManifest.xml
+++ b/shadows/httpclient/src/test/resources/AndroidManifest.xml
@@ -4,6 +4,5 @@
 
     <uses-sdk android:targetSdkVersion="19"/>
 
-    <application android:name="android.app.Application">
-    </application>
+    <application android:name="android.app.Application"/>
 </manifest>
diff --git a/shadows/playservices/build.gradle.kts b/shadows/playservices/build.gradle.kts
index a8b355192..b32ba63e7 100644
--- a/shadows/playservices/build.gradle.kts
+++ b/shadows/playservices/build.gradle.kts
@@ -24,6 +24,7 @@ dependencies {
   testImplementation(libs.junit4)
   testImplementation(libs.truth)
   testImplementation(libs.mockito)
+  testImplementation(libs.mockito.subclass)
   testRuntimeOnly(libs.bundles.play.services.`for`.shadows)
   testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
 }
diff --git a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtil.java b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtil.java
index 7c7ec4293..6bf2bf1bb 100644
--- a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtil.java
+++ b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtil.java
@@ -10,10 +10,10 @@ import com.google.android.gms.auth.GoogleAuthUtil;
 import com.google.android.gms.auth.GooglePlayServicesAvailabilityException;
 import com.google.android.gms.auth.UserRecoverableAuthException;
 import com.google.android.gms.auth.UserRecoverableNotifiedException;
-import com.google.common.base.Preconditions;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Objects;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
@@ -23,7 +23,10 @@ import org.robolectric.annotation.Resetter;
  * GoogleAuthUtilImpl} implementation. Use {@link #provideImpl(GoogleAuthUtilImpl)} to set the
  * implementation instance. By default, a {@link GoogleAuthUtilImpl} is used in call redirection.
  * Use mocks or subclassing {@link GoogleAuthUtilImpl} to achieve desired behaviors.
+ *
+ * @deprecated This package is no longer maintained and will be removed in Robolectric 4.16.
  */
+@Deprecated
 @Implements(GoogleAuthUtil.class)
 public class ShadowGoogleAuthUtil {
 
@@ -34,7 +37,7 @@ public class ShadowGoogleAuthUtil {
   }
 
   public static synchronized void provideImpl(GoogleAuthUtilImpl impl) {
-    googleAuthUtilImpl = Preconditions.checkNotNull(impl);
+    googleAuthUtilImpl = Objects.requireNonNull(impl);
   }
 
   @Resetter
@@ -207,7 +210,7 @@ public class ShadowGoogleAuthUtil {
         String authority,
         Bundle syncBundle)
         throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
-      if (authority == null || authority.length() == 0) {
+      if (authority == null || authority.isEmpty()) {
         throw new IllegalArgumentException("Authority cannot be empty.");
       }
       return "token";
diff --git a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtil.java b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtil.java
index 729b3e138..561fa408c 100644
--- a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtil.java
+++ b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtil.java
@@ -10,7 +10,7 @@ import android.content.res.Resources;
 import androidx.fragment.app.Fragment;
 import com.google.android.gms.common.ConnectionResult;
 import com.google.android.gms.common.GooglePlayServicesUtil;
-import com.google.common.base.Preconditions;
+import java.util.Objects;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -22,7 +22,10 @@ import org.robolectric.annotation.Resetter;
  * #provideImpl(GooglePlayServicesUtilImpl)} to set the implementation instance. By default, a
  * {@link GooglePlayServicesUtilImpl} is used in call redirection. Use mocks or subclassing {@link
  * GooglePlayServicesUtilImpl} to achieve desired behaviors.
+ *
+ * @deprecated This package is no longer maintained and will be removed in Robolectric 4.16.
  */
+@Deprecated
 @Implements(GooglePlayServicesUtil.class)
 public class ShadowGooglePlayServicesUtil {
   private static GooglePlayServicesUtilImpl googlePlayServicesUtilImpl =
@@ -33,7 +36,7 @@ public class ShadowGooglePlayServicesUtil {
   }
 
   public static synchronized void provideImpl(GooglePlayServicesUtilImpl impl) {
-    googlePlayServicesUtilImpl = Preconditions.checkNotNull(impl);
+    googlePlayServicesUtilImpl = Objects.requireNonNull(impl);
   }
 
   @Resetter
diff --git a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/common/ShadowGoogleApiAvailability.java b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/common/ShadowGoogleApiAvailability.java
index 6d3236922..9bf853203 100644
--- a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/common/ShadowGoogleApiAvailability.java
+++ b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/common/ShadowGoogleApiAvailability.java
@@ -10,11 +10,14 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadow.api.Shadow;
 
+/**
+ * @deprecated This package is no longer maintained and will be removed in Robolectric 4.16.
+ */
+@Deprecated
 @Implements(GoogleApiAvailability.class)
 public class ShadowGoogleApiAvailability {
   private int availabilityCode = ConnectionResult.SERVICE_MISSING;
   private boolean isUserResolvableError = false;
-  private String openSourceSoftwareLicenseInfo = "";
   private Dialog errorDialog;
 
   @Implementation
@@ -42,7 +45,7 @@ public class ShadowGoogleApiAvailability {
 
   @Implementation
   public String getOpenSourceSoftwareLicenseInfo(Context context) {
-    return openSourceSoftwareLicenseInfo;
+    return "";
   }
 
   @Implementation
diff --git a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/package-info.java b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/package-info.java
index 2f6993bf9..8501b331f 100644
--- a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/package-info.java
+++ b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/package-info.java
@@ -1,7 +1,10 @@
 /**
  * Shadows for the Google Play Services Library.
  *
- * <p>To use this in your project, add the artifact {@code org.robolectric:shadows-play-services} to
+ * <p>To use this in your project, add the artifact {@code org.robolectric:shadows-playservices} to
  * your project.
+ *
+ * @deprecated This package is no longer maintained and will be removed in Robolectric 4.16.
  */
+@Deprecated
 package org.robolectric.shadows.gms;
diff --git a/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtilTest.java b/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtilTest.java
index 1ee274078..f0f87ea6c 100644
--- a/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtilTest.java
+++ b/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtilTest.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows.gms;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThrows;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
@@ -11,10 +12,9 @@ import android.content.Intent;
 import com.google.android.gms.auth.AccountChangeEvent;
 import com.google.android.gms.auth.GoogleAuthUtil;
 import java.util.List;
+import org.junit.After;
 import org.junit.Before;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
@@ -30,16 +30,21 @@ import org.robolectric.shadows.gms.ShadowGoogleAuthUtil.GoogleAuthUtilImpl;
     shadows = {ShadowGoogleAuthUtil.class})
 public class ShadowGoogleAuthUtilTest {
 
-  @Mock private GoogleAuthUtilImpl mockGoogleAuthUtil;
+  private AutoCloseable mock;
 
-  @Rule public ExpectedException thrown = ExpectedException.none();
+  @Mock private GoogleAuthUtilImpl mockGoogleAuthUtil;
 
   @Before
   public void setup() {
-    MockitoAnnotations.initMocks(this);
+    mock = MockitoAnnotations.openMocks(this);
     ShadowGoogleAuthUtil.reset();
   }
 
+  @After
+  public void tearDown() throws Exception {
+    mock.close();
+  }
+
   @Test
   public void getImplementation_defaultNotNull() {
     assertNotNull(ShadowGoogleAuthUtil.getImpl());
@@ -47,12 +52,11 @@ public class ShadowGoogleAuthUtilTest {
 
   @Test
   public void provideImplementation_nullValueNotAllowed() {
-    thrown.expect(NullPointerException.class);
-    ShadowGoogleAuthUtil.provideImpl(null);
+    assertThrows(NullPointerException.class, () -> ShadowGoogleAuthUtil.provideImpl(null));
   }
 
   @Test
-  public void getImplementation_shouldGetSetted() {
+  public void getImplementation_shouldGetSet() {
     ShadowGoogleAuthUtil.provideImpl(mockGoogleAuthUtil);
     GoogleAuthUtilImpl googleAuthUtil = ShadowGoogleAuthUtil.getImpl();
     assertSame(googleAuthUtil, mockGoogleAuthUtil);
@@ -119,19 +123,20 @@ public class ShadowGoogleAuthUtilTest {
   }
 
   @Test
-  public void getTokenWithNotification_nullCallBackThrowIllegalArgumentException()
-      throws Exception {
-    thrown.expect(IllegalArgumentException.class);
-    GoogleAuthUtil.getTokenWithNotification(
-        RuntimeEnvironment.getApplication(), "name", "scope", null, null);
+  public void getTokenWithNotification_nullCallBackThrowIllegalArgumentException() {
+    assertThrows(
+        IllegalArgumentException.class,
+        () ->
+            GoogleAuthUtil.getTokenWithNotification(
+                RuntimeEnvironment.getApplication(), "name", "scope", null, null));
   }
 
   @Test
-  public void getTokenWithNotification_nullAuthorityThrowIllegalArgumentException()
-      throws Exception {
-    thrown.expect(IllegalArgumentException.class);
-    assertNotNull(
-        GoogleAuthUtil.getTokenWithNotification(
-            RuntimeEnvironment.getApplication(), "name", "scope", null, null, null));
+  public void getTokenWithNotification_nullAuthorityThrowIllegalArgumentException() {
+    assertThrows(
+        IllegalArgumentException.class,
+        () ->
+            GoogleAuthUtil.getTokenWithNotification(
+                RuntimeEnvironment.getApplication(), "name", "scope", null, null, null));
   }
 }
diff --git a/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtilTest.java b/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtilTest.java
index c828fa814..a28234b62 100644
--- a/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtilTest.java
+++ b/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtilTest.java
@@ -4,6 +4,7 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThrows;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.when;
 
@@ -11,10 +12,9 @@ import android.app.Activity;
 import android.content.Context;
 import com.google.android.gms.common.ConnectionResult;
 import com.google.android.gms.common.GooglePlayServicesUtil;
+import org.junit.After;
 import org.junit.Before;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
@@ -31,11 +31,16 @@ public class ShadowGooglePlayServicesUtilTest {
 
   @Mock private GooglePlayServicesUtilImpl mockGooglePlayServicesUtil;
 
-  @Rule public ExpectedException thrown = ExpectedException.none();
+  private AutoCloseable mock;
 
   @Before
   public void setup() {
-    MockitoAnnotations.initMocks(this);
+    mock = MockitoAnnotations.openMocks(this);
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    mock.close();
   }
 
   @Test
@@ -45,12 +50,11 @@ public class ShadowGooglePlayServicesUtilTest {
 
   @Test
   public void provideImplementation_nullValueNotAllowed() {
-    thrown.expect(NullPointerException.class);
-    ShadowGooglePlayServicesUtil.provideImpl(null);
+    assertThrows(NullPointerException.class, () -> ShadowGooglePlayServicesUtil.provideImpl(null));
   }
 
   @Test
-  public void getImplementation_shouldGetSetted() {
+  public void getImplementation_shouldGetSet() {
     ShadowGooglePlayServicesUtil.provideImpl(mockGooglePlayServicesUtil);
     ShadowGooglePlayServicesUtil.GooglePlayServicesUtilImpl googlePlayServicesUtil =
         ShadowGooglePlayServicesUtil.getImpl();
diff --git a/simulator-gradle-plugin/build.gradle.kts b/simulator-gradle-plugin/build.gradle.kts
new file mode 100644
index 000000000..f3755e6b5
--- /dev/null
+++ b/simulator-gradle-plugin/build.gradle.kts
@@ -0,0 +1,68 @@
+import java.io.File
+import org.robolectric.gradle.applyPomMetadata
+import org.robolectric.gradle.sonatypeRepositories
+
+plugins {
+  `kotlin-dsl`
+  `java-gradle-plugin`
+  `maven-publish`
+  signing
+}
+
+gradlePlugin {
+  plugins {
+    create("simulatorPlugin") {
+      id = "org.robolectric.simulator"
+      implementationClass = "org.robolectric.simulator.gradle.SimulatorPlugin"
+    }
+  }
+}
+
+dependencies {
+  compileOnly("com.android.tools.build:gradle:8.2.2")
+  implementation(libs.kotlin.stdlib)
+  implementation(project(":simulator"))
+}
+
+afterEvaluate {
+  val isSnapshotVersion = project.version.toString().endsWith("-SNAPSHOT")
+  publishing {
+    publications.named("pluginMaven", MavenPublication::class) { applyPomMetadata(project) }
+
+    sonatypeRepositories(isSnapshotVersion)
+    signing {
+      setRequired { !isSnapshotVersion }
+      sign(publications.getByName("pluginMaven"))
+    }
+  }
+}
+
+val generatedSourcesDir = File(buildDir, "generated-sources/kotlin/")
+
+// Generates a file containing the Robolectric version to be used by the plugin.
+val generateVersionFile by
+  tasks.registering {
+    outputs.dir(generatedSourcesDir)
+    doLast {
+      val versionFile =
+        File(generatedSourcesDir, "org/robolectric/simulator/gradle/generated/Version.kt")
+      versionFile.getParentFile().mkdirs()
+      versionFile.writeText(
+        """
+        package org.robolectric.simulator.gradle.generated
+
+        // Generated by Gradle. Do not edit.
+        object Version {
+            const val VERSION = "${project.version}"
+        }
+        """
+          .trimIndent()
+      )
+    }
+  }
+
+sourceSets.main.get().kotlin.srcDirs(generatedSourcesDir)
+
+tasks.named("compileKotlin") { dependsOn(generateVersionFile) }
+
+tasks.named("clean") { delete(generatedSourcesDir) }
diff --git a/simulator-gradle-plugin/src/main/kotlin/org/robolectric/SimulatorPlugin.kt b/simulator-gradle-plugin/src/main/kotlin/org/robolectric/SimulatorPlugin.kt
new file mode 100644
index 000000000..767e8666d
--- /dev/null
+++ b/simulator-gradle-plugin/src/main/kotlin/org/robolectric/SimulatorPlugin.kt
@@ -0,0 +1,61 @@
+package org.robolectric.simulator.gradle
+
+import com.android.build.gradle.AppExtension
+import java.io.File
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+import org.gradle.api.tasks.JavaExec
+import org.gradle.api.tasks.testing.Test
+import org.robolectric.simulator.gradle.generated.Version
+
+class SimulatorPlugin : Plugin<Project> {
+  override fun apply(project: Project) {
+    val androidExtension = getAndroidExtension(project)
+    if (androidExtension == null) {
+      return
+    }
+
+    project.afterEvaluate {
+      project.tasks.register("simulate", JavaExec::class.java) {
+        group = "simulation"
+        description = "Runs the Robolectric simulator"
+        configureTask(project, this)
+      }
+    }
+  }
+
+  private fun getAndroidExtension(project: Project) =
+    project.extensions.findByType(AppExtension::class.java)
+
+  private fun configureTask(project: Project, task: JavaExec) {
+
+    val testTaskName = "testDebugUnitTest"
+    val testTask = project.tasks.findByName(testTaskName) as? Test
+    val buildDir = project.buildDir
+    // This is the name of the resource APK file generated by AGP for Robolectric tests.
+    // TODO(hoisie): derive this path from the Android plugin.
+    val resourceApkFile =
+      File(buildDir, "intermediates/apk_for_local_test/debugUnitTest/apk-for-local-test.ap_")
+
+    if (testTask == null) {
+      throw IllegalStateException("Missing testDebugUntTest task")
+    }
+
+    val simulator =
+      project.configurations
+        .detachedConfiguration(
+          project.dependencies.create("org.robolectric:simulator:${Version.VERSION}")
+        )
+        .resolve()
+
+    task.apply {
+      classpath = testTask.classpath + project.files(simulator)
+      jvmArgs = testTask.jvmArgs
+      mainClass.set("org.robolectric.simulator.SimulatorMain")
+      args = listOf(resourceApkFile.absolutePath)
+      dependsOn(testTaskName, "assembleDebug")
+      standardOutput = System.out
+      errorOutput = System.err
+    }
+  }
+}
diff --git a/simulator/build.gradle.kts b/simulator/build.gradle.kts
new file mode 100644
index 000000000..fd8cc3fa4
--- /dev/null
+++ b/simulator/build.gradle.kts
@@ -0,0 +1,15 @@
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+}
+
+dependencies {
+  annotationProcessor(libs.error.prone.core)
+  annotationProcessor(libs.auto.service)
+
+  api(project(":robolectric"))
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+  compileOnly(libs.auto.service.annotations)
+
+  api(libs.guava)
+}
diff --git a/simulator/src/main/java/org/robolectric/simulator/AppLoader.java b/simulator/src/main/java/org/robolectric/simulator/AppLoader.java
index f18927ad4..fe7cb8313 100644
--- a/simulator/src/main/java/org/robolectric/simulator/AppLoader.java
+++ b/simulator/src/main/java/org/robolectric/simulator/AppLoader.java
@@ -11,7 +11,7 @@ import java.nio.file.Path;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
-import org.robolectric.Robolectric;
+import java.util.Objects;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.ConscryptMode;
@@ -60,18 +60,16 @@ public class AppLoader implements Runnable {
     ResolveInfo resolveInfo = resolveInfoList.get(0);
     ActivityInfo activityInfo = resolveInfo.activityInfo;
 
-    Preconditions.checkNotNull(activityInfo);
-    Preconditions.checkNotNull(activityInfo.name);
+    Objects.requireNonNull(activityInfo);
+    Objects.requireNonNull(activityInfo.name);
     // Start the main Activity
     try {
       Class<? extends Activity> activityClass =
           Class.forName(activityInfo.name).asSubclass(Activity.class);
-      System.err.println("Launching " + activityClass.getName());
-      Robolectric.setupActivity(activityClass);
+      new Simulator(activityClass).start();
     } catch (Exception e) {
       throw new RuntimeException(e);
     }
-    new Simulator().start();
   }
 
   /**
diff --git a/simulator/src/main/java/org/robolectric/simulator/MouseHandler.java b/simulator/src/main/java/org/robolectric/simulator/MouseHandler.java
index 9062a1407..ad4ae7901 100644
--- a/simulator/src/main/java/org/robolectric/simulator/MouseHandler.java
+++ b/simulator/src/main/java/org/robolectric/simulator/MouseHandler.java
@@ -9,7 +9,6 @@ import android.view.MotionEvent;
 import androidx.test.platform.app.InstrumentationRegistry;
 import java.awt.event.MouseAdapter;
 import java.awt.event.MouseEvent;
-import java.time.Duration;
 import java.time.Instant;
 import javax.swing.JMenuItem;
 import javax.swing.JPopupMenu;
@@ -24,7 +23,6 @@ public class MouseHandler extends MouseAdapter {
       InstrumentationRegistry.getInstrumentation().getUiAutomation();
 
   private boolean isPressed;
-  private Duration androidSystemClockTimeDelta;
   private Instant downTime;
 
   private final Handler handler = new Handler(Looper.getMainLooper());
@@ -44,31 +42,30 @@ public class MouseHandler extends MouseAdapter {
   private JMenuItem getBackMenuItem() {
     JMenuItem sendBackMenuItem = new JMenuItem("Press back");
     sendBackMenuItem.addActionListener(
-        e -> {
-          handler.post(
-              () -> {
-                long eventTime = SystemClock.uptimeMillis();
-                KeyEvent backKeyDown =
-                    new KeyEvent(
-                        eventTime,
-                        eventTime,
-                        KeyEvent.ACTION_DOWN,
-                        KeyEvent.KEYCODE_BACK,
-                        /* repeat= */ 0,
-                        0);
-                ShadowUiAutomation.injectInputEvent(backKeyDown);
-
-                KeyEvent backKeyUp =
-                    new KeyEvent(
-                        eventTime,
-                        eventTime,
-                        KeyEvent.ACTION_UP,
-                        KeyEvent.KEYCODE_BACK,
-                        /* repeat= */ 0,
-                        0);
-                ShadowUiAutomation.injectInputEvent(backKeyUp);
-              });
-        });
+        e ->
+            handler.post(
+                () -> {
+                  long eventTime = SystemClock.uptimeMillis();
+                  KeyEvent backKeyDown =
+                      new KeyEvent(
+                          eventTime,
+                          eventTime,
+                          KeyEvent.ACTION_DOWN,
+                          KeyEvent.KEYCODE_BACK,
+                          /* repeat= */ 0,
+                          0);
+                  ShadowUiAutomation.injectInputEvent(backKeyDown);
+
+                  KeyEvent backKeyUp =
+                      new KeyEvent(
+                          eventTime,
+                          eventTime,
+                          KeyEvent.ACTION_UP,
+                          KeyEvent.KEYCODE_BACK,
+                          /* repeat= */ 0,
+                          0);
+                  ShadowUiAutomation.injectInputEvent(backKeyUp);
+                }));
 
     return sendBackMenuItem;
   }
@@ -77,9 +74,7 @@ public class MouseHandler extends MouseAdapter {
   public void mousePressed(MouseEvent mouseEvent) {
     if (shouldHandle(mouseEvent)) {
       isPressed = true;
-      androidSystemClockTimeDelta =
-          Duration.ofMillis(SystemClock.uptimeMillis()).minus(Duration.ofNanos(System.nanoTime()));
-      downTime = Instant.ofEpochMilli(mouseEvent.getWhen());
+      downTime = Instant.ofEpochMilli(SystemClock.uptimeMillis());
       postMotionEvent(mouseEvent, MotionEvent.ACTION_DOWN);
     }
   }
@@ -113,15 +108,11 @@ public class MouseHandler extends MouseAdapter {
 
   private MotionEvent obtainMotionEvent(MouseEvent mouseEvent, int action) {
     return MotionEvent.obtain(
-        toAndroidTime(downTime),
-        toAndroidTime(Instant.ofEpochMilli(mouseEvent.getWhen())),
+        downTime.toEpochMilli(),
+        SystemClock.uptimeMillis(),
         action,
         mouseEvent.getX(),
         mouseEvent.getY(),
         /* metaState= */ 0);
   }
-
-  private long toAndroidTime(Instant instant) {
-    return instant.minus(androidSystemClockTimeDelta).toEpochMilli();
-  }
 }
diff --git a/simulator/src/main/java/org/robolectric/simulator/SandboxBuilder.java b/simulator/src/main/java/org/robolectric/simulator/SandboxBuilder.java
index 272c24f93..12de4e68e 100644
--- a/simulator/src/main/java/org/robolectric/simulator/SandboxBuilder.java
+++ b/simulator/src/main/java/org/robolectric/simulator/SandboxBuilder.java
@@ -33,6 +33,7 @@ import org.robolectric.util.inject.Injector;
 public final class SandboxBuilder {
 
   private final List<Path> extraJars = new ArrayList<>();
+  private int sdkVersion = -1;
 
   private SandboxBuilder() {}
 
@@ -41,14 +42,14 @@ public final class SandboxBuilder {
   }
 
   @CanIgnoreReturnValue
-  public SandboxBuilder addExtraJar(Path jarPath) {
-    extraJars.add(jarPath);
+  public SandboxBuilder addClasspathEntries(Collection<Path> jarPaths) {
+    extraJars.addAll(jarPaths);
     return this;
   }
 
   @CanIgnoreReturnValue
-  public SandboxBuilder addExtraJars(Collection<Path> jarPaths) {
-    extraJars.addAll(jarPaths);
+  public SandboxBuilder setSdkVersion(int sdkVersion) {
+    this.sdkVersion = sdkVersion;
     return this;
   }
 
@@ -63,7 +64,14 @@ public final class SandboxBuilder {
 
     ArrayList<Sdk> sdks = new ArrayList<>(sdkProvider.getSdks());
 
-    Sdk latestSdk = Iterables.getLast(sdks);
+    Sdk chosenSdk = Iterables.getLast(sdks);
+    if (sdkVersion != -1) {
+      for (Sdk sdk : sdks) {
+        if (sdk.getApiLevel() == sdkVersion) {
+          chosenSdk = sdk;
+        }
+      }
+    }
 
     Interceptors interceptors = new Interceptors(AndroidInterceptors.all());
 
@@ -76,8 +84,8 @@ public final class SandboxBuilder {
     AndroidSandbox androidSandbox =
         sandboxBuilder.build(
             instrumentationConfiguration,
-            latestSdk,
-            latestSdk,
+            chosenSdk,
+            chosenSdk,
             ResourcesMode.Mode.BINARY,
             SQLiteMode.Mode.NATIVE);
 
@@ -89,7 +97,7 @@ public final class SandboxBuilder {
     ShadowMap shadowMap = smBuilder.build();
     androidSandbox.replaceShadowMap(shadowMap);
 
-    AndroidSdkShadowMatcher shadowMatcher = new AndroidSdkShadowMatcher(latestSdk.getApiLevel());
+    AndroidSdkShadowMatcher shadowMatcher = new AndroidSdkShadowMatcher(chosenSdk.getApiLevel());
 
     ClassHandler classHandler = classHandlerBuilder.build(shadowMap, shadowMatcher, interceptors);
 
diff --git a/simulator/src/main/java/org/robolectric/simulator/Simulator.java b/simulator/src/main/java/org/robolectric/simulator/Simulator.java
index 013c90234..a07727ba9 100644
--- a/simulator/src/main/java/org/robolectric/simulator/Simulator.java
+++ b/simulator/src/main/java/org/robolectric/simulator/Simulator.java
@@ -3,19 +3,25 @@ package org.robolectric.simulator;
 import static java.lang.Math.max;
 import static java.lang.Math.min;
 
+import android.app.Activity;
 import android.app.Application;
+import android.app.UiAutomation;
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.hardware.display.DisplayManager;
+import android.os.Handler;
 import android.os.Looper;
 import android.os.SystemClock;
+import android.view.Choreographer;
 import android.view.Display;
+import android.view.MotionEvent;
 import androidx.test.platform.app.InstrumentationRegistry;
 import com.google.common.annotations.Beta;
 import com.google.common.base.Preconditions;
 import java.time.Duration;
 import javax.swing.SwingUtilities;
 import javax.swing.UIManager;
+import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.LooperMode.Mode;
 import org.robolectric.shadow.api.Shadow;
@@ -30,11 +36,34 @@ import org.robolectric.shadows.ShadowView;
 public final class Simulator {
 
   private SimulatorFrame simulatorFrame;
+  private float displayWidth;
+  private float displayHeight;
+
+  private final Class<? extends Activity> activityClassToLaunch;
+
+  public Simulator() {
+    activityClassToLaunch = null;
+  }
+
+  public Simulator(Class<? extends Activity> activityClassToLaunch) {
+    this.activityClassToLaunch = activityClassToLaunch;
+  }
 
   public void start() {
     Preconditions.checkState(ShadowView.useRealGraphics());
     Preconditions.checkState(ShadowLooper.looperMode() != Mode.LEGACY);
     System.setProperty("java.awt.headless", "false");
+    ShadowView.setUseRealViewAnimations(true);
+    ShadowChoreographer.setPaused(true);
+    ShadowChoreographer.setFrameDelay(Duration.ofMillis(15));
+
+    if (this.activityClassToLaunch != null) {
+      System.err.println("Launching " + this.activityClassToLaunch.getName());
+      Robolectric.setupActivity(this.activityClassToLaunch);
+    }
+    // Inject an off-screen motion event to avoid a blank screen when the simulator first starts.
+    postMotionEvent();
+
     startUi();
     captureScreen();
     loop();
@@ -42,9 +71,8 @@ public final class Simulator {
 
   private void loop() {
     ShadowPausedLooper shadowLooper = Shadow.extract(Looper.myLooper());
-    ShadowChoreographer.setPaused(true);
-    ShadowChoreographer.setFrameDelay(Duration.ofMillis(15));
     shadowLooper.idle();
+    Choreographer.getInstance().postFrameCallback(new SimulatorFrameCallback());
     while (true) {
       long currentSystemTime = System.nanoTime();
       long nextTaskTime = shadowLooper.getNextScheduledTaskTime().toMillis();
@@ -65,24 +93,48 @@ public final class Simulator {
     DisplayManager displayManager =
         (DisplayManager) application.getSystemService(Context.DISPLAY_SERVICE);
     Display display = displayManager.getDisplay(Display.DEFAULT_DISPLAY);
-
+    this.displayWidth = display.getWidth();
+    this.displayHeight = display.getHeight();
     try {
       UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
     } catch (Exception e) {
       throw new RuntimeException(e);
     }
+    final int apiLevel = RuntimeEnvironment.getApiLevel();
     SwingUtilities.invokeLater(
-        (Runnable)
-            () -> {
-              simulatorFrame = new SimulatorFrame(display.getWidth(), display.getHeight());
-              simulatorFrame.setVisible(true);
-              simulatorFrame.toFront();
-            });
+        () -> {
+          simulatorFrame =
+              new SimulatorFrame((int) this.displayWidth, (int) this.displayHeight, apiLevel);
+          simulatorFrame.setVisible(true);
+          simulatorFrame.toFront();
+        });
   }
 
   private void captureScreen() {
     final Bitmap bitmap =
         InstrumentationRegistry.getInstrumentation().getUiAutomation().takeScreenshot();
-    SwingUtilities.invokeLater((Runnable) () -> simulatorFrame.getCanvas().drawBitmap(bitmap));
+    SwingUtilities.invokeLater(() -> simulatorFrame.getCanvas().drawBitmap(bitmap));
+  }
+
+  private void postMotionEvent() {
+    UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+    MotionEvent androidEvent =
+        MotionEvent.obtain(
+            /* downTime= */ 0,
+            /* eventTime= */ SystemClock.uptimeMillis(),
+            /* action= */ MotionEvent.ACTION_MOVE,
+            /* x= */ this.displayWidth,
+            /* y= */ this.displayHeight,
+            /* metaState= */ 0);
+
+    new Handler(Looper.getMainLooper())
+        .post(() -> uiAutomation.injectInputEvent(androidEvent, true));
+  }
+
+  private static class SimulatorFrameCallback implements Choreographer.FrameCallback {
+    @Override
+    public void doFrame(long frameTimeNanos) {
+      Choreographer.getInstance().postFrameCallback(this);
+    }
   }
 }
diff --git a/simulator/src/main/java/org/robolectric/simulator/SimulatorFrame.java b/simulator/src/main/java/org/robolectric/simulator/SimulatorFrame.java
index a8a4e463c..bc5aefd2b 100644
--- a/simulator/src/main/java/org/robolectric/simulator/SimulatorFrame.java
+++ b/simulator/src/main/java/org/robolectric/simulator/SimulatorFrame.java
@@ -7,8 +7,8 @@ public class SimulatorFrame extends JFrame {
 
   private final SimulatorCanvas simulatorCanvas;
 
-  public SimulatorFrame(int displayWidth, int displayHeight) {
-    setTitle("Robolectric Simulator");
+  public SimulatorFrame(int displayWidth, int displayHeight, int sdkLevel) {
+    setTitle("Robolectric SDK " + sdkLevel + " Simulator");
 
     setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
     setLocationByPlatform(true);
diff --git a/simulator/src/main/java/org/robolectric/simulator/SimulatorMain.java b/simulator/src/main/java/org/robolectric/simulator/SimulatorMain.java
index 3a8bbf8a2..50668bf2b 100644
--- a/simulator/src/main/java/org/robolectric/simulator/SimulatorMain.java
+++ b/simulator/src/main/java/org/robolectric/simulator/SimulatorMain.java
@@ -11,35 +11,26 @@ import org.robolectric.internal.AndroidSandbox;
 public final class SimulatorMain {
 
   public static void main(String[] args) throws Exception {
-    if (args.length < 2) {
-      System.err.println("Command-line usage: SimulatorLauncher <apk> <deploy_jar> [extra jars]");
+    if (args.length < 1) {
+      System.err.println("Command-line usage: SimulatorLauncher <apk> [extra_jars]");
       System.exit(1);
     }
 
     File apkFile = new File(args[0]);
-    File deployJar = new File(args[1]);
-
-    List<Path> extraJars = new ArrayList<>();
-    for (int i = 2; i < args.length; i++) {
-      extraJars.add(Path.of(args[i]));
-    }
-
     if (!apkFile.exists()) {
       System.err.println("Missing APK file " + args[0]);
       System.exit(1);
     }
 
-    if (!deployJar.exists()) {
-      System.err.println("Missing deploy jar " + args[1]);
-      System.exit(1);
+    List<Path> extraClasspathEntries = new ArrayList<>();
+    extraClasspathEntries.add(
+        apkFile.toPath()); // Include on classpath to open arsc file as a resource.
+    for (int i = 1; i < args.length; i++) {
+      extraClasspathEntries.add(Path.of(args[i]));
     }
 
     final AndroidSandbox androidSandbox =
-        SandboxBuilder.newBuilder()
-            .addExtraJar(apkFile.toPath())
-            .addExtraJar(deployJar.toPath())
-            .addExtraJars(extraJars)
-            .build();
+        SandboxBuilder.newBuilder().addClasspathEntries(extraClasspathEntries).build();
 
     androidSandbox.runOnMainThread(
         () -> {
diff --git a/soong/robolectric.go b/soong/robolectric.go
index 8295f2ddb..185ece968 100644
--- a/soong/robolectric.go
+++ b/soong/robolectric.go
@@ -59,7 +59,7 @@ func (b *buildProps) GenerateAndroidBuildActions(ctx android.ModuleContext) {
 		"ro.hardware=robolectric",
 		"ro.build.version.security_patch=" + ctx.Config().PlatformSecurityPatch(),
 		"ro.build.version.sdk=" + ctx.Config().PlatformSdkVersion().String(),
-		"ro.build.version.sdk_full=" + ctx.Config().PlatformSdkVersion().String() + ".0",
+		"ro.build.version.sdk_full=" + ctx.Config().PlatformSdkVersionFull(),
 		"ro.build.version.release=" + ctx.Config().PlatformVersionName(),
 		"ro.build.version.preview_sdk=" + ctx.Config().PlatformPreviewSdkVersion(),
 		// We don't have the API fingerprint available, just use the preview SDK version.
diff --git a/utils/build.gradle.kts b/utils/build.gradle.kts
index dab0ccc5c..39c22fcb3 100644
--- a/utils/build.gradle.kts
+++ b/utils/build.gradle.kts
@@ -19,7 +19,6 @@ tasks.compileKotlin.configure { compilerOptions.jvmTarget = JvmTarget.JVM_1_8 }
 tasks.compileTestKotlin.configure { compilerOptions.jvmTarget = JvmTarget.JVM_1_8 }
 
 dependencies {
-  api(project(":annotations"))
   api(project(":pluginapi"))
   api(libs.javax.inject)
   api(libs.javax.annotation.api)
@@ -29,8 +28,7 @@ dependencies {
   testCompileOnly(libs.auto.service.annotations)
   testAnnotationProcessor(libs.auto.service)
   testAnnotationProcessor(libs.error.prone.core)
-  implementation(libs.error.prone.annotations)
-
+  testImplementation(libs.findbugs.jsr305)
   testImplementation(libs.junit4)
   testImplementation(libs.truth)
   testImplementation(libs.kotlin.stdlib)
diff --git a/utils/reflector/build.gradle.kts b/utils/reflector/build.gradle.kts
index 2278f0b78..9bc1a338b 100644
--- a/utils/reflector/build.gradle.kts
+++ b/utils/reflector/build.gradle.kts
@@ -6,10 +6,11 @@ plugins {
 dependencies {
   api(libs.asm)
   api(libs.asm.commons)
-  api(libs.asm.util)
+  compileOnly(libs.findbugs.jsr305)
   api(project(":utils"))
 
   testImplementation(project(":shadowapi"))
+  testCompileOnly(libs.findbugs.jsr305)
   testImplementation(libs.junit4)
   testImplementation(libs.truth)
 }
diff --git a/utils/reflector/src/main/java/org/robolectric/util/reflector/Reflector.java b/utils/reflector/src/main/java/org/robolectric/util/reflector/Reflector.java
index b0f0b0218..e8b07c4e1 100644
--- a/utils/reflector/src/main/java/org/robolectric/util/reflector/Reflector.java
+++ b/utils/reflector/src/main/java/org/robolectric/util/reflector/Reflector.java
@@ -1,11 +1,11 @@
 package org.robolectric.util.reflector;
 
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
+import java.nio.file.Files;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -120,7 +120,7 @@ public class Reflector {
     if (DEBUG) {
       File file = new File("/tmp", reflectorClassName + ".class");
       System.out.println("Generated reflector: " + file.getAbsolutePath());
-      try (OutputStream out = new FileOutputStream(file)) {
+      try (OutputStream out = Files.newOutputStream(file.toPath())) {
         out.write(bytecode);
       } catch (IOException e) {
         throw new RuntimeException(e);
diff --git a/utils/reflector/src/main/java/org/robolectric/util/reflector/UnsafeAccess.java b/utils/reflector/src/main/java/org/robolectric/util/reflector/UnsafeAccess.java
index d5c1f196f..e6b56e0c2 100644
--- a/utils/reflector/src/main/java/org/robolectric/util/reflector/UnsafeAccess.java
+++ b/utils/reflector/src/main/java/org/robolectric/util/reflector/UnsafeAccess.java
@@ -49,7 +49,6 @@ public class UnsafeAccess {
     }
 
     @Override
-    @SuppressWarnings("unchecked")
     public <T> Class<?> defineClass(Class<T> iClass, String reflectorClassName, byte[] bytecode) {
       // use reflection to call since this method does not exist on JDK11
       try {
diff --git a/utils/reflector/src/test/java/org/robolectric/util/reflector/ReflectorTest.java b/utils/reflector/src/test/java/org/robolectric/util/reflector/ReflectorTest.java
index f858d88d3..ec91f523a 100644
--- a/utils/reflector/src/test/java/org/robolectric/util/reflector/ReflectorTest.java
+++ b/utils/reflector/src/test/java/org/robolectric/util/reflector/ReflectorTest.java
@@ -17,13 +17,12 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
 @RunWith(JUnit4.class)
 public class ReflectorTest {
 
-  private SomeClass someClass;
   private _SomeClass_ reflector;
   private _SomeClass_ staticReflector;
 
   @Before
-  public void setUp() throws Exception {
-    someClass = new SomeClass("c");
+  public void setUp() {
+    SomeClass someClass = new SomeClass("c");
     reflector = reflector(_SomeClass_.class, someClass);
 
     staticReflector = reflector(_SomeClass_.class, null);
@@ -144,11 +143,11 @@ public class ReflectorTest {
     _SomeClass_ accessor = reflector(_SomeClass_.class, i);
 
     time("ReflectionHelpers", 10_000_000, this::constructorByReflectionHelpers);
-    time("accessor", 10_000_000, () -> constructorByReflector());
+    time("accessor", 10_000_000, this::constructorByReflector);
     time("saved accessor", 10_000_000, () -> constructorBySavedReflector(accessor));
 
-    time("ReflectionHelpers", 10_000_000, () -> constructorByReflectionHelpers());
-    time("accessor", 10_000_000, () -> constructorByReflector());
+    time("ReflectionHelpers", 10_000_000, this::constructorByReflectionHelpers);
+    time("accessor", 10_000_000, this::constructorByReflector);
     time("saved accessor", 10_000_000, () -> constructorBySavedReflector(accessor));
   }
 
@@ -259,8 +258,8 @@ public class ReflectorTest {
     for (int i = 0; i < times; i++) {
       runnable.run();
     }
-    long elasedMs = System.currentTimeMillis() - startTime;
-    System.out.println(name + " took " + elasedMs);
+    long elapsedMs = System.currentTimeMillis() - startTime;
+    System.out.println(name + " took " + elapsedMs);
   }
 
   private String methodByReflectionHelpers(SomeClass o) {
diff --git a/utils/src/main/java/org/robolectric/util/PerfStatsCollector.java b/utils/src/main/java/org/robolectric/util/PerfStatsCollector.java
index 1e45625fe..6e38b7ec7 100644
--- a/utils/src/main/java/org/robolectric/util/PerfStatsCollector.java
+++ b/utils/src/main/java/org/robolectric/util/PerfStatsCollector.java
@@ -4,6 +4,7 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Objects;
 import org.robolectric.pluginapi.perf.Metadata;
 import org.robolectric.pluginapi.perf.Metric;
 import org.robolectric.pluginapi.perf.PerfStatsReporter;
@@ -169,7 +170,7 @@ public class PerfStatsCollector {
       if (success != metricKey.success) {
         return false;
       }
-      return name != null ? name.equals(metricKey.name) : metricKey.name == null;
+      return Objects.equals(name, metricKey.name);
     }
 
     @Override
diff --git a/utils/src/main/java/org/robolectric/util/Scheduler.java b/utils/src/main/java/org/robolectric/util/Scheduler.java
index a4b25c76d..2f553bc65 100644
--- a/utils/src/main/java/org/robolectric/util/Scheduler.java
+++ b/utils/src/main/java/org/robolectric/util/Scheduler.java
@@ -10,6 +10,7 @@ import java.time.Duration;
 import java.util.Iterator;
 import java.util.PriorityQueue;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nonnull;
 
 /**
  * Class that manages a queue of Runnables that are scheduled to run now (or at some time in the
@@ -397,7 +398,7 @@ public class Scheduler {
     }
 
     @Override
-    public int compareTo(ScheduledRunnable runnable) {
+    public int compareTo(@Nonnull ScheduledRunnable runnable) {
       int timeCompare = Long.compare(scheduledTime, runnable.scheduledTime);
       if (timeCompare == 0) {
         return Long.compare(timeDisambiguator, runnable.timeDisambiguator);
diff --git a/utils/src/main/java/org/robolectric/util/SimplePerfStatsReporter.java b/utils/src/main/java/org/robolectric/util/SimplePerfStatsReporter.java
index 68bc24214..198e785cd 100644
--- a/utils/src/main/java/org/robolectric/util/SimplePerfStatsReporter.java
+++ b/utils/src/main/java/org/robolectric/util/SimplePerfStatsReporter.java
@@ -6,7 +6,9 @@ import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Objects;
 import java.util.TreeMap;
+import javax.annotation.Nonnull;
 import org.robolectric.AndroidMetadata;
 import org.robolectric.pluginapi.perf.Metadata;
 import org.robolectric.pluginapi.perf.Metric;
@@ -99,7 +101,7 @@ public class SimplePerfStatsReporter implements PerfStatsReporter {
       if (success != metricKey.success) {
         return false;
       }
-      if (name != null ? !name.equals(metricKey.name) : metricKey.name != null) {
+      if (!Objects.equals(name, metricKey.name)) {
         return false;
       }
       if (sdkLevel != metricKey.sdkLevel) {
@@ -117,7 +119,7 @@ public class SimplePerfStatsReporter implements PerfStatsReporter {
     }
 
     @Override
-    public int compareTo(MetricKey o) {
+    public int compareTo(@Nonnull MetricKey o) {
       int i = name.compareTo(o.name);
       if (i != 0) {
         return i;
diff --git a/utils/src/main/java/org/robolectric/util/SoftThreadLocal.java b/utils/src/main/java/org/robolectric/util/SoftThreadLocal.java
deleted file mode 100644
index d1b24370f..000000000
--- a/utils/src/main/java/org/robolectric/util/SoftThreadLocal.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package org.robolectric.util;
-
-import java.lang.ref.SoftReference;
-
-/**
- * Soft reference to a {@code java.lang.ThreadLocal}.
- *
- * @param <T> The referent to track.
- */
-public abstract class SoftThreadLocal<T> {
-
-  @SuppressWarnings({"AndroidJdkLibsChecker", "NewApi"})
-  private final ThreadLocal<SoftReference<T>> threadLocal =
-      ThreadLocal.withInitial(() -> new SoftReference<>(create()));
-
-  public synchronized T get() {
-    T item = threadLocal.get().get();
-    if (item == null) {
-      item = create();
-      threadLocal.set(new SoftReference<>(item));
-    }
-    return item;
-  }
-
-  public void set(T item) {
-    threadLocal.set(new SoftReference<>(item));
-  }
-
-  protected abstract T create();
-}
diff --git a/utils/src/main/java/org/robolectric/util/TempDirectory.java b/utils/src/main/java/org/robolectric/util/TempDirectory.java
index 7564ec2c1..d5a37dc6a 100644
--- a/utils/src/main/java/org/robolectric/util/TempDirectory.java
+++ b/utils/src/main/java/org/robolectric/util/TempDirectory.java
@@ -18,6 +18,7 @@ import java.util.HashSet;
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import javax.annotation.Nonnull;
 
 /**
  * A helper class for working with temporary directories. All temporary directories created by this
@@ -64,7 +65,7 @@ public class TempDirectory {
 
     synchronized (tempDirectoriesToDelete) {
       // If we haven't initialised the shutdown hook we should set everything up.
-      if (tempDirectoriesToDelete.size() == 0) {
+      if (tempDirectoriesToDelete.isEmpty()) {
         // Use a manual hook that actually clears the directory
         // This is necessary because File.deleteOnExit won't delete non empty directories
         Runtime.getRuntime().addShutdownHook(new Thread(TempDirectory::clearAllDirectories));
@@ -157,8 +158,9 @@ public class TempDirectory {
     Files.walkFileTree(
         directory,
         new SimpleFileVisitor<Path>() {
+          @Nonnull
           @Override
-          public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
+          public FileVisitResult visitFile(Path file, @Nonnull BasicFileAttributes attrs)
               throws IOException {
             // Avoid deleting the obsolete temp directory marker
             if (!(OsUtil.isWindows()
@@ -168,6 +170,7 @@ public class TempDirectory {
             return FileVisitResult.CONTINUE;
           }
 
+          @Nonnull
           @Override
           public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
             if (!dir.equals(directory)) {
diff --git a/utils/src/main/java/org/robolectric/util/inject/Injector.java b/utils/src/main/java/org/robolectric/util/inject/Injector.java
index 7eee9d798..c71b1ba1c 100644
--- a/utils/src/main/java/org/robolectric/util/inject/Injector.java
+++ b/utils/src/main/java/org/robolectric/util/inject/Injector.java
@@ -244,7 +244,6 @@ public class Injector {
     return new MemoizingProvider<>(tProvider);
   }
 
-  @SuppressWarnings("unchecked")
   @Nonnull
   private <T> T inject(@Nonnull Class<? extends T> implementingClass) {
     Constructor<T> ctor;
@@ -264,6 +263,7 @@ public class Injector {
     }
   }
 
+  @SuppressWarnings("unchecked")
   private <T> Constructor<T> findConstructor(@Nonnull Class<? extends T> implementingClass) {
     List<Constructor<T>> injectCtors = new ArrayList<>();
     List<Constructor<T>> otherCtors = new ArrayList<>();
@@ -405,7 +405,7 @@ public class Injector {
       this(theInterface, null);
     }
 
-    public Key(Type theInterface, String name) {
+    public Key(@Nonnull Type theInterface, String name) {
       this.theInterface = theInterface;
       this.name = name;
     }
@@ -423,7 +423,7 @@ public class Injector {
       if (!(o instanceof Key)) {
         return false;
       }
-      Key key = (Key) o;
+      Key<?> key = (Key<?>) o;
       return theInterface.equals(key.theInterface) && Objects.equals(name, key.name);
     }
 
@@ -447,7 +447,7 @@ public class Injector {
       StringBuilder buf = new StringBuilder();
       buf.append(
           theInterface instanceof Class
-              ? ((Class) theInterface).getSimpleName()
+              ? ((Class<?>) theInterface).getSimpleName()
               : theInterface.getTypeName());
       if (name != null) {
         buf.append(" \"").append(name).append("\"");
@@ -456,7 +456,7 @@ public class Injector {
     }
 
     public boolean isArray() {
-      return (theInterface instanceof Class && ((Class) theInterface).isArray())
+      return (theInterface instanceof Class && ((Class<?>) theInterface).isArray())
           || theInterface instanceof GenericArrayType;
     }
 
@@ -471,7 +471,7 @@ public class Injector {
     Class<?> getComponentType() {
       if (isArray()) {
         if (theInterface instanceof Class) {
-          return ((Class) theInterface).getComponentType();
+          return ((Class<?>) theInterface).getComponentType();
         } else if (theInterface instanceof GenericArrayType) {
           Type genericComponentType = ((GenericArrayType) theInterface).getGenericComponentType();
           return (Class<?>) ((ParameterizedType) genericComponentType).getRawType();
@@ -479,7 +479,7 @@ public class Injector {
           throw new InjectionException(this, new IllegalArgumentException());
         }
       } else if (isCollection() && theInterface instanceof ParameterizedType) {
-        return (Class) ((ParameterizedType) theInterface).getActualTypeArguments()[0];
+        return (Class<?>) ((ParameterizedType) theInterface).getActualTypeArguments()[0];
       } else {
         throw new IllegalStateException(theInterface + "...?");
       }
@@ -487,7 +487,7 @@ public class Injector {
 
     boolean isAutoFactory() {
       return theInterface instanceof Class
-          && ((Class) theInterface).isAnnotationPresent(AutoFactory.class);
+          && ((Class<?>) theInterface).isAnnotationPresent(AutoFactory.class);
     }
   }
 
diff --git a/utils/src/main/java/org/robolectric/util/inject/PluginFinder.java b/utils/src/main/java/org/robolectric/util/inject/PluginFinder.java
index f3ed5f14f..bb34a5b22 100644
--- a/utils/src/main/java/org/robolectric/util/inject/PluginFinder.java
+++ b/utils/src/main/java/org/robolectric/util/inject/PluginFinder.java
@@ -145,8 +145,15 @@ class PluginFinder {
                             new InputStreamReader(url.openStream(), StandardCharsets.UTF_8));
                     while (reader.ready()) {
                       String s = reader.readLine();
-                      result.add(
-                          Class.forName(s, false, serviceClassLoader).asSubclass(pluginType));
+                      int startPositionOfComment = s.indexOf('#');
+                      if (startPositionOfComment != -1) {
+                        s = s.substring(0, startPositionOfComment);
+                      }
+                      s = s.trim();
+                      if (!s.isBlank()) {
+                        result.add(
+                            Class.forName(s, false, serviceClassLoader).asSubclass(pluginType));
+                      }
                     }
                     reader.close();
                   }
diff --git a/utils/src/test/java/org/robolectric/util/inject/InjectorTest.java b/utils/src/test/java/org/robolectric/util/inject/InjectorTest.java
index bfa112ca6..e7c2fe9bb 100644
--- a/utils/src/test/java/org/robolectric/util/inject/InjectorTest.java
+++ b/utils/src/test/java/org/robolectric/util/inject/InjectorTest.java
@@ -25,20 +25,20 @@ public class InjectorTest {
   private final List<Class<?>> pluginClasses = new ArrayList<>();
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     builder = new Injector.Builder();
     injector = builder.build();
   }
 
   @Test
-  public void whenImplSpecified_shouldProvideInstance() throws Exception {
+  public void whenImplSpecified_shouldProvideInstance() {
     injector = builder.bind(Thing.class, MyThing.class).build();
 
     assertThat(injector.getInstance(Thing.class)).isInstanceOf(MyThing.class);
   }
 
   @Test
-  public void whenImplSpecified_shouldUseSameInstance() throws Exception {
+  public void whenImplSpecified_shouldUseSameInstance() {
     injector = builder.bind(Thing.class, MyThing.class).build();
 
     Thing thing = injector.getInstance(Thing.class);
@@ -46,36 +46,36 @@ public class InjectorTest {
   }
 
   @Test
-  public void whenServiceSpecified_shouldProvideInstance() throws Exception {
+  public void whenServiceSpecified_shouldProvideInstance() {
     assertThat(injector.getInstance(Thing.class)).isInstanceOf(ThingFromServiceConfig.class);
   }
 
   @Test
-  public void whenServiceSpecified_shouldUseSameInstance() throws Exception {
+  public void whenServiceSpecified_shouldUseSameInstance() {
     Thing thing = injector.getInstance(Thing.class);
     assertThat(injector.getInstance(Thing.class)).isSameInstanceAs(thing);
   }
 
   @Test
-  public void whenConcreteClassRequested_shouldProvideInstance() throws Exception {
+  public void whenConcreteClassRequested_shouldProvideInstance() {
     assertThat(injector.getInstance(MyUmm.class)).isInstanceOf(MyUmm.class);
   }
 
   @Test
-  public void whenDefaultSpecified_shouldProvideInstance() throws Exception {
+  public void whenDefaultSpecified_shouldProvideInstance() {
     injector = builder.bindDefault(Umm.class, MyUmm.class).build();
 
     assertThat(injector.getInstance(Umm.class)).isInstanceOf(MyUmm.class);
   }
 
   @Test
-  public void whenDefaultSpecified_shouldUseSameInstance() throws Exception {
+  public void whenDefaultSpecified_shouldUseSameInstance() {
     Thing thing = injector.getInstance(Thing.class);
     assertThat(injector.getInstance(Thing.class)).isSameInstanceAs(thing);
   }
 
   @Test
-  public void whenNoImplOrServiceOrDefaultSpecified_shouldThrow() throws Exception {
+  public void whenNoImplOrServiceOrDefaultSpecified_shouldThrow() {
     try {
       injector.getInstance(Umm.class);
       fail();
@@ -85,8 +85,7 @@ public class InjectorTest {
   }
 
   @Test
-  public void registerDefaultService_providesFallbackImplOnlyIfNoServiceSpecified()
-      throws Exception {
+  public void registerDefaultService_providesFallbackImplOnlyIfNoServiceSpecified() {
     builder.bindDefault(Thing.class, MyThing.class);
 
     assertThat(injector.getInstance(Thing.class)).isInstanceOf(ThingFromServiceConfig.class);
@@ -96,7 +95,7 @@ public class InjectorTest {
   }
 
   @Test
-  public void shouldPreferSingularPublicConstructorAnnotatedInject() throws Exception {
+  public void shouldPreferSingularPublicConstructorAnnotatedInject() {
     injector = builder.bind(Thing.class, MyThing.class).bind(Umm.class, MyUmm.class).build();
 
     Umm umm = injector.getInstance(Umm.class);
@@ -111,7 +110,7 @@ public class InjectorTest {
   }
 
   @Test
-  public void shouldAcceptSingularPublicConstructorWithoutInjectAnnotation() throws Exception {
+  public void shouldAcceptSingularPublicConstructorWithoutInjectAnnotation() {
     injector =
         builder.bind(Thing.class, MyThing.class).bind(Umm.class, MyUmmNoInject.class).build();
 
@@ -127,7 +126,7 @@ public class InjectorTest {
   }
 
   @Test
-  public void whenArrayRequested_mayReturnMultiplePlugins() throws Exception {
+  public void whenArrayRequested_mayReturnMultiplePlugins() {
     MultiThing[] multiThings = injector.getInstance(MultiThing[].class);
 
     // X comes first because it has a higher priority
@@ -137,7 +136,7 @@ public class InjectorTest {
   }
 
   @Test
-  public void whenCollectionRequested_mayReturnMultiplePlugins() throws Exception {
+  public void whenCollectionRequested_mayReturnMultiplePlugins() {
     ThingRequiringMultiThings it = injector.getInstance(ThingRequiringMultiThings.class);
 
     // X comes first because it has a higher priority
@@ -147,7 +146,7 @@ public class InjectorTest {
   }
 
   @Test
-  public void whenListRequested_itIsUnmodifiable() throws Exception {
+  public void whenListRequested_itIsUnmodifiable() {
     ThingRequiringMultiThings it = injector.getInstance(ThingRequiringMultiThings.class);
 
     try {
@@ -159,7 +158,7 @@ public class InjectorTest {
   }
 
   @Test
-  public void autoFactory_factoryMethodsCreateNewInstances() throws Exception {
+  public void autoFactory_factoryMethodsCreateNewInstances() {
     injector = builder.bind(Umm.class, MyUmm.class).build();
     FooFactory factory = injector.getInstance(FooFactory.class);
     Foo chauncey = factory.create("Chauncey");
@@ -170,7 +169,7 @@ public class InjectorTest {
   }
 
   @Test
-  public void autoFactory_injectedValuesComeFromSuperInjector() throws Exception {
+  public void autoFactory_injectedValuesComeFromSuperInjector() {
     injector = builder.bind(Umm.class, MyUmm.class).build();
     FooFactory factory = injector.getInstance(FooFactory.class);
     Foo chauncey = factory.create("Chauncey");
@@ -178,7 +177,7 @@ public class InjectorTest {
   }
 
   @Test
-  public void whenFactoryRequested_createsInjectedFactory() throws Exception {
+  public void whenFactoryRequested_createsInjectedFactory() {
     injector = builder.bind(Umm.class, MyUmm.class).build();
     FooFactory factory = injector.getInstance(FooFactory.class);
     Foo chauncey = factory.create("Chauncey");
@@ -191,7 +190,7 @@ public class InjectorTest {
   }
 
   @Test
-  public void scopedInjector_shouldCheckParentBeforeProvidingDefault() throws Exception {
+  public void scopedInjector_shouldCheckParentBeforeProvidingDefault() {
     injector = builder.build();
     Injector subInjector = new Injector.Builder(injector).build();
 
@@ -200,7 +199,7 @@ public class InjectorTest {
   }
 
   @Test
-  public void shouldInjectByNamedKeys() throws Exception {
+  public void shouldInjectByNamedKeys() {
     injector =
         builder
             .bind(new Injector.Key<>(String.class, "namedThing"), "named value")
@@ -212,7 +211,7 @@ public class InjectorTest {
   }
 
   @Test
-  public void shouldPreferPluginsOverConcreteClass() throws Exception {
+  public void shouldPreferPluginsOverConcreteClass() {
     PluginFinder pluginFinder = new PluginFinder(new MyServiceFinderAdapter(pluginClasses));
     Injector injector = new Injector.Builder(null, pluginFinder).build();
     pluginClasses.add(SubclassOfConcreteThing.class);
@@ -221,7 +220,7 @@ public class InjectorTest {
   }
 
   @Test
-  public void subInjectorIsUsedForResolvingTransitiveDependencies() throws Exception {
+  public void subInjectorIsUsedForResolvingTransitiveDependencies() {
     FakeSandboxManager sandboxManager = injector.getInstance(FakeSandboxManager.class);
     FakeSdk runtimeSdk = new FakeSdk("runtime");
     FakeSdk compileSdk = new FakeSdk("compile");
@@ -232,7 +231,7 @@ public class InjectorTest {
 
   @Test
   @Ignore("todo")
-  public void objectsCreatedByFactoryShareTransitiveDependencies() throws Exception {
+  public void objectsCreatedByFactoryShareTransitiveDependencies() {
     FakeSandboxManager sandboxManager = injector.getInstance(FakeSandboxManager.class);
     FakeSdk runtimeSdk = new FakeSdk("runtime");
     FakeSdk compileASdk = new FakeSdk("compileA");
@@ -243,7 +242,7 @@ public class InjectorTest {
   }
 
   @Test
-  public void shouldProvideDecentErrorMessages() throws Exception {
+  public void shouldProvideDecentErrorMessages() {
     FakeSandboxManager sandboxManager = injector.getInstance(FakeSandboxManager.class);
     Exception actualException = null;
     try {
@@ -258,7 +257,7 @@ public class InjectorTest {
 
   @Test
   @Ignore("todo")
-  public void shouldOnlyAttemptToResolveTypesKnownToClassLoader() throws Exception {}
+  public void shouldOnlyAttemptToResolveTypesKnownToClassLoader() {}
 
   /////////////////////////////
 
@@ -295,7 +294,7 @@ public class InjectorTest {
     }
 
     @SuppressWarnings("unused")
-    public MyUmm(String thingz) {
+    public MyUmm(String thing) {
       this.thing = null;
     }
   }
diff --git a/utils/src/test/java/org/robolectric/util/inject/MyServiceFinderAdapter.kt b/utils/src/test/java/org/robolectric/util/inject/MyServiceFinderAdapter.kt
index 01418f720..2f65ddc4b 100644
--- a/utils/src/test/java/org/robolectric/util/inject/MyServiceFinderAdapter.kt
+++ b/utils/src/test/java/org/robolectric/util/inject/MyServiceFinderAdapter.kt
@@ -6,7 +6,7 @@ import org.robolectric.util.inject.PluginFinder.ServiceFinderAdapter
 internal class MyServiceFinderAdapter(private val pluginClasses: List<Class<*>>) :
   ServiceFinderAdapter(null) {
   @Nonnull
-  public override fun <T> load(pluginType: Class<T>): Iterable<Class<out T>> {
+  override fun <T> load(pluginType: Class<T>): Iterable<Class<out T>> {
     return fill()
   }
 
```

