```diff
diff --git a/.bazelrc b/.bazelrc
index 83cfd48..f301b3d 100644
--- a/.bazelrc
+++ b/.bazelrc
@@ -1,7 +1,3 @@
-# Until we have migrated all deps out of WORKSPACE file, we need to continue to use it.
-# Starting with bazel 8, this flag flips to default false.
-common --enable_workspace
-
 # Runfiles are needed by several tests. Typically these are defaulted on for
 # non-Windows platforms.
 build --enable_runfiles
diff --git a/Android.bp b/Android.bp
index ff3747f..6892bfd 100644
--- a/Android.bp
+++ b/Android.bp
@@ -15,36 +15,52 @@ license {
     ],
 }
 
-cc_library {
+cc_library_static {
     name: "iamf_tools",
     export_include_dirs: [
-        "iamf/api",
-        "iamf/api/decoder",
-    ],
-    cflags: [
-        "-DIAMF_TOOLS_DISABLE_AAC_DECODER",
-        "-DIAMF_TOOLS_DISABLE_FLAC_DECODER",
+        "iamf/include/",
     ],
     shared_libs: [
+        "libFLAC",
+        "libFraunhoferAAC",
         "liblog",
         "libopus",
     ],
-    static_libs: [
-        "libabsl",
+    whole_static_libs: [
+        "absl_status",
+        "absl_status_statusor",
+        "absl_strings",
+        "absl_types_span",
+        "absl_log",
+        "absl_log_check",
+        "absl_container_flat_hash_map",
+        "absl_container_flat_hash_set",
+        "absl_container_node_hash_map",
     ],
     local_include_dirs: [
         ".",
     ],
+    // iamf_tools is developed using Bazel/Google C++ style of full include paths
+    // (rather than using include folders inside dependencies), so we add the roots
+    // of these dependencies here.
     include_dirs: [
+        "external/aac",
         "external/abseil-cpp",
+        "external/flac",
         "external/libopus",
     ],
     srcs: [
+        "iamf/api/conversion/channel_reorderer.cc",
         "iamf/api/conversion/mix_presentation_conversion.cc",
+        "iamf/api/conversion/profile_conversion.cc",
         "iamf/api/decoder/iamf_decoder.cc",
+        "iamf/api/iamf_tools_api_types.cc",
         "iamf/cli/audio_frame_decoder.cc",
         "iamf/cli/channel_label.cc",
         "iamf/cli/cli_util.cc",
+        "iamf/cli/codec/aac_decoder.cc",
+        "iamf/cli/codec/flac_decoder_stream_callbacks.cc",
+        "iamf/cli/codec/flac_decoder.cc",
         "iamf/cli/codec/lpcm_decoder.cc",
         "iamf/cli/codec/opus_decoder.cc",
         "iamf/cli/codec/opus_utils.cc",
@@ -91,10 +107,11 @@ cc_library {
         "iamf/obu/parameter_block.cc",
         "iamf/obu/recon_gain_info_parameter_data.cc",
     ],
+    min_sdk_version: "apex_inherit",
     apex_available: [
         "com.android.media.swcodec",
     ],
     visibility: [
-        "//frameworks/av/media/codec2/components/iamf",
+        "//frameworks/av/media/codec2:__subpackages__",
     ],
 }
diff --git a/METADATA b/METADATA
index 6d8d34d..c734c27 100644
--- a/METADATA
+++ b/METADATA
@@ -13,14 +13,14 @@ third_party {
   license_note: "Alliance for Open Media Patent License and BSD 3-Clause Clear License as described in iamf_tools/LICENSE and iamf_tools/PATENTS and in the headers for all code files in iamf_tools/iamf/, such as iamf_tools/iamf/common/read_bit_buffer.h."
   last_upgrade_date {
     year: 2025
-    month: 3
-    day: 24
+    month: 5
+    day: 22
   }
   homepage: "https://aomediacodec.github.io/iamf/"
   identifier {
     type: "Git"
     value: "https://github.com/AOMediaCodec/iamf-tools"
-    version: "e42e82092f6a46df4c1eebc0e67fa1fdd6788696"
+    version: "3b42c3ebf8cb7be92ffb136832227725aa198db9"
     primary_source: true
   }
 }
diff --git a/MODULE.bazel b/MODULE.bazel
index 3c56a16..8d4d97c 100644
--- a/MODULE.bazel
+++ b/MODULE.bazel
@@ -1,8 +1,7 @@
 ###############################################################################
-# This project is now using bazelmod to manage some dependencies.
-# Some still remain in WORKSPACE.
+# This project uses bazelmod to manage dependencies.
 #
-# For more details, please check https://github.com/bazelbuild/bazel/issues/18958
+# For more details, please check https://bazel.build/external/module.
 ###############################################################################
 
 module(
@@ -10,7 +9,9 @@ module(
     version = "1.0.0",
 )
 
+# Bazel central registry dependencies.
 bazel_dep(name = "rules_cc", version = "0.1.1")
+bazel_dep(name = "rules_license", version = "1.0.0")
 bazel_dep(
     name = "abseil-cpp",
     version = "20240722.0.bcr.2",
@@ -38,5 +39,54 @@ bazel_dep(
 )
 bazel_dep(
     name = "eigen",
-    version = "3.4.0",
+    version = "3.4.0.bcr.3",
+)
+bazel_dep(name = "platforms", version = "0.0.11")
+
+# Some modules are not yet available in the bazel central registry. We use git_repository for all of
+# them, and provide custom BUILD files for projects that are not bazel-native.
+git_repository = use_repo_rule("@bazel_tools//tools/build_defs/repo:git.bzl", "git_repository")
+
+git_repository(
+    name = "com_google_audio_to_tactile",
+    commit = "d3f449fdfd8cfe4a845d0ae244fce2a0bca34a15",
+    remote = "https://github.com/google/audio-to-tactile.git",
+)
+
+git_repository(
+    name = "com_google_loudness_ebur128",
+    commit = "e9e73147637db60dc742cba8a611a37dd72b14b5",
+    remote = "https://github.com/google/loudness_ebur128.git",
+)
+
+# Expat.
+git_repository(
+    name = "libexpat",
+    build_file = "@//external:libexpat.BUILD",
+    commit = "fa75b96546c069d17b8f80d91e0f4ef0cde3790d",
+    remote = "https://github.com/libexpat/libexpat.git",
+)
+
+# FDK AAC.
+git_repository(
+    name = "fdk_aac",
+    build_file = "@//external:fdk_aac.BUILD",
+    commit = "38c27d428ee223bf32f0a2a07cae9fcb99cf3cae",
+    remote = "https://android.googlesource.com/platform/external/aac",
+)
+
+# FLAC.
+git_repository(
+    name = "flac",
+    build_file = "@//external:flac.BUILD",
+    commit = "8d648456a2d7444d54a579e365bab4c815ac6873",
+    remote = "https://github.com/xiph/flac.git",
+)
+
+# Opus.
+git_repository(
+    name = "libopus",
+    build_file = "@//external:libopus.BUILD",
+    commit = "82ac57d9f1aaf575800cf17373348e45b7ce6c0d",
+    remote = "https://gitlab.xiph.org/xiph/opus.git",
 )
diff --git a/WORKSPACE b/WORKSPACE
deleted file mode 100644
index fb7f312..0000000
--- a/WORKSPACE
+++ /dev/null
@@ -1,50 +0,0 @@
-####################################################################################################
-# This project is now manages dependencies with both bazelmod and WORKSPACE, with the goal of moving
-# all dependencies to bazelmod.
-#
-# For more details, please check https://github.com/bazelbuild/bazel/issues/18958.
-####################################################################################################
-
-load(
-    "@bazel_tools//tools/build_defs/repo:git.bzl",
-    "git_repository",
-)
-
-# Google Audio-to-Tactile Library.
-git_repository(
-    name = "com_google_audio_to_tactile",
-    commit = "d3f449fdfd8cfe4a845d0ae244fce2a0bca34a15",
-    remote = "https://github.com/google/audio-to-tactile.git",
-)
-
-# Expat.
-git_repository(
-    name = "libexpat",
-    build_file = "libexpat.BUILD",
-    commit = "fa75b96546c069d17b8f80d91e0f4ef0cde3790d",
-    remote = "https://github.com/libexpat/libexpat.git",
-)
-
-# FDK AAC.
-git_repository(
-    name = "fdk_aac",
-    build_file = "fdk_aac.BUILD",
-    commit = "38c27d428ee223bf32f0a2a07cae9fcb99cf3cae",
-    remote = "https://android.googlesource.com/platform/external/aac",
-)
-
-# FLAC.
-git_repository(
-    name = "flac",
-    build_file = "flac.BUILD",
-    commit = "28e4f0528c76b296c561e922ba67d43751990599",
-    remote = "https://github.com/xiph/flac.git",
-)
-
-# Opus.
-git_repository(
-    name = "libopus",
-    build_file = "libopus.BUILD",
-    commit = "82ac57d9f1aaf575800cf17373348e45b7ce6c0d",
-    remote = "https://gitlab.xiph.org/xiph/opus.git",
-)
diff --git a/external/flac.BUILD b/external/flac.BUILD
index 213bbca..d6ce49c 100644
--- a/external/flac.BUILD
+++ b/external/flac.BUILD
@@ -45,21 +45,26 @@ flac_hdrs = glob([
     "src/libFLAC/**/*.h",
 ])
 
-flac_copts = [
-    "-w",
-    "-Iexternal/flac/src/libFLAC/include",
-    "-Iexternal/flac/include",
+flac_copts = ["-w"]
+
+flac_includes = [
+    "src/libFLAC/include",
+    "include",
 ]
 
+# Defines which do not need to propagate to all downstream users.
 flac_local_defines = [
     "FLAC__HAS_OGG=0",
     "FLAC__USE_VISIBILITY_ATTR",
-    "PACKAGE_VERSION=\\\"1.4.3\\\"",
+    "PACKAGE_VERSION=\\\"1.5.0\\\"",
     "HAVE_STDINT_H",
     "HAVE_LROUND",
     "NDEBUG",
     "_FORTIFY_SOURCE=2",
-]
+] + select({
+    "@platforms//os:osx": ["HAVE_FSEEKO"],
+    "//conditions:default": [],
+})
 
 # Defines which need to propagate to all downstream users.
 flac_defines = select({
@@ -77,17 +82,16 @@ cc_library(
     srcs = flac_srcs,
     hdrs = flac_hdrs,
     copts = flac_copts,
-    local_defines = flac_local_defines,
     defines = flac_defines,
+    includes = flac_includes,
     linkopts = flac_linkopts,
+    local_defines = flac_local_defines,
     textual_hdrs = flac_textual_includes,
 )
 
 cc_library(
     name = "src",
-    copts = [
-        "-w",
-    ],
+    copts = flac_copts,
     deps = [
         ":flac",
     ],
diff --git a/iamf/api/BUILD b/iamf/api/BUILD
index cb4e078..ebdf6f8 100644
--- a/iamf/api/BUILD
+++ b/iamf/api/BUILD
@@ -1,8 +1,12 @@
+package(default_visibility = ["//iamf/api:__subpackages__"])
+
 # keep-sorted start block=yes prefix_order=cc_library newline_separated=yes
 cc_library(
-    name = "types",
-    hdrs = ["types.h"],
-    visibility = ["//iamf/api:__subpackages__"],
+    name = "iamf_tools_api_types",
+    srcs = ["iamf_tools_api_types.cc"],
+    hdrs = [
+        "//iamf/include/iamf_tools:iamf_tools_api_types_header",
+    ],
 )
 
 # keep-sorted end
diff --git a/iamf/api/conversion/BUILD b/iamf/api/conversion/BUILD
index 4285786..84d1e34 100644
--- a/iamf/api/conversion/BUILD
+++ b/iamf/api/conversion/BUILD
@@ -1,15 +1,27 @@
+load("@rules_cc//cc:cc_library.bzl", "cc_library")
+
 package(default_visibility = [
     "//iamf/api/conversion/tests:__pkg__",
     "//iamf/api/decoder:__pkg__",
 ])
 
 # keep-sorted start block=yes prefix_order=cc_library newline_separated=yes
+cc_library(
+    name = "channel_reorderer",
+    srcs = ["channel_reorderer.cc"],
+    hdrs = ["channel_reorderer.h"],
+    deps = [
+        "//iamf/obu:mix_presentation",
+        "@com_google_absl//absl/types:span",
+    ],
+)
+
 cc_library(
     name = "mix_presentation_conversion",
     srcs = ["mix_presentation_conversion.cc"],
     hdrs = ["mix_presentation_conversion.h"],
     deps = [
-        "//iamf/api:types",
+        "//iamf/api:iamf_tools_api_types",
         "//iamf/obu:mix_presentation",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/status",
@@ -17,4 +29,19 @@ cc_library(
         "@com_google_absl//absl/strings",
     ],
 )
+
+cc_library(
+    name = "profile_conversion",
+    srcs = ["profile_conversion.cc"],
+    hdrs = ["profile_conversion.h"],
+    deps = [
+        "//iamf/api:iamf_tools_api_types",
+        "//iamf/obu:ia_sequence_header",
+        "@com_google_absl//absl/log",
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/status:statusor",
+        "@com_google_absl//absl/strings",
+    ],
+)
+
 # keep-sorted end
diff --git a/iamf/api/conversion/channel_reorderer.cc b/iamf/api/conversion/channel_reorderer.cc
new file mode 100644
index 0000000..f02cb2a
--- /dev/null
+++ b/iamf/api/conversion/channel_reorderer.cc
@@ -0,0 +1,178 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#include "iamf/api/conversion/channel_reorderer.h"
+
+#include <algorithm>
+#include <cstdint>
+#include <functional>
+#include <utility>
+#include <vector>
+
+#include "absl/types/span.h"
+#include "iamf/obu/mix_presentation.h"
+
+namespace iamf_tools {
+namespace {
+
+// No transformation.
+void NoOp(std::vector<absl::Span<const int32_t>>& samples) {}
+
+void SwapBackAndSides(std::vector<absl::Span<const int32_t>>& samples) {
+  // 7-something layout are ordered as [L, R, C, LFE, Lss, Rss, Lrs, Rrs].
+  // Android needs rear before side surrounds.
+  std::swap(samples[4], samples[6]);
+  std::swap(samples[5], samples[7]);
+}
+
+void ReorderSoundSystemFForAndroid(
+    std::vector<absl::Span<const int32_t>>& samples) {
+  if (samples.empty()) {
+    return;
+  }
+  //             0  1  2   3   4   5   6   7   8   9    10    11
+  // Ordered as [C, L, R, LH, RH, LS, RS, LB, RB, CH, LFE1, LFE2].
+  // Android needs [L, R, C, LFE, BACK_LEFT, BACK_RIGHT, SIDE_LEFT, SIDE_RIGHT,
+  // TOP_CENTER, TOP_FRONT_LEFT, TOP_FRONT_RIGHT, LOW_FREQUENCY_2]
+
+  auto originals = samples;
+  samples[0] = originals[1];
+  samples[1] = originals[2];
+  samples[2] = originals[0];
+  samples[3] = originals[10];
+  samples[4] = originals[7];
+  samples[5] = originals[8];
+  samples[6] = originals[5];
+  samples[7] = originals[6];
+  samples[8] = originals[9];
+  samples[9] = originals[3];
+  samples[10] = originals[4];
+  // Channel 11 is the same.
+}
+
+void ReorderSoundSystemGForAndroid(
+    std::vector<absl::Span<const int32_t>>& samples) {
+  // Ordered as
+  //  0  1  2    3    4    5    6    7    8    9   10   11   12   13
+  // [L, R, C, LFE, Lss, Rss, Lrs, Rrs, Ltf, Rtf, Ltb, Rtb, Lsc, Rsc]
+  // Android needs
+  //  0  1  2    3          4           5                     6
+  // [L, R, C, LFE, BACK_LEFT, BACK_RIGHT, FRONT_LEFT_OF_CENTER (for Lsc),
+  //                     7                    8          9    10   11   12   13
+  // FRONT_RIGHT_OF_CENTER (for Rsc), SIDE_LEFT, SIDE_RIGHT, Ltf, Rtf, Ltb, Rtb]
+
+  auto originals = samples;
+  // 0-3 are the same.
+  samples[4] = originals[6];
+  samples[5] = originals[7];
+  samples[6] = originals[12];
+  samples[7] = originals[13];
+  samples[8] = originals[4];
+  samples[9] = originals[5];
+  samples[10] = originals[8];
+  samples[11] = originals[9];
+  samples[12] = originals[10];
+  samples[13] = originals[11];
+}
+
+void ReorderSoundSystemHForAndroid(
+    std::vector<absl::Span<const int32_t>>& samples) {
+  // Ordered as
+  //   0   1   2     3  4    5    6    7   8     9  10    11   12     13    14
+  // [FL, FR, FC, LFE1, BL, BR, FLc, FRc, BC, LFE2, SiL, SiR, TpFL, TpFR, TpFC,
+  //  15    16    17     18     19    20    21    22    23
+  // TpC, TpBL, TpBR, TpSiL, TpSiR, TpBC, BtFC, BtFL, BtFR].
+
+  // ANDROID needs
+  //   0   1   2     3   4   5    6    7   8     9               10          11
+  // [FL, FR, FC, LFE1, BL, BR, FLc, FRc, BC, SIDE_LEFT, SIDE_RIGHT, TOP_CENTER,
+  //             12                13               14             15
+  // TOP_FRONT_LEFT, TOP_FRONT_CENTER, TOP_FRONT_RIGHT, TOP_BACK_LEFT,
+  //              16              17             18              19
+  // TOP_BACK_CENTER, TOP_BACK_RIGHT, TOP_SIDE_LEFT, TOP_SIDE_RIGHT,
+  //                 20                   21                  22    23
+  //  BOTTOM_FRONT_LEFT, BOTTOM_FRONT_CENTER, BOTTOM_FRONT_RIGHT, LFE2]
+
+  auto originals = samples;
+  // 0-8 are the same.
+  samples[9] = originals[10];
+  samples[10] = originals[11];
+  samples[11] = originals[15];
+  // 12 is the same
+  samples[13] = originals[14];
+  samples[14] = originals[13];
+  samples[15] = originals[16];
+  samples[16] = originals[20];
+  // 17-19 are the same.
+  samples[20] = originals[22];
+  // 21 is the same.
+  samples[22] = originals[23];
+  samples[23] = originals[9];
+}
+
+std::function<void(std::vector<absl::Span<const int32_t>>&)> MakeFunction(
+    LoudspeakersSsConventionLayout::SoundSystem original_layout,
+    ChannelReorderer::RearrangementScheme scheme) {
+  switch (scheme) {
+    case ChannelReorderer::RearrangementScheme::kDefaultNoOp:
+      return NoOp;
+    case ChannelReorderer::RearrangementScheme::kReorderForAndroid: {
+      switch (original_layout) {
+        // For these, Android matches
+        case LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemA_0_2_0:
+        case LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemB_0_5_0:
+        case LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemC_2_5_0:
+        case LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemD_4_5_0:
+        case LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemE_4_5_1:
+        case LoudspeakersSsConventionLayout::SoundSystem::kSoundSystem11_2_3_0:
+        case LoudspeakersSsConventionLayout::SoundSystem::kSoundSystem12_0_1_0:
+        case LoudspeakersSsConventionLayout::SoundSystem::kSoundSystem13_6_9_0:
+        default:
+          return NoOp;
+        // These just need to have back L/R before side L/R.
+        case LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemI_0_7_0:
+        case LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemJ_4_7_0:
+        case LoudspeakersSsConventionLayout::SoundSystem::kSoundSystem10_2_7_0:
+          return SwapBackAndSides;
+        case LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemF_3_7_0:
+          return ReorderSoundSystemFForAndroid;
+        case LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemG_4_9_0:
+          return ReorderSoundSystemGForAndroid;
+        case LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemH_9_10_3:
+          return ReorderSoundSystemHForAndroid;
+      }
+    }
+  }
+}
+
+}  // namespace
+
+ChannelReorderer::ChannelReorderer(
+    std::function<void(std::vector<absl::Span<const int32_t>>&)>
+        reorder_function)
+    : reorder_function_(reorder_function) {}
+
+ChannelReorderer ChannelReorderer::Create(
+    LoudspeakersSsConventionLayout::SoundSystem original_layout,
+    RearrangementScheme scheme) {
+  if (scheme == RearrangementScheme::kDefaultNoOp) {
+    return ChannelReorderer(NoOp);
+  }
+  return ChannelReorderer(MakeFunction(original_layout, scheme));
+}
+
+void ChannelReorderer::Reorder(
+    std::vector<absl::Span<const int32_t>>& audio_frame) {
+  reorder_function_(audio_frame);
+}
+
+}  // namespace iamf_tools
diff --git a/iamf/api/conversion/channel_reorderer.h b/iamf/api/conversion/channel_reorderer.h
new file mode 100644
index 0000000..588a581
--- /dev/null
+++ b/iamf/api/conversion/channel_reorderer.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#ifndef API_CONVERSION_CHANNEL_REORDERER_H_
+#define API_CONVERSION_CHANNEL_REORDERER_H_
+
+#include <cstdint>
+#include <functional>
+#include <vector>
+
+#include "absl/types/span.h"
+#include "iamf/obu/mix_presentation.h"
+
+namespace iamf_tools {
+
+/*!\brief Reorders output audio samples for a given configuration. */
+class ChannelReorderer {
+ public:
+  enum class RearrangementScheme {
+    kDefaultNoOp = 0,
+    kReorderForAndroid = 1,
+  };
+
+  /*!\brief Factory function.
+   *
+   * \param original_layout The Layout of the audio samples before
+   *        rearrangement.
+   * \param scheme The rearrangement scheme to apply to all calls of Reorder.
+   * \return `ChannelRenderer` with the requested configuration.
+   */
+  static ChannelReorderer Create(
+      LoudspeakersSsConventionLayout::SoundSystem original_layout,
+      RearrangementScheme scheme);
+
+  /*!\brief Re-orders the audio in-place.
+   *
+   * \param audio_frame Samples arranged in (channel, time) axes to reorder in
+   *        place.
+   */
+  void Reorder(std::vector<absl::Span<const int32_t>>& audio_frame);
+
+ private:
+  explicit ChannelReorderer(
+      std::function<void(std::vector<absl::Span<const int32_t>>&)>
+          reorder_function);
+
+  std::function<void(std::vector<absl::Span<const int32_t>>&)>
+      reorder_function_;
+};
+
+}  // namespace iamf_tools
+
+#endif  // API_CONVERSION_CHANNEL_REORDERER_H_
diff --git a/iamf/api/conversion/mix_presentation_conversion.cc b/iamf/api/conversion/mix_presentation_conversion.cc
index cbf5c89..65ee5a1 100644
--- a/iamf/api/conversion/mix_presentation_conversion.cc
+++ b/iamf/api/conversion/mix_presentation_conversion.cc
@@ -17,7 +17,7 @@
 #include "absl/log/log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
-#include "iamf/api/types.h"
+#include "iamf/include/iamf_tools/iamf_tools_api_types.h"
 #include "iamf/obu/mix_presentation.h"
 
 namespace iamf_tools {
diff --git a/iamf/api/conversion/mix_presentation_conversion.h b/iamf/api/conversion/mix_presentation_conversion.h
index 78d0cf1..1b2ee52 100644
--- a/iamf/api/conversion/mix_presentation_conversion.h
+++ b/iamf/api/conversion/mix_presentation_conversion.h
@@ -14,7 +14,7 @@
 #define API_CONVERSION_MIX_PRESENTATION_METADATA_H_
 
 #include "absl/status/statusor.h"
-#include "iamf/api/types.h"
+#include "iamf/include/iamf_tools/iamf_tools_api_types.h"
 #include "iamf/obu/mix_presentation.h"
 
 namespace iamf_tools {
diff --git a/iamf/api/conversion/profile_conversion.cc b/iamf/api/conversion/profile_conversion.cc
new file mode 100644
index 0000000..d36312a
--- /dev/null
+++ b/iamf/api/conversion/profile_conversion.cc
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#include "iamf/api/conversion/profile_conversion.h"
+
+#include "absl/log/log.h"
+#include "absl/status/status.h"
+#include "absl/status/statusor.h"
+#include "absl/strings/str_cat.h"
+#include "iamf/include/iamf_tools/iamf_tools_api_types.h"
+#include "iamf/obu/ia_sequence_header.h"
+
+namespace iamf_tools {
+
+typedef ::iamf_tools::ProfileVersion InternalProfileVersion;
+
+InternalProfileVersion ApiToInternalType(
+    api::ProfileVersion api_profile_version) {
+  switch (api_profile_version) {
+    case api::ProfileVersion::kIamfSimpleProfile:
+      return InternalProfileVersion::kIamfSimpleProfile;
+    case api::ProfileVersion::kIamfBaseProfile:
+      return InternalProfileVersion::kIamfBaseProfile;
+    case api::ProfileVersion::kIamfBaseEnhancedProfile:
+      return InternalProfileVersion::kIamfBaseEnhancedProfile;
+  }
+  // Switch above is exhaustive.
+  LOG(FATAL) << "Invalid profile version= "
+             << static_cast<int>(api_profile_version);
+}
+
+absl::StatusOr<api::ProfileVersion> InternalToApiType(
+    InternalProfileVersion profile_version) {
+  switch (profile_version) {
+    case InternalProfileVersion::kIamfSimpleProfile:
+      return api::ProfileVersion::kIamfSimpleProfile;
+    case InternalProfileVersion::kIamfBaseProfile:
+      return api::ProfileVersion::kIamfBaseProfile;
+    case InternalProfileVersion::kIamfBaseEnhancedProfile:
+      return api::ProfileVersion::kIamfBaseEnhancedProfile;
+    default:
+      // Some internal profiles are not intended for use in the API.
+      return absl::InvalidArgumentError(
+          absl::StrCat("Invalid profile version= ", profile_version));
+  }
+}
+
+}  // namespace iamf_tools
diff --git a/iamf/api/conversion/profile_conversion.h b/iamf/api/conversion/profile_conversion.h
new file mode 100644
index 0000000..28a4846
--- /dev/null
+++ b/iamf/api/conversion/profile_conversion.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#ifndef API_CONVERSION_PROFILE_CONVERSION_H_
+#define API_CONVERSION_PROFILE_CONVERSION_H_
+
+#include "absl/status/statusor.h"
+#include "iamf/include/iamf_tools/iamf_tools_api_types.h"
+#include "iamf/obu/ia_sequence_header.h"
+
+namespace iamf_tools {
+
+/*!\brief Converts the API ProfileVersion to an internal ProfileVersion.
+ *
+ * \param api_profile_version API-requested profile version.
+ * \return Internal profile version.
+ */
+iamf_tools::ProfileVersion ApiToInternalType(
+    api::ProfileVersion api_profile_version);
+
+/*!\brief Converts the internal IAMF ProfileVersion to the API ProfileVersion.
+ *
+ * \param profile_version Internal profile version.
+ * \return API profile version, or an error if the internal profile version is
+ *         not intended for use in the API.
+ */
+absl::StatusOr<iamf_tools::api::ProfileVersion> InternalToApiType(
+    iamf_tools::ProfileVersion profile_version);
+
+}  // namespace iamf_tools
+
+#endif  // API_CONVERSION_PROFILE_CONVERSION_H_
diff --git a/iamf/api/conversion/tests/BUILD b/iamf/api/conversion/tests/BUILD
index e029d85..40a9811 100644
--- a/iamf/api/conversion/tests/BUILD
+++ b/iamf/api/conversion/tests/BUILD
@@ -1,13 +1,53 @@
+load("@rules_cc//cc:cc_test.bzl", "cc_test")
+
 # keep-sorted start block=yes prefix_order=cc_test newline_separated=yes
+cc_test(
+    name = "channel_reorderer_benchmark",
+    srcs = ["channel_reorderer_benchmark.cc"],
+    deps = [
+        "//iamf/api/conversion:channel_reorderer",
+        "//iamf/obu:mix_presentation",
+        "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/types:span",
+        "@com_google_benchmark//:benchmark_main",
+    ],
+)
+
+cc_test(
+    name = "channel_reorderer_test",
+    srcs = ["channel_reorderer_test.cc"],
+    deps = [
+        "//iamf/api/conversion:channel_reorderer",
+        "//iamf/obu:mix_presentation",
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/types:span",
+        "@com_google_googletest//:gtest_main",
+    ],
+)
+
 cc_test(
     name = "mix_presentation_conversion_test",
     srcs = ["mix_presentation_conversion_test.cc"],
     deps = [
-        "//iamf/api:types",
+        "//iamf/api:iamf_tools_api_types",
         "//iamf/api/conversion:mix_presentation_conversion",
         "//iamf/obu:mix_presentation",
         "@com_google_absl//absl/status:status_matchers",
         "@com_google_googletest//:gtest_main",
     ],
 )
+
+cc_test(
+    name = "profile_conversion_test",
+    srcs = ["profile_conversion_test.cc"],
+    deps = [
+        "//iamf/api:iamf_tools_api_types",
+        "//iamf/api/conversion:profile_conversion",
+        "//iamf/obu:ia_sequence_header",
+        "@com_google_absl//absl/status:status_matchers",
+        "@com_google_googletest//:gtest_main",
+    ],
+)
+
 # keep-sorted end
diff --git a/iamf/api/conversion/tests/channel_reorderer_benchmark.cc b/iamf/api/conversion/tests/channel_reorderer_benchmark.cc
new file mode 100644
index 0000000..9d2efa1
--- /dev/null
+++ b/iamf/api/conversion/tests/channel_reorderer_benchmark.cc
@@ -0,0 +1,133 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#include <cstdint>
+#include <vector>
+
+#include "absl/log/check.h"
+#include "absl/status/status.h"
+#include "absl/types/span.h"
+#include "benchmark/benchmark.h"
+#include "iamf/api/conversion/channel_reorderer.h"
+#include "iamf/obu/mix_presentation.h"
+
+namespace iamf_tools {
+namespace {
+
+using enum LoudspeakersSsConventionLayout::SoundSystem;
+
+static int32_t GetNumberOfChannels(
+    LoudspeakersSsConventionLayout::SoundSystem sound_system) {
+  int32_t num_channels = 0;
+  absl::Status status = MixPresentationObu::GetNumChannelsFromLayout(
+      {.layout_type = Layout::kLayoutTypeLoudspeakersSsConvention,
+       .specific_layout =
+           LoudspeakersSsConventionLayout{.sound_system = sound_system}},
+      num_channels);
+  CHECK_OK(status);
+  return num_channels;
+}
+
+static std::vector<std::vector<int32_t>> CreateAudioSamples(
+    LoudspeakersSsConventionLayout::SoundSystem sound_system, int num_ticks) {
+  std::vector<std::vector<int32_t>> samples(GetNumberOfChannels(sound_system),
+                                            std::vector<int32_t>(num_ticks));
+  int32_t i = 0;
+  for (auto& channel : samples) {
+    for (auto& sample : channel) {
+      sample = i++;
+    }
+  }
+  return samples;
+}
+
+static void BM_ReorderForAndroid(
+    LoudspeakersSsConventionLayout::SoundSystem sound_system,
+    benchmark::State& state) {
+  // Create a channel reorderer.
+  // We do not benchmark the NoOp scheme, since it should be trivial.
+  const auto scheme = ChannelReorderer::RearrangementScheme::kReorderForAndroid;
+  auto reorderer = ChannelReorderer::Create(sound_system, scheme);
+
+  // Create input samples and a vector of spans pointing to the channels.
+  const int num_ticks = state.range(0);
+  auto samples = CreateAudioSamples(sound_system, num_ticks);
+  std::vector<absl::Span<const int32_t>> sample_spans(samples.size());
+  for (int c = 0; c < samples.size(); c++) {
+    sample_spans[c] = absl::MakeConstSpan(samples[c]);
+  }
+
+  // Measure the calls to `ChannelReorderer::Reorder()`.
+  for (auto _ : state) {
+    reorderer.Reorder(sample_spans);
+    ;
+  }
+}
+
+static void BM_ReorderForAndroid_SoundSystemF(benchmark::State& state) {
+  BM_ReorderForAndroid(kSoundSystemF_3_7_0, state);
+}
+
+static void BM_ReorderForAndroid_SoundSystemG(benchmark::State& state) {
+  BM_ReorderForAndroid(kSoundSystemG_4_9_0, state);
+}
+
+static void BM_ReorderForAndroid_SoundSystemH(benchmark::State& state) {
+  BM_ReorderForAndroid(kSoundSystemH_9_10_3, state);
+}
+
+static void BM_ReorderForAndroid_SoundSystemI(benchmark::State& state) {
+  BM_ReorderForAndroid(kSoundSystemI_0_7_0, state);
+}
+
+static void BM_ReorderForAndroid_SoundSystemJ(benchmark::State& state) {
+  BM_ReorderForAndroid(kSoundSystemJ_4_7_0, state);
+}
+
+static void BM_ReorderForAndroid_SoundSystem10(benchmark::State& state) {
+  BM_ReorderForAndroid(kSoundSystem10_2_7_0, state);
+}
+
+// Benchmark for sound systems that require reordering for Android, which means
+// to exclude Sound system A, B, C, D, E, 11, 12, and 13.
+BENCHMARK(BM_ReorderForAndroid_SoundSystemF)
+    ->Args({1 << 4})
+    ->Args({1 << 8})
+    ->Args({1 << 12});
+
+BENCHMARK(BM_ReorderForAndroid_SoundSystemG)
+    ->Args({1 << 4})
+    ->Args({1 << 8})
+    ->Args({1 << 12});
+
+BENCHMARK(BM_ReorderForAndroid_SoundSystemH)
+    ->Args({1 << 4})
+    ->Args({1 << 8})
+    ->Args({1 << 12});
+
+BENCHMARK(BM_ReorderForAndroid_SoundSystemI)
+    ->Args({1 << 4})
+    ->Args({1 << 8})
+    ->Args({1 << 12});
+
+BENCHMARK(BM_ReorderForAndroid_SoundSystemJ)
+    ->Args({1 << 4})
+    ->Args({1 << 8})
+    ->Args({1 << 12});
+
+BENCHMARK(BM_ReorderForAndroid_SoundSystem10)
+    ->Args({1 << 4})
+    ->Args({1 << 8})
+    ->Args({1 << 12});
+
+}  // namespace
+}  // namespace iamf_tools
diff --git a/iamf/api/conversion/tests/channel_reorderer_test.cc b/iamf/api/conversion/tests/channel_reorderer_test.cc
new file mode 100644
index 0000000..4dae356
--- /dev/null
+++ b/iamf/api/conversion/tests/channel_reorderer_test.cc
@@ -0,0 +1,302 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#include "iamf/api/conversion/channel_reorderer.h"
+
+#include <cstddef>
+#include <cstdint>
+#include <string>
+#include <vector>
+
+#include "absl/status/status.h"
+#include "absl/types/span.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+#include "iamf/obu/mix_presentation.h"
+
+namespace iamf_tools {
+
+using ::absl::MakeSpan;
+using ::testing::ContainerEq;
+using ::testing::TestWithParam;
+using ::testing::UnorderedElementsAreArray;
+
+namespace {
+// Helper to get an appropriate number of samples for tests.
+int32_t GetNumberOfChannels(
+    LoudspeakersSsConventionLayout::SoundSystem sound_system) {
+  int32_t num_channels = 0;
+  absl::Status status = MixPresentationObu::GetNumChannelsFromLayout(
+      {.layout_type = Layout::kLayoutTypeLoudspeakersSsConvention,
+       .specific_layout =
+           LoudspeakersSsConventionLayout{.sound_system = sound_system}},
+      num_channels);
+  return num_channels;
+}
+
+// Helper to make some random samples of the appropriate size.
+std::vector<absl::Span<const int32_t>> CreateAudioSamples(
+    LoudspeakersSsConventionLayout::SoundSystem sound_system,
+    size_t num_ticks = 5) {
+  static std::vector<std::vector<int32_t>> samples;
+
+  samples.resize(GetNumberOfChannels(sound_system),
+                 std::vector<int32_t>(num_ticks));
+  std::vector<absl::Span<const int32_t>> sample_spans(samples.size());
+  int32_t i = 0;
+  for (int c = 0; c < samples.size(); c++) {
+    for (auto& sample : samples[c]) {
+      sample = i++;
+    }
+    sample_spans[c] = absl::MakeConstSpan(samples[c]);
+  }
+  return sample_spans;
+}
+
+struct ReordererTestCase {
+  std::string test_name;
+  LoudspeakersSsConventionLayout::SoundSystem sound_system;
+  ChannelReorderer::RearrangementScheme scheme;
+};
+
+// Parameterized test for when the samples should be unaltered.
+using ChannelReordererTest_NoChange = TestWithParam<ReordererTestCase>;
+TEST_P(ChannelReordererTest_NoChange, SamplesAreUnaltered) {
+  const auto& sound_system = GetParam().sound_system;
+  const auto scheme = GetParam().scheme;
+  auto reorderer = ChannelReorderer::Create(sound_system, scheme);
+  auto samples = CreateAudioSamples(sound_system);
+  auto expected = samples;  // Save a copy for comparison.
+
+  reorderer.Reorder(samples);
+
+  EXPECT_THAT(samples, ContainerEq(expected));
+}
+
+// When using kDefaultNoOp, no layout should be altered.
+INSTANTIATE_TEST_SUITE_P(
+    ChannelReordererTest_NoOpInstantiation, ChannelReordererTest_NoChange,
+    testing::ValuesIn<ReordererTestCase>({
+        {"NoOp_kSoundSystemA_0_2_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemA_0_2_0,
+         ChannelReorderer::RearrangementScheme::kDefaultNoOp},
+        {"NoOp_kSoundSystemB_0_5_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemB_0_5_0,
+         ChannelReorderer::RearrangementScheme::kDefaultNoOp},
+        {"NoOp_kSoundSystemC_2_5_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemC_2_5_0,
+         ChannelReorderer::RearrangementScheme::kDefaultNoOp},
+        {"NoOp_kSoundSystemD_4_5_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemD_4_5_0,
+         ChannelReorderer::RearrangementScheme::kDefaultNoOp},
+        {"NoOp_kSoundSystemE_4_5_1",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemE_4_5_1,
+         ChannelReorderer::RearrangementScheme::kDefaultNoOp},
+        {"NoOp_kSoundSystemF_3_7_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemF_3_7_0,
+         ChannelReorderer::RearrangementScheme::kDefaultNoOp},
+        {"NoOp_kSoundSystemG_4_9_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemG_4_9_0,
+         ChannelReorderer::RearrangementScheme::kDefaultNoOp},
+        {"NoOp_kSoundSystemH_9_10_3",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemH_9_10_3,
+         ChannelReorderer::RearrangementScheme::kDefaultNoOp},
+        {"NoOp_kSoundSystemI_0_7_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemI_0_7_0,
+         ChannelReorderer::RearrangementScheme::kDefaultNoOp},
+        {"NoOp_kSoundSystemJ_4_7_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemJ_4_7_0,
+         ChannelReorderer::RearrangementScheme::kDefaultNoOp},
+        {"NoOp_kSoundSystem10_2_7_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystem10_2_7_0,
+         ChannelReorderer::RearrangementScheme::kDefaultNoOp},
+        {"NoOp_kSoundSystem11_2_3_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystem11_2_3_0,
+         ChannelReorderer::RearrangementScheme::kDefaultNoOp},
+        {"NoOp_kSoundSystem12_0_1_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystem12_0_1_0,
+         ChannelReorderer::RearrangementScheme::kDefaultNoOp},
+        {"NoOp_kSoundSystem13_6_9_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystem13_6_9_0,
+         ChannelReorderer::RearrangementScheme::kDefaultNoOp},
+    }),
+    [](const testing::TestParamInfo<ChannelReordererTest_NoChange::ParamType>&
+           info) { return info.param.test_name; });
+
+// These layouts should be unaltered for Android.
+INSTANTIATE_TEST_SUITE_P(
+    ChannelReordererTest_Android_UnchangedLayouts_Instantiation,
+    ChannelReordererTest_NoChange,
+    testing::ValuesIn<ReordererTestCase>({
+        {"Android_kSoundSystemA_0_2_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemA_0_2_0,
+         ChannelReorderer::RearrangementScheme::kReorderForAndroid},
+        {"Android_kSoundSystemB_0_5_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemB_0_5_0,
+         ChannelReorderer::RearrangementScheme::kReorderForAndroid},
+        {"Android_kSoundSystemC_2_5_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemC_2_5_0,
+         ChannelReorderer::RearrangementScheme::kReorderForAndroid},
+        {"Android_kSoundSystemD_4_5_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemD_4_5_0,
+         ChannelReorderer::RearrangementScheme::kReorderForAndroid},
+        {"Android_kSoundSystemE_4_5_1",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemE_4_5_1,
+         ChannelReorderer::RearrangementScheme::kReorderForAndroid},
+        {"Android_kSoundSystem11_2_3_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystem11_2_3_0,
+         ChannelReorderer::RearrangementScheme::kReorderForAndroid},
+        {"Android_kSoundSystem12_0_1_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystem12_0_1_0,
+         ChannelReorderer::RearrangementScheme::kReorderForAndroid},
+        {"Android_kSoundSystem13_6_9_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystem13_6_9_0,
+         ChannelReorderer::RearrangementScheme::kReorderForAndroid},
+    }),
+    [](const testing::TestParamInfo<ChannelReordererTest_NoChange::ParamType>&
+           info) { return info.param.test_name; });
+
+using ChannelReordererTest_SwapBackAndSides = TestWithParam<ReordererTestCase>;
+
+TEST_P(ChannelReordererTest_SwapBackAndSides, SamplesAreUnaltered) {
+  const auto& sound_system = GetParam().sound_system;
+  const auto scheme = GetParam().scheme;
+  auto reorderer = ChannelReorderer::Create(sound_system, scheme);
+  auto samples = CreateAudioSamples(sound_system, /*num_ticks=*/1);
+  const auto original = samples;  // Save a copy for comparison.
+
+  reorderer.Reorder(samples);
+
+  EXPECT_EQ(samples[4], original[6]);
+  EXPECT_EQ(samples[5], original[7]);
+  EXPECT_EQ(samples[6], original[4]);
+  EXPECT_EQ(samples[7], original[5]);
+  EXPECT_EQ(MakeSpan(samples).first(4), MakeSpan(original).first(4));
+  if (original[0].size() > 7) {
+    EXPECT_EQ(MakeSpan(samples).subspan(8), MakeSpan(original).subspan(8));
+  }
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    ChannelReordererTest_AndroidSwapBackAndSides_Instantiation,
+    ChannelReordererTest_SwapBackAndSides,
+    testing::ValuesIn<ReordererTestCase>({
+        {"Android_kSoundSystemI_0_7_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemI_0_7_0,
+         ChannelReorderer::RearrangementScheme::kReorderForAndroid},
+        {"Android_kSoundSystemJ_4_7_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemJ_4_7_0,
+         ChannelReorderer::RearrangementScheme::kReorderForAndroid},
+        {"Android_kSoundSystem10_2_7_0",
+         LoudspeakersSsConventionLayout::SoundSystem::kSoundSystem10_2_7_0,
+         ChannelReorderer::RearrangementScheme::kReorderForAndroid},
+    }),
+    [](const testing::TestParamInfo<
+        ChannelReordererTest_SwapBackAndSides::ParamType>& info) {
+      return info.param.test_name;
+    });
+
+TEST(ChannelReordererTest, TestLayoutFForAndroid) {
+  auto reorderer = ChannelReorderer::Create(
+      LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemF_3_7_0,
+      ChannelReorderer::RearrangementScheme::kReorderForAndroid);
+  auto samples = CreateAudioSamples(
+      LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemF_3_7_0,
+      /*num_ticks=*/1);
+  const auto original = samples;  // Save a copy for comparison.
+
+  reorderer.Reorder(samples);
+
+  // Check we have all the same samples.
+  EXPECT_THAT(samples, UnorderedElementsAreArray(original));
+  // Check the reordering.
+  EXPECT_EQ(samples[0], original[1]);
+  EXPECT_EQ(samples[1], original[2]);
+  EXPECT_EQ(samples[2], original[0]);
+  EXPECT_EQ(samples[3], original[10]);
+  EXPECT_EQ(samples[4], original[7]);
+  EXPECT_EQ(samples[5], original[8]);
+  EXPECT_EQ(samples[6], original[5]);
+  EXPECT_EQ(samples[7], original[6]);
+  EXPECT_EQ(samples[8], original[9]);
+  EXPECT_EQ(samples[9], original[3]);
+  EXPECT_EQ(samples[10], original[4]);
+}
+
+TEST(ChannelReordererTest, TestLayoutGForAndroid) {
+  auto reorderer = ChannelReorderer::Create(
+      LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemG_4_9_0,
+      ChannelReorderer::RearrangementScheme::kReorderForAndroid);
+  auto samples = CreateAudioSamples(
+      LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemG_4_9_0,
+      /*num_ticks=*/1);
+  auto original = samples;  // Save a copy for comparison.
+
+  reorderer.Reorder(samples);
+
+  // Check we have all the same samples.
+  EXPECT_THAT(samples, UnorderedElementsAreArray(original));
+  // Check the reordering.
+  for (int c = 0; c < 4; c++) {
+    EXPECT_EQ(samples[c], original[c]);
+  }
+  EXPECT_EQ(samples[4], original[6]);
+  EXPECT_EQ(samples[5], original[7]);
+  EXPECT_EQ(samples[6], original[12]);
+  EXPECT_EQ(samples[7], original[13]);
+  EXPECT_EQ(samples[8], original[4]);
+  EXPECT_EQ(samples[9], original[5]);
+  EXPECT_EQ(samples[10], original[8]);
+  EXPECT_EQ(samples[11], original[9]);
+  EXPECT_EQ(samples[12], original[10]);
+  EXPECT_EQ(samples[13], original[11]);
+}
+
+TEST(ChannelReordererTest, TestLayoutHForAndroid) {
+  auto reorderer = ChannelReorderer::Create(
+      LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemH_9_10_3,
+      ChannelReorderer::RearrangementScheme::kReorderForAndroid);
+  auto samples = CreateAudioSamples(
+      LoudspeakersSsConventionLayout::SoundSystem::kSoundSystemH_9_10_3,
+      /*num_ticks=*/1);
+  auto original = samples;  // Save a copy for comparison.
+
+  reorderer.Reorder(samples);
+
+  // Check we have all the same samples.
+  EXPECT_THAT(samples, UnorderedElementsAreArray(original));
+  // Check the reordering.
+  // 0-8 are the same.
+  for (int c = 0; c < 8; c++) {
+    EXPECT_EQ(samples[c], original[c]);
+  }
+  EXPECT_EQ(samples[9], original[10]);
+  EXPECT_EQ(samples[10], original[11]);
+  EXPECT_EQ(samples[11], original[15]);
+  // 12 is the same
+  EXPECT_EQ(samples[12], original[12]);
+  EXPECT_EQ(samples[13], original[14]);
+  EXPECT_EQ(samples[14], original[13]);
+  EXPECT_EQ(samples[15], original[16]);
+  EXPECT_EQ(samples[16], original[20]);
+  // 17-19 are the same.
+  EXPECT_EQ(samples[17], original[17]);
+  EXPECT_EQ(samples[18], original[18]);
+  EXPECT_EQ(samples[19], original[19]);
+  EXPECT_EQ(samples[20], original[22]);
+  EXPECT_EQ(samples[21], original[21]);
+  EXPECT_EQ(samples[22], original[23]);
+  EXPECT_EQ(samples[23], original[9]);
+}
+
+}  // namespace
+}  // namespace iamf_tools
diff --git a/iamf/api/conversion/tests/mix_presentation_conversion_test.cc b/iamf/api/conversion/tests/mix_presentation_conversion_test.cc
index f3604ff..772311d 100644
--- a/iamf/api/conversion/tests/mix_presentation_conversion_test.cc
+++ b/iamf/api/conversion/tests/mix_presentation_conversion_test.cc
@@ -18,7 +18,7 @@
 #include "absl/status/status_matchers.h"
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
-#include "iamf/api/types.h"
+#include "iamf/include/iamf_tools/iamf_tools_api_types.h"
 #include "iamf/obu/mix_presentation.h"
 
 namespace iamf_tools {
diff --git a/iamf/api/conversion/tests/profile_conversion_test.cc b/iamf/api/conversion/tests/profile_conversion_test.cc
new file mode 100644
index 0000000..4585b98
--- /dev/null
+++ b/iamf/api/conversion/tests/profile_conversion_test.cc
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#include "iamf/api/conversion/profile_conversion.h"
+
+#include <utility>
+
+#include "absl/status/status_matchers.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+#include "iamf/include/iamf_tools/iamf_tools_api_types.h"
+#include "iamf/obu/ia_sequence_header.h"
+
+namespace iamf_tools {
+namespace {
+
+using ::absl_testing::IsOk;
+using ::absl_testing::IsOkAndHolds;
+using ::testing::Not;
+using ::testing::TestWithParam;
+
+using ProfileVersionPair =
+    std::pair<api::ProfileVersion, iamf_tools::ProfileVersion>;
+using ApiToInternalType_ProfileVersion = TestWithParam<ProfileVersionPair>;
+
+auto kApiOutputToInternalProfileVersionPairs = ::testing::Values(
+    ProfileVersionPair(api::ProfileVersion::kIamfSimpleProfile,
+                       ProfileVersion::kIamfSimpleProfile),
+    ProfileVersionPair(api::ProfileVersion::kIamfBaseProfile,
+                       ProfileVersion::kIamfBaseProfile),
+    ProfileVersionPair(api::ProfileVersion::kIamfBaseEnhancedProfile,
+                       ProfileVersion::kIamfBaseEnhancedProfile));
+
+TEST_P(ApiToInternalType_ProfileVersion,
+       ConvertsOutputProfileVersionToInternalProfileVersion) {
+  const auto& [api_profile_version, expected_profile_version] = GetParam();
+
+  const ProfileVersion resulting_profile_version =
+      ApiToInternalType(api_profile_version);
+
+  EXPECT_EQ(resulting_profile_version, expected_profile_version);
+}
+
+INSTANTIATE_TEST_SUITE_P(ApiToInternalType_ProfileVersion_Instantiation,
+                         ApiToInternalType_ProfileVersion,
+                         kApiOutputToInternalProfileVersionPairs);
+
+using InternalTypeToApi_ProfileVersion = TestWithParam<ProfileVersionPair>;
+
+TEST_P(InternalTypeToApi_ProfileVersion,
+       ConvertsInternalProfileVersionToOutputProfileVersion) {
+  const auto& [expected_api_output_layout, internal_profile_version] =
+      GetParam();
+
+  const auto api_output_layout = InternalToApiType(internal_profile_version);
+
+  EXPECT_THAT(api_output_layout, IsOkAndHolds(expected_api_output_layout));
+}
+
+INSTANTIATE_TEST_SUITE_P(InternalTypeToApi_ProfileVersion_Instantiation,
+                         InternalTypeToApi_ProfileVersion,
+                         kApiOutputToInternalProfileVersionPairs);
+
+TEST(InternalToApiType_InvalidProfileVersion, ReturnsError) {
+  // Some special reserved internal types have no corresponding API type.
+  EXPECT_THAT(InternalToApiType(ProfileVersion::kIamfReserved255Profile),
+              Not(IsOk()));
+}
+
+}  // namespace
+}  // namespace iamf_tools
diff --git a/iamf/api/decoder/BUILD b/iamf/api/decoder/BUILD
index dfe3aa8..995554d 100644
--- a/iamf/api/decoder/BUILD
+++ b/iamf/api/decoder/BUILD
@@ -1,24 +1,31 @@
 package(default_visibility = [
     "//iamf/api/decoder/tests:__pkg__",
+    "//iamf/api/internal_utils:__pkg__",
 ])
 
 # keep-sorted start block=yes prefix_order=cc_library newline_separated=yes
 cc_library(
     name = "iamf_decoder",
     srcs = ["iamf_decoder.cc"],
-    hdrs = ["iamf_decoder.h"],
+    hdrs = [
+        "//iamf/include/iamf_tools:iamf_decoder_header",
+    ],
     deps = [
-        "//iamf/api:types",
+        "//iamf/api:iamf_tools_api_types",
+        "//iamf/api/conversion:channel_reorderer",
         "//iamf/api/conversion:mix_presentation_conversion",
+        "//iamf/api/conversion:profile_conversion",
         "//iamf/cli:obu_processor",
         "//iamf/cli:rendering_mix_presentation_finalizer",
         "//iamf/common:read_bit_buffer",
         "//iamf/common/utils:macros",
         "//iamf/common/utils:sample_processing_utils",
+        "//iamf/obu:ia_sequence_header",
         "//iamf/obu:mix_presentation",
+        "@com_google_absl//absl/container:flat_hash_set",
         "@com_google_absl//absl/log",
+        "@com_google_absl//absl/memory",
         "@com_google_absl//absl/status",
-        "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/types:span",
     ],
 )
diff --git a/iamf/api/decoder/iamf_decoder.cc b/iamf/api/decoder/iamf_decoder.cc
index b844eed..103e0e7 100644
--- a/iamf/api/decoder/iamf_decoder.cc
+++ b/iamf/api/decoder/iamf_decoder.cc
@@ -10,43 +10,65 @@
  * www.aomedia.org/license/patent.
  */
 
-#include "iamf/api/decoder/iamf_decoder.h"
+#include "iamf/include/iamf_tools/iamf_decoder.h"
 
 #include <cstddef>
 #include <cstdint>
 #include <memory>
 #include <optional>
 #include <queue>
+#include <string>
 #include <utility>
+#include <variant>
 #include <vector>
 
+#include "absl/container/flat_hash_set.h"
 #include "absl/log/log.h"
+#include "absl/memory/memory.h"
 #include "absl/status/status.h"
 #include "absl/types/span.h"
+#include "iamf/api/conversion/channel_reorderer.h"
 #include "iamf/api/conversion/mix_presentation_conversion.h"
-#include "iamf/api/types.h"
+#include "iamf/api/conversion/profile_conversion.h"
 #include "iamf/cli/obu_processor.h"
 #include "iamf/cli/rendering_mix_presentation_finalizer.h"
 #include "iamf/common/read_bit_buffer.h"
 #include "iamf/common/utils/macros.h"
 #include "iamf/common/utils/sample_processing_utils.h"
+#include "iamf/include/iamf_tools/iamf_tools_api_types.h"
+#include "iamf/obu/ia_sequence_header.h"
 #include "iamf/obu/mix_presentation.h"
 
 namespace iamf_tools {
 namespace api {
 
-enum class Status { kAcceptingData, kFlushCalled };
+enum class DecoderStatus { kAcceptingData, kEndOfStream };
 
 // Holds the internal state of the decoder to hide it and necessary includes
 // from API users.
 struct IamfDecoder::DecoderState {
+  /*!\brief Constructor.
+   *
+   * \param read_bit_buffer Buffer to decode from.
+   * \param requested_layout User-requested layout, the actual layout may be
+   *        different depending on the mix presentations.
+   * \param requested_profile_versions User-requested profile versions, the
+   *        actual profile version may be different depending on the mix
+   *        presentations.
+   */
   DecoderState(std::unique_ptr<StreamBasedReadBitBuffer> read_bit_buffer,
-               const Layout& initial_requested_layout)
+               const Layout& requested_layout,
+               const absl::flat_hash_set<::iamf_tools::ProfileVersion>&
+                   requested_profile_versions)
       : read_bit_buffer(std::move(read_bit_buffer)),
-        layout(initial_requested_layout) {}
+        layout(requested_layout),
+        desired_profile_versions(requested_profile_versions) {}
+
+  /*!\brief Creates an ObuProcessor and maintains related bookeeping. */
+  absl::Status CreateObuProcessor();
 
   // Current status of the decoder.
-  Status status = Status::kAcceptingData;
+  DecoderStatus status = DecoderStatus::kAcceptingData;
 
   // Used to process descriptor OBUs and temporal units. Is only created after
   // the descriptor OBUs have been parsed.
@@ -59,7 +81,7 @@ struct IamfDecoder::DecoderState {
   // temporal unit. A temporal unit will never be partially filled, so the
   // number of elements in the outer vector is equal to the number of decoded
   // temporal units currently available.
-  std::queue<std::vector<std::vector<int32_t>>> rendered_pcm_samples;
+  std::queue<std::vector<absl::Span<const int32_t>>> rendered_pcm_samples;
 
   // The layout used for the rendered output audio.
   // Initially set to the requested Layout but updated by ObuProcessor.
@@ -68,80 +90,138 @@ struct IamfDecoder::DecoderState {
   // TODO(b/379122580):  Use the bit depth of the underlying content.
   // Defaulting to int32 for now.
   OutputSampleType output_sample_type = OutputSampleType::kInt32LittleEndian;
-};
 
-namespace {
-constexpr int kInitialBufferSize = 1024;
+  // True iff the decoder was created via CreateFromDescriptors().
+  bool created_from_descriptors = false;
+
+  // Cache the profile versions that the user is interested in, we use them to
+  // select an appropriate mix presentation.
+  const absl::flat_hash_set<::iamf_tools::ProfileVersion>
+      desired_profile_versions;
+
+  // Once descriptors have been processed, they are stored here. This is useful
+  // for Reset() purposes, in which we can recreate the ObuProcessor with the
+  // original descriptors in order to ensure that the state of the processor is
+  // clean.
+  std::vector<uint8_t> descriptor_obus;
+
+  ChannelReorderer::RearrangementScheme channel_rearrangement_scheme =
+      ChannelReorderer::RearrangementScheme::kDefaultNoOp;
+  // Created after DescriptorObus are processed and final Layout is known.
+  std::optional<ChannelReorderer> channel_reorderer = std::nullopt;
+};
 
 // Creates an ObuProcessor; an ObuProcessor is only created once all descriptor
 // OBUs have been processed. Contracted to only return a resource exhausted
 // error if there is not enough data to process the descriptor OBUs.
-absl::StatusOr<std::unique_ptr<ObuProcessor>> CreateObuProcessor(
-    bool contains_all_descriptor_obus, absl::Span<const uint8_t> bitstream,
-    StreamBasedReadBitBuffer* read_bit_buffer, Layout& in_out_layout) {
+absl::Status IamfDecoder::DecoderState::CreateObuProcessor() {
+  // When resetting, the `ObuProcessor` is recreated with the original
+  // descriptors. So we force `is_exhaustive_and_exact` to be true in that case.
+  const bool on_reset = obu_processor != nullptr;
+  const bool is_exhaustive_and_exact = on_reset || created_from_descriptors;
+
   // Happens only in the pure streaming case.
-  auto start_position = read_bit_buffer->Tell();
+  const auto start_position = read_bit_buffer->Tell();
   bool insufficient_data;
-  auto obu_processor = ObuProcessor::CreateForRendering(
-      in_out_layout,
+  auto temp_obu_processor = ObuProcessor::CreateForRendering(
+      desired_profile_versions, layout,
       RenderingMixPresentationFinalizer::ProduceNoSampleProcessors,
-      /*is_exhaustive_and_exact=*/contains_all_descriptor_obus, read_bit_buffer,
-      in_out_layout, insufficient_data);
-  if (obu_processor == nullptr) {
+      is_exhaustive_and_exact, read_bit_buffer.get(), layout,
+      insufficient_data);
+  if (temp_obu_processor == nullptr) {
     // `insufficient_data` is true iff everything so far is valid but more data
     // is needed.
-    if (insufficient_data && !contains_all_descriptor_obus) {
+    if (insufficient_data && !created_from_descriptors) {
       return absl::ResourceExhaustedError(
           "Have not received enough data yet to process descriptor "
           "OBUs. Please call Decode() again with more data.");
     }
     return absl::InvalidArgumentError("Failed to create OBU processor.");
   }
-  auto num_bits_read = read_bit_buffer->Tell() - start_position;
-  RETURN_IF_NOT_OK(read_bit_buffer->Flush(num_bits_read / 8));
-  return obu_processor;
+  const auto num_bytes_read = (read_bit_buffer->Tell() - start_position) / 8;
+
+  // Seek back to the beginning of the data that was processed so that we can
+  // read and store the binary IAMF descriptor OBUs.
+  RETURN_IF_NOT_OK(read_bit_buffer->Seek(start_position));
+  descriptor_obus.resize(num_bytes_read);
+  RETURN_IF_NOT_OK(
+      read_bit_buffer->ReadUint8Span(absl::MakeSpan(descriptor_obus)));
+  RETURN_IF_NOT_OK(read_bit_buffer->Flush(num_bytes_read));
+
+  // Copy over fields at the end, now that everything is successful.
+  obu_processor = std::move(temp_obu_processor);
+  return absl::OkStatus();
+}
+
+namespace {
+constexpr int kInitialBufferSize = 1024;
+
+IamfStatus AbslToIamfStatus(const absl::Status& absl_status) {
+  if (absl_status.ok()) {
+    return IamfStatus::OkStatus();
+  } else {
+    return IamfStatus::ErrorStatus(
+        absl_status.ToString(absl::StatusToStringMode::kDefault));
+  }
+}
+
+ChannelReorderer::RearrangementScheme ChannelOrderingApiToInternalType(
+    ChannelOrdering channel_ordering) {
+  switch (channel_ordering) {
+    case ChannelOrdering::kOrderingForAndroid:
+      return ChannelReorderer::RearrangementScheme::kReorderForAndroid;
+    case ChannelOrdering::kIamfOrdering:
+    default:
+      return ChannelReorderer::RearrangementScheme::kDefaultNoOp;
+  }
 }
 
-absl::Status ProcessAllTemporalUnits(
+IamfStatus ProcessAllTemporalUnits(
     StreamBasedReadBitBuffer* read_bit_buffer, ObuProcessor* obu_processor,
-    std::queue<std::vector<std::vector<int32_t>>>& rendered_pcm_samples) {
-  LOG(INFO) << "Processing Temporal Units";
-  int32_t num_bits_read = 0;
+    bool created_from_descriptors,
+    std::queue<std::vector<absl::Span<const int32_t>>>& rendered_pcm_samples,
+    std::optional<ChannelReorderer> channel_reorderer) {
+  LOG_FIRST_N(INFO, 10) << "Processing Temporal Units";
   bool continue_processing = true;
+  const auto start_position_bits = read_bit_buffer->Tell();
   while (continue_processing) {
-    auto start_position_for_temporal_unit = read_bit_buffer->Tell();
     std::optional<ObuProcessor::OutputTemporalUnit> output_temporal_unit;
     // TODO(b/395889878): Add support for partial temporal units.
-    RETURN_IF_NOT_OK(obu_processor->ProcessTemporalUnit(
-        /*eos_is_end_of_sequence=*/false, output_temporal_unit,
-        continue_processing));
-    if (!output_temporal_unit.has_value()) {
-      break;
+    absl::Status absl_status = obu_processor->ProcessTemporalUnit(
+        created_from_descriptors, output_temporal_unit, continue_processing);
+    if (!absl_status.ok()) {
+      return AbslToIamfStatus(absl_status);
     }
-
-    // Trivial IA Sequences may have empty temporal units. Do not try to
-    // render empty temporal unit.
+    // We may have processed bytes but not a full temporal unit.
     if (output_temporal_unit.has_value()) {
-      absl::Span<const std::vector<int32_t>>
+      absl::Span<const absl::Span<const int32_t>>
           rendered_pcm_samples_for_temporal_unit;
-      RETURN_IF_NOT_OK(obu_processor->RenderTemporalUnitAndMeasureLoudness(
+      absl_status = obu_processor->RenderTemporalUnitAndMeasureLoudness(
           output_temporal_unit->output_timestamp,
           output_temporal_unit->output_audio_frames,
           output_temporal_unit->output_parameter_blocks,
-          rendered_pcm_samples_for_temporal_unit));
-      rendered_pcm_samples.push(
+          rendered_pcm_samples_for_temporal_unit);
+      if (!absl_status.ok()) {
+        return AbslToIamfStatus(absl_status);
+      }
+      auto temporal_unit =
           std::vector(rendered_pcm_samples_for_temporal_unit.begin(),
-                      rendered_pcm_samples_for_temporal_unit.end()));
+                      rendered_pcm_samples_for_temporal_unit.end());
+      if (channel_reorderer.has_value()) {
+        channel_reorderer->Reorder(temporal_unit);
+      }
+      rendered_pcm_samples.push(std::move(temporal_unit));
     }
-    num_bits_read +=
-        (read_bit_buffer->Tell() - start_position_for_temporal_unit);
   }
   // Empty the buffer of the data that was processed thus far.
-  RETURN_IF_NOT_OK(read_bit_buffer->Flush(num_bits_read / 8));
-  LOG(INFO) << "Rendered " << rendered_pcm_samples.size()
-            << " temporal units. Please call GetOutputTemporalUnit() to get "
-               "the rendered PCM samples.";
-  return absl::OkStatus();
+  const auto num_bits_read = read_bit_buffer->Tell() - start_position_bits;
+  absl::Status absl_status = read_bit_buffer->Flush(num_bits_read / 8);
+  if (!absl_status.ok()) {
+    return AbslToIamfStatus(absl_status);
+  }
+  LOG_FIRST_N(INFO, 10) << "Rendered " << rendered_pcm_samples.size()
+                        << " temporal units.";
+  return IamfStatus::OkStatus();
 }
 
 size_t BytesPerSample(OutputSampleType sample_type) {
@@ -155,30 +235,34 @@ size_t BytesPerSample(OutputSampleType sample_type) {
   }
 }
 
-absl::Status WriteFrameToSpan(const std::vector<std::vector<int32_t>>& frame,
-                              OutputSampleType sample_type,
-                              absl::Span<uint8_t>& output_bytes,
-                              size_t& bytes_written) {
+IamfStatus WriteFrameToSpan(const std::vector<absl::Span<const int32_t>>& frame,
+                            OutputSampleType sample_type,
+                            absl::Span<uint8_t> output_bytes,
+                            size_t& bytes_written) {
   const size_t bytes_per_sample = BytesPerSample(sample_type);
   const size_t bits_per_sample = bytes_per_sample * 8;
   const size_t required_size =
       frame.size() * frame[0].size() * bytes_per_sample;
   if (output_bytes.size() < required_size) {
-    return absl::InvalidArgumentError(
-        "Span does not have enough space to write output bytes.");
+    return IamfStatus::ErrorStatus(
+        "Invalid Argument: Span does not have enough space to write output "
+        "bytes.");
   }
   const bool big_endian = false;
   size_t write_position = 0;
   uint8_t* data = output_bytes.data();
-  for (int t = 0; t < frame.size(); t++) {
-    for (int c = 0; c < frame[0].size(); ++c) {
-      const uint32_t sample = static_cast<uint32_t>(frame[t][c]);
-      RETURN_IF_NOT_OK(WritePcmSample(sample, bits_per_sample, big_endian, data,
-                                      write_position));
+  for (int t = 0; t < frame[0].size(); t++) {
+    for (int c = 0; c < frame.size(); ++c) {
+      const uint32_t sample = static_cast<uint32_t>(frame[c][t]);
+      absl::Status absl_status = WritePcmSample(
+          sample, bits_per_sample, big_endian, data, write_position);
+      if (!absl_status.ok()) {
+        return AbslToIamfStatus(absl_status);
+      }
     }
   }
   bytes_written = write_position;
-  return absl::OkStatus();
+  return IamfStatus::OkStatus();
 }
 
 }  // namespace
@@ -193,72 +277,97 @@ IamfDecoder::~IamfDecoder() = default;
 IamfDecoder::IamfDecoder(IamfDecoder&&) = default;
 IamfDecoder& IamfDecoder::operator=(IamfDecoder&&) = default;
 
-absl::StatusOr<IamfDecoder> IamfDecoder::Create(
-    const OutputLayout& requested_layout) {
+IamfStatus IamfDecoder::Create(const Settings& settings,
+                               std::unique_ptr<IamfDecoder>& output_decoder) {
+  output_decoder = nullptr;
+
   std::unique_ptr<StreamBasedReadBitBuffer> read_bit_buffer =
       StreamBasedReadBitBuffer::Create(kInitialBufferSize);
   if (read_bit_buffer == nullptr) {
-    return absl::InternalError("Failed to create read bit buffer.");
+    return IamfStatus::ErrorStatus(
+        "Internal Error: Failed to create read bit buffer.");
   }
+
+  // Cache the internal representation of the profile versions. Depending on
+  // creation mode, we may not have all the descriptors yet.
+  absl::flat_hash_set<::iamf_tools::ProfileVersion> desired_profile_versions;
+  for (const auto& profile_version : settings.requested_profile_versions) {
+    desired_profile_versions.insert(ApiToInternalType(profile_version));
+  }
+
   std::unique_ptr<DecoderState> state = std::make_unique<DecoderState>(
-      std::move(read_bit_buffer), ApiToInternalType(requested_layout));
-  return IamfDecoder(std::move(state));
+      std::move(read_bit_buffer), ApiToInternalType(settings.requested_layout),
+      desired_profile_versions);
+  state->channel_rearrangement_scheme =
+      ChannelOrderingApiToInternalType(settings.channel_ordering);
+  output_decoder = absl::WrapUnique(new IamfDecoder(std::move(state)));
+  return IamfStatus::OkStatus();
 }
 
-absl::StatusOr<IamfDecoder> IamfDecoder::CreateFromDescriptors(
-    const OutputLayout& requested_layout,
-    absl::Span<const uint8_t> descriptor_obus) {
-  absl::StatusOr<IamfDecoder> decoder = Create(requested_layout);
-  if (!decoder.ok()) {
-    return decoder.status();
+IamfStatus IamfDecoder::CreateFromDescriptors(
+    const Settings& settings, const uint8_t* input_buffer,
+    size_t input_buffer_size, std::unique_ptr<IamfDecoder>& output_decoder) {
+  output_decoder = nullptr;
+  absl::Span<const uint8_t> descriptor_obus(input_buffer, input_buffer_size);
+
+  IamfStatus status = Create(settings, output_decoder);
+  if (!status.ok()) {
+    return status;
   }
-  RETURN_IF_NOT_OK(
-      decoder->state_->read_bit_buffer->PushBytes(descriptor_obus));
-  absl::StatusOr<std::unique_ptr<ObuProcessor>> obu_processor =
-      CreateObuProcessor(/*contains_all_descriptor_obus=*/true, descriptor_obus,
-                         decoder->state_->read_bit_buffer.get(),
-                         decoder->state_->layout);
-  if (!obu_processor.ok()) {
-    return obu_processor.status();
+  if (output_decoder == nullptr) {
+    return IamfStatus::ErrorStatus("Internal Error: Unexpected null decoder");
+  }
+  absl::Status absl_status =
+      output_decoder->state_->read_bit_buffer->PushBytes(descriptor_obus);
+  if (!absl_status.ok()) {
+    return AbslToIamfStatus(absl_status);
   }
-  decoder->state_->obu_processor = *std::move(obu_processor);
-  return decoder;
+
+  output_decoder->state_->created_from_descriptors = true;
+  return AbslToIamfStatus(output_decoder->state_->CreateObuProcessor());
 }
 
-absl::Status IamfDecoder::Decode(absl::Span<const uint8_t> bitstream) {
-  if (state_->status == Status::kFlushCalled) {
-    return absl::FailedPreconditionError(
-        "Decode() cannot be called after Flush() has been called.");
+IamfStatus IamfDecoder::Decode(const uint8_t* input_buffer,
+                               size_t input_buffer_size) {
+  if (state_->status == DecoderStatus::kEndOfStream) {
+    return IamfStatus::ErrorStatus(
+        "Failed Precondition: Decode() cannot be called after "
+        "SignalEndOfStream() has been called.");
+  }
+  auto bitstream = absl::MakeConstSpan(input_buffer, input_buffer_size);
+  absl::Status push_bytes_status =
+      state_->read_bit_buffer->PushBytes(bitstream);
+  if (!push_bytes_status.ok()) {
+    return AbslToIamfStatus(push_bytes_status);
   }
-  RETURN_IF_NOT_OK(state_->read_bit_buffer->PushBytes(bitstream));
   if (!IsDescriptorProcessingComplete()) {
-    auto obu_processor = CreateObuProcessor(
-        /*contains_all_descriptor_obus=*/false, bitstream,
-        state_->read_bit_buffer.get(), state_->layout);
-    if (obu_processor.ok()) {
-      state_->obu_processor = *std::move(obu_processor);
-      return absl::OkStatus();
-    } else if (absl::IsResourceExhausted(obu_processor.status())) {
+    const auto created_obu_processor_status = state_->CreateObuProcessor();
+
+    if (created_obu_processor_status.ok()) {
+      return IamfStatus::OkStatus();
+    } else if (absl::IsResourceExhausted(created_obu_processor_status)) {
       // Don't have enough data to process the descriptor OBUs yet, but no
       // errors have occurred.
-      return absl::OkStatus();
+      return IamfStatus::OkStatus();
     } else {
       // Corrupted data or other errors.
-      return obu_processor.status();
+      return AbslToIamfStatus(created_obu_processor_status);
     }
   }
 
   // At this stage, we know that we've processed all descriptor OBUs.
-  RETURN_IF_NOT_OK(ProcessAllTemporalUnits(state_->read_bit_buffer.get(),
-                                           state_->obu_processor.get(),
-                                           state_->rendered_pcm_samples));
-  return absl::OkStatus();
-}
-
-absl::Status IamfDecoder::ConfigureMixPresentationId(
-    MixPresentationId mix_presentation_id) {
-  return absl::UnimplementedError(
-      "ConfigureMixPresentationId is not yet implemented.");
+  if (std::holds_alternative<LoudspeakersSsConventionLayout>(
+          state_->layout.specific_layout)) {
+    auto sound_system =
+        std::get<LoudspeakersSsConventionLayout>(state_->layout.specific_layout)
+            .sound_system;
+    state_->channel_reorderer = ChannelReorderer::Create(
+        sound_system, state_->channel_rearrangement_scheme);
+  }
+  return ProcessAllTemporalUnits(
+      state_->read_bit_buffer.get(), state_->obu_processor.get(),
+      state_->created_from_descriptors, state_->rendered_pcm_samples,
+      state_->channel_reorderer);
 }
 
 void IamfDecoder::ConfigureOutputSampleType(
@@ -266,19 +375,19 @@ void IamfDecoder::ConfigureOutputSampleType(
   state_->output_sample_type = output_sample_type;
 }
 
-absl::Status IamfDecoder::GetOutputTemporalUnit(
-    absl::Span<uint8_t> output_bytes, size_t& bytes_written) {
+IamfStatus IamfDecoder::GetOutputTemporalUnit(uint8_t* output_buffer,
+                                              size_t output_buffer_size,
+                                              size_t& bytes_written) {
   bytes_written = 0;
   if (state_->rendered_pcm_samples.empty()) {
-    return absl::OkStatus();
+    return IamfStatus::OkStatus();
   }
   OutputSampleType output_sample_type = GetOutputSampleType();
-  absl::Status status =
-      WriteFrameToSpan(state_->rendered_pcm_samples.front(), output_sample_type,
-                       output_bytes, bytes_written);
+  IamfStatus status = WriteFrameToSpan(
+      state_->rendered_pcm_samples.front(), output_sample_type,
+      absl::MakeSpan(output_buffer, output_buffer_size), bytes_written);
   if (status.ok()) {
     state_->rendered_pcm_samples.pop();
-    return absl::OkStatus();
   }
   return status;
 }
@@ -291,65 +400,111 @@ bool IamfDecoder::IsDescriptorProcessingComplete() const {
   return state_->obu_processor != nullptr;
 }
 
-absl::StatusOr<OutputLayout> IamfDecoder::GetOutputLayout() const {
+IamfStatus IamfDecoder::GetOutputLayout(OutputLayout& output_layout) const {
   if (!IsDescriptorProcessingComplete()) {
-    return absl::FailedPreconditionError(
-        "GetOutputLayout() cannot be called before descriptor processing is "
-        "complete.");
+    return IamfStatus::ErrorStatus(
+        "Failed Precondition: GetOutputLayout() cannot be called before "
+        "descriptor processing is complete.");
+  }
+  absl::StatusOr<OutputLayout> conversion = InternalToApiType(state_->layout);
+  if (conversion.ok()) {
+    output_layout = *conversion;
+    return IamfStatus::OkStatus();
   }
-  return InternalToApiType(state_->layout);
+  return AbslToIamfStatus(conversion.status());
 }
 
-absl::StatusOr<int> IamfDecoder::GetNumberOfOutputChannels() const {
+IamfStatus IamfDecoder::GetNumberOfOutputChannels(
+    int& output_num_channels) const {
   if (!IsDescriptorProcessingComplete()) {
-    return absl::FailedPreconditionError(
-        "GetNumberOfOutputChannels() cannot be called before descriptor "
-        "processing is complete.");
+    return IamfStatus::ErrorStatus(
+        "Failed Precondition: GetNumberOfOutputChannels() cannot be called "
+        "before descriptor processing is complete.");
   }
-  int num_channels;
-  RETURN_IF_NOT_OK(MixPresentationObu::GetNumChannelsFromLayout(state_->layout,
-                                                                num_channels));
-  return num_channels;
+  return AbslToIamfStatus(MixPresentationObu::GetNumChannelsFromLayout(
+      state_->layout, output_num_channels));
 }
 
-absl::Status IamfDecoder::GetMixPresentations(
-    std::vector<MixPresentationMetadata>& output_mix_presentation_metadata)
-    const {
-  return absl::UnimplementedError(
-      "GetMixPresentations is not yet implemented.");
-}
 OutputSampleType IamfDecoder::GetOutputSampleType() const {
   return state_->output_sample_type;
 }
 
-absl::StatusOr<uint32_t> IamfDecoder::GetSampleRate() const {
+IamfStatus IamfDecoder::GetSampleRate(uint32_t& output_sample_rate) const {
   if (!IsDescriptorProcessingComplete()) {
-    return absl::FailedPreconditionError(
-        "GetSampleRate() cannot be called before descriptor processing is "
-        "complete.");
+    return IamfStatus::ErrorStatus(
+        "Failed Precondition: GetSampleRate() cannot be called before "
+        "descriptor processing is complete.");
   }
-  return state_->obu_processor->GetOutputSampleRate();
+  absl::StatusOr<uint32_t> sample_rate =
+      state_->obu_processor->GetOutputSampleRate();
+  if (sample_rate.ok()) {
+    output_sample_rate = *sample_rate;
+    return IamfStatus::OkStatus();
+  }
+  return AbslToIamfStatus(sample_rate.status());
 }
 
-absl::StatusOr<uint32_t> IamfDecoder::GetFrameSize() const {
+IamfStatus IamfDecoder::GetFrameSize(uint32_t& output_frame_size) const {
   if (!IsDescriptorProcessingComplete()) {
-    return absl::FailedPreconditionError(
-        "GetFrameSize() cannot be called before descriptor processing is "
-        "complete.");
+    return IamfStatus::ErrorStatus(
+        "Failed Precondition: GetFrameSize() cannot be called before "
+        "descriptor processing is complete.");
   }
 
-  return state_->obu_processor->GetOutputFrameSize();
+  absl::StatusOr<uint32_t> frame_size =
+      state_->obu_processor->GetOutputFrameSize();
+  if (frame_size.ok()) {
+    output_frame_size = *frame_size;
+    return IamfStatus::OkStatus();
+  }
+  return AbslToIamfStatus(frame_size.status());
 }
 
-absl::Status IamfDecoder::Flush(absl::Span<uint8_t> output_bytes,
-                                size_t& bytes_written, bool& output_is_done) {
-  state_->status = Status::kFlushCalled;
-  RETURN_IF_NOT_OK(GetOutputTemporalUnit(output_bytes, bytes_written));
-  output_is_done = state_->rendered_pcm_samples.empty();
-  return absl::OkStatus();
+IamfStatus IamfDecoder::Reset() {
+  if (!IsDescriptorProcessingComplete()) {
+    return IamfStatus::ErrorStatus(
+        "Failed Precondition: Reset() cannot be called before descriptor "
+        "processing is complete.");
+  }
+
+  // Clear the rendered PCM samples.
+  state_->rendered_pcm_samples = {};
+
+  // Set state.
+  state_->status = DecoderStatus::kAcceptingData;
+  // Create a new read bit buffer.
+  std::unique_ptr<StreamBasedReadBitBuffer> read_bit_buffer =
+      StreamBasedReadBitBuffer::Create(kInitialBufferSize);
+  if (read_bit_buffer == nullptr) {
+    return IamfStatus::ErrorStatus(
+        "Internal Error: Failed to create read bit buffer.");
+  }
+  state_->read_bit_buffer = std::move(read_bit_buffer);
+
+  // Create a new ObuProcessor with the original descriptor OBUs.
+  absl::Status absl_status =
+      state_->read_bit_buffer->PushBytes(state_->descriptor_obus);
+  if (!absl_status.ok()) {
+    return AbslToIamfStatus(absl_status);
+  }
+  return AbslToIamfStatus(state_->CreateObuProcessor());
+}
+
+IamfStatus IamfDecoder::ResetWithNewLayout(OutputLayout output_layout) {
+  if (!state_->created_from_descriptors) {
+    return IamfStatus::ErrorStatus(
+        "Failed Precondition: ResetWithNewLayout() cannot be called in "
+        "standalone decoding mode.");
+  }
+  state_->layout = ApiToInternalType(output_layout);
+  return Reset();
+}
+
+void IamfDecoder::SignalEndOfDecoding() {
+  state_->status = DecoderStatus::kEndOfStream;
 }
 
-absl::Status IamfDecoder::Close() { return absl::OkStatus(); }
+IamfStatus IamfDecoder::Close() { return IamfStatus::OkStatus(); }
 
 }  // namespace api
 }  // namespace iamf_tools
diff --git a/iamf/api/decoder/iamf_decoder.h b/iamf/api/decoder/iamf_decoder.h
deleted file mode 100644
index 643c04a..0000000
--- a/iamf/api/decoder/iamf_decoder.h
+++ /dev/null
@@ -1,283 +0,0 @@
-/*
- * Copyright (c) 2024, Alliance for Open Media. All rights reserved
- *
- * This source code is subject to the terms of the BSD 3-Clause Clear License
- * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
- * License was not distributed with this source code in the LICENSE file, you
- * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
- * Alliance for Open Media Patent License 1.0 was not distributed with this
- * source code in the PATENTS file, you can obtain it at
- * www.aomedia.org/license/patent.
- */
-
-#ifndef API_DECODER_IAMF_DECODER_H_
-#define API_DECODER_IAMF_DECODER_H_
-
-#include <cstddef>
-#include <cstdint>
-#include <memory>
-#include <vector>
-
-#include "absl/status/status.h"
-#include "absl/status/statusor.h"
-#include "absl/types/span.h"
-#include "iamf/api/types.h"
-
-namespace iamf_tools {
-namespace api {
-
-/*!brief The class and entrypoint for decoding IAMF bitstreams. */
-class IamfDecoder {
- public:
-  /* WARNING: API is currently in flux and will change.
-   *
-   * The functions below constitute our IAMF Iterative Decoder API. Below is a
-   * sample usage of the API.
-   *
-   * Reconfigurable Standalone IAMF Usage
-   * IamfDecoder streaming_decoder = IamfDecoder::Create();
-   * for chunk of data in iamf stream:
-   *    Decode()
-   *    if (IsDescriptorProcessingComplete()) {
-   *      GetMixPresentations(output_mix_presentation_ids)
-   *      ConfigureMixPresentationId(mix_presentation_id)
-   *      ConfigureOutputLayout(output_layout)
-   *      ConfigureBitDepth(bit_depth)
-   *    }
-   * for chunk of data in iamf stream:
-   *    Decode()
-   *    while (IsTemporalUnitAvailable()) {
-   *      GetOutputTemporalUnit(output_temporal_unit)
-   *      Playback(output_temporal_unit)
-   *    }
-   * while (IsTemporalUnitAvailable()) {
-   *      Flush(output_temporal_unit)
-   *      Playback(output_temporal_unit)
-   *  }
-   * Close();
-   */
-
-  // Dtor cannot be inline (so it must be declared and defined in the source
-  // file) because this class holds a (unique) pointer to the partial class,
-  // DecoderState.  Moves must be declared and defined because dtor is defined.
-  ~IamfDecoder();
-  IamfDecoder(IamfDecoder&&);
-  IamfDecoder& operator=(IamfDecoder&&);
-
-  /*!\brief Creates an IamfDecoder.
-   *
-   * This function should be used for pure streaming applications in which the
-   * descriptor OBUs are not known in advance.
-   *
-   * \param requested_layout Specifies the desired output layout. This layout
-   *        will be used so long as it is present in the Descriptor OBUs that
-   *        are later provided to Decode(). If not, a default layout will be
-   *        selected.
-   *
-   * \return IamfDecoder upon success. Other specific statuses on
-   *         failure.
-   */
-  static absl::StatusOr<IamfDecoder> Create(
-      const OutputLayout& requested_layout);
-
-  /*!\brief Creates an IamfDecoder from a known set of descriptor OBUs.
-   *
-   * This function should be used for applications in which the descriptor OBUs
-   * are known in advance.
-   *
-   * \param requested_layout Specifies the desired output layout. This layout
-   *        will be used so long as it is present in the Descriptor OBUs that
-   *        are provided. If not, a default layout will be selected.
-   * \param descriptor_obus Bitstream containing all the descriptor OBUs and
-   *        only descriptor OBUs.
-   * \return IamfDecoder upon success. Other specific statuses on
-   *         failure.
-   */
-  static absl::StatusOr<IamfDecoder> CreateFromDescriptors(
-      const OutputLayout& requested_layout,
-      absl::Span<const uint8_t> descriptor_obus);
-
-  /*!\brief Configures the decoder with the desired mix presentation.
-   *
-   * \param mix_presentation_id Specifies the desired mix presentation.
-   * \return `absl::OkStatus()` upon success. Other specific statuses on
-   *         failure.
-   */
-  absl::Status ConfigureMixPresentationId(
-      MixPresentationId mix_presentation_id);
-
-  /*!\brief Configures the decoder with the desired bit depth.
-   *
-   * Call this method to specify a specific output sample type.  If it is not
-   * called, the output samples will be a default value, retrievable by
-   * `GetOutputSampleType`.
-   */
-  void ConfigureOutputSampleType(OutputSampleType output_sample_type);
-
-  /*!\brief Decodes the bitstream provided.
-   *
-   * Supports both descriptor OBUs, temporal units, and partial versions of
-   * both. User can provide as much data as they would like. To receive decoded
-   * temporal units, GetOutputTemporalUnit() should be called. If
-   * GetOutputTemporalUnit() has not been called, this function guarantees that
-   * any temporal units received thus far have not been lost. If descriptors are
-   * processed for the first time, function will exit before processing any
-   * temporal units. This provides the user a chance to configure the decoder as
-   * they see fit. See sample usages for more details.
-   *
-   * \param bitstream Bitstream to decode.
-   * \return `absl::OkStatus()` upon success. Other specific statuses on
-   *         failure.
-   */
-  absl::Status Decode(absl::Span<const uint8_t> bitstream);
-
-  /*!\brief Outputs the next temporal unit of decoded audio.
-   *
-   * If no decoded data is available, output_decoded_temporal_unit will be
-   * empty. The user can continue calling until the output is empty, as there
-   * may be more than one temporal unit available. When this returns empty, the
-   * user should call Decode() again with more data.
-   *
-   * \param output_bytes Output buffer to receive bytes.  Must be large enough
-   *        to receive bytes.  Maximum necessary size can be determined by
-   *        GetFrameSize and GetOutputSampleType.
-   * \param bytes_written Number of bytes written to the output_bytes.
-   * \return `absl::OkStatus()` upon success. Other specific statuses on
-   *         failure.
-   */
-  absl::Status GetOutputTemporalUnit(absl::Span<uint8_t> output_bytes,
-                                     size_t& bytes_written);
-
-  /*!\brief Returns true iff a decoded temporal unit is available.
-   *
-   * This function can be used to determine when the user should call
-   * GetOutputTemporalUnit().
-   *
-   * \return true iff a decoded temporal unit is available.
-   */
-  bool IsTemporalUnitAvailable() const;
-
-  /*!\brief Returns true iff the descriptor OBUs have been parsed.
-   *
-   * This function can be used for determining when configuration setters that
-   * rely on Descriptor OBU parsing can be called.
-   *
-   * \return true iff the Descriptor OBUs have been parsed.
-   */
-  bool IsDescriptorProcessingComplete() const;
-
-  /*!\brief Gets the layout that will be used to render the audio.
-   *
-   * The actual Layout used for rendering may not the same as requested when
-   * creating the IamfDecoder, if the requested Layout could not be used.
-   * This function allows verifying the actual Layout used after Descriptor OBU
-   * parsing is complete.
-   *
-   * This function can only be used after all Descriptor OBUs have been parsed,
-   * i.e. IsDescriptorProcessingComplete() returns true.
-   *
-   * \return OutputLayout or error statuses on failure.
-   */
-  absl::StatusOr<OutputLayout> GetOutputLayout() const;
-
-  /*!\brief Gets the number of output channels.
-   *
-   * This function can only be used after all Descriptor OBUs have been parsed,
-   * i.e. IsDescriptorProcessingComplete() returns true.
-   *
-   * \return
-   */
-  absl::StatusOr<int> GetNumberOfOutputChannels() const;
-
-  /*!\brief Provides mix presentation information from the descriptor OBUs.
-   *
-   * This function can be used to determine which mix presentation the user
-   * would like to configure the decoder with.
-   *
-   * This function can only be used after all Descriptor OBUs have been parsed,
-   * i.e. IsDescriptorProcessingComplete() returns true.
-   *
-   * \param output_mix_presentation_metadatas Output parameter for the mix
-   *        presentation metadata.
-   * \return `absl::OkStatus()` upon success. Other specific statuses on
-   *         failure.
-   */
-  absl::Status GetMixPresentations(std::vector<MixPresentationMetadata>&
-                                       output_mix_presentation_metadatas) const;
-
-  /*!\brief Returns the current OutputSampleType.
-   *
-   * The value is either the value set by ConfigureOutputSampleType or a default
-   * which may vary based on content.
-   *
-   * This function can only be used after all Descriptor OBUs have been parsed,
-   * i.e. IsDescriptorProcessingComplete() returns true.
-   */
-  OutputSampleType GetOutputSampleType() const;
-
-  /*!\brief Gets the sample rate.
-   *
-   * This function can only be used after all Descriptor OBUs have been parsed,
-   * i.e. IsDescriptorProcessingComplete() returns true.
-   *
-   * \return `absl::OkStatus()` upon success. Other specific statuses on
-   *         failure.
-   */
-  absl::StatusOr<uint32_t> GetSampleRate() const;
-
-  /*!\brief Gets the number of samples per frame.
-   *
-   * This function can only be used after all Descriptor OBUs have been parsed,
-   * i.e. IsDescriptorProcessingComplete() returns true.
-   *
-   * Returns the number of samples per frame of the output audio. The total
-   * number of samples in a time tick is the number of channels times the number
-   * of samples per frame.
-   *
-   * \return Number of samples per frame upon success. Other specific statuses
-   *         on failure.
-   */
-  absl::StatusOr<uint32_t> GetFrameSize() const;
-
-  /*!\brief Outputs the last temporal unit(s) of decoded audio.
-   *
-   * Signals to the decoder that no more data will be provided; therefore it
-   * should only be called once the user has finished providing data to
-   * Decode(). Temporal units are output one at a time, so this function should
-   * be called until output_is_done is true.
-   *
-   * \param output_decoded_temporal_unit Output parameter for the next temporal
-   *        unit of decoded audio.
-   * \param output_is_done Output parameter for whether there are more temporal
-   *        units to be output.
-   * \return `absl::OkStatus()` upon success. Other specific statuses on
-   *         failure.
-   */
-  absl::Status Flush(absl::Span<uint8_t> output_bytes, size_t& bytes_written,
-                     bool& output_is_done);
-
-  /*!\brief Closes the decoder.
-   *
-   * This should be called once the user has finished providing data into
-   * Decode() and has called Flush() until output_is_done is true. Will close
-   * all underlying decoders.
-   *
-   * \return `absl::OkStatus()` upon success. Other specific statuses on
-   *         failure.
-   */
-  absl::Status Close();
-
- private:
-  // Forward declaration of the internal state of the decoder.
-  struct DecoderState;
-
-  // Private constructor only used by Create functions.
-  IamfDecoder(std::unique_ptr<DecoderState> state);
-
-  // Internal state of the decoder.
-  std::unique_ptr<DecoderState> state_;
-};
-}  // namespace api
-}  // namespace iamf_tools
-
-#endif  // API_DECODER_IAMF_DECODER_H_
diff --git a/iamf/api/decoder/tests/BUILD b/iamf/api/decoder/tests/BUILD
index 2d1493a..44b8675 100644
--- a/iamf/api/decoder/tests/BUILD
+++ b/iamf/api/decoder/tests/BUILD
@@ -8,10 +8,8 @@ cc_test(
         "@platforms//os:linux",
     ],
     deps = [
-        "//iamf/api:types",
+        "//iamf/api:iamf_tools_api_types",
         "//iamf/api/decoder:iamf_decoder",
-        "@com_google_absl//absl/status:status_matchers",
-        "@com_google_absl//absl/types:span",
         "@com_google_fuzztest//fuzztest",
         "@com_google_googletest//:gtest_main",
     ],
@@ -21,7 +19,7 @@ cc_test(
     name = "iamf_decoder_test",
     srcs = ["iamf_decoder_test.cc"],
     deps = [
-        "//iamf/api:types",
+        "//iamf/api:iamf_tools_api_types",
         "//iamf/api/decoder:iamf_decoder",
         "//iamf/cli:audio_element_with_data",
         "//iamf/cli:audio_frame_with_data",
@@ -36,7 +34,6 @@ cc_test(
         "//iamf/obu:temporal_delimiter",
         "//iamf/obu:types",
         "@com_google_absl//absl/container:flat_hash_map",
-        "@com_google_absl//absl/status:status_matchers",
         "@com_google_absl//absl/types:span",
         "@com_google_googletest//:gtest_main",
     ],
diff --git a/iamf/api/decoder/tests/iamf_decoder_fuzz_test.cc b/iamf/api/decoder/tests/iamf_decoder_fuzz_test.cc
index d07aeca..9043d81 100644
--- a/iamf/api/decoder/tests/iamf_decoder_fuzz_test.cc
+++ b/iamf/api/decoder/tests/iamf_decoder_fuzz_test.cc
@@ -14,13 +14,11 @@
 #include <string>
 #include <vector>
 
-#include "absl/status/status_matchers.h"
-#include "absl/types/span.h"
 #include "fuzztest/fuzztest.h"
-#include "gmock/gmock.h"
+#include "gtest/gtest.h"
 // [internal] Placeholder for FLAC fuzzing include.
-#include "iamf/api/decoder/iamf_decoder.h"
-#include "iamf/api/types.h"
+#include "iamf/include/iamf_tools/iamf_decoder.h"
+#include "iamf/include/iamf_tools/iamf_tools_api_types.h"
 
 namespace iamf_tools {
 namespace {
@@ -33,24 +31,34 @@ constexpr OutputLayout kStereoLayout =
     OutputLayout::kItu2051_SoundSystemA_0_2_0;
 
 void DoesNotDieWithBasicDecode(const std::string& data) {
-  absl::StatusOr<api::IamfDecoder> iamf_decoder =
-      api::IamfDecoder::Create(kStereoLayout);
-  std::vector<uint8_t> bitstream(data.begin(), data.end());
-  ASSERT_THAT(iamf_decoder, ::absl_testing::IsOk());
+  std::unique_ptr<api::IamfDecoder> iamf_decoder;
+  const api::IamfDecoder::Settings kStereoLayoutSettings = {.requested_layout =
+                                                                kStereoLayout};
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(kStereoLayoutSettings, iamf_decoder).ok());
 
-  auto decode_status = iamf_decoder->Decode(bitstream);
+  std::vector<uint8_t> bitstream(data.begin(), data.end());
+  auto decode_status = iamf_decoder->Decode(bitstream.data(), bitstream.size());
 }
 
 FUZZ_TEST(IamfDecoderFuzzTest_ArbitraryBytes, DoesNotDieWithBasicDecode);
 
-void DoesNotDieCreateFromDescriptors(const std::string& data) {
-  std::vector<uint8_t> bitstream(data.begin(), data.end());
-
-  absl::StatusOr<api::IamfDecoder> iamf_decoder =
-      api::IamfDecoder::CreateFromDescriptors(kStereoLayout, bitstream);
-
-  if (iamf_decoder.ok()) {
-    auto decoder_status = iamf_decoder->Decode(bitstream);
+void DoesNotDieCreateFromDescriptors(const std::string& descriptor_data,
+                                     const std::string& temporal_unit_data) {
+  std::vector<uint8_t> descriptors(descriptor_data.begin(),
+                                   descriptor_data.end());
+
+  std::unique_ptr<api::IamfDecoder> iamf_decoder;
+  // Intentionally check that defaulted settings are safe to use.
+  const api::IamfDecoder::Settings kDefaultSettings;
+  api::IamfStatus status = api::IamfDecoder::CreateFromDescriptors(
+      kDefaultSettings, descriptors.data(), descriptors.size(), iamf_decoder);
+
+  if (status.ok()) {
+    std::vector<uint8_t> temporal_unit(temporal_unit_data.begin(),
+                                       temporal_unit_data.end());
+    auto decoder_status =
+        iamf_decoder->Decode(temporal_unit.data(), temporal_unit.size());
   }
 }
 
@@ -61,11 +69,13 @@ void DoesNotDieAllParams(api::OutputLayout output_layout,
                          api::OutputSampleType output_sample_type,
                          uint32_t mix_presentation_id, std::string data) {
   std::vector<uint8_t> bitstream(data.begin(), data.end());
-  absl::StatusOr<api::IamfDecoder> iamf_decoder =
-      api::IamfDecoder::Create(kStereoLayout);
-  ASSERT_THAT(iamf_decoder, ::absl_testing::IsOk());
+  std::unique_ptr<api::IamfDecoder> iamf_decoder;
+  const api::IamfDecoder::Settings kSettings = {.requested_layout =
+                                                    output_layout};
+  ASSERT_TRUE(api::IamfDecoder::Create(kSettings, iamf_decoder).ok());
 
-  auto decode_status = iamf_decoder->Decode(bitstream);
+  auto unused_decode_status =
+      iamf_decoder->Decode(bitstream.data(), bitstream.size());
   iamf_decoder->ConfigureOutputSampleType(output_sample_type);
 }
 
diff --git a/iamf/api/decoder/tests/iamf_decoder_test.cc b/iamf/api/decoder/tests/iamf_decoder_test.cc
index e72c794..63be26f 100644
--- a/iamf/api/decoder/tests/iamf_decoder_test.cc
+++ b/iamf/api/decoder/tests/iamf_decoder_test.cc
@@ -10,24 +10,23 @@
  * www.aomedia.org/license/patent.
  */
 
-#include "iamf/api/decoder/iamf_decoder.h"
+#include "iamf/include/iamf_tools/iamf_decoder.h"
 
 #include <array>
 #include <cstddef>
 #include <cstdint>
 #include <list>
+#include <memory>
 #include <vector>
 
 #include "absl/container/flat_hash_map.h"
-#include "absl/status/status_matchers.h"
 #include "absl/types/span.h"
-#include "gmock/gmock.h"
 #include "gtest/gtest.h"
-#include "iamf/api/types.h"
 #include "iamf/cli/audio_element_with_data.h"
 #include "iamf/cli/audio_frame_with_data.h"
 #include "iamf/cli/parameter_block_with_data.h"
 #include "iamf/cli/tests/cli_test_utils.h"
+#include "iamf/include/iamf_tools/iamf_tools_api_types.h"
 #include "iamf/obu/audio_frame.h"
 #include "iamf/obu/codec_config.h"
 #include "iamf/obu/ia_sequence_header.h"
@@ -40,13 +39,6 @@
 namespace iamf_tools {
 namespace {
 
-using ::absl_testing::IsOk;
-using ::absl_testing::IsOkAndHolds;
-using ::testing::Not;
-
-using api::OutputLayout;
-using ::testing::Not;
-
 constexpr DecodedUleb128 kFirstCodecConfigId = 1;
 constexpr uint32_t kNumSamplesPerFrame = 8;
 constexpr uint32_t kBitDepth = 16;
@@ -80,58 +72,114 @@ std::vector<uint8_t> GenerateBasicDescriptorObus() {
                                 &mix_presentation_obus.front()});
 }
 
+std::vector<uint8_t> GenerateBaseEnhancedDescriptorObus() {
+  const IASequenceHeaderObu ia_sequence_header(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfBaseEnhancedProfile,
+      ProfileVersion::kIamfBaseEnhancedProfile);
+  absl::flat_hash_map<DecodedUleb128, CodecConfigObu> codec_configs;
+  AddLpcmCodecConfig(kFirstCodecConfigId, kNumSamplesPerFrame, kBitDepth,
+                     kSampleRate, codec_configs);
+  absl::flat_hash_map<DecodedUleb128, AudioElementWithData> audio_elements;
+  // Fourth-order ambisonics uses too many channels for simple or base
+  // profile, but it permitted in base-enhanced profile.
+  constexpr std::array<DecodedUleb128, 25> kFourthOrderAmbisonicsSubstreamIds =
+      {0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+       13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24};
+  AddAmbisonicsMonoAudioElementWithSubstreamIds(
+      kFirstAudioElementId, kFirstCodecConfigId,
+      kFourthOrderAmbisonicsSubstreamIds, codec_configs, audio_elements);
+  std::list<MixPresentationObu> mix_presentation_obus;
+  AddMixPresentationObuWithAudioElementIds(
+      kFirstMixPresentationId, {kFirstAudioElementId},
+      kCommonMixGainParameterId, kCommonParameterRate, mix_presentation_obus);
+  return SerializeObusExpectOk({&ia_sequence_header,
+                                &codec_configs.at(kFirstCodecConfigId),
+                                &audio_elements.at(kFirstAudioElementId).obu,
+                                &mix_presentation_obus.front()});
+}
+
+api::IamfDecoder::Settings GetStereoDecoderSettings() {
+  return {
+      .requested_layout = api::OutputLayout::kItu2051_SoundSystemA_0_2_0,
+  };
+}
+
+api::IamfDecoder::Settings Get5_1DecoderSettings() {
+  return {
+      .requested_layout = api::OutputLayout::kItu2051_SoundSystemB_0_5_0,
+  };
+}
+
 TEST(IsDescriptorProcessingComplete,
      ReturnsFalseBeforeDescriptorObusAreProcessed) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
 
   EXPECT_FALSE(decoder->IsDescriptorProcessingComplete());
 }
 
 TEST(IamfDecoder,
      MethodsDependingOnDescriptorsFailBeforeDescriptorObusAreProcessed) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
-
-  EXPECT_THAT(decoder->GetOutputLayout(), Not(IsOk()));
-  EXPECT_THAT(decoder->GetNumberOfOutputChannels(), Not(IsOk()));
-  EXPECT_THAT(decoder->GetSampleRate(), Not(IsOk()));
-  EXPECT_THAT(decoder->GetFrameSize(), Not(IsOk()));
-  std::vector<api::MixPresentationMetadata> output_mix_presentation_metadatas;
-  EXPECT_THAT(decoder->GetMixPresentations(output_mix_presentation_metadatas),
-              Not(IsOk()));
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
+  api::OutputLayout output_layout;
+  EXPECT_FALSE(decoder->GetOutputLayout(output_layout).ok());
+  int num_channels;
+  EXPECT_FALSE(decoder->GetNumberOfOutputChannels(num_channels).ok());
+  uint32_t sample_rate;
+  EXPECT_FALSE(decoder->GetSampleRate(sample_rate).ok());
+  uint32_t frame_size;
+  EXPECT_FALSE(decoder->GetFrameSize(frame_size).ok());
 }
 
 TEST(GetOutputLayout, ReturnsOutputLayoutAfterDescriptorObusAreProcessed) {
-  auto decoder = api::IamfDecoder::CreateFromDescriptors(
-      OutputLayout::kItu2051_SoundSystemA_0_2_0, GenerateBasicDescriptorObus());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  auto descriptors = GenerateBasicDescriptorObus();
+  ASSERT_TRUE(api::IamfDecoder::CreateFromDescriptors(
+                  GetStereoDecoderSettings(), descriptors.data(),
+                  descriptors.size(), decoder)
+                  .ok());
 
   EXPECT_TRUE(decoder->IsDescriptorProcessingComplete());
-  auto output_layout = decoder->GetOutputLayout();
-  EXPECT_THAT(output_layout.status(), IsOk());
-  EXPECT_EQ(*output_layout, OutputLayout::kItu2051_SoundSystemA_0_2_0);
-  auto number_of_output_channels = decoder->GetNumberOfOutputChannels();
-  EXPECT_THAT(number_of_output_channels.status(), IsOk());
-  EXPECT_EQ(*number_of_output_channels, 2);
+  api::OutputLayout output_layout;
+  EXPECT_TRUE(decoder->GetOutputLayout(output_layout).ok());
+  EXPECT_EQ(output_layout, api::OutputLayout::kItu2051_SoundSystemA_0_2_0);
+  int num_output_channels;
+  EXPECT_TRUE(decoder->GetNumberOfOutputChannels(num_output_channels).ok());
+  EXPECT_EQ(num_output_channels, 2);
 }
 
-TEST(GetOutputLayout, ReturnsDefaultStereoLayoutIfNoMatchingLayoutExists) {
-  auto decoder = api::IamfDecoder::CreateFromDescriptors(
-      OutputLayout::kItu2051_SoundSystemE_4_5_1, GenerateBasicDescriptorObus());
+TEST(GetOutputLayout, ReturnVirtualDesiredLayoutIfNoMatchingLayoutExists) {
+  std::unique_ptr<api::IamfDecoder> decoder;
+  auto descriptors = GenerateBasicDescriptorObus();
+  constexpr api::OutputLayout kDesiredLayout =
+      api::OutputLayout::kItu2051_SoundSystemE_4_5_1;
+  const api::IamfDecoder::Settings kSettings = {.requested_layout =
+                                                    kDesiredLayout};
+  ASSERT_TRUE(api::IamfDecoder::CreateFromDescriptors(
+                  kSettings, descriptors.data(), descriptors.size(), decoder)
+                  .ok());
 
   EXPECT_TRUE(decoder->IsDescriptorProcessingComplete());
-  auto output_layout = decoder->GetOutputLayout();
-  EXPECT_THAT(output_layout.status(), IsOk());
-  EXPECT_EQ(*output_layout, OutputLayout::kItu2051_SoundSystemA_0_2_0);
-  auto number_of_output_channels = decoder->GetNumberOfOutputChannels();
-  EXPECT_THAT(number_of_output_channels.status(), IsOk());
-  EXPECT_EQ(*number_of_output_channels, 2);
+  api::OutputLayout output_layout;
+  EXPECT_TRUE(decoder->GetOutputLayout(output_layout).ok());
+  EXPECT_EQ(output_layout, kDesiredLayout);
+  int num_output_channels;
+  EXPECT_TRUE(decoder->GetNumberOfOutputChannels(num_output_channels).ok());
+  EXPECT_EQ(num_output_channels, 11);
 }
 
 TEST(GetOutputLayout,
-     ReturnsDefaultStereoLayoutIfNoMatchingLayoutExistsUsingDecode) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemE_4_5_1);
+     ReturnsVirtualDesiredLayoutIfNoMatchingLayoutExistsUsingDecode) {
+  std::unique_ptr<api::IamfDecoder> decoder;
+  constexpr api::OutputLayout kDesiredLayout =
+      api::OutputLayout::kItu2051_SoundSystemE_4_5_1;
+  const api::IamfDecoder::Settings kSettings = {.requested_layout =
+                                                    kDesiredLayout};
+  ASSERT_TRUE(api::IamfDecoder::Create(kSettings, decoder).ok());
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
   TemporalDelimiterObu temporal_delimiter_obu =
       TemporalDelimiterObu(ObuHeader());
@@ -140,15 +188,15 @@ TEST(GetOutputLayout,
   source_data.insert(source_data.end(), temporal_delimiter_bytes.begin(),
                      temporal_delimiter_bytes.end());
 
-  EXPECT_THAT(decoder->Decode(source_data), IsOk());
+  EXPECT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
 
   EXPECT_TRUE(decoder->IsDescriptorProcessingComplete());
-  auto output_layout = decoder->GetOutputLayout();
-  EXPECT_THAT(output_layout.status(), IsOk());
-  EXPECT_EQ(*output_layout, OutputLayout::kItu2051_SoundSystemA_0_2_0);
-  auto number_of_output_channels = decoder->GetNumberOfOutputChannels();
-  EXPECT_THAT(number_of_output_channels.status(), IsOk());
-  EXPECT_EQ(*number_of_output_channels, 2);
+  api::OutputLayout output_layout;
+  EXPECT_TRUE(decoder->GetOutputLayout(output_layout).ok());
+  EXPECT_EQ(output_layout, api::OutputLayout::kItu2051_SoundSystemE_4_5_1);
+  int num_output_channels;
+  EXPECT_TRUE(decoder->GetNumberOfOutputChannels(num_output_channels).ok());
+  EXPECT_EQ(num_output_channels, 11);
 }
 
 TEST(GetOutputLayout, ReturnsNonStereoLayoutWhenPresentInDescriptorObus) {
@@ -177,47 +225,53 @@ TEST(GetOutputLayout, ReturnsNonStereoLayoutWhenPresentInDescriptorObus) {
        &audio_elements.at(kFirstAudioElementId).obu,
        &mix_presentation_obus.front()});
 
-  auto decoder = api::IamfDecoder::CreateFromDescriptors(
-      OutputLayout::kItu2051_SoundSystemB_0_5_0, descriptor_obus);
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(api::IamfDecoder::CreateFromDescriptors(
+                  Get5_1DecoderSettings(), descriptor_obus.data(),
+                  descriptor_obus.size(), decoder)
+                  .ok());
 
   EXPECT_TRUE(decoder->IsDescriptorProcessingComplete());
-  auto output_layout = decoder->GetOutputLayout();
-  EXPECT_THAT(output_layout.status(), IsOk());
-  EXPECT_EQ(*output_layout, OutputLayout::kItu2051_SoundSystemB_0_5_0);
-  auto number_of_output_channels = decoder->GetNumberOfOutputChannels();
-  EXPECT_THAT(number_of_output_channels.status(), IsOk());
-  EXPECT_EQ(*number_of_output_channels, 6);
+  api::OutputLayout output_layout;
+  EXPECT_TRUE(decoder->GetOutputLayout(output_layout).ok());
+  EXPECT_EQ(output_layout, api::OutputLayout::kItu2051_SoundSystemB_0_5_0);
+  int num_output_channels;
+  EXPECT_TRUE(decoder->GetNumberOfOutputChannels(num_output_channels).ok());
+  EXPECT_EQ(num_output_channels, 6);
 }
 
 TEST(Create, SucceedsAndDecodeSucceedsWithPartialData) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
-  EXPECT_THAT(decoder, IsOk());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
 
   std::vector<uint8_t> source_data = {0x01, 0x23, 0x45};
-  EXPECT_TRUE(decoder->Decode(source_data).ok());
+  EXPECT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
   EXPECT_FALSE(decoder->IsDescriptorProcessingComplete());
 }
 
 TEST(Create, SucceedsWithNonStereoLayout) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemB_0_5_0);
-  EXPECT_THAT(decoder, IsOk());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  EXPECT_TRUE(api::IamfDecoder::Create(Get5_1DecoderSettings(), decoder).ok());
 }
 
 TEST(CreateFromDescriptors, Succeeds) {
-  auto decoder = api::IamfDecoder::CreateFromDescriptors(
-      OutputLayout::kItu2051_SoundSystemA_0_2_0, GenerateBasicDescriptorObus());
-
-  EXPECT_THAT(decoder, IsOk());
+  auto descriptors = GenerateBasicDescriptorObus();
+  std::unique_ptr<api::IamfDecoder> decoder;
+  EXPECT_TRUE(api::IamfDecoder::CreateFromDescriptors(
+                  GetStereoDecoderSettings(), descriptors.data(),
+                  descriptors.size(), decoder)
+                  .ok());
   EXPECT_TRUE(decoder->IsDescriptorProcessingComplete());
 }
 
 TEST(CreateFromDescriptors, SucceedsWithNonStereoLayout) {
-  auto decoder = api::IamfDecoder::CreateFromDescriptors(
-      OutputLayout::kItu2051_SoundSystemB_0_5_0, GenerateBasicDescriptorObus());
-
-  EXPECT_THAT(decoder, IsOk());
+  auto descriptors = GenerateBasicDescriptorObus();
+  std::unique_ptr<api::IamfDecoder> decoder;
+  EXPECT_TRUE(api::IamfDecoder::CreateFromDescriptors(
+                  Get5_1DecoderSettings(), descriptors.data(),
+                  descriptors.size(), decoder)
+                  .ok());
   EXPECT_TRUE(decoder->IsDescriptorProcessingComplete());
 }
 
@@ -226,17 +280,21 @@ TEST(CreateFromDescriptors, FailsWithIncompleteDescriptorObus) {
   // remove the last byte to make the descriptor OBUs incomplete.
   descriptors.pop_back();
 
-  auto decoder = api::IamfDecoder::CreateFromDescriptors(
-      OutputLayout::kItu2051_SoundSystemA_0_2_0, descriptors);
-
-  EXPECT_FALSE(decoder.ok());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  EXPECT_FALSE(api::IamfDecoder::CreateFromDescriptors(
+                   GetStereoDecoderSettings(), descriptors.data(),
+                   descriptors.size(), decoder)
+                   .ok());
 }
 
 TEST(CreateFromDescriptors, FailsWithDescriptorObuInSubsequentDecode) {
-  auto decoder = api::IamfDecoder::CreateFromDescriptors(
-      OutputLayout::kItu2051_SoundSystemA_0_2_0, GenerateBasicDescriptorObus());
-  EXPECT_THAT(decoder, IsOk());
-  EXPECT_TRUE(decoder->IsDescriptorProcessingComplete());
+  auto descriptors = GenerateBasicDescriptorObus();
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(api::IamfDecoder::CreateFromDescriptors(
+                  GetStereoDecoderSettings(), descriptors.data(),
+                  descriptors.size(), decoder)
+                  .ok());
+  ASSERT_TRUE(decoder->IsDescriptorProcessingComplete());
 
   std::list<MixPresentationObu> mix_presentation_obus;
   AddMixPresentationObuWithAudioElementIds(
@@ -244,13 +302,98 @@ TEST(CreateFromDescriptors, FailsWithDescriptorObuInSubsequentDecode) {
       kCommonMixGainParameterId, kCommonParameterRate, mix_presentation_obus);
   auto second_chunk = SerializeObusExpectOk({&mix_presentation_obus.front()});
 
-  EXPECT_FALSE(decoder->Decode(second_chunk).ok());
+  EXPECT_FALSE(decoder->Decode(second_chunk.data(), second_chunk.size()).ok());
+}
+
+TEST(CreateThenDecode, FailsWhenNoMatchingProfileVersionIsFound) {
+  // Configure a "legacy" decoder with only the base profile. E.g. mimic a
+  // client that may not want to spend additional CPU cycles on handling
+  // base-enhanced profile.
+  std::unique_ptr<api::IamfDecoder> decoder;
+  const api::IamfDecoder::Settings kSettingsWithoutBaseEnhancedProfile = {
+      .requested_profile_versions = {api::ProfileVersion::kIamfBaseProfile}};
+  const auto status =
+      api::IamfDecoder::Create(kSettingsWithoutBaseEnhancedProfile, decoder);
+  EXPECT_TRUE(status.ok());
+
+  // The descriptors are base-enhanced with no backwards compatibility features.
+  auto descriptors = GenerateBaseEnhancedDescriptorObus();
+  EXPECT_TRUE(decoder->Decode(descriptors.data(), descriptors.size()).ok());
+  // Once we see the start of a temporal unit, we know that no remaining mixes
+  // match the requested profile.
+  const TemporalDelimiterObu temporal_delimiter_obu =
+      TemporalDelimiterObu(ObuHeader());
+  const auto serialized_temporal_delimiter =
+      SerializeObusExpectOk({&temporal_delimiter_obu});
+
+  // No mix matches the requested profile. Nothing can be decoded.
+  EXPECT_FALSE(decoder
+                   ->Decode(serialized_temporal_delimiter.data(),
+                            serialized_temporal_delimiter.size())
+                   .ok());
+}
+
+TEST(CreateThenDecode, SucceedsWithBaseEnhancedProfileWhenConfigured) {
+  std::unique_ptr<api::IamfDecoder> decoder;
+  const api::IamfDecoder::Settings kSettingsWithBaseEnhancedProfile = {
+      .requested_profile_versions = {
+          api::ProfileVersion::kIamfBaseEnhancedProfile}};
+  const auto status =
+      api::IamfDecoder::Create(kSettingsWithBaseEnhancedProfile, decoder);
+  EXPECT_TRUE(status.ok());
+
+  auto descriptors = GenerateBaseEnhancedDescriptorObus();
+  EXPECT_TRUE(decoder->Decode(descriptors.data(), descriptors.size()).ok());
+
+  // Once we see the start of a temporal unit, we know all descriptors are
+  // processed.
+  const TemporalDelimiterObu temporal_delimiter_obu =
+      TemporalDelimiterObu(ObuHeader());
+  const auto serialized_temporal_delimiter =
+      SerializeObusExpectOk({&temporal_delimiter_obu});
+  EXPECT_TRUE(decoder
+                  ->Decode(serialized_temporal_delimiter.data(),
+                           serialized_temporal_delimiter.size())
+                  .ok());
+  EXPECT_TRUE(decoder->IsDescriptorProcessingComplete());
+}
+
+TEST(CreateFromDescriptors, FailsWhenNoMatchingProfileVersionIsFound) {
+  // Configure a "legacy" decoder with only the base profile. E.g. mimic a
+  // client that may not want to spend additional CPU cycles on handling
+  // base-enhanced profile.
+  std::unique_ptr<api::IamfDecoder> decoder;
+  const api::IamfDecoder::Settings kSettingsWithoutBaseEnhancedProfile = {
+      .requested_profile_versions = {api::ProfileVersion::kIamfSimpleProfile}};
+  auto descriptors = GenerateBaseEnhancedDescriptorObus();
+
+  auto status = api::IamfDecoder::CreateFromDescriptors(
+      kSettingsWithoutBaseEnhancedProfile, descriptors.data(),
+      descriptors.size(), decoder);
+
+  // No relevant mix was found. Nothing can be decoded.
+  EXPECT_FALSE(status.ok());
+}
+
+TEST(CreateFromDescriptors, SucceedsWithBaseEnhancedProfileWhenConfigured) {
+  // Configure a decoder which may use base-enhanced profile.
+  std::unique_ptr<api::IamfDecoder> decoder;
+  const api::IamfDecoder::Settings kSettingsWithBaseEnhancedProfile = {
+      .requested_profile_versions = {
+          api::ProfileVersion::kIamfBaseEnhancedProfile}};
+  auto descriptors = GenerateBaseEnhancedDescriptorObus();
+
+  // Ok. The descriptors are suitable for the requested profiles.
+  auto status = api::IamfDecoder::CreateFromDescriptors(
+      kSettingsWithBaseEnhancedProfile, descriptors.data(), descriptors.size(),
+      decoder);
+  EXPECT_TRUE(status.ok());
 }
 
 TEST(Decode, SucceedsAndProcessesDescriptorsWithTemporalDelimiterAtEnd) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
-  ASSERT_THAT(decoder, IsOk());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
   TemporalDelimiterObu temporal_delimiter_obu =
       TemporalDelimiterObu(ObuHeader());
@@ -259,14 +402,14 @@ TEST(Decode, SucceedsAndProcessesDescriptorsWithTemporalDelimiterAtEnd) {
   source_data.insert(source_data.end(), temporal_delimiter_bytes.begin(),
                      temporal_delimiter_bytes.end());
 
-  EXPECT_THAT(decoder->Decode(source_data), IsOk());
+  EXPECT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
   EXPECT_TRUE(decoder->IsDescriptorProcessingComplete());
 }
 
 TEST(Decode, SucceedsWithMultiplePushesOfDescriptorObus) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
-  ASSERT_THAT(decoder, IsOk());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
   TemporalDelimiterObu temporal_delimiter_obu =
       TemporalDelimiterObu(ObuHeader());
@@ -274,33 +417,34 @@ TEST(Decode, SucceedsWithMultiplePushesOfDescriptorObus) {
       SerializeObusExpectOk({&temporal_delimiter_obu});
   source_data.insert(source_data.end(), temporal_delimiter_bytes.begin(),
                      temporal_delimiter_bytes.end());
-  auto first_chunk = absl::MakeConstSpan(source_data).first(2);
-  auto second_chunk =
-      absl::MakeConstSpan(source_data).last(source_data.size() - 2);
-
-  EXPECT_THAT(decoder->Decode(first_chunk), IsOk());
+  EXPECT_TRUE(
+      decoder->Decode(source_data.data(), /* input_buffer_size=*/2).ok());
   EXPECT_FALSE(decoder->IsDescriptorProcessingComplete());
-  EXPECT_THAT(decoder->Decode(second_chunk), IsOk());
+  EXPECT_TRUE(
+      decoder->Decode(source_data.data() + 2, source_data.size() - 2).ok());
   EXPECT_TRUE(decoder->IsDescriptorProcessingComplete());
 }
 
 TEST(Decode, SucceedsWithSeparatePushesOfDescriptorAndTemporalUnits) {
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
-  auto decoder = api::IamfDecoder::CreateFromDescriptors(
-      OutputLayout::kItu2051_SoundSystemA_0_2_0, source_data);
-  ASSERT_THAT(decoder, IsOk());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(api::IamfDecoder::CreateFromDescriptors(
+                  GetStereoDecoderSettings(), source_data.data(),
+                  source_data.size(), decoder)
+                  .ok());
   EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
   AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
                             kEightSampleAudioFrame);
   auto temporal_unit = SerializeObusExpectOk({&audio_frame});
 
-  EXPECT_THAT(decoder->Decode(temporal_unit), IsOk());
+  EXPECT_TRUE(decoder->Decode(temporal_unit.data(), temporal_unit.size()).ok());
+  EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
 }
 
 TEST(Decode, SucceedsWithOneTemporalUnit) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
-  ASSERT_THAT(decoder, IsOk());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
   AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
                             kEightSampleAudioFrame);
@@ -308,13 +452,64 @@ TEST(Decode, SucceedsWithOneTemporalUnit) {
   source_data.insert(source_data.end(), temporal_unit.begin(),
                      temporal_unit.end());
 
-  EXPECT_THAT(decoder->Decode(source_data), IsOk());
+  EXPECT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
+}
+
+TEST(Decode, ReordersSamplesIfRequested) {
+  api::IamfDecoder::Settings settings = {
+      .requested_layout = api::OutputLayout::kItu2051_SoundSystemI_0_7_0,
+      .channel_ordering = api::ChannelOrdering::kIamfOrdering,
+  };
+  auto descriptors = GenerateBasicDescriptorObus();
+  std::unique_ptr<api::IamfDecoder> regular_decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::CreateFromDescriptors(
+          settings, descriptors.data(), descriptors.size(), regular_decoder)
+          .ok());
+  settings.channel_ordering = api::ChannelOrdering::kOrderingForAndroid;
+  std::unique_ptr<api::IamfDecoder> reordering_decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::CreateFromDescriptors(
+          settings, descriptors.data(), descriptors.size(), reordering_decoder)
+          .ok());
+  AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
+                            kEightSampleAudioFrame);
+  auto temporal_unit = SerializeObusExpectOk({&audio_frame});
+  ASSERT_TRUE(
+      regular_decoder->Decode(temporal_unit.data(), temporal_unit.size()).ok());
+  ASSERT_TRUE(
+      reordering_decoder->Decode(temporal_unit.data(), temporal_unit.size())
+          .ok());
+
+  const size_t expected_output_size =
+      8 * 4 * 8;  // 8 samples, 32-bit ints, 7.1.
+  std::vector<uint8_t> regular_output_data(expected_output_size);
+  size_t bytes_written;
+  EXPECT_TRUE(regular_decoder
+                  ->GetOutputTemporalUnit(regular_output_data.data(),
+                                          regular_output_data.size(),
+                                          bytes_written)
+                  .ok());
+  std::vector<uint8_t> reordered_output_data(expected_output_size);
+  EXPECT_TRUE(reordering_decoder
+                  ->GetOutputTemporalUnit(reordered_output_data.data(),
+                                          reordered_output_data.size(),
+                                          bytes_written)
+                  .ok());
+
+  auto regular = absl::MakeSpan(regular_output_data);
+  auto reordered = absl::MakeSpan(reordered_output_data);
+  // First 4 samples should be same.
+  EXPECT_EQ(regular.first(16), reordered.first(16));
+  // Expect last 4 to be swapped.
+  EXPECT_EQ(regular.subspan(16, 8), reordered.subspan(24, 8));
+  EXPECT_EQ(regular.subspan(24, 8), reordered.subspan(16, 8));
 }
 
 TEST(Decode, SucceedsWithMultipleTemporalUnits) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
-  ASSERT_THAT(decoder, IsOk());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
   AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
                             kEightSampleAudioFrame);
@@ -322,13 +517,14 @@ TEST(Decode, SucceedsWithMultipleTemporalUnits) {
   source_data.insert(source_data.end(), temporal_units.begin(),
                      temporal_units.end());
 
-  EXPECT_THAT(decoder->Decode(source_data), IsOk());
+  EXPECT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
 }
 
 TEST(Decode, SucceedsWithMultipleTemporalUnitsForNonStereoLayout) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kIAMF_SoundSystemExtension_0_1_0);
-  ASSERT_THAT(decoder, IsOk());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  const api::IamfDecoder::Settings kMonoSettings = {
+      .requested_layout = api::OutputLayout::kIAMF_SoundSystemExtension_0_1_0};
+  ASSERT_TRUE(api::IamfDecoder::Create(kMonoSettings, decoder).ok());
 
   absl::flat_hash_map<DecodedUleb128, CodecConfigObu> codec_config_obus;
   AddLpcmCodecConfigWithIdAndSampleRate(kFirstCodecConfigId, kSampleRate,
@@ -367,59 +563,203 @@ TEST(Decode, SucceedsWithMultipleTemporalUnitsForNonStereoLayout) {
   source_data.insert(source_data.end(), temporal_units.begin(),
                      temporal_units.end());
 
-  EXPECT_THAT(decoder->Decode(source_data), IsOk());
+  EXPECT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
   // Calling with empty due to forced exit after descriptor processing, so that
   // we can get the output temporal unit.
-  EXPECT_THAT(decoder->Decode({}), IsOk());
+  EXPECT_TRUE(decoder->Decode(source_data.data(), 0).ok());
+
+  const size_t expected_output_size = 8 * 4;  // 8 samples, 32-bit ints, mono.
+  std::vector<uint8_t> output_data(expected_output_size);
+  size_t bytes_written;
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
+  EXPECT_EQ(bytes_written, expected_output_size);
+}
+
+TEST(Decode, CreatedFromDescriptorsSucceedsWithMultipleTemporalUnits) {
+  auto descriptors = GenerateBasicDescriptorObus();
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(api::IamfDecoder::CreateFromDescriptors(
+                  GetStereoDecoderSettings(), descriptors.data(),
+                  descriptors.size(), decoder)
+                  .ok());
+  AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
+                            kEightSampleAudioFrame);
+  auto temporal_units = SerializeObusExpectOk({&audio_frame, &audio_frame});
+
+  // We expect for decode to succeed and fully process both temporal units. This
+  // means that we should be able to pull two temporal units from the decoder,
+  // and then there should be nothing left.
+  EXPECT_TRUE(
+      decoder->Decode(temporal_units.data(), temporal_units.size()).ok());
+  EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
+  const size_t expected_output_size =
+      8 * 4 * 2;  // 8 samples, 32-bit ints, stereo.
+  std::vector<uint8_t> output_data(expected_output_size);
+  size_t bytes_written;
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
+
+  EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
+
+  output_data.clear();
+  output_data.resize(expected_output_size);
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
+  EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
+}
+
+TEST(Decode,
+     CreatedFromDescriptorsSucceedsWithTemporalUnitsDecodedInSeparatePushes) {
+  auto descriptors = GenerateBasicDescriptorObus();
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(api::IamfDecoder::CreateFromDescriptors(
+                  GetStereoDecoderSettings(), descriptors.data(),
+                  descriptors.size(), decoder)
+                  .ok());
+  AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
+                            kEightSampleAudioFrame);
+  auto temporal_unit = SerializeObusExpectOk({&audio_frame});
+
+  // We expect for decode to succeed and fully process the singular temporal
+  // unit that was pushed.
+  EXPECT_TRUE(decoder->Decode(temporal_unit.data(), temporal_unit.size()).ok());
+  EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
+  const size_t expected_output_size =
+      8 * 4 * 2;  // 8 samples, 32-bit ints, stereo.
+  std::vector<uint8_t> output_data(expected_output_size);
+  size_t bytes_written;
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
+
+  EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
+
+  output_data.clear();
+  output_data.resize(expected_output_size);
+
+  // Now, we expect for decode to succeed and fully process the second temporal
+  // unit that was pushed.
+  EXPECT_TRUE(decoder->Decode(temporal_unit.data(), temporal_unit.size()).ok());
+  EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
+  EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
+}
+
+TEST(
+    Decode,
+    CreatedFromDescriptorsSucceedsWithMultipleTemporalUnitsForNonStereoLayout) {
+  absl::flat_hash_map<DecodedUleb128, CodecConfigObu> codec_config_obus;
+  AddLpcmCodecConfigWithIdAndSampleRate(kFirstCodecConfigId, kSampleRate,
+                                        codec_config_obus);
+  absl::flat_hash_map<DecodedUleb128, AudioElementWithData>
+      audio_elements_with_data;
+  AddAmbisonicsMonoAudioElementWithSubstreamIds(
+      kFirstAudioElementId, kFirstCodecConfigId, {kFirstSubstreamId},
+      codec_config_obus, audio_elements_with_data);
+  std::list<MixPresentationObu> mix_presentation_obus;
+  std::vector<LoudspeakersSsConventionLayout::SoundSystem>
+      sound_system_layouts = {
+          LoudspeakersSsConventionLayout::kSoundSystemA_0_2_0,
+          LoudspeakersSsConventionLayout::kSoundSystem12_0_1_0};
+  AddMixPresentationObuWithConfigurableLayouts(
+      kFirstMixPresentationId, {kFirstAudioElementId},
+      kCommonMixGainParameterId, kCommonParameterRate, sound_system_layouts,
+      mix_presentation_obus);
+
+  const IASequenceHeaderObu ia_sequence_header(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
+  std::list<const ObuBase*> input_ia_sequence(
+      {&codec_config_obus.at(kFirstCodecConfigId),
+       &audio_elements_with_data.at(kFirstAudioElementId).obu,
+       &mix_presentation_obus.front()});
+  input_ia_sequence.push_front(&ia_sequence_header);
+  std::vector<uint8_t> descriptors = SerializeObusExpectOk(input_ia_sequence);
+
+  std::unique_ptr<api::IamfDecoder> decoder;
+  const api::IamfDecoder::Settings kMonoSettings = {
+      .requested_layout = api::OutputLayout::kIAMF_SoundSystemExtension_0_1_0};
+  ASSERT_TRUE(
+      api::IamfDecoder::CreateFromDescriptors(kMonoSettings, descriptors.data(),
+                                              descriptors.size(), decoder)
+          .ok());
+
+  const std::list<AudioFrameWithData> empty_audio_frames_with_data = {};
+  const std::list<ParameterBlockWithData> empty_parameter_blocks_with_data = {};
+
+  AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
+                            kEightSampleAudioFrame);
+  auto temporal_units = SerializeObusExpectOk({&audio_frame, &audio_frame});
 
+  // Call decode with both temporal units.
+  EXPECT_TRUE(
+      decoder->Decode(temporal_units.data(), temporal_units.size()).ok());
+
+  // We expect to get the first temporal unit with the correct number of
+  // samples.
   const size_t expected_output_size = 8 * 4;  // 8 samples, 32-bit ints, mono.
   std::vector<uint8_t> output_data(expected_output_size);
   size_t bytes_written;
-  EXPECT_THAT(decoder->GetOutputTemporalUnit(absl::MakeSpan(output_data),
-                                             bytes_written),
-              IsOk());
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
+  EXPECT_EQ(bytes_written, expected_output_size);
+
+  output_data.clear();
+  output_data.resize(expected_output_size);
+  bytes_written = 0;
+
+  // We expect to get the second temporal unit with the correct number of
+  // samples.
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
   EXPECT_EQ(bytes_written, expected_output_size);
 }
 
-TEST(Decode, FailsWhenCalledAfterFlush) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
-  ASSERT_THAT(decoder, IsOk());
+TEST(Decode, FailsWhenCalledAfterSignalEndOfDecoding) {
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
   AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
                             kEightSampleAudioFrame);
   auto temporal_units = SerializeObusExpectOk({&audio_frame, &audio_frame});
   source_data.insert(source_data.end(), temporal_units.begin(),
                      temporal_units.end());
-  ASSERT_THAT(decoder->Decode(source_data), IsOk());
-  ASSERT_FALSE(decoder->IsTemporalUnitAvailable());
-  ASSERT_THAT(decoder->Decode({}), IsOk());
-  ASSERT_TRUE(decoder->IsTemporalUnitAvailable());
-
-  size_t expected_size = 2 * 8 * 4;  // Stereo * 8 samples * int32.
-  std::vector<uint8_t> output_data(expected_size);
-  size_t bytes_written;
-  bool output_is_done;
-  EXPECT_THAT(decoder->Flush(absl::MakeSpan(output_data), bytes_written,
-                             output_is_done),
-              IsOk());
-  EXPECT_TRUE(output_is_done);
-  EXPECT_EQ(bytes_written, expected_size);
-  EXPECT_FALSE(decoder->Decode(source_data).ok());
+  ASSERT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
+  decoder->SignalEndOfDecoding();
+  EXPECT_FALSE(decoder->Decode(source_data.data(), source_data.size()).ok());
 }
 
 TEST(IsTemporalUnitAvailable, ReturnsFalseAfterCreateFromDescriptorObus) {
-  auto decoder = api::IamfDecoder::CreateFromDescriptors(
-      OutputLayout::kItu2051_SoundSystemA_0_2_0, GenerateBasicDescriptorObus());
-  ASSERT_THAT(decoder, IsOk());
+  auto descriptors = GenerateBasicDescriptorObus();
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(api::IamfDecoder::CreateFromDescriptors(
+                  GetStereoDecoderSettings(), descriptors.data(),
+                  descriptors.size(), decoder)
+                  .ok());
   EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
 }
 
 TEST(IsTemporalUnitAvailable,
      TemporalUnitIsNotAvailableAfterDecodeWithNoTemporalDelimiterAtEnd) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
-  ASSERT_THAT(decoder, IsOk());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
   AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
                             kEightSampleAudioFrame);
@@ -427,15 +767,15 @@ TEST(IsTemporalUnitAvailable,
   source_data.insert(source_data.end(), temporal_unit.begin(),
                      temporal_unit.end());
 
-  ASSERT_THAT(decoder->Decode(source_data), IsOk());
+  ASSERT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
   EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
 }
 
 TEST(IsTemporalUnitAvailable,
      ReturnsTrueAfterDecodingOneTemporalUnitWithTemporalDelimiterAtEnd) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
-  ASSERT_THAT(decoder, IsOk());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
   AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
                             kEightSampleAudioFrame);
@@ -445,7 +785,7 @@ TEST(IsTemporalUnitAvailable,
   source_data.insert(source_data.end(), temporal_unit.begin(),
                      temporal_unit.end());
 
-  ASSERT_THAT(decoder->Decode(source_data), IsOk());
+  ASSERT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
   EXPECT_TRUE(decoder->IsDescriptorProcessingComplete());
   // Even though a temporal unit was provided, it has not been decoded yet. This
   // is because Decode() returns after processing the descriptor OBUs, even if
@@ -455,15 +795,15 @@ TEST(IsTemporalUnitAvailable,
   EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
   // The user can call Decode() again to process the temporal unit still
   // available in the buffer.
-  EXPECT_THAT(decoder->Decode({}), IsOk());
+  EXPECT_TRUE(decoder->Decode({}, 0).ok());
   // Now, the temporal unit has been decoded and is available for output.
   EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
 }
 
 TEST(IsTemporalUnitAvailable, ReturnsTrueAfterDecodingMultipleTemporalUnits) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
-  ASSERT_THAT(decoder, IsOk());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
   AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
                             kEightSampleAudioFrame);
@@ -471,43 +811,44 @@ TEST(IsTemporalUnitAvailable, ReturnsTrueAfterDecodingMultipleTemporalUnits) {
   source_data.insert(source_data.end(), temporal_units.begin(),
                      temporal_units.end());
 
-  ASSERT_THAT(decoder->Decode(source_data), IsOk());
+  ASSERT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
   EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
-  EXPECT_THAT(decoder->Decode({}), IsOk());
+  EXPECT_TRUE(decoder->Decode({}, 0).ok());
   EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
 }
 
 TEST(GetOutputTemporalUnit, FillsOutputVectorWithLastTemporalUnit) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
-  ASSERT_THAT(decoder, IsOk());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
   AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
                             kEightSampleAudioFrame);
   auto temporal_units = SerializeObusExpectOk({&audio_frame, &audio_frame});
   source_data.insert(source_data.end(), temporal_units.begin(),
                      temporal_units.end());
-  ASSERT_THAT(decoder->Decode(source_data), IsOk());
+  ASSERT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
   EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
-  EXPECT_THAT(decoder->Decode({}), IsOk());
+  EXPECT_TRUE(decoder->Decode({}, 0).ok());
   EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
 
   size_t expected_size = 2 * 8 * 4;
   std::vector<uint8_t> output_data(expected_size);
   size_t bytes_written;
-  EXPECT_THAT(decoder->GetOutputTemporalUnit(absl::MakeSpan(output_data),
-                                             bytes_written),
-              IsOk());
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
 
   EXPECT_EQ(bytes_written, expected_size);
   EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
 }
 
 TEST(GetOutputTemporalUnit, FillsOutputVectorWithInt16) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
   decoder->ConfigureOutputSampleType(api::OutputSampleType::kInt16LittleEndian);
-  ASSERT_THAT(decoder, IsOk());
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
   AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
                             kEightSampleAudioFrame);
@@ -515,26 +856,26 @@ TEST(GetOutputTemporalUnit, FillsOutputVectorWithInt16) {
   source_data.insert(source_data.end(), temporal_units.begin(),
                      temporal_units.end());
 
-  ASSERT_THAT(decoder->Decode(source_data), IsOk());
+  ASSERT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
   EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
-  EXPECT_THAT(decoder->Decode({}), IsOk());
+  EXPECT_TRUE(decoder->Decode({}, 0).ok());
   EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
 
   size_t expected_size = 2 * 8 * 2;  // Stereo * 8 samples * 2 bytes (int16).
   std::vector<uint8_t> output_data(expected_size);
   size_t bytes_written;
-  EXPECT_THAT(decoder->GetOutputTemporalUnit(absl::MakeSpan(output_data),
-                                             bytes_written),
-              IsOk());
-
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
   EXPECT_EQ(bytes_written, expected_size);
 }
 
 TEST(GetOutputTemporalUnit, FailsWhenBufferTooSmall) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
   decoder->ConfigureOutputSampleType(api::OutputSampleType::kInt16LittleEndian);
-  ASSERT_THAT(decoder, IsOk());
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
   AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
                             kEightSampleAudioFrame);
@@ -542,40 +883,43 @@ TEST(GetOutputTemporalUnit, FailsWhenBufferTooSmall) {
   source_data.insert(source_data.end(), temporal_units.begin(),
                      temporal_units.end());
 
-  ASSERT_THAT(decoder->Decode(source_data), IsOk());
+  ASSERT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
   EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
-  EXPECT_THAT(decoder->Decode({}), IsOk());
+  EXPECT_TRUE(decoder->Decode({}, 0).ok());
   EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
 
   size_t needed_size = 2 * 8 * 2;  // Stereo * 8 samples * 2 bytes (int16).
   std::vector<uint8_t> output_data(needed_size - 1);  // Buffer too small.
   size_t bytes_written;
-  EXPECT_THAT(decoder->GetOutputTemporalUnit(absl::MakeSpan(output_data),
-                                             bytes_written),
-              Not(IsOk()));
+  EXPECT_FALSE(decoder
+                   ->GetOutputTemporalUnit(output_data.data(),
+                                           output_data.size(), bytes_written)
+                   .ok());
   EXPECT_EQ(bytes_written, 0);
 }
 
 TEST(GetOutputTemporalUnit,
      DoesNotFillOutputVectorWhenNoTemporalUnitIsAvailable) {
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
-  auto decoder = api::IamfDecoder::CreateFromDescriptors(
-      OutputLayout::kItu2051_SoundSystemA_0_2_0, source_data);
-  ASSERT_THAT(decoder, IsOk());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(api::IamfDecoder::CreateFromDescriptors(
+                  GetStereoDecoderSettings(), source_data.data(),
+                  source_data.size(), decoder)
+                  .ok());
 
   std::vector<uint8_t> output_data;
   size_t bytes_written;
-  EXPECT_THAT(decoder->GetOutputTemporalUnit(absl::MakeSpan(output_data),
-                                             bytes_written),
-              IsOk());
-
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
   EXPECT_EQ(bytes_written, 0);
 }
 
-TEST(Flush, SucceedsWithMultipleTemporalUnits) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
-  ASSERT_THAT(decoder, IsOk());
+TEST(SignalEndOfDecoding, GetMultipleTemporalUnitsOutAfterCall) {
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
   AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
                             kEightSampleAudioFrame);
@@ -585,61 +929,237 @@ TEST(Flush, SucceedsWithMultipleTemporalUnits) {
                              &audio_frame, &temporal_delimiter_obu});
   source_data.insert(source_data.end(), temporal_units.begin(),
                      temporal_units.end());
-  ASSERT_THAT(decoder->Decode(source_data), IsOk());
+  ASSERT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
   EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
-  EXPECT_THAT(decoder->Decode({}), IsOk());
+  EXPECT_TRUE(decoder->Decode({}, 0).ok());
   EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
 
+  decoder->SignalEndOfDecoding();
+
   // Stereo * 8 samples * 4 bytes per sample
   const size_t expected_size_per_temp_unit = 2 * 8 * 4;
   std::vector<uint8_t> output_data(expected_size_per_temp_unit);
+  EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
   size_t bytes_written;
-  bool output_is_done;
-  EXPECT_THAT(decoder->Flush(absl::MakeSpan(output_data), bytes_written,
-                             output_is_done),
-              IsOk());
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
   EXPECT_EQ(bytes_written, expected_size_per_temp_unit);
-  EXPECT_FALSE(output_is_done);
-  EXPECT_THAT(decoder->Flush(absl::MakeSpan(output_data), bytes_written,
-                             output_is_done),
-              IsOk());
+
+  EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
   EXPECT_EQ(bytes_written, expected_size_per_temp_unit);
-  EXPECT_TRUE(output_is_done);
+  EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
 }
 
-TEST(Flush, SucceedsWithNoTemporalUnits) {
-  auto decoder =
-      api::IamfDecoder::Create(OutputLayout::kItu2051_SoundSystemA_0_2_0);
-  ASSERT_THAT(decoder, IsOk());
+TEST(SignalEndOfDecoding, SucceedsWithNoTemporalUnits) {
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
 
   std::vector<std::vector<int32_t>> output_decoded_temporal_unit;
   std::vector<uint8_t> output_data;
-  size_t bytes_written;
-  bool output_is_done;
-  EXPECT_THAT(decoder->Flush(absl::MakeSpan(output_data), bytes_written,
-                             output_is_done),
-              IsOk());
+  decoder->SignalEndOfDecoding();
 
+  EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
+  size_t bytes_written;
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
   EXPECT_EQ(bytes_written, 0);
-  EXPECT_TRUE(output_is_done);
 }
 
 TEST(GetSampleRate, ReturnsSampleRateBasedOnCodecConfigObu) {
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
-  auto decoder = api::IamfDecoder::CreateFromDescriptors(
-      api::OutputLayout::kItu2051_SoundSystemA_0_2_0, source_data);
-  ASSERT_THAT(decoder, IsOk());
-
-  EXPECT_THAT(decoder->GetSampleRate(), IsOkAndHolds(kSampleRate));
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(api::IamfDecoder::CreateFromDescriptors(
+                  GetStereoDecoderSettings(), source_data.data(),
+                  source_data.size(), decoder)
+                  .ok());
+
+  uint32_t sample_rate;
+  ASSERT_TRUE(decoder->GetSampleRate(sample_rate).ok());
+  EXPECT_EQ(sample_rate, kSampleRate);
 }
 
 TEST(GetFrameSize, ReturnsFrameSizeBasedOnCodecConfigObu) {
   std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
-  auto decoder = api::IamfDecoder::CreateFromDescriptors(
-      api::OutputLayout::kItu2051_SoundSystemA_0_2_0, source_data);
-  ASSERT_THAT(decoder, IsOk());
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(api::IamfDecoder::CreateFromDescriptors(
+                  GetStereoDecoderSettings(), source_data.data(),
+                  source_data.size(), decoder)
+                  .ok());
+
+  uint32_t frame_size;
+  ASSERT_TRUE(decoder->GetFrameSize(frame_size).ok());
+  EXPECT_EQ(frame_size, kNumSamplesPerFrame);
+}
 
-  EXPECT_THAT(decoder->GetFrameSize(), IsOkAndHolds(kNumSamplesPerFrame));
+TEST(Reset, DecodingAfterResetSucceedsAfterCreateFromDescriptors) {
+  // Create a decoder from descriptors.
+  std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(api::IamfDecoder::CreateFromDescriptors(
+                  GetStereoDecoderSettings(), source_data.data(),
+                  source_data.size(), decoder)
+                  .ok());
+  // Decode a temporal unit.
+  AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
+                            kEightSampleAudioFrame);
+  auto temporal_units = SerializeObusExpectOk({&audio_frame});
+  EXPECT_TRUE(
+      decoder->Decode(temporal_units.data(), temporal_units.size()).ok());
+  EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
+
+  // Signal end of decoding and reset.
+  decoder->SignalEndOfDecoding();
+  EXPECT_TRUE(decoder->Reset().ok());
+
+  // Confirm that there is no temporal unit available after reset.
+  EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
+
+  // Decode another temporal unit.
+  EXPECT_TRUE(
+      decoder->Decode(temporal_units.data(), temporal_units.size()).ok());
+  // Confirm that the temporal unit is available and can be retrieved.
+  EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
+  size_t expected_size = 2 * 8 * 4;
+  std::vector<uint8_t> output_data(expected_size);
+  size_t bytes_written;
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
+  EXPECT_EQ(bytes_written, expected_size);
+}
+
+TEST(Reset, DecodingAfterResetSucceedsInStandaloneCase) {
+  // Create a decoder from descriptors.
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
+  // Add descriptors.
+  std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
+  // Add temporal unit.
+  AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
+                            kEightSampleAudioFrame);
+  auto temporal_units = SerializeObusExpectOk({&audio_frame, &audio_frame});
+  source_data.insert(source_data.end(), temporal_units.begin(),
+                     temporal_units.end());
+  EXPECT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
+  // We have an inherent exit when initially decoding the descriptors, so we
+  // call again with an empty vector so that the first temporal unit is
+  // processed.
+  EXPECT_TRUE(decoder->Decode({}, 0).ok());
+  // We expect one temporal unit to be available since we are decoding in a
+  // standalone case and we've passed two in.
+  EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
+
+  // Signal end of decoding and reset.
+  decoder->SignalEndOfDecoding();
+  EXPECT_TRUE(decoder->Reset().ok());
+
+  // Confirm that there is no temporal unit available after reset.
+  EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
+
+  // Now, we put two temporal units into decode again.
+  EXPECT_TRUE(
+      decoder->Decode(temporal_units.data(), temporal_units.size()).ok());
+  // Confirm that one temporal unit is available and can be retrieved.
+  EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
+  size_t expected_size = 2 * 8 * 4;
+  std::vector<uint8_t> output_data(expected_size);
+  size_t bytes_written;
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
+  EXPECT_EQ(bytes_written, expected_size);
+}
+
+TEST(Reset, ResetFailsWhenDescriptorProcessingIncomplete) {
+  // Create a decoder without descriptors.
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
+  EXPECT_FALSE(decoder->Reset().ok());
+}
+
+TEST(ResetWithNewLayout,
+     DecodingAfterResetWithNewLayoutSucceedsInContainerizedCase) {
+  // Create a decoder from descriptors.
+  std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(api::IamfDecoder::CreateFromDescriptors(
+                  GetStereoDecoderSettings(), source_data.data(),
+                  source_data.size(), decoder)
+                  .ok());
+  // Decode a temporal unit.
+  AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
+                            kEightSampleAudioFrame);
+  auto temporal_units = SerializeObusExpectOk({&audio_frame});
+  EXPECT_TRUE(
+      decoder->Decode(temporal_units.data(), temporal_units.size()).ok());
+  EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
+
+  // Signal end of decoding and reset with 5.1 layout, which is different from
+  // the original stereo layout.
+  decoder->SignalEndOfDecoding();
+  EXPECT_TRUE(
+      decoder
+          ->ResetWithNewLayout(api::OutputLayout::kItu2051_SoundSystemB_0_5_0)
+          .ok());
+  api::OutputLayout output_layout;
+  EXPECT_TRUE(decoder->GetOutputLayout(output_layout).ok());
+  EXPECT_EQ(output_layout, api::OutputLayout::kItu2051_SoundSystemB_0_5_0);
+
+  // Confirm that there is no temporal unit available after reset.
+  EXPECT_FALSE(decoder->IsTemporalUnitAvailable());
+
+  // Decode another temporal unit.
+  EXPECT_TRUE(
+      decoder->Decode(temporal_units.data(), temporal_units.size()).ok());
+  // Confirm that the temporal unit is available and can be retrieved.
+  EXPECT_TRUE(decoder->IsTemporalUnitAvailable());
+  // We now have 6 channels instead of 2, so we updated the expected size
+  // accordingly.
+  size_t expected_size = 6 * 8 * 4;
+  std::vector<uint8_t> output_data(expected_size);
+  size_t bytes_written;
+  EXPECT_TRUE(decoder
+                  ->GetOutputTemporalUnit(output_data.data(),
+                                          output_data.size(), bytes_written)
+                  .ok());
+  EXPECT_EQ(bytes_written, expected_size);
+}
+
+TEST(ResetWithNewLayout, ResetWithNewLayoutFailsInStandaloneCase) {
+  // Create a decoder from descriptors.
+  std::unique_ptr<api::IamfDecoder> decoder;
+  ASSERT_TRUE(
+      api::IamfDecoder::Create(GetStereoDecoderSettings(), decoder).ok());
+  // Add descriptors.
+  std::vector<uint8_t> source_data = GenerateBasicDescriptorObus();
+  // Add temporal unit.
+  AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
+                            kEightSampleAudioFrame);
+  auto temporal_units = SerializeObusExpectOk({&audio_frame, &audio_frame});
+  source_data.insert(source_data.end(), temporal_units.begin(),
+                     temporal_units.end());
+  EXPECT_TRUE(decoder->Decode(source_data.data(), source_data.size()).ok());
+
+  decoder->SignalEndOfDecoding();
+  // The decoder should fail to reset with a new layout because we are in a
+  // standalone case.
+  EXPECT_FALSE(
+      decoder
+          ->ResetWithNewLayout(api::OutputLayout::kItu2051_SoundSystemB_0_5_0)
+          .ok());
 }
 
 }  // namespace
diff --git a/iamf/api/iamf_tools_api_types.cc b/iamf/api/iamf_tools_api_types.cc
new file mode 100644
index 0000000..3ae4a58
--- /dev/null
+++ b/iamf/api/iamf_tools_api_types.cc
@@ -0,0 +1,28 @@
+#include "iamf/include/iamf_tools/iamf_tools_api_types.h"
+
+#include <ostream>
+#include <string>
+
+namespace iamf_tools {
+namespace api {
+
+IamfStatus::IamfStatus(const std::string& error_message)
+    : success(false), error_message(error_message) {}
+
+IamfStatus IamfStatus::OkStatus() { return IamfStatus(); }
+
+IamfStatus IamfStatus::ErrorStatus(const std::string& error_message) {
+  return IamfStatus(error_message);
+}
+
+std::ostream& operator<<(std::ostream& os, const IamfStatus& status) {
+  if (status.ok()) {
+    os << "Success\n";
+  } else {
+    os << "Failure: " << status.error_message << "\n";
+  }
+  return os;
+}
+
+}  // namespace api
+}  // namespace iamf_tools
diff --git a/iamf/api/internal_utils/BUILD b/iamf/api/internal_utils/BUILD
new file mode 100644
index 0000000..ce62aca
--- /dev/null
+++ b/iamf/api/internal_utils/BUILD
@@ -0,0 +1,41 @@
+load("@rules_cc//cc:cc_library.bzl", "cc_library")
+load("@rules_cc//cc:cc_test.bzl", "cc_test")
+
+# keep-sorted start block=yes prefix_order=cc_library,cc_test newline_separated=yes
+cc_library(
+    name = "internal_utils",
+    srcs = ["internal_utils.cc"],
+    hdrs = ["internal_utils.h"],
+    visibility = ["//iamf/cli/internal/decoder:__pkg__"],
+    deps = [
+        "//iamf/api:iamf_tools_api_types",
+        "//iamf/api/decoder:iamf_decoder",
+        "//iamf/cli:wav_writer",
+        "@com_google_absl//absl/log",
+        "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/types:span",
+    ],
+)
+
+cc_test(
+    name = "internal_utils_test",
+    srcs = ["internal_utils_test.cc"],
+    deps = [
+        ":internal_utils",
+        "//iamf/api:iamf_tools_api_types",
+        "//iamf/api/decoder:iamf_decoder",
+        "//iamf/cli:audio_element_with_data",
+        "//iamf/cli:wav_writer",
+        "//iamf/cli/tests:cli_test_utils",
+        "//iamf/obu:audio_frame",
+        "//iamf/obu:codec_config",
+        "//iamf/obu:ia_sequence_header",
+        "//iamf/obu:mix_presentation",
+        "//iamf/obu:obu_header",
+        "//iamf/obu:types",
+        "@com_google_absl//absl/container:flat_hash_map",
+        "@com_google_googletest//:gtest_main",
+    ],
+)
+
+# keep-sorted end
diff --git a/iamf/api/internal_utils/internal_utils.cc b/iamf/api/internal_utils/internal_utils.cc
new file mode 100644
index 0000000..78085f5
--- /dev/null
+++ b/iamf/api/internal_utils/internal_utils.cc
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#include "iamf/api/internal_utils/internal_utils.h"
+
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "absl/log/check.h"
+#include "absl/log/log.h"
+#include "absl/types/span.h"
+#include "iamf/cli/wav_writer.h"
+#include "iamf/include/iamf_tools/iamf_decoder.h"
+#include "iamf/include/iamf_tools/iamf_tools_api_types.h"
+
+namespace iamf_tools {
+
+// Configure the wav writer and reusable sample buffer, based on output
+// properties of the decoder.
+api::IamfStatus SetupAfterDescriptors(
+    const api::IamfDecoder& decoder, const std::string& output_filename,
+    std::unique_ptr<WavWriter>& wav_writer,
+    std::vector<uint8_t>& reusable_sample_buffer) {
+  // Gather statistics about the output.
+  uint32_t frame_size;
+  iamf_tools::api::IamfStatus frame_size_status =
+      decoder.GetFrameSize(frame_size);
+  if (!frame_size_status.ok()) {
+    return frame_size_status;
+  }
+  int sample_size_bytes = 0;
+  switch (decoder.GetOutputSampleType()) {
+    case iamf_tools::api::OutputSampleType::kInt16LittleEndian:
+      sample_size_bytes = 2;
+      break;
+    case iamf_tools::api::OutputSampleType::kInt32LittleEndian:
+      sample_size_bytes = 4;
+      break;
+    default:
+      return api::IamfStatus::ErrorStatus("Unsupported output sample type.");
+  }
+
+  int num_channels;
+  iamf_tools::api::IamfStatus num_channels_status =
+      decoder.GetNumberOfOutputChannels(num_channels);
+  if (!num_channels_status.ok()) {
+    return num_channels_status;
+  }
+  uint32_t sample_rate;
+  iamf_tools::api::IamfStatus sample_rate_status =
+      decoder.GetSampleRate(sample_rate);
+  if (!sample_rate_status.ok()) {
+    return sample_rate_status;
+  }
+
+  LOG(INFO) << "Output sample rate: " << sample_rate;
+  LOG(INFO) << "Output frame size: " << frame_size;
+  LOG(INFO) << "Output number of channels: " << num_channels;
+  LOG(INFO) << "Output sample size bytes: " << sample_size_bytes;
+
+  // Now that we know output properties, create the wav writer, and configure
+  // the size of the reusable sample buffer.
+  const int sample_size_bits = sample_size_bytes * 8;
+  wav_writer = WavWriter::Create(output_filename, num_channels, sample_rate,
+                                 sample_size_bits, frame_size,
+                                 /*write_wav_header=*/true);
+  if (wav_writer == nullptr) {
+    return api::IamfStatus::ErrorStatus("Failed to create wav writer.");
+  }
+  const size_t buffer_size_bytes =
+      frame_size * num_channels * sample_size_bytes;
+  reusable_sample_buffer.resize(buffer_size_bytes);
+  return api::IamfStatus::OkStatus();
+}
+
+api::IamfStatus DumpPendingTemporalUnitsToWav(
+    api::IamfDecoder& decoder, std::vector<uint8_t>& reusable_sample_buffer,
+    WavWriter& wav_writer, int32_t& output_num_temporal_units_processed) {
+  // We could have fed in multiple (or none) temporal units. Flush all
+  output_num_temporal_units_processed = 0;
+  while (decoder.IsTemporalUnitAvailable()) {
+    size_t bytes_written;
+    iamf_tools::api::IamfStatus decode_status = decoder.GetOutputTemporalUnit(
+        reusable_sample_buffer.data(), reusable_sample_buffer.size(),
+        bytes_written);
+    if (!decode_status.ok()) {
+      return decode_status;
+    }
+    // Write the valid portion of the buffer to a wav file.
+    const auto valid_span =
+        absl::MakeConstSpan(reusable_sample_buffer).first(bytes_written);
+    absl::Status absl_status = wav_writer.WritePcmSamples(valid_span);
+    if (!absl_status.ok()) {
+      return api::IamfStatus::ErrorStatus("Failed to write to wav writer");
+    }
+    output_num_temporal_units_processed++;
+  }
+  return api::IamfStatus::OkStatus();
+}
+
+}  // namespace iamf_tools
diff --git a/iamf/api/internal_utils/internal_utils.h b/iamf/api/internal_utils/internal_utils.h
new file mode 100644
index 0000000..91b47e7
--- /dev/null
+++ b/iamf/api/internal_utils/internal_utils.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#ifndef API_INTERNAL_UTILS_INTERNAL_UTILS_H_
+#define API_INTERNAL_UTILS_INTERNAL_UTILS_H_
+
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "iamf/cli/wav_writer.h"
+#include "iamf/include/iamf_tools/iamf_decoder.h"
+#include "iamf/include/iamf_tools/iamf_tools_api_types.h"
+namespace iamf_tools {
+
+/*!\ This file contains utility functions that use the public iamf_decoder
+ * API to perform internal tasks. This is not intended to be used by external
+ * clients.
+ * /
+
+/*!\brief Configures the wav writer and output sample buffer.
+ *
+ * Configuration is based on the output properties of the decoder.
+ *
+ * \param decoder Decoder used to determine output properties.
+ * \param output_filename Filename to use for the wav writer.
+ * \param wav_writer Wav writer to configure.
+ * \param reusable_sample_buffer Sample buffer to configure.
+ */
+api::IamfStatus SetupAfterDescriptors(
+    const api::IamfDecoder& decoder, const std::string& output_filename,
+    std::unique_ptr<WavWriter>& wav_writer,
+    std::vector<uint8_t>& reusable_sample_buffer);
+
+/*!\brief Dump all pending temporal units from the decoder to the wav writer.
+ *
+ * \param decoder Decoder which holds the pending temporal units.
+ * \param reusable_sample_buffer Buffer into which the decoder will write
+ *        decoded temporal units.
+ * \param wav_writer Wav writer to write to.
+ * \param output_num_temporal_units_processed Number of temporal units
+ *        processed.
+ */
+api::IamfStatus DumpPendingTemporalUnitsToWav(
+    api::IamfDecoder& decoder, std::vector<uint8_t>& reusable_sample_buffer,
+    WavWriter& wav_writer, int32_t& output_num_temporal_units_processed);
+
+}  // namespace iamf_tools
+
+#endif  // API_INTERNAL_UTILS_INTERNAL_UTILS_H_
diff --git a/iamf/api/internal_utils/internal_utils_test.cc b/iamf/api/internal_utils/internal_utils_test.cc
new file mode 100644
index 0000000..16c4f36
--- /dev/null
+++ b/iamf/api/internal_utils/internal_utils_test.cc
@@ -0,0 +1,207 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#include "iamf/api/internal_utils/internal_utils.h"
+
+#include <array>
+#include <cstdint>
+#include <list>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "absl/container/flat_hash_map.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+#include "iamf/cli/audio_element_with_data.h"
+#include "iamf/cli/tests/cli_test_utils.h"
+#include "iamf/cli/wav_writer.h"
+#include "iamf/include/iamf_tools/iamf_decoder.h"
+#include "iamf/include/iamf_tools/iamf_tools_api_types.h"
+#include "iamf/obu/audio_frame.h"
+#include "iamf/obu/codec_config.h"
+#include "iamf/obu/ia_sequence_header.h"
+#include "iamf/obu/mix_presentation.h"
+#include "iamf/obu/obu_header.h"
+#include "iamf/obu/types.h"
+
+namespace iamf_tools {
+namespace {
+
+using api::IamfDecoder;
+using api::OutputLayout;
+
+constexpr DecodedUleb128 kFirstCodecConfigId = 1;
+constexpr uint32_t kNumSamplesPerFrame = 8;
+constexpr uint32_t kBitDepth = 16;
+constexpr DecodedUleb128 kSampleRate = 48000;
+constexpr DecodedUleb128 kFirstAudioElementId = 2;
+constexpr DecodedUleb128 kFirstSubstreamId = 18;
+constexpr DecodedUleb128 kFirstMixPresentationId = 3;
+constexpr DecodedUleb128 kCommonMixGainParameterId = 999;
+constexpr DecodedUleb128 kCommonParameterRate = kSampleRate;
+constexpr std::array<uint8_t, 16> kEightSampleAudioFrame = {
+    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
+
+std::vector<uint8_t> GenerateBasicDescriptorObus() {
+  const IASequenceHeaderObu ia_sequence_header(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
+  absl::flat_hash_map<DecodedUleb128, CodecConfigObu> codec_configs;
+  AddLpcmCodecConfig(kFirstCodecConfigId, kNumSamplesPerFrame, kBitDepth,
+                     kSampleRate, codec_configs);
+  absl::flat_hash_map<DecodedUleb128, AudioElementWithData> audio_elements;
+  AddAmbisonicsMonoAudioElementWithSubstreamIds(
+      kFirstAudioElementId, kFirstCodecConfigId, {kFirstSubstreamId},
+      codec_configs, audio_elements);
+  std::list<MixPresentationObu> mix_presentation_obus;
+  AddMixPresentationObuWithAudioElementIds(
+      kFirstMixPresentationId, {kFirstAudioElementId},
+      kCommonMixGainParameterId, kCommonParameterRate, mix_presentation_obus);
+  return SerializeObusExpectOk({&ia_sequence_header,
+                                &codec_configs.at(kFirstCodecConfigId),
+                                &audio_elements.at(kFirstAudioElementId).obu,
+                                &mix_presentation_obus.front()});
+}
+
+TEST(SetUpAfterDescriptors, SetsWavWriterAndSampleBuffer) {
+  auto bitstream = GenerateBasicDescriptorObus();
+  std::unique_ptr<IamfDecoder> decoder;
+  iamf_tools::api::IamfStatus status = IamfDecoder::CreateFromDescriptors(
+      IamfDecoder::Settings{.requested_layout =
+                                OutputLayout::kItu2051_SoundSystemA_0_2_0},
+      bitstream.data(), bitstream.size(), decoder);
+  OutputLayout output_layout;
+  ASSERT_TRUE(decoder->GetOutputLayout(output_layout).ok());
+  ASSERT_THAT(output_layout, OutputLayout::kItu2051_SoundSystemA_0_2_0);
+  decoder->ConfigureOutputSampleType(
+      iamf_tools::api::OutputSampleType::kInt16LittleEndian);
+
+  std::unique_ptr<WavWriter> wav_writer;
+  std::vector<uint8_t> reusable_sample_buffer;
+  auto iamf_status =
+      SetupAfterDescriptors(*decoder, GetAndCleanupOutputFileName("test.wav"),
+                            wav_writer, reusable_sample_buffer);
+
+  EXPECT_TRUE(iamf_status.ok());
+  constexpr int kSampleSizeBytesFor16Bit = 2;
+  constexpr int kNumChannels = 2;
+  EXPECT_EQ(wav_writer->bit_depth(), kSampleSizeBytesFor16Bit * 8);
+  EXPECT_EQ(reusable_sample_buffer.size(),
+            kNumSamplesPerFrame * kNumChannels * kSampleSizeBytesFor16Bit);
+}
+
+TEST(SetUpAfterDescriptors, FailsWithInvalidWavWriter) {
+  auto bitstream = GenerateBasicDescriptorObus();
+  std::unique_ptr<IamfDecoder> decoder;
+  iamf_tools::api::IamfStatus status = IamfDecoder::CreateFromDescriptors(
+      IamfDecoder::Settings{.requested_layout =
+                                OutputLayout::kItu2051_SoundSystemA_0_2_0},
+      bitstream.data(), bitstream.size(), decoder);
+  std::unique_ptr<WavWriter> wav_writer;
+  std::vector<uint8_t> reusable_sample_buffer;
+
+  // A filename which cannot be written to on most platforms.
+  const std::string kBadFileName = "";
+  auto iamf_status = SetupAfterDescriptors(*decoder, kBadFileName, wav_writer,
+                                           reusable_sample_buffer);
+  EXPECT_FALSE(iamf_status.ok());
+}
+
+TEST(DumpPendingTemporalUnitsToWav, SucceedsWithNoTemporalUnits) {
+  auto bitstream = GenerateBasicDescriptorObus();
+  std::unique_ptr<IamfDecoder> decoder;
+  iamf_tools::api::IamfStatus status = IamfDecoder::CreateFromDescriptors(
+      IamfDecoder::Settings{.requested_layout =
+                                OutputLayout::kItu2051_SoundSystemA_0_2_0},
+      bitstream.data(), bitstream.size(), decoder);
+  std::unique_ptr<WavWriter> wav_writer;
+  std::vector<uint8_t> reusable_sample_buffer;
+  ASSERT_TRUE(SetupAfterDescriptors(*decoder,
+                                    GetAndCleanupOutputFileName("test.wav"),
+                                    wav_writer, reusable_sample_buffer)
+                  .ok());
+  int32_t num_temporal_units_processed;
+  auto iamf_status =
+      DumpPendingTemporalUnitsToWav(*decoder, reusable_sample_buffer,
+                                    *wav_writer, num_temporal_units_processed);
+  EXPECT_TRUE(iamf_status.ok());
+  EXPECT_EQ(num_temporal_units_processed, 0);
+}
+
+TEST(DumpPendingTemporalUnitsToWav,
+     SucceedsWithVariousTemporalUnitsInSequence) {
+  auto bitstream = GenerateBasicDescriptorObus();
+  std::unique_ptr<IamfDecoder> decoder;
+  iamf_tools::api::IamfStatus status = IamfDecoder::CreateFromDescriptors(
+      IamfDecoder::Settings{.requested_layout =
+                                OutputLayout::kItu2051_SoundSystemA_0_2_0},
+      bitstream.data(), bitstream.size(), decoder);
+  std::unique_ptr<WavWriter> wav_writer;
+  std::vector<uint8_t> reusable_sample_buffer;
+  ASSERT_TRUE(SetupAfterDescriptors(*decoder,
+                                    GetAndCleanupOutputFileName("test.wav"),
+                                    wav_writer, reusable_sample_buffer)
+                  .ok());
+
+  AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
+                            kEightSampleAudioFrame);
+  std::vector<uint8_t> temporal_unit = SerializeObusExpectOk({&audio_frame});
+
+  // Decode the first temporal unit.
+  EXPECT_TRUE(decoder->Decode(temporal_unit.data(), temporal_unit.size()).ok());
+  int32_t num_temporal_units_processed;
+  auto iamf_status_first_unit =
+      DumpPendingTemporalUnitsToWav(*decoder, reusable_sample_buffer,
+                                    *wav_writer, num_temporal_units_processed);
+  EXPECT_TRUE(iamf_status_first_unit.ok());
+  EXPECT_EQ(num_temporal_units_processed, 1);
+  // Decode another temporal unit.
+  EXPECT_TRUE(decoder->Decode(temporal_unit.data(), temporal_unit.size()).ok());
+  auto iamf_status_second_unit =
+      DumpPendingTemporalUnitsToWav(*decoder, reusable_sample_buffer,
+                                    *wav_writer, num_temporal_units_processed);
+  EXPECT_TRUE(iamf_status_second_unit.ok());
+  EXPECT_EQ(num_temporal_units_processed, 1);
+}
+
+TEST(DumpPendingTemporalUnitsToWav, SucceedsWithVariousTemporalUnitsAtOnce) {
+  auto bitstream = GenerateBasicDescriptorObus();
+  std::unique_ptr<IamfDecoder> decoder;
+  iamf_tools::api::IamfStatus status = IamfDecoder::CreateFromDescriptors(
+      IamfDecoder::Settings{.requested_layout =
+                                OutputLayout::kItu2051_SoundSystemA_0_2_0},
+      bitstream.data(), bitstream.size(), decoder);
+  std::unique_ptr<WavWriter> wav_writer;
+  std::vector<uint8_t> reusable_sample_buffer;
+  ASSERT_TRUE(SetupAfterDescriptors(*decoder,
+                                    GetAndCleanupOutputFileName("test.wav"),
+                                    wav_writer, reusable_sample_buffer)
+                  .ok());
+
+  AudioFrameObu audio_frame(ObuHeader(), kFirstSubstreamId,
+                            kEightSampleAudioFrame);
+  std::vector<uint8_t> temporal_unit = SerializeObusExpectOk({&audio_frame});
+
+  // Decode the first temporal unit.
+  EXPECT_TRUE(decoder->Decode(temporal_unit.data(), temporal_unit.size()).ok());
+  EXPECT_TRUE(decoder->Decode(temporal_unit.data(), temporal_unit.size()).ok());
+  int32_t num_temporal_units_processed;
+  auto iamf_status =
+      DumpPendingTemporalUnitsToWav(*decoder, reusable_sample_buffer,
+                                    *wav_writer, num_temporal_units_processed);
+  EXPECT_TRUE(iamf_status.ok());
+  EXPECT_EQ(num_temporal_units_processed, 2);
+}
+
+}  // namespace
+}  // namespace iamf_tools
diff --git a/iamf/api/types.h b/iamf/api/types.h
deleted file mode 100644
index 76a7f85..0000000
--- a/iamf/api/types.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (c) 2025, Alliance for Open Media. All rights reserved
- *
- * This source code is subject to the terms of the BSD 3-Clause Clear License
- * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
- * License was not distributed with this source code in the LICENSE file, you
- * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
- * Alliance for Open Media Patent License 1.0 was not distributed with this
- * source code in the PATENTS file, you can obtain it at
- * www.aomedia.org/license/patent.
- */
-
-#ifndef API_DECODER_TYPES_H_
-#define API_DECODER_TYPES_H_
-
-#include <cstdint>
-#include <string>
-#include <vector>
-
-namespace iamf_tools {
-namespace api {
-
-// TODO(b/339500539): Add support for other IAMF supported layouts
-/*!\brief Determines the layout of the output file.
- *
- * Typically these correspond with `sound_system`s in the IAMF spec
- * (https://aomediacodec.github.io/iamf/#syntax-layout).
- */
-enum class OutputLayout {
-  // ITU-R B.S. 2051-3 sound system A (0+2+0), commonly known as Stereo.
-  kItu2051_SoundSystemA_0_2_0 = 0,
-  // ITU-R B.S. 2051-3 sound system B (0+5+0), commonly known as 5.1.
-  kItu2051_SoundSystemB_0_5_0 = 1,
-  // ITU-R B.S. 2051-3 sound system C (2+5+0), commonly known as 5.1.2.
-  kItu2051_SoundSystemC_2_5_0 = 2,
-  // ITU-R B.S. 2051-3 sound system D (4+5+0), commonly known as 5.1.4.
-  kItu2051_SoundSystemD_4_5_0 = 3,
-  // ITU-R B.S. 2051-3 sound system E (4+5+1).
-  kItu2051_SoundSystemE_4_5_1 = 4,
-  // ITU-R B.S. 2051-3 sound system F (3+7+0).
-  kItu2051_SoundSystemF_3_7_0 = 5,
-  // ITU-R B.S. 2051-3 sound system G (4+9+0).
-  kItu2051_SoundSystemG_4_9_0 = 6,
-  // ITU-R B.S. 2051-3 sound system H (9+10+3).
-  kItu2051_SoundSystemH_9_10_3 = 7,
-  // ITU-R B.S. 2051-3 sound system I (0+7+0), commonly known as 7.1.
-  kItu2051_SoundSystemI_0_7_0 = 8,
-  // ITU-R B.S. 2051-3 sound system J (4+7+0), commonly known as 7.1.4.
-  kItu2051_SoundSystemJ_4_7_0 = 9,
-  // IAMF extension 7.1.2.
-  kIAMF_SoundSystemExtension_2_7_0 = 10,
-  // IAMF extension 3.1.2.
-  kIAMF_SoundSystemExtension_2_3_0 = 11,
-  // Mono.
-  kIAMF_SoundSystemExtension_0_1_0 = 12,
-  // IAMF Extension 9.1.6.
-  kIAMF_SoundSystemExtension_6_9_0 = 13,
-};
-
-/*!\brief The requested format of the output samples. */
-enum class OutputSampleType {
-  kInt16LittleEndian = 1,
-  kInt32LittleEndian = 2,
-};
-
-/*!\brief A unique identifier for a `MixPresentation` in the IAMF stream. */
-using MixPresentationId = uint32_t;
-
-/*!\brief A name:value tag describing a `MixPresentation` in the IAMF stream. */
-struct MixPresentationTag {
-  std::string tag_name;
-  std::string tag_value;
-};
-
-/*!\brief Metadata that describes a mix presentation.
- *
- * Used by a user to determine which mix presentation they would like to
- * configure the decoder with.
- */
-struct MixPresentationMetadata {
-  MixPresentationId id;
-  std::vector<MixPresentationTag> tags;
-};
-
-}  // namespace api
-}  // namespace iamf_tools
-
-#endif  // API_DECODER_TYPES_H_
diff --git a/iamf/cli/BUILD b/iamf/cli/BUILD
index 5791758..05dfa73 100644
--- a/iamf/cli/BUILD
+++ b/iamf/cli/BUILD
@@ -47,9 +47,12 @@ cc_library(
         "//iamf/obu:parameter_data",
         "//iamf/obu:types",
         "@com_google_absl//absl/container:node_hash_map",
+        "@com_google_absl//absl/log",
+        "@com_google_absl//absl/log:check",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
+        "@com_google_absl//absl/types:span",
     ],
 )
 
@@ -131,6 +134,7 @@ cc_library(
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
+        "@com_google_absl//absl/types:span",
     ],
 )
 
@@ -147,11 +151,15 @@ cc_library(
         ":obu_sequencer_base",
         ":parameter_block_partitioner",
         ":parameter_block_with_data",
+        ":rendering_mix_presentation_finalizer",
+        ":sample_processor_base",
         ":wav_sample_provider",
         ":wav_writer",
+        "//iamf/cli/proto:encoder_control_metadata_cc_proto",
         "//iamf/cli/proto:temporal_delimiter_cc_proto",
         "//iamf/cli/proto:test_vector_metadata_cc_proto",
         "//iamf/cli/proto:user_metadata_cc_proto",
+        "//iamf/cli/proto_conversion:output_audio_format_utils",
         "//iamf/common/utils:macros",
         "//iamf/obu:arbitrary_obu",
         "//iamf/obu:codec_config",
@@ -197,6 +205,7 @@ cc_library(
         ":obu_sequencer_base",
         ":obu_sequencer_iamf",
         ":renderer_factory",
+        "//iamf/cli/itu_1770_4:loudness_calculator_factory_itu_1770_4",
         "//iamf/cli/proto:mix_presentation_cc_proto",
         "//iamf/cli/proto:test_vector_metadata_cc_proto",
         "//iamf/cli/proto:user_metadata_cc_proto",
@@ -303,6 +312,7 @@ cc_library(
         "//iamf/obu:parameter_block",
         "//iamf/obu:temporal_delimiter",
         "//iamf/obu:types",
+        "@com_google_absl//absl/base:nullability",
         "@com_google_absl//absl/container:flat_hash_map",
         "@com_google_absl//absl/container:flat_hash_set",
         "@com_google_absl//absl/log",
@@ -359,6 +369,22 @@ cc_library(
         "//iamf/common:leb_generator",
         "//iamf/common:write_bit_buffer",
         "//iamf/common/utils:macros",
+        "//iamf/obu:types",
+        "@com_google_absl//absl/log",
+        "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/types:span",
+    ],
+)
+
+cc_library(
+    name = "obu_sequencer_streaming_iamf",
+    srcs = ["obu_sequencer_streaming_iamf.cc"],
+    hdrs = ["obu_sequencer_streaming_iamf.h"],
+    deps = [
+        ":obu_sequencer_base",
+        "//iamf/common:leb_generator",
+        "//iamf/obu:types",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/log:check",
         "@com_google_absl//absl/status",
@@ -481,6 +507,7 @@ cc_library(
         "@com_google_absl//absl/container:flat_hash_map",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/status",
+        "@com_google_absl//absl/types:span",
     ],
 )
 
@@ -544,6 +571,8 @@ cc_library(
     srcs = ["sample_processor_base.cc"],
     hdrs = ["sample_processor_base.h"],
     deps = [
+        "//iamf/common/utils:macros",
+        "//iamf/common/utils:validation_utils",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/types:span",
diff --git a/iamf/cli/audio_frame_decoder.cc b/iamf/cli/audio_frame_decoder.cc
index a10a1bb..9cf5ab1 100644
--- a/iamf/cli/audio_frame_decoder.cc
+++ b/iamf/cli/audio_frame_decoder.cc
@@ -14,7 +14,8 @@
 #include <memory>
 #include <utility>
 
-#include "absl/container/node_hash_map.h"
+#include "absl/log/check.h"
+#include "absl/log/log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -44,52 +45,42 @@ namespace iamf_tools {
 
 namespace {
 
-absl::Status InitializeDecoder(const CodecConfigObu& codec_config,
-                               int num_channels,
-                               std::unique_ptr<DecoderBase>& decoder) {
+absl::StatusOr<std::unique_ptr<DecoderBase>> CreateDecoder(
+    const CodecConfigObu& codec_config, int num_channels) {
   switch (codec_config.GetCodecConfig().codec_id) {
     using enum CodecConfig::CodecId;
     case kCodecIdLpcm:
-      decoder = std::make_unique<LpcmDecoder>(codec_config, num_channels);
-      break;
+      return LpcmDecoder::Create(codec_config, num_channels);
 #ifndef IAMF_TOOLS_DISABLE_OPUS_DECODER
     case kCodecIdOpus:
-      decoder = std::make_unique<OpusDecoder>(codec_config, num_channels);
-      break;
+      return OpusDecoder::Create(codec_config, num_channels);
 #endif
 #ifndef IAMF_TOOLS_DISABLE_AAC_DECODER
     case kCodecIdAacLc:
-      decoder = std::make_unique<AacDecoder>(codec_config, num_channels);
-      break;
+      return AacDecoder::Create(codec_config, num_channels);
 #endif
 #ifndef IAMF_TOOLS_DISABLE_FLAC_DECODER
     case kCodecIdFlac:
-      decoder = std::make_unique<FlacDecoder>(
-          num_channels, codec_config.GetNumSamplesPerFrame());
-      break;
+      return FlacDecoder::Create(num_channels,
+                                 codec_config.GetNumSamplesPerFrame());
 #endif
     default:
       return absl::InvalidArgumentError(
           absl::StrCat("Unrecognized or disabled codec_id= ",
                        codec_config.GetCodecConfig().codec_id));
   }
-
-  if (decoder) {
-    RETURN_IF_NOT_OK(decoder->Initialize());
-  }
-  return absl::OkStatus();
 }
 
 }  // namespace
 
-// Initializes all decoders and wav writers based on the corresponding Audio
-// Element and Codec Config OBUs.
+// Initializes all decoders based on the corresponding Audio Element and Codec
+// Config OBUs.
 absl::Status AudioFrameDecoder::InitDecodersForSubstreams(
     const SubstreamIdLabelsMap& substream_id_to_labels,
     const CodecConfigObu& codec_config) {
   for (const auto& [substream_id, labels] : substream_id_to_labels) {
-    auto& decoder = substream_id_to_decoder_[substream_id];
-    if (decoder != nullptr) {
+    auto& decoder_for_substream = substream_id_to_decoder_[substream_id];
+    if (decoder_for_substream != nullptr) {
       return absl::InvalidArgumentError(absl::StrCat(
           "Already initialized decoder for substream ID: ", substream_id,
           ". Maybe multiple Audio Element OBUs have the same substream ID?"));
@@ -97,9 +88,16 @@ absl::Status AudioFrameDecoder::InitDecodersForSubstreams(
 
     const int num_channels = static_cast<int>(labels.size());
 
-    // Initialize the decoder based on the found Codec Config OBU and number
-    // of channels.
-    RETURN_IF_NOT_OK(InitializeDecoder(codec_config, num_channels, decoder));
+    // Create the decoder, unwrap it and move it into the map, if it is valid.
+    absl::StatusOr<std::unique_ptr<DecoderBase>> new_decoder =
+        CreateDecoder(codec_config, num_channels);
+    if (!new_decoder.ok()) {
+      return new_decoder.status();
+    }
+    // The factories are not supposed to return an OK and `nullptr` decoder.
+    // For defensive programming, check for that case.
+    CHECK_NE(*new_decoder, nullptr);
+    decoder_for_substream = std::move(*new_decoder);
   }
 
   return absl::OkStatus();
diff --git a/iamf/cli/audio_frame_decoder.h b/iamf/cli/audio_frame_decoder.h
index 537520c..4f3ef16 100644
--- a/iamf/cli/audio_frame_decoder.h
+++ b/iamf/cli/audio_frame_decoder.h
@@ -19,6 +19,7 @@
 #include "absl/container/node_hash_map.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
+#include "absl/types/span.h"
 #include "iamf/cli/audio_element_with_data.h"
 #include "iamf/cli/audio_frame_with_data.h"
 #include "iamf/cli/codec/decoder_base.h"
@@ -39,7 +40,10 @@ struct DecodedAudioFrame {
   uint32_t samples_to_trim_at_start;
 
   // Decoded samples. Includes any samples that will be trimmed in processing.
-  std::vector<std::vector<int32_t>> decoded_samples;
+  // Points to the memory location where samples were first produced.
+  // TODO(b/4107595837): Find a more robust data model so that the span is
+  //                     guaranteed to point to correct samples.
+  absl::Span<const std::vector<int32_t>> decoded_samples;
 
   // Down-mixing parameters used to create this audio frame.
   DownMixingParams down_mixing_params;
diff --git a/iamf/cli/cli_util.cc b/iamf/cli/cli_util.cc
index 5e6e554..2815087 100644
--- a/iamf/cli/cli_util.cc
+++ b/iamf/cli/cli_util.cc
@@ -192,13 +192,16 @@ absl::Status WritePcmFrameToBuffer(
   }
   const size_t num_samples = frame.size() * frame[0].size();
   buffer.resize(num_samples * (bit_depth / 8));
+  if (num_samples == 0) {
+    return absl::OkStatus();
+  }
 
-  // The input frame is arranged in (time, channel) axes. Interlace these in
+  // The input frame is arranged in (channel, time) axes. Interlace these in
   // the output PCM.
   size_t write_position = 0;
-  for (int t = 0; t < frame.size(); t++) {
-    for (int c = 0; c < frame[0].size(); ++c) {
-      const uint32_t sample = static_cast<uint32_t>(frame[t][c]);
+  for (int t = 0; t < frame[0].size(); ++t) {
+    for (int c = 0; c < frame.size(); c++) {
+      const uint32_t sample = static_cast<uint32_t>(frame[c][t]);
       RETURN_IF_NOT_OK(WritePcmSample(sample, bit_depth, big_endian,
                                       buffer.data(), write_position));
     }
diff --git a/iamf/cli/cli_util.h b/iamf/cli/cli_util.h
index f28d238..5947a70 100644
--- a/iamf/cli/cli_util.h
+++ b/iamf/cli/cli_util.h
@@ -89,7 +89,7 @@ absl::Status CompareTimestamps(InternalTimestamp expected_timestamp,
 
 /*!\brief Writes interlaced PCM samples into the output buffer.
  *
- * \param frame Input frames arranged in (time, channel) axes.
+ * \param frame Input frames arranged in (channel, time) axes.
  * \param bit_depth Sample size in bits.
  * \param big_endian Whether the sample should be written as big or little
  *        endian.
diff --git a/iamf/cli/codec/BUILD b/iamf/cli/codec/BUILD
index 8824237..dce90bf 100644
--- a/iamf/cli/codec/BUILD
+++ b/iamf/cli/codec/BUILD
@@ -15,9 +15,13 @@ cc_library(
         "//iamf/common/utils:sample_processing_utils",
         "//iamf/obu:codec_config",
         "//iamf/obu/decoder_config:aac_decoder_config",
+        "@com_google_absl//absl/base:nullability",
         "@com_google_absl//absl/functional:any_invocable",
         "@com_google_absl//absl/log",
+        "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/memory",
         "@com_google_absl//absl/status",
+        "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/strings:string_view",
         "@com_google_absl//absl/types:span",
@@ -60,7 +64,11 @@ cc_library(
 cc_library(
     name = "decoder_base",
     hdrs = ["decoder_base.h"],
-    deps = ["@com_google_absl//absl/status"],
+    deps = [
+        "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/types:span",
+    ],
 )
 
 cc_library(
@@ -85,8 +93,12 @@ cc_library(
     hdrs = ["flac_decoder.h"],
     deps = [
         ":decoder_base",
-        "@com_google_absl//absl/log",
+        ":flac_decoder_stream_callbacks",
+        "@com_google_absl//absl/base:nullability",
+        "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/memory",
         "@com_google_absl//absl/status",
+        "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@flac//:src",
     ],
@@ -97,8 +109,8 @@ cc_library(
     srcs = ["flac_decoder_stream_callbacks.cc"],
     hdrs = ["flac_decoder_stream_callbacks.h"],
     deps = [
-        ":flac_decoder",
         "@com_google_absl//absl/log",
+        "@com_google_absl//absl/types:span",
         "@flac//:src",
     ],
 )
@@ -137,7 +149,9 @@ cc_library(
         "//iamf/common/utils:numeric_utils",
         "//iamf/obu:codec_config",
         "//iamf/obu/decoder_config:lpcm_decoder_config",
+        "@com_google_absl//absl/memory",
         "@com_google_absl//absl/status",
+        "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/types:span",
     ],
@@ -173,9 +187,13 @@ cc_library(
         "//iamf/common/utils:sample_processing_utils",
         "//iamf/obu:codec_config",
         "//iamf/obu/decoder_config:opus_decoder_config",
+        "@com_google_absl//absl/base:nullability",
         "@com_google_absl//absl/functional:any_invocable",
         "@com_google_absl//absl/log",
+        "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/memory",
         "@com_google_absl//absl/status",
+        "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/types:span",
         "@libopus",
diff --git a/iamf/cli/codec/aac_decoder.cc b/iamf/cli/codec/aac_decoder.cc
index 668b09a..08aeb5f 100644
--- a/iamf/cli/codec/aac_decoder.cc
+++ b/iamf/cli/codec/aac_decoder.cc
@@ -15,9 +15,13 @@
 #include <cstddef>
 #include <cstdint>
 #include <cstdlib>
+#include <memory>
+#include <variant>
 #include <vector>
 
 #include "absl/functional/any_invocable.h"
+#include "absl/log/check.h"
+#include "absl/memory/memory.h"
 #include "absl/types/span.h"
 #include "iamf/common/utils/sample_processing_utils.h"
 
@@ -138,40 +142,46 @@ absl::Status ConfigureAacDecoder(const AacDecoderConfig& raw_aac_decoder_config,
 
 }  // namespace
 
-AacDecoder::AacDecoder(const CodecConfigObu& codec_config_obu, int num_channels)
-    : DecoderBase(num_channels,
-                  static_cast<int>(codec_config_obu.GetNumSamplesPerFrame())),
-      aac_decoder_config_(std::get<AacDecoderConfig>(
-          codec_config_obu.GetCodecConfig().decoder_config)) {}
-
-AacDecoder::~AacDecoder() {
-  if (decoder_ != nullptr) {
-    aacDecoder_Close(decoder_);
+absl::StatusOr<std::unique_ptr<DecoderBase>> AacDecoder::Create(
+    const CodecConfigObu& codec_config_obu, int num_channels) {
+  const AacDecoderConfig* decoder_config = std::get_if<AacDecoderConfig>(
+      &codec_config_obu.GetCodecConfig().decoder_config);
+  if (decoder_config == nullptr) {
+    return absl::InvalidArgumentError(
+        "CodecConfigObu does not contain an `AacDecoderConfig`.");
   }
-}
 
-absl::Status AacDecoder::Initialize() {
   // Initialize the decoder.
-  decoder_ = aacDecoder_Open(GetAacTransportationType(), /*nrOfLayers=*/1);
+  AAC_DECODER_INSTANCE* decoder =
+      aacDecoder_Open(GetAacTransportationType(), /*nrOfLayers=*/1);
 
-  if (decoder_ == nullptr) {
+  if (decoder == nullptr) {
     return absl::UnknownError("Failed to initialize AAC decoder.");
   }
 
-  RETURN_IF_NOT_OK(
-      ConfigureAacDecoder(aac_decoder_config_, num_channels_, decoder_));
+  const auto status =
+      ConfigureAacDecoder(*decoder_config, num_channels, decoder);
+  if (!status.ok()) {
+    aacDecoder_Close(decoder);
+    return status;
+  }
 
-  const auto* stream_info = aacDecoder_GetStreamInfo(decoder_);
-  LOG_FIRST_N(INFO, 1) << "Created an AAC encoder with "
+  const auto* stream_info = aacDecoder_GetStreamInfo(decoder);
+  LOG_FIRST_N(INFO, 1) << "Created an AAC decoder with "
                        << stream_info->numChannels << " channels.";
 
-  return absl::OkStatus();
+  return absl::WrapUnique(new AacDecoder(
+      num_channels, codec_config_obu.GetNumSamplesPerFrame(), decoder));
+}
+
+AacDecoder::~AacDecoder() {
+  // The factory function prevents `decoder_` from ever being null.
+  CHECK_NE(decoder_, nullptr);
+  aacDecoder_Close(decoder_);
 }
 
 absl::Status AacDecoder::DecodeAudioFrame(
     const std::vector<uint8_t>& encoded_frame) {
-  num_valid_ticks_ = 0;
-
   // Transform the data and feed it to the decoder.
   std::vector<UCHAR> input_data(encoded_frame.size());
   std::transform(encoded_frame.begin(), encoded_frame.end(), input_data.begin(),
@@ -189,6 +199,7 @@ absl::Status AacDecoder::DecodeAudioFrame(
         "complete AAC frame.");
   }
 
+  // TODO(b/382197581): Avoid re-allocations of `output_pcm`.
   // Retrieve the decoded frame. `fdk_aac` decodes to INT_PCM (usually 16-bits)
   // samples with channels interlaced.
   std::vector<INT_PCM> output_pcm(num_samples_per_channel_ * num_channels_);
@@ -197,16 +208,16 @@ absl::Status AacDecoder::DecodeAudioFrame(
                              /*flags=*/0),
       "Failed on `aacDecoder_DecodeFrame`: "));
 
-  // Arrange the interleaved data in (time, channel) axes with samples stored in
+  // Arrange the interleaved data in (channel, time) axes with samples stored in
   // the upper bytes of an `int32_t`.
   const absl::AnyInvocable<absl::Status(INT_PCM, int32_t&) const>
       kAacInternalTypeToInt32 = [](INT_PCM input, int32_t& output) {
         output = static_cast<int32_t>(input) << (32 - GetFdkAacBitDepth());
         return absl::OkStatus();
       };
-  return ConvertInterleavedToTimeChannel(absl::MakeConstSpan(output_pcm),
+  return ConvertInterleavedToChannelTime(absl::MakeConstSpan(output_pcm),
                                          num_channels_, kAacInternalTypeToInt32,
-                                         decoded_samples_, num_valid_ticks_);
+                                         decoded_samples_);
 }
 
 }  // namespace iamf_tools
diff --git a/iamf/cli/codec/aac_decoder.h b/iamf/cli/codec/aac_decoder.h
index 4b6b842..f407936 100644
--- a/iamf/cli/codec/aac_decoder.h
+++ b/iamf/cli/codec/aac_decoder.h
@@ -13,8 +13,12 @@
 #define CLI_AAC_ENCODER_DECODER_H_
 
 #include <cstdint>
+#include <memory>
 #include <vector>
 
+#include "absl/base/nullability.h"
+#include "absl/status/statusor.h"
+
 // This symbol conflicts with a macro in fdk_aac.
 #ifdef IS_LITTLE_ENDIAN
 #undef IS_LITTLE_ENDIAN
@@ -23,7 +27,6 @@
 #include "absl/status/status.h"
 #include "iamf/cli/codec/decoder_base.h"
 #include "iamf/obu/codec_config.h"
-#include "iamf/obu/decoder_config/aac_decoder_config.h"
 #include "libAACdec/include/aacdecoder_lib.h"
 
 namespace iamf_tools {
@@ -31,23 +34,18 @@ namespace iamf_tools {
 // TODO(b/277731089): Test all of `aac_encoder_decoder.h`.
 class AacDecoder : public DecoderBase {
  public:
-  /*!\brief Constructor.
+  /*!brief Factory function.
    *
-   * \param codec_config_obu Codec Config OBU with initialization settings.
+   * \param codec_config_obu Codec config for this stream.
    * \param num_channels Number of channels for this stream.
+   * \return AAC decoder on success. A specific status on failure.
    */
-  AacDecoder(const CodecConfigObu& codec_config_obu, int num_channels);
+  static absl::StatusOr<std::unique_ptr<DecoderBase>> Create(
+      const CodecConfigObu& codec_config_obu, int num_channels);
 
   /*!\brief Destructor.
    */
   ~AacDecoder() override;
-
-  /*!\brief Initializes the underlying decoder.
-   *
-   * \return `absl::OkStatus()` on success. A specific status on failure.
-   */
-  absl::Status Initialize() override;
-
   /*!\brief Decodes an AAC audio frame.
    *
    * \param encoded_frame Frame to decode.
@@ -57,8 +55,19 @@ class AacDecoder : public DecoderBase {
       const std::vector<uint8_t>& encoded_frame) override;
 
  private:
-  const AacDecoderConfig& aac_decoder_config_;
-  AAC_DECODER_INSTANCE* decoder_ = nullptr;
+  /* Private constructor.
+   *
+   * Used only by the factory function.
+   *
+   * \param num_channels Number of channels for this stream.
+   * \param num_samples_per_frame Number of samples per frame for this stream.
+   * \param decoder `fdk_aac` decoder to use.
+   */
+  AacDecoder(int num_channels, uint32_t num_samples_per_frame,
+             AAC_DECODER_INSTANCE* /* absl_nonnull */ decoder)
+      : DecoderBase(num_channels, num_samples_per_frame), decoder_(decoder) {}
+
+  AAC_DECODER_INSTANCE* const /* absl_nonnull */ /* absl_nonnull */ decoder_;
 };
 
 }  // namespace iamf_tools
diff --git a/iamf/cli/codec/aac_encoder.cc b/iamf/cli/codec/aac_encoder.cc
index aed5eb7..1fbf9db 100644
--- a/iamf/cli/codec/aac_encoder.cc
+++ b/iamf/cli/codec/aac_encoder.cc
@@ -220,15 +220,17 @@ absl::Status AacEncoder::EncodeAudioFrame(
 
   // `fdk_aac` requires the native system endianness as input.
   const bool big_endian = IsNativeBigEndian();
+
+  // TODO(b/382197581): Avoid re-allocations of `encoder_input_pcm`.
   std::vector<INT_PCM> encoder_input_pcm(
       num_samples_per_channel * num_channels_, 0);
   size_t write_position = 0;
-  for (int t = 0; t < samples.size(); t++) {
-    for (int c = 0; c < samples[0].size(); ++c) {
+  for (int t = 0; t < samples[0].size(); ++t) {
+    for (int c = 0; c < samples.size(); c++) {
       // Convert all frames to INT_PCM samples for input for `fdk_aac` (usually
       // 16-bit).
       RETURN_IF_NOT_OK(WritePcmSample(
-          static_cast<uint32_t>(samples[t][c]), input_bit_depth, big_endian,
+          static_cast<uint32_t>(samples[c][t]), input_bit_depth, big_endian,
           reinterpret_cast<uint8_t*>(encoder_input_pcm.data()),
           write_position));
     }
@@ -241,11 +243,11 @@ absl::Status AacEncoder::EncodeAudioFrame(
   INT in_buffer_sizes[1] = {
       static_cast<INT>(encoder_input_pcm.size() * GetFdkAacBytesPerSample())};
   INT in_buffer_element_sizes[1] = {GetFdkAacBytesPerSample()};
-  AACENC_BufDesc inBufDesc = {.numBufs = 1,
-                              .bufs = in_buffers,
-                              .bufferIdentifiers = in_buffer_identifiers,
-                              .bufSizes = in_buffer_sizes,
-                              .bufElSizes = in_buffer_element_sizes};
+  AACENC_BufDesc in_buffer_desc = {.numBufs = 1,
+                                   .bufs = in_buffers,
+                                   .bufferIdentifiers = in_buffer_identifiers,
+                                   .bufSizes = in_buffer_sizes,
+                                   .bufElSizes = in_buffer_element_sizes};
   AACENC_InArgs in_args = {
       .numInSamples = num_samples_per_channel * num_channels_,
       .numAncBytes = 0};
@@ -261,18 +263,19 @@ absl::Status AacEncoder::EncodeAudioFrame(
   INT out_buffer_sizes[1] = {
       static_cast<INT>(audio_frame.size() * sizeof(uint8_t))};
   INT out_buffer_element_sizes[1] = {sizeof(uint8_t)};
-  AACENC_BufDesc outBufDesc = {.numBufs = 1,
-                               .bufs = out_bufs,
-                               .bufferIdentifiers = out_buffer_identifiers,
-                               .bufSizes = out_buffer_sizes,
-                               .bufElSizes = out_buffer_element_sizes};
+  AACENC_BufDesc out_buffer_desc = {.numBufs = 1,
+                                    .bufs = out_bufs,
+                                    .bufferIdentifiers = out_buffer_identifiers,
+                                    .bufSizes = out_buffer_sizes,
+                                    .bufElSizes = out_buffer_element_sizes};
 
   // Encode the frame.
   AACENC_OutArgs out_args;
   // This implementation expects `fdk_aac` to return an entire frame and no
   // error code.
   RETURN_IF_NOT_OK(AacEncErrorToAbslStatus(
-      aacEncEncode(encoder_, &inBufDesc, &outBufDesc, &in_args, &out_args),
+      aacEncEncode(encoder_, &in_buffer_desc, &out_buffer_desc, &in_args,
+                   &out_args),
       "Failed on call to `aacEncEncode`."));
 
   if (num_samples_per_channel * num_channels_ != out_args.numInSamples) {
@@ -285,7 +288,7 @@ absl::Status AacEncoder::EncodeAudioFrame(
   finalized_audio_frames_.emplace_back(
       std::move(*partial_audio_frame_with_data));
 
-  LOG_FIRST_N(INFO, 3) << "Encoded " << num_samples_per_channel << " samples * "
+  LOG_FIRST_N(INFO, 1) << "Encoded " << num_samples_per_channel << " samples * "
                        << num_channels_ << " channels using "
                        << out_args.numOutBytes << " bytes";
   return absl::OkStatus();
diff --git a/iamf/cli/codec/aac_encoder.h b/iamf/cli/codec/aac_encoder.h
index 67ce8aa..7c6292e 100644
--- a/iamf/cli/codec/aac_encoder.h
+++ b/iamf/cli/codec/aac_encoder.h
@@ -63,7 +63,7 @@ class AacEncoder : public EncoderBase {
   /*!\brief Encodes an audio frame.
    *
    * \param input_bit_depth Bit-depth of the input data.
-   * \param samples Samples arranged in (time x channel) axes. The samples are
+   * \param samples Samples arranged in (channel, time) axes. The samples are
    *        left-justified and stored in the upper `input_bit_depth` bits.
    * \param partial_audio_frame_with_data Unique pointer to take ownership of.
    *        The underlying `audio_frame_` is modified. All other fields are
diff --git a/iamf/cli/codec/decoder_base.h b/iamf/cli/codec/decoder_base.h
index 0c21fb3..1bbb079 100644
--- a/iamf/cli/codec/decoder_base.h
+++ b/iamf/cli/codec/decoder_base.h
@@ -13,11 +13,12 @@
 #ifndef CLI_DECODER_BASE_H_
 #define CLI_DECODER_BASE_H_
 
-#include <cstddef>
 #include <cstdint>
 #include <vector>
 
+#include "absl/log/check.h"
 #include "absl/status/status.h"
+#include "absl/types/span.h"
 
 namespace iamf_tools {
 
@@ -35,21 +36,14 @@ class DecoderBase {
    */
   DecoderBase(int num_channels, uint32_t num_samples_per_channel)
       : num_channels_(num_channels),
-        num_samples_per_channel_(num_samples_per_channel),
-        decoded_samples_(num_samples_per_channel_,
-                         std::vector<int32_t>(num_channels)),
-        num_valid_ticks_(0) {}
+        num_samples_per_channel_(num_samples_per_channel) {
+    decoded_samples_.reserve(num_samples_per_channel_);
+  }
 
   /*!\brief Destructor.
    */
   virtual ~DecoderBase() = default;
 
-  /*!\brief Initializes the underlying decoder.
-   *
-   * \return `absl::OkStatus()` on success. A specific status on failure.
-   */
-  virtual absl::Status Initialize() = 0;
-
   /*!\brief Decodes an audio frame.
    *
    * \param encoded_frame Frame to decode.
@@ -58,28 +52,24 @@ class DecoderBase {
   virtual absl::Status DecodeAudioFrame(
       const std::vector<uint8_t>& encoded_frame) = 0;
 
-  /*!\brief Outputs valid decoded samples.
+  /*!\brief Outputs valid decoded samples as a span.
    *
-   * \return Valid decoded samples.
+   * \return Span of valid decoded samples.
    */
-  std::vector<std::vector<int32_t>> ValidDecodedSamples() const {
-    return {decoded_samples_.begin(),
-            decoded_samples_.begin() + num_valid_ticks_};
+  absl::Span<const std::vector<int32_t>> ValidDecodedSamples() const {
+    return absl::MakeConstSpan(decoded_samples_);
   }
 
  protected:
   const int num_channels_;
   const uint32_t num_samples_per_channel_;
 
-  // Stores the output decoded frames arranged in (time, sample) axes. That
-  // is to say, each inner vector has one sample for per channel and the outer
-  // vector contains one inner vector for each time tick. When the decoded
-  // samples is shorter than a frame, only the first `num_valid_ticks_` ticks
-  // should be used.
+  // Stores the output decoded frames arranged in (channel, time) axes. That
+  // is to say, each inner vector has one sample for per time tick and the outer
+  // vector contains one inner vector for each channel. When the decoded
+  // samples is shorter than a frame, the inner vectors will be resized to fit
+  // the valid portion.
   std::vector<std::vector<int32_t>> decoded_samples_;
-
-  // Number of ticks (time samples) in `decoded_samples_` that are valid.
-  size_t num_valid_ticks_;
 };
 
 }  // namespace iamf_tools
diff --git a/iamf/cli/codec/encoder_base.cc b/iamf/cli/codec/encoder_base.cc
index 25f579f..af8f595 100644
--- a/iamf/cli/codec/encoder_base.cc
+++ b/iamf/cli/codec/encoder_base.cc
@@ -34,19 +34,19 @@ absl::Status EncoderBase::Initialize(bool validate_codec_delay) {
 
 absl::Status EncoderBase::ValidateInputSamples(
     const std::vector<std::vector<int32_t>>& samples) const {
-  if (samples.size() != num_samples_per_frame_) {
-    auto error_message = absl::StrCat("Found ", samples.size(),
-                                      " samples per channels. Expected ",
-                                      num_samples_per_frame_, ".");
+  if (samples.size() != num_channels_) {
+    auto error_message = absl::StrCat(
+        "Found ", samples.size(), " channels. Expected ", num_channels_, ".");
     return absl::InvalidArgumentError(error_message);
   }
   if (samples.empty()) {
     return absl::InvalidArgumentError("samples cannot be empty.");
   }
-  if (samples[0].size() != num_channels_) {
-    auto error_message =
-        absl::StrCat("Found ", samples[0].size(), " channels. Expected ",
-                     num_channels_, ".");
+
+  if (samples[0].size() != num_samples_per_frame_) {
+    auto error_message = absl::StrCat("Found ", samples[0].size(),
+                                      " samples per channels. Expected ",
+                                      num_samples_per_frame_, ".");
     return absl::InvalidArgumentError(error_message);
   }
 
diff --git a/iamf/cli/codec/encoder_base.h b/iamf/cli/codec/encoder_base.h
index 47cbb01..3d8a2e4 100644
--- a/iamf/cli/codec/encoder_base.h
+++ b/iamf/cli/codec/encoder_base.h
@@ -67,7 +67,7 @@ class EncoderBase {
   /*!\brief Encodes an audio frame.
    *
    * \param input_bit_depth Bit-depth of the input data.
-   * \param samples Samples arranged in (time x channel) axes. The samples are
+   * \param samples Samples arranged in (channel, time) axes. The samples are
    *        left-justified and stored in the upper `input_bit_depth` bits.
    * \param partial_audio_frame_with_data Unique pointer to take ownership of.
    *        The underlying `audio_frame_` is modified. All other fields are
@@ -175,7 +175,7 @@ class EncoderBase {
     return absl::OkStatus();
   }
 
-  /*!\brief Validates `samples` has the correct number of ticks and channels.
+  /*!\brief Validates `samples` has the correct number of channels and ticks.
    *
    * \return `absl::OkStatus()` on success. A specific status on failure.
    */
diff --git a/iamf/cli/codec/flac_decoder.cc b/iamf/cli/codec/flac_decoder.cc
index 17b3447..ed46607 100644
--- a/iamf/cli/codec/flac_decoder.cc
+++ b/iamf/cli/codec/flac_decoder.cc
@@ -12,122 +12,45 @@
 
 #include "iamf/cli/codec/flac_decoder.h"
 
-#include <algorithm>
-#include <cstddef>
 #include <cstdint>
+#include <memory>
 #include <vector>
 
-#include "absl/log/log.h"
+#include "absl/log/check.h"
+#include "absl/memory/memory.h"
 #include "absl/status/status.h"
+#include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
 #include "iamf/cli/codec/decoder_base.h"
-#include "include/FLAC/format.h"
-#include "include/FLAC/ordinals.h"
+#include "iamf/cli/codec/flac_decoder_stream_callbacks.h"
 #include "include/FLAC/stream_decoder.h"
 
 namespace iamf_tools {
 
-FLAC__StreamDecoderReadStatus FlacDecoder::LibFlacReadCallback(
-    const FLAC__StreamDecoder* /*decoder*/, FLAC__byte buffer[], size_t* bytes,
-    void* client_data) {
-  auto flac_decoder = static_cast<FlacDecoder*>(client_data);
-  auto encoded_frame = flac_decoder->GetEncodedFrame();
-  if (encoded_frame.empty()) {
-    // No more data to read.
-    *bytes = 0;
-    return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;
-  }
-  if (encoded_frame.size() > *bytes) {
-    LOG(ERROR) << "Encoded frame size " << encoded_frame.size()
-               << " is larger than the libflac buffer size " << *bytes;
-    *bytes = 0;
-    return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
-  }
-  for (int i = 0; i < encoded_frame.size(); ++i) {
-    buffer[i] = encoded_frame[i];
-  }
-  *bytes = encoded_frame.size();
-  return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
-}
-
-FLAC__StreamDecoderWriteStatus FlacDecoder::LibFlacWriteCallback(
-    const FLAC__StreamDecoder* /*decoder*/, const FLAC__Frame* frame,
-    const FLAC__int32* const buffer[], void* client_data) {
-  auto* flac_decoder = static_cast<FlacDecoder*>(client_data);
-  const auto num_samples_per_channel = frame->header.blocksize;
-  if (flac_decoder->GetNumSamplesPerChannel() != frame->header.blocksize) {
-    LOG(ERROR) << "Frame blocksize " << frame->header.blocksize
-               << " does not match expected number of samples per channel "
-               << flac_decoder->GetNumSamplesPerChannel();
-    return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
-  }
-  std::vector<std::vector<int32_t>> decoded_samples(
-      num_samples_per_channel, std::vector<int32_t>(frame->header.channels));
-  // Note: libFLAC represents data in a planar fashion, so each channel is
-  // stored in a separate array, and the elements within those arrays represent
-  // time ticks. However, we store samples in an interleaved fashion, which
-  // means that each outer entry in decoded_samples represents a time tick, and
-  // each element within represents a channel. So we need to transpose the data
-  // from libFLAC's planar format into our interleaved format.
-  for (int c = 0; c < frame->header.channels; ++c) {
-    const FLAC__int32* const channel_buffer = buffer[c];
-    for (int t = 0; t < num_samples_per_channel; ++t) {
-      decoded_samples[t][c] = channel_buffer[t]
-                              << (32 - frame->header.bits_per_sample);
-    }
+absl::StatusOr<std::unique_ptr<DecoderBase>> FlacDecoder::Create(
+    int num_channels, uint32_t num_samples_per_frame) {
+  FLAC__StreamDecoder* decoder = FLAC__stream_decoder_new();
+  if (decoder == nullptr) {
+    return absl::InternalError("Failed to create FLAC stream decoder.");
   }
-  flac_decoder->SetDecodedFrame(decoded_samples);
-  return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
-}
 
-void FlacDecoder::LibFlacErrorCallback(const FLAC__StreamDecoder* /*decoder*/,
-                                       FLAC__StreamDecoderErrorStatus status,
-                                       void* /*client_data*/) {
-  switch (status) {
-    case FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC:
-      LOG(ERROR) << "FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC";
-      break;
-    case FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER:
-      LOG(ERROR) << "FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER";
-      break;
-    case FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH:
-      LOG(ERROR) << "FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH";
-      break;
-    case FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM:
-      LOG(ERROR) << "FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM";
-      break;
-    default:
-      LOG(ERROR) << "Unknown FLAC__StreamDecoderErrorStatus= " << status;
-      break;
-  }
-}
+  auto flac_decoder = absl::WrapUnique(
+      new FlacDecoder(num_channels, num_samples_per_frame, decoder));
 
-FlacDecoder::FlacDecoder(int num_channels, uint32_t num_samples_per_frame)
-    : DecoderBase(num_channels, num_samples_per_frame) {}
+  FLAC__stream_decoder_init_stream(
+      decoder, flac_callbacks::LibFlacReadCallback, /*seek_callback=*/nullptr,
+      /*tell_callback=*/nullptr, /*length_callback=*/nullptr,
+      /*eof_callback=*/nullptr, flac_callbacks::LibFlacWriteCallback,
+      /*metadata_callback=*/nullptr, flac_callbacks::LibFlacErrorCallback,
+      static_cast<void*>(flac_decoder->callback_data_.get()));
 
-FlacDecoder::~FlacDecoder() {
-  if (decoder_ != nullptr) {
-    FLAC__stream_decoder_delete(decoder_);
-  }
+  return flac_decoder;
 }
 
-absl::Status FlacDecoder::Initialize() {
-  decoder_ = FLAC__stream_decoder_new();
-  if (decoder_ == nullptr) {
-    return absl::InternalError("Failed to create FLAC stream decoder.");
-  }
-  FLAC__StreamDecoderInitStatus status = FLAC__stream_decoder_init_stream(
-      decoder_, LibFlacReadCallback, /*seek_callback=*/nullptr,
-      /*tell_callback=*/nullptr, /*length_callback=*/nullptr,
-      /*eof_callback=*/nullptr, LibFlacWriteCallback,
-      /*metadata_callback=*/nullptr, LibFlacErrorCallback,
-      static_cast<void*>(this));
-
-  if (status != FLAC__STREAM_DECODER_INIT_STATUS_OK) {
-    return absl::InternalError(
-        absl::StrCat("Failed to initialize FLAC stream decoder: ", status));
-  }
-  return absl::OkStatus();
+FlacDecoder::~FlacDecoder() {
+  // The factory function prevents `decoder_` from ever being null.
+  CHECK_NE(decoder_, nullptr);
+  FLAC__stream_decoder_delete(decoder_);
 }
 
 absl::Status FlacDecoder::Finalize() {
@@ -140,20 +63,14 @@ absl::Status FlacDecoder::Finalize() {
 
 absl::Status FlacDecoder::DecodeAudioFrame(
     const std::vector<uint8_t>& encoded_frame) {
-  num_valid_ticks_ = 0;
-
   // Set the encoded frame to be decoded; the libflac decoder will copy the
   // data using LibFlacReadCallback.
-  encoded_frame_ = encoded_frame;
+  callback_data_->SetEncodedFrame(encoded_frame);
   if (!FLAC__stream_decoder_process_single(decoder_)) {
     // More specific error information is logged in LibFlacErrorCallback.
     return absl::InternalError("Failed to decode FLAC frame.");
   }
-  // Get the decoded frame, which will have been set by LibFlacWriteCallback.
-  // Copy the first `num_valid_ticks_` time samples to `decoded_samples_`.
-  num_valid_ticks_ = decoded_frame_.size();
-  std::copy(decoded_frame_.begin(), decoded_frame_.begin() + num_valid_ticks_,
-            decoded_samples_.begin());
+
   return absl::OkStatus();
 }
 
diff --git a/iamf/cli/codec/flac_decoder.h b/iamf/cli/codec/flac_decoder.h
index cad5a48..814d47a 100644
--- a/iamf/cli/codec/flac_decoder.h
+++ b/iamf/cli/codec/flac_decoder.h
@@ -13,14 +13,15 @@
 #ifndef CLI_CODEC_FLAC_DECODER_H_
 #define CLI_CODEC_FLAC_DECODER_H_
 
-#include <cstddef>
 #include <cstdint>
+#include <memory>
 #include <vector>
 
+#include "absl/base/nullability.h"
 #include "absl/status/status.h"
+#include "absl/status/statusor.h"
 #include "iamf/cli/codec/decoder_base.h"
-#include "include/FLAC/format.h"
-#include "include/FLAC/ordinals.h"
+#include "iamf/cli/codec/flac_decoder_stream_callbacks.h"
 #include "include/FLAC/stream_decoder.h"
 namespace iamf_tools {
 
@@ -28,27 +29,17 @@ namespace iamf_tools {
  */
 class FlacDecoder : public DecoderBase {
  public:
-  /*!brief Constructor.
+  /*!brief Factory function.
    *
    * \param num_channels Number of channels for this stream.
    * \param num_samples_per_frame Number of samples per frame.
+   * \return Flac decoder on success. A specific status on failure.
    */
-  FlacDecoder(int num_channels, uint32_t num_samples_per_frame);
+  static absl::StatusOr<std::unique_ptr<DecoderBase>> Create(
+      int num_channels, uint32_t num_samples_per_frame);
 
   ~FlacDecoder() override;
 
-  /*!\brief Initializes the underlying libflac decoder.
-   *
-   * \return `absl::OkStatus()` on success. A specific status on failure.
-   */
-  absl::Status Initialize() override;
-
-  /*!\brief Gets the number of samples per channel.
-   *
-   * \return Number of samples per channel.
-   */
-  int GetNumSamplesPerChannel() { return num_samples_per_channel_; }
-
   /*!\brief Finalizes the underlying libflac decoder.
    *
    * \return `absl::OkStatus()` on success. A specific status on failure.
@@ -63,98 +54,28 @@ class FlacDecoder : public DecoderBase {
   absl::Status DecodeAudioFrame(
       const std::vector<uint8_t>& encoded_frame) override;
 
-  /*!\brief Sets an encoded FLAC frame in decoder.encoded_frame_.
-   *
-   * \param encoded_frame Encoded FLAC frame.
-   */
-  void SetEncodedFrame(const std::vector<uint8_t>& encoded_frame) {
-    encoded_frame_ = encoded_frame;
-  }
-
-  /*!\brief Retrieves the encoded frame in decoder.encoded_frame_.
-   *
-   * \return Vector of encoded FLAC bytes representing a single frame.
-   */
-  std::vector<uint8_t> GetEncodedFrame() const { return encoded_frame_; }
-
-  /*!\brief Sets a decoded FLAC frame in decoder.decoded_frame_.
+ private:
+  /* Private constructor.
    *
-   * \param decoded_frame Decoded FLAC frame.
-   */
-  void SetDecodedFrame(const std::vector<std::vector<int32_t>>& decoded_frame) {
-    decoded_frame_ = decoded_frame;
-  }
-
-  /*!\brief Retrieves the decoded FLAC frame in decoder.decoded_frame_.
+   * Used only by the factory function.
    *
-   * \return Vector of decoded FLAC samples.
+   * \param num_channels Number of channels for this stream.
+   * \param num_samples_per_frame Number of samples per frame for this stream.
+   * \param decoder `libflac` decoder to use.
    */
-  std::vector<std::vector<int32_t>> GetDecodedFrame() const {
-    return decoded_frame_;
+  FlacDecoder(int num_channels, uint32_t num_samples_per_frame,
+              FLAC__StreamDecoder* /* absl_nonnull */ decoder)
+      : DecoderBase(num_channels, num_samples_per_frame), decoder_(decoder) {
+    callback_data_ = std::make_unique<flac_callbacks::LibFlacCallbackData>(
+        num_samples_per_frame, decoded_samples_);
   }
 
-  /*!\brief Reads an encoded flac frame into the libflac decoder
-   *
-   * This callback function is used whenever the decoder needs more input data.
-   *
-   * \param decoder Unused libflac stream decoder. This parameter is not used in
-   *        this implementation, but is included to override the libflac
-   *        signature.
-   * \param buffer Output buffer for the encoded frame.
-   * \param bytes Maximum size of the buffer; in the case of a successful read,
-   *        this will be set to the actual number of bytes read.
-   * \param client_data universal pointer, which in this case should point to
-   *        FlacDecoder.
-   *
-   * \return A libflac read status indicating whether the read was successful.
-   */
-  static FLAC__StreamDecoderReadStatus LibFlacReadCallback(
-      const FLAC__StreamDecoder* /*decoder*/, FLAC__byte buffer[],
-      size_t* bytes, void* client_data);
-
-  /*!\brief Writes a decoded flac frame to an instance of FlacDecoder.
-   *
-   * This callback function is used to write out a decoded frame from the
-   * libflac decoder.
-   *
-   * \param decoder Unused libflac stream decoder. This parameter is not used in
-   *        this implementation, but is included to override the libflac
-   *        signature.
-   * \param frame libflac encoded frame metadata.
-   * \param buffer Array of pointers to decoded channels of data. Each pointer
-   *        will point to an array of signed samples of length
-   *        `frame->header.blocksize`. Channels will be ordered according to the
-   *        FLAC specification.
-   * \param client_data Universal pointer, which in this case should point to
-   *        FlacDecoder.
-   *
-   * \return A libflac write status indicating whether the write was successful.
-   */
-  static FLAC__StreamDecoderWriteStatus LibFlacWriteCallback(
-      const FLAC__StreamDecoder* /*decoder*/, const FLAC__Frame* frame,
-      const FLAC__int32* const buffer[], void* client_data);
-
-  /*!\brief Logs an error from the libflac decoder.
-   *
-   *  This function will be called whenever an error occurs during libflac
-   *  decoding.
-   *
-   * \param decoder Unused libflac stream decoder. This parameter is not used in
-   *        this implementation, but is included to override the libflac
-   *        signature.
-   * \param status The error encountered by the decoder.
-   * \param client_data Universal pointer, which in this case should point to
-   *        FlacDecoder. Unused in this implementation.
-   */
-  static void LibFlacErrorCallback(const FLAC__StreamDecoder* /*decoder*/,
-                                   FLAC__StreamDecoderErrorStatus status,
-                                   void* /*client_data*/);
-
- private:
-  std::vector<uint8_t> encoded_frame_ = {};
-  std::vector<std::vector<int32_t>> decoded_frame_ = {};
+  // Backing data for the `libflac` decoder callbacks. Held in `unique_ptr` for
+  // pointer stability after move.
+  /* absl_nonnull */ std::unique_ptr<flac_callbacks::LibFlacCallbackData>
+      callback_data_;
   // A pointer to the `libflac` decoder.
-  FLAC__StreamDecoder* decoder_ = nullptr;
+  FLAC__StreamDecoder* const /* absl_nonnull */ decoder_;
 };
 
 }  // namespace iamf_tools
diff --git a/iamf/cli/codec/flac_decoder_stream_callbacks.cc b/iamf/cli/codec/flac_decoder_stream_callbacks.cc
index 7be44dc..3120ffe 100644
--- a/iamf/cli/codec/flac_decoder_stream_callbacks.cc
+++ b/iamf/cli/codec/flac_decoder_stream_callbacks.cc
@@ -17,52 +17,71 @@
 #include <vector>
 
 #include "absl/log/log.h"
-#include "iamf/cli/codec/flac_decoder.h"
+#include "absl/types/span.h"
 #include "include/FLAC/format.h"
 #include "include/FLAC/ordinals.h"
 #include "include/FLAC/stream_decoder.h"
 
 namespace iamf_tools {
 
+namespace flac_callbacks {
+
+namespace {
+using absl::MakeConstSpan;
+}
+
 FLAC__StreamDecoderReadStatus LibFlacReadCallback(
     const FLAC__StreamDecoder* /*decoder*/, FLAC__byte buffer[], size_t* bytes,
     void* client_data) {
-  auto flac_decoder = static_cast<FlacDecoder*>(client_data);
-  const auto& encoded_frame = flac_decoder->GetEncodedFrame();
-  if (encoded_frame.empty()) {
+  if (bytes == nullptr || buffer == nullptr || client_data == nullptr) {
+    return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
+  }
+
+  auto libflac_callback_data = static_cast<LibFlacCallbackData*>(client_data);
+  // We are contracted to fill in up to the next `*bytes` bytes of the buffer.
+  // If there is more data, then there will be a subsequent call to this
+  // callback.
+  const auto encoded_frame_slice = libflac_callback_data->GetNextSlice(*bytes);
+  if (encoded_frame_slice.empty()) {
     // No more data to read.
     *bytes = 0;
     return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;
   }
-  if (encoded_frame.size() > *bytes) {
-    LOG(ERROR) << "Encoded frame size " << encoded_frame.size()
-               << " is larger than the libflac buffer size " << *bytes;
-    *bytes = 0;
-    return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
-  }
-  for (int i = 0; i < encoded_frame.size(); ++i) {
-    buffer[i] = encoded_frame[i];
+
+  for (int i = 0; i < encoded_frame_slice.size(); ++i) {
+    buffer[i] = encoded_frame_slice[i];
   }
-  *bytes = encoded_frame.size();
+  *bytes = encoded_frame_slice.size();
   return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
 }
 
 FLAC__StreamDecoderWriteStatus LibFlacWriteCallback(
     const FLAC__StreamDecoder* /*decoder*/, const FLAC__Frame* frame,
     const FLAC__int32* const buffer[], void* client_data) {
-  std::vector<std::vector<int32_t>> decoded_samples(frame->header.channels);
-  auto* flac_decoder = static_cast<FlacDecoder*>(client_data);
-  const auto num_samples_per_channel = frame->header.blocksize;
-  // Note: libFLAC represents data in a planar fashion, so each channel is
-  // stored in a separate array.
-  for (int i = 0; i < frame->header.channels; ++i) {
-    decoded_samples[i].resize(num_samples_per_channel);
-    const FLAC__int32* const channel_buffer = buffer[i];
-    for (int j = 0; j < num_samples_per_channel; ++j) {
-      decoded_samples[i][j] = static_cast<int32_t>(channel_buffer[j]);
+  auto* libflac_callback_data = static_cast<LibFlacCallbackData*>(client_data);
+  if (libflac_callback_data->num_samples_per_channel_ <
+      frame->header.blocksize) {
+    LOG(ERROR) << "Frame blocksize " << frame->header.blocksize
+               << " does not match expected number of samples per channel "
+               << libflac_callback_data->num_samples_per_channel_;
+    return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
+  }
+
+  auto& decoded_samples = libflac_callback_data->decoded_frame_;
+  decoded_samples.resize(frame->header.channels);
+  for (int c = 0; c < frame->header.channels; ++c) {
+    const FLAC__int32* const channel_buffer = buffer[c];
+    auto& decoded_samples_for_channel = decoded_samples[c];
+
+    // Zero-initialize a vector of the maximum number of samples per channel.
+    // But only fill in based on the actual number of samples in the frame.
+    decoded_samples_for_channel.resize(
+        libflac_callback_data->num_samples_per_channel_, 0);
+    for (int t = 0; t < frame->header.blocksize; ++t) {
+      decoded_samples_for_channel[t] = channel_buffer[t]
+                                       << (32 - frame->header.bits_per_sample);
     }
   }
-  flac_decoder->SetDecodedFrame(decoded_samples);
   return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
 }
 
@@ -83,9 +102,33 @@ void LibFlacErrorCallback(const FLAC__StreamDecoder* /*decoder*/,
       LOG(ERROR) << "FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM";
       break;
     default:
-      LOG(ERROR) << "Unknown error";
+      LOG(ERROR) << "Unknown FLAC__StreamDecoderErrorStatus= " << status;
       break;
   }
 }
 
+void LibFlacCallbackData::SetEncodedFrame(
+    absl::Span<const uint8_t> raw_encoded_frame) {
+  // Cache the frame, and reset the bookkeeping index.
+  encoded_frame_ =
+      std::vector<uint8_t>(raw_encoded_frame.begin(), raw_encoded_frame.end());
+  next_byte_index_ = 0;
+}
+
+absl::Span<const uint8_t> LibFlacCallbackData::GetNextSlice(size_t chunk_size) {
+  // Ok, the buffer is exhausted. Return an empty span.
+  if (next_byte_index_ >= encoded_frame_.size()) {
+    return {};
+  }
+
+  // Grab the next slice, advance the bookkeeping index; effectively consecutive
+  // calls stride over the source frame.
+  auto next_slice =
+      MakeConstSpan(encoded_frame_).subspan(next_byte_index_, chunk_size);
+  next_byte_index_ += next_slice.size();
+  return next_slice;
+}
+
+}  // namespace flac_callbacks
+
 }  // namespace iamf_tools
diff --git a/iamf/cli/codec/flac_decoder_stream_callbacks.h b/iamf/cli/codec/flac_decoder_stream_callbacks.h
index 4abbf65..caf97e1 100644
--- a/iamf/cli/codec/flac_decoder_stream_callbacks.h
+++ b/iamf/cli/codec/flac_decoder_stream_callbacks.h
@@ -14,29 +14,84 @@
 #define CLI_CODEC_FLAC_DECODER_STREAM_CALLBACKS_H_
 
 #include <cstddef>
+#include <cstdint>
+#include <vector>
 
+#include "absl/types/span.h"
 #include "include/FLAC/format.h"
 #include "include/FLAC/ordinals.h"
 #include "include/FLAC/stream_decoder.h"
 
 namespace iamf_tools {
+
+namespace flac_callbacks {
+
+/*!\brief Data to be passed to the libflac decoder callbacks.
+ *
+ * The callback functions work by reading and writing to this struct.
+ */
+class LibFlacCallbackData {
+ public:
+  /*!\brief Constructor.
+   *
+   * \param num_samples_per_channel Number of samples per channel to
+   *        process.
+   * \param decoded_frame Reference to the decoded frame, where decoded samples
+   *        are written. The vector may be resized to fit the channels and
+   *        time ticks within the function.
+   */
+  LibFlacCallbackData(uint32_t num_samples_per_channel,
+                      std::vector<std::vector<int32_t>>& decoded_frame)
+      : num_samples_per_channel_(num_samples_per_channel),
+        decoded_frame_(decoded_frame) {}
+
+  /*!\brief Sets the frame to be decoded.
+   *
+   * \param raw_encoded_frame Frame to decode.
+   */
+  void SetEncodedFrame(absl::Span<const uint8_t> raw_encoded_frame);
+
+  /*!\brief Retrieve the next slice to be decoded.
+   *
+   * Subsequent calls to this function will return the next slice of the encoded
+   * frame. The output span is valid until the next call to `SetEncodedFrame`.
+   *
+   * \param chunk_size Maximum number of bytes to return.
+   * \return Next slice to be decoded, or an empty span if the encoded frame is
+   *         exhausted.
+   */
+  absl::Span<const uint8_t> GetNextSlice(size_t chunk_size);
+
+  const uint32_t num_samples_per_channel_;
+
+  // Reference to the backing data for the decoded frame.
+  std::vector<std::vector<int32_t>>& decoded_frame_;
+
+ private:
+  // Backing data for the next frame to be decoded.
+  std::vector<uint8_t> encoded_frame_;
+
+  // Index of the next byte to be read from the encoded frame.
+  size_t next_byte_index_ = 0;
+};
+
 /*!\brief Reads an encoded flac frame into the libflac decoder
  *
  * This callback function is used whenever the decoder needs more input data.
  *
- * \param decoder libflac stream decoder
- *        This parameter is not used in this implementation, but is included to
- *        override the libflac signature.
+ * \param decoder Unused libflac stream decoder. This parameter is not used in
+ *        this implementation, but is included to override the libflac
+ *        signature.
  * \param buffer Output buffer for the encoded frame.
- * \param bytes Maximum size of the buffer; in the case of a successful read,
- *        this will be set to the actual number of bytes read.
- * \param client_data universal pointer, which in this case should point to
- *        FlacDecoder.
+ * \param bytes At input, the maximum size of the buffer. At output, the actual
+ *        number of bytes read (on successful read).
+ * \param client_data Universal pointer, which in this case should point to
+ *        a `LibFlacCallbackData`.
  *
  * \return A libflac read status indicating whether the read was successful.
  */
 FLAC__StreamDecoderReadStatus LibFlacReadCallback(
-    const FLAC__StreamDecoder* decoder, FLAC__byte buffer[], size_t* bytes,
+    const FLAC__StreamDecoder* /*decoder*/, FLAC__byte buffer[], size_t* bytes,
     void* client_data);
 
 /*!\brief Writes a decoded flac frame to an instance of FlacDecoder.
@@ -52,8 +107,8 @@ FLAC__StreamDecoderReadStatus LibFlacReadCallback(
  *        will point to an array of signed samples of length
  *        `frame->header.blocksize`. Channels will be ordered according to the
  *        FLAC specification.
- * \param client_data Universal pointer, which in this case should point to
- *        FlacDecoder.
+ * \param client_data universal pointer, which in this case should point to a
+ *        `LibFlacCallbackData`.
  *
  * \return A libflac write status indicating whether the write was successful.
  */
@@ -66,17 +121,19 @@ FLAC__StreamDecoderWriteStatus LibFlacWriteCallback(
  *  This function will be called whenever an error occurs during libflac
  *  decoding.
  *
- * \param decoder libflac stream decoder
- *        This parameter is not used in this implementation, but is included to
- *        override the libflac signature.
+ * \param decoder Unused libflac stream decoder. This parameter is not used in
+ *        this implementation, but is included to override the libflac
+ *        signature.
  * \param status The error encountered by the decoder.
  * \param client_data Universal pointer, which in this case should point to
- *        FlacDecoder. Unused in this implementation.
+ *        `LibFlacCallbackData`. Unused in this implementation.
  */
 void LibFlacErrorCallback(const FLAC__StreamDecoder* /*decoder*/,
                           FLAC__StreamDecoderErrorStatus status,
                           void* /*client_data*/);
 
+}  // namespace flac_callbacks
+
 }  // namespace iamf_tools
 
 #endif  // CLI_CODEC_FLAC_DECODER_STREAM_CALLBACKS_H_
diff --git a/iamf/cli/codec/flac_encoder.cc b/iamf/cli/codec/flac_encoder.cc
index 8747615..aee99d4 100644
--- a/iamf/cli/codec/flac_encoder.cc
+++ b/iamf/cli/codec/flac_encoder.cc
@@ -84,7 +84,8 @@ FLAC__StreamEncoderWriteStatus LibFlacWriteCallback(
   const unsigned int kLibFlacMetadataSentinel = 0;
   if (samples == kLibFlacMetadataSentinel) {
     // `libflac` uses a value of `0` to indicate this callback is for metadata.
-    LOG(INFO) << "`iamf_tools` currently ignores all additional FLAC metadata.";
+    LOG_FIRST_N(INFO, 1)
+        << "`iamf_tools` currently ignores all additional FLAC metadata.";
     return FLAC__STREAM_ENCODER_WRITE_STATUS_OK;
   }
 
@@ -126,7 +127,7 @@ void LibFlacMetadataCallback(const FLAC__StreamEncoder* /*encoder*/,
   LOG_FIRST_N(INFO, 1) << "Begin `LibFlacMetadataCallback`.";
 
   if (metadata->type == FLAC__METADATA_TYPE_STREAMINFO) {
-    LOG(INFO) << "Received `STREAMINFO` metadata.";
+    LOG_FIRST_N(INFO, 1) << "Received `STREAMINFO` metadata.";
     // Just validate we got the `STREAMINFO` metadata at some point. IAMF
     // requires some fields to be set constant and different from what will be
     // returned by `libflac`.
@@ -179,10 +180,16 @@ absl::Status FlacEncoder::EncodeAudioFrame(
             return absl::OkStatus();
           };
 
+  // TODO(b/382197581): Avoid re-allocations of `encoder_input_pcm` and
+  //                    `samples_spans`.
   // Convert input to the array that will be passed to `flac_encode`.
   std::vector<FLAC__int32> encoder_input_pcm;
-  RETURN_IF_NOT_OK(ConvertTimeChannelToInterleaved(
-      absl::MakeConstSpan(samples), kLeftJustifiedToRightJustified,
+  std::vector<absl::Span<const int32_t>> samples_spans(samples.size());
+  for (int c = 0; c < samples.size(); c++) {
+    samples_spans[c] = absl::MakeConstSpan(samples[c]);
+  }
+  RETURN_IF_NOT_OK(ConvertChannelTimeToInterleaved(
+      absl::MakeConstSpan(samples_spans), kLeftJustifiedToRightJustified,
       encoder_input_pcm));
 
   LOG_FIRST_N(INFO, 1) << "Encoding " << encoder_input_pcm.size() * 4
diff --git a/iamf/cli/codec/flac_encoder.h b/iamf/cli/codec/flac_encoder.h
index c0be0bf..950b370 100644
--- a/iamf/cli/codec/flac_encoder.h
+++ b/iamf/cli/codec/flac_encoder.h
@@ -72,7 +72,7 @@ class FlacEncoder : public EncoderBase {
   /*!\brief Encodes an audio frame.
    *
    * \param input_bit_depth Bit-depth of the input data.
-   * \param samples Samples arranged in (time x channel) axes. The samples are
+   * \param samples Samples arranged in (channel, time) axes. The samples are
    *        left-justified and stored in the upper `input_bit_depth` bits.
    * \param partial_audio_frame_with_data Unique pointer to take ownership of.
    *        The underlying `audio_frame_` is modified. All other fields are
diff --git a/iamf/cli/codec/lpcm_decoder.cc b/iamf/cli/codec/lpcm_decoder.cc
index bd77e2b..0c89d3e 100644
--- a/iamf/cli/codec/lpcm_decoder.cc
+++ b/iamf/cli/codec/lpcm_decoder.cc
@@ -14,9 +14,13 @@
 
 #include <cstddef>
 #include <cstdint>
+#include <memory>
+#include <variant>
 #include <vector>
 
+#include "absl/memory/memory.h"
 #include "absl/status/status.h"
+#include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
 #include "absl/types/span.h"
 #include "iamf/cli/codec/decoder_base.h"
@@ -27,25 +31,20 @@
 
 namespace iamf_tools {
 
-LpcmDecoder::LpcmDecoder(const CodecConfigObu& codec_config_obu,
-                         int num_channels)
-    : DecoderBase(num_channels,
-                  static_cast<int>(codec_config_obu.GetNumSamplesPerFrame())),
-      decoder_config_(std::get<LpcmDecoderConfig>(
-          codec_config_obu.GetCodecConfig().decoder_config)),
-      audio_roll_distance_(
-          codec_config_obu.GetCodecConfig().audio_roll_distance) {}
+absl::StatusOr<std::unique_ptr<DecoderBase>> LpcmDecoder::Create(
+    const CodecConfigObu& codec_config_obu, int num_channels) {
+  const LpcmDecoderConfig* decoder_config = std::get_if<LpcmDecoderConfig>(
+      &codec_config_obu.GetCodecConfig().decoder_config);
+  if (decoder_config == nullptr) {
+    return absl::InvalidArgumentError(
+        "CodecConfigObu does not contain an `LpcmDecoderConfig`.");
+  }
 
-absl::Status LpcmDecoder::Initialize() {
-  RETURN_IF_NOT_OK(decoder_config_.Validate(audio_roll_distance_));
-  return absl::OkStatus();
-}
+  RETURN_IF_NOT_OK(decoder_config->Validate(
+      codec_config_obu.GetCodecConfig().audio_roll_distance));
 
-absl::Status LpcmDecoder::DecodeAudioFrame(
-    const std::vector<uint8_t>& encoded_frame) {
-  num_valid_ticks_ = 0;
   uint8_t bit_depth;
-  auto status = decoder_config_.GetBitDepthToMeasureLoudness(bit_depth);
+  auto status = decoder_config->GetBitDepthToMeasureLoudness(bit_depth);
   if (!status.ok()) {
     return status;
   }
@@ -57,19 +56,27 @@ absl::Status LpcmDecoder::DecodeAudioFrame(
                      bit_depth, ") is not a multiple of 8."));
   }
   const size_t bytes_per_sample = bit_depth / 8;
+
+  return absl::WrapUnique(
+      new LpcmDecoder(num_channels, codec_config_obu.GetNumSamplesPerFrame(),
+                      decoder_config->IsLittleEndian(), bytes_per_sample));
+}
+
+absl::Status LpcmDecoder::DecodeAudioFrame(
+    const std::vector<uint8_t>& encoded_frame) {
   // Make sure we have a valid number of bytes.  There needs to be an equal
   // number of samples for each channel.
-  if (encoded_frame.size() % bytes_per_sample != 0 ||
-      (encoded_frame.size() / bytes_per_sample) % num_channels_ != 0) {
+  if (encoded_frame.size() % bytes_per_sample_ != 0 ||
+      (encoded_frame.size() / bytes_per_sample_) % num_channels_ != 0) {
     return absl::InvalidArgumentError(absl::StrCat(
         "LpcmDecoder::DecodeAudioFrame() failed: encoded_frame has ",
         encoded_frame.size(),
         " bytes, which is not a multiple of the bytes per sample (",
-        bytes_per_sample, ") * number of channels (", num_channels_, ")."));
+        bytes_per_sample_, ") * number of channels (", num_channels_, ")."));
   }
-  // Each time tick has one sample for each channel.
+  // Each channel has one sample per tick.
   const size_t num_ticks =
-      encoded_frame.size() / bytes_per_sample / num_channels_;
+      encoded_frame.size() / bytes_per_sample_ / num_channels_;
   if (num_ticks > num_samples_per_channel_) {
     return absl::InvalidArgumentError(
         absl::StrCat("Detected num_ticks= ", num_ticks,
@@ -77,24 +84,22 @@ absl::Status LpcmDecoder::DecodeAudioFrame(
                      "num_samples_per_channel_= ",
                      num_samples_per_channel_, "."));
   }
-  num_valid_ticks_ = num_ticks;
-
-  const bool little_endian = decoder_config_.IsLittleEndian();
-
+  decoded_samples_.resize(num_channels_);
   int32_t sample_result;
-  for (size_t t = 0; t < num_valid_ticks_; ++t) {
-    // One sample for each channel in this time tick.
-    for (size_t c = 0; c < num_channels_; ++c) {
-      const size_t offset = (t * num_channels_ + c) * bytes_per_sample;
+  for (size_t c = 0; c < num_channels_; ++c) {
+    // One sample for each time tick in this channel.
+    auto& decoded_samples_for_channel = decoded_samples_[c];
+    decoded_samples_for_channel.resize(num_ticks);
+    for (size_t t = 0; t < num_ticks; ++t) {
+      const size_t offset = (t * num_channels_ + c) * bytes_per_sample_;
       absl::Span<const uint8_t> input_bytes(encoded_frame.data() + offset,
-                                            bytes_per_sample);
-      if (little_endian) {
-        status = LittleEndianBytesToInt32(input_bytes, sample_result);
+                                            bytes_per_sample_);
+      if (little_endian_) {
+        RETURN_IF_NOT_OK(LittleEndianBytesToInt32(input_bytes, sample_result));
       } else {
-        status = BigEndianBytesToInt32(input_bytes, sample_result);
+        RETURN_IF_NOT_OK(BigEndianBytesToInt32(input_bytes, sample_result));
       }
-      RETURN_IF_NOT_OK(status);
-      decoded_samples_[t][c] = sample_result;
+      decoded_samples_for_channel[t] = sample_result;
     }
   }
   return absl::OkStatus();
diff --git a/iamf/cli/codec/lpcm_decoder.h b/iamf/cli/codec/lpcm_decoder.h
index c3ad147..e4c5b49 100644
--- a/iamf/cli/codec/lpcm_decoder.h
+++ b/iamf/cli/codec/lpcm_decoder.h
@@ -13,13 +13,15 @@
 #ifndef CLI_CODEC_LPCM_DECODER_H_
 #define CLI_CODEC_LPCM_DECODER_H_
 
+#include <cstddef>
 #include <cstdint>
+#include <memory>
 #include <vector>
 
 #include "absl/status/status.h"
+#include "absl/status/statusor.h"
 #include "iamf/cli/codec/decoder_base.h"
 #include "iamf/obu/codec_config.h"
-#include "iamf/obu/decoder_config/lpcm_decoder_config.h"
 
 namespace iamf_tools {
 
@@ -31,22 +33,18 @@ namespace iamf_tools {
  */
 class LpcmDecoder : public DecoderBase {
  public:
-  /*!brief Constructor.
+  /*!brief Factory function.
    *
-   * \param codec_config_obu Codec Config OBU with initialization settings.
+   * \param codec_config_obu Codec config for this stream.
    * \param num_channels Number of channels for this stream.
+   * \return LPCM decoder on success. A specific status on failure.
    */
-  LpcmDecoder(const CodecConfigObu& codec_config_obu, int num_channels);
+  static absl::StatusOr<std::unique_ptr<DecoderBase>> Create(
+      const CodecConfigObu& codec_config_obu, int num_channels);
 
   /*!brief Destructor. */
   ~LpcmDecoder() override = default;
 
-  /*!\brief Initializes the underlying decoder.
-   *
-   * \return `absl::OkStatus()` on success. A specific status on failure.
-   */
-  absl::Status Initialize() override;
-
   /*!\brief Decodes an LPCM audio frame.
    *
    * \param encoded_frame Frame to decode.
@@ -56,11 +54,22 @@ class LpcmDecoder : public DecoderBase {
       const std::vector<uint8_t>& encoded_frame) override;
 
  private:
-  const LpcmDecoderConfig decoder_config_;
-
-  // We don't need the audio_roll_distance_ for decoding, but needed to validate
-  // the LpcmDecoderConfig.
-  int16_t audio_roll_distance_;
+  /* Private constructor.
+   *
+   * Used only by the factory function.
+   *
+   * \param num_channels Number of channels for this stream.
+   * \param num_samples_per_frame Number of samples per frame for this stream.
+   * \param little_endian Whether the samples are little endian.
+   * \param bytes_per_sample Number of bytes per sample.
+   */
+  LpcmDecoder(int num_channels, uint32_t num_samples_per_frame,
+              bool little_endian, size_t bytes_per_sample)
+      : DecoderBase(num_channels, num_samples_per_frame),
+        little_endian_(little_endian),
+        bytes_per_sample_(bytes_per_sample) {}
+  const bool little_endian_;
+  const size_t bytes_per_sample_;
 };
 
 }  // namespace iamf_tools
diff --git a/iamf/cli/codec/lpcm_encoder.h b/iamf/cli/codec/lpcm_encoder.h
index e38ee77..430ada6 100644
--- a/iamf/cli/codec/lpcm_encoder.h
+++ b/iamf/cli/codec/lpcm_encoder.h
@@ -43,7 +43,7 @@ class LpcmEncoder : public EncoderBase {
   /*!\brief Encodes an audio frame.
    *
    * \param input_bit_depth Ignored.
-   * \param samples Samples arranged in (time x channel) axes. The samples are
+   * \param samples Samples arranged in (channel, time) axes. The samples are
    *        left-justified and stored in the upper `input_bit_depth` bits.
    *
    * \param partial_audio_frame_with_data Unique pointer to take ownership of.
diff --git a/iamf/cli/codec/opus_decoder.cc b/iamf/cli/codec/opus_decoder.cc
index 8f61741..5d1815f 100644
--- a/iamf/cli/codec/opus_decoder.cc
+++ b/iamf/cli/codec/opus_decoder.cc
@@ -13,11 +13,16 @@
 
 #include <algorithm>
 #include <cstdint>
+#include <memory>
+#include <variant>
 #include <vector>
 
 #include "absl/functional/any_invocable.h"
+#include "absl/log/check.h"
 #include "absl/log/log.h"
+#include "absl/memory/memory.h"
 #include "absl/status/status.h"
+#include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
 #include "absl/types/span.h"
 #include "iamf/cli/codec/decoder_base.h"
@@ -54,36 +59,41 @@ absl::Status ValidateDecoderConfig(
 
 }  // namespace
 
-OpusDecoder::OpusDecoder(const CodecConfigObu& codec_config_obu,
-                         int num_channels)
-    : DecoderBase(num_channels,
-                  static_cast<int>(codec_config_obu.GetNumSamplesPerFrame())),
-      opus_decoder_config_(std::get<OpusDecoderConfig>(
-          codec_config_obu.GetCodecConfig().decoder_config)),
-      output_sample_rate_(codec_config_obu.GetOutputSampleRate()) {}
-
-OpusDecoder::~OpusDecoder() {
-  if (decoder_ != nullptr) {
-    opus_decoder_destroy(decoder_);
+absl::StatusOr<std::unique_ptr<DecoderBase>> OpusDecoder::Create(
+    const CodecConfigObu& codec_config_obu, int num_channels) {
+  const OpusDecoderConfig* decoder_config = std::get_if<OpusDecoderConfig>(
+      &codec_config_obu.GetCodecConfig().decoder_config);
+  if (decoder_config == nullptr) {
+    return absl::InvalidArgumentError(
+        "CodecConfigObu does not contain an `OpusDecoderConfig`.");
   }
-}
-
-absl::Status OpusDecoder::Initialize() {
-  MAYBE_RETURN_IF_NOT_OK(ValidateDecoderConfig(opus_decoder_config_));
+  MAYBE_RETURN_IF_NOT_OK(ValidateDecoderConfig(*decoder_config));
 
   // Initialize the decoder.
   int opus_error_code;
-  decoder_ = opus_decoder_create(static_cast<opus_int32>(output_sample_rate_),
-                                 num_channels_, &opus_error_code);
+  LibOpusDecoder* decoder = opus_decoder_create(
+      static_cast<opus_int32>(codec_config_obu.GetOutputSampleRate()),
+      num_channels, &opus_error_code);
   RETURN_IF_NOT_OK(OpusErrorCodeToAbslStatus(
       opus_error_code, "Failed to initialize Opus decoder."));
+  if (decoder == nullptr) {
+    return absl::UnknownError("Unexpected null decoder after initialization.");
+  }
 
-  return absl::OkStatus();
+  return absl::WrapUnique(new OpusDecoder(
+      num_channels, codec_config_obu.GetNumSamplesPerFrame(), decoder));
+}
+
+OpusDecoder::~OpusDecoder() {
+  // The factory function prevents `decoder_` from ever being null.
+  CHECK_NE(decoder_, nullptr);
+  opus_decoder_destroy(decoder_);
 }
 
 absl::Status OpusDecoder::DecodeAudioFrame(
     const std::vector<uint8_t>& encoded_frame) {
-  num_valid_ticks_ = 0;
+  // TODO(b/382197581): Pre-allocate working buffers like `output_pcm_float` and
+  //                    `input_data`.
 
   // `opus_decode_float` decodes to `float` samples with channels interlaced.
   // Typically these values are in the range of [-1, +1] (always for
@@ -106,17 +116,17 @@ absl::Status OpusDecoder::DecodeAudioFrame(
     return OpusErrorCodeToAbslStatus(num_output_samples,
                                      "Failed to decode Opus frame.");
   }
-  LOG_FIRST_N(INFO, 3) << "Opus decoded " << num_output_samples
+  LOG_FIRST_N(INFO, 1) << "Opus decoded " << num_output_samples
                        << " samples per channel. With " << num_channels_
                        << " channels.";
-  // Convert the interleaved data to (time, channel) axes.
-  return ConvertInterleavedToTimeChannel(
+  // Convert the interleaved data to (channel, time) axes.
+  return ConvertInterleavedToChannelTime(
       absl::MakeConstSpan(output_pcm_float)
           .first(num_output_samples * num_channels_),
       num_channels_,
       absl::AnyInvocable<absl::Status(float, int32_t&) const>(
           NormalizedFloatingPointToInt32<float>),
-      decoded_samples_, num_valid_ticks_);
+      decoded_samples_);
 }
 
 }  // namespace iamf_tools
diff --git a/iamf/cli/codec/opus_decoder.h b/iamf/cli/codec/opus_decoder.h
index 0cc3842..bb9cf2e 100644
--- a/iamf/cli/codec/opus_decoder.h
+++ b/iamf/cli/codec/opus_decoder.h
@@ -13,35 +13,33 @@
 #define CLI_OPUS_ENCODER_DECODER_H_
 
 #include <cstdint>
+#include <memory>
 #include <vector>
 
+#include "absl/base/nullability.h"
 #include "absl/status/status.h"
+#include "absl/status/statusor.h"
 #include "iamf/cli/codec/decoder_base.h"
 #include "iamf/obu/codec_config.h"
-#include "iamf/obu/decoder_config/opus_decoder_config.h"
 #include "include/opus.h"
 
 namespace iamf_tools {
 
 class OpusDecoder : public DecoderBase {
  public:
-  /*!\brief Constructor
+  /*!brief Factory function.
    *
-   * \param codec_config_obu Codec Config OBU with initialization settings.
+   * \param codec_config_obu Codec config for this stream.
    * \param num_channels Number of channels for this stream.
+   * \return Opus decoder on success. A specific status on failure.
    */
-  OpusDecoder(const CodecConfigObu& codec_config_obu, int num_channels);
+  static absl::StatusOr<std::unique_ptr<DecoderBase>> Create(
+      const CodecConfigObu& codec_config_obu, int num_channels);
 
   /*!\brief Destructor
    */
   ~OpusDecoder() override;
 
-  /*!\brief Initializes the underlying decoder.
-   *
-   * \return `absl::OkStatus()` on success. A specific status on failure.
-   */
-  absl::Status Initialize() override;
-
   /*!\brief Decodes an Opus audio frame.
    *
    * \param encoded_frame Frame to decode.
@@ -54,10 +52,19 @@ class OpusDecoder : public DecoderBase {
   // The decoder from `libopus` is in the global namespace.
   typedef ::OpusDecoder LibOpusDecoder;
 
-  const OpusDecoderConfig& opus_decoder_config_;
-  const uint32_t output_sample_rate_;
+  /* Private constructor.
+   *
+   * Used only by the factory function.
+   *
+   * \param num_channels Number of channels for this stream.
+   * \param num_samples_per_frame Number of samples per frame for this stream.
+   * \param decoder `libopus` decoder to use.
+   */
+  OpusDecoder(int num_channels, uint32_t num_samples_per_frame,
+              LibOpusDecoder* /* absl_nonnull */ decoder)
+      : DecoderBase(num_channels, num_samples_per_frame), decoder_(decoder) {}
 
-  LibOpusDecoder* decoder_ = nullptr;
+  LibOpusDecoder* const /* absl_nonnull */ decoder_;
 };
 
 }  // namespace iamf_tools
diff --git a/iamf/cli/codec/opus_encoder.cc b/iamf/cli/codec/opus_encoder.cc
index e212cbd..a388cab 100644
--- a/iamf/cli/codec/opus_encoder.cc
+++ b/iamf/cli/codec/opus_encoder.cc
@@ -68,10 +68,17 @@ absl::StatusOr<int> EncodeFloat(
     const std::vector<std::vector<int32_t>>& samples,
     int num_samples_per_channel, ::OpusEncoder* encoder,
     std::vector<uint8_t>& audio_frame) {
+  // TODO(b/382197581): Avoid re-allocations of `encoder_input_pcm` and
+  //                    `samples_spans`.
   std::vector<float> encoder_input_pcm;
-  RETURN_IF_NOT_OK(ConvertTimeChannelToInterleaved(absl::MakeConstSpan(samples),
-                                                   kInt32ToNormalizedFloat,
-                                                   encoder_input_pcm));
+  std::vector<absl::Span<const int32_t>> samples_spans(samples.size());
+  for (int c = 0; c < samples.size(); c++) {
+    samples_spans[c] = absl::MakeConstSpan(samples[c]);
+  }
+
+  RETURN_IF_NOT_OK(ConvertChannelTimeToInterleaved(
+      absl::MakeConstSpan(samples_spans), kInt32ToNormalizedFloat,
+      encoder_input_pcm));
 
   // TODO(b/311655037): Test that samples are passed to `opus_encode_float` in
   //                    the correct order. Maybe also check they are in the
@@ -88,16 +95,18 @@ absl::StatusOr<int> EncodeInt16(
     std::vector<uint8_t>& audio_frame) {
   // `libopus` requires the native system endianness as input.
   const bool big_endian = IsNativeBigEndian();
+
+  // TODO(b/382197581): Avoid re-allocations of `encoder_input_pcm`.
   // Convert input to the array that will be passed to `opus_encode`.
   std::vector<opus_int16> encoder_input_pcm(
       num_samples_per_channel * num_channels, 0);
   size_t write_position = 0;
-  for (int t = 0; t < samples.size(); t++) {
-    for (int c = 0; c < samples[0].size(); ++c) {
+  for (int t = 0; t < samples[0].size(); t++) {
+    for (int c = 0; c < samples.size(); c++) {
       // Convert all frames to 16-bit samples for input to Opus.
       // Write the 16-bit samples directly into the pcm vector.
       RETURN_IF_NOT_OK(
-          WritePcmSample(static_cast<uint32_t>(samples[t][c]), 16, big_endian,
+          WritePcmSample(static_cast<uint32_t>(samples[c][t]), 16, big_endian,
                          reinterpret_cast<uint8_t*>(encoder_input_pcm.data()),
                          write_position));
     }
diff --git a/iamf/cli/codec/opus_encoder.h b/iamf/cli/codec/opus_encoder.h
index 325356f..e006545 100644
--- a/iamf/cli/codec/opus_encoder.h
+++ b/iamf/cli/codec/opus_encoder.h
@@ -65,7 +65,7 @@ class OpusEncoder : public EncoderBase {
   /*!\brief Encodes an audio frame.
    *
    * \param input_bit_depth Ignored.
-   * \param samples Samples arranged in (time x channel) axes. The samples are
+   * \param samples Samples arranged in (channel, time) axes. The samples are
    *        left-justified and stored in the upper `input_bit_depth` bits.
    * \param partial_audio_frame_with_data Unique pointer to take ownership of.
    *        The underlying `audio_frame_` is modified. All other fields are
diff --git a/iamf/cli/codec/tests/BUILD b/iamf/cli/codec/tests/BUILD
index 4ed01fa..dc64f85 100644
--- a/iamf/cli/codec/tests/BUILD
+++ b/iamf/cli/codec/tests/BUILD
@@ -8,6 +8,7 @@ cc_library(
         "//iamf/cli:audio_frame_with_data",
         "//iamf/cli/codec:encoder_base",
         "//iamf/obu:audio_frame",
+        "//iamf/obu:types",
         "@com_google_absl//absl/memory",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:status_matchers",
@@ -61,7 +62,6 @@ cc_test(
     name = "flac_decoder_stream_callbacks_test",
     srcs = ["flac_decoder_stream_callbacks_test.cc"],
     deps = [
-        "//iamf/cli/codec:flac_decoder",
         "//iamf/cli/codec:flac_decoder_stream_callbacks",
         "@com_google_googletest//:gtest_main",
         "@flac//:src",
@@ -72,10 +72,10 @@ cc_test(
     name = "flac_decoder_test",
     srcs = ["flac_decoder_test.cc"],
     deps = [
+        "//iamf/cli/codec:decoder_base",
         "//iamf/cli/codec:flac_decoder",
         "@com_google_absl//absl/status:status_matchers",
         "@com_google_googletest//:gtest_main",
-        "@flac//:src",
     ],
 )
 
@@ -100,6 +100,7 @@ cc_test(
     size = "small",
     srcs = ["lpcm_decoder_test.cc"],
     deps = [
+        "//iamf/cli/codec:decoder_base",
         "//iamf/cli/codec:lpcm_decoder",
         "//iamf/obu:codec_config",
         "//iamf/obu:obu_header",
diff --git a/iamf/cli/codec/tests/aac_encoder_test.cc b/iamf/cli/codec/tests/aac_encoder_test.cc
index 6ae14e8..7f36566 100644
--- a/iamf/cli/codec/tests/aac_encoder_test.cc
+++ b/iamf/cli/codec/tests/aac_encoder_test.cc
@@ -81,7 +81,7 @@ TEST_F(AacEncoderTest, FramesAreInOrder) {
   const int kNumFrames = 100;
   for (int i = 0; i < kNumFrames; i++) {
     EncodeAudioFrame(std::vector<std::vector<int32_t>>(
-        num_samples_per_frame_, std::vector<int32_t>(num_channels_, i)));
+        num_channels_, std::vector<int32_t>(num_samples_per_frame_, i)));
   }
   FinalizeAndValidateOrderOnly(kNumFrames);
 }
diff --git a/iamf/cli/codec/tests/decoder_base_test.cc b/iamf/cli/codec/tests/decoder_base_test.cc
index aa27c37..49e6705 100644
--- a/iamf/cli/codec/tests/decoder_base_test.cc
+++ b/iamf/cli/codec/tests/decoder_base_test.cc
@@ -21,10 +21,6 @@ class MockDecoder : public DecoderBase {
 
   // Unimplemented implementations for base class pure virtual methods
   // that we won't test.
-  absl::Status Initialize() override {
-    return absl::UnimplementedError("Not implemented");
-  }
-
   absl::Status DecodeAudioFrame(
       const std::vector<uint8_t>& encoded_frame) override {
     return absl::UnimplementedError("Not implemented");
diff --git a/iamf/cli/codec/tests/encoder_base_test.cc b/iamf/cli/codec/tests/encoder_base_test.cc
index cc6b9fc..18f3cbb 100644
--- a/iamf/cli/codec/tests/encoder_base_test.cc
+++ b/iamf/cli/codec/tests/encoder_base_test.cc
@@ -107,8 +107,8 @@ TEST(EncoderBaseTest, FinalizeAndPopAppendNothingWhenNoFramesAvailable) {
   // `Finalize()` and `Pop()`, because we know an empty list
   // (`finalized_audio_frames_`) is appended at the end.
   const DecodedUleb128 kSubstreamId = 137;
-  const int32_t kStartTimestamp = 77;
-  const int32_t kEndTimestamp = 101;
+  const InternalTimestamp kStartTimestamp = 77;
+  const InternalTimestamp kEndTimestamp = 101;
   const std::vector<uint8_t> kAudioFrame = {1, 7, 5, 3};
   AudioFrameObu obu(ObuHeader(), kSubstreamId, kAudioFrame);
   std::list<AudioFrameWithData> audio_frames;
diff --git a/iamf/cli/codec/tests/encoder_test_base.h b/iamf/cli/codec/tests/encoder_test_base.h
index d4c53df..3896485 100644
--- a/iamf/cli/codec/tests/encoder_test_base.h
+++ b/iamf/cli/codec/tests/encoder_test_base.h
@@ -26,6 +26,7 @@
 #include "iamf/cli/audio_frame_with_data.h"
 #include "iamf/cli/codec/encoder_base.h"
 #include "iamf/obu/audio_frame.h"
+#include "iamf/obu/types.h"
 
 namespace iamf_tools {
 
@@ -51,8 +52,8 @@ class EncoderTestBase {
     // `EncodeAudioFrame` only passes on most of the data in the input
     // `AudioFrameWithData`. Simulate the timestamp to ensure frames are
     // returned in the correct order, but most other fields do not matter.
-    const int32_t next_timestamp =
-        cur_timestamp_ + static_cast<int32_t>(num_samples_per_frame_);
+    const InternalTimestamp next_timestamp =
+        cur_timestamp_ + static_cast<InternalTimestamp>(num_samples_per_frame_);
     auto partial_audio_frame_with_data =
         absl::WrapUnique(new AudioFrameWithData{
             .obu = AudioFrameObu(
@@ -131,7 +132,7 @@ class EncoderTestBase {
     }
   }
 
-  int32_t cur_timestamp_ = 0;
+  InternalTimestamp cur_timestamp_ = 0;
 };
 
 }  // namespace iamf_tools
diff --git a/iamf/cli/codec/tests/flac_decoder_stream_callbacks_test.cc b/iamf/cli/codec/tests/flac_decoder_stream_callbacks_test.cc
index 99a19db..f6019aa 100644
--- a/iamf/cli/codec/tests/flac_decoder_stream_callbacks_test.cc
+++ b/iamf/cli/codec/tests/flac_decoder_stream_callbacks_test.cc
@@ -18,7 +18,6 @@
 
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
-#include "iamf/cli/codec/flac_decoder.h"
 #include "include/FLAC/format.h"
 #include "include/FLAC/ordinals.h"
 #include "include/FLAC/stream_decoder.h"
@@ -31,48 +30,170 @@ using ::testing::ElementsAreArray;
 constexpr uint32_t kNumSamplesPerFrame = 1024;
 constexpr int kNumChannels = 2;
 
+using flac_callbacks::LibFlacCallbackData;
+
+TEST(LibFlacCallbackData, ConstructorSetsNumSamplesPerChannel) {
+  std::vector<std::vector<int32_t>> decoded_frame;
+  LibFlacCallbackData callback_data(kNumSamplesPerFrame, decoded_frame);
+
+  EXPECT_EQ(callback_data.num_samples_per_channel_, kNumSamplesPerFrame);
+}
+
+TEST(LibFlacCallbackData, SetEncodedFrameRemovesPreviouslySetFrame) {
+  std::vector<std::vector<int32_t>> decoded_frame;
+  LibFlacCallbackData callback_data(kNumSamplesPerFrame, decoded_frame);
+  // Intentionally get the buffer to a state where it was partially exhausted.
+  callback_data.SetEncodedFrame({99, 100});
+  // Intentionally avoid exhausting the buffer.
+  callback_data.GetNextSlice(1);
+
+  // Resetting it gets rid of any trace of the previous frame.
+  const std::vector<uint8_t> encoded_frame = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+  callback_data.SetEncodedFrame(encoded_frame);
+  EXPECT_EQ(callback_data.GetNextSlice(10), encoded_frame);
+}
+
+TEST(LibFlacCallbackData, GetNextSliceCapsOutputToAtMostRemainingSize) {
+  std::vector<std::vector<int32_t>> decoded_frame;
+  LibFlacCallbackData callback_data(kNumSamplesPerFrame, decoded_frame);
+  const std::vector<uint8_t> kEncodedFrame = {99, 100};
+  callback_data.SetEncodedFrame(kEncodedFrame);
+
+  // It's ok to request more bytes than are available, fewer will be returned if
+  // there are not enough left.
+  EXPECT_EQ(callback_data.GetNextSlice(kEncodedFrame.size() + 1),
+            kEncodedFrame);
+}
+
+TEST(LibFlacCallbackData, RepeatedCallsToGetNextSliceReturnNextSlice) {
+  std::vector<std::vector<int32_t>> decoded_frame;
+  LibFlacCallbackData callback_data(kNumSamplesPerFrame, decoded_frame);
+  const std::vector<uint8_t> encoded_frame = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+  callback_data.SetEncodedFrame(encoded_frame);
+
+  EXPECT_EQ(callback_data.GetNextSlice(5),
+            std::vector<uint8_t>({1, 2, 3, 4, 5}));
+  EXPECT_EQ(callback_data.GetNextSlice(5),
+            std::vector<uint8_t>({6, 7, 8, 9, 10}));
+}
+
+TEST(LibFlacCallbackData, CallsWhenBufferIsExhaustedReturnEmptySpan) {
+  std::vector<std::vector<int32_t>> decoded_frame;
+  LibFlacCallbackData callback_data(kNumSamplesPerFrame, decoded_frame);
+  constexpr int kNumBytes = 5;
+  const std::vector<uint8_t> encoded_frame(kNumBytes, 0);
+  callback_data.SetEncodedFrame(encoded_frame);
+  callback_data.GetNextSlice(kNumBytes);
+
+  EXPECT_TRUE(callback_data.GetNextSlice(kNumBytes).empty());
+}
+
 TEST(LibFlacReadCallback, ReadCallbackReturnsEndOfStreamForEmptyFrame) {
-  FlacDecoder flac_decoder(kNumChannels, kNumSamplesPerFrame);
+  const std::vector<uint8_t> kEmptyFrame;
+  std::vector<std::vector<int32_t>> decoded_frame;
+  LibFlacCallbackData callback_data(kNumSamplesPerFrame, decoded_frame);
   FLAC__byte buffer[1024];
   size_t bytes = 1024;
 
-  auto status = LibFlacReadCallback(/*stream_decoder=*/nullptr, buffer, &bytes,
-                                    &flac_decoder);
+  auto status = flac_callbacks::LibFlacReadCallback(
+      /*stream_decoder=*/nullptr, buffer, &bytes, &callback_data);
 
   EXPECT_EQ(status, FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM);
   EXPECT_EQ(bytes, 0);
 }
 
-TEST(LibFlacReadCallback, ReadCallbackReturnsAbortForTooLargeFrame) {
-  FlacDecoder flac_decoder(kNumChannels, kNumSamplesPerFrame);
+TEST(LibFlacReadCallback, ReadCallbackReturnsAbortForNullPtrs) {
+  std::vector<std::vector<int32_t>> decoded_frame;
+  LibFlacCallbackData callback_data(kNumSamplesPerFrame, decoded_frame);
   FLAC__byte buffer[1024];
   size_t bytes = 1024;
-  flac_decoder.SetEncodedFrame(std::vector<uint8_t>(1025));
 
+  // Various `nullptr` arguments will force the callback to abort.
+  EXPECT_EQ(flac_callbacks::LibFlacReadCallback(
+                /*stream_decoder=*/nullptr, /*buffer=*/nullptr, &bytes,
+                &callback_data),
+            FLAC__STREAM_DECODER_READ_STATUS_ABORT);
+  EXPECT_EQ(flac_callbacks::LibFlacReadCallback(
+                /*stream_decoder=*/nullptr, buffer, /*bytes=*/nullptr,
+                &callback_data),
+            FLAC__STREAM_DECODER_READ_STATUS_ABORT);
+  EXPECT_EQ(flac_callbacks::LibFlacReadCallback(/*stream_decoder=*/nullptr,
+                                                buffer, &bytes,
+                                                /*client_data=*/nullptr),
+            FLAC__STREAM_DECODER_READ_STATUS_ABORT);
+}
+
+TEST(LibFlacReadCallback, EachCallToReadCallbackWritesUpToBufferSize) {
+  std::vector<std::vector<int32_t>> decoded_frame;
+  LibFlacCallbackData callback_data(kNumSamplesPerFrame, decoded_frame);
+  // Simulate `libFLAC` requestes 8 bytes at a time.
+  const size_t kFlacBufferSize = 8;
+  FLAC__byte buffer[kFlacBufferSize];
+  // But raw frame has 9 bytes.
+  callback_data.SetEncodedFrame({1, 2, 3, 4, 5, 6, 7, 8, 9});
+
+  // The first call loads the first 8 bytes.
+  size_t bytes = kFlacBufferSize;
   auto status = LibFlacReadCallback(/*stream_decoder=*/nullptr, buffer, &bytes,
-                                    &flac_decoder);
+                                    &callback_data);
+  EXPECT_EQ(status, FLAC__STREAM_DECODER_READ_STATUS_CONTINUE);
+  EXPECT_EQ(bytes, 8);
+  EXPECT_THAT(buffer, ElementsAreArray({1, 2, 3, 4, 5, 6, 7, 8}));
+
+  // The second call loads the last byte.
+  bytes = kFlacBufferSize;
+  status = LibFlacReadCallback(/*stream_decoder=*/nullptr, buffer, &bytes,
+                               &callback_data);
+  EXPECT_EQ(status, FLAC__STREAM_DECODER_READ_STATUS_CONTINUE);
+  EXPECT_EQ(bytes, 1);
+  // Expect the first byte is 9 using a matcher
+  EXPECT_THAT(buffer[0], 9);
 
-  EXPECT_EQ(status, FLAC__STREAM_DECODER_READ_STATUS_ABORT);
+  // Finally the frame is exhausted, subsequent calls return end of stream.
+  bytes = kFlacBufferSize;
+  status = LibFlacReadCallback(/*stream_decoder=*/nullptr, buffer, &bytes,
+                               &callback_data);
+  EXPECT_EQ(status, FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM);
   EXPECT_EQ(bytes, 0);
 }
 
+TEST(LibFlacReadCallback, ConsumesEncodedFrame) {
+  std::vector<std::vector<int32_t>> decoded_frame;
+  LibFlacCallbackData callback_data(kNumSamplesPerFrame, decoded_frame);
+  FLAC__byte buffer[1024];
+  size_t bytes = 1028;
+  const std::vector<uint8_t> encoded_frame(1024, 1);
+  callback_data.SetEncodedFrame(encoded_frame);
+
+  auto status = flac_callbacks::LibFlacReadCallback(
+      /*stream_decoder=*/nullptr, buffer, &bytes, &callback_data);
+
+  EXPECT_EQ(status, FLAC__STREAM_DECODER_READ_STATUS_CONTINUE);
+  // Any further reads are safe, but will return an empty span.
+  const size_t kChunkSize = 1;
+  EXPECT_TRUE(callback_data.GetNextSlice(kChunkSize).empty());
+}
+
 TEST(LibFlacReadCallback, Success) {
-  FlacDecoder flac_decoder(kNumChannels, kNumSamplesPerFrame);
+  std::vector<std::vector<int32_t>> decoded_frame;
+  LibFlacCallbackData callback_data(kNumSamplesPerFrame, decoded_frame);
   FLAC__byte buffer[1024];
   size_t bytes = 1028;
   const std::vector<uint8_t> encoded_frame(1024, 1);
-  flac_decoder.SetEncodedFrame(encoded_frame);
+  callback_data.SetEncodedFrame(encoded_frame);
 
-  auto status = LibFlacReadCallback(/*stream_decoder=*/nullptr, buffer, &bytes,
-                                    &flac_decoder);
+  auto status = flac_callbacks::LibFlacReadCallback(
+      /*stream_decoder=*/nullptr, buffer, &bytes, &callback_data);
 
   EXPECT_EQ(status, FLAC__STREAM_DECODER_READ_STATUS_CONTINUE);
   EXPECT_EQ(bytes, 1024);
   EXPECT_THAT(buffer, ElementsAreArray(encoded_frame));
 }
 
-TEST(LibFlacWriteCallback, Success32BitSamples) {
-  FlacDecoder flac_decoder(kNumChannels, kNumSamplesPerFrame);
+TEST(LibFlacWriteCallback, SucceedsFor32BitSamples) {
+  constexpr int kThreeSamplesPerFrame = 3;
+  std::vector<std::vector<int32_t>> decoded_frame;
+  LibFlacCallbackData callback_data(kThreeSamplesPerFrame, decoded_frame);
   const FLAC__Frame kFlacFrame = {.header = {.blocksize = 3,
                                              .channels = kNumChannels,
                                              .bits_per_sample = 32}};
@@ -80,31 +201,79 @@ TEST(LibFlacWriteCallback, Success32BitSamples) {
   FLAC__int32 channel_1[] = {2, 3, 4};
   const FLAC__int32 *const buffer[] = {channel_0, channel_1};
 
-  auto status = LibFlacWriteCallback(/*stream_decoder=*/nullptr, &kFlacFrame,
-                                     buffer, &flac_decoder);
+  auto status = flac_callbacks::LibFlacWriteCallback(
+      /*stream_decoder=*/nullptr, &kFlacFrame, buffer, &callback_data);
 
   EXPECT_EQ(status, FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE);
-  EXPECT_THAT(flac_decoder.GetDecodedFrame(),
+  EXPECT_THAT(callback_data.decoded_frame_,
               ElementsAreArray(std::vector<std::vector<int32_t>>(
                   {{1, 0x7fffffff, 3}, {2, 3, 4}})));
 }
 
-TEST(LibFlacWriteCallback, Success16BitSamples) {
-  FlacDecoder flac_decoder(kNumChannels, kNumSamplesPerFrame);
+TEST(LibFlacWriteCallback, SucceedsFor16BitSamples) {
+  constexpr int kTwoSamplesPerFrame = 2;
+  std::vector<std::vector<int32_t>> decoded_frame;
+  LibFlacCallbackData callback_data(kTwoSamplesPerFrame, decoded_frame);
   const FLAC__Frame kFlacFrame = {.header = {.blocksize = 2,
                                              .channels = kNumChannels,
                                              .bits_per_sample = 16}};
-  FLAC__int32 channel_0[] = {0x11110000, 0x7fff0000};
-  FLAC__int32 channel_1[] = {0x01010000, 0x22220000};
+  FLAC__int32 channel_0[] = {0x00001111, 0x0000ffff};
+  FLAC__int32 channel_1[] = {0x00000101, 0x00002222};
   const FLAC__int32 *const buffer[] = {channel_0, channel_1};
 
-  auto status = LibFlacWriteCallback(/*stream_decoder=*/nullptr, &kFlacFrame,
-                                     buffer, &flac_decoder);
+  auto status = flac_callbacks::LibFlacWriteCallback(
+      /*stream_decoder=*/nullptr, &kFlacFrame, buffer, &callback_data);
 
   EXPECT_EQ(status, FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE);
-  EXPECT_THAT(flac_decoder.GetDecodedFrame(),
+  EXPECT_THAT(callback_data.decoded_frame_,
               ElementsAreArray(std::vector<std::vector<int32_t>>(
-                  {{0x11110000, 0x7fff0000}, {0x01010000, 0x22220000}})));
+                  {{0x11110000, static_cast<int32_t>(0xffff0000)},
+                   {0x01010000, 0x22220000}})));
+}
+
+TEST(LibFlacWriteCallback, ReturnsStatusAbortForTooSmallBlockSize) {
+  constexpr int kTwoSamplesPerFrame = 2;
+  constexpr int kLargerBlockSize = 3;
+  // num_samples_per_channel = 2, but the encoded frame has 3 samples per
+  // channel.
+  std::vector<std::vector<int32_t>> decoded_frame;
+  LibFlacCallbackData callback_data(kTwoSamplesPerFrame, decoded_frame);
+  const FLAC__Frame kFlacFrame = {.header = {.blocksize = kLargerBlockSize,
+                                             .channels = kNumChannels,
+                                             .bits_per_sample = 32}};
+  FLAC__int32 channel_0[] = {1, 0x7fffffff, 3};
+  FLAC__int32 channel_1[] = {2, 3, 4};
+  const FLAC__int32 *const buffer[] = {channel_0, channel_1};
+
+  auto status = flac_callbacks::LibFlacWriteCallback(
+      /*stream_decoder=*/nullptr, &kFlacFrame, buffer, &callback_data);
+
+  EXPECT_EQ(status, FLAC__STREAM_DECODER_WRITE_STATUS_ABORT);
+}
+
+TEST(LibFlacWriteCallback, FillsExtraSamplesWithZeros) {
+  constexpr int kFourSamplesPerFrame = 4;
+  constexpr int kSmallerBlockSize = 3;
+  // num_samples_per_channel = 4, but the encoded frame has 3 samples per
+  // channel.
+  std::vector<std::vector<int32_t>> decoded_frame;
+  LibFlacCallbackData callback_data(kFourSamplesPerFrame, decoded_frame);
+  const FLAC__Frame kFlacFrame = {.header = {.blocksize = kSmallerBlockSize,
+                                             .channels = kNumChannels,
+                                             .bits_per_sample = 32}};
+  FLAC__int32 channel_0[] = {1, 0x7fffffff, 3};
+  FLAC__int32 channel_1[] = {2, 3, 4};
+  const FLAC__int32 *const buffer[] = {channel_0, channel_1};
+
+  auto status = flac_callbacks::LibFlacWriteCallback(
+      /*stream_decoder=*/nullptr, &kFlacFrame, buffer, &callback_data);
+
+  // The last sample is extra, and should be filled with zeros.
+  EXPECT_EQ(status, FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE);
+  EXPECT_EQ(callback_data.decoded_frame_.size(), kNumChannels);
+  for (int c = 0; c < kNumChannels; c++) {
+    EXPECT_EQ(callback_data.decoded_frame_[c][3], 0);
+  }
 }
 
 }  // namespace
diff --git a/iamf/cli/codec/tests/flac_decoder_test.cc b/iamf/cli/codec/tests/flac_decoder_test.cc
index cb91cf6..4520070 100644
--- a/iamf/cli/codec/tests/flac_decoder_test.cc
+++ b/iamf/cli/codec/tests/flac_decoder_test.cc
@@ -13,22 +13,24 @@
 #include "iamf/cli/codec/flac_decoder.h"
 
 #include <array>
-#include <cstddef>
 #include <cstdint>
+#include <memory>
+#include <utility>
 #include <vector>
 
 #include "absl/status/status_matchers.h"
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
-#include "include/FLAC/format.h"
-#include "include/FLAC/ordinals.h"
-#include "include/FLAC/stream_decoder.h"
+#include "iamf/cli/codec/decoder_base.h"
 
 namespace iamf_tools {
 namespace {
 
 using ::absl_testing::IsOk;
+using ::absl_testing::IsOkAndHolds;
 using ::testing::ElementsAreArray;
+using ::testing::IsNull;
+using ::testing::Not;
 using ::testing::Test;
 
 // Derived from iamf/cli/testdata/stereo_8_samples_48khz_s16le.wav @ 16 samples
@@ -40,154 +42,87 @@ constexpr std::array<uint8_t, 22> kFlacEncodedFrame = {
 constexpr uint32_t kNumSamplesPerFrame = 16;
 constexpr int kNumChannels = 2;
 
-TEST(LibflacReadCallback, SignalsEndOfStreamForEmptyFrame) {
-  FlacDecoder flac_decoder(kNumChannels, kNumSamplesPerFrame);
-  FLAC__byte buffer[1024];
-  size_t bytes = 1024;
-
-  auto status = FlacDecoder::LibFlacReadCallback(
-      /*stream_decoder=*/nullptr, buffer, &bytes, &flac_decoder);
-
-  EXPECT_EQ(status, FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM);
-  EXPECT_EQ(bytes, 0);
-}
-
-TEST(LibFlacReadCallback, SignalsAbortForTooLargeFrame) {
-  FlacDecoder flac_decoder(kNumChannels, kNumSamplesPerFrame);
-  FLAC__byte buffer[1024];
-  size_t bytes = 1024;
-  flac_decoder.SetEncodedFrame(std::vector<uint8_t>(1025));
-
-  auto status = FlacDecoder::LibFlacReadCallback(
-      /*stream_decoder=*/nullptr, buffer, &bytes, &flac_decoder);
-
-  EXPECT_EQ(status, FLAC__STREAM_DECODER_READ_STATUS_ABORT);
-  EXPECT_EQ(bytes, 0);
-}
-
-TEST(LibFlacReadCallback, Success) {
-  FlacDecoder flac_decoder(kNumChannels, kNumSamplesPerFrame);
-  FLAC__byte buffer[1024];
-  size_t bytes = 1028;
-  const std::vector<uint8_t> encoded_frame(1024, 1);
-  flac_decoder.SetEncodedFrame(encoded_frame);
-
-  auto status = FlacDecoder::LibFlacReadCallback(
-      /*stream_decoder=*/nullptr, buffer, &bytes, &flac_decoder);
-
-  EXPECT_EQ(status, FLAC__STREAM_DECODER_READ_STATUS_CONTINUE);
-  EXPECT_EQ(bytes, 1024);
-  EXPECT_THAT(buffer, ElementsAreArray(encoded_frame));
+std::unique_ptr<DecoderBase> CreateFlacDecoderExpectNonNull(
+    int num_channels, uint32_t num_samples_per_frame) {
+  auto flac_decoder = FlacDecoder::Create(num_channels, num_samples_per_frame);
+  EXPECT_THAT(flac_decoder, IsOkAndHolds(Not(IsNull())));
+  return std::move(*flac_decoder);
 }
 
-TEST(LibFlacWriteCallback, SucceedsFor32BitSamples) {
-  constexpr int kThreeSamplesPerFrame = 3;
-  FlacDecoder flac_decoder(kNumChannels, kThreeSamplesPerFrame);
-  const FLAC__Frame kFlacFrame = {.header = {.blocksize = 3,
-                                             .channels = kNumChannels,
-                                             .bits_per_sample = 32}};
-  FLAC__int32 channel_0[] = {1, 0x7fffffff, 3};
-  FLAC__int32 channel_1[] = {2, 3, 4};
-  const FLAC__int32 *const buffer[] = {channel_0, channel_1};
-
-  auto status = FlacDecoder::LibFlacWriteCallback(
-      /*stream_decoder=*/nullptr, &kFlacFrame, buffer, &flac_decoder);
-
-  EXPECT_EQ(status, FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE);
-  EXPECT_THAT(flac_decoder.GetDecodedFrame(),
-              ElementsAreArray(std::vector<std::vector<int32_t>>(
-                  {{1, 2}, {0x7fffffff, 3}, {3, 4}})));
+TEST(Create, Succeeds) {
+  auto flac_decoder = FlacDecoder::Create(kNumChannels, kNumSamplesPerFrame);
+  EXPECT_THAT(flac_decoder, IsOkAndHolds(Not(IsNull())));
 }
 
-TEST(LibFlacWriteCallback, SucceedsFor16BitSamples) {
-  constexpr int kTwoSamplesPerFrame = 2;
-  FlacDecoder flac_decoder(kNumChannels, kTwoSamplesPerFrame);
-  const FLAC__Frame kFlacFrame = {.header = {.blocksize = 2,
-                                             .channels = kNumChannels,
-                                             .bits_per_sample = 16}};
-  FLAC__int32 channel_0[] = {0x00001111, 0x0000ffff};
-  FLAC__int32 channel_1[] = {0x00000101, 0x00002222};
-  const FLAC__int32 *const buffer[] = {channel_0, channel_1};
-
-  auto status = FlacDecoder::LibFlacWriteCallback(
-      /*stream_decoder=*/nullptr, &kFlacFrame, buffer, &flac_decoder);
-
-  EXPECT_EQ(status, FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE);
-  EXPECT_THAT(flac_decoder.GetDecodedFrame(),
-              ElementsAreArray(std::vector<std::vector<int32_t>>(
-                  {{0x11110000, 0x01010000},
-                   {static_cast<int32_t>(0xffff0000), 0x22220000}})));
-}
+TEST(DecodeAudioFrame, SubsequentCallsSucceed) {
+  auto flac_decoder =
+      CreateFlacDecoderExpectNonNull(kNumChannels, kNumSamplesPerFrame);
 
-TEST(LibFlacWriteCallback, ReturnsStatusAbortForMismatchedBlocksize) {
-  constexpr int kFiveSamplesPerFrame = 5;
-  // num_samples_per_channel = 5, but the encoded frame has 3 samples per
-  // channel.
-  FlacDecoder flac_decoder(kNumChannels, kFiveSamplesPerFrame);
-  const FLAC__Frame kFlacFrame = {.header = {.blocksize = 3,
-                                             .channels = kNumChannels,
-                                             .bits_per_sample = 32}};
-  FLAC__int32 channel_0[] = {1, 0x7fffffff, 3};
-  FLAC__int32 channel_1[] = {2, 3, 4};
-  const FLAC__int32 *const buffer[] = {channel_0, channel_1};
-
-  auto status = FlacDecoder::LibFlacWriteCallback(
-      /*stream_decoder=*/nullptr, &kFlacFrame, buffer, &flac_decoder);
-
-  EXPECT_EQ(status, FLAC__STREAM_DECODER_WRITE_STATUS_ABORT);
-}
-
-TEST(Initialize, Succeeds) {
-  FlacDecoder flac_decoder(kNumChannels, kNumSamplesPerFrame);
+  EXPECT_THAT(flac_decoder->DecodeAudioFrame(std::vector(
+                  kFlacEncodedFrame.begin(), kFlacEncodedFrame.end())),
+              IsOk());
+  const std::vector<std::vector<int32_t>> kExpectedDecodedSamples = {
+      {0x00010000, 0x00020000, 0x00030000, 0x00040000, 0x00050000, 0x00060000,
+       0x00070000, 0x00080000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+       0x00000000, 0x00000000, 0x00000000, 0x00000000},
+      {static_cast<int32_t>(0xffff0000), static_cast<int32_t>(0xfffe0000),
+       static_cast<int32_t>(0xfffd0000), static_cast<int32_t>(0xfffc0000),
+       static_cast<int32_t>(0xfffb0000), static_cast<int32_t>(0xfffa0000),
+       static_cast<int32_t>(0xfff90000), static_cast<int32_t>(0xfff80000),
+       0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+       0x00000000, 0x00000000}};
+
+  EXPECT_EQ(flac_decoder->ValidDecodedSamples(), kExpectedDecodedSamples);
 
-  EXPECT_THAT(flac_decoder.Initialize(), IsOk());
+  // Decode again.
+  EXPECT_THAT(flac_decoder->DecodeAudioFrame(std::vector(
+                  kFlacEncodedFrame.begin(), kFlacEncodedFrame.end())),
+              IsOk());
+  EXPECT_EQ(flac_decoder->ValidDecodedSamples(), kExpectedDecodedSamples);
 }
 
-TEST(DecodeAudioFrame, Succeeds) {
-  FlacDecoder flac_decoder(kNumChannels, kNumSamplesPerFrame);
-
-  EXPECT_THAT(flac_decoder.Initialize(), IsOk());
-  auto status = flac_decoder.DecodeAudioFrame(
-      std::vector(kFlacEncodedFrame.begin(), kFlacEncodedFrame.end()));
-  EXPECT_THAT(status, IsOk());
+TEST(DecodeAudioFrame, DoesNotHangOnInvalidFrame) {
+  auto flac_decoder =
+      CreateFlacDecoderExpectNonNull(kNumChannels, kNumSamplesPerFrame);
 
-  const std::vector<std::vector<int32_t>> kExpectedDecodedSamples = {
-      {0x00010000, static_cast<int32_t>(0xffff0000)},
-      {0x00020000, static_cast<int32_t>(0xfffe0000)},
-      {0x00030000, static_cast<int32_t>(0xfffd0000)},
-      {0x00040000, static_cast<int32_t>(0xfffc0000)},
-      {0x00050000, static_cast<int32_t>(0xfffb0000)},
-      {0x00060000, static_cast<int32_t>(0xfffa0000)},
-      {0x00070000, static_cast<int32_t>(0xfff90000)},
-      {0x00080000, static_cast<int32_t>(0xfff80000)},
-      {0x00000000, 0x00000000},
-      {0x00000000, 0x00000000},
-      {0x00000000, 0x00000000},
-      {0x00000000, 0x00000000},
-      {0x00000000, 0x00000000},
-      {0x00000000, 0x00000000},
-      {0x00000000, 0x00000000},
-      {0x00000000, 0x00000000}};
-  EXPECT_EQ(flac_decoder.ValidDecodedSamples(), kExpectedDecodedSamples);
+  const std::vector<uint8_t> kInvalidFrame = {0x00};
+  const auto status = flac_decoder->DecodeAudioFrame(
+      std::vector(kInvalidFrame.begin(), kInvalidFrame.end()));
 
-  // Decode again.
-  status = flac_decoder.DecodeAudioFrame(
-      std::vector(kFlacEncodedFrame.begin(), kFlacEncodedFrame.end()));
-  EXPECT_THAT(status, IsOk());
-  EXPECT_EQ(flac_decoder.ValidDecodedSamples(), kExpectedDecodedSamples);
+  // The frame is not valid, but we expect to not hang and get an error status.
+  EXPECT_THAT(status, Not(IsOk()));
 }
 
-TEST(DecodeAudioFrame, FailsOnMismatchedBlocksize) {
-  constexpr uint32_t kNumSamplesPerFrame = 32;
-  // num_samples_per_channel = 32, but the encoded frame has 16 samples per
+TEST(DecodeAudioFrame, FailsOnMismatchedBlocksizeTooLarge) {
+  constexpr uint32_t kNumSamplesPerFrame = 15;
+  // num_samples_per_channel = 15, but the encoded frame has 16 samples per
   // channel.
-  FlacDecoder flac_decoder(kNumChannels, kNumSamplesPerFrame);
-  EXPECT_THAT(flac_decoder.Initialize(), IsOk());
+  auto flac_decoder =
+      CreateFlacDecoderExpectNonNull(kNumChannels, kNumSamplesPerFrame);
 
-  auto status = flac_decoder.DecodeAudioFrame(
-      std::vector(kFlacEncodedFrame.begin(), kFlacEncodedFrame.end()));
+  EXPECT_THAT(flac_decoder->DecodeAudioFrame(std::vector(
+                  kFlacEncodedFrame.begin(), kFlacEncodedFrame.end())),
+              Not(IsOk()));
+}
 
-  EXPECT_FALSE(status.ok());
+TEST(DecodeAudioFrame, FillsExtraSamplesWithZeros) {
+  constexpr uint32_t kNumSamplesPerFrame = 17;
+  // num_samples_per_channel = 17, but the actual encoded frame has 16 samples
+  // per channel.
+  auto flac_decoder =
+      CreateFlacDecoderExpectNonNull(kNumChannels, kNumSamplesPerFrame);
+
+  EXPECT_THAT(flac_decoder->DecodeAudioFrame(std::vector(
+                  kFlacEncodedFrame.begin(), kFlacEncodedFrame.end())),
+              IsOk());
+  const auto decoded_samples = flac_decoder->ValidDecodedSamples();
+
+  // Ok, we still expect 2 channels with 17 samples per channel. The last sample
+  // of each channel is filled with a zero, and typically would be trimmed.
+  EXPECT_EQ(decoded_samples.size(), kNumChannels);
+  for (int c = 0; c < kNumChannels; c++) {
+    EXPECT_EQ(decoded_samples[c].back(), 0);
+  }
 }
 
 }  // namespace
diff --git a/iamf/cli/codec/tests/flac_encoder_test.cc b/iamf/cli/codec/tests/flac_encoder_test.cc
index 994e174..e63fe66 100644
--- a/iamf/cli/codec/tests/flac_encoder_test.cc
+++ b/iamf/cli/codec/tests/flac_encoder_test.cc
@@ -78,7 +78,7 @@ TEST_F(FlacEncoderTest, FramesAreInOrder) {
   const int kNumFrames = 100;
   for (int i = 0; i < kNumFrames; i++) {
     EncodeAudioFrame(std::vector<std::vector<int32_t>>(
-        num_samples_per_frame_, std::vector<int32_t>(num_channels_, i)));
+        num_channels_, std::vector<int32_t>(num_samples_per_frame_, i)));
   }
   FinalizeAndValidateOrderOnly(kNumFrames);
 }
@@ -96,7 +96,7 @@ TEST_F(FlacEncoderTest, EncodeAudioFrameSucceeds) {
   // Typically the user of the encoder should pad partial frames of input data
   // before passing it into the encoder.
   const std::vector<std::vector<int32_t>> kAudioFrameWithCorrectNumSamples(
-      num_samples_per_frame_, std::vector<int32_t>(num_channels_, 0));
+      num_channels_, std::vector<int32_t>(num_samples_per_frame_, 0));
   InitExpectOk();
 
   EncodeAudioFrame(kAudioFrameWithCorrectNumSamples);
@@ -107,7 +107,7 @@ TEST_F(FlacEncoderTest,
   // Typically the user of the encoder should pad partial frames of input data
   // before passing it into the encoder.
   const std::vector<std::vector<int32_t>> kAudioFrameWithMissingSample(
-      num_samples_per_frame_ - 1, std::vector<int32_t>(num_channels_, 0));
+      num_channels_, std::vector<int32_t>(num_samples_per_frame_ - 1, 0));
   InitExpectOk();
 
   EncodeAudioFrame(kAudioFrameWithMissingSample,
@@ -117,7 +117,7 @@ TEST_F(FlacEncoderTest,
 TEST_F(FlacEncoderTest,
        EncodeAudioFrameFailsWhenAudioFrameIsLargerThanNumSamplesPerFrame) {
   const std::vector<std::vector<int32_t>> kAudioFrameWithExtraSample(
-      num_samples_per_frame_ + 1, std::vector<int32_t>(num_channels_, 0));
+      num_channels_, std::vector<int32_t>(num_samples_per_frame_ + 1, 0));
   InitExpectOk();
 
   EncodeAudioFrame(kAudioFrameWithExtraSample,
diff --git a/iamf/cli/codec/tests/lpcm_decoder_test.cc b/iamf/cli/codec/tests/lpcm_decoder_test.cc
index f64ccb8..ff22b36 100644
--- a/iamf/cli/codec/tests/lpcm_decoder_test.cc
+++ b/iamf/cli/codec/tests/lpcm_decoder_test.cc
@@ -1,12 +1,15 @@
 #include "iamf/cli/codec/lpcm_decoder.h"
 
 #include <cstdint>
+#include <memory>
+#include <utility>
 #include <vector>
 
 #include "absl/log/log.h"
 #include "absl/status/status_matchers.h"
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
+#include "iamf/cli/codec/decoder_base.h"
 #include "iamf/obu/codec_config.h"
 #include "iamf/obu/decoder_config/lpcm_decoder_config.h"
 #include "iamf/obu/obu_header.h"
@@ -15,11 +18,17 @@ namespace iamf_tools {
 namespace {
 
 using ::absl_testing::IsOk;
+using ::absl_testing::IsOkAndHolds;
+
+using ::testing::IsEmpty;
+using ::testing::IsNull;
+using ::testing::Not;
 
 constexpr bool kOverrideAudioRollDistance = true;
 constexpr uint32_t kNumSamplesPerFrame = 1024;
 constexpr uint8_t kSampleSize16 = 16;
 constexpr bool kLittleEndian = true;
+constexpr int kTwoChannels = 2;  // Keep the amount of test data reasonable.
 
 CodecConfigObu CreateCodecConfigObu(LpcmDecoderConfig lpcm_decoder_config,
                                     uint32_t num_samples_per_frame) {
@@ -32,7 +41,7 @@ CodecConfigObu CreateCodecConfigObu(LpcmDecoderConfig lpcm_decoder_config,
   return codec_config_obu;
 };
 
-TEST(LpcmDecoderTest, Construct) {
+TEST(Create, Succeed) {
   LpcmDecoderConfig lpcm_decoder_config;
   lpcm_decoder_config.sample_rate_ = 48000;
   lpcm_decoder_config.sample_size_ = 16;
@@ -43,10 +52,11 @@ TEST(LpcmDecoderTest, Construct) {
   ASSERT_THAT(codec_config_obu.Initialize(kOverrideAudioRollDistance), IsOk());
   int number_of_channels = 11;  // Arbitrary.
 
-  LpcmDecoder lpcm_decoder(codec_config_obu, number_of_channels);
+  auto lpcm_decoder = LpcmDecoder::Create(codec_config_obu, number_of_channels);
+  EXPECT_THAT(lpcm_decoder, IsOkAndHolds(Not(IsNull())));
 }
 
-TEST(LpcmDecoderTest, Initialize_InvalidConfigFails) {
+TEST(Create, FailsWithInvalidConfig) {
   LpcmDecoderConfig lpcm_decoder_config;
   // The sample rate and bit depth are validated with CodecConfigObu::Initialize
   // so if we want to test the validation in LpcmDecoderConfig::Initialize we
@@ -60,15 +70,12 @@ TEST(LpcmDecoderTest, Initialize_InvalidConfigFails) {
   ASSERT_THAT(codec_config_obu.Initialize(kOverrideAudioRollDistance), IsOk());
   int number_of_channels = 11;  // Arbitrary.
 
-  LpcmDecoder lpcm_decoder(codec_config_obu, number_of_channels);
-  auto status = lpcm_decoder.Initialize();
-
-  EXPECT_FALSE(status.ok());
+  auto lpcm_decoder = LpcmDecoder::Create(codec_config_obu, number_of_channels);
+  EXPECT_THAT(lpcm_decoder, Not(IsOk()));
 }
 
-LpcmDecoder CreateDecoderForDecodingTest(uint8_t sample_size,
-                                         bool little_endian,
-                                         uint32_t num_samples_per_frame) {
+std::unique_ptr<DecoderBase> CreateDecoderForDecodingTest(
+    uint8_t sample_size, bool little_endian, uint32_t num_samples_per_frame) {
   LpcmDecoderConfig lpcm_decoder_config;
   // The sample rate and bit depth are validated with CodecConfigObu::Initialize
   // so if we want to test the validation in LpcmDecoderConfig::Initialize we
@@ -83,16 +90,15 @@ LpcmDecoder CreateDecoderForDecodingTest(uint8_t sample_size,
   if (!codec_config_obu.Initialize(kOverrideAudioRollDistance).ok()) {
     LOG(ERROR) << "Failed to initialize codec config OBU";
   }
-  constexpr int kTwoChannels = 2;  // Keep the amount of test data reasonable.
 
-  LpcmDecoder lpcm_decoder(codec_config_obu, kTwoChannels);
-  auto status = lpcm_decoder.Initialize();
-  return lpcm_decoder;
+  auto lpcm_decoder = LpcmDecoder::Create(codec_config_obu, kTwoChannels);
+  EXPECT_THAT(lpcm_decoder, IsOkAndHolds(Not(IsNull())));
+  return std::move(*lpcm_decoder);
 }
 
 TEST(LpcmDecoderTest, DecodeAudioFrame_FailsWhenFrameIsLargerThanExpected) {
   constexpr uint32_t kShortNumberOfSamplesPerFrame = 1;
-  LpcmDecoder lpcm_decoder = CreateDecoderForDecodingTest(
+  auto lpcm_decoder = CreateDecoderForDecodingTest(
       kSampleSize16, kLittleEndian, kShortNumberOfSamplesPerFrame);
   const std::vector<uint8_t>& kEncodedFrameWithOneSamplesPerFrame = {
       0x00, 0x00,  // 0
@@ -100,7 +106,7 @@ TEST(LpcmDecoderTest, DecodeAudioFrame_FailsWhenFrameIsLargerThanExpected) {
   };
   // The decoder is configured correctly. One sample per frame decodes fine.
   ASSERT_THAT(
-      lpcm_decoder.DecodeAudioFrame(kEncodedFrameWithOneSamplesPerFrame),
+      lpcm_decoder->DecodeAudioFrame(kEncodedFrameWithOneSamplesPerFrame),
       IsOk());
 
   // But decoding two samples per frame fails, since the decoder was configured
@@ -112,14 +118,14 @@ TEST(LpcmDecoderTest, DecodeAudioFrame_FailsWhenFrameIsLargerThanExpected) {
       0x80, 0xff,  // -128
   };
   EXPECT_FALSE(
-      lpcm_decoder.DecodeAudioFrame(kEncodedFrameWithTwoSamplesPerFrame).ok());
+      lpcm_decoder->DecodeAudioFrame(kEncodedFrameWithTwoSamplesPerFrame).ok());
 }
 
 TEST(LpcmDecoderTest, DecodeAudioFrame_LittleEndian16BitSamples) {
   uint8_t sample_size = 16;
   bool little_endian = true;
-  LpcmDecoder lpcm_decoder = CreateDecoderForDecodingTest(
-      sample_size, little_endian, kNumSamplesPerFrame);
+  auto lpcm_decoder = CreateDecoderForDecodingTest(sample_size, little_endian,
+                                                   kNumSamplesPerFrame);
   const std::vector<uint8_t>& encoded_frame = {
       0x00, 0x00,  // 0
       0x01, 0x00,  // 1
@@ -127,26 +133,25 @@ TEST(LpcmDecoderTest, DecodeAudioFrame_LittleEndian16BitSamples) {
       0x80, 0xff,  // -128
   };
 
-  auto status = lpcm_decoder.DecodeAudioFrame(encoded_frame);
-  const auto& decoded_samples = lpcm_decoder.ValidDecodedSamples();
+  EXPECT_THAT(lpcm_decoder->DecodeAudioFrame(encoded_frame), IsOk());
+  const auto& decoded_samples = lpcm_decoder->ValidDecodedSamples();
 
-  EXPECT_THAT(status, IsOk());
-  // We have two channels and four samples, so we expect two time ticks of two
+  // We have two channels and four samples, so we expect two channels of two
   // samples each.
   EXPECT_EQ(decoded_samples.size(), 2);
   EXPECT_EQ(decoded_samples[0].size(), 2);
   EXPECT_EQ(decoded_samples[0][0], 0);
-  EXPECT_EQ(decoded_samples[0][1], 0x00010000);
+  EXPECT_EQ(decoded_samples[0][1], 0x01000000);
   EXPECT_EQ(decoded_samples[1].size(), 2);
-  EXPECT_EQ(decoded_samples[1][0], 0x01000000);
+  EXPECT_EQ(decoded_samples[1][0], 0x00010000);
   EXPECT_EQ(decoded_samples[1][1], 0xff800000);
 }
 
 TEST(LpcmDecoderTest, DecodeAudioFrame_BigEndian24BitSamples) {
   uint8_t sample_size = 24;
   bool little_endian = false;
-  LpcmDecoder lpcm_decoder = CreateDecoderForDecodingTest(
-      sample_size, little_endian, kNumSamplesPerFrame);
+  auto lpcm_decoder = CreateDecoderForDecodingTest(sample_size, little_endian,
+                                                   kNumSamplesPerFrame);
   const std::vector<uint8_t>& encoded_frame = {
       0x00, 0x00, 0x00,  // 0
       0x00, 0x00, 0x01,  // 1
@@ -156,57 +161,59 @@ TEST(LpcmDecoderTest, DecodeAudioFrame_BigEndian24BitSamples) {
       0x80, 0x00, 0x00,  // -8388608
   };
 
-  auto status = lpcm_decoder.DecodeAudioFrame(encoded_frame);
-  const auto& decoded_samples = lpcm_decoder.ValidDecodedSamples();
+  EXPECT_THAT(lpcm_decoder->DecodeAudioFrame(encoded_frame), IsOk());
+  const auto& decoded_samples = lpcm_decoder->ValidDecodedSamples();
 
-  EXPECT_THAT(status, IsOk());
-  // We have two channels and six samples, so we expect three time ticks of two
+  // We have two channels and six samples, so we expect two channels of three
   // samples each.
-  EXPECT_EQ(decoded_samples.size(), 3);
-  EXPECT_EQ(decoded_samples[0].size(), 2);
+  EXPECT_EQ(decoded_samples.size(), 2);
+  EXPECT_EQ(decoded_samples[0].size(), 3);
   EXPECT_EQ(decoded_samples[0][0], 0);
-  EXPECT_EQ(decoded_samples[0][1], 0x00000100);
-  EXPECT_EQ(decoded_samples[1].size(), 2);
-  EXPECT_EQ(decoded_samples[1][0], 0x00000300);
+  EXPECT_EQ(decoded_samples[0][1], 0x00000300);
+  EXPECT_EQ(decoded_samples[0][2], 0x7fffff00);
+  EXPECT_EQ(decoded_samples[1].size(), 3);
+  EXPECT_EQ(decoded_samples[1][0], 0x00000100);
   EXPECT_EQ(decoded_samples[1][1], 0x00000400);
-  EXPECT_EQ(decoded_samples[2].size(), 2);
-  EXPECT_EQ(decoded_samples[2][0], 0x7fffff00);
-  EXPECT_EQ(decoded_samples[2][1], 0x80000000);
+  EXPECT_EQ(decoded_samples[1][2], 0x80000000);
 }
 
 TEST(LpcmDecoderTest, DecodeAudioFrame_WillNotDecodeWrongSize) {
   uint8_t sample_size = 16;
   bool little_endian = true;
-  LpcmDecoder lpcm_decoder = CreateDecoderForDecodingTest(
-      sample_size, little_endian, kNumSamplesPerFrame);
+  auto lpcm_decoder = CreateDecoderForDecodingTest(sample_size, little_endian,
+                                                   kNumSamplesPerFrame);
   // If we have 6 bytes, 16-bit samples, and two channels, we only have 3
   // samples which doesn't divide evenly into the number of channels.
   const std::vector<uint8_t>& encoded_frame = {0x00, 0x00, 0x00,
                                                0x00, 0x00, 0x00};
 
-  auto status = lpcm_decoder.DecodeAudioFrame(encoded_frame);
-  EXPECT_FALSE(status.ok());
-  EXPECT_THAT(lpcm_decoder.ValidDecodedSamples(), ::testing::IsEmpty());
+  EXPECT_THAT(lpcm_decoder->DecodeAudioFrame(encoded_frame), Not(IsOk()));
+  EXPECT_THAT(lpcm_decoder->ValidDecodedSamples(), IsEmpty());
 }
 
 TEST(LpcmDecoderTest, DecodeAudioFrame_OverwritesExistingSamples) {
   uint8_t sample_size = 16;
   bool little_endian = true;
-  LpcmDecoder lpcm_decoder = CreateDecoderForDecodingTest(
-      sample_size, little_endian, kNumSamplesPerFrame);
+  auto lpcm_decoder = CreateDecoderForDecodingTest(sample_size, little_endian,
+                                                   kNumSamplesPerFrame);
   const std::vector<uint8_t>& encoded_frame = {0x00, 0x00, 0x01, 0x00};
 
-  auto status = lpcm_decoder.DecodeAudioFrame(encoded_frame);
-  EXPECT_THAT(status, IsOk());
-  EXPECT_EQ(lpcm_decoder.ValidDecodedSamples().size(), 1);
-
-  status = lpcm_decoder.DecodeAudioFrame(encoded_frame);
-  EXPECT_THAT(status, IsOk());
-  EXPECT_EQ(lpcm_decoder.ValidDecodedSamples().size(), 1);
-
-  status = lpcm_decoder.DecodeAudioFrame(encoded_frame);
-  EXPECT_THAT(status, IsOk());
-  EXPECT_EQ(lpcm_decoder.ValidDecodedSamples().size(), 1);
+  EXPECT_THAT(lpcm_decoder->DecodeAudioFrame(encoded_frame), IsOk());
+  EXPECT_EQ(lpcm_decoder->ValidDecodedSamples().size(), kTwoChannels);
+  const auto* first_decoded_samples_address =
+      lpcm_decoder->ValidDecodedSamples().data();
+
+  // Expect that `ValidDecodedSamples()` still points to the same address,
+  // meaning the existing samples are overwritten.
+  EXPECT_THAT(lpcm_decoder->DecodeAudioFrame(encoded_frame), IsOk());
+  EXPECT_EQ(lpcm_decoder->ValidDecodedSamples().size(), kTwoChannels);
+  EXPECT_EQ(lpcm_decoder->ValidDecodedSamples().data(),
+            first_decoded_samples_address);
+
+  EXPECT_THAT(lpcm_decoder->DecodeAudioFrame(encoded_frame), IsOk());
+  EXPECT_EQ(lpcm_decoder->ValidDecodedSamples().size(), kTwoChannels);
+  EXPECT_EQ(lpcm_decoder->ValidDecodedSamples().data(),
+            first_decoded_samples_address);
 }
 
 }  // namespace
diff --git a/iamf/cli/codec/tests/lpcm_encoder_test.cc b/iamf/cli/codec/tests/lpcm_encoder_test.cc
index fe17f19..58d5b2f 100644
--- a/iamf/cli/codec/tests/lpcm_encoder_test.cc
+++ b/iamf/cli/codec/tests/lpcm_encoder_test.cc
@@ -131,7 +131,7 @@ TEST_F(LpcmEncoderTest, MultipleSamplesPerFrame) {
   num_samples_per_frame_ = 3;
   InitExpectOk();
 
-  EncodeAudioFrame({{0x11111111}, {0x22222222}, {0x33333333}});
+  EncodeAudioFrame({{0x11111111, 0x22222222, 0x33333333}});
   expected_audio_frames_.push_back(
       {0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22, 0x33, 0x33, 0x33, 0x33});
   FinalizeAndValidate();
@@ -157,7 +157,7 @@ TEST_F(LpcmEncoderTest, TwoChannels) {
   num_channels_ = 2;
   InitExpectOk();
 
-  EncodeAudioFrame({{0x11111111, 0x22222222}});
+  EncodeAudioFrame({{0x11111111}, {0x22222222}});
   expected_audio_frames_.push_back(
       {0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22});
   FinalizeAndValidate();
diff --git a/iamf/cli/codec/tests/opus_encoder_test.cc b/iamf/cli/codec/tests/opus_encoder_test.cc
index ed83788..94d11e0 100644
--- a/iamf/cli/codec/tests/opus_encoder_test.cc
+++ b/iamf/cli/codec/tests/opus_encoder_test.cc
@@ -74,7 +74,7 @@ TEST_F(OpusEncoderTest, FramesAreInOrder) {
   const int kNumFrames = 100;
   for (int i = 0; i < kNumFrames; i++) {
     EncodeAudioFrame(std::vector<std::vector<int32_t>>(
-        num_samples_per_frame_, std::vector<int32_t>(num_channels_, i)));
+        num_channels_, std::vector<int32_t>(num_samples_per_frame_, i)));
   }
   FinalizeAndValidateOrderOnly(kNumFrames);
 }
@@ -84,7 +84,7 @@ TEST_F(OpusEncoderTest, EncodeAndFinalizes16BitFrameSucceeds) {
   InitExpectOk();
 
   EncodeAudioFrame(std::vector<std::vector<int32_t>>(
-      num_samples_per_frame_, std::vector<int32_t>(num_channels_, 42 << 16)));
+      num_channels_, std::vector<int32_t>(num_samples_per_frame_, 42 << 16)));
 
   FinalizeAndValidateOrderOnly(1);
 }
@@ -95,7 +95,7 @@ TEST_F(OpusEncoderTest, EncodeAndFinalizes16BitFrameSucceedsWithoutFloatApi) {
   InitExpectOk();
 
   EncodeAudioFrame(std::vector<std::vector<int32_t>>(
-      num_samples_per_frame_, std::vector<int32_t>(num_channels_, 42 << 16)));
+      num_channels_, std::vector<int32_t>(num_samples_per_frame_, 42 << 16)));
 
   FinalizeAndValidateOrderOnly(1);
 }
@@ -105,7 +105,7 @@ TEST_F(OpusEncoderTest, EncodeAndFinalizes24BitFrameSucceeds) {
   InitExpectOk();
 
   EncodeAudioFrame(std::vector<std::vector<int32_t>>(
-      num_samples_per_frame_, std::vector<int32_t>(num_channels_, 42 << 8)));
+      num_channels_, std::vector<int32_t>(num_samples_per_frame_, 42 << 8)));
 
   FinalizeAndValidateOrderOnly(1);
 }
@@ -115,7 +115,7 @@ TEST_F(OpusEncoderTest, EncodeAndFinalizes32BitFrameSucceeds) {
   InitExpectOk();
 
   EncodeAudioFrame(std::vector<std::vector<int32_t>>(
-      num_samples_per_frame_, std::vector<int32_t>(num_channels_, 42)));
+      num_channels_, std::vector<int32_t>(num_samples_per_frame_, 42)));
 
   FinalizeAndValidateOrderOnly(1);
 }
diff --git a/iamf/cli/demixing_module.cc b/iamf/cli/demixing_module.cc
index 07f9d68..292dcd1 100644
--- a/iamf/cli/demixing_module.cc
+++ b/iamf/cli/demixing_module.cc
@@ -29,6 +29,7 @@
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
+#include "absl/types/span.h"
 #include "iamf/cli/audio_element_with_data.h"
 #include "iamf/cli/audio_frame_decoder.h"
 #include "iamf/cli/audio_frame_with_data.h"
@@ -52,7 +53,7 @@ using DemixingMetadataForAudioElementId =
 
 absl::Status S7ToS5DownMixer(const DownMixingParams& down_mixing_params,
                              LabelSamplesMap& label_to_samples) {
-  LOG_FIRST_N(INFO, 1) << "S7 to S5";
+  VLOG(1) << "S7 to S5";
 
   // Check input to perform this down-mixing exist.
   if (label_to_samples.find(kL7) == label_to_samples.end() ||
@@ -95,26 +96,26 @@ absl::Status S7ToS5DownMixer(const DownMixingParams& down_mixing_params,
 
 absl::Status S5ToS7Demixer(const DownMixingParams& down_mixing_params,
                            LabelSamplesMap& label_to_samples) {
-  LOG_FIRST_N(INFO, 1) << "S5 to S7";
-
-  const std::vector<InternalSampleType>* l5_samples;
-  const std::vector<InternalSampleType>* ls5_samples;
-  const std::vector<InternalSampleType>* lss7_samples;
-  const std::vector<InternalSampleType>* r5_samples;
-  const std::vector<InternalSampleType>* rs5_samples;
-  const std::vector<InternalSampleType>* rss7_samples;
+  VLOG(1) << "S5 to S7";
+
+  absl::Span<const InternalSampleType> l5_samples;
+  absl::Span<const InternalSampleType> ls5_samples;
+  absl::Span<const InternalSampleType> lss7_samples;
+  absl::Span<const InternalSampleType> r5_samples;
+  absl::Span<const InternalSampleType> rs5_samples;
+  absl::Span<const InternalSampleType> rss7_samples;
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kL5, label_to_samples, &l5_samples));
+      kL5, label_to_samples, l5_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kLs5, label_to_samples, &ls5_samples));
+      kLs5, label_to_samples, ls5_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kLss7, label_to_samples, &lss7_samples));
+      kLss7, label_to_samples, lss7_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kR5, label_to_samples, &r5_samples));
+      kR5, label_to_samples, r5_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kRs5, label_to_samples, &rs5_samples));
+      kRs5, label_to_samples, rs5_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kRss7, label_to_samples, &rss7_samples));
+      kRss7, label_to_samples, rss7_samples));
 
   auto& l7_samples = label_to_samples[kDemixedL7];
   auto& r7_samples = label_to_samples[kDemixedR7];
@@ -122,19 +123,19 @@ absl::Status S5ToS7Demixer(const DownMixingParams& down_mixing_params,
   auto& rrs7_samples = label_to_samples[kDemixedRrs7];
 
   // Directly copy L5/R5 to L7/R7, because they are the same.
-  l7_samples = *l5_samples;
-  r7_samples = *r5_samples;
+  l7_samples = {l5_samples.begin(), l5_samples.end()};
+  r7_samples = {r5_samples.begin(), r5_samples.end()};
 
   // Handle Lrs7 and Rrs7.
-  const size_t num_ticks = l5_samples->size();
+  const size_t num_ticks = l5_samples.size();
   lrs7_samples.resize(num_ticks, 0.0);
   rrs7_samples.resize(num_ticks, 0.0);
   for (int i = 0; i < num_ticks; i++) {
     lrs7_samples[i] =
-        ((*ls5_samples)[i] - down_mixing_params.alpha * (*lss7_samples)[i]) /
+        (ls5_samples[i] - down_mixing_params.alpha * lss7_samples[i]) /
         down_mixing_params.beta;
     rrs7_samples[i] =
-        ((*rs5_samples)[i] - down_mixing_params.alpha * (*rss7_samples)[i]) /
+        (rs5_samples[i] - down_mixing_params.alpha * rss7_samples[i]) /
         down_mixing_params.beta;
   }
 
@@ -143,7 +144,7 @@ absl::Status S5ToS7Demixer(const DownMixingParams& down_mixing_params,
 
 absl::Status S5ToS3DownMixer(const DownMixingParams& down_mixing_params,
                              LabelSamplesMap& label_to_samples) {
-  LOG_FIRST_N(INFO, 1) << "S5 to S3";
+  VLOG(1) << "S5 to S3";
 
   // Check input to perform this down-mixing exist.
   if (label_to_samples.find(kL5) == label_to_samples.end() ||
@@ -172,32 +173,30 @@ absl::Status S5ToS3DownMixer(const DownMixingParams& down_mixing_params,
 
 absl::Status S3ToS5Demixer(const DownMixingParams& down_mixing_params,
                            LabelSamplesMap& label_to_samples) {
-  LOG_FIRST_N(INFO, 1) << "S3 to S5";
+  VLOG(1) << "S3 to S5";
 
-  const std::vector<InternalSampleType>* l3_samples;
-  const std::vector<InternalSampleType>* l5_samples;
-  const std::vector<InternalSampleType>* r3_samples;
-  const std::vector<InternalSampleType>* r5_samples;
+  absl::Span<const InternalSampleType> l3_samples;
+  absl::Span<const InternalSampleType> l5_samples;
+  absl::Span<const InternalSampleType> r3_samples;
+  absl::Span<const InternalSampleType> r5_samples;
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kL3, label_to_samples, &l3_samples));
+      kL3, label_to_samples, l3_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kL5, label_to_samples, &l5_samples));
+      kL5, label_to_samples, l5_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kR3, label_to_samples, &r3_samples));
+      kR3, label_to_samples, r3_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kR5, label_to_samples, &r5_samples));
+      kR5, label_to_samples, r5_samples));
 
   auto& ls5_samples = label_to_samples[kDemixedLs5];
   auto& rs5_samples = label_to_samples[kDemixedRs5];
 
-  const size_t num_ticks = l3_samples->size();
+  const size_t num_ticks = l3_samples.size();
   ls5_samples.resize(num_ticks, 0.0);
   rs5_samples.resize(num_ticks, 0.0);
   for (int i = 0; i < num_ticks; i++) {
-    ls5_samples[i] =
-        ((*l3_samples)[i] - (*l5_samples)[i]) / down_mixing_params.delta;
-    rs5_samples[i] =
-        ((*r3_samples)[i] - (*r5_samples)[i]) / down_mixing_params.delta;
+    ls5_samples[i] = (l3_samples[i] - l5_samples[i]) / down_mixing_params.delta;
+    rs5_samples[i] = (r3_samples[i] - r5_samples[i]) / down_mixing_params.delta;
   }
 
   return absl::OkStatus();
@@ -205,7 +204,7 @@ absl::Status S3ToS5Demixer(const DownMixingParams& down_mixing_params,
 
 absl::Status S3ToS2DownMixer(const DownMixingParams& /*down_mixing_params*/,
                              LabelSamplesMap& label_to_samples) {
-  LOG_FIRST_N(INFO, 1) << "S3 to S2";
+  VLOG(1) << "S3 to S2";
 
   // Check input to perform this down-mixing exist.
   if (label_to_samples.find(kL3) == label_to_samples.end() ||
@@ -232,27 +231,27 @@ absl::Status S3ToS2DownMixer(const DownMixingParams& /*down_mixing_params*/,
 
 absl::Status S2ToS3Demixer(const DownMixingParams& /*down_mixing_params*/,
                            LabelSamplesMap& label_to_samples) {
-  LOG_FIRST_N(INFO, 1) << "S2 to S3";
+  VLOG(1) << "S2 to S3";
 
-  const std::vector<InternalSampleType>* l2_samples;
-  const std::vector<InternalSampleType>* r2_samples;
-  const std::vector<InternalSampleType>* c_samples;
+  absl::Span<const InternalSampleType> l2_samples;
+  absl::Span<const InternalSampleType> r2_samples;
+  absl::Span<const InternalSampleType> c_samples;
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kL2, label_to_samples, &l2_samples));
+      kL2, label_to_samples, l2_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kR2, label_to_samples, &r2_samples));
+      kR2, label_to_samples, r2_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kCentre, label_to_samples, &c_samples));
+      kCentre, label_to_samples, c_samples));
 
   auto& l3_samples = label_to_samples[kDemixedL3];
   auto& r3_samples = label_to_samples[kDemixedR3];
 
-  const size_t num_ticks = c_samples->size();
+  const size_t num_ticks = c_samples.size();
   l3_samples.resize(num_ticks, 0.0);
   r3_samples.resize(num_ticks, 0.0);
   for (int i = 0; i < num_ticks; i++) {
-    l3_samples[i] = ((*l2_samples)[i] - 0.707 * (*c_samples)[i]);
-    r3_samples[i] = ((*r2_samples)[i] - 0.707 * (*c_samples)[i]);
+    l3_samples[i] = (l2_samples[i] - 0.707 * c_samples[i]);
+    r3_samples[i] = (r2_samples[i] - 0.707 * c_samples[i]);
   }
 
   return absl::OkStatus();
@@ -260,7 +259,7 @@ absl::Status S2ToS3Demixer(const DownMixingParams& /*down_mixing_params*/,
 
 absl::Status S2ToS1DownMixer(const DownMixingParams& /*down_mixing_params*/,
                              LabelSamplesMap& label_to_samples) {
-  LOG_FIRST_N(INFO, 1) << "S2 to S1";
+  VLOG(1) << "S2 to S1";
 
   // Check input to perform this down-mixing exist.
   if (label_to_samples.find(kL2) == label_to_samples.end() ||
@@ -282,20 +281,20 @@ absl::Status S2ToS1DownMixer(const DownMixingParams& /*down_mixing_params*/,
 
 absl::Status S1ToS2Demixer(const DownMixingParams& /*down_mixing_params*/,
                            LabelSamplesMap& label_to_samples) {
-  LOG_FIRST_N(INFO, 1) << "S1 to S2";
+  VLOG(1) << "S1 to S2";
 
-  const std::vector<InternalSampleType>* l2_samples;
-  const std::vector<InternalSampleType>* mono_samples;
+  absl::Span<const InternalSampleType> l2_samples;
+  absl::Span<const InternalSampleType> mono_samples;
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kL2, label_to_samples, &l2_samples));
+      kL2, label_to_samples, l2_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kMono, label_to_samples, &mono_samples));
+      kMono, label_to_samples, mono_samples));
 
   auto& r2_samples = label_to_samples[kDemixedR2];
-  const size_t num_ticks = mono_samples->size();
+  const size_t num_ticks = mono_samples.size();
   r2_samples.resize(num_ticks, 0.0);
   for (int i = 0; i < num_ticks; i++) {
-    r2_samples[i] = 2.0 * (*mono_samples)[i] - (*l2_samples)[i];
+    r2_samples[i] = 2.0 * mono_samples[i] - l2_samples[i];
   }
 
   return absl::OkStatus();
@@ -303,7 +302,7 @@ absl::Status S1ToS2Demixer(const DownMixingParams& /*down_mixing_params*/,
 
 absl::Status T4ToT2DownMixer(const DownMixingParams& down_mixing_params,
                              LabelSamplesMap& label_to_samples) {
-  LOG_FIRST_N(INFO, 1) << "T4 to T2";
+  VLOG(1) << "T4 to T2";
 
   // Check input to perform this down-mixing exist.
   if (label_to_samples.find(kLtf4) == label_to_samples.end() ||
@@ -334,31 +333,31 @@ absl::Status T4ToT2DownMixer(const DownMixingParams& down_mixing_params,
 
 absl::Status T2ToT4Demixer(const DownMixingParams& down_mixing_params,
                            LabelSamplesMap& label_to_samples) {
-  LOG_FIRST_N(INFO, 1) << "T2 to T4";
+  VLOG(1) << "T2 to T4";
 
-  const std::vector<InternalSampleType>* ltf2_samples;
-  const std::vector<InternalSampleType>* ltf4_samples;
-  const std::vector<InternalSampleType>* rtf2_samples;
-  const std::vector<InternalSampleType>* rtf4_samples;
+  absl::Span<const InternalSampleType> ltf2_samples;
+  absl::Span<const InternalSampleType> ltf4_samples;
+  absl::Span<const InternalSampleType> rtf2_samples;
+  absl::Span<const InternalSampleType> rtf4_samples;
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kLtf2, label_to_samples, &ltf2_samples));
+      kLtf2, label_to_samples, ltf2_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kLtf4, label_to_samples, &ltf4_samples));
+      kLtf4, label_to_samples, ltf4_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kRtf2, label_to_samples, &rtf2_samples));
+      kRtf2, label_to_samples, rtf2_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kRtf4, label_to_samples, &rtf4_samples));
+      kRtf4, label_to_samples, rtf4_samples));
 
   auto& ltb4_samples = label_to_samples[kDemixedLtb4];
   auto& rtb4_samples = label_to_samples[kDemixedRtb4];
-  const size_t num_ticks = ltf2_samples->size();
+  const size_t num_ticks = ltf2_samples.size();
   ltb4_samples.resize(num_ticks, 0.0);
   rtb4_samples.resize(num_ticks, 0.0);
   for (int i = 0; i < num_ticks; i++) {
     ltb4_samples[i] =
-        ((*ltf2_samples)[i] - (*ltf4_samples)[i]) / down_mixing_params.gamma;
+        (ltf2_samples[i] - ltf4_samples[i]) / down_mixing_params.gamma;
     rtb4_samples[i] =
-        ((*rtf2_samples)[i] - (*rtf4_samples)[i]) / down_mixing_params.gamma;
+        (rtf2_samples[i] - rtf4_samples[i]) / down_mixing_params.gamma;
   }
 
   return absl::OkStatus();
@@ -366,7 +365,7 @@ absl::Status T2ToT4Demixer(const DownMixingParams& down_mixing_params,
 
 absl::Status T2ToTf2DownMixer(const DownMixingParams& down_mixing_params,
                               LabelSamplesMap& label_to_samples) {
-  LOG_FIRST_N(INFO, 1) << "T2 to TF2";
+  VLOG(1) << "T2 to TF2";
 
   // Check input to perform this down-mixing exist.
   if (label_to_samples.find(kLtf2) == label_to_samples.end() ||
@@ -399,39 +398,37 @@ absl::Status T2ToTf2DownMixer(const DownMixingParams& down_mixing_params,
 
 absl::Status Tf2ToT2Demixer(const DownMixingParams& down_mixing_params,
                             LabelSamplesMap& label_to_samples) {
-  LOG_FIRST_N(INFO, 1) << "TF2 to T2";
-
-  const std::vector<InternalSampleType>* ltf3_samples;
-  const std::vector<InternalSampleType>* l3_samples;
-  const std::vector<InternalSampleType>* l5_samples;
-  const std::vector<InternalSampleType>* rtf3_samples;
-  const std::vector<InternalSampleType>* r3_samples;
-  const std::vector<InternalSampleType>* r5_samples;
+  VLOG(1) << "TF2 to T2";
+
+  absl::Span<const InternalSampleType> ltf3_samples;
+  absl::Span<const InternalSampleType> l3_samples;
+  absl::Span<const InternalSampleType> l5_samples;
+  absl::Span<const InternalSampleType> rtf3_samples;
+  absl::Span<const InternalSampleType> r3_samples;
+  absl::Span<const InternalSampleType> r5_samples;
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kLtf3, label_to_samples, &ltf3_samples));
+      kLtf3, label_to_samples, ltf3_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kL3, label_to_samples, &l3_samples));
+      kL3, label_to_samples, l3_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kL5, label_to_samples, &l5_samples));
+      kL5, label_to_samples, l5_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kRtf3, label_to_samples, &rtf3_samples));
+      kRtf3, label_to_samples, rtf3_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kR3, label_to_samples, &r3_samples));
+      kR3, label_to_samples, r3_samples));
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      kR5, label_to_samples, &r5_samples));
+      kR5, label_to_samples, r5_samples));
 
   auto& ltf2_samples = label_to_samples[kDemixedLtf2];
   auto& rtf2_samples = label_to_samples[kDemixedRtf2];
-  const size_t num_ticks = ltf3_samples->size();
+  const size_t num_ticks = ltf3_samples.size();
   ltf2_samples.resize(num_ticks, 0.0);
   rtf2_samples.resize(num_ticks, 0.0);
   for (int i = 0; i < num_ticks; i++) {
-    ltf2_samples[i] =
-        (*ltf3_samples)[i] -
-        down_mixing_params.w * ((*l3_samples)[i] - (*l5_samples)[i]);
-    rtf2_samples[i] =
-        (*rtf3_samples)[i] -
-        down_mixing_params.w * ((*r3_samples)[i] - (*r5_samples)[i]);
+    ltf2_samples[i] = ltf3_samples[i] -
+                      down_mixing_params.w * (l3_samples[i] - l5_samples[i]);
+    rtf2_samples[i] = rtf3_samples[i] -
+                      down_mixing_params.w * (r3_samples[i] - r5_samples[i]);
   }
 
   return absl::OkStatus();
@@ -491,30 +488,30 @@ absl::Status FillRequiredDemixingMetadata(
       break;
     }
   }
-  LOG(INFO) << "Surround down-mixers from S" << input_surround_number << " to S"
-            << output_lowest_surround_number << " needed:";
+  VLOG(1) << "Surround down-mixers from S" << input_surround_number << " to S"
+          << output_lowest_surround_number << " needed:";
   for (int surround_number = input_surround_number;
        surround_number > output_lowest_surround_number; surround_number--) {
     if (surround_number == 7) {
       down_mixers.push_back(S7ToS5DownMixer);
-      LOG(INFO) << "  S7ToS5DownMixer added";
+      VLOG(1) << "  S7ToS5DownMixer added";
       demixers.push_front(S5ToS7Demixer);
-      LOG(INFO) << "  S5ToS7Demixer added";
+      VLOG(1) << "  S5ToS7Demixer added";
     } else if (surround_number == 5) {
       down_mixers.push_back(S5ToS3DownMixer);
-      LOG(INFO) << "  S5ToS3DownMixer added";
+      VLOG(1) << "  S5ToS3DownMixer added";
       demixers.push_front(S3ToS5Demixer);
-      LOG(INFO) << "  S3ToS5Demixer added";
+      VLOG(1) << "  S3ToS5Demixer added";
     } else if (surround_number == 3) {
       down_mixers.push_back(S3ToS2DownMixer);
-      LOG(INFO) << "  S3ToS2DownMixer added";
+      VLOG(1) << "  S3ToS2DownMixer added";
       demixers.push_front(S2ToS3Demixer);
-      LOG(INFO) << "  S2ToS3Demixer added";
+      VLOG(1) << "  S2ToS3Demixer added";
     } else if (surround_number == 2) {
       down_mixers.push_back(S2ToS1DownMixer);
-      LOG(INFO) << "  S2ToS1DownMixer added";
+      VLOG(1) << "  S2ToS1DownMixer added";
       demixers.push_front(S1ToS2Demixer);
-      LOG(INFO) << "  S1ToS2Demixer added";
+      VLOG(1) << "  S1ToS2Demixer added";
     }
   }
 
@@ -550,21 +547,21 @@ absl::Status FillRequiredDemixingMetadata(
   // Collect demixers in a separate list first and append the list to the
   // output later. Height demixers need to be in reverse order as height
   // down-mixers but should go after the surround demixers.
-  LOG(INFO) << "Height down-mixers from T" << input_height_number << " to "
-            << (output_lowest_height_number == 2 ? "T2" : "TF3") << " needed:";
+  VLOG(1) << "Height down-mixers from T" << input_height_number << " to "
+          << (output_lowest_height_number == 2 ? "T2" : "TF3") << " needed:";
   std::list<Demixer> height_demixers;
   for (int height_number = input_height_number;
        height_number > output_lowest_height_number; height_number--) {
     if (height_number == 4) {
       down_mixers.push_back(T4ToT2DownMixer);
-      LOG(INFO) << "  T4ToT2DownMixer added";
+      VLOG(1) << "  T4ToT2DownMixer added";
       height_demixers.push_front(T2ToT4Demixer);
-      LOG(INFO) << "  T2ToT4Demixer added";
+      VLOG(1) << "  T2ToT4Demixer added";
     } else if (height_number == 2) {
       down_mixers.push_back(T2ToTf2DownMixer);
-      LOG(INFO) << "  T2ToTf2DownMixer added";
+      VLOG(1) << "  T2ToTf2DownMixer added";
       height_demixers.push_front(Tf2ToT2Demixer);
-      LOG(INFO) << "  Tf2ToT2Demixer added";
+      VLOG(1) << "  Tf2ToT2Demixer added";
     }
   }
   demixers.splice(demixers.end(), height_demixers);
@@ -601,17 +598,18 @@ uint32_t GetSubstreamId(const DecodedAudioFrame& audio_frame_with_data) {
   return audio_frame_with_data.substream_id;
 }
 
-const std::vector<std::vector<int32_t>>* GetSamples(
+absl::Span<const std::vector<int32_t>> GetSamples(
     const AudioFrameWithData& audio_frame_with_data) {
   if (!audio_frame_with_data.pcm_samples.has_value()) {
-    return nullptr;
+    return {};
   }
-  return &audio_frame_with_data.pcm_samples.value();
+
+  return absl::MakeConstSpan(audio_frame_with_data.pcm_samples.value());
 }
 
-const std::vector<std::vector<int32_t>>* GetSamples(
+absl::Span<const std::vector<int32_t>> GetSamples(
     const DecodedAudioFrame& audio_frame_with_data) {
-  return &audio_frame_with_data.decoded_samples;
+  return audio_frame_with_data.decoded_samples;
 }
 
 // NOOP function if the frame is not a DecodedAudioFrame.
@@ -624,7 +622,7 @@ absl::Status PassThroughReconGainData(
     const DecodedAudioFrame& decoded_audio_frame,
     LabeledFrame& labeled_decoded_frame) {
   if (decoded_audio_frame.audio_element_with_data == nullptr) {
-    LOG(INFO)
+    LOG_FIRST_N(INFO, 1)
         << "No audio element with data found, thus layer info is inaccessible.";
     return absl::OkStatus();
   }
@@ -660,7 +658,7 @@ absl::Status StoreSamplesForAudioElementId(
   if (audio_frames_or_decoded_audio_frames.empty()) {
     return absl::OkStatus();
   }
-  const int32_t common_start_timestamp =
+  const InternalTimestamp common_start_timestamp =
       audio_frames_or_decoded_audio_frames.begin()->start_timestamp;
 
   for (auto& audio_frame : audio_frames_or_decoded_audio_frames) {
@@ -678,21 +676,29 @@ absl::Status StoreSamplesForAudioElementId(
 
     const auto& labels = substream_id_labels_iter->second;
     int channel_index = 0;
+    const auto num_channels = labels.size();
     for (const auto& label : labels) {
-      const auto* input_samples = GetSamples(audio_frame);
-      if (input_samples == nullptr) {
+      const auto input_samples = GetSamples(audio_frame);
+      if (input_samples.empty()) {
         return absl::InvalidArgumentError(
             "Input samples are not available for down-mixing.");
       }
-      const size_t num_ticks = input_samples->size();
-
+      RETURN_IF_NOT_OK(ValidateEqual(
+          input_samples.size(), num_channels,
+          "Decoded number of channels vs. expected number of channels"));
       ConfigureLabeledFrame(audio_frame, labeled_frame);
 
       auto& samples = labeled_frame.label_to_samples[label];
-      samples.resize(num_ticks, 0);
-      for (int t = 0; t < samples.size(); t++) {
+      const auto& input_samples_for_channel = input_samples[channel_index];
+      const size_t num_ticks = input_samples_for_channel.size();
+
+      samples.resize(num_ticks);
+      for (int t = 0; t < num_ticks; t++) {
+        // TODO(b/416166882): Convert to floating points directly from
+        // the decoder. Then we can simply copy the samples over or even do
+        // zero-copy referencing.
         samples[t] = Int32ToNormalizedFloatingPoint<InternalSampleType>(
-            (*input_samples)[t][channel_index]);
+            input_samples_for_channel[t]);
       }
       channel_index++;
     }
@@ -766,8 +772,8 @@ void LogForAudioElementId(absl::string_view log_prefix,
   }
   for (const auto& [label, samples] :
        id_to_labeled_frame.at(audio_element_id).label_to_samples) {
-    LOG_FIRST_N(INFO, 1) << "  Channel " << label << ":\t" << log_prefix
-                         << " frame size= " << samples.size() << ".";
+    VLOG(1) << "  Channel " << label << ":\t" << log_prefix
+            << " frame size= " << samples.size() << ".";
   }
 }
 
@@ -775,9 +781,9 @@ void LogForAudioElementId(absl::string_view log_prefix,
 
 absl::Status DemixingModule::FindSamplesOrDemixedSamples(
     ChannelLabel::Label label, const LabelSamplesMap& label_to_samples,
-    const std::vector<InternalSampleType>** samples) {
+    absl::Span<const InternalSampleType>& samples) {
   if (label_to_samples.find(label) != label_to_samples.end()) {
-    *samples = &label_to_samples.at(label);
+    samples = absl::MakeConstSpan(label_to_samples.at(label));
     return absl::OkStatus();
   }
 
@@ -786,11 +792,10 @@ absl::Status DemixingModule::FindSamplesOrDemixedSamples(
     return demixed_label.status();
   }
   if (label_to_samples.find(*demixed_label) != label_to_samples.end()) {
-    *samples = &label_to_samples.at(*demixed_label);
+    samples = absl::MakeConstSpan(label_to_samples.at(*demixed_label));
     return absl::OkStatus();
   } else {
-    *samples = nullptr;
-    return absl::UnknownError(
+    return absl::InvalidArgumentError(
         absl::StrCat("Channel ", label, " or ", *demixed_label, " not found"));
   }
 }
diff --git a/iamf/cli/demixing_module.h b/iamf/cli/demixing_module.h
index aa9b1f5..732e5a6 100644
--- a/iamf/cli/demixing_module.h
+++ b/iamf/cli/demixing_module.h
@@ -24,6 +24,7 @@
 #include "absl/container/node_hash_map.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
+#include "absl/types/span.h"
 #include "iamf/cli/audio_element_with_data.h"
 #include "iamf/cli/audio_frame_decoder.h"
 #include "iamf/cli/audio_frame_with_data.h"
@@ -57,7 +58,7 @@ typedef absl::node_hash_map<ChannelLabel::Label,
     LabelSamplesMap;
 
 struct LabeledFrame {
-  int32_t end_timestamp;
+  InternalTimestamp end_timestamp;
   uint32_t samples_to_trim_at_end;
   uint32_t samples_to_trim_at_start;
   LabelSamplesMap label_to_samples;
@@ -148,13 +149,13 @@ class DemixingModule {
    *
    * \param label Label of the channel (or its demixed version) to search for.
    * \param label_to_samples Map of label to samples to search.
-   * \param samples Output argument for the samples if found.
-   * \return `absl::OkStatus()` on success. `absl::UnknownError()` if the search
-   *         failed.
+   * \param samples Output span to the samples if found.
+   * \return `absl::OkStatus()` on success. `absl::InvalidArgumentError()` if
+   *         the search failed.
    */
   static absl::Status FindSamplesOrDemixedSamples(
       ChannelLabel::Label label, const LabelSamplesMap& label_to_samples,
-      const std::vector<InternalSampleType>** samples);
+      absl::Span<const InternalSampleType>& samples);
 
   /*!\brief Down-mixes samples of input channels to substreams.
    *
diff --git a/iamf/cli/encoder_main_lib.cc b/iamf/cli/encoder_main_lib.cc
index 5863447..532ec04 100644
--- a/iamf/cli/encoder_main_lib.cc
+++ b/iamf/cli/encoder_main_lib.cc
@@ -11,7 +11,6 @@
  */
 #include "iamf/cli/encoder_main_lib.h"
 
-#include <algorithm>
 #include <cstddef>
 #include <cstdint>
 #include <filesystem>
@@ -33,9 +32,13 @@
 #include "iamf/cli/obu_sequencer_base.h"
 #include "iamf/cli/parameter_block_partitioner.h"
 #include "iamf/cli/parameter_block_with_data.h"
+#include "iamf/cli/proto/encoder_control_metadata.pb.h"
 #include "iamf/cli/proto/temporal_delimiter.pb.h"
 #include "iamf/cli/proto/test_vector_metadata.pb.h"
 #include "iamf/cli/proto/user_metadata.pb.h"
+#include "iamf/cli/proto_conversion/output_audio_format_utils.h"
+#include "iamf/cli/rendering_mix_presentation_finalizer.h"
+#include "iamf/cli/sample_processor_base.h"
 #include "iamf/cli/wav_sample_provider.h"
 #include "iamf/cli/wav_writer.h"
 #include "iamf/common/utils/macros.h"
@@ -82,7 +85,8 @@ absl::Status PartitionParameterMetadata(UserMetadata& user_metadata) {
 }
 
 // Mapping from the start timestamps to lists of parameter block metadata.
-typedef absl::flat_hash_map<int32_t, std::list<ParameterBlockObuMetadata>>
+typedef absl::flat_hash_map<InternalTimestamp,
+                            std::list<ParameterBlockObuMetadata>>
     TimeParameterBlockMetadataMap;
 absl::Status OrganizeParameterBlockMetadata(
     const google::protobuf::RepeatedPtrField<ParameterBlockObuMetadata>&
@@ -145,6 +149,27 @@ absl::Status CreateOutputDirectory(const std::string& output_directory) {
   return absl::OkStatus();
 }
 
+iamf_tools_cli_proto::OutputAudioFormat GetOutputAudioFormat(
+    const iamf_tools_cli_proto::OutputAudioFormat output_audio_format,
+    const iamf_tools_cli_proto::TestVectorMetadata& test_vector_metadata) {
+  if (test_vector_metadata.has_output_wav_file_bit_depth_override()) {
+    LOG(WARNING)
+        << "`output_wav_file_bit_depth_override` takes no effect. Please "
+           "upgrade to `encoder_control_metadata.output_rendered_file_format` "
+           "instead."
+           "\nSuggested upgrades:\n"
+           "- `output_wav_file_bit_depth_override: 0 -> "
+           "OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC`\n"
+           "- `output_wav_file_bit_depth_override: 16 -> "
+           "OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN`\n"
+           "- `output_wav_file_bit_depth_override: 24 -> "
+           "OUTPUT_FORMAT_WAV_BIT_DEPTH_TWENTY_FOUR`\n"
+           "- `output_wav_file_bit_depth_override: 32 -> "
+           "OUTPUT_FORMAT_WAV_BIT_DEPTH_THIRTY_TWO`\n";
+  }
+  return output_audio_format;
+}
+
 absl::Status GenerateTemporalUnitObus(
     const UserMetadata& user_metadata, const std::string& input_wav_directory,
     IamfEncoder& iamf_encoder,
@@ -174,7 +199,7 @@ absl::Status GenerateTemporalUnitObus(
 
     iamf_encoder.BeginTemporalUnit();
 
-    int32_t input_timestamp = 0;
+    InternalTimestamp input_timestamp = 0;
     RETURN_IF_NOT_OK(iamf_encoder.GetInputTimestamp(input_timestamp));
 
     // Add audio samples.
@@ -229,20 +254,6 @@ absl::Status GenerateTemporalUnitObus(
   return absl::OkStatus();
 }
 
-// TODO(b/390392510): Update control of output wav file bit-depth.
-std::optional<uint8_t> GetOverrideBitDepth(uint32_t requested_bit_depth) {
-  if (requested_bit_depth == 0) {
-    return std::nullopt;
-  }
-
-  // Clamp the bit-depth to something supported by wav files.
-  constexpr uint32_t kMinWavFileBitDepth = 16;
-  constexpr uint32_t kMaxWavFileBitDepth = 32;
-  const uint32_t clamped_bit_depth =
-      std::clamp(requested_bit_depth, kMinWavFileBitDepth, kMaxWavFileBitDepth);
-  return static_cast<uint8_t>(clamped_bit_depth);
-}
-
 absl::Status WriteObus(
     const UserMetadata& user_metadata, const std::string& output_iamf_directory,
     const IASequenceHeaderObu& ia_sequence_header_obu,
@@ -293,36 +304,40 @@ absl::Status TestMain(const UserMetadata& input_user_metadata,
     RETURN_IF_NOT_OK(PartitionParameterMetadata(user_metadata));
   }
 
-  // We want to hold the `IamfEncoder` until all OBUs have been written.
   // Write the output audio streams which were used to measure loudness to the
   // same directory as the IAMF file.
   const std::string output_wav_file_prefix =
       (std::filesystem::path(output_iamf_directory) /
        user_metadata.test_vector_metadata().file_name_prefix())
           .string();
-  const std::optional<uint8_t> override_bit_depth =
-      GetOverrideBitDepth(user_metadata.test_vector_metadata()
-                              .output_wav_file_bit_depth_override());
   LOG(INFO) << "output_wav_file_prefix = " << output_wav_file_prefix;
-  const auto ProduceAllWavWriters =
-      [output_wav_file_prefix, override_bit_depth](
-          DecodedUleb128 mix_presentation_id, int sub_mix_index,
-          int layout_index, const Layout&, int num_channels, int sample_rate,
-          int bit_depth,
-          size_t max_input_samples_per_frame) -> std::unique_ptr<WavWriter> {
+  RenderingMixPresentationFinalizer::SampleProcessorFactory
+      sample_processor_factory =
+          [output_wav_file_prefix](DecodedUleb128 mix_presentation_id,
+                                   int sub_mix_index, int layout_index,
+                                   const Layout&, int num_channels,
+                                   int sample_rate, int bit_depth,
+                                   size_t max_input_samples_per_frame)
+      -> std::unique_ptr<SampleProcessorBase> {
+    // Generate a unique filename for each layout of each mix presentation.
     const auto wav_path = absl::StrCat(
         output_wav_file_prefix, "_rendered_id_", mix_presentation_id,
         "_sub_mix_", sub_mix_index, "_layout_", layout_index, ".wav");
-    // Obey the override bit depth. But if it is not set, we can infer a good
-    // bit-depth from the input audio.
-    const uint8_t wav_file_bit_depth = override_bit_depth.value_or(bit_depth);
-    return WavWriter::Create(wav_path, num_channels, sample_rate,
-                             wav_file_bit_depth, max_input_samples_per_frame);
+    return WavWriter::Create(wav_path, num_channels, sample_rate, bit_depth,
+                             max_input_samples_per_frame);
   };
 
+  // Apply the bit depth override.
+  const auto output_audio_format = GetOutputAudioFormat(
+      user_metadata.encoder_control_metadata().output_rendered_file_format(),
+      user_metadata.test_vector_metadata());
+  ApplyOutputAudioFormatToSampleProcessorFactory(output_audio_format,
+                                                 sample_processor_factory);
+
+  // We want to hold the `IamfEncoder` until all OBUs have been written.
   auto iamf_encoder = IamfEncoder::Create(
       user_metadata, CreateRendererFactory().get(),
-      CreateLoudnessCalculatorFactory().get(), ProduceAllWavWriters,
+      CreateLoudnessCalculatorFactory().get(), sample_processor_factory,
       ia_sequence_header_obu, codec_config_obus, audio_elements,
       preliminary_mix_presentation_obus, arbitrary_obus);
   if (!iamf_encoder.ok()) {
diff --git a/iamf/cli/iamf_components.cc b/iamf/cli/iamf_components.cc
index 3b83a91..a6082b6 100644
--- a/iamf/cli/iamf_components.cc
+++ b/iamf/cli/iamf_components.cc
@@ -19,6 +19,7 @@
 #include "absl/log/log.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
+#include "iamf/cli/itu_1770_4/loudness_calculator_factory_itu_1770_4.h"
 #include "iamf/cli/loudness_calculator_factory_base.h"
 #include "iamf/cli/obu_sequencer_base.h"
 #include "iamf/cli/obu_sequencer_iamf.h"
@@ -26,7 +27,6 @@
 #include "iamf/cli/proto/user_metadata.pb.h"
 #include "iamf/cli/proto_conversion/proto_utils.h"
 #include "iamf/cli/renderer_factory.h"
-
 namespace iamf_tools {
 
 namespace {
@@ -36,14 +36,12 @@ constexpr absl::string_view kOmitIamfFile = "";
 }
 
 std::unique_ptr<RendererFactoryBase> CreateRendererFactory() {
-  // Skip rendering.
-  return nullptr;
+  return std::make_unique<RendererFactory>();
 }
 
 std::unique_ptr<LoudnessCalculatorFactoryBase>
 CreateLoudnessCalculatorFactory() {
-  // Skip loudness calculation.
-  return nullptr;
+  return std::make_unique<LoudnessCalculatorFactoryItu1770_4>();
 }
 
 std::vector<std::unique_ptr<ObuSequencerBase>> CreateObuSequencers(
diff --git a/iamf/cli/iamf_encoder.cc b/iamf/cli/iamf_encoder.cc
index 01b0752..883f81d 100644
--- a/iamf/cli/iamf_encoder.cc
+++ b/iamf/cli/iamf_encoder.cc
@@ -81,8 +81,8 @@ absl::Status InitAudioFrameDecoderForAllAudioElements(
 
 absl::StatusOr<IamfEncoder> IamfEncoder::Create(
     const iamf_tools_cli_proto::UserMetadata& user_metadata,
-    absl::Nullable<const RendererFactoryBase*> renderer_factory,
-    absl::Nullable<const LoudnessCalculatorFactoryBase*>
+    const RendererFactoryBase* /* absl_nullable */ renderer_factory,
+    const LoudnessCalculatorFactoryBase* /* absl_nullable */
         loudness_calculator_factory,
     const RenderingMixPresentationFinalizer::SampleProcessorFactory&
         sample_processor_factory,
@@ -211,8 +211,9 @@ void IamfEncoder::BeginTemporalUnit() {
   }
 }
 
-absl::Status IamfEncoder::GetInputTimestamp(int32_t& input_timestamp) {
-  std::optional<int32_t> timestamp;
+absl::Status IamfEncoder::GetInputTimestamp(
+    InternalTimestamp& input_timestamp) {
+  std::optional<InternalTimestamp> timestamp;
   RETURN_IF_NOT_OK(
       global_timing_module_->GetGlobalAudioFrameTimestamp(timestamp));
   if (!timestamp.has_value()) {
diff --git a/iamf/cli/iamf_encoder.h b/iamf/cli/iamf_encoder.h
index 4274c3b..6864c7e 100644
--- a/iamf/cli/iamf_encoder.h
+++ b/iamf/cli/iamf_encoder.h
@@ -114,8 +114,8 @@ class IamfEncoder {
    */
   static absl::StatusOr<IamfEncoder> Create(
       const iamf_tools_cli_proto::UserMetadata& user_metadata,
-      absl::Nullable<const RendererFactoryBase*> renderer_factory,
-      absl::Nullable<const LoudnessCalculatorFactoryBase*>
+      const RendererFactoryBase* /* absl_nullable */ renderer_factory,
+      const LoudnessCalculatorFactoryBase* /* absl_nullable */
           loudness_calculator_factory,
       const RenderingMixPresentationFinalizer::SampleProcessorFactory&
           sample_processor_factory,
@@ -140,7 +140,7 @@ class IamfEncoder {
    * \param input_timestamp Result of input timestamp.
    * \return `absl::OkStatus()` if successful. A specific status on failure.
    */
-  absl::Status GetInputTimestamp(int32_t& input_timestamp);
+  absl::Status GetInputTimestamp(InternalTimestamp& input_timestamp);
 
   /*!\brief Adds audio samples belonging to the same temporal unit.
    *
@@ -241,8 +241,8 @@ class IamfEncoder {
   // Mapping from parameter IDs to parameter definitions.
   // Parameter block generator owns a reference to this map. Wrapped in
   // `std::unique_ptr` for reference stability after move.
-  absl::Nonnull<std::unique_ptr<
-      const absl::flat_hash_map<DecodedUleb128, ParamDefinitionVariant>>>
+  /* absl_nonnull */ std::unique_ptr<
+      const absl::flat_hash_map<DecodedUleb128, ParamDefinitionVariant>>
       param_definition_variants_;
 
   // Saved parameter blocks generated in one iteration.
@@ -260,11 +260,12 @@ class IamfEncoder {
   // Various generators and modules used when generating data OBUs iteratively.
   // Some are held in `unique_ptr` for reference stability after move.
   ParameterBlockGenerator parameter_block_generator_;
-  absl::Nonnull<std::unique_ptr<ParametersManager>> parameters_manager_;
+  /* absl_nonnull */ std::unique_ptr<ParametersManager> parameters_manager_;
   const DemixingModule demixing_module_;
-  absl::Nonnull<std::unique_ptr<AudioFrameGenerator>> audio_frame_generator_;
+  /* absl_nonnull */ std::unique_ptr<AudioFrameGenerator>
+      audio_frame_generator_;
   AudioFrameDecoder audio_frame_decoder_;
-  absl::Nonnull<std::unique_ptr<GlobalTimingModule>> global_timing_module_;
+  /* absl_nonnull */ std::unique_ptr<GlobalTimingModule> global_timing_module_;
 
   // Modules to render the output layouts and measure their loudness.
   RenderingMixPresentationFinalizer mix_presentation_finalizer_;
diff --git a/iamf/cli/itu_1770_4/BUILD b/iamf/cli/itu_1770_4/BUILD
new file mode 100644
index 0000000..b54f9e6
--- /dev/null
+++ b/iamf/cli/itu_1770_4/BUILD
@@ -0,0 +1,44 @@
+package(default_visibility = [
+    "//iamf/api:__subpackages__",
+    "//iamf/cli:__subpackages__",
+])
+
+# keep-sorted start block=yes prefix_order=cc_library newline_separated=yes
+cc_library(
+    name = "loudness_calculator_factory_itu_1770_4",
+    srcs = ["loudness_calculator_factory_itu_1770_4.cc"],
+    hdrs = ["loudness_calculator_factory_itu_1770_4.h"],
+    deps = [
+        ":loudness_calculator_itu_1770_4",
+        "//iamf/cli:loudness_calculator_base",
+        "//iamf/cli:loudness_calculator_factory_base",
+        "//iamf/obu:mix_presentation",
+    ],
+)
+
+cc_library(
+    name = "loudness_calculator_itu_1770_4",
+    srcs = ["loudness_calculator_itu_1770_4.cc"],
+    hdrs = ["loudness_calculator_itu_1770_4.h"],
+    deps = [
+        "//iamf/cli:loudness_calculator_base",
+        "//iamf/cli/proto:mix_presentation_cc_proto",
+        "//iamf/cli/proto:test_vector_metadata_cc_proto",
+        "//iamf/common/utils:macros",
+        "//iamf/common/utils:numeric_utils",
+        "//iamf/common/utils:sample_processing_utils",
+        "//iamf/obu:mix_presentation",
+        "@com_google_absl//absl/base:no_destructor",
+        "@com_google_absl//absl/container:flat_hash_map",
+        "@com_google_absl//absl/log",
+        "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/memory",
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/status:statusor",
+        "@com_google_absl//absl/strings",
+        "@com_google_absl//absl/types:span",
+        "@com_google_loudness_ebur128//:ebur128_analyzer",
+    ],
+)
+
+# keep-sorted end
diff --git a/iamf/cli/itu_1770_4/loudness_calculator_factory_itu_1770_4.cc b/iamf/cli/itu_1770_4/loudness_calculator_factory_itu_1770_4.cc
new file mode 100644
index 0000000..416d72d
--- /dev/null
+++ b/iamf/cli/itu_1770_4/loudness_calculator_factory_itu_1770_4.cc
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2024, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+#include "iamf/cli/itu_1770_4/loudness_calculator_factory_itu_1770_4.h"
+
+#include <cstdint>
+#include <memory>
+
+#include "iamf/cli/itu_1770_4/loudness_calculator_itu_1770_4.h"
+#include "iamf/cli/loudness_calculator_base.h"
+#include "iamf/obu/mix_presentation.h"
+
+namespace iamf_tools {
+
+std::unique_ptr<LoudnessCalculatorBase>
+LoudnessCalculatorFactoryItu1770_4::CreateLoudnessCalculator(
+    const MixPresentationLayout& layout, uint32_t num_samples_per_frame,
+    int32_t rendered_sample_rate, int32_t rendered_bit_depth) const {
+  return LoudnessCalculatorItu1770_4::CreateForLayout(
+      layout, num_samples_per_frame, rendered_sample_rate, rendered_bit_depth);
+}
+
+}  // namespace iamf_tools
diff --git a/iamf/cli/itu_1770_4/loudness_calculator_factory_itu_1770_4.h b/iamf/cli/itu_1770_4/loudness_calculator_factory_itu_1770_4.h
new file mode 100644
index 0000000..5f40ff2
--- /dev/null
+++ b/iamf/cli/itu_1770_4/loudness_calculator_factory_itu_1770_4.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2024, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+#ifndef CLI_ITU_1770_4_LOUDNESS_CALCULATOR_FACTORY_ITU_1770_4_H_
+#define CLI_ITU_1770_4_LOUDNESS_CALCULATOR_FACTORY_ITU_1770_4_H_
+
+#include <cstdint>
+#include <memory>
+
+#include "iamf/cli/loudness_calculator_base.h"
+#include "iamf/cli/loudness_calculator_factory_base.h"
+#include "iamf/obu/mix_presentation.h"
+
+namespace iamf_tools {
+
+/*!\brief Factory which returns ITU 1770-4 loudness calculators.
+ *
+ * This factory creates `LoudnessCalculatorItu1770_4` calculators. It can be
+ * used to measure the loudness of any layout defined in IAMF v1 (excluding
+ * extensions).
+ *
+ * This factory is intended to be used when the user wants "accurate" loudness
+ * measurements for a signal when played on a particular layout. It should only
+ * be used when the user expects to pass in samples which are representative of
+ * the signal the end user would receive.
+ */
+class LoudnessCalculatorFactoryItu1770_4
+    : public LoudnessCalculatorFactoryBase {
+ public:
+  /*!\brief Creates an ITU 1770-4 loudness calculator.
+   *
+   * \param layout Layout to measure loudness on.
+   * \param num_samples_per_frame Number of samples per frame for the calculator
+   *        to process.
+   * \param rendered_sample_rate Sample rate of the rendered audio.
+   * \param rendered_bit_depth Bit-depth of the rendered audio.
+   * \return Unique pointer to a loudness calculator or `nullptr` if it could
+   *         not be created.
+   */
+  std::unique_ptr<LoudnessCalculatorBase> CreateLoudnessCalculator(
+      const MixPresentationLayout& layout, uint32_t num_samples_per_frame,
+      int32_t rendered_sample_rate, int32_t rendered_bit_depth) const override;
+
+  /*!\brief Destructor. */
+  ~LoudnessCalculatorFactoryItu1770_4() override = default;
+};
+
+}  // namespace iamf_tools
+
+#endif  // CLI_ITU_1770_4_LOUDNESS_CALCULATOR_FACTORY_ITU_1770_4_H_
diff --git a/iamf/cli/itu_1770_4/loudness_calculator_itu_1770_4.cc b/iamf/cli/itu_1770_4/loudness_calculator_itu_1770_4.cc
new file mode 100644
index 0000000..295697c
--- /dev/null
+++ b/iamf/cli/itu_1770_4/loudness_calculator_itu_1770_4.cc
@@ -0,0 +1,293 @@
+/*
+ * Copyright (c) 2024, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#include "iamf/cli/itu_1770_4/loudness_calculator_itu_1770_4.h"
+
+#include <algorithm>
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <vector>
+
+#include "absl/base/no_destructor.h"
+#include "absl/container/flat_hash_map.h"
+#include "absl/log/check.h"
+#include "absl/log/log.h"
+#include "absl/memory/memory.h"
+#include "absl/status/status.h"
+#include "absl/strings/str_cat.h"
+#include "absl/strings/str_join.h"
+#include "absl/strings/string_view.h"
+#include "absl/types/span.h"
+#include "iamf/cli/proto/mix_presentation.pb.h"
+#include "iamf/cli/proto/test_vector_metadata.pb.h"
+#include "iamf/common/utils/macros.h"
+#include "iamf/common/utils/numeric_utils.h"
+#include "iamf/common/utils/sample_processing_utils.h"
+#include "iamf/obu/mix_presentation.h"
+#include "include/ebur128_analyzer.h"
+
+namespace iamf_tools {
+
+namespace {
+// This implementation flattens data to interleaved format before passing to the
+// library.
+constexpr auto kInterleavesSampleLayout =
+    loudness::EbuR128Analyzer::INTERLEAVED;
+
+absl::Status FloatToQ7_8WithDebuggingMessage(float value, int16_t& output,
+                                             absl::string_view context) {
+  if (const auto& status = FloatToQ7_8(value, output); !status.ok()) {
+    // Prepend some better context to the error message.
+    return absl::Status(status.code(), absl::StrCat("Failed to set ", context,
+                                                    "`FloatToQ7_8` returned: ",
+                                                    status.message()));
+  }
+  return absl::OkStatus();
+}
+
+bool IncludeTruePeak(uint8_t info_type) {
+  return info_type & LoudnessInfo::kTruePeak;
+}
+
+// Returns the channel weights as per Table 4 and Table 5 of ITU-1770-4 when the
+// channels are ordered according to the `iamf-tools` output order (see
+// iamf/cli/testdata/README#Output-wav-files).
+absl::StatusOr<std::vector<float>> GetItu1770_4ChannelWeights(
+    const Layout& layout) {
+  switch (layout.layout_type) {
+    using enum Layout::LayoutType;
+    case Layout::kLayoutTypeLoudspeakersSsConvention: {
+      const auto& ss_layout =
+          std::get<LoudspeakersSsConventionLayout>(layout.specific_layout);
+
+      using enum LoudspeakersSsConventionLayout::SoundSystem;
+      static const absl::NoDestructor<absl::flat_hash_map<
+          LoudspeakersSsConventionLayout::SoundSystem, std::vector<float>>>
+          kSsLayoutToItu1440_4Weights({
+              {kSoundSystemA_0_2_0, {1.0f, 1.0f}},
+              {kSoundSystemB_0_5_0, {1.0f, 1.0f, 1.0f, 0.0f, 1.41f, 1.41f}},
+              {kSoundSystemC_2_5_0,
+               {1.0f, 1.0f, 1.0f, 0.0f, 1.41f, 1.41f, 1.0f, 1.0f}},
+              {kSoundSystemD_4_5_0,
+               {1.0f, 1.0f, 1.0f, 0.0f, 1.41f, 1.41f, 1.0f, 1.0f, 1.0f, 1.0f}},
+              {kSoundSystemE_4_5_1,
+               {1.0f, 1.0f, 1.0f, 0.0f, 1.41f, 1.41f, 1.0f, 1.0f, 1.0f, 1.0f,
+                1.0f}},
+              {kSoundSystemF_3_7_0,
+               {1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.41f, 1.41f, 1.0f, 1.0f, 1.0f,
+                0.0f, 0.0f}},
+              {kSoundSystemG_4_9_0,
+               {1.0f, 1.0f, 1.0f, 0.0f, 1.41f, 1.41f, 1.0f, 1.0f, 1.0f, 1.0f,
+                1.0f, 1.0f, 1.0f, 1.0f}},
+              {kSoundSystemH_9_10_3,
+               {1.41f, 1.41f, 1.0f,  0.0f, 1.0f, 1.0f, 1.0f, 1.0f,
+                1.0f,  0.0f,  1.41f, 1.41, 1.0f, 1.0f, 1.0f, 1.0f,
+                1.0f,  1.0f,  1.0f,  1.0f, 1.0f, 1.0f, 1.0f, 1.0f}},
+              {kSoundSystemI_0_7_0,
+               {1.0f, 1.0f, 1.0f, 0.0f, 1.41f, 1.41f, 1.0f, 1.0f}},
+              {kSoundSystemJ_4_7_0,
+               {1.0f, 1.0f, 1.0f, 0.0f, 1.41f, 1.41f, 1.0f, 1.0f, 1.0f, 1.0f,
+                1.0f, 1.0f}},
+              {kSoundSystem10_2_7_0,
+               {1.0f, 1.0f, 1.0f, 0.0f, 1.41f, 1.41f, 1.0f, 1.0f, 1.0f, 1.0f}},
+              {kSoundSystem11_2_3_0, {1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f}},
+              {kSoundSystem12_0_1_0, {1.0f}},
+              {kSoundSystem13_6_9_0,
+               {1.41f, 1.41f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.41f, 1.41,
+                1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f}},
+          });
+
+      auto it = kSsLayoutToItu1440_4Weights->find(ss_layout.sound_system);
+      if (it == kSsLayoutToItu1440_4Weights->end()) {
+        return absl::InvalidArgumentError(
+            absl::StrCat("Weights are not known for sound_system= ",
+                         ss_layout.sound_system));
+      }
+      return it->second;
+    }
+    case Layout::kLayoutTypeBinaural:
+      return std::vector<float>{1.0f, 1.0f};
+    default:
+      return absl::InvalidArgumentError(
+          absl::StrCat("Weights are not known for reserved layout_type= ",
+                       layout.layout_type));
+  }
+}
+
+// Flattens to the output buffer, and returns a span to the relevant slice of
+// data.
+absl::StatusOr<absl::Span<const uint8_t>> FlattenToInterleavedPcm(
+    absl::Span<const absl::Span<const int32_t>> channel_time_samples,
+    size_t max_num_samples_per_frame, int32_t expected_num_channels,
+    int32_t bit_depth, std::vector<uint8_t>& interleaved_pcm_buffer) {
+  if (channel_time_samples.size() != expected_num_channels) {
+    return absl::InvalidArgumentError(
+        absl::StrCat("Input samples are not stored in ", expected_num_channels,
+                     " channels."));
+  }
+
+  const size_t num_samples_per_channel =
+      channel_time_samples.empty() ? 0 : channel_time_samples[0].size();
+  if (num_samples_per_channel > max_num_samples_per_frame) {
+    return absl::InvalidArgumentError(absl::StrCat(
+        "Input number of samples per channel (", num_samples_per_channel,
+        ") is greater than the pre-configured number of samples per frame (",
+        max_num_samples_per_frame, ")"));
+  }
+
+  const bool all_channels_have_expected_num_samples =
+      std::all_of(channel_time_samples.begin(), channel_time_samples.end(),
+                  [&num_samples_per_channel](const auto& channel) {
+                    return channel.size() == num_samples_per_channel;
+                  });
+  if (!all_channels_have_expected_num_samples) {
+    return absl::InvalidArgumentError(
+        absl::StrCat("Detected a channel which does not contain ",
+                     num_samples_per_channel, " ticks."));
+  }
+
+  size_t write_position = 0;
+  const size_t interleaved_pcm_buffer_size = interleaved_pcm_buffer.size();
+  for (int t = 0; t < num_samples_per_channel; t++) {
+    for (int c = 0; c < expected_num_channels; ++c) {
+      // The buffer is pre-allocated to fit the largest accepted input. But for
+      // safety, check the write position does not exceed the buffer size.
+      CHECK(write_position < interleaved_pcm_buffer_size);
+      // `WritePcmSample` requires the input sample to be in the upper
+      // bits of the first argument.
+      RETURN_IF_NOT_OK(WritePcmSample(
+          static_cast<uint32_t>(channel_time_samples[c][t]), bit_depth,
+          /*big_endian=*/false, interleaved_pcm_buffer.data(), write_position));
+    }
+  }
+
+  return absl::MakeConstSpan(interleaved_pcm_buffer).first(write_position);
+}
+
+}  // namespace
+
+std::unique_ptr<LoudnessCalculatorItu1770_4>
+LoudnessCalculatorItu1770_4::CreateForLayout(
+    const MixPresentationLayout& layout, uint32_t num_samples_per_frame,
+    int32_t rendered_sample_rate, int32_t rendered_bit_depth) {
+  const auto weights = GetItu1770_4ChannelWeights(layout.loudness_layout);
+  if (!weights.ok()) {
+    LOG(ERROR) << "Failed to get channel weights: " << weights.status();
+    return nullptr;
+  }
+
+  // Configure a bit-depth to measure loudness on.
+  int32_t bit_depth_to_measure_loudness;
+  loudness::EbuR128Analyzer::SampleFormat sample_format;
+  switch (rendered_bit_depth) {
+    case 16:
+      bit_depth_to_measure_loudness = 16;
+      sample_format = loudness::EbuR128Analyzer::S16;
+      break;
+    case 24:
+    case 32:
+      // The underlying library does not support 24-bit input, so intentionally
+      // handle it the same as 32-bit.
+      bit_depth_to_measure_loudness = 32;
+      sample_format = loudness::EbuR128Analyzer::S32;
+      break;
+    default:
+      LOG(ERROR) << "Unsupported bit depth: " << rendered_bit_depth;
+      return nullptr;
+  }
+  // Later code assumes this is always a multiple of 8.
+  CHECK_EQ(bit_depth_to_measure_loudness % 8, 0);
+
+  const size_t num_channels = weights->size();
+
+  const bool enable_true_peak_measurement =
+      IncludeTruePeak(layout.loudness.info_type);
+  LOG(INFO) << "Creating AudioLoudness1770:";
+  LOG(INFO) << "  num_channels= " << num_channels;
+  LOG(INFO) << "  sample_rate= " << rendered_sample_rate;
+  LOG(INFO) << "  bit_depth_to_measure_loudness= "
+            << bit_depth_to_measure_loudness;
+  LOG(INFO) << "  sample_format= " << sample_format;
+  LOG(INFO) << "  enable_true_peak_measurement= "
+            << enable_true_peak_measurement;
+  LOG(INFO) << "  weights= " << absl::StrJoin(*weights, ", ");
+
+  return absl::WrapUnique(new LoudnessCalculatorItu1770_4(
+      num_samples_per_frame, num_channels, *weights, rendered_sample_rate,
+      bit_depth_to_measure_loudness, sample_format, layout.loudness,
+      enable_true_peak_measurement));
+}
+
+absl::Status LoudnessCalculatorItu1770_4::AccumulateLoudnessForSamples(
+    absl::Span<const absl::Span<const int32_t>> channel_time_samples) {
+  auto interleaved_pcm_span = FlattenToInterleavedPcm(
+      channel_time_samples, num_samples_per_frame_, num_channels_,
+      bit_depth_to_measure_loudness_, interleaved_pcm_buffer_);
+  if (!interleaved_pcm_span.ok()) {
+    return interleaved_pcm_span.status();
+  }
+
+  const int64_t num_samples_per_channel =
+      channel_time_samples.empty() ? 0 : channel_time_samples[0].size();
+  ebu_r128_analyzer_.Process(
+      static_cast<const void*>(interleaved_pcm_span->data()),
+      num_samples_per_channel, sample_format_, kInterleavesSampleLayout);
+
+  return absl::OkStatus();
+}
+
+absl::StatusOr<LoudnessInfo> LoudnessCalculatorItu1770_4::QueryLoudness()
+    const {
+  constexpr float kMinQ7_8 = -128.0;
+  constexpr float kMaxQ7_8 = 128.0 - 1 / 256.0;
+
+  float calculated_integrated_loudness = kMinQ7_8;
+  float calculated_digital_peak = kMinQ7_8;
+  float calculated_true_peak = kMinQ7_8;
+
+  if (const auto& integrated_loudness =
+          ebu_r128_analyzer_.GetRelativeGatedIntegratedLoudness();
+      !integrated_loudness.has_value()) {
+    // TODO(b/274740345): Figure out if there is a better solution for short
+    //                    audio sequences.
+    LOG(WARNING) << "Loudness cannot be computed or is too low; "
+                 << "using minimal value representable by Q7.8.";
+    // OK. Fallback to the default values.
+  } else {
+    calculated_integrated_loudness =
+        std::clamp(*integrated_loudness, kMinQ7_8, kMaxQ7_8);
+    calculated_digital_peak =
+        std::clamp(ebu_r128_analyzer_.digital_peak_dbfs(), kMinQ7_8, kMaxQ7_8);
+    calculated_true_peak =
+        std::clamp(ebu_r128_analyzer_.true_peak_dbfs(), kMinQ7_8, kMaxQ7_8);
+  }
+
+  // Initialize the output based on the user-provided loudness info. This allows
+  // loudnesses that this module does not support (i.e. anchored loudness,
+  // loudness extensions) to have a fallback.
+  LoudnessInfo output_loudness = user_provided_loudness_info_;
+
+  RETURN_IF_NOT_OK(FloatToQ7_8WithDebuggingMessage(
+      calculated_integrated_loudness, output_loudness.integrated_loudness,
+      "integrated loudness"));
+  RETURN_IF_NOT_OK(FloatToQ7_8WithDebuggingMessage(
+      calculated_digital_peak, output_loudness.digital_peak, "digital peak"));
+  if (IncludeTruePeak(user_provided_loudness_info_.info_type)) {
+    RETURN_IF_NOT_OK(FloatToQ7_8WithDebuggingMessage(
+        calculated_true_peak, output_loudness.true_peak, "true peak"));
+  }
+
+  return output_loudness;
+}
+
+}  // namespace iamf_tools
diff --git a/iamf/cli/itu_1770_4/loudness_calculator_itu_1770_4.h b/iamf/cli/itu_1770_4/loudness_calculator_itu_1770_4.h
new file mode 100644
index 0000000..7aeecf3
--- /dev/null
+++ b/iamf/cli/itu_1770_4/loudness_calculator_itu_1770_4.h
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 2024, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+#ifndef CLI_ITU_1770_4_LOUDNESS_CALCULATOR_ITU_1770_4_H_
+#define CLI_ITU_1770_4_LOUDNESS_CALCULATOR_ITU_1770_4_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+
+#include "absl/status/status.h"
+#include "absl/status/statusor.h"
+#include "absl/types/span.h"
+#include "iamf/cli/loudness_calculator_base.h"
+#include "iamf/obu/mix_presentation.h"
+#include "include/ebur128_analyzer.h"
+
+namespace iamf_tools {
+
+/*!\brief Calculate loudness according the ITU 1770-4 for an input audio stream.
+ *
+ * - Call the builder with an input `MixPresentationLayout`
+ * - Call `AccumulateLoudnessForSamples()` to accumulate interleaved audio
+ * samples to measure loudness on.
+ * - Call `QueryLoudness()` to query the current loudness. The types to be
+ * measured are determined from the constructor argument.
+ */
+class LoudnessCalculatorItu1770_4 : public LoudnessCalculatorBase {
+ public:
+  /*!\brief Creates an ITU 1770-4 loudness calculator.
+   *
+   * \param layout Layout to measure loudness on.
+   * \param num_samples_per_frame Number of samples per frame for the calculator
+   *        to process. Subsequent calls to `AccumulateLoudnessForSamples()`
+   *        must not have more sample than this.
+   * \param rendered_sample_rate Sample rate of the rendered audio.
+   * \param rendered_bit_depth Bit-depth of the rendered audio.
+   */
+  static std::unique_ptr<LoudnessCalculatorItu1770_4> CreateForLayout(
+      const MixPresentationLayout& layout, uint32_t num_samples_per_frame,
+      int32_t rendered_sample_rate, int32_t rendered_bit_depth);
+
+  /*!\brief Destructor. */
+  ~LoudnessCalculatorItu1770_4() override = default;
+
+  /*!\brief Accumulates samples to be measured.
+   *
+   * \param channel_time_samples Samples to measure arranged in (channel, time).
+   * \return `absl::OkStatus()` on success. A specific status on failure.
+   */
+  absl::Status AccumulateLoudnessForSamples(
+      absl::Span<const absl::Span<const int32_t>> channel_time_samples)
+      override;
+
+  /*!\brief Outputs the measured loudness.
+   *
+   * Outputs a `LoudnessInfo` with calculated values for `integrated_loudness`,
+   * `digital_peak`, and (optionally) `true_peak` according to ITU-1770-4. Other
+   * loudness values are copied over from the user-provided `LoudnessInfo`.
+   *
+   * \return Measured loudness on success. A specific status on failure.
+   */
+  absl::StatusOr<LoudnessInfo> QueryLoudness() const override;
+
+ private:
+  /*!\brief Constructor.
+   *
+   * \param num_samples_per_frame Number of samples per frame for the calculator
+   *        to process.
+   * \param num_channels Number of channels in the input audio.
+   * \param weights Per-channel weights for each of the ITU-1770-4
+   *        loudness-measurement bands.
+   * \param rendered_sample_rate Sample rate of the rendered audio.
+   * \param bit_depth_to_measure_loudness Bit-depth to use when measuring the
+   *        rendered audio.
+   * \param sample_format Sample format to use when measuring the rendered
+   *        audio.
+   * \param loudness_info User-provided loudness information.
+   * \param enable_true_peak_measurement Whether to enable true peak
+   *        measurement.
+   */
+  LoudnessCalculatorItu1770_4(
+      uint32_t num_samples_per_frame, int32_t num_channels,
+      const std::vector<float>& weights, int32_t rendered_sample_rate,
+      int32_t bit_depth_to_measure_loudness,
+      loudness::EbuR128Analyzer::SampleFormat sample_format,
+      const LoudnessInfo& loudness_info, bool enable_true_peak_measurement)
+      : num_samples_per_frame_(num_samples_per_frame),
+        num_channels_(num_channels),
+        bit_depth_to_measure_loudness_(bit_depth_to_measure_loudness),
+        sample_format_(sample_format),
+        user_provided_loudness_info_(loudness_info),
+        interleaved_pcm_buffer_(num_samples_per_frame * num_channels *
+                                bit_depth_to_measure_loudness / 8),
+        ebu_r128_analyzer_(num_channels, weights, rendered_sample_rate,
+                           enable_true_peak_measurement) {}
+
+  const uint32_t num_samples_per_frame_;
+  const int32_t num_channels_;
+  const int32_t bit_depth_to_measure_loudness_;
+  const loudness::EbuR128Analyzer::SampleFormat sample_format_;
+  const LoudnessInfo user_provided_loudness_info_;
+
+  // Reusable buffer between calls, to prevent excessive allocations.
+  std::vector<uint8_t> interleaved_pcm_buffer_;
+
+  loudness::EbuR128Analyzer ebu_r128_analyzer_;
+};
+
+}  // namespace iamf_tools
+
+#endif  // CLI_ITU_1770_4_LOUDNESS_CALCULATOR_ITU_1770_4_H_
diff --git a/iamf/cli/itu_1770_4/tests/BUILD b/iamf/cli/itu_1770_4/tests/BUILD
new file mode 100644
index 0000000..f136e33
--- /dev/null
+++ b/iamf/cli/itu_1770_4/tests/BUILD
@@ -0,0 +1,28 @@
+# keep-sorted start block=yes prefix_order=cc_test newline_separated=yes
+cc_test(
+    name = "loudness_calculator_factory_itu_1770_4_test",
+    srcs = ["loudness_calculator_factory_itu_1770_4_test.cc"],
+    deps = [
+        "//iamf/cli/itu_1770_4:loudness_calculator_factory_itu_1770_4",
+        "//iamf/cli/proto:obu_header_cc_proto",
+        "//iamf/cli/proto:parameter_data_cc_proto",
+        "//iamf/cli/proto:temporal_delimiter_cc_proto",
+        "//iamf/cli/proto:user_metadata_cc_proto",
+        "//iamf/obu:mix_presentation",
+        "@com_google_googletest//:gtest_main",
+    ],
+)
+
+cc_test(
+    name = "loudness_calculator_itu_1770_4_test",
+    srcs = ["loudness_calculator_itu_1770_4_test.cc"],
+    deps = [
+        "//iamf/cli/itu_1770_4:loudness_calculator_itu_1770_4",
+        "//iamf/cli/tests:cli_test_utils",
+        "//iamf/obu:mix_presentation",
+        "@com_google_absl//absl/status:status_matchers",
+        "@com_google_googletest//:gtest_main",
+    ],
+)
+
+# keep-sorted end
diff --git a/iamf/cli/itu_1770_4/tests/loudness_calculator_factory_itu_1770_4_test.cc b/iamf/cli/itu_1770_4/tests/loudness_calculator_factory_itu_1770_4_test.cc
new file mode 100644
index 0000000..018c75a
--- /dev/null
+++ b/iamf/cli/itu_1770_4/tests/loudness_calculator_factory_itu_1770_4_test.cc
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2024, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+#include "iamf/cli/itu_1770_4/loudness_calculator_factory_itu_1770_4.h"
+
+#include <cstdint>
+
+#include "gtest/gtest.h"
+#include "iamf/cli/proto/obu_header.pb.h"
+#include "iamf/cli/proto/parameter_data.pb.h"
+#include "iamf/cli/proto/temporal_delimiter.pb.h"
+#include "iamf/cli/proto/user_metadata.pb.h"
+#include "iamf/obu/mix_presentation.h"
+
+namespace iamf_tools {
+namespace {
+
+constexpr uint32_t kNumSamplesPerFrame = 1024;
+constexpr int32_t kRenderedSampleRate = 48000;
+constexpr int32_t kRenderedBitDepth = 16;
+
+const MixPresentationLayout kStereoMixPresentationLayout = {
+    .loudness_layout =
+        {.layout_type = Layout::kLayoutTypeLoudspeakersSsConvention,
+         .specific_layout =
+             LoudspeakersSsConventionLayout{
+                 .sound_system =
+                     LoudspeakersSsConventionLayout::kSoundSystemA_0_2_0}},
+    .loudness = {}};
+
+const MixPresentationLayout kUnknownExtensionLayout = {
+    .loudness_layout = {.layout_type = Layout::kLayoutTypeReserved0,
+                        .specific_layout =
+                            LoudspeakersReservedOrBinauralLayout{}},
+    .loudness = {}};
+
+TEST(CreateLoudnessCalculator, ReturnsNonNullWhenLayoutIsKnown) {
+  const LoudnessCalculatorFactoryItu1770_4 factory;
+
+  EXPECT_NE(factory.CreateLoudnessCalculator(
+                kStereoMixPresentationLayout, kNumSamplesPerFrame,
+                kRenderedSampleRate, kRenderedBitDepth),
+            nullptr);
+}
+
+TEST(CreateLoudnessCalculator, ReturnsNullWhenLayoutIsUnknown) {
+  const LoudnessCalculatorFactoryItu1770_4 factory;
+
+  EXPECT_EQ(factory.CreateLoudnessCalculator(
+                kUnknownExtensionLayout, kNumSamplesPerFrame,
+                kRenderedSampleRate, kRenderedBitDepth),
+            nullptr);
+}
+
+}  // namespace
+}  // namespace iamf_tools
diff --git a/iamf/cli/itu_1770_4/tests/loudness_calculator_itu_1770_4_test.cc b/iamf/cli/itu_1770_4/tests/loudness_calculator_itu_1770_4_test.cc
new file mode 100644
index 0000000..4f4f7f8
--- /dev/null
+++ b/iamf/cli/itu_1770_4/tests/loudness_calculator_itu_1770_4_test.cc
@@ -0,0 +1,250 @@
+/*
+ * Copyright (c) 2024, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+#include "iamf/cli/itu_1770_4/loudness_calculator_itu_1770_4.h"
+
+#include <cstddef>
+#include <cstdint>
+#include <limits>
+#include <memory>
+#include <vector>
+
+#include "absl/status/status_matchers.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+#include "iamf/cli/tests/cli_test_utils.h"
+#include "iamf/obu/mix_presentation.h"
+
+namespace iamf_tools {
+namespace {
+
+using ::absl_testing::IsOk;
+
+const int16_t kMaxLoudness = std::numeric_limits<int16_t>::max();
+const int16_t kMinLoudness = std::numeric_limits<int16_t>::min();
+
+const uint32_t kNumSamplesPerFrame = 1024;
+// Changing this effectively changes the frequencies of the samples; loudness
+// is dependent on frequency.
+const uint32_t kSampleRate = 48000;
+const uint32_t kMaxBitDepthToMeasureLoudness = 32;
+
+const Layout kStereoLayout = {
+    .layout_type = Layout::kLayoutTypeLoudspeakersSsConvention,
+    .specific_layout = LoudspeakersSsConventionLayout{
+        .sound_system = LoudspeakersSsConventionLayout::kSoundSystemA_0_2_0}};
+
+const Layout kMonoLayout = {
+    .layout_type = Layout::kLayoutTypeLoudspeakersSsConvention,
+    .specific_layout = LoudspeakersSsConventionLayout{
+        .sound_system = LoudspeakersSsConventionLayout::kSoundSystem12_0_1_0}};
+
+const LoudnessInfo kLoudnessInfoWithMaxLoudness = {
+    .info_type = LoudnessInfo::kTruePeak,
+    .integrated_loudness = kMaxLoudness,
+    .digital_peak = kMaxLoudness,
+    .true_peak = kMaxLoudness};
+
+const MixPresentationLayout kStereoLayoutWithMaxUserLoudness = {
+    .loudness_layout = kStereoLayout, .loudness = kLoudnessInfoWithMaxLoudness};
+
+TEST(CreateForLayout, ReturnsNonNullForKnownLayouts) {
+  EXPECT_NE(LoudnessCalculatorItu1770_4::CreateForLayout(
+                kStereoLayoutWithMaxUserLoudness, kNumSamplesPerFrame,
+                kSampleRate, kMaxBitDepthToMeasureLoudness),
+            nullptr);
+}
+
+TEST(CreateForLayout, ReturnsNullForReservedLayouts) {
+  const MixPresentationLayout kReservedLayout = {
+      .loudness_layout = {
+          .layout_type = Layout::kLayoutTypeReserved0,
+          .specific_layout = LoudspeakersReservedOrBinauralLayout{}}};
+  EXPECT_EQ(LoudnessCalculatorItu1770_4::CreateForLayout(
+                kReservedLayout, kNumSamplesPerFrame, kSampleRate,
+                kMaxBitDepthToMeasureLoudness),
+            nullptr);
+}
+
+TEST(LoudnessCalculatorItu1770_4, ReturnsNullptrForUnsupportedBitDepth) {
+  const auto kUnsupportedBitDepth = 12;
+  auto calculator = LoudnessCalculatorItu1770_4::CreateForLayout(
+      kStereoLayoutWithMaxUserLoudness, kNumSamplesPerFrame, kSampleRate,
+      kUnsupportedBitDepth);
+
+  ASSERT_EQ(calculator, nullptr);
+}
+
+TEST(LoudnessCalculatorItu1770_4, ProvidesMinimumLoudnessForEmptySequence) {
+  auto calculator = LoudnessCalculatorItu1770_4::CreateForLayout(
+      kStereoLayoutWithMaxUserLoudness, kNumSamplesPerFrame, kSampleRate,
+      kMaxBitDepthToMeasureLoudness);
+  ASSERT_NE(calculator, nullptr);
+
+  const auto& calculated_loudness = calculator->QueryLoudness();
+  ASSERT_THAT(calculated_loudness, IsOk());
+
+  EXPECT_EQ((*calculated_loudness).integrated_loudness, kMinLoudness);
+  EXPECT_EQ((*calculated_loudness).digital_peak, kMinLoudness);
+  EXPECT_EQ((*calculated_loudness).true_peak, kMinLoudness);
+}
+
+TEST(LoudnessCalculatorItu1770_4, ProvidesMinimumLoudnessForShortSequences) {
+  auto calculator = LoudnessCalculatorItu1770_4::CreateForLayout(
+      kStereoLayoutWithMaxUserLoudness, kNumSamplesPerFrame, kSampleRate,
+      kMaxBitDepthToMeasureLoudness);
+  ASSERT_NE(calculator, nullptr);
+
+  const std::vector<std::vector<int32_t>> samples = {
+      {std::numeric_limits<int32_t>::min(),
+       std::numeric_limits<int32_t>::max()},
+      {std::numeric_limits<int32_t>::min(),
+       std::numeric_limits<int32_t>::max()}};
+  EXPECT_THAT(
+      calculator->AccumulateLoudnessForSamples(MakeSpanOfConstSpans(samples)),
+      IsOk());
+  const auto& calculated_loudness = calculator->QueryLoudness();
+  ASSERT_THAT(calculated_loudness, IsOk());
+
+  EXPECT_EQ((*calculated_loudness).integrated_loudness, kMinLoudness);
+  EXPECT_EQ((*calculated_loudness).digital_peak, kMinLoudness);
+  EXPECT_EQ((*calculated_loudness).true_peak, kMinLoudness);
+}
+
+TEST(LoudnessCalculatorItu1770_4, AlwaysCopiesAnchoredLoudness) {
+  const uint8_t kExpectedNumAnchoredLoudness = 1;
+  const auto kExpectedAnchorElement =
+      AnchoredLoudnessElement::kAnchorElementDialogue;
+  const int16_t kExpectedDialogueLoudness = 123;
+  const MixPresentationLayout kLayoutWithAnchoredLoudness = {
+      .loudness_layout = kStereoLayout,
+      .loudness = {.info_type = LoudnessInfo::kTruePeak,
+                   .anchored_loudness = {
+                       .anchor_elements = {
+                           {.anchor_element = kExpectedAnchorElement,
+                            .anchored_loudness = kExpectedDialogueLoudness}}}}};
+
+  const auto calculator = LoudnessCalculatorItu1770_4::CreateForLayout(
+      kLayoutWithAnchoredLoudness, kNumSamplesPerFrame, kSampleRate,
+      kMaxBitDepthToMeasureLoudness);
+  ASSERT_NE(calculator, nullptr);
+  const auto& calculated_loudness = calculator->QueryLoudness();
+  ASSERT_THAT(calculated_loudness, IsOk());
+
+  EXPECT_EQ(calculated_loudness->anchored_loudness.anchor_elements.size(),
+            kExpectedNumAnchoredLoudness);
+  ASSERT_FALSE(calculated_loudness->anchored_loudness.anchor_elements.empty());
+  EXPECT_EQ(
+      calculated_loudness->anchored_loudness.anchor_elements[0].anchor_element,
+      kExpectedAnchorElement);
+  EXPECT_EQ(calculated_loudness->anchored_loudness.anchor_elements[0]
+                .anchored_loudness,
+            kExpectedDialogueLoudness);
+}
+
+TEST(LoudnessCalculatorItu1770_4, MeasuresLoudnessWithSharpPeak) {
+  constexpr size_t kNumTicks = 10;
+  constexpr size_t kNumChannels = 1;
+  const std::vector<std::vector<int32_t>> kQuietSignal(
+      kNumChannels, std::vector<int32_t>(kNumTicks, 0));
+  const std::vector<std::vector<int32_t>> kSignalWithHighTruePeak = {
+      {0, 0, 0, 0, std::numeric_limits<int32_t>::max(), 0, 0, 0, 0, 0}};
+  const MixPresentationLayout kMonoLayoutWithMaxUserLoudness = {
+      .loudness_layout = kMonoLayout, .loudness = kLoudnessInfoWithMaxLoudness};
+
+  auto calculator = LoudnessCalculatorItu1770_4::CreateForLayout(
+      kMonoLayoutWithMaxUserLoudness, kNumSamplesPerFrame, kSampleRate,
+      kMaxBitDepthToMeasureLoudness);
+  ASSERT_NE(calculator, nullptr);
+
+  // Create a sequence that is generally quiet, but has a single sharp peak.
+  for (int i = 0; i < 1000; i++) {
+    EXPECT_THAT(calculator->AccumulateLoudnessForSamples(
+                    MakeSpanOfConstSpans(kQuietSignal)),
+                IsOk());
+  }
+  EXPECT_THAT(calculator->AccumulateLoudnessForSamples(
+                  MakeSpanOfConstSpans(kSignalWithHighTruePeak)),
+              IsOk());
+  for (int i = 0; i < 1000; i++) {
+    EXPECT_THAT(calculator->AccumulateLoudnessForSamples(
+                    MakeSpanOfConstSpans(kQuietSignal)),
+                IsOk());
+  }
+
+  const auto& calculated_loudness = calculator->QueryLoudness();
+  ASSERT_THAT(calculated_loudness, IsOk());
+
+  EXPECT_NE((*calculated_loudness).integrated_loudness, kMinLoudness);
+  // Digital and true peaks should be 0 dBFS.
+  EXPECT_EQ((*calculated_loudness).true_peak, 0);
+  EXPECT_EQ((*calculated_loudness).digital_peak, 0);
+}
+
+TEST(AccumulateLoudnessForSamples, SucceedsWithExactlyEnoughSamples) {
+  const MixPresentationLayout kMonoLayoutWithMaxUserLoudness = {
+      .loudness_layout = kMonoLayout, .loudness = kLoudnessInfoWithMaxLoudness};
+  auto calculator = LoudnessCalculatorItu1770_4::CreateForLayout(
+      kMonoLayoutWithMaxUserLoudness, kNumSamplesPerFrame, kSampleRate,
+      kMaxBitDepthToMeasureLoudness);
+  ASSERT_NE(calculator, nullptr);
+
+  constexpr size_t kNumChannels = 1;
+  const std::vector<std::vector<int32_t>> kExactlyEnoughSamples(
+      kNumChannels, std::vector<int32_t>(kNumSamplesPerFrame, 0));
+  EXPECT_THAT(calculator->AccumulateLoudnessForSamples(
+                  MakeSpanOfConstSpans(kExactlyEnoughSamples)),
+              IsOk());
+}
+
+TEST(AccumulateLoudnessForSamples,
+     ReturnsErrorWhenThereAreNotAMultipleOfNumChannels) {
+  const MixPresentationLayout kStereoLayoutWithMaxUserLoudness = {
+      .loudness_layout = kStereoLayout,
+      .loudness = kLoudnessInfoWithMaxLoudness};
+  auto calculator = LoudnessCalculatorItu1770_4::CreateForLayout(
+      kStereoLayoutWithMaxUserLoudness, kNumSamplesPerFrame, kSampleRate,
+      kMaxBitDepthToMeasureLoudness);
+  ASSERT_NE(calculator, nullptr);
+
+  // The calculator is configured for stereo, but there is only one channel.
+  constexpr size_t kNumTicks = 10;
+  constexpr size_t kTooFewChannels = 1;
+  const std::vector<std::vector<int32_t>> kSamplesWithMissingChannels(
+      kTooFewChannels, std::vector<int32_t>(kNumTicks, 0));
+  EXPECT_FALSE(calculator
+                   ->AccumulateLoudnessForSamples(
+                       MakeSpanOfConstSpans(kSamplesWithMissingChannels))
+                   .ok());
+}
+
+TEST(AccumulateLoudnessForSamples, ReturnsErrorWhenThereAreTooManySamples) {
+  const MixPresentationLayout kMonoLayoutWithMaxUserLoudness = {
+      .loudness_layout = kMonoLayout, .loudness = kLoudnessInfoWithMaxLoudness};
+  auto calculator = LoudnessCalculatorItu1770_4::CreateForLayout(
+      kMonoLayoutWithMaxUserLoudness, kNumSamplesPerFrame, kSampleRate,
+      kMaxBitDepthToMeasureLoudness);
+  ASSERT_NE(calculator, nullptr);
+
+  // The calculator is configured to accept only `kNumSamplesPerFrame` samples.
+  // It is invalid to provide more samples per call.
+  constexpr size_t kTooManySamples = kNumSamplesPerFrame + 1;
+  constexpr size_t kNumChannels = 2;
+  const std::vector<std::vector<int32_t>> kSamplesWithTooManySamples(
+      kNumChannels, std::vector<int32_t>(kTooManySamples, 0));
+  EXPECT_FALSE(calculator
+                   ->AccumulateLoudnessForSamples(
+                       MakeSpanOfConstSpans(kSamplesWithTooManySamples))
+                   .ok());
+}
+
+}  // namespace
+}  // namespace iamf_tools
diff --git a/iamf/cli/loudness_calculator_base.h b/iamf/cli/loudness_calculator_base.h
index 19c47a1..d049282 100644
--- a/iamf/cli/loudness_calculator_base.h
+++ b/iamf/cli/loudness_calculator_base.h
@@ -13,7 +13,6 @@
 #define CLI_LOUDNESS_CALCULATOR_BASE_H_
 
 #include <cstdint>
-#include <vector>
 
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
@@ -37,11 +36,11 @@ class LoudnessCalculatorBase {
 
   /*!\brief Accumulates samples to be measured.
    *
-   * \param time_channel_samples Samples to push arranged in (time, channel).
+   * \param channel_time_samples Samples to push arranged in (channel, time).
    * \return `absl::OkStatus()` on success. A specific status on failure.
    */
   virtual absl::Status AccumulateLoudnessForSamples(
-      absl::Span<const std::vector<int32_t>> time_channel_samples) = 0;
+      absl::Span<const absl::Span<const int32_t>> channel_time_samples) = 0;
 
   /*!\brief Outputs the measured loudness.
    *
diff --git a/iamf/cli/obu_processor.cc b/iamf/cli/obu_processor.cc
index b639300..d99c36a 100644
--- a/iamf/cli/obu_processor.cc
+++ b/iamf/cli/obu_processor.cc
@@ -61,12 +61,28 @@ namespace iamf_tools {
 
 namespace {
 
+// The size of a Codec Config OBU payload (after header) if all fields are
+// minimal size, and `DecoderConfig` is empty. Real Codec Config OBUs would have
+// a non-empty `DecoderConfig` and always be a few bytes larger.
+constexpr size_t kSmallestAcceptedCodecConfigSize = 8;
+
 // Gets a CodecConfigObu from `read_bit_buffer` and stores it into
 // `codec_config_obu_map`, using the `codec_config_id` as the unique key.
 absl::Status GetAndStoreCodecConfigObu(
     const ObuHeader& header, int64_t payload_size,
     absl::flat_hash_map<DecodedUleb128, CodecConfigObu>& codec_config_obu_map,
     ReadBitBuffer& read_bit_buffer) {
+  if (payload_size < kSmallestAcceptedCodecConfigSize) {
+    // The OBU is implausibly small. It is likely the source file is corrupted.
+    // For maximum compatibility, silently skip over the OBU.
+    LOG(WARNING)
+        << "Possible bitstream corruption. Skipping over an "
+           "implausibly small Codec Config OBU with a payload size of: "
+        << payload_size << " bytes.";
+    std::vector<uint8_t> buffer_to_discard(payload_size);
+    return read_bit_buffer.ReadUint8Span(absl::MakeSpan(buffer_to_discard));
+  }
+
   absl::StatusOr<CodecConfigObu> codec_config_obu =
       CodecConfigObu::CreateFromBuffer(header, payload_size, read_bit_buffer);
   if (!codec_config_obu.ok()) {
@@ -208,18 +224,15 @@ absl::Status GetAndStoreParameterBlockWithData(
 // Returns a list of pointers to the supported mix presentations. Empty if none
 // are supported.
 std::list<MixPresentationObu*> GetSupportedMixPresentations(
+    const absl::flat_hash_set<ProfileVersion> requested_profiles,
     const absl::flat_hash_map<uint32_t, AudioElementWithData>& audio_elements,
     std::list<MixPresentationObu>& mix_presentation_obus) {
-  // TODO(b/377554944): Support `ProfileVersion::kIamfBaseEnhancedProfile`.
-  // Only permit certain profiles to be used.
-  const absl::flat_hash_set<ProfileVersion> kSupportedProfiles = {
-      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile};
-
+  // Find a mix presentation and layout that agrees with the requested profiles.
   std::list<MixPresentationObu*> supported_mix_presentations;
   std::string cumulative_error_message;
   for (auto iter = mix_presentation_obus.begin();
        iter != mix_presentation_obus.end(); ++iter) {
-    auto profiles = kSupportedProfiles;
+    auto profiles = requested_profiles;
     const auto status = ProfileFilter::FilterProfilesForMixPresentation(
         audio_elements, *iter, profiles);
     if (status.ok()) {
@@ -260,9 +273,12 @@ absl::StatusOr<MixPresentationObu*> GetPlaybackLayoutAndMixPresentation(
     return absl::InvalidArgumentError(
         "No layouts found in the first submix of the first mix presentation.");
   }
-  output_playback_layout = output_mix_presentation->sub_mixes_.front()
-                               .layouts.front()
-                               .loudness_layout;
+  // We add a "virtual" layout here that matches the desired layout if it wasn't
+  // found. This allows us to decode to the user-requested layout even if it
+  // wasn't present in the mix presentation.
+  output_mix_presentation->sub_mixes_.front().layouts.front().loudness_layout =
+      desired_layout;
+  output_playback_layout = desired_layout;
   return output_mix_presentation;
 }
 
@@ -659,6 +675,7 @@ std::unique_ptr<ObuProcessor> ObuProcessor::Create(
 }
 
 std::unique_ptr<ObuProcessor> ObuProcessor::CreateForRendering(
+    const absl::flat_hash_set<ProfileVersion>& desired_profile_versions,
     const Layout& desired_layout,
     const RenderingMixPresentationFinalizer::SampleProcessorFactory&
         sample_processor_factory,
@@ -680,7 +697,8 @@ std::unique_ptr<ObuProcessor> ObuProcessor::CreateForRendering(
   }
 
   if (const auto status = obu_processor->InitializeForRendering(
-          desired_layout, sample_processor_factory, output_layout);
+          desired_profile_versions, desired_layout, sample_processor_factory,
+          output_layout);
       !status.ok()) {
     LOG(ERROR) << status;
     return nullptr;
@@ -703,6 +721,7 @@ absl::StatusOr<uint32_t> ObuProcessor::GetOutputFrameSize() const {
 }
 
 absl::Status ObuProcessor::InitializeForRendering(
+    const absl::flat_hash_set<ProfileVersion>& desired_profile_versions,
     const Layout& desired_layout,
     const RenderingMixPresentationFinalizer::SampleProcessorFactory&
         sample_processor_factory,
@@ -734,7 +753,8 @@ absl::Status ObuProcessor::InitializeForRendering(
   // TODO(b/340289717): Add a way to select the mix presentation if multiple
   //                    are supported.
   const std::list<MixPresentationObu*> supported_mix_presentations =
-      GetSupportedMixPresentations(audio_elements_, mix_presentations_);
+      GetSupportedMixPresentations(desired_profile_versions, audio_elements_,
+                                   mix_presentations_);
   if (supported_mix_presentations.empty()) {
     return absl::NotFoundError("No supported mix presentation OBUs found.");
   }
@@ -851,6 +871,8 @@ absl::Status ObuProcessor::ProcessTemporalUnit(
     // - The timestamp has advanced (i.e. when the next temporal unit gets its
     //   timestamp).
     // - A temporal delimiter is encountered.
+    // TODO(b/405943120): Stop creating buggy first "empty" temporal units when
+    //                    temporal delimiters are encountered.
     if ((!continue_processing && eos_is_end_of_sequence) ||
         next_temporal_unit_.timestamp.has_value() ||
         current_temporal_unit_.temporal_delimiter.has_value()) {
@@ -876,7 +898,7 @@ absl::Status ObuProcessor::RenderTemporalUnitAndMeasureLoudness(
     InternalTimestamp start_timestamp,
     const std::list<AudioFrameWithData>& audio_frames,
     const std::list<ParameterBlockWithData>& parameter_blocks,
-    absl::Span<const std::vector<int32_t>>& output_rendered_pcm_samples) {
+    absl::Span<const absl::Span<const int32_t>>& output_rendered_pcm_samples) {
   if (audio_frames.empty()) {
     // Nothing to decode, render, or measure loudness of.
     return absl::OkStatus();
@@ -917,7 +939,7 @@ absl::Status ObuProcessor::RenderTemporalUnitAndMeasureLoudness(
                                        audio_frame.end_timestamp,
                                        "Audio frame has a different end "
                                        "timestamp than the temporal unit: "));
-    auto decoded_frame = audio_frame_decoder_->Decode(audio_frame);
+    const auto& decoded_frame = audio_frame_decoder_->Decode(audio_frame);
     if (!decoded_frame.ok()) {
       return decoded_frame.status();
     }
@@ -926,7 +948,7 @@ absl::Status ObuProcessor::RenderTemporalUnitAndMeasureLoudness(
   }
 
   // Reconstruct the temporal unit and store the result in the output map.
-  const auto decoded_labeled_frames_for_temporal_unit =
+  const auto& decoded_labeled_frames_for_temporal_unit =
       demixing_module_->DemixDecodedAudioSamples(
           decoded_frames_for_temporal_unit_);
   if (!decoded_labeled_frames_for_temporal_unit.ok()) {
diff --git a/iamf/cli/obu_processor.h b/iamf/cli/obu_processor.h
index cc607e3..7f9ece8 100644
--- a/iamf/cli/obu_processor.h
+++ b/iamf/cli/obu_processor.h
@@ -17,9 +17,10 @@
 #include <list>
 #include <memory>
 #include <optional>
-#include <vector>
 
+#include "absl/base/nullability.h"
 #include "absl/container/flat_hash_map.h"
+#include "absl/container/flat_hash_set.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/types/span.h"
@@ -154,6 +155,8 @@ class ObuProcessor {
    * Creation succeeds only if the descriptor OBUs are successfully processed
    * and all rendering modules are successfully initialized.
    *
+   * \param desired_profile_versions Profiles that are permitted to be used
+   *        selecting the mix presentation.
    * \param desired_layout Specifies the desired layout that will be used to
    *        render the audio, if available in the mix presentations. If not
    *        available, the first layout in the first mix presentation will be
@@ -174,6 +177,7 @@ class ObuProcessor {
    * \return Pointer to an ObuProcessor on success. `nullptr` on failure.
    */
   static std::unique_ptr<ObuProcessor> CreateForRendering(
+      const absl::flat_hash_set<ProfileVersion>& desired_profile_versions,
       const Layout& desired_layout,
       const RenderingMixPresentationFinalizer::SampleProcessorFactory&
           sample_processor_factory,
@@ -262,7 +266,7 @@ class ObuProcessor {
       InternalTimestamp timestamp,
       const std::list<AudioFrameWithData>& audio_frames,
       const std::list<ParameterBlockWithData>& parameter_blocks,
-      absl::Span<const std::vector<int32_t>>& output_rendered_pcm_samples);
+      absl::Span<const absl::Span<const int32_t>>& output_rendered_pcm_samples);
 
   IASequenceHeaderObu ia_sequence_header_;
   absl::flat_hash_map<DecodedUleb128, CodecConfigObu> codec_config_obus_ = {};
@@ -277,7 +281,8 @@ class ObuProcessor {
    *        bitstream.
    * \return ObuProcessor instance.
    */
-  explicit ObuProcessor(ReadBitBuffer* buffer) : read_bit_buffer_(buffer) {}
+  explicit ObuProcessor(ReadBitBuffer* /* absl_nonnull */ buffer)
+      : read_bit_buffer_(buffer) {}
 
   /*!\brief Performs internal initialization of the OBU processor.
    *
@@ -300,6 +305,8 @@ class ObuProcessor {
    *
    * Must be called after `Initialize()` is called.
    *
+   * \param desired_profile_versions Profiles that are permitted to be used
+   *        selecting the mix presentation.
    * \param desired_layout Specifies the layout that will be used to render the
    *        audio, if available.
    * \param sample_processor_factory Factory to create post processors.
@@ -310,6 +317,7 @@ class ObuProcessor {
    *         on failure.
    */
   absl::Status InitializeForRendering(
+      const absl::flat_hash_set<ProfileVersion>& desired_profile_versions,
       const Layout& desired_layout,
       const RenderingMixPresentationFinalizer::SampleProcessorFactory&
           sample_processor_factory,
@@ -326,7 +334,7 @@ class ObuProcessor {
     std::list<AudioFrameWithData> audio_frames;
 
     std::optional<TemporalDelimiterObu> temporal_delimiter;
-    std::optional<int32_t> timestamp;
+    std::optional<InternalTimestamp> timestamp;
 
     bool Empty() const {
       return parameter_blocks.empty() && audio_frames.empty();
@@ -343,7 +351,7 @@ class ObuProcessor {
     static void AddDataToCorrectTemporalUnit(
         TemporalUnitData& current_temporal_unit,
         TemporalUnitData& next_temporal_unit, T&& obu_with_data) {
-      const auto new_timestamp = obu_with_data.start_timestamp;
+      const InternalTimestamp new_timestamp = obu_with_data.start_timestamp;
       if (!current_temporal_unit.timestamp.has_value()) {
         current_temporal_unit.timestamp = new_timestamp;
       }
@@ -377,7 +385,7 @@ class ObuProcessor {
       substream_id_to_audio_element_;
   std::unique_ptr<GlobalTimingModule> global_timing_module_;
   std::optional<ParametersManager> parameters_manager_;
-  ReadBitBuffer* read_bit_buffer_;
+  ReadBitBuffer* /* absl_nonnull */ read_bit_buffer_;
 
   // Contains target layout information for rendering.
   DecodingLayoutInfo decoding_layout_info_;
diff --git a/iamf/cli/obu_sequencer_base.cc b/iamf/cli/obu_sequencer_base.cc
index 038019c..8e4c59c 100644
--- a/iamf/cli/obu_sequencer_base.cc
+++ b/iamf/cli/obu_sequencer_base.cc
@@ -50,6 +50,8 @@ namespace iamf_tools {
 
 namespace {
 
+using absl::MakeConstSpan;
+
 // Write buffer. Let's start with 64 KB. The buffer will resize for larger
 // OBUs if needed.
 constexpr int64_t kBufferStartSize = 65536;
@@ -60,7 +62,7 @@ constexpr int64_t kBufferStartSize = 65536;
  * Using absl::btree_map for convenience as this allows iterating by
  * timestamp (which is the key).
  */
-typedef absl::btree_map<int32_t, TemporalUnitView> TemporalUnitMap;
+typedef absl::btree_map<InternalTimestamp, TemporalUnitView> TemporalUnitMap;
 
 /*!\brief Helper class to abort an `ObuSequencerBase` on destruction.
  *
@@ -257,11 +259,9 @@ absl::Status GenerateTemporalUnitMap(
   return absl::OkStatus();
 }
 
-}  // namespace
-
-absl::Status ObuSequencerBase::WriteTemporalUnit(
-    bool include_temporal_delimiters, const TemporalUnitView& temporal_unit,
-    WriteBitBuffer& wb, int& num_samples) {
+absl::Status WriteTemporalUnit(bool include_temporal_delimiters,
+                               const TemporalUnitView& temporal_unit,
+                               WriteBitBuffer& wb, int& num_samples) {
   num_samples += temporal_unit.num_untrimmed_samples_;
 
   if (include_temporal_delimiters) {
@@ -317,7 +317,7 @@ absl::Status ObuSequencerBase::WriteTemporalUnit(
 // For Arbitrary OBUs, they are inserted in an order implied by the insertion
 // hook. Ties are broken by the original order, when multiple OBUs have the same
 // hook.
-absl::Status ObuSequencerBase::WriteDescriptorObus(
+absl::Status WriteDescriptorObus(
     const IASequenceHeaderObu& ia_sequence_header_obu,
     const absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus,
     const absl::flat_hash_map<uint32_t, AudioElementWithData>& audio_elements,
@@ -378,6 +378,8 @@ absl::Status ObuSequencerBase::WriteDescriptorObus(
   return absl::OkStatus();
 }
 
+}  // namespace
+
 ObuSequencerBase::ObuSequencerBase(
     const LebGenerator& leb_generator, bool include_temporal_delimiters,
     bool delay_descriptors_until_first_untrimmed_sample)
@@ -430,7 +432,7 @@ absl::Status ObuSequencerBase::PushDescriptorObus(
   RETURN_IF_NOT_OK(ArbitraryObu::WriteObusWithHook(
       ArbitraryObu::kInsertionHookBeforeDescriptors, arbitrary_obus, wb_));
   // Write out the descriptor OBUs.
-  RETURN_IF_NOT_OK(ObuSequencerBase::WriteDescriptorObus(
+  RETURN_IF_NOT_OK(WriteDescriptorObus(
       ia_sequence_header_obu, codec_config_obus, audio_elements,
       mix_presentation_obus, arbitrary_obus, wb_));
   RETURN_IF_NOT_OK(ArbitraryObu::WriteObusWithHook(
@@ -481,8 +483,7 @@ absl::Status ObuSequencerBase::PushTemporalUnit(
   wb_.Reset();
 
   // Cache the frame for later
-  const int64_t start_timestamp =
-      static_cast<int64_t>(temporal_unit.start_timestamp_);
+  const InternalTimestamp start_timestamp = temporal_unit.start_timestamp_;
   int num_samples = 0;
   RETURN_IF_NOT_OK(WriteTemporalUnit(include_temporal_delimiters_,
                                      temporal_unit, wb_, num_samples));
@@ -558,39 +559,46 @@ absl::Status ObuSequencerBase::UpdateDescriptorObusAndClose(
   RETURN_IF_NOT_OK(ArbitraryObu::WriteObusWithHook(
       ArbitraryObu::kInsertionHookBeforeDescriptors, arbitrary_obus, wb_));
   // Write out the descriptor OBUs.
-  RETURN_IF_NOT_OK(ObuSequencerBase::WriteDescriptorObus(
+  RETURN_IF_NOT_OK(WriteDescriptorObus(
       ia_sequence_header_obu, codec_config_obus, audio_elements,
       mix_presentation_obus, arbitrary_obus, wb_));
   RETURN_IF_NOT_OK(ArbitraryObu::WriteObusWithHook(
       ArbitraryObu::kInsertionHookAfterDescriptors, arbitrary_obus, wb_));
+  const auto updated_descriptor_obus = MakeConstSpan(wb_.bit_buffer());
+  if (updated_descriptor_obus != descriptor_statistics_->descriptor_obus) {
+    // Descriptors changed. We're a bit loose with what types of metadata we
+    // allow to change. Check at least the "functional" statistics are
+    // equivalent.
+    DescriptorStatistics descriptor_statistics{
+        .descriptor_obus = std::vector<uint8_t>(updated_descriptor_obus.begin(),
+                                                updated_descriptor_obus.end())};
+
+    RETURN_IF_NOT_OK(
+        FillDescriptorStatistics(codec_config_obus, descriptor_statistics));
+    if (descriptor_statistics_->common_samples_per_frame !=
+            descriptor_statistics.common_samples_per_frame ||
+        descriptor_statistics_->common_sample_rate !=
+            descriptor_statistics.common_sample_rate ||
+        descriptor_statistics_->common_bit_depth !=
+            descriptor_statistics.common_bit_depth ||
+        descriptor_statistics_->num_channels !=
+            descriptor_statistics.num_channels) {
+      return absl::FailedPreconditionError(
+          "Descriptor OBUs have changed properties between finalizing and "
+          "closing.");
+    }
+    if (descriptor_statistics_->descriptor_obus.size() !=
+        descriptor_statistics.descriptor_obus.size()) {
+      return absl::UnimplementedError(
+          "Descriptor OBUs have changed size between finalizing and closing.");
+    }
 
-  // We're a bit loose with what types of metadata we allow to change. Check
-  // at least the "functional" statistics are equivalent.
-  DescriptorStatistics descriptor_statistics{.descriptor_obus =
-                                                 wb_.bit_buffer()};
-  RETURN_IF_NOT_OK(
-      FillDescriptorStatistics(codec_config_obus, descriptor_statistics));
-  if (descriptor_statistics_->common_samples_per_frame !=
-          descriptor_statistics.common_samples_per_frame ||
-      descriptor_statistics_->common_sample_rate !=
-          descriptor_statistics.common_sample_rate ||
-      descriptor_statistics_->common_bit_depth !=
-          descriptor_statistics.common_bit_depth ||
-      descriptor_statistics_->num_channels !=
-          descriptor_statistics.num_channels) {
-    return absl::FailedPreconditionError(
-        "Descriptor OBUs have changed size between finalizing and "
-        "closing.");
-  }
-  if (descriptor_statistics_->descriptor_obus.size() !=
-      descriptor_statistics.descriptor_obus.size()) {
-    return absl::UnimplementedError(
-        "Descriptor OBUs have changed size between finalizing and closing.");
+    RETURN_IF_NOT_OK(PushFinalizedDescriptorObus(updated_descriptor_obus));
+    state_ = kPushSerializedDescriptorsCalled;
   }
+  // OK, regardless of whether the descriptors actually changed, obey the
+  // request to close.
 
-  RETURN_IF_NOT_OK(
-      PushFinalizedDescriptorObus(absl::MakeConstSpan(wb_.bit_buffer())));
-  state_ = kPushSerializedDescriptorsCalled;
   RETURN_IF_NOT_OK(Close());
 
   abort_on_destruct.CancelAbort();
diff --git a/iamf/cli/obu_sequencer_base.h b/iamf/cli/obu_sequencer_base.h
index 955f14c..3a1cf1b 100644
--- a/iamf/cli/obu_sequencer_base.h
+++ b/iamf/cli/obu_sequencer_base.h
@@ -30,6 +30,7 @@
 #include "iamf/obu/codec_config.h"
 #include "iamf/obu/ia_sequence_header.h"
 #include "iamf/obu/mix_presentation.h"
+#include "iamf/obu/types.h"
 
 namespace iamf_tools {
 
@@ -66,44 +67,6 @@ namespace iamf_tools {
  */
 class ObuSequencerBase {
  public:
-  /*!\brief Serializes and writes out a temporal unit.
-   *
-   * Write out the OBUs contained within the input arguments to the output write
-   * buffer.
-   *
-   * \param include_temporal_delimiters Whether the serialized data should
-   *        include a temporal delimiter.
-   * \param temporal_unit Temporal unit to write out.
-   * \param wb Write buffer to write to.
-   * \param num_samples Number of samples written out.
-   * \return `absl::OkStatus()` on success. A specific status on failure.
-   */
-  [[deprecated("Use this class as per the class documentation instead.")]]
-  static absl::Status WriteTemporalUnit(bool include_temporal_delimiters,
-                                        const TemporalUnitView& temporal_unit,
-                                        WriteBitBuffer& wb, int& num_samples);
-
-  /*!\brief Writes the input descriptor OBUs.
-   *
-   * Write out the OBUs contained within the input arguments to the output write
-   * buffer.
-   *
-   * \param ia_sequence_header_obu IA Sequence Header OBU to write.
-   * \param codec_config_obus Codec Config OBUs to write.
-   * \param audio_elements Audio Element OBUs with data to write.
-   * \param mix_presentation_obus Mix Presentation OBUs to write.
-   * \param arbitrary_obus Arbitrary OBUs to write.
-   * \param wb Write buffer to write to.
-   * \return `absl::OkStatus()` on success. A specific status on failure.
-   */
-  [[deprecated("Use this class as per the class documentation instead.")]]
-  static absl::Status WriteDescriptorObus(
-      const IASequenceHeaderObu& ia_sequence_header_obu,
-      const absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus,
-      const absl::flat_hash_map<uint32_t, AudioElementWithData>& audio_elements,
-      const std::list<MixPresentationObu>& mix_presentation_obus,
-      const std::list<ArbitraryObu>& arbitrary_obus, WriteBitBuffer& wb);
-
   /*!\brief Constructor.
    *
    * \param leb_generator Leb generator to use when writing OBUs.
@@ -215,8 +178,8 @@ class ObuSequencerBase {
   virtual absl::Status PushSerializedDescriptorObus(
       uint32_t common_samples_per_frame, uint32_t common_sample_rate,
       uint8_t common_bit_depth,
-      std::optional<int64_t> first_untrimmed_timestamp, int num_channels,
-      absl::Span<const uint8_t> descriptor_obus) = 0;
+      std::optional<InternalTimestamp> first_untrimmed_timestamp,
+      int num_channels, absl::Span<const uint8_t> descriptor_obus) = 0;
 
   /*!\brief Pushes a single temporal unit to some output.
    *
@@ -226,7 +189,7 @@ class ObuSequencerBase {
    * \return `absl::OkStatus()` on success. A specific status on failure.
    */
   virtual absl::Status PushSerializedTemporalUnit(
-      int64_t timestamp, int num_samples,
+      InternalTimestamp timestamp, int num_samples,
       absl::Span<const uint8_t> temporal_unit) = 0;
 
   /*!\brief Pushes the finalized descriptor OBUs to some output.
@@ -289,7 +252,7 @@ class ObuSequencerBase {
     uint32_t common_sample_rate = 0;
     uint8_t common_bit_depth = 0;
     int num_channels = 0;
-    std::optional<int64_t> first_untrimmed_timestamp;
+    std::optional<InternalTimestamp> first_untrimmed_timestamp;
     std::vector<uint8_t> descriptor_obus;
   };
   std::optional<DescriptorStatistics> descriptor_statistics_;
@@ -305,7 +268,7 @@ class ObuSequencerBase {
   // sample is seen. In practical IA Sequences, this is rarely more than a few
   // temporal units.
   struct SerializedTemporalUnit {
-    int64_t start_timestamp;
+    InternalTimestamp start_timestamp;
     uint32_t num_untrimmed_samples;
     std::vector<uint8_t> data;
   };
diff --git a/iamf/cli/obu_sequencer_iamf.cc b/iamf/cli/obu_sequencer_iamf.cc
index a55bd2d..1eac2a1 100644
--- a/iamf/cli/obu_sequencer_iamf.cc
+++ b/iamf/cli/obu_sequencer_iamf.cc
@@ -27,6 +27,7 @@
 #include "iamf/common/leb_generator.h"
 #include "iamf/common/utils/macros.h"
 #include "iamf/common/write_bit_buffer.h"
+#include "iamf/obu/types.h"
 
 namespace iamf_tools {
 
@@ -68,8 +69,8 @@ ObuSequencerIamf::ObuSequencerIamf(const std::string& iamf_filename,
 absl::Status ObuSequencerIamf::PushSerializedDescriptorObus(
     uint32_t /*common_samples_per_frame*/, uint32_t /*common_sample_rate*/,
     uint8_t /*common_bit_depth*/,
-    std::optional<int64_t> /*first_untrimmed_timestamp*/, int /*num_channels*/,
-    absl::Span<const uint8_t> descriptor_obus) {
+    std::optional<InternalTimestamp> /*first_untrimmed_timestamp*/,
+    int /*num_channels*/, absl::Span<const uint8_t> descriptor_obus) {
   if (!iamf_filename_.empty()) {
     LOG(INFO) << "Writing descriptor OBUs to " << iamf_filename_;
 
@@ -81,7 +82,7 @@ absl::Status ObuSequencerIamf::PushSerializedDescriptorObus(
 }
 
 absl::Status ObuSequencerIamf::PushSerializedTemporalUnit(
-    int64_t /*timestamp*/, int /*num_samples*/,
+    InternalTimestamp /*timestamp*/, int /*num_samples*/,
     absl::Span<const uint8_t> temporal_unit) {
   RETURN_IF_NOT_OK(wb_.WriteUint8Span(temporal_unit));
   return wb_.FlushAndWriteToFile(output_iamf_);
diff --git a/iamf/cli/obu_sequencer_iamf.h b/iamf/cli/obu_sequencer_iamf.h
index 21a6b9a..4d06f78 100644
--- a/iamf/cli/obu_sequencer_iamf.h
+++ b/iamf/cli/obu_sequencer_iamf.h
@@ -22,6 +22,7 @@
 #include "iamf/cli/obu_sequencer_base.h"
 #include "iamf/common/leb_generator.h"
 #include "iamf/common/write_bit_buffer.h"
+#include "iamf/obu/types.h"
 
 namespace iamf_tools {
 
@@ -58,7 +59,7 @@ class ObuSequencerIamf : public ObuSequencerBase {
   absl::Status PushSerializedDescriptorObus(
       uint32_t /*common_samples_per_frame*/, uint32_t /*common_sample_rate*/,
       uint8_t /*common_bit_depth*/,
-      std::optional<int64_t> /*first_untrimmed_timestamp*/,
+      std::optional<InternalTimestamp> /*first_untrimmed_timestamp*/,
       int /*num_channels*/, absl::Span<const uint8_t> descriptor_obus) override;
 
   /*!\brief Pushes a single temporal unit to some output.
@@ -69,7 +70,7 @@ class ObuSequencerIamf : public ObuSequencerBase {
    * \return `absl::OkStatus()` on success. A specific status on failure.
    */
   absl::Status PushSerializedTemporalUnit(
-      int64_t /*timestamp*/, int /*num_samples*/,
+      InternalTimestamp /*timestamp*/, int /*num_samples*/,
       absl::Span<const uint8_t> temporal_unit) override;
 
   /*!\brief Pushes the finalized descriptor OBUs to the IAMF file.
diff --git a/iamf/cli/obu_sequencer_streaming_iamf.cc b/iamf/cli/obu_sequencer_streaming_iamf.cc
new file mode 100644
index 0000000..38c7497
--- /dev/null
+++ b/iamf/cli/obu_sequencer_streaming_iamf.cc
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+#include "iamf/cli/obu_sequencer_streaming_iamf.h"
+
+#include <algorithm>
+#include <cstdint>
+#include <iterator>
+#include <optional>
+#include <vector>
+
+#include "absl/log/check.h"
+#include "absl/log/log.h"
+#include "absl/status/status.h"
+#include "absl/types/span.h"
+#include "iamf/cli/obu_sequencer_base.h"
+#include "iamf/common/leb_generator.h"
+#include "iamf/obu/types.h"
+
+namespace iamf_tools {
+
+namespace {
+
+// This sequencer does not care about the delay or timing information.
+constexpr bool kDoNotDelayDescriptorsUntilFirstUntrimmedSample = false;
+
+void CopySpanToVector(absl::Span<const uint8_t> span,
+                      std::vector<uint8_t>& vector) {
+  vector.clear();
+  vector.reserve(span.size());
+  std::copy(span.begin(), span.end(), std::back_inserter(vector));
+}
+
+}  // namespace
+
+ObuSequencerStreamingIamf::ObuSequencerStreamingIamf(
+    bool include_temporal_delimiters, const LebGenerator& leb_generator)
+    : ObuSequencerBase(leb_generator, include_temporal_delimiters,
+                       kDoNotDelayDescriptorsUntilFirstUntrimmedSample) {}
+
+absl::Span<const uint8_t>
+ObuSequencerStreamingIamf::GetSerializedDescriptorObus() const {
+  return absl::MakeConstSpan(serialized_descriptor_obus_);
+}
+
+absl::Span<const uint8_t>
+ObuSequencerStreamingIamf::GetPreviousSerializedTemporalUnit() const {
+  return absl::MakeConstSpan(previous_serialized_temporal_unit_);
+}
+
+absl::Status ObuSequencerStreamingIamf::PushSerializedDescriptorObus(
+    uint32_t /*common_samples_per_frame*/, uint32_t /*common_sample_rate*/,
+    uint8_t /*common_bit_depth*/,
+    std::optional<InternalTimestamp> /*first_untrimmed_timestamp*/,
+    int /*num_channels*/, absl::Span<const uint8_t> descriptor_obus) {
+  CopySpanToVector(descriptor_obus, serialized_descriptor_obus_);
+  return absl::OkStatus();
+}
+
+absl::Status ObuSequencerStreamingIamf::PushSerializedTemporalUnit(
+    InternalTimestamp /*timestamp*/, int /*num_samples*/,
+    absl::Span<const uint8_t> temporal_unit) {
+  CopySpanToVector(temporal_unit, previous_serialized_temporal_unit_);
+  return absl::OkStatus();
+}
+
+absl::Status ObuSequencerStreamingIamf::PushFinalizedDescriptorObus(
+    absl::Span<const uint8_t> descriptor_obus) {
+  CopySpanToVector(descriptor_obus, serialized_descriptor_obus_);
+  return absl::OkStatus();
+}
+
+void ObuSequencerStreamingIamf::CloseDerived() {
+  // Leave the descriptor OBUs in place, so the user can retrieve the updated
+  // descriptors if available.
+  previous_serialized_temporal_unit_.clear();
+}
+
+void ObuSequencerStreamingIamf::AbortDerived() {
+  LOG(INFO) << "Aborting ObuSequencerStreamingIamf.";
+  serialized_descriptor_obus_.clear();
+  previous_serialized_temporal_unit_.clear();
+}
+
+}  // namespace iamf_tools
diff --git a/iamf/cli/obu_sequencer_streaming_iamf.h b/iamf/cli/obu_sequencer_streaming_iamf.h
new file mode 100644
index 0000000..01243e7
--- /dev/null
+++ b/iamf/cli/obu_sequencer_streaming_iamf.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+#ifndef CLI_OBU_SEQUENCER_STREAMING_IAMF_H_
+#define CLI_OBU_SEQUENCER_STREAMING_IAMF_H_
+
+#include <cstdint>
+#include <optional>
+#include <vector>
+
+#include "absl/status/status.h"
+#include "absl/types/span.h"
+#include "iamf/cli/obu_sequencer_base.h"
+#include "iamf/common/leb_generator.h"
+#include "iamf/obu/types.h"
+
+namespace iamf_tools {
+
+/*!\brief OBU sequencer for streaming standalone IAMF.
+ *
+ * This class is useful to directly process serialized IAMF in memory. For
+ * example, OBUs may be pushed in one at a time and then collected and sent out
+ * over the network by the user of this class.
+ *
+ * The class usage is similar to the `ObuSequencerBase` class, but the user of
+ * this class should retrieve the serialized OBUs using
+ * `GetSerializedDescriptorObus` and `GetPreviousSerializedTemporalUnit` and do
+ * something with them.
+ */
+class ObuSequencerStreamingIamf : public ObuSequencerBase {
+ public:
+  /*!\brief Constructor.
+   *
+   * \param include_temporal_delimiters Whether the serialized data should
+   *        include a temporal delimiter.
+   * \param leb_generator Leb generator to use when writing OBUs.
+   */
+  ObuSequencerStreamingIamf(bool include_temporal_delimiters,
+                            const LebGenerator& leb_generator);
+
+  ~ObuSequencerStreamingIamf() override = default;
+
+  /*!\brief Returns the serialized descriptor OBUs.
+   *
+   * \return Serialized descriptor OBUs, or an empty span if descriptor OBUs
+   *         are not available
+   */
+  absl::Span<const uint8_t> GetSerializedDescriptorObus() const;
+
+  /*!\brief Returns the previous serialized temporal unit OBUs.
+   *
+   * \return Serialized OBUS from the previous temporal unit, or an empty span
+   *         if a temporal unit is not available.
+   */
+  absl::Span<const uint8_t> GetPreviousSerializedTemporalUnit() const;
+
+ private:
+  /*!\brief Pushes the descriptor OBUs to some output.
+   *
+   * \param common_samples_per_frame Ignored.
+   * \param common_sample_rate Ignored.
+   * \param common_bit_depth Ignored.
+   * \param first_untrimmed_timestamp Ignored.
+   * \param num_channels Ignored..
+   * \param descriptor_obus Serialized descriptor OBUs to write.
+   * \return `absl::OkStatus()` on success. A specific status on failure.
+   */
+  absl::Status PushSerializedDescriptorObus(
+      uint32_t /*common_samples_per_frame*/, uint32_t /*common_sample_rate*/,
+      uint8_t /*common_bit_depth*/,
+      std::optional<InternalTimestamp> /*first_untrimmed_timestamp*/,
+      int /*num_channels*/, absl::Span<const uint8_t> descriptor_obus) override;
+
+  /*!\brief Pushes a single temporal unit to some output.
+   *
+   * \param timestamp Ignored.
+   * \param num_samples Ignored.
+   * \param temporal_unit Temporal unit to push.
+   * \return `absl::OkStatus()` on success. A specific status on failure.
+   */
+  absl::Status PushSerializedTemporalUnit(
+      InternalTimestamp /*timestamp*/, int /*num_samples*/,
+      absl::Span<const uint8_t> temporal_unit) override;
+
+  /*!\brief Pushes the finalized descriptor OBUs to the IAMF file.
+   *
+   * \param descriptor_obus Serialized finalized descriptor OBUs to push.
+   * \return `absl::OkStatus()` on success. A specific status on failure.
+   */
+  absl::Status PushFinalizedDescriptorObus(
+      absl::Span<const uint8_t> descriptor_obus) override;
+
+  /*!\brief Signals that no more data is coming. */
+  void CloseDerived() override;
+
+  /*!\brief Aborts writing the output.
+   *
+   * Cleans up the output file if it exists.
+   */
+  void AbortDerived() override;
+
+  std::vector<uint8_t> serialized_descriptor_obus_;
+  std::vector<uint8_t> previous_serialized_temporal_unit_;
+};
+
+}  // namespace iamf_tools
+
+#endif  // CLI_OBU_SEQUENCER_STREAMING_IAMF_H_
diff --git a/iamf/cli/parameter_block_partitioner.cc b/iamf/cli/parameter_block_partitioner.cc
index a744e61..ce6d822 100644
--- a/iamf/cli/parameter_block_partitioner.cc
+++ b/iamf/cli/parameter_block_partitioner.cc
@@ -192,13 +192,13 @@ absl::Status GetPartitionedSubblocks(
   InternalTimestamp current_time = full_parameter_block.start_timestamp();
 
   // Track that the split subblocks cover the whole partition.
-  int32_t total_covered_duration = 0;
+  InternalTimestamp total_covered_duration = 0;
 
   // Loop through all subblocks in the original Parameter Block.
   const auto num_subblocks = full_parameter_block.num_subblocks();
   for (int i = 0; i < num_subblocks; ++i) {
     // Get the start and end time of this subblock.
-    const int32_t subblock_start_time = current_time;
+    const InternalTimestamp subblock_start_time = current_time;
 
     // The partitioner works directly on the parameter block OBU metadata and
     // assumes all needed information (e.g. subblock duration) is in the
@@ -220,8 +220,9 @@ absl::Status GetPartitionedSubblocks(
     if (!subblock_duration.ok()) {
       return subblock_duration.status();
     }
-    const int32_t subblock_end_time =
-        subblock_start_time + static_cast<int32_t>(*subblock_duration);
+    const InternalTimestamp subblock_end_time =
+        subblock_start_time +
+        static_cast<InternalTimestamp>(*subblock_duration);
     current_time = subblock_end_time;
 
     if (subblock_end_time <= partitioned_start_time ||
@@ -234,12 +235,12 @@ absl::Status GetPartitionedSubblocks(
     // Found an overlapping subblock. Create a new one for the partition that
     // represents the overlapped time.
     iamf_tools_cli_proto::ParameterSubblock partitioned_subblock;
-    const int partitioned_subblock_start =
+    const InternalTimestamp partitioned_subblock_start =
         std::max(partitioned_start_time, subblock_start_time);
-    const int partitioned_subblock_end =
+    const InternalTimestamp partitioned_subblock_end =
         std::min(partitioned_end_time, subblock_end_time);
-    uint32_t partitioned_subblock_duration =
-        partitioned_subblock_end - partitioned_subblock_start;
+    const auto partitioned_subblock_duration = static_cast<uint32_t>(
+        partitioned_subblock_end - partitioned_subblock_start);
     total_covered_duration += partitioned_subblock_duration;
     partitioned_subblock.set_subblock_duration(partitioned_subblock_duration);
 
@@ -353,7 +354,8 @@ absl::Status ParameterBlockPartitioner::FindPartitionDuration(
 
 absl::Status ParameterBlockPartitioner::PartitionParameterBlock(
     const ParameterBlockObuMetadata& full_parameter_block,
-    int32_t partitioned_start_time, int32_t partitioned_end_time,
+    InternalTimestamp partitioned_start_time,
+    InternalTimestamp partitioned_end_time,
     ParameterBlockObuMetadata& partitioned) {
   if (partitioned_start_time >= partitioned_end_time) {
     return absl::InvalidArgumentError(
@@ -392,11 +394,12 @@ absl::Status ParameterBlockPartitioner::PartitionFrameAligned(
     const ParameterBlockObuMetadata& full_parameter_block,
     std::list<ParameterBlockObuMetadata>& partitioned_parameter_blocks) {
   // Partition this parameter block into several blocks with the same duration.
-  const int32_t end_timestamp =
+  const InternalTimestamp end_timestamp =
       full_parameter_block.start_timestamp() + full_parameter_block.duration();
-  for (int32_t t = full_parameter_block.start_timestamp(); t < end_timestamp;
-       t += partition_duration) {
-    LOG(INFO) << "Partitioning parameter blocks at timestamp= " << t;
+  for (InternalTimestamp t = full_parameter_block.start_timestamp();
+       t < end_timestamp; t += partition_duration) {
+    LOG_EVERY_N_SEC(INFO, 10)
+        << "Partitioning parameter blocks at timestamp= " << t;
     ParameterBlockObuMetadata partitioned_parameter_block;
     RETURN_IF_NOT_OK(PartitionParameterBlock(full_parameter_block, t,
                                              t + partition_duration,
diff --git a/iamf/cli/parameter_block_partitioner.h b/iamf/cli/parameter_block_partitioner.h
index 571a5de..7a7e138 100644
--- a/iamf/cli/parameter_block_partitioner.h
+++ b/iamf/cli/parameter_block_partitioner.h
@@ -20,6 +20,7 @@
 #include "iamf/cli/proto/codec_config.pb.h"
 #include "iamf/cli/proto/ia_sequence_header.pb.h"
 #include "iamf/cli/proto/parameter_block.pb.h"
+#include "iamf/obu/types.h"
 
 namespace iamf_tools {
 
@@ -69,7 +70,8 @@ class ParameterBlockPartitioner {
   static absl::Status PartitionParameterBlock(
       const iamf_tools_cli_proto::ParameterBlockObuMetadata&
           full_parameter_block,
-      int32_t partitioned_start_time, int32_t partitioned_end_time,
+      InternalTimestamp partitioned_start_time,
+      InternalTimestamp partitioned_end_time,
       iamf_tools_cli_proto::ParameterBlockObuMetadata&
           partitioned_parameter_block);
 
diff --git a/iamf/cli/parameters_manager.cc b/iamf/cli/parameters_manager.cc
index ee4835e..64746e8 100644
--- a/iamf/cli/parameters_manager.cc
+++ b/iamf/cli/parameters_manager.cc
@@ -310,7 +310,7 @@ absl::Status ParametersManager::UpdateDemixingState(
 }
 
 absl::Status ParametersManager::UpdateReconGainState(
-    DecodedUleb128 audio_element_id, int32_t expected_timestamp) {
+    DecodedUleb128 audio_element_id, InternalTimestamp expected_timestamp) {
   std::optional<ReconGainState*> recon_gain_state = std::nullopt;
 
   // No additional updating needed.
diff --git a/iamf/cli/proto/BUILD b/iamf/cli/proto/BUILD
index 1d1ee1e..4638a7d 100644
--- a/iamf/cli/proto/BUILD
+++ b/iamf/cli/proto/BUILD
@@ -40,6 +40,7 @@ proto_library(
 proto_library(
     name = "encoder_control_metadata_proto",
     srcs = ["encoder_control_metadata.proto"],
+    deps = [":output_audio_format_proto"],
 )
 
 proto_library(
@@ -62,6 +63,11 @@ proto_library(
     srcs = ["obu_header.proto"],
 )
 
+proto_library(
+    name = "output_audio_format_proto",
+    srcs = ["output_audio_format.proto"],
+)
+
 proto_library(
     name = "param_definitions_proto",
     srcs = ["param_definitions.proto"],
@@ -149,6 +155,11 @@ cc_proto_library(
     deps = [":obu_header_proto"],
 )
 
+cc_proto_library(
+    name = "output_audio_format_cc_proto",
+    deps = [":output_audio_format_proto"],
+)
+
 cc_proto_library(
     name = "param_definitions_cc_proto",
     deps = [":param_definitions_proto"],
diff --git a/iamf/cli/proto/arbitrary_obu.proto b/iamf/cli/proto/arbitrary_obu.proto
index 0ffc9d0..bcce9a1 100644
--- a/iamf/cli/proto/arbitrary_obu.proto
+++ b/iamf/cli/proto/arbitrary_obu.proto
@@ -8,12 +8,14 @@
 // source code in the PATENTS file, you can obtain it at
 // www.aomedia.org/license/patent.
 
-syntax = "proto2";
+edition = "2023";
 
 package iamf_tools_cli_proto;
 
 import "iamf/cli/proto/obu_header.proto";
 
+option features.enum_type = CLOSED;
+
 enum ArbitraryObuType {
   OBU_IA_INVALID = 0;
   OBU_IA_CODEC_CONFIG = 1;
@@ -52,7 +54,11 @@ enum ArbitraryObuType {
 
 enum InsertionHook {
   INSERTION_HOOK_INVALID = 0;
+  // Places this before the canonical descriptors. In an MP4 context, this would
+  // be early in the "IACB" box.
   INSERTION_HOOK_BEFORE_DESCRIPTORS = 1;
+  // Places this after the canonical descriptors. In an MP4 context, this would
+  // be late in the "IACB" box.
   INSERTION_HOOK_AFTER_DESCRIPTORS = 2;
   INSERTION_HOOK_AFTER_IA_SEQUENCE_HEADER = 3;
   INSERTION_HOOK_AFTER_CODEC_CONFIGS = 4;
@@ -64,13 +70,15 @@ enum InsertionHook {
 }
 
 message ArbitraryObuMetadata {
-  optional InsertionHook insertion_hook = 1;
-  optional ArbitraryObuType obu_type = 4;
-  optional ObuHeaderMetadata obu_header = 2;
-  optional bytes payload = 3;
+  InsertionHook insertion_hook = 1;
+  ArbitraryObuType obu_type = 4;
+  ObuHeaderMetadata obu_header = 2;
+  bytes payload = 3;
+
   // Used to force the bitstream to be invalid when this OBU is inserted.
-  optional bool invalidates_bitstream = 5;
+  bool invalidates_bitstream = 5;
+
   // Used to control the temporal unit when using the *_AT_TICK insertion hooks.
   // Ignored otherwise.
-  optional int64 insertion_tick = 6;
+  int64 insertion_tick = 6;
 }
diff --git a/iamf/cli/proto/audio_element.proto b/iamf/cli/proto/audio_element.proto
index fde1aa1..9b29fa1 100644
--- a/iamf/cli/proto/audio_element.proto
+++ b/iamf/cli/proto/audio_element.proto
@@ -8,13 +8,15 @@
 // source code in the PATENTS file, you can obtain it at
 // www.aomedia.org/license/patent.
 
-syntax = "proto2";
+edition = "2023";
 
 package iamf_tools_cli_proto;
 
 import "iamf/cli/proto/obu_header.proto";
 import "iamf/cli/proto/param_definitions.proto";
 
+option features.enum_type = CLOSED;
+
 enum AudioElementType {
   AUDIO_ELEMENT_INVALID = 0;
   AUDIO_ELEMENT_CHANNEL_BASED = 1;
@@ -22,13 +24,15 @@ enum AudioElementType {
 }
 
 message ParamDefinitionExtension {
-  optional uint32 param_definition_size = 1;
-  optional bytes param_definition_bytes = 2;
+  uint32 param_definition_size = 1;
+  bytes param_definition_bytes = 2;
 }
 
 message AudioElementParam {
-  optional uint32 deprecated_param_definition_type = 1 [deprecated = true];
-  optional ParamDefinitionType param_definition_type = 5;
+  uint32 deprecated_param_definition_type = 1 [deprecated = true];
+
+  ParamDefinitionType param_definition_type = 5;
+
   oneof param_definition {
     DemixingParamDefinition demixing_param = 2;
     ReconGainParamDefinition recon_gain_param = 3;
@@ -77,22 +81,23 @@ enum ExpandedLoudspeakerLayout {
 }
 
 message ChannelAudioLayerConfig {
-  optional uint32 deprecated_loudspeaker_layout = 1 [deprecated = true];
-  optional LoudspeakerLayout loudspeaker_layout = 10;
-  optional uint32 output_gain_is_present_flag = 2;
-  optional uint32 recon_gain_is_present_flag = 3;
-  optional uint32 reserved_a = 4;
-  optional uint32 substream_count = 5;
-  optional uint32 coupled_substream_count = 6;
-  optional uint32 output_gain_flag = 7;
-  optional uint32 reserved_b = 8;
-  optional int32 output_gain = 9;
-  optional ExpandedLoudspeakerLayout expanded_loudspeaker_layout = 11;
+  uint32 deprecated_loudspeaker_layout = 1 [deprecated = true];
+
+  LoudspeakerLayout loudspeaker_layout = 10;
+  uint32 output_gain_is_present_flag = 2;
+  uint32 recon_gain_is_present_flag = 3;
+  uint32 reserved_a = 4;
+  uint32 substream_count = 5;
+  uint32 coupled_substream_count = 6;
+  uint32 output_gain_flag = 7;
+  uint32 reserved_b = 8;
+  int32 output_gain = 9;
+  ExpandedLoudspeakerLayout expanded_loudspeaker_layout = 11;
 }
 
 message ScalableChannelLayoutConfig {
-  optional uint32 num_layers = 1;
-  optional uint32 reserved = 2;
+  uint32 num_layers = 1;
+  uint32 reserved = 2;
   repeated ChannelAudioLayerConfig channel_audio_layer_configs = 3;
 }
 
@@ -103,20 +108,21 @@ enum AmbisonicsMode {
 }
 
 message AmbisonicsMonoConfig {
-  optional uint32 output_channel_count = 1;
-  optional uint32 substream_count = 2;
-  repeated uint32 channel_mapping = 3 [packed = true];
+  uint32 output_channel_count = 1;
+  uint32 substream_count = 2;
+  repeated uint32 channel_mapping = 3;
 }
 
 message AmbisonicsProjectionConfig {
-  optional uint32 output_channel_count = 1;
-  optional uint32 substream_count = 2;
-  optional uint32 coupled_substream_count = 3;
-  repeated int32 demixing_matrix = 4 [packed = true];
+  uint32 output_channel_count = 1;
+  uint32 substream_count = 2;
+  uint32 coupled_substream_count = 3;
+  repeated int32 demixing_matrix = 4;
 }
 
 message AmbisonicsConfig {
-  optional AmbisonicsMode ambisonics_mode = 1;
+  AmbisonicsMode ambisonics_mode = 1;
+
   oneof ambisonics_config {
     AmbisonicsMonoConfig ambisonics_mono_config = 2;
     AmbisonicsProjectionConfig ambisonics_projection_config = 3;
@@ -124,23 +130,25 @@ message AmbisonicsConfig {
 }
 
 message AudioElementConfigExtension {
-  optional uint32 audio_element_config_size = 1;
-  optional bytes audio_element_config_bytes = 2;
+  uint32 audio_element_config_size = 1;
+  bytes audio_element_config_bytes = 2;
 }
 
 message AudioElementObuMetadata {
-  optional uint32 audio_element_id = 1;
-  optional AudioElementType audio_element_type = 2;
-  optional uint32 reserved = 3;
-  optional uint32 codec_config_id = 4;
-  optional uint32 num_substreams = 5;
-  repeated uint32 audio_substream_ids = 6 [packed = true];
-  optional uint32 num_parameters = 7;
+  uint32 audio_element_id = 1;
+  AudioElementType audio_element_type = 2;
+  uint32 reserved = 3;
+  uint32 codec_config_id = 4;
+  uint32 num_substreams = 5;
+  repeated uint32 audio_substream_ids = 6;
+  uint32 num_parameters = 7;
   repeated AudioElementParam audio_element_params = 8;
+
   oneof config {
     ScalableChannelLayoutConfig scalable_channel_layout_config = 9;
     AmbisonicsConfig ambisonics_config = 10;
     AudioElementConfigExtension audio_element_config_extension = 11;
   }
-  optional ObuHeaderMetadata obu_header = 12;
+
+  ObuHeaderMetadata obu_header = 12;
 }
diff --git a/iamf/cli/proto/audio_frame.proto b/iamf/cli/proto/audio_frame.proto
index 130877e..7a8852b 100644
--- a/iamf/cli/proto/audio_frame.proto
+++ b/iamf/cli/proto/audio_frame.proto
@@ -8,40 +8,54 @@
 // source code in the PATENTS file, you can obtain it at
 // www.aomedia.org/license/patent.
 
-syntax = "proto2";
+edition = "2023";
 
 package iamf_tools_cli_proto;
 
+option features.utf8_validation = NONE;
+
 enum ChannelLabel {
+  option features.enum_type = CLOSED;
+
   CHANNEL_LABEL_INVALID = 0;
+
   reserved 1;  // Reserved for potential "omitted" label.
+
   // Mono channels.
   CHANNEL_LABEL_MONO = 2;
+
   // Stereo or binaural channels.
   CHANNEL_LABEL_L_2 = 3;
   CHANNEL_LABEL_R_2 = 4;
+
   // Centre channel common to several layouts (e.g. 3.1.2, 5.x.y, 7.x.y).
   CHANNEL_LABEL_CENTRE = 6;
+
   // LFE channel common to several layouts (e.g. 3.1.2, 5.1.y, 7.1.y, 9.1.6).
   CHANNEL_LABEL_LFE = 7;
+
   // 3.1.2 surround channels.
   CHANNEL_LABEL_L_3 = 8;
   CHANNEL_LABEL_R_3 = 9;
   CHANNEL_LABEL_LTF_3 = 10;
   CHANNEL_LABEL_RTF_3 = 11;
+
   // 5.x.y surround channels.
   CHANNEL_LABEL_L_5 = 14;
   CHANNEL_LABEL_R_5 = 15;
   CHANNEL_LABEL_LS_5 = 16;
   CHANNEL_LABEL_RS_5 = 17;
+
   // Common channels between 5.1.2 and 7.1.2.
   CHANNEL_LABEL_LTF_2 = 22;
   CHANNEL_LABEL_RTF_2 = 23;
+
   // Common channels between 5.1.4 and 7.1.4.
   CHANNEL_LABEL_LTF_4 = 26;
   CHANNEL_LABEL_RTF_4 = 27;
   CHANNEL_LABEL_LTB_4 = 28;
   CHANNEL_LABEL_RTB_4 = 29;
+
   // 7.x.y surround channels.
   CHANNEL_LABEL_L_7 = 32;
   CHANNEL_LABEL_R_7 = 33;
@@ -49,6 +63,7 @@ enum ChannelLabel {
   CHANNEL_LABEL_RSS_7 = 35;
   CHANNEL_LABEL_LRS_7 = 36;
   CHANNEL_LABEL_RRS_7 = 37;
+
   // 9.1.6 surround channels.
   CHANNEL_LABEL_FLC = 42;
   CHANNEL_LABEL_FC = 43;
@@ -65,8 +80,10 @@ enum ChannelLabel {
   CHANNEL_LABEL_TP_SI_R = 54;
   CHANNEL_LABEL_TP_BL = 55;
   CHANNEL_LABEL_TP_BR = 56;
+
   // Reserved for possible use of demixed labels.
   reserved 5, 12, 13, 18 to 21, 24, 25, 30, 31, 38 to 41;
+
   // Reserved for channel-based labels.
   reserved 57 to 999;
 
@@ -95,6 +112,7 @@ enum ChannelLabel {
   CHANNEL_LABEL_A_22 = 1022;
   CHANNEL_LABEL_A_23 = 1023;
   CHANNEL_LABEL_A_24 = 1024;
+
   reserved 1025 to 1224;  // Reserved for future ambisonics channels.
 
   // Next ID: 57 (channel-based) or 1025 (ambisonics).
@@ -103,16 +121,16 @@ enum ChannelLabel {
 message ChannelMetadata {
   // Used to map the index of the channel in an ADM or WAV file. Ignored when
   // data comes from other sources.
-  optional uint32 channel_id = 1;
+  uint32 channel_id = 1;
 
   // The IAMF-based channel label.
-  optional ChannelLabel channel_label = 2;
+  ChannelLabel channel_label = 2;
 }
 
 message AudioFrameObuMetadata {
   reserved 2, 3;
 
-  optional string wav_filename = 1;
+  string wav_filename = 1;
 
   // Controls whether the number of samples required to pad the final frame are
   // automatically added to the `samples_to_trim_at_end` value.
@@ -132,8 +150,9 @@ message AudioFrameObuMetadata {
   //   - samples_to_trim_at_end: 0
   // These settings will automatically insert the correct padding to create a
   // valid final frame and avoid trimming the original audio content.
-  optional bool samples_to_trim_at_end_includes_padding = 9 [default = true];
-  optional uint32 samples_to_trim_at_end = 4;
+  bool samples_to_trim_at_end_includes_padding = 9 [default = true];
+
+  uint32 samples_to_trim_at_end = 4;
 
   // Controls whether the number of samples required by codec delay for the
   // initial first frames are automatically added to the
@@ -155,19 +174,19 @@ message AudioFrameObuMetadata {
   //   - samples_to_trim_at_start: 0
   // These settings will automatically insert the correct codec delay to create
   // a valid final frame and avoid trimming the original audio content.
-  optional bool samples_to_trim_at_start_includes_codec_delay = 10
-      [default = true];
-  optional uint32 samples_to_trim_at_start = 5;
+  bool samples_to_trim_at_start_includes_codec_delay = 10 [default = true];
+
+  uint32 samples_to_trim_at_start = 5;
 
   // ID of the audio element whose substreams will be provided/mixed
   // from the channels in this WAV file.
-  optional uint32 audio_element_id = 6;
+  uint32 audio_element_id = 6;
 
   // Channels used in this WAV file, in the order as described in [ITU2051-3]
   // for loudspeaker layouts or ACN order for ambisonics. May be fewer than
   // the total number of channels in the WAV file if only a subset is to be
   // used.
-  repeated uint32 channel_ids = 7 [packed = true, deprecated = true];
+  repeated uint32 channel_ids = 7 [deprecated = true];
 
   // Channel Labels, e.g. "L2", "Ls5". For ambisonics, use "A{ACN number}",
   // e.g. "A0", "A13". Must be of the same length as `channel_ids`.
diff --git a/iamf/cli/proto/codec_config.proto b/iamf/cli/proto/codec_config.proto
index 99c923e..7707331 100644
--- a/iamf/cli/proto/codec_config.proto
+++ b/iamf/cli/proto/codec_config.proto
@@ -8,12 +8,14 @@
 // source code in the PATENTS file, you can obtain it at
 // www.aomedia.org/license/patent.
 
-syntax = "proto2";
+edition = "2023";
 
 package iamf_tools_cli_proto;
 
 import "iamf/cli/proto/obu_header.proto";
 
+option features.enum_type = CLOSED;
+
 // Valid proto enums start at index 1, which are different from the
 // corresponding enums in C++, e.g. kLpcmBigEndian = 0.
 enum LpcmFormatFlags {
@@ -23,9 +25,9 @@ enum LpcmFormatFlags {
 }
 
 message LpcmDecoderConfig {
-  optional LpcmFormatFlags sample_format_flags = 1;
-  optional uint32 sample_size = 2;
-  optional uint32 sample_rate = 3;
+  LpcmFormatFlags sample_format_flags = 1;
+  uint32 sample_size = 2;
+  uint32 sample_rate = 3;
 }
 
 enum OpusApplicationFlag {
@@ -37,8 +39,8 @@ enum OpusApplicationFlag {
 
 // Settings to configure `libopus`.
 message OpusEncoderMetadata {
-  optional OpusApplicationFlag application = 2;
-  optional bool use_float_api = 3 [default = true];
+  OpusApplicationFlag application = 2;
+  bool use_float_api = 3 [default = true];
 
   // Fields to control the bitrate.
   //
@@ -48,19 +50,23 @@ message OpusEncoderMetadata {
   //    - One channel: `target_bitrate_per_channel`.
   //    - Two channels: `target_bitrate_per_channel * 2 *
   //  coupling_rate_adjustment`.
-  optional int32 target_bitrate_per_channel = 1;
-  optional float coupling_rate_adjustment = 4 [default = 1.0];
+  int32 target_bitrate_per_channel = 1;
+  float coupling_rate_adjustment = 4 [default = 1.0];
+
   map<uint32, int32> substream_id_to_bitrate_override = 5;
 }
 
 message OpusDecoderConfig {
-  optional uint32 version = 1;
-  optional uint32 output_channel_count = 2 [default = 2];
-  optional uint32 pre_skip = 3;
-  optional uint32 input_sample_rate = 4;
-  optional int32 output_gain = 5 [default = 0];
-  optional uint32 mapping_family = 6 [default = 0];
-  optional OpusEncoderMetadata opus_encoder_metadata = 7;
+  uint32 version = 1;
+  uint32 output_channel_count = 2 [default = 2];
+
+  uint32 pre_skip = 3;
+  uint32 input_sample_rate = 4;
+  int32 output_gain = 5 [default = 0];
+
+  uint32 mapping_family = 6 [default = 0];
+
+  OpusEncoderMetadata opus_encoder_metadata = 7;
 }
 
 enum SampleFrequencyIndex {
@@ -85,39 +91,49 @@ enum SampleFrequencyIndex {
 
 // Settings to configure `fdk_aac`.
 message AacEncoderMetadata {
-  optional int32 bitrate_mode = 1;
-  optional bool enable_afterburner = 2 [default = true];
-  optional int32 signaling_mode = 3 [default = 2];
+  int32 bitrate_mode = 1;
+  bool enable_afterburner = 2 [default = true];
+
+  int32 signaling_mode = 3 [default = 2];
 }
 
 message AacDecoderSpecificInfo {
-  optional uint32 decoder_specific_info_descriptor_tag = 5 [default = 0x05];
-  optional uint32 audio_object_type = 1 [default = 2];
-  optional SampleFrequencyIndex sample_frequency_index = 2;
-  optional uint32 sampling_frequency = 3;
-  optional uint32 channel_configuration = 4 [default = 2];
+  uint32 decoder_specific_info_descriptor_tag = 5 [default = 0x05];
+
+  uint32 audio_object_type = 1 [default = 2];
+
+  SampleFrequencyIndex sample_frequency_index = 2;
+  uint32 sampling_frequency = 3;
+  uint32 channel_configuration = 4 [default = 2];
 
   // Next ID: 6
 }
 
 message AacGaSpecificConfig {
-  optional bool frame_length_flag = 1 [default = false];
-  optional bool depends_on_core_coder = 2 [default = false];
-  optional bool extension_flag = 3 [default = false];
+  bool frame_length_flag = 1 [default = false];
+
+  bool depends_on_core_coder = 2 [default = false];
+
+  bool extension_flag = 3 [default = false];
 }
 
 message AacDecoderConfig {
-  optional uint32 decoder_config_descriptor_tag = 11 [default = 0x04];
-  optional uint32 object_type_indication = 1 [default = 0x40];
-  optional uint32 stream_type = 2 [default = 5];
-  optional bool upstream = 3 [default = false];
-  optional bool reserved = 4 [default = true];  // As per ISO 14496-1:2010.
-  optional uint32 buffer_size_db = 5;
-  optional uint32 max_bitrate = 6;
-  optional uint32 average_bit_rate = 7;
-  optional AacDecoderSpecificInfo decoder_specific_info = 8;
-  optional AacGaSpecificConfig ga_specific_config = 9;
-  optional AacEncoderMetadata aac_encoder_metadata = 10;
+  uint32 decoder_config_descriptor_tag = 11 [default = 0x04];
+
+  uint32 object_type_indication = 1 [default = 0x40];
+
+  uint32 stream_type = 2 [default = 5];
+
+  bool upstream = 3 [default = false];
+
+  bool reserved = 4 [default = true];  // As per ISO 14496-1:2010.
+
+  uint32 buffer_size_db = 5;
+  uint32 max_bitrate = 6;
+  uint32 average_bit_rate = 7;
+  AacDecoderSpecificInfo decoder_specific_info = 8;
+  AacGaSpecificConfig ga_specific_config = 9;
+  AacEncoderMetadata aac_encoder_metadata = 10;
 }
 
 enum FlacBlockType {
@@ -132,32 +148,36 @@ enum FlacBlockType {
 }
 
 message FlacMetaBlockHeader {
-  optional bool last_metadata_block_flag = 1;
-  optional FlacBlockType block_type = 2;
-  optional uint32 metadata_data_block_length = 3;
+  bool last_metadata_block_flag = 1;
+  FlacBlockType block_type = 2;
+  uint32 metadata_data_block_length = 3;
 }
 
 message FlacMetaBlockStreamInfo {
-  optional uint32 minimum_block_size = 1;
-  optional uint32 maximum_block_size = 2;
-  optional uint32 minimum_frame_size = 3 [default = 0];
-  optional uint32 maximum_frame_size = 4 [default = 0];
-  optional uint32 sample_rate = 5;
-  optional uint32 number_of_channels = 6 [default = 1];
-  optional uint32 bits_per_sample = 7;
-  optional uint64 total_samples_in_stream = 8;
-  optional bytes md5_signature = 9
+  uint32 minimum_block_size = 1;
+  uint32 maximum_block_size = 2;
+  uint32 minimum_frame_size = 3 [default = 0];
+
+  uint32 maximum_frame_size = 4 [default = 0];
+
+  uint32 sample_rate = 5;
+  uint32 number_of_channels = 6 [default = 1];
+
+  uint32 bits_per_sample = 7;
+  uint64 total_samples_in_stream = 8;
+  bytes md5_signature = 9
       [default =
-           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"];
+           "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"];
 }
 
 // Settings to configure `libflac`.
 message FlacEncoderMetadata {
-  optional uint32 compression_level = 1;
+  uint32 compression_level = 1;
 }
 
 message FlacMetaBlock {
-  optional FlacMetaBlockHeader header = 1;
+  FlacMetaBlockHeader header = 1;
+
   oneof data {
     FlacMetaBlockStreamInfo stream_info = 2;
     bytes generic_block = 3;
@@ -168,7 +188,7 @@ message FlacDecoderConfig {
   reserved 1, 2;
 
   repeated FlacMetaBlock metadata_blocks = 3;
-  optional FlacEncoderMetadata flac_encoder_metadata = 4;
+  FlacEncoderMetadata flac_encoder_metadata = 4;
 }
 
 enum CodecId {
@@ -182,10 +202,12 @@ enum CodecId {
 message CodecConfig {
   reserved 3, 4;
 
-  optional uint32 deprecated_codec_id = 1 [deprecated = true];
-  optional CodecId codec_id = 10;
-  optional uint32 num_samples_per_frame = 2;
-  optional int32 audio_roll_distance = 9;
+  uint32 deprecated_codec_id = 1 [deprecated = true];
+
+  CodecId codec_id = 10;
+  uint32 num_samples_per_frame = 2;
+  int32 audio_roll_distance = 9;
+
   oneof decoder_config {
     LpcmDecoderConfig decoder_config_lpcm = 5;
     OpusDecoderConfig decoder_config_opus = 6;
@@ -197,17 +219,17 @@ message CodecConfig {
   // determined. For example, the OpusDecoderConfig.pre_skip field will be
   // ignored and set to the number of samples reported by the underlying encoder
   // library.
-  optional bool automatically_override_codec_delay = 11 [default = true];
+  bool automatically_override_codec_delay = 11 [default = true];
 
   // If true, the `audio_roll_distance` will be ignored and automatically be set
   // to the correct value.
-  optional bool automatically_override_audio_roll_distance = 12
-      [default = true];
+  bool automatically_override_audio_roll_distance = 12 [default = true];
+
   // Next ID: 13
 }
 
 message CodecConfigObuMetadata {
-  optional uint32 codec_config_id = 1;
-  optional CodecConfig codec_config = 2;
-  optional ObuHeaderMetadata obu_header = 3;
+  uint32 codec_config_id = 1;
+  CodecConfig codec_config = 2;
+  ObuHeaderMetadata obu_header = 3;
 }
diff --git a/iamf/cli/proto/encoder_control_metadata.proto b/iamf/cli/proto/encoder_control_metadata.proto
index 50169d8..4e6e94c 100644
--- a/iamf/cli/proto/encoder_control_metadata.proto
+++ b/iamf/cli/proto/encoder_control_metadata.proto
@@ -8,15 +8,24 @@
 // source code in the PATENTS file, you can obtain it at
 // www.aomedia.org/license/patent.
 
-syntax = "proto2";
+edition = "2023";
 
 package iamf_tools_cli_proto;
 
+import "iamf/cli/proto/output_audio_format.proto";
+
 // Controls for the encoder behavior.
 message EncoderControlMetadata {
   // If true [default]: Each Mix Presentation OBU will get an extra
   //                    `MixPresentationTag` with metadata describing the build
   //                    information.
   //  If false: The encoder omit adding an extra build information tag.
-  optional bool add_build_information_tag = 1 [default = true];
+  bool add_build_information_tag = 1 [default = true];
+
+  // Controls the output audio format for any rendered files. The encoder may
+  // produce rendered files as a side effect of the encoding process. The files
+  // are useful for debugging and as an approximation of what a decoder would
+  // generate when playing back the IAMF file.
+  OutputAudioFormat output_rendered_file_format = 2
+      [default = OUTPUT_FORMAT_NONE];
 }
diff --git a/iamf/cli/proto/ia_sequence_header.proto b/iamf/cli/proto/ia_sequence_header.proto
index 2f5d869..b3cba90 100644
--- a/iamf/cli/proto/ia_sequence_header.proto
+++ b/iamf/cli/proto/ia_sequence_header.proto
@@ -8,13 +8,15 @@
 // source code in the PATENTS file, you can obtain it at
 // www.aomedia.org/license/patent.
 
-syntax = "proto2";
+edition = "2023";
 
 package iamf_tools_cli_proto;
 
 import "iamf/cli/proto/obu_header.proto";
 
 enum ProfileVersion {
+  option features.enum_type = CLOSED;
+
   PROFILE_VERSION_INVALID = 0;
   PROFILE_VERSION_SIMPLE = 1;
   PROFILE_VERSION_BASE = 2;
@@ -23,8 +25,11 @@ enum ProfileVersion {
 }
 
 message IASequenceHeaderObuMetadata {
-  optional uint32 ia_code = 1 [default = 0x69616d66 /* "iamf" */];
-  optional ProfileVersion primary_profile = 2;
-  optional ProfileVersion additional_profile = 3;
-  optional ObuHeaderMetadata obu_header = 4;
+  uint32 ia_code = 1 [
+    default = 0x69616d66 /* "iamf" */
+  ];
+
+  ProfileVersion primary_profile = 2;
+  ProfileVersion additional_profile = 3;
+  ObuHeaderMetadata obu_header = 4;
 }
diff --git a/iamf/cli/proto/mix_presentation.proto b/iamf/cli/proto/mix_presentation.proto
index a10815f..65f63a8 100644
--- a/iamf/cli/proto/mix_presentation.proto
+++ b/iamf/cli/proto/mix_presentation.proto
@@ -8,29 +8,32 @@
 // source code in the PATENTS file, you can obtain it at
 // www.aomedia.org/license/patent.
 
-syntax = "proto2";
+edition = "2023";
 
 package iamf_tools_cli_proto;
 
 import "iamf/cli/proto/obu_header.proto";
 import "iamf/cli/proto/param_definitions.proto";
 
+option features.enum_type = CLOSED;
+option features.utf8_validation = NONE;
+
 message MixPresentationAnnotations {
   option deprecated = true;
 
-  optional string mix_presentation_friendly_label = 1;
+  string mix_presentation_friendly_label = 1;
 }
 
 message MixPresentationElementAnnotations {
   option deprecated = true;
 
-  optional string audio_element_friendly_label = 1;
+  string audio_element_friendly_label = 1;
 }
 
 message ElementMixConfig {
   option deprecated = true;
 
-  optional MixGainParamDefinition mix_gain = 1;
+  MixGainParamDefinition mix_gain = 1;
 }
 
 enum HeadPhonesRenderingMode {
@@ -42,32 +45,35 @@ enum HeadPhonesRenderingMode {
 }
 
 message RenderingConfig {
-  optional HeadPhonesRenderingMode headphones_rendering_mode = 1;
-  optional uint32 reserved = 2;
-  optional uint32 rendering_config_extension_size = 3;
-  optional bytes rendering_config_extension_bytes = 4;
+  HeadPhonesRenderingMode headphones_rendering_mode = 1;
+  uint32 reserved = 2;
+  uint32 rendering_config_extension_size = 3;
+  bytes rendering_config_extension_bytes = 4;
 }
 
 message SubMixAudioElement {
   reserved 2;
 
-  optional uint32 audio_element_id = 1;
+  uint32 audio_element_id = 1;
+
   // Superseded by `localized_element_annotations`.
   repeated MixPresentationElementAnnotations
       mix_presentation_element_annotations_array = 4 [deprecated = true];
+
   // Length should be equal to `count_label` in the OBU.
   repeated string localized_element_annotations = 6;
+  RenderingConfig rendering_config = 5;
 
-  optional RenderingConfig rendering_config = 5;
   // Superseded by `element_mix_gain`.
-  optional ElementMixConfig element_mix_config = 3 [deprecated = true];
-  optional MixGainParamDefinition element_mix_gain = 7;
+  ElementMixConfig element_mix_config = 3 [deprecated = true];
+
+  MixGainParamDefinition element_mix_gain = 7;
 }
 
 message OutputMixConfig {
   option deprecated = true;
 
-  optional MixGainParamDefinition output_mix_gain = 1;
+  MixGainParamDefinition output_mix_gain = 1;
 }
 
 enum SoundSystem {
@@ -89,12 +95,12 @@ enum SoundSystem {
 }
 
 message LoudspeakersSsConventionLayout {
-  optional SoundSystem sound_system = 1;
-  optional uint32 reserved = 2;
+  SoundSystem sound_system = 1;
+  uint32 reserved = 2;
 }
 
 message LoudspeakersReservedOrBinauralLayout {
-  optional uint32 reserved = 1;
+  uint32 reserved = 1;
 }
 
 enum LayoutType {
@@ -108,7 +114,8 @@ enum LayoutType {
 message Layout {
   reserved 2;
 
-  optional LayoutType layout_type = 1;
+  LayoutType layout_type = 1;
+
   oneof specific_layout {
     LoudspeakersSsConventionLayout ss_layout = 3;
     LoudspeakersReservedOrBinauralLayout reserved_or_binaural_layout = 4;
@@ -130,14 +137,15 @@ enum AnchorType {
 //
 // See detailed examples on Q7.8 format below in `LoudnessInfo`.
 message AnchorElement {
-  optional AnchorType anchor_element = 1;
-  optional int32 anchored_loudness = 2;  // Q7.8.
+  AnchorType anchor_element = 1;
+  int32 anchored_loudness = 2;  // Q7.8.
 }
 
 message AnchoredLoudness {
   // `num_anchored_loudness` is ignored. The value in the bitstream is inferred
   // based on the number of `anchor_elements`.
-  optional uint32 num_anchored_loudness = 1 [deprecated = true];
+  uint32 num_anchored_loudness = 1 [deprecated = true];
+
   repeated AnchorElement anchor_elements = 2;
 }
 
@@ -163,73 +171,81 @@ enum LoudnessInfoTypeBitMask {
 //  - For -3 dB, set the proto value to 256 * -3 = -768.
 //  - For +6 dB, set the proto value to 256 * 6 = 1536.
 message LoudnessInfo {
-  optional uint32 deprecated_info_type = 1 [deprecated = true];
-  repeated LoudnessInfoTypeBitMask info_type_bit_masks = 8 [packed = true];
-  optional int32 integrated_loudness = 2;  // Q7.8.
-  optional int32 digital_peak = 3;         // Q7.8.
-  optional int32 true_peak = 4;            // Q7.8.
-  optional AnchoredLoudness anchored_loudness = 5;
-  optional uint32 info_type_size = 6;
-  optional bytes info_type_bytes = 7;
+  uint32 deprecated_info_type = 1 [deprecated = true];
+
+  repeated LoudnessInfoTypeBitMask info_type_bit_masks = 8;
+  int32 integrated_loudness = 2;  // Q7.8.
+  int32 digital_peak = 3;         // Q7.8.
+  int32 true_peak = 4;            // Q7.8.
+  AnchoredLoudness anchored_loudness = 5;
+  uint32 info_type_size = 6;
+  bytes info_type_bytes = 7;
 
   // Next ID: 9
 }
 
 message MixPresentationLayout {
-  optional Layout loudness_layout = 1;
-  optional LoudnessInfo loudness = 2;
+  Layout loudness_layout = 1;
+  LoudnessInfo loudness = 2;
 }
 
 message MixPresentationSubMix {
   // `num_audio_elements` is ignored. The value in the bitstream is inferred
   // based on the number of `audio_elements`.
-  optional uint32 num_audio_elements = 1 [deprecated = true];
+  uint32 num_audio_elements = 1 [deprecated = true];
+
   repeated SubMixAudioElement audio_elements = 2;
 
   // Superseded by `output_mix_gain`.
-  optional OutputMixConfig output_mix_config = 3 [deprecated = true];
-  optional MixGainParamDefinition output_mix_gain = 6;
+  OutputMixConfig output_mix_config = 3 [deprecated = true];
+
+  MixGainParamDefinition output_mix_gain = 6;
 
   // `num_layouts` is ignored. The value in the bitstream is inferred
   // based on the number of `layouts`.
-  optional uint32 num_layouts = 4 [deprecated = true];
+  uint32 num_layouts = 4 [deprecated = true];
+
   repeated MixPresentationLayout layouts = 5;
 
   // Next ID: 7
 }
 
 message MixPresentationTag {
-  optional string tag_name = 1;
-  optional string tag_value = 2;
+  string tag_name = 1;
+  string tag_value = 2;
 }
 
 message MixPresentationTags {
   // `num_tags` is ignored. The value in the bitstream is inferred based on the
   // number of tags.
-  optional uint32 num_tags = 1 [deprecated = true];
+  uint32 num_tags = 1 [deprecated = true];
+
   repeated MixPresentationTag tags = 2;
 }
 
 message MixPresentationObuMetadata {
   reserved 2;
 
-  optional uint32 mix_presentation_id = 1;
-  optional uint32 count_label = 5;
+  uint32 mix_presentation_id = 1;
+  uint32 count_label = 5;
 
   // Superseded by `annotations_language`.
   repeated string language_labels = 6 [deprecated = true];
+
   // Length should be equal to `count_label`.
   repeated string annotations_language = 9;
 
   // Superseded by `localized_presentation_annotations`.
   repeated MixPresentationAnnotations mix_presentation_annotations_array = 7
       [deprecated = true];
+
   // Length should be equal to `count_label`.
   repeated string localized_presentation_annotations = 10;
 
   // `num_sub_mixes` is ignored. The value in the bitstream is inferred
   // based on the number of `sub_mixes`.
-  optional uint32 num_sub_mixes = 3 [deprecated = true];
+  uint32 num_sub_mixes = 3 [deprecated = true];
+
   repeated MixPresentationSubMix sub_mixes = 4;
 
   // When false [default]: The encoder will ignore the below
@@ -240,10 +256,9 @@ message MixPresentationObuMetadata {
   //                      `EncoderControlMetadata.add_build_information_tag`
   //                      fields to false.
   // When true: The encoder will use the `mix_presentation_tags` field.
-  optional bool include_mix_presentation_tags = 11;
-  optional MixPresentationTags mix_presentation_tags = 12;
-
-  optional ObuHeaderMetadata obu_header = 8;
+  bool include_mix_presentation_tags = 11;
+  MixPresentationTags mix_presentation_tags = 12;
+  ObuHeaderMetadata obu_header = 8;
 
   // Next ID: 13
 }
diff --git a/iamf/cli/proto/obu_header.proto b/iamf/cli/proto/obu_header.proto
index aa6db6f..c0af9f7 100644
--- a/iamf/cli/proto/obu_header.proto
+++ b/iamf/cli/proto/obu_header.proto
@@ -8,18 +8,24 @@
 // source code in the PATENTS file, you can obtain it at
 // www.aomedia.org/license/patent.
 
-syntax = "proto2";
+edition = "2023";
 
 package iamf_tools_cli_proto;
 
 message ObuHeaderMetadata {
   reserved 1, 5;
 
-  optional bool obu_redundant_copy = 2 [default = false];
-  optional bool obu_trimming_status_flag = 3 [default = false];
-  optional bool obu_extension_flag = 4 [default = false];
-  optional uint32 num_samples_to_trim_at_end = 6 [default = 0];
-  optional uint32 num_samples_to_trim_at_start = 7 [default = 0];
-  optional uint32 extension_header_size = 8 [default = 0];
-  optional bytes extension_header_bytes = 9 [default = ""];
+  bool obu_redundant_copy = 2 [default = false];
+
+  bool obu_trimming_status_flag = 3 [default = false];
+
+  bool obu_extension_flag = 4 [default = false];
+
+  uint32 num_samples_to_trim_at_end = 6 [default = 0];
+
+  uint32 num_samples_to_trim_at_start = 7 [default = 0];
+
+  uint32 extension_header_size = 8 [default = 0];
+
+  bytes extension_header_bytes = 9 [default = ""];
 }
diff --git a/iamf/cli/proto/output_audio_format.proto b/iamf/cli/proto/output_audio_format.proto
new file mode 100644
index 0000000..edba51f
--- /dev/null
+++ b/iamf/cli/proto/output_audio_format.proto
@@ -0,0 +1,31 @@
+// Copyright (c) 2025, Alliance for Open Media. All rights reserved
+//
+// This source code is subject to the terms of the BSD 3-Clause Clear License
+// and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+// License was not distributed with this source code in the LICENSE file, you
+// can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+// Alliance for Open Media Patent License 1.0 was not distributed with this
+// source code in the PATENTS file, you can obtain it at
+// www.aomedia.org/license/patent.
+
+edition = "2023";
+
+package iamf_tools_cli_proto;
+
+enum OutputAudioFormat {
+  option features.enum_type = CLOSED;
+
+  OUTPUT_FORMAT_INVALID = 0;
+
+  // Omit output files.
+  OUTPUT_FORMAT_NONE = 1;
+
+  // Wav file output. Bit depth is automatically determined based on the
+  // underlying codec.
+  OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC = 2;
+
+  // Wav file output, with explicit bit depths.
+  OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN = 3;
+  OUTPUT_FORMAT_WAV_BIT_DEPTH_TWENTY_FOUR = 4;
+  OUTPUT_FORMAT_WAV_BIT_DEPTH_THIRTY_TWO = 5;
+}
diff --git a/iamf/cli/proto/param_definitions.proto b/iamf/cli/proto/param_definitions.proto
index ccc6ce2..afb43da 100644
--- a/iamf/cli/proto/param_definitions.proto
+++ b/iamf/cli/proto/param_definitions.proto
@@ -8,7 +8,7 @@
 // source code in the PATENTS file, you can obtain it at
 // www.aomedia.org/license/patent.
 
-syntax = "proto2";
+edition = "2023";
 
 package iamf_tools_cli_proto;
 
@@ -17,6 +17,8 @@ import "iamf/cli/proto/parameter_data.proto";
 // Valid proto enums start at index 1, which are different from the
 // corresponding enums in C++, e.g. kParameterDefinitionMixGain = 0.
 enum ParamDefinitionType {
+  option features.enum_type = CLOSED;
+
   PARAM_DEFINITION_TYPE_INVALID = 0;
   PARAM_DEFINITION_TYPE_MIX_GAIN = 1;
   PARAM_DEFINITION_TYPE_DEMIXING = 2;
@@ -25,14 +27,14 @@ enum ParamDefinitionType {
 }
 
 message ParamDefinition {
-  optional uint32 parameter_id = 1;
-  optional uint32 parameter_rate = 2;
-  optional bool param_definition_mode = 3;
-  optional uint32 reserved = 4;
-  optional uint32 duration = 5;
-  optional uint32 constant_subblock_duration = 7;
-  optional uint32 num_subblocks = 6;
-  repeated uint32 subblock_durations = 8 [packed = true];
+  uint32 parameter_id = 1;
+  uint32 parameter_rate = 2;
+  bool param_definition_mode = 3;
+  uint32 reserved = 4;
+  uint32 duration = 5;
+  uint32 constant_subblock_duration = 7;
+  uint32 num_subblocks = 6;
+  repeated uint32 subblock_durations = 8;
 }
 
 // Values are represented to align with the IAMF spec.
@@ -45,17 +47,17 @@ message ParamDefinition {
 //  - For -3 dB, set the proto value to 256 * -3 = -768.
 //  - For +6 dB, set the proto value to 256 * 6 = 1536.
 message MixGainParamDefinition {
-  optional ParamDefinition param_definition = 1;
-  optional int32 default_mix_gain = 2;  // Q7.8.
+  ParamDefinition param_definition = 1;
+  int32 default_mix_gain = 2;  // Q7.8.
 }
 
 message DemixingParamDefinition {
-  optional ParamDefinition param_definition = 1;
-  optional DemixingInfoParameterData default_demixing_info_parameter_data = 2;
-  optional uint32 default_w = 3;
-  optional uint32 reserved = 4;
+  ParamDefinition param_definition = 1;
+  DemixingInfoParameterData default_demixing_info_parameter_data = 2;
+  uint32 default_w = 3;
+  uint32 reserved = 4;
 }
 
 message ReconGainParamDefinition {
-  optional ParamDefinition param_definition = 1;
+  ParamDefinition param_definition = 1;
 }
diff --git a/iamf/cli/proto/parameter_block.proto b/iamf/cli/proto/parameter_block.proto
index 5f04c32..3629821 100644
--- a/iamf/cli/proto/parameter_block.proto
+++ b/iamf/cli/proto/parameter_block.proto
@@ -8,7 +8,7 @@
 // source code in the PATENTS file, you can obtain it at
 // www.aomedia.org/license/patent.
 
-syntax = "proto2";
+edition = "2023";
 
 package iamf_tools_cli_proto;
 
@@ -16,12 +16,13 @@ import "iamf/cli/proto/obu_header.proto";
 import "iamf/cli/proto/parameter_data.proto";
 
 message ParameterDataExtension {
-  optional uint32 parameter_data_size = 1;
-  optional bytes parameter_data_bytes = 2;
+  uint32 parameter_data_size = 1;
+  bytes parameter_data_bytes = 2;
 }
 
 message ParameterSubblock {
-  optional uint32 subblock_duration = 1;
+  uint32 subblock_duration = 1;
+
   oneof parameter_data {
     MixGainParameterData mix_gain_parameter_data = 2;
     DemixingInfoParameterData demixing_info_parameter_data = 3;
@@ -31,13 +32,11 @@ message ParameterSubblock {
 }
 
 message ParameterBlockObuMetadata {
-  optional uint32 parameter_id = 1;
-  optional uint32 duration = 2;
-  optional uint32 num_subblocks = 3;
-  optional uint32 constant_subblock_duration = 4;
+  uint32 parameter_id = 1;
+  uint32 duration = 2;
+  uint32 num_subblocks = 3;
+  uint32 constant_subblock_duration = 4;
   repeated ParameterSubblock subblocks = 5;
-  // TODO(b/395159650): Bump up to hold an `int64_t` in order to support very
-  //                    long durations.
-  optional int32 start_timestamp = 6;
-  optional ObuHeaderMetadata obu_header = 7;
+  int64 start_timestamp = 6;
+  ObuHeaderMetadata obu_header = 7;
 }
diff --git a/iamf/cli/proto/parameter_data.proto b/iamf/cli/proto/parameter_data.proto
index fe5a065..9e39e24 100644
--- a/iamf/cli/proto/parameter_data.proto
+++ b/iamf/cli/proto/parameter_data.proto
@@ -8,10 +8,12 @@
 // source code in the PATENTS file, you can obtain it at
 // www.aomedia.org/license/patent.
 
-syntax = "proto2";
+edition = "2023";
 
 package iamf_tools_cli_proto;
 
+option features.enum_type = CLOSED;
+
 enum AnimationType {
   ANIMATE_INVALID = 0;
   ANIMATE_STEP = 1;
@@ -26,7 +28,7 @@ enum AnimationType {
 //
 // See detailed examples on Q7.8 format below in `AnimationLinearInt16`.
 message AnimationStepInt16 {
-  optional int32 start_point_value = 1;  // Q7.8.
+  int32 start_point_value = 1;  // Q7.8.
 }
 
 // Values are represented to align with the IAMF spec.
@@ -36,8 +38,8 @@ message AnimationStepInt16 {
 //
 // See detailed examples on Q7.8 format below in `AnimationLinearInt16`.
 message AnimationLinearInt16 {
-  optional int32 start_point_value = 1;  // Q7.8.
-  optional int32 end_point_value = 2;    // Q7.8.
+  int32 start_point_value = 1;  // Q7.8.
+  int32 end_point_value = 2;    // Q7.8.
 }
 
 // Values are represented to align with the IAMF spec.
@@ -56,10 +58,10 @@ message AnimationLinearInt16 {
 //  - For a control point relative time of 1.0, set the proto value to
 //    clamp(1.0 * 256, 0, 255) = 255.
 message AnimationBezierInt16 {
-  optional int32 start_point_value = 1;             // Q7.8.
-  optional int32 end_point_value = 2;               // Q7.8.
-  optional int32 control_point_value = 3;           // Q7.8.
-  optional uint32 control_point_relative_time = 4;  // Q0.8.
+  int32 start_point_value = 1;             // Q7.8.
+  int32 end_point_value = 2;               // Q7.8.
+  int32 control_point_value = 3;           // Q7.8.
+  uint32 control_point_relative_time = 4;  // Q0.8.
 }
 
 message AnimatedParameterDataInt16 {
@@ -71,12 +73,13 @@ message AnimatedParameterDataInt16 {
 }
 
 message MixGainParameterData {
-  optional AnimationType animation_type = 1;
-  optional AnimatedParameterDataInt16 param_data = 2;
+  AnimationType animation_type = 1;
+  AnimatedParameterDataInt16 param_data = 2;
 }
 
 enum DMixPMode {
   DMIXP_MODE_INVALID = 0;
+
   //                       (alpha, beta,  gamma, delta, w_idx_offset)
   DMIXP_MODE_1 = 1;  //    (    1,     1, 0.707, 0.707,           -1)
   DMIXP_MODE_2 = 2;  //    (0.707, 0.707, 0.707, 0.707,           -1)
@@ -89,8 +92,8 @@ enum DMixPMode {
 }
 
 message DemixingInfoParameterData {
-  optional DMixPMode dmixp_mode = 1;
-  optional uint32 reserved = 2;
+  DMixPMode dmixp_mode = 1;
+  uint32 reserved = 2;
 }
 
 message ReconGains {
diff --git a/iamf/cli/proto/temporal_delimiter.proto b/iamf/cli/proto/temporal_delimiter.proto
index 027d899..b78c151 100644
--- a/iamf/cli/proto/temporal_delimiter.proto
+++ b/iamf/cli/proto/temporal_delimiter.proto
@@ -8,10 +8,10 @@
 // source code in the PATENTS file, you can obtain it at
 // www.aomedia.org/license/patent.
 
-syntax = "proto2";
+edition = "2023";
 
 package iamf_tools_cli_proto;
 
 message TemporalDelimiterObuMetadata {
-  optional bool enable_temporal_delimiters = 1;
+  bool enable_temporal_delimiters = 1;
 }
diff --git a/iamf/cli/proto/test_vector_metadata.proto b/iamf/cli/proto/test_vector_metadata.proto
index 4c9b3a1..ac4e908 100644
--- a/iamf/cli/proto/test_vector_metadata.proto
+++ b/iamf/cli/proto/test_vector_metadata.proto
@@ -8,23 +8,30 @@
 // source code in the PATENTS file, you can obtain it at
 // www.aomedia.org/license/patent.
 
-syntax = "proto2";
+edition = "2023";
 
 package iamf_tools_cli_proto;
 
+option features.utf8_validation = NONE;
+
 enum Leb128GeneratorMode {
+  option features.enum_type = CLOSED;
+
   GENERATE_LEB_INVALID = 0;
+
   // Generate values using the minimum number of bytes.
   GENERATE_LEB_MINIMUM = 1;
+
   // Generate values using the target of bytes.
   GENERATE_LEB_FIXED_SIZE = 2;
 }
 
 message Leb128Generator {
-  optional Leb128GeneratorMode mode = 1 [default = GENERATE_LEB_MINIMUM];
+  Leb128GeneratorMode mode = 1 [default = GENERATE_LEB_MINIMUM];
+
   // Configures the target number of bytes when using `GENERATE_LEB_FIXED_SIZE`
   // mode.
-  optional int32 fixed_size = 2 [default = 5];
+  int32 fixed_size = 2 [default = 5];
 }
 
 // Metadata to describe and annotate test vectors. For historical reasons, some
@@ -32,19 +39,21 @@ message Leb128Generator {
 message TestVectorMetadata {
   reserved 5;
 
-  optional string human_readable_description = 1;
+  string human_readable_description = 1;
+
   // Prefix of the output file names. Leave empty to skip writing to output
   // files.
-  optional string file_name_prefix = 2;
+  string file_name_prefix = 2;
 
   // TODO(b/269708630): Rename `is_valid` to `is_valid_to_encode`.
   // `true` when all mixes are valid to encode. Mixes may be invalid if they
   // contain any mixes that use certain reserved values, or if they exercise any
   // features which are not supported by the encoder.
-  optional bool is_valid = 3;
+  bool is_valid = 3;
+
   // `true` when a compliant decoder would decode at least one valid mix. Some
   // other mixes may be invalid or use reserved values which may be ignored.
-  optional bool is_valid_to_decode = 14 [default = true];
+  bool is_valid_to_decode = 14 [default = true];
 
   // Tags to identify the repository this test vector belongs to. A repository
   // could be a git branch or it could refer to some other way to organize a
@@ -59,44 +68,40 @@ message TestVectorMetadata {
   //     branch of https://github.com/AOMediaCodec/libiamf
   repeated string test_repository_tags = 15;
   repeated string primary_tested_spec_sections = 6;
-  optional string base_test = 7;
+  string base_test = 7;
 
   // TODO(b/384960137): Migrate `mp4_fixed_timestamp`, `ms_per_fragment`,
   //                    `override_computed_recon_gains`,
   //                    `validate_user_loudness`,
-  //                    `output_wav_file_bit_depth_override`,
   //                    `partition_mix_gain_parameter_blocks`, `leb_generator`
   //                    to `EncoderControlMetadata`.
 
   // MP4 controls.
-  optional string mp4_fixed_timestamp = 4;
-  optional int32 ms_per_fragment = 8 [default = 10000];
+  string mp4_fixed_timestamp = 4;
+  int32 ms_per_fragment = 8 [default = 10000];
 
   // TODO(b/309461674): Deprecate and add a mode in `EncoderControlMetadata` to
   //                    use the computed gains, without checking the
   //                    user-provided gains.
   // `false` to check that user-provided recon gains match the computed gains.
   // `true` to override the computed recon gains with the user-provided gains.
-  optional bool override_computed_recon_gains = 9 [default = false];
+  bool override_computed_recon_gains = 9 [default = false];
 
   // Controls whether to validate the user-provided loudness against the
   // computed loudness.
-  optional bool validate_user_loudness = 13 [default = false];
+  bool validate_user_loudness = 13 [default = false];
 
-  // TODO(b/390392510): Migrate to `EncoderControlMetadata` and update to limit
-  //                    the possible values.
-  // An override to control the output bit-depth of the output `rendered` wav
-  // file. Or 0, to use a default bit-depth depending on the bitstream. The
-  // value may be clamped to a supported-bit depth.
-  optional uint32 output_wav_file_bit_depth_override = 12;
+  // Deprecated: This field should not be set and has been superseded by
+  // `EncoderControlMetadata.output_audio_format`.
+  uint32 output_wav_file_bit_depth_override = 12 [deprecated = true];
 
   // `true` partitions the input mix gain parameter blocks to be aligned with
   // single frames. The `param_definition` in the descriptor OBUs must be
   // accurate.
-  optional bool partition_mix_gain_parameter_blocks = 10 [default = true];
+  bool partition_mix_gain_parameter_blocks = 10 [default = true];
 
   // Settings to configure how `Leb128`s are generated.
-  optional Leb128Generator leb_generator = 11;
+  Leb128Generator leb_generator = 11;
 
   // Next ID: 16
 }
diff --git a/iamf/cli/proto/user_metadata.proto b/iamf/cli/proto/user_metadata.proto
index d8154bf..760aed3 100644
--- a/iamf/cli/proto/user_metadata.proto
+++ b/iamf/cli/proto/user_metadata.proto
@@ -8,7 +8,7 @@
 // source code in the PATENTS file, you can obtain it at
 // www.aomedia.org/license/patent.
 
-syntax = "proto2";
+edition = "2023";
 
 package iamf_tools_cli_proto;
 
@@ -25,10 +25,12 @@ import "iamf/cli/proto/test_vector_metadata.proto";
 
 message UserMetadata {
   reserved 1, 5;
+
   // Top-level metadata about the file.
-  optional TestVectorMetadata test_vector_metadata = 9;
+  TestVectorMetadata test_vector_metadata = 9;
+
   // Knobs to control the encoder behavior.
-  optional EncoderControlMetadata encoder_control_metadata = 12;
+  EncoderControlMetadata encoder_control_metadata = 12;
 
   // Descriptor OBUs.
   repeated IASequenceHeaderObuMetadata ia_sequence_header_metadata = 10;
@@ -39,7 +41,7 @@ message UserMetadata {
   // Temporal Unit OBUs.
   repeated AudioFrameObuMetadata audio_frame_metadata = 6;
   repeated ParameterBlockObuMetadata parameter_block_metadata = 7;
-  optional TemporalDelimiterObuMetadata temporal_delimiter_metadata = 8;
+  TemporalDelimiterObuMetadata temporal_delimiter_metadata = 8;
 
   // A list of arbitrary OBUs to insert blindly into the stream. There is no
   // attempt to validate or process any side effects of adding the OBUs.
diff --git a/iamf/cli/proto_conversion/BUILD b/iamf/cli/proto_conversion/BUILD
index 7d2183c..572ea36 100644
--- a/iamf/cli/proto_conversion/BUILD
+++ b/iamf/cli/proto_conversion/BUILD
@@ -2,6 +2,8 @@
 # cli/proto_to_obu and cli/obu_to_proto are subdirectories for unidirectional conversion, but utils
 # and bidirectional conversion can stay in this directory.
 
+load("@rules_cc//cc:cc_library.bzl", "cc_library")
+
 # keep-sorted start block=yes prefix_order=cc_library newline_separated=yes
 cc_library(
     name = "channel_label_utils",
@@ -76,6 +78,25 @@ cc_library(
     ],
 )
 
+cc_library(
+    name = "output_audio_format_utils",
+    srcs = ["output_audio_format_utils.cc"],
+    hdrs = ["output_audio_format_utils.h"],
+    visibility = [
+        "//iamf/cli:__pkg__",
+        "//iamf/cli/proto_conversion:__subpackages__",
+    ],
+    deps = [
+        "//iamf/cli:rendering_mix_presentation_finalizer",
+        "//iamf/cli:sample_processor_base",
+        "//iamf/cli/proto:obu_header_cc_proto",
+        "//iamf/cli/proto:output_audio_format_cc_proto",
+        "//iamf/obu:mix_presentation",
+        "//iamf/obu:types",
+        "@com_google_absl//absl/log",
+    ],
+)
+
 cc_library(
     name = "proto_utils",
     srcs = ["proto_utils.cc"],
diff --git a/iamf/cli/proto_conversion/output_audio_format_utils.cc b/iamf/cli/proto_conversion/output_audio_format_utils.cc
new file mode 100644
index 0000000..b70a40a
--- /dev/null
+++ b/iamf/cli/proto_conversion/output_audio_format_utils.cc
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+#include "iamf/cli/proto_conversion/output_audio_format_utils.h"
+
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <utility>
+
+#include "absl/log/log.h"
+#include "iamf/cli/proto/output_audio_format.pb.h"
+#include "iamf/cli/rendering_mix_presentation_finalizer.h"
+#include "iamf/cli/sample_processor_base.h"
+#include "iamf/obu/mix_presentation.h"
+#include "iamf/obu/types.h"
+
+namespace iamf_tools {
+
+namespace {
+typedef RenderingMixPresentationFinalizer::SampleProcessorFactory
+    SampleProcessorFactory;
+using iamf_tools_cli_proto::OutputAudioFormat;
+}  // namespace
+
+void ApplyOutputAudioFormatToSampleProcessorFactory(
+    OutputAudioFormat output_audio_format,
+    SampleProcessorFactory& sample_processor_factory) {
+  // The bit-depth force when writing the wav file, or `std::nullopt` to use the
+  // bit-depth of the input audio.
+  uint8_t override_bit_depth = 0;
+  switch (output_audio_format) {
+    using enum iamf_tools_cli_proto::OutputAudioFormat;
+    case OUTPUT_FORMAT_INVALID:
+      LOG(WARNING) << "Invalid output audio format. Disabling output audio.";
+      [[fallthrough]];
+    case OUTPUT_FORMAT_NONE:
+      // Disable wav writing entirely.
+      sample_processor_factory =
+          RenderingMixPresentationFinalizer::ProduceNoSampleProcessors;
+      return;
+    case OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC:
+      // Preserve the factory. Later the bit-depth will be inferred from the
+      // input audio.
+      return;
+    // Modes which force the bit-depth of the output wav file.
+    case OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN:
+      override_bit_depth = 16;
+      break;
+    case OUTPUT_FORMAT_WAV_BIT_DEPTH_TWENTY_FOUR:
+      override_bit_depth = 24;
+      break;
+    case OUTPUT_FORMAT_WAV_BIT_DEPTH_THIRTY_TWO:
+      override_bit_depth = 32;
+      break;
+  }
+
+  // Override the bit-depth to match the requested format.
+  sample_processor_factory =
+      [original_factory = std::move(sample_processor_factory),
+       override_bit_depth](DecodedUleb128 mix_presentation_id,
+                           int sub_mix_index, int layout_index,
+                           const Layout& layout, int num_channels,
+                           int sample_rate, int /*bit_depth*/,
+                           size_t max_input_samples_per_frame)
+      -> std::unique_ptr<SampleProcessorBase> {
+    return original_factory(mix_presentation_id, sub_mix_index, layout_index,
+                            layout, num_channels, sample_rate,
+                            override_bit_depth, max_input_samples_per_frame);
+  };
+}
+
+}  // namespace iamf_tools
diff --git a/iamf/cli/proto_conversion/output_audio_format_utils.h b/iamf/cli/proto_conversion/output_audio_format_utils.h
new file mode 100644
index 0000000..4b789ba
--- /dev/null
+++ b/iamf/cli/proto_conversion/output_audio_format_utils.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#ifndef CLI_PROTO_CONVERSION_OUTPUT_AUDIO_FORMAT_UTILS_H_
+#define CLI_PROTO_CONVERSION_OUTPUT_AUDIO_FORMAT_UTILS_H_
+
+#include "iamf/cli/proto/obu_header.pb.h"
+#include "iamf/cli/proto/output_audio_format.pb.h"
+#include "iamf/cli/rendering_mix_presentation_finalizer.h"
+
+namespace iamf_tools {
+
+/*!\brief Modifies a factory function for creating sample processors.
+ *
+ * \param output_audio_format Requested format of the output audio.
+ * \param sample_processor_factory Factory function to modify in place.
+ */
+void ApplyOutputAudioFormatToSampleProcessorFactory(
+    iamf_tools_cli_proto::OutputAudioFormat output_audio_format,
+    RenderingMixPresentationFinalizer::SampleProcessorFactory&
+        sample_processor_factory);
+
+}  // namespace iamf_tools
+
+#endif  // CLI_PROTO_CONVERSION_OUTPUT_AUDIO_FORMAT_UTILS_H_
diff --git a/iamf/cli/proto_conversion/proto_to_obu/audio_frame_generator.cc b/iamf/cli/proto_conversion/proto_to_obu/audio_frame_generator.cc
index 8c6f382..f358317 100644
--- a/iamf/cli/proto_conversion/proto_to_obu/audio_frame_generator.cc
+++ b/iamf/cli/proto_conversion/proto_to_obu/audio_frame_generator.cc
@@ -183,8 +183,16 @@ void MoveSamples(const size_t num_samples,
                  std::deque<std::vector<int32_t>>& source_samples,
                  std::vector<std::vector<int32_t>>& destination_samples) {
   CHECK_GE(source_samples.size(), num_samples);
-  std::copy(source_samples.begin(), source_samples.begin() + num_samples,
-            destination_samples.begin());
+  const size_t num_channels = source_samples.front().size();
+  CHECK_EQ(destination_samples.size(), num_channels);
+
+  for (int c = 0; c < num_channels; c++) {
+    auto& destination_samples_for_channel = destination_samples[c];
+    destination_samples_for_channel.resize(num_samples);
+    for (int t = 0; t < num_samples; t++) {
+      destination_samples_for_channel[t] = source_samples[t][c];
+    }
+  }
   source_samples.erase(source_samples.begin(),
                        source_samples.begin() + num_samples);
 }
@@ -428,8 +436,10 @@ absl::Status MaybeEncodeFramesForAudioElement(
     label_to_empty_samples[label] = {};
   }
 
-  std::optional<int32_t> encoded_timestamp;
+  std::optional<InternalTimestamp> encoded_timestamp;
   bool more_samples_to_encode = false;
+  std::vector<std::vector<int32_t>> samples_encode;
+  std::vector<std::vector<int32_t>> samples_obu;
   do {
     RETURN_IF_NOT_OK(GetNextFrameSubstreamData(
         audio_element_id, demixing_module, num_samples_per_frame,
@@ -459,6 +469,7 @@ absl::Status MaybeEncodeFramesForAudioElement(
       }
 
       more_samples_to_encode = true;
+      const auto num_channels = substream_data.samples_obu.front().size();
 
       // Encode.
       if (substream_data.samples_encode.size() < num_samples_per_frame) {
@@ -473,11 +484,14 @@ absl::Status MaybeEncodeFramesForAudioElement(
         continue;
       }
 
-      // Pop samples from the queues and arrange in (time, channel) axes.
+      // Pop samples from the queues and arrange in (channel, time) axes.
       const size_t num_samples_to_encode =
           static_cast<size_t>(num_samples_per_frame);
-      std::vector<std::vector<int32_t>> samples_encode(num_samples_to_encode);
-      std::vector<std::vector<int32_t>> samples_obu(num_samples_to_encode);
+      // std::vector<std::vector<int32_t>>
+      // samples_encode(num_samples_to_encode);
+      // std::vector<std::vector<int32_t>> samples_obu(num_samples_to_encode);
+      samples_obu.resize(num_channels);
+      samples_encode.resize(num_channels);
 
       MoveSamples(num_samples_to_encode, substream_data.samples_obu,
                   samples_obu);
@@ -494,7 +508,8 @@ absl::Status MaybeEncodeFramesForAudioElement(
       InternalTimestamp start_timestamp;
       InternalTimestamp end_timestamp;
       RETURN_IF_NOT_OK(global_timing_module.GetNextAudioFrameTimestamps(
-          substream_id, samples_obu.size(), start_timestamp, end_timestamp));
+          substream_id, samples_obu.front().size(), start_timestamp,
+          end_timestamp));
 
       if (encoded_timestamp.has_value()) {
         // All frames corresponding to the same Audio Element should have
diff --git a/iamf/cli/proto_conversion/proto_to_obu/parameter_block_generator.cc b/iamf/cli/proto_conversion/proto_to_obu/parameter_block_generator.cc
index eab5a79..51defe5 100644
--- a/iamf/cli/proto_conversion/proto_to_obu/parameter_block_generator.cc
+++ b/iamf/cli/proto_conversion/proto_to_obu/parameter_block_generator.cc
@@ -553,27 +553,16 @@ absl::Status PopulateSubblocks(
   return absl::OkStatus();
 }
 
-absl::Status LogParameterBlockObus(
+void LogParameterBlockObus(
     const std::list<ParameterBlockWithData>& output_parameter_blocks) {
-  // Log only the first and the last parameter blocks.
-  if (output_parameter_blocks.empty()) {
-    return absl::OkStatus();
-  }
-  std::vector<const ParameterBlockWithData*> to_log = {
-      &output_parameter_blocks.front()};
-  if (output_parameter_blocks.size() > 1) {
-    to_log.push_back(&output_parameter_blocks.back());
-  }
-
-  for (const auto* parameter_block_with_data : to_log) {
-    parameter_block_with_data->obu->PrintObu();
+  for (const auto& parameter_block_with_data : output_parameter_blocks) {
+    CHECK_NE(parameter_block_with_data.obu, nullptr);
+    parameter_block_with_data.obu->PrintObu();
     LOG(INFO) << "  // start_timestamp= "
-              << parameter_block_with_data->start_timestamp;
+              << parameter_block_with_data.start_timestamp;
     LOG(INFO) << "  // end_timestamp= "
-              << parameter_block_with_data->end_timestamp;
+              << parameter_block_with_data.end_timestamp;
   }
-
-  return absl::OkStatus();
 }
 
 }  // namespace
@@ -694,7 +683,10 @@ absl::Status ParameterBlockGenerator::GenerateParameterBlocks(
     output_parameter_blocks.push_back(std::move(output_parameter_block));
   }
 
-  RETURN_IF_NOT_OK(LogParameterBlockObus(output_parameter_blocks));
+  if (additional_parameter_block_logging_) {
+    LogParameterBlockObus(output_parameter_blocks);
+    additional_parameter_block_logging_ = false;
+  }
 
   // Clear the metadata of this frame.
   proto_metadata_list.clear();
diff --git a/iamf/cli/proto_conversion/proto_to_obu/parameter_block_generator.h b/iamf/cli/proto_conversion/proto_to_obu/parameter_block_generator.h
index 6299ce1..0c1745a 100644
--- a/iamf/cli/proto_conversion/proto_to_obu/parameter_block_generator.h
+++ b/iamf/cli/proto_conversion/proto_to_obu/parameter_block_generator.h
@@ -59,6 +59,7 @@ class ParameterBlockGenerator {
           param_definition_variants)
       : override_computed_recon_gains_(override_computed_recon_gains),
         additional_recon_gains_logging_(true),
+        additional_parameter_block_logging_(true),
         param_definition_variants_(param_definition_variants) {}
 
   /*!\brief Initializes the class.
@@ -139,6 +140,7 @@ class ParameterBlockGenerator {
   const bool override_computed_recon_gains_;
 
   bool additional_recon_gains_logging_;
+  bool additional_parameter_block_logging_;
 
   // Mapping from parameter IDs to param definitions.
   const absl::flat_hash_map<DecodedUleb128, ParamDefinitionVariant>&
diff --git a/iamf/cli/proto_conversion/proto_to_obu/tests/codec_config_generator_test.cc b/iamf/cli/proto_conversion/proto_to_obu/tests/codec_config_generator_test.cc
index 1c2217f..8583f15 100644
--- a/iamf/cli/proto_conversion/proto_to_obu/tests/codec_config_generator_test.cc
+++ b/iamf/cli/proto_conversion/proto_to_obu/tests/codec_config_generator_test.cc
@@ -886,14 +886,17 @@ TEST_F(CodecConfigGeneratorTest, ObeysInvalidFlacStreamInfo) {
   // IAMF requires several fields in the Stream Info block are fixed. The
   // generator does not validate OBU requirements.
   const uint32_t kInvalidMinimumFrameSize = 99;
-  ASSERT_NE(kInvalidMinimumFrameSize, FlacStreamInfoConstraints::kMinFrameSize);
+  ASSERT_NE(kInvalidMinimumFrameSize,
+            FlacStreamInfoLooseConstraints::kMinFrameSize);
   const uint32_t kInvalidMaximumFrameSize = 98;
-  ASSERT_NE(kInvalidMaximumFrameSize, FlacStreamInfoConstraints::kMaxFrameSize);
+  ASSERT_NE(kInvalidMaximumFrameSize,
+            FlacStreamInfoLooseConstraints::kMaxFrameSize);
   const uint8_t kInvalidNumberOfChannels = 97;
   ASSERT_NE(kInvalidNumberOfChannels,
-            FlacStreamInfoConstraints::kNumberOfChannels);
+            FlacStreamInfoStrictConstraints::kNumberOfChannels);
   const std::array<uint8_t, 16> kInvalidMd5Signature = {1};
-  ASSERT_NE(kInvalidMd5Signature, FlacStreamInfoConstraints::kMd5Signature);
+  ASSERT_NE(kInvalidMd5Signature,
+            FlacStreamInfoLooseConstraints::kMd5Signature);
   InitMetadataForFlac(codec_config_metadata_);
   auto* stream_info_metadata = codec_config_metadata_.at(0)
                                    .mutable_codec_config()
diff --git a/iamf/cli/proto_conversion/proto_to_obu/tests/parameter_block_generator_test.cc b/iamf/cli/proto_conversion/proto_to_obu/tests/parameter_block_generator_test.cc
index 95aa8dc..2949098 100644
--- a/iamf/cli/proto_conversion/proto_to_obu/tests/parameter_block_generator_test.cc
+++ b/iamf/cli/proto_conversion/proto_to_obu/tests/parameter_block_generator_test.cc
@@ -134,8 +134,8 @@ void InitializePrerequisiteObus(
 void ValidateParameterBlocksCommon(
     const std::list<ParameterBlockWithData>& output_parameter_blocks,
     const DecodedUleb128 expected_parameter_id,
-    const std::vector<int32_t>& expected_start_timestamps,
-    const std::vector<int32_t>& expected_end_timestamps) {
+    const std::vector<InternalTimestamp>& expected_start_timestamps,
+    const std::vector<InternalTimestamp>& expected_end_timestamps) {
   EXPECT_EQ(expected_start_timestamps.size(), output_parameter_blocks.size());
   EXPECT_EQ(expected_end_timestamps.size(), output_parameter_blocks.size());
   int block_index = 0;
diff --git a/iamf/cli/proto_conversion/tests/BUILD b/iamf/cli/proto_conversion/tests/BUILD
index 7820f8a..04df0a3 100644
--- a/iamf/cli/proto_conversion/tests/BUILD
+++ b/iamf/cli/proto_conversion/tests/BUILD
@@ -1,3 +1,5 @@
+load("@rules_cc//cc:cc_test.bzl", "cc_test")
+
 # keep-sorted start block=yes prefix_order=cc_test newline_separated=yes
 cc_test(
     name = "channel_label_utils_test",
@@ -32,6 +34,21 @@ cc_test(
     ],
 )
 
+cc_test(
+    name = "output_audio_format_utils_test",
+    srcs = ["output_audio_format_utils_test.cc"],
+    deps = [
+        "//iamf/cli:rendering_mix_presentation_finalizer",
+        "//iamf/cli/proto:obu_header_cc_proto",
+        "//iamf/cli/proto:parameter_data_cc_proto",
+        "//iamf/cli/proto_conversion:output_audio_format_utils",
+        "//iamf/cli/tests:cli_test_utils",
+        "//iamf/obu:mix_presentation",
+        "//iamf/obu:types",
+        "@com_google_googletest//:gtest_main",
+    ],
+)
+
 cc_test(
     name = "proto_utils_test",
     srcs = ["proto_utils_test.cc"],
diff --git a/iamf/cli/proto_conversion/tests/output_audio_format_utils_test.cc b/iamf/cli/proto_conversion/tests/output_audio_format_utils_test.cc
new file mode 100644
index 0000000..a60c1a7
--- /dev/null
+++ b/iamf/cli/proto_conversion/tests/output_audio_format_utils_test.cc
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+#include "iamf/cli/proto_conversion/output_audio_format_utils.h"
+
+#include <cstddef>
+
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+#include "iamf/cli/proto/obu_header.pb.h"
+#include "iamf/cli/proto/parameter_data.pb.h"
+#include "iamf/cli/rendering_mix_presentation_finalizer.h"
+#include "iamf/cli/tests/cli_test_utils.h"
+#include "iamf/obu/mix_presentation.h"
+#include "iamf/obu/types.h"
+
+namespace iamf_tools {
+namespace {
+
+using ::testing::_;
+
+typedef RenderingMixPresentationFinalizer::SampleProcessorFactory
+    SampleProcessorFactory;
+using enum iamf_tools_cli_proto::OutputAudioFormat;
+
+constexpr DecodedUleb128 kMixPresentationId = 42;
+constexpr int kSubMixIndex = 1;
+constexpr int kLayoutIndex = 3;
+const Layout kStereoLayout = {
+    .layout_type = Layout::kLayoutTypeLoudspeakersSsConvention,
+    .specific_layout = LoudspeakersSsConventionLayout{
+        .sound_system = LoudspeakersSsConventionLayout::kSoundSystemA_0_2_0}};
+constexpr int kNumChannels = 2;
+constexpr int kSampleRate = 48000;
+constexpr int kBitDepth16 = 16;
+constexpr int kBitDepth24 = 24;
+constexpr int kBitDepth32 = 32;
+constexpr size_t kMaxInputSamplesPerFrame = 0;
+
+TEST(GetWavSampleProcessorFactoryFromOutputAudioFormat,
+     ForwardsArgumentsWhenBitDepthIsPreserved) {
+  MockSampleProcessorFactory mock_factory;
+  // Configure the factory to preserve the bit-depth.
+  const auto kPreserveBitDepth = OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC;
+  // All arguments should be preserved.
+  EXPECT_CALL(mock_factory, Call(kMixPresentationId, kSubMixIndex, kLayoutIndex,
+                                 kStereoLayout, kNumChannels, kSampleRate,
+                                 kBitDepth16, kMaxInputSamplesPerFrame));
+  SampleProcessorFactory sample_processor_factory =
+      mock_factory.AsStdFunction();
+
+  ApplyOutputAudioFormatToSampleProcessorFactory(kPreserveBitDepth,
+                                                 sample_processor_factory);
+
+  sample_processor_factory(kMixPresentationId, kSubMixIndex, kLayoutIndex,
+                           kStereoLayout, kNumChannels, kSampleRate,
+                           kBitDepth16, kMaxInputSamplesPerFrame);
+}
+
+TEST(GetWavSampleProcessorFactoryFromOutputAudioFormat,
+     ForwardsmostArgumentsWhenBitDepthIsNotPreserved) {
+  MockSampleProcessorFactory mock_factory;
+  // Configure the factory to override the bit-depth.
+  const auto kOverrideBitDepth = OUTPUT_FORMAT_WAV_BIT_DEPTH_TWENTY_FOUR;
+  // All arguments, except the bit-depth, should be preserved.
+  EXPECT_CALL(mock_factory, Call(kMixPresentationId, kSubMixIndex, kLayoutIndex,
+                                 kStereoLayout, kNumChannels, kSampleRate, _,
+                                 kMaxInputSamplesPerFrame));
+  SampleProcessorFactory sample_processor_factory =
+      mock_factory.AsStdFunction();
+
+  ApplyOutputAudioFormatToSampleProcessorFactory(kOverrideBitDepth,
+                                                 sample_processor_factory);
+
+  sample_processor_factory(kMixPresentationId, kSubMixIndex, kLayoutIndex,
+                           kStereoLayout, kNumChannels, kSampleRate,
+                           kBitDepth16, kMaxInputSamplesPerFrame);
+}
+
+TEST(GetWavSampleProcessorFactoryFromOutputAudioFormat,
+     DoesNotUseFactoryWhenOutputIsDisabled) {
+  MockSampleProcessorFactory mock_factory;
+  // Omit output wav files.
+  const auto kPreserveBitDepth = OUTPUT_FORMAT_NONE;
+  // The mock factory is thrown away, and observes no calls when the output
+  // factory is used.
+  EXPECT_CALL(mock_factory, Call(_, _, _, _, _, _, _, _)).Times(0);
+  SampleProcessorFactory sample_processor_factory =
+      mock_factory.AsStdFunction();
+
+  ApplyOutputAudioFormatToSampleProcessorFactory(kPreserveBitDepth,
+                                                 sample_processor_factory);
+
+  sample_processor_factory(kMixPresentationId, kSubMixIndex, kLayoutIndex,
+                           kStereoLayout, kNumChannels, kSampleRate,
+                           kBitDepth16, kMaxInputSamplesPerFrame);
+}
+
+struct BitDepthOverrideTestParam {
+  int initial_bit_depth;
+  iamf_tools_cli_proto::OutputAudioFormat output_audio_format;
+  int expected_bit_depth;
+};
+
+using BitDepthOverrideTest =
+    ::testing::TestWithParam<BitDepthOverrideTestParam>;
+
+TEST_P(BitDepthOverrideTest, ValidateBitDepthOverride) {
+  MockSampleProcessorFactory mock_factory;
+  EXPECT_CALL(mock_factory,
+              Call(_, _, _, _, _, _, GetParam().expected_bit_depth, _));
+
+  SampleProcessorFactory sample_processor_factory =
+      mock_factory.AsStdFunction();
+
+  ApplyOutputAudioFormatToSampleProcessorFactory(GetParam().output_audio_format,
+                                                 sample_processor_factory);
+
+  sample_processor_factory(kMixPresentationId, kSubMixIndex, kLayoutIndex,
+                           kStereoLayout, kNumChannels, kSampleRate,
+                           GetParam().initial_bit_depth,
+                           kMaxInputSamplesPerFrame);
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    OverridesTo16Bit, BitDepthOverrideTest,
+    testing::ValuesIn<BitDepthOverrideTestParam>(
+        {{kBitDepth16, OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN, kBitDepth16},
+         {kBitDepth24, OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN, kBitDepth16},
+         {kBitDepth32, OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN, kBitDepth16}}));
+
+INSTANTIATE_TEST_SUITE_P(
+    OverridesTo24Bit, BitDepthOverrideTest,
+    testing::ValuesIn<BitDepthOverrideTestParam>(
+        {{kBitDepth16, OUTPUT_FORMAT_WAV_BIT_DEPTH_TWENTY_FOUR, kBitDepth24},
+         {kBitDepth24, OUTPUT_FORMAT_WAV_BIT_DEPTH_TWENTY_FOUR, kBitDepth24},
+         {kBitDepth32, OUTPUT_FORMAT_WAV_BIT_DEPTH_TWENTY_FOUR, kBitDepth24}}));
+
+INSTANTIATE_TEST_SUITE_P(
+    OverridesTo32Bit, BitDepthOverrideTest,
+    testing::ValuesIn<BitDepthOverrideTestParam>(
+        {{kBitDepth16, OUTPUT_FORMAT_WAV_BIT_DEPTH_THIRTY_TWO, kBitDepth32},
+         {kBitDepth24, OUTPUT_FORMAT_WAV_BIT_DEPTH_THIRTY_TWO, kBitDepth32},
+         {kBitDepth32, OUTPUT_FORMAT_WAV_BIT_DEPTH_THIRTY_TWO, kBitDepth32}}));
+
+}  // namespace
+}  // namespace iamf_tools
diff --git a/iamf/cli/recon_gain_generator.cc b/iamf/cli/recon_gain_generator.cc
index 710dbcf..88490d4 100644
--- a/iamf/cli/recon_gain_generator.cc
+++ b/iamf/cli/recon_gain_generator.cc
@@ -12,12 +12,12 @@
 #include "iamf/cli/recon_gain_generator.h"
 
 #include <cmath>
-#include <vector>
 
 #include "absl/base/no_destructor.h"
 #include "absl/container/flat_hash_map.h"
 #include "absl/log/log.h"
 #include "absl/status/status.h"
+#include "absl/types/span.h"
 #include "iamf/cli/channel_label.h"
 #include "iamf/cli/demixing_module.h"
 #include "iamf/common/utils/macros.h"
@@ -29,7 +29,7 @@ namespace iamf_tools {
 namespace {
 
 // Returns the Root Mean Square (RMS) power of input `samples`.
-double ComputeSignalPower(const std::vector<InternalSampleType>& samples) {
+double ComputeSignalPower(absl::Span<const InternalSampleType>& samples) {
   double mean_square = 0.0;
   const double scale = 1.0 / static_cast<double>(samples.size());
   for (const auto s : samples) {
@@ -45,7 +45,7 @@ double ComputeSignalPower(const std::vector<InternalSampleType>& samples) {
 absl::Status FindRelevantMixedSamples(
     const bool additional_logging, ChannelLabel::Label label,
     const LabelSamplesMap& label_to_samples,
-    const std::vector<InternalSampleType>** relevant_mixed_samples) {
+    absl::Span<const InternalSampleType>& relevant_mixed_samples) {
   using enum ChannelLabel::Label;
   static const absl::NoDestructor<
       absl::flat_hash_map<ChannelLabel::Label, ChannelLabel::Label>>
@@ -84,15 +84,15 @@ absl::Status ReconGainGenerator::ComputeReconGain(
     const LabelSamplesMap& label_to_decoded_samples,
     const bool additional_logging, double& recon_gain) {
   // Gather information about the original samples.
-  const std::vector<InternalSampleType>* original_samples;
+  absl::Span<const InternalSampleType> original_samples;
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      label, label_to_samples, &original_samples));
+      label, label_to_samples, original_samples));
   LOG_IF(INFO, additional_logging)
       << "[" << label
-      << "] original_samples.size()= " << original_samples->size();
+      << "] original_samples.size()= " << original_samples.size();
 
   // Level Ok in the Spec.
-  const double original_power = ComputeSignalPower(*original_samples);
+  const double original_power = ComputeSignalPower(original_samples);
 
   // TODO(b/289064747): Investigate if the recon gain mismatches are resolved
   //                    after we switched to representing data in [-1, +1].
@@ -109,16 +109,16 @@ absl::Status ReconGainGenerator::ComputeReconGain(
   }
 
   // Gather information about mixed samples.
-  const std::vector<InternalSampleType>* relevant_mixed_samples;
+  absl::Span<const InternalSampleType> relevant_mixed_samples;
   RETURN_IF_NOT_OK(FindRelevantMixedSamples(
-      additional_logging, label, label_to_samples, &relevant_mixed_samples));
+      additional_logging, label, label_to_samples, relevant_mixed_samples));
   LOG_IF(INFO, additional_logging)
       << "[" << label
-      << "] relevant_mixed_samples.size()= " << relevant_mixed_samples->size();
+      << "] relevant_mixed_samples.size()= " << relevant_mixed_samples.size();
 
   // Level Mk in the Spec.
   const double relevant_mixed_power =
-      ComputeSignalPower(*relevant_mixed_samples);
+      ComputeSignalPower(relevant_mixed_samples);
   const double mixed_power_db = 10 * log10(relevant_mixed_power / kMaxLSquared);
   LOG_IF(INFO, additional_logging) << "Level MK (dB) " << mixed_power_db;
 
@@ -137,15 +137,14 @@ absl::Status ReconGainGenerator::ComputeReconGain(
   }
 
   // Gather information about the demixed samples.
-  const std::vector<InternalSampleType>* demixed_samples;
+  absl::Span<const InternalSampleType> demixed_samples;
   RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-      label, label_to_decoded_samples, &demixed_samples));
+      label, label_to_decoded_samples, demixed_samples));
   LOG_IF(INFO, additional_logging)
-      << "[" << label
-      << "] demixed_samples.size()= " << demixed_samples->size();
+      << "[" << label << "] demixed_samples.size()= " << demixed_samples.size();
 
   // Level Dk in the Spec.
-  const double demixed_power = ComputeSignalPower(*demixed_samples);
+  const double demixed_power = ComputeSignalPower(demixed_samples);
 
   // Set recon gain to the value implied by the spec.
   double demixed_power_ratio_db = 10 * log10(demixed_power / mixed_power_db);
diff --git a/iamf/cli/renderer/BUILD b/iamf/cli/renderer/BUILD
index bff8c5e..0f0bbe2 100644
--- a/iamf/cli/renderer/BUILD
+++ b/iamf/cli/renderer/BUILD
@@ -149,6 +149,7 @@ cc_library(
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:statusor",
         "@com_google_absl//absl/strings",
+        "@com_google_absl//absl/types:span",
     ],
 )
 
diff --git a/iamf/cli/renderer/audio_element_renderer_ambisonics_to_channel.cc b/iamf/cli/renderer/audio_element_renderer_ambisonics_to_channel.cc
index 6ac66d3..261dbff 100644
--- a/iamf/cli/renderer/audio_element_renderer_ambisonics_to_channel.cc
+++ b/iamf/cli/renderer/audio_element_renderer_ambisonics_to_channel.cc
@@ -197,7 +197,7 @@ AudioElementRendererAmbisonicsToChannel::CreateFromAmbisonicsConfig(
 }
 
 absl::Status AudioElementRendererAmbisonicsToChannel::RenderSamples(
-    absl::Span<const std::vector<InternalSampleType>> samples_to_render,
+    absl::Span<const absl::Span<const InternalSampleType>> samples_to_render,
     std::vector<InternalSampleType>& rendered_samples) {
   // Render the samples.
   RETURN_IF_NOT_OK(RenderAmbisonicsToLoudspeakers(
diff --git a/iamf/cli/renderer/audio_element_renderer_ambisonics_to_channel.h b/iamf/cli/renderer/audio_element_renderer_ambisonics_to_channel.h
index 0a5c920..e288506 100644
--- a/iamf/cli/renderer/audio_element_renderer_ambisonics_to_channel.h
+++ b/iamf/cli/renderer/audio_element_renderer_ambisonics_to_channel.h
@@ -87,12 +87,12 @@ class AudioElementRendererAmbisonicsToChannel
 
   /*!\brief Renders samples.
    *
-   * \param samples_to_render Samples to render arranged in (time, channel).
+   * \param samples_to_render Samples to render arranged in (channel, time).
    * \param rendered_samples Output rendered samples.
    * \return `absl::OkStatus()` on success. A specific status on failure.
    */
   absl::Status RenderSamples(
-      absl::Span<const std::vector<InternalSampleType>> samples_to_render,
+      absl::Span<const absl::Span<const InternalSampleType>> samples_to_render,
       std::vector<InternalSampleType>& rendered_samples)
       ABSL_SHARED_LOCKS_REQUIRED(mutex_) override;
 
diff --git a/iamf/cli/renderer/audio_element_renderer_base.cc b/iamf/cli/renderer/audio_element_renderer_base.cc
index 88fff87..bfa77f4 100644
--- a/iamf/cli/renderer/audio_element_renderer_base.cc
+++ b/iamf/cli/renderer/audio_element_renderer_base.cc
@@ -33,16 +33,16 @@ absl::StatusOr<size_t> AudioElementRendererBase::RenderLabeledFrame(
 
   size_t num_valid_samples = 0;
   RETURN_IF_NOT_OK(iamf_tools::renderer_utils::ArrangeSamplesToRender(
-      labeled_frame, ordered_labels_, samples_to_render_, num_valid_samples));
+      labeled_frame, ordered_labels_, kEmptyChannel, samples_to_render_,
+      num_valid_samples));
 
   // Render samples in concrete subclasses.
   current_labeled_frame_ = &labeled_frame;
 
   std::vector<InternalSampleType> rendered_samples(
       num_output_channels_ * num_valid_samples, 0);
-  RETURN_IF_NOT_OK(RenderSamples(
-      absl::MakeConstSpan(samples_to_render_).first(num_valid_samples),
-      rendered_samples));
+  RETURN_IF_NOT_OK(
+      RenderSamples(absl::MakeConstSpan(samples_to_render_), rendered_samples));
 
   // Copy rendered samples to the output.
   rendered_samples_.insert(rendered_samples_.end(), rendered_samples.begin(),
diff --git a/iamf/cli/renderer/audio_element_renderer_base.h b/iamf/cli/renderer/audio_element_renderer_base.h
index 726d183..f26d0be 100644
--- a/iamf/cli/renderer/audio_element_renderer_base.h
+++ b/iamf/cli/renderer/audio_element_renderer_base.h
@@ -96,18 +96,17 @@ class AudioElementRendererBase {
       : ordered_labels_(ordered_labels.begin(), ordered_labels.end()),
         num_samples_per_frame_(num_samples_per_frame),
         num_output_channels_(num_output_channels),
-        samples_to_render_(
-            num_samples_per_frame_,
-            std::vector<InternalSampleType>(ordered_labels_.size(), 0)) {}
+        samples_to_render_(ordered_labels_.size()),
+        kEmptyChannel(num_samples_per_frame_, 0.0) {}
 
   /*!\brief Renders samples.
    *
-   * \param samples_to_render Samples to render arranged in (time, channel).
+   * \param samples_to_render Samples to render arranged in (channel, time).
    * \param rendered_samples Output rendered samples.
    * \return `absl::OkStatus()` on success. A specific status on failure.
    */
   virtual absl::Status RenderSamples(
-      absl::Span<const std::vector<InternalSampleType>> samples_to_render,
+      absl::Span<const absl::Span<const InternalSampleType>> samples_to_render,
       std::vector<InternalSampleType>& rendered_samples)
       ABSL_SHARED_LOCKS_REQUIRED(mutex_) = 0;
 
@@ -117,9 +116,15 @@ class AudioElementRendererBase {
 
   // Mutex to guard simultaneous access to data members.
   mutable absl::Mutex mutex_;
-  std::vector<std::vector<InternalSampleType>> samples_to_render_
+
+  // Buffer of samples to render arranged in (channel, time).
+  std::vector<absl::Span<const InternalSampleType>> samples_to_render_
       ABSL_GUARDED_BY(mutex_);
   std::vector<InternalSampleType> rendered_samples_ ABSL_GUARDED_BY(mutex_);
+
+  // Buffer storing zeros. All omitted channels' spans point to this.
+  const std::vector<InternalSampleType> kEmptyChannel;
+
   bool is_finalized_ ABSL_GUARDED_BY(mutex_) = false;
   const LabeledFrame* current_labeled_frame_ ABSL_GUARDED_BY(mutex_) = nullptr;
 };
diff --git a/iamf/cli/renderer/audio_element_renderer_channel_to_channel.cc b/iamf/cli/renderer/audio_element_renderer_channel_to_channel.cc
index bb8e537..82a4b15 100644
--- a/iamf/cli/renderer/audio_element_renderer_channel_to_channel.cc
+++ b/iamf/cli/renderer/audio_element_renderer_channel_to_channel.cc
@@ -165,7 +165,7 @@ AudioElementRendererChannelToChannel::CreateFromScalableChannelLayoutConfig(
 }
 
 absl::Status AudioElementRendererChannelToChannel::RenderSamples(
-    absl::Span<const std::vector<InternalSampleType>> samples_to_render,
+    absl::Span<const absl::Span<const InternalSampleType>> samples_to_render,
     std::vector<InternalSampleType>& rendered_samples) {
   // Render the samples.
   RETURN_IF_NOT_OK(RenderChannelLayoutToLoudspeakers(
diff --git a/iamf/cli/renderer/audio_element_renderer_channel_to_channel.h b/iamf/cli/renderer/audio_element_renderer_channel_to_channel.h
index fbff8a4..58af337 100644
--- a/iamf/cli/renderer/audio_element_renderer_channel_to_channel.h
+++ b/iamf/cli/renderer/audio_element_renderer_channel_to_channel.h
@@ -86,12 +86,12 @@ class AudioElementRendererChannelToChannel : public AudioElementRendererBase {
 
   /*!\brief Renders samples.
    *
-   * \param samples_to_render Samples to render arranged in (time, channel).
+   * \param samples_to_render Samples to render arranged in (channel, time).
    * \param rendered_samples Output rendered samples.
    * \return `absl::OkStatus()` on success. A specific status on failure.
    */
   absl::Status RenderSamples(
-      absl::Span<const std::vector<InternalSampleType>> samples_to_render,
+      absl::Span<const absl::Span<const InternalSampleType>> samples_to_render,
       std::vector<InternalSampleType>& rendered_samples)
       ABSL_SHARED_LOCKS_REQUIRED(mutex_) override;
 
diff --git a/iamf/cli/renderer/audio_element_renderer_passthrough.cc b/iamf/cli/renderer/audio_element_renderer_passthrough.cc
index 600404f..8e4ed9c 100644
--- a/iamf/cli/renderer/audio_element_renderer_passthrough.cc
+++ b/iamf/cli/renderer/audio_element_renderer_passthrough.cc
@@ -178,9 +178,9 @@ AudioElementRendererPassThrough::CreateFromScalableChannelLayoutConfig(
 }
 
 absl::Status AudioElementRendererPassThrough::RenderSamples(
-    absl::Span<const std::vector<InternalSampleType>> samples_to_render,
+    absl::Span<const absl::Span<const InternalSampleType>> samples_to_render,
     std::vector<InternalSampleType>& rendered_samples) {
-  // Flatten the (time, channel) axes into interleaved samples.
+  // Flatten the (channel, time) axes into interleaved samples.
   const absl::AnyInvocable<absl::Status(InternalSampleType, InternalSampleType&)
                                const>
       kIdentityTransform =
@@ -188,8 +188,7 @@ absl::Status AudioElementRendererPassThrough::RenderSamples(
             output = input;
             return absl::OkStatus();
           };
-
-  return ConvertTimeChannelToInterleaved(samples_to_render, kIdentityTransform,
+  return ConvertChannelTimeToInterleaved(samples_to_render, kIdentityTransform,
                                          rendered_samples);
 }
 
diff --git a/iamf/cli/renderer/audio_element_renderer_passthrough.h b/iamf/cli/renderer/audio_element_renderer_passthrough.h
index d42952a..2b6f168 100644
--- a/iamf/cli/renderer/audio_element_renderer_passthrough.h
+++ b/iamf/cli/renderer/audio_element_renderer_passthrough.h
@@ -83,12 +83,12 @@ class AudioElementRendererPassThrough : public AudioElementRendererBase {
 
   /*!\brief Renders samples.
    *
-   * \param samples_to_render Samples to render arranged in (time, channel).
+   * \param samples_to_render Samples to render arranged in (channel, time).
    * \param rendered_samples Output rendered samples.
    * \return `absl::OkStatus()` on success. A specific status on failure.
    */
   absl::Status RenderSamples(
-      absl::Span<const std::vector<InternalSampleType>> samples_to_render,
+      absl::Span<const absl::Span<const InternalSampleType>> samples_to_render,
       std::vector<InternalSampleType>& rendered_samples)
       ABSL_SHARED_LOCKS_REQUIRED(mutex_) override;
 };
diff --git a/iamf/cli/renderer/loudspeakers_renderer.cc b/iamf/cli/renderer/loudspeakers_renderer.cc
index 6b7dd1b..d061607 100644
--- a/iamf/cli/renderer/loudspeakers_renderer.cc
+++ b/iamf/cli/renderer/loudspeakers_renderer.cc
@@ -163,59 +163,66 @@ double Q15ToSignedDouble(const int16_t input) {
   return static_cast<double>(input) / 32768.0;
 }
 
-std::vector<std::vector<InternalSampleType>> ProjectSamplesToRender(
-    absl::Span<const std::vector<InternalSampleType>>& input_samples,
-    const int16_t* demixing_matrix, const int output_channel_count) {
+void ProjectSamplesToRender(
+    absl::Span<const absl::Span<const InternalSampleType>> input_samples,
+    const int16_t* demixing_matrix, const int num_output_channels,
+    std::vector<std::vector<InternalSampleType>>& projected_samples) {
   CHECK_NE(demixing_matrix, nullptr);
-  std::vector<std::vector<InternalSampleType>> samples_to_render(
-      input_samples.size(),
-      std::vector<InternalSampleType>(output_channel_count, 0.0));
-
-  for (int t = 0; t < samples_to_render.size(); t++) {
-    for (int out_channel = 0; out_channel < output_channel_count;
-         out_channel++) {
-      // Project with `demixing_matrix`, which is encoded as Q15 and stored
-      // in column major.
-      for (int in_channel = 0; in_channel < input_samples[0].size();
-           in_channel++) {
-        samples_to_render[t][out_channel] +=
+  const auto num_in_channels = input_samples.size();
+  const auto num_ticks = input_samples.empty() ? 0 : input_samples[0].size();
+  projected_samples.resize(num_output_channels);
+  for (int out_channel = 0; out_channel < num_output_channels; out_channel++) {
+    projected_samples[out_channel].resize(num_ticks, 0.0);
+    for (int in_channel = 0; in_channel < num_in_channels; in_channel++) {
+      for (int t = 0; t < num_ticks; t++) {
+        // Project with `demixing_matrix`, which is encoded as Q15 and stored
+        // in column major.
+        projected_samples[out_channel][t] +=
             Q15ToSignedDouble(
-                demixing_matrix[in_channel * output_channel_count +
-                                out_channel]) *
-            input_samples[t][in_channel];
+                demixing_matrix[in_channel * num_in_channels + out_channel]) *
+            input_samples[in_channel][t];
       }
     }
   }
-  return samples_to_render;
 }
 
 void RenderSamplesUsingGains(
-    absl::Span<const std::vector<InternalSampleType>>& input_samples,
+    absl::Span<const absl::Span<const InternalSampleType>> input_samples,
     const std::vector<std::vector<double>>& gains,
     const int16_t* demixing_matrix,
     std::vector<InternalSampleType>& rendered_samples) {
   // Project with `demixing_matrix` when in projection mode.
-  absl::Span<const std::vector<InternalSampleType>> samples_to_render_double;
+  absl::Span<const absl::Span<const InternalSampleType>>
+      samples_to_render_double;
+
+  // TODO(b/382197581): Avoid re-allocating vectors in each function call.
   std::vector<std::vector<InternalSampleType>> projected_samples;
+  std::vector<absl::Span<const InternalSampleType>> projected_spans;
   if (demixing_matrix != nullptr) {
-    projected_samples =
-        ProjectSamplesToRender(input_samples, demixing_matrix, gains.size());
-    samples_to_render_double = absl::MakeConstSpan(projected_samples);
+    ProjectSamplesToRender(input_samples, demixing_matrix, gains.size(),
+                           projected_samples);
+    projected_spans.resize(projected_samples.size());
+    for (int c = 0; c < projected_samples.size(); c++) {
+      projected_spans[c] = absl::MakeConstSpan(projected_samples[c]);
+    }
+    samples_to_render_double = absl::MakeConstSpan(projected_spans);
   } else {
     samples_to_render_double = input_samples;
   }
 
   int rendered_samples_index = 0;
+
   std::fill(rendered_samples.begin(), rendered_samples.end(), 0);
-  for (int t = 0; t < samples_to_render_double.size(); t++) {
-    for (int out_channel = 0; out_channel < gains[0].size(); out_channel++) {
-      for (int in_channel = 0; in_channel < samples_to_render_double[0].size();
-           in_channel++) {
+  const auto num_ticks = input_samples.empty() ? 0 : input_samples[0].size();
+  const auto num_in_channels = input_samples.size();
+  const auto num_out_channels = gains[0].size();
+  for (int t = 0; t < num_ticks; t++) {
+    for (int out_channel = 0; out_channel < num_out_channels; out_channel++) {
+      for (int in_channel = 0; in_channel < num_in_channels; in_channel++) {
         rendered_samples[rendered_samples_index] +=
-            samples_to_render_double[t][in_channel] *
+            samples_to_render_double[in_channel][t] *
             gains[in_channel][out_channel];
       }
-
       rendered_samples_index++;
     }
   }
@@ -223,6 +230,8 @@ void RenderSamplesUsingGains(
 
 }  // namespace
 
+// TODO(b/382197581): Avoid returning newly constructed vectors. Store the
+// results in a pre-allocated data structure.
 absl::StatusOr<std::vector<std::vector<double>>> LookupPrecomputedGains(
     absl::string_view input_key, absl::string_view output_key) {
   static const absl::NoDestructor<PrecomputedGains> precomputed_gains(
@@ -242,7 +251,7 @@ absl::StatusOr<std::vector<std::vector<double>>> LookupPrecomputedGains(
 }
 
 absl::Status RenderChannelLayoutToLoudspeakers(
-    absl::Span<const std::vector<InternalSampleType>>& input_samples,
+    absl::Span<const absl::Span<const InternalSampleType>> input_samples,
     const DownMixingParams& down_mixing_params,
     const std::vector<ChannelLabel::Label>& channel_labels,
     absl::string_view input_key, absl::string_view output_key,
@@ -265,7 +274,7 @@ absl::Status RenderChannelLayoutToLoudspeakers(
 }
 
 absl::Status RenderAmbisonicsToLoudspeakers(
-    absl::Span<const std::vector<InternalSampleType>>& input_samples,
+    absl::Span<const absl::Span<const InternalSampleType>> input_samples,
     const AmbisonicsConfig& ambisonics_config,
     const std::vector<std::vector<double>>& gains,
     std::vector<InternalSampleType>& rendered_samples) {
diff --git a/iamf/cli/renderer/loudspeakers_renderer.h b/iamf/cli/renderer/loudspeakers_renderer.h
index 41bece9..bbe949e 100644
--- a/iamf/cli/renderer/loudspeakers_renderer.h
+++ b/iamf/cli/renderer/loudspeakers_renderer.h
@@ -46,7 +46,7 @@ absl::StatusOr<std::vector<std::vector<double>>> LookupPrecomputedGains(
  * \return `absl::OkStatus()` on success. A specific status on failure.
  */
 absl::Status RenderChannelLayoutToLoudspeakers(
-    absl::Span<const std::vector<InternalSampleType>>& input_samples,
+    absl::Span<const absl::Span<const InternalSampleType>> input_samples,
     const DownMixingParams& down_mixing_params,
     const std::vector<ChannelLabel::Label>& channel_labels,
     absl::string_view input_key, absl::string_view output_key,
@@ -62,7 +62,7 @@ absl::Status RenderChannelLayoutToLoudspeakers(
  * \return `absl::OkStatus()` on success. A specific status on failure.
  */
 absl::Status RenderAmbisonicsToLoudspeakers(
-    absl::Span<const std::vector<InternalSampleType>>& input_samples,
+    absl::Span<const absl::Span<const InternalSampleType>> input_samples,
     const AmbisonicsConfig& ambisonics_config,
     const std::vector<std::vector<double>>& gains,
     std::vector<InternalSampleType>& rendered_samples);
diff --git a/iamf/cli/renderer/renderer_utils.cc b/iamf/cli/renderer/renderer_utils.cc
index a653366..d62b061 100644
--- a/iamf/cli/renderer/renderer_utils.cc
+++ b/iamf/cli/renderer/renderer_utils.cc
@@ -9,6 +9,8 @@
  * source code in the PATENTS file, you can obtain it at
  * www.aomedia.org/license/patent.
  */
+#include "iamf/cli/renderer/renderer_utils.h"
+
 #include <cstddef>
 #include <optional>
 #include <string>
@@ -20,6 +22,7 @@
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
+#include "absl/types/span.h"
 #include "iamf/cli/channel_label.h"
 #include "iamf/cli/demixing_module.h"
 #include "iamf/common/utils/macros.h"
@@ -38,28 +41,33 @@ namespace {
 // number of time ticks in the rendered audio after trimming.
 absl::StatusOr<size_t> GetCommonNumTrimmedTimeTicks(
     const LabeledFrame& labeled_frame,
-    const std::vector<ChannelLabel::Label>& ordered_labels) {
+    const std::vector<ChannelLabel::Label>& ordered_labels,
+    const std::vector<InternalSampleType>& empty_channel) {
   std::optional<size_t> num_raw_time_ticks;
   for (const auto& label : ordered_labels) {
     if (label == ChannelLabel::kOmitted) {
       continue;
     }
 
-    const std::vector<InternalSampleType>* samples_to_render = nullptr;
+    absl::Span<const InternalSampleType> samples_to_render;
     RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-        label, labeled_frame.label_to_samples, &samples_to_render));
-
-    if (samples_to_render == nullptr) {
-      return absl::InvalidArgumentError(
-          absl::StrCat("Label ", label, " or D_", label, " not found."));
-    } else if (!num_raw_time_ticks.has_value()) {
-      num_raw_time_ticks = samples_to_render->size();
-    } else if (*num_raw_time_ticks != samples_to_render->size()) {
+        label, labeled_frame.label_to_samples, samples_to_render));
+
+    if (!num_raw_time_ticks.has_value()) {
+      num_raw_time_ticks = samples_to_render.size();
+    } else if (*num_raw_time_ticks != samples_to_render.size()) {
       return absl::InvalidArgumentError(absl::StrCat(
           "All labels must have the same number of samples ", label, " (",
-          samples_to_render->size(), " vs. ", *num_raw_time_ticks, ")"));
+          samples_to_render.size(), " vs. ", *num_raw_time_ticks, ")"));
     }
   }
+  if (empty_channel.size() < *num_raw_time_ticks) {
+    return absl::InvalidArgumentError(absl::StrCat(
+        "`empty_channel` should contain at least as many samples as other "
+        "labels: (",
+        empty_channel.size(), " < ", *num_raw_time_ticks, ")"));
+  }
+
   if (*num_raw_time_ticks < (labeled_frame.samples_to_trim_at_start +
                              labeled_frame.samples_to_trim_at_end)) {
     return absl::InvalidArgumentError(absl::StrCat(
@@ -78,47 +86,37 @@ absl::StatusOr<size_t> GetCommonNumTrimmedTimeTicks(
 absl::Status ArrangeSamplesToRender(
     const LabeledFrame& labeled_frame,
     const std::vector<ChannelLabel::Label>& ordered_labels,
-    std::vector<std::vector<InternalSampleType>>& samples_to_render,
-    size_t& num_valid_samples) {
+    const std::vector<InternalSampleType>& empty_channel,
+    std::vector<absl::Span<const InternalSampleType>>& samples_to_render,
+    size_t& num_valid_ticks) {
   if (ordered_labels.empty()) {
     return absl::OkStatus();
   }
 
-  const auto common_num_trimmed_time_ticks =
-      GetCommonNumTrimmedTimeTicks(labeled_frame, ordered_labels);
+  const auto common_num_trimmed_time_ticks = GetCommonNumTrimmedTimeTicks(
+      labeled_frame, ordered_labels, empty_channel);
   if (!common_num_trimmed_time_ticks.ok()) {
     return common_num_trimmed_time_ticks.status();
   }
-  num_valid_samples = *common_num_trimmed_time_ticks;
+  num_valid_ticks = *common_num_trimmed_time_ticks;
 
   const auto num_channels = ordered_labels.size();
-  if (num_valid_samples > samples_to_render.size()) [[unlikely]] {
-    return absl::InvalidArgumentError(absl::StrCat(
-        "Number of time samples to render= ", num_valid_samples,
-        "does not fit into the output of size ", samples_to_render.size()));
-  }
+  for (int c = 0; c < num_channels; ++c) {
+    const auto& channel_label = ordered_labels[c];
+    absl::Span<const InternalSampleType> channel_samples;
 
-  for (int channel = 0; channel < num_channels; ++channel) {
-    const auto& channel_label = ordered_labels[channel];
     if (channel_label == ChannelLabel::kOmitted) {
       // Missing channels for mixed-order ambisonics representation will not be
-      // updated and will thus have the initialized zeros.
-      continue;
+      // updated. Point to the passed-in empty channel.
+      channel_samples = absl::MakeConstSpan(empty_channel);
+    } else {
+      RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
+          channel_label, labeled_frame.label_to_samples, channel_samples));
     }
 
-    const std::vector<InternalSampleType>* channel_samples = nullptr;
-    RETURN_IF_NOT_OK(DemixingModule::FindSamplesOrDemixedSamples(
-        channel_label, labeled_frame.label_to_samples, &channel_samples));
-    // The lookup should not fail because its presence was already checked in
-    // `GetCommonNumTrimmedTimeTicks`.
-    CHECK_NE(channel_samples, nullptr);
-
-    // Grab the entire time axes for this label, Skip over any samples that
-    // should be trimmed.
-    for (int time = 0; time < num_valid_samples; ++time) {
-      samples_to_render[time][channel] =
-          (*channel_samples)[time + labeled_frame.samples_to_trim_at_start];
-    }
+    // Return the valid portion after trimming.
+    samples_to_render[c] = channel_samples.subspan(
+        labeled_frame.samples_to_trim_at_start, num_valid_ticks);
   }
 
   return absl::OkStatus();
diff --git a/iamf/cli/renderer/renderer_utils.h b/iamf/cli/renderer/renderer_utils.h
index e2931e8..4dcac96 100644
--- a/iamf/cli/renderer/renderer_utils.h
+++ b/iamf/cli/renderer/renderer_utils.h
@@ -17,6 +17,7 @@
 
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
+#include "absl/types/span.h"
 #include "iamf/cli/channel_label.h"
 #include "iamf/cli/demixing_module.h"
 #include "iamf/obu/mix_presentation.h"
@@ -26,23 +27,26 @@ namespace iamf_tools {
 
 namespace renderer_utils {
 
-/*!\brief Arranges the samples to be rendered in (time, channel) axes.
+/*!\brief Arranges the samples to be rendered in (channel, time) axes.
  *
  * \param labeled_frame Labeled frame determine which original or demixed
  *        samples to trim and render.
- * \param ordered_labels Ordered list of original labels. Samples are arranged
- *        based on the original or demixed label samples in each time tick.
- *        Slots corresponding with `ChannelLabel::Label::kOmitted` will create
- *        zeroed-out samples.
- * \param samples_to_render Output samples to render in (time, channel) axes.
+ * \param ordered_labels Ordered list of original labels.
+ * \param empty_channel Vector of an all-zero channel. All output spans of
+ *        channels corresponding to missing labels
+ *        (`ChannelLabel::Label::kOmitted`) will point to this vector.
+ * \param samples_to_render Output samples to render in (channel, time) axes.
  *        Samples which should be trimmed are omitted from the output.
+ * \param num_valid_ticks Number of valid time ticks in the returned
+ *        `samples_to_render`, which is the length of the time-axis.
  * \return `absl::OkStatus()` on success. A specific status on failure.
  */
 absl::Status ArrangeSamplesToRender(
     const LabeledFrame& labeled_frame,
     const std::vector<ChannelLabel::Label>& ordered_labels,
-    std::vector<std::vector<InternalSampleType>>& samples_to_render,
-    size_t& num_valid_samples);
+    const std::vector<InternalSampleType>& empty_channel,
+    std::vector<absl::Span<const InternalSampleType>>& samples_to_render,
+    size_t& num_valid_ticks);
 
 /*!\brief Gets a key associated with the playback layout.
  *
diff --git a/iamf/cli/renderer/tests/BUILD b/iamf/cli/renderer/tests/BUILD
index 194f65d..893fa27 100644
--- a/iamf/cli/renderer/tests/BUILD
+++ b/iamf/cli/renderer/tests/BUILD
@@ -75,6 +75,21 @@ cc_test(
     ],
 )
 
+cc_test(
+    name = "renderer_utils_benchmark",
+    srcs = ["renderer_utils_benchmark.cc"],
+    deps = [
+        "//iamf/cli:channel_label",
+        "//iamf/cli:demixing_module",
+        "//iamf/cli/renderer:renderer_utils",
+        "//iamf/obu:types",
+        "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/random",
+        "@com_google_absl//absl/types:span",
+        "@com_google_benchmark//:benchmark_main",
+    ],
+)
+
 cc_test(
     name = "renderer_utils_test",
     srcs = ["renderer_utils_test.cc"],
diff --git a/iamf/cli/renderer/tests/audio_element_renderer_base_test.cc b/iamf/cli/renderer/tests/audio_element_renderer_base_test.cc
index 222a581..ec1e2a9 100644
--- a/iamf/cli/renderer/tests/audio_element_renderer_base_test.cc
+++ b/iamf/cli/renderer/tests/audio_element_renderer_base_test.cc
@@ -38,7 +38,7 @@ class MockAudioElementRenderer : public AudioElementRendererBase {
   MockAudioElementRenderer() : AudioElementRendererBase({}, 0, 0) {};
 
   absl::Status RenderSamples(
-      absl::Span<const std::vector<InternalSampleType>>,
+      absl::Span<const absl::Span<const InternalSampleType>>,
       std::vector<InternalSampleType>& rendered_samples) override {
     rendered_samples.insert(rendered_samples.end(), kSamplesToRender.begin(),
                             kSamplesToRender.end());
diff --git a/iamf/cli/renderer/tests/renderer_utils_benchmark.cc b/iamf/cli/renderer/tests/renderer_utils_benchmark.cc
new file mode 100644
index 0000000..40c5ad1
--- /dev/null
+++ b/iamf/cli/renderer/tests/renderer_utils_benchmark.cc
@@ -0,0 +1,178 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#include <algorithm>
+#include <cstddef>
+#include <cstdlib>
+#include <vector>
+
+#include "absl/log/check.h"
+#include "absl/random/random.h"
+#include "absl/types/span.h"
+#include "benchmark/benchmark.h"
+#include "iamf/cli/channel_label.h"
+#include "iamf/cli/demixing_module.h"
+#include "iamf/cli/renderer/renderer_utils.h"
+#include "iamf/obu/types.h"
+
+namespace iamf_tools {
+namespace renderer_utils {
+namespace {
+
+using enum ChannelLabel::Label;
+
+static std::vector<ChannelLabel::Label> CreateLabels(int num_channels) {
+  // This list includes all non-demixed labels.
+  static const std::vector<ChannelLabel::Label> kLabelsToPick = {
+      kOmitted,
+      // Mono channels.
+      kMono,
+      // Stereo or binaural channels.
+      kL2,
+      kR2,
+      // Centre channel common to several layouts (e.g. 3.1.2, 5.x.y, 7.x.y).
+      kCentre,
+      // LFE channel common to several layouts
+      // (e.g. 3.1.2, 5.1.y, 7.1.y, 9.1.6).
+      kLFE,
+      // 3.1.2 surround channels.
+      kL3,
+      kR3,
+      kLtf3,
+      kRtf3,
+      // 5.x.y surround channels.
+      kL5,
+      kR5,
+      kLs5,
+      kRs5,
+      // Common channels between 5.1.2 and 7.1.2.
+      kLtf2,
+      kRtf2,
+      // Common channels between 5.1.4 and 7.1.4.
+      kLtf4,
+      kRtf4,
+      kLtb4,
+      kRtb4,
+      // 7.x.y surround channels.
+      kL7,
+      kR7,
+      kLss7,
+      kRss7,
+      kLrs7,
+      kRrs7,
+      // 9.1.6 surround channels.
+      kFLc,
+      kFC,
+      kFRc,
+      kFL,
+      kFR,
+      kSiL,
+      kSiR,
+      kBL,
+      kBR,
+      kTpFL,
+      kTpFR,
+      kTpSiL,
+      kTpSiR,
+      kTpBL,
+      kTpBR,
+      // Ambisonics channels.
+      kA0,
+      kA1,
+      kA2,
+      kA3,
+      kA4,
+      kA5,
+      kA6,
+      kA7,
+      kA8,
+      kA9,
+      kA10,
+      kA11,
+      kA12,
+      kA13,
+      kA14,
+      kA15,
+      kA16,
+      kA17,
+      kA18,
+      kA19,
+      kA20,
+      kA21,
+      kA22,
+      kA23,
+      kA24,
+  };
+
+  // We cannot pick more labels than available ones.
+  CHECK_LE(num_channels, kLabelsToPick.size());
+
+  // Randomly pick `num_channels` from the list.
+  auto shuffled_labels = kLabelsToPick;
+  absl::BitGen gen;
+  for (int i = 0; i < num_channels; ++i) {
+    int j = absl::Uniform<int>(gen, i, num_channels);
+    std::swap(shuffled_labels[i], shuffled_labels[j]);
+  }
+  shuffled_labels.resize(num_channels);
+  return shuffled_labels;
+}
+
+static void BM_ArrangeSamplesToRender(benchmark::State& state) {
+  const int num_channels = state.range(0);
+  const int num_ticks = state.range(1);
+
+  // Create input ordered labels.
+  const std::vector<ChannelLabel::Label> ordered_labels =
+      CreateLabels(num_channels);
+
+  // Create input labeled frames.
+  LabeledFrame labeled_frame;
+  for (const auto label : ordered_labels) {
+    labeled_frame.samples_to_trim_at_start = 0;
+    labeled_frame.samples_to_trim_at_end = 0;
+    labeled_frame.label_to_samples[label] =
+        std::vector<InternalSampleType>(num_ticks);
+  }
+
+  // Create an input empty channel.
+  const std::vector<InternalSampleType> kEmptyChannel(num_ticks, 0.0);
+
+  // Placeholder for outputs.
+  std::vector<absl::Span<const InternalSampleType>> samples_to_render(
+      num_channels);
+  size_t num_valid_samples = 0;
+
+  // Measure the calls to `ArrangeSamplesToRender()`.
+  for (auto _ : state) {
+    auto status =
+        ArrangeSamplesToRender(labeled_frame, ordered_labels, kEmptyChannel,
+                               samples_to_render, num_valid_samples);
+    CHECK_OK(status);
+  }
+}
+
+// Benchmark various combinations of (#channels, #ticks).
+BENCHMARK(BM_ArrangeSamplesToRender)
+    ->Args({2, 1 << 4})
+    ->Args({2, 1 << 8})
+    ->Args({2, 1 << 12})
+    ->Args({8, 1 << 4})
+    ->Args({8, 1 << 8})
+    ->Args({8, 1 << 12})
+    ->Args({32, 1 << 4})
+    ->Args({32, 1 << 8})
+    ->Args({32, 1 << 12});
+
+}  // namespace
+}  // namespace renderer_utils
+}  // namespace iamf_tools
diff --git a/iamf/cli/renderer/tests/renderer_utils_test.cc b/iamf/cli/renderer/tests/renderer_utils_test.cc
index 3566dca..7c8507c 100644
--- a/iamf/cli/renderer/tests/renderer_utils_test.cc
+++ b/iamf/cli/renderer/tests/renderer_utils_test.cc
@@ -33,71 +33,68 @@ using enum ChannelLabel::Label;
 using testing::DoubleEq;
 using testing::Pointwise;
 
-constexpr size_t kNumSamplesPerFrame = 8;
-
 TEST(ArrangeSamplesToRender, SucceedsOnEmptyFrame) {
-  std::vector<std::vector<InternalSampleType>> samples(
-      kNumSamplesPerFrame, std::vector<InternalSampleType>(0));
+  constexpr size_t kNumChannels = 2;
+  std::vector<absl::Span<const InternalSampleType>> samples(kNumChannels);
   size_t num_valid_samples = 0;
-  EXPECT_THAT(ArrangeSamplesToRender({}, {}, samples, num_valid_samples),
+  EXPECT_THAT(ArrangeSamplesToRender({}, {}, {}, samples, num_valid_samples),
               IsOk());
 
-  // `samples` remains the same size, but `num_valid_samples` is zero.
-  EXPECT_EQ(samples.size(), kNumSamplesPerFrame);
+  // `samples` remains the same size (number of channels), but
+  // `num_valid_samples` is zero.
+  EXPECT_EQ(samples.size(), kNumChannels);
   EXPECT_EQ(num_valid_samples, 0);
 }
 
-TEST(ArrangeSamplesToRender, ArrangesSamplesInTimeChannelAxes) {
+TEST(ArrangeSamplesToRender, ArrangesSamplesInChannelTimeAxes) {
   const LabeledFrame kStereoLabeledFrame = {
       .label_to_samples = {{kL2, {0, 1, 2}}, {kR2, {10, 11, 12}}}};
   const std::vector<ChannelLabel::Label> kStereoArrangement = {kL2, kR2};
+  const std::vector<InternalSampleType> kEmptyChannel(3, 0.0);
 
-  std::vector<std::vector<InternalSampleType>> samples(
-      kNumSamplesPerFrame,
-      std::vector<InternalSampleType>(kStereoArrangement.size()));
+  std::vector<absl::Span<const InternalSampleType>> samples(
+      kStereoArrangement.size());
   size_t num_valid_samples = 0;
   EXPECT_THAT(ArrangeSamplesToRender(kStereoLabeledFrame, kStereoArrangement,
-                                     samples, num_valid_samples),
+                                     kEmptyChannel, samples, num_valid_samples),
               IsOk());
-  EXPECT_THAT(absl::MakeConstSpan(samples).first(num_valid_samples),
-              testing::ElementsAreArray({Pointwise(DoubleEq(), {0.0, 10.0}),
-                                         Pointwise(DoubleEq(), {1.0, 11.0}),
-                                         Pointwise(DoubleEq(), {2.0, 12.0})}));
+  EXPECT_THAT(samples,
+              testing::ElementsAre(Pointwise(DoubleEq(), {0.0, 1.0, 2.0}),
+                                   Pointwise(DoubleEq(), {10.0, 11.0, 12.0})));
 }
 
 TEST(ArrangeSamplesToRender, FindsDemixedLabels) {
   const LabeledFrame kDemixedTwoLayerStereoFrame = {
       .label_to_samples = {{kMono, {75}}, {kL2, {50}}, {kDemixedR2, {100}}}};
   const std::vector<ChannelLabel::Label> kStereoArrangement = {kL2, kR2};
+  const std::vector<InternalSampleType> kEmptyChannel(1, 0.0);
 
-  std::vector<std::vector<InternalSampleType>> samples(
-      kNumSamplesPerFrame,
-      std::vector<InternalSampleType>(kStereoArrangement.size()));
+  std::vector<absl::Span<const InternalSampleType>> samples(
+      kStereoArrangement.size());
   size_t num_valid_samples = 0;
   EXPECT_THAT(
       ArrangeSamplesToRender(kDemixedTwoLayerStereoFrame, kStereoArrangement,
-                             samples, num_valid_samples),
+                             kEmptyChannel, samples, num_valid_samples),
       IsOk());
-  EXPECT_THAT(
-      absl::MakeConstSpan(samples).first(num_valid_samples),
-      testing::ElementsAreArray({Pointwise(DoubleEq(), {50.0, 100.0})}));
+  EXPECT_THAT(samples, testing::ElementsAre(Pointwise(DoubleEq(), {50.0}),
+                                            Pointwise(DoubleEq(), {100.0})));
 }
 
 TEST(ArrangeSamplesToRender, IgnoresExtraLabels) {
   const LabeledFrame kStereoLabeledFrameWithExtraLabel = {
       .label_to_samples = {{kL2, {0}}, {kR2, {10}}, {kLFE, {999}}}};
   const std::vector<ChannelLabel::Label> kStereoArrangement = {kL2, kR2};
+  const std::vector<InternalSampleType> kEmptyChannel(1, 0.0);
 
-  std::vector<std::vector<InternalSampleType>> samples(
-      kNumSamplesPerFrame,
-      std::vector<InternalSampleType>(kStereoArrangement.size()));
+  std::vector<absl::Span<const InternalSampleType>> samples(
+      kStereoArrangement.size());
   size_t num_valid_samples = 0;
-  EXPECT_THAT(
-      ArrangeSamplesToRender(kStereoLabeledFrameWithExtraLabel,
-                             kStereoArrangement, samples, num_valid_samples),
-      IsOk());
-  EXPECT_THAT(absl::MakeConstSpan(samples).first(num_valid_samples),
-              testing::ElementsAreArray({Pointwise(DoubleEq(), {0.0, 10.0})}));
+  EXPECT_THAT(ArrangeSamplesToRender(kStereoLabeledFrameWithExtraLabel,
+                                     kStereoArrangement, kEmptyChannel, samples,
+                                     num_valid_samples),
+              IsOk());
+  EXPECT_THAT(samples, testing::ElementsAre(Pointwise(DoubleEq(), {0.0}),
+                                            Pointwise(DoubleEq(), {10.0})));
 }
 
 TEST(ArrangeSamplesToRender, LeavesOmittedLabelsZeroForMixedOrderAmbisonics) {
@@ -106,38 +103,39 @@ TEST(ArrangeSamplesToRender, LeavesOmittedLabelsZeroForMixedOrderAmbisonics) {
           {kA0, {1, 2}}, {kA2, {201, 202}}, {kA3, {301, 302}}}};
   const std::vector<ChannelLabel::Label> kMixedFirstOrderAmbisonicsArrangement =
       {kA0, kOmitted, kA2, kA3};
+  const std::vector<InternalSampleType> kEmptyChannel(2, 0.0);
 
-  std::vector<std::vector<InternalSampleType>> samples(
-      kNumSamplesPerFrame, std::vector<InternalSampleType>(
-                               kMixedFirstOrderAmbisonicsArrangement.size()));
+  std::vector<absl::Span<const InternalSampleType>> samples(
+      kMixedFirstOrderAmbisonicsArrangement.size());
   size_t num_valid_samples = 0;
   EXPECT_THAT(ArrangeSamplesToRender(kMixedFirstOrderAmbisonicsFrame,
                                      kMixedFirstOrderAmbisonicsArrangement,
-                                     samples, num_valid_samples),
+                                     kEmptyChannel, samples, num_valid_samples),
               IsOk());
-  EXPECT_THAT(absl::MakeConstSpan(samples).first(num_valid_samples),
-              testing::ElementsAreArray(
-                  {Pointwise(DoubleEq(), {1.0, 0.0, 201.0, 301.0}),
-                   Pointwise(DoubleEq(), {2.0, 0.0, 202.0, 302.0})}));
+  EXPECT_THAT(samples,
+              testing::ElementsAre(Pointwise(DoubleEq(), {1.0, 2.0}),
+                                   Pointwise(DoubleEq(), {0.0, 0.0}),
+                                   Pointwise(DoubleEq(), {201.0, 202.0}),
+                                   Pointwise(DoubleEq(), {301.0, 302.0})));
 }
 
 TEST(ArrangeSamplesToRender, LeavesOmittedLabelsZeroForChannelBasedLayout) {
   const LabeledFrame kLFEOnlyFrame = {.label_to_samples = {{kLFE, {1, 2}}}};
   const std::vector<ChannelLabel::Label> kLFEAsSecondChannelArrangement = {
       kOmitted, kOmitted, kLFE, kOmitted};
+  const std::vector<InternalSampleType> kEmptyChannel(2, 0.0);
 
-  std::vector<std::vector<InternalSampleType>> samples(
-      kNumSamplesPerFrame,
-      std::vector<InternalSampleType>(kLFEAsSecondChannelArrangement.size()));
+  std::vector<absl::Span<const InternalSampleType>> samples(
+      kLFEAsSecondChannelArrangement.size());
   size_t num_valid_samples = 0;
   EXPECT_THAT(
       ArrangeSamplesToRender(kLFEOnlyFrame, kLFEAsSecondChannelArrangement,
-                             samples, num_valid_samples),
+                             kEmptyChannel, samples, num_valid_samples),
       IsOk());
-  EXPECT_THAT(
-      absl::MakeConstSpan(samples).first(num_valid_samples),
-      testing::ElementsAreArray({Pointwise(DoubleEq(), {0.0, 0.0, 1.0, 0.0}),
-                                 Pointwise(DoubleEq(), {0.0, 0.0, 2.0, 0.0})}));
+  EXPECT_THAT(samples, testing::ElementsAre(Pointwise(DoubleEq(), {0.0, 0.0}),
+                                            Pointwise(DoubleEq(), {0.0, 0.0}),
+                                            Pointwise(DoubleEq(), {1.0, 2.0}),
+                                            Pointwise(DoubleEq(), {0.0, 0.0})));
 }
 
 TEST(ArrangeSamplesToRender, ExcludesSamplesToBeTrimmed) {
@@ -146,50 +144,53 @@ TEST(ArrangeSamplesToRender, ExcludesSamplesToBeTrimmed) {
       .samples_to_trim_at_start = 1,
       .label_to_samples = {{kMono, {999, 100, 999, 999}}}};
   const std::vector<ChannelLabel::Label> kMonoArrangement = {kMono};
+  const std::vector<InternalSampleType> kEmptyChannel(4, 0.0);
 
-  std::vector<std::vector<InternalSampleType>> samples(
-      kNumSamplesPerFrame,
-      std::vector<InternalSampleType>(kMonoArrangement.size()));
+  std::vector<absl::Span<const InternalSampleType>> samples(
+      kMonoArrangement.size());
   size_t num_valid_samples = 0;
-  EXPECT_THAT(
-      ArrangeSamplesToRender(kMonoLabeledFrameWithSamplesToTrim,
-                             kMonoArrangement, samples, num_valid_samples),
-      IsOk());
-  EXPECT_THAT(absl::MakeConstSpan(samples).first(num_valid_samples),
-              testing::ElementsAreArray({Pointwise(DoubleEq(), {100.0})}));
+  EXPECT_THAT(ArrangeSamplesToRender(kMonoLabeledFrameWithSamplesToTrim,
+                                     kMonoArrangement, kEmptyChannel, samples,
+                                     num_valid_samples),
+              IsOk());
+  EXPECT_THAT(samples, testing::ElementsAre(Pointwise(DoubleEq(), {100.0})));
 }
 
 TEST(ArrangeSamplesToRender, OverwritesInputVector) {
   const LabeledFrame kMonoLabeledFrame = {
       .label_to_samples = {{kMono, {1, 2}}}};
   const std::vector<ChannelLabel::Label> kMonoArrangement = {kMono};
+  const std::vector<InternalSampleType> kEmptyChannel(2, 0.0);
 
-  std::vector<std::vector<InternalSampleType>> samples = {{999}, {999}};
+  const std::vector<InternalSampleType> original_input_samples = {999, 999};
+  std::vector<absl::Span<const InternalSampleType>> samples = {
+      absl::MakeConstSpan(original_input_samples)};
   size_t num_valid_samples = 0;
   EXPECT_THAT(ArrangeSamplesToRender(kMonoLabeledFrame, kMonoArrangement,
-                                     samples, num_valid_samples),
+                                     kEmptyChannel, samples, num_valid_samples),
               IsOk());
-  EXPECT_THAT(absl::MakeConstSpan(samples).first(num_valid_samples),
-              testing::ElementsAreArray({Pointwise(DoubleEq(), {1.0}),
-                                         Pointwise(DoubleEq(), {2.0})}));
+  EXPECT_THAT(samples, testing::ElementsAre(Pointwise(DoubleEq(), {1.0, 2.0})));
 }
 
-TEST(ArrangeSamplesToRender, TrimmingAllFramesFromStartIsResultsInEmptyOutput) {
+TEST(ArrangeSamplesToRender,
+     TrimmingAllFramesFromStartIsResultsInEmptyChannels) {
   const LabeledFrame kMonoLabeledFrameWithSamplesToTrim = {
       .samples_to_trim_at_end = 0,
       .samples_to_trim_at_start = 4,
       .label_to_samples = {{kMono, {999, 999, 999, 999}}}};
   const std::vector<ChannelLabel::Label> kMonoArrangement = {kMono};
+  const std::vector<InternalSampleType> kEmptyChannel(4, 0.0);
 
-  std::vector<std::vector<InternalSampleType>> samples(
-      kNumSamplesPerFrame,
-      std::vector<InternalSampleType>(kMonoArrangement.size()));
+  std::vector<absl::Span<const InternalSampleType>> samples(
+      kMonoArrangement.size());
   size_t num_valid_samples = 0;
-  EXPECT_THAT(
-      ArrangeSamplesToRender(kMonoLabeledFrameWithSamplesToTrim,
-                             kMonoArrangement, samples, num_valid_samples),
-      IsOk());
-  EXPECT_TRUE(absl::MakeConstSpan(samples).first(num_valid_samples).empty());
+  EXPECT_THAT(ArrangeSamplesToRender(kMonoLabeledFrameWithSamplesToTrim,
+                                     kMonoArrangement, kEmptyChannel, samples,
+                                     num_valid_samples),
+              IsOk());
+  for (const auto& channel : samples) {
+    EXPECT_TRUE(channel.empty());
+  }
 }
 
 TEST(ArrangeSamplesToRender,
@@ -197,13 +198,30 @@ TEST(ArrangeSamplesToRender,
   const LabeledFrame kStereoLabeledFrameWithMissingSample = {
       .label_to_samples = {{kL2, {0, 1}}, {kR2, {10}}}};
   const std::vector<ChannelLabel::Label> kStereoArrangement = {kL2, kR2};
+  const std::vector<InternalSampleType> kEmptyChannel(2, 0.0);
 
-  std::vector<std::vector<InternalSampleType>> samples(
-      kNumSamplesPerFrame,
-      std::vector<InternalSampleType>(kStereoArrangement.size()));
+  std::vector<absl::Span<const InternalSampleType>> samples(
+      kStereoArrangement.size());
   size_t num_valid_samples = 0;
   EXPECT_FALSE(ArrangeSamplesToRender(kStereoLabeledFrameWithMissingSample,
-                                      kStereoArrangement, samples,
+                                      kStereoArrangement, kEmptyChannel,
+                                      samples, num_valid_samples)
+                   .ok());
+}
+
+TEST(ArrangeSamplesToRender, InvalidWhenEmptyChannelHasTooFewSamples) {
+  const LabeledFrame kStereoLabeledFrame = {
+      .label_to_samples = {{kL2, {0, 1}}, {kR2, {10, 11}}}};
+  const std::vector<ChannelLabel::Label> kStereoArrangement = {kL2, kR2};
+
+  // Other labels have two samples, but the empty channel has only one.
+  const std::vector<InternalSampleType> kEmptyChannelWithTooManySamples(1, 0.0);
+
+  std::vector<absl::Span<const InternalSampleType>> samples(
+      kStereoArrangement.size());
+  size_t num_valid_samples = 0;
+  EXPECT_FALSE(ArrangeSamplesToRender(kStereoLabeledFrame, kStereoArrangement,
+                                      kEmptyChannelWithTooManySamples, samples,
                                       num_valid_samples)
                    .ok());
 }
@@ -214,14 +232,14 @@ TEST(ArrangeSamplesToRender, InvalidWhenTrimIsImplausible) {
       .samples_to_trim_at_start = 2,
       .label_to_samples = {{kL2, {0, 1}}, {kR2, {10, 11}}}};
   const std::vector<ChannelLabel::Label> kStereoArrangement = {kL2, kR2};
+  const std::vector<InternalSampleType> kEmptyChannel(2, 0.0);
 
-  std::vector<std::vector<InternalSampleType>> samples(
-      kNumSamplesPerFrame,
-      std::vector<InternalSampleType>(kStereoArrangement.size()));
+  std::vector<absl::Span<const InternalSampleType>> samples(
+      kStereoArrangement.size());
   size_t num_valid_samples = 0;
   EXPECT_FALSE(ArrangeSamplesToRender(kFrameWithExcessSamplesTrimmed,
-                                      kStereoArrangement, samples,
-                                      num_valid_samples)
+                                      kStereoArrangement, kEmptyChannel,
+                                      samples, num_valid_samples)
                    .ok());
 }
 
@@ -229,13 +247,14 @@ TEST(ArrangeSamplesToRender, InvalidMissingLabel) {
   const LabeledFrame kStereoLabeledFrame = {
       .label_to_samples = {{kL2, {0}}, {kR2, {10}}}};
   const std::vector<ChannelLabel::Label> kMonoArrangement = {kMono};
+  const std::vector<InternalSampleType> kEmptyChannel(1, 0.0);
 
-  std::vector<std::vector<InternalSampleType>> unused_samples(
-      kNumSamplesPerFrame,
-      std::vector<InternalSampleType>(kMonoArrangement.size()));
+  std::vector<absl::Span<const InternalSampleType>> unused_samples(
+      kMonoArrangement.size());
   size_t num_valid_samples = 0;
   EXPECT_FALSE(ArrangeSamplesToRender(kStereoLabeledFrame, kMonoArrangement,
-                                      unused_samples, num_valid_samples)
+                                      kEmptyChannel, unused_samples,
+                                      num_valid_samples)
                    .ok());
 }
 
diff --git a/iamf/cli/rendering_mix_presentation_finalizer.cc b/iamf/cli/rendering_mix_presentation_finalizer.cc
index 9fce5fa..6268b68 100644
--- a/iamf/cli/rendering_mix_presentation_finalizer.cc
+++ b/iamf/cli/rendering_mix_presentation_finalizer.cc
@@ -407,7 +407,7 @@ absl::Status RenderAllFramesForLayout(
     const std::list<ParameterBlockWithData>& parameter_blocks,
     const uint32_t common_sample_rate,
     std::vector<std::vector<int32_t>>& rendered_samples,
-    absl::Span<const std::vector<int32_t>>& valid_rendered_samples) {
+    std::vector<absl::Span<const int32_t>>& valid_rendered_samples) {
   // Each audio element rendered individually with `element_mix_gain` applied.
   std::vector<std::vector<InternalSampleType>> rendered_audio_elements(
       sub_mix_audio_elements.size());
@@ -445,14 +445,15 @@ absl::Status RenderAllFramesForLayout(
                          linear_mix_gain_per_tick, rendered_samples_internal));
 
   // Convert the rendered samples to int32, clipping if needed.
-  size_t num_ticks = 0;
-  RETURN_IF_NOT_OK(ConvertInterleavedToTimeChannel(
+  RETURN_IF_NOT_OK(ConvertInterleavedToChannelTime(
       absl::MakeConstSpan(rendered_samples_internal), num_channels,
       absl::AnyInvocable<absl::Status(InternalSampleType, int32_t&) const>(
           NormalizedFloatingPointToInt32<InternalSampleType>),
-      rendered_samples, num_ticks));
-  valid_rendered_samples =
-      absl::MakeConstSpan(rendered_samples).first(num_ticks);
+      rendered_samples));
+  valid_rendered_samples.resize(rendered_samples.size());
+  for (int c = 0; c < rendered_samples.size(); ++c) {
+    valid_rendered_samples[c] = absl::MakeConstSpan(rendered_samples[c]);
+  }
   return absl::OkStatus();
 }
 
@@ -590,7 +591,7 @@ absl::Status GenerateRenderingMetadataForLayouts(
 // loudness calculator.
 absl::Status GenerateRenderingMetadataForSubmixes(
     const RendererFactoryBase& renderer_factory,
-    absl::Nullable<const LoudnessCalculatorFactoryBase*>
+    const LoudnessCalculatorFactoryBase* /* absl_nullable */
         loudness_calculator_factory,
     const RenderingMixPresentationFinalizer::SampleProcessorFactory&
         sample_processor_factory,
@@ -717,20 +718,21 @@ absl::Status RenderWriteAndCalculateLoudnessForTemporalUnit(
           submix_rendering_metadata.common_sample_rate,
           layout_rendering_metadata.rendered_samples,
           layout_rendering_metadata.valid_rendered_samples));
+      auto span_of_valid_rendered_samples =
+          absl::MakeSpan(layout_rendering_metadata.valid_rendered_samples);
 
       // Calculate loudness based on the original rendered samples; we do not
       // know what post-processing the end user will have.
       if (layout_rendering_metadata.loudness_calculator != nullptr) {
         RETURN_IF_NOT_OK(
             layout_rendering_metadata.loudness_calculator
-                ->AccumulateLoudnessForSamples(
-                    layout_rendering_metadata.valid_rendered_samples));
+                ->AccumulateLoudnessForSamples(span_of_valid_rendered_samples));
       }
 
       // Perform any post-processing.
       if (layout_rendering_metadata.sample_processor != nullptr) {
         RETURN_IF_NOT_OK(layout_rendering_metadata.sample_processor->PushFrame(
-            layout_rendering_metadata.valid_rendered_samples));
+            span_of_valid_rendered_samples));
       }
     }
   }
@@ -776,8 +778,8 @@ GetRenderedSamplesAndPostProcessor(
 
 absl::StatusOr<RenderingMixPresentationFinalizer>
 RenderingMixPresentationFinalizer::Create(
-    absl::Nullable<const RendererFactoryBase*> renderer_factory,
-    absl::Nullable<const LoudnessCalculatorFactoryBase*>
+    const RendererFactoryBase* /* absl_nullable */ renderer_factory,
+    const LoudnessCalculatorFactoryBase* /* absl_nullable */
         loudness_calculator_factory,
     const absl::flat_hash_map<uint32_t, AudioElementWithData>& audio_elements,
     const SampleProcessorFactory& sample_processor_factory,
@@ -845,7 +847,7 @@ absl::Status RenderingMixPresentationFinalizer::PushTemporalUnit(
   return absl::OkStatus();
 }
 
-absl::StatusOr<absl::Span<const std::vector<int32_t>>>
+absl::StatusOr<absl::Span<const absl::Span<const int32_t>>>
 RenderingMixPresentationFinalizer::GetPostProcessedSamplesAsSpan(
     DecodedUleb128 mix_presentation_id, size_t sub_mix_index,
     size_t layout_index) const {
@@ -863,7 +865,8 @@ RenderingMixPresentationFinalizer::GetPostProcessedSamplesAsSpan(
   return (*layout_rendering_metadata)->sample_processor != nullptr
              ? (*layout_rendering_metadata)
                    ->sample_processor->GetOutputSamplesAsSpan()
-             : (*layout_rendering_metadata)->valid_rendered_samples;
+             : absl::MakeSpan(
+                   (*layout_rendering_metadata)->valid_rendered_samples);
 }
 
 absl::Status RenderingMixPresentationFinalizer::FinalizePushingTemporalUnits() {
diff --git a/iamf/cli/rendering_mix_presentation_finalizer.h b/iamf/cli/rendering_mix_presentation_finalizer.h
index 331560c..8c81270 100644
--- a/iamf/cli/rendering_mix_presentation_finalizer.h
+++ b/iamf/cli/rendering_mix_presentation_finalizer.h
@@ -100,8 +100,10 @@ class RenderingMixPresentationFinalizer {
 
     // Reusable buffer for storing rendered samples.
     std::vector<std::vector<int32_t>> rendered_samples;
-    // A view into the valid portion of `rendered_samples`.
-    absl::Span<const std::vector<int32_t>> valid_rendered_samples;
+
+    // Vector of views into the valid portions of the channels in
+    // `rendered_samples`.
+    std::vector<absl::Span<const int32_t>> valid_rendered_samples;
   };
 
   // We need to store rendering metadata for each submix, layout, and audio
@@ -173,8 +175,8 @@ class RenderingMixPresentationFinalizer {
    * \return `absl::OkStatus()` on success. A specific status on failure.
    */
   static absl::StatusOr<RenderingMixPresentationFinalizer> Create(
-      absl::Nullable<const RendererFactoryBase*> renderer_factory,
-      absl::Nullable<const LoudnessCalculatorFactoryBase*>
+      const RendererFactoryBase* /* absl_nullable */ renderer_factory,
+      const LoudnessCalculatorFactoryBase* /* absl_nullable */
           loudness_calculator_factory,
       const absl::flat_hash_map<uint32_t, AudioElementWithData>& audio_elements,
       const SampleProcessorFactory& sample_processor_factory,
@@ -234,7 +236,7 @@ class RenderingMixPresentationFinalizer {
    * \param Post-processed samples, or rendered samples if no post-processor is
    *        available. A specific status on failure.
    */
-  absl::StatusOr<absl::Span<const std::vector<int32_t>>>
+  absl::StatusOr<absl::Span<const absl::Span<const int32_t>>>
   GetPostProcessedSamplesAsSpan(DecodedUleb128 mix_presentation_id,
                                 size_t sub_mix_index,
                                 size_t layout_index) const;
diff --git a/iamf/cli/sample_processor_base.cc b/iamf/cli/sample_processor_base.cc
index 87788ff..2fa6f27 100644
--- a/iamf/cli/sample_processor_base.cc
+++ b/iamf/cli/sample_processor_base.cc
@@ -17,38 +17,36 @@
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/types/span.h"
+#include "iamf/common/utils/macros.h"
+#include "iamf/common/utils/validation_utils.h"
 
 namespace iamf_tools {
 
 SampleProcessorBase::~SampleProcessorBase() {};
 
 absl::Status SampleProcessorBase::PushFrame(
-    absl::Span<const std::vector<int32_t>> time_channel_samples) {
+    absl::Span<const absl::Span<const int32_t>> channel_time_samples) {
   if (state_ != State::kTakingSamples) {
     return absl::FailedPreconditionError(absl::StrCat(
         "Do not use PushFrame() after Flush() is called. State= ", state_));
   }
 
   // Check the shape of the input data.
-  if (time_channel_samples.size() > max_input_samples_per_frame_) {
-    return absl::InvalidArgumentError(
-        "Too many samples per frame. The maximum number of samples per frame "
-        "is: " +
-        absl::StrCat(max_input_samples_per_frame_) +
-        ". The number of samples per frame received is: " +
-        absl::StrCat(time_channel_samples.size()));
-  }
-  for (const auto& channel_samples : time_channel_samples) {
-    if (channel_samples.size() != num_channels_) {
-      return absl::InvalidArgumentError(absl::StrCat(
-          "Number of channels does not match the expected number of channels, "
-          "num_channels_",
-          num_channels_, " vs. ", channel_samples.size()));
+  RETURN_IF_NOT_OK(ValidateEqual(channel_time_samples.size(), num_channels_,
+                                 "number of channels"));
+  for (int c = 0; c < num_channels_; c++) {
+    if (channel_time_samples[c].size() > max_input_samples_per_frame_) {
+      return absl::InvalidArgumentError(
+          absl::StrCat("Too many samples per frame. ",
+                       "The maximum number of samples per frame is: ",
+                       max_input_samples_per_frame_,
+                       ". The number of samples per frame received is: ",
+                       channel_time_samples[c].size()));
     }
+    output_channel_time_samples_[c].resize(0);
   }
 
-  num_valid_ticks_ = 0;
-  return PushFrameDerived(time_channel_samples);
+  return PushFrameDerived(channel_time_samples);
 }
 
 absl::Status SampleProcessorBase::Flush() {
@@ -58,14 +56,20 @@ absl::Status SampleProcessorBase::Flush() {
   }
 
   state_ = State::kFlushCalled;
-  num_valid_ticks_ = 0;
+  for (int c = 0; c < num_channels_; c++) {
+    output_channel_time_samples_[c].resize(0);
+  }
   return FlushDerived();
 }
 
-absl::Span<const std::vector<int32_t>>
-SampleProcessorBase::GetOutputSamplesAsSpan() const {
-  return absl::MakeConstSpan(output_time_channel_samples_)
-      .first(num_valid_ticks_);
+absl::Span<const absl::Span<const int32_t>>
+SampleProcessorBase::GetOutputSamplesAsSpan() {
+  for (int c = 0; c < output_channel_time_samples_.size(); c++) {
+    output_span_buffer_[c] =
+        absl::MakeConstSpan(output_channel_time_samples_[c]);
+  }
+
+  return absl::MakeSpan(output_span_buffer_);
 }
 
 }  // namespace iamf_tools
diff --git a/iamf/cli/sample_processor_base.h b/iamf/cli/sample_processor_base.h
index 0821b74..4b387bd 100644
--- a/iamf/cli/sample_processor_base.h
+++ b/iamf/cli/sample_processor_base.h
@@ -53,20 +53,25 @@ class SampleProcessorBase {
                       size_t max_output_samples_per_frame)
       : max_input_samples_per_frame_(max_input_samples_per_frame),
         num_channels_(num_channels),
-        output_time_channel_samples_(max_output_samples_per_frame,
-                                     std::vector<int32_t>(num_channels)) {}
+        output_channel_time_samples_(num_channels),
+        output_span_buffer_(num_channels) {
+    for (int c = 0; c < num_channels; c++) {
+      output_channel_time_samples_[c].reserve(max_input_samples_per_frame_);
+      output_span_buffer_[c] = absl::MakeSpan(output_channel_time_samples_[c]);
+    }
+  }
 
   /*!\brief Destructor. */
   virtual ~SampleProcessorBase() = 0;
 
   /*!\brief Pushes a frame of samples to the processor.
    *
-   * \param time_channel_samples Samples to push arranged in (time, channel).
+   * \param channel_time_samples Samples to push arranged in (channel, time).
    * \return `absl::OkStatus()` on success. `absl::FailedPreconditionError` if
    *         called after `Flush()`. Other specific statuses on failure.
    */
   absl::Status PushFrame(
-      absl::Span<const std::vector<int32_t>> time_channel_samples);
+      absl::Span<const absl::Span<const int32_t>> channel_time_samples);
 
   /*!\brief Signals to close the processor and flush any remaining samples.
    *
@@ -83,16 +88,16 @@ class SampleProcessorBase {
    * \return Span of the output samples. The span will be invalidated when
    *         `PushFrame()` or `Flush()` is called.
    */
-  absl::Span<const std::vector<int32_t>> GetOutputSamplesAsSpan() const;
+  absl::Span<const absl::Span<const int32_t>> GetOutputSamplesAsSpan();
 
  protected:
   /*!\brief Pushes a frame of samples to the processor.
    *
-   * \param time_channel_samples Samples to push arranged in (time, channel).
+   * \param channel_time_samples Samples to push arranged in (channel, time).
    * \return `absl::OkStatus()` on success. A specific status on failure.
    */
   virtual absl::Status PushFrameDerived(
-      absl::Span<const std::vector<int32_t>> time_channel_samples) = 0;
+      absl::Span<const absl::Span<const int32_t>> channel_time_samples) = 0;
 
   /*!\brief Signals to close the processor and flush any remaining samples.
    *
@@ -103,16 +108,16 @@ class SampleProcessorBase {
   const size_t max_input_samples_per_frame_;
   const size_t num_channels_;
 
-  // Stores the output decoded frames arranged in (time, sample) axes. That
+  // Stores the output decoded frames arranged in (channel, time) axes. That
   // is to say, each inner vector has one sample for per channel and the outer
   // vector contains one inner vector for each time tick. When the decoded
-  // samples is shorter than a frame, only the first `num_valid_ticks_` ticks
-  // should be used.
-  std::vector<std::vector<int32_t>> output_time_channel_samples_;
+  // samples is shorter than a frame, the inner vector will be resized to fit
+  // the actual length.
+  std::vector<std::vector<int32_t>> output_channel_time_samples_;
 
-  // Number of ticks (time samples) in `output_time_channel_samples_` that are
-  // valid.
-  size_t num_valid_ticks_ = 0;
+  // Buffer backing the spans of output samples returned by
+  // `GetOutputSamplesAsSpan()`.
+  std::vector<absl::Span<const int32_t>> output_span_buffer_;
 
  private:
   enum class State {
diff --git a/iamf/cli/temporal_unit_view.cc b/iamf/cli/temporal_unit_view.cc
index f234c56..2576bd3 100644
--- a/iamf/cli/temporal_unit_view.cc
+++ b/iamf/cli/temporal_unit_view.cc
@@ -147,8 +147,7 @@ absl::Status ValidateAllArbitraryObusMatchStatistics(
   for (const auto* arbitrary_obu : arbitrary_obus) {
     RETURN_IF_NOT_OK(ValidateNotNull(arbitrary_obu, "`arbitrary_obu`"));
     RETURN_IF_NOT_OK(ValidateEqual(
-        *arbitrary_obu->insertion_tick_,
-        static_cast<int64_t>(statistics.start_timestamp),
+        *arbitrary_obu->insertion_tick_, statistics.start_timestamp,
         "`insertion_tick` must be the same for  all arbitrary OBUs"));
   }
   return absl::OkStatus();
diff --git a/iamf/cli/testdata/README.md b/iamf/cli/testdata/README.md
index a970234..be25b27 100644
--- a/iamf/cli/testdata/README.md
+++ b/iamf/cli/testdata/README.md
@@ -83,7 +83,7 @@ Sound System B (0+5+0)  | ITU-2051-3               | L, R, C, LFE, Ls, Rs
 Sound System C (2+5+0)  | ITU-2051-3               | L, R, C, LFE, Ls, Rs, Ltf, Rtf
 Sound System D (4+5+0)  | ITU-2051-3               | L, R, C, LFE, Ls, Rs, Ltf, Rtf, Ltr, Rtr
 Sound System E (4+5+1)  | ITU-2051-3               | L, R, C, LFE, Ls, Rs, Ltf, Rtf, Ltr, Rtr, Cbf
-Sound System F (3+7+0)  | ITU-2051-3               | C, L, R, LH, RH, LS, LB, RB, CH, LFE1, LFE2
+Sound System F (3+7+0)  | ITU-2051-3               | C, L, R, LH, RH, LS, RS, LB, RB, CH, LFE1, LFE2
 Sound System G (4+9+0)  | ITU-2051-3               | L, R, C, LFE, Lss, Rss, Lrs, Rrs, Ltf, Rtf, Ltb, Rtb, Lsc, Rsc
 Sound System H (9+10+3) | ITU-2051-3               | FL, FR, FC, LFE1, BL, BR, FLc, FRc, BC, LFE2, SiL, SiR, TpFL, TpFR, TpFC, TpC, TpBL, TpBR, TpSiL, TpSiR, TpBC, BtFC, BtFL, BtFR
 Sound System I (0+7+0)  | ITU_2051-3               | L, R, C, LFE, Lss, Rss, Lrs, Rrs
diff --git a/iamf/cli/testdata/test_000000_3.textproto b/iamf/cli/testdata/test_000000_3.textproto
index 8ce9812..6b74d12 100644
--- a/iamf/cli/testdata/test_000000_3.textproto
+++ b/iamf/cli/testdata/test_000000_3.textproto
@@ -40,6 +40,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000002.textproto b/iamf/cli/testdata/test_000002.textproto
index a4c763f..a3f3651 100644
--- a/iamf/cli/testdata/test_000002.textproto
+++ b/iamf/cli/testdata/test_000002.textproto
@@ -44,6 +44,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000003.textproto b/iamf/cli/testdata/test_000003.textproto
index f8450a6..3213306 100644
--- a/iamf/cli/testdata/test_000003.textproto
+++ b/iamf/cli/testdata/test_000003.textproto
@@ -44,6 +44,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000005.textproto b/iamf/cli/testdata/test_000005.textproto
index 87903c7..3b5ac6a 100644
--- a/iamf/cli/testdata/test_000005.textproto
+++ b/iamf/cli/testdata/test_000005.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000006.textproto b/iamf/cli/testdata/test_000006.textproto
index 45881ac..c54b1e7 100644
--- a/iamf/cli/testdata/test_000006.textproto
+++ b/iamf/cli/testdata/test_000006.textproto
@@ -37,6 +37,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000007.textproto b/iamf/cli/testdata/test_000007.textproto
index 036d14a..2b30507 100644
--- a/iamf/cli/testdata/test_000007.textproto
+++ b/iamf/cli/testdata/test_000007.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000012.textproto b/iamf/cli/testdata/test_000012.textproto
index 621fc99..9169c95 100644
--- a/iamf/cli/testdata/test_000012.textproto
+++ b/iamf/cli/testdata/test_000012.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000013.textproto b/iamf/cli/testdata/test_000013.textproto
index 86c3e3a..0471d38 100644
--- a/iamf/cli/testdata/test_000013.textproto
+++ b/iamf/cli/testdata/test_000013.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000014.textproto b/iamf/cli/testdata/test_000014.textproto
index 462da08..43da7c8 100644
--- a/iamf/cli/testdata/test_000014.textproto
+++ b/iamf/cli/testdata/test_000014.textproto
@@ -29,11 +29,11 @@ test_vector_metadata {
     "3.11.1/pre_skip"
   ]
   base_test: "test_000005"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000015.textproto b/iamf/cli/testdata/test_000015.textproto
index ea623db..bf32f86 100644
--- a/iamf/cli/testdata/test_000015.textproto
+++ b/iamf/cli/testdata/test_000015.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
@@ -157,8 +158,10 @@ parameter_block_metadata {
   ]
 }
 
+# Place the extra parameter block in the first temporal unit.
 arbitrary_obu_metadata {
-  insertion_hook: INSERTION_HOOK_AFTER_DESCRIPTORS
+  insertion_hook: INSERTION_HOOK_AFTER_PARAMETER_BLOCKS_AT_TICK
+  insertion_tick: 0
   obu_type: OBU_IA_PARAMETER_BLOCK
   obu_header {
     obu_redundant_copy: false
diff --git a/iamf/cli/testdata/test_000016.textproto b/iamf/cli/testdata/test_000016.textproto
index bd0f2a1..506332e 100644
--- a/iamf/cli/testdata/test_000016.textproto
+++ b/iamf/cli/testdata/test_000016.textproto
@@ -38,6 +38,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000017.textproto b/iamf/cli/testdata/test_000017.textproto
index 0265cc7..a755011 100644
--- a/iamf/cli/testdata/test_000017.textproto
+++ b/iamf/cli/testdata/test_000017.textproto
@@ -33,6 +33,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000018.textproto b/iamf/cli/testdata/test_000018.textproto
index db09503..c9a7581 100644
--- a/iamf/cli/testdata/test_000018.textproto
+++ b/iamf/cli/testdata/test_000018.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000019.textproto b/iamf/cli/testdata/test_000019.textproto
index adac24f..ec63d7f 100644
--- a/iamf/cli/testdata/test_000019.textproto
+++ b/iamf/cli/testdata/test_000019.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000020.textproto b/iamf/cli/testdata/test_000020.textproto
index b5153a7..3f37531 100644
--- a/iamf/cli/testdata/test_000020.textproto
+++ b/iamf/cli/testdata/test_000020.textproto
@@ -32,11 +32,11 @@ test_vector_metadata {
     "6.2.2/roll"
   ]
   base_test: "test_000014"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000021.textproto b/iamf/cli/testdata/test_000021.textproto
index 697672b..2da165f 100644
--- a/iamf/cli/testdata/test_000021.textproto
+++ b/iamf/cli/testdata/test_000021.textproto
@@ -31,11 +31,11 @@ test_vector_metadata {
     "3.11.1/num_samples_per_frame"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000022.textproto b/iamf/cli/testdata/test_000022.textproto
index 4741676..b395b35 100644
--- a/iamf/cli/testdata/test_000022.textproto
+++ b/iamf/cli/testdata/test_000022.textproto
@@ -31,11 +31,11 @@ test_vector_metadata {
     "3.11.1/num_samples_per_frame"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000023.textproto b/iamf/cli/testdata/test_000023.textproto
index d0ac5fe..18e71d8 100644
--- a/iamf/cli/testdata/test_000023.textproto
+++ b/iamf/cli/testdata/test_000023.textproto
@@ -31,11 +31,11 @@ test_vector_metadata {
     "3.11.1/num_samples_per_frame"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000024.textproto b/iamf/cli/testdata/test_000024.textproto
index bea5f7f..27caf37 100644
--- a/iamf/cli/testdata/test_000024.textproto
+++ b/iamf/cli/testdata/test_000024.textproto
@@ -31,11 +31,11 @@ test_vector_metadata {
     "3.11.1/num_samples_per_frame"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000025.textproto b/iamf/cli/testdata/test_000025.textproto
index 2cd6545..71565bf 100644
--- a/iamf/cli/testdata/test_000025.textproto
+++ b/iamf/cli/testdata/test_000025.textproto
@@ -29,11 +29,11 @@ test_vector_metadata {
     "3.11.1/version"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000026.textproto b/iamf/cli/testdata/test_000026.textproto
index 9a0c9c5..4745901 100644
--- a/iamf/cli/testdata/test_000026.textproto
+++ b/iamf/cli/testdata/test_000026.textproto
@@ -32,11 +32,11 @@ test_vector_metadata {
     "3.11.1/output_channel_count"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000027.textproto b/iamf/cli/testdata/test_000027.textproto
index c35e113..55d4fe3 100644
--- a/iamf/cli/testdata/test_000027.textproto
+++ b/iamf/cli/testdata/test_000027.textproto
@@ -29,11 +29,11 @@ test_vector_metadata {
     "3.11.1/output_gain"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000028.textproto b/iamf/cli/testdata/test_000028.textproto
index 6800881..584df2d 100644
--- a/iamf/cli/testdata/test_000028.textproto
+++ b/iamf/cli/testdata/test_000028.textproto
@@ -29,11 +29,11 @@ test_vector_metadata {
     "3.11.1/channel_mapping_family"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000029.textproto b/iamf/cli/testdata/test_000029.textproto
index 78cb678..76437c1 100644
--- a/iamf/cli/testdata/test_000029.textproto
+++ b/iamf/cli/testdata/test_000029.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000030.textproto b/iamf/cli/testdata/test_000030.textproto
index 04db601..1706b20 100644
--- a/iamf/cli/testdata/test_000030.textproto
+++ b/iamf/cli/testdata/test_000030.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000031.textproto b/iamf/cli/testdata/test_000031.textproto
index 1f8bef6..b26be66 100644
--- a/iamf/cli/testdata/test_000031.textproto
+++ b/iamf/cli/testdata/test_000031.textproto
@@ -31,6 +31,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000032.textproto b/iamf/cli/testdata/test_000032.textproto
index 50255b9..2e3e299 100644
--- a/iamf/cli/testdata/test_000032.textproto
+++ b/iamf/cli/testdata/test_000032.textproto
@@ -31,11 +31,11 @@ test_vector_metadata {
     "3.11.1/target_bitrate"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000033.textproto b/iamf/cli/testdata/test_000033.textproto
index 1370340..ca63472 100644
--- a/iamf/cli/testdata/test_000033.textproto
+++ b/iamf/cli/testdata/test_000033.textproto
@@ -30,11 +30,11 @@ test_vector_metadata {
     "3.11.1/target_bitrate"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000034.textproto b/iamf/cli/testdata/test_000034.textproto
index f9d9df5..6210d32 100644
--- a/iamf/cli/testdata/test_000034.textproto
+++ b/iamf/cli/testdata/test_000034.textproto
@@ -30,11 +30,11 @@ test_vector_metadata {
     "3.11.1/application"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000035.textproto b/iamf/cli/testdata/test_000035.textproto
index 6f2b509..7d022cf 100644
--- a/iamf/cli/testdata/test_000035.textproto
+++ b/iamf/cli/testdata/test_000035.textproto
@@ -30,11 +30,11 @@ test_vector_metadata {
     "3.11.1/application"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000036.textproto b/iamf/cli/testdata/test_000036.textproto
index feba90a..0317938 100644
--- a/iamf/cli/testdata/test_000036.textproto
+++ b/iamf/cli/testdata/test_000036.textproto
@@ -38,6 +38,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000037.textproto b/iamf/cli/testdata/test_000037.textproto
index bb1a85f..8813ebe 100644
--- a/iamf/cli/testdata/test_000037.textproto
+++ b/iamf/cli/testdata/test_000037.textproto
@@ -26,11 +26,11 @@ test_vector_metadata {
   ]
   primary_tested_spec_sections: ["6/ISOBMFF IAMF Encapsulation"]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000038.textproto b/iamf/cli/testdata/test_000038.textproto
index 1014c80..f67092b 100644
--- a/iamf/cli/testdata/test_000038.textproto
+++ b/iamf/cli/testdata/test_000038.textproto
@@ -38,6 +38,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000039.textproto b/iamf/cli/testdata/test_000039.textproto
index 1ccbcf5..af96cf5 100644
--- a/iamf/cli/testdata/test_000039.textproto
+++ b/iamf/cli/testdata/test_000039.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000040.textproto b/iamf/cli/testdata/test_000040.textproto
index 107de26..fd4fa5f 100644
--- a/iamf/cli/testdata/test_000040.textproto
+++ b/iamf/cli/testdata/test_000040.textproto
@@ -31,6 +31,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000042.textproto b/iamf/cli/testdata/test_000042.textproto
index 449a600..5fdbfe9 100644
--- a/iamf/cli/testdata/test_000042.textproto
+++ b/iamf/cli/testdata/test_000042.textproto
@@ -38,6 +38,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000043.textproto b/iamf/cli/testdata/test_000043.textproto
index 66f3165..19f940a 100644
--- a/iamf/cli/testdata/test_000043.textproto
+++ b/iamf/cli/testdata/test_000043.textproto
@@ -38,6 +38,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000044.textproto b/iamf/cli/testdata/test_000044.textproto
index 6e57569..a25b917 100644
--- a/iamf/cli/testdata/test_000044.textproto
+++ b/iamf/cli/testdata/test_000044.textproto
@@ -39,6 +39,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000045.textproto b/iamf/cli/testdata/test_000045.textproto
index a576893..2f5d55d 100644
--- a/iamf/cli/testdata/test_000045.textproto
+++ b/iamf/cli/testdata/test_000045.textproto
@@ -30,11 +30,11 @@ test_vector_metadata {
     "3.11.1/OPUS Specific"
   ]
   base_test: "test_000038"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000046.textproto b/iamf/cli/testdata/test_000046.textproto
index 740f96d..be516f4 100644
--- a/iamf/cli/testdata/test_000046.textproto
+++ b/iamf/cli/testdata/test_000046.textproto
@@ -30,11 +30,11 @@ test_vector_metadata {
     "3.11.1/OPUS Specific"
   ]
   base_test: "test_000043"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000048.textproto b/iamf/cli/testdata/test_000048.textproto
index 45c4399..4cfc2f5 100644
--- a/iamf/cli/testdata/test_000048.textproto
+++ b/iamf/cli/testdata/test_000048.textproto
@@ -32,11 +32,11 @@ test_vector_metadata {
     "7.3.2.2/Rendering a Scene-Based Audio Element to Loudspeakers"
   ]
   base_test: "test_000042"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000049.textproto b/iamf/cli/testdata/test_000049.textproto
index a99529d..d84f835 100644
--- a/iamf/cli/testdata/test_000049.textproto
+++ b/iamf/cli/testdata/test_000049.textproto
@@ -34,11 +34,11 @@ test_vector_metadata {
     "3.11.1/OPUS Specific"
   ]
   base_test: "test_000036"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000050.textproto b/iamf/cli/testdata/test_000050.textproto
index b01509c..f3705d3 100644
--- a/iamf/cli/testdata/test_000050.textproto
+++ b/iamf/cli/testdata/test_000050.textproto
@@ -41,11 +41,11 @@ test_vector_metadata {
     "7.3.2.1/Rendering a Channel-Based Audio Element to Loudspeakers"
   ]
   base_test: "test_000037"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000051.textproto b/iamf/cli/testdata/test_000051.textproto
index aa71e34..fad3972 100644
--- a/iamf/cli/testdata/test_000051.textproto
+++ b/iamf/cli/testdata/test_000051.textproto
@@ -34,11 +34,11 @@ test_vector_metadata {
     "3.11.1/OPUS Specific"
   ]
   base_test: "test_000050"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000052.textproto b/iamf/cli/testdata/test_000052.textproto
index b286ed4..e42f633 100644
--- a/iamf/cli/testdata/test_000052.textproto
+++ b/iamf/cli/testdata/test_000052.textproto
@@ -37,11 +37,11 @@ test_vector_metadata {
     "7.3.2.1/Rendering a Channel-Based Audio Element to Loudspeakers"
   ]
   base_test: "test_000051"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000053.textproto b/iamf/cli/testdata/test_000053.textproto
index f453ddd..16b8978 100644
--- a/iamf/cli/testdata/test_000053.textproto
+++ b/iamf/cli/testdata/test_000053.textproto
@@ -34,11 +34,11 @@ test_vector_metadata {
     "3.11.1/OPUS Specific"
   ]
   base_test: "test_000051"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000054.textproto b/iamf/cli/testdata/test_000054.textproto
index c842c23..b8b0e0d 100644
--- a/iamf/cli/testdata/test_000054.textproto
+++ b/iamf/cli/testdata/test_000054.textproto
@@ -36,11 +36,11 @@ test_vector_metadata {
     "3.11.1/OPUS Specific"
   ]
   base_test: "test_000050"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000055.textproto b/iamf/cli/testdata/test_000055.textproto
index 649a873..e682be3 100644
--- a/iamf/cli/testdata/test_000055.textproto
+++ b/iamf/cli/testdata/test_000055.textproto
@@ -31,11 +31,11 @@ test_vector_metadata {
     "3.11.1/OPUS Specific"
   ]
   base_test: "test_000054"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000056.textproto b/iamf/cli/testdata/test_000056.textproto
index d5710c1..6a586eb 100644
--- a/iamf/cli/testdata/test_000056.textproto
+++ b/iamf/cli/testdata/test_000056.textproto
@@ -31,11 +31,11 @@ test_vector_metadata {
     "3.11.1/OPUS Specific"
   ]
   base_test: "test_000055"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000058.textproto b/iamf/cli/testdata/test_000058.textproto
index cd480bc..b835f23 100644
--- a/iamf/cli/testdata/test_000058.textproto
+++ b/iamf/cli/testdata/test_000058.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000059.textproto b/iamf/cli/testdata/test_000059.textproto
index 358676b..5af0e00 100644
--- a/iamf/cli/testdata/test_000059.textproto
+++ b/iamf/cli/testdata/test_000059.textproto
@@ -35,11 +35,11 @@ test_vector_metadata {
     "7.3.2.1/Rendering a Channel-Based Audio Element to Loudspeakers"
   ]
   base_test: "test_000056"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000060.textproto b/iamf/cli/testdata/test_000060.textproto
index 6403246..47d546f 100644
--- a/iamf/cli/testdata/test_000060.textproto
+++ b/iamf/cli/testdata/test_000060.textproto
@@ -34,6 +34,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000061.textproto b/iamf/cli/testdata/test_000061.textproto
index 06c8cfe..0461834 100644
--- a/iamf/cli/testdata/test_000061.textproto
+++ b/iamf/cli/testdata/test_000061.textproto
@@ -37,11 +37,11 @@ test_vector_metadata {
     "7.3.2.1/Rendering a Channel-Based Audio Element to Loudspeakers"
   ]
   base_test: "test_000056"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000062.textproto b/iamf/cli/testdata/test_000062.textproto
index 8f5e049..cb3105b 100644
--- a/iamf/cli/testdata/test_000062.textproto
+++ b/iamf/cli/testdata/test_000062.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000063.textproto b/iamf/cli/testdata/test_000063.textproto
index 43797b5..49df968 100644
--- a/iamf/cli/testdata/test_000063.textproto
+++ b/iamf/cli/testdata/test_000063.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000064.textproto b/iamf/cli/testdata/test_000064.textproto
index 6ff6441..95fb097 100644
--- a/iamf/cli/testdata/test_000064.textproto
+++ b/iamf/cli/testdata/test_000064.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000065.textproto b/iamf/cli/testdata/test_000065.textproto
index 6f183ae..abdd4ec 100644
--- a/iamf/cli/testdata/test_000065.textproto
+++ b/iamf/cli/testdata/test_000065.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000066.textproto b/iamf/cli/testdata/test_000066.textproto
index d18ffdc..7c71c9f 100644
--- a/iamf/cli/testdata/test_000066.textproto
+++ b/iamf/cli/testdata/test_000066.textproto
@@ -41,6 +41,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000067.textproto b/iamf/cli/testdata/test_000067.textproto
index 10ce80b..7e4cbb8 100644
--- a/iamf/cli/testdata/test_000067.textproto
+++ b/iamf/cli/testdata/test_000067.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000068.textproto b/iamf/cli/testdata/test_000068.textproto
index d8e1bc3..910de5e 100644
--- a/iamf/cli/testdata/test_000068.textproto
+++ b/iamf/cli/testdata/test_000068.textproto
@@ -41,6 +41,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000069.textproto b/iamf/cli/testdata/test_000069.textproto
index 4cf8df9..d9f0666 100644
--- a/iamf/cli/testdata/test_000069.textproto
+++ b/iamf/cli/testdata/test_000069.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000070.textproto b/iamf/cli/testdata/test_000070.textproto
index 1a8a11a..bdb4e23 100644
--- a/iamf/cli/testdata/test_000070.textproto
+++ b/iamf/cli/testdata/test_000070.textproto
@@ -44,6 +44,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000071.textproto b/iamf/cli/testdata/test_000071.textproto
index be95ff1..be08379 100644
--- a/iamf/cli/testdata/test_000071.textproto
+++ b/iamf/cli/testdata/test_000071.textproto
@@ -44,6 +44,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000072.textproto b/iamf/cli/testdata/test_000072.textproto
index 5ee3fa1..a1782c5 100644
--- a/iamf/cli/testdata/test_000072.textproto
+++ b/iamf/cli/testdata/test_000072.textproto
@@ -33,6 +33,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000073.textproto b/iamf/cli/testdata/test_000073.textproto
index 87ea023..360bad9 100644
--- a/iamf/cli/testdata/test_000073.textproto
+++ b/iamf/cli/testdata/test_000073.textproto
@@ -37,6 +37,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000074.textproto b/iamf/cli/testdata/test_000074.textproto
index be0812c..d97f09e 100644
--- a/iamf/cli/testdata/test_000074.textproto
+++ b/iamf/cli/testdata/test_000074.textproto
@@ -34,6 +34,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000075.textproto b/iamf/cli/testdata/test_000075.textproto
index 32649ac..c819cd8 100644
--- a/iamf/cli/testdata/test_000075.textproto
+++ b/iamf/cli/testdata/test_000075.textproto
@@ -34,6 +34,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000076.textproto b/iamf/cli/testdata/test_000076.textproto
index 2650905..aca1dbc 100644
--- a/iamf/cli/testdata/test_000076.textproto
+++ b/iamf/cli/testdata/test_000076.textproto
@@ -33,6 +33,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000077.textproto b/iamf/cli/testdata/test_000077.textproto
index 2bc2062..2a390d6 100644
--- a/iamf/cli/testdata/test_000077.textproto
+++ b/iamf/cli/testdata/test_000077.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000078.textproto b/iamf/cli/testdata/test_000078.textproto
index 5ad094f..68c7b8f 100644
--- a/iamf/cli/testdata/test_000078.textproto
+++ b/iamf/cli/testdata/test_000078.textproto
@@ -32,6 +32,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000079.textproto b/iamf/cli/testdata/test_000079.textproto
index f078179..548febe 100644
--- a/iamf/cli/testdata/test_000079.textproto
+++ b/iamf/cli/testdata/test_000079.textproto
@@ -32,6 +32,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000080.textproto b/iamf/cli/testdata/test_000080.textproto
index 2f04627..8ebee7d 100644
--- a/iamf/cli/testdata/test_000080.textproto
+++ b/iamf/cli/testdata/test_000080.textproto
@@ -36,11 +36,11 @@ test_vector_metadata {
     "3.11.1/OPUS Specific"
   ]
   base_test: "test_000054"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000081.textproto b/iamf/cli/testdata/test_000081.textproto
index 9c03f97..e730a2d 100644
--- a/iamf/cli/testdata/test_000081.textproto
+++ b/iamf/cli/testdata/test_000081.textproto
@@ -40,11 +40,11 @@ test_vector_metadata {
     "7.3.2.1/Rendering a Channel-Based Audio Element to Loudspeakers"
   ]
   base_test: "test_000054"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000082.textproto b/iamf/cli/testdata/test_000082.textproto
index 98a1310..5cbc77b 100644
--- a/iamf/cli/testdata/test_000082.textproto
+++ b/iamf/cli/testdata/test_000082.textproto
@@ -37,6 +37,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000083.textproto b/iamf/cli/testdata/test_000083.textproto
index c97801d..79750cb 100644
--- a/iamf/cli/testdata/test_000083.textproto
+++ b/iamf/cli/testdata/test_000083.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000084.textproto b/iamf/cli/testdata/test_000084.textproto
index 7b7e6f9..529db5c 100644
--- a/iamf/cli/testdata/test_000084.textproto
+++ b/iamf/cli/testdata/test_000084.textproto
@@ -33,6 +33,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000085.textproto b/iamf/cli/testdata/test_000085.textproto
index 299410a..2e8b237 100644
--- a/iamf/cli/testdata/test_000085.textproto
+++ b/iamf/cli/testdata/test_000085.textproto
@@ -34,6 +34,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000086.textproto b/iamf/cli/testdata/test_000086.textproto
index 9758a2b..a6fceb8 100644
--- a/iamf/cli/testdata/test_000086.textproto
+++ b/iamf/cli/testdata/test_000086.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000087.textproto b/iamf/cli/testdata/test_000087.textproto
index afcfaa8..04162ef 100644
--- a/iamf/cli/testdata/test_000087.textproto
+++ b/iamf/cli/testdata/test_000087.textproto
@@ -33,11 +33,11 @@ test_vector_metadata {
     "8.5.1/Loudness Information"
   ]
   base_test: "test_000405"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000088.textproto b/iamf/cli/testdata/test_000088.textproto
index f652ba0..33bc1ac 100644
--- a/iamf/cli/testdata/test_000088.textproto
+++ b/iamf/cli/testdata/test_000088.textproto
@@ -50,6 +50,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000089.textproto b/iamf/cli/testdata/test_000089.textproto
index def4b02..65a0cd3 100644
--- a/iamf/cli/testdata/test_000089.textproto
+++ b/iamf/cli/testdata/test_000089.textproto
@@ -42,11 +42,11 @@ test_vector_metadata {
     "7.3.2.3/Rendering a Channel-Based Audio Element to Headphones"
   ]
   base_test: "test_000050"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000090.textproto b/iamf/cli/testdata/test_000090.textproto
index 8c5c942..3e9f4f0 100644
--- a/iamf/cli/testdata/test_000090.textproto
+++ b/iamf/cli/testdata/test_000090.textproto
@@ -34,6 +34,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000091.textproto b/iamf/cli/testdata/test_000091.textproto
index 6d110eb..0880660 100644
--- a/iamf/cli/testdata/test_000091.textproto
+++ b/iamf/cli/testdata/test_000091.textproto
@@ -33,6 +33,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000092.textproto b/iamf/cli/testdata/test_000092.textproto
index 3e32e76..662aed1 100644
--- a/iamf/cli/testdata/test_000092.textproto
+++ b/iamf/cli/testdata/test_000092.textproto
@@ -38,6 +38,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000093.textproto b/iamf/cli/testdata/test_000093.textproto
index 45655ea..6cf0bf1 100644
--- a/iamf/cli/testdata/test_000093.textproto
+++ b/iamf/cli/testdata/test_000093.textproto
@@ -39,6 +39,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000094.textproto b/iamf/cli/testdata/test_000094.textproto
index 8a09c25..ba85360 100644
--- a/iamf/cli/testdata/test_000094.textproto
+++ b/iamf/cli/testdata/test_000094.textproto
@@ -37,6 +37,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000095.textproto b/iamf/cli/testdata/test_000095.textproto
index 26a2a74..0a6e2d1 100644
--- a/iamf/cli/testdata/test_000095.textproto
+++ b/iamf/cli/testdata/test_000095.textproto
@@ -47,6 +47,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000096.textproto b/iamf/cli/testdata/test_000096.textproto
index a14a35a..7fbc6b7 100644
--- a/iamf/cli/testdata/test_000096.textproto
+++ b/iamf/cli/testdata/test_000096.textproto
@@ -37,6 +37,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000097.textproto b/iamf/cli/testdata/test_000097.textproto
index 3685c69..134be90 100644
--- a/iamf/cli/testdata/test_000097.textproto
+++ b/iamf/cli/testdata/test_000097.textproto
@@ -32,6 +32,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000098.textproto b/iamf/cli/testdata/test_000098.textproto
index ca94dfb..c382626 100644
--- a/iamf/cli/testdata/test_000098.textproto
+++ b/iamf/cli/testdata/test_000098.textproto
@@ -34,11 +34,11 @@ test_vector_metadata {
     "3.11.1/OPUS Specific"
   ]
   base_test: "test_000049"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000100.textproto b/iamf/cli/testdata/test_000100.textproto
index 72ec1b8..1e81504 100644
--- a/iamf/cli/testdata/test_000100.textproto
+++ b/iamf/cli/testdata/test_000100.textproto
@@ -34,6 +34,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000101.textproto b/iamf/cli/testdata/test_000101.textproto
index 71e1abf..530d31a 100644
--- a/iamf/cli/testdata/test_000101.textproto
+++ b/iamf/cli/testdata/test_000101.textproto
@@ -34,6 +34,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000102.textproto b/iamf/cli/testdata/test_000102.textproto
index 7fafa1c..700b748 100644
--- a/iamf/cli/testdata/test_000102.textproto
+++ b/iamf/cli/testdata/test_000102.textproto
@@ -34,6 +34,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000103.textproto b/iamf/cli/testdata/test_000103.textproto
index 3793de7..3aecad0 100644
--- a/iamf/cli/testdata/test_000103.textproto
+++ b/iamf/cli/testdata/test_000103.textproto
@@ -34,6 +34,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000104.textproto b/iamf/cli/testdata/test_000104.textproto
index c304dca..e5c12b4 100644
--- a/iamf/cli/testdata/test_000104.textproto
+++ b/iamf/cli/testdata/test_000104.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000105.textproto b/iamf/cli/testdata/test_000105.textproto
index 5b46a57..5c9cb0a 100644
--- a/iamf/cli/testdata/test_000105.textproto
+++ b/iamf/cli/testdata/test_000105.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000106.textproto b/iamf/cli/testdata/test_000106.textproto
index 2f18e26..469dd3f 100644
--- a/iamf/cli/testdata/test_000106.textproto
+++ b/iamf/cli/testdata/test_000106.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000107.textproto b/iamf/cli/testdata/test_000107.textproto
index 203ecfc..47cea21 100644
--- a/iamf/cli/testdata/test_000107.textproto
+++ b/iamf/cli/testdata/test_000107.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000108.textproto b/iamf/cli/testdata/test_000108.textproto
index 2c2b607..9c71d24 100644
--- a/iamf/cli/testdata/test_000108.textproto
+++ b/iamf/cli/testdata/test_000108.textproto
@@ -29,11 +29,11 @@ test_vector_metadata {
     "3.11.1/OPUS Specific"
   ]
   base_test: "test_000100"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000109.textproto b/iamf/cli/testdata/test_000109.textproto
index ed04e0d..209bfbc 100644
--- a/iamf/cli/testdata/test_000109.textproto
+++ b/iamf/cli/testdata/test_000109.textproto
@@ -31,11 +31,11 @@ test_vector_metadata {
     "7.5.2/Limiter"
   ]
   base_test: "test_000101"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000110.textproto b/iamf/cli/testdata/test_000110.textproto
index 3815fdf..2f991fa 100644
--- a/iamf/cli/testdata/test_000110.textproto
+++ b/iamf/cli/testdata/test_000110.textproto
@@ -31,11 +31,11 @@ test_vector_metadata {
     "7.5.2/Limiter"
   ]
   base_test: "test_000102"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000111.textproto b/iamf/cli/testdata/test_000111.textproto
index 2bfda22..27d2a36 100644
--- a/iamf/cli/testdata/test_000111.textproto
+++ b/iamf/cli/testdata/test_000111.textproto
@@ -31,11 +31,11 @@ test_vector_metadata {
     "7.5.2/Limiter"
   ]
   base_test: "test_000103"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000112.textproto b/iamf/cli/testdata/test_000112.textproto
index 471468b..f751841 100644
--- a/iamf/cli/testdata/test_000112.textproto
+++ b/iamf/cli/testdata/test_000112.textproto
@@ -29,11 +29,11 @@ test_vector_metadata {
     "3.11.1/OPUS Specific"
   ]
   base_test: "test_000104"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000113.textproto b/iamf/cli/testdata/test_000113.textproto
index 7d8f4e6..09052f7 100644
--- a/iamf/cli/testdata/test_000113.textproto
+++ b/iamf/cli/testdata/test_000113.textproto
@@ -33,11 +33,11 @@ test_vector_metadata {
     "7.5.2/Limiter"
   ]
   base_test: "test_000105"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000114.textproto b/iamf/cli/testdata/test_000114.textproto
index 17e6e02..bd11325 100644
--- a/iamf/cli/testdata/test_000114.textproto
+++ b/iamf/cli/testdata/test_000114.textproto
@@ -33,11 +33,11 @@ test_vector_metadata {
     "7.5.2/Limiter"
   ]
   base_test: "test_000106"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000115.textproto b/iamf/cli/testdata/test_000115.textproto
index e6af8bf..360eff6 100644
--- a/iamf/cli/testdata/test_000115.textproto
+++ b/iamf/cli/testdata/test_000115.textproto
@@ -33,11 +33,11 @@ test_vector_metadata {
     "7.5.2/Limiter"
   ]
   base_test: "test_000107"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000116.textproto b/iamf/cli/testdata/test_000116.textproto
index f0f371c..b313eaf 100644
--- a/iamf/cli/testdata/test_000116.textproto
+++ b/iamf/cli/testdata/test_000116.textproto
@@ -37,11 +37,11 @@ test_vector_metadata {
     "6.2.2/roll"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000117.textproto b/iamf/cli/testdata/test_000117.textproto
index d72e712..fe19da6 100644
--- a/iamf/cli/testdata/test_000117.textproto
+++ b/iamf/cli/testdata/test_000117.textproto
@@ -34,11 +34,11 @@ test_vector_metadata {
     "6.2.2/roll"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000118.textproto b/iamf/cli/testdata/test_000118.textproto
index 8f728bd..6def04a 100644
--- a/iamf/cli/testdata/test_000118.textproto
+++ b/iamf/cli/testdata/test_000118.textproto
@@ -37,11 +37,11 @@ test_vector_metadata {
     "8.5.1/Loudness Information"
   ]
   base_test: "test_000087"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000119.textproto b/iamf/cli/testdata/test_000119.textproto
index 0eae73c..e1724d4 100644
--- a/iamf/cli/testdata/test_000119.textproto
+++ b/iamf/cli/testdata/test_000119.textproto
@@ -38,6 +38,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000120.textproto b/iamf/cli/testdata/test_000120.textproto
index d02ac27..0a1a4cf 100644
--- a/iamf/cli/testdata/test_000120.textproto
+++ b/iamf/cli/testdata/test_000120.textproto
@@ -38,6 +38,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000121.textproto b/iamf/cli/testdata/test_000121.textproto
index 674b35a..b78d452 100644
--- a/iamf/cli/testdata/test_000121.textproto
+++ b/iamf/cli/testdata/test_000121.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000122.textproto b/iamf/cli/testdata/test_000122.textproto
index 358716e..1a4d67c 100644
--- a/iamf/cli/testdata/test_000122.textproto
+++ b/iamf/cli/testdata/test_000122.textproto
@@ -38,6 +38,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000123.textproto b/iamf/cli/testdata/test_000123.textproto
index 6cd17d8..c1c69c6 100644
--- a/iamf/cli/testdata/test_000123.textproto
+++ b/iamf/cli/testdata/test_000123.textproto
@@ -38,11 +38,11 @@ test_vector_metadata {
     "4.3/Cumulative channel limit"
   ]
   base_test: "test_000118"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000124.textproto b/iamf/cli/testdata/test_000124.textproto
index b8f8a9c..9690f42 100644
--- a/iamf/cli/testdata/test_000124.textproto
+++ b/iamf/cli/testdata/test_000124.textproto
@@ -28,11 +28,11 @@ test_vector_metadata {
     "3.7/num_sub_mixes"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000125.textproto b/iamf/cli/testdata/test_000125.textproto
index 5753774..12450f5 100644
--- a/iamf/cli/testdata/test_000125.textproto
+++ b/iamf/cli/testdata/test_000125.textproto
@@ -28,11 +28,11 @@ test_vector_metadata {
     "3.7.3/headphones_rendering_mode"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000126.textproto b/iamf/cli/testdata/test_000126.textproto
index dcaa3eb..0e25f95 100644
--- a/iamf/cli/testdata/test_000126.textproto
+++ b/iamf/cli/testdata/test_000126.textproto
@@ -33,11 +33,11 @@ test_vector_metadata {
     "6.2.2/roll"
   ]
   base_test: "test_000020"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000127.textproto b/iamf/cli/testdata/test_000127.textproto
index c4ac169..13851d8 100644
--- a/iamf/cli/testdata/test_000127.textproto
+++ b/iamf/cli/testdata/test_000127.textproto
@@ -34,11 +34,11 @@ test_vector_metadata {
     "8.5.1/Loudness Information"
   ]
   base_test: "test_000303"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000128.textproto b/iamf/cli/testdata/test_000128.textproto
index 5eaf020..8611153 100644
--- a/iamf/cli/testdata/test_000128.textproto
+++ b/iamf/cli/testdata/test_000128.textproto
@@ -35,11 +35,11 @@ test_vector_metadata {
     "8.5.1/Loudness Information"
   ]
   base_test: "test_000303"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000129.textproto b/iamf/cli/testdata/test_000129.textproto
index 9bd720f..83486f0 100644
--- a/iamf/cli/testdata/test_000129.textproto
+++ b/iamf/cli/testdata/test_000129.textproto
@@ -38,6 +38,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000130.textproto b/iamf/cli/testdata/test_000130.textproto
index fd5d5d7..1ac6716 100644
--- a/iamf/cli/testdata/test_000130.textproto
+++ b/iamf/cli/testdata/test_000130.textproto
@@ -38,6 +38,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000131.textproto b/iamf/cli/testdata/test_000131.textproto
index 2804d4e..352386c 100644
--- a/iamf/cli/testdata/test_000131.textproto
+++ b/iamf/cli/testdata/test_000131.textproto
@@ -32,11 +32,11 @@ validate_user_loudness: true
     "7.3.2.2/Rendering a Scene-Based Audio Element to Loudspeakers"
   ]
   base_test: "test_000048"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000132.textproto b/iamf/cli/testdata/test_000132.textproto
index a973aa6..eef133c 100644
--- a/iamf/cli/testdata/test_000132.textproto
+++ b/iamf/cli/testdata/test_000132.textproto
@@ -38,11 +38,11 @@ test_vector_metadata {
     "4.3/Cumulative channel limit"
   ]
   base_test: "test_000118"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000133.textproto b/iamf/cli/testdata/test_000133.textproto
index 7525379..a810a98 100644
--- a/iamf/cli/testdata/test_000133.textproto
+++ b/iamf/cli/testdata/test_000133.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000134.textproto b/iamf/cli/testdata/test_000134.textproto
index 86cf9ae..335bfe4 100644
--- a/iamf/cli/testdata/test_000134.textproto
+++ b/iamf/cli/testdata/test_000134.textproto
@@ -38,6 +38,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000135.textproto b/iamf/cli/testdata/test_000135.textproto
index 85fab65..beb9116 100644
--- a/iamf/cli/testdata/test_000135.textproto
+++ b/iamf/cli/testdata/test_000135.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000136.textproto b/iamf/cli/testdata/test_000136.textproto
index 3c2a04f..42d213e 100644
--- a/iamf/cli/testdata/test_000136.textproto
+++ b/iamf/cli/testdata/test_000136.textproto
@@ -40,6 +40,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000200.textproto b/iamf/cli/testdata/test_000200.textproto
index ee5380a..0801c6d 100644
--- a/iamf/cli/testdata/test_000200.textproto
+++ b/iamf/cli/testdata/test_000200.textproto
@@ -32,6 +32,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000201.textproto b/iamf/cli/testdata/test_000201.textproto
index 1da0df7..c8900e1 100644
--- a/iamf/cli/testdata/test_000201.textproto
+++ b/iamf/cli/testdata/test_000201.textproto
@@ -32,6 +32,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000202.textproto b/iamf/cli/testdata/test_000202.textproto
index 04d6d95..a469fda 100644
--- a/iamf/cli/testdata/test_000202.textproto
+++ b/iamf/cli/testdata/test_000202.textproto
@@ -32,6 +32,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000203.textproto b/iamf/cli/testdata/test_000203.textproto
index acbc0db..1f6bce9 100644
--- a/iamf/cli/testdata/test_000203.textproto
+++ b/iamf/cli/testdata/test_000203.textproto
@@ -32,6 +32,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000204.textproto b/iamf/cli/testdata/test_000204.textproto
index 6bc6e29..e0e2dde 100644
--- a/iamf/cli/testdata/test_000204.textproto
+++ b/iamf/cli/testdata/test_000204.textproto
@@ -32,6 +32,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000205.textproto b/iamf/cli/testdata/test_000205.textproto
index 2c5b370..e1c35d7 100644
--- a/iamf/cli/testdata/test_000205.textproto
+++ b/iamf/cli/testdata/test_000205.textproto
@@ -34,6 +34,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000206.textproto b/iamf/cli/testdata/test_000206.textproto
index bdabe16..5dc9a35 100644
--- a/iamf/cli/testdata/test_000206.textproto
+++ b/iamf/cli/testdata/test_000206.textproto
@@ -32,6 +32,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000207.textproto b/iamf/cli/testdata/test_000207.textproto
index 8594b07..da82b15 100644
--- a/iamf/cli/testdata/test_000207.textproto
+++ b/iamf/cli/testdata/test_000207.textproto
@@ -32,6 +32,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000208.textproto b/iamf/cli/testdata/test_000208.textproto
index 77a5361..4e541b8 100644
--- a/iamf/cli/testdata/test_000208.textproto
+++ b/iamf/cli/testdata/test_000208.textproto
@@ -34,6 +34,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000209.textproto b/iamf/cli/testdata/test_000209.textproto
index 0af9eec..2fd9667 100644
--- a/iamf/cli/testdata/test_000209.textproto
+++ b/iamf/cli/testdata/test_000209.textproto
@@ -39,6 +39,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000210.textproto b/iamf/cli/testdata/test_000210.textproto
index c13905e..577db3b 100644
--- a/iamf/cli/testdata/test_000210.textproto
+++ b/iamf/cli/testdata/test_000210.textproto
@@ -39,6 +39,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000211.textproto b/iamf/cli/testdata/test_000211.textproto
index 0126631..3594b00 100644
--- a/iamf/cli/testdata/test_000211.textproto
+++ b/iamf/cli/testdata/test_000211.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000212.textproto b/iamf/cli/testdata/test_000212.textproto
index e2d2445..89228fa 100644
--- a/iamf/cli/testdata/test_000212.textproto
+++ b/iamf/cli/testdata/test_000212.textproto
@@ -32,11 +32,11 @@ test_vector_metadata {
     "3.11.1/pre_skip"
   ]
   base_test: "test_000200"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000213.textproto b/iamf/cli/testdata/test_000213.textproto
index b4a95e4..057a4c1 100644
--- a/iamf/cli/testdata/test_000213.textproto
+++ b/iamf/cli/testdata/test_000213.textproto
@@ -32,11 +32,11 @@ test_vector_metadata {
     "3.11.1/pre_skip"
   ]
   base_test: "test_000201"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000214.textproto b/iamf/cli/testdata/test_000214.textproto
index d484a0d..623ceed 100644
--- a/iamf/cli/testdata/test_000214.textproto
+++ b/iamf/cli/testdata/test_000214.textproto
@@ -32,11 +32,11 @@ test_vector_metadata {
     "3.11.1/pre_skip"
   ]
   base_test: "test_000202"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000215.textproto b/iamf/cli/testdata/test_000215.textproto
index 25c5a95..cb271dd 100644
--- a/iamf/cli/testdata/test_000215.textproto
+++ b/iamf/cli/testdata/test_000215.textproto
@@ -32,11 +32,11 @@ test_vector_metadata {
     "3.11.1/pre_skip"
   ]
   base_test: "test_000203"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000216.textproto b/iamf/cli/testdata/test_000216.textproto
index a843605..71a8cc5 100644
--- a/iamf/cli/testdata/test_000216.textproto
+++ b/iamf/cli/testdata/test_000216.textproto
@@ -32,11 +32,11 @@ test_vector_metadata {
     "3.11.1/pre_skip"
   ]
   base_test: "test_000204"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000217.textproto b/iamf/cli/testdata/test_000217.textproto
index 158292a..13a3dec 100644
--- a/iamf/cli/testdata/test_000217.textproto
+++ b/iamf/cli/testdata/test_000217.textproto
@@ -34,11 +34,11 @@ test_vector_metadata {
     "7.5.2/Limiter"
   ]
   base_test: "test_000205"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000218.textproto b/iamf/cli/testdata/test_000218.textproto
index 55bcd44..1a497c7 100644
--- a/iamf/cli/testdata/test_000218.textproto
+++ b/iamf/cli/testdata/test_000218.textproto
@@ -32,11 +32,11 @@ test_vector_metadata {
     "3.11.1/pre_skip"
   ]
   base_test: "test_000206"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000219.textproto b/iamf/cli/testdata/test_000219.textproto
index 99c82fd..9b6bc11 100644
--- a/iamf/cli/testdata/test_000219.textproto
+++ b/iamf/cli/testdata/test_000219.textproto
@@ -32,11 +32,11 @@ test_vector_metadata {
     "3.11.1/pre_skip"
   ]
   base_test: "test_000207"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000220.textproto b/iamf/cli/testdata/test_000220.textproto
index 2c2433f..031b334 100644
--- a/iamf/cli/testdata/test_000220.textproto
+++ b/iamf/cli/testdata/test_000220.textproto
@@ -34,11 +34,11 @@ test_vector_metadata {
     "7.5.2/Limiter"
   ]
   base_test: "test_000208"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000221.textproto b/iamf/cli/testdata/test_000221.textproto
index 14f6500..1b0ef7c 100644
--- a/iamf/cli/testdata/test_000221.textproto
+++ b/iamf/cli/testdata/test_000221.textproto
@@ -34,11 +34,11 @@ test_vector_metadata {
     "9.1.2.1/Annex A2.1: Down-mix parameter and Loudness"
   ]
   base_test: "test_000209"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000222.textproto b/iamf/cli/testdata/test_000222.textproto
index 373a308..cde0456 100644
--- a/iamf/cli/testdata/test_000222.textproto
+++ b/iamf/cli/testdata/test_000222.textproto
@@ -35,11 +35,11 @@ test_vector_metadata {
     "9.1.2.1/Annex A2.1: Down-mix parameter and Loudness"
   ]
   base_test: "test_000221"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000223.textproto b/iamf/cli/testdata/test_000223.textproto
index 2bdc5cc..e2d5d3c 100644
--- a/iamf/cli/testdata/test_000223.textproto
+++ b/iamf/cli/testdata/test_000223.textproto
@@ -33,11 +33,11 @@ test_vector_metadata {
     "9.1.2.1/Annex A2.1: Down-mix parameter and Loudness"
   ]
   base_test: "test_000223"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000224.textproto b/iamf/cli/testdata/test_000224.textproto
index 3f02660..53fbe49 100644
--- a/iamf/cli/testdata/test_000224.textproto
+++ b/iamf/cli/testdata/test_000224.textproto
@@ -42,6 +42,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000225.textproto b/iamf/cli/testdata/test_000225.textproto
index 1b7803f..64a756f 100644
--- a/iamf/cli/testdata/test_000225.textproto
+++ b/iamf/cli/testdata/test_000225.textproto
@@ -48,6 +48,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000226.textproto b/iamf/cli/testdata/test_000226.textproto
index c8965be..0f9a8cb 100644
--- a/iamf/cli/testdata/test_000226.textproto
+++ b/iamf/cli/testdata/test_000226.textproto
@@ -43,6 +43,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000227.textproto b/iamf/cli/testdata/test_000227.textproto
index 60963c9..19eb848 100644
--- a/iamf/cli/testdata/test_000227.textproto
+++ b/iamf/cli/testdata/test_000227.textproto
@@ -44,12 +44,12 @@ test_vector_metadata {
     "9.1.2.4/Annex A2.4: Channel Group Generation Rule"
   ]
   base_test: "test_000224"
-  output_wav_file_bit_depth_override: 16
   override_computed_recon_gains: true
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000228.textproto b/iamf/cli/testdata/test_000228.textproto
index e588faa..fe5b357 100644
--- a/iamf/cli/testdata/test_000228.textproto
+++ b/iamf/cli/testdata/test_000228.textproto
@@ -45,12 +45,12 @@ test_vector_metadata {
     "9.1.2.4/Annex A2.4: Channel Group Generation Rule"
   ]
   base_test: "test_000225"
-  output_wav_file_bit_depth_override: 16
   override_computed_recon_gains: true
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000229.textproto b/iamf/cli/testdata/test_000229.textproto
index 4f30564..442d440 100644
--- a/iamf/cli/testdata/test_000229.textproto
+++ b/iamf/cli/testdata/test_000229.textproto
@@ -45,12 +45,12 @@ test_vector_metadata {
     "9.1.2.4/Annex A2.4: Channel Group Generation Rule"
   ]
   base_test: "test_000226"
-  output_wav_file_bit_depth_override: 16
   override_computed_recon_gains: true
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000230.textproto b/iamf/cli/testdata/test_000230.textproto
index 9dc8a09..547eaed 100644
--- a/iamf/cli/testdata/test_000230.textproto
+++ b/iamf/cli/testdata/test_000230.textproto
@@ -46,12 +46,12 @@ test_vector_metadata {
     "9.1.2.4/Annex A2.4: Channel Group Generation Rule"
   ]
   base_test: "test_000226"
-  output_wav_file_bit_depth_override: 16
   override_computed_recon_gains: true
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000231.textproto b/iamf/cli/testdata/test_000231.textproto
index 01cd7fb..8a37cc4 100644
--- a/iamf/cli/testdata/test_000231.textproto
+++ b/iamf/cli/testdata/test_000231.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000300.textproto b/iamf/cli/testdata/test_000300.textproto
index 0063009..a619c13 100644
--- a/iamf/cli/testdata/test_000300.textproto
+++ b/iamf/cli/testdata/test_000300.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000301.textproto b/iamf/cli/testdata/test_000301.textproto
index c813f4a..bb96c76 100644
--- a/iamf/cli/testdata/test_000301.textproto
+++ b/iamf/cli/testdata/test_000301.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000302.textproto b/iamf/cli/testdata/test_000302.textproto
index 1109fa8..761aee1 100644
--- a/iamf/cli/testdata/test_000302.textproto
+++ b/iamf/cli/testdata/test_000302.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000303.textproto b/iamf/cli/testdata/test_000303.textproto
index dba3a0c..c8a388e 100644
--- a/iamf/cli/testdata/test_000303.textproto
+++ b/iamf/cli/testdata/test_000303.textproto
@@ -34,11 +34,11 @@ test_vector_metadata {
     "8.5.1/Loudness Information"
   ]
   base_test: "test_000109"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000304.textproto b/iamf/cli/testdata/test_000304.textproto
index cb5adcf..1b1e4a4 100644
--- a/iamf/cli/testdata/test_000304.textproto
+++ b/iamf/cli/testdata/test_000304.textproto
@@ -33,11 +33,11 @@ test_vector_metadata {
     "8.5.1/Loudness Information"
   ]
   base_test: "test_000110"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000305.textproto b/iamf/cli/testdata/test_000305.textproto
index bdcd8f2..ab45f65 100644
--- a/iamf/cli/testdata/test_000305.textproto
+++ b/iamf/cli/testdata/test_000305.textproto
@@ -33,11 +33,11 @@ test_vector_metadata {
     "8.5.1/Loudness Information"
   ]
   base_test: "test_000111"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000400.textproto b/iamf/cli/testdata/test_000400.textproto
index 9de536a..0355712 100644
--- a/iamf/cli/testdata/test_000400.textproto
+++ b/iamf/cli/testdata/test_000400.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000401.textproto b/iamf/cli/testdata/test_000401.textproto
index 4ff50d4..80705e3 100644
--- a/iamf/cli/testdata/test_000401.textproto
+++ b/iamf/cli/testdata/test_000401.textproto
@@ -37,6 +37,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000402.textproto b/iamf/cli/testdata/test_000402.textproto
index 2f339f0..1710682 100644
--- a/iamf/cli/testdata/test_000402.textproto
+++ b/iamf/cli/testdata/test_000402.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000403.textproto b/iamf/cli/testdata/test_000403.textproto
index 8f66ccf..2a3f861 100644
--- a/iamf/cli/testdata/test_000403.textproto
+++ b/iamf/cli/testdata/test_000403.textproto
@@ -32,11 +32,11 @@ test_vector_metadata {
     "8.5.1/Loudness Information"
   ]
   base_test: "test_000303"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000404.textproto b/iamf/cli/testdata/test_000404.textproto
index 22a1588..03c1e01 100644
--- a/iamf/cli/testdata/test_000404.textproto
+++ b/iamf/cli/testdata/test_000404.textproto
@@ -33,11 +33,11 @@ test_vector_metadata {
     "8.5.1/Loudness Information"
   ]
   base_test: "test_000403"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000405.textproto b/iamf/cli/testdata/test_000405.textproto
index ae224f1..2c56aa8 100644
--- a/iamf/cli/testdata/test_000405.textproto
+++ b/iamf/cli/testdata/test_000405.textproto
@@ -33,11 +33,11 @@ test_vector_metadata {
     "8.5.1/Loudness Information"
   ]
   base_test: "test_000404"
-  output_wav_file_bit_depth_override: 16
 }
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_SIXTEEN
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000406.textproto b/iamf/cli/testdata/test_000406.textproto
index 39ddecc..a889430 100644
--- a/iamf/cli/testdata/test_000406.textproto
+++ b/iamf/cli/testdata/test_000406.textproto
@@ -30,6 +30,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000407.textproto b/iamf/cli/testdata/test_000407.textproto
index 1192bda..9699154 100644
--- a/iamf/cli/testdata/test_000407.textproto
+++ b/iamf/cli/testdata/test_000407.textproto
@@ -32,6 +32,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000408.textproto b/iamf/cli/testdata/test_000408.textproto
index 514be8f..f713860 100644
--- a/iamf/cli/testdata/test_000408.textproto
+++ b/iamf/cli/testdata/test_000408.textproto
@@ -38,6 +38,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000409.textproto b/iamf/cli/testdata/test_000409.textproto
index 6067cf4..5fbd5b1 100644
--- a/iamf/cli/testdata/test_000409.textproto
+++ b/iamf/cli/testdata/test_000409.textproto
@@ -34,6 +34,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000500.textproto b/iamf/cli/testdata/test_000500.textproto
index 763e279..0867fab 100644
--- a/iamf/cli/testdata/test_000500.textproto
+++ b/iamf/cli/testdata/test_000500.textproto
@@ -34,6 +34,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000501.textproto b/iamf/cli/testdata/test_000501.textproto
index d02e521..d148c1b 100644
--- a/iamf/cli/testdata/test_000501.textproto
+++ b/iamf/cli/testdata/test_000501.textproto
@@ -34,6 +34,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000502.textproto b/iamf/cli/testdata/test_000502.textproto
index 073566d..7113e3f 100644
--- a/iamf/cli/testdata/test_000502.textproto
+++ b/iamf/cli/testdata/test_000502.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000503.textproto b/iamf/cli/testdata/test_000503.textproto
index 82baa60..b65e496 100644
--- a/iamf/cli/testdata/test_000503.textproto
+++ b/iamf/cli/testdata/test_000503.textproto
@@ -34,6 +34,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000600.textproto b/iamf/cli/testdata/test_000600.textproto
index ab93b2e..2f125ea 100644
--- a/iamf/cli/testdata/test_000600.textproto
+++ b/iamf/cli/testdata/test_000600.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000601.textproto b/iamf/cli/testdata/test_000601.textproto
index 1c245da..4b2ff8a 100644
--- a/iamf/cli/testdata/test_000601.textproto
+++ b/iamf/cli/testdata/test_000601.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000602.textproto b/iamf/cli/testdata/test_000602.textproto
index 75817b9..948c83e 100644
--- a/iamf/cli/testdata/test_000602.textproto
+++ b/iamf/cli/testdata/test_000602.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000603.textproto b/iamf/cli/testdata/test_000603.textproto
index 25cb0a6..fe6ff64 100644
--- a/iamf/cli/testdata/test_000603.textproto
+++ b/iamf/cli/testdata/test_000603.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000604.textproto b/iamf/cli/testdata/test_000604.textproto
index a15d65f..a2c322c 100644
--- a/iamf/cli/testdata/test_000604.textproto
+++ b/iamf/cli/testdata/test_000604.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000605.textproto b/iamf/cli/testdata/test_000605.textproto
index ca2779d..5a986e9 100644
--- a/iamf/cli/testdata/test_000605.textproto
+++ b/iamf/cli/testdata/test_000605.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000606.textproto b/iamf/cli/testdata/test_000606.textproto
index e7b53d5..216dd5c 100644
--- a/iamf/cli/testdata/test_000606.textproto
+++ b/iamf/cli/testdata/test_000606.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000607.textproto b/iamf/cli/testdata/test_000607.textproto
index 09c1019..976386d 100644
--- a/iamf/cli/testdata/test_000607.textproto
+++ b/iamf/cli/testdata/test_000607.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000608.textproto b/iamf/cli/testdata/test_000608.textproto
index 71bb7a1..ee3bc5a 100644
--- a/iamf/cli/testdata/test_000608.textproto
+++ b/iamf/cli/testdata/test_000608.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000609.textproto b/iamf/cli/testdata/test_000609.textproto
index ad8bf14..697cae2 100644
--- a/iamf/cli/testdata/test_000609.textproto
+++ b/iamf/cli/testdata/test_000609.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000610.textproto b/iamf/cli/testdata/test_000610.textproto
index c5ba203..98397df 100644
--- a/iamf/cli/testdata/test_000610.textproto
+++ b/iamf/cli/testdata/test_000610.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000611.textproto b/iamf/cli/testdata/test_000611.textproto
index 22b8936..fe9a66c 100644
--- a/iamf/cli/testdata/test_000611.textproto
+++ b/iamf/cli/testdata/test_000611.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000612.textproto b/iamf/cli/testdata/test_000612.textproto
index 0bb810a..a3d123c 100644
--- a/iamf/cli/testdata/test_000612.textproto
+++ b/iamf/cli/testdata/test_000612.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000613.textproto b/iamf/cli/testdata/test_000613.textproto
index 7a83a2a..156a5c0 100644
--- a/iamf/cli/testdata/test_000613.textproto
+++ b/iamf/cli/testdata/test_000613.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000614.textproto b/iamf/cli/testdata/test_000614.textproto
index ab59392..6c250d8 100644
--- a/iamf/cli/testdata/test_000614.textproto
+++ b/iamf/cli/testdata/test_000614.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000615.textproto b/iamf/cli/testdata/test_000615.textproto
index 2a66c2d..15c8925 100644
--- a/iamf/cli/testdata/test_000615.textproto
+++ b/iamf/cli/testdata/test_000615.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000616.textproto b/iamf/cli/testdata/test_000616.textproto
index 74dbeb2..6fa503a 100644
--- a/iamf/cli/testdata/test_000616.textproto
+++ b/iamf/cli/testdata/test_000616.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000617.textproto b/iamf/cli/testdata/test_000617.textproto
index e7ff85c..e8623bf 100644
--- a/iamf/cli/testdata/test_000617.textproto
+++ b/iamf/cli/testdata/test_000617.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000618.textproto b/iamf/cli/testdata/test_000618.textproto
index 32e0bc5..c655bc8 100644
--- a/iamf/cli/testdata/test_000618.textproto
+++ b/iamf/cli/testdata/test_000618.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000619.textproto b/iamf/cli/testdata/test_000619.textproto
index d40fde9..7eed3f1 100644
--- a/iamf/cli/testdata/test_000619.textproto
+++ b/iamf/cli/testdata/test_000619.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000620.textproto b/iamf/cli/testdata/test_000620.textproto
index 0d215a8..5228736 100644
--- a/iamf/cli/testdata/test_000620.textproto
+++ b/iamf/cli/testdata/test_000620.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000621.textproto b/iamf/cli/testdata/test_000621.textproto
index 1d94bf3..87a40a6 100644
--- a/iamf/cli/testdata/test_000621.textproto
+++ b/iamf/cli/testdata/test_000621.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000622.textproto b/iamf/cli/testdata/test_000622.textproto
index 4ac9bd4..f190b31 100644
--- a/iamf/cli/testdata/test_000622.textproto
+++ b/iamf/cli/testdata/test_000622.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000623.textproto b/iamf/cli/testdata/test_000623.textproto
index 6484523..decb2f7 100644
--- a/iamf/cli/testdata/test_000623.textproto
+++ b/iamf/cli/testdata/test_000623.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000624.textproto b/iamf/cli/testdata/test_000624.textproto
index d2f7ced..bc65464 100644
--- a/iamf/cli/testdata/test_000624.textproto
+++ b/iamf/cli/testdata/test_000624.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000625.textproto b/iamf/cli/testdata/test_000625.textproto
index a3e4509..04547ce 100644
--- a/iamf/cli/testdata/test_000625.textproto
+++ b/iamf/cli/testdata/test_000625.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000626.textproto b/iamf/cli/testdata/test_000626.textproto
index 10928f9..81250d3 100644
--- a/iamf/cli/testdata/test_000626.textproto
+++ b/iamf/cli/testdata/test_000626.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000627.textproto b/iamf/cli/testdata/test_000627.textproto
index 7e591e1..9730050 100644
--- a/iamf/cli/testdata/test_000627.textproto
+++ b/iamf/cli/testdata/test_000627.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000628.textproto b/iamf/cli/testdata/test_000628.textproto
index a0b33d3..983cb6a 100644
--- a/iamf/cli/testdata/test_000628.textproto
+++ b/iamf/cli/testdata/test_000628.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000629.textproto b/iamf/cli/testdata/test_000629.textproto
index 9d14ceb..990abe7 100644
--- a/iamf/cli/testdata/test_000629.textproto
+++ b/iamf/cli/testdata/test_000629.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000630.textproto b/iamf/cli/testdata/test_000630.textproto
index 231c3cd..fdef7e7 100644
--- a/iamf/cli/testdata/test_000630.textproto
+++ b/iamf/cli/testdata/test_000630.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000631.textproto b/iamf/cli/testdata/test_000631.textproto
index f870dbb..15a5c5c 100644
--- a/iamf/cli/testdata/test_000631.textproto
+++ b/iamf/cli/testdata/test_000631.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000632.textproto b/iamf/cli/testdata/test_000632.textproto
index 4c9de32..f8c67f0 100644
--- a/iamf/cli/testdata/test_000632.textproto
+++ b/iamf/cli/testdata/test_000632.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000633.textproto b/iamf/cli/testdata/test_000633.textproto
index 6ee65f6..c1af231 100644
--- a/iamf/cli/testdata/test_000633.textproto
+++ b/iamf/cli/testdata/test_000633.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000700.textproto b/iamf/cli/testdata/test_000700.textproto
index abcaa54..74303c3 100644
--- a/iamf/cli/testdata/test_000700.textproto
+++ b/iamf/cli/testdata/test_000700.textproto
@@ -37,6 +37,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000701.textproto b/iamf/cli/testdata/test_000701.textproto
index 3b8a855..6357679 100644
--- a/iamf/cli/testdata/test_000701.textproto
+++ b/iamf/cli/testdata/test_000701.textproto
@@ -37,6 +37,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000702.textproto b/iamf/cli/testdata/test_000702.textproto
index 9a4b2f9..cc8bd56 100644
--- a/iamf/cli/testdata/test_000702.textproto
+++ b/iamf/cli/testdata/test_000702.textproto
@@ -42,6 +42,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000703.textproto b/iamf/cli/testdata/test_000703.textproto
index 0afee3e..dbe34ff 100644
--- a/iamf/cli/testdata/test_000703.textproto
+++ b/iamf/cli/testdata/test_000703.textproto
@@ -43,6 +43,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000704.textproto b/iamf/cli/testdata/test_000704.textproto
index b7e6665..1d1993b 100644
--- a/iamf/cli/testdata/test_000704.textproto
+++ b/iamf/cli/testdata/test_000704.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000705.textproto b/iamf/cli/testdata/test_000705.textproto
index 6dee85c..1239694 100644
--- a/iamf/cli/testdata/test_000705.textproto
+++ b/iamf/cli/testdata/test_000705.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000706.textproto b/iamf/cli/testdata/test_000706.textproto
index d9441ff..ca01a50 100644
--- a/iamf/cli/testdata/test_000706.textproto
+++ b/iamf/cli/testdata/test_000706.textproto
@@ -37,6 +37,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000707.textproto b/iamf/cli/testdata/test_000707.textproto
index d34f52a..30ccfc6 100644
--- a/iamf/cli/testdata/test_000707.textproto
+++ b/iamf/cli/testdata/test_000707.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000708.textproto b/iamf/cli/testdata/test_000708.textproto
index f720127..72a45e5 100644
--- a/iamf/cli/testdata/test_000708.textproto
+++ b/iamf/cli/testdata/test_000708.textproto
@@ -35,6 +35,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000709.textproto b/iamf/cli/testdata/test_000709.textproto
index 09171d9..f811e6c 100644
--- a/iamf/cli/testdata/test_000709.textproto
+++ b/iamf/cli/testdata/test_000709.textproto
@@ -36,6 +36,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000710.textproto b/iamf/cli/testdata/test_000710.textproto
index 45fc0b4..8415eb4 100644
--- a/iamf/cli/testdata/test_000710.textproto
+++ b/iamf/cli/testdata/test_000710.textproto
@@ -39,6 +39,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000711.textproto b/iamf/cli/testdata/test_000711.textproto
index 9a6ad63..1e7af99 100644
--- a/iamf/cli/testdata/test_000711.textproto
+++ b/iamf/cli/testdata/test_000711.textproto
@@ -41,6 +41,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/testdata/test_000712.textproto b/iamf/cli/testdata/test_000712.textproto
index 65015f2..ef98265 100644
--- a/iamf/cli/testdata/test_000712.textproto
+++ b/iamf/cli/testdata/test_000712.textproto
@@ -29,6 +29,7 @@ test_vector_metadata {
 
 encoder_control_metadata {
   add_build_information_tag: false
+  output_rendered_file_format: OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC
 }
 
 ia_sequence_header_metadata {
diff --git a/iamf/cli/tests/BUILD b/iamf/cli/tests/BUILD
index 16b4b1f..4245b92 100644
--- a/iamf/cli/tests/BUILD
+++ b/iamf/cli/tests/BUILD
@@ -62,6 +62,32 @@ cc_library(
     ],
 )
 
+cc_test(
+    name = "audio_frame_decoder_benchmark",
+    srcs = ["audio_frame_decoder_benchmark.cc"],
+    deps = [
+        ":cli_test_utils",
+        "//iamf/cli:audio_element_with_data",
+        "//iamf/cli:audio_frame_decoder",
+        "//iamf/cli:audio_frame_with_data",
+        "//iamf/cli/codec:aac_encoder",
+        "//iamf/cli/codec:encoder_base",
+        "//iamf/cli/codec:flac_encoder",
+        "//iamf/cli/codec:lpcm_encoder",
+        "//iamf/cli/codec:opus_encoder",
+        "//iamf/cli/proto:codec_config_cc_proto",
+        "//iamf/obu:audio_frame",
+        "//iamf/obu:codec_config",
+        "//iamf/obu:parameter_data",
+        "//iamf/obu:types",
+        "@com_google_absl//absl/container:flat_hash_map",
+        "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/memory",
+        "@com_google_absl//absl/types:span",
+        "@com_google_benchmark//:benchmark_main",
+    ],
+)
+
 cc_test(
     name = "audio_frame_decoder_test",
     srcs = ["audio_frame_decoder_test.cc"],
@@ -139,6 +165,32 @@ cc_test(
     ],
 )
 
+cc_test(
+    name = "demixing_module_benchmark",
+    srcs = ["demixing_module_benchmark.cc"],
+    deps = [
+        ":cli_test_utils",
+        "//iamf/cli:audio_element_with_data",
+        "//iamf/cli:audio_frame_decoder",
+        "//iamf/cli:audio_frame_with_data",
+        "//iamf/cli:channel_label",
+        "//iamf/cli:demixing_module",
+        "//iamf/cli/proto:user_metadata_cc_proto",
+        "//iamf/cli/proto_conversion:channel_label_utils",
+        "//iamf/cli/proto_conversion:downmixing_reconstruction_util",
+        "//iamf/obu:audio_element",
+        "//iamf/obu:audio_frame",
+        "//iamf/obu:obu_header",
+        "//iamf/obu:parameter_data",
+        "//iamf/obu:types",
+        "@com_google_absl//absl/container:flat_hash_map",
+        "@com_google_absl//absl/log:check",
+        "@com_google_absl//absl/status:statusor",
+        "@com_google_absl//absl/types:span",
+        "@com_google_benchmark//:benchmark_main",
+    ],
+)
+
 cc_test(
     name = "demixing_module_test",
     srcs = ["demixing_module_test.cc"],
@@ -181,7 +233,9 @@ cc_test(
         ":cli_test_utils",
         "//iamf/cli:encoder_main_lib",
         "//iamf/cli/proto:codec_config_cc_proto",
+        "//iamf/cli/proto:encoder_control_metadata_cc_proto",
         "//iamf/cli/proto:ia_sequence_header_cc_proto",
+        "//iamf/cli/proto:output_audio_format_cc_proto",
         "//iamf/cli/proto:test_vector_metadata_cc_proto",
         "//iamf/cli/proto:user_metadata_cc_proto",
         "@com_google_absl//absl/log",
@@ -294,6 +348,7 @@ cc_test(
         "//iamf/obu:temporal_delimiter",
         "//iamf/obu:types",
         "@com_google_absl//absl/container:flat_hash_map",
+        "@com_google_absl//absl/container:flat_hash_set",
         "@com_google_absl//absl/status:status_matchers",
         "@com_google_absl//absl/strings:string_view",
         "@com_google_absl//absl/types:span",
@@ -362,6 +417,31 @@ cc_test(
     ],
 )
 
+cc_test(
+    name = "obu_sequencer_streaming_iamf_test",
+    srcs = ["obu_sequencer_streaming_iamf_test.cc"],
+    deps = [
+        ":cli_test_utils",
+        "//iamf/cli:audio_element_with_data",
+        "//iamf/cli:audio_frame_with_data",
+        "//iamf/cli:obu_sequencer_streaming_iamf",
+        "//iamf/cli:parameter_block_with_data",
+        "//iamf/cli:temporal_unit_view",
+        "//iamf/common:leb_generator",
+        "//iamf/obu:arbitrary_obu",
+        "//iamf/obu:audio_frame",
+        "//iamf/obu:codec_config",
+        "//iamf/obu:ia_sequence_header",
+        "//iamf/obu:obu_base",
+        "//iamf/obu:obu_header",
+        "//iamf/obu:types",
+        "@com_google_absl//absl/container:flat_hash_map",
+        "@com_google_absl//absl/status:status_matchers",
+        "@com_google_absl//absl/types:span",
+        "@com_google_googletest//:gtest_main",
+    ],
+)
+
 cc_test(
     name = "obu_with_data_generator_test",
     srcs = ["obu_with_data_generator_test.cc"],
@@ -398,6 +478,7 @@ cc_test(
         "//iamf/cli:parameter_block_partitioner",
         "//iamf/cli/proto:parameter_block_cc_proto",
         "//iamf/cli/proto:parameter_data_cc_proto",
+        "//iamf/obu:types",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:status_matchers",
         "@com_google_googletest//:gtest_main",
diff --git a/iamf/cli/tests/audio_frame_decoder_benchmark.cc b/iamf/cli/tests/audio_frame_decoder_benchmark.cc
new file mode 100644
index 0000000..7bf49a5
--- /dev/null
+++ b/iamf/cli/tests/audio_frame_decoder_benchmark.cc
@@ -0,0 +1,193 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#include <array>
+#include <cstdint>
+#include <list>
+#include <memory>
+#include <utility>
+#include <vector>
+
+#include "absl/container/flat_hash_map.h"
+#include "absl/log/check.h"
+#include "absl/memory/memory.h"
+#include "absl/types/span.h"
+#include "benchmark/benchmark.h"
+#include "iamf/cli/audio_element_with_data.h"
+#include "iamf/cli/audio_frame_decoder.h"
+#include "iamf/cli/audio_frame_with_data.h"
+#include "iamf/cli/codec/aac_encoder.h"
+#include "iamf/cli/codec/encoder_base.h"
+#include "iamf/cli/codec/flac_encoder.h"
+#include "iamf/cli/codec/lpcm_encoder.h"
+#include "iamf/cli/codec/opus_encoder.h"
+#include "iamf/cli/proto/codec_config.pb.h"
+#include "iamf/cli/tests/cli_test_utils.h"
+#include "iamf/obu/audio_frame.h"
+#include "iamf/obu/codec_config.h"
+#include "iamf/obu/types.h"
+
+namespace iamf_tools {
+namespace {
+
+constexpr DecodedUleb128 kCodecConfigId = 57;
+constexpr uint32_t kSampleRate = 48000;
+constexpr uint8_t kSampleSize = 16;
+constexpr int kOneChannel = 1;
+constexpr bool kValidateCodecDelay = true;
+constexpr DecodedUleb128 kAudioElementId = 9;
+constexpr DecodedUleb128 kSubstreamId = 11;
+
+static std::unique_ptr<AacEncoder> CreateAacEncoder(
+    const CodecConfigObu& codec_config) {
+  iamf_tools_cli_proto::AacEncoderMetadata aac_encoder_metadata;
+  aac_encoder_metadata.set_bitrate_mode(0);
+  aac_encoder_metadata.set_enable_afterburner(true);
+  aac_encoder_metadata.set_signaling_mode(2);
+  auto encoder = std::make_unique<AacEncoder>(aac_encoder_metadata,
+                                              codec_config, kOneChannel);
+  return encoder;
+}
+
+static std::unique_ptr<FlacEncoder> CreateFlacEncoder(
+    const CodecConfigObu& codec_config) {
+  // Encoder.
+  iamf_tools_cli_proto::FlacEncoderMetadata flac_encoder_metadata;
+  flac_encoder_metadata.set_compression_level(0);
+  auto encoder = std::make_unique<FlacEncoder>(flac_encoder_metadata,
+                                               codec_config, kOneChannel);
+  return encoder;
+}
+
+static std::unique_ptr<OpusEncoder> CreateOpusEncoder(
+    const CodecConfigObu& codec_config) {
+  // Encoder.
+  iamf_tools_cli_proto::OpusEncoderMetadata opus_encoder_metadata;
+  opus_encoder_metadata.set_target_bitrate_per_channel(48000);
+  opus_encoder_metadata.set_application(
+      iamf_tools_cli_proto::APPLICATION_AUDIO);
+  auto encoder = std::make_unique<OpusEncoder>(
+      opus_encoder_metadata, codec_config, kOneChannel, kSubstreamId);
+  return encoder;
+}
+
+static AudioFrameWithData PrepareEncodedAudioFrame(
+    const uint32_t num_samples_per_frame,
+    absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus,
+    CodecConfig::CodecId codec_id_type) {
+  std::unique_ptr<EncoderBase> encoder;
+  if (codec_id_type == CodecConfig::kCodecIdAacLc) {
+    AddAacCodecConfig(kCodecConfigId, num_samples_per_frame, codec_config_obus);
+    encoder = CreateAacEncoder(codec_config_obus.at(kCodecConfigId));
+  } else if (codec_id_type == CodecConfig::kCodecIdFlac) {
+    AddFlacCodecConfig(kCodecConfigId, num_samples_per_frame, kSampleRate,
+                       kSampleSize, codec_config_obus);
+    encoder = CreateFlacEncoder(codec_config_obus.at(kCodecConfigId));
+  } else if (codec_id_type == CodecConfig::kCodecIdLpcm) {
+    AddLpcmCodecConfig(kCodecConfigId, num_samples_per_frame, kSampleSize,
+                       kSampleRate, codec_config_obus);
+    encoder = std::make_unique<LpcmEncoder>(
+        codec_config_obus.at(kCodecConfigId), kOneChannel);
+  } else if (codec_id_type == CodecConfig::kCodecIdOpus) {
+    AddOpusCodecConfig(kCodecConfigId, num_samples_per_frame, kSampleRate,
+                       codec_config_obus);
+    encoder = CreateOpusEncoder(codec_config_obus.at(kCodecConfigId));
+  }
+  CHECK_NE(encoder, nullptr);
+  CHECK_OK(encoder->Initialize(kValidateCodecDelay));
+
+  std::vector<uint8_t> encoded_audio_frame_payload = {};
+  auto partial_audio_frame_with_data = absl::WrapUnique(new AudioFrameWithData{
+      .obu = AudioFrameObu(
+          {
+              .obu_trimming_status_flag = false,
+              .num_samples_to_trim_at_end = 0,
+              .num_samples_to_trim_at_start = 0,
+          },
+          kSubstreamId, absl::MakeConstSpan(encoded_audio_frame_payload)),
+      .start_timestamp = 0,
+      .end_timestamp = num_samples_per_frame,
+  });
+
+  // Encode a frame of one channel with `num_samples_per_frame` samples.
+  std::vector<std::vector<int32_t>> pcm_samples(kOneChannel);
+  pcm_samples[0].resize(num_samples_per_frame, 0);
+  CHECK_OK(encoder->EncodeAudioFrame(kSampleSize, pcm_samples,
+                                     std::move(partial_audio_frame_with_data)));
+  std::list<AudioFrameWithData> output_audio_frames;
+  CHECK_OK(encoder->Finalize());
+  CHECK_OK(encoder->Pop(output_audio_frames));
+
+  return output_audio_frames.back();
+}
+
+static void InitAudioFrameDecoder(
+    const absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus,
+    absl::flat_hash_map<DecodedUleb128, AudioElementWithData>& audio_elements,
+    AudioFrameDecoder& decoder) {
+  AddAmbisonicsMonoAudioElementWithSubstreamIds(
+      kAudioElementId, kCodecConfigId, {kSubstreamId}, codec_config_obus,
+      audio_elements);
+  for (const auto& [audio_element_id, audio_element_with_data] :
+       audio_elements) {
+    CHECK_OK(decoder.InitDecodersForSubstreams(
+        audio_element_with_data.substream_id_to_labels,
+        *audio_element_with_data.codec_config));
+  }
+}
+
+static void BM_DecodeForCodecId(const CodecConfig::CodecId codec_id_type,
+                                benchmark::State& state) {
+  // Prepare the input, which is an encoded audio frame.
+  const uint32_t num_samples_per_frame = state.range(0);
+  absl::flat_hash_map<uint32_t, CodecConfigObu> codec_config_obus;
+  const AudioFrameWithData encoded_audio_frame = PrepareEncodedAudioFrame(
+      num_samples_per_frame, codec_config_obus, codec_id_type);
+
+  // Prepare the audio frame decoder.
+  absl::flat_hash_map<DecodedUleb128, AudioElementWithData> audio_elements;
+  AudioFrameDecoder decoder;
+  InitAudioFrameDecoder(codec_config_obus, audio_elements, decoder);
+
+  // Measure the calls to `AudioFrameDecoder::Decode()`, which decodes a frame.
+  for (auto _ : state) {
+    const auto& decoded_audio_frame = decoder.Decode(encoded_audio_frame);
+    CHECK_OK(decoded_audio_frame);
+  }
+}
+
+static void BM_DecodeAac(benchmark::State& state) {
+  BM_DecodeForCodecId(CodecConfig::kCodecIdAacLc, state);
+}
+
+static void BM_DecodeFlac(benchmark::State& state) {
+  BM_DecodeForCodecId(CodecConfig::kCodecIdFlac, state);
+}
+
+static void BM_DecodeLpcm(benchmark::State& state) {
+  BM_DecodeForCodecId(CodecConfig::kCodecIdLpcm, state);
+}
+
+static void BM_DecodeOpus(benchmark::State& state) {
+  BM_DecodeForCodecId(CodecConfig::kCodecIdOpus, state);
+}
+
+// Benchmark with various numbers of samples per frame.
+BENCHMARK(BM_DecodeFlac)->Args({480})->Args({960})->Args({1920});
+BENCHMARK(BM_DecodeLpcm)->Args({480})->Args({960})->Args({1920});
+BENCHMARK(BM_DecodeOpus)->Args({480})->Args({960})->Args({1920});
+
+// AAC-LC only supports a frame size of 1024.
+BENCHMARK(BM_DecodeAac)->Args({1024});
+
+}  // namespace
+}  // namespace iamf_tools
diff --git a/iamf/cli/tests/audio_frame_decoder_test.cc b/iamf/cli/tests/audio_frame_decoder_test.cc
index 43a978c..0ce52d1 100644
--- a/iamf/cli/tests/audio_frame_decoder_test.cc
+++ b/iamf/cli/tests/audio_frame_decoder_test.cc
@@ -156,11 +156,10 @@ TEST(Decode, DecodesLpcmFrame) {
   // For LPCM, the input bytes are all zeros, but we expect the decoder to
   // combine kBytesPerSample bytes each into one int32_t sample.
   // There are kNumSamplesPerFrame samples in the frame.
-  EXPECT_EQ(decoded_audio_frame->decoded_samples.size(), kNumSamplesPerFrame);
-  for (const std::vector<int32_t>& samples_for_one_time_tick :
-       decoded_audio_frame->decoded_samples) {
-    EXPECT_EQ(samples_for_one_time_tick.size(), kNumChannels);
-    for (int32_t sample : samples_for_one_time_tick) {
+  EXPECT_EQ(decoded_audio_frame->decoded_samples.size(), kNumChannels);
+  for (const auto& samples_for_channel : decoded_audio_frame->decoded_samples) {
+    EXPECT_EQ(samples_for_channel.size(), kNumSamplesPerFrame);
+    for (int32_t sample : samples_for_channel) {
       EXPECT_EQ(sample, 0);
     }
   }
@@ -191,22 +190,16 @@ TEST(Decode, DecodesFlacFrame) {
   EXPECT_EQ(decoded_audio_frame->audio_element_with_data,
             &audio_elements.at(kAudioElementId));
   const std::vector<std::vector<int32_t>> kExpectedDecodedSamples = {
-      {0x00010000, static_cast<int32_t>(0xffff0000)},
-      {0x00020000, static_cast<int32_t>(0xfffe0000)},
-      {0x00030000, static_cast<int32_t>(0xfffd0000)},
-      {0x00040000, static_cast<int32_t>(0xfffc0000)},
-      {0x00050000, static_cast<int32_t>(0xfffb0000)},
-      {0x00060000, static_cast<int32_t>(0xfffa0000)},
-      {0x00070000, static_cast<int32_t>(0xfff90000)},
-      {0x00080000, static_cast<int32_t>(0xfff80000)},
-      {0x00000000, 0x00000000},
-      {0x00000000, 0x00000000},
-      {0x00000000, 0x00000000},
-      {0x00000000, 0x00000000},
-      {0x00000000, 0x00000000},
-      {0x00000000, 0x00000000},
-      {0x00000000, 0x00000000},
-      {0x00000000, 0x00000000}};
+      {0x00010000, 0x00020000, 0x00030000, 0x00040000, 0x00050000, 0x00060000,
+       0x00070000, 0x00080000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+       0x00000000, 0x00000000, 0x00000000, 0x00000000},
+      {static_cast<int32_t>(0xffff0000), static_cast<int32_t>(0xfffe0000),
+       static_cast<int32_t>(0xfffd0000), static_cast<int32_t>(0xfffc0000),
+       static_cast<int32_t>(0xfffb0000), static_cast<int32_t>(0xfffa0000),
+       static_cast<int32_t>(0xfff90000), static_cast<int32_t>(0xfff80000),
+       0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+       0x00000000, 0x00000000}};
+
   EXPECT_EQ(decoded_audio_frame->decoded_samples, kExpectedDecodedSamples);
 }
 
diff --git a/iamf/cli/tests/cli_test_utils.cc b/iamf/cli/tests/cli_test_utils.cc
index 3d72e5a..219984c 100644
--- a/iamf/cli/tests/cli_test_utils.cc
+++ b/iamf/cli/tests/cli_test_utils.cc
@@ -175,12 +175,13 @@ void AddLpcmCodecConfigWithIdAndSampleRate(
   // values.
   constexpr uint32_t kNumSamplesPerFrame = 8;
   constexpr uint8_t kSampleSize = 16;
-  return AddLpcmCodecConfig(codec_config_id, kNumSamplesPerFrame, kSampleSize,
-                            sample_rate, codec_config_obus);
+  AddLpcmCodecConfig(codec_config_id, kNumSamplesPerFrame, kSampleSize,
+                     sample_rate, codec_config_obus);
 }
 
-void AddOpusCodecConfigWithId(
-    uint32_t codec_config_id,
+void AddOpusCodecConfig(
+    uint32_t codec_config_id, uint32_t num_samples_per_frame,
+    uint32_t sample_rate,
     absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus) {
   // Initialize the Codec Config OBU.
   ASSERT_EQ(codec_config_obus.find(codec_config_id), codec_config_obus.end());
@@ -188,51 +189,82 @@ void AddOpusCodecConfigWithId(
   CodecConfigObu obu(
       ObuHeader(), codec_config_id,
       {.codec_id = CodecConfig::kCodecIdOpus,
-       .num_samples_per_frame = 8,
-       .decoder_config = OpusDecoderConfig{
-           .version_ = 1, .pre_skip_ = 312, .input_sample_rate_ = 0}});
+       .num_samples_per_frame = num_samples_per_frame,
+       .decoder_config = OpusDecoderConfig{.version_ = 1,
+                                           .pre_skip_ = 312,
+                                           .input_sample_rate_ = sample_rate}});
   ASSERT_THAT(obu.Initialize(kOverrideAudioRollDistance), IsOk());
   codec_config_obus.emplace(codec_config_id, std::move(obu));
 }
 
-void AddFlacCodecConfigWithId(
+void AddOpusCodecConfigWithId(
     uint32_t codec_config_id,
     absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus) {
+  const uint32_t kNumSamplesPerFrame = 8;
+  const uint32_t kSampleRate = 48000;
+
+  AddOpusCodecConfig(codec_config_id, kNumSamplesPerFrame, kSampleRate,
+                     codec_config_obus);
+}
+
+void AddFlacCodecConfig(
+    uint32_t codec_config_id, uint32_t num_samples_per_frame,
+    uint32_t sample_rate, uint8_t sample_size,
+    absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus) {
   // Initialize the Codec Config OBU.
   ASSERT_EQ(codec_config_obus.find(codec_config_id), codec_config_obus.end());
 
   CodecConfigObu obu(
       ObuHeader(), codec_config_id,
       {.codec_id = CodecConfig::kCodecIdFlac,
-       .num_samples_per_frame = 16,
+       .num_samples_per_frame = num_samples_per_frame,
        .decoder_config = FlacDecoderConfig(
            {{{.header = {.last_metadata_block_flag = true,
                          .block_type = FlacMetaBlockHeader::kFlacStreamInfo,
                          .metadata_data_block_length = 34},
-              .payload =
-                  FlacMetaBlockStreamInfo{.minimum_block_size = 16,
-                                          .maximum_block_size = 16,
-                                          .sample_rate = 48000,
-                                          .bits_per_sample = 15,
-                                          .total_samples_in_stream = 0}}}})});
+              .payload = FlacMetaBlockStreamInfo{
+                  .minimum_block_size =
+                      static_cast<uint16_t>(num_samples_per_frame),
+                  .maximum_block_size =
+                      static_cast<uint16_t>(num_samples_per_frame),
+                  .sample_rate = sample_rate,
+                  .bits_per_sample = static_cast<uint8_t>(sample_size - 1),
+                  .total_samples_in_stream = 0}}}})});
   ASSERT_THAT(obu.Initialize(kOverrideAudioRollDistance), IsOk());
   codec_config_obus.emplace(codec_config_id, std::move(obu));
 }
 
-void AddAacCodecConfigWithId(
+void AddFlacCodecConfigWithId(
     uint32_t codec_config_id,
     absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus) {
+  const uint32_t kNumSamplesPerFrame = 16;
+  const uint32_t kSampleRate = 48000;
+  const uint8_t kSampleSize = 16;
+  AddFlacCodecConfig(codec_config_id, kNumSamplesPerFrame, kSampleRate,
+                     kSampleSize, codec_config_obus);
+}
+
+void AddAacCodecConfig(
+    uint32_t codec_config_id, uint32_t num_samples_per_frame,
+    absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus) {
   // Initialize the Codec Config OBU.
   ASSERT_EQ(codec_config_obus.find(codec_config_id), codec_config_obus.end());
 
   CodecConfigObu obu(ObuHeader(), codec_config_id,
                      {.codec_id = CodecConfig::kCodecIdAacLc,
-                      .num_samples_per_frame = 1024,
+                      .num_samples_per_frame = num_samples_per_frame,
                       .decoder_config = AacDecoderConfig{}});
   ASSERT_THAT(obu.Initialize(kOverrideAudioRollDistance), IsOk());
   codec_config_obus.emplace(codec_config_id, std::move(obu));
 }
 
+void AddAacCodecConfigWithId(
+    uint32_t codec_config_id,
+    absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus) {
+  const uint32_t kNumSamplesPerFrame = 1024;
+  AddAacCodecConfig(codec_config_id, kNumSamplesPerFrame, codec_config_obus);
+}
+
 void AddAmbisonicsMonoAudioElementWithSubstreamIds(
     DecodedUleb128 audio_element_id, uint32_t codec_config_id,
     absl::Span<const DecodedUleb128> substream_ids,
@@ -552,11 +584,11 @@ std::vector<InternalSampleType> GenerateSineWav(uint64_t start_tick,
 }
 
 void AccumulateZeroCrossings(
-    absl::Span<const std::vector<int32_t>> samples,
+    absl::Span<const absl::Span<const int32_t>> channel_time_samples,
     std::vector<ZeroCrossingState>& zero_crossing_states,
     std::vector<int>& zero_crossing_counts) {
   using enum ZeroCrossingState;
-  const auto num_channels = samples.empty() ? 0 : samples[0].size();
+  const auto num_channels = channel_time_samples.size();
   // Seed the data structures, or check they contain the right number of
   // channels.
   if (zero_crossing_counts.empty()) {
@@ -575,19 +607,20 @@ void AccumulateZeroCrossings(
   // the sine wave stopped.)  Note that -18 dB would correspond to dividing
   // by 8, while dividing by 100 is -40 dB.
   constexpr int32_t kThreshold = std::numeric_limits<int32_t>::max() / 100;
-  for (const auto& tick : samples) {
-    ASSERT_EQ(tick.size(), num_channels);
-    for (int i = 0; i < num_channels; ++i) {
-      ZeroCrossingState next_state = (tick[i] > kThreshold)    ? kPositive
-                                     : (tick[i] < -kThreshold) ? kNegative
-                                                               : kUnknown;
+
+  for (int c = 0; c < num_channels; c++) {
+    const auto& channel = channel_time_samples[c];
+    for (int t = 0; t < channel.size(); ++t) {
+      ZeroCrossingState next_state = (channel[t] > kThreshold)    ? kPositive
+                                     : (channel[t] < -kThreshold) ? kNegative
+                                                                  : kUnknown;
       if (next_state == kUnknown) {
         // Don't do anything if it's not clearly positive or negative.
         continue;
-      } else if (zero_crossing_states[i] != next_state) {
+      } else if (zero_crossing_states[c] != next_state) {
         // If we clearly flipped states, count it as a zero crossing.
-        zero_crossing_counts[i]++;
-        zero_crossing_states[i] = next_state;
+        zero_crossing_counts[c]++;
+        zero_crossing_states[c] = next_state;
       }
     }
   }
@@ -611,43 +644,54 @@ absl::Status ReadFileToBytes(const std::filesystem::path& file_path,
 }
 
 absl::Status EverySecondTickResampler::PushFrameDerived(
-    absl::Span<const std::vector<int32_t>> time_channel_samples) {
-  EXPECT_EQ(num_valid_ticks_, 0);  // `SampleProcessorBase` should ensure this.
-  for (size_t i = 0; i < time_channel_samples.size(); ++i) {
-    if (i % 2 == 1) {
-      output_time_channel_samples_[num_valid_ticks_] = time_channel_samples[i];
-      ++num_valid_ticks_;
+    absl::Span<const absl::Span<const int32_t>> channel_time_samples) {
+  for (int c = 0; c < num_channels_; c++) {
+    // `SampleProcessorBase` should ensure this.
+    EXPECT_TRUE(output_channel_time_samples_[c].empty());
+    for (size_t i = 0; i < channel_time_samples[c].size(); ++i) {
+      if (i % 2 == 1) {
+        output_channel_time_samples_[c].push_back(channel_time_samples[c][i]);
+      }
     }
   }
   return absl::OkStatus();
 }
 
 absl::Status EverySecondTickResampler::FlushDerived() {
-  EXPECT_EQ(num_valid_ticks_, 0);  // `SampleProcessorBase` should ensure this.
+  // `SampleProcessorBase` should ensure this.
+  for (int c = 0; c < num_channels_; c++) {
+    // `SampleProcessorBase` should ensure this.
+    EXPECT_TRUE(output_channel_time_samples_[c].empty());
+  }
   return absl::OkStatus();
 }
 
 absl::Status OneFrameDelayer::PushFrameDerived(
-    absl::Span<const std::vector<int32_t>> time_channel_samples) {
+    absl::Span<const absl::Span<const int32_t>> channel_time_samples) {
   // Swap the delayed samples with the output samples from the base class.
-  std::swap(delayed_samples_, output_time_channel_samples_);
-  std::swap(num_delayed_ticks_, num_valid_ticks_);
-
-  // The fact that the input size is less than the output size should have
-  // already been validated in `SampleProcessorBase`, but for safety we can
-  // check it here.
-  EXPECT_LE(time_channel_samples.size(), delayed_samples_.size());
-  // Cache the new samples to delay.
-  std::copy(time_channel_samples.begin(), time_channel_samples.end(),
-            delayed_samples_.begin());
-  num_delayed_ticks_ = time_channel_samples.size();
+  std::swap(delayed_samples_, output_channel_time_samples_);
+
+  num_delayed_ticks_ = 0;
+  for (int c = 0; c < num_channels_; c++) {
+    delayed_samples_[c].resize(channel_time_samples[c].size());
+
+    // Cache the new samples to delay.
+    std::copy(channel_time_samples[c].begin(), channel_time_samples[c].end(),
+              delayed_samples_[c].begin());
+
+    if (num_delayed_ticks_ == 0) {
+      num_delayed_ticks_ = channel_time_samples[c].size();
+    }
+    EXPECT_EQ(num_delayed_ticks_, channel_time_samples[c].size());
+  }
 
   return absl::OkStatus();
 }
 
 absl::Status OneFrameDelayer::FlushDerived() {
   // Pushing in an empty frame will cause the delayed frame to be available.
-  return PushFrameDerived({});
+  auto empty_frame = std::vector<absl::Span<const int32_t>>(num_channels_);
+  return PushFrameDerived(absl::MakeConstSpan(empty_frame));
 }
 
 }  // namespace iamf_tools
diff --git a/iamf/cli/tests/cli_test_utils.h b/iamf/cli/tests/cli_test_utils.h
index eb86a9a..455b3fb 100644
--- a/iamf/cli/tests/cli_test_utils.h
+++ b/iamf/cli/tests/cli_test_utils.h
@@ -92,7 +92,7 @@ struct DecodeSpecification {
  *
  * \param codec_config_id `codec_config_id` of the OBU to create.
  * \param num_samples_per_frame Number of samples per frame.
- * \param sample_size Sample size.
+ * \param sample_size Sample size in bits.
  * \param sample_rate `sample_rate` of the OBU to create.
  * \param codec_config_obus Map to add the OBU to keyed by `codec_config_id`.
  */
@@ -111,6 +111,18 @@ void AddLpcmCodecConfigWithIdAndSampleRate(
     uint32_t codec_config_id, uint32_t sample_rate,
     absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus);
 
+/*!\brief Adds a configurable Opus `CodecConfigObu` to the output argument.
+ *
+ * \param codec_config_id `codec_config_id` of the OBU to create.
+ * \param num_samples_per_frame Number of samples per frame.
+ * \param sample_rate `sample_rate` of the OBU to create.
+ * \param codec_config_obus Map to add the OBU to keyed by `codec_config_id`.
+ */
+void AddOpusCodecConfig(
+    uint32_t codec_config_id, uint32_t num_samples_per_frame,
+    uint32_t sample_rate,
+    absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus);
+
 /*!\brief Adds a configurable Opus `CodecConfigObu` to the output argument.
  *
  * \param codec_config_id `codec_config_id` of the OBU to create.
@@ -120,6 +132,19 @@ void AddOpusCodecConfigWithId(
     uint32_t codec_config_id,
     absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus);
 
+/*!\brief Adds a configurable Flac `CodecConfigObu` to the output argument.
+ *
+ * \param codec_config_id `codec_config_id` of the OBU to create.
+ * \param num_samples_per_frame Number of samples per frame.
+ * \param sample_rate `sample_rate` of the OBU to create.
+ * \param sample_size Sample size in bits.
+ * \param codec_config_obus Map to add the OBU to keyed by `codec_config_id`.
+ */
+void AddFlacCodecConfig(
+    uint32_t codec_config_id, uint32_t num_samples_per_frame,
+    uint32_t sample_rate, uint8_t sample_size,
+    absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus);
+
 /*!\brief Adds a configurable Flac `CodecConfigObu` to the output argument.
  *
  * \param codec_config_id `codec_config_id` of the OBU to create.
@@ -129,6 +154,16 @@ void AddFlacCodecConfigWithId(
     uint32_t codec_config_id,
     absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus);
 
+/*!\brief Adds a configurable AAC `CodecConfigObu` to the output argument.
+ *
+ * \param codec_config_id `codec_config_id` of the OBU to create.
+ * \param num_samples_per_frame Number of samples per frame.
+ * \param codec_config_obus Map to add the OBU to keyed by `codec_config_id`.
+ */
+void AddAacCodecConfig(
+    uint32_t codec_config_id, uint32_t num_samples_per_frame,
+    absl::flat_hash_map<uint32_t, CodecConfigObu>& codec_config_obus);
+
 /*!\brief Adds a configurable AAC `CodecConfigObu` to the output argument.
  *
  * \param codec_config_id `codec_config_id` of the OBU to create.
@@ -371,6 +406,24 @@ std::vector<InternalSampleType> GenerateSineWav(uint64_t start_tick,
                                                 double frequency_hz,
                                                 double amplitude);
 
+/*!\brief Converts a vector of vectors to a span of constant spans.
+ *
+ * \param input Input vector of vectors.
+ * \return Output span of constant spans.
+ */
+template <typename ValueType>
+inline absl::Span<const absl::Span<const ValueType>> MakeSpanOfConstSpans(
+    const std::vector<std::vector<ValueType>>& input) {
+  static std::vector<absl::Span<const ValueType>> buffer_of_spans;
+  buffer_of_spans.resize(input.size());
+
+  for (int i = 0; i < input.size(); i++) {
+    buffer_of_spans[i] = absl::MakeConstSpan(input[i]);
+  }
+
+  return absl::MakeConstSpan(buffer_of_spans);
+}
+
 /*!\brief Counts the zero crossings for each channel.
  *
  * The first time a user calls this, the `zero_crossing_states` and
@@ -381,7 +434,7 @@ std::vector<InternalSampleType> GenerateSineWav(uint64_t start_tick,
  * single audio channel, while allowing data to be processed in chunks (i.e.
  * frames).
  *
- * \param tick_channel_samples Samples arranged in (time, channel) axes.
+ * \param channel_time_samples Samples arranged in (channel, time) axes.
  * \param zero_crossing_states Initial state for each channel. Used between
  *        subsequence calls to `CountZeroCrossings` to track the state of each
  *        channel.
@@ -390,9 +443,10 @@ std::vector<InternalSampleType> GenerateSineWav(uint64_t start_tick,
  */
 enum class ZeroCrossingState { kUnknown, kPositive, kNegative };
 void AccumulateZeroCrossings(
-    absl::Span<const std::vector<int32_t>> tick_channel_samples,
+    absl::Span<const absl::Span<const int32_t>> channel_time_samples,
     std::vector<ZeroCrossingState>& zero_crossing_states,
     std::vector<int>& zero_crossing_counts);
+
 /*!\brief Reads the contents of the file and appends it to `buffer`.
  *
  * \param file_path Path of file to read.
@@ -450,9 +504,10 @@ class MockSampleProcessor : public SampleProcessorBase {
       : SampleProcessorBase(max_input_samples_per_frame, num_channels,
                             max_output_samples_per_frame) {}
 
-  MOCK_METHOD(absl::Status, PushFrameDerived,
-              (absl::Span<const std::vector<int32_t>> time_channel_samples),
-              (override));
+  MOCK_METHOD(
+      absl::Status, PushFrameDerived,
+      (absl::Span<const absl::Span<const int32_t>> channel_time_samples),
+      (override));
 
   MOCK_METHOD(absl::Status, FlushDerived, (), (override));
 };
@@ -470,11 +525,11 @@ class EverySecondTickResampler : public SampleProcessorBase {
  private:
   /*!\brief Pushes a frame of samples to be resampled.
    *
-   * \param time_channel_samples Samples to push arranged in (time, channel).
+   * \param channel_time_samples Samples to push arranged in (channel, time).
    * \return `absl::OkStatus()` on success. A specific status on failure.
    */
-  absl::Status PushFrameDerived(
-      absl::Span<const std::vector<int32_t>> time_channel_samples) override;
+  absl::Status PushFrameDerived(absl::Span<const absl::Span<const int32_t>>
+                                    channel_time_samples) override;
 
   /*!\brief Signals to close the resampler and flush any remaining samples.
    *
@@ -509,17 +564,16 @@ class OneFrameDelayer : public SampleProcessorBase {
       : SampleProcessorBase(max_input_num_samples_per_frame, num_channels,
                             /*max_output_samples_per_frame=*/
                             max_input_num_samples_per_frame),
-        delayed_samples_(max_input_num_samples_per_frame,
-                         std::vector<int32_t>(num_channels)) {}
+        delayed_samples_(num_channels) {}
 
  private:
   /*!\brief Pushes a frame of samples to be resampled.
    *
-   * \param time_channel_samples Samples to push arranged in (time, channel).
+   * \param channel_time_samples Samples to push arranged in (channel, time).
    * \return `absl::OkStatus()` on success. A specific status on failure.
    */
-  absl::Status PushFrameDerived(
-      absl::Span<const std::vector<int32_t>> time_channel_samples) override;
+  absl::Status PushFrameDerived(absl::Span<const absl::Span<const int32_t>>
+                                    channel_time_samples) override;
 
   /*!\brief Signals to close the resampler and flush any remaining samples.
    *
@@ -549,9 +603,10 @@ class MockLoudnessCalculator : public LoudnessCalculatorBase {
  public:
   MockLoudnessCalculator() : LoudnessCalculatorBase() {}
 
-  MOCK_METHOD(absl::Status, AccumulateLoudnessForSamples,
-              (absl::Span<const std::vector<int32_t>> time_channel_samples),
-              (override));
+  MOCK_METHOD(
+      absl::Status, AccumulateLoudnessForSamples,
+      (absl::Span<const absl::Span<const int32_t>> channel_time_samples),
+      (override));
 
   MOCK_METHOD(absl::StatusOr<LoudnessInfo>, QueryLoudness, (),
               (const, override));
@@ -587,12 +642,12 @@ class MockObuSequencer : public ObuSequencerBase {
   MOCK_METHOD(absl::Status, PushSerializedDescriptorObus,
               (uint32_t common_samples_per_frame, uint32_t common_sample_rate,
                uint8_t common_bit_depth,
-               std::optional<int64_t> first_untrimmed_timestamp,
+               std::optional<InternalTimestamp> first_untrimmed_timestamp,
                int num_channels, absl::Span<const uint8_t> descriptor_obus),
               (override));
 
   MOCK_METHOD(absl::Status, PushSerializedTemporalUnit,
-              (int64_t timestamp, int num_samples,
+              (InternalTimestamp timestamp, int num_samples,
                absl::Span<const uint8_t> temporal_unit),
               (override));
 
diff --git a/iamf/cli/tests/cli_test_utils_test.cc b/iamf/cli/tests/cli_test_utils_test.cc
index 7b537b4..707bff5 100644
--- a/iamf/cli/tests/cli_test_utils_test.cc
+++ b/iamf/cli/tests/cli_test_utils_test.cc
@@ -149,7 +149,8 @@ TEST(OneFrameDelayer, ValidatesInputShapeWithTooManyChannels) {
   const std::vector<std::vector<int32_t>> kInputFrameWithTooManyChannels(
       kNumSamplesPerFrame, std::vector<int32_t>(kNumChannels + 1, 0));
 
-  EXPECT_THAT(one_frame_delayer.PushFrame(kInputFrameWithTooManyChannels),
+  EXPECT_THAT(one_frame_delayer.PushFrame(
+                  MakeSpanOfConstSpans(kInputFrameWithTooManyChannels)),
               Not(IsOk()));
 }
 
@@ -161,7 +162,8 @@ TEST(OneFrameDelayer, ValidatesInputShapeWithTooManySamplesPerFrame) {
   const std::vector<std::vector<int32_t>> kInputFrameWithTooFewSamples(
       kNumSamplesPerFrame + 1, std::vector<int32_t>(kNumChannels, 0));
 
-  EXPECT_THAT(one_frame_delayer.PushFrame(kInputFrameWithTooFewSamples),
+  EXPECT_THAT(one_frame_delayer.PushFrame(
+                  MakeSpanOfConstSpans(kInputFrameWithTooFewSamples)),
               Not(IsOk()));
 }
 
@@ -169,44 +171,59 @@ TEST(OneFrameDelayer, DelaysSamplesByOneFrame) {
   constexpr uint32_t kNumSamplesPerFrame = 5;
   constexpr size_t kNumChannels = 4;
   const std::vector<std::vector<int32_t>> kFirstInputFrame = {
-      {{1, 2, 3, 4},
-       {5, 6, 7, 8},
-       {9, 10, 11, 12},
-       {13, 14, 15, 16},
-       {17, 18, 19, 20}}};
+      {1, 5, 9, 13, 17},
+      {2, 6, 10, 14, 18},
+      {3, 7, 11, 15, 19},
+      {4, 8, 12, 16, 20}};
   const std::vector<std::vector<int32_t>> kSecondInputFrame = {
-      {{21, 22, 23, 24}}};
+      {21}, {22}, {23}, {24}};
   OneFrameDelayer one_frame_delayer(kNumSamplesPerFrame, kNumChannels);
   // Nothing is available at the start.
-  EXPECT_TRUE(one_frame_delayer.GetOutputSamplesAsSpan().empty());
-  EXPECT_THAT(one_frame_delayer.PushFrame(kFirstInputFrame), IsOk());
+  for (const auto& output_channel :
+       one_frame_delayer.GetOutputSamplesAsSpan()) {
+    EXPECT_TRUE(output_channel.empty());
+  }
+
+  EXPECT_THAT(
+      one_frame_delayer.PushFrame(MakeSpanOfConstSpans(kFirstInputFrame)),
+      IsOk());
   // Still nothing is available because the samples are delayed by a frame.
-  EXPECT_TRUE(one_frame_delayer.GetOutputSamplesAsSpan().empty());
+  for (const auto& output_channel :
+       one_frame_delayer.GetOutputSamplesAsSpan()) {
+    EXPECT_TRUE(output_channel.empty());
+  }
 
   // Pushing in a new frame will cause the first frame to be available.
-  EXPECT_THAT(one_frame_delayer.PushFrame(kSecondInputFrame), IsOk());
-
-  EXPECT_THAT(one_frame_delayer.GetOutputSamplesAsSpan(), kFirstInputFrame);
+  EXPECT_THAT(
+      one_frame_delayer.PushFrame(MakeSpanOfConstSpans(kSecondInputFrame)),
+      IsOk());
+  EXPECT_EQ(one_frame_delayer.GetOutputSamplesAsSpan(),
+            MakeSpanOfConstSpans(kFirstInputFrame));
 }
 
 TEST(OneFrameDelayer, GetOutputSamplesAsSpanReturnsFinalFrameAfterFlush) {
   constexpr uint32_t kNumSamplesPerFrame = 5;
   constexpr size_t kNumChannels = 4;
   const std::vector<std::vector<int32_t>> kFirstInputFrame = {
-      {{1, 2, 3, 4},
-       {5, 6, 7, 8},
-       {9, 10, 11, 12},
-       {13, 14, 15, 16},
-       {17, 18, 19, 20}}};
+      {1, 5, 9, 13, 17},
+      {2, 6, 10, 14, 18},
+      {3, 7, 11, 15, 19},
+      {4, 8, 12, 16, 20}};
   OneFrameDelayer one_frame_delayer(kNumSamplesPerFrame, kNumChannels);
-  EXPECT_THAT(one_frame_delayer.PushFrame(kFirstInputFrame), IsOk());
+  EXPECT_THAT(
+      one_frame_delayer.PushFrame(MakeSpanOfConstSpans(kFirstInputFrame)),
+      IsOk());
   // Nothing is available because the samples are delayed by a frame.
-  EXPECT_TRUE(one_frame_delayer.GetOutputSamplesAsSpan().empty());
+  for (const auto& output_channel :
+       one_frame_delayer.GetOutputSamplesAsSpan()) {
+    EXPECT_TRUE(output_channel.empty());
+  }
 
   // Flushing will allow access to the final delayed frame.
   EXPECT_THAT(one_frame_delayer.Flush(), IsOk());
 
-  EXPECT_THAT(one_frame_delayer.GetOutputSamplesAsSpan(), kFirstInputFrame);
+  EXPECT_EQ(one_frame_delayer.GetOutputSamplesAsSpan(),
+            MakeSpanOfConstSpans(kFirstInputFrame));
 }
 
 }  // namespace
diff --git a/iamf/cli/tests/cli_util_test.cc b/iamf/cli/tests/cli_util_test.cc
index b9a56f8..cea0222 100644
--- a/iamf/cli/tests/cli_util_test.cc
+++ b/iamf/cli/tests/cli_util_test.cc
@@ -71,8 +71,8 @@ TEST(WritePcmFrameToBuffer, ResizesOutputBuffer) {
 }
 
 TEST(WritePcmFrameToBuffer, WritesBigEndian) {
-  std::vector<std::vector<int32_t>> frame_to_write = {{0x7f001200, 0x7e003400},
-                                                      {0x7f005600, 0x7e007800}};
+  std::vector<std::vector<int32_t>> frame_to_write = {{0x7f001200, 0x7f005600},
+                                                      {0x7e003400, 0x7e007800}};
   const uint8_t kBitDepth = 24;
   const bool kBigEndian = true;
   std::vector<uint8_t> output_buffer;
@@ -86,8 +86,8 @@ TEST(WritePcmFrameToBuffer, WritesBigEndian) {
 }
 
 TEST(WritePcmFrameToBuffer, WritesLittleEndian) {
-  std::vector<std::vector<int32_t>> frame_to_write = {{0x7f001200, 0x7e003400},
-                                                      {0x7f005600, 0x7e007800}};
+  std::vector<std::vector<int32_t>> frame_to_write = {{0x7f001200, 0x7f005600},
+                                                      {0x7e003400, 0x7e007800}};
   const uint8_t kBitDepth = 24;
   const bool kBigEndian = false;
   std::vector<uint8_t> output_buffer;
diff --git a/iamf/cli/tests/demixing_module_benchmark.cc b/iamf/cli/tests/demixing_module_benchmark.cc
new file mode 100644
index 0000000..0a7b8f3
--- /dev/null
+++ b/iamf/cli/tests/demixing_module_benchmark.cc
@@ -0,0 +1,262 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#include <cstdint>
+#include <list>
+#include <utility>
+#include <vector>
+
+#include "absl/container/flat_hash_map.h"
+#include "absl/log/check.h"
+#include "absl/status/statusor.h"
+#include "absl/types/span.h"
+#include "benchmark/benchmark.h"
+#include "iamf/cli/audio_element_with_data.h"
+#include "iamf/cli/audio_frame_decoder.h"
+#include "iamf/cli/audio_frame_with_data.h"
+#include "iamf/cli/channel_label.h"
+#include "iamf/cli/demixing_module.h"
+#include "iamf/cli/proto/user_metadata.pb.h"
+#include "iamf/cli/proto_conversion/channel_label_utils.h"
+#include "iamf/cli/proto_conversion/downmixing_reconstruction_util.h"
+#include "iamf/cli/tests/cli_test_utils.h"
+#include "iamf/obu/audio_element.h"
+#include "iamf/obu/audio_frame.h"
+#include "iamf/obu/demixing_info_parameter_data.h"
+#include "iamf/obu/obu_header.h"
+#include "iamf/obu/types.h"
+
+namespace iamf_tools {
+namespace {
+
+using enum ChannelLabel::Label;
+constexpr DecodedUleb128 kAudioElementId = 591;
+constexpr DownMixingParams kDownMixingParams = {
+    .alpha = 1, .beta = .866, .gamma = .866, .delta = .866, .w = 0.25};
+constexpr InternalTimestamp kStartTimestamp = 0;
+
+static void ConfigureAudioFrameMetadata(
+    absl::Span<const ChannelLabel::Label> labels,
+    iamf_tools_cli_proto::AudioFrameObuMetadata& audio_frame_metadata) {
+  for (const auto& label : labels) {
+    auto proto_label = ChannelLabelUtils::LabelToProto(label);
+    CHECK_OK(proto_label);
+    audio_frame_metadata.add_channel_metadatas()->set_channel_label(
+        *proto_label);
+  }
+}
+
+static void ConfigureInputChannel(
+    ChannelLabel::Label label, absl::Span<const int32_t> input_samples,
+    iamf_tools_cli_proto::AudioFrameObuMetadata& audio_frame_metadata,
+    LabelSamplesMap& input_label_to_samples) {
+  ConfigureAudioFrameMetadata({label}, audio_frame_metadata);
+  auto [iter, inserted] = input_label_to_samples.emplace(
+      label, std::vector<InternalSampleType>(input_samples.size(), 0));
+  Int32ToInternalSampleType(input_samples, absl::MakeSpan(iter->second));
+
+  // This function should not be called with the same label twice, so the
+  // insertion should succeed.
+  CHECK(inserted);
+}
+
+static void ConfigureOutputChannel(
+    const std::list<ChannelLabel::Label>& requested_output_labels,
+    SubstreamIdLabelsMap& substream_id_to_labels,
+    absl::flat_hash_map<uint32_t, SubstreamData>&
+        substream_id_to_substream_data) {
+  // The substream ID itself does not matter. Generate a unique one.
+  const uint32_t substream_id = substream_id_to_labels.size();
+  substream_id_to_labels[substream_id] = requested_output_labels;
+  substream_id_to_substream_data[substream_id] = {.substream_id = substream_id};
+}
+
+static DemixingModule CreateDemixingModule(
+    const iamf_tools_cli_proto::AudioFrameObuMetadata& audio_frame_metadata,
+    const SubstreamIdLabelsMap& substream_id_to_labels) {
+  absl::flat_hash_map<DecodedUleb128, AudioElementWithData> audio_elements;
+  iamf_tools_cli_proto::UserMetadata user_metadata;
+  *user_metadata.add_audio_frame_metadata() = audio_frame_metadata;
+  audio_elements.emplace(
+      kAudioElementId,
+      AudioElementWithData{
+          .obu = AudioElementObu(ObuHeader(), kAudioElementId,
+                                 AudioElementObu::kAudioElementChannelBased,
+                                 /*reserved=*/0,
+                                 /*codec_config_id=*/0),
+          .substream_id_to_labels = substream_id_to_labels,
+      });
+  const absl::StatusOr<absl::flat_hash_map<
+      DecodedUleb128, DemixingModule::DownmixingAndReconstructionConfig>>
+      audio_element_id_to_demixing_metadata =
+          CreateAudioElementIdToDemixingMetadata(user_metadata, audio_elements);
+  auto demixing_module = DemixingModule::CreateForDownMixingAndReconstruction(
+      std::move(audio_element_id_to_demixing_metadata.value()));
+  CHECK_OK(demixing_module);
+
+  return *demixing_module;
+}
+
+static void ConfigureLosslessAudioFrame(
+    const std::list<ChannelLabel::Label>& labels,
+    const std::vector<std::vector<int32_t>>& pcm_samples, const int num_ticks,
+    SubstreamIdLabelsMap& substream_id_to_labels,
+    std::list<AudioFrameWithData>& audio_frames) {
+  // The substream ID itself does not matter. Generate a unique one.
+  const DecodedUleb128 substream_id = substream_id_to_labels.size();
+  substream_id_to_labels[substream_id] = labels;
+  audio_frames.push_back(
+      AudioFrameWithData{.obu = AudioFrameObu(ObuHeader(), substream_id, {}),
+                         .start_timestamp = kStartTimestamp,
+                         .end_timestamp = kStartTimestamp + num_ticks,
+                         .pcm_samples = pcm_samples,
+                         .down_mixing_params = kDownMixingParams});
+}
+
+static void ConfigureLosslessDecodedAudioFrame(
+    const std::list<ChannelLabel::Label>& labels,
+    const std::vector<std::vector<int32_t>>& pcm_samples, const int num_ticks,
+    SubstreamIdLabelsMap& substream_id_to_labels,
+    std::list<DecodedAudioFrame>& decoded_audio_frames) {
+  // The substream ID itself does not matter. Generate a unique one.
+  const DecodedUleb128 substream_id = substream_id_to_labels.size();
+  substream_id_to_labels[substream_id] = labels;
+  decoded_audio_frames.push_back(
+      DecodedAudioFrame{.substream_id = substream_id,
+                        .start_timestamp = kStartTimestamp,
+                        .end_timestamp = kStartTimestamp + num_ticks,
+                        .samples_to_trim_at_end = 0,
+                        .samples_to_trim_at_start = 0,
+                        .decoded_samples = absl::MakeConstSpan(pcm_samples),
+                        .down_mixing_params = kDownMixingParams});
+}
+
+// Currently benchmarking down-mixing from stereo to mono and demixing from
+// mono to stero. Both consist of the basic unit of operation: mixing two
+// channels into one. Down-mixing/demixing betwee other layouts should take
+// time proportional to the number of units of operations.
+static void BM_DownMixing(benchmark::State& state) {
+  // Set up the input.
+  const int num_ticks = state.range(0);
+  std::vector<std::vector<int32_t>> input_samples_stereo(2);
+  for (auto& input_samples_for_channel : input_samples_stereo) {
+    input_samples_for_channel.resize(num_ticks);
+  }
+
+  iamf_tools_cli_proto::AudioFrameObuMetadata audio_frame_metadata;
+  audio_frame_metadata.set_audio_element_id(kAudioElementId);
+  LabelSamplesMap input_label_to_samples;
+  ConfigureInputChannel(kL2, input_samples_stereo[0], audio_frame_metadata,
+                        input_label_to_samples);
+  ConfigureInputChannel(kR2, input_samples_stereo[1], audio_frame_metadata,
+                        input_label_to_samples);
+
+  // Placeholder for the output.
+  SubstreamIdLabelsMap substream_id_to_labels;
+  absl::flat_hash_map<uint32_t, SubstreamData> substream_id_to_substream_data;
+  ConfigureOutputChannel({kMono}, substream_id_to_labels,
+                         substream_id_to_substream_data);
+
+  // Create a demixing module.
+  auto demixing_module =
+      CreateDemixingModule(audio_frame_metadata, substream_id_to_labels);
+
+  // Measure the calls to `DemixingModule::DownMixSamplesToSubstreams()`.
+  for (auto _ : state) {
+    auto status = demixing_module.DownMixSamplesToSubstreams(
+        kAudioElementId, kDownMixingParams, input_label_to_samples,
+        substream_id_to_substream_data);
+  }
+}
+
+static void BM_DemixingOriginal(benchmark::State& state) {
+  // Set up the input.
+  const int num_ticks = state.range(0);
+  std::vector<std::vector<int32_t>> input_samples_mono(1);
+  input_samples_mono[0].resize(num_ticks);
+  std::vector<std::vector<int32_t>> input_samples_l2(1);
+  input_samples_l2[0].resize(num_ticks);
+  SubstreamIdLabelsMap substream_id_to_labels;
+  std::list<AudioFrameWithData> audio_frames;
+
+  // Mono is the lowest layer.
+  ConfigureLosslessAudioFrame({kMono}, input_samples_mono, num_ticks,
+                              substream_id_to_labels, audio_frames);
+
+  // Stereo is the next layer. One additional channel (L2) is provided.
+  ConfigureLosslessAudioFrame({kL2}, input_samples_l2, num_ticks,
+                              substream_id_to_labels, audio_frames);
+
+  // To form a complete stereo layout, R2 will be demixed from mono and L2.
+  iamf_tools_cli_proto::AudioFrameObuMetadata audio_frame_metadata;
+  audio_frame_metadata.set_audio_element_id(kAudioElementId);
+  ConfigureAudioFrameMetadata({kL2, kR2}, audio_frame_metadata);
+
+  // Create a demixing module.
+  auto demixing_module =
+      CreateDemixingModule(audio_frame_metadata, substream_id_to_labels);
+
+  // Measure the calls to `DemixingModule::DemixOriginalAudioSamples()`.
+  for (auto _ : state) {
+    auto id_to_labeled_frame =
+        demixing_module.DemixOriginalAudioSamples(audio_frames);
+    CHECK_OK(id_to_labeled_frame);
+  }
+}
+
+static void BM_DemixingDecoded(benchmark::State& state) {
+  // Set up the input.
+  const int num_ticks = state.range(0);
+  std::vector<std::vector<int32_t>> input_samples_mono(1);
+  input_samples_mono[0].resize(num_ticks);
+  std::vector<std::vector<int32_t>> input_samples_l2(1);
+  input_samples_l2[0].resize(num_ticks);
+  SubstreamIdLabelsMap substream_id_to_labels;
+  std::list<DecodedAudioFrame> decoded_audio_frames;
+
+  // Mono is the lowest layer.
+  ConfigureLosslessDecodedAudioFrame({kMono}, input_samples_mono, num_ticks,
+                                     substream_id_to_labels,
+                                     decoded_audio_frames);
+
+  // Stereo is the next layer. One additional channel (L2) is provided.
+  ConfigureLosslessDecodedAudioFrame({kL2}, input_samples_l2, num_ticks,
+                                     substream_id_to_labels,
+                                     decoded_audio_frames);
+
+  // To form a complete stereo layout, R2 will be demixed from mono and L2.
+  iamf_tools_cli_proto::AudioFrameObuMetadata audio_frame_metadata;
+  audio_frame_metadata.set_audio_element_id(kAudioElementId);
+  ConfigureAudioFrameMetadata({kL2, kR2}, audio_frame_metadata);
+
+  // Create a demixing module.
+  auto demixing_module =
+      CreateDemixingModule(audio_frame_metadata, substream_id_to_labels);
+
+  // Measure the calls to `DemixingModule::DemixDecodedAudioSamples()`.
+  for (auto _ : state) {
+    auto id_to_labeled_decoded_frame =
+        demixing_module.DemixDecodedAudioSamples(decoded_audio_frames);
+    CHECK_OK(id_to_labeled_decoded_frame);
+  }
+}
+
+// Benchmark with different number of samples per frame.
+BENCHMARK(BM_DownMixing)->Args({1 << 8})->Args({1 << 10})->Args({1 << 12});
+BENCHMARK(BM_DemixingOriginal)
+    ->Args({1 << 8})
+    ->Args({1 << 10})
+    ->Args({1 << 12});
+BENCHMARK(BM_DemixingDecoded)->Args({1 << 8})->Args({1 << 10})->Args({1 << 12});
+
+}  // namespace
+}  // namespace iamf_tools
diff --git a/iamf/cli/tests/demixing_module_test.cc b/iamf/cli/tests/demixing_module_test.cc
index 503d258..2292f78 100644
--- a/iamf/cli/tests/demixing_module_test.cc
+++ b/iamf/cli/tests/demixing_module_test.cc
@@ -59,12 +59,13 @@ using ::testing::Pointwise;
 constexpr DecodedUleb128 kAudioElementId = 137;
 constexpr std::array<uint8_t, 12> kReconGainValues = {
     255, 0, 125, 200, 150, 255, 255, 255, 255, 255, 255, 255};
-const uint32_t kZeroSamplesToTrimAtEnd = 0;
-const uint32_t kZeroSamplesToTrimAtStart = 0;
-const int kStartTimestamp = 0;
-const int kEndTimestamp = 4;
-const DecodedUleb128 kMonoSubstreamId = 0;
-const DecodedUleb128 kL2SubstreamId = 1;
+constexpr uint32_t kZeroSamplesToTrimAtEnd = 0;
+constexpr uint32_t kZeroSamplesToTrimAtStart = 0;
+constexpr InternalTimestamp kStartTimestamp = 0;
+constexpr InternalTimestamp kEndTimestamp = 4;
+constexpr DecodedUleb128 kMonoSubstreamId = 0;
+constexpr DecodedUleb128 kL2SubstreamId = 1;
+constexpr DecodedUleb128 kStereoSubstreamId = 2;
 
 // TODO(b/305927287): Test computation of linear output gains. Test some cases
 //                    of erroneous input.
@@ -73,31 +74,31 @@ TEST(FindSamplesOrDemixedSamples, FindsMatchingSamples) {
   const std::vector<InternalSampleType> kSamplesToFind = {1, 2, 3};
   const LabelSamplesMap kLabelToSamples = {{kL2, kSamplesToFind}};
 
-  const std::vector<InternalSampleType>* found_samples;
+  absl::Span<const InternalSampleType> found_samples;
   EXPECT_THAT(DemixingModule::FindSamplesOrDemixedSamples(kL2, kLabelToSamples,
-                                                          &found_samples),
+                                                          found_samples),
               IsOk());
-  EXPECT_THAT(*found_samples, Pointwise(DoubleEq(), kSamplesToFind));
+  EXPECT_THAT(found_samples, Pointwise(DoubleEq(), kSamplesToFind));
 }
 
 TEST(FindSamplesOrDemixedSamples, FindsMatchingDemixedSamples) {
   const std::vector<InternalSampleType> kSamplesToFind = {1, 2, 3};
   const LabelSamplesMap kLabelToSamples = {{kDemixedR2, kSamplesToFind}};
 
-  const std::vector<InternalSampleType>* found_samples;
+  absl::Span<const InternalSampleType> found_samples;
   EXPECT_THAT(DemixingModule::FindSamplesOrDemixedSamples(kR2, kLabelToSamples,
-                                                          &found_samples),
+                                                          found_samples),
               IsOk());
-  EXPECT_THAT(*found_samples, Pointwise(DoubleEq(), kSamplesToFind));
+  EXPECT_THAT(found_samples, Pointwise(DoubleEq(), kSamplesToFind));
 }
 
 TEST(FindSamplesOrDemixedSamples, InvalidWhenThereIsNoDemixingLabel) {
   const std::vector<InternalSampleType> kSamplesToFind = {1, 2, 3};
   const LabelSamplesMap kLabelToSamples = {{kDemixedR2, kSamplesToFind}};
 
-  const std::vector<InternalSampleType>* found_samples;
+  absl::Span<const InternalSampleType> found_samples;
   EXPECT_FALSE(DemixingModule::FindSamplesOrDemixedSamples(kL2, kLabelToSamples,
-                                                           &found_samples)
+                                                           found_samples)
                    .ok());
 }
 
@@ -106,20 +107,20 @@ TEST(FindSamplesOrDemixedSamples, RegularSamplesTakePrecedence) {
   const std::vector<InternalSampleType> kDemixedSamplesToIgnore = {4, 5, 6};
   const LabelSamplesMap kLabelToSamples = {
       {kR2, kSamplesToFind}, {kDemixedR2, kDemixedSamplesToIgnore}};
-  const std::vector<InternalSampleType>* found_samples;
+  absl::Span<const InternalSampleType> found_samples;
   EXPECT_THAT(DemixingModule::FindSamplesOrDemixedSamples(kR2, kLabelToSamples,
-                                                          &found_samples),
+                                                          found_samples),
               IsOk());
-  EXPECT_THAT(*found_samples, Pointwise(DoubleEq(), kSamplesToFind));
+  EXPECT_THAT(found_samples, Pointwise(DoubleEq(), kSamplesToFind));
 }
 
 TEST(FindSamplesOrDemixedSamples, ErrorNoMatchingSamples) {
   const std::vector<InternalSampleType> kSamplesToFind = {1, 2, 3};
   const LabelSamplesMap kLabelToSamples = {{kL2, kSamplesToFind}};
 
-  const std::vector<InternalSampleType>* found_samples;
+  absl::Span<const InternalSampleType> found_samples;
   EXPECT_FALSE(DemixingModule::FindSamplesOrDemixedSamples(kL3, kLabelToSamples,
-                                                           &found_samples)
+                                                           found_samples)
                    .ok());
 }
 
@@ -281,6 +282,7 @@ TEST(DemixOriginalAudioSamples, ReturnsErrorAfterCreateForReconstruction) {
 }
 
 TEST(DemixDecodedAudioSamples, OutputContainsOriginalAndDemixedSamples) {
+  const std::vector<std::vector<int32_t>> kDecodedSamples = {{0}};
   absl::flat_hash_map<DecodedUleb128, AudioElementWithData> audio_elements;
   InitAudioElementWithLabelsAndLayers(
       {{kMonoSubstreamId, {kMono}}, {kL2SubstreamId, {kL2}}},
@@ -294,7 +296,7 @@ TEST(DemixDecodedAudioSamples, OutputContainsOriginalAndDemixedSamples) {
                         .end_timestamp = kEndTimestamp,
                         .samples_to_trim_at_end = kZeroSamplesToTrimAtEnd,
                         .samples_to_trim_at_start = kZeroSamplesToTrimAtStart,
-                        .decoded_samples = {{0}},
+                        .decoded_samples = absl::MakeConstSpan(kDecodedSamples),
                         .down_mixing_params = DownMixingParams()});
   decoded_audio_frames.push_back(
       DecodedAudioFrame{.substream_id = kL2SubstreamId,
@@ -302,7 +304,7 @@ TEST(DemixDecodedAudioSamples, OutputContainsOriginalAndDemixedSamples) {
                         .end_timestamp = kEndTimestamp,
                         .samples_to_trim_at_end = kZeroSamplesToTrimAtEnd,
                         .samples_to_trim_at_start = kZeroSamplesToTrimAtStart,
-                        .decoded_samples = {{0}},
+                        .decoded_samples = absl::MakeConstSpan(kDecodedSamples),
                         .down_mixing_params = DownMixingParams()});
   auto demixing_module =
       DemixingModule::CreateForReconstruction(audio_elements);
@@ -318,6 +320,34 @@ TEST(DemixDecodedAudioSamples, OutputContainsOriginalAndDemixedSamples) {
   EXPECT_TRUE(labeled_frame.label_to_samples.contains(kDemixedR2));
 }
 
+TEST(DemixDecodedAudioSamples, ReturnsErrorWhenChannelCountsMismatch) {
+  // Configure a stereo audio element. We'd typically expected audio frames to
+  // have two channels.
+  absl::flat_hash_map<DecodedUleb128, AudioElementWithData> audio_elements;
+  InitAudioElementWithLabelsAndLayers({{kStereoSubstreamId, {kL2, kR2}}},
+                                      {ChannelAudioLayerConfig::kLayoutStereo},
+                                      audio_elements);
+  auto demixing_module =
+      DemixingModule::CreateForReconstruction(audio_elements);
+  ASSERT_THAT(demixing_module, IsOk());
+  std::list<DecodedAudioFrame> decoded_audio_frames;
+  // The decoded audio frame has one channel, which is inconsistent with a
+  // one-layer stereo audio element.
+  const std::vector<std::vector<int32_t>> kErrorOneChannel = {{0}};
+  decoded_audio_frames.push_back(DecodedAudioFrame{
+      .substream_id = kStereoSubstreamId,
+      .start_timestamp = kStartTimestamp,
+      .end_timestamp = kEndTimestamp,
+      .samples_to_trim_at_end = kZeroSamplesToTrimAtEnd,
+      .samples_to_trim_at_start = kZeroSamplesToTrimAtStart,
+      .decoded_samples = absl::MakeConstSpan(kErrorOneChannel),
+      .down_mixing_params = DownMixingParams()});
+
+  // Demixing gracefully fails, as we can't determine the missing channel.
+  EXPECT_THAT(demixing_module->DemixDecodedAudioSamples(decoded_audio_frames),
+              Not(IsOk()));
+}
+
 TEST(DemixDecodedAudioSamples, OutputEchoesTimingInformation) {
   // These values are not very sensible, but as long as they are consistent
   // between related frames it is OK.
@@ -326,6 +356,7 @@ TEST(DemixDecodedAudioSamples, OutputEchoesTimingInformation) {
   const DecodedUleb128 kExpectedNumSamplesToTrimAtEnd = 999;
   const DecodedUleb128 kExpectedNumSamplesToTrimAtStart = 9999;
   const DecodedUleb128 kL2SubstreamId = 1;
+  const std::vector<std::vector<int32_t>> kDecodedSamples = {{0}};
   absl::flat_hash_map<DecodedUleb128, AudioElementWithData> audio_elements;
   InitAudioElementWithLabelsAndLayers(
       {{kMonoSubstreamId, {kMono}}, {kL2SubstreamId, {kL2}}},
@@ -339,7 +370,7 @@ TEST(DemixDecodedAudioSamples, OutputEchoesTimingInformation) {
       .end_timestamp = kExpectedEndTimestamp,
       .samples_to_trim_at_end = kExpectedNumSamplesToTrimAtEnd,
       .samples_to_trim_at_start = kExpectedNumSamplesToTrimAtStart,
-      .decoded_samples = {{0}},
+      .decoded_samples = absl::MakeConstSpan(kDecodedSamples),
       .down_mixing_params = DownMixingParams()});
   decoded_audio_frames.push_back(DecodedAudioFrame{
       .substream_id = kL2SubstreamId,
@@ -347,7 +378,7 @@ TEST(DemixDecodedAudioSamples, OutputEchoesTimingInformation) {
       .end_timestamp = kExpectedEndTimestamp,
       .samples_to_trim_at_end = kExpectedNumSamplesToTrimAtEnd,
       .samples_to_trim_at_start = kExpectedNumSamplesToTrimAtStart,
-      .decoded_samples = {{0}},
+      .decoded_samples = absl::MakeConstSpan(kDecodedSamples),
       .down_mixing_params = DownMixingParams()});
   const auto demixing_module =
       DemixingModule::CreateForReconstruction(audio_elements);
@@ -367,6 +398,8 @@ TEST(DemixDecodedAudioSamples, OutputEchoesTimingInformation) {
 }
 
 TEST(DemixDecodedAudioSamples, OutputEchoesOriginalLabels) {
+  const std::vector<std::vector<int32_t>> kDecodedMonoSamples = {{1, 2, 3}};
+  const std::vector<std::vector<int32_t>> kDecodedL2Samples = {{9, 10, 11}};
   absl::flat_hash_map<DecodedUleb128, AudioElementWithData> audio_elements;
   InitAudioElementWithLabelsAndLayers(
       {{kMonoSubstreamId, {kMono}}, {kL2SubstreamId, {kL2}}},
@@ -374,22 +407,22 @@ TEST(DemixDecodedAudioSamples, OutputEchoesOriginalLabels) {
        ChannelAudioLayerConfig::kLayoutStereo},
       audio_elements);
   std::list<DecodedAudioFrame> decoded_audio_frames;
-  decoded_audio_frames.push_back(
-      DecodedAudioFrame{.substream_id = kMonoSubstreamId,
-                        .start_timestamp = kStartTimestamp,
-                        .end_timestamp = kEndTimestamp,
-                        .samples_to_trim_at_end = kZeroSamplesToTrimAtEnd,
-                        .samples_to_trim_at_start = kZeroSamplesToTrimAtStart,
-                        .decoded_samples = {{1}, {2}, {3}},
-                        .down_mixing_params = DownMixingParams()});
-  decoded_audio_frames.push_back(
-      DecodedAudioFrame{.substream_id = kL2SubstreamId,
-                        .start_timestamp = kStartTimestamp,
-                        .end_timestamp = kEndTimestamp,
-                        .samples_to_trim_at_end = kZeroSamplesToTrimAtEnd,
-                        .samples_to_trim_at_start = kZeroSamplesToTrimAtStart,
-                        .decoded_samples = {{9}, {10}, {11}},
-                        .down_mixing_params = DownMixingParams()});
+  decoded_audio_frames.push_back(DecodedAudioFrame{
+      .substream_id = kMonoSubstreamId,
+      .start_timestamp = kStartTimestamp,
+      .end_timestamp = kEndTimestamp,
+      .samples_to_trim_at_end = kZeroSamplesToTrimAtEnd,
+      .samples_to_trim_at_start = kZeroSamplesToTrimAtStart,
+      .decoded_samples = absl::MakeConstSpan(kDecodedMonoSamples),
+      .down_mixing_params = DownMixingParams()});
+  decoded_audio_frames.push_back(DecodedAudioFrame{
+      .substream_id = kL2SubstreamId,
+      .start_timestamp = kStartTimestamp,
+      .end_timestamp = kEndTimestamp,
+      .samples_to_trim_at_end = kZeroSamplesToTrimAtEnd,
+      .samples_to_trim_at_start = kZeroSamplesToTrimAtStart,
+      .decoded_samples = absl::MakeConstSpan(kDecodedL2Samples),
+      .down_mixing_params = DownMixingParams()});
   const auto demixing_module =
       DemixingModule::CreateForReconstruction(audio_elements);
   ASSERT_THAT(demixing_module, IsOk());
@@ -413,6 +446,8 @@ TEST(DemixDecodedAudioSamples, OutputEchoesOriginalLabels) {
 }
 
 TEST(DemixDecodedAudioSamples, OutputHasReconstructedLayers) {
+  const std::vector<std::vector<int32_t>> kDecodedMonoSamples = {{750}};
+  const std::vector<std::vector<int32_t>> kDecodedL2Samples = {{1000}};
   absl::flat_hash_map<DecodedUleb128, AudioElementWithData> audio_elements;
 
   InitAudioElementWithLabelsAndLayers(
@@ -421,22 +456,22 @@ TEST(DemixDecodedAudioSamples, OutputHasReconstructedLayers) {
        ChannelAudioLayerConfig::kLayoutStereo},
       audio_elements);
   std::list<DecodedAudioFrame> decoded_audio_frames;
-  decoded_audio_frames.push_back(
-      DecodedAudioFrame{.substream_id = kMonoSubstreamId,
-                        .start_timestamp = kStartTimestamp,
-                        .end_timestamp = kEndTimestamp,
-                        .samples_to_trim_at_end = kZeroSamplesToTrimAtEnd,
-                        .samples_to_trim_at_start = kZeroSamplesToTrimAtStart,
-                        .decoded_samples = {{750}},
-                        .down_mixing_params = DownMixingParams()});
-  decoded_audio_frames.push_back(
-      DecodedAudioFrame{.substream_id = kL2SubstreamId,
-                        .start_timestamp = kStartTimestamp,
-                        .end_timestamp = kEndTimestamp,
-                        .samples_to_trim_at_end = kZeroSamplesToTrimAtEnd,
-                        .samples_to_trim_at_start = kZeroSamplesToTrimAtStart,
-                        .decoded_samples = {{1000}},
-                        .down_mixing_params = DownMixingParams()});
+  decoded_audio_frames.push_back(DecodedAudioFrame{
+      .substream_id = kMonoSubstreamId,
+      .start_timestamp = kStartTimestamp,
+      .end_timestamp = kEndTimestamp,
+      .samples_to_trim_at_end = kZeroSamplesToTrimAtEnd,
+      .samples_to_trim_at_start = kZeroSamplesToTrimAtStart,
+      .decoded_samples = absl::MakeConstSpan(kDecodedMonoSamples),
+      .down_mixing_params = DownMixingParams()});
+  decoded_audio_frames.push_back(DecodedAudioFrame{
+      .substream_id = kL2SubstreamId,
+      .start_timestamp = kStartTimestamp,
+      .end_timestamp = kEndTimestamp,
+      .samples_to_trim_at_end = kZeroSamplesToTrimAtEnd,
+      .samples_to_trim_at_start = kZeroSamplesToTrimAtStart,
+      .decoded_samples = absl::MakeConstSpan(kDecodedL2Samples),
+      .down_mixing_params = DownMixingParams()});
   const auto demixing_module =
       DemixingModule::CreateForReconstruction(audio_elements);
   ASSERT_THAT(demixing_module, IsOk());
@@ -454,6 +489,7 @@ TEST(DemixDecodedAudioSamples, OutputHasReconstructedLayers) {
 }
 
 TEST(DemixDecodedAudioSamples, OutputContainsReconGainAndLayerInfo) {
+  const std::vector<std::vector<int32_t>> kDecodedSamples = {{0}};
   absl::flat_hash_map<DecodedUleb128, AudioElementWithData> audio_elements;
   InitAudioElementWithLabelsAndLayers(
       {{kMonoSubstreamId, {kMono}}, {kL2SubstreamId, {kL2}}},
@@ -470,7 +506,7 @@ TEST(DemixDecodedAudioSamples, OutputContainsReconGainAndLayerInfo) {
       .end_timestamp = kEndTimestamp,
       .samples_to_trim_at_end = kZeroSamplesToTrimAtEnd,
       .samples_to_trim_at_start = kZeroSamplesToTrimAtStart,
-      .decoded_samples = {{0}},
+      .decoded_samples = absl::MakeConstSpan(kDecodedSamples),
       .down_mixing_params = DownMixingParams(),
       .recon_gain_info_parameter_data = recon_gain_info_parameter_data,
       .audio_element_with_data = &audio_elements.at(kAudioElementId)});
@@ -480,7 +516,7 @@ TEST(DemixDecodedAudioSamples, OutputContainsReconGainAndLayerInfo) {
       .end_timestamp = kEndTimestamp,
       .samples_to_trim_at_end = kZeroSamplesToTrimAtEnd,
       .samples_to_trim_at_start = kZeroSamplesToTrimAtStart,
-      .decoded_samples = {{0}},
+      .decoded_samples = absl::MakeConstSpan(kDecodedSamples),
       .down_mixing_params = DownMixingParams(),
       .recon_gain_info_parameter_data = recon_gain_info_parameter_data,
       .audio_element_with_data = &audio_elements.at(kAudioElementId)});
@@ -943,6 +979,10 @@ class DemixingModuleTest : public DemixingModuleTestBase,
       const std::vector<std::vector<int32_t>>& pcm_samples,
       DownMixingParams down_mixing_params = {
           .alpha = 1, .beta = .866, .gamma = .866, .delta = .866, .w = 0.25}) {
+    // Copy the samples to the buffer so the
+    // `DecodedAudioFrame::decoded_samples` can point to them.
+    pcm_samples_buffer_.push_back(pcm_samples);
+
     // The substream ID itself does not matter. Generate a unique one.
     const DecodedUleb128 substream_id = substream_id_to_labels_.size();
     substream_id_to_labels_[substream_id] = labels;
@@ -957,28 +997,28 @@ class DemixingModuleTest : public DemixingModuleTestBase,
         .down_mixing_params = down_mixing_params,
     });
 
-    decoded_audio_frames_.push_back(
-        DecodedAudioFrame{.substream_id = substream_id,
-                          .start_timestamp = kStartTimestamp,
-                          .end_timestamp = kEndTimestamp,
-                          .samples_to_trim_at_end = kZeroSamplesToTrimAtEnd,
-                          .samples_to_trim_at_start = kZeroSamplesToTrimAtStart,
-                          .decoded_samples = pcm_samples,
-                          .down_mixing_params = down_mixing_params});
-
+    decoded_audio_frames_.push_back(DecodedAudioFrame{
+        .substream_id = substream_id,
+        .start_timestamp = kStartTimestamp,
+        .end_timestamp = kEndTimestamp,
+        .samples_to_trim_at_end = kZeroSamplesToTrimAtEnd,
+        .samples_to_trim_at_start = kZeroSamplesToTrimAtStart,
+        .decoded_samples = absl::MakeConstSpan(pcm_samples_buffer_.back()),
+        .down_mixing_params = down_mixing_params});
     auto& expected_label_to_samples =
         expected_id_to_labeled_decoded_frame_[kAudioElementId].label_to_samples;
-    // `raw_samples` is arranged in (time, channel axes). Arrange the samples
-    // associated with each channel by time. The demixing process never changes
-    // data for the input labels.
+
+    // `pcm_samples` is arranged in (channel, time axes). Convert the samples
+    // to floating points. The demixing process never changes data for the
+    // input labels.
     auto labels_iter = labels.begin();
     for (int channel = 0; channel < labels.size(); ++channel) {
       auto& samples_for_channel = expected_label_to_samples[*labels_iter];
 
-      samples_for_channel.reserve(pcm_samples.size());
-      for (auto tick : pcm_samples) {
+      samples_for_channel.reserve(pcm_samples[channel].size());
+      for (const auto pcm_sample : pcm_samples[channel]) {
         samples_for_channel.push_back(
-            Int32ToNormalizedFloatingPoint<InternalSampleType>(tick[channel]));
+            Int32ToNormalizedFloatingPoint<InternalSampleType>(pcm_sample));
       }
       labels_iter++;
     }
@@ -1038,7 +1078,12 @@ class DemixingModuleTest : public DemixingModuleTestBase,
   std::list<AudioFrameWithData> audio_frames_;
   std::list<DecodedAudioFrame> decoded_audio_frames_;
 
+  // Memory for the samples, so that the span in `DecodedAudioFrame` points
+  // to valid memory addresses.
+  std::list<std::vector<std::vector<int32_t>>> pcm_samples_buffer_;
+
   IdLabeledFrameMap expected_id_to_labeled_decoded_frame_;
+
 };  // namespace
 
 TEST(DemixingModule, DemixingOriginalAudioSamplesSucceedsWithEmptyInputs) {
@@ -1075,9 +1120,9 @@ TEST_F(DemixingModuleTest, S1ToS2Demixer) {
   ConfigureAudioFrameMetadata({kL2, kR2});
 
   // Mono is the lowest layer.
-  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kMono}, {{750}, {1500}});
+  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kMono}, {{750, 1500}});
   // Stereo is the next layer.
-  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kL2}, {{1000}, {2000}});
+  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kL2}, {{1000, 2000}});
 
   // Demixing recovers kDemixedR2
   // D_R2 =  M - (L2 - 6 dB)  + 6 dB.
@@ -1089,8 +1134,8 @@ TEST_F(DemixingModuleTest, S1ToS2Demixer) {
 TEST_F(DemixingModuleTest,
        DemixOriginalAudioSamplesReturnsErrorIfAudioFrameIsMissingPcmSamples) {
   ConfigureAudioFrameMetadata({kL2, kR2});
-  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kMono}, {{750}, {1500}});
-  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kL2}, {{1000}, {2000}});
+  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kMono}, {{750, 1500}});
+  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kL2}, {{1000, 2000}});
   IdLabeledFrameMap unused_id_to_labeled_frame, id_to_labeled_decoded_frame;
   TestCreateDemixingModule(1);
   // Destroy the raw samples.
@@ -1106,12 +1151,12 @@ TEST_F(DemixingModuleTest, S2ToS3Demixer) {
 
   // Stereo is the lowest layer.
   ConfigureLosslessAudioFrameAndDecodedAudioFrame({kL2, kR2},
-                                                  {{70, 70}, {1700, 1700}});
+                                                  {{70, 1700}, {70, 1700}});
 
   // 3.1.2 as the next layer.
-  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kCentre}, {{2000}, {1000}});
+  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kCentre}, {{2000, 1000}});
   ConfigureLosslessAudioFrameAndDecodedAudioFrame(
-      {kLtf3, kRtf3}, {{99999, 99998}, {99999, 99998}});
+      {kLtf3, kRtf3}, {{99999, 99999}, {99998, 99998}});
 
   // L3/R3 get demixed from the lower layers.
   // L3 = L2 - (C - 3 dB).
@@ -1131,16 +1176,16 @@ TEST_F(DemixingModuleTest, S3ToS5AndTf2ToT2Demixers) {
   const DownMixingParams kDownMixingParams = {.delta = .866, .w = 0.25};
 
   // 3.1.2 is the lowest layer.
-  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kL3, kR3}, {{18660, 28660}},
-                                                  kDownMixingParams);
+  ConfigureLosslessAudioFrameAndDecodedAudioFrame(
+      {kL3, kR3}, {{18660}, {28660}}, kDownMixingParams);
   ConfigureLosslessAudioFrameAndDecodedAudioFrame({kCentre}, {{100}},
                                                   kDownMixingParams);
   ConfigureLosslessAudioFrameAndDecodedAudioFrame(
-      {kLtf3, kRtf3}, {{1000, 2000}}, kDownMixingParams);
+      {kLtf3, kRtf3}, {{1000}, {2000}}, kDownMixingParams);
 
   // 5.1.2 as the next layer.
-  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kL5, kR5}, {{10000, 20000}},
-                                                  kDownMixingParams);
+  ConfigureLosslessAudioFrameAndDecodedAudioFrame(
+      {kL5, kR5}, {{10000}, {20000}}, kDownMixingParams);
 
   // S3ToS5: Ls5/Rs5 get demixed from the lower layers.
   // Ls5 = (1 / delta) * (L3 - L5).
@@ -1164,16 +1209,16 @@ TEST_F(DemixingModuleTest, S5ToS7Demixer) {
   const DownMixingParams kDownMixingParams = {.alpha = 0.866, .beta = .866};
 
   // 5.1.0 is the lowest layer.
-  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kL5, kR5}, {{100, 100}},
-                                                  kDownMixingParams);
-  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kLs5, kRs5}, {{7794, 7794}},
+  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kL5, kR5}, {{100}, {100}},
                                                   kDownMixingParams);
+  ConfigureLosslessAudioFrameAndDecodedAudioFrame(
+      {kLs5, kRs5}, {{7794}, {7794}}, kDownMixingParams);
   ConfigureLosslessAudioFrameAndDecodedAudioFrame({kCentre}, {{100}},
                                                   kDownMixingParams);
 
   // 7.1.0 as the next layer.
   ConfigureLosslessAudioFrameAndDecodedAudioFrame(
-      {kLss7, kRss7}, {{1000, 2000}}, kDownMixingParams);
+      {kLss7, kRss7}, {{1000}, {2000}}, kDownMixingParams);
 
   // L7/R7 get demixed from the lower layers.
   // L7 = R5.
@@ -1197,18 +1242,18 @@ TEST_F(DemixingModuleTest, T2ToT4Demixer) {
   const DownMixingParams kDownMixingParams = {.gamma = .866};
 
   // 5.1.2 is the lowest layer.
-  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kL5, kR5}, {{100, 100}},
+  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kL5, kR5}, {{100}, {100}},
                                                   kDownMixingParams);
-  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kLs5, kRs5}, {{100, 100}},
+  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kLs5, kRs5}, {{100}, {100}},
                                                   kDownMixingParams);
   ConfigureLosslessAudioFrameAndDecodedAudioFrame({kCentre}, {{100}},
                                                   kDownMixingParams);
   ConfigureLosslessAudioFrameAndDecodedAudioFrame(
-      {kLtf2, kRtf2}, {{8660, 17320}}, kDownMixingParams);
+      {kLtf2, kRtf2}, {{8660}, {17320}}, kDownMixingParams);
 
   // 5.1.4 as the next layer.
-  ConfigureLosslessAudioFrameAndDecodedAudioFrame({kLtf4, kRtf4}, {{866, 1732}},
-                                                  kDownMixingParams);
+  ConfigureLosslessAudioFrameAndDecodedAudioFrame(
+      {kLtf4, kRtf4}, {{866}, {1732}}, kDownMixingParams);
 
   // Ltb4/Rtb4 get demixed from the lower layers.
   // Ltb4 = (1 / gamma) * (Ltf2 - Ltf4).
diff --git a/iamf/cli/tests/encoder_main_lib_test.cc b/iamf/cli/tests/encoder_main_lib_test.cc
index d530a66..702e8ea 100644
--- a/iamf/cli/tests/encoder_main_lib_test.cc
+++ b/iamf/cli/tests/encoder_main_lib_test.cc
@@ -23,7 +23,9 @@
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 #include "iamf/cli/proto/codec_config.pb.h"
+#include "iamf/cli/proto/encoder_control_metadata.pb.h"
 #include "iamf/cli/proto/ia_sequence_header.pb.h"
+#include "iamf/cli/proto/output_audio_format.pb.h"
 #include "iamf/cli/proto/test_vector_metadata.pb.h"
 #include "iamf/cli/proto/user_metadata.pb.h"
 #include "iamf/cli/tests/cli_test_utils.h"
@@ -34,6 +36,11 @@ namespace {
 
 using ::absl_testing::IsOk;
 constexpr absl::string_view kIgnoredOutputPath = "";
+constexpr absl::string_view kTest000005ExpectedWavFilename =
+    "test_000005_rendered_id_42_sub_mix_0_layout_0.wav";
+const int kTest000005ExpectedWavBitDepth = 16;
+
+using enum iamf_tools_cli_proto::OutputAudioFormat;
 
 void AddIaSequenceHeader(iamf_tools_cli_proto::UserMetadata& user_metadata) {
   ASSERT_TRUE(google::protobuf::TextFormat::ParseFromString(
@@ -62,6 +69,19 @@ void AddCodecConfig(iamf_tools_cli_proto::UserMetadata& user_metadata) {
       user_metadata.add_codec_config_metadata()));
 }
 
+void ParseTestVectorAssertSuccess(
+    absl::string_view textproto_filename, std::string& wav_directory,
+    iamf_tools_cli_proto::UserMetadata& user_metadata) {
+  const std::filesystem::path test_data_path =
+      (std::filesystem::current_path() / std::string("iamf/cli/testdata"));
+
+  wav_directory = test_data_path.string();
+  // Get and parse the textproto to test.
+  const auto user_metadata_filename = test_data_path / textproto_filename;
+  ParseUserMetadataAssertSuccess(user_metadata_filename.string(),
+                                 user_metadata);
+}
+
 TEST(EncoderMainLibTest, EmptyUserMetadataTestMainFails) {
   EXPECT_FALSE(TestMain(iamf_tools_cli_proto::UserMetadata(), "", "").ok());
 }
@@ -125,6 +145,105 @@ TEST(EncoderMainLibTest, ConfigureOutputWavFileBitDepthOverrideHighSucceeds) {
               IsOk());
 }
 
+TEST(EncoderMainLibTest,
+     OutputRenderedFileFormatTakesPrecedenceOverDeprecatedOverrideBitDepth) {
+  std::string wav_directory;
+  iamf_tools_cli_proto::UserMetadata user_metadata;
+  ParseTestVectorAssertSuccess("test_000005.textproto", wav_directory,
+                               user_metadata);
+  const auto output_iamf_directory = GetAndCreateOutputDirectory("");
+  // Update controls to override the bit-depth with the deprecated
+  // `output_wav_file_bit_depth_override`.
+  constexpr uint32_t kDeprecatedOverrideBitDepth = 32;
+  user_metadata.mutable_test_vector_metadata()
+      ->set_output_wav_file_bit_depth_override(kDeprecatedOverrideBitDepth);
+  // `output_rendered_file_format` should take precedence over the deprecated
+  // field.
+  const auto kExpectedBitDepth = 24;
+  user_metadata.mutable_encoder_control_metadata()
+      ->set_output_rendered_file_format(
+          OUTPUT_FORMAT_WAV_BIT_DEPTH_TWENTY_FOUR);
+
+  EXPECT_THAT(TestMain(user_metadata, wav_directory, output_iamf_directory),
+              IsOk());
+
+  const auto expected_wav_path = std::filesystem::path(output_iamf_directory) /
+                                 kTest000005ExpectedWavFilename;
+  EXPECT_TRUE(std::filesystem::exists(expected_wav_path));
+  const auto wav_reader = CreateWavReaderExpectOk(expected_wav_path.string());
+  EXPECT_EQ(wav_reader.bit_depth(), kExpectedBitDepth);
+}
+
+TEST(EncoderMainLibTest, OutputRenderedFileFormatCanUseAutomaticBitDepth) {
+  std::string wav_directory;
+  iamf_tools_cli_proto::UserMetadata user_metadata;
+  ParseTestVectorAssertSuccess("test_000005.textproto", wav_directory,
+                               user_metadata);
+  const auto output_iamf_directory = GetAndCreateOutputDirectory("");
+  // Update controls to write out a wav file with automatic bit-depth.
+  user_metadata.mutable_test_vector_metadata()
+      ->clear_output_wav_file_bit_depth_override();
+  user_metadata.mutable_encoder_control_metadata()
+      ->set_output_rendered_file_format(OUTPUT_FORMAT_WAV_BIT_DEPTH_AUTOMATIC);
+
+  EXPECT_THAT(TestMain(user_metadata, wav_directory, output_iamf_directory),
+              IsOk());
+
+  // The wav file matches the regular bit-depth of `test_000005.textproto`.
+  const auto expected_wav_path = std::filesystem::path(output_iamf_directory) /
+                                 kTest000005ExpectedWavFilename;
+  EXPECT_TRUE(std::filesystem::exists(expected_wav_path));
+  const auto wav_reader = CreateWavReaderExpectOk(expected_wav_path.string());
+  EXPECT_EQ(wav_reader.bit_depth(), kTest000005ExpectedWavBitDepth);
+}
+
+TEST(EncoderMainLibTest, OutputRenderedFileFormatCanOverrideBitDepth) {
+  std::string wav_directory;
+  iamf_tools_cli_proto::UserMetadata user_metadata;
+  ParseTestVectorAssertSuccess("test_000005.textproto", wav_directory,
+                               user_metadata);
+  const auto output_iamf_directory = GetAndCreateOutputDirectory("");
+  // Update controls to write out a wav file with a specific bit-depth.
+  user_metadata.mutable_test_vector_metadata()
+      ->clear_output_wav_file_bit_depth_override();
+  constexpr int kExpectedOverriddenBitDepth = 24;
+  user_metadata.mutable_encoder_control_metadata()
+      ->set_output_rendered_file_format(
+          OUTPUT_FORMAT_WAV_BIT_DEPTH_TWENTY_FOUR);
+
+  EXPECT_THAT(TestMain(user_metadata, wav_directory, output_iamf_directory),
+              IsOk());
+
+  // The wav file matches the overridden bit-depth.
+  const auto expected_wav_path = std::filesystem::path(output_iamf_directory) /
+                                 kTest000005ExpectedWavFilename;
+  EXPECT_TRUE(std::filesystem::exists(expected_wav_path));
+  const auto wav_reader = CreateWavReaderExpectOk(expected_wav_path.string());
+  EXPECT_EQ(wav_reader.bit_depth(), kExpectedOverriddenBitDepth);
+}
+
+TEST(EncoderMainLibTest, OutputRenderedFileFormatCanDisableWavFileOutput) {
+  std::string wav_directory;
+  iamf_tools_cli_proto::UserMetadata user_metadata;
+  ParseTestVectorAssertSuccess("test_000005.textproto", wav_directory,
+                               user_metadata);
+  const auto output_iamf_directory = GetAndCreateOutputDirectory("");
+  // Update controls to disable writing a wav file.
+  user_metadata.mutable_test_vector_metadata()
+      ->clear_output_wav_file_bit_depth_override();
+  user_metadata.mutable_encoder_control_metadata()
+      ->set_output_rendered_file_format(
+          iamf_tools_cli_proto::OUTPUT_FORMAT_NONE);
+
+  EXPECT_THAT(TestMain(user_metadata, wav_directory, output_iamf_directory),
+              IsOk());
+
+  // The wav file is absent.
+  const auto wav_path = std::filesystem::path(output_iamf_directory) /
+                        kTest000005ExpectedWavFilename;
+  EXPECT_FALSE(std::filesystem::exists(wav_path));
+}
+
 TEST(EncoderMainLibTest, SettingPrefixOutputsFile) {
   iamf_tools_cli_proto::UserMetadata user_metadata;
   AddIaSequenceHeader(user_metadata);
@@ -173,24 +292,22 @@ using TestVector = ::testing::TestWithParam<absl::string_view>;
 TEST_P(TestVector, ValidateTestSuite) {
   // Get the location of test wav files.
   const auto textproto_filename = GetParam();
-  static const auto input_wav_dir =
-      std::filesystem::current_path() / std::string("iamf/cli/testdata");
-
-  // Get the textproto to test.
-  const auto user_metadata_filename = std::filesystem::current_path() /
-                                      std::string("iamf/cli/testdata") /
-                                      textproto_filename;
+  std::string wav_directory;
   iamf_tools_cli_proto::UserMetadata user_metadata;
-  ParseUserMetadataAssertSuccess(user_metadata_filename.string(),
-                                 user_metadata);
+  ParseTestVectorAssertSuccess(textproto_filename, wav_directory,
+                               user_metadata);
 
   // Call encoder. Clear `file_name_prefix`; we only care about the status and
   // not the output files.
   user_metadata.mutable_test_vector_metadata()->clear_file_name_prefix();
+  // Skip checking the loudness is consistent with the user-provided data.
+  // Loudness depends on coding and rendering details, and may slightly drift as
+  // these change over time.
+  user_metadata.mutable_test_vector_metadata()->set_validate_user_loudness(
+      false);
   LOG(INFO) << "Testing with " << textproto_filename;
-  const absl::Status result =
-      iamf_tools::TestMain(user_metadata, input_wav_dir.string().c_str(),
-                           std::string(kIgnoredOutputPath));
+  const absl::Status result = iamf_tools::TestMain(
+      user_metadata, wav_directory, std::string(kIgnoredOutputPath));
 
   // Check if the result matches the expected value in the protos.
   if (user_metadata.test_vector_metadata().is_valid()) {
diff --git a/iamf/cli/tests/iamf_components_test.cc b/iamf/cli/tests/iamf_components_test.cc
index dcd1ff4..59a3aad 100644
--- a/iamf/cli/tests/iamf_components_test.cc
+++ b/iamf/cli/tests/iamf_components_test.cc
@@ -21,12 +21,12 @@
 namespace iamf_tools {
 namespace {
 
-TEST(IamfComponentsTest, CreateRendererFactoryReturnsNull) {
-  EXPECT_EQ(CreateRendererFactory(), nullptr);
+TEST(IamfComponentsTest, CreateRendererFactoryReturnsNonNull) {
+  EXPECT_NE(CreateRendererFactory(), nullptr);
 }
 
-TEST(IamfComponentsTest, CreatreLoudnessCalculatorFactoryReturnsNull) {
-  EXPECT_EQ(CreateLoudnessCalculatorFactory(), nullptr);
+TEST(IamfComponentsTest, CreateLoudnessCalculatorFactoryReturnsNonNull) {
+  EXPECT_NE(CreateLoudnessCalculatorFactory(), nullptr);
 }
 
 TEST(IamfComponentsTest,
diff --git a/iamf/cli/tests/iamf_encoder_test.cc b/iamf/cli/tests/iamf_encoder_test.cc
index 45cf7ba..6a8d711 100644
--- a/iamf/cli/tests/iamf_encoder_test.cc
+++ b/iamf/cli/tests/iamf_encoder_test.cc
@@ -84,7 +84,7 @@ void AddCodecConfig(UserMetadata& user_metadata) {
           audio_roll_distance: 0
           decoder_config_lpcm {
             sample_format_flags: LPCM_LITTLE_ENDIAN
-            sample_rate: 48000
+            sample_rate: 16000
           }
         }
       )pb",
diff --git a/iamf/cli/tests/obu_processor_test.cc b/iamf/cli/tests/obu_processor_test.cc
index 4ce2376..403651d 100644
--- a/iamf/cli/tests/obu_processor_test.cc
+++ b/iamf/cli/tests/obu_processor_test.cc
@@ -26,6 +26,7 @@
 #include <vector>
 
 #include "absl/container/flat_hash_map.h"
+#include "absl/container/flat_hash_set.h"
 #include "absl/status/status_matchers.h"
 #include "absl/strings/string_view.h"
 #include "absl/types/span.h"
@@ -62,10 +63,13 @@ namespace {
 
 using ::absl_testing::IsOk;
 using ::absl_testing::IsOkAndHolds;
+using ::testing::_;
 using ::testing::IsNull;
 using ::testing::Not;
 using ::testing::NotNull;
 
+using absl::MakeConstSpan;
+
 constexpr DecodedUleb128 kFirstCodecConfigId = 1;
 constexpr DecodedUleb128 kSecondCodecConfigId = 2;
 constexpr DecodedUleb128 kFirstAudioElementId = 2;
@@ -93,6 +97,13 @@ constexpr std::optional<uint8_t> kNoOutputFileBitDepthOverride = std::nullopt;
 constexpr std::array<uint8_t, 16> kArbitraryAudioFrame = {
     1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
 
+const absl::flat_hash_set<ProfileVersion> kIamfV1_0_0ErrataProfiles = {
+    ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile};
+
+const absl::flat_hash_set<ProfileVersion> kIamfV1_1_1Profiles = {
+    ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile,
+    ProfileVersion::kIamfBaseEnhancedProfile};
+
 std::vector<uint8_t> AddSequenceHeaderAndSerializeObusExpectOk(
     const std::list<const ObuBase*>& input_ia_sequence_without_header) {
   const IASequenceHeaderObu ia_sequence_header(
@@ -126,7 +137,6 @@ TEST(ProcessDescriptorObus, FailsWithEmptyBitstream) {
   std::list<MixPresentationObu> mix_presentation_obus;
 
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity,
       absl::MakeConstSpan(bitstream_without_ia_sequence_header));
   bool insufficient_data;
   EXPECT_FALSE(ObuProcessor::ProcessDescriptorObus(
@@ -158,7 +168,7 @@ TEST(ProcessDescriptorObus, CollectsCodecConfigsBeforeATemporalUnit) {
   std::list<MixPresentationObu> mix_presentation_obus;
 
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(two_codec_configs_and_audio_frame));
+      absl::MakeConstSpan(two_codec_configs_and_audio_frame));
   bool insufficient_data;
   EXPECT_THAT(
       ObuProcessor::ProcessDescriptorObus(
@@ -176,6 +186,47 @@ TEST(ProcessDescriptorObus, CollectsCodecConfigsBeforeATemporalUnit) {
   EXPECT_FALSE(insufficient_data);
 }
 
+TEST(ProcessDescriptorObus, IgnoresImplausibleCodecConfigObus) {
+  absl::flat_hash_map<DecodedUleb128, CodecConfigObu> input_codec_configs;
+  AddOpusCodecConfigWithId(kFirstCodecConfigId, input_codec_configs);
+  std::vector<uint8_t> bitstream = AddSequenceHeaderAndSerializeObusExpectOk(
+      {&input_codec_configs.at(kFirstCodecConfigId)});
+  // Insert an invalid tiny Codec Config OBU. This is too small to be
+  // syntactically valid.
+  const std::vector<uint8_t> tiny_invalid_codec_config = {
+      // First byte of the OBU header.
+      0x00,
+      // `obu_size`
+      0x02,
+      // `codec_config_id`.
+      0x09,
+      // Implausibly small `codec_id`.
+      0x00};
+  bitstream.insert(bitstream.end(), tiny_invalid_codec_config.begin(),
+                   tiny_invalid_codec_config.end());
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
+  IASequenceHeaderObu unused_ia_sequence_header;
+  absl::flat_hash_map<DecodedUleb128, CodecConfigObu> output_codec_config_obus;
+  absl::flat_hash_map<DecodedUleb128, AudioElementWithData>
+      audio_elements_with_data;
+  std::list<MixPresentationObu> mix_presentation_obus;
+  bool insufficient_data;
+
+  EXPECT_THAT(
+      ObuProcessor::ProcessDescriptorObus(
+          /*is_exhaustive_and_exact=*/true, *read_bit_buffer,
+          unused_ia_sequence_header, output_codec_config_obus,
+          audio_elements_with_data, mix_presentation_obus, insufficient_data),
+      IsOk());
+
+  // We only find the valid Codec Config OBU, with no sign of the tiny one.
+  EXPECT_EQ(output_codec_config_obus.size(), 1);
+  EXPECT_TRUE(output_codec_config_obus.contains(kFirstCodecConfigId));
+  // The buffer advanced past the tiny Codec Config OBU.
+  EXPECT_FALSE(read_bit_buffer->CanReadBytes(1));
+}
+
 TEST(ProcessDescriptorObus, CollectsCodecConfigsAtEndOfBitstream) {
   absl::flat_hash_map<DecodedUleb128, CodecConfigObu> input_codec_configs;
   AddOpusCodecConfigWithId(kFirstCodecConfigId, input_codec_configs);
@@ -191,7 +242,6 @@ TEST(ProcessDescriptorObus, CollectsCodecConfigsAtEndOfBitstream) {
   std::list<MixPresentationObu> mix_presentation_obus;
 
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity,
       absl::MakeConstSpan(two_codec_configs_at_end_of_bitstream));
   bool insufficient_data;
   EXPECT_THAT(
@@ -224,7 +274,6 @@ TEST(ProcessDescriptorObus,
   std::list<MixPresentationObu> mix_presentation_obus;
 
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity,
       absl::MakeConstSpan(two_codec_configs_at_end_of_bitstream));
   auto start_position = read_bit_buffer->Tell();
   bool insufficient_data;
@@ -251,7 +300,7 @@ TEST(ProcessDescriptorObus, CollectsIaSequenceHeaderWithoutOtherObus) {
   std::list<MixPresentationObu> mix_presentation_obus;
 
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(only_ia_sequence_header));
+      absl::MakeConstSpan(only_ia_sequence_header));
   bool insufficient_data;
   EXPECT_THAT(
       ObuProcessor::ProcessDescriptorObus(
@@ -286,7 +335,6 @@ TEST(ProcessDescriptorObus, DescriptorObusMustStartWithIaSequenceHeader) {
                              &input_codec_configs.at(kFirstCodecConfigId)});
 
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity,
       absl::MakeConstSpan(ia_sequence_header_then_codec_config));
   bool insufficient_data;
   EXPECT_THAT(ObuProcessor::ProcessDescriptorObus(
@@ -303,7 +351,6 @@ TEST(ProcessDescriptorObus, DescriptorObusMustStartWithIaSequenceHeader) {
                              &input_ia_sequence_header});
 
   read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity,
       absl::MakeConstSpan(codec_config_then_ia_sequence_header));
   EXPECT_FALSE(ObuProcessor::ProcessDescriptorObus(
                    /*is_exhaustive_and_exact=*/true, *read_bit_buffer,
@@ -328,8 +375,8 @@ TEST(ProcessDescriptorObus, SucceedsWithSuccessiveRedundantSequenceHeaders) {
       audio_elements_with_data;
   std::list<MixPresentationObu> mix_presentation_obus;
 
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   bool insufficient_data;
   EXPECT_THAT(
       ObuProcessor::ProcessDescriptorObus(
@@ -360,8 +407,8 @@ TEST(ProcessDescriptorObus, ConsumesUpToNextNonRedundantSequenceHeader) {
       audio_elements_with_data;
   std::list<MixPresentationObu> mix_presentation_obus;
 
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(buffer));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(buffer));
   bool insufficient_data;
   EXPECT_THAT(
       ObuProcessor::ProcessDescriptorObus(
@@ -393,7 +440,6 @@ TEST(ProcessDescriptorObus, CollectsIaSequenceHeaderWithCodecConfigs) {
   std::list<MixPresentationObu> mix_presentation_obus;
 
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity,
       absl::MakeConstSpan(ia_sequence_header_with_codec_configs));
   bool insufficient_data;
   EXPECT_THAT(
@@ -444,7 +490,6 @@ TEST(ProcessDescriptorObus, SucceedsWithoutTemporalUnitFollowing) {
   std::list<MixPresentationObu> mix_presentation_obus;
 
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity,
       absl::MakeConstSpan(zeroth_order_ambisonics_descriptor_obus));
   bool insufficient_data;
 
@@ -480,7 +525,6 @@ TEST(ProcessDescriptorObus,
   std::list<MixPresentationObu> mix_presentation_obus;
 
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity,
       absl::MakeConstSpan(zeroth_order_ambisonics_descriptor_obus));
   auto start_position = read_bit_buffer->Tell();
   bool insufficient_data;
@@ -519,8 +563,8 @@ TEST(ProcessDescriptorObusTest,
       audio_elements_with_data;
   std::list<MixPresentationObu> mix_presentation_obus;
 
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   auto start_position = read_bit_buffer->Tell();
   bool insufficient_data;
 
@@ -556,8 +600,8 @@ TEST(ProcessDescriptorObusTest, SucceedsWithTemporalUnitFollowing) {
       audio_elements_with_data;
   std::list<MixPresentationObu> mix_presentation_obus;
 
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   bool insufficient_data;
 
   EXPECT_THAT(
@@ -603,8 +647,8 @@ TEST(ProcessDescriptorObusTest,
       audio_elements_with_data;
   std::list<MixPresentationObu> mix_presentation_obus;
 
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   auto start_position = read_bit_buffer->Tell();
   bool insufficient_data;
 
@@ -635,8 +679,8 @@ TEST(ProcessDescriptorObus, RejectsDescriptorObusWithPartialHeaderFollowing) {
       audio_elements_with_data;
   std::list<MixPresentationObu> mix_presentation_obus;
 
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   auto start_position = read_bit_buffer->Tell();
   bool insufficient_data;
 
@@ -659,7 +703,7 @@ TEST(ProcessDescriptorObus, RejectsDescriptorObusWithPartialHeaderFollowing) {
 TEST(ProcessTemporalUnitObus, OkAndProducesNoObusIfEmpty) {
   const auto empty_temporal_unit = SerializeObusExpectOk({});
   auto empty_read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(empty_temporal_unit));
+      absl::MakeConstSpan(empty_temporal_unit));
   const absl::flat_hash_map<DecodedUleb128, CodecConfigObu> kNoCodecConfigs =
       {};
   const absl::flat_hash_map<DecodedUleb128, AudioElementWithData>
@@ -719,7 +763,7 @@ TEST(ProcessTemporalUnitObus, ConsumesAllTemporalUnits) {
   ASSERT_THAT(parameters_manager.Initialize(), IsOk());
   absl::flat_hash_map<DecodedUleb128, ParamDefinitionVariant> param_definitions;
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(one_temporal_unit));
+      absl::MakeConstSpan(one_temporal_unit));
 
   bool continue_processing = true;
   std::optional<AudioFrameWithData> audio_frame_with_data;
@@ -771,9 +815,8 @@ TEST(ProcessTemporalUnitObus, ReadsAllTemporalUnitsBeforeNewIaSequence) {
   ParametersManager parameters_manager(audio_elements_with_data);
   ASSERT_THAT(parameters_manager.Initialize(), IsOk());
   absl::flat_hash_map<DecodedUleb128, ParamDefinitionVariant> param_definitions;
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity,
-      absl::MakeConstSpan(
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(
           one_temporal_unit_before_non_redundant_descriptor_obu));
 
   bool continue_processing = true;
@@ -845,7 +888,6 @@ TEST(ProcessTemporalUnitObus,
   ASSERT_THAT(parameters_manager.Initialize(), IsOk());
   absl::flat_hash_map<DecodedUleb128, ParamDefinitionVariant> param_definitions;
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity,
       absl::MakeConstSpan(one_temporal_unit_before_redundant_descriptor_obu));
 
   bool continue_processing = true;
@@ -926,7 +968,6 @@ TEST(ProcessTemporalUnitObus,
   ASSERT_THAT(parameters_manager.Initialize(), IsOk());
   absl::flat_hash_map<DecodedUleb128, ParamDefinitionVariant> param_definitions;
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity,
       absl::MakeConstSpan(temporal_unit_with_non_redundant_codec_config_obu));
 
   bool continue_processing = true;
@@ -989,7 +1030,7 @@ TEST(ProcessTemporalUnitObus, ConsumesAllTemporalUnitsAndReservedObus) {
   ASSERT_THAT(parameters_manager.Initialize(), IsOk());
   absl::flat_hash_map<DecodedUleb128, ParamDefinitionVariant> param_definitions;
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(temporal_unit_with_reserved_obus));
+      absl::MakeConstSpan(temporal_unit_with_reserved_obus));
 
   bool continue_processing = true;
   std::optional<AudioFrameWithData> audio_frame_with_data;
@@ -1075,7 +1116,7 @@ TEST(ProcessTemporalUnitObusTest, ProcessMultipleAudioSubstreams) {
   ASSERT_THAT(parameters_manager.Initialize(), IsOk());
   absl::flat_hash_map<DecodedUleb128, ParamDefinitionVariant> param_definitions;
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(multiple_audio_substreams));
+      absl::MakeConstSpan(multiple_audio_substreams));
 
   bool continue_processing = true;
   std::optional<AudioFrameWithData> audio_frame_with_data;
@@ -1128,7 +1169,7 @@ TEST(ProcessTemporalUnitObusTest, ProcessesSubstreamWithMultipleFrames) {
   ASSERT_THAT(parameters_manager.Initialize(), IsOk());
   absl::flat_hash_map<DecodedUleb128, ParamDefinitionVariant> param_definitions;
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(audio_substream_with_two_frames));
+      absl::MakeConstSpan(audio_substream_with_two_frames));
 
   bool continue_processing = true;
   std::optional<AudioFrameWithData> audio_frame_with_data;
@@ -1185,7 +1226,6 @@ TEST(ProcessTemporalUnitObusTest, ProcessesTemporalDelimiterObu) {
   ASSERT_THAT(parameters_manager.Initialize(), IsOk());
   absl::flat_hash_map<DecodedUleb128, ParamDefinitionVariant> param_definitions;
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity,
       absl::MakeConstSpan(two_temporal_units_with_delimiter_obu));
 
   bool continue_processing = true;
@@ -1256,7 +1296,7 @@ TEST(ProcessTemporalUnitObusTest,
   ParametersManager parameters_manager(audio_elements_with_data);
   ASSERT_THAT(parameters_manager.Initialize(), IsOk());
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(one_parameter_block_obu));
+      absl::MakeConstSpan(one_parameter_block_obu));
 
   bool continue_processing = true;
   std::optional<AudioFrameWithData> audio_frame_with_data;
@@ -1274,7 +1314,7 @@ TEST(ProcessTemporalUnitObusTest,
   EXPECT_FALSE(temporal_delimiter.has_value());
   EXPECT_TRUE(continue_processing);
 
-  const int32_t kObuRelativeTime = 0;
+  const InternalTimestamp kObuRelativeTime = 0;
   float unused_mix_gain;
   EXPECT_THAT(parameter_block_with_data->obu->GetLinearMixGain(kObuRelativeTime,
                                                                unused_mix_gain),
@@ -1314,7 +1354,7 @@ TEST(ProcessTemporalUnitObus,
   // incomplete header (A header requires at least 2 bytes).
   one_temporal_unit.push_back(0);
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(one_temporal_unit));
+      absl::MakeConstSpan(one_temporal_unit));
 
   // Confirm that the first temporal unit is processed successfully.
   bool continue_processing = true;
@@ -1381,7 +1421,7 @@ TEST(ProcessTemporalUnitObus,
                      extra_audio_frame_obu_header_bytes.begin(),
                      extra_audio_frame_obu_header_bytes.end());
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(ia_sequence));
+      absl::MakeConstSpan(ia_sequence));
 
   // Confirm that the first temporal unit is processed successfully.
   bool continue_processing = true;
@@ -1423,8 +1463,8 @@ TEST(ProcessTemporalUnit, ConsumesOneAudioFrameAsTemporalUnit) {
   auto temporal_unit_obus = SerializeObusExpectOk({&audio_frame_obu});
   bitstream.insert(bitstream.end(), temporal_unit_obus.begin(),
                    temporal_unit_obus.end());
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   bool insufficient_data;
   auto obu_processor =
       ObuProcessor::Create(/*is_exhaustive_and_exact=*/false,
@@ -1454,8 +1494,8 @@ TEST(ProcessTemporalUnit, DoesNotConsumeOneAudioFrameAsTemporalUnit) {
   auto temporal_unit_obus = SerializeObusExpectOk({&audio_frame_obu});
   bitstream.insert(bitstream.end(), temporal_unit_obus.begin(),
                    temporal_unit_obus.end());
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   bool insufficient_data;
   auto obu_processor =
       ObuProcessor::Create(/*is_exhaustive_and_exact=*/false,
@@ -1489,8 +1529,8 @@ TEST(ProcessTemporalUnit, ConsumesMultipleTemporalUnitsWithTemporalDelimiters) {
   bitstream.insert(bitstream.end(),
                    two_temporal_units_with_delimiter_obu.begin(),
                    two_temporal_units_with_delimiter_obu.end());
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   bool insufficient_data;
   auto obu_processor =
       ObuProcessor::Create(/*is_exhaustive_and_exact=*/false,
@@ -1537,8 +1577,8 @@ TEST(ProcessTemporalUnit,
       SerializeObusExpectOk({&audio_frame_obus[0], &audio_frame_obus[1]});
   bitstream.insert(bitstream.end(), two_temporal_units.begin(),
                    two_temporal_units.end());
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   bool insufficient_data;
   auto obu_processor =
       ObuProcessor::Create(/*is_exhaustive_and_exact=*/false,
@@ -1588,8 +1628,8 @@ TEST(ProcessTemporalUnit, ConsumesOnlyOneTemporalUnitFromTwoAudioFrames) {
       SerializeObusExpectOk({&audio_frame_obus[0], &audio_frame_obus[1]});
   bitstream.insert(bitstream.end(), two_temporal_units.begin(),
                    two_temporal_units.end());
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   bool insufficient_data;
   auto obu_processor =
       ObuProcessor::Create(/*is_exhaustive_and_exact=*/false,
@@ -1647,8 +1687,8 @@ TEST(ProcessTemporalUnit,
                             extra_audio_frame_obu_header_bytes.end());
   bitstream.insert(bitstream.end(), two_temporal_units.begin(),
                    two_temporal_units.end());
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   bool insufficient_data;
   auto obu_processor =
       ObuProcessor::Create(/*is_exhaustive_and_exact=*/false,
@@ -1801,8 +1841,8 @@ TEST(CollectObusFromIaSequence, ConsumesIaSequenceAndCollectsAllObus) {
   std::list<MixPresentationObu> mix_presentation_obus;
   std::list<AudioFrameWithData> audio_frames;
   std::list<ParameterBlockWithData> parameter_blocks;
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   EXPECT_THAT(CollectObusFromIaSequence(*read_bit_buffer, ia_sequence_header,
                                         codec_config_obus, audio_elements,
                                         mix_presentation_obus, audio_frames,
@@ -1850,7 +1890,7 @@ TEST(CollectObusFromIaSequence, ConsumesTrivialIaSequence) {
   std::list<AudioFrameWithData> audio_frames;
   std::list<ParameterBlockWithData> parameter_blocks;
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(two_ia_sequences));
+      absl::MakeConstSpan(two_ia_sequences));
   EXPECT_THAT(CollectObusFromIaSequence(*read_bit_buffer, ia_sequence_header,
                                         codec_config_obus, audio_elements,
                                         mix_presentation_obus, audio_frames,
@@ -1897,8 +1937,8 @@ TEST(CollectObusFromIaSequence, ConsumesUpToNextIaSequence) {
   std::list<MixPresentationObu> mix_presentation_obus;
   std::list<AudioFrameWithData> audio_frames;
   std::list<ParameterBlockWithData> parameter_blocks;
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   EXPECT_THAT(CollectObusFromIaSequence(*read_bit_buffer, ia_sequence_header,
                                         codec_config_obus, audio_elements,
                                         mix_presentation_obus, audio_frames,
@@ -1912,8 +1952,8 @@ TEST(CollectObusFromIaSequence, ConsumesUpToNextIaSequence) {
 
 TEST(Create, Succeeds) {
   auto bitstream = InitAllDescriptorsForZerothOrderAmbisonics();
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   bool insufficient_data;
 
   auto obu_processor =
@@ -1932,8 +1972,8 @@ TEST(Create, SucceedsForTrivialIaSequence) {
       ObuHeader(), IASequenceHeaderObu::kIaCode,
       ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
   auto buffer = SerializeObusExpectOk({&kIaSequenceHeader});
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(buffer));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(buffer));
   bool insufficient_data;
   auto obu_processor =
       ObuProcessor::Create(/*is_exhaustive_and_exact=*/true,
@@ -1955,8 +1995,8 @@ TEST(Create, FailsOnNullReadBitBuffer) {
 
 TEST(Create, FailsOnInsufficientData) {
   auto bitstream = InitAllDescriptorsForZerothOrderAmbisonics();
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   bool insufficient_data;
 
   auto obu_processor =
@@ -1977,8 +2017,8 @@ TEST(GetOutputSampleRate, ReturnsSampleRateBasedOnCodecConfigObu) {
                                         codec_config_obus);
   const auto buffer = SerializeObusExpectOk(
       {&kIaSequenceHeader, &codec_config_obus.at(kFirstCodecConfigId)});
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(buffer));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(buffer));
   bool insufficient_data;
   auto obu_processor =
       ObuProcessor::Create(/*is_exhaustive_and_exact=*/true,
@@ -1993,8 +2033,8 @@ TEST(GetOutputSampleRate, FailsForTrivialIaSequence) {
       ObuHeader(), IASequenceHeaderObu::kIaCode,
       ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
   const auto buffer = SerializeObusExpectOk({&kIaSequenceHeader});
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(buffer));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(buffer));
   bool insufficient_data;
   auto obu_processor =
       ObuProcessor::Create(/*is_exhaustive_and_exact=*/true,
@@ -2016,8 +2056,8 @@ TEST(GetOutputSampleRate, FailsForMultipleCodecConfigObus) {
   const auto buffer = SerializeObusExpectOk(
       {&kIaSequenceHeader, &codec_config_obus.at(kFirstCodecConfigId),
        &codec_config_obus.at(kSecondCodecConfigId)});
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(buffer));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(buffer));
   bool insufficient_data;
   auto obu_processor =
       ObuProcessor::Create(/*is_exhaustive_and_exact=*/true,
@@ -2036,8 +2076,8 @@ TEST(GetOutputFrameSize, ReturnsSampleRateBasedOnCodecConfigObu) {
                      codec_config_obus);
   const auto buffer = SerializeObusExpectOk(
       {&kIaSequenceHeader, &codec_config_obus.at(kFirstCodecConfigId)});
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(buffer));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(buffer));
   bool insufficient_data;
   auto obu_processor =
       ObuProcessor::Create(/*is_exhaustive_and_exact=*/true,
@@ -2052,8 +2092,8 @@ TEST(GetOutputFrameSize, FailsForTrivialIaSequence) {
       ObuHeader(), IASequenceHeaderObu::kIaCode,
       ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
   const auto buffer = SerializeObusExpectOk({&kIaSequenceHeader});
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(buffer));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(buffer));
   bool insufficient_data;
   auto obu_processor =
       ObuProcessor::Create(/*is_exhaustive_and_exact=*/true,
@@ -2075,8 +2115,8 @@ TEST(GetOutputFrameSize, FailsForMultipleCodecConfigObus) {
   const auto buffer = SerializeObusExpectOk(
       {&kIaSequenceHeader, &codec_config_obus.at(kFirstCodecConfigId),
        &codec_config_obus.at(kSecondCodecConfigId)});
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(buffer));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(buffer));
   bool insufficient_data;
   auto obu_processor =
       ObuProcessor::Create(/*is_exhaustive_and_exact=*/true,
@@ -2094,8 +2134,8 @@ TEST(NonStatic, ProcessTemporalUnitObu) {
   bitstream.insert(bitstream.end(), temporal_unit_obus.begin(),
                    temporal_unit_obus.end());
 
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   bool insufficient_data;
 
   auto obu_processor =
@@ -2127,27 +2167,31 @@ void RenderUsingObuProcessorExpectOk(
     const std::list<ParameterBlockWithData>& parameter_blocks,
     const std::vector<uint8_t>& bitstream_of_descriptors) {
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream_of_descriptors));
+      absl::MakeConstSpan(bitstream_of_descriptors));
   bool insufficient_data;
 
   const std::string output_filename_string(output_filename);
   Layout unused_output_layout;
   auto obu_processor = ObuProcessor::CreateForRendering(
-      kStereoLayout,
+      kIamfV1_0_0ErrataProfiles, kStereoLayout,
       CreateAllWavWriters(output_filename_string, write_wav_header),
       /*is_exhaustive_and_exact=*/true, read_bit_buffer.get(),
       unused_output_layout, insufficient_data);
   ASSERT_THAT(obu_processor, NotNull());
   ASSERT_FALSE(insufficient_data);
-  absl::Span<const std::vector<int32_t>> output_rendered_pcm_samples;
+  absl::Span<const absl::Span<const int32_t>> output_rendered_pcm_samples;
   EXPECT_THAT(obu_processor->RenderTemporalUnitAndMeasureLoudness(
                   /*timestamp=*/0, audio_frames, parameter_blocks,
                   output_rendered_pcm_samples),
               IsOk());
-  EXPECT_TRUE(output_rendered_pcm_samples.empty());
+  for (const auto output_channel : output_rendered_pcm_samples) {
+    EXPECT_TRUE(output_channel.empty());
+  }
 }
 
-void RenderOneSampleFoaToStereoWavExpectOk(
+// Render a zero-th order ambisonics (i.e. mono) with one sampel to stereo
+// and expect the rendering process is ok.
+void RenderOneSampleZoaToStereoWavExpectOk(
     absl::string_view output_filename, bool write_wav_header,
     std::optional<uint8_t> output_file_bit_depth_override) {
   absl::flat_hash_map<DecodedUleb128, CodecConfigObu> codec_config_obus;
@@ -2172,6 +2216,7 @@ void RenderOneSampleFoaToStereoWavExpectOk(
       .end_timestamp = 1,
       .audio_element_with_data = common_audio_element_with_data,
   });
+
   // Create a single parameter block consistent with the mix presentation OBU.
   std::list<ParameterBlockWithData> parameter_blocks_with_data = {};
   auto parameter_block = std::make_unique<ParameterBlockObu>(
@@ -2196,6 +2241,7 @@ void RenderOneSampleFoaToStereoWavExpectOk(
       output_filename, write_wav_header, output_file_bit_depth_override,
       audio_frames_with_data, parameter_blocks_with_data, bitstream);
 }
+
 TEST(RenderAudioFramesWithDataAndMeasureLoudness, RenderingNothingReturnsOk) {
   absl::flat_hash_map<DecodedUleb128, CodecConfigObu> codec_config_obus;
   AddLpcmCodecConfigWithIdAndSampleRate(kFirstCodecConfigId, kSampleRate,
@@ -2289,7 +2335,7 @@ TEST(RenderAudioFramesWithDataAndMeasureLoudness,
      SupportsMixGainParameterBlocks) {
   const auto output_filename = GetAndCleanupOutputFileName(".wav");
 
-  RenderOneSampleFoaToStereoWavExpectOk(output_filename, kWriteWavHeader,
+  RenderOneSampleZoaToStereoWavExpectOk(output_filename, kWriteWavHeader,
                                         kNoOutputFileBitDepthOverride);
 
   const auto wav_reader = CreateWavReaderExpectOk(output_filename);
@@ -2298,14 +2344,14 @@ TEST(RenderAudioFramesWithDataAndMeasureLoudness,
 
 TEST(RenderAudioFramesWithDataAndMeasureLoudness, CanWritePcmOrWav) {
   const auto output_wav_filename = GetAndCleanupOutputFileName(".wav");
-  RenderOneSampleFoaToStereoWavExpectOk(output_wav_filename, kWriteWavHeader,
+  RenderOneSampleZoaToStereoWavExpectOk(output_wav_filename, kWriteWavHeader,
                                         kNoOutputFileBitDepthOverride);
 
   const auto wav_reader = CreateWavReaderExpectOk(output_wav_filename);
   EXPECT_EQ(wav_reader.remaining_samples(), 2);
 
   const auto output_pcm_filename = GetAndCleanupOutputFileName(".pcm");
-  RenderOneSampleFoaToStereoWavExpectOk(
+  RenderOneSampleZoaToStereoWavExpectOk(
       output_pcm_filename, kDontWriteWavHeader, kNoOutputFileBitDepthOverride);
 
   EXPECT_TRUE(std::filesystem::exists(output_pcm_filename));
@@ -2367,31 +2413,31 @@ TEST(RenderTemporalUnitAndMeasureLoudness, RendersPassthroughStereoToPcm) {
       {&codec_config_obus.at(kFirstCodecConfigId),
        &audio_elements_with_data.at(kFirstAudioElementId).obu,
        &mix_presentation_obus.front()});
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
 
   Layout unused_output_layout;
   bool insufficient_data;
   auto obu_processor = ObuProcessor::CreateForRendering(
-      kStereoLayout,
+      kIamfV1_0_0ErrataProfiles, kStereoLayout,
       RenderingMixPresentationFinalizer::ProduceNoSampleProcessors,
       /*is_exhaustive_and_exact=*/true, read_bit_buffer.get(),
       unused_output_layout, insufficient_data);
   ASSERT_THAT(obu_processor, NotNull());
   ASSERT_FALSE(insufficient_data);
-  absl::Span<const std::vector<int32_t>> output_rendered_pcm_samples;
+  absl::Span<const absl::Span<const int32_t>> output_rendered_pcm_samples;
   EXPECT_THAT(obu_processor->RenderTemporalUnitAndMeasureLoudness(
                   /*timestamp=*/0, audio_frames_with_data, kNoParameterBlocks,
                   output_rendered_pcm_samples),
               IsOk());
 
-  // Outer vector is for each tick, inner vector is for each channel.
+  // Outer vector is for each channel, inner vector is for each tick.
   std::vector<std::vector<int32_t>> expected_pcm_samples = {
-      {0x33110000, 0x44220000},
-      {0x77550000, 0x08660000},
-      {0x0a990000, 0x0dbb0000},
+      {0x33110000, 0x77550000, 0x0a990000},
+      {0x44220000, 0x08660000, 0x0dbb0000},
   };
-  EXPECT_EQ(output_rendered_pcm_samples, expected_pcm_samples);
+  EXPECT_EQ(output_rendered_pcm_samples,
+            MakeSpanOfConstSpans(expected_pcm_samples));
 }
 
 TEST(RenderAudioFramesWithDataAndMeasureLoudness,
@@ -2447,12 +2493,12 @@ TEST(RenderAudioFramesWithDataAndMeasureLoudness,
   EXPECT_EQ(wav_reader.ReadFrame(), 6);
   // Validate left channel.
   EXPECT_EQ(wav_reader.buffers_[0][0], int32_t{0x33110000});
-  EXPECT_EQ(wav_reader.buffers_[1][0], int32_t{0x77550000});
-  EXPECT_EQ(wav_reader.buffers_[2][0], int32_t{0x0a990000});
+  EXPECT_EQ(wav_reader.buffers_[0][1], int32_t{0x77550000});
+  EXPECT_EQ(wav_reader.buffers_[0][2], int32_t{0x0a990000});
   // Validate right channel.
-  EXPECT_EQ(wav_reader.buffers_[0][1], int32_t{0x44220000});
+  EXPECT_EQ(wav_reader.buffers_[1][0], int32_t{0x44220000});
   EXPECT_EQ(wav_reader.buffers_[1][1], int32_t{0x08660000});
-  EXPECT_EQ(wav_reader.buffers_[2][1], int32_t{0x0dbb0000});
+  EXPECT_EQ(wav_reader.buffers_[1][2], int32_t{0x0dbb0000});
 }
 
 TEST(RenderAudioFramesWithDataAndMeasureLoudness,
@@ -2480,13 +2526,13 @@ TEST(RenderAudioFramesWithDataAndMeasureLoudness,
          &audio_elements_with_data.at(kFirstAudioElementId).obu,
          &mix_presentation_obus.front()});
     auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-        kBufferCapacity, absl::MakeConstSpan(bitstream));
+        absl::MakeConstSpan(bitstream));
 
     Layout unused_output_layout;
     bool insufficient_data;
     const std::string output_filename_string(output_filename);
     auto obu_processor = ObuProcessor::CreateForRendering(
-        kStereoLayout,
+        kIamfV1_0_0ErrataProfiles, kStereoLayout,
         CreateAllWavWriters(output_filename_string, kWriteWavHeader),
         /*is_exhaustive_and_exact=*/true, read_bit_buffer.get(),
         unused_output_layout, insufficient_data);
@@ -2504,7 +2550,8 @@ TEST(RenderAudioFramesWithDataAndMeasureLoudness,
           .audio_element_with_data =
               &audio_elements_with_data.at(kFirstAudioElementId),
       });
-      absl::Span<const std::vector<int32_t>> unused_output_rendered_pcm_samples;
+      absl::Span<const absl::Span<const int32_t>>
+          unused_output_rendered_pcm_samples;
       EXPECT_THAT(obu_processor->RenderTemporalUnitAndMeasureLoudness(
                       /*timestamp=*/i, audio_frames_with_data,
                       kNoParameterBlocks, unused_output_rendered_pcm_samples),
@@ -2582,8 +2629,8 @@ TEST(RenderAudioFramesWithDataAndMeasureLoudness,
             kExpectedFirstSampleForFirstMixPresentation);
 }
 
-TEST(RenderAudioFramesWithDataAndMeasureLoudness,
-     DoesNotSupportBaseEnhancedProfile) {
+TEST(CreateForRendering,
+     ReturnsNullptrWhenDesiredProfileVersionIsNotSupported) {
   const auto output_filename = GetAndCleanupOutputFileName(".wav");
   absl::flat_hash_map<DecodedUleb128, CodecConfigObu> codec_config_obus;
   AddLpcmCodecConfigWithIdAndSampleRate(kFirstCodecConfigId, kSampleRate,
@@ -2640,96 +2687,132 @@ TEST(RenderAudioFramesWithDataAndMeasureLoudness,
        &audio_elements_with_data.at(kThirdAudioElementId).obu,
        &mix_presentation_obus.front()});
 
-  // Expect that the `ObuProcessor` rejects the rendering request.
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  // The only mix presentation requires Base-Enhanced profile, but the user
+  // restricted the profiles to Simple and Base.
+  const absl::flat_hash_set<ProfileVersion> kProfilesTooLow = {
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile};
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   Layout unused_output_layout;
   bool insufficient_data;
   auto obu_processor = ObuProcessor::CreateForRendering(
-      kStereoLayout,
+      kProfilesTooLow, kStereoLayout,
       RenderingMixPresentationFinalizer::ProduceNoSampleProcessors,
       /*is_exhaustive_and_exact=*/true, read_bit_buffer.get(),
       unused_output_layout, insufficient_data);
+
   EXPECT_FALSE(insufficient_data);
   EXPECT_THAT(obu_processor, IsNull());
 }
 
-TEST(RenderAudioFramesWithDataAndMeasureLoudness,
-     SelectsFirstSupportedMixPresentation) {
-  const auto output_filename = GetAndCleanupOutputFileName(".wav");
+TEST(CreateForRendering,
+     ForwardsBaseEnhancedProfileMixToSampleProcessorFactoryWhenConfigured) {
+  // Create a minimal fourth-order ambisonics IA Sequence. Fourth-order
+  // ambisonics requires Base-Enhanced profile, as of IAMF v1.1.0.
+  const IASequenceHeaderObu kIaSequenceHeader(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfBaseEnhancedProfile,
+      ProfileVersion::kIamfBaseEnhancedProfile);
   absl::flat_hash_map<DecodedUleb128, CodecConfigObu> codec_config_obus;
   AddLpcmCodecConfigWithIdAndSampleRate(kFirstCodecConfigId, kSampleRate,
                                         codec_config_obus);
   absl::flat_hash_map<DecodedUleb128, AudioElementWithData>
       audio_elements_with_data;
-  AddOneLayerStereoAudioElement(kFirstCodecConfigId, kFirstAudioElementId,
-                                kFirstSubstreamId, codec_config_obus,
-                                audio_elements_with_data);
-  AddOneLayerStereoAudioElement(kFirstCodecConfigId, kSecondAudioElementId,
-                                kSecondSubstreamId, codec_config_obus,
-                                audio_elements_with_data);
-  AddOneLayerStereoAudioElement(kFirstCodecConfigId, kThirdAudioElementId,
-                                kThirdSubstreamId, codec_config_obus,
-                                audio_elements_with_data);
-  std::list<AudioFrameWithData> audio_frames_with_data;
-  const std::list<ParameterBlockWithData> kNoParameterBlocks;
-  audio_frames_with_data.push_back(AudioFrameWithData{
-      .obu = AudioFrameObu(ObuHeader(), kFirstSubstreamId,
-                           /*audio_frame=*/{10, 0, 0, 0}),
-      .start_timestamp = 0,
-      .end_timestamp = 1,
-      .audio_element_with_data =
-          &audio_elements_with_data.at(kFirstAudioElementId),
-  });
-  audio_frames_with_data.push_back(AudioFrameWithData{
-      .obu = AudioFrameObu(ObuHeader(), kSecondSubstreamId,
-                           /*audio_frame=*/{20, 0, 0, 0}),
-      .start_timestamp = 0,
-      .end_timestamp = 1,
-      .audio_element_with_data =
-          &audio_elements_with_data.at(kSecondAudioElementId),
-  });
-  audio_frames_with_data.push_back(AudioFrameWithData{
-      .obu = AudioFrameObu(ObuHeader(), kThirdSubstreamId,
-                           /*audio_frame=*/{40, 0, 0, 0}),
-      .start_timestamp = 0,
-      .end_timestamp = 1,
-      .audio_element_with_data =
-          &audio_elements_with_data.at(kThirdAudioElementId),
-  });
-  // The first mix presentation is not suitable for simple or base profile.
+  constexpr std::array<DecodedUleb128, 25> kFourthOrderAmbisonicsSubstreamIds =
+      {0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+       13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24};
+  AddAmbisonicsMonoAudioElementWithSubstreamIds(
+      kFirstAudioElementId, kFirstCodecConfigId,
+      MakeConstSpan(kFourthOrderAmbisonicsSubstreamIds), codec_config_obus,
+      audio_elements_with_data);
   std::list<MixPresentationObu> mix_presentation_obus;
   AddMixPresentationObuWithAudioElementIds(
-      kFirstMixPresentationId,
-      {kFirstAudioElementId, kSecondAudioElementId, kThirdAudioElementId},
+      kFirstMixPresentationId, {kFirstAudioElementId},
       kCommonMixGainParameterId, kCommonParameterRate, mix_presentation_obus);
-  // The second is suitable.
-  constexpr int32_t kExpectedFirstSampleForFirstSupportedMixPresentation =
-      30 << 16;
+  const auto bitstream = SerializeObusExpectOk(
+      {&kIaSequenceHeader, &codec_config_obus.at(kFirstCodecConfigId),
+       &audio_elements_with_data.at(kFirstAudioElementId).obu,
+       &mix_presentation_obus.front()});
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(MakeConstSpan(bitstream));
+  // Minimize the test, we can exclude audio frames by claiming this is just the
+  // descriptors via `is_exhaustive_and_exact`.
+  constexpr bool kIsExhaustiveAndExact = true;
+  MockSampleProcessorFactory mock_sample_processor_factory;
+  EXPECT_CALL(mock_sample_processor_factory,
+              Call(kFirstMixPresentationId, _, _, _, _, _, _, _));
+
+  bool insufficient_data;
+  Layout unused_output_layout;
+  auto obu_processor = ObuProcessor::CreateForRendering(
+      kIamfV1_1_1Profiles, kStereoLayout,
+      mock_sample_processor_factory.AsStdFunction(), kIsExhaustiveAndExact,
+      read_bit_buffer.get(), unused_output_layout, insufficient_data);
+
+  EXPECT_FALSE(insufficient_data);
+  EXPECT_THAT(obu_processor, NotNull());
+}
+
+TEST(CreateForRendering,
+     ForwardsFirstSupportedMixPresentationToSampleProcessorFactory) {
+  // Create an IA Sequence with two mix presentations. The first mix
+  // presentation has 32-channels, and is not supported under Simple, Base, or
+  // Base-Enhanced profiles. The second mix presentation has sixteen channels,
+  // and is supported under all profiles defined in IAMF v1.1.0.
+  absl::flat_hash_map<DecodedUleb128, CodecConfigObu> codec_config_obus;
+  AddLpcmCodecConfigWithIdAndSampleRate(kFirstCodecConfigId, kSampleRate,
+                                        codec_config_obus);
+  absl::flat_hash_map<DecodedUleb128, AudioElementWithData>
+      audio_elements_with_data;
+  constexpr std::array<DecodedUleb128, 16> kFirstAudioElementSubstreamIds = {
+      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
+  AddAmbisonicsMonoAudioElementWithSubstreamIds(
+      kFirstAudioElementId, kFirstCodecConfigId,
+      MakeConstSpan(kFirstAudioElementSubstreamIds), codec_config_obus,
+      audio_elements_with_data);
+  constexpr std::array<DecodedUleb128, 16> kSecondAudioElementSubstreamIds = {
+      100, 101, 102, 103, 104, 105, 106, 107,
+      108, 109, 110, 111, 112, 113, 114, 115};
+  AddAmbisonicsMonoAudioElementWithSubstreamIds(
+      kSecondAudioElementId, kFirstCodecConfigId,
+      MakeConstSpan(kSecondAudioElementSubstreamIds), codec_config_obus,
+      audio_elements_with_data);
+  // The first mix presentation is not suitable for simple or base profile.
+  std::list<MixPresentationObu> mix_presentation_obus;
   AddMixPresentationObuWithAudioElementIds(
-      kSecondMixPresentationId, {kFirstAudioElementId, kSecondAudioElementId},
+      kFirstMixPresentationId, {kFirstAudioElementId, kSecondAudioElementId},
       kCommonMixGainParameterId, kCommonParameterRate, mix_presentation_obus);
-  // The third is also suitable, but the will not be selected.
+  // The second is suitable.
   AddMixPresentationObuWithAudioElementIds(
-      kThirdMixPresentationId, {kFirstAudioElementId, kThirdAudioElementId},
+      kSecondMixPresentationId, {kSecondAudioElementId},
       kCommonMixGainParameterId, kCommonParameterRate, mix_presentation_obus);
-
   auto mix_presentation_obus_iter = mix_presentation_obus.begin();
   const auto bitstream = AddSequenceHeaderAndSerializeObusExpectOk(
       {&codec_config_obus.at(kFirstCodecConfigId),
        &audio_elements_with_data.at(kFirstAudioElementId).obu,
        &audio_elements_with_data.at(kSecondAudioElementId).obu,
-       &audio_elements_with_data.at(kThirdAudioElementId).obu,
-       &(*mix_presentation_obus_iter++), &(*mix_presentation_obus_iter++),
-       &(*mix_presentation_obus_iter++)});
-  RenderUsingObuProcessorExpectOk(
-      output_filename, kWriteWavHeader, kNoOutputFileBitDepthOverride,
-      audio_frames_with_data, kNoParameterBlocks, bitstream);
+       &(*mix_presentation_obus_iter++), &(*mix_presentation_obus_iter++)});
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(MakeConstSpan(bitstream));
+  // Minimize the test, we can exclude audio frames by claiming this is just the
+  // descriptors via `is_exhaustive_and_exact`.
+  constexpr bool kIsExhaustiveAndExact = true;
 
-  auto wav_reader = CreateWavReaderExpectOk(output_filename);
-  EXPECT_EQ(wav_reader.ReadFrame(), 2);
-  EXPECT_EQ(wav_reader.buffers_[0][0],
-            kExpectedFirstSampleForFirstSupportedMixPresentation);
+  MockSampleProcessorFactory mock_sample_processor_factory;
+  // Regardless of the unsupported mix presentation, we expect the first
+  // supported mix presentation to be used.
+  EXPECT_CALL(mock_sample_processor_factory,
+              Call(kSecondMixPresentationId, _, _, _, _, _, _, _))
+      .Times(1);
+
+  bool insufficient_data;
+  Layout unused_output_layout;
+  auto obu_processor = ObuProcessor::CreateForRendering(
+      kIamfV1_0_0ErrataProfiles, kStereoLayout,
+      mock_sample_processor_factory.AsStdFunction(), kIsExhaustiveAndExact,
+      read_bit_buffer.get(), unused_output_layout, insufficient_data);
+  EXPECT_FALSE(insufficient_data);
+  EXPECT_THAT(obu_processor, NotNull());
 }
 
 TEST(CreateForRendering, ForwardsArgumentsToSampleProcessorFactory) {
@@ -2755,8 +2838,8 @@ TEST(CreateForRendering, ForwardsArgumentsToSampleProcessorFactory) {
       {&codec_config_obus.at(kFirstCodecConfigId),
        &audio_elements_with_data.at(kFirstAudioElementId).obu,
        &mix_presentation_obus.front()});
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   bool insufficient_data;
 
   // We expect arguments to be forwarded from the OBUs to the sample processor
@@ -2782,15 +2865,14 @@ TEST(CreateForRendering, ForwardsArgumentsToSampleProcessorFactory) {
       sample_processor_factory = mock_sample_processor_factory.AsStdFunction();
 
   Layout unused_output_layout;
-  EXPECT_THAT(ObuProcessor::CreateForRendering(
-                  kStereoLayout, sample_processor_factory,
-                  /*is_exhaustive_and_exact=*/true, read_bit_buffer.get(),
-                  unused_output_layout, insufficient_data),
-              NotNull());
+  EXPECT_THAT(
+      ObuProcessor::CreateForRendering(
+          kIamfV1_0_0ErrataProfiles, kStereoLayout, sample_processor_factory,
+          /*is_exhaustive_and_exact=*/true, read_bit_buffer.get(),
+          unused_output_layout, insufficient_data),
+      NotNull());
 }
 
-using testing::_;
-
 constexpr Layout k5_1_Layout = {
     .layout_type = Layout::kLayoutTypeLoudspeakersSsConvention,
     .specific_layout = LoudspeakersSsConventionLayout{
@@ -2824,8 +2906,8 @@ TEST(CreateForRendering, ForwardsChosenLayoutToSampleProcessorFactory) {
       {&codec_config_obus.at(kFirstCodecConfigId),
        &audio_elements_with_data.at(kFirstAudioElementId).obu,
        &mix_presentation_obus.front()});
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   bool insufficient_data;
 
   // We expect to use the second layout, since this is the only one that matches
@@ -2843,15 +2925,18 @@ TEST(CreateForRendering, ForwardsChosenLayoutToSampleProcessorFactory) {
       sample_processor_factory = mock_sample_processor_factory.AsStdFunction();
 
   Layout output_layout;
-  EXPECT_THAT(ObuProcessor::CreateForRendering(
-                  k5_1_Layout, sample_processor_factory,
-                  /*is_exhaustive_and_exact=*/true, read_bit_buffer.get(),
-                  output_layout, insufficient_data),
-              NotNull());
+  EXPECT_THAT(
+      ObuProcessor::CreateForRendering(
+          kIamfV1_0_0ErrataProfiles, k5_1_Layout, sample_processor_factory,
+          /*is_exhaustive_and_exact=*/true, read_bit_buffer.get(),
+          output_layout, insufficient_data),
+      NotNull());
   EXPECT_EQ(output_layout, k5_1_Layout);
 }
 
-TEST(CreateForRendering, ForwardsDefaultLayoutToSampleProcessorFactory) {
+TEST(CreateForRendering, ForwardsVirtualChosenLayoutToSampleProcessorFactory) {
+  // Set up inputs; key aspect is that the mix presentation does not contain the
+  // desired layout.
   absl::flat_hash_map<DecodedUleb128, CodecConfigObu> codec_config_obus;
   AddLpcmCodecConfigWithIdAndSampleRate(kFirstCodecConfigId, kSampleRate,
                                         codec_config_obus);
@@ -2879,30 +2964,33 @@ TEST(CreateForRendering, ForwardsDefaultLayoutToSampleProcessorFactory) {
       {&codec_config_obus.at(kFirstCodecConfigId),
        &audio_elements_with_data.at(kFirstAudioElementId).obu,
        &mix_presentation_obus.front()});
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   bool insufficient_data;
 
-  // We expect to use the first layout as default, since the desired layout is
-  // not available in the mix presentation.
+  // We expect to default to the first mix presentation and first submix.
+  // However, we expect the layout in the first position to be virtualized to
+  // match the desired layout, which is 5.1 in this case.
   constexpr int kSubmixIndex = 0;
   constexpr int kLayoutIndex = 0;
-  const auto& forwarded_layout =
-      mix_presentation_obus.front().sub_mixes_[0].layouts[0].loudness_layout;
+  const auto& forwarded_layout = k5_1_Layout;
 
   MockSampleProcessorFactory mock_sample_processor_factory;
   EXPECT_CALL(mock_sample_processor_factory,
               Call(kFirstMixPresentationId, kSubmixIndex, kLayoutIndex,
-                   forwarded_layout, /*num_channels=*/2, _, _, _));
+                   forwarded_layout, /*num_channels=*/6, _, _, _));
   RenderingMixPresentationFinalizer::SampleProcessorFactory
       sample_processor_factory = mock_sample_processor_factory.AsStdFunction();
 
-  Layout unused_output_layout;
-  EXPECT_THAT(ObuProcessor::CreateForRendering(
-                  k5_1_Layout, sample_processor_factory,
-                  /*is_exhaustive_and_exact=*/true, read_bit_buffer.get(),
-                  unused_output_layout, insufficient_data),
-              NotNull());
+  Layout output_layout;
+  EXPECT_THAT(
+      ObuProcessor::CreateForRendering(
+          kIamfV1_0_0ErrataProfiles, k5_1_Layout, sample_processor_factory,
+          /*is_exhaustive_and_exact=*/true, read_bit_buffer.get(),
+          output_layout, insufficient_data),
+      NotNull());
+  // We also expect the output layout to be the same as the desired layout.
+  EXPECT_EQ(output_layout, k5_1_Layout);
 }
 
 TEST(CreateForRendering,
@@ -2943,8 +3031,8 @@ TEST(CreateForRendering,
        &audio_elements_with_data.at(kFirstAudioElementId).obu,
        &mix_presentation_obus.front(),
        &*(std::next(mix_presentation_obus.begin()))});
-  auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      kBufferCapacity, absl::MakeConstSpan(bitstream));
+  auto read_bit_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   bool insufficient_data;
 
   // We expect to use the second layout in the second mix presentation, since
@@ -2964,11 +3052,12 @@ TEST(CreateForRendering,
       sample_processor_factory = mock_sample_processor_factory.AsStdFunction();
 
   Layout output_layout;
-  EXPECT_THAT(ObuProcessor::CreateForRendering(
-                  k5_1_Layout, sample_processor_factory,
-                  /*is_exhaustive_and_exact=*/true, read_bit_buffer.get(),
-                  output_layout, insufficient_data),
-              NotNull());
+  EXPECT_THAT(
+      ObuProcessor::CreateForRendering(
+          kIamfV1_0_0ErrataProfiles, k5_1_Layout, sample_processor_factory,
+          /*is_exhaustive_and_exact=*/true, read_bit_buffer.get(),
+          output_layout, insufficient_data),
+      NotNull());
   EXPECT_EQ(output_layout, k5_1_Layout);
 }
 
@@ -2979,11 +3068,12 @@ TEST(CreateForRendering, NullReadBitBufferRejected) {
   bool insufficient_data;
 
   Layout unused_output_layout;
-  EXPECT_THAT(ObuProcessor::CreateForRendering(
-                  kStereoLayout, sample_processor_factory,
-                  /*is_exhaustive_and_exact=*/true, read_bit_buffer_nullptr,
-                  unused_output_layout, insufficient_data),
-              IsNull());
+  EXPECT_THAT(
+      ObuProcessor::CreateForRendering(
+          kIamfV1_0_0ErrataProfiles, kStereoLayout, sample_processor_factory,
+          /*is_exhaustive_and_exact=*/true, read_bit_buffer_nullptr,
+          unused_output_layout, insufficient_data),
+      IsNull());
   EXPECT_FALSE(insufficient_data);
 }
 
diff --git a/iamf/cli/tests/obu_sequencer_base_test.cc b/iamf/cli/tests/obu_sequencer_base_test.cc
index fd33b8f..1cb2c7f 100644
--- a/iamf/cli/tests/obu_sequencer_base_test.cc
+++ b/iamf/cli/tests/obu_sequencer_base_test.cc
@@ -190,29 +190,43 @@ DemixingParamDefinition CreateDemixingParamDefinition(
   return demixing_param_definition;
 }
 
-void ValidateWriteTemporalUnitSequence(
-    bool include_temporal_delimiters, const TemporalUnitView& temporal_unit,
-    const std::list<const ObuBase*>& expected_sequence) {
-  WriteBitBuffer result_wb(128);
-  int unused_num_samples;
-  EXPECT_THAT(ObuSequencerBase::WriteTemporalUnit(include_temporal_delimiters,
-                                                  temporal_unit, result_wb,
-                                                  unused_num_samples),
-              IsOk());
+void ExpectPushedTemporalUnitMatchesExpectedSequence(
+    const TemporalUnitView& temporal_unit,
+    const std::list<const ObuBase*>& expected_sequence,
+    MockObuSequencer& mock_obu_sequencer) {
+  const std::vector<uint8_t> expected_serialized_temporal_unit =
+      SerializeObusExpectOk(expected_sequence);
+  EXPECT_CALL(mock_obu_sequencer,
+              PushSerializedTemporalUnit(
+                  _, _, MakeConstSpan(expected_serialized_temporal_unit)));
 
-  EXPECT_EQ(result_wb.bit_buffer(), SerializeObusExpectOk(expected_sequence));
+  EXPECT_THAT(mock_obu_sequencer.PushTemporalUnit(temporal_unit), IsOk());
 }
 
-TEST(WriteTemporalUnit, WritesArbitraryObuBeforeParameterBlocksAtTime) {
+TEST(PushTemporalUnit, SerializesArbitraryObuBeforeParameterBlocksAtTime) {
+  const IASequenceHeaderObu kIaSequenceHeader(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
   std::list<ParameterBlockWithData> parameter_blocks;
   std::list<AudioFrameWithData> audio_frames;
   absl::flat_hash_map<uint32_t, CodecConfigObu> codec_config_obus;
   absl::flat_hash_map<uint32_t, AudioElementWithData> audio_elements;
+  const std::list<MixPresentationObu> kNoMixPresentationObus;
+  const std::list<ArbitraryObu> kNoDescriptorArbitraryObus;
   DemixingParamDefinition param_definition =
       CreateDemixingParamDefinition(kFirstDemixingParameterId);
   InitializeOneParameterBlockAndOneAudioFrame(
       param_definition, parameter_blocks, audio_frames, codec_config_obus,
       audio_elements);
+  MockObuSequencer mock_obu_sequencer(
+      *LebGenerator::Create(), kIncludeTemporalDelimiters,
+      kDoNotDelayDescriptorsUntilTrimAtStartIsKnown);
+  EXPECT_THAT(mock_obu_sequencer.PushDescriptorObus(
+                  kIaSequenceHeader, codec_config_obus, audio_elements,
+                  kNoMixPresentationObus, kNoDescriptorArbitraryObus),
+              IsOk());
+
+  // Create a temporal unit with an arbitrary OBU before the parameter blocks.
   const std::list<ArbitraryObu> kArbitraryObuBeforeParameterBlocks(
       {ArbitraryObu(kObuIaReserved25, ObuHeader(), {},
                     ArbitraryObu::kInsertionHookBeforeParameterBlocksAtTick,
@@ -220,29 +234,39 @@ TEST(WriteTemporalUnit, WritesArbitraryObuBeforeParameterBlocksAtTime) {
   const auto temporal_unit = TemporalUnitView::Create(
       parameter_blocks, audio_frames, kArbitraryObuBeforeParameterBlocks);
   ASSERT_THAT(temporal_unit, IsOk());
-
   const TemporalDelimiterObu temporal_delimiter_obu(ObuHeader{});
 
-  const std::list<const ObuBase*>
-      expected_arbitrary_obu_between_temporal_delimiter_and_parameter_block = {
-          &temporal_delimiter_obu, &kArbitraryObuBeforeParameterBlocks.front(),
-          parameter_blocks.front().obu.get(), &audio_frames.front().obu};
-
-  ValidateWriteTemporalUnitSequence(
-      kIncludeTemporalDelimiters, *temporal_unit,
-      expected_arbitrary_obu_between_temporal_delimiter_and_parameter_block);
+  ExpectPushedTemporalUnitMatchesExpectedSequence(
+      *temporal_unit,
+      {&temporal_delimiter_obu, &kArbitraryObuBeforeParameterBlocks.front(),
+       parameter_blocks.front().obu.get(), &audio_frames.front().obu},
+      mock_obu_sequencer);
 }
 
-TEST(WriteTemporalUnit, WritesArbitraryObuAfterParameterBlocksAtTime) {
+TEST(PushTemporalUnit, SerializesArbitraryObuAfterParameterBlocksAtTime) {
+  const IASequenceHeaderObu kIaSequenceHeader(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
   std::list<ParameterBlockWithData> parameter_blocks;
   std::list<AudioFrameWithData> audio_frames;
   absl::flat_hash_map<uint32_t, CodecConfigObu> codec_config_obus;
   absl::flat_hash_map<uint32_t, AudioElementWithData> audio_elements;
+  const std::list<MixPresentationObu> kNoMixPresentationObus;
+  const std::list<ArbitraryObu> kNoDescriptorArbitraryObus;
   DemixingParamDefinition param_definition =
       CreateDemixingParamDefinition(kFirstDemixingParameterId);
   InitializeOneParameterBlockAndOneAudioFrame(
       param_definition, parameter_blocks, audio_frames, codec_config_obus,
       audio_elements);
+  MockObuSequencer mock_obu_sequencer(
+      *LebGenerator::Create(), kDoNotIncludeTemporalDelimiters,
+      kDoNotDelayDescriptorsUntilTrimAtStartIsKnown);
+  EXPECT_THAT(mock_obu_sequencer.PushDescriptorObus(
+                  kIaSequenceHeader, codec_config_obus, audio_elements,
+                  kNoMixPresentationObus, kNoDescriptorArbitraryObus),
+              IsOk());
+
+  // Create a temporal unit with an arbitrary OBU after the parameter blocks.
   const std::list<ArbitraryObu> kArbitraryObuAfterParameterBlocks(
       {ArbitraryObu(kObuIaReserved25, ObuHeader(), {},
                     ArbitraryObu::kInsertionHookAfterParameterBlocksAtTick,
@@ -251,28 +275,37 @@ TEST(WriteTemporalUnit, WritesArbitraryObuAfterParameterBlocksAtTime) {
       parameter_blocks, audio_frames, kArbitraryObuAfterParameterBlocks);
   ASSERT_THAT(temporal_unit, IsOk());
 
-  const std::list<const ObuBase*>
-      expected_arbitrary_obu_between_parameter_block_and_audio_frame = {
-          parameter_blocks.front().obu.get(),
-          &kArbitraryObuAfterParameterBlocks.front(),
-          &audio_frames.front().obu,
-      };
-
-  ValidateWriteTemporalUnitSequence(
-      kDoNotIncludeTemporalDelimiters, *temporal_unit,
-      expected_arbitrary_obu_between_parameter_block_and_audio_frame);
+  ExpectPushedTemporalUnitMatchesExpectedSequence(
+      *temporal_unit,
+      {parameter_blocks.front().obu.get(),
+       &kArbitraryObuAfterParameterBlocks.front(), &audio_frames.front().obu},
+      mock_obu_sequencer);
 }
 
-TEST(WriteTemporalUnit, WritesArbitraryObuAfterAudioFramesAtTime) {
+TEST(PushTemporalUnit, SerializesArbitraryObuAfterAudioFramesAtTime) {
+  const IASequenceHeaderObu kIaSequenceHeader(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
   std::list<ParameterBlockWithData> parameter_blocks;
   std::list<AudioFrameWithData> audio_frames;
   absl::flat_hash_map<uint32_t, CodecConfigObu> codec_config_obus;
   absl::flat_hash_map<uint32_t, AudioElementWithData> audio_elements;
+  const std::list<MixPresentationObu> kNoMixPresentationObus;
+  const std::list<ArbitraryObu> kNoDescriptorArbitraryObus;
   DemixingParamDefinition param_definition =
       CreateDemixingParamDefinition(kFirstDemixingParameterId);
   InitializeOneParameterBlockAndOneAudioFrame(
       param_definition, parameter_blocks, audio_frames, codec_config_obus,
       audio_elements);
+  MockObuSequencer mock_obu_sequencer(
+      *LebGenerator::Create(), kDoNotIncludeTemporalDelimiters,
+      kDoNotDelayDescriptorsUntilTrimAtStartIsKnown);
+  EXPECT_THAT(mock_obu_sequencer.PushDescriptorObus(
+                  kIaSequenceHeader, codec_config_obus, audio_elements,
+                  kNoMixPresentationObus, kNoDescriptorArbitraryObus),
+              IsOk());
+
+  // Create a temporal unit with an arbitrary OBU after the audio frames.
   const std::list<ArbitraryObu> kArbitraryObuAfterAudioFrames({ArbitraryObu(
       kObuIaReserved25, ObuHeader(), {},
       ArbitraryObu::kInsertionHookAfterAudioFramesAtTick, kFirstTimestamp)});
@@ -280,22 +313,32 @@ TEST(WriteTemporalUnit, WritesArbitraryObuAfterAudioFramesAtTime) {
       parameter_blocks, audio_frames, kArbitraryObuAfterAudioFrames);
   ASSERT_THAT(temporal_unit, IsOk());
 
-  const std::list<const ObuBase*> expected_arbitrary_obu_after_audio_frame = {
-      parameter_blocks.front().obu.get(),
-      &audio_frames.front().obu,
-      &kArbitraryObuAfterAudioFrames.front(),
-  };
-
-  ValidateWriteTemporalUnitSequence(kDoNotIncludeTemporalDelimiters,
-                                    *temporal_unit,
-                                    expected_arbitrary_obu_after_audio_frame);
+  ExpectPushedTemporalUnitMatchesExpectedSequence(
+      *temporal_unit,
+      {parameter_blocks.front().obu.get(), &audio_frames.front().obu,
+       &kArbitraryObuAfterAudioFrames.front()},
+      mock_obu_sequencer);
 }
 
-TEST(WriteTemporalUnit, AccumulatesZeroSamplesForFullyTrimmedAudioFrame) {
+TEST(PushTemporalUnit, PassesZeroSamplesForFullyTrimmedAudioFrame) {
+  const IASequenceHeaderObu kIaSequenceHeader(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
   std::list<AudioFrameWithData> audio_frames;
   absl::flat_hash_map<uint32_t, CodecConfigObu> codec_config_obus;
   absl::flat_hash_map<uint32_t, AudioElementWithData> audio_elements;
+  const std::list<MixPresentationObu> kNoMixPresentationObus;
+  const std::list<ArbitraryObu> kNoDescriptorArbitraryObus;
   InitializeOneFrameIaSequence(codec_config_obus, audio_elements, audio_frames);
+  MockObuSequencer mock_obu_sequencer(
+      *LebGenerator::Create(), kDoNotIncludeTemporalDelimiters,
+      kDoNotDelayDescriptorsUntilTrimAtStartIsKnown);
+  EXPECT_THAT(mock_obu_sequencer.PushDescriptorObus(
+                  kIaSequenceHeader, codec_config_obus, audio_elements,
+                  kNoMixPresentationObus, kNoDescriptorArbitraryObus),
+              IsOk());
+
+  // Make a temporal unit with an audio frame that is fully trimmed.
   audio_frames.front().obu.header_.num_samples_to_trim_at_end = 0;
   audio_frames.front().obu.header_.num_samples_to_trim_at_start = 8;
   constexpr uint32_t kNumUntrimmedSamples = 0;
@@ -303,21 +346,30 @@ TEST(WriteTemporalUnit, AccumulatesZeroSamplesForFullyTrimmedAudioFrame) {
       kNoParameterBlocks, audio_frames, kNoArbitraryObus);
   ASSERT_THAT(temporal_unit, IsOk());
 
-  WriteBitBuffer wb(128);
-  int num_samples = 0;
-  EXPECT_THAT(
-      ObuSequencerBase::WriteTemporalUnit(kDoNotIncludeTemporalDelimiters,
-                                          *temporal_unit, wb, num_samples),
-      IsOk());
-
-  EXPECT_EQ(num_samples, kNumUntrimmedSamples);
+  EXPECT_CALL(mock_obu_sequencer,
+              PushSerializedTemporalUnit(_, kNumUntrimmedSamples, _));
+  EXPECT_THAT(mock_obu_sequencer.PushTemporalUnit(*temporal_unit), IsOk());
 }
 
-TEST(WriteTemporalUnit, AddsNumberOfUntrimmedSamplesToNumSamples) {
+TEST(PushTemporalUnit, PAssesNumberOfUntrimmedSamplesToNumSamples) {
+  const IASequenceHeaderObu kIaSequenceHeader(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
   std::list<AudioFrameWithData> audio_frames;
   absl::flat_hash_map<uint32_t, CodecConfigObu> codec_config_obus;
   absl::flat_hash_map<uint32_t, AudioElementWithData> audio_elements;
+  const std::list<MixPresentationObu> kNoMixPresentationObus;
+  const std::list<ArbitraryObu> kNoDescriptorArbitraryObus;
   InitializeOneFrameIaSequence(codec_config_obus, audio_elements, audio_frames);
+  MockObuSequencer mock_obu_sequencer(
+      *LebGenerator::Create(), kDoNotIncludeTemporalDelimiters,
+      kDoNotDelayDescriptorsUntilTrimAtStartIsKnown);
+  EXPECT_THAT(mock_obu_sequencer.PushDescriptorObus(
+                  kIaSequenceHeader, codec_config_obus, audio_elements,
+                  kNoMixPresentationObus, kNoDescriptorArbitraryObus),
+              IsOk());
+
+  // Make a temporal unit with an audio frame that is fully trimmed.
   audio_frames.front().obu.header_.num_samples_to_trim_at_end = 2;
   audio_frames.front().obu.header_.num_samples_to_trim_at_start = 1;
   constexpr uint32_t kNumUntrimmedSamples = kNumSamplesPerFrame - 1 - 2;
@@ -325,67 +377,79 @@ TEST(WriteTemporalUnit, AddsNumberOfUntrimmedSamplesToNumSamples) {
       kNoParameterBlocks, audio_frames, kNoArbitraryObus);
   ASSERT_THAT(temporal_unit, IsOk());
 
-  WriteBitBuffer undefined_wb(128);
-  int num_samples = 0;
-  EXPECT_THAT(ObuSequencerBase::WriteTemporalUnit(
-                  kDoNotIncludeTemporalDelimiters, *temporal_unit, undefined_wb,
-                  num_samples),
-              IsOk());
-  EXPECT_EQ(num_samples, kNumUntrimmedSamples);
-  // Another write keeps adding to the number of samples.
-  EXPECT_THAT(ObuSequencerBase::WriteTemporalUnit(
-                  kDoNotIncludeTemporalDelimiters, *temporal_unit, undefined_wb,
-                  num_samples),
-              IsOk());
-  EXPECT_EQ(num_samples, kNumUntrimmedSamples * 2);
+  EXPECT_CALL(mock_obu_sequencer,
+              PushSerializedTemporalUnit(_, kNumUntrimmedSamples, _));
+  EXPECT_THAT(mock_obu_sequencer.PushTemporalUnit(*temporal_unit), IsOk());
 }
 
 TEST(WriteTemporalUnit, WritesTemporalDelimiterObuWhenEnabled) {
+  const IASequenceHeaderObu kIaSequenceHeader(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
   std::list<ParameterBlockWithData> parameter_blocks;
   std::list<AudioFrameWithData> audio_frames;
   absl::flat_hash_map<uint32_t, CodecConfigObu> codec_config_obus;
   absl::flat_hash_map<uint32_t, AudioElementWithData> audio_elements;
+  const std::list<MixPresentationObu> kNoMixPresentationObus;
+  const std::list<ArbitraryObu> kNoDescriptorArbitraryObus;
   DemixingParamDefinition param_definition =
       CreateDemixingParamDefinition(kFirstDemixingParameterId);
   InitializeOneParameterBlockAndOneAudioFrame(
       param_definition, parameter_blocks, audio_frames, codec_config_obus,
       audio_elements);
+  // Configure with temporal delimiters.
+  MockObuSequencer mock_obu_sequencer(
+      *LebGenerator::Create(), kIncludeTemporalDelimiters,
+      kDoNotDelayDescriptorsUntilTrimAtStartIsKnown);
+  EXPECT_THAT(mock_obu_sequencer.PushDescriptorObus(
+                  kIaSequenceHeader, codec_config_obus, audio_elements,
+                  kNoMixPresentationObus, kNoDescriptorArbitraryObus),
+              IsOk());
+
   const auto temporal_unit = TemporalUnitView::Create(
       parameter_blocks, audio_frames, kNoArbitraryObus);
   ASSERT_THAT(temporal_unit, IsOk());
 
   const TemporalDelimiterObu kTemporalDelimiterObu(ObuHeader{});
-  const std::list<const ObuBase*> expected_sequence = {
-      &kTemporalDelimiterObu,
-      parameter_blocks.front().obu.get(),
-      &audio_frames.front().obu,
-  };
-
-  ValidateWriteTemporalUnitSequence(kIncludeTemporalDelimiters, *temporal_unit,
-                                    expected_sequence);
+  ExpectPushedTemporalUnitMatchesExpectedSequence(
+      *temporal_unit,
+      {&kTemporalDelimiterObu, parameter_blocks.front().obu.get(),
+       &audio_frames.front().obu},
+      mock_obu_sequencer);
 }
 
 TEST(WriteTemporalUnit, OmitsTemporalDelimiterObuWhenDisabled) {
+  const IASequenceHeaderObu kIaSequenceHeader(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
   std::list<ParameterBlockWithData> parameter_blocks;
   std::list<AudioFrameWithData> audio_frames;
   absl::flat_hash_map<uint32_t, CodecConfigObu> codec_config_obus;
   absl::flat_hash_map<uint32_t, AudioElementWithData> audio_elements;
+  const std::list<MixPresentationObu> kNoMixPresentationObus;
+  const std::list<ArbitraryObu> kNoDescriptorArbitraryObus;
   DemixingParamDefinition param_definition =
       CreateDemixingParamDefinition(kFirstDemixingParameterId);
   InitializeOneParameterBlockAndOneAudioFrame(
       param_definition, parameter_blocks, audio_frames, codec_config_obus,
       audio_elements);
+  // Configure without temporal delimiters.
+  MockObuSequencer mock_obu_sequencer(
+      *LebGenerator::Create(), kDoNotIncludeTemporalDelimiters,
+      kDoNotDelayDescriptorsUntilTrimAtStartIsKnown);
+  EXPECT_THAT(mock_obu_sequencer.PushDescriptorObus(
+                  kIaSequenceHeader, codec_config_obus, audio_elements,
+                  kNoMixPresentationObus, kNoDescriptorArbitraryObus),
+              IsOk());
+
   const auto temporal_unit = TemporalUnitView::Create(
       parameter_blocks, audio_frames, kNoArbitraryObus);
   ASSERT_THAT(temporal_unit, IsOk());
 
-  const std::list<const ObuBase*> expected_sequence = {
-      parameter_blocks.front().obu.get(),
-      &audio_frames.front().obu,
-  };
-
-  ValidateWriteTemporalUnitSequence(kDoNotIncludeTemporalDelimiters,
-                                    *temporal_unit, expected_sequence);
+  ExpectPushedTemporalUnitMatchesExpectedSequence(
+      *temporal_unit,
+      {parameter_blocks.front().obu.get(), &audio_frames.front().obu},
+      mock_obu_sequencer);
 }
 
 class ObuSequencerTest : public ::testing::Test {
@@ -425,22 +489,27 @@ class ObuSequencerTest : public ::testing::Test {
         mix_presentation_obus_);
   }
 
-  void ValidateWriteDescriptorObuSequence(
+  void ValidatePushDescriptorObus(
       const std::list<const ObuBase*>& expected_sequence) {
+    MockObuSequencer mock_obu_sequencer(
+        *LebGenerator::Create(), kDoNotIncludeTemporalDelimiters,
+        kDoNotDelayDescriptorsUntilTrimAtStartIsKnown);
+    // Check that the descriptor OBUs are serialized and pushed to the mock in
+    // the expected order.
     WriteBitBuffer expected_wb(128);
     for (const auto* expected_obu : expected_sequence) {
       ASSERT_NE(expected_obu, nullptr);
       EXPECT_THAT(expected_obu->ValidateAndWriteObu(expected_wb), IsOk());
     }
+    EXPECT_CALL(
+        mock_obu_sequencer,
+        PushSerializedDescriptorObus(
+            _, _, _, _, _, absl::MakeConstSpan(expected_wb.bit_buffer())));
 
-    WriteBitBuffer result_wb(128);
-    EXPECT_THAT(ObuSequencerBase::WriteDescriptorObus(
+    EXPECT_THAT(mock_obu_sequencer.PushDescriptorObus(
                     ia_sequence_header_obu_.value(), codec_config_obus_,
-                    audio_elements_, mix_presentation_obus_, arbitrary_obus_,
-                    result_wb),
+                    audio_elements_, mix_presentation_obus_, arbitrary_obus_),
                 IsOk());
-
-    EXPECT_EQ(result_wb.bit_buffer(), expected_wb.bit_buffer());
   }
 
  protected:
@@ -466,7 +535,7 @@ TEST_F(ObuSequencerTest, OrdersByAParticularObuType) {
       &audio_elements_.at(kFirstAudioElementId).obu,
       &mix_presentation_obus_.back()};
 
-  ValidateWriteDescriptorObuSequence(expected_sequence);
+  ValidatePushDescriptorObus(expected_sequence);
 }
 
 TEST_F(ObuSequencerTest, ArbitraryObuAfterIaSequenceHeader) {
@@ -484,7 +553,7 @@ TEST_F(ObuSequencerTest, ArbitraryObuAfterIaSequenceHeader) {
       &mix_presentation_obus_.back(),
   };
 
-  ValidateWriteDescriptorObuSequence(expected_sequence);
+  ValidatePushDescriptorObus(expected_sequence);
 }
 
 TEST_F(ObuSequencerTest, ArbitraryObuAfterCodecConfigs) {
@@ -502,7 +571,7 @@ TEST_F(ObuSequencerTest, ArbitraryObuAfterCodecConfigs) {
       &mix_presentation_obus_.back(),
   };
 
-  ValidateWriteDescriptorObuSequence(expected_sequence);
+  ValidatePushDescriptorObus(expected_sequence);
 }
 
 TEST_F(ObuSequencerTest, ArbitraryObuAfterAudioElements) {
@@ -520,7 +589,7 @@ TEST_F(ObuSequencerTest, ArbitraryObuAfterAudioElements) {
       &mix_presentation_obus_.back(),
   };
 
-  ValidateWriteDescriptorObuSequence(expected_sequence);
+  ValidatePushDescriptorObus(expected_sequence);
 }
 
 TEST_F(ObuSequencerTest, ArbitraryObuAfterMixPresentations) {
@@ -538,12 +607,11 @@ TEST_F(ObuSequencerTest, ArbitraryObuAfterMixPresentations) {
       &arbitrary_obus_.back(),
   };
 
-  ValidateWriteDescriptorObuSequence(expected_sequence);
+  ValidatePushDescriptorObus(expected_sequence);
 }
 
-// This behavior helps ensure that "after descriptors" are not written in the
-// "IACB" box in MP4.
-TEST_F(ObuSequencerTest, DoesNotWriteArbitraryObuAfterDescriptors) {
+TEST_F(ObuSequencerTest,
+       ArbitraryObuAfterDescriptorsIsSerializedWithDescriptors) {
   InitializeDescriptorObus();
 
   arbitrary_obus_.emplace_back(
@@ -551,13 +619,16 @@ TEST_F(ObuSequencerTest, DoesNotWriteArbitraryObuAfterDescriptors) {
                    ArbitraryObu::kInsertionHookAfterDescriptors));
 
   const std::list<const ObuBase*> expected_sequence = {
-      &ia_sequence_header_obu_.value(), &codec_config_obus_.at(kCodecConfigId),
+      &ia_sequence_header_obu_.value(),
+      &codec_config_obus_.at(kCodecConfigId),
       &audio_elements_.at(kFirstAudioElementId).obu,
       &mix_presentation_obus_.back(),
-      // &arbitrary_obus_.back(),
+      // Placed after the canonical descriptors, and part of the "IACB" box in
+      // an MP4 context.
+      &arbitrary_obus_.back(),
   };
 
-  ValidateWriteDescriptorObuSequence(expected_sequence);
+  ValidatePushDescriptorObus(expected_sequence);
 }
 
 TEST_F(ObuSequencerTest, CodecConfigAreAscendingOrderByDefault) {
@@ -578,7 +649,7 @@ TEST_F(ObuSequencerTest, CodecConfigAreAscendingOrderByDefault) {
       &audio_elements_.at(kFirstAudioElementId).obu,
       &mix_presentation_obus_.back()};
 
-  ValidateWriteDescriptorObuSequence(expected_sequence);
+  ValidatePushDescriptorObus(expected_sequence);
 }
 
 TEST_F(ObuSequencerTest, AudioElementAreAscendingOrderByDefault) {
@@ -600,7 +671,7 @@ TEST_F(ObuSequencerTest, AudioElementAreAscendingOrderByDefault) {
       &audio_elements_.at(kSecondAudioElementId).obu,
       &mix_presentation_obus_.back()};
 
-  ValidateWriteDescriptorObuSequence(expected_sequence);
+  ValidatePushDescriptorObus(expected_sequence);
 }
 
 TEST_F(ObuSequencerTest, MixPresentationsMaintainOriginalOrder) {
@@ -634,11 +705,11 @@ TEST_F(ObuSequencerTest, MixPresentationsMaintainOriginalOrder) {
       mix_presentation_obus_);
   expected_sequence.push_back(&mix_presentation_obus_.back());
 
-  ValidateWriteDescriptorObuSequence(expected_sequence);
+  ValidatePushDescriptorObus(expected_sequence);
 }
 
 TEST(WriteDescriptorObus,
-     InvalidWhenMixPresentationDoesNotComplyWithIaSequenceHeader) {
+     InvalidWhenMixPresentationDoesNotAgreeWithIaSequenceHeader) {
   IASequenceHeaderObu ia_sequence_header_obu(
       ObuHeader(), IASequenceHeaderObu::kIaCode,
       ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfSimpleProfile);
@@ -647,16 +718,17 @@ TEST(WriteDescriptorObus,
   std::list<MixPresentationObu> mix_presentation_obus;
   InitializeDescriptorObusForTwoMonoAmbisonicsAudioElement(
       codec_config_obus, audio_elements, mix_presentation_obus);
+  MockObuSequencer mock_obu_sequencer(
+      *LebGenerator::Create(), kDoNotIncludeTemporalDelimiters,
+      kDoNotDelayDescriptorsUntilTrimAtStartIsKnown);
 
-  WriteBitBuffer unused_wb(0);
-  EXPECT_FALSE(ObuSequencerBase::WriteDescriptorObus(
-                   ia_sequence_header_obu, codec_config_obus, audio_elements,
-                   mix_presentation_obus, /*arbitrary_obus=*/{}, unused_wb)
-                   .ok());
+  EXPECT_THAT(mock_obu_sequencer.PushDescriptorObus(
+                  ia_sequence_header_obu, codec_config_obus, audio_elements,
+                  mix_presentation_obus, /*arbitrary_obus=*/{}),
+              Not(IsOk()));
 }
 
-TEST(WriteDescriptorObus,
-     ValidWhenMixPresentationCompliesWithIaSequenceHeader) {
+TEST(WriteDescriptorObus, ValidWhenMixPresentationAgreesWithIaSequenceHeader) {
   IASequenceHeaderObu ia_sequence_header_obu(
       ObuHeader(), IASequenceHeaderObu::kIaCode,
       ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
@@ -665,11 +737,13 @@ TEST(WriteDescriptorObus,
   std::list<MixPresentationObu> mix_presentation_obus;
   InitializeDescriptorObusForTwoMonoAmbisonicsAudioElement(
       codec_config_obus, audio_elements, mix_presentation_obus);
+  MockObuSequencer mock_obu_sequencer(
+      *LebGenerator::Create(), kDoNotIncludeTemporalDelimiters,
+      kDoNotDelayDescriptorsUntilTrimAtStartIsKnown);
 
-  WriteBitBuffer unused_wb(0);
-  EXPECT_THAT(ObuSequencerBase::WriteDescriptorObus(
+  EXPECT_THAT(mock_obu_sequencer.PushDescriptorObus(
                   ia_sequence_header_obu, codec_config_obus, audio_elements,
-                  mix_presentation_obus, /*arbitrary_obus=*/{}, unused_wb),
+                  mix_presentation_obus, /*arbitrary_obus=*/{}),
               IsOk());
 }
 
@@ -782,7 +856,7 @@ TEST(PushDescriptorObus, ForwardsPropertiesToPushSerializedDescriptorObus) {
       codec_config_obu.GetOutputSampleRate();
   const uint8_t kExpectedCommonBitDepth =
       codec_config_obu.GetBitDepthToMeasureLoudness();
-  const std::optional<int64_t> kOmitFirstPts = std::nullopt;
+  const std::optional<InternalTimestamp> kOmitFirstPts = std::nullopt;
   const int kExpectedNumChannels = 2;
   const std::vector<uint8_t> descriptor_obus = {1, 2, 3};
   EXPECT_CALL(
@@ -821,7 +895,7 @@ TEST(PickAndPlace, ForwardsPropertiesToPushSerializedDescriptorObus) {
       codec_config_obu.GetOutputSampleRate();
   const uint8_t kExpectedCommonBitDepth =
       codec_config_obu.GetBitDepthToMeasureLoudness();
-  const std::optional<int64_t> kOmitFirstPts = std::nullopt;
+  const std::optional<InternalTimestamp> kOmitFirstPts = std::nullopt;
   const int kExpectedNumChannels = 2;
   const std::vector<uint8_t> descriptor_obus = {1, 2, 3};
   EXPECT_CALL(
@@ -858,7 +932,8 @@ TEST(PushDescriptorObus,
   const uint32_t kExpectedCommonSamplesPerFrame = 1024;
   const uint32_t kExpectedCommonSampleRate = 48000;
   const uint8_t kExpectedCommonBitDepth = 16;
-  const std::optional<int64_t> kFirstUntrimmedTimestamp = std::nullopt;
+  const std::optional<InternalTimestamp> kFirstUntrimmedTimestamp =
+      std::nullopt;
   const int kExpectedNumChannels = 2;
   EXPECT_CALL(mock_obu_sequencer,
               PushSerializedDescriptorObus(
@@ -899,7 +974,7 @@ TEST(
   const uint32_t kExpectedCommonSamplesPerFrame = 1024;
   const uint32_t kExpectedCommonSampleRate = 48000;
   const uint8_t kExpectedCommonBitDepth = 16;
-  const std::optional<int64_t> kFirstUntrimmedTimestamp = 0;
+  const std::optional<InternalTimestamp> kFirstUntrimmedTimestamp = 0;
   const int kExpectedNumChannels = 2;
   EXPECT_CALL(mock_obu_sequencer,
               PushSerializedDescriptorObus(
@@ -931,7 +1006,7 @@ TEST(PickAndPlace, ForwardsDefaultPropertiesForTrivialIaSequences) {
   const uint32_t kExpectedCommonSamplesPerFrame = 1024;
   const uint32_t kExpectedCommonSampleRate = 48000;
   const uint8_t kExpectedCommonBitDepth = 16;
-  const std::optional<int64_t> kFirstUntrimmedTimestamp = 0;
+  const std::optional<InternalTimestamp> kFirstUntrimmedTimestamp = 0;
   const int kExpectedNumChannels = 2;
   EXPECT_CALL(mock_obu_sequencer,
               PushSerializedDescriptorObus(
@@ -1193,7 +1268,8 @@ TEST(PushTemporalUnit,
       kNoParameterBlocks, second_audio_frame, kNoArbitraryObus);
   ASSERT_THAT(second_temporal_unit, IsOk());
   // The first frame is fully trimmed. The second frame is partially trimmed.
-  constexpr std::optional<int64_t> kExpectedFirstUntrimmedTimestamp = 11;
+  constexpr std::optional<InternalTimestamp> kExpectedFirstUntrimmedTimestamp =
+      11;
   MockObuSequencer mock_obu_sequencer(*LebGenerator::Create(),
                                       kDoNotIncludeTemporalDelimiters,
                                       kDelayDescriptorsUntilTrimAtStartIsKnown);
@@ -1234,7 +1310,8 @@ TEST(PickAndPlace,
       kThirdTimestamp, audio_elements, audio_frames);
   audio_frames.back().obu.header_.num_samples_to_trim_at_start = 3;
   // The first frame is fully trimmed. The second frame is partially trimmed.
-  constexpr std::optional<int64_t> kExpectedFirstUntrimmedTimestamp = 11;
+  constexpr std::optional<InternalTimestamp> kExpectedFirstUntrimmedTimestamp =
+      11;
   MockObuSequencer mock_obu_sequencer(*LebGenerator::Create(),
                                       kDoNotIncludeTemporalDelimiters,
                                       kDelayDescriptorsUntilTrimAtStartIsKnown);
@@ -1938,6 +2015,34 @@ TEST(UpdateDescriptorObusAndClose, FailsWhenSerializedSizeChanges) {
               Not(IsOk()));
 }
 
+TEST(UpdateDescriptorObusAndClose,
+     OmitsCallToPushFinalizedDescriptorObusWhenDescriptorsAreUnchanged) {
+  const IASequenceHeaderObu kOriginalIaSequenceHeader(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
+  const absl::flat_hash_map<DecodedUleb128, CodecConfigObu> kNoCodecConfigObus;
+  const absl::flat_hash_map<uint32_t, AudioElementWithData> kNoAudioElements;
+  const std::list<MixPresentationObu> kNoMixPresentationObus;
+  const std::list<ArbitraryObu> kNoArbitraryObus;
+  MockObuSequencer mock_obu_sequencer(
+      *LebGenerator::Create(), kDoNotIncludeTemporalDelimiters,
+      kDoNotDelayDescriptorsUntilTrimAtStartIsKnown);
+  EXPECT_THAT(mock_obu_sequencer.PushDescriptorObus(
+                  kOriginalIaSequenceHeader, kNoCodecConfigObus,
+                  kNoAudioElements, kNoMixPresentationObus, kNoArbitraryObus),
+              IsOk());
+
+  // It's OK to call with identical descriptor OBUs, but we expect the sequencer
+  // to safely close without needing to update the finalized descriptor OBUs.
+  EXPECT_CALL(mock_obu_sequencer, PushFinalizedDescriptorObus(_)).Times(0);
+  EXPECT_CALL(mock_obu_sequencer, CloseDerived()).Times(1);
+
+  EXPECT_THAT(mock_obu_sequencer.UpdateDescriptorObusAndClose(
+                  kOriginalIaSequenceHeader, kNoCodecConfigObus,
+                  kNoAudioElements, kNoMixPresentationObus, kNoArbitraryObus),
+              IsOk());
+}
+
 TEST(UpdateDescriptorObusAndClose, FailsWhenCodecConfigPropertiesChange) {
   const IASequenceHeaderObu kIaSequenceHeader(
       ObuHeader(), IASequenceHeaderObu::kIaCode,
diff --git a/iamf/cli/tests/obu_sequencer_streaming_iamf_test.cc b/iamf/cli/tests/obu_sequencer_streaming_iamf_test.cc
new file mode 100644
index 0000000..43d092d
--- /dev/null
+++ b/iamf/cli/tests/obu_sequencer_streaming_iamf_test.cc
@@ -0,0 +1,250 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear
+ * License and the Alliance for Open Media Patent License 1.0. If the BSD
+ * 3-Clause Clear License was not distributed with this source code in the
+ * LICENSE file, you can obtain it at
+ * www.aomedia.org/license/software-license/bsd-3-c-c. If the Alliance for
+ * Open Media Patent License 1.0 was not distributed with this source code
+ * in the PATENTS file, you can obtain it at www.aomedia.org/license/patent.
+ */
+#include "iamf/cli/obu_sequencer_streaming_iamf.h"
+
+#include <array>
+#include <cstdint>
+#include <list>
+#include <memory>
+#include <optional>
+#include <vector>
+
+#include "absl/container/flat_hash_map.h"
+#include "absl/status/status_matchers.h"
+#include "absl/types/span.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+#include "iamf/cli/audio_element_with_data.h"
+#include "iamf/cli/audio_frame_with_data.h"
+#include "iamf/cli/parameter_block_with_data.h"
+#include "iamf/cli/temporal_unit_view.h"
+#include "iamf/cli/tests/cli_test_utils.h"
+#include "iamf/common/leb_generator.h"
+#include "iamf/obu/arbitrary_obu.h"
+#include "iamf/obu/audio_frame.h"
+#include "iamf/obu/codec_config.h"
+#include "iamf/obu/ia_sequence_header.h"
+#include "iamf/obu/obu_base.h"
+#include "iamf/obu/obu_header.h"
+#include "iamf/obu/types.h"
+
+namespace iamf_tools {
+namespace {
+
+using ::absl_testing::IsOk;
+
+using ::testing::IsEmpty;
+
+using absl::MakeConstSpan;
+
+constexpr DecodedUleb128 kCodecConfigId = 1;
+constexpr uint32_t kEightSamplesPerFrame = 8;
+constexpr uint8_t kBitDepth = 16;
+constexpr uint32_t kSampleRate = 48000;
+constexpr InternalTimestamp kStartTimestamp = 0;
+constexpr InternalTimestamp kEndTimestamp = 8;
+constexpr DecodedUleb128 kFirstAudioElementId = 1;
+constexpr DecodedUleb128 kFirstSubstreamId = 1;
+
+constexpr bool kDoNotIncludeTemporalDelimiters = false;
+
+constexpr std::nullopt_t kOriginalSamplesAreIrrelevant = std::nullopt;
+
+constexpr std::array<uint8_t, 16> kEightSampleAudioFrame{
+    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
+
+constexpr absl::Span<ParameterBlockWithData> kNoParameterBlocks = {};
+constexpr absl::Span<ArbitraryObu> kNoArbitraryObus = {};
+
+void AddOneFrame(
+    uint32_t audio_element_id, uint32_t substream_id,
+    InternalTimestamp start_timestamp, InternalTimestamp end_timestamp,
+    const absl::flat_hash_map<uint32_t, AudioElementWithData>& audio_elements,
+    std::list<AudioFrameWithData>& audio_frames) {
+  ASSERT_TRUE(audio_elements.contains(audio_element_id));
+
+  audio_frames.push_back(
+      {.obu = AudioFrameObu(ObuHeader(), substream_id,
+                            MakeConstSpan(kEightSampleAudioFrame)),
+       .start_timestamp = start_timestamp,
+       .end_timestamp = end_timestamp,
+       .pcm_samples = kOriginalSamplesAreIrrelevant,
+       .down_mixing_params = {.in_bitstream = false},
+       .audio_element_with_data = &audio_elements.at(audio_element_id)});
+}
+
+TEST(GetSerializedDescriptorObus, IsEmptyBeforePushDescriptorObus) {
+  ObuSequencerStreamingIamf sequencer(kDoNotIncludeTemporalDelimiters,
+                                      *LebGenerator::Create());
+
+  EXPECT_TRUE(sequencer.GetSerializedDescriptorObus().empty());
+}
+
+TEST(GetPreviousSerializedTemporalUnit, IsEmptyBeforeFirstPushTemporalUnit) {
+  ObuSequencerStreamingIamf sequencer(kDoNotIncludeTemporalDelimiters,
+                                      *LebGenerator::Create());
+
+  EXPECT_TRUE(sequencer.GetPreviousSerializedTemporalUnit().empty());
+}
+
+TEST(GetPreviousSerializedTemporalUnit, IsEmptyAfterClose) {
+  ObuSequencerStreamingIamf sequencer(kDoNotIncludeTemporalDelimiters,
+                                      *LebGenerator::Create());
+  EXPECT_THAT(sequencer.Close(), IsOk());
+
+  EXPECT_TRUE(sequencer.GetPreviousSerializedTemporalUnit().empty());
+}
+
+TEST(GetSerializedDescriptorObus, ReturnsSerializedPushedDescriptorObus) {
+  const IASequenceHeaderObu ia_sequence_header_obu(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
+  ObuSequencerStreamingIamf sequencer(kDoNotIncludeTemporalDelimiters,
+                                      *LebGenerator::Create());
+  EXPECT_THAT(sequencer.PushDescriptorObus(
+                  ia_sequence_header_obu, /*codec_config_obus=*/{},
+                  /*audio_elements=*/{}, /*mix_presentation_obus=*/{},
+                  /*arbitrary_obus=*/{}),
+              IsOk());
+
+  const std::vector<uint8_t> expected_serialized_descriptor_obus =
+      SerializeObusExpectOk(
+          std::list<const ObuBase*>({&ia_sequence_header_obu}));
+  EXPECT_EQ(sequencer.GetSerializedDescriptorObus(),
+            expected_serialized_descriptor_obus);
+}
+
+TEST(GetSerializedDescriptorObus, ReturnsSerializedUpdatedDescriptorObus) {
+  const IASequenceHeaderObu ia_sequence_header_obu(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
+  ObuSequencerStreamingIamf sequencer(kDoNotIncludeTemporalDelimiters,
+                                      *LebGenerator::Create());
+  EXPECT_THAT(sequencer.PushDescriptorObus(
+                  ia_sequence_header_obu, /*codec_config_obus=*/{},
+                  /*audio_elements=*/{}, /*mix_presentation_obus=*/{},
+                  /*arbitrary_obus=*/{}),
+              IsOk());
+
+  // Push a new descriptor OBU.
+  const IASequenceHeaderObu updated_ia_sequence_header_obu(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfBaseProfile, ProfileVersion::kIamfBaseProfile);
+  const std::vector<uint8_t> expected_serialized_descriptor_obus =
+      SerializeObusExpectOk(
+          std::list<const ObuBase*>({&updated_ia_sequence_header_obu}));
+  EXPECT_THAT(sequencer.UpdateDescriptorObusAndClose(
+                  updated_ia_sequence_header_obu, /*codec_config_obus=*/{},
+                  /*audio_elements=*/{}, /*mix_presentation_obus=*/{},
+                  /*arbitrary_obus=*/{}),
+              IsOk());
+
+  EXPECT_EQ(sequencer.GetSerializedDescriptorObus(),
+            expected_serialized_descriptor_obus);
+}
+
+TEST(GetPreviousSerializedTemporalUnit, GetsPreviousSerializedTemporalUnit) {
+  IASequenceHeaderObu ia_sequence_header_obu(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
+  absl::flat_hash_map<DecodedUleb128, CodecConfigObu> codec_config_obus;
+  absl::flat_hash_map<DecodedUleb128, AudioElementWithData> audio_elements;
+  AddLpcmCodecConfig(kCodecConfigId, kEightSamplesPerFrame, kBitDepth,
+                     kSampleRate, codec_config_obus);
+  AddAmbisonicsMonoAudioElementWithSubstreamIds(
+      kFirstAudioElementId, kCodecConfigId, {kFirstSubstreamId},
+      codec_config_obus, audio_elements);
+  ObuSequencerStreamingIamf sequencer(kDoNotIncludeTemporalDelimiters,
+                                      *LebGenerator::Create());
+  EXPECT_THAT(
+      sequencer.PushDescriptorObus(ia_sequence_header_obu, codec_config_obus,
+                                   audio_elements, /*mix_presentation_obus=*/{},
+                                   /*arbitrary_obus=*/{}),
+      IsOk());
+  std::list<AudioFrameWithData> audio_frames;
+  AddOneFrame(kFirstAudioElementId, kFirstSubstreamId, kStartTimestamp,
+              kEndTimestamp, audio_elements, audio_frames);
+  const auto temporal_unit = TemporalUnitView::Create(
+      kNoParameterBlocks, audio_frames, kNoArbitraryObus);
+  ASSERT_THAT(temporal_unit, IsOk());
+  EXPECT_THAT(sequencer.PushTemporalUnit(*temporal_unit), IsOk());
+  const std::vector<uint8_t> expected_serialized_temporal_unit =
+      SerializeObusExpectOk(
+          std::list<const ObuBase*>({&audio_frames.front().obu}));
+
+  EXPECT_EQ(sequencer.GetPreviousSerializedTemporalUnit(),
+            expected_serialized_temporal_unit);
+}
+
+TEST(Close, ClearsSerializedTemporalUnitObus) {
+  IASequenceHeaderObu ia_sequence_header_obu(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
+  absl::flat_hash_map<DecodedUleb128, CodecConfigObu> codec_config_obus;
+  absl::flat_hash_map<DecodedUleb128, AudioElementWithData> audio_elements;
+  AddLpcmCodecConfig(kCodecConfigId, kEightSamplesPerFrame, kBitDepth,
+                     kSampleRate, codec_config_obus);
+  AddAmbisonicsMonoAudioElementWithSubstreamIds(
+      kFirstAudioElementId, kCodecConfigId, {kFirstSubstreamId},
+      codec_config_obus, audio_elements);
+  ObuSequencerStreamingIamf sequencer(kDoNotIncludeTemporalDelimiters,
+                                      *LebGenerator::Create());
+  EXPECT_THAT(
+      sequencer.PushDescriptorObus(ia_sequence_header_obu, codec_config_obus,
+                                   audio_elements, /*mix_presentation_obus=*/{},
+                                   /*arbitrary_obus=*/{}),
+      IsOk());
+  std::list<AudioFrameWithData> audio_frames;
+  AddOneFrame(kFirstAudioElementId, kFirstSubstreamId, kStartTimestamp,
+              kEndTimestamp, audio_elements, audio_frames);
+  const auto temporal_unit = TemporalUnitView::Create(
+      kNoParameterBlocks, audio_frames, kNoArbitraryObus);
+  ASSERT_THAT(temporal_unit, IsOk());
+  EXPECT_THAT(sequencer.PushTemporalUnit(*temporal_unit), IsOk());
+
+  EXPECT_THAT(sequencer.Close(), IsOk());
+
+  EXPECT_THAT(sequencer.GetPreviousSerializedTemporalUnit(), IsEmpty());
+}
+
+TEST(Abort, ClearsSerializedDescriptorAndTemporalUnitObus) {
+  IASequenceHeaderObu ia_sequence_header_obu(
+      ObuHeader(), IASequenceHeaderObu::kIaCode,
+      ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile);
+  absl::flat_hash_map<DecodedUleb128, CodecConfigObu> codec_config_obus;
+  absl::flat_hash_map<DecodedUleb128, AudioElementWithData> audio_elements;
+  AddLpcmCodecConfig(kCodecConfigId, kEightSamplesPerFrame, kBitDepth,
+                     kSampleRate, codec_config_obus);
+  AddAmbisonicsMonoAudioElementWithSubstreamIds(
+      kFirstAudioElementId, kCodecConfigId, {kFirstSubstreamId},
+      codec_config_obus, audio_elements);
+  ObuSequencerStreamingIamf sequencer(kDoNotIncludeTemporalDelimiters,
+                                      *LebGenerator::Create());
+  EXPECT_THAT(sequencer.PushDescriptorObus(
+                  ia_sequence_header_obu, /*codec_config_obus=*/{},
+                  /*audio_elements=*/{}, /*mix_presentation_obus=*/{},
+                  /*arbitrary_obus=*/{}),
+              IsOk());
+  std::list<AudioFrameWithData> audio_frames;
+  AddOneFrame(kFirstAudioElementId, kFirstSubstreamId, kStartTimestamp,
+              kEndTimestamp, audio_elements, audio_frames);
+  const auto temporal_unit = TemporalUnitView::Create(
+      kNoParameterBlocks, audio_frames, kNoArbitraryObus);
+  ASSERT_THAT(temporal_unit, IsOk());
+  EXPECT_THAT(sequencer.PushTemporalUnit(*temporal_unit), IsOk());
+  sequencer.Abort();
+
+  EXPECT_THAT(sequencer.GetSerializedDescriptorObus(), IsEmpty());
+  EXPECT_THAT(sequencer.GetPreviousSerializedTemporalUnit(), IsEmpty());
+}
+}  // namespace
+}  // namespace iamf_tools
diff --git a/iamf/cli/tests/obu_with_data_generator_test.cc b/iamf/cli/tests/obu_with_data_generator_test.cc
index ea61519..cbbfda4 100644
--- a/iamf/cli/tests/obu_with_data_generator_test.cc
+++ b/iamf/cli/tests/obu_with_data_generator_test.cc
@@ -81,9 +81,9 @@ const ScalableChannelLayoutConfig kOneLayerStereoConfig{
          .substream_count = 1,
          .coupled_substream_count = 1}}};
 
-constexpr int32_t kStartTimestamp = 0;
-constexpr int32_t kEndTimestamp = 8;
-constexpr int32_t kDuration = 8;
+constexpr InternalTimestamp kStartTimestamp = 0;
+constexpr InternalTimestamp kEndTimestamp = 8;
+constexpr InternalTimestamp kDuration = 8;
 
 TEST(GenerateAudioElementWithData, ValidAudioElementWithCodecConfig) {
   absl::flat_hash_map<DecodedUleb128, AudioElementObu> audio_element_obus;
@@ -322,7 +322,7 @@ class GenerateAudioFrameWithDataTest : public testing::Test {
 
     // Call `GenerateParameterBlockWithData()` iteratively with one OBU at a
     // time.
-    absl::flat_hash_map<DecodedUleb128, int32_t>
+    absl::flat_hash_map<DecodedUleb128, InternalTimestamp>
         parameter_id_to_last_end_timestamp;
     absl::flat_hash_map<DecodedUleb128, int> parameter_blocks_count;
     for (auto& parameter_block_obu : parameter_block_obus) {
@@ -359,7 +359,7 @@ class GenerateAudioFrameWithDataTest : public testing::Test {
   // the parameters manager.
   void AddCurrentParameterBlocksToParametersManager(
       std::list<ParameterBlockWithData>::iterator& parameter_block_iter) {
-    std::optional<int32_t> global_timestamp = std::nullopt;
+    std::optional<InternalTimestamp> global_timestamp = std::nullopt;
     ASSERT_THAT(
         global_timing_module_->GetGlobalAudioFrameTimestamp(global_timestamp),
         IsOk());
@@ -386,7 +386,7 @@ class GenerateAudioFrameWithDataTest : public testing::Test {
   }
 
   void UpdateParameterStatesIfNeeded() {
-    std::optional<int32_t> global_timestamp = std::nullopt;
+    std::optional<InternalTimestamp> global_timestamp = std::nullopt;
     EXPECT_THAT(
         global_timing_module_->GetGlobalAudioFrameTimestamp(global_timestamp),
         IsOk());
@@ -404,7 +404,8 @@ class GenerateAudioFrameWithDataTest : public testing::Test {
   void ValidateAudioFrameWithData(
       const AudioFrameWithData& audio_frame_with_data,
       const AudioFrameObu& expected_audio_frame_obu,
-      int32_t expected_start_timestamp, int32_t expected_end_timestamp,
+      InternalTimestamp expected_start_timestamp,
+      InternalTimestamp expected_end_timestamp,
       DecodedUleb128 audio_element_id) {
     EXPECT_EQ(audio_frame_with_data.obu, expected_audio_frame_obu);
     EXPECT_EQ(audio_frame_with_data.start_timestamp, expected_start_timestamp);
@@ -572,8 +573,8 @@ TEST_F(GenerateAudioFrameWithDataTest,
 
   // Expectations.
   EXPECT_EQ(audio_frames_with_data.size(), 2);
-  int32_t expected_start_timestamp = kStartTimestamp;
-  int32_t expected_end_timestamp = kEndTimestamp;
+  InternalTimestamp expected_start_timestamp = kStartTimestamp;
+  InternalTimestamp expected_end_timestamp = kEndTimestamp;
   const std::vector<AlphaBetaGammaDelta> expected_alpha_beta_gamma_delta{
       AlphaBetaGammaDelta{0.707, 0.707, 0.707, 0.707},  // `kDMixPMode2`.
       AlphaBetaGammaDelta{1.0, 0.866, 0.866, 0.866}     // `kDMixPMode3`.
@@ -643,10 +644,10 @@ TEST_F(GenerateAudioFrameWithDataTest,
 
   // Expected timestamps for successive temporal units. Same for both
   // substreams.
-  const std::vector<int32_t> expected_start_timestamps = {kStartTimestamp,
-                                                          kStartTimestamp + 8};
-  const std::vector<int32_t> expected_end_timestamps = {kEndTimestamp,
-                                                        kEndTimestamp + 8};
+  const std::vector<InternalTimestamp> expected_start_timestamps = {
+      kStartTimestamp, kStartTimestamp + 8};
+  const std::vector<InternalTimestamp> expected_end_timestamps = {
+      kEndTimestamp, kEndTimestamp + 8};
 
   // Expected {alpha, beta, gamma, delta} for successive temporal units. Same
   // for both substreams.
@@ -704,8 +705,8 @@ TEST_F(GenerateAudioFrameWithDataTest,
 
   // Expectations.
   EXPECT_EQ(audio_frames_with_data.size(), 2);
-  int32_t expected_start_timestamp = kStartTimestamp;
-  int32_t expected_end_timestamp = kEndTimestamp;
+  InternalTimestamp expected_start_timestamp = kStartTimestamp;
+  InternalTimestamp expected_end_timestamp = kEndTimestamp;
   const std::vector<std::array<uint8_t, 12>> expected_recon_gain_values = {
       kFirstReconGainValues, kSecondReconGainValues};
   int frame_index = 0;
@@ -761,8 +762,8 @@ TEST_F(GenerateAudioFrameWithDataTest,
 
   // Expectations.
   EXPECT_EQ(audio_frames_with_data.size(), 2);
-  int32_t expected_start_timestamp = kStartTimestamp;
-  int32_t expected_end_timestamp = kEndTimestamp;
+  InternalTimestamp expected_start_timestamp = kStartTimestamp;
+  InternalTimestamp expected_end_timestamp = kEndTimestamp;
   const std::vector<std::array<uint8_t, 12>> expected_recon_gain_values = {
       kFirstReconGainValues, kSecondReconGainValues};
   const std::vector<AlphaBetaGammaDelta> expected_alpha_beta_gamma_delta = {
diff --git a/iamf/cli/tests/parameter_block_partitioner_test.cc b/iamf/cli/tests/parameter_block_partitioner_test.cc
index dff790f..4bb5392 100644
--- a/iamf/cli/tests/parameter_block_partitioner_test.cc
+++ b/iamf/cli/tests/parameter_block_partitioner_test.cc
@@ -21,6 +21,7 @@
 #include "gtest/gtest.h"
 #include "iamf/cli/proto/parameter_block.pb.h"
 #include "iamf/cli/proto/parameter_data.pb.h"
+#include "iamf/obu/types.h"
 #include "src/google/protobuf/text_format.h"
 
 namespace iamf_tools {
@@ -123,8 +124,8 @@ absl::Status CreateMinimalParameterBlockObuMetadata(
 struct PartitionParameterBlocksTestCase {
   std::vector<uint32_t> input_subblock_durations;
   std::vector<MixGainParameterData> input_mix_gains;
-  int32_t partition_start;
-  int32_t partition_end;
+  InternalTimestamp partition_start;
+  InternalTimestamp partition_end;
   std::vector<uint32_t> expected_partition_durations;
   std::vector<MixGainParameterData> expected_output_mix_gains;
   uint32_t constant_subblock_duration;
@@ -418,9 +419,9 @@ TEST(PartitionParameterBlock, InvalidWhenSubblockBoundaryIsCrossedForDemixing) {
 
 TEST(PartitionParameterBlock,
      IsEquivalentWhenSubblockBoundaryIsNotCrossedForReconGain) {
-  const int32_t kStartDuration = 0;
-  const int32_t kEndDuration = 4000;
-  const int32_t kExpectedDuration = kEndDuration - kStartDuration;
+  const InternalTimestamp kStartDuration = 0;
+  const InternalTimestamp kEndDuration = 4000;
+  const InternalTimestamp kExpectedDuration = kEndDuration - kStartDuration;
   ParameterBlockObuMetadata full_parameter_block;
   google::protobuf::TextFormat::ParseFromString(
       R"pb(
diff --git a/iamf/cli/tests/rendering_mix_presentation_finalizer_test.cc b/iamf/cli/tests/rendering_mix_presentation_finalizer_test.cc
index f365dc4..9067307 100644
--- a/iamf/cli/tests/rendering_mix_presentation_finalizer_test.cc
+++ b/iamf/cli/tests/rendering_mix_presentation_finalizer_test.cc
@@ -68,8 +68,8 @@ using enum ChannelLabel::Label;
 
 using absl::StatusCode::kFailedPrecondition;
 
-constexpr int64_t kStartTime = 0;
-constexpr int32_t kEndTime = 10;
+constexpr InternalTimestamp kStartTime = 0;
+constexpr InternalTimestamp kEndTime = 10;
 constexpr bool kValidateLoudness = true;
 constexpr bool kDontValidateLoudness = false;
 const std::optional<uint8_t> kNoOverrideBitDepth = std::nullopt;
@@ -109,7 +109,7 @@ class MockRenderer : public AudioElementRendererBase {
 
   MOCK_METHOD(
       absl::Status, RenderSamples,
-      (absl::Span<const std::vector<InternalSampleType>> samples_to_render,
+      (absl::Span<const absl::Span<const InternalSampleType>> samples_to_render,
        std::vector<InternalSampleType>& rendered_samples),
       (override));
 };
@@ -205,7 +205,7 @@ class FinalizerTest : public ::testing::Test {
 
   void AddLabeledFrame(DecodedUleb128 audio_element_id,
                        const LabelSamplesMap& label_to_samples,
-                       int32_t end_timestamp,
+                       InternalTimestamp end_timestamp,
                        uint32_t samples_to_trim_at_end = 0,
                        uint32_t samples_to_trim_at_start = 0) {
     IdLabeledFrameMap id_to_labeled_frame;
@@ -259,7 +259,7 @@ class FinalizerTest : public ::testing::Test {
   void IterativeRenderingExpectOk(
       RenderingMixPresentationFinalizer& finalizer,
       const std::list<ParameterBlockWithData>& parameter_blocks) {
-    int64_t start_timestamp = 0;
+    InternalTimestamp start_timestamp = 0;
     for (const auto& id_to_labeled_frame : ordered_labeled_frames_) {
       ASSERT_TRUE(id_to_labeled_frame.contains(kAudioElementId));
       EXPECT_THAT(finalizer.PushTemporalUnit(
@@ -429,10 +429,10 @@ TEST_F(FinalizerTest, ForwardsOrderedSamplesToRenderer) {
   auto mock_renderer = std::make_unique<MockRenderer>(kStereoLabels, 2);
   std::vector<InternalSampleType> rendered_samples;
   const std::vector<std::vector<InternalSampleType>>
-      kExpectedTimeChannelOrderedSamples = {{0, 2}, {1, 3}};
+      kExpectedChannelTimeOrderedSamples = {{0, 1}, {2, 3}};
   EXPECT_CALL(*mock_renderer,
               RenderSamples(
-                  absl::MakeConstSpan(kExpectedTimeChannelOrderedSamples), _));
+                  MakeSpanOfConstSpans(kExpectedChannelTimeOrderedSamples), _));
   auto mock_renderer_factory = std::make_unique<MockRendererFactory>();
   ASSERT_NE(mock_renderer_factory, nullptr);
   EXPECT_CALL(*mock_renderer_factory,
@@ -691,7 +691,7 @@ TEST_F(FinalizerTest, PushTemporalUnitDelegatesToSampleProcessor) {
   // Post-processing is only possible if rendering is enabled.
   renderer_factory_ = std::make_unique<RendererFactory>();
   const std::vector<std::vector<int32_t>> kExpectedPassthroughSamples = {
-      {0}, {std::numeric_limits<int32_t>::max()}};
+      {0, std::numeric_limits<int32_t>::max()}};
   const std::vector<InternalSampleType> kInputSamples = {0, 1.0};
   InitPrerequisiteObusForMonoInput(kAudioElementId);
   AddMixPresentationObuForMonoOutput(kMixPresentationId);
@@ -704,7 +704,7 @@ TEST_F(FinalizerTest, PushTemporalUnitDelegatesToSampleProcessor) {
   // We expect the post-processor to be called with the rendered samples.
   EXPECT_CALL(
       *mock_sample_processor,
-      PushFrameDerived(absl::MakeConstSpan(kExpectedPassthroughSamples)));
+      PushFrameDerived(MakeSpanOfConstSpans(kExpectedPassthroughSamples)));
   MockSampleProcessorFactory mock_sample_processor_factory;
   EXPECT_CALL(mock_sample_processor_factory, Call(_, _, _, _, _, _, _, _))
       .WillOnce(Return(std::move(mock_sample_processor)));
@@ -771,7 +771,7 @@ TEST_F(FinalizerTest, DelegatestoLoudnessCalculator) {
   const LoudnessInfo kMockCalculatedLoudness = kArbitraryLoudnessInfo;
   const LoudnessInfo kMismatchingUserLoudness = kExpectedMinimumLoudnessInfo;
   const std::vector<std::vector<int32_t>> kExpectedPassthroughSamples = {
-      {0}, {std::numeric_limits<int32_t>::max()}};
+      {0, std::numeric_limits<int32_t>::max()}};
   const std::vector<InternalSampleType> kInputSamples = {0, 1.0};
   InitPrerequisiteObusForMonoInput(kAudioElementId);
   AddMixPresentationObuForMonoOutput(kMixPresentationId);
@@ -785,7 +785,7 @@ TEST_F(FinalizerTest, DelegatestoLoudnessCalculator) {
   // We expect the loudness calculator to be called with the rendered samples.
   EXPECT_CALL(*mock_loudness_calculator,
               AccumulateLoudnessForSamples(
-                  absl::MakeConstSpan(kExpectedPassthroughSamples)))
+                  MakeSpanOfConstSpans(kExpectedPassthroughSamples)))
       .WillOnce(Return(absl::OkStatus()));
   ON_CALL(*mock_loudness_calculator, QueryLoudness())
       .WillByDefault(Return(kArbitraryLoudnessInfo));
@@ -848,7 +848,7 @@ void FinalizeOneFrameAndExpectUserLoudnessIsPreserved(
     const LoudnessInfo& kExpectedLoudness,
     RenderingMixPresentationFinalizer& finalizer) {
   std::list<ParameterBlockWithData> parameter_blocks;
-  int64_t start_timestamp = 0;
+  InternalTimestamp start_timestamp = 0;
   for (const auto& id_to_labeled_frame : ordered_labeled_frames_) {
     ASSERT_TRUE(id_to_labeled_frame.contains(kAudioElementId));
     EXPECT_THAT(finalizer.PushTemporalUnit(
@@ -1213,7 +1213,7 @@ TEST_F(FinalizerTest,
       {kR2, Int32ToInternalSampleType({2, 3})}};
   AddLabeledFrame(kAudioElementId, kLabelToSamples, kEndTime);
   renderer_factory_ = std::make_unique<RendererFactory>();
-  const std::vector<std::vector<int32_t>> kExpectedSamples = {{1, 3}};
+  const std::vector<std::vector<int32_t>> kExpectedSamples = {{1}, {3}};
   // We expect the post-processor to be called with the rendered samples.
   sample_processor_factory_ =
       [](DecodedUleb128 /*mix_presentation_id*/, int /*sub_mix_index*/,
@@ -1234,7 +1234,7 @@ TEST_F(FinalizerTest,
   // We expect the post-processed samples, i.e. every other tick.
   EXPECT_THAT(finalizer.GetPostProcessedSamplesAsSpan(
                   kMixPresentationId, kFirstLayoutIndex, kFirstSubmixIndex),
-              IsOkAndHolds(absl::MakeConstSpan(kExpectedSamples)));
+              IsOkAndHolds(MakeSpanOfConstSpans(kExpectedSamples)));
 }
 
 TEST_F(FinalizerTest,
@@ -1244,7 +1244,7 @@ TEST_F(FinalizerTest,
   const LabelSamplesMap kLabelToSamples = {
       {kL2, Int32ToInternalSampleType({0, 1})},
       {kR2, Int32ToInternalSampleType({2, 3})}};
-  const std::vector<std::vector<int32_t>> kExpectedSamples = {{0, 2}, {1, 3}};
+  const std::vector<std::vector<int32_t>> kExpectedSamples = {{0, 1}, {2, 3}};
   AddLabeledFrame(kAudioElementId, kLabelToSamples, kEndTime);
   renderer_factory_ = std::make_unique<RendererFactory>();
   sample_processor_factory_ =
@@ -1262,7 +1262,7 @@ TEST_F(FinalizerTest,
   // rendered samples.
   EXPECT_THAT(finalizer.GetPostProcessedSamplesAsSpan(
                   kMixPresentationId, kFirstLayoutIndex, kFirstSubmixIndex),
-              IsOkAndHolds(absl::MakeConstSpan(kExpectedSamples)));
+              IsOkAndHolds(MakeSpanOfConstSpans(kExpectedSamples)));
 }
 
 TEST_F(FinalizerTest,
@@ -1279,7 +1279,8 @@ TEST_F(FinalizerTest,
       };
   const LabelSamplesMap kLabelToSamples = {
       {kMono, Int32ToInternalSampleType({100, 900})}};
-  const std::vector<std::vector<int32_t>> kExpectedSamples = {{100}, {900}};
+  const std::vector<std::vector<int32_t>> kExpectedSamples = {{100, 900}};
+  const std::vector<std::vector<int32_t>> kEmptySamples = {{}};
   AddLabeledFrame(kAudioElementId, kLabelToSamples, kEndTime);
   auto finalizer = CreateFinalizerExpectOk();
 
@@ -1291,13 +1292,13 @@ TEST_F(FinalizerTest,
       IsOk());
   EXPECT_THAT(finalizer.GetPostProcessedSamplesAsSpan(
                   kMixPresentationId, kFirstSubmixIndex, kFirstLayoutIndex),
-              IsOkAndHolds(IsEmpty()));
+              IsOkAndHolds(MakeSpanOfConstSpans(kEmptySamples)));
 
   // But finally after flushing, samples are available.
   EXPECT_THAT(finalizer.FinalizePushingTemporalUnits(), IsOk());
   EXPECT_THAT(finalizer.GetPostProcessedSamplesAsSpan(
                   kMixPresentationId, kFirstSubmixIndex, kFirstLayoutIndex),
-              IsOkAndHolds(absl::MakeConstSpan(kExpectedSamples)));
+              IsOkAndHolds(MakeSpanOfConstSpans(kExpectedSamples)));
 }
 
 }  // namespace
diff --git a/iamf/cli/tests/sample_processor_base_test.cc b/iamf/cli/tests/sample_processor_base_test.cc
index 1bdd374..92077ca 100644
--- a/iamf/cli/tests/sample_processor_base_test.cc
+++ b/iamf/cli/tests/sample_processor_base_test.cc
@@ -34,34 +34,52 @@ constexpr uint32_t kMaxOutputTicks = 4;
 constexpr size_t kNumChannels = 2;
 
 TEST(GetOutputSamplesAsSpan, ReturnsEmptyAfterConstruction) {
-  const MockSampleProcessor mock_resampler(kMaxInputTicks, kNumChannels,
-                                           kMaxOutputTicks);
-  EXPECT_TRUE(mock_resampler.GetOutputSamplesAsSpan().empty());
+  MockSampleProcessor mock_resampler(kMaxInputTicks, kNumChannels,
+                                     kMaxOutputTicks);
+  for (const auto& output_channel : mock_resampler.GetOutputSamplesAsSpan()) {
+    EXPECT_TRUE(output_channel.empty());
+  }
 }
 
 TEST(GetOutputSamplesAsSpan, SizeMatchesNumValidTicks) {
   EverySecondTickResampler every_second_tick_resampler(kMaxInputTicks,
                                                        kNumChannels);
+  const std::vector<std::vector<int32_t>> first_frame = {{1, 3, 5, 7},
+                                                         {2, 4, 6, 8}};
   EXPECT_THAT(
-      every_second_tick_resampler.PushFrame({{1, 2}, {3, 4}, {5, 6}, {7, 8}}),
+      every_second_tick_resampler.PushFrame(MakeSpanOfConstSpans(first_frame)),
       IsOk());
-  EXPECT_EQ(every_second_tick_resampler.GetOutputSamplesAsSpan().size(), 2);
+  for (const auto& output_channel :
+       every_second_tick_resampler.GetOutputSamplesAsSpan()) {
+    EXPECT_EQ(output_channel.size(), 2);
+  }
 
-  EXPECT_THAT(every_second_tick_resampler.PushFrame({{9, 10}, {11, 12}}),
-              IsOk());
-  EXPECT_EQ(every_second_tick_resampler.GetOutputSamplesAsSpan().size(), 1);
+  const std::vector<std::vector<int32_t>> second_frame = {{9, 10}, {11, 12}};
+  EXPECT_THAT(
+      every_second_tick_resampler.PushFrame(MakeSpanOfConstSpans(second_frame)),
+      IsOk());
+  for (const auto& output_channel :
+       every_second_tick_resampler.GetOutputSamplesAsSpan()) {
+    EXPECT_EQ(output_channel.size(), 1);
+  }
 
   EXPECT_THAT(every_second_tick_resampler.Flush(), IsOk());
-  EXPECT_TRUE(every_second_tick_resampler.GetOutputSamplesAsSpan().empty());
+  for (const auto& output_channel :
+       every_second_tick_resampler.GetOutputSamplesAsSpan()) {
+    EXPECT_TRUE(output_channel.empty());
+  }
 }
 
 TEST(PushFrame, ReturnsFailedPreconditionWhenCalledAfterFlush) {
   MockSampleProcessor mock_resampler(kMaxInputTicks, kNumChannels,
                                      kMaxOutputTicks);
-  EXPECT_THAT(mock_resampler.PushFrame({}), IsOk());
+  const std::vector<std::vector<int32_t>> empty_frame = {{}, {}};
+  EXPECT_THAT(mock_resampler.PushFrame(MakeSpanOfConstSpans(empty_frame)),
+              IsOk());
   EXPECT_THAT(mock_resampler.Flush(), IsOk());
 
-  EXPECT_THAT(mock_resampler.PushFrame({}), StatusIs(kFailedPrecondition));
+  EXPECT_THAT(mock_resampler.PushFrame(MakeSpanOfConstSpans(empty_frame)),
+              StatusIs(kFailedPrecondition));
 }
 
 TEST(PushFrame, InvalidIfInputSpanHasTooManyTicks) {
@@ -71,7 +89,7 @@ TEST(PushFrame, InvalidIfInputSpanHasTooManyTicks) {
       kMaxInputTicks + 1, std::vector<int32_t>(kNumChannels));
 
   EXPECT_FALSE(
-      mock_resampler.PushFrame(absl::MakeConstSpan(kTooManyTicks)).ok());
+      mock_resampler.PushFrame(MakeSpanOfConstSpans(kTooManyTicks)).ok());
 }
 
 TEST(PushFrame, InvalidIfInputSpanHasTooFewChannels) {
@@ -81,7 +99,7 @@ TEST(PushFrame, InvalidIfInputSpanHasTooFewChannels) {
       kMaxInputTicks, std::vector<int32_t>(kNumChannels - 1));
 
   EXPECT_FALSE(
-      mock_resampler.PushFrame(absl::MakeConstSpan(kTooFewChannels)).ok());
+      mock_resampler.PushFrame(MakeSpanOfConstSpans(kTooFewChannels)).ok());
 }
 
 TEST(PushFrame, InvalidIfInputSpanHasTooManyChannels) {
@@ -91,7 +109,7 @@ TEST(PushFrame, InvalidIfInputSpanHasTooManyChannels) {
       kMaxInputTicks, std::vector<int32_t>(kNumChannels + 1));
 
   EXPECT_FALSE(
-      mock_resampler.PushFrame(absl::MakeConstSpan(kTooManyChannels)).ok());
+      mock_resampler.PushFrame(MakeSpanOfConstSpans(kTooManyChannels)).ok());
 }
 
 TEST(Flush, ReturnsFailedPreconditionWhenCalledTwice) {
diff --git a/iamf/cli/tests/wav_reader_test.cc b/iamf/cli/tests/wav_reader_test.cc
index 6e9ce1b..adb5012 100644
--- a/iamf/cli/tests/wav_reader_test.cc
+++ b/iamf/cli/tests/wav_reader_test.cc
@@ -264,15 +264,12 @@ TEST(WavReader, OneFrame16BitLittleEndian) {
   // bits.
   EXPECT_EQ(wav_reader.ReadFrame(), 16);
   std::vector<std::vector<int32_t>> expected_frame = {
-      {0x00010000, static_cast<int32_t>(0xffff0000)},
-      {0x00020000, static_cast<int32_t>(0xfffe0000)},
-      {0x00030000, static_cast<int32_t>(0xfffd0000)},
-      {0x00040000, static_cast<int32_t>(0xfffc0000)},
-      {0x00050000, static_cast<int32_t>(0xfffb0000)},
-      {0x00060000, static_cast<int32_t>(0xfffa0000)},
-      {0x00070000, static_cast<int32_t>(0xfff90000)},
-      {0x00080000, static_cast<int32_t>(0xfff80000)},
-  };
+      {0x00010000, 0x00020000, 0x00030000, 0x00040000, 0x00050000, 0x00060000,
+       0x00070000, 0x00080000},
+      {static_cast<int32_t>(0xffff0000), static_cast<int32_t>(0xfffe0000),
+       static_cast<int32_t>(0xfffd0000), static_cast<int32_t>(0xfffc0000),
+       static_cast<int32_t>(0xfffb0000), static_cast<int32_t>(0xfffa0000),
+       static_cast<int32_t>(0xfff90000), static_cast<int32_t>(0xfff80000)}};
   EXPECT_EQ(wav_reader.buffers_, expected_frame);
 }
 
@@ -283,17 +280,15 @@ TEST(WavReader, TwoFrames16BitLittleEndian) {
 
   EXPECT_EQ(wav_reader.ReadFrame(), 8);
   std::vector<std::vector<int32_t>> expected_frame = {
-      {0x00010000, static_cast<int32_t>(0xffff0000)},
-      {0x00020000, static_cast<int32_t>(0xfffe0000)},
-      {0x00030000, static_cast<int32_t>(0xfffd0000)},
-      {0x00040000, static_cast<int32_t>(0xfffc0000)},
-  };
+      {0x00010000, 0x00020000, 0x00030000, 0x00040000},
+      {static_cast<int32_t>(0xffff0000), static_cast<int32_t>(0xfffe0000),
+       static_cast<int32_t>(0xfffd0000), static_cast<int32_t>(0xfffc0000)}};
   EXPECT_EQ(wav_reader.buffers_, expected_frame);
 
-  expected_frame = {{0x00050000, static_cast<int32_t>(0xfffb0000)},
-                    {0x00060000, static_cast<int32_t>(0xfffa0000)},
-                    {0x00070000, static_cast<int32_t>(0xfff90000)},
-                    {0x00080000, static_cast<int32_t>(0xfff80000)}};
+  expected_frame = {
+      {0x00050000, 0x00060000, 0x00070000, 0x00080000},
+      {static_cast<int32_t>(0xfffb0000), static_cast<int32_t>(0xfffa0000),
+       static_cast<int32_t>(0xfff90000), static_cast<int32_t>(0xfff80000)}};
   wav_reader.ReadFrame();
   EXPECT_EQ(wav_reader.buffers_, expected_frame);
 }
@@ -305,9 +300,8 @@ TEST(WavReader, OneFrame24BitLittleEndian) {
 
   EXPECT_EQ(wav_reader.ReadFrame(), 4);
   std::vector<std::vector<int32_t>> expected_frame = {
-      {0x00000100, static_cast<int32_t>(0xffffff00)},
-      {0x00000200, static_cast<int32_t>(0xfffffe00)},
-  };
+      {0x00000100, 0x00000200},
+      {static_cast<int32_t>(0xffffff00), static_cast<int32_t>(0xfffffe00)}};
 
   EXPECT_EQ(wav_reader.buffers_, expected_frame);
 }
@@ -320,9 +314,8 @@ TEST(WavReader, OneFrame32BitLittleEndian) {
 
   EXPECT_EQ(wav_reader.ReadFrame(), 8);
   std::vector<std::vector<int32_t>> expected_frame = {
-      {0},         {82180641},  {151850024}, {198401618},
-      {214748364}, {198401618}, {151850024}, {82180641},
-  };
+      {0, 82180641, 151850024, 198401618, 214748364, 198401618, 151850024,
+       82180641}};
   EXPECT_EQ(wav_reader.buffers_, expected_frame);
 }
 
@@ -339,7 +332,7 @@ TEST(WavReader, OneFrameAdm) {
   // bits.
   EXPECT_EQ(wav_reader.ReadFrame(), 3);
   const std::vector<std::vector<int32_t>> kExpectedFrame = {
-      {0x23010000, 0x67450000, static_cast<int32_t>(0xbbaa0000)}};
+      {0x23010000}, {0x67450000}, {static_cast<int32_t>(0xbbaa0000)}};
   EXPECT_EQ(wav_reader.buffers_, kExpectedFrame);
 }
 
@@ -351,7 +344,7 @@ TEST(WavReader, IsSafeToCallReadFrameAfterMove) {
 
   EXPECT_EQ(wav_reader_moved.ReadFrame(), 2);
   const std::vector<std::vector<int32_t>> kExpectedFrame = {
-      {0x00010000, static_cast<int32_t>(0xffff0000)}};
+      {0x00010000}, {static_cast<int32_t>(0xffff0000)}};
   EXPECT_EQ(wav_reader_moved.buffers_, kExpectedFrame);
 }
 
diff --git a/iamf/cli/tests/wav_writer_test.cc b/iamf/cli/tests/wav_writer_test.cc
index f2fd389..0dbe56b 100644
--- a/iamf/cli/tests/wav_writer_test.cc
+++ b/iamf/cli/tests/wav_writer_test.cc
@@ -93,15 +93,17 @@ TEST(DeprecatedWritePcmSamples, WriteEmptySamplesSucceeds) {
   EXPECT_THAT(wav_writer->WritePcmSamples(kEmptySamples), IsOk());
 }
 
-TEST(PushFrame, WriteEmptySamplesSucceeds) {
+TEST(PushFrame, WriteChannelsOfEmptySamplesSucceeds) {
   auto wav_writer =
       WavWriter::Create(GetAndCleanupOutputFileName(".wav"), kNumChannels,
                         kSampleRateHz, kBitDepth24, kMaxInputSamplesPerFrame);
   ASSERT_NE(wav_writer, nullptr);
 
-  const std::vector<std::vector<int32_t>> kEmptySamples;
-  EXPECT_THAT(wav_writer->PushFrame(absl::MakeConstSpan(kEmptySamples)),
-              IsOk());
+  const std::vector<std::vector<int32_t>> kChannelsOfEmptySamples(
+      kNumChannels, std::vector<int32_t>());
+  EXPECT_THAT(
+      wav_writer->PushFrame(MakeSpanOfConstSpans(kChannelsOfEmptySamples)),
+      IsOk());
 }
 
 TEST(DeprecatedWritePcmSamples, WriteIntegerSamplesSucceeds) {
@@ -123,8 +125,8 @@ TEST(PushFrame, WriteIntegerSamplesSucceeds) {
 
   constexpr int kNumSamples = 3;
   const std::vector<std::vector<int32_t>> samples(
-      kNumSamples, std::vector<int32_t>(kNumChannels, kSampleValue));
-  EXPECT_THAT(wav_writer->PushFrame(absl::MakeConstSpan(samples)), IsOk());
+      kNumChannels, std::vector<int32_t>(kNumSamples, kSampleValue));
+  EXPECT_THAT(wav_writer->PushFrame(MakeSpanOfConstSpans(samples)), IsOk());
 }
 
 TEST(PushFrame, WriteManyChannelsSucceeds) {
@@ -138,8 +140,8 @@ TEST(PushFrame, WriteManyChannelsSucceeds) {
 
   constexpr int kNumSamples = 3;
   const std::vector<std::vector<int32_t>> samples(
-      kNumSamples, std::vector<int32_t>(kNumChannels, kSampleValue));
-  EXPECT_THAT(wav_writer->PushFrame(absl::MakeConstSpan(samples)), IsOk());
+      kNumChannels, std::vector<int32_t>(kNumSamples, kSampleValue));
+  EXPECT_THAT(wav_writer->PushFrame(MakeSpanOfConstSpans(samples)), IsOk());
 }
 
 TEST(DeprecatedWritePcmSamples, WriteMoreSamplesThanConfiguredFails) {
@@ -164,7 +166,7 @@ TEST(PushFrame, WriteMoreSamplesThanConfiguredFails) {
   constexpr int kTooManySamples = 2;
   std::vector<std::vector<int32_t>> samples(
       kNumChannels, std::vector<int32_t>(kTooManySamples, kSampleValue));
-  EXPECT_FALSE(wav_writer->PushFrame(samples).ok());
+  EXPECT_FALSE(wav_writer->PushFrame(MakeSpanOfConstSpans(samples)).ok());
 }
 
 TEST(DeprecatedWritePcmSamples, DeprecatedWriteNonIntegerNumberOfSamplesFails) {
@@ -187,7 +189,7 @@ TEST(PushFrame, WriteChannelWithTooFewSamplesFails) {
   // The second tick is missing a channel.
   const std::vector<std::vector<int32_t>> samples = {
       {kSampleValue, kSampleValue}, {kSampleValue}};
-  EXPECT_FALSE(wav_writer->PushFrame(absl::MakeConstSpan(samples)).ok());
+  EXPECT_FALSE(wav_writer->PushFrame(MakeSpanOfConstSpans(samples)).ok());
 }
 
 TEST(PushFrame, ConsumesInputSamples) {
@@ -197,15 +199,17 @@ TEST(PushFrame, ConsumesInputSamples) {
   ASSERT_NE(wav_writer, nullptr);
   constexpr int kNumSamples = 3;
   const std::vector<std::vector<int32_t>> samples(
-      kNumSamples, std::vector<int32_t>(kNumChannels, kSampleValue));
+      kNumChannels, std::vector<int32_t>(kNumSamples, kSampleValue));
 
-  EXPECT_THAT(wav_writer->PushFrame(absl::MakeConstSpan(samples)), IsOk());
+  EXPECT_THAT(wav_writer->PushFrame(MakeSpanOfConstSpans(samples)), IsOk());
 
   // The writer consumes all input samples, so
-  // `SampleProcessorBase::GetOutputSamplesAsSpan` will always return an empty
-  // span.
-  EXPECT_TRUE(wav_writer->GetOutputSamplesAsSpan().empty());
-}
+  // `SampleProcessorBase::GetOutputSamplesAsSpan` will always return a span of
+  // empty spans.
+  for (const auto channel_span : wav_writer->GetOutputSamplesAsSpan()) {
+    EXPECT_TRUE(channel_span.empty());
+  }
+}  //   std::vector<absl::Span<const InternalSampleType>>
 
 TEST(DeprecatedWritePcmSamples,
      DeprecatedWriteIntegerSamplesSucceedsWithoutHeader) {
@@ -305,8 +309,7 @@ TEST(WavWriterTest,
      Output16BitWavFileHasCorrectDataWithDeprecatedWritePcmSamples) {
   const std::string output_file_path(GetAndCleanupOutputFileName(".wav"));
   const std::vector<std::vector<int32_t>> kExpectedSamples = {
-      {0x01000000}, {0x03020000}, {0x05040000},
-      {0x07060000}, {0x09080000}, {0x0b0a0000}};
+      {0x01000000, 0x03020000, 0x05040000, 0x07060000, 0x09080000, 0x0b0a0000}};
   constexpr int kNumSamplesPerFrame = 6;
   const int kInputBytes = kNumSamplesPerFrame * 2;
   {
@@ -332,8 +335,7 @@ TEST(WavWriterTest,
      Output16BitWavFileHasCorrectDataWithPushFrameAfterDestruction) {
   const std::string output_file_path(GetAndCleanupOutputFileName(".wav"));
   const std::vector<std::vector<int32_t>> kExpectedSamples = {
-      {0x01000000}, {0x03020000}, {0x05040000},
-      {0x07060000}, {0x09080000}, {0x0b0a0000}};
+      {0x01000000, 0x03020000, 0x05040000, 0x07060000, 0x09080000, 0x0b0a0000}};
   constexpr int kNumSamplesPerFrame = 6;
   {
     // Create the writer in a small scope. The user can safely omit the call the
@@ -343,7 +345,7 @@ TEST(WavWriterTest,
         WavWriter::Create(output_file_path, kNumChannels, kSampleRateHz,
                           kBitDepth16, kMaxInputSamplesPerFrame);
     ASSERT_NE(wav_writer, nullptr);
-    EXPECT_THAT(wav_writer->PushFrame(absl::MakeConstSpan(kExpectedSamples)),
+    EXPECT_THAT(wav_writer->PushFrame(MakeSpanOfConstSpans(kExpectedSamples)),
                 IsOk());
   }
 
@@ -357,15 +359,14 @@ TEST(WavWriterTest,
 TEST(WavWriterTest, Output16BitWavFileHasCorrectDataWithPushFrameAfterFlush) {
   const std::string output_file_path(GetAndCleanupOutputFileName(".wav"));
   const std::vector<std::vector<int32_t>> kExpectedSamples = {
-      {0x01000000}, {0x03020000}, {0x05040000},
-      {0x07060000}, {0x09080000}, {0x0b0a0000}};
+      {0x01000000, 0x03020000, 0x05040000, 0x07060000, 0x09080000, 0x0b0a0000}};
   constexpr int kNumSamplesPerFrame = 6;
 
   auto wav_writer =
       WavWriter::Create(output_file_path, kNumChannels, kSampleRateHz,
                         kBitDepth16, kMaxInputSamplesPerFrame);
   ASSERT_NE(wav_writer, nullptr);
-  EXPECT_THAT(wav_writer->PushFrame(absl::MakeConstSpan(kExpectedSamples)),
+  EXPECT_THAT(wav_writer->PushFrame(MakeSpanOfConstSpans(kExpectedSamples)),
               IsOk());
   // Instead of waiting for the destructor to call `Flush()`, the user can call
   // `Flush()` explicitly, to signal the wav header (including the total number
@@ -383,7 +384,7 @@ TEST(WavWriterTest,
      Output24BitWavFileHasCorrectDataWithDeprecatedWritePcmSamples) {
   const std::string output_file_path(GetAndCleanupOutputFileName(".wav"));
   const std::vector<std::vector<int32_t>> kExpectedSamples = {
-      {0x02010000}, {0x05040300}, {0x08070600}, {0x0b0a0900}};
+      {0x02010000, 0x05040300, 0x08070600, 0x0b0a0900}};
   constexpr int kNumSamplesPerFrame = 4;
   constexpr int kInputBytes = kNumSamplesPerFrame * 3;
   {
@@ -408,7 +409,7 @@ TEST(WavWriterTest,
 TEST(WavWriterTest, Output24BitWavFileHasCorrectData) {
   const std::string output_file_path(GetAndCleanupOutputFileName(".wav"));
   const std::vector<std::vector<int32_t>> kExpectedSamples = {
-      {0x02010000}, {0x05040300}, {0x08070600}, {0x0b0a0900}};
+      {0x02010000, 0x05040300, 0x08070600, 0x0b0a0900}};
   constexpr int kNumSamplesPerFrame = 4;
   {
     // Create the writer in a small scope. It should be destroyed before
@@ -416,7 +417,7 @@ TEST(WavWriterTest, Output24BitWavFileHasCorrectData) {
     auto wav_writer =
         WavWriter::Create(output_file_path, kNumChannels, kSampleRateHz,
                           kBitDepth24, kMaxInputSamplesPerFrame);
-    EXPECT_THAT(wav_writer->PushFrame(absl::MakeConstSpan(kExpectedSamples)),
+    EXPECT_THAT(wav_writer->PushFrame(MakeSpanOfConstSpans(kExpectedSamples)),
                 IsOk());
   }
 
@@ -431,7 +432,7 @@ TEST(WavWriterTest,
      Output32BitWavFileHasCorrectDataWithDeprecatedWritePcmSamples) {
   const std::string output_file_path(GetAndCleanupOutputFileName(".wav"));
   const std::vector<std::vector<int32_t>> kExpectedSamples = {
-      {0x03020100}, {0x07060504}, {0x0b0a0908}};
+      {0x03020100, 0x07060504, 0x0b0a0908}};
   constexpr int kNumSamplesPerFrame = 3;
   constexpr int kInputBytes = kNumSamplesPerFrame * 4;
   {
@@ -456,7 +457,7 @@ TEST(WavWriterTest,
 TEST(WavWriterTest, Output32BitWavFileHasCorrectData) {
   const std::string output_file_path(GetAndCleanupOutputFileName(".wav"));
   const std::vector<std::vector<int32_t>> kExpectedSamples = {
-      {0x03020100}, {0x07060504}, {0x0b0a0908}};
+      {0x03020100, 0x07060504, 0x0b0a0908}};
   constexpr int kNumSamplesPerFrame = 3;
   {
     // Create the writer in a small scope. It should be destroyed before
@@ -465,7 +466,7 @@ TEST(WavWriterTest, Output32BitWavFileHasCorrectData) {
         WavWriter::Create(output_file_path, kNumChannels, kSampleRateHz,
                           kBitDepth32, kMaxInputSamplesPerFrame);
     ASSERT_NE(wav_writer, nullptr);
-    EXPECT_THAT(wav_writer->PushFrame(absl::MakeConstSpan(kExpectedSamples)),
+    EXPECT_THAT(wav_writer->PushFrame(MakeSpanOfConstSpans(kExpectedSamples)),
                 IsOk());
   }
 
@@ -480,8 +481,10 @@ TEST(WavWriterTest, OutputWithManyChannelsHasCorrectData) {
   constexpr int kNumChannels = 6;
   const std::string output_file_path(GetAndCleanupOutputFileName(".wav"));
   const std::vector<std::vector<int32_t>> kExpectedSamples = {
-      {0x01010101, 0x02010101, 0x03010101, 0x04010101, 0x05010101, 0x06010101},
-      {0x01020202, 0x02020202, 0x03020202, 0x04020202, 0x05020202, 0x06020202}};
+      {0x01010101, 0x01020202}, {0x02010101, 0x02020202},
+      {0x03010101, 0x03020202}, {0x04010101, 0x04020202},
+      {0x05010101, 0x05020202}, {0x06010101, 0x06020202}};
+
   constexpr int kNumSamplesPerFrame = 2;
   {
     // Create the writer in a small scope. It should be destroyed before
@@ -490,7 +493,7 @@ TEST(WavWriterTest, OutputWithManyChannelsHasCorrectData) {
         WavWriter::Create(output_file_path, kNumChannels, kSampleRateHz,
                           kBitDepth32, kMaxInputSamplesPerFrame);
     ASSERT_NE(wav_writer, nullptr);
-    EXPECT_THAT(wav_writer->PushFrame(absl::MakeConstSpan(kExpectedSamples)),
+    EXPECT_THAT(wav_writer->PushFrame(MakeSpanOfConstSpans(kExpectedSamples)),
                 IsOk());
   }
 
diff --git a/iamf/cli/wav_reader.cc b/iamf/cli/wav_reader.cc
index 6b07b67..79e3b47 100644
--- a/iamf/cli/wav_reader.cc
+++ b/iamf/cli/wav_reader.cc
@@ -74,8 +74,7 @@ absl::StatusOr<WavReader> WavReader::CreateFromFile(
 
 WavReader::WavReader(const size_t num_samples_per_frame, FILE* file,
                      const ReadWavInfo& info)
-    : buffers_(num_samples_per_frame,
-               std::vector<int32_t>(info.num_channels, 0)),
+    : buffers_(info.num_channels, std::vector<int32_t>(num_samples_per_frame)),
       num_samples_per_frame_(num_samples_per_frame),
       file_(file),
       info_(info) {}
@@ -97,11 +96,22 @@ WavReader::~WavReader() {
 }
 
 size_t WavReader::ReadFrame() {
+  // Read samples in an interleaved mannar but store the outputs in
+  // (channel, time) axes.
   size_t samples_read = 0;
-  for (int i = 0; i < buffers_.size(); i++) {
+  const auto num_channels = info_.num_channels;
+  std::vector<int32_t> buffer_of_one_tick(num_channels, 0);
+  for (int t = 0; t < num_samples_per_frame_; t++) {
     samples_read +=
-        ReadWavSamples(file_, &info_, buffers_[i].data(), buffers_[i].size());
+        ReadWavSamples(file_, &info_, buffer_of_one_tick.data(), num_channels);
+    if (samples_read < num_channels) {
+      break;
+    }
+    for (int c = 0; c < num_channels; c++) {
+      buffers_[c][t] = buffer_of_one_tick[c];
+    }
   }
+
   return samples_read;
 }
 
diff --git a/iamf/cli/wav_reader.h b/iamf/cli/wav_reader.h
index d798eaa..7651088 100644
--- a/iamf/cli/wav_reader.h
+++ b/iamf/cli/wav_reader.h
@@ -76,7 +76,7 @@ class WavReader {
    */
   size_t ReadFrame();
 
-  /*!\brief Buffers stored a vector of interleaved samples.
+  /*!\brief Buffers storing samples in (channel, time) axes.
    *
    * The samples are left-justified; the upper `bit_depth()` bits represent the
    * sample, with the remaining lower bits set to 0.
diff --git a/iamf/cli/wav_sample_provider.cc b/iamf/cli/wav_sample_provider.cc
index 2fb451a..43222c1 100644
--- a/iamf/cli/wav_sample_provider.cc
+++ b/iamf/cli/wav_sample_provider.cc
@@ -25,6 +25,7 @@
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
 #include "iamf/cli/audio_element_with_data.h"
+#include "iamf/cli/channel_label.h"
 #include "iamf/cli/demixing_module.h"
 #include "iamf/cli/proto/audio_frame.pb.h"
 #include "iamf/cli/proto_conversion/channel_label_utils.h"
@@ -263,7 +264,7 @@ absl::Status WavSampleProvider::ReadFrames(
     samples.resize(num_time_ticks);
     for (int t = 0; t < num_time_ticks; ++t) {
       samples[t] = Int32ToNormalizedFloatingPoint<InternalSampleType>(
-          wav_reader.buffers_[t][channel_ids[c]]);
+          wav_reader.buffers_[channel_ids[c]][t]);
     }
   }
   finished_reading = (wav_reader.remaining_samples() == 0);
diff --git a/iamf/cli/wav_writer.cc b/iamf/cli/wav_writer.cc
index 2e4269a..66c9163 100644
--- a/iamf/cli/wav_writer.cc
+++ b/iamf/cli/wav_writer.cc
@@ -37,6 +37,9 @@
 namespace iamf_tools {
 
 namespace {
+
+using ::absl::MakeConstSpan;
+
 // Some audio to tactile functions return 0 on success and 1 on failure.
 constexpr int kAudioToTactileResultFailure = 0;
 constexpr int kAudioToTactileResultSuccess = 1;
@@ -46,10 +49,10 @@ constexpr int kAudioToTactileResultSuccess = 1;
 constexpr size_t kMaxOutputSamplesPerFrame = 0;
 
 // Write samples for all channels.
-absl::Status WriteSamplesInternal(absl::Nullable<FILE*> file,
+absl::Status WriteSamplesInternal(FILE* /* absl_nullable */ file,
                                   size_t num_channels, int bit_depth,
                                   size_t max_num_samples_per_frame,
-                                  const std::vector<uint8_t>& buffer,
+                                  absl::Span<const uint8_t> buffer,
                                   size_t& total_samples_accumulator) {
   if (file == nullptr) {
     // Wav writer may have been aborted.
@@ -210,33 +213,33 @@ WavWriter::~WavWriter() {
 }
 
 absl::Status WavWriter::PushFrameDerived(
-    absl::Span<const std::vector<int32_t>> time_channel_samples) {
+    absl::Span<const absl::Span<const int32_t>> channel_time_samples) {
   // Flatten down the serialized PCM for compatibility with the internal
   // `WriteSamplesInternal` function.
-  const size_t num_ticks = time_channel_samples.size();
-  const size_t num_channels =
-      time_channel_samples.empty() ? 0 : time_channel_samples[0].size();
+  const size_t num_channels = channel_time_samples.size();
+  const size_t num_ticks =
+      channel_time_samples.empty() ? 0 : channel_time_samples[0].size();
   if (!std::all_of(
-          time_channel_samples.begin(), time_channel_samples.end(),
-          [&](const auto& tick) { return tick.size() == num_channels; })) {
+          channel_time_samples.begin(), channel_time_samples.end(),
+          [&](const auto& channel) { return channel.size() == num_ticks; })) {
     return absl::InvalidArgumentError(
-        "All ticks must have the same number of channels.");
+        "All channels must have the same number of ticks.");
   }
 
   std::vector<uint8_t> samples_as_pcm(num_channels * num_ticks * bit_depth_ / 8,
                                       0);
   size_t write_position = 0;
-  for (const auto& tick : time_channel_samples) {
-    for (const auto& channel_sample : tick) {
-      RETURN_IF_NOT_OK(WritePcmSample(channel_sample, bit_depth_,
-                                      /*big_endian=*/false,
-                                      samples_as_pcm.data(), write_position));
+  for (int t = 0; t < num_ticks; t++) {
+    for (int c = 0; c < num_channels; c++) {
+      RETURN_IF_NOT_OK(WritePcmSample(
+          static_cast<uint32_t>(channel_time_samples[c][t]), bit_depth_,
+          /*big_endian=*/false, samples_as_pcm.data(), write_position));
     }
   }
 
-  return WriteSamplesInternal(file_, num_channels_, bit_depth_,
-                              max_input_samples_per_frame_, samples_as_pcm,
-                              total_samples_written_);
+  return WriteSamplesInternal(
+      file_, num_channels_, bit_depth_, max_input_samples_per_frame_,
+      MakeConstSpan(samples_as_pcm), total_samples_written_);
 }
 
 absl::Status WavWriter::FlushDerived() {
@@ -246,7 +249,7 @@ absl::Status WavWriter::FlushDerived() {
   return absl::OkStatus();
 }
 
-absl::Status WavWriter::WritePcmSamples(const std::vector<uint8_t>& buffer) {
+absl::Status WavWriter::WritePcmSamples(absl::Span<const uint8_t> buffer) {
   return WriteSamplesInternal(file_, num_channels_, bit_depth_,
                               max_input_samples_per_frame_, buffer,
                               total_samples_written_);
diff --git a/iamf/cli/wav_writer.h b/iamf/cli/wav_writer.h
index 54af84a..4f319c8 100644
--- a/iamf/cli/wav_writer.h
+++ b/iamf/cli/wav_writer.h
@@ -18,7 +18,6 @@
 #include <cstdio>
 #include <memory>
 #include <string>
-#include <vector>
 
 #include "absl/functional/any_invocable.h"
 #include "absl/status/status.h"
@@ -67,7 +66,7 @@ class WavWriter : public SampleProcessorBase {
    * \return `absl::OkStatus()` on success. A specific status on failure.
    */
   [[deprecated("Use `SampleProcessorBase::PushFrame` instead.")]]
-  absl::Status WritePcmSamples(const std::vector<uint8_t>& buffer);
+  absl::Status WritePcmSamples(absl::Span<const uint8_t> buffer);
 
   /*!\brief Aborts the write process and deletes the wav file.*/
   void Abort();
@@ -94,16 +93,16 @@ class WavWriter : public SampleProcessorBase {
   /*!\brief Writes samples to the wav file and consumes them.
    *
    * Since the samples are consumed, the
-   * `SampleProcessorBase::GetOutputSamplesAsSpan` method will always return an
-   * empty span.
+   * `SampleProcessorBase::GetOutputSamplesAsSpan` method will always return a
+   * span of empty channels.
    *
    * There must be the same number of samples for each channel.
    *
-   * \param time_channel_samples Samples to push arranged in (time, channel).
+   * \param channel_time_samples Samples to push arranged in (channel, time).
    * \return `absl::OkStatus()` on success. A specific status on failure.
    */
-  absl::Status PushFrameDerived(
-      absl::Span<const std::vector<int32_t>> time_channel_samples) override;
+  absl::Status PushFrameDerived(absl::Span<const absl::Span<const int32_t>>
+                                    channel_time_samples) override;
 
   /*!\brief Signals that no more samples will be pushed.
    *
diff --git a/iamf/common/read_bit_buffer.cc b/iamf/common/read_bit_buffer.cc
index 83cc8ed..774eae3 100644
--- a/iamf/common/read_bit_buffer.cc
+++ b/iamf/common/read_bit_buffer.cc
@@ -247,33 +247,35 @@ absl::Status ReadBitBuffer::ReadBoolean(bool& output) {
   return absl::OkStatus();
 }
 
-ReadBitBuffer::ReadBitBuffer(size_t capacity, int64_t source_size)
-    : bit_buffer_(capacity),
+ReadBitBuffer::ReadBitBuffer(size_t capacity_bytes, int64_t source_size_bits)
+    : bit_buffer_(capacity_bytes),
       buffer_bit_offset_(0),
-      buffer_size_(0),
-      source_size_(source_size),
+      buffer_size_bits_(0),
+      source_size_bits_(source_size_bits),
       source_bit_offset_(0) {}
 
 bool ReadBitBuffer::IsDataAvailable() const {
   const bool valid_data_in_buffer =
-      (buffer_bit_offset_ >= 0 && buffer_bit_offset_ < buffer_size_);
+      (buffer_bit_offset_ >= 0 && buffer_bit_offset_ < buffer_size_bits_);
   const bool valid_data_in_source =
-      (source_bit_offset_ >= 0 && source_bit_offset_ < source_size_);
+      (source_bit_offset_ >= 0 && source_bit_offset_ < source_size_bits_);
   return valid_data_in_buffer || valid_data_in_source;
 }
 
 bool ReadBitBuffer::CanReadBytes(int64_t num_bytes_requested) const {
   CHECK_GE(num_bytes_requested, 0);
-  CHECK(source_bit_offset_ >= 0 && source_bit_offset_ <= source_size_);
-  const int64_t num_bytes_in_source = (source_size_ - source_bit_offset_) / 8;
-  CHECK(buffer_bit_offset_ >= 0 && buffer_bit_offset_ <= buffer_size_);
-  const int64_t num_bytes_in_buffer = (buffer_size_ - buffer_bit_offset_) / 8;
+  CHECK(source_bit_offset_ >= 0 && source_bit_offset_ <= source_size_bits_);
+  const int64_t num_bytes_in_source =
+      (source_size_bits_ - source_bit_offset_) / 8;
+  CHECK(buffer_bit_offset_ >= 0 && buffer_bit_offset_ <= buffer_size_bits_);
+  const int64_t num_bytes_in_buffer =
+      (buffer_size_bits_ - buffer_bit_offset_) / 8;
   return (num_bytes_in_source + num_bytes_in_buffer) >= num_bytes_requested;
 }
 
 int64_t ReadBitBuffer::Tell() {
   is_position_valid_ = true;
-  return source_bit_offset_ - buffer_size_ + buffer_bit_offset_;
+  return source_bit_offset_ - buffer_size_bits_ + buffer_bit_offset_;
 }
 
 absl::Status ReadBitBuffer::Seek(const int64_t position) {
@@ -287,17 +289,17 @@ absl::Status ReadBitBuffer::Seek(const int64_t position) {
         absl::StrCat("Invalid source position: ", position));
   }
 
-  if (position >= source_size_) {
+  if (position >= source_size_bits_) {
     return absl::ResourceExhaustedError(
         absl::StrCat("Not enough bits in source: position= ", position,
-                     " >= #(bits in source)= ", source_size_));
+                     " >= #(bits in source)= ", source_size_bits_));
   }
 
-  // Simply move the `buffer_bit_offset_` if the requested position lies within
-  // the current buffer.
-  if ((source_bit_offset_ - buffer_size_ <= position) &&
+  // Simply move the `buffer_bit_offset_` if the requested position lies
+  // within the current buffer.
+  if ((source_bit_offset_ - buffer_size_bits_ <= position) &&
       (position < source_bit_offset_)) {
-    buffer_bit_offset_ = position - (source_bit_offset_ - buffer_size_);
+    buffer_bit_offset_ = position - (source_bit_offset_ - buffer_size_bits_);
     return absl::OkStatus();
   }
 
@@ -306,14 +308,14 @@ absl::Status ReadBitBuffer::Seek(const int64_t position) {
   const int64_t starting_byte = position / 8;
   const int64_t num_bytes =
       std::min(static_cast<int64_t>(bit_buffer_.capacity()),
-               source_size_ / 8 - starting_byte);
+               source_size_bits_ / 8 - starting_byte);
 
   RETURN_IF_NOT_OK(LoadBytesToBuffer(starting_byte, num_bytes));
 
   // Update other bookkeeping data.
   buffer_bit_offset_ = position % 8;
   source_bit_offset_ = (starting_byte + num_bytes) * 8;
-  buffer_size_ = num_bytes * 8;
+  buffer_size_bits_ = num_bytes * 8;
 
   return absl::OkStatus();
 }
@@ -344,7 +346,7 @@ absl::Status ReadBitBuffer::ReadUnsignedLiteralInternal(const int num_bits,
 
   // If the final position and the current position lies within the same byte.
   if (expected_final_position / 8 == Tell() / 8) {
-    ReadUnsignedLiteralBits(bit_buffer_, buffer_size_, buffer_bit_offset_,
+    ReadUnsignedLiteralBits(bit_buffer_, buffer_size_bits_, buffer_bit_offset_,
                             remaining_bits_to_read, output);
     CHECK_EQ(remaining_bits_to_read, 0) << remaining_bits_to_read;
     return absl::OkStatus();
@@ -355,7 +357,7 @@ absl::Status ReadBitBuffer::ReadUnsignedLiteralInternal(const int num_bits,
   if (buffer_bit_offset_ % 8 != 0) {
     int64_t num_bits_to_byte_aligned = 8 - (buffer_bit_offset_ % 8);
     remaining_bits_to_read -= num_bits_to_byte_aligned;
-    ReadUnsignedLiteralBits(bit_buffer_, buffer_size_, buffer_bit_offset_,
+    ReadUnsignedLiteralBits(bit_buffer_, buffer_size_bits_, buffer_bit_offset_,
                             num_bits_to_byte_aligned, output);
   }
 
@@ -365,8 +367,9 @@ absl::Status ReadBitBuffer::ReadUnsignedLiteralInternal(const int num_bits,
     RETURN_IF_NOT_OK(Seek(Tell()));
 
     // Read as much as possible from the buffer.
-    int64_t num_bits_from_buffer = std::min(buffer_size_ - buffer_bit_offset_,
-                                            (remaining_bits_to_read / 8) * 8);
+    int64_t num_bits_from_buffer =
+        std::min(buffer_size_bits_ - buffer_bit_offset_,
+                 (remaining_bits_to_read / 8) * 8);
 
     CHECK(CanReadByteAligned(buffer_bit_offset_, num_bits_from_buffer));
     remaining_bits_to_read -= num_bits_from_buffer;
@@ -377,7 +380,7 @@ absl::Status ReadBitBuffer::ReadUnsignedLiteralInternal(const int num_bits,
   // Read the final several bits in the last byte.
   int64_t num_bits_in_final_byte = expected_final_position % 8;
   remaining_bits_to_read -= num_bits_in_final_byte;
-  ReadUnsignedLiteralBits(bit_buffer_, buffer_size_, buffer_bit_offset_,
+  ReadUnsignedLiteralBits(bit_buffer_, buffer_size_bits_, buffer_bit_offset_,
                           num_bits_in_final_byte, output);
   CHECK_EQ(remaining_bits_to_read, 0) << remaining_bits_to_read;
   return absl::OkStatus();
@@ -386,13 +389,8 @@ absl::Status ReadBitBuffer::ReadUnsignedLiteralInternal(const int num_bits,
 // ----- MemoryBasedReadBitBuffer -----
 
 std::unique_ptr<MemoryBasedReadBitBuffer>
-MemoryBasedReadBitBuffer::CreateFromSpan(int64_t capacity,
-                                         absl::Span<const uint8_t> source) {
-  if (capacity < 0) {
-    LOG(ERROR) << "MemoryBasedReadBitBuffer capacity must be >= 0.";
-    return nullptr;
-  }
-  return absl::WrapUnique(new MemoryBasedReadBitBuffer(capacity, source));
+MemoryBasedReadBitBuffer::CreateFromSpan(absl::Span<const uint8_t> source) {
+  return absl::WrapUnique(new MemoryBasedReadBitBuffer(source.size(), source));
 }
 
 absl::Status MemoryBasedReadBitBuffer::LoadBytesToBuffer(int64_t starting_byte,
@@ -410,17 +408,17 @@ absl::Status MemoryBasedReadBitBuffer::LoadBytesToBuffer(int64_t starting_byte,
 }
 
 MemoryBasedReadBitBuffer::MemoryBasedReadBitBuffer(
-    size_t capacity, absl::Span<const uint8_t> source)
-    : ReadBitBuffer(capacity, static_cast<int64_t>(source.size()) * 8),
+    size_t capacity_bytes, absl::Span<const uint8_t> source)
+    : ReadBitBuffer(capacity_bytes, static_cast<int64_t>(source.size()) * 8),
       source_vector_(source.begin(), source.end()) {}
 
 // ----- FileBasedReadBitBuffer -----
 
 std::unique_ptr<FileBasedReadBitBuffer>
 FileBasedReadBitBuffer::CreateFromFilePath(
-    const int64_t capacity, const std::filesystem::path& file_path) {
-  if (capacity < 0) {
-    LOG(ERROR) << "FileBasedReadBitBuffer capacity must be >= 0.";
+    const int64_t capacity_bytes, const std::filesystem::path& file_path) {
+  if (capacity_bytes < 0) {
+    LOG(ERROR) << "FileBasedReadBitBuffer capacity_bytes must be >= 0.";
     return nullptr;
   }
   if (!std::filesystem::exists(file_path)) {
@@ -437,8 +435,8 @@ FileBasedReadBitBuffer::CreateFromFilePath(
   }
 
   // File size is in bytes, `source_size` is in bits.
-  return absl::WrapUnique(
-      new FileBasedReadBitBuffer(capacity, file_size * 8, std::move(ifs)));
+  return absl::WrapUnique(new FileBasedReadBitBuffer(
+      capacity_bytes, file_size * 8, std::move(ifs)));
 }
 
 absl::Status FileBasedReadBitBuffer::LoadBytesToBuffer(int64_t starting_byte,
@@ -453,27 +451,25 @@ absl::Status FileBasedReadBitBuffer::LoadBytesToBuffer(int64_t starting_byte,
   return absl::OkStatus();
 }
 
-FileBasedReadBitBuffer::FileBasedReadBitBuffer(size_t capacity,
+FileBasedReadBitBuffer::FileBasedReadBitBuffer(size_t capacity_bytes,
                                                int64_t source_size,
                                                std::ifstream&& ifs)
-    : ReadBitBuffer(capacity, source_size), source_ifs_(std::move(ifs)) {}
+    : ReadBitBuffer(capacity_bytes, source_size), source_ifs_(std::move(ifs)) {}
 
 // ----- StreamBasedReadBitBuffer -----
 std::unique_ptr<StreamBasedReadBitBuffer> StreamBasedReadBitBuffer::Create(
-    int64_t capacity) {
-  if (capacity < 0) {
-    LOG(ERROR) << "StreamBasedReadBitBuffer capacity must be >= 0.";
+    int64_t capacity_bytes) {
+  if (capacity_bytes < 0) {
+    LOG(ERROR) << "StreamBasedReadBitBuffer capacity_bytes must be >= 0.";
     return nullptr;
   }
-  // Since this is a stream based buffer, we do not initialize with any data,
-  // hence the source size is initially set to 0.
-  return absl::WrapUnique(
-      new StreamBasedReadBitBuffer(capacity, /*source_size=*/0));
+  // Since this is a stream based buffer, we do not initialize with any data.
+  return absl::WrapUnique(new StreamBasedReadBitBuffer(capacity_bytes));
 }
 
 absl::Status StreamBasedReadBitBuffer::PushBytes(
     absl::Span<const uint8_t> bytes) {
-  if (bytes.size() > ((max_source_size_ / 8) - source_vector_.size())) {
+  if (bytes.size() > ((max_source_size_bits_ / 8) - source_vector_.size())) {
     return absl::InvalidArgumentError(
         "Cannot push more bytes than the available space in the source.");
   }
@@ -481,7 +477,7 @@ absl::Status StreamBasedReadBitBuffer::PushBytes(
   // are already some bytes in the source.
   source_vector_.insert(source_vector_.end(), bytes.begin(), bytes.end());
   // The source grows as bytes are pushed.
-  source_size_ += bytes.size() * 8;
+  source_size_bits_ += bytes.size() * 8;
   return absl::OkStatus();
 }
 
@@ -502,17 +498,16 @@ absl::Status StreamBasedReadBitBuffer::Flush(int64_t num_bytes) {
   // Offset needs to be moved back as erase moves the elements of a vector that
   // are not removed to the beginning of the vector.
   source_bit_offset_ -= num_bytes * 8;
-  source_size_ -= num_bytes * 8;
+  source_size_bits_ -= num_bytes * 8;
   // Disable seeking as the position returned by a previous Tell() call is no
   // longer valid.
   is_position_valid_ = false;
   return absl::OkStatus();
 }
 
-StreamBasedReadBitBuffer::StreamBasedReadBitBuffer(size_t capacity,
-                                                   int64_t source_size)
-    : MemoryBasedReadBitBuffer(capacity, absl::Span<const uint8_t>()) {
-  max_source_size_ = kEntireObuSizeMaxTwoMegabytes * 2 * 8;
+StreamBasedReadBitBuffer::StreamBasedReadBitBuffer(size_t capacity_bytes)
+    : MemoryBasedReadBitBuffer(capacity_bytes, absl::Span<const uint8_t>()) {
+  max_source_size_bits_ = kEntireObuSizeMaxTwoMegabytes * 2 * 8;
 }
 
 }  // namespace iamf_tools
diff --git a/iamf/common/read_bit_buffer.h b/iamf/common/read_bit_buffer.h
index 80d9e8c..904e981 100644
--- a/iamf/common/read_bit_buffer.h
+++ b/iamf/common/read_bit_buffer.h
@@ -215,10 +215,10 @@ class ReadBitBuffer {
  protected:
   /*!\brief Constructor.
    *
-   * \param capacity Capacity of the internal buffer in bytes.
+   * \param capacity_bytes Capacity of the internal buffer in bytes.
    * \param source_size Size of the source data in bits.
    */
-  ReadBitBuffer(size_t capacity, int64_t source_size);
+  ReadBitBuffer(size_t capacity_bytes, int64_t source_size_bits);
 
   /*!\brief Internal reading function that reads `num_bits` from buffer.
    *
@@ -254,13 +254,13 @@ class ReadBitBuffer {
   int64_t buffer_bit_offset_ = 0;
 
   // Size of the valid data in the buffer in bits.
-  int64_t buffer_size_ = 0;
+  int64_t buffer_size_bits_ = 0;
 
   // Size of the source data in bits. It may refer to the total file size
   // for a file-based buffer, or the total memory size for a memory-based
   // buffer. For a stream-based buffer, it is the current size of the source
   // data, which is updated as bytes are pushed or flushed.
-  int64_t source_size_;
+  int64_t source_size_bits_;
 
   // Specifies the next bit to consume from the source data (the actual storage
   // type is subclass-specific).
@@ -283,14 +283,13 @@ class MemoryBasedReadBitBuffer : public ReadBitBuffer {
  public:
   /*!\brief Creates an instance of a memory-based read bit buffer.
    *
-   * \param capacity Capacity of the internal buffer in bytes.
    * \param source Source span from which the buffer will load data. The
    *        entire contents will be copied into the constructed instance.
    * \return Unique pointer of the created instance. `nullptr` if the creation
    *         fails.
    */
   static std::unique_ptr<MemoryBasedReadBitBuffer> CreateFromSpan(
-      int64_t capacity, absl::Span<const uint8_t> source);
+      absl::Span<const uint8_t> source);
 
   /*!\brief Destructor.*/
   ~MemoryBasedReadBitBuffer() override = default;
@@ -298,11 +297,12 @@ class MemoryBasedReadBitBuffer : public ReadBitBuffer {
  protected:
   /*!\brief Protected constructor. Called by the factory method or subclasses.
    *
-   * \param capacity Capacity of the internal buffer in bytes.
+   * \param capacity_bytes Capacity of the internal buffer in bytes.
    * \param source Source span from which the buffer will load data. The
    *        entire contents will be copied into the constructed instance.
    */
-  MemoryBasedReadBitBuffer(size_t capacity, absl::Span<const uint8_t> source);
+  MemoryBasedReadBitBuffer(size_t capacity_bytes,
+                           absl::Span<const uint8_t> source);
   /*!\brief Load bytes from the source vector to the buffer.
    *
    * \param starting_byte Starting byte to load from source.
@@ -325,13 +325,13 @@ class FileBasedReadBitBuffer : public ReadBitBuffer {
  public:
   /*!\brief Creates an instance of a file-based read bit buffer.
    *
-   * \param capacity Capacity of the internal buffer in bytes.
+   * \param capacity_bytes Capacity of the internal buffer in bytes.
    * \param file_path Path to the file to load the buffer from.
    * \return Unique pointer of the created instance. `nullptr` if the creation
    *         fails.
    */
   static std::unique_ptr<FileBasedReadBitBuffer> CreateFromFilePath(
-      int64_t capacity, const std::filesystem::path& file_path);
+      int64_t capacity_bytes, const std::filesystem::path& file_path);
 
   /*!\brief Destructor.*/
   ~FileBasedReadBitBuffer() override = default;
@@ -339,13 +339,13 @@ class FileBasedReadBitBuffer : public ReadBitBuffer {
  private:
   /*!\brief Private constructor. Called by the factory method only.
    *
-   * \param capacity Capacity of the internal buffer in bytes.
+   * \param capacity_bytes Capacity of the internal buffer in bytes.
    * \param source_size Total size of the file in bits.
    * \param ifs Input file stream from which the buffer will load data. At most
    *        a buffer full of data will be read at a given time.
    *
    */
-  FileBasedReadBitBuffer(size_t capacity, int64_t source_size,
+  FileBasedReadBitBuffer(size_t capacity_bytes, int64_t source_size,
                          std::ifstream&& ifs);
 
   /*!\brief Load bytes from the source file to the buffer.
@@ -373,11 +373,12 @@ class StreamBasedReadBitBuffer : public MemoryBasedReadBitBuffer {
  public:
   /*!\brief Creates an instance of a stream-based read bit buffer.
    *
-   * \param capacity Capacity of the internal buffer in bytes.
+   * \param capacity_bytes Capacity of the internal buffer in bytes.
    * \return Unique pointer of the created instance. `nullptr` if the creation
    *         fails.
    */
-  static std::unique_ptr<StreamBasedReadBitBuffer> Create(int64_t capacity);
+  static std::unique_ptr<StreamBasedReadBitBuffer> Create(
+      int64_t capacity_bytes);
 
   /*!\brief Adds some chunk of data to StreamBasedReadBitBuffer.
    *
@@ -403,14 +404,12 @@ class StreamBasedReadBitBuffer : public MemoryBasedReadBitBuffer {
  private:
   /*!\brief Private constructor.
    *
-   * \param capacity Capacity of the internal buffer in bytes.
-   * \param source_size Size of the source data in bits.
-   *
+   * \param capacity_bytes Capacity of the internal buffer in bytes.
    */
-  StreamBasedReadBitBuffer(size_t capacity, int64_t source_size);
+  StreamBasedReadBitBuffer(size_t capacity_bytes);
 
   // Specifies the maximum size of the source data in bits.
-  int64_t max_source_size_;
+  int64_t max_source_size_bits_;
 };
 
 }  // namespace iamf_tools
diff --git a/iamf/common/tests/BUILD b/iamf/common/tests/BUILD
index b1fa47b..a03ae8a 100644
--- a/iamf/common/tests/BUILD
+++ b/iamf/common/tests/BUILD
@@ -37,7 +37,6 @@ cc_test(
         "//iamf/cli/tests:cli_test_utils",
         "//iamf/common:read_bit_buffer",
         "//iamf/common/utils:bit_buffer_util",
-        "//iamf/common/utils:numeric_utils",
         "//iamf/obu:types",
         "@com_google_absl//absl/status",
         "@com_google_absl//absl/status:status_matchers",
diff --git a/iamf/common/tests/read_bit_buffer_fuzz_test.cc b/iamf/common/tests/read_bit_buffer_fuzz_test.cc
index 2882341..5b721c2 100644
--- a/iamf/common/tests/read_bit_buffer_fuzz_test.cc
+++ b/iamf/common/tests/read_bit_buffer_fuzz_test.cc
@@ -16,7 +16,7 @@ namespace {
 void ReadUnsignedLiteral64NoUndefinedBehavior(std::vector<uint8_t> data,
                                               int num_bits) {
   std::unique_ptr<MemoryBasedReadBitBuffer> rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(256, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   uint64_t read_data;
   absl::Status status = rb->ReadUnsignedLiteral(num_bits, read_data);
 }
@@ -26,7 +26,7 @@ FUZZ_TEST(ReadBitBufferFuzzTest, ReadUnsignedLiteral64NoUndefinedBehavior);
 void ReadUnsignedLiteral32NoUndefinedBehavior(std::vector<uint8_t> data,
                                               int num_bits) {
   std::unique_ptr<MemoryBasedReadBitBuffer> rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(256, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   uint32_t read_data;
   absl::Status status = rb->ReadUnsignedLiteral(num_bits, read_data);
 }
@@ -36,7 +36,7 @@ FUZZ_TEST(ReadBitBufferFuzzTest, ReadUnsignedLiteral32NoUndefinedBehavior);
 void ReadUnsignedLiteral16NoUndefinedBehavior(std::vector<uint8_t> data,
                                               int num_bits) {
   std::unique_ptr<MemoryBasedReadBitBuffer> rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(256, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   uint16_t read_data;
   absl::Status status = rb->ReadUnsignedLiteral(num_bits, read_data);
 }
@@ -46,7 +46,7 @@ FUZZ_TEST(ReadBitBufferFuzzTest, ReadUnsignedLiteral16NoUndefinedBehavior);
 void ReadUnsignedLiteral8NoUndefinedBehavior(std::vector<uint8_t> data,
                                              int num_bits) {
   std::unique_ptr<MemoryBasedReadBitBuffer> rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(256, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   uint8_t read_data;
   absl::Status status = rb->ReadUnsignedLiteral(num_bits, read_data);
 }
@@ -55,7 +55,7 @@ FUZZ_TEST(ReadBitBufferFuzzTest, ReadUnsignedLiteral8NoUndefinedBehavior);
 
 void ReadSigned16NoUndefinedBehavior(std::vector<uint8_t> data) {
   std::unique_ptr<MemoryBasedReadBitBuffer> rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(256, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   int16_t read_data;
   absl::Status status = rb->ReadSigned16(read_data);
 }
@@ -64,7 +64,7 @@ FUZZ_TEST(ReadBitBufferFuzzTest, ReadSigned16NoUndefinedBehavior);
 
 void ReadStringNoUndefinedBehavior(std::vector<uint8_t> data) {
   std::unique_ptr<MemoryBasedReadBitBuffer> rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(256, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   std::string read_data;
   absl::Status status = rb->ReadString(read_data);
 }
@@ -73,7 +73,7 @@ FUZZ_TEST(ReadBitBufferFuzzTest, ReadStringNoUndefinedBehavior);
 
 void ReadULeb128NoUndefinedBehavior(std::vector<uint8_t> data) {
   std::unique_ptr<MemoryBasedReadBitBuffer> rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(256, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   DecodedUleb128 read_data;
   absl::Status status = rb->ReadULeb128(read_data);
 }
@@ -83,7 +83,7 @@ FUZZ_TEST(ReadBitBufferFuzzTest, ReadULeb128NoUndefinedBehavior);
 void ReadIso14496_1ExpandedNoUndefinedBehavior(std::vector<uint8_t> data,
                                                uint32_t max_class_size) {
   std::unique_ptr<MemoryBasedReadBitBuffer> rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(256, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   uint32_t read_data;
   absl::Status status = rb->ReadIso14496_1Expanded(max_class_size, read_data);
 }
@@ -92,7 +92,7 @@ FUZZ_TEST(ReadBitBufferFuzzTest, ReadIso14496_1ExpandedNoUndefinedBehavior);
 
 void ReadUint8SpanNoUndefinedBehavior(std::vector<uint8_t> data) {
   std::unique_ptr<MemoryBasedReadBitBuffer> rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(256, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   std::vector<uint8_t> read_data(data.size());
   absl::Span<uint8_t> span(read_data);
   absl::Status status = rb->ReadUint8Span(span);
@@ -102,7 +102,7 @@ FUZZ_TEST(ReadBitBufferFuzzTest, ReadUint8SpanNoUndefinedBehavior);
 
 void ReadBooleanNoUndefinedBehavior(std::vector<uint8_t> data) {
   std::unique_ptr<MemoryBasedReadBitBuffer> rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(256, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   bool read_data;
   absl::Status status = rb->ReadBoolean(read_data);
 }
diff --git a/iamf/common/tests/read_bit_buffer_test.cc b/iamf/common/tests/read_bit_buffer_test.cc
index 839e685..5fcb2a4 100644
--- a/iamf/common/tests/read_bit_buffer_test.cc
+++ b/iamf/common/tests/read_bit_buffer_test.cc
@@ -45,13 +45,6 @@ constexpr int kMaxUint32 = std::numeric_limits<uint32_t>::max();
 
 constexpr std::array<uint8_t, 3> kThreeBytes = {0x01, 0x23, 0x45};
 
-TEST(MemoryBasedReadBitBufferTest, CreateFromVectorFailsWithNegativeCapacity) {
-  const std::vector<uint8_t> source_data = {0x01, 0x23, 0x45, 0x68, 0x89};
-  EXPECT_THAT(MemoryBasedReadBitBuffer::CreateFromSpan(
-                  -1, absl::MakeConstSpan(source_data)),
-              ::testing::IsNull());
-}
-
 TEST(FileBasedReadBitBufferTest, CreateFromFilePathFailsWithNegativeCapacity) {
   const auto file_path = GetAndCleanupOutputFileName(".iamf");
   EXPECT_THAT(FileBasedReadBitBuffer::CreateFromFilePath(-1, file_path),
@@ -85,7 +78,7 @@ std::unique_ptr<BufferReaderType> CreateConcreteReadBitBuffer(
 template <>
 std::unique_ptr<MemoryBasedReadBitBuffer> CreateConcreteReadBitBuffer(
     int64_t capacity, absl::Span<const uint8_t> source_data) {
-  return MemoryBasedReadBitBuffer::CreateFromSpan(capacity, source_data);
+  return MemoryBasedReadBitBuffer::CreateFromSpan(source_data);
 }
 
 template <>
diff --git a/iamf/common/tests/write_read_fuzz_test.cc b/iamf/common/tests/write_read_fuzz_test.cc
index d59059a..4bbc3be 100644
--- a/iamf/common/tests/write_read_fuzz_test.cc
+++ b/iamf/common/tests/write_read_fuzz_test.cc
@@ -24,7 +24,7 @@ void WriteReadString(const std::string& data) {
     std::vector<uint8_t> source_data = wb.bit_buffer();
     std::unique_ptr<MemoryBasedReadBitBuffer> rb =
         MemoryBasedReadBitBuffer::CreateFromSpan(
-            256, absl::MakeConstSpan(source_data));
+            absl::MakeConstSpan(source_data));
 
     std::string read_data;
     EXPECT_THAT(rb->ReadString(read_data), IsOk());
@@ -43,7 +43,7 @@ void WriteReadUint8Span(const std::vector<uint8_t>& data) {
     std::vector<uint8_t> source_data = wb.bit_buffer();
     std::unique_ptr<MemoryBasedReadBitBuffer> rb =
         MemoryBasedReadBitBuffer::CreateFromSpan(
-            256, absl::MakeConstSpan(source_data));
+            absl::MakeConstSpan(source_data));
 
     std::vector<uint8_t> read_data(data.size());
     EXPECT_THAT(rb->ReadUint8Span(absl::MakeSpan(read_data)), IsOk());
diff --git a/iamf/common/utils/sample_processing_utils.h b/iamf/common/utils/sample_processing_utils.h
index d3f9f8a..ed56363 100644
--- a/iamf/common/utils/sample_processing_utils.h
+++ b/iamf/common/utils/sample_processing_utils.h
@@ -46,28 +46,25 @@ absl::Status WritePcmSample(uint32_t sample, uint8_t sample_size,
                             bool big_endian, uint8_t* buffer,
                             size_t& write_position);
 
-/*!\brief Arranges the input samples by time and channel.
+/*!\brief Arranges the input samples by channel and time.
  *
  * \param samples Interleaved samples to arrange.
  * \param num_channels Number of channels.
  * \param transform_samples Function to transform each sample to the output
  *        type.
- * \param output Output vector to write the samples to. The size is not
- *        modified in this function even if the number of input samples do
- *        not fill the entire output vector. In that case, only the first
- *        `num_ticks` are filled.
- * \param num_ticks Number of ticks (time samples) of the output vector that
- *        are filled in this function.
+ * \param output Output vector to write the samples to. If the number of
+ *        input samples do not fill the entire output vector, the time axis will
+ *        be modified to fit the actual length.
  * \return `absl::OkStatus()` on success. `absl::InvalidArgumentError()` if the
  *         number of samples is not a multiple of the number of channels. An
  *         error propagated from `transform_samples` if it fails.
  */
 template <typename InputType, typename OutputType>
-absl::Status ConvertInterleavedToTimeChannel(
+absl::Status ConvertInterleavedToChannelTime(
     absl::Span<const InputType> samples, size_t num_channels,
     const absl::AnyInvocable<absl::Status(InputType, OutputType&) const>&
         transform_samples,
-    std::vector<std::vector<OutputType>>& output, size_t& num_ticks) {
+    std::vector<std::vector<OutputType>>& output) {
   if (samples.size() % num_channels != 0) [[unlikely]] {
     return absl::InvalidArgumentError(absl::StrCat(
         "Number of samples must be a multiple of the number of "
@@ -75,22 +72,14 @@ absl::Status ConvertInterleavedToTimeChannel(
         samples.size(), " samples and ", num_channels, " channels."));
   }
 
-  num_ticks = samples.size() / num_channels;
-  if (num_ticks > output.size()) [[unlikely]] {
-    return absl::InvalidArgumentError(absl::StrCat(
-        "Number of ticks does not fit into the output vector: (num_ticks= ",
-        num_ticks, " > output.size()= ", output.size(), ")"));
-  }
-
-  for (int t = 0; t < num_ticks; ++t) {
-    if (output[t].size() != num_channels) [[unlikely]] {
-      return absl::InvalidArgumentError(absl::StrCat(
-          "Number of channels is not equal to the output vector at tick ", t,
-          ": (", num_channels, " != ", output[t].size(), ")"));
-    }
-    for (int c = 0; c < num_channels; ++c) {
-      const auto status =
-          transform_samples(samples[t * num_channels + c], output[t][c]);
+  output.resize(num_channels);
+  const auto num_ticks = samples.size() / num_channels;
+  for (int c = 0; c < num_channels; ++c) {
+    auto& output_for_channel = output[c];
+    output_for_channel.resize(num_ticks);
+    for (int t = 0; t < num_ticks; ++t) {
+      const auto status = transform_samples(samples[t * num_channels + c],
+                                            output_for_channel[t]);
       if (!status.ok()) [[unlikely]] {
         return status;
       }
@@ -101,7 +90,7 @@ absl::Status ConvertInterleavedToTimeChannel(
 
 /*!\brief Interleaves the input samples.
  *
- * \param samples Samples in (time, channel) axes to arrange.
+ * \param samples Samples in (channel, time) axes to arrange.
  * \param transform_samples Function to transform each sample to the output
  *        type.
  * \param output Output vector to write the interleaved samples to.
@@ -110,30 +99,31 @@ absl::Status ConvertInterleavedToTimeChannel(
  *         from `transform_samples` if it fails.
  */
 template <typename InputType, typename OutputType>
-absl::Status ConvertTimeChannelToInterleaved(
-    absl::Span<const std::vector<InputType>> input,
+absl::Status ConvertChannelTimeToInterleaved(
+    absl::Span<const absl::Span<const InputType>> input,
     const absl::AnyInvocable<absl::Status(InputType, OutputType&) const>&
         transform_samples,
     std::vector<OutputType>& output) {
-  const size_t num_channels = input.empty() ? 0 : input[0].size();
-  if (!std::all_of(input.begin(), input.end(), [&](const auto& tick) {
-        return tick.size() == num_channels;
+  const size_t num_ticks = input.empty() ? 0 : input[0].size();
+  if (!std::all_of(input.begin(), input.end(), [&](const auto& channel) {
+        return channel.size() == num_ticks;
       })) {
     return absl::InvalidArgumentError(
-        "All ticks must have the same number of channels.");
+        "All channels must have the same number of ticks.");
   }
 
-  // TODO(b/382197581): avoid resizing inside this function.
-  output.clear();
-  output.reserve(input.size() * num_channels);
-  for (const auto& tick : input) {
-    for (const auto& sample : tick) {
+  const auto num_channels = input.size();
+  output.resize(num_channels * num_ticks);
+  for (int c = 0; c < num_channels; ++c) {
+    const auto& input_for_channel = input[c];
+    for (int t = 0; t < num_ticks; ++t) {
       OutputType transformed_sample;
-      auto status = transform_samples(sample, transformed_sample);
+      const auto status =
+          transform_samples(input_for_channel[t], transformed_sample);
       if (!status.ok()) {
         return status;
       }
-      output.emplace_back(transformed_sample);
+      output[t * num_channels + c] = transformed_sample;
     }
   }
   return absl::OkStatus();
diff --git a/iamf/common/utils/tests/BUILD b/iamf/common/utils/tests/BUILD
index e648e18..0882d2c 100644
--- a/iamf/common/utils/tests/BUILD
+++ b/iamf/common/utils/tests/BUILD
@@ -47,6 +47,7 @@ cc_test(
     name = "sample_processing_utils_test",
     srcs = ["sample_processing_utils_test.cc"],
     deps = [
+        "//iamf/cli/tests:cli_test_utils",
         "//iamf/common/utils:sample_processing_utils",
         "@com_google_absl//absl/functional:any_invocable",
         "@com_google_absl//absl/status",
diff --git a/iamf/common/utils/tests/sample_processing_utils_test.cc b/iamf/common/utils/tests/sample_processing_utils_test.cc
index 6af390b..510ac68 100644
--- a/iamf/common/utils/tests/sample_processing_utils_test.cc
+++ b/iamf/common/utils/tests/sample_processing_utils_test.cc
@@ -23,6 +23,7 @@
 #include "absl/types/span.h"
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
+#include "iamf/cli/tests/cli_test_utils.h"
 
 namespace iamf_tools {
 namespace {
@@ -112,143 +113,84 @@ const absl::AnyInvocable<absl::Status(int32_t, int32_t&) const>
       return absl::OkStatus();
     };
 
-TEST(ConvertInterleavedToTimeChannel, FailsIfSamplesIsNotAMultipleOfChannels) {
+TEST(ConvertInterleavedToChannelTime, FailsIfSamplesIsNotAMultipleOfChannels) {
   constexpr std::array<int32_t, 4> kFourTestValues = {1, 2, 3, 4};
   constexpr size_t kNumChannels = 3;
-  std::vector<std::vector<int32_t>> undefined_result(
-      1, std::vector<int32_t>(kNumChannels));
-  size_t undefined_num_ticks;
-  EXPECT_THAT(ConvertInterleavedToTimeChannel(
+  std::vector<std::vector<int32_t>> undefined_result(kNumChannels);
+  EXPECT_THAT(ConvertInterleavedToChannelTime(
                   absl::MakeConstSpan(kFourTestValues), kNumChannels,
-                  kIdentityTransform, undefined_result, undefined_num_ticks),
+                  kIdentityTransform, undefined_result),
               StatusIs(absl::StatusCode::kInvalidArgument));
 }
 
-TEST(ConvertInterleavedToTimeChannel, FailsIfTooFewTicksInResult) {
-  constexpr std::array<int32_t, 4> kFourTestValues = {1, 2, 3, 4};
-  constexpr size_t kNumChannels = 2;
-  const size_t input_num_ticks = kFourTestValues.size() / kNumChannels;
-
-  // The result has one fewer ticks than the input, which will be rejected.
-  std::vector<std::vector<int32_t>> undefined_result(
-      input_num_ticks - 1, std::vector<int32_t>(kNumChannels));
-  size_t undefined_num_ticks;
-  EXPECT_THAT(ConvertInterleavedToTimeChannel(
-                  absl::MakeConstSpan(kFourTestValues), kNumChannels,
-                  kIdentityTransform, undefined_result, undefined_num_ticks),
-              StatusIs(absl::StatusCode::kInvalidArgument));
-}
-
-TEST(ConvertInterleavedToTimeChannel, FailsIfDifferentChannelNumbersInResult) {
-  constexpr std::array<int32_t, 4> kFourTestValues = {1, 2, 3, 4};
-  constexpr size_t kNumChannels = 2;
-  const size_t input_num_ticks = kFourTestValues.size() / kNumChannels;
-
-  // The result has a different number of channels than the input, which will be
-  // rejected.
-  std::vector<std::vector<int32_t>> undefined_result(
-      input_num_ticks, std::vector<int32_t>(kNumChannels + 1));
-  size_t undefined_num_ticks;
-  EXPECT_THAT(ConvertInterleavedToTimeChannel(
-                  absl::MakeConstSpan(kFourTestValues), kNumChannels,
-                  kIdentityTransform, undefined_result, undefined_num_ticks),
-              StatusIs(absl::StatusCode::kInvalidArgument));
-}
-
-TEST(ConvertInterleavedToTimeChannel, PropagatesError) {
+TEST(ConvertInterleavedToChannelTime, PropagatesError) {
   const absl::Status kError = absl::InternalError("Test error");
   const size_t kNumChannels = 2;
   constexpr std::array<int32_t, 4> kSamples{1, 2, 3, 4};
-  const size_t kNumTicks = kSamples.size() / kNumChannels;
   const absl::AnyInvocable<absl::Status(int32_t, int32_t&) const>
       kAlwaysErrorTransform =
           [kError](int32_t input, int32_t& output) { return kError; };
-  std::vector<std::vector<int32_t>> undefined_result(
-      kNumTicks, std::vector<int32_t>(kNumChannels));
-  size_t undefined_num_ticks;
-  EXPECT_EQ(ConvertInterleavedToTimeChannel(
-                absl::MakeConstSpan(kSamples), kNumChannels,
-                kAlwaysErrorTransform, undefined_result, undefined_num_ticks),
+  std::vector<std::vector<int32_t>> undefined_result(kNumChannels);
+  EXPECT_EQ(ConvertInterleavedToChannelTime(absl::MakeConstSpan(kSamples),
+                                            kNumChannels, kAlwaysErrorTransform,
+                                            undefined_result),
             kError);
 }
 
-TEST(ConvertInterleavedToTimeChannel, SucceedsOnEmptySamples) {
+TEST(ConvertInterleavedToChannelTime, SucceedsOnEmptySamples) {
   constexpr std::array<int32_t, 0> kEmptySamples{};
   constexpr size_t kNumChannels = 2;
-  std::vector<std::vector<int32_t>> result;
-  size_t num_ticks = 0;
-  EXPECT_THAT(ConvertInterleavedToTimeChannel(
-                  absl::MakeConstSpan(kEmptySamples), kNumChannels,
-                  kIdentityTransform, result, num_ticks),
-              IsOk());
-  EXPECT_EQ(num_ticks, 0);
-}
-
-TEST(ConvertInterleavedToTimeChannel, DoesNotAlterOutputVector) {
-  constexpr size_t kNumChannels = 2;
-  constexpr std::array<int32_t, 0> kEmptySamples{};
-  std::vector<std::vector<int32_t>> result = {{1, 2}, {3, 4}};
-  const auto copy_of_result = result;
-  size_t num_ticks = 0;
-  EXPECT_THAT(ConvertInterleavedToTimeChannel(
-                  absl::MakeConstSpan(kEmptySamples), kNumChannels,
-                  kIdentityTransform, result, num_ticks),
-              IsOk());
-
-  // Result is not changed but the valid range (`num_ticks`) is zero, meaning
-  // none of the result should be used.
-  EXPECT_EQ(copy_of_result, result);
-  EXPECT_EQ(num_ticks, 0);
+  std::vector<std::vector<int32_t>> result(kNumChannels);
+  EXPECT_THAT(
+      ConvertInterleavedToChannelTime(absl::MakeConstSpan(kEmptySamples),
+                                      kNumChannels, kIdentityTransform, result),
+      IsOk());
+  for (const auto& channel : result) {
+    EXPECT_TRUE(channel.empty());
+  }
 }
 
-TEST(ConvertInterleavedToTimeChannel, InterleavesResults) {
+TEST(ConvertInterleavedToChannelTime, InterleavesResults) {
   constexpr size_t kNumChannels = 3;
   constexpr std::array<int32_t, 6> kTwoTicksOfThreeChannels{1, 2, 3, 4, 5, 6};
-  const std::vector<std::vector<int32_t>> kExpectedTwoTicksForThreeChannels = {
-      {1, 2, 3}, {4, 5, 6}};
-  std::vector<std::vector<int32_t>> result(2,
-                                           std::vector<int32_t>(kNumChannels));
-  size_t num_ticks = 0;
-  EXPECT_THAT(ConvertInterleavedToTimeChannel(
+  const std::vector<std::vector<int32_t>> kExpectedThreeChannelsOfTwoTicks = {
+      {1, 4}, {2, 5}, {3, 6}};
+  std::vector<std::vector<int32_t>> result(kNumChannels);
+  EXPECT_THAT(ConvertInterleavedToChannelTime(
                   absl::MakeConstSpan(kTwoTicksOfThreeChannels), kNumChannels,
-                  kIdentityTransform, result, num_ticks),
+                  kIdentityTransform, result),
               IsOk());
-  EXPECT_EQ(result, kExpectedTwoTicksForThreeChannels);
-  EXPECT_EQ(num_ticks, 2);
+  EXPECT_EQ(result, kExpectedThreeChannelsOfTwoTicks);
 }
 
-TEST(ConvertInterleavedToTimeChannel, AppliesTransform) {
+TEST(ConvertInterleavedToChannelTime, AppliesTransform) {
   const size_t kNumChannels = 2;
   constexpr std::array<int32_t, 4> kSamples = {1, 2, 3, 4};
-  const std::vector<std::vector<int32_t>> kExpectedResult = {{2, 4}, {6, 8}};
+  const std::vector<std::vector<int32_t>> kExpectedResult = {{2, 6}, {4, 8}};
   const absl::AnyInvocable<absl::Status(int32_t, int32_t&) const>
       kDoublingTransform = [](int32_t input, int32_t& output) {
         output = input * 2;
         return absl::OkStatus();
       };
-  std::vector<std::vector<int32_t>> result(2,
-                                           std::vector<int32_t>(kNumChannels));
-  size_t num_ticks = 0;
-  EXPECT_THAT(ConvertInterleavedToTimeChannel(absl::MakeConstSpan(kSamples),
-                                              kNumChannels, kDoublingTransform,
-                                              result, num_ticks),
-              IsOk());
+  std::vector<std::vector<int32_t>> result(kNumChannels);
+  EXPECT_THAT(
+      ConvertInterleavedToChannelTime(absl::MakeConstSpan(kSamples),
+                                      kNumChannels, kDoublingTransform, result),
+      IsOk());
   EXPECT_EQ(result, kExpectedResult);
-  EXPECT_EQ(num_ticks, 2);
 }
 
-TEST(ConvertTimeChannelToInterleaved,
-     FailsIfSamplesHaveAnUnevenNumberOfChannels) {
+TEST(ConvertChannelTimeToInterleaved, FailsIfSamplesHaveAnUnevenNumberOfTicks) {
   std::vector<std::vector<int32_t>> input = {{1, 2}, {3, 4, 5}};
   std::vector<int32_t> undefined_result;
 
   EXPECT_THAT(
-      ConvertTimeChannelToInterleaved(absl::MakeConstSpan(input),
+      ConvertChannelTimeToInterleaved(MakeSpanOfConstSpans(input),
                                       kIdentityTransform, undefined_result),
       StatusIs(absl::StatusCode::kInvalidArgument));
 }
 
-TEST(ConvertTimeChannelToInterleaved, PropagatesError) {
+TEST(ConvertChannelTimeToInterleaved, PropagatesError) {
   const absl::Status kError = absl::InternalError("Test error");
   const std::vector<std::vector<int32_t>> kInput = {{1, 2, 3}, {4, 5, 6}};
   const absl::AnyInvocable<absl::Status(int32_t, int32_t&) const>
@@ -257,45 +199,45 @@ TEST(ConvertTimeChannelToInterleaved, PropagatesError) {
   std::vector<int32_t> undefined_result;
 
   EXPECT_EQ(
-      ConvertTimeChannelToInterleaved(absl::MakeConstSpan(kInput),
+      ConvertChannelTimeToInterleaved(MakeSpanOfConstSpans(kInput),
                                       kAlwaysErrorTransform, undefined_result),
       kError);
 }
 
-TEST(ConvertTimeChannelToInterleaved, SucceedsOnEmptyInput) {
+TEST(ConvertChannelTimeToInterleaved, SucceedsOnEmptyInput) {
   const std::vector<std::vector<int32_t>> kEmptyInput;
   std::vector<int32_t> result;
 
-  EXPECT_THAT(ConvertTimeChannelToInterleaved(absl::MakeConstSpan(kEmptyInput),
+  EXPECT_THAT(ConvertChannelTimeToInterleaved(MakeSpanOfConstSpans(kEmptyInput),
                                               kIdentityTransform, result),
               IsOk());
   EXPECT_TRUE(result.empty());
 }
 
-TEST(ConvertTimeChannelToInterleaved, ClearsOutputVector) {
+TEST(ConvertChannelTimeToInterleaved, ClearsOutputVector) {
   const std::vector<std::vector<int32_t>> kInput = {{1}};
   std::vector<int32_t> result = {1, 2, 3};
   constexpr std::array<int32_t, 1> kExpectedResult{1};
 
-  EXPECT_THAT(ConvertTimeChannelToInterleaved(absl::MakeConstSpan(kInput),
+  EXPECT_THAT(ConvertChannelTimeToInterleaved(MakeSpanOfConstSpans(kInput),
                                               kIdentityTransform, result),
               IsOk());
   EXPECT_THAT(result, ElementsAreArray(kExpectedResult));
 }
 
-TEST(ConvertTimeChannelToInterleaved, InterleavesResult) {
-  const std::vector<std::vector<int32_t>> kInput = {{1, 2, 3}, {4, 5, 6}};
+TEST(ConvertChannelTimeToInterleaved, InterleavesResult) {
+  const std::vector<std::vector<int32_t>> kInput = {{1, 4}, {2, 5}, {3, 6}};
   std::vector<int32_t> result;
   constexpr std::array<int32_t, 6> kExpectedResult{1, 2, 3, 4, 5, 6};
 
-  EXPECT_THAT(ConvertTimeChannelToInterleaved(absl::MakeConstSpan(kInput),
+  EXPECT_THAT(ConvertChannelTimeToInterleaved(MakeSpanOfConstSpans(kInput),
                                               kIdentityTransform, result),
               IsOk());
   EXPECT_THAT(result, ElementsAreArray(kExpectedResult));
 }
 
-TEST(ConvertTimeChannelToInterleaved, AppliesTransform) {
-  const std::vector<std::vector<int32_t>> kInput = {{1, 2, 3}, {4, 5, 6}};
+TEST(ConvertChannelTimeToInterleaved, AppliesTransform) {
+  const std::vector<std::vector<int32_t>> kInput = {{1, 4}, {2, 5}, {3, 6}};
   std::vector<int32_t> result;
   const absl::AnyInvocable<absl::Status(int32_t, int32_t&) const>
       kDoublingTransform = [](int32_t input, int32_t& output) {
@@ -304,7 +246,7 @@ TEST(ConvertTimeChannelToInterleaved, AppliesTransform) {
       };
   constexpr std::array<int32_t, 6> kExpectedResult{2, 4, 6, 8, 10, 12};
 
-  EXPECT_THAT(ConvertTimeChannelToInterleaved(absl::MakeConstSpan(kInput),
+  EXPECT_THAT(ConvertChannelTimeToInterleaved(MakeSpanOfConstSpans(kInput),
                                               kDoublingTransform, result),
               IsOk());
   EXPECT_THAT(result, ElementsAreArray(kExpectedResult));
diff --git a/iamf/include/iamf_tools/BUILD b/iamf/include/iamf_tools/BUILD
new file mode 100644
index 0000000..7a68e54
--- /dev/null
+++ b/iamf/include/iamf_tools/BUILD
@@ -0,0 +1,15 @@
+filegroup(
+    name = "iamf_decoder_header",
+    srcs = ["iamf_decoder.h"],
+    visibility = [
+        "//iamf/api/decoder:__pkg__",
+    ],
+)
+
+filegroup(
+    name = "iamf_tools_api_types_header",
+    srcs = ["iamf_tools_api_types.h"],
+    visibility = [
+        "//iamf/api:__pkg__",
+    ],
+)
diff --git a/iamf/include/iamf_tools/iamf_decoder.h b/iamf/include/iamf_tools/iamf_decoder.h
new file mode 100644
index 0000000..d926026
--- /dev/null
+++ b/iamf/include/iamf_tools/iamf_decoder.h
@@ -0,0 +1,313 @@
+/*
+ * Copyright (c) 2024, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#ifndef API_DECODER_IAMF_DECODER_H_
+#define API_DECODER_IAMF_DECODER_H_
+
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <unordered_set>
+#include <vector>
+
+#include "iamf_tools_api_types.h"
+
+namespace iamf_tools {
+namespace api {
+
+/*!\brief The class and entrypoint for decoding IAMF bitstreams.
+ * WARNING: API is currently in flux and will change.
+ *
+ * The functions below constitute our IAMF Iterative Decoder API. Below is a
+ * sample usage of the API.
+ *
+ * Reconfigurable Standalone IAMF Usage
+ *
+ * IamfDecoderSettings settings = {
+ *   .requested_layout = OutputLayout::kItu2051_SoundSystemA_0_2_0,
+ * };
+ * StatusOr<IamfDecoder> decoder = IamfDecoder::Create(settings);
+ * for chunk of data in iamf stream:
+ *    decoder.Decode()
+ *    if (IsDescriptorProcessingComplete()) {
+ *      decoder.ConfigureOutputSampleType(output_sample_type)
+ *    }
+ * for chunk of data in iamf stream:
+ *    decoder.Decode(chunk)
+ *    while (decoder.IsTemporalUnitAvailable()) {
+ *      decoder.GetOutputTemporalUnit(output_buffer, bytes_written)
+ *      Playback(output_buffer)
+ *    }
+ * if (end_of_stream):
+ *    decoder.SignalEndOfStream()
+ *    // Get remaining audio
+ *    while (decoder.IsTemporalUnitAvailable()) {
+ *      decoder.GetOutputTemporalUnit(output_buffer, bytes_written)
+ *      Playback(output_buffer)
+ *    }
+ * decoder.Close();
+ */
+class IamfDecoder {
+ public:
+  /*!\brief Settings for the `IamfDecoder`. */
+  struct Settings {
+    // Specifies the desired output layout. This layout will be used so long as
+    // it is present in the Descriptor OBUs that are provided. If not, after
+    // `IsDescriptorProcessingComplete` returns true, a default layout will have
+    // been selected and retrievable via `GetOutputLayout`.
+    OutputLayout requested_layout = OutputLayout::kItu2051_SoundSystemA_0_2_0;
+
+    // Specify a different ordering for the output samples.  Only specific
+    // orderings are available, custom or granular control is not possible.
+    ChannelOrdering channel_ordering = ChannelOrdering::kIamfOrdering;
+
+    // Specifies the desired profile versions. Clients should explicitly provide
+    // the profiles they are interested in. Otherwise, the default value will
+    // evolve in the future, based on recommendations or additions to the IAMF
+    // spec.
+    //
+    // If the descriptor OBUs do not contain a mix presentation which is
+    // suitable for one of the matching profiles the decoder will return an
+    // error. Typically all profiles the client is capable of handling should
+    // be provided, to ensure compatibility with as many mixes as possible.
+    std::unordered_set<ProfileVersion> requested_profile_versions = {
+        ProfileVersion::kIamfSimpleProfile, ProfileVersion::kIamfBaseProfile,
+        ProfileVersion::kIamfBaseEnhancedProfile};
+  };
+
+  // Dtor cannot be inline (so it must be declared and defined in the source
+  // file) because this class holds a (unique) pointer to the partial class,
+  // DecoderState.  Moves must be declared and defined because dtor is defined.
+  ~IamfDecoder();
+  IamfDecoder(IamfDecoder&&);
+  IamfDecoder& operator=(IamfDecoder&&);
+
+  /*!\brief Creates an IamfDecoder.
+   *
+   * This function should be used for pure streaming applications in which the
+   * descriptor OBUs are not known in advance.
+   *
+   * \param settings Settings to configure the decoder.
+   * \param output_decoder An output param for the decoder upon success.
+   * \return Ok status upon success. Other specific statuses on  failure.
+   */
+  static IamfStatus Create(const IamfDecoder::Settings& settings,
+                           std::unique_ptr<IamfDecoder>& output_decoder);
+
+  /*!\brief Creates an IamfDecoder from a known set of descriptor OBUs.
+   *
+   * This function should be used for applications in which the descriptor OBUs
+   * are known in advance. When creating the decoder via this mode, future calls
+   * to decode must pass complete temporal units.
+   *
+   * \param settings Settings to configure the decoder.
+   * \param input_buffer Bitstream containing all the descriptor OBUs and
+   *        only descriptor OBUs.
+   * \param input_buffer_size Size in bytes of the input buffer.
+   * \param output_decoder An output param for the decoder upon success.
+   * \return Ok status upon success. Other specific statuses on failure.
+   */
+  static IamfStatus CreateFromDescriptors(
+      const IamfDecoder::Settings& settings, const uint8_t* input_buffer,
+      size_t input_buffer_size, std::unique_ptr<IamfDecoder>& output_decoder);
+
+  /*!\brief Configures the decoder with the desired bit depth.
+   *
+   * Call this method to specify a specific output sample type.  If it is not
+   * called, the output samples will be a default value, retrievable by
+   * `GetOutputSampleType`.
+   */
+  void ConfigureOutputSampleType(OutputSampleType output_sample_type);
+
+  /*!\brief Decodes the bitstream provided.
+   *
+   * Supports both descriptor OBUs, temporal units, and partial versions of
+   * both. User can provide as much data as they would like. To receive decoded
+   * temporal units, GetOutputTemporalUnit() should be called. If
+   * GetOutputTemporalUnit() has not been called, this function guarantees that
+   * any temporal units received thus far have not been lost. If descriptors are
+   * processed for the first time, function will exit before processing any
+   * temporal units. This provides the user a chance to configure the decoder as
+   * they see fit. See sample usages for more details.
+   *
+   * \param input_buffer Bitstream to decode.
+   * \param input_buffer_size Size in bytes of the input buffer.
+   * \return Ok status upon success. Other specific statuses on failure.
+   */
+  IamfStatus Decode(const uint8_t* input_buffer, size_t input_buffer_size);
+
+  /*!\brief Outputs the next temporal unit of decoded audio.
+   *
+   * If no decoded data is available, bytes_written will be 0. The user can
+   * continue calling until bytes_written is 0, as there may be more than one
+   * temporal unit available. At this point, the user should call Decode() again
+   * with more data.
+   *
+   * The output PCM is arranged based on the configured `OutputLayout` and
+   * `OutputSampleType`.
+   *
+   * \param output_buffer Output buffer to receive bytes.  Must be large enough
+   *        to receive bytes.  Maximum necessary size can be determined by
+   *        GetFrameSize * GetNumberOfOutputChannels * bit depth (as determined
+   *        by GetOutputSampleType).
+   * \param output_buffer_size Available size in bytes of the output buffer.
+   * \param bytes_written Output param for the number of bytes written to the
+   * output_bytes.
+   * \return Ok status upon success. Other specific statuses on failure.
+   */
+  IamfStatus GetOutputTemporalUnit(uint8_t* output_buffer,
+                                   size_t output_buffer_size,
+                                   size_t& bytes_written);
+
+  /*!\brief Returns true iff a decoded temporal unit is available.
+   *
+   * This function can be used to determine when the user should call
+   * GetOutputTemporalUnit().
+   *
+   * \return true iff a decoded temporal unit is available.
+   */
+  bool IsTemporalUnitAvailable() const;
+
+  /*!\brief Returns true iff the descriptor OBUs have been parsed.
+   *
+   * This function can be used for determining when configuration setters that
+   * rely on Descriptor OBU parsing can be called.
+   *
+   * \return true iff the Descriptor OBUs have been parsed.
+   */
+  bool IsDescriptorProcessingComplete() const;
+
+  /*!\brief Gets the layout that will be used to render the audio.
+   *
+   * The actual Layout used for rendering may not the same as requested when
+   * creating the IamfDecoder, if the requested Layout could not be used.
+   * This function allows verifying the actual Layout used after Descriptor OBU
+   * parsing is complete.
+   *
+   * This function can only be used after all Descriptor OBUs have been parsed,
+   * i.e. IsDescriptorProcessingComplete() returns true.
+   *
+   * \param output_layout Output param for the layout upon success.
+   * \return Ok status upon success. Other specific statuses on failure.
+   */
+  IamfStatus GetOutputLayout(OutputLayout& output_layout) const;
+
+  /*!\brief Gets the number of output channels.
+   *
+   * This function can only be used after all Descriptor OBUs have been parsed,
+   * i.e. IsDescriptorProcessingComplete() returns true.
+   *
+   * \param output_num_channels Output param for the number of output channels
+   * upon success.
+   * \return Ok status upon success. Other specific statuses on failure.
+   */
+  IamfStatus GetNumberOfOutputChannels(int& output_num_channels) const;
+
+  /*!\brief Returns the current OutputSampleType.
+   *
+   * The value is either the value set by ConfigureOutputSampleType or a default
+   * which may vary based on content.
+   *
+   * This function can only be used after all Descriptor OBUs have been parsed,
+   * i.e. IsDescriptorProcessingComplete() returns true.
+   */
+  OutputSampleType GetOutputSampleType() const;
+
+  /*!\brief Gets the sample rate.
+   *
+   * This function can only be used after all Descriptor OBUs have been parsed,
+   * i.e. IsDescriptorProcessingComplete() returns true.
+   *
+   * \param output_sample_rate Output param for the sample rate upon success.
+   * \return Ok status upon success. Other specific statuses on failure.
+   */
+  IamfStatus GetSampleRate(uint32_t& output_sample_rate) const;
+
+  /*!\brief Gets the number of samples per frame.
+   *
+   * This function can only be used after all Descriptor OBUs have been parsed,
+   * i.e. IsDescriptorProcessingComplete() returns true.
+   *
+   * Returns the number of samples per frame per channel of the output audio.
+   * The total number of samples in a frame is the number of channels times
+   * this number, the frame size.
+   *
+   * \param output_frame_size Output param for the frame size upon success.
+   * \return Ok status upon success. Other specific statuses on failure.
+   */
+  IamfStatus GetFrameSize(uint32_t& output_frame_size) const;
+
+  /*!\brief Resets the decoder to a clean state ready to decode new data.
+   *
+   * A clean state refers to a state in which descriptors OBUs have been parsed,
+   * but no other data has been parsed.
+   *
+   * This function can only be used after all Descriptor OBUs have been parsed,
+   * i.e. IsDescriptorProcessingComplete() returns true.
+   *
+   * This function will result in all decoded temporal units that have not been
+   * retrieved by GetOutputTemporalUnit() to be lost. It will also result in any
+   * pending data in the internal buffer being lost.
+   *
+   * return Ok status upon success. Other specific statuses on failure.
+   */
+  IamfStatus Reset();
+
+  /*!\brief Resets the decoder with a new layout and a clean state.
+   *
+   * A clean state refers to a state in which descriptors OBUs have been parsed,
+   * but no other data has been parsed. If possible, the decoder will use the
+   * new layout for decoding. To confirm the actual layout that will be used,
+   * GetOutputLayout() should be called before continuing to decode.
+   *
+   * This function can only be used if the decoder was created with
+   * CreateFromDescriptors().
+   *
+   * This function will result in all decoded temporal units that have not been
+   * retrieved by GetOutputTemporalUnit() to be lost. It will also result in any
+   * pending data in the internal buffer being lost.
+   *
+   * return Ok status upon success. Other specific statuses on failure.
+   */
+  IamfStatus ResetWithNewLayout(OutputLayout output_layout);
+
+  /*!\brief Signals to the decoder that no more data will be provided.
+   *
+   * Decode cannot be called after this method has been called, unless Reset()
+   * is called first.
+   */
+  void SignalEndOfDecoding();
+
+  /*!\brief Closes the decoder.
+   *
+   * This should be called once the user has finished providing data into
+   * Decode(), has called SignalEndOfStream(), and gotten all output units.
+   * Will close all underlying decoders.
+   *
+   * \return Ok status upon success. Other specific statuses on failure.
+   */
+  IamfStatus Close();
+
+ private:
+  // Forward declaration of the internal state of the decoder.
+  struct DecoderState;
+
+  // Private constructor only used by Create functions.
+  IamfDecoder(std::unique_ptr<DecoderState> state);
+
+  // Internal state of the decoder.
+  std::unique_ptr<DecoderState> state_;
+};
+}  // namespace api
+}  // namespace iamf_tools
+
+#endif  // API_DECODER_IAMF_DECODER_H_
diff --git a/iamf/include/iamf_tools/iamf_tools_api_types.h b/iamf/include/iamf_tools/iamf_tools_api_types.h
new file mode 100644
index 0000000..8e577a7
--- /dev/null
+++ b/iamf/include/iamf_tools/iamf_tools_api_types.h
@@ -0,0 +1,154 @@
+/*
+ * Copyright (c) 2025, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 3-Clause Clear License
+ * and the Alliance for Open Media Patent License 1.0. If the BSD 3-Clause Clear
+ * License was not distributed with this source code in the LICENSE file, you
+ * can obtain it at www.aomedia.org/license/software-license/bsd-3-c-c. If the
+ * Alliance for Open Media Patent License 1.0 was not distributed with this
+ * source code in the PATENTS file, you can obtain it at
+ * www.aomedia.org/license/patent.
+ */
+
+#ifndef API_DECODER_TYPES_H_
+#define API_DECODER_TYPES_H_
+
+#include <cstdint>
+#include <ostream>
+#include <string>
+#include <vector>
+
+namespace iamf_tools {
+namespace api {
+
+/*!\brief Indicates the result of a method that can fail. */
+// TODO(b/408003095): Add test coverage for this struct.
+struct [[nodiscard]] IamfStatus {
+  const bool success = true;
+  const std::string error_message;
+
+  // Construct a success Status.
+  static IamfStatus OkStatus();
+  // Construct a failure Status.
+  static IamfStatus ErrorStatus(const std::string& error_message);
+
+  // Convenience method for checking results.
+  bool ok() const { return success; }
+
+ private:
+  IamfStatus() = default;
+  IamfStatus(const std::string& error_message);
+};
+
+std::ostream& operator<<(std::ostream& os, const IamfStatus& status);
+
+/*!\brief Indicates the profile version to decode.
+ *
+ * Profiles are defined in the IAMF spec:
+ * https://aomediacodec.github.io/iamf/#obu-iasequenceheader.
+ */
+enum class ProfileVersion {
+  // Simple profile as defined in IAMF v1.0.0-errata.
+  kIamfSimpleProfile = 0,
+  // Base profile as defined in IAMF v1.0.0-errata.
+  kIamfBaseProfile = 1,
+  // Base-Enhanced profile as defined in IAMF v1.1.0.
+  kIamfBaseEnhancedProfile = 2,
+};
+
+/*!\brief Determines the layout of the output file.
+ *
+ * Typically these correspond with `sound_system`s in the IAMF spec
+ * (https://aomediacodec.github.io/iamf/#syntax-layout).
+ *
+ * Generally, the ordering of channels is based on the related
+ * [ITU-2051-3](https://www.itu.int/rec/R-REC-BS.2051) layout.
+ */
+enum class OutputLayout {
+  // ITU-R B.S. 2051-3 sound system A (0+2+0), commonly known as Stereo.
+  // Ordered as [L, R].
+  kItu2051_SoundSystemA_0_2_0 = 0,
+
+  // ITU-R B.S. 2051-3 sound system B (0+5+0), commonly known as 5.1.
+  // Ordered as [L, R, C, LFE, Ls, Rs].
+  kItu2051_SoundSystemB_0_5_0 = 1,
+
+  // ITU-R B.S. 2051-3 sound system C (2+5+0), commonly known as 5.1.2.
+  // Ordered as [L, R, C, LFE, Ls, Rs, Ltf, Rtf].
+  kItu2051_SoundSystemC_2_5_0 = 2,
+
+  // ITU-R B.S. 2051-3 sound system D (4+5+0), commonly known as 5.1.4.
+  // Ordered as [L, R, C, LFE, Ls, Rs, Ltf, Rtf, Ltr, Rtr].
+  kItu2051_SoundSystemD_4_5_0 = 3,
+
+  // ITU-R B.S. 2051-3 sound system E (4+5+1).
+  // Ordered as [L, R, C, LFE, Ls, Rs, Ltf, Rtf, Ltr, Rtr, Cbf].
+  kItu2051_SoundSystemE_4_5_1 = 4,
+
+  // ITU-R B.S. 2051-3 sound system F (3+7+0).
+  // Ordered as [C, L, R, LH, RH, LS, RS, LB, RB, CH, LFE1, LFE2].
+  kItu2051_SoundSystemF_3_7_0 = 5,
+
+  // ITU-R B.S. 2051-3 sound system G (4+9+0).
+  // Ordered as [L, R, C, LFE, Lss, Rss, Lrs, Rrs, Ltf, Rtf, Ltb, Rtb, Lsc,
+  // Rsc].
+  kItu2051_SoundSystemG_4_9_0 = 6,
+
+  // ITU-R B.S. 2051-3 sound system H (9+10+3).
+  // Ordered as [FL, FR, FC, LFE1, BL, BR, FLc, FRc, BC, LFE2, SiL, SiR, TpFL,
+  // TpFR, TpFC, TpC, TpBL, TpBR, TpSiL, TpSiR, TpBC, BtFC, BtFL, BtFR].
+  kItu2051_SoundSystemH_9_10_3 = 7,
+
+  // ITU-R B.S. 2051-3 sound system I (0+7+0), commonly known as 7.1.
+  // Ordered as [L, R, C, LFE, Lss, Rss, Lrs, Rrs].
+  kItu2051_SoundSystemI_0_7_0 = 8,
+
+  // ITU-R B.S. 2051-3 sound system J (4+7+0), commonly known as 7.1.4.
+  // Ordered as [L, R, C, LFE, Lss, Rss, Lrs, Rrs, Ltf, Rtf, Ltb, Rtb].
+  kItu2051_SoundSystemJ_4_7_0 = 9,
+
+  // IAMF extension 7.1.2.
+  // Ordered as [L, R, C, LFE, Lss, Rss, Lrs, Rrs, Ltf, Rtf].
+  kIAMF_SoundSystemExtension_2_7_0 = 10,
+
+  // IAMF extension 3.1.2.
+  // Ordered as [L, R, C, LFE, Ltf, Rtf].
+  kIAMF_SoundSystemExtension_2_3_0 = 11,
+
+  // Mono.
+  // Ordered as [C].
+  kIAMF_SoundSystemExtension_0_1_0 = 12,
+
+  // IAMF Extension 9.1.6.
+  // Ordered as [FL, FR, FC, LFE, BL, BR, FLc, FRc, SiL, SiR, TpFL, TpFR, TpBL,
+  // TpBR, TpSiL, TpSiR].
+  kIAMF_SoundSystemExtension_6_9_0 = 13,
+};
+
+/*!\brief The requested format of the output samples. */
+enum class OutputSampleType {
+  // Interleaved little endian signed 16-bit, ordered based on the
+  // `OutputLayout`.
+  kInt16LittleEndian = 1,
+
+  // Interleaved little endian signed 32-bit, ordered based on the
+  // `OutputLayout`.
+  kInt32LittleEndian = 2,
+};
+
+enum class ChannelOrdering {
+  // Ordering as specified in the above OutputLayout enum, in the ITU/IAMF
+  // order.
+  // This is the default behaviour.
+  kIamfOrdering = 0,
+  // Ordering to match that found in Android's AudioFormat.java.  See
+  // https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/media/java/android/media/AudioFormat.java
+  // Also matches Windows/WAVE for the channels that are defined. See
+  // https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ksmedia/ns-ksmedia-waveformatextensible
+  kOrderingForAndroid = 1,
+};
+
+}  // namespace api
+}  // namespace iamf_tools
+
+#endif  // API_DECODER_TYPES_H_
diff --git a/iamf/obu/BUILD b/iamf/obu/BUILD
index 7ba1922..f237b67 100644
--- a/iamf/obu/BUILD
+++ b/iamf/obu/BUILD
@@ -10,6 +10,7 @@ cc_library(
     deps = [
         ":obu_base",
         ":obu_header",
+        ":types",
         "//iamf/common:read_bit_buffer",
         "//iamf/common:write_bit_buffer",
         "//iamf/common/utils:macros",
diff --git a/iamf/obu/arbitrary_obu.h b/iamf/obu/arbitrary_obu.h
index d6bc771..bdf6861 100644
--- a/iamf/obu/arbitrary_obu.h
+++ b/iamf/obu/arbitrary_obu.h
@@ -22,6 +22,7 @@
 #include "iamf/common/write_bit_buffer.h"
 #include "iamf/obu/obu_base.h"
 #include "iamf/obu/obu_header.h"
+#include "iamf/obu/types.h"
 
 namespace iamf_tools {
 
@@ -58,11 +59,11 @@ class ArbitraryObu : public ObuBase {
    * \param invalidates_bitstream Whether writing the OBU invalidates the
    *        bitstream.
    */
-  ArbitraryObu(ObuType obu_type, const ObuHeader& header,
-               const std::vector<uint8_t>& payload,
-               InsertionHook insertion_hook,
-               const std::optional<int64_t>& insertion_tick = std::nullopt,
-               bool invalidates_bitstream = false)
+  ArbitraryObu(
+      ObuType obu_type, const ObuHeader& header,
+      const std::vector<uint8_t>& payload, InsertionHook insertion_hook,
+      const std::optional<InternalTimestamp>& insertion_tick = std::nullopt,
+      bool invalidates_bitstream = false)
       : ObuBase(header, obu_type),
         payload_(payload),
         insertion_hook_(insertion_hook),
@@ -94,7 +95,7 @@ class ArbitraryObu : public ObuBase {
 
   // Metadata.
   const InsertionHook insertion_hook_;
-  const std::optional<int64_t> insertion_tick_;
+  const std::optional<InternalTimestamp> insertion_tick_;
   const bool invalidates_bitstream_;
 
  private:
diff --git a/iamf/obu/decoder_config/flac_decoder_config.cc b/iamf/obu/decoder_config/flac_decoder_config.cc
index e57df77..68199da 100644
--- a/iamf/obu/decoder_config/flac_decoder_config.cc
+++ b/iamf/obu/decoder_config/flac_decoder_config.cc
@@ -12,7 +12,6 @@
 #include "iamf/obu/decoder_config/flac_decoder_config.h"
 
 #include <cstdint>
-#include <functional>
 #include <utility>
 #include <vector>
 
@@ -44,33 +43,36 @@ absl::Status GetStreamInfo(const FlacDecoderConfig& decoder_config,
   return absl::OkStatus();
 }
 
-using Cons = FlacStreamInfoConstraints;
+using StrictCons = FlacStreamInfoStrictConstraints;
 
 absl::Status ValidateSampleRate(uint32_t sample_rate) {
   return ValidateInRange(
-      sample_rate, {Cons::kMinSampleRate, Cons::kMaxSampleRate}, "sample_rate");
+      sample_rate, {StrictCons::kMinSampleRate, StrictCons::kMaxSampleRate},
+      "sample_rate");
 }
 
 absl::Status ValidateBitsPerSample(uint8_t bits_per_sample) {
   // Validate restrictions from the FLAC specification.
-  return ValidateInRange(bits_per_sample,
-                         {Cons::kMinBitsPerSample, Cons::kMaxBitsPerSample},
-                         "bits_per_sample");
+  return ValidateInRange(
+      bits_per_sample,
+      {StrictCons::kMinBitsPerSample, StrictCons::kMaxBitsPerSample},
+      "bits_per_sample");
 }
 
 absl::Status ValidateTotalSamplesInStream(uint64_t total_samples_in_stream) {
   // The FLAC specification treats this as a 36-bit value which is always valid,
   // but in `iamf_tools` it could be out of bounds because it is stored as a
   // `uint64_t`.
-  return ValidateInRange(
-      total_samples_in_stream,
-      {Cons::kMinTotalSamplesInStream, Cons::kMaxTotalSamplesInStream},
-      "total_samples_in_stream");
+  return ValidateInRange(total_samples_in_stream,
+                         {StrictCons::kMinTotalSamplesInStream,
+                          StrictCons::kMaxTotalSamplesInStream},
+                         "total_samples_in_stream");
 }
 
-// Validates the `FlacDecoderConfig`.
-absl::Status ValidatePayload(uint32_t num_samples_per_frame,
-                             const FlacDecoderConfig& decoder_config) {
+// Validates the `FlacDecoderConfig` for decoding. To be robust and encode files
+// that are not valid, some restrictions are relaxed.
+absl::Status ValidateDecodingRestrictions(
+    uint32_t num_samples_per_frame, const FlacDecoderConfig& decoder_config) {
   for (int i = 0; i < decoder_config.metadata_blocks_.size(); i++) {
     const bool last_metadata_block_flag =
         decoder_config.metadata_blocks_[i].header.last_metadata_block_flag;
@@ -91,13 +93,6 @@ absl::Status ValidatePayload(uint32_t num_samples_per_frame,
   RETURN_IF_NOT_OK(ValidateSampleRate(stream_info->sample_rate));
   RETURN_IF_NOT_OK(ValidateBitsPerSample(stream_info->bits_per_sample));
 
-  RETURN_IF_NOT_OK(Validate(stream_info->minimum_block_size,
-                            std::greater_equal{}, Cons::kMinMinAndMaxBlockSize,
-                            "minimum_block_size >="));
-  RETURN_IF_NOT_OK(Validate(stream_info->maximum_block_size,
-                            std::greater_equal{}, Cons::kMinMinAndMaxBlockSize,
-                            "maximum_block_size >="));
-
   // IAMF restricts some fields.
   RETURN_IF_NOT_OK(
       ValidateEqual(static_cast<uint32_t>(stream_info->maximum_block_size),
@@ -105,18 +100,37 @@ absl::Status ValidatePayload(uint32_t num_samples_per_frame,
   RETURN_IF_NOT_OK(
       ValidateEqual(static_cast<uint32_t>(stream_info->minimum_block_size),
                     num_samples_per_frame, "minimum_block_size"));
-  RETURN_IF_NOT_OK(ValidateEqual(stream_info->minimum_frame_size,
-                                 Cons::kMinFrameSize, "minimum_frame_size"));
-  RETURN_IF_NOT_OK(ValidateEqual(stream_info->maximum_frame_size,
-                                 Cons::kMaxFrameSize, "maximum_frame_size"));
 
   RETURN_IF_NOT_OK(ValidateEqual(stream_info->number_of_channels,
-                                 Cons::kNumberOfChannels,
+                                 StrictCons::kNumberOfChannels,
                                  "number_of_channels"));
 
-  RETURN_IF_NOT_OK(ValidateTotalSamplesInStream(stream_info->bits_per_sample));
+  return ValidateTotalSamplesInStream(stream_info->total_samples_in_stream);
+}
+
+// Validates the `FlacDecoderConfig` for encoding, typically we want to enforce
+// both the strict and looser constraints. It's best not to encode or allow
+// producing files that are strange.
+absl::Status ValidateEncodingRestrictions(
+    uint32_t num_samples_per_frame, const FlacDecoderConfig& decoder_config) {
+  // Validate the stricter stricter constaints also used when decoding.
+  RETURN_IF_NOT_OK(
+      ValidateDecodingRestrictions(num_samples_per_frame, decoder_config));
+  using LooseCons = FlacStreamInfoLooseConstraints;
+
+  const FlacMetaBlockStreamInfo* stream_info;
+  RETURN_IF_NOT_OK(GetStreamInfo(decoder_config, &stream_info));
+
+  // The IAMF spec instruct there values "SHOULD" agree. During encoding we take
+  // this strictly, to avoid producing files that are strange.
+  RETURN_IF_NOT_OK(ValidateEqual(stream_info->minimum_frame_size,
+                                 LooseCons::kMinFrameSize,
+                                 "minimum_frame_size"));
+  RETURN_IF_NOT_OK(ValidateEqual(stream_info->maximum_frame_size,
+                                 LooseCons::kMaxFrameSize,
+                                 "maximum_frame_size"));
 
-  if (stream_info->md5_signature != Cons::kMd5Signature) {
+  if (stream_info->md5_signature != LooseCons::kMd5Signature) {
     return absl::InvalidArgumentError("Invalid md5_signature.");
   }
 
@@ -182,7 +196,7 @@ absl::Status FlacDecoderConfig::ValidateAndWrite(uint32_t num_samples_per_frame,
                                                  WriteBitBuffer& wb) const {
   MAYBE_RETURN_IF_NOT_OK(ValidateAudioRollDistance(audio_roll_distance));
 
-  RETURN_IF_NOT_OK(ValidatePayload(num_samples_per_frame, *this));
+  RETURN_IF_NOT_OK(ValidateEncodingRestrictions(num_samples_per_frame, *this));
 
   for (const auto& metadata_block : metadata_blocks_) {
     RETURN_IF_NOT_OK(wb.WriteUnsignedLiteral(
@@ -254,7 +268,7 @@ absl::Status FlacDecoderConfig::ReadAndValidate(uint32_t num_samples_per_frame,
     }
     metadata_blocks_.push_back(std::move(metadata_block));
   }
-  RETURN_IF_NOT_OK(ValidatePayload(num_samples_per_frame, *this));
+  RETURN_IF_NOT_OK(ValidateDecodingRestrictions(num_samples_per_frame, *this));
   return absl::OkStatus();
 }
 
diff --git a/iamf/obu/decoder_config/flac_decoder_config.h b/iamf/obu/decoder_config/flac_decoder_config.h
index 41c1bde..686ab0b 100644
--- a/iamf/obu/decoder_config/flac_decoder_config.h
+++ b/iamf/obu/decoder_config/flac_decoder_config.h
@@ -23,7 +23,12 @@
 
 namespace iamf_tools {
 
-struct FlacStreamInfoConstraints {
+/*!\brief Strict constraints for the IAMF or FLAC spec.
+ *
+ * Typically these are "SHALL" requirements from either the FLAC or IAMF spec.
+ * These are used to enforce in all modes.
+ */
+struct FlacStreamInfoStrictConstraints {
   // Required 0 audio_roll_distance as per IAMF spec.
   static constexpr int16_t kAudioRollDistance = 0;
 
@@ -31,18 +36,11 @@ struct FlacStreamInfoConstraints {
   // FLAC spec.
   static constexpr uint16_t kMinMinAndMaxBlockSize = 16;
 
-  // IAMF requires frame_size fields to have fixed values.
-  static constexpr uint32_t kMinFrameSize = 0;
-  static constexpr uint32_t kMaxFrameSize = 0;
-
   // In IAMF the number_of_channels is fixed to `1`, but can be ignored when
   // reading / decoding. The actual number of channels is determined on a
   // per-substream basis based on the audio element.
   static constexpr uint8_t kNumberOfChannels = 1;
 
-  // Required signature, as per IAMF spec.
-  static constexpr std::array<uint8_t, 16> kMd5Signature = {0};
-
   // Acceptable ranges for sample_rate, bits_per_sample, and
   // totals_samples_in_stream from the FLAC documentation.
   static constexpr uint32_t kMinSampleRate = 1;
@@ -54,6 +52,21 @@ struct FlacStreamInfoConstraints {
   static constexpr uint64_t kMaxTotalSamplesInStream = 0xfffffffff;
 };
 
+/*!\brief Loose constraints for the IAMF or FLAC spec.
+ *
+ * Typically these are "SHOULD" requirements from either the FLAC or IAMF spec.
+ * These requirements are enforced loosely to allow some components to handle
+ * bitstreams which may not strictly follow the spec recommendations.
+ */
+struct FlacStreamInfoLooseConstraints {
+  // The IAMF spec notes these SHOULD have fixed values.
+  static constexpr uint32_t kMinFrameSize = 0;
+  static constexpr uint32_t kMaxFrameSize = 0;
+
+  // The IAMF spec notes that the md5_signature SHOULD be fixed to zero.
+  static constexpr std::array<uint8_t, 16> kMd5Signature = {0};
+};
+
 struct FlacMetaBlockStreamInfo {
   friend bool operator==(const FlacMetaBlockStreamInfo& lhs,
                          const FlacMetaBlockStreamInfo& rhs) = default;
@@ -61,16 +74,16 @@ struct FlacMetaBlockStreamInfo {
   uint16_t minimum_block_size;
   uint16_t maximum_block_size;
   uint32_t minimum_frame_size =
-      FlacStreamInfoConstraints::kMinFrameSize;  // 24 bits.
+      FlacStreamInfoLooseConstraints::kMinFrameSize;  // 24 bits.
   uint32_t maximum_frame_size =
-      FlacStreamInfoConstraints::kMaxFrameSize;  // 24 bits.
-  uint32_t sample_rate;                          // 20 bits.
+      FlacStreamInfoLooseConstraints::kMaxFrameSize;  // 24 bits.
+  uint32_t sample_rate;                               // 20 bits.
   uint8_t number_of_channels =
-      FlacStreamInfoConstraints::kNumberOfChannels;  // 3 bits.
-  uint8_t bits_per_sample;                           // 5 bits.
-  uint64_t total_samples_in_stream;                  // 36 bits.
+      FlacStreamInfoStrictConstraints::kNumberOfChannels;  // 3 bits.
+  uint8_t bits_per_sample;                                 // 5 bits.
+  uint64_t total_samples_in_stream;                        // 36 bits.
   std::array<uint8_t, 16> md5_signature =
-      FlacStreamInfoConstraints::kMd5Signature;
+      FlacStreamInfoLooseConstraints::kMd5Signature;
 };
 
 /*!\brief The header portion of a metadata block described in the FLAC spec. */
@@ -120,7 +133,7 @@ class FlacDecoderConfig {
    * \return Audio roll distance required by the IAMF spec.
    */
   static int16_t GetRequiredAudioRollDistance() {
-    return FlacStreamInfoConstraints::kAudioRollDistance;
+    return FlacStreamInfoStrictConstraints::kAudioRollDistance;
   }
 
   /*!\brief Validates and writes the `FlacDecoderConfig` to a buffer.
diff --git a/iamf/obu/decoder_config/tests/aac_decoder_config_test.cc b/iamf/obu/decoder_config/tests/aac_decoder_config_test.cc
index 746f46c..36d1617 100644
--- a/iamf/obu/decoder_config/tests/aac_decoder_config_test.cc
+++ b/iamf/obu/decoder_config/tests/aac_decoder_config_test.cc
@@ -203,8 +203,7 @@ TEST(AudioSpecificConfig, ReadsWithImplicitSampleFrequency64000) {
       kLowerByteSerializedSamplingFrequencyIndex64000 |
           kChannelConfigurationAndGaSpecificConfigMask};
   AudioSpecificConfig audio_specific_config;
-  auto rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+  auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
 
   EXPECT_THAT(audio_specific_config.Read(*rb), IsOk());
 
@@ -233,7 +232,7 @@ TEST(AudioSpecificConfig, ReadsWithImplicitSampleFrequency24000) {
       kLowerByteSerializedSamplingFrequencyIndex24000 |
           kChannelConfigurationAndGaSpecificConfigMask};
   AudioSpecificConfig audio_specific_config;
-  auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(1024, data);
+  auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(data);
 
   EXPECT_THAT(audio_specific_config.Read(*rb), IsOk());
 
@@ -257,8 +256,7 @@ TEST(AudioSpecificConfig, ReadsWithExplicitSampleFrequency) {
       // `frame_length_flag`, `depends_on_core_coder`, `extension_flag`.
       ((kSampleFrequency & 1)) | kChannelConfigurationAndGaSpecificConfigMask};
   AudioSpecificConfig audio_specific_config;
-  auto rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+  auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
 
   EXPECT_THAT(audio_specific_config.Read(*rb), IsOk());
 
@@ -296,8 +294,7 @@ TEST(AacDecoderConfig, ReadAndValidateReadsAllFields) {
       kLowerByteSerializedSamplingFrequencyIndex64000 |
           kChannelConfigurationAndGaSpecificConfigMask};
   AacDecoderConfig decoder_config;
-  auto rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+  auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
 
   EXPECT_THAT(decoder_config.ReadAndValidate(kAudioRollDistance, *rb), IsOk());
 
@@ -353,8 +350,7 @@ TEST(AacDecoderConfig, ReadAndValidateWithExplicitSampleFrequency) {
       // `frame_length_flag`, `depends_on_core_coder`, `extension_flag`.
       ((48000 & 1)) | kChannelConfigurationAndGaSpecificConfigMask};
   AacDecoderConfig decoder_config;
-  auto rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+  auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
 
   EXPECT_THAT(decoder_config.ReadAndValidate(kAudioRollDistance, *rb), IsOk());
 
@@ -392,8 +388,7 @@ TEST(AacDecoderConfig, FailsIfDecoderConfigDescriptorExpandableSizeIsTooSmall) {
       kLowerByteSerializedSamplingFrequencyIndex64000 |
           kChannelConfigurationAndGaSpecificConfigMask};
   AacDecoderConfig decoder_config;
-  auto rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+  auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
 
   EXPECT_FALSE(decoder_config.ReadAndValidate(kAudioRollDistance, *rb).ok());
 }
@@ -428,8 +423,7 @@ TEST(AacDecoderConfig, ReadExtensions) {
           kChannelConfigurationAndGaSpecificConfigMask,
       'd', 'e', 'f', 'a', 'b', 'c'};
   AacDecoderConfig decoder_config;
-  auto rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+  auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
 
   EXPECT_THAT(decoder_config.ReadAndValidate(kAudioRollDistance, *rb), IsOk());
 
@@ -469,8 +463,7 @@ TEST(AacDecoderConfig, ValidatesAudioRollDistance) {
       kLowerByteSerializedSamplingFrequencyIndex64000 |
           kChannelConfigurationAndGaSpecificConfigMask};
   AacDecoderConfig decoder_config;
-  auto rb =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+  auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
 
   EXPECT_FALSE(
       decoder_config.ReadAndValidate(kInvalidAudioRollDistance, *rb).ok());
diff --git a/iamf/obu/decoder_config/tests/flac_decoder_config_test.cc b/iamf/obu/decoder_config/tests/flac_decoder_config_test.cc
index 0150715..df8e6b9 100644
--- a/iamf/obu/decoder_config/tests/flac_decoder_config_test.cc
+++ b/iamf/obu/decoder_config/tests/flac_decoder_config_test.cc
@@ -11,6 +11,7 @@
  */
 #include "iamf/obu/decoder_config/flac_decoder_config.h"
 
+#include <array>
 #include <cstdint>
 #include <limits>
 #include <variant>
@@ -105,7 +106,7 @@ TEST_F(FlacTest, WriteDefault) {
       0x0b, 0xb8,
       (0 << 4) |
           // `number_of_channels` (3 bits) and `bits_per_sample` (5 bits).
-          (FlacStreamInfoConstraints::kNumberOfChannels << 1),
+          (FlacStreamInfoStrictConstraints::kNumberOfChannels << 1),
       15 << 4 |
           // `total_samples_in_stream` (36 bits).
           0,
@@ -149,7 +150,7 @@ TEST_F(FlacTest, CanContainAdditionalBlocks) {
       0x0b, 0xb8,
       (0 << 4) |
           // `number_of_channels` (3 bits) and `bits_per_sample` (5 bits).
-          (FlacStreamInfoConstraints::kNumberOfChannels << 1),
+          (FlacStreamInfoStrictConstraints::kNumberOfChannels << 1),
       15 << 4 |
           // `total_samples_in_stream` (36 bits).
           0,
@@ -228,7 +229,7 @@ TEST_F(FlacTest, IllegalStreamInfoMustBePresent) {
 
 TEST_F(FlacTest, WriteBitsPerSampleMin) {
   first_stream_info_payload_->bits_per_sample =
-      FlacStreamInfoConstraints::kMinBitsPerSample;
+      FlacStreamInfoStrictConstraints::kMinBitsPerSample;
 
   expected_decoder_config_payload_ = {
       // `last_metadata_block_flag` and `block_type` fields.
@@ -247,7 +248,7 @@ TEST_F(FlacTest, WriteBitsPerSampleMin) {
       0x0b, 0xb8,
       (0 << 4) |
           // `number_of_channels` (3 bits) and `bits_per_sample` (5 bits).
-          (FlacStreamInfoConstraints::kNumberOfChannels << 1),
+          (FlacStreamInfoStrictConstraints::kNumberOfChannels << 1),
       3 << 4 |
           // `total_samples_in_stream` (36 bits).
           0,
@@ -260,7 +261,7 @@ TEST_F(FlacTest, WriteBitsPerSampleMin) {
 
 TEST_F(FlacTest, WriteBitsPerSampleMax) {
   first_stream_info_payload_->bits_per_sample =
-      FlacStreamInfoConstraints::kMaxBitsPerSample;
+      FlacStreamInfoStrictConstraints::kMaxBitsPerSample;
 
   expected_decoder_config_payload_ = {
       // `last_metadata_block_flag` and `block_type` fields.
@@ -279,7 +280,7 @@ TEST_F(FlacTest, WriteBitsPerSampleMax) {
       0x0b, 0xb8,
       (0 << 4) |
           // `number_of_channels` (3 bits) and `bits_per_sample` (5 bits).
-          (FlacStreamInfoConstraints::kNumberOfChannels << 1) | 1,
+          (FlacStreamInfoStrictConstraints::kNumberOfChannels << 1) | 1,
       15 << 4 |
           // `total_samples_in_stream` (36 bits).
           0,
@@ -316,7 +317,7 @@ TEST_F(FlacTest, WriteVaryMostLegalFields) {
       0x0b, 0xb8,
       (0 << 4) |
           // `number_of_channels` (3 bits) and `bits_per_sample` (5 bits).
-          FlacStreamInfoConstraints::kNumberOfChannels << 1,
+          FlacStreamInfoStrictConstraints::kNumberOfChannels << 1,
       7 << 4 |
           // `total_samples_in_stream` (36 bits).
           0,
@@ -329,7 +330,7 @@ TEST_F(FlacTest, WriteVaryMostLegalFields) {
 
 TEST_F(FlacTest, WriteSampleRateMin) {
   first_stream_info_payload_->sample_rate =
-      FlacStreamInfoConstraints::kMinSampleRate;
+      FlacStreamInfoStrictConstraints::kMinSampleRate;
 
   expected_decoder_config_payload_ = {
       // `last_metadata_block_flag` and `block_type` fields.
@@ -348,7 +349,7 @@ TEST_F(FlacTest, WriteSampleRateMin) {
       0x00, 0x00,
       (0x1 << 4) |
           // `number_of_channels` (3 bits) and `bits_per_sample` (5 bits).
-          (FlacStreamInfoConstraints::kNumberOfChannels << 1),
+          (FlacStreamInfoStrictConstraints::kNumberOfChannels << 1),
       15 << 4 |
           // `total_samples_in_stream` (36 bits).
           0,
@@ -361,7 +362,7 @@ TEST_F(FlacTest, WriteSampleRateMin) {
 
 TEST_F(FlacTest, WriteSampleRateMax) {
   first_stream_info_payload_->sample_rate =
-      FlacStreamInfoConstraints::kMaxSampleRate;
+      FlacStreamInfoStrictConstraints::kMaxSampleRate;
 
   expected_decoder_config_payload_ = {
       // `last_metadata_block_flag` and `block_type` fields.
@@ -380,7 +381,7 @@ TEST_F(FlacTest, WriteSampleRateMax) {
       0x9f, 0xff,
       (0x6 << 4) |
           // `number_of_channels` (3 bits) and `bits_per_sample` (5 bits).
-          (FlacStreamInfoConstraints::kNumberOfChannels << 1),
+          (FlacStreamInfoStrictConstraints::kNumberOfChannels << 1),
       15 << 4 |
           // `total_samples_in_stream` (36 bits).
           0,
@@ -444,7 +445,7 @@ TEST_F(FlacTest, WriteMinimumMaximumBlockSizeMax) {
       0x0b, 0xb8,
       (0 << 4) |
           // `number_of_channels` (3 bits) and `bits_per_sample` (5 bits).
-          (FlacStreamInfoConstraints::kNumberOfChannels << 1),
+          (FlacStreamInfoStrictConstraints::kNumberOfChannels << 1),
       15 << 4 |
           // `total_samples_in_stream` (36 bits).
           0,
@@ -494,7 +495,8 @@ TEST_F(FlacTest, IllegalMinimumMaximumBlockSizeNotEqualToEachOther) {
 
 TEST_F(FlacTest, IllegalMinimumFrameSizeNotEqualToZero) {
   const uint32_t kInvalidMinimumFrameSize = 16;
-  ASSERT_NE(kInvalidMinimumFrameSize, FlacStreamInfoConstraints::kMinFrameSize);
+  ASSERT_NE(kInvalidMinimumFrameSize,
+            FlacStreamInfoLooseConstraints::kMinFrameSize);
   first_stream_info_payload_->minimum_frame_size = kInvalidMinimumFrameSize;
 
   expected_write_status_code_ = absl::StatusCode::kInvalidArgument;
@@ -503,7 +505,8 @@ TEST_F(FlacTest, IllegalMinimumFrameSizeNotEqualToZero) {
 
 TEST_F(FlacTest, IllegalMaximumFrameSizeNotEqualToZero) {
   const uint32_t kInvalidMaximumFrameSize = 16;
-  ASSERT_NE(kInvalidMaximumFrameSize, FlacStreamInfoConstraints::kMaxFrameSize);
+  ASSERT_NE(kInvalidMaximumFrameSize,
+            FlacStreamInfoLooseConstraints::kMaxFrameSize);
   first_stream_info_payload_->maximum_frame_size = kInvalidMaximumFrameSize;
 
   expected_write_status_code_ = absl::StatusCode::kInvalidArgument;
@@ -513,7 +516,7 @@ TEST_F(FlacTest, IllegalMaximumFrameSizeNotEqualToZero) {
 TEST_F(FlacTest, IllegalNumberOfChannelsNotEqualToOne) {
   const uint8_t kInvalidNumberOfChannels = 2;
   ASSERT_NE(kInvalidNumberOfChannels,
-            FlacStreamInfoConstraints::kNumberOfChannels);
+            FlacStreamInfoStrictConstraints::kNumberOfChannels);
   first_stream_info_payload_->number_of_channels = kInvalidNumberOfChannels;
 
   expected_write_status_code_ = absl::StatusCode::kInvalidArgument;
@@ -522,7 +525,7 @@ TEST_F(FlacTest, IllegalNumberOfChannelsNotEqualToOne) {
 
 TEST_F(FlacTest, WriteTotalSamplesInStreamMax) {
   first_stream_info_payload_->total_samples_in_stream =
-      FlacStreamInfoConstraints::kMaxTotalSamplesInStream;
+      FlacStreamInfoStrictConstraints::kMaxTotalSamplesInStream;
 
   expected_decoder_config_payload_ = {
       // `last_metadata_block_flag` and `block_type` fields.
@@ -541,7 +544,7 @@ TEST_F(FlacTest, WriteTotalSamplesInStreamMax) {
       0x0b, 0xb8,
       (0 << 4) |
           // `number_of_channels` (3 bits) and `bits_per_sample` (5 bits).
-          (FlacStreamInfoConstraints::kNumberOfChannels << 1),
+          (FlacStreamInfoStrictConstraints::kNumberOfChannels << 1),
       15 << 4 |
           // `total_samples_in_stream` (36 bits).
           0xf,
@@ -554,7 +557,7 @@ TEST_F(FlacTest, WriteTotalSamplesInStreamMax) {
 
 TEST_F(FlacTest, IllegalMd5SumNonZero) {
   const uint8_t kInvalidMd5SumFirstByte = 0x01;
-  ASSERT_NE(FlacStreamInfoConstraints::kMd5Signature[0],
+  ASSERT_NE(FlacStreamInfoLooseConstraints::kMd5Signature[0],
             kInvalidMd5SumFirstByte);
   first_stream_info_payload_->md5_signature[0] = kInvalidMd5SumFirstByte;
 
@@ -574,28 +577,30 @@ TEST(GetRequiredAudioRollDistance, ReturnsFixedValue) {
 
 TEST_F(FlacTest, GetOutputSampleRateMin) {
   first_stream_info_payload_->sample_rate =
-      FlacStreamInfoConstraints::kMinSampleRate;
+      FlacStreamInfoStrictConstraints::kMinSampleRate;
 
   uint32_t output_sample_rate;
   EXPECT_THAT(flac_decoder_config_.GetOutputSampleRate(output_sample_rate),
               IsOk());
-  EXPECT_EQ(output_sample_rate, FlacStreamInfoConstraints::kMinSampleRate);
+  EXPECT_EQ(output_sample_rate,
+            FlacStreamInfoStrictConstraints::kMinSampleRate);
 }
 
 TEST_F(FlacTest, GetOutputSampleRateMax) {
   first_stream_info_payload_->sample_rate =
-      FlacStreamInfoConstraints::kMaxSampleRate;
+      FlacStreamInfoStrictConstraints::kMaxSampleRate;
 
   uint32_t output_sample_rate;
   EXPECT_THAT(flac_decoder_config_.GetOutputSampleRate(output_sample_rate),
               IsOk());
-  EXPECT_EQ(output_sample_rate, FlacStreamInfoConstraints::kMaxSampleRate);
+  EXPECT_EQ(output_sample_rate,
+            FlacStreamInfoStrictConstraints::kMaxSampleRate);
 }
 
 TEST_F(FlacTest, InvalidGetOutputSampleRateTooLow) {
-  ASSERT_GT(FlacStreamInfoConstraints::kMinSampleRate, 0);
+  ASSERT_GT(FlacStreamInfoStrictConstraints::kMinSampleRate, 0);
   first_stream_info_payload_->sample_rate =
-      FlacStreamInfoConstraints::kMinSampleRate - 1;
+      FlacStreamInfoStrictConstraints::kMinSampleRate - 1;
 
   uint32_t output_sample_rate;
   EXPECT_FALSE(
@@ -603,10 +608,10 @@ TEST_F(FlacTest, InvalidGetOutputSampleRateTooLow) {
 }
 
 TEST_F(FlacTest, InvalidGetOutputSampleRateTooHigh) {
-  ASSERT_LT(FlacStreamInfoConstraints::kMaxSampleRate,
+  ASSERT_LT(FlacStreamInfoStrictConstraints::kMaxSampleRate,
             std::numeric_limits<uint32_t>::max());
   first_stream_info_payload_->sample_rate =
-      FlacStreamInfoConstraints::kMaxSampleRate + 1;
+      FlacStreamInfoStrictConstraints::kMaxSampleRate + 1;
 
   uint32_t output_sample_rate;
   EXPECT_FALSE(
@@ -623,30 +628,32 @@ TEST_F(FlacTest, InvalidGetOutputSampleRateWithNoStreamInfo) {
 
 TEST_F(FlacTest, GetBitsPerSampleMin) {
   first_stream_info_payload_->bits_per_sample =
-      FlacStreamInfoConstraints::kMinBitsPerSample;
+      FlacStreamInfoStrictConstraints::kMinBitsPerSample;
 
   uint8_t output_bit_depth;
   EXPECT_THAT(
       flac_decoder_config_.GetBitDepthToMeasureLoudness(output_bit_depth),
       IsOk());
-  EXPECT_EQ(output_bit_depth, FlacStreamInfoConstraints::kMinBitsPerSample + 1);
+  EXPECT_EQ(output_bit_depth,
+            FlacStreamInfoStrictConstraints::kMinBitsPerSample + 1);
 }
 
 TEST_F(FlacTest, GetBitsPerSampleMax) {
   first_stream_info_payload_->bits_per_sample =
-      FlacStreamInfoConstraints::kMaxBitsPerSample;
+      FlacStreamInfoStrictConstraints::kMaxBitsPerSample;
 
   uint8_t output_bit_depth;
   EXPECT_THAT(
       flac_decoder_config_.GetBitDepthToMeasureLoudness(output_bit_depth),
       IsOk());
-  EXPECT_EQ(output_bit_depth, FlacStreamInfoConstraints::kMaxBitsPerSample + 1);
+  EXPECT_EQ(output_bit_depth,
+            FlacStreamInfoStrictConstraints::kMaxBitsPerSample + 1);
 }
 
 TEST_F(FlacTest, GetBitsPerSampleMinTooLow) {
-  ASSERT_GT(FlacStreamInfoConstraints::kMinBitsPerSample, 0);
+  ASSERT_GT(FlacStreamInfoStrictConstraints::kMinBitsPerSample, 0);
   first_stream_info_payload_->bits_per_sample =
-      FlacStreamInfoConstraints::kMinBitsPerSample - 1;
+      FlacStreamInfoStrictConstraints::kMinBitsPerSample - 1;
   uint8_t unused_output_bit_depth;
   EXPECT_FALSE(
       flac_decoder_config_.GetBitDepthToMeasureLoudness(unused_output_bit_depth)
@@ -654,10 +661,10 @@ TEST_F(FlacTest, GetBitsPerSampleMinTooLow) {
 }
 
 TEST_F(FlacTest, GetBitsPerSampleMaxTooHigh) {
-  ASSERT_LT(FlacStreamInfoConstraints::kMaxBitsPerSample,
+  ASSERT_LT(FlacStreamInfoStrictConstraints::kMaxBitsPerSample,
             std::numeric_limits<uint32_t>::max());
   first_stream_info_payload_->bits_per_sample =
-      FlacStreamInfoConstraints::kMaxBitsPerSample + 1;
+      FlacStreamInfoStrictConstraints::kMaxBitsPerSample + 1;
 
   uint8_t unused_output_bit_depth;
   EXPECT_FALSE(
@@ -676,33 +683,33 @@ TEST_F(FlacTest, InvalidGetBitsPerSampleWithNoStreamInfo) {
 
 TEST_F(FlacTest, GetTotalNumSamplesInStreamMin) {
   first_stream_info_payload_->total_samples_in_stream =
-      FlacStreamInfoConstraints::kMinTotalSamplesInStream;
+      FlacStreamInfoStrictConstraints::kMinTotalSamplesInStream;
 
   uint64_t output_total_samples_in_stream;
   EXPECT_THAT(flac_decoder_config_.GetTotalSamplesInStream(
                   output_total_samples_in_stream),
               IsOk());
   EXPECT_EQ(output_total_samples_in_stream,
-            FlacStreamInfoConstraints::kMinTotalSamplesInStream);
+            FlacStreamInfoStrictConstraints::kMinTotalSamplesInStream);
 }
 
 TEST_F(FlacTest, GetTotalNumSamplesInStreamMax) {
   first_stream_info_payload_->total_samples_in_stream =
-      FlacStreamInfoConstraints::kMaxTotalSamplesInStream;
+      FlacStreamInfoStrictConstraints::kMaxTotalSamplesInStream;
 
   uint64_t output_total_samples_in_stream;
   EXPECT_THAT(flac_decoder_config_.GetTotalSamplesInStream(
                   output_total_samples_in_stream),
               IsOk());
   EXPECT_EQ(output_total_samples_in_stream,
-            FlacStreamInfoConstraints::kMaxTotalSamplesInStream);
+            FlacStreamInfoStrictConstraints::kMaxTotalSamplesInStream);
 }
 
 TEST_F(FlacTest, InvalidGetTotalNumSamplesInStreamTooHigh) {
-  ASSERT_LT(FlacStreamInfoConstraints::kMaxTotalSamplesInStream,
+  ASSERT_LT(FlacStreamInfoStrictConstraints::kMaxTotalSamplesInStream,
             std::numeric_limits<uint64_t>::max());
   first_stream_info_payload_->total_samples_in_stream =
-      FlacStreamInfoConstraints::kMaxTotalSamplesInStream + 1;
+      FlacStreamInfoStrictConstraints::kMaxTotalSamplesInStream + 1;
 
   uint64_t output_total_samples_in_stream;
   EXPECT_FALSE(flac_decoder_config_
@@ -741,7 +748,7 @@ TEST(ReadAndValidateTest, ReadAndValidateStreamInfoSuccess) {
       0x0b, 0xb8,
       (0 << 4) |
           // `number_of_channels` (3 bits) and `bits_per_sample` (5 bits).
-          FlacStreamInfoConstraints::kNumberOfChannels << 1,
+          FlacStreamInfoStrictConstraints::kNumberOfChannels << 1,
       7 << 4 |
           // `total_samples_in_stream` (36 bits).
           0,
@@ -750,8 +757,8 @@ TEST(ReadAndValidateTest, ReadAndValidateStreamInfoSuccess) {
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00};
 
-  auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(payload));
+  auto rb =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(payload));
   FlacDecoderConfig decoder_config;
   EXPECT_THAT(decoder_config.ReadAndValidate(
                   /*num_samples_per_frame=*/64, /*audio_roll_distance=*/0, *rb),
@@ -768,11 +775,11 @@ TEST(ReadAndValidateTest, ReadAndValidateStreamInfoSuccess) {
   EXPECT_EQ(stream_info.maximum_frame_size, 0);
   EXPECT_EQ(stream_info.sample_rate, 48000);
   EXPECT_EQ(stream_info.number_of_channels,
-            FlacStreamInfoConstraints::kNumberOfChannels);
+            FlacStreamInfoStrictConstraints::kNumberOfChannels);
   EXPECT_EQ(stream_info.bits_per_sample, 7);
   EXPECT_EQ(stream_info.total_samples_in_stream, 100);
   EXPECT_EQ(stream_info.md5_signature,
-            FlacStreamInfoConstraints::kMd5Signature);
+            FlacStreamInfoLooseConstraints::kMd5Signature);
 }
 
 TEST(ReadAndValidateTest, ReadAndValidateCanReadMultipleMetadataBlocks) {
@@ -793,7 +800,7 @@ TEST(ReadAndValidateTest, ReadAndValidateCanReadMultipleMetadataBlocks) {
       0x0b, 0xb8,
       (0 << 4) |
           // `number_of_channels` (3 bits) and `bits_per_sample` (5 bits).
-          (FlacStreamInfoConstraints::kNumberOfChannels << 1),
+          (FlacStreamInfoStrictConstraints::kNumberOfChannels << 1),
       15 << 4 |
           // `total_samples_in_stream` (36 bits).
           0,
@@ -814,8 +821,8 @@ TEST(ReadAndValidateTest, ReadAndValidateCanReadMultipleMetadataBlocks) {
       // Payload.
       'd', 'e', 'f'};
 
-  auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(payload));
+  auto rb =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(payload));
   FlacDecoderConfig decoder_config;
   EXPECT_THAT(decoder_config.ReadAndValidate(
                   /*num_samples_per_frame=*/64, /*audio_roll_distance=*/0, *rb),
@@ -855,8 +862,10 @@ TEST(ReadAndValidateTest, ReadAndValidateCanReadMultipleMetadataBlocks) {
   EXPECT_THAT(application_payload, ElementsAreArray({'d', 'e', 'f'}));
 }
 
-TEST(ReadAndValidateTest, ReadAndValidateStreamInfoFailsOnInvalidMd5Signature) {
-  std::vector<uint8_t> payload = {
+TEST(ReadAndValidate, ReadsInvalidMd5Signature) {
+  // The spec notes that the MD5 sum "SHOULD" be fixed. However, to be a robust
+  // decoder, we ignore that do not match the recommended value.
+  const std::vector<uint8_t> payload = {
       // `last_metadata_block_flag` and `block_type` fields.
       1 << 7 | FlacMetaBlockHeader::kFlacStreamInfo,
       // `metadata_data_block_length`.
@@ -873,7 +882,7 @@ TEST(ReadAndValidateTest, ReadAndValidateStreamInfoFailsOnInvalidMd5Signature) {
       0x0b, 0xb8,
       (0 << 4) |
           // `number_of_channels` (3 bits) and `bits_per_sample` (5 bits).
-          FlacStreamInfoConstraints::kNumberOfChannels << 1,
+          FlacStreamInfoStrictConstraints::kNumberOfChannels << 1,
       7 << 4 |
           // `total_samples_in_stream` (36 bits).
           0,
@@ -881,15 +890,68 @@ TEST(ReadAndValidateTest, ReadAndValidateStreamInfoFailsOnInvalidMd5Signature) {
       // MD5 sum (invalid bit at end)
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x01};
+  constexpr std::array<uint8_t, 16> kExpectedInvalidMd5Signature = {
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
 
-  auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(payload));
+  auto rb =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(payload));
   FlacDecoderConfig decoder_config;
-  EXPECT_FALSE(
-      decoder_config
-          .ReadAndValidate(
-              /*num_samples_per_frame=*/64, /*audio_roll_distance=*/0, *rb)
-          .ok());
+  EXPECT_THAT(decoder_config.ReadAndValidate(
+                  /*num_samples_per_frame=*/64, /*audio_roll_distance=*/0, *rb),
+              IsOk());
+  EXPECT_THAT(decoder_config.metadata_blocks_[0].header.block_type,
+              Eq(FlacMetaBlockHeader::kFlacStreamInfo));
+
+  FlacMetaBlockStreamInfo stream_info = std::get<FlacMetaBlockStreamInfo>(
+      decoder_config.metadata_blocks_[0].payload);
+  EXPECT_EQ(stream_info.md5_signature, kExpectedInvalidMd5Signature);
+}
+
+TEST(ReadAndValidateTest, ReadsInvalidFrameSizes) {
+  // The spec notes that these values "SHOULD" be fixed. However, to be a robust
+  // decoder, we ignore that they do not match the recommended value.
+  constexpr uint8_t kInvalidMinimumFrameSize = 1;
+  constexpr uint8_t kInvalidMaximumFrameSize = 2;
+  const std::vector<uint8_t> payload = {
+      // `last_metadata_block_flag` and `block_type` fields.
+      1 << 7 | FlacMetaBlockHeader::kFlacStreamInfo,
+      // `metadata_data_block_length`.
+      0, 0, 34,
+      // `minimum_block_size`.
+      0, 64,
+      // `maximum_block_size`.
+      0, 64,
+      // `minimum_frame_size`.
+      0, 0, kInvalidMinimumFrameSize,
+      // `maximum_frame_size`.
+      0, 0, kInvalidMaximumFrameSize,
+      // `sample_rate` (20 bits)
+      0x0b, 0xb8,
+      (0 << 4) |
+          // `number_of_channels` (3 bits) and `bits_per_sample` (5 bits).
+          FlacStreamInfoStrictConstraints::kNumberOfChannels << 1,
+      7 << 4 |
+          // `total_samples_in_stream` (36 bits).
+          0,
+      0x00, 0x00, 0x00, 100,
+      // MD5 sum.
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x00, 0x00, 0x00, 0x00};
+
+  auto rb =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(payload));
+  FlacDecoderConfig decoder_config;
+
+  EXPECT_THAT(decoder_config.ReadAndValidate(
+                  /*num_samples_per_frame=*/64, /*audio_roll_distance=*/0, *rb),
+              IsOk());
+
+  FlacMetaBlockStreamInfo* stream_info = std::get_if<FlacMetaBlockStreamInfo>(
+      &decoder_config.metadata_blocks_[0].payload);
+  ASSERT_NE(stream_info, nullptr);
+  EXPECT_EQ(stream_info->minimum_frame_size, kInvalidMinimumFrameSize);
+  EXPECT_EQ(stream_info->maximum_frame_size, kInvalidMaximumFrameSize);
 }
 
 }  // namespace
diff --git a/iamf/obu/decoder_config/tests/lpcm_decoder_config_test.cc b/iamf/obu/decoder_config/tests/lpcm_decoder_config_test.cc
index 07e81d6..e231168 100644
--- a/iamf/obu/decoder_config/tests/lpcm_decoder_config_test.cc
+++ b/iamf/obu/decoder_config/tests/lpcm_decoder_config_test.cc
@@ -276,8 +276,8 @@ TEST(ReadAndValidateTest, ReadAllFields) {
       0x00, 0x00, 0xbb, 0x80  // sample_rate
   };
   int16_t audio_roll_distance = 0;
-  auto read_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto read_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   LpcmDecoderConfig lpcm_decoder_config;
   EXPECT_THAT(
       lpcm_decoder_config.ReadAndValidate(audio_roll_distance, *read_buffer),
@@ -294,8 +294,8 @@ TEST(ReadAndValidateTest, RejectInvalidAudioRollDistance) {
       0x00, 0x00, 0xbb, 0x80  // sample_rate
   };
   int16_t audio_roll_distance = 1;
-  auto read_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto read_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   LpcmDecoderConfig lpcm_decoder_config;
   EXPECT_FALSE(
       lpcm_decoder_config.ReadAndValidate(audio_roll_distance, *read_buffer)
diff --git a/iamf/obu/decoder_config/tests/opus_decoder_config_test.cc b/iamf/obu/decoder_config/tests/opus_decoder_config_test.cc
index 5c48ffa..1aa83b6 100644
--- a/iamf/obu/decoder_config/tests/opus_decoder_config_test.cc
+++ b/iamf/obu/decoder_config/tests/opus_decoder_config_test.cc
@@ -291,8 +291,8 @@ TEST(ReadAndValidate, VaryAllLegalFields) {
                                  0, 0,
                                  // `mapping_family`.
                                  OpusDecoderConfig::kMappingFamily};
-  auto read_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto read_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   EXPECT_THAT(opus_decoder_config.ReadAndValidate(
                   num_samples_per_frame, audio_roll_distance, *read_buffer),
               IsOk());
@@ -318,8 +318,8 @@ TEST(ReadAndValidate, MaxAllLegalFields) {
                                  0, 0,
                                  // `mapping_family`.
                                  OpusDecoderConfig::kMappingFamily};
-  auto read_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto read_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   EXPECT_THAT(opus_decoder_config.ReadAndValidate(
                   num_samples_per_frame, audio_roll_distance, *read_buffer),
               IsOk());
@@ -345,8 +345,8 @@ TEST(ReadAndValidate, MinorVersion) {
                                  0, 0,
                                  // `mapping_family`.
                                  OpusDecoderConfig::kMappingFamily};
-  auto read_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto read_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   EXPECT_THAT(opus_decoder_config.ReadAndValidate(
                   num_samples_per_frame, audio_roll_distance, *read_buffer),
               IsOk());
@@ -370,8 +370,8 @@ TEST(ReadAndValidate, IllegalVersionZero) {
                                  0, 0,
                                  // `mapping_family`.
                                  OpusDecoderConfig::kMappingFamily};
-  auto read_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto read_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   EXPECT_FALSE(opus_decoder_config
                    .ReadAndValidate(num_samples_per_frame, audio_roll_distance,
                                     *read_buffer)
@@ -394,8 +394,8 @@ TEST(ReadAndValidate, IllegalVersionFuture) {
                                  0, 0,
                                  // `mapping_family`.
                                  OpusDecoderConfig::kMappingFamily};
-  auto read_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto read_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   EXPECT_FALSE(opus_decoder_config
                    .ReadAndValidate(num_samples_per_frame, audio_roll_distance,
                                     *read_buffer)
@@ -418,8 +418,8 @@ TEST(ReadAndValidate, IllegalVersionmax) {
                                  0, 0,
                                  // `mapping_family`.
                                  OpusDecoderConfig::kMappingFamily};
-  auto read_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto read_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   EXPECT_FALSE(opus_decoder_config
                    .ReadAndValidate(num_samples_per_frame, audio_roll_distance,
                                     *read_buffer)
@@ -442,8 +442,8 @@ TEST(ReadAndValidate, IllegalChannelCountZero) {
                                  0, 0,
                                  // `mapping_family`.
                                  OpusDecoderConfig::kMappingFamily};
-  auto read_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto read_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   EXPECT_FALSE(opus_decoder_config
                    .ReadAndValidate(num_samples_per_frame, audio_roll_distance,
                                     *read_buffer)
@@ -466,8 +466,8 @@ TEST(ReadAndValidate, ReadPreSkip312) {
                                  0, 0,
                                  // `mapping_family`.
                                  OpusDecoderConfig::kMappingFamily};
-  auto read_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto read_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   EXPECT_THAT(opus_decoder_config.ReadAndValidate(
                   num_samples_per_frame, audio_roll_distance, *read_buffer),
               IsOk());
@@ -492,8 +492,8 @@ TEST(ReadAndValidate, ReadSampleRate48kHz) {
                                  0, 0,
                                  // `mapping_family`.
                                  OpusDecoderConfig::kMappingFamily};
-  auto read_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto read_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   EXPECT_THAT(opus_decoder_config.ReadAndValidate(
                   num_samples_per_frame, audio_roll_distance, *read_buffer),
               IsOk());
@@ -518,8 +518,8 @@ TEST(ReadAndValidate, ReadSampleRate192kHz) {
                                  0, 0,
                                  // `mapping_family`.
                                  OpusDecoderConfig::kMappingFamily};
-  auto read_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto read_buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   EXPECT_THAT(opus_decoder_config.ReadAndValidate(
                   num_samples_per_frame, audio_roll_distance, *read_buffer),
               IsOk());
diff --git a/iamf/obu/tests/audio_element_test.cc b/iamf/obu/tests/audio_element_test.cc
index dc2cfcb..1932c6f 100644
--- a/iamf/obu/tests/audio_element_test.cc
+++ b/iamf/obu/tests/audio_element_test.cc
@@ -747,7 +747,7 @@ TEST(ChannelAudioLayerConfig, ReadsBinauralLayer) {
       ChannelAudioLayerConfig::kLayoutBinaural << kLoudspeakerLayoutBitShift, 1,
       1};
   auto buffer =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   ChannelAudioLayerConfig config;
 
   EXPECT_THAT(config.Read(*buffer), IsOk());
@@ -766,7 +766,7 @@ TEST(ChannelAudioLayerConfig, ReadsReserved10Layer) {
       ChannelAudioLayerConfig::kLayoutReserved10 << kLoudspeakerLayoutBitShift,
       1, 1};
   auto buffer =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   ChannelAudioLayerConfig config;
 
   EXPECT_THAT(config.Read(*buffer), IsOk());
@@ -780,7 +780,7 @@ TEST(ChannelAudioLayerConfig, ReadsReserved11Layer) {
       ChannelAudioLayerConfig::kLayoutReserved11 << kLoudspeakerLayoutBitShift,
       1, 1};
   auto buffer =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   ChannelAudioLayerConfig config;
 
   EXPECT_THAT(config.Read(*buffer), IsOk());
@@ -794,7 +794,7 @@ TEST(ChannelAudioLayerConfig, ReadsReserved12Layer) {
       ChannelAudioLayerConfig::kLayoutReserved12 << kLoudspeakerLayoutBitShift,
       1, 1};
   auto buffer =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   ChannelAudioLayerConfig config;
 
   EXPECT_THAT(config.Read(*buffer), IsOk());
@@ -808,7 +808,7 @@ TEST(ChannelAudioLayerConfig, ReadsReserved13Layer) {
       ChannelAudioLayerConfig::kLayoutReserved13 << kLoudspeakerLayoutBitShift,
       1, 1};
   auto buffer =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   ChannelAudioLayerConfig config;
 
   EXPECT_THAT(config.Read(*buffer), IsOk());
@@ -822,7 +822,7 @@ TEST(ChannelAudioLayerConfig, ReadsReserved14Layer) {
       ChannelAudioLayerConfig::kLayoutReserved14 << kLoudspeakerLayoutBitShift,
       1, 1};
   auto buffer =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   ChannelAudioLayerConfig config;
 
   EXPECT_THAT(config.Read(*buffer), IsOk());
@@ -836,7 +836,7 @@ TEST(ChannelAudioLayerConfig, ReadsExpandedLayoutLFE) {
       ChannelAudioLayerConfig::kLayoutExpanded << kLoudspeakerLayoutBitShift, 1,
       1, ChannelAudioLayerConfig::kExpandedLayoutLFE};
   auto buffer =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   ChannelAudioLayerConfig config;
 
   EXPECT_THAT(config.Read(*buffer), IsOk());
@@ -854,7 +854,7 @@ TEST(ChannelAudioLayerConfig,
       1
       /*`expanded_loudspeaker_layout` is omitted*/};
   auto buffer =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   ChannelAudioLayerConfig config;
 
   EXPECT_FALSE(config.Read(*buffer).ok());
@@ -865,7 +865,7 @@ TEST(ChannelAudioLayerConfig, ReadsExpandedLayoutReserved13) {
       ChannelAudioLayerConfig::kLayoutExpanded << kLoudspeakerLayoutBitShift, 1,
       1, ChannelAudioLayerConfig::kExpandedLayoutReserved13};
   auto buffer =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   ChannelAudioLayerConfig config;
 
   EXPECT_THAT(config.Read(*buffer), IsOk());
@@ -890,7 +890,7 @@ TEST(ChannelAudioLayerConfig, ReadsOutputGainIsPresentRelatedFields) {
       0,
       5};
   auto buffer =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   ChannelAudioLayerConfig config;
 
   EXPECT_THAT(config.Read(*buffer), IsOk());
@@ -908,7 +908,7 @@ TEST(ChannelAudioLayerConfig, ReadsReconGainIsPresent) {
           kReconGainIsPresent << kReconGainIsPresentBitShift,
       1, 0};
   auto buffer =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   ChannelAudioLayerConfig config;
 
   EXPECT_THAT(config.Read(*buffer), IsOk());
@@ -923,7 +923,7 @@ TEST(ChannelAudioLayerConfig, ReadsFirstReservedField) {
           kReservedField,
       1, 0};
   auto buffer =
-      MemoryBasedReadBitBuffer::CreateFromSpan(1024, absl::MakeConstSpan(data));
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(data));
   ChannelAudioLayerConfig config;
 
   EXPECT_THAT(config.Read(*buffer), IsOk());
@@ -1769,8 +1769,8 @@ TEST(ReadAudioElementParamTest, ValidReconGainParamDefinition) {
       // Constant Subblock Duration.
       64};
 
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(bitstream));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   AudioElementParam param;
   EXPECT_THAT(param.ReadAndValidate(kAudioElementId, *buffer), IsOk());
 }
@@ -1789,8 +1789,8 @@ TEST(ReadAudioElementParamTest, RejectMixGainParamDefinition) {
       64,
       // Constant Subblock Duration.
       64};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(bitstream));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   AudioElementParam param;
   EXPECT_FALSE(param.ReadAndValidate(kAudioElementId, *buffer).ok());
 }
@@ -1813,8 +1813,8 @@ TEST(ReadAudioElementParamTest, ValidDemixingParamDefinition) {
       DemixingInfoParameterData::kDMixPMode2 << 5,
       // `default_w`.
       0};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(bitstream));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   AudioElementParam param;
   EXPECT_THAT(param.ReadAndValidate(kAudioElementId, *buffer), IsOk());
 
@@ -1838,8 +1838,8 @@ TEST(AudioElementParam, ReadAndValidateReadsReservedParamDefinition3) {
       0x01,
       // param_definition_bytes.
       99};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(bitstream));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   AudioElementParam param;
   EXPECT_THAT(param.ReadAndValidate(kAudioElementId, *buffer), IsOk());
 
@@ -1855,8 +1855,8 @@ TEST(AudioElementParam, ReadAndValidateReadsReservedParamDefinition3) {
 // --- Begin CreateFromBuffer tests ---
 TEST(CreateFromBuffer, InvalidWhenPayloadIsEmpty) {
   std::vector<uint8_t> source;
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header;
   EXPECT_FALSE(AudioElementObu::CreateFromBuffer(header, 0, *buffer).ok());
 }
@@ -1903,8 +1903,8 @@ TEST(CreateFromBuffer, ScalableChannelConfigMultipleChannelsNoParams) {
       // `output_gain`.
       0, 1};
   const int64_t payload_size = source.size();
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header;
   auto obu = AudioElementObu::CreateFromBuffer(header, payload_size, *buffer);
 
@@ -1981,8 +1981,8 @@ TEST(CreateFromBuffer, InvalidMultipleChannelConfigWithBinauralLayout) {
       // `coupled_substream_count`.
       1};
   const int64_t payload_size = source.size();
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header;
   auto obu = AudioElementObu::CreateFromBuffer(header, payload_size, *buffer);
 
@@ -2012,8 +2012,8 @@ TEST(CreateFromBuffer, ValidAmbisonicsMonoConfig) {
       0, 1, 2, 3  // `channel_mapping`, one per `output_channel_count`.
   };
   const int64_t payload_size = source.size();
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header;
   auto obu = AudioElementObu::CreateFromBuffer(header, payload_size, *buffer);
 
@@ -2061,8 +2061,8 @@ TEST(CreateFromBuffer, ValidAmbisonicsProjectionConfig) {
       0x00, 0x07, 0x00, 0x08, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x0b, 0x00, 0x0c,
       0x00, 0x0d, 0x00, 0x0e, 0x00, 0x0f, 0x00, 0x10};
   const int64_t payload_size = source.size();
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header;
   auto obu = AudioElementObu::CreateFromBuffer(header, payload_size, *buffer);
 
diff --git a/iamf/obu/tests/audio_frame_test.cc b/iamf/obu/tests/audio_frame_test.cc
index 340d616..f62ca47 100644
--- a/iamf/obu/tests/audio_frame_test.cc
+++ b/iamf/obu/tests/audio_frame_test.cc
@@ -297,8 +297,8 @@ TEST(CreateFromBuffer, ValidAudioFrameWithExplicitId) {
                                  18,
                                  // `audio_frame`, arbitrary values.
                                  8, 6, 24, 55, 11};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header = {.obu_type = kObuIaAudioFrame};  // Requires explicit ID.
   const int64_t obu_payload_size = 6;
   auto obu = AudioFrameObu::CreateFromBuffer(header, obu_payload_size, *buffer);
@@ -310,8 +310,8 @@ TEST(CreateFromBuffer, ValidAudioFrameWithExplicitId) {
 TEST(CreateFromBuffer, ValidAudioFrameWithImplicitId) {
   std::vector<uint8_t> source = {// `audio_frame`, arbitrary values.
                                  8, 6, 24, 55, 11};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header = {.obu_type = kObuIaAudioFrameId0};  // ID from OBU type.
   int64_t obu_payload_size = 5;
   auto obu = AudioFrameObu::CreateFromBuffer(header, obu_payload_size, *buffer);
@@ -329,8 +329,8 @@ TEST(CreateFromBuffer, FailsWithPayloadSizeTooLarge) {
                                  18,
                                  // `audio_frame`, arbitrary values.
                                  8, 6, 24, 55, 11};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header = {.obu_type = kObuIaAudioFrame};  // Requires explicit ID.
   int64_t obu_payload_size = 7;
   auto obu = AudioFrameObu::CreateFromBuffer(header, obu_payload_size, *buffer);
@@ -343,8 +343,8 @@ TEST(CreateFromBuffer, FailsWithPayloadSizeZero) {
                                  18,
                                  // `audio_frame`, arbitrary values.
                                  8, 6, 24, 55, 11};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header = {.obu_type = kObuIaAudioFrame};  // Requires explicit ID.
   int64_t obu_payload_size = 0;
   auto obu = AudioFrameObu::CreateFromBuffer(header, obu_payload_size, *buffer);
@@ -356,8 +356,8 @@ TEST(CreateFromBuffer, FailsWithPayloadSizeLessThanSizeUsedById) {
   std::vector<uint8_t> source = {
       0x80, 0x80, 0x1,           // `explicit_audio_substream_id`, 3 byte ULEB.
       8,    6,    24,  55, 11};  // `audio_frame`, arbitrary values.
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header = {.obu_type = kObuIaAudioFrame};  // Requires explicit ID.
   int64_t obu_payload_size = 2;  // Less than the 3 used for the ID.
   auto obu = AudioFrameObu::CreateFromBuffer(header, obu_payload_size, *buffer);
@@ -367,8 +367,8 @@ TEST(CreateFromBuffer, FailsWithPayloadSizeLessThanSizeUsedById) {
 TEST(CreateFromBuffer, FailsWithNegativePayloadSize) {
   std::vector<uint8_t> source = {// `audio_frame`, arbitrary values.
                                  8, 6, 24, 55, 11};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header = {.obu_type = kObuIaAudioFrameId0};  // ID from OBU type.
   int64_t obu_payload_size = -1;
   auto obu = AudioFrameObu::CreateFromBuffer(header, obu_payload_size, *buffer);
diff --git a/iamf/obu/tests/codec_config_test.cc b/iamf/obu/tests/codec_config_test.cc
index 6e5ef1c..20addf3 100644
--- a/iamf/obu/tests/codec_config_test.cc
+++ b/iamf/obu/tests/codec_config_test.cc
@@ -617,7 +617,7 @@ TEST(CreateFromBuffer, OpusDecoderConfig) {
                                       OpusDecoderConfig::kMappingFamily};
   const int64_t payload_size = source_data.size();
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   ObuHeader header;
 
   absl::StatusOr<CodecConfigObu> obu =
@@ -723,7 +723,7 @@ TEST(CreateFromBuffer, AacLcDecoderConfig) {
           kChannelConfigurationAndGaSpecificConfigMask};
   const int64_t payload_size = source_data.size();
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   ObuHeader header;
 
   absl::StatusOr<CodecConfigObu> obu =
@@ -825,7 +825,7 @@ TEST(CreateFromBuffer, ValidLpcmDecoderConfig) {
                                       0, 0, 0xbb, 0x80};
   const int64_t payload_size = source_data.size();
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   ObuHeader header;
 
   absl::StatusOr<CodecConfigObu> obu =
@@ -879,7 +879,7 @@ TEST(CreateFromBuffer, ValidFlacDecoderConfig) {
       0x0b, 0xb8,
       (0 << 4) |
           // `number_of_channels` (3 bits) and `bits_per_sample` (5 bits).
-          FlacStreamInfoConstraints::kNumberOfChannels << 1,
+          FlacStreamInfoStrictConstraints::kNumberOfChannels << 1,
       7 << 4 |
           // `total_samples_in_stream` (36 bits).
           0,
@@ -889,7 +889,7 @@ TEST(CreateFromBuffer, ValidFlacDecoderConfig) {
       0x00, 0x00, 0x00, 0x00};
   const int64_t payload_size = source_data.size();
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   ObuHeader header;
 
   absl::StatusOr<CodecConfigObu> obu =
@@ -920,11 +920,11 @@ TEST(CreateFromBuffer, ValidFlacDecoderConfig) {
   EXPECT_EQ(stream_info.maximum_frame_size, 0);
   EXPECT_EQ(stream_info.sample_rate, 48000);
   EXPECT_EQ(stream_info.number_of_channels,
-            FlacStreamInfoConstraints::kNumberOfChannels);
+            FlacStreamInfoStrictConstraints::kNumberOfChannels);
   EXPECT_EQ(stream_info.bits_per_sample, 7);
   EXPECT_EQ(stream_info.total_samples_in_stream, 100);
   EXPECT_EQ(stream_info.md5_signature,
-            FlacStreamInfoConstraints::kMd5Signature);
+            FlacStreamInfoLooseConstraints::kMd5Signature);
   EXPECT_TRUE(obu->IsLossless());
 }
 
diff --git a/iamf/obu/tests/demixing_info_parameter_data_test.cc b/iamf/obu/tests/demixing_info_parameter_data_test.cc
index cddc3d5..5dd65cf 100644
--- a/iamf/obu/tests/demixing_info_parameter_data_test.cc
+++ b/iamf/obu/tests/demixing_info_parameter_data_test.cc
@@ -168,7 +168,7 @@ TEST(WriteDefaultDemixingInfoParameterData, Writes) {
 TEST(ReadDemixingInfoParameterData, ReadDMixPMode1) {
   std::vector<uint8_t> source_data = {kDMixPMode1 << kDMixPModeBitShift};
   auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   DemixingInfoParameterData data;
   EXPECT_THAT(data.ReadAndValidate(*rb), IsOk());
   EXPECT_EQ(data.dmixp_mode, kDMixPMode1);
@@ -178,7 +178,7 @@ TEST(ReadDemixingInfoParameterData, ReadDMixPMode1) {
 TEST(ReadDemixingInfoParameterData, ReadDMixPMode3) {
   std::vector<uint8_t> source_data = {kDMixPMode3 << kDMixPModeBitShift};
   auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   DemixingInfoParameterData data;
   EXPECT_THAT(data.ReadAndValidate(*rb), IsOk());
   EXPECT_EQ(data.dmixp_mode, kDMixPMode3);
@@ -190,7 +190,7 @@ TEST(ReadDemixingInfoParameterData, ReadReservedMax) {
   std::vector<uint8_t> source_data = {kDMixPMode1 << kDMixPModeBitShift |
                                       kReservedMax};
   auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   DemixingInfoParameterData data;
   EXPECT_THAT(data.ReadAndValidate(*rb), IsOk());
   EXPECT_EQ(data.dmixp_mode, kDMixPMode1);
@@ -206,7 +206,7 @@ TEST(ReadsDefaultDemixingInfoParameterData, Reads) {
       kExpectedDMixPMode << kDMixPModeBitShift | kExpectedReserved,
       kExpectedDefaultW << kDefaultWBitShift | kExpectedReservedDefault};
   auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   DefaultDemixingInfoParameterData data;
   EXPECT_THAT(data.ReadAndValidate(*rb), IsOk());
   EXPECT_EQ(data.dmixp_mode, kExpectedDMixPMode);
diff --git a/iamf/obu/tests/extension_parameter_data_test.cc b/iamf/obu/tests/extension_parameter_data_test.cc
index fb16e4d..420b9c7 100644
--- a/iamf/obu/tests/extension_parameter_data_test.cc
+++ b/iamf/obu/tests/extension_parameter_data_test.cc
@@ -32,7 +32,7 @@ TEST(ExtensionParameterDataReadTest, NineBytes) {
                                       'a', 'r', 'b', 'i', 't', 'r', 'a', 'r',
                                       'y'};
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   ExtensionParameterData extension_parameter_data;
   EXPECT_THAT(extension_parameter_data.ReadAndValidate(*buffer), IsOk());
diff --git a/iamf/obu/tests/ia_sequence_header_test.cc b/iamf/obu/tests/ia_sequence_header_test.cc
index 1e42f80..1b78f7a 100644
--- a/iamf/obu/tests/ia_sequence_header_test.cc
+++ b/iamf/obu/tests/ia_sequence_header_test.cc
@@ -160,8 +160,8 @@ TEST(CreateFromBuffer, SimpleAndBaseProfile) {
       // `additional_profile`.
       static_cast<uint8_t>(ProfileVersion::kIamfBaseProfile)};
   const int64_t payload_size = source.size();
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header;
 
   absl::StatusOr<IASequenceHeaderObu> obu =
@@ -181,8 +181,8 @@ TEST(CreateFromBuffer, BaseEnhancedProfile) {
       // `additional_profile`.
       static_cast<uint8_t>(ProfileVersion::kIamfBaseEnhancedProfile)};
   const int64_t payload_size = source.size();
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header;
 
   absl::StatusOr<IASequenceHeaderObu> obu =
@@ -203,8 +203,8 @@ TEST(CreateFromBuffer, InvalidWhenPrimaryProfileIs3) {
       // `additional_profile`.
       static_cast<uint8_t>(ProfileVersion::kIamfBaseProfile)};
   const int64_t payload_size = source.size();
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header;
 
   EXPECT_FALSE(
@@ -221,8 +221,8 @@ TEST(CreateFromBuffer, InvalidWhenPrimaryProfileIs255) {
       // `additional_profile`.
       static_cast<uint8_t>(ProfileVersion::kIamfBaseProfile)};
   const int64_t payload_size = source.size();
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header;
 
   EXPECT_FALSE(
diff --git a/iamf/obu/tests/mix_gain_parameter_data_test.cc b/iamf/obu/tests/mix_gain_parameter_data_test.cc
index c04a039..a928975 100644
--- a/iamf/obu/tests/mix_gain_parameter_data_test.cc
+++ b/iamf/obu/tests/mix_gain_parameter_data_test.cc
@@ -41,7 +41,7 @@ TEST(AnimationStepInt16, ReadAndValidate) {
       0x01,
   };
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   AnimationStepInt16 step_animation;
   EXPECT_THAT(step_animation.ReadAndValidate(*buffer), IsOk());
@@ -58,7 +58,7 @@ TEST(AnimationLinearInt16, ReadAndValidate) {
       0x01,
   };
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   AnimationLinearInt16 linear_animation;
   EXPECT_THAT(linear_animation.ReadAndValidate(*buffer), IsOk());
@@ -76,7 +76,7 @@ TEST(AnimationBezierInt16, ReadAndValidate) {
                                       // Control point relative time.
                                       0x01};
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   AnimationBezierInt16 bezier_animation;
   EXPECT_THAT(bezier_animation.ReadAndValidate(*buffer), IsOk());
@@ -95,7 +95,7 @@ TEST(MixGainParameterData, ReadAndValidateStep) {
       0x01,
   };
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   MixGainParameterData mix_gain_parameter_data;
   EXPECT_THAT(mix_gain_parameter_data.ReadAndValidate(*buffer), IsOk());
@@ -116,7 +116,7 @@ TEST(MixGainParameterData, ReadAndValidateLinear) {
       0x01,
   };
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   MixGainParameterData mix_gain_parameter_data;
   EXPECT_THAT(mix_gain_parameter_data.ReadAndValidate(*buffer), IsOk());
@@ -142,7 +142,7 @@ TEST(MixGainParameterData, ReadAndValidateBezier) {
       0x01,
   };
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   MixGainParameterData mix_gain_parameter_data;
   EXPECT_THAT(mix_gain_parameter_data.ReadAndValidate(*buffer), IsOk());
@@ -158,7 +158,7 @@ TEST(MixGainParameterData,
       0x03,
   };
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   MixGainParameterData mix_gain_parameter_data;
   EXPECT_FALSE(mix_gain_parameter_data.ReadAndValidate(*buffer).ok());
diff --git a/iamf/obu/tests/mix_presentation_test.cc b/iamf/obu/tests/mix_presentation_test.cc
index b046b1c..834053b 100644
--- a/iamf/obu/tests/mix_presentation_test.cc
+++ b/iamf/obu/tests/mix_presentation_test.cc
@@ -953,8 +953,8 @@ TEST_F(GetNumChannelsFromLayoutTest, ErrorBeyondReservedSoundSystem) {
 TEST(CreateFromBufferTest, RejectEmptyBitstream) {
   std::vector<uint8_t> source;
   const int64_t payload_size = source.size();
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header;
   EXPECT_FALSE(
       MixPresentationObu::CreateFromBuffer(header, payload_size, *buffer).ok());
@@ -976,8 +976,8 @@ TEST(CreateFromBuffer, InvalidWithNoSubMixes) {
       // End Mix OBU.
   };
   const int64_t payload_size = source.size();
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header;
   EXPECT_FALSE(
       MixPresentationObu::CreateFromBuffer(header, payload_size, *buffer).ok());
@@ -1023,8 +1023,8 @@ TEST(CreateFromBuffer, ReadsOneSubMix) {
       // End Mix OBU.
   };
   const int64_t payload_size = source.size();
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header;
   auto obu =
       MixPresentationObu::CreateFromBuffer(header, payload_size, *buffer);
@@ -1073,8 +1073,8 @@ TEST(CreateFromBufferTest, ReadsMixPresentationTagsIntoFooter) {
   source.insert(source.end(), kMixPresentationTags.begin(),
                 kMixPresentationTags.end());
   const int64_t payload_size = source.size();
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header;
   auto obu =
       MixPresentationObu::CreateFromBuffer(header, payload_size, *buffer);
@@ -1123,8 +1123,8 @@ TEST(CreateFromBufferTest, SucceedsWithDuplicateContentLanguageTags) {
   source.insert(source.end(), kDuplicateContentLanguageTags.begin(),
                 kDuplicateContentLanguageTags.end());
   const int64_t payload_size = source.size();
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   ObuHeader header;
   auto obu =
       MixPresentationObu::CreateFromBuffer(header, payload_size, *buffer);
@@ -1155,8 +1155,8 @@ TEST(ReadSubMixAudioElementTest, AllFieldsPresent) {
       0, 4
       // End ElementMixGain
   };
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   SubMixAudioElement audio_element;
   EXPECT_THAT(audio_element.ReadAndValidate(/*count_label=*/1, *buffer),
               IsOk());
@@ -1190,8 +1190,8 @@ TEST(ReadMixPresentationLayoutTest, LoudSpeakerWithAnchoredLoudness) {
       // End anchored loudness.
       // End Layout.
   };
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   MixPresentationLayout layout;
   EXPECT_THAT(layout.ReadAndValidate(*buffer), IsOk());
   EXPECT_EQ(layout.loudness_layout.layout_type,
@@ -1225,8 +1225,8 @@ TEST(LoudspeakersSsConventionLayoutRead, ReadsSsConventionLayout) {
   std::vector<uint8_t> source = {
       (kSoundSystem << kSoundSystemBitShift | kArbitraryTwoBitReservedField)
       << kSsConventionBitShift};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   LoudspeakersSsConventionLayout ss_convention_layout;
 
   EXPECT_THAT(ss_convention_layout.Read(*buffer), IsOk());
@@ -1242,8 +1242,8 @@ TEST(LoudspeakersReservedOrBinauralLayoutRead, ReadsReservedField) {
   constexpr uint8_t kArbitrarySixBitReservedField = 63;
   std::vector<uint8_t> source = {kArbitrarySixBitReservedField
                                  << kBinauralLayoutBitShift};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   LoudspeakersReservedOrBinauralLayout reserved_binaural_layout;
 
   EXPECT_THAT(reserved_binaural_layout.Read(*buffer), IsOk());
@@ -1258,8 +1258,8 @@ TEST(LayoutReadAndValidate, ReadsLoudspeakersSsConventionLayout) {
   std::vector<uint8_t> source = {
       (Layout::kLayoutTypeLoudspeakersSsConvention << kLayoutTypeBitShift) |
       (kSoundSystem << kSoundSystemBitShift | kArbitraryTwoBitReservedField)};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   Layout loudness_layout;
 
   EXPECT_THAT(loudness_layout.ReadAndValidate(*buffer), IsOk());
@@ -1279,8 +1279,8 @@ TEST(LayoutReadAndValidate, ReadsReservedLayout) {
   constexpr uint8_t kArbitrarySixBitReservedField = 63;
   std::vector<uint8_t> source = {(kReservedLayout << kLayoutTypeBitShift) |
                                  (kArbitrarySixBitReservedField)};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   Layout loudness_layout;
 
   EXPECT_THAT(loudness_layout.ReadAndValidate(*buffer), IsOk());
@@ -1299,8 +1299,8 @@ TEST(LayoutReadAndValidate, ReadsBinauralLayout) {
   constexpr uint8_t kArbitrarySixBitReservedField = 33;
   std::vector<uint8_t> source = {(kBinauralLayout << kLayoutTypeBitShift) |
                                  (kArbitrarySixBitReservedField)};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   Layout loudness_layout;
 
   EXPECT_THAT(loudness_layout.ReadAndValidate(*buffer), IsOk());
@@ -1334,8 +1334,8 @@ TEST(ReadMixPresentationSubMixTest, AudioElementAndMultipleLayouts) {
       0, 0, 31, 0, 32,
       // End SubMix.
   };
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   MixPresentationSubMix sub_mix;
   EXPECT_THAT(sub_mix.ReadAndValidate(/*count_label=*/1, *buffer), IsOk());
   EXPECT_EQ(sub_mix.audio_elements.size(), 1);
diff --git a/iamf/obu/tests/obu_base_test.cc b/iamf/obu/tests/obu_base_test.cc
index 23901e8..216232f 100644
--- a/iamf/obu/tests/obu_base_test.cc
+++ b/iamf/obu/tests/obu_base_test.cc
@@ -71,7 +71,7 @@ TEST(ObuBaseTest, InvalidWhenValidatePayloadDerivedDoesNotReadIntegerBytes) {
 
   std::vector<uint8_t> source_data = {kObuIaReserved24 << 3, 1, 0x80};
   auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   EXPECT_FALSE(ImaginaryObuNonIntegerBytes::CreateFromBuffer(1, *rb).ok());
 }
@@ -155,7 +155,7 @@ TEST(ObuBaseTest, WritesObuFooterAndConsistentObuSize) {
 TEST(ObuBaseTest, ReadWithConsistentSize) {
   std::vector<uint8_t> source_data = {kObuIaReserved24 << 3, 1, 255};
   auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   auto obu = OneByteObu::CreateFromBuffer(ObuHeader(), 1, *rb);
   EXPECT_THAT(obu, IsOk());
@@ -168,7 +168,7 @@ TEST(ObuBaseTest, ReadDoesNotOverflowWhenBufferIsLarge) {
   std::vector<uint8_t> source_data(kJunkDataSize + kObu.size(), 0);
   source_data.insert(source_data.end() - kObu.size(), kObu.begin(), kObu.end());
   auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   // Advance the buffer to just before the OBU of interest.
   std::vector<uint8_t> junk_data(kJunkDataSize);
   ASSERT_THAT(rb->ReadUint8Span(absl::MakeSpan(junk_data)), IsOk());
@@ -180,7 +180,7 @@ TEST(ObuBaseTest, ReadFailsWhenSizeIsTooSmall) {
   const int64_t kSizeTooSmall = 0;
   std::vector<uint8_t> source_data = {kObuIaReserved24 << 3, 1, 255};
   auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   EXPECT_FALSE(
       OneByteObu::CreateFromBuffer(ObuHeader(), kSizeTooSmall, *rb).ok());
@@ -192,7 +192,7 @@ TEST(ObuBaseTest, ReadsFooterWhenObuSizeIsTooLarge) {
 
   std::vector<uint8_t> source_data = {255, 'e', 'x', 't'};
   auto rb = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   const auto obu =
       OneByteObu::CreateFromBuffer(ObuHeader(), kSizeWithExtraData, *rb);
diff --git a/iamf/obu/tests/obu_header_test.cc b/iamf/obu/tests/obu_header_test.cc
index fea24fe..4e89554 100644
--- a/iamf/obu/tests/obu_header_test.cc
+++ b/iamf/obu/tests/obu_header_test.cc
@@ -536,7 +536,7 @@ TEST_F(ObuHeaderTest, ReadAndValidateIncludeAllConditionalFields) {
       // `extension_header_bytes`
       100, 101, 102};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_THAT(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_),
       IsOk());
@@ -569,7 +569,7 @@ TEST_F(ObuHeaderTest, ReadAndValidateImplicitAudioFrameId17) {
       // `obu_size == 1024`
       0x80, 0x08};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_THAT(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_),
       IsOk());
@@ -598,7 +598,7 @@ TEST_F(ObuHeaderTest, ReadAndValidateIaSequenceHeaderNoConditionalFields) {
       // `obu_size == 1024`
       0x80, 0x08};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_THAT(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_),
       IsOk());
@@ -627,7 +627,7 @@ TEST_F(ObuHeaderTest, ReadAndValidateIaSequenceHeaderRedundantCopy) {
       // `obu_size == 1024`
       0x80, 0x08};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_THAT(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_),
       IsOk());
@@ -656,7 +656,7 @@ TEST_F(ObuHeaderTest, ReadAndValidateUpperEdgeObuSizeOneByteLeb128) {
       // `obu_size == 127`
       0x7f};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_THAT(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_),
       IsOk());
@@ -685,7 +685,7 @@ TEST_F(ObuHeaderTest, ReadAndValidateLowerEdgeObuSizeTwoByteLeb128) {
       // `obu_size == 128`
       0x80, 0x01};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_THAT(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_),
       IsOk());
@@ -711,7 +711,7 @@ TEST_F(ObuHeaderTest, InvalidWhenObuWouldExceedTwoMegabytes_FourByteObuSize) {
                                       // `obu_size == 268435456 - 1`
                                       0xff, 0xff, 0xff, 0x7f};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_FALSE(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_)
           .ok());
@@ -722,7 +722,7 @@ TEST_F(ObuHeaderTest, InvalidWhenObuWouldExceedTwoMegabytes_FiveByteObuSize) {
                                       // `obu_size == 268435456`
                                       0x80, 0x80, 0x80, 0x80, 0x01};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_FALSE(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_)
           .ok());
@@ -733,7 +733,7 @@ TEST_F(ObuHeaderTest, InvalidWhenObuWouldExceedTwoMegabytes_MaxByteObuSize) {
                                       // `obu_size == 4294967295`
                                       0xff, 0xff, 0xff, 0xff, 0x0f};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_FALSE(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_)
           .ok());
@@ -746,7 +746,7 @@ TEST_F(ObuHeaderTest, MaxObuSizeWithMinimalLeb128) {
                                       // `obu_size == 2 megabytes - 4`
                                       0xfc, 0xff, 0x7f};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_THAT(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_),
       IsOk());
@@ -761,7 +761,7 @@ TEST_F(ObuHeaderTest, InvalidEdgeOverMaxSizeWithMinimalLeb128) {
                                       // `obu_size == 2 megabytes - 3`
                                       0xfd, 0xff, 0x7f};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   EXPECT_FALSE(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_)
@@ -776,7 +776,7 @@ TEST_F(ObuHeaderTest, MaxObuSizeWithFixesSizeLebEightBytes) {
                                       0xf7, 0xff, 0xff, 0x80, 0x80, 0x80, 0x80,
                                       0x00};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_THAT(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_),
       IsOk());
@@ -793,7 +793,7 @@ TEST_F(ObuHeaderTest, InvalidEdgeOverMaxSizeWithFixedSizeLebEightBytes) {
                                       0xf8, 0xff, 0xff, 0x80, 0x80, 0x80, 0x80,
                                       0x00};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   EXPECT_FALSE(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_)
@@ -812,7 +812,7 @@ TEST_F(ObuHeaderTest, ReadAndValidateMaxObuSizeWithMinimalTrim) {
       // `num_samples_to_trim_at_start`.
       0x00};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_THAT(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_),
       IsOk());
@@ -846,7 +846,7 @@ TEST_F(ObuHeaderTest,
       // `num_samples_to_trim_at_start`.
       0x00};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_FALSE(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_)
           .ok());
@@ -868,7 +868,7 @@ TEST_F(ObuHeaderTest, ReadAndValidateTrimmingStatusFlagNonZeroTrimAtEnd) {
                                       // `num_samples_to_trim_at_start`.
                                       0x00};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_THAT(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_),
       IsOk());
@@ -891,7 +891,7 @@ TEST_F(ObuHeaderTest, ReadAndValidateTrimmingStatusFlagNonZeroTrimAtStart) {
                                       // `num_samples_to_trim_at_start`.
                                       0x02};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_THAT(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_),
       IsOk());
@@ -914,7 +914,7 @@ TEST_F(ObuHeaderTest, ReadAndValidateTrimmingStatusFlagNonZeroBothTrims) {
                                       // `num_samples_to_trim_at_start`.
                                       0x02};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_THAT(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_),
       IsOk());
@@ -937,7 +937,7 @@ TEST_F(ObuHeaderTest, NegativePayloadSizeNotAcceptable) {
                                       // `num_samples_to_trim_at_start`.
                                       0x02};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_THAT(
       obu_header_.ReadAndValidate(*read_bit_buffer, payload_serialized_size_),
       Not(IsOk()));
@@ -948,7 +948,7 @@ TEST(PeekObuTypeAndTotalObuSize, Success) {
                                       // `obu_size`
                                       2};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   auto start_position = read_bit_buffer->Tell();
 
   auto header_metadata =
@@ -967,7 +967,7 @@ TEST(PeekObuTypeAndTotalObuSize, SuccessWithMaxSizedObuSize) {
                                       0xf7, 0xff, 0xff, 0x80, 0x80, 0x80, 0x80,
                                       0x00};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   auto start_position = read_bit_buffer->Tell();
 
   auto header_metadata =
@@ -984,7 +984,7 @@ TEST(PeekObuTypeAndTotalObuSize, SuccessWithMaxSizedObuSize) {
 TEST(PeekObuTypeAndTotalObuSize, EmptyBitBufferResourceExhausted) {
   std::vector<uint8_t> source_data = {};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   auto start_position = read_bit_buffer->Tell();
 
   auto header_metadata =
@@ -998,7 +998,7 @@ TEST(PeekObuTypeAndTotalObuSize, EmptyBitBufferResourceExhausted) {
 TEST(PeekObuTypeAndTotalObuSize, NoObuSizeResourceExhausted) {
   std::vector<uint8_t> source_data = {kObuIaAudioFrameId0};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   auto start_position = read_bit_buffer->Tell();
   auto header_metadata =
       ObuHeader::PeekObuTypeAndTotalObuSize(*read_bit_buffer);
@@ -1011,7 +1011,7 @@ TEST(PeekObuTypeAndTotalObuSize, NoObuSizeResourceExhausted) {
 TEST(PeekObuTypeAndTotalObuSize, ReturnsResourceExhaustedForPartialObuSize) {
   std::vector<uint8_t> source_data = {kObuIaAudioFrameId0, 0x80};
   auto read_bit_buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   auto start_position = read_bit_buffer->Tell();
 
   auto header_metadata =
diff --git a/iamf/obu/tests/param_definitions_test.cc b/iamf/obu/tests/param_definitions_test.cc
index c5fab13..ab6a964 100644
--- a/iamf/obu/tests/param_definitions_test.cc
+++ b/iamf/obu/tests/param_definitions_test.cc
@@ -682,8 +682,8 @@ TEST(ReadMixGainParamDefinitionTest, DefaultMixGainMode1) {
       0x80,
       // Default Mix Gain.
       0, 4};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   EXPECT_THAT(param_definition.ReadAndValidate(*buffer), IsOk());
   EXPECT_EQ(*param_definition.GetType(),
             ParamDefinition::kParameterDefinitionMixGain);
@@ -712,8 +712,8 @@ TEST(ReadMixGainParamDefinitionTest, DefaultMixGainWithSubblockArray) {
       24,
       // Default Mix Gain.
       0, 3};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(source));
   EXPECT_THAT(param_definition.ReadAndValidate(*buffer), IsOk());
   EXPECT_EQ(*param_definition.GetType(),
             ParamDefinition::kParameterDefinitionMixGain);
@@ -731,8 +731,8 @@ TEST(ReadReconGainParamDefinitionTest, Default) {
                                     64,
                                     // Constant Subblock Duration.
                                     64};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(bitstream));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   ReconGainParamDefinition param_definition = ReconGainParamDefinition(0);
   EXPECT_TRUE(param_definition.ReadAndValidate(*buffer).ok());
   EXPECT_EQ(*param_definition.GetType(),
@@ -747,8 +747,8 @@ TEST(ReadReconGainParamDefinitionTest, Mode1) {
       1,
       // Param Definition Mode (upper bit), next 7 bits reserved.
       0x80};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(bitstream));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   ReconGainParamDefinition param_definition = ReconGainParamDefinition(0);
   EXPECT_THAT(param_definition.ReadAndValidate(*buffer), IsOk());
 }
@@ -765,8 +765,8 @@ TEST(ReadReconGainParamDefinitionTest, Mode0NonZeroSubblockDuration) {
       0xc0, 0x00,
       // `constant_subblock_duration`.
       0xc0, 0x00};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(bitstream));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   ReconGainParamDefinition param_definition = ReconGainParamDefinition(0);
   EXPECT_THAT(param_definition.ReadAndValidate(*buffer), IsOk());
 }
@@ -788,8 +788,8 @@ TEST(ReadReconGainParamDefinitionTest, Mode0SubblockArray) {
       // `subblock_durations`
       // `subblock_duration[0]`
       64};
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(bitstream));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   ReconGainParamDefinition param_definition = ReconGainParamDefinition(0);
   EXPECT_THAT(param_definition.ReadAndValidate(*buffer), IsOk());
 }
@@ -810,8 +810,8 @@ TEST(ReadDemixingParamDefinitionTest, DefaultDmixPMode) {
                                     // `default_w`.
                                     0};
 
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(bitstream));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   DemixingParamDefinition param_definition = DemixingParamDefinition();
   EXPECT_THAT(param_definition.ReadAndValidate(*buffer), IsOk());
   EXPECT_EQ(*param_definition.GetType(),
@@ -836,8 +836,8 @@ TEST(ReadDemixingParamDefinitionTest, DefaultW) {
                                     // `default_w`.
                                     1 << 4};
 
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(bitstream));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   DemixingParamDefinition param_definition = DemixingParamDefinition();
   EXPECT_THAT(param_definition.ReadAndValidate(*buffer), IsOk());
   EXPECT_EQ(*param_definition.GetType(),
@@ -854,8 +854,8 @@ TEST(ExtendedParamDefinition, ReadAndValidateWithZeroSize) {
   std::vector<uint8_t> bitstream = {// param_definition_size.
                                     0x00};
 
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(bitstream));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   ExtendedParamDefinition param_definition =
       ExtendedParamDefinition(kExtensiontype);
   EXPECT_THAT(param_definition.ReadAndValidate(*buffer), IsOk());
@@ -874,8 +874,8 @@ TEST(ExtendedParamDefinition, ReadAndValidateWithNonZeroSize) {
                                     // param_definition_bytes.
                                     'e', 'x', 't', 'r', 'a'};
 
-  auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(bitstream));
+  auto buffer =
+      MemoryBasedReadBitBuffer::CreateFromSpan(absl::MakeConstSpan(bitstream));
   ExtendedParamDefinition param_definition =
       ExtendedParamDefinition(kExtensiontype);
   EXPECT_THAT(param_definition.ReadAndValidate(*buffer), IsOk());
diff --git a/iamf/obu/tests/parameter_block_test.cc b/iamf/obu/tests/parameter_block_test.cc
index d884b41..942c1e9 100644
--- a/iamf/obu/tests/parameter_block_test.cc
+++ b/iamf/obu/tests/parameter_block_test.cc
@@ -71,7 +71,7 @@ TEST(CreateFromBuffer, InvalidWhenObuSizeIsTooSmallToReadParameterId) {
   const int64_t kCorrectObuSize = source_data.size();
   constexpr int64_t kIncorrectObuSize = 1;
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   MixGainParamDefinition param_definition;
   param_definition.parameter_id_ = kParameterId;
@@ -128,7 +128,7 @@ TEST(ParameterBlockObu, CreateFromBufferParamDefinitionMode1) {
   };
   const int64_t payload_size = source_data.size();
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   MixGainParamDefinition param_definition;
   param_definition.parameter_id_ = kParameterId;
   param_definition.parameter_rate_ = 1;
@@ -185,7 +185,7 @@ TEST(ParameterBlockObu, CreateFromBufferParamDefinitionMode0) {
   };
   const int64_t payload_size = source_data.size();
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   MixGainParamDefinition param_definition;
   param_definition.parameter_id_ = kParameterId;
   param_definition.parameter_rate_ = 1;
@@ -250,7 +250,7 @@ TEST(ParameterBlockObu,
   };
   const int64_t payload_size = source_data.size();
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   MixGainParamDefinition param_definition;
   param_definition.parameter_id_ = kParameterId;
   param_definition.parameter_rate_ = 1;
@@ -280,7 +280,7 @@ TEST(ParameterBlockObu, CreateFromBufferParamRequiresParamDefinition) {
   };
   const int64_t payload_size = source_data.size();
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   MixGainParamDefinition param_definition;
   param_definition.parameter_id_ = kParameterId;
   param_definition.parameter_rate_ = 1;
@@ -297,7 +297,7 @@ TEST(ParameterBlockObu, CreateFromBufferParamRequiresParamDefinition) {
   param_definitions.erase(kParameterId);
   auto buffer_to_use_without_metadata =
       MemoryBasedReadBitBuffer::CreateFromSpan(
-          1024, absl::MakeConstSpan(source_data));
+          absl::MakeConstSpan(source_data));
   EXPECT_FALSE(ParameterBlockObu::CreateFromBuffer(
                    ObuHeader{.obu_type = kObuIaParameterBlock}, payload_size,
                    param_definitions, *buffer_to_use_without_metadata)
@@ -312,7 +312,7 @@ TEST(ParameterBlockObu, CreateFromBufferDemixingParamDefinitionMode0) {
                                       kDMixPMode2 << 5};
   const int64_t payload_size = source_data.size();
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   DemixingParamDefinition param_definition;
   param_definition.parameter_id_ = kParameterId;
   param_definition.parameter_rate_ = 1;
diff --git a/iamf/obu/tests/recon_gain_info_parameter_data_test.cc b/iamf/obu/tests/recon_gain_info_parameter_data_test.cc
index 9edab7d..6962c42 100644
--- a/iamf/obu/tests/recon_gain_info_parameter_data_test.cc
+++ b/iamf/obu/tests/recon_gain_info_parameter_data_test.cc
@@ -37,7 +37,7 @@ TEST(ReconGainInfoParameterDataReadTest, TwoLayerParamDefinition) {
       // `layer[1]`.
       ReconGainElement::kReconGainFlagR, 1};
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   ReconGainInfoParameterData recon_gain_info_parameter_data;
   recon_gain_info_parameter_data.recon_gain_is_present_flags =
@@ -79,7 +79,7 @@ TEST(ReconGainInfoParameterDataReadTest, MaxLayer7_1_4) {
           (ReconGainElement::kReconGainFlagRtb >> 7),
       8, 9};
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   ReconGainInfoParameterData recon_gain_info_parameter_data;
   recon_gain_info_parameter_data.recon_gain_is_present_flags =
diff --git a/iamf/obu/tests/temporal_delimiter_test.cc b/iamf/obu/tests/temporal_delimiter_test.cc
index bb81b3d..76f98d0 100644
--- a/iamf/obu/tests/temporal_delimiter_test.cc
+++ b/iamf/obu/tests/temporal_delimiter_test.cc
@@ -119,7 +119,7 @@ TEST_F(TemporalDelimiterTest,
 TEST(CreateFromBuffer, SucceedsWithEmptyBuffer) {
   std::vector<uint8_t> source_data = {};
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   EXPECT_THAT(TemporalDelimiterObu::CreateFromBuffer(
                   ObuHeader(), source_data.size(), *buffer),
@@ -129,7 +129,7 @@ TEST(CreateFromBuffer, SucceedsWithEmptyBuffer) {
 TEST(CreateFromBuffer, SetsObuType) {
   std::vector<uint8_t> source_data = {};
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
 
   absl::StatusOr<TemporalDelimiterObu> obu =
       TemporalDelimiterObu::CreateFromBuffer(ObuHeader(), source_data.size(),
@@ -142,7 +142,7 @@ TEST(CreateFromBuffer, DoesNotConsumeBufferWhenObuPayloadSizeIsZero) {
   const int64_t kObuPayloadSize = 0;
   std::vector<uint8_t> source_data = {99};
   auto buffer = MemoryBasedReadBitBuffer::CreateFromSpan(
-      1024, absl::MakeConstSpan(source_data));
+      absl::MakeConstSpan(source_data));
   EXPECT_THAT(TemporalDelimiterObu::CreateFromBuffer(ObuHeader(),
                                                      kObuPayloadSize, *buffer),
               IsOk());
diff --git a/iamf/obu/types.h b/iamf/obu/types.h
index a3cd683..f0c4138 100644
--- a/iamf/obu/types.h
+++ b/iamf/obu/types.h
@@ -42,7 +42,7 @@ typedef double InternalSampleType;
  * for timing purposes in an IA Sequence. I.e. if the sample rate is 48 kHz,
  * then a timestamp of 1000 represents `1000/48000Hz ~= .02083s`.
  */
-typedef int32_t InternalTimestamp;
+typedef int64_t InternalTimestamp;
 
 }  // namespace iamf_tools
 
```

