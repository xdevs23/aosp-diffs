```diff
diff --git a/.github/ci-gradle.properties b/.github/ci-gradle.properties
new file mode 100644
index 0000000..6fe41e0
--- /dev/null
+++ b/.github/ci-gradle.properties
@@ -0,0 +1,26 @@
+#
+# Copyright 2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+org.gradle.configureondemand=true
+org.gradle.caching=true
+org.gradle.parallel=true
+
+# Declare we support AndroidX
+android.useAndroidX=true
+
+org.gradle.jvmargs=-Xmx4608m -XX:MaxMetaspaceSize=1536m -XX:+HeapDumpOnOutOfMemoryError
+
+kotlin.compiler.execution.strategy=in-process
diff --git a/.github/workflows/code-check.yml b/.github/workflows/code-check.yml
index 37fb816..d7e3ea5 100644
--- a/.github/workflows/code-check.yml
+++ b/.github/workflows/code-check.yml
@@ -16,7 +16,7 @@ jobs:
     runs-on: ubuntu-latest
     strategy:
       matrix:
-        python-version: ["3.8", "3.9", "3.10", "3.11", "3.12"]
+        python-version: ["3.9", "3.10", "3.11", "3.12", "3.13.0"]
       fail-fast: false
 
     steps:
@@ -33,7 +33,7 @@ jobs:
     - name: Install dependencies
       run: |
         python -m pip install --upgrade pip
-        python -m pip install ".[build,test,development,pandora]"
+        python -m pip install ".[build,test,development]"
     - name: Check
       run: |
         invoke project.pre-commit
diff --git a/.github/workflows/gradle-btbench.yml b/.github/workflows/gradle-btbench.yml
new file mode 100644
index 0000000..3277d24
--- /dev/null
+++ b/.github/workflows/gradle-btbench.yml
@@ -0,0 +1,33 @@
+name: Gradle Android Build & test
+
+on:
+  push:
+    branches: [ main ]
+  pull_request:
+    branches: [ main ]
+    paths:
+      - 'extras/android/BtBench/**'
+
+permissions:
+  contents: read
+
+jobs:
+  build:
+    runs-on: ubuntu-latest
+    timeout-minutes: 40
+
+    steps:
+      - name: Check out from Git
+        uses: actions/checkout@v3
+
+      - name: Set up JDK
+        uses: actions/setup-java@v4
+        with:
+          distribution: 'zulu'
+          java-version: 17
+
+      - name: Setup Gradle
+        uses: gradle/actions/setup-gradle@v3
+
+      - name: Build with Gradle
+        run: cd extras/android/BtBench && ./gradlew build
diff --git a/.github/workflows/python-avatar.yml b/.github/workflows/python-avatar.yml
index 90ca0f0..98a4905 100644
--- a/.github/workflows/python-avatar.yml
+++ b/.github/workflows/python-avatar.yml
@@ -32,7 +32,7 @@ jobs:
       - name: Install
         run: |
           python -m pip install --upgrade pip
-          python -m pip install .[avatar,pandora]
+          python -m pip install .[avatar]
       - name: Rootcanal
         run: nohup python -m rootcanal > rootcanal.log &
       - name: Test
@@ -44,7 +44,7 @@ jobs:
         run: cat rootcanal.log
       - name: Upload Mobly logs
         if: always()
-        uses: actions/upload-artifact@v3
+        uses: actions/upload-artifact@v4
         with:
-          name: mobly-logs
+          name: mobly-logs-${{ strategy.job-index }}
           path: /tmp/logs/mobly/bumble.bumbles/
diff --git a/.github/workflows/python-build-test.yml b/.github/workflows/python-build-test.yml
index 230779f..ccb1030 100644
--- a/.github/workflows/python-build-test.yml
+++ b/.github/workflows/python-build-test.yml
@@ -16,7 +16,7 @@ jobs:
     strategy:
       matrix:
         os: ['ubuntu-latest', 'macos-latest', 'windows-latest']
-        python-version: ["3.8", "3.9", "3.10", "3.11", "3.12"]
+        python-version: ["3.9", "3.10", "3.11", "3.12", "3.13"]
       fail-fast: false
 
     steps:
@@ -46,7 +46,7 @@ jobs:
     runs-on: ubuntu-latest
     strategy:
       matrix:
-        python-version: [ "3.8", "3.9", "3.10", "3.11", "3.12" ]
+        python-version: ["3.9", "3.10", "3.11", "3.12", "3.13"]
         rust-version: [ "1.76.0", "stable" ]
       fail-fast: false
     steps:
diff --git a/.vscode/settings.json b/.vscode/settings.json
index 777c47b..e0ff04e 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -14,9 +14,12 @@
         "ASHA",
         "asyncio",
         "ATRAC",
+        "auracast",
         "avctp",
         "avdtp",
         "avrcp",
+        "biginfo",
+        "bigs",
         "bitpool",
         "bitstruct",
         "BSCP",
@@ -36,6 +39,7 @@
         "deregistration",
         "dhkey",
         "diversifier",
+        "ediv",
         "endianness",
         "ESCO",
         "Fitbit",
@@ -47,6 +51,7 @@
         "libc",
         "liblc",
         "libusb",
+        "maxs",
         "MITM",
         "MSBC",
         "NDIS",
@@ -54,8 +59,10 @@
         "NONBLOCK",
         "NONCONN",
         "OXIMETER",
+        "PDUS",
         "popleft",
         "PRAND",
+        "prefs",
         "protobuf",
         "psms",
         "pyee",
diff --git a/Android.bp b/Android.bp
index c5a7c8c..62c95d8 100644
--- a/Android.bp
+++ b/Android.bp
@@ -21,11 +21,13 @@ python_library_host {
         "bumble/*.py",
         "bumble/drivers/*.py",
         "bumble/profiles/*.py",
-        "bumble/transport/*.py",
+        "bumble/transport/**/*.py",
+        "bumble/crypto/*.py",
     ],
     libs: [
+        "libprotobuf-python",
         "pyee",
-    ]
+    ],
 }
 
 python_library_host {
@@ -36,9 +38,8 @@ python_library_host {
     libs: [
         "bumble",
         "pandora-python",
-        "libprotobuf-python",
     ],
     data: [
-        "bumble/pandora/py.typed"
-    ]
-}
\ No newline at end of file
+        "bumble/pandora/py.typed",
+    ],
+}
diff --git a/METADATA b/METADATA
index e4b9b79..df56299 100644
--- a/METADATA
+++ b/METADATA
@@ -1,17 +1,20 @@
-name: "Bumble"
-description:
-    "Bumble is a full-featured Bluetooth stack written entirely in Python."
+# This project was upgraded with external_updater.
+# Usage: tools/external_updater/updater.sh update external/python/bumble
+# For more info, check https://cs.android.com/android/platform/superproject/main/+/main:tools/external_updater/README.md
 
+name: "Bumble"
+description: "Bumble is a full-featured Bluetooth stack written entirely in Python."
 third_party {
-  url {
-    type: HOMEPAGE
-    value: "https://google.github.io/bumble/"
+  license_type: NOTICE
+  last_upgrade_date {
+    year: 2025
+    month: 5
+    day: 19
   }
-  url {
-    type: GIT
+  homepage: "https://google.github.io/bumble/"
+  identifier {
+    type: "Git"
     value: "https://github.com/google/bumble"
+    version: "3b399ea1a2bc52f64e4f6317fad75fd1b5db3e8c"
   }
-  version: "737abdc481b226b16d85174d9ae0ebd9346b0fb4"
-  last_upgrade_date { year: 2024 month: 9 day: 17 }
-  license_type: NOTICE
 }
diff --git a/OWNERS b/OWNERS
index 21ba05c..baa8116 100644
--- a/OWNERS
+++ b/OWNERS
@@ -1,4 +1,5 @@
 boccongibod@google.com
 charliebout@google.com
 girardier@google.com
+joshwu@google.com
 include platform/system/core:/janitors/OWNERS #{LAST_RESORT_SUGGESTION}
diff --git a/apps/auracast.py b/apps/auracast.py
index 96f2a23..cceb142 100644
--- a/apps/auracast.py
+++ b/apps/auracast.py
@@ -1,4 +1,4 @@
-# Copyright 2024 Google LLC
+# Copyright 2025 Google LLC
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -16,29 +16,47 @@
 # Imports
 # -----------------------------------------------------------------------------
 from __future__ import annotations
+
 import asyncio
+import collections
 import contextlib
 import dataclasses
+import functools
 import logging
 import os
-from typing import cast, Any, AsyncGenerator, Coroutine, Dict, Optional, Tuple
+import struct
+from typing import (
+    Any,
+    AsyncGenerator,
+    Coroutine,
+    Deque,
+    Optional,
+    Tuple,
+)
 
 import click
-import pyee
 
+try:
+    import lc3  # type: ignore  # pylint: disable=E0401
+except ImportError as e:
+    raise ImportError(
+        "Try `python -m pip install \"git+https://github.com/google/liblc3.git\"`."
+    ) from e
+
+from bumble.audio import io as audio_io
 from bumble.colors import color
-import bumble.company_ids
-import bumble.core
+from bumble import company_ids
+from bumble import core
+from bumble import gatt
+from bumble import hci
+from bumble.profiles import bap
+from bumble.profiles import le_audio
+from bumble.profiles import pbp
+from bumble.profiles import bass
 import bumble.device
-import bumble.gatt
-import bumble.hci
-import bumble.profiles.bap
-import bumble.profiles.bass
-import bumble.profiles.pbp
 import bumble.transport
 import bumble.utils
 
-
 # -----------------------------------------------------------------------------
 # Logging
 # -----------------------------------------------------------------------------
@@ -49,30 +67,69 @@ logger = logging.getLogger(__name__)
 # Constants
 # -----------------------------------------------------------------------------
 AURACAST_DEFAULT_DEVICE_NAME = 'Bumble Auracast'
-AURACAST_DEFAULT_DEVICE_ADDRESS = bumble.hci.Address('F0:F1:F2:F3:F4:F5')
+AURACAST_DEFAULT_DEVICE_ADDRESS = hci.Address('F0:F1:F2:F3:F4:F5')
 AURACAST_DEFAULT_SYNC_TIMEOUT = 5.0
 AURACAST_DEFAULT_ATT_MTU = 256
+AURACAST_DEFAULT_FRAME_DURATION = 10000
+AURACAST_DEFAULT_SAMPLE_RATE = 48000
+AURACAST_DEFAULT_TRANSMIT_BITRATE = 80000
+
+
+# -----------------------------------------------------------------------------
+# Utils
+# -----------------------------------------------------------------------------
+def codec_config_string(
+    codec_config: bap.CodecSpecificConfiguration, indent: str
+) -> str:
+    lines = []
+    if codec_config.sampling_frequency is not None:
+        lines.append(f'Sampling Frequency: {codec_config.sampling_frequency.hz} hz')
+    if codec_config.frame_duration is not None:
+        lines.append(f'Frame Duration:     {codec_config.frame_duration.us} µs')
+    if codec_config.octets_per_codec_frame is not None:
+        lines.append(f'Frame Size:         {codec_config.octets_per_codec_frame} bytes')
+    if codec_config.codec_frames_per_sdu is not None:
+        lines.append(f'Frames Per SDU:     {codec_config.codec_frames_per_sdu}')
+    if codec_config.audio_channel_allocation is not None:
+        lines.append(
+            f'Audio Location:     {codec_config.audio_channel_allocation.name}'
+        )
+    return '\n'.join(indent + line for line in lines)
+
+
+def broadcast_code_bytes(broadcast_code: str) -> bytes:
+    """
+    Convert a broadcast code string to a 16-byte value.
+
+    If `broadcast_code` is `0x` followed by 32 hex characters, it is interpreted as a
+    raw 16-byte raw broadcast code in big-endian byte order.
+    Otherwise, `broadcast_code` is converted to a 16-byte value as specified in
+    BLUETOOTH CORE SPECIFICATION Version 6.0 | Vol 3, Part C , section 3.2.6.3
+    """
+    if broadcast_code.startswith("0x") and len(broadcast_code) == 34:
+        return bytes.fromhex(broadcast_code[2:])[::-1]
+
+    broadcast_code_utf8 = broadcast_code.encode("utf-8")
+    if len(broadcast_code_utf8) > 16:
+        raise ValueError("broadcast code must be <= 16 bytes in utf-8 encoding")
+    padding = bytes(16 - len(broadcast_code_utf8))
+    return broadcast_code_utf8 + padding
 
 
 # -----------------------------------------------------------------------------
 # Scan For Broadcasts
 # -----------------------------------------------------------------------------
-class BroadcastScanner(pyee.EventEmitter):
+class BroadcastScanner(bumble.utils.EventEmitter):
     @dataclasses.dataclass
-    class Broadcast(pyee.EventEmitter):
-        name: str
+    class Broadcast(bumble.utils.EventEmitter):
+        name: str | None
         sync: bumble.device.PeriodicAdvertisingSync
+        broadcast_id: int
         rssi: int = 0
-        public_broadcast_announcement: Optional[
-            bumble.profiles.pbp.PublicBroadcastAnnouncement
-        ] = None
-        broadcast_audio_announcement: Optional[
-            bumble.profiles.bap.BroadcastAudioAnnouncement
-        ] = None
-        basic_audio_announcement: Optional[
-            bumble.profiles.bap.BasicAudioAnnouncement
-        ] = None
-        appearance: Optional[bumble.core.Appearance] = None
+        public_broadcast_announcement: Optional[pbp.PublicBroadcastAnnouncement] = None
+        broadcast_audio_announcement: Optional[bap.BroadcastAudioAnnouncement] = None
+        basic_audio_announcement: Optional[bap.BasicAudioAnnouncement] = None
+        appearance: Optional[core.Appearance] = None
         biginfo: Optional[bumble.device.BIGInfoAdvertisement] = None
         manufacturer_data: Optional[Tuple[str, bytes]] = None
 
@@ -86,42 +143,32 @@ class BroadcastScanner(pyee.EventEmitter):
         def update(self, advertisement: bumble.device.Advertisement) -> None:
             self.rssi = advertisement.rssi
             for service_data in advertisement.data.get_all(
-                bumble.core.AdvertisingData.SERVICE_DATA
+                core.AdvertisingData.Type.SERVICE_DATA_16_BIT_UUID
             ):
-                assert isinstance(service_data, tuple)
                 service_uuid, data = service_data
-                assert isinstance(data, bytes)
 
-                if (
-                    service_uuid
-                    == bumble.gatt.GATT_PUBLIC_BROADCAST_ANNOUNCEMENT_SERVICE
-                ):
+                if service_uuid == gatt.GATT_PUBLIC_BROADCAST_ANNOUNCEMENT_SERVICE:
                     self.public_broadcast_announcement = (
-                        bumble.profiles.pbp.PublicBroadcastAnnouncement.from_bytes(data)
+                        pbp.PublicBroadcastAnnouncement.from_bytes(data)
                     )
                     continue
 
-                if (
-                    service_uuid
-                    == bumble.gatt.GATT_BROADCAST_AUDIO_ANNOUNCEMENT_SERVICE
-                ):
+                if service_uuid == gatt.GATT_BROADCAST_AUDIO_ANNOUNCEMENT_SERVICE:
                     self.broadcast_audio_announcement = (
-                        bumble.profiles.bap.BroadcastAudioAnnouncement.from_bytes(data)
+                        bap.BroadcastAudioAnnouncement.from_bytes(data)
                     )
                     continue
 
-            self.appearance = advertisement.data.get(  # type: ignore[assignment]
-                bumble.core.AdvertisingData.APPEARANCE
+            self.appearance = advertisement.data.get(
+                core.AdvertisingData.Type.APPEARANCE
             )
 
             if manufacturer_data := advertisement.data.get(
-                bumble.core.AdvertisingData.MANUFACTURER_SPECIFIC_DATA
+                core.AdvertisingData.Type.MANUFACTURER_SPECIFIC_DATA
             ):
-                assert isinstance(manufacturer_data, tuple)
-                company_id = cast(int, manufacturer_data[0])
-                data = cast(bytes, manufacturer_data[1])
+                company_id, data = manufacturer_data
                 self.manufacturer_data = (
-                    bumble.company_ids.COMPANY_IDENTIFIERS.get(
+                    company_ids.COMPANY_IDENTIFIERS.get(
                         company_id, f'0x{company_id:04X}'
                     ),
                     data,
@@ -135,7 +182,8 @@ class BroadcastScanner(pyee.EventEmitter):
                 self.sync.advertiser_address,
                 color(self.sync.state.name, 'green'),
             )
-            print(f'  {color("Name", "cyan")}:         {self.name}')
+            if self.name is not None:
+                print(f'  {color("Name", "cyan")}:         {self.name}')
             if self.appearance:
                 print(f'  {color("Appearance", "cyan")}:   {str(self.appearance)}')
             print(f'  {color("RSSI", "cyan")}:         {self.rssi}')
@@ -156,25 +204,24 @@ class BroadcastScanner(pyee.EventEmitter):
             if self.public_broadcast_announcement:
                 print(
                     f'  {color("Features", "cyan")}:     '
-                    f'{self.public_broadcast_announcement.features}'
-                )
-                print(
-                    f'  {color("Metadata", "cyan")}:     '
-                    f'{self.public_broadcast_announcement.metadata}'
+                    f'{self.public_broadcast_announcement.features.name}'
                 )
+                print(f'  {color("Metadata", "cyan")}:')
+                print(self.public_broadcast_announcement.metadata.pretty_print('    '))
 
             if self.basic_audio_announcement:
                 print(color('  Audio:', 'cyan'))
                 print(
                     color('    Presentation Delay:', 'magenta'),
                     self.basic_audio_announcement.presentation_delay,
+                    "µs",
                 )
                 for subgroup in self.basic_audio_announcement.subgroups:
                     print(color('    Subgroup:', 'magenta'))
                     print(color('      Codec ID:', 'yellow'))
                     print(
                         color('        Coding Format:           ', 'green'),
-                        subgroup.codec_id.coding_format.name,
+                        subgroup.codec_id.codec_id.name,
                     )
                     print(
                         color('        Company ID:              ', 'green'),
@@ -184,37 +231,34 @@ class BroadcastScanner(pyee.EventEmitter):
                         color('        Vendor Specific Codec ID:', 'green'),
                         subgroup.codec_id.vendor_specific_codec_id,
                     )
+                    print(color('      Codec Config:', 'yellow'))
                     print(
-                        color('      Codec Config:', 'yellow'),
-                        subgroup.codec_specific_configuration,
+                        codec_config_string(
+                            subgroup.codec_specific_configuration, '        '
+                        ),
                     )
-                    print(color('      Metadata:    ', 'yellow'), subgroup.metadata)
+                    print(color('      Metadata:    ', 'yellow'))
+                    print(subgroup.metadata.pretty_print('        '))
 
                     for bis in subgroup.bis:
                         print(color(f'      BIS [{bis.index}]:', 'yellow'))
+                        print(color('       Codec Config:', 'green'))
                         print(
-                            color('       Codec Config:', 'green'),
-                            bis.codec_specific_configuration,
+                            codec_config_string(
+                                bis.codec_specific_configuration, '         '
+                            ),
                         )
 
             if self.biginfo:
                 print(color('  BIG:', 'cyan'))
-                print(
-                    color('    Number of BIS:', 'magenta'),
-                    self.biginfo.num_bis,
-                )
-                print(
-                    color('    PHY:          ', 'magenta'),
-                    self.biginfo.phy.name,
-                )
-                print(
-                    color('    Framed:       ', 'magenta'),
-                    self.biginfo.framed,
-                )
-                print(
-                    color('    Encrypted:    ', 'magenta'),
-                    self.biginfo.encrypted,
-                )
+                print(color('    Number of BIS:', 'magenta'), self.biginfo.num_bis)
+                print(color('    ISO Interval: ', 'magenta'), self.biginfo.iso_interval)
+                print(color('    Max PDU:      ', 'magenta'), self.biginfo.max_pdu)
+                print(color('    SDU Interval: ', 'magenta'), self.biginfo.sdu_interval)
+                print(color('    Max SDU:      ', 'magenta'), self.biginfo.max_sdu)
+                print(color('    PHY:          ', 'magenta'), self.biginfo.phy.name)
+                print(color('    Framed:       ', 'magenta'), self.biginfo.framed)
+                print(color('    Encrypted:    ', 'magenta'), self.biginfo.encrypted)
 
         def on_sync_establishment(self) -> None:
             self.emit('sync_establishment')
@@ -231,15 +275,13 @@ class BroadcastScanner(pyee.EventEmitter):
                 return
 
             for service_data in advertisement.data.get_all(
-                bumble.core.AdvertisingData.SERVICE_DATA
+                core.AdvertisingData.Type.SERVICE_DATA_16_BIT_UUID
             ):
-                assert isinstance(service_data, tuple)
                 service_uuid, data = service_data
-                assert isinstance(data, bytes)
 
-                if service_uuid == bumble.gatt.GATT_BASIC_AUDIO_ANNOUNCEMENT_SERVICE:
+                if service_uuid == gatt.GATT_BASIC_AUDIO_ANNOUNCEMENT_SERVICE:
                     self.basic_audio_announcement = (
-                        bumble.profiles.bap.BasicAudioAnnouncement.from_bytes(data)
+                        bap.BasicAudioAnnouncement.from_bytes(data)
                     )
                     break
 
@@ -261,7 +303,7 @@ class BroadcastScanner(pyee.EventEmitter):
         self.device = device
         self.filter_duplicates = filter_duplicates
         self.sync_timeout = sync_timeout
-        self.broadcasts: Dict[bumble.hci.Address, BroadcastScanner.Broadcast] = {}
+        self.broadcasts = dict[hci.Address, BroadcastScanner.Broadcast]()
         device.on('advertisement', self.on_advertisement)
 
     async def start(self) -> None:
@@ -274,24 +316,45 @@ class BroadcastScanner(pyee.EventEmitter):
         await self.device.stop_scanning()
 
     def on_advertisement(self, advertisement: bumble.device.Advertisement) -> None:
-        if (
-            broadcast_name := advertisement.data.get(
-                bumble.core.AdvertisingData.BROADCAST_NAME
+        if not (
+            ads := advertisement.data.get_all(
+                core.AdvertisingData.Type.SERVICE_DATA_16_BIT_UUID
+            )
+        ) or not (
+            broadcast_audio_announcement := next(
+                (
+                    ad
+                    for ad in ads
+                    if ad[0] == gatt.GATT_BROADCAST_AUDIO_ANNOUNCEMENT_SERVICE
+                ),
+                None,
             )
-        ) is None:
+        ):
             return
-        assert isinstance(broadcast_name, str)
+
+        broadcast_name = advertisement.data.get_all(
+            core.AdvertisingData.Type.BROADCAST_NAME
+        )
 
         if broadcast := self.broadcasts.get(advertisement.address):
             broadcast.update(advertisement)
             return
 
         bumble.utils.AsyncRunner.spawn(
-            self.on_new_broadcast(broadcast_name, advertisement)
+            self.on_new_broadcast(
+                broadcast_name[0] if broadcast_name else None,
+                advertisement,
+                bap.BroadcastAudioAnnouncement.from_bytes(
+                    broadcast_audio_announcement[1]
+                ).broadcast_id,
+            )
         )
 
     async def on_new_broadcast(
-        self, name: str, advertisement: bumble.device.Advertisement
+        self,
+        name: str | None,
+        advertisement: bumble.device.Advertisement,
+        broadcast_id: int,
     ) -> None:
         periodic_advertising_sync = await self.device.create_periodic_advertising_sync(
             advertiser_address=advertisement.address,
@@ -299,10 +362,7 @@ class BroadcastScanner(pyee.EventEmitter):
             sync_timeout=self.sync_timeout,
             filter_duplicates=self.filter_duplicates,
         )
-        broadcast = self.Broadcast(
-            name,
-            periodic_advertising_sync,
-        )
+        broadcast = self.Broadcast(name, periodic_advertising_sync, broadcast_id)
         broadcast.update(advertisement)
         self.broadcasts[advertisement.address] = broadcast
         periodic_advertising_sync.on('loss', lambda: self.on_broadcast_loss(broadcast))
@@ -314,10 +374,11 @@ class BroadcastScanner(pyee.EventEmitter):
         self.emit('broadcast_loss', broadcast)
 
 
-class PrintingBroadcastScanner:
+class PrintingBroadcastScanner(bumble.utils.EventEmitter):
     def __init__(
         self, device: bumble.device.Device, filter_duplicates: bool, sync_timeout: float
     ) -> None:
+        super().__init__()
         self.scanner = BroadcastScanner(device, filter_duplicates, sync_timeout)
         self.scanner.on('new_broadcast', self.on_new_broadcast)
         self.scanner.on('broadcast_loss', self.on_broadcast_loss)
@@ -452,27 +513,34 @@ async def run_assist(
         await peer.request_mtu(mtu)
 
         # Get the BASS service
-        bass = await peer.discover_service_and_create_proxy(
-            bumble.profiles.bass.BroadcastAudioScanServiceProxy
+        bass_client = await peer.discover_service_and_create_proxy(
+            bass.BroadcastAudioScanServiceProxy
         )
 
         # Check that the service was found
-        if not bass:
+        if not bass_client:
             print(color('!!! Broadcast Audio Scan Service not found', 'red'))
             return
 
         # Subscribe to and read the broadcast receive state characteristics
-        for i, broadcast_receive_state in enumerate(bass.broadcast_receive_states):
+        def on_broadcast_receive_state_update(
+            value: bass.BroadcastReceiveState, index: int
+        ) -> None:
+            print(
+                f"{color(f'Broadcast Receive State Update [{index}]:', 'green')} {value}"
+            )
+
+        for i, broadcast_receive_state in enumerate(
+            bass_client.broadcast_receive_states
+        ):
             try:
                 await broadcast_receive_state.subscribe(
-                    lambda value, i=i: print(
-                        f"{color(f'Broadcast Receive State Update [{i}]:', 'green')} {value}"
-                    )
+                    functools.partial(on_broadcast_receive_state_update, index=i)
                 )
-            except bumble.core.ProtocolError as error:
+            except core.ProtocolError as error:
                 print(
                     color(
-                        f'!!! Failed to subscribe to Broadcast Receive State characteristic:',
+                        '!!! Failed to subscribe to Broadcast Receive State characteristic',
                         'red',
                     ),
                     error,
@@ -488,7 +556,7 @@ async def run_assist(
 
         if command == 'add-source':
             # Find the requested broadcast
-            await bass.remote_scan_started()
+            await bass_client.remote_scan_started()
             if broadcast_name:
                 print(color('Scanning for broadcast:', 'cyan'), broadcast_name)
             else:
@@ -508,15 +576,15 @@ async def run_assist(
 
             # Add the source
             print(color('Adding source:', 'blue'), broadcast.sync.advertiser_address)
-            await bass.add_source(
+            await bass_client.add_source(
                 broadcast.sync.advertiser_address,
                 broadcast.sync.sid,
                 broadcast.broadcast_audio_announcement.broadcast_id,
-                bumble.profiles.bass.PeriodicAdvertisingSyncParams.SYNCHRONIZE_TO_PA_PAST_AVAILABLE,
+                bass.PeriodicAdvertisingSyncParams.SYNCHRONIZE_TO_PA_PAST_AVAILABLE,
                 0xFFFF,
                 [
-                    bumble.profiles.bass.SubgroupInfo(
-                        bumble.profiles.bass.SubgroupInfo.ANY_BIS,
+                    bass.SubgroupInfo(
+                        bass.SubgroupInfo.ANY_BIS,
                         bytes(broadcast.basic_audio_announcement.subgroups[0].metadata),
                     )
                 ],
@@ -526,7 +594,7 @@ async def run_assist(
             await broadcast.sync.transfer(peer.connection)
 
             # Notify the sink that we're done scanning.
-            await bass.remote_scan_stopped()
+            await bass_client.remote_scan_stopped()
 
             await peer.sustain()
             return
@@ -537,7 +605,7 @@ async def run_assist(
                 return
 
             # Find the requested broadcast
-            await bass.remote_scan_started()
+            await bass_client.remote_scan_started()
             if broadcast_name:
                 print(color('Scanning for broadcast:', 'cyan'), broadcast_name)
             else:
@@ -560,13 +628,13 @@ async def run_assist(
                 color('Modifying source:', 'blue'),
                 source_id,
             )
-            await bass.modify_source(
+            await bass_client.modify_source(
                 source_id,
-                bumble.profiles.bass.PeriodicAdvertisingSyncParams.SYNCHRONIZE_TO_PA_PAST_NOT_AVAILABLE,
+                bass.PeriodicAdvertisingSyncParams.SYNCHRONIZE_TO_PA_PAST_NOT_AVAILABLE,
                 0xFFFF,
                 [
-                    bumble.profiles.bass.SubgroupInfo(
-                        bumble.profiles.bass.SubgroupInfo.ANY_BIS,
+                    bass.SubgroupInfo(
+                        bass.SubgroupInfo.ANY_BIS,
                         bytes(broadcast.basic_audio_announcement.subgroups[0].metadata),
                     )
                 ],
@@ -581,7 +649,7 @@ async def run_assist(
 
             # Remove the source
             print(color('Removing source:', 'blue'), source_id)
-            await bass.remove_source(source_id)
+            await bass_client.remove_source(source_id)
             await peer.sustain()
             return
 
@@ -601,14 +669,338 @@ async def run_pair(transport: str, address: str) -> None:
             print("+++ Paired")
 
 
+async def run_receive(
+    transport: str,
+    broadcast_id: Optional[int],
+    output: str,
+    broadcast_code: str | None,
+    sync_timeout: float,
+    subgroup_index: int,
+) -> None:
+    # Run a pre-flight check for the output.
+    try:
+        if not audio_io.check_audio_output(output):
+            return
+    except ValueError as error:
+        print(error)
+        return
+
+    async with create_device(transport) as device:
+        if not device.supports_le_periodic_advertising:
+            print(color('Periodic advertising not supported', 'red'))
+            return
+
+        scanner = BroadcastScanner(device, False, sync_timeout)
+        scan_result: asyncio.Future[BroadcastScanner.Broadcast] = (
+            asyncio.get_running_loop().create_future()
+        )
+
+        def on_new_broadcast(broadcast: BroadcastScanner.Broadcast) -> None:
+            if scan_result.done():
+                return
+            if broadcast_id is None or broadcast.broadcast_id == broadcast_id:
+                scan_result.set_result(broadcast)
+
+        scanner.on('new_broadcast', on_new_broadcast)
+        await scanner.start()
+        print('Start scanning...')
+        broadcast = await scan_result
+        print('Advertisement found:')
+        broadcast.print()
+        basic_audio_announcement_scanned = asyncio.Event()
+
+        def on_change() -> None:
+            if (
+                broadcast.basic_audio_announcement and broadcast.biginfo
+            ) and not basic_audio_announcement_scanned.is_set():
+                basic_audio_announcement_scanned.set()
+
+        broadcast.on('change', on_change)
+        if not broadcast.basic_audio_announcement or not broadcast.biginfo:
+            print('Wait for Basic Audio Announcement and BIG Info...')
+            await basic_audio_announcement_scanned.wait()
+        print('Basic Audio Announcement found')
+        broadcast.print()
+        print('Stop scanning')
+        await scanner.stop()
+        print('Start sync to BIG')
+
+        assert broadcast.basic_audio_announcement
+        subgroup = broadcast.basic_audio_announcement.subgroups[subgroup_index]
+        configuration = subgroup.codec_specific_configuration
+        assert configuration
+        assert (sampling_frequency := configuration.sampling_frequency)
+        assert (frame_duration := configuration.frame_duration)
+
+        big_sync = await device.create_big_sync(
+            broadcast.sync,
+            bumble.device.BigSyncParameters(
+                big_sync_timeout=0x4000,
+                bis=[bis.index for bis in subgroup.bis],
+                broadcast_code=(
+                    broadcast_code_bytes(broadcast_code) if broadcast_code else None
+                ),
+            ),
+        )
+        num_bis = len(big_sync.bis_links)
+        decoder = lc3.Decoder(
+            frame_duration_us=frame_duration.us,
+            sample_rate_hz=sampling_frequency.hz,
+            num_channels=num_bis,
+        )
+        lc3_queues: list[Deque[bytes]] = [collections.deque() for i in range(num_bis)]
+        packet_stats = [0, 0]
+
+        audio_output = await audio_io.create_audio_output(output)
+        # This try should be replaced with contextlib.aclosing() when python 3.9 is no
+        # longer needed.
+        try:
+            await audio_output.open(
+                audio_io.PcmFormat(
+                    audio_io.PcmFormat.Endianness.LITTLE,
+                    audio_io.PcmFormat.SampleType.FLOAT32,
+                    sampling_frequency.hz,
+                    num_bis,
+                )
+            )
+
+            def sink(queue: Deque[bytes], packet: hci.HCI_IsoDataPacket):
+                # TODO: re-assemble fragments and detect errors
+                queue.append(packet.iso_sdu_fragment)
+
+                while all(lc3_queues):
+                    # This assumes SDUs contain one LC3 frame each, which may not
+                    # be correct for all cases. TODO: revisit this assumption.
+                    frame = b''.join([lc3_queue.popleft() for lc3_queue in lc3_queues])
+                    if not frame:
+                        print(color('!!! received empty frame', 'red'))
+                        continue
+
+                    packet_stats[0] += len(frame)
+                    packet_stats[1] += 1
+                    print(
+                        f'\rRECEIVED: {packet_stats[0]} bytes in '
+                        f'{packet_stats[1]} packets',
+                        end='',
+                    )
+
+                    try:
+                        pcm = decoder.decode(frame).tobytes()
+                    except lc3.BaseError as error:
+                        print(color(f'!!! LC3 decoding error: {error}'))
+                        continue
+
+                    audio_output.write(pcm)
+
+            for i, bis_link in enumerate(big_sync.bis_links):
+                print(f'Setup ISO for BIS {bis_link.handle}')
+                bis_link.sink = functools.partial(sink, lc3_queues[i])
+                await bis_link.setup_data_path(
+                    direction=bis_link.Direction.CONTROLLER_TO_HOST
+                )
+
+            terminated = asyncio.Event()
+            big_sync.on(big_sync.Event.TERMINATION, lambda _: terminated.set())
+            await terminated.wait()
+        finally:
+            await audio_output.aclose()
+
+
+async def run_transmit(
+    transport: str,
+    broadcast_id: int,
+    broadcast_code: str | None,
+    broadcast_name: str,
+    bitrate: int,
+    manufacturer_data: tuple[int, bytes] | None,
+    input: str,
+    input_format: str,
+) -> None:
+    # Run a pre-flight check for the input.
+    try:
+        if not audio_io.check_audio_input(input):
+            return
+    except ValueError as error:
+        print(error)
+        return
+
+    async with create_device(transport) as device:
+        if not device.supports_le_periodic_advertising:
+            print(color('Periodic advertising not supported', 'red'))
+            return
+
+        basic_audio_announcement = bap.BasicAudioAnnouncement(
+            presentation_delay=40000,
+            subgroups=[
+                bap.BasicAudioAnnouncement.Subgroup(
+                    codec_id=hci.CodingFormat(codec_id=hci.CodecID.LC3),
+                    codec_specific_configuration=bap.CodecSpecificConfiguration(
+                        sampling_frequency=bap.SamplingFrequency.FREQ_48000,
+                        frame_duration=bap.FrameDuration.DURATION_10000_US,
+                        octets_per_codec_frame=100,
+                    ),
+                    metadata=le_audio.Metadata(
+                        [
+                            le_audio.Metadata.Entry(
+                                tag=le_audio.Metadata.Tag.LANGUAGE, data=b'eng'
+                            ),
+                            le_audio.Metadata.Entry(
+                                tag=le_audio.Metadata.Tag.PROGRAM_INFO, data=b'Disco'
+                            ),
+                        ]
+                    ),
+                    bis=[
+                        bap.BasicAudioAnnouncement.BIS(
+                            index=1,
+                            codec_specific_configuration=bap.CodecSpecificConfiguration(
+                                audio_channel_allocation=bap.AudioLocation.FRONT_LEFT
+                            ),
+                        ),
+                        bap.BasicAudioAnnouncement.BIS(
+                            index=2,
+                            codec_specific_configuration=bap.CodecSpecificConfiguration(
+                                audio_channel_allocation=bap.AudioLocation.FRONT_RIGHT
+                            ),
+                        ),
+                    ],
+                )
+            ],
+        )
+        broadcast_audio_announcement = bap.BroadcastAudioAnnouncement(broadcast_id)
+
+        advertising_manufacturer_data = (
+            b''
+            if manufacturer_data is None
+            else bytes(
+                core.AdvertisingData(
+                    [
+                        (
+                            core.AdvertisingData.MANUFACTURER_SPECIFIC_DATA,
+                            struct.pack('<H', manufacturer_data[0])
+                            + manufacturer_data[1],
+                        )
+                    ]
+                )
+            )
+        )
+
+        advertising_set = await device.create_advertising_set(
+            advertising_parameters=bumble.device.AdvertisingParameters(
+                advertising_event_properties=bumble.device.AdvertisingEventProperties(
+                    is_connectable=False
+                ),
+                primary_advertising_interval_min=100,
+                primary_advertising_interval_max=200,
+            ),
+            advertising_data=(
+                broadcast_audio_announcement.get_advertising_data()
+                + bytes(
+                    core.AdvertisingData(
+                        [(core.AdvertisingData.BROADCAST_NAME, broadcast_name.encode())]
+                    )
+                )
+                + advertising_manufacturer_data
+            ),
+            periodic_advertising_parameters=bumble.device.PeriodicAdvertisingParameters(
+                periodic_advertising_interval_min=80,
+                periodic_advertising_interval_max=160,
+            ),
+            periodic_advertising_data=basic_audio_announcement.get_advertising_data(),
+            auto_restart=True,
+            auto_start=True,
+        )
+
+        print('Start Periodic Advertising')
+        await advertising_set.start_periodic()
+
+        audio_input = await audio_io.create_audio_input(input, input_format)
+        pcm_format = await audio_input.open()
+        # This try should be replaced with contextlib.aclosing() when python 3.9 is no
+        # longer needed.
+        try:
+            if pcm_format.channels != 2:
+                print("Only 2 channels PCM configurations are supported")
+                return
+            if pcm_format.sample_type == audio_io.PcmFormat.SampleType.INT16:
+                pcm_bit_depth = 16
+            elif pcm_format.sample_type == audio_io.PcmFormat.SampleType.FLOAT32:
+                pcm_bit_depth = None
+            else:
+                print("Only INT16 and FLOAT32 sample types are supported")
+                return
+
+            encoder = lc3.Encoder(
+                frame_duration_us=AURACAST_DEFAULT_FRAME_DURATION,
+                sample_rate_hz=AURACAST_DEFAULT_SAMPLE_RATE,
+                num_channels=pcm_format.channels,
+                input_sample_rate_hz=pcm_format.sample_rate,
+            )
+            lc3_frame_samples = encoder.get_frame_samples()
+            lc3_frame_size = encoder.get_frame_bytes(bitrate)
+            print(
+                f'Encoding with {lc3_frame_samples} '
+                f'PCM samples per {lc3_frame_size} byte frame'
+            )
+
+            print('Setup BIG')
+            big = await device.create_big(
+                advertising_set,
+                parameters=bumble.device.BigParameters(
+                    num_bis=pcm_format.channels,
+                    sdu_interval=AURACAST_DEFAULT_FRAME_DURATION,
+                    max_sdu=lc3_frame_size,
+                    max_transport_latency=65,
+                    rtn=4,
+                    broadcast_code=(
+                        broadcast_code_bytes(broadcast_code) if broadcast_code else None
+                    ),
+                ),
+            )
+            for bis_link in big.bis_links:
+                print(f'Setup ISO for BIS {bis_link.handle}')
+                await bis_link.setup_data_path(
+                    direction=bis_link.Direction.HOST_TO_CONTROLLER
+                )
+
+            iso_queues = [
+                bumble.device.IsoPacketStream(bis_link, 64)
+                for bis_link in big.bis_links
+            ]
+
+            def on_flow():
+                data_packet_queue = iso_queues[0].data_packet_queue
+                print(
+                    f'\rPACKETS: pending={data_packet_queue.pending}, '
+                    f'queued={data_packet_queue.queued}, '
+                    f'completed={data_packet_queue.completed}',
+                    end='',
+                )
+
+            iso_queues[0].data_packet_queue.on('flow', on_flow)
+
+            frame_count = 0
+            async for pcm_frame in audio_input.frames(lc3_frame_samples):
+                lc3_frame = encoder.encode(
+                    pcm_frame, num_bytes=2 * lc3_frame_size, bit_depth=pcm_bit_depth
+                )
+
+                mid = len(lc3_frame) // 2
+                await iso_queues[0].write(lc3_frame[:mid])
+                await iso_queues[1].write(lc3_frame[mid:])
+
+                frame_count += 1
+        finally:
+            await audio_input.aclose()
+
+
 def run_async(async_command: Coroutine) -> None:
     try:
         asyncio.run(async_command)
-    except bumble.core.ProtocolError as error:
+    except core.ProtocolError as error:
         if error.error_namespace == 'att' and error.error_code in list(
-            bumble.profiles.bass.ApplicationError
+            bass.ApplicationError
         ):
-            message = bumble.profiles.bass.ApplicationError(error.error_code).name
+            message = bass.ApplicationError(error.error_code).name
         else:
             message = str(error)
 
@@ -622,9 +1014,7 @@ def run_async(async_command: Coroutine) -> None:
 # -----------------------------------------------------------------------------
 @click.group()
 @click.pass_context
-def auracast(
-    ctx,
-):
+def auracast(ctx):
     ctx.ensure_object(dict)
 
 
@@ -669,7 +1059,7 @@ def scan(ctx, filter_duplicates, sync_timeout, transport):
 @click.argument('address')
 @click.pass_context
 def assist(ctx, broadcast_name, source_id, command, transport, address):
-    """Scan for broadcasts on behalf of a audio server"""
+    """Scan for broadcasts on behalf of an audio server"""
     run_async(run_assist(broadcast_name, source_id, command, transport, address))
 
 
@@ -682,6 +1072,166 @@ def pair(ctx, transport, address):
     run_async(run_pair(transport, address))
 
 
+@auracast.command('receive')
+@click.argument('transport')
+@click.argument(
+    'broadcast_id',
+    type=int,
+    required=False,
+)
+@click.option(
+    '--output',
+    default='device',
+    help=(
+        "Audio output. "
+        "'device' -> use the host's default sound output device, "
+        "'device:<DEVICE_ID>' -> use one of the  host's sound output device "
+        "(specify 'device:?' to get a list of available sound output devices), "
+        "'stdout' -> send audio to stdout, "
+        "'file:<filename> -> write audio to a raw float32 PCM file, "
+        "'ffplay' -> pipe the audio to ffplay"
+    ),
+)
+@click.option(
+    '--broadcast-code',
+    metavar='BROADCAST_CODE',
+    type=str,
+    help='Broadcast encryption code (string or raw hex format prefixed with 0x)',
+)
+@click.option(
+    '--sync-timeout',
+    metavar='SYNC_TIMEOUT',
+    type=float,
+    default=AURACAST_DEFAULT_SYNC_TIMEOUT,
+    help='Sync timeout (in seconds)',
+)
+@click.option(
+    '--subgroup',
+    metavar='SUBGROUP',
+    type=int,
+    default=0,
+    help='Index of Subgroup',
+)
+@click.pass_context
+def receive(
+    ctx,
+    transport,
+    broadcast_id,
+    output,
+    broadcast_code,
+    sync_timeout,
+    subgroup,
+):
+    """Receive a broadcast source"""
+    run_async(
+        run_receive(
+            transport,
+            broadcast_id,
+            output,
+            broadcast_code,
+            sync_timeout,
+            subgroup,
+        )
+    )
+
+
+@auracast.command('transmit')
+@click.argument('transport')
+@click.option(
+    '--input',
+    required=True,
+    help=(
+        "Audio input. "
+        "'device' -> use the host's default sound input device, "
+        "'device:<DEVICE_ID>' -> use one of the host's sound input devices "
+        "(specify 'device:?' to get a list of available sound input devices), "
+        "'stdin' -> receive audio from stdin as int16 PCM, "
+        "'file:<filename> -> read audio from a .wav or raw int16 PCM file. "
+        "(The file: prefix may be omitted if the file path does not start with "
+        "the substring 'device:' or 'file:' and is not 'stdin')"
+    ),
+)
+@click.option(
+    '--input-format',
+    metavar="FORMAT",
+    default='auto',
+    help=(
+        "Audio input format. "
+        "Use 'auto' for .wav files, or for the default setting with the devices. "
+        "For other inputs, the format is specified as "
+        "<sample-type>,<sample-rate>,<channels> (supported <sample-type>: 'int16le' "
+        "for 16-bit signed integers with little-endian byte order or 'float32le' for "
+        "32-bit floating point with little-endian byte order)"
+    ),
+)
+@click.option(
+    '--broadcast-id',
+    metavar='BROADCAST_ID',
+    type=int,
+    default=123456,
+    help='Broadcast ID',
+)
+@click.option(
+    '--broadcast-code',
+    metavar='BROADCAST_CODE',
+    help='Broadcast encryption code in hex format',
+)
+@click.option(
+    '--broadcast-name',
+    metavar='BROADCAST_NAME',
+    default='Bumble Auracast',
+    help='Broadcast name',
+)
+@click.option(
+    '--bitrate',
+    type=int,
+    default=AURACAST_DEFAULT_TRANSMIT_BITRATE,
+    help='Bitrate, per channel, in bps',
+)
+@click.option(
+    '--manufacturer-data',
+    metavar='VENDOR-ID:DATA-HEX',
+    help='Manufacturer data (specify as <vendor-id>:<data-hex>)',
+)
+@click.pass_context
+def transmit(
+    ctx,
+    transport,
+    broadcast_id,
+    broadcast_code,
+    manufacturer_data,
+    broadcast_name,
+    bitrate,
+    input,
+    input_format,
+):
+    """Transmit a broadcast source"""
+    if manufacturer_data:
+        vendor_id_str, data_hex = manufacturer_data.split(':')
+        vendor_id = int(vendor_id_str)
+        data = bytes.fromhex(data_hex)
+        manufacturer_data_tuple = (vendor_id, data)
+    else:
+        manufacturer_data_tuple = None
+
+    if (input == 'device' or input.startswith('device:')) and input_format == 'auto':
+        # Use a default format for device inputs
+        input_format = 'int16le,48000,1'
+
+    run_async(
+        run_transmit(
+            transport=transport,
+            broadcast_id=broadcast_id,
+            broadcast_code=broadcast_code,
+            broadcast_name=broadcast_name,
+            bitrate=bitrate,
+            manufacturer_data=manufacturer_data_tuple,
+            input=input,
+            input_format=input_format,
+        )
+    )
+
+
 def main():
     logging.basicConfig(level=os.environ.get('BUMBLE_LOGLEVEL', 'INFO').upper())
     auracast()
diff --git a/apps/bench.py b/apps/bench.py
index 0e5addb..7d815d2 100644
--- a/apps/bench.py
+++ b/apps/bench.py
@@ -16,18 +16,20 @@
 # Imports
 # -----------------------------------------------------------------------------
 import asyncio
+import dataclasses
 import enum
 import logging
 import os
+import statistics
 import struct
 import time
+from typing import Optional
 
 import click
 
 from bumble import l2cap
 from bumble.core import (
-    BT_BR_EDR_TRANSPORT,
-    BT_LE_TRANSPORT,
+    PhysicalTransport,
     BT_L2CAP_PROTOCOL_ID,
     BT_RFCOMM_PROTOCOL_ID,
     UUID,
@@ -40,8 +42,7 @@ from bumble.hci import (
     HCI_LE_1M_PHY,
     HCI_LE_2M_PHY,
     HCI_LE_CODED_PHY,
-    HCI_CENTRAL_ROLE,
-    HCI_PERIPHERAL_ROLE,
+    Role,
     HCI_Constant,
     HCI_Error,
     HCI_StatusError,
@@ -75,6 +76,7 @@ DEFAULT_CENTRAL_ADDRESS = 'F0:F0:F0:F0:F0:F0'
 DEFAULT_CENTRAL_NAME = 'Speed Central'
 DEFAULT_PERIPHERAL_ADDRESS = 'F1:F1:F1:F1:F1:F1'
 DEFAULT_PERIPHERAL_NAME = 'Speed Peripheral'
+DEFAULT_ADVERTISING_INTERVAL = 100
 
 SPEED_SERVICE_UUID = '50DB505C-8AC4-4738-8448-3B1D9CC09CC5'
 SPEED_TX_UUID = 'E789C754-41A1-45F4-A948-A0A1A90DBA53'
@@ -96,49 +98,22 @@ DEFAULT_RFCOMM_MTU = 2048
 # -----------------------------------------------------------------------------
 # Utils
 # -----------------------------------------------------------------------------
-def parse_packet(packet):
-    if len(packet) < 1:
-        logging.info(
-            color(f'!!! Packet too short (got {len(packet)} bytes, need >= 1)', 'red')
-        )
-        raise ValueError('packet too short')
-
-    try:
-        packet_type = PacketType(packet[0])
-    except ValueError:
-        logging.info(color(f'!!! Invalid packet type 0x{packet[0]:02X}', 'red'))
-        raise
-
-    return (packet_type, packet[1:])
-
-
-def parse_packet_sequence(packet_data):
-    if len(packet_data) < 5:
-        logging.info(
-            color(
-                f'!!!Packet too short (got {len(packet_data)} bytes, need >= 5)',
-                'red',
-            )
-        )
-        raise ValueError('packet too short')
-    return struct.unpack_from('>bI', packet_data, 0)
-
-
 def le_phy_name(phy_id):
     return {HCI_LE_1M_PHY: '1M', HCI_LE_2M_PHY: '2M', HCI_LE_CODED_PHY: 'CODED'}.get(
         phy_id, HCI_Constant.le_phy_name(phy_id)
     )
 
 
+def print_connection_phy(phy):
+    logging.info(
+        color('@@@ PHY: ', 'yellow') + f'TX:{le_phy_name(phy.tx_phy)}/'
+        f'RX:{le_phy_name(phy.rx_phy)}'
+    )
+
+
 def print_connection(connection):
     params = []
-    if connection.transport == BT_LE_TRANSPORT:
-        params.append(
-            'PHY='
-            f'TX:{le_phy_name(connection.phy.tx_phy)}/'
-            f'RX:{le_phy_name(connection.phy.rx_phy)}'
-        )
-
+    if connection.transport == PhysicalTransport.LE:
         params.append(
             'DL=('
             f'TX:{connection.data_length[0]}/{connection.data_length[1]},'
@@ -148,9 +123,9 @@ def print_connection(connection):
 
         params.append(
             'Parameters='
-            f'{connection.parameters.connection_interval * 1.25:.2f}/'
+            f'{connection.parameters.connection_interval:.2f}/'
             f'{connection.parameters.peripheral_latency}/'
-            f'{connection.parameters.supervision_timeout * 10} '
+            f'{connection.parameters.supervision_timeout:.2f} '
         )
 
         params.append(f'MTU={connection.att_mtu}')
@@ -194,17 +169,19 @@ def make_sdp_records(channel):
     }
 
 
-def log_stats(title, stats):
+def log_stats(title, stats, precision=2):
     stats_min = min(stats)
     stats_max = max(stats)
-    stats_avg = sum(stats) / len(stats)
+    stats_avg = statistics.mean(stats)
+    stats_stdev = statistics.stdev(stats) if len(stats) >= 2 else 0
     logging.info(
         color(
             (
                 f'### {title} stats: '
-                f'min={stats_min:.2f}, '
-                f'max={stats_max:.2f}, '
-                f'average={stats_avg:.2f}'
+                f'min={stats_min:.{precision}f}, '
+                f'max={stats_max:.{precision}f}, '
+                f'average={stats_avg:.{precision}f}, '
+                f'stdev={stats_stdev:.{precision}f}'
             ),
             'cyan',
         )
@@ -212,7 +189,7 @@ def log_stats(title, stats):
 
 
 async def switch_roles(connection, role):
-    target_role = HCI_CENTRAL_ROLE if role == "central" else HCI_PERIPHERAL_ROLE
+    target_role = Role.CENTRAL if role == "central" else Role.PERIPHERAL
     if connection.role != target_role:
         logging.info(f'{color("### Switching roles to:", "cyan")} {role}')
         try:
@@ -222,13 +199,180 @@ async def switch_roles(connection, role):
             logging.info(f'{color("### Role switch failed:", "red")} {error}')
 
 
-class PacketType(enum.IntEnum):
-    RESET = 0
-    SEQUENCE = 1
-    ACK = 2
+async def pre_power_on(device: Device, classic: bool) -> None:
+    device.classic_enabled = classic
 
+    # Set up a pairing config factory with minimal requirements.
+    device.config.keystore = "JsonKeyStore"
+    device.pairing_config_factory = lambda _: PairingConfig(
+        sc=False, mitm=False, bonding=False
+    )
+
+
+async def post_power_on(
+    device: Device,
+    le_scan: Optional[tuple[int, int]],
+    le_advertise: Optional[int],
+    classic_page_scan: bool,
+    classic_inquiry_scan: bool,
+) -> None:
+    if classic_page_scan:
+        logging.info(color("*** Enabling page scan", "blue"))
+        await device.set_connectable(True)
+    if classic_inquiry_scan:
+        logging.info(color("*** Enabling inquiry scan", "blue"))
+        await device.set_discoverable(True)
+
+    if le_scan:
+        scan_window, scan_interval = le_scan
+        logging.info(
+            color(
+                f"*** Starting LE scanning [{scan_window}ms/{scan_interval}ms]",
+                "blue",
+            )
+        )
+        await device.start_scanning(
+            scan_interval=scan_interval, scan_window=scan_window
+        )
 
-PACKET_FLAG_LAST = 1
+    if le_advertise:
+        logging.info(color(f"*** Starting LE advertising [{le_advertise}ms]", "blue"))
+        await device.start_advertising(
+            advertising_interval_min=le_advertise,
+            advertising_interval_max=le_advertise,
+            auto_restart=True,
+        )
+
+
+# -----------------------------------------------------------------------------
+# Packet
+# -----------------------------------------------------------------------------
+@dataclasses.dataclass
+class Packet:
+    class PacketType(enum.IntEnum):
+        RESET = 0
+        SEQUENCE = 1
+        ACK = 2
+
+    class PacketFlags(enum.IntFlag):
+        LAST = 1
+
+    packet_type: PacketType
+    flags: PacketFlags = PacketFlags(0)
+    sequence: int = 0
+    timestamp: int = 0
+    payload: bytes = b""
+
+    @classmethod
+    def from_bytes(cls, data: bytes):
+        if len(data) < 1:
+            logging.warning(
+                color(f'!!! Packet too short (got {len(data)} bytes, need >= 1)', 'red')
+            )
+            raise ValueError('packet too short')
+
+        try:
+            packet_type = cls.PacketType(data[0])
+        except ValueError:
+            logging.warning(color(f'!!! Invalid packet type 0x{data[0]:02X}', 'red'))
+            raise
+
+        if packet_type == cls.PacketType.RESET:
+            return cls(packet_type)
+
+        flags = cls.PacketFlags(data[1])
+        (sequence,) = struct.unpack_from("<I", data, 2)
+
+        if packet_type == cls.PacketType.ACK:
+            if len(data) < 6:
+                logging.warning(
+                    color(
+                        f'!!! Packet too short (got {len(data)} bytes, need >= 6)',
+                        'red',
+                    )
+                )
+            return cls(packet_type, flags, sequence)
+
+        if len(data) < 10:
+            logging.warning(
+                color(
+                    f'!!! Packet too short (got {len(data)} bytes, need >= 10)', 'red'
+                )
+            )
+            raise ValueError('packet too short')
+
+        (timestamp,) = struct.unpack_from("<I", data, 6)
+        return cls(packet_type, flags, sequence, timestamp, data[10:])
+
+    def __bytes__(self):
+        if self.packet_type == self.PacketType.RESET:
+            return bytes([self.packet_type])
+
+        if self.packet_type == self.PacketType.ACK:
+            return struct.pack("<BBI", self.packet_type, self.flags, self.sequence)
+
+        return (
+            struct.pack(
+                "<BBII", self.packet_type, self.flags, self.sequence, self.timestamp
+            )
+            + self.payload
+        )
+
+
+# -----------------------------------------------------------------------------
+# Jitter Stats
+# -----------------------------------------------------------------------------
+class JitterStats:
+    def __init__(self):
+        self.reset()
+
+    def reset(self):
+        self.packets = []
+        self.receive_times = []
+        self.jitter = []
+
+    def on_packet_received(self, packet):
+        now = time.time()
+        self.packets.append(packet)
+        self.receive_times.append(now)
+
+        if packet.timestamp and len(self.packets) > 1:
+            expected_time = (
+                self.receive_times[0]
+                + (packet.timestamp - self.packets[0].timestamp) / 1000000
+            )
+            jitter = now - expected_time
+        else:
+            jitter = 0.0
+
+        self.jitter.append(jitter)
+        return jitter
+
+    def show_stats(self):
+        if len(self.jitter) < 3:
+            return
+        average = sum(self.jitter) / len(self.jitter)
+        adjusted = [jitter - average for jitter in self.jitter]
+
+        log_stats('Jitter (signed)', adjusted, 3)
+        log_stats('Jitter (absolute)', [abs(jitter) for jitter in adjusted], 3)
+
+        # Show a histogram
+        bin_count = 20
+        bins = [0] * bin_count
+        interval_min = min(adjusted)
+        interval_max = max(adjusted)
+        interval_range = interval_max - interval_min
+        bin_thresholds = [
+            interval_min + i * (interval_range / bin_count) for i in range(bin_count)
+        ]
+        for jitter in adjusted:
+            for i in reversed(range(bin_count)):
+                if jitter >= bin_thresholds[i]:
+                    bins[i] += 1
+                    break
+        for i in range(bin_count):
+            logging.info(f'@@@ >= {bin_thresholds[i]:.4f}: {bins[i]}')
 
 
 # -----------------------------------------------------------------------------
@@ -278,19 +422,37 @@ class Sender:
                 await asyncio.sleep(self.tx_start_delay)
 
             logging.info(color('=== Sending RESET', 'magenta'))
-            await self.packet_io.send_packet(bytes([PacketType.RESET]))
+            await self.packet_io.send_packet(
+                bytes(Packet(packet_type=Packet.PacketType.RESET))
+            )
+
             self.start_time = time.time()
             self.bytes_sent = 0
             for tx_i in range(self.tx_packet_count):
-                packet_flags = (
-                    PACKET_FLAG_LAST if tx_i == self.tx_packet_count - 1 else 0
+                if self.pace > 0:
+                    # Wait until it is time to send the next packet
+                    target_time = self.start_time + (tx_i * self.pace / 1000)
+                    now = time.time()
+                    if now < target_time:
+                        await asyncio.sleep(target_time - now)
+                else:
+                    await self.packet_io.drain()
+
+                packet = bytes(
+                    Packet(
+                        packet_type=Packet.PacketType.SEQUENCE,
+                        flags=(
+                            Packet.PacketFlags.LAST
+                            if tx_i == self.tx_packet_count - 1
+                            else 0
+                        ),
+                        sequence=tx_i,
+                        timestamp=int((time.time() - self.start_time) * 1000000),
+                        payload=bytes(
+                            self.tx_packet_size - 10 - self.packet_io.overhead_size
+                        ),
+                    )
                 )
-                packet = struct.pack(
-                    '>bbI',
-                    PacketType.SEQUENCE,
-                    packet_flags,
-                    tx_i,
-                ) + bytes(self.tx_packet_size - 6 - self.packet_io.overhead_size)
                 logging.info(
                     color(
                         f'Sending packet {tx_i}: {self.tx_packet_size} bytes', 'yellow'
@@ -299,14 +461,6 @@ class Sender:
                 self.bytes_sent += len(packet)
                 await self.packet_io.send_packet(packet)
 
-                if self.pace is None:
-                    continue
-
-                if self.pace > 0:
-                    await asyncio.sleep(self.pace / 1000)
-                else:
-                    await self.packet_io.drain()
-
             await self.done.wait()
 
             run_counter = f'[{run + 1} of {self.repeat + 1}]' if self.repeat else ''
@@ -318,13 +472,13 @@ class Sender:
         if self.repeat:
             logging.info(color('--- End of runs', 'blue'))
 
-    def on_packet_received(self, packet):
+    def on_packet_received(self, data):
         try:
-            packet_type, _ = parse_packet(packet)
+            packet = Packet.from_bytes(data)
         except ValueError:
             return
 
-        if packet_type == PacketType.ACK:
+        if packet.packet_type == Packet.PacketType.ACK:
             elapsed = time.time() - self.start_time
             average_tx_speed = self.bytes_sent / elapsed
             self.stats.append(average_tx_speed)
@@ -347,52 +501,53 @@ class Receiver:
     last_timestamp: float
 
     def __init__(self, packet_io, linger):
-        self.reset()
+        self.jitter_stats = JitterStats()
         self.packet_io = packet_io
         self.packet_io.packet_listener = self
         self.linger = linger
         self.done = asyncio.Event()
+        self.reset()
 
     def reset(self):
         self.expected_packet_index = 0
         self.measurements = [(time.time(), 0)]
         self.total_bytes_received = 0
+        self.jitter_stats.reset()
 
-    def on_packet_received(self, packet):
+    def on_packet_received(self, data):
         try:
-            packet_type, packet_data = parse_packet(packet)
+            packet = Packet.from_bytes(data)
         except ValueError:
+            logging.exception("invalid packet")
             return
 
-        if packet_type == PacketType.RESET:
+        if packet.packet_type == Packet.PacketType.RESET:
             logging.info(color('=== Received RESET', 'magenta'))
             self.reset()
             return
 
-        try:
-            packet_flags, packet_index = parse_packet_sequence(packet_data)
-        except ValueError:
-            return
+        jitter = self.jitter_stats.on_packet_received(packet)
         logging.info(
-            f'<<< Received packet {packet_index}: '
-            f'flags=0x{packet_flags:02X}, '
-            f'{len(packet) + self.packet_io.overhead_size} bytes'
+            f'<<< Received packet {packet.sequence}: '
+            f'flags={packet.flags}, '
+            f'jitter={jitter:.4f}, '
+            f'{len(data) + self.packet_io.overhead_size} bytes',
         )
 
-        if packet_index != self.expected_packet_index:
+        if packet.sequence != self.expected_packet_index:
             logging.info(
                 color(
                     f'!!! Unexpected packet, expected {self.expected_packet_index} '
-                    f'but received {packet_index}'
+                    f'but received {packet.sequence}'
                 )
             )
 
         now = time.time()
         elapsed_since_start = now - self.measurements[0][0]
         elapsed_since_last = now - self.measurements[-1][0]
-        self.measurements.append((now, len(packet)))
-        self.total_bytes_received += len(packet)
-        instant_rx_speed = len(packet) / elapsed_since_last
+        self.measurements.append((now, len(data)))
+        self.total_bytes_received += len(data)
+        instant_rx_speed = len(data) / elapsed_since_last
         average_rx_speed = self.total_bytes_received / elapsed_since_start
         window = self.measurements[-64:]
         windowed_rx_speed = sum(measurement[1] for measurement in window[1:]) / (
@@ -408,15 +563,17 @@ class Receiver:
             )
         )
 
-        self.expected_packet_index = packet_index + 1
+        self.expected_packet_index = packet.sequence + 1
 
-        if packet_flags & PACKET_FLAG_LAST:
+        if packet.flags & Packet.PacketFlags.LAST:
             AsyncRunner.spawn(
                 self.packet_io.send_packet(
-                    struct.pack('>bbI', PacketType.ACK, packet_flags, packet_index)
+                    bytes(Packet(Packet.PacketType.ACK, packet.flags, packet.sequence))
                 )
             )
             logging.info(color('@@@ Received last packet', 'green'))
+            self.jitter_stats.show_stats()
+
             if not self.linger:
                 self.done.set()
 
@@ -448,9 +605,9 @@ class Ping:
         self.repeat_delay = repeat_delay
         self.pace = pace
         self.done = asyncio.Event()
-        self.current_packet_index = 0
-        self.ping_sent_time = 0.0
-        self.latencies = []
+        self.ping_times = []
+        self.rtts = []
+        self.next_expected_packet_index = 0
         self.min_stats = []
         self.max_stats = []
         self.avg_stats = []
@@ -465,6 +622,7 @@ class Ping:
 
         for run in range(self.repeat + 1):
             self.done.clear()
+            self.ping_times = []
 
             if run > 0 and self.repeat and self.repeat_delay:
                 logging.info(color(f'*** Repeat delay: {self.repeat_delay}', 'green'))
@@ -475,98 +633,97 @@ class Ping:
                 await asyncio.sleep(self.tx_start_delay)
 
             logging.info(color('=== Sending RESET', 'magenta'))
-            await self.packet_io.send_packet(bytes([PacketType.RESET]))
-
-            self.current_packet_index = 0
-            self.latencies = []
-            await self.send_next_ping()
+            await self.packet_io.send_packet(bytes(Packet(Packet.PacketType.RESET)))
+
+            start_time = time.time()
+            self.next_expected_packet_index = 0
+            for i in range(self.tx_packet_count):
+                target_time = start_time + (i * self.pace / 1000)
+                now = time.time()
+                if now < target_time:
+                    await asyncio.sleep(target_time - now)
+                    now = time.time()
+
+                packet = bytes(
+                    Packet(
+                        packet_type=Packet.PacketType.SEQUENCE,
+                        flags=(
+                            Packet.PacketFlags.LAST
+                            if i == self.tx_packet_count - 1
+                            else 0
+                        ),
+                        sequence=i,
+                        timestamp=int((now - start_time) * 1000000),
+                        payload=bytes(self.tx_packet_size - 10),
+                    )
+                )
+                logging.info(color(f'Sending packet {i}', 'yellow'))
+                self.ping_times.append(now)
+                await self.packet_io.send_packet(packet)
 
             await self.done.wait()
 
-            min_latency = min(self.latencies)
-            max_latency = max(self.latencies)
-            avg_latency = sum(self.latencies) / len(self.latencies)
+            min_rtt = min(self.rtts)
+            max_rtt = max(self.rtts)
+            avg_rtt = statistics.mean(self.rtts)
+            stdev_rtt = statistics.stdev(self.rtts)
             logging.info(
                 color(
-                    '@@@ Latencies: '
-                    f'min={min_latency:.2f}, '
-                    f'max={max_latency:.2f}, '
-                    f'average={avg_latency:.2f}'
+                    '@@@ RTTs: '
+                    f'min={min_rtt:.2f}, '
+                    f'max={max_rtt:.2f}, '
+                    f'average={avg_rtt:.2f}, '
+                    f'stdev={stdev_rtt:.2f}'
                 )
             )
 
-            self.min_stats.append(min_latency)
-            self.max_stats.append(max_latency)
-            self.avg_stats.append(avg_latency)
+            self.min_stats.append(min_rtt)
+            self.max_stats.append(max_rtt)
+            self.avg_stats.append(avg_rtt)
 
             run_counter = f'[{run + 1} of {self.repeat + 1}]' if self.repeat else ''
             logging.info(color(f'=== {run_counter} Done!', 'magenta'))
 
             if self.repeat:
-                log_stats('Min Latency', self.min_stats)
-                log_stats('Max Latency', self.max_stats)
-                log_stats('Average Latency', self.avg_stats)
+                log_stats('Min RTT', self.min_stats)
+                log_stats('Max RTT', self.max_stats)
+                log_stats('Average RTT', self.avg_stats)
 
         if self.repeat:
             logging.info(color('--- End of runs', 'blue'))
 
-    async def send_next_ping(self):
-        if self.pace:
-            await asyncio.sleep(self.pace / 1000)
-
-        packet = struct.pack(
-            '>bbI',
-            PacketType.SEQUENCE,
-            (
-                PACKET_FLAG_LAST
-                if self.current_packet_index == self.tx_packet_count - 1
-                else 0
-            ),
-            self.current_packet_index,
-        ) + bytes(self.tx_packet_size - 6)
-        logging.info(color(f'Sending packet {self.current_packet_index}', 'yellow'))
-        self.ping_sent_time = time.time()
-        await self.packet_io.send_packet(packet)
-
-    def on_packet_received(self, packet):
-        elapsed = time.time() - self.ping_sent_time
-
+    def on_packet_received(self, data):
         try:
-            packet_type, packet_data = parse_packet(packet)
+            packet = Packet.from_bytes(data)
         except ValueError:
             return
 
-        try:
-            packet_flags, packet_index = parse_packet_sequence(packet_data)
-        except ValueError:
-            return
-
-        if packet_type == PacketType.ACK:
-            latency = elapsed * 1000
-            self.latencies.append(latency)
+        if packet.packet_type == Packet.PacketType.ACK:
+            elapsed = time.time() - self.ping_times[packet.sequence]
+            rtt = elapsed * 1000
+            self.rtts.append(rtt)
             logging.info(
                 color(
-                    f'<<< Received ACK [{packet_index}], latency={latency:.2f}ms',
+                    f'<<< Received ACK [{packet.sequence}], RTT={rtt:.2f}ms',
                     'green',
                 )
             )
 
-            if packet_index == self.current_packet_index:
-                self.current_packet_index += 1
+            if packet.sequence == self.next_expected_packet_index:
+                self.next_expected_packet_index += 1
             else:
                 logging.info(
                     color(
-                        f'!!! Unexpected packet, expected {self.current_packet_index} '
-                        f'but received {packet_index}'
+                        f'!!! Unexpected packet, '
+                        f'expected {self.next_expected_packet_index} '
+                        f'but received {packet.sequence}'
                     )
                 )
 
-        if packet_flags & PACKET_FLAG_LAST:
+        if packet.flags & Packet.PacketFlags.LAST:
             self.done.set()
             return
 
-        AsyncRunner.spawn(self.send_next_ping())
-
 
 # -----------------------------------------------------------------------------
 # Pong
@@ -575,56 +732,59 @@ class Pong:
     expected_packet_index: int
 
     def __init__(self, packet_io, linger):
-        self.reset()
+        self.jitter_stats = JitterStats()
         self.packet_io = packet_io
         self.packet_io.packet_listener = self
         self.linger = linger
         self.done = asyncio.Event()
+        self.reset()
 
     def reset(self):
         self.expected_packet_index = 0
+        self.jitter_stats.reset()
 
-    def on_packet_received(self, packet):
+    def on_packet_received(self, data):
         try:
-            packet_type, packet_data = parse_packet(packet)
+            packet = Packet.from_bytes(data)
         except ValueError:
             return
 
-        if packet_type == PacketType.RESET:
+        if packet.packet_type == Packet.PacketType.RESET:
             logging.info(color('=== Received RESET', 'magenta'))
             self.reset()
             return
 
-        try:
-            packet_flags, packet_index = parse_packet_sequence(packet_data)
-        except ValueError:
-            return
+        jitter = self.jitter_stats.on_packet_received(packet)
         logging.info(
             color(
-                f'<<< Received packet {packet_index}: '
-                f'flags=0x{packet_flags:02X}, {len(packet)} bytes',
+                f'<<< Received packet {packet.sequence}: '
+                f'flags={packet.flags}, {len(data)} bytes, '
+                f'jitter={jitter:.4f}',
                 'green',
             )
         )
 
-        if packet_index != self.expected_packet_index:
+        if packet.sequence != self.expected_packet_index:
             logging.info(
                 color(
                     f'!!! Unexpected packet, expected {self.expected_packet_index} '
-                    f'but received {packet_index}'
+                    f'but received {packet.sequence}'
                 )
             )
 
-        self.expected_packet_index = packet_index + 1
+        self.expected_packet_index = packet.sequence + 1
 
         AsyncRunner.spawn(
             self.packet_io.send_packet(
-                struct.pack('>bbI', PacketType.ACK, packet_flags, packet_index)
+                bytes(Packet(Packet.PacketType.ACK, packet.flags, packet.sequence))
             )
         )
 
-        if packet_flags & PACKET_FLAG_LAST and not self.linger:
-            self.done.set()
+        if packet.flags & Packet.PacketFlags.LAST:
+            self.jitter_stats.show_stats()
+
+            if not self.linger:
+                self.done.set()
 
     async def run(self):
         await self.done.wait()
@@ -942,9 +1102,12 @@ class RfcommClient(StreamedPacketIO):
             channel = await bumble.rfcomm.find_rfcomm_channel_with_uuid(
                 connection, self.uuid
             )
-            logging.info(color(f'@@@ Channel number = {channel}', 'cyan'))
-            if channel == 0:
-                logging.info(color('!!! No RFComm service with this UUID found', 'red'))
+            if channel:
+                logging.info(color(f'@@@ Channel number = {channel}', 'cyan'))
+            else:
+                logging.warning(
+                    color('!!! No RFComm service with this UUID found', 'red')
+                )
                 await connection.disconnect()
                 return
 
@@ -1054,6 +1217,8 @@ class RfcommServer(StreamedPacketIO):
         if self.credits_threshold is not None:
             dlc.rx_credits_threshold = self.credits_threshold
 
+        self.ready.set()
+
     async def drain(self):
         assert self.dlc
         await self.dlc.drain()
@@ -1068,7 +1233,7 @@ class Central(Connection.Listener):
         transport,
         peripheral_address,
         classic,
-        role_factory,
+        scenario_factory,
         mode_factory,
         connection_interval,
         phy,
@@ -1076,17 +1241,25 @@ class Central(Connection.Listener):
         encrypt,
         extended_data_length,
         role_switch,
+        le_scan,
+        le_advertise,
+        classic_page_scan,
+        classic_inquiry_scan,
     ):
         super().__init__()
         self.transport = transport
         self.peripheral_address = peripheral_address
         self.classic = classic
-        self.role_factory = role_factory
+        self.scenario_factory = scenario_factory
         self.mode_factory = mode_factory
         self.authenticate = authenticate
         self.encrypt = encrypt or authenticate
         self.extended_data_length = extended_data_length
         self.role_switch = role_switch
+        self.le_scan = le_scan
+        self.le_advertise = le_advertise
+        self.classic_page_scan = classic_page_scan
+        self.classic_inquiry_scan = classic_inquiry_scan
         self.device = None
         self.connection = None
 
@@ -1134,19 +1307,17 @@ class Central(Connection.Listener):
                 DEFAULT_CENTRAL_NAME, central_address, hci_source, hci_sink
             )
             mode = self.mode_factory(self.device)
-            role = self.role_factory(mode)
-            self.device.classic_enabled = self.classic
-
-            # Set up a pairing config factory with minimal requirements.
-            self.device.pairing_config_factory = lambda _: PairingConfig(
-                sc=False, mitm=False, bonding=False
-            )
+            scenario = self.scenario_factory(mode)
 
+            await pre_power_on(self.device, self.classic)
             await self.device.power_on()
-
-            if self.classic:
-                await self.device.set_discoverable(False)
-                await self.device.set_connectable(False)
+            await post_power_on(
+                self.device,
+                self.le_scan,
+                self.le_advertise,
+                self.classic_page_scan,
+                self.classic_inquiry_scan,
+            )
 
             logging.info(
                 color(f'### Connecting to {self.peripheral_address}...', 'cyan')
@@ -1155,7 +1326,11 @@ class Central(Connection.Listener):
                 self.connection = await self.device.connect(
                     self.peripheral_address,
                     connection_parameters_preferences=self.connection_parameter_preferences,
-                    transport=BT_BR_EDR_TRANSPORT if self.classic else BT_LE_TRANSPORT,
+                    transport=(
+                        PhysicalTransport.BR_EDR
+                        if self.classic
+                        else PhysicalTransport.LE
+                    ),
                 )
             except CommandTimeoutError:
                 logging.info(color('!!! Connection timed out', 'red'))
@@ -1170,6 +1345,10 @@ class Central(Connection.Listener):
             self.connection.listener = self
             print_connection(self.connection)
 
+            if not self.classic:
+                phy = await self.connection.get_phy()
+                print_connection_phy(phy)
+
             # Switch roles if needed.
             if self.role_switch:
                 await switch_roles(self.connection, self.role_switch)
@@ -1215,7 +1394,7 @@ class Central(Connection.Listener):
 
             await mode.on_connection(self.connection)
 
-            await role.run()
+            await scenario.run()
             await asyncio.sleep(DEFAULT_LINGER_TIME)
             await self.connection.disconnect()
 
@@ -1226,8 +1405,8 @@ class Central(Connection.Listener):
     def on_connection_parameters_update(self):
         print_connection(self.connection)
 
-    def on_connection_phy_update(self):
-        print_connection(self.connection)
+    def on_connection_phy_update(self, phy):
+        print_connection_phy(phy)
 
     def on_connection_att_mtu_update(self):
         print_connection(self.connection)
@@ -1246,24 +1425,36 @@ class Peripheral(Device.Listener, Connection.Listener):
     def __init__(
         self,
         transport,
-        role_factory,
+        scenario_factory,
         mode_factory,
         classic,
         extended_data_length,
         role_switch,
+        le_scan,
+        le_advertise,
+        classic_page_scan,
+        classic_inquiry_scan,
     ):
         self.transport = transport
         self.classic = classic
-        self.role_factory = role_factory
+        self.scenario_factory = scenario_factory
         self.mode_factory = mode_factory
         self.extended_data_length = extended_data_length
         self.role_switch = role_switch
-        self.role = None
+        self.le_scan = le_scan
+        self.classic_page_scan = classic_page_scan
+        self.classic_inquiry_scan = classic_inquiry_scan
+        self.scenario = None
         self.mode = None
         self.device = None
         self.connection = None
         self.connected = asyncio.Event()
 
+        if le_advertise:
+            self.le_advertise = le_advertise
+        else:
+            self.le_advertise = 0 if classic else DEFAULT_ADVERTISING_INTERVAL
+
     async def run(self):
         logging.info(color('>>> Connecting to HCI...', 'green'))
         async with await open_transport_or_link(self.transport) as (
@@ -1278,21 +1469,17 @@ class Peripheral(Device.Listener, Connection.Listener):
             )
             self.device.listener = self
             self.mode = self.mode_factory(self.device)
-            self.role = self.role_factory(self.mode)
-            self.device.classic_enabled = self.classic
-
-            # Set up a pairing config factory with minimal requirements.
-            self.device.pairing_config_factory = lambda _: PairingConfig(
-                sc=False, mitm=False, bonding=False
-            )
+            self.scenario = self.scenario_factory(self.mode)
 
+            await pre_power_on(self.device, self.classic)
             await self.device.power_on()
-
-            if self.classic:
-                await self.device.set_discoverable(True)
-                await self.device.set_connectable(True)
-            else:
-                await self.device.start_advertising(auto_restart=True)
+            await post_power_on(
+                self.device,
+                self.le_scan,
+                self.le_advertise,
+                self.classic or self.classic_page_scan,
+                self.classic or self.classic_inquiry_scan,
+            )
 
             if self.classic:
                 logging.info(
@@ -1315,7 +1502,7 @@ class Peripheral(Device.Listener, Connection.Listener):
             print_connection(self.connection)
 
             await self.mode.on_connection(self.connection)
-            await self.role.run()
+            await self.scenario.run()
             await asyncio.sleep(DEFAULT_LINGER_TIME)
 
     def on_connection(self, connection):
@@ -1323,10 +1510,14 @@ class Peripheral(Device.Listener, Connection.Listener):
         self.connection = connection
         self.connected.set()
 
-        # Stop being discoverable and connectable
+        # Stop being discoverable and connectable if possible
         if self.classic:
-            AsyncRunner.spawn(self.device.set_discoverable(False))
-            AsyncRunner.spawn(self.device.set_connectable(False))
+            if not self.classic_inquiry_scan:
+                logging.info(color("*** Stopping inquiry scan", "blue"))
+                AsyncRunner.spawn(self.device.set_discoverable(False))
+            if not self.classic_page_scan:
+                logging.info(color("*** Stopping page scan", "blue"))
+                AsyncRunner.spawn(self.device.set_connectable(False))
 
         # Request a new data length if needed
         if not self.classic and self.extended_data_length:
@@ -1344,17 +1535,19 @@ class Peripheral(Device.Listener, Connection.Listener):
     def on_disconnection(self, reason):
         logging.info(color(f'!!! Disconnection: reason={reason}', 'red'))
         self.connection = None
-        self.role.reset()
+        self.scenario.reset()
 
         if self.classic:
+            logging.info(color("*** Enabling inquiry scan", "blue"))
             AsyncRunner.spawn(self.device.set_discoverable(True))
+            logging.info(color("*** Enabling page scan", "blue"))
             AsyncRunner.spawn(self.device.set_connectable(True))
 
     def on_connection_parameters_update(self):
         print_connection(self.connection)
 
-    def on_connection_phy_update(self):
-        print_connection(self.connection)
+    def on_connection_phy_update(self, phy):
+        print_connection_phy(phy)
 
     def on_connection_att_mtu_update(self):
         print_connection(self.connection)
@@ -1426,13 +1619,13 @@ def create_mode_factory(ctx, default_mode):
 
 
 # -----------------------------------------------------------------------------
-def create_role_factory(ctx, default_role):
-    role = ctx.obj['role']
-    if role is None:
-        role = default_role
+def create_scenario_factory(ctx, default_scenario):
+    scenario = ctx.obj['scenario']
+    if scenario is None:
+        scenario = default_scenario
 
-    def create_role(packet_io):
-        if role == 'sender':
+    def create_scenario(packet_io):
+        if scenario == 'send':
             return Sender(
                 packet_io,
                 start_delay=ctx.obj['start_delay'],
@@ -1443,10 +1636,10 @@ def create_role_factory(ctx, default_role):
                 packet_count=ctx.obj['packet_count'],
             )
 
-        if role == 'receiver':
+        if scenario == 'receive':
             return Receiver(packet_io, ctx.obj['linger'])
 
-        if role == 'ping':
+        if scenario == 'ping':
             return Ping(
                 packet_io,
                 start_delay=ctx.obj['start_delay'],
@@ -1457,12 +1650,12 @@ def create_role_factory(ctx, default_role):
                 packet_count=ctx.obj['packet_count'],
             )
 
-        if role == 'pong':
+        if scenario == 'pong':
             return Pong(packet_io, ctx.obj['linger'])
 
-        raise ValueError('invalid role')
+        raise ValueError('invalid scenario')
 
-    return create_role
+    return create_scenario
 
 
 # -----------------------------------------------------------------------------
@@ -1470,7 +1663,7 @@ def create_role_factory(ctx, default_role):
 # -----------------------------------------------------------------------------
 @click.group()
 @click.option('--device-config', metavar='FILENAME', help='Device configuration file')
-@click.option('--role', type=click.Choice(['sender', 'receiver', 'ping', 'pong']))
+@click.option('--scenario', type=click.Choice(['send', 'receive', 'ping', 'pong']))
 @click.option(
     '--mode',
     type=click.Choice(
@@ -1488,10 +1681,12 @@ def create_role_factory(ctx, default_role):
     '--att-mtu',
     metavar='MTU',
     type=click.IntRange(23, 517),
+    default=517,
     help='GATT MTU (gatt-client mode)',
 )
 @click.option(
     '--extended-data-length',
+    metavar='<TX-OCTETS>/<TX-TIME>',
     help='Request a data length upon connection, specified as tx_octets/tx_time',
 )
 @click.option(
@@ -1499,11 +1694,31 @@ def create_role_factory(ctx, default_role):
     type=click.Choice(['central', 'peripheral']),
     help='Request role switch upon connection (central or peripheral)',
 )
+@click.option(
+    '--le-scan',
+    metavar='<WINDOW>/<INTERVAL>',
+    help='Perform an LE scan with a given window and interval (milliseconds)',
+)
+@click.option(
+    '--le-advertise',
+    metavar='<INTERVAL>',
+    help='Advertise with a given interval (milliseconds)',
+)
+@click.option(
+    '--classic-page-scan',
+    is_flag=True,
+    help='Enable Classic page scanning',
+)
+@click.option(
+    '--classic-inquiry-scan',
+    is_flag=True,
+    help='Enable Classic enquiry scanning',
+)
 @click.option(
     '--rfcomm-channel',
     type=int,
     default=DEFAULT_RFCOMM_CHANNEL,
-    help='RFComm channel to use',
+    help='RFComm channel to use (specify 0 for channel discovery via SDP)',
 )
 @click.option(
     '--rfcomm-uuid',
@@ -1563,9 +1778,9 @@ def create_role_factory(ctx, default_role):
     '--packet-size',
     '-s',
     metavar='SIZE',
-    type=click.IntRange(8, 8192),
+    type=click.IntRange(10, 8192),
     default=500,
-    help='Packet size (client or ping role)',
+    help='Packet size (send or ping scenario)',
 )
 @click.option(
     '--packet-count',
@@ -1573,7 +1788,7 @@ def create_role_factory(ctx, default_role):
     metavar='COUNT',
     type=int,
     default=10,
-    help='Packet count (client or ping role)',
+    help='Packet count (send or ping scenario)',
 )
 @click.option(
     '--start-delay',
@@ -1581,7 +1796,7 @@ def create_role_factory(ctx, default_role):
     metavar='SECONDS',
     type=int,
     default=1,
-    help='Start delay (client or ping role)',
+    help='Start delay (send or ping scenario)',
 )
 @click.option(
     '--repeat',
@@ -1589,7 +1804,7 @@ def create_role_factory(ctx, default_role):
     type=int,
     default=0,
     help=(
-        'Repeat the run N times (client and ping roles)'
+        'Repeat the run N times (send and ping scenario)'
         '(0, which is the fault, to run just once) '
     ),
 )
@@ -1613,17 +1828,21 @@ def create_role_factory(ctx, default_role):
 @click.option(
     '--linger',
     is_flag=True,
-    help="Don't exit at the end of a run (server and pong roles)",
+    help="Don't exit at the end of a run (receive and pong scenarios)",
 )
 @click.pass_context
 def bench(
     ctx,
     device_config,
-    role,
+    scenario,
     mode,
     att_mtu,
     extended_data_length,
     role_switch,
+    le_scan,
+    le_advertise,
+    classic_page_scan,
+    classic_inquiry_scan,
     packet_size,
     packet_count,
     start_delay,
@@ -1645,7 +1864,7 @@ def bench(
 ):
     ctx.ensure_object(dict)
     ctx.obj['device_config'] = device_config
-    ctx.obj['role'] = role
+    ctx.obj['scenario'] = scenario
     ctx.obj['mode'] = mode
     ctx.obj['att_mtu'] = att_mtu
     ctx.obj['rfcomm_channel'] = rfcomm_channel
@@ -1672,6 +1891,10 @@ def bench(
         else None
     )
     ctx.obj['role_switch'] = role_switch
+    ctx.obj['le_scan'] = [float(x) for x in le_scan.split('/')] if le_scan else None
+    ctx.obj['le_advertise'] = float(le_advertise) if le_advertise else None
+    ctx.obj['classic_page_scan'] = classic_page_scan
+    ctx.obj['classic_inquiry_scan'] = classic_inquiry_scan
     ctx.obj['classic'] = mode in ('rfcomm-client', 'rfcomm-server')
 
 
@@ -1699,7 +1922,7 @@ def central(
     ctx, transport, peripheral_address, connection_interval, phy, authenticate, encrypt
 ):
     """Run as a central (initiates the connection)"""
-    role_factory = create_role_factory(ctx, 'sender')
+    scenario_factory = create_scenario_factory(ctx, 'send')
     mode_factory = create_mode_factory(ctx, 'gatt-client')
     classic = ctx.obj['classic']
 
@@ -1708,7 +1931,7 @@ def central(
             transport,
             peripheral_address,
             classic,
-            role_factory,
+            scenario_factory,
             mode_factory,
             connection_interval,
             phy,
@@ -1716,6 +1939,10 @@ def central(
             encrypt or authenticate,
             ctx.obj['extended_data_length'],
             ctx.obj['role_switch'],
+            ctx.obj['le_scan'],
+            ctx.obj['le_advertise'],
+            ctx.obj['classic_page_scan'],
+            ctx.obj['classic_inquiry_scan'],
         ).run()
 
     asyncio.run(run_central())
@@ -1726,24 +1953,32 @@ def central(
 @click.pass_context
 def peripheral(ctx, transport):
     """Run as a peripheral (waits for a connection)"""
-    role_factory = create_role_factory(ctx, 'receiver')
+    scenario_factory = create_scenario_factory(ctx, 'receive')
     mode_factory = create_mode_factory(ctx, 'gatt-server')
 
     async def run_peripheral():
         await Peripheral(
             transport,
-            role_factory,
+            scenario_factory,
             mode_factory,
             ctx.obj['classic'],
             ctx.obj['extended_data_length'],
             ctx.obj['role_switch'],
+            ctx.obj['le_scan'],
+            ctx.obj['le_advertise'],
+            ctx.obj['classic_page_scan'],
+            ctx.obj['classic_inquiry_scan'],
         ).run()
 
     asyncio.run(run_peripheral())
 
 
 def main():
-    logging.basicConfig(level=os.environ.get('BUMBLE_LOGLEVEL', 'INFO').upper())
+    logging.basicConfig(
+        level=os.environ.get('BUMBLE_LOGLEVEL', 'INFO').upper(),
+        format="[%(asctime)s.%(msecs)03d] %(levelname)s:%(name)s:%(message)s",
+        datefmt="%H:%M:%S",
+    )
     bench()
 
 
diff --git a/apps/console.py b/apps/console.py
index e942321..7ad313d 100644
--- a/apps/console.py
+++ b/apps/console.py
@@ -22,7 +22,6 @@
 import asyncio
 import logging
 import os
-import random
 import re
 import humanize
 from typing import Optional, Union
@@ -56,8 +55,14 @@ from prompt_toolkit.layout import (
 from bumble import __version__
 import bumble.core
 from bumble import colors
-from bumble.core import UUID, AdvertisingData, BT_LE_TRANSPORT
-from bumble.device import ConnectionParametersPreferences, Device, Connection, Peer
+from bumble.core import UUID, AdvertisingData, PhysicalTransport
+from bumble.device import (
+    ConnectionParametersPreferences,
+    ConnectionPHY,
+    Device,
+    Connection,
+    Peer,
+)
 from bumble.utils import AsyncRunner
 from bumble.transport import open_transport_or_link
 from bumble.gatt import Characteristic, Service, CharacteristicDeclaration, Descriptor
@@ -125,6 +130,7 @@ def parse_phys(phys):
 # -----------------------------------------------------------------------------
 class ConsoleApp:
     connected_peer: Optional[Peer]
+    connection_phy: Optional[ConnectionPHY]
 
     def __init__(self):
         self.known_addresses = set()
@@ -132,6 +138,7 @@ class ConsoleApp:
         self.known_local_attributes = []
         self.device = None
         self.connected_peer = None
+        self.connection_phy = None
         self.top_tab = 'device'
         self.monitor_rssi = False
         self.connection_rssi = None
@@ -328,14 +335,14 @@ class ConsoleApp:
             elif self.connected_peer:
                 connection = self.connected_peer.connection
                 connection_parameters = (
-                    f'{connection.parameters.connection_interval}/'
+                    f'{connection.parameters.connection_interval:.2f}/'
                     f'{connection.parameters.peripheral_latency}/'
-                    f'{connection.parameters.supervision_timeout}'
+                    f'{connection.parameters.supervision_timeout:.2f}'
                 )
-                if connection.transport == BT_LE_TRANSPORT:
+                if self.connection_phy is not None:
                     phy_state = (
-                        f' RX={le_phy_name(connection.phy.rx_phy)}/'
-                        f'TX={le_phy_name(connection.phy.tx_phy)}'
+                        f' RX={le_phy_name(self.connection_phy.rx_phy)}/'
+                        f'TX={le_phy_name(self.connection_phy.tx_phy)}'
                     )
                 else:
                     phy_state = ''
@@ -654,11 +661,12 @@ class ConsoleApp:
         self.append_to_output('connecting...')
 
         try:
-            await self.device.connect(
+            connection = await self.device.connect(
                 params[0],
                 connection_parameters_preferences=connection_parameters_preferences,
                 timeout=DEFAULT_CONNECTION_TIMEOUT,
             )
+            self.connection_phy = await connection.get_phy()
             self.top_tab = 'services'
         except bumble.core.TimeoutError:
             self.show_error('connection timed out')
@@ -838,8 +846,8 @@ class ConsoleApp:
 
         phy = await self.connected_peer.connection.get_phy()
         self.append_to_output(
-            f'PHY: RX={HCI_Constant.le_phy_name(phy[0])}, '
-            f'TX={HCI_Constant.le_phy_name(phy[1])}'
+            f'PHY: RX={HCI_Constant.le_phy_name(phy.rx_phy)}, '
+            f'TX={HCI_Constant.le_phy_name(phy.tx_phy)}'
         )
 
     async def do_request_mtu(self, params):
@@ -1076,10 +1084,9 @@ class DeviceListener(Device.Listener, Connection.Listener):
             f'{self.app.connected_peer.connection.parameters}'
         )
 
-    def on_connection_phy_update(self):
-        self.app.append_to_output(
-            f'connection phy update: {self.app.connected_peer.connection.phy}'
-        )
+    def on_connection_phy_update(self, phy):
+        self.app.connection_phy = phy
+        self.app.append_to_output(f'connection phy update: {phy}')
 
     def on_connection_att_mtu_update(self):
         self.app.append_to_output(
diff --git a/apps/controller_info.py b/apps/controller_info.py
index 9ac0882..2c8d9aa 100644
--- a/apps/controller_info.py
+++ b/apps/controller_info.py
@@ -37,6 +37,8 @@ from bumble.hci import (
     HCI_Command_Status_Event,
     HCI_READ_BUFFER_SIZE_COMMAND,
     HCI_Read_Buffer_Size_Command,
+    HCI_LE_READ_BUFFER_SIZE_V2_COMMAND,
+    HCI_LE_Read_Buffer_Size_V2_Command,
     HCI_READ_BD_ADDR_COMMAND,
     HCI_Read_BD_ADDR_Command,
     HCI_READ_LOCAL_NAME_COMMAND,
@@ -75,7 +77,7 @@ async def get_classic_info(host: Host) -> None:
         if command_succeeded(response):
             print()
             print(
-                color('Classic Address:', 'yellow'),
+                color('Public Address:', 'yellow'),
                 response.return_parameters.bd_addr.to_string(False),
             )
 
@@ -147,7 +149,7 @@ async def get_le_info(host: Host) -> None:
 
 
 # -----------------------------------------------------------------------------
-async def get_acl_flow_control_info(host: Host) -> None:
+async def get_flow_control_info(host: Host) -> None:
     print()
 
     if host.supports_command(HCI_READ_BUFFER_SIZE_COMMAND):
@@ -160,14 +162,28 @@ async def get_acl_flow_control_info(host: Host) -> None:
             f'packets of size {response.return_parameters.hc_acl_data_packet_length}',
         )
 
-    if host.supports_command(HCI_LE_READ_BUFFER_SIZE_COMMAND):
+    if host.supports_command(HCI_LE_READ_BUFFER_SIZE_V2_COMMAND):
+        response = await host.send_command(
+            HCI_LE_Read_Buffer_Size_V2_Command(), check_result=True
+        )
+        print(
+            color('LE ACL Flow Control:', 'yellow'),
+            f'{response.return_parameters.total_num_le_acl_data_packets} '
+            f'packets of size {response.return_parameters.le_acl_data_packet_length}',
+        )
+        print(
+            color('LE ISO Flow Control:', 'yellow'),
+            f'{response.return_parameters.total_num_iso_data_packets} '
+            f'packets of size {response.return_parameters.iso_data_packet_length}',
+        )
+    elif host.supports_command(HCI_LE_READ_BUFFER_SIZE_COMMAND):
         response = await host.send_command(
             HCI_LE_Read_Buffer_Size_Command(), check_result=True
         )
         print(
             color('LE ACL Flow Control:', 'yellow'),
-            f'{response.return_parameters.hc_total_num_le_acl_data_packets} '
-            f'packets of size {response.return_parameters.hc_le_acl_data_packet_length}',
+            f'{response.return_parameters.total_num_le_acl_data_packets} '
+            f'packets of size {response.return_parameters.le_acl_data_packet_length}',
         )
 
 
@@ -274,8 +290,8 @@ async def async_main(latency_probes, transport):
         # Get the LE info
         await get_le_info(host)
 
-        # Print the ACL flow control info
-        await get_acl_flow_control_info(host)
+        # Print the flow control info
+        await get_flow_control_info(host)
 
         # Get codec info
         await get_codecs_info(host)
diff --git a/apps/device_info.py b/apps/device_info.py
index df18c65..2e57a3f 100644
--- a/apps/device_info.py
+++ b/apps/device_info.py
@@ -29,7 +29,9 @@ from bumble.gatt import Service
 from bumble.profiles.device_information_service import DeviceInformationServiceProxy
 from bumble.profiles.battery_service import BatteryServiceProxy
 from bumble.profiles.gap import GenericAccessServiceProxy
+from bumble.profiles.pacs import PublishedAudioCapabilitiesServiceProxy
 from bumble.profiles.tmap import TelephonyAndMediaAudioServiceProxy
+from bumble.profiles.vcs import VolumeControlServiceProxy
 from bumble.transport import open_transport_or_link
 
 
@@ -126,14 +128,52 @@ async def show_tmas(
     print(color('### Telephony And Media Audio Service', 'yellow'))
 
     if tmas.role:
-        print(
-            color('  Role:', 'green'),
-            await tmas.role.read_value(),
-        )
+        role = await tmas.role.read_value()
+        print(color('  Role:', 'green'), role)
+
+    print()
+
+
+# -----------------------------------------------------------------------------
+async def show_pacs(pacs: PublishedAudioCapabilitiesServiceProxy) -> None:
+    print(color('### Published Audio Capabilities Service', 'yellow'))
+
+    contexts = await pacs.available_audio_contexts.read_value()
+    print(color('  Available Audio Contexts:', 'green'), contexts)
+
+    contexts = await pacs.supported_audio_contexts.read_value()
+    print(color('  Supported Audio Contexts:', 'green'), contexts)
+
+    if pacs.sink_pac:
+        pac = await pacs.sink_pac.read_value()
+        print(color('  Sink PAC:                ', 'green'), pac)
+
+    if pacs.sink_audio_locations:
+        audio_locations = await pacs.sink_audio_locations.read_value()
+        print(color('  Sink Audio Locations:    ', 'green'), audio_locations)
+
+    if pacs.source_pac:
+        pac = await pacs.source_pac.read_value()
+        print(color('  Source PAC:              ', 'green'), pac)
+
+    if pacs.source_audio_locations:
+        audio_locations = await pacs.source_audio_locations.read_value()
+        print(color('  Source Audio Locations:  ', 'green'), audio_locations)
 
     print()
 
 
+# -----------------------------------------------------------------------------
+async def show_vcs(vcs: VolumeControlServiceProxy) -> None:
+    print(color('### Volume Control Service', 'yellow'))
+
+    volume_state = await vcs.volume_state.read_value()
+    print(color('  Volume State:', 'green'), volume_state)
+
+    volume_flags = await vcs.volume_flags.read_value()
+    print(color('  Volume Flags:', 'green'), volume_flags)
+
+
 # -----------------------------------------------------------------------------
 async def show_device_info(peer, done: Optional[asyncio.Future]) -> None:
     try:
@@ -161,6 +201,12 @@ async def show_device_info(peer, done: Optional[asyncio.Future]) -> None:
         if tmas := peer.create_service_proxy(TelephonyAndMediaAudioServiceProxy):
             await try_show(show_tmas, tmas)
 
+        if pacs := peer.create_service_proxy(PublishedAudioCapabilitiesServiceProxy):
+            await try_show(show_pacs, pacs)
+
+        if vcs := peer.create_service_proxy(VolumeControlServiceProxy):
+            await try_show(show_vcs, vcs)
+
         if done is not None:
             done.set_result(None)
     except asyncio.CancelledError:
diff --git a/apps/gg_bridge.py b/apps/gg_bridge.py
index 12d16e4..c1ee2fb 100644
--- a/apps/gg_bridge.py
+++ b/apps/gg_bridge.py
@@ -234,7 +234,7 @@ class GattlinkNodeBridge(GattlinkL2capEndpoint, Device.Listener):
             Characteristic.WRITEABLE,
             CharacteristicValue(write=self.on_rx_write),
         )
-        self.tx_characteristic = Characteristic(
+        self.tx_characteristic: Characteristic[bytes] = Characteristic(
             GG_GATTLINK_TX_CHARACTERISTIC_UUID,
             Characteristic.Properties.NOTIFY,
             Characteristic.READABLE,
diff --git a/apps/hci_bridge.py b/apps/hci_bridge.py
index 1d1f9a1..00093a0 100644
--- a/apps/hci_bridge.py
+++ b/apps/hci_bridge.py
@@ -83,7 +83,7 @@ async def async_main():
                         return_parameters=bytes([hci.HCI_SUCCESS]),
                     )
                     # Return a packet with 'respond to sender' set to True
-                    return (response.to_bytes(), True)
+                    return (bytes(response), True)
 
                 return None
 
diff --git a/apps/lea_unicast/app.py b/apps/lea_unicast/app.py
index 5885dab..3c74cdb 100644
--- a/apps/lea_unicast/app.py
+++ b/apps/lea_unicast/app.py
@@ -16,35 +16,36 @@
 # Imports
 # -----------------------------------------------------------------------------
 from __future__ import annotations
+
 import asyncio
 import datetime
-import enum
 import functools
 from importlib import resources
 import json
 import os
 import logging
 import pathlib
-from typing import Optional, List, cast
 import weakref
-import struct
+import wave
 
-import ctypes
-import wasmtime
-import wasmtime.loader
-import liblc3  # type: ignore
+try:
+    import lc3  # type: ignore  # pylint: disable=E0401
+except ImportError as e:
+    raise ImportError("Try `python -m pip install \".[lc3]\"`.") from e
 
 import click
 import aiohttp.web
 
 import bumble
+from bumble import utils
 from bumble.core import AdvertisingData
 from bumble.colors import color
-from bumble.device import Device, DeviceConfiguration, AdvertisingParameters
+from bumble.device import Device, DeviceConfiguration, AdvertisingParameters, CisLink
 from bumble.transport import open_transport
 from bumble.profiles import ascs, bap, pacs
 from bumble.hci import Address, CodecID, CodingFormat, HCI_IsoDataPacket
 
+
 # -----------------------------------------------------------------------------
 # Logging
 # -----------------------------------------------------------------------------
@@ -54,6 +55,7 @@ logger = logging.getLogger(__name__)
 # Constants
 # -----------------------------------------------------------------------------
 DEFAULT_UI_PORT = 7654
+DEFAULT_PCM_BYTES_PER_SAMPLE = 2
 
 
 def _sink_pac_record() -> pacs.PacRecord:
@@ -100,153 +102,8 @@ def _source_pac_record() -> pacs.PacRecord:
     )
 
 
-# -----------------------------------------------------------------------------
-# WASM - liblc3
-# -----------------------------------------------------------------------------
-store = wasmtime.loader.store
-_memory = cast(wasmtime.Memory, liblc3.memory)
-STACK_POINTER = _memory.data_len(store)
-_memory.grow(store, 1)
-# Mapping wasmtime memory to linear address
-memory = (ctypes.c_ubyte * _memory.data_len(store)).from_address(
-    ctypes.addressof(_memory.data_ptr(store).contents)  # type: ignore
-)
-
-
-class Liblc3PcmFormat(enum.IntEnum):
-    S16 = 0
-    S24 = 1
-    S24_3LE = 2
-    FLOAT = 3
-
-
-MAX_DECODER_SIZE = liblc3.lc3_decoder_size(10000, 48000)
-MAX_ENCODER_SIZE = liblc3.lc3_encoder_size(10000, 48000)
-
-DECODER_STACK_POINTER = STACK_POINTER
-ENCODER_STACK_POINTER = DECODER_STACK_POINTER + MAX_DECODER_SIZE * 2
-DECODE_BUFFER_STACK_POINTER = ENCODER_STACK_POINTER + MAX_ENCODER_SIZE * 2
-ENCODE_BUFFER_STACK_POINTER = DECODE_BUFFER_STACK_POINTER + 8192
-DEFAULT_PCM_SAMPLE_RATE = 48000
-DEFAULT_PCM_FORMAT = Liblc3PcmFormat.S16
-DEFAULT_PCM_BYTES_PER_SAMPLE = 2
-
-
-encoders: List[int] = []
-decoders: List[int] = []
-
-
-def setup_encoders(
-    sample_rate_hz: int, frame_duration_us: int, num_channels: int
-) -> None:
-    logger.info(
-        f"setup_encoders {sample_rate_hz}Hz {frame_duration_us}us {num_channels}channels"
-    )
-    encoders[:num_channels] = [
-        liblc3.lc3_setup_encoder(
-            frame_duration_us,
-            sample_rate_hz,
-            DEFAULT_PCM_SAMPLE_RATE,  # Input sample rate
-            ENCODER_STACK_POINTER + MAX_ENCODER_SIZE * i,
-        )
-        for i in range(num_channels)
-    ]
-
-
-def setup_decoders(
-    sample_rate_hz: int, frame_duration_us: int, num_channels: int
-) -> None:
-    logger.info(
-        f"setup_decoders {sample_rate_hz}Hz {frame_duration_us}us {num_channels}channels"
-    )
-    decoders[:num_channels] = [
-        liblc3.lc3_setup_decoder(
-            frame_duration_us,
-            sample_rate_hz,
-            DEFAULT_PCM_SAMPLE_RATE,  # Output sample rate
-            DECODER_STACK_POINTER + MAX_DECODER_SIZE * i,
-        )
-        for i in range(num_channels)
-    ]
-
-
-def decode(
-    frame_duration_us: int,
-    num_channels: int,
-    input_bytes: bytes,
-) -> bytes:
-    if not input_bytes:
-        return b''
-
-    input_buffer_offset = DECODE_BUFFER_STACK_POINTER
-    input_buffer_size = len(input_bytes)
-    input_bytes_per_frame = input_buffer_size // num_channels
-
-    # Copy into wasm
-    memory[input_buffer_offset : input_buffer_offset + input_buffer_size] = input_bytes  # type: ignore
-
-    output_buffer_offset = input_buffer_offset + input_buffer_size
-    output_buffer_size = (
-        liblc3.lc3_frame_samples(frame_duration_us, DEFAULT_PCM_SAMPLE_RATE)
-        * DEFAULT_PCM_BYTES_PER_SAMPLE
-        * num_channels
-    )
-
-    for i in range(num_channels):
-        res = liblc3.lc3_decode(
-            decoders[i],
-            input_buffer_offset + input_bytes_per_frame * i,
-            input_bytes_per_frame,
-            DEFAULT_PCM_FORMAT,
-            output_buffer_offset + i * DEFAULT_PCM_BYTES_PER_SAMPLE,
-            num_channels,  # Stride
-        )
-
-        if res != 0:
-            logging.error(f"Parsing failed, res={res}")
-
-    # Extract decoded data from the output buffer
-    return bytes(
-        memory[output_buffer_offset : output_buffer_offset + output_buffer_size]
-    )
-
-
-def encode(
-    sdu_length: int,
-    num_channels: int,
-    stride: int,
-    input_bytes: bytes,
-) -> bytes:
-    if not input_bytes:
-        return b''
-
-    input_buffer_offset = ENCODE_BUFFER_STACK_POINTER
-    input_buffer_size = len(input_bytes)
-
-    # Copy into wasm
-    memory[input_buffer_offset : input_buffer_offset + input_buffer_size] = input_bytes  # type: ignore
-
-    output_buffer_offset = input_buffer_offset + input_buffer_size
-    output_buffer_size = sdu_length
-    output_frame_size = output_buffer_size // num_channels
-
-    for i in range(num_channels):
-        res = liblc3.lc3_encode(
-            encoders[i],
-            DEFAULT_PCM_FORMAT,
-            input_buffer_offset + DEFAULT_PCM_BYTES_PER_SAMPLE * i,
-            stride,
-            output_frame_size,
-            output_buffer_offset + output_frame_size * i,
-        )
-
-        if res != 0:
-            logging.error(f"Parsing failed, res={res}")
-
-    # Extract decoded data from the output buffer
-    return bytes(
-        memory[output_buffer_offset : output_buffer_offset + output_buffer_size]
-    )
+decoder: lc3.Decoder | None = None
+encoding_config: bap.CodecSpecificConfiguration | None = None
 
 
 async def lc3_source_task(
@@ -254,44 +111,49 @@ async def lc3_source_task(
     sdu_length: int,
     frame_duration_us: int,
     device: Device,
-    cis_handle: int,
+    cis_link: CisLink,
 ) -> None:
-    with open(filename, 'rb') as f:
-        header = f.read(44)
-        assert header[8:12] == b'WAVE'
-
-        pcm_num_channel, pcm_sample_rate, _byte_rate, _block_align, bits_per_sample = (
-            struct.unpack("<HIIHH", header[22:36])
-        )
-        assert pcm_sample_rate == DEFAULT_PCM_SAMPLE_RATE
-        assert bits_per_sample == DEFAULT_PCM_BYTES_PER_SAMPLE * 8
+    logger.info(
+        "lc3_source_task filename=%s, sdu_length=%d, frame_duration=%.1f",
+        filename,
+        sdu_length,
+        frame_duration_us / 1000,
+    )
+    with wave.open(filename, 'rb') as wav:
+        bits_per_sample = wav.getsampwidth() * 8
 
-        frame_bytes = (
-            liblc3.lc3_frame_samples(frame_duration_us, DEFAULT_PCM_SAMPLE_RATE)
-            * DEFAULT_PCM_BYTES_PER_SAMPLE
-        )
-        packet_sequence_number = 0
+        encoder: lc3.Encoder | None = None
 
         while True:
             next_round = datetime.datetime.now() + datetime.timedelta(
                 microseconds=frame_duration_us
             )
-            pcm_data = f.read(frame_bytes)
-            sdu = encode(sdu_length, pcm_num_channel, pcm_num_channel, pcm_data)
-
-            iso_packet = HCI_IsoDataPacket(
-                connection_handle=cis_handle,
-                data_total_length=sdu_length + 4,
-                packet_sequence_number=packet_sequence_number,
-                pb_flag=0b10,
-                packet_status_flag=0,
-                iso_sdu_length=sdu_length,
-                iso_sdu_fragment=sdu,
-            )
-            device.host.send_hci_packet(iso_packet)
-            packet_sequence_number += 1
+            if not encoder:
+                if (
+                    encoding_config
+                    and (frame_duration := encoding_config.frame_duration)
+                    and (sampling_frequency := encoding_config.sampling_frequency)
+                    and (
+                        audio_channel_allocation := encoding_config.audio_channel_allocation
+                    )
+                ):
+                    logger.info("Use %s", encoding_config)
+                    encoder = lc3.Encoder(
+                        frame_duration_us=frame_duration.us,
+                        sample_rate_hz=sampling_frequency.hz,
+                        num_channels=audio_channel_allocation.channel_count,
+                        input_sample_rate_hz=wav.getframerate(),
+                    )
+            else:
+                sdu = encoder.encode(
+                    pcm=wav.readframes(encoder.get_frame_samples()),
+                    num_bytes=sdu_length,
+                    bit_depth=bits_per_sample,
+                )
+                cis_link.write(sdu)
+
             sleep_time = next_round - datetime.datetime.now()
-            await asyncio.sleep(sleep_time.total_seconds())
+            await asyncio.sleep(sleep_time.total_seconds() * 0.9)
 
 
 # -----------------------------------------------------------------------------
@@ -410,7 +272,7 @@ class Speaker:
 
     def __init__(
         self,
-        device_config_path: Optional[str],
+        device_config_path: str | None,
         ui_port: int,
         transport: str,
         lc3_input_file_path: str,
@@ -437,6 +299,7 @@ class Speaker:
                     advertising_interval_min=25,
                     advertising_interval_max=25,
                     address=Address('F1:F2:F3:F4:F5:F6'),
+                    identity_address_type=Address.RANDOM_DEVICE_ADDRESS,
                 )
 
             device_config.le_enabled = True
@@ -486,21 +349,35 @@ class Speaker:
 
             def on_pdu(pdu: HCI_IsoDataPacket, ase: ascs.AseStateMachine):
                 codec_config = ase.codec_specific_configuration
-                assert isinstance(codec_config, bap.CodecSpecificConfiguration)
-                pcm = decode(
-                    codec_config.frame_duration.us,
-                    codec_config.audio_channel_allocation.channel_count,
-                    pdu.iso_sdu_fragment,
+                if (
+                    not isinstance(codec_config, bap.CodecSpecificConfiguration)
+                    or codec_config.frame_duration is None
+                    or codec_config.audio_channel_allocation is None
+                    or decoder is None
+                    or not pdu.iso_sdu_fragment
+                ):
+                    return
+                pcm = decoder.decode(
+                    pdu.iso_sdu_fragment, bit_depth=DEFAULT_PCM_BYTES_PER_SAMPLE * 8
+                )
+                utils.cancel_on_event(
+                    self.device, 'disconnection', self.ui_server.send_audio(pcm)
                 )
-                self.device.abort_on('disconnection', self.ui_server.send_audio(pcm))
 
             def on_ase_state_change(ase: ascs.AseStateMachine) -> None:
+                codec_config = ase.codec_specific_configuration
                 if ase.state == ascs.AseStateMachine.State.STREAMING:
-                    codec_config = ase.codec_specific_configuration
-                    assert isinstance(codec_config, bap.CodecSpecificConfiguration)
-                    assert ase.cis_link
                     if ase.role == ascs.AudioRole.SOURCE:
-                        ase.cis_link.abort_on(
+                        if (
+                            not isinstance(codec_config, bap.CodecSpecificConfiguration)
+                            or ase.cis_link is None
+                            or codec_config.octets_per_codec_frame is None
+                            or codec_config.frame_duration is None
+                            or codec_config.codec_frames_per_sdu is None
+                        ):
+                            return
+                        utils.cancel_on_event(
+                            ase.cis_link,
                             'disconnection',
                             lc3_source_task(
                                 filename=self.lc3_input_file_path,
@@ -510,25 +387,30 @@ class Speaker:
                                 ),
                                 frame_duration_us=codec_config.frame_duration.us,
                                 device=self.device,
-                                cis_handle=ase.cis_link.handle,
+                                cis_link=ase.cis_link,
                             ),
                         )
                     else:
+                        if not ase.cis_link:
+                            return
                         ase.cis_link.sink = functools.partial(on_pdu, ase=ase)
                 elif ase.state == ascs.AseStateMachine.State.CODEC_CONFIGURED:
-                    codec_config = ase.codec_specific_configuration
-                    assert isinstance(codec_config, bap.CodecSpecificConfiguration)
+                    if (
+                        not isinstance(codec_config, bap.CodecSpecificConfiguration)
+                        or codec_config.sampling_frequency is None
+                        or codec_config.frame_duration is None
+                        or codec_config.audio_channel_allocation is None
+                    ):
+                        return
                     if ase.role == ascs.AudioRole.SOURCE:
-                        setup_encoders(
-                            codec_config.sampling_frequency.hz,
-                            codec_config.frame_duration.us,
-                            codec_config.audio_channel_allocation.channel_count,
-                        )
+                        global encoding_config
+                        encoding_config = codec_config
                     else:
-                        setup_decoders(
-                            codec_config.sampling_frequency.hz,
-                            codec_config.frame_duration.us,
-                            codec_config.audio_channel_allocation.channel_count,
+                        global decoder
+                        decoder = lc3.Decoder(
+                            frame_duration_us=codec_config.frame_duration.us,
+                            sample_rate_hz=codec_config.sampling_frequency.hz,
+                            num_channels=codec_config.audio_channel_allocation.channel_count,
                         )
 
             for ase in ascs_service.ase_state_machines.values():
@@ -567,7 +449,7 @@ def speaker(ui_port: int, device_config: str, transport: str, lc3_file: str) ->
 
 # -----------------------------------------------------------------------------
 def main():
-    logging.basicConfig(level=os.environ.get('BUMBLE_LOGLEVEL', 'WARNING').upper())
+    logging.basicConfig(level=os.environ.get('BUMBLE_LOGLEVEL', 'INFO').upper())
     speaker()
 
 
diff --git a/apps/lea_unicast/liblc3.wasm b/apps/lea_unicast/liblc3.wasm
deleted file mode 100755
index e905105..0000000
Binary files a/apps/lea_unicast/liblc3.wasm and /dev/null differ
diff --git a/apps/pair.py b/apps/pair.py
index 67eec90..13dc06d 100644
--- a/apps/pair.py
+++ b/apps/pair.py
@@ -18,9 +18,12 @@
 import asyncio
 import os
 import logging
+import struct
+
 import click
 from prompt_toolkit.shortcuts import PromptSession
 
+from bumble.a2dp import make_audio_sink_service_sdp_records
 from bumble.colors import color
 from bumble.device import Device, Peer
 from bumble.transport import open_transport_or_link
@@ -30,17 +33,20 @@ from bumble.smp import error_name as smp_error_name
 from bumble.keys import JsonKeyStore
 from bumble.core import (
     AdvertisingData,
+    Appearance,
     ProtocolError,
-    BT_LE_TRANSPORT,
-    BT_BR_EDR_TRANSPORT,
+    PhysicalTransport,
+    UUID,
 )
 from bumble.gatt import (
     GATT_DEVICE_NAME_CHARACTERISTIC,
     GATT_GENERIC_ACCESS_SERVICE,
+    GATT_HEART_RATE_SERVICE,
+    GATT_HEART_RATE_MEASUREMENT_CHARACTERISTIC,
     Service,
     Characteristic,
-    CharacteristicValue,
 )
+from bumble.hci import OwnAddressType
 from bumble.att import (
     ATT_Error,
     ATT_INSUFFICIENT_AUTHENTICATION_ERROR,
@@ -63,7 +69,7 @@ class Waiter:
         self.linger = linger
 
     def terminate(self):
-        if not self.linger:
+        if not self.linger and not self.done.done:
             self.done.set_result(None)
 
     async def wait_until_terminated(self):
@@ -194,7 +200,7 @@ class Delegate(PairingDelegate):
 
 # -----------------------------------------------------------------------------
 async def get_peer_name(peer, mode):
-    if mode == 'classic':
+    if peer.connection.transport == PhysicalTransport.BR_EDR:
         return await peer.request_name()
 
     # Try to get the peer name from GATT
@@ -226,13 +232,14 @@ def read_with_error(connection):
     raise ATT_Error(ATT_INSUFFICIENT_AUTHENTICATION_ERROR)
 
 
-def write_with_error(connection, _value):
-    if not connection.is_encrypted:
-        raise ATT_Error(ATT_INSUFFICIENT_ENCRYPTION_ERROR)
-
-    if not AUTHENTICATION_ERROR_RETURNED[1]:
-        AUTHENTICATION_ERROR_RETURNED[1] = True
-        raise ATT_Error(ATT_INSUFFICIENT_AUTHENTICATION_ERROR)
+# -----------------------------------------------------------------------------
+def sdp_records():
+    service_record_handle = 0x00010001
+    return {
+        service_record_handle: make_audio_sink_service_sdp_records(
+            service_record_handle
+        )
+    }
 
 
 # -----------------------------------------------------------------------------
@@ -240,15 +247,19 @@ def on_connection(connection, request):
     print(color(f'<<< Connection: {connection}', 'green'))
 
     # Listen for pairing events
-    connection.on('pairing_start', on_pairing_start)
-    connection.on('pairing', lambda keys: on_pairing(connection, keys))
+    connection.on(connection.EVENT_PAIRING_START, on_pairing_start)
+    connection.on(connection.EVENT_PAIRING, lambda keys: on_pairing(connection, keys))
     connection.on(
-        'pairing_failure', lambda reason: on_pairing_failure(connection, reason)
+        connection.EVENT_CLASSIC_PAIRING, lambda: on_classic_pairing(connection)
+    )
+    connection.on(
+        connection.EVENT_PAIRING_FAILURE,
+        lambda reason: on_pairing_failure(connection, reason),
     )
 
     # Listen for encryption changes
     connection.on(
-        'connection_encryption_change',
+        connection.EVENT_CONNECTION_ENCRYPTION_CHANGE,
         lambda: on_connection_encryption_change(connection),
     )
 
@@ -289,6 +300,20 @@ async def on_pairing(connection, keys):
     Waiter.instance.terminate()
 
 
+# -----------------------------------------------------------------------------
+@AsyncRunner.run_in_task()
+async def on_classic_pairing(connection):
+    print(color('***-----------------------------------', 'cyan'))
+    print(
+        color(
+            f'*** Paired [Classic]! (peer identity={connection.peer_address})', 'cyan'
+        )
+    )
+    print(color('***-----------------------------------', 'cyan'))
+    await asyncio.sleep(POST_PAIRING_DELAY)
+    Waiter.instance.terminate()
+
+
 # -----------------------------------------------------------------------------
 @AsyncRunner.run_in_task()
 async def on_pairing_failure(connection, reason):
@@ -306,6 +331,7 @@ async def pair(
     mitm,
     bond,
     ctkd,
+    advertising_address,
     identity_address,
     linger,
     io,
@@ -314,6 +340,8 @@ async def pair(
     request,
     print_keys,
     keystore_file,
+    advertise_service_uuids,
+    advertise_appearance,
     device_config,
     hci_transport,
     address_or_name,
@@ -329,29 +357,33 @@ async def pair(
 
         # Expose a GATT characteristic that can be used to trigger pairing by
         # responding with an authentication error when read
-        if mode == 'le':
-            device.le_enabled = True
+        if mode in ('le', 'dual'):
             device.add_service(
                 Service(
-                    '50DB505C-8AC4-4738-8448-3B1D9CC09CC5',
+                    GATT_HEART_RATE_SERVICE,
                     [
                         Characteristic(
-                            '552957FB-CF1F-4A31-9535-E78847E1A714',
-                            Characteristic.Properties.READ
-                            | Characteristic.Properties.WRITE,
-                            Characteristic.READABLE | Characteristic.WRITEABLE,
-                            CharacteristicValue(
-                                read=read_with_error, write=write_with_error
-                            ),
+                            GATT_HEART_RATE_MEASUREMENT_CHARACTERISTIC,
+                            Characteristic.Properties.READ,
+                            Characteristic.READ_REQUIRES_AUTHENTICATION,
+                            bytes(1),
                         )
                     ],
                 )
             )
 
-        # Select LE or Classic
-        if mode == 'classic':
+        # LE and Classic support
+        if mode in ('classic', 'dual'):
             device.classic_enabled = True
             device.classic_smp_enabled = ctkd
+        if mode in ('le', 'dual'):
+            device.le_enabled = True
+        if mode == 'dual':
+            device.le_simultaneous_enabled = True
+
+        # Setup SDP
+        if mode in ('classic', 'dual'):
+            device.sdp_service_records = sdp_records()
 
         # Get things going
         await device.power_on()
@@ -373,7 +405,9 @@ async def pair(
             shared_data = (
                 None
                 if oob == '-'
-                else OobData.from_ad(AdvertisingData.from_bytes(bytes.fromhex(oob)))
+                else OobData.from_ad(
+                    AdvertisingData.from_bytes(bytes.fromhex(oob))
+                ).shared_data
             )
             legacy_context = OobLegacyContext()
             oob_contexts = PairingConfig.OobConfig(
@@ -381,16 +415,19 @@ async def pair(
                 peer_data=shared_data,
                 legacy_context=legacy_context,
             )
-            oob_data = OobData(
-                address=device.random_address,
-                shared_data=shared_data,
-                legacy_context=legacy_context,
-            )
             print(color('@@@-----------------------------------', 'yellow'))
             print(color('@@@ OOB Data:', 'yellow'))
-            print(color(f'@@@   {our_oob_context.share()}', 'yellow'))
+            if shared_data is None:
+                oob_data = OobData(
+                    address=device.random_address, shared_data=our_oob_context.share()
+                )
+                print(
+                    color(
+                        f'@@@   SHARE: {bytes(oob_data.to_ad()).hex()}',
+                        'yellow',
+                    )
+                )
             print(color(f'@@@   TK={legacy_context.tk.hex()}', 'yellow'))
-            print(color(f'@@@   HEX: ({bytes(oob_data.to_ad()).hex()})', 'yellow'))
             print(color('@@@-----------------------------------', 'yellow'))
         else:
             oob_contexts = None
@@ -417,7 +454,9 @@ async def pair(
             print(color(f'=== Connecting to {address_or_name}...', 'green'))
             connection = await device.connect(
                 address_or_name,
-                transport=BT_LE_TRANSPORT if mode == 'le' else BT_BR_EDR_TRANSPORT,
+                transport=(
+                    PhysicalTransport.LE if mode == 'le' else PhysicalTransport.BR_EDR
+                ),
             )
 
             if not request:
@@ -430,13 +469,109 @@ async def pair(
                     print(color(f'Pairing failed: {error}', 'red'))
 
         else:
-            if mode == 'le':
-                # Advertise so that peers can find us and connect
-                await device.start_advertising(auto_restart=True)
-            else:
+            if mode in ('le', 'dual'):
+                # Advertise so that peers can find us and connect.
+                # Include the heart rate service UUID in the advertisement data
+                # so that devices like iPhones can show this device in their
+                # Bluetooth selector.
+                service_uuids_16 = []
+                service_uuids_32 = []
+                service_uuids_128 = []
+                if advertise_service_uuids:
+                    for uuid in advertise_service_uuids:
+                        uuid = uuid.replace("-", "")
+                        if len(uuid) == 4:
+                            service_uuids_16.append(UUID(uuid))
+                        elif len(uuid) == 8:
+                            service_uuids_32.append(UUID(uuid))
+                        elif len(uuid) == 32:
+                            service_uuids_128.append(UUID(uuid))
+                        else:
+                            print(color('Invalid UUID format', 'red'))
+                            return
+                else:
+                    service_uuids_16.append(GATT_HEART_RATE_SERVICE)
+
+                flags = AdvertisingData.Flags.LE_LIMITED_DISCOVERABLE_MODE
+                if mode == 'le':
+                    flags |= AdvertisingData.Flags.BR_EDR_NOT_SUPPORTED
+                if mode == 'dual':
+                    flags |= AdvertisingData.Flags.SIMULTANEOUS_LE_BR_EDR_CAPABLE
+
+                ad_structs = [
+                    (
+                        AdvertisingData.FLAGS,
+                        bytes([flags]),
+                    ),
+                    (AdvertisingData.COMPLETE_LOCAL_NAME, 'Bumble'.encode()),
+                ]
+                if service_uuids_16:
+                    ad_structs.append(
+                        (
+                            AdvertisingData.INCOMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS,
+                            b"".join(bytes(uuid) for uuid in service_uuids_16),
+                        )
+                    )
+                if service_uuids_32:
+                    ad_structs.append(
+                        (
+                            AdvertisingData.INCOMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS,
+                            b"".join(bytes(uuid) for uuid in service_uuids_32),
+                        )
+                    )
+                if service_uuids_128:
+                    ad_structs.append(
+                        (
+                            AdvertisingData.INCOMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS,
+                            b"".join(bytes(uuid) for uuid in service_uuids_128),
+                        )
+                    )
+
+                if advertise_appearance:
+                    advertise_appearance = advertise_appearance.upper()
+                    try:
+                        advertise_appearance_int = int(advertise_appearance)
+                    except ValueError:
+                        category, subcategory = advertise_appearance.split('/')
+                        try:
+                            category_enum = Appearance.Category[category]
+                        except ValueError:
+                            print(
+                                color(f'Invalid appearance category {category}', 'red')
+                            )
+                            return
+                        subcategory_class = Appearance.SUBCATEGORY_CLASSES[
+                            category_enum
+                        ]
+                        try:
+                            subcategory_enum = subcategory_class[subcategory]
+                        except ValueError:
+                            print(color(f'Invalid subcategory {subcategory}', 'red'))
+                            return
+                        advertise_appearance_int = int(
+                            Appearance(category_enum, subcategory_enum)
+                        )
+                    ad_structs.append(
+                        (
+                            AdvertisingData.APPEARANCE,
+                            struct.pack('<H', advertise_appearance_int),
+                        )
+                    )
+                device.advertising_data = bytes(AdvertisingData(ad_structs))
+                await device.start_advertising(
+                    auto_restart=True,
+                    own_address_type=(
+                        OwnAddressType.PUBLIC
+                        if advertising_address == 'public'
+                        else OwnAddressType.RANDOM
+                    ),
+                )
+
+            if mode in ('classic', 'dual'):
                 # Become discoverable and connectable
                 await device.set_discoverable(True)
                 await device.set_connectable(True)
+                print(color('Ready for connections on', 'blue'), device.public_address)
 
         # Run until the user asks to exit
         await Waiter.instance.wait_until_terminated()
@@ -456,7 +591,10 @@ class LogHandler(logging.Handler):
 # -----------------------------------------------------------------------------
 @click.command()
 @click.option(
-    '--mode', type=click.Choice(['le', 'classic']), default='le', show_default=True
+    '--mode',
+    type=click.Choice(['le', 'classic', 'dual']),
+    default='le',
+    show_default=True,
 )
 @click.option(
     '--sc',
@@ -478,6 +616,10 @@ class LogHandler(logging.Handler):
     help='Enable CTKD',
     show_default=True,
 )
+@click.option(
+    '--advertising-address',
+    type=click.Choice(['random', 'public']),
+)
 @click.option(
     '--identity-address',
     type=click.Choice(['random', 'public']),
@@ -506,9 +648,20 @@ class LogHandler(logging.Handler):
 @click.option('--print-keys', is_flag=True, help='Print the bond keys before pairing')
 @click.option(
     '--keystore-file',
-    metavar='<filename>',
+    metavar='FILENAME',
     help='File in which to store the pairing keys',
 )
+@click.option(
+    '--advertise-service-uuid',
+    metavar="UUID",
+    multiple=True,
+    help="Advertise a GATT service UUID (may be specified more than once)",
+)
+@click.option(
+    '--advertise-appearance',
+    metavar='APPEARANCE',
+    help='Advertise an Appearance ID (int value or string)',
+)
 @click.argument('device-config')
 @click.argument('hci_transport')
 @click.argument('address-or-name', required=False)
@@ -518,6 +671,7 @@ def main(
     mitm,
     bond,
     ctkd,
+    advertising_address,
     identity_address,
     linger,
     io,
@@ -526,6 +680,8 @@ def main(
     request,
     print_keys,
     keystore_file,
+    advertise_service_uuid,
+    advertise_appearance,
     device_config,
     hci_transport,
     address_or_name,
@@ -544,6 +700,7 @@ def main(
             mitm,
             bond,
             ctkd,
+            advertising_address,
             identity_address,
             linger,
             io,
@@ -552,6 +709,8 @@ def main(
             request,
             print_keys,
             keystore_file,
+            advertise_service_uuid,
+            advertise_appearance,
             device_config,
             hci_transport,
             address_or_name,
diff --git a/apps/player/player.py b/apps/player/player.py
new file mode 100644
index 0000000..448b8cc
--- /dev/null
+++ b/apps/player/player.py
@@ -0,0 +1,608 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
+from __future__ import annotations
+import asyncio
+import asyncio.subprocess
+import os
+import logging
+from typing import Optional, Union
+
+import click
+
+from bumble.a2dp import (
+    make_audio_source_service_sdp_records,
+    A2DP_SBC_CODEC_TYPE,
+    A2DP_MPEG_2_4_AAC_CODEC_TYPE,
+    A2DP_NON_A2DP_CODEC_TYPE,
+    AacFrame,
+    AacParser,
+    AacPacketSource,
+    AacMediaCodecInformation,
+    SbcFrame,
+    SbcParser,
+    SbcPacketSource,
+    SbcMediaCodecInformation,
+    OpusPacket,
+    OpusParser,
+    OpusPacketSource,
+    OpusMediaCodecInformation,
+)
+from bumble.avrcp import Protocol as AvrcpProtocol
+from bumble.avdtp import (
+    find_avdtp_service_with_connection,
+    AVDTP_AUDIO_MEDIA_TYPE,
+    AVDTP_DELAY_REPORTING_SERVICE_CATEGORY,
+    MediaCodecCapabilities,
+    MediaPacketPump,
+    Protocol as AvdtpProtocol,
+)
+from bumble.colors import color
+from bumble.core import (
+    AdvertisingData,
+    ConnectionError as BumbleConnectionError,
+    DeviceClass,
+    PhysicalTransport,
+)
+from bumble.device import Connection, Device, DeviceConfiguration
+from bumble.hci import Address, HCI_CONNECTION_ALREADY_EXISTS_ERROR, HCI_Constant
+from bumble.pairing import PairingConfig
+from bumble.transport import open_transport
+from bumble.utils import AsyncRunner
+
+
+# -----------------------------------------------------------------------------
+# Logging
+# -----------------------------------------------------------------------------
+logger = logging.getLogger(__name__)
+
+
+# -----------------------------------------------------------------------------
+def a2dp_source_sdp_records():
+    service_record_handle = 0x00010001
+    return {
+        service_record_handle: make_audio_source_service_sdp_records(
+            service_record_handle
+        )
+    }
+
+
+# -----------------------------------------------------------------------------
+async def sbc_codec_capabilities(read_function) -> MediaCodecCapabilities:
+    sbc_parser = SbcParser(read_function)
+    sbc_frame: SbcFrame
+    async for sbc_frame in sbc_parser.frames:
+        # We only need the first frame
+        print(color(f"SBC format: {sbc_frame}", "cyan"))
+        break
+
+    channel_mode = [
+        SbcMediaCodecInformation.ChannelMode.MONO,
+        SbcMediaCodecInformation.ChannelMode.DUAL_CHANNEL,
+        SbcMediaCodecInformation.ChannelMode.STEREO,
+        SbcMediaCodecInformation.ChannelMode.JOINT_STEREO,
+    ][sbc_frame.channel_mode]
+    block_length = {
+        4: SbcMediaCodecInformation.BlockLength.BL_4,
+        8: SbcMediaCodecInformation.BlockLength.BL_8,
+        12: SbcMediaCodecInformation.BlockLength.BL_12,
+        16: SbcMediaCodecInformation.BlockLength.BL_16,
+    }[sbc_frame.block_count]
+    subbands = {
+        4: SbcMediaCodecInformation.Subbands.S_4,
+        8: SbcMediaCodecInformation.Subbands.S_8,
+    }[sbc_frame.subband_count]
+    allocation_method = [
+        SbcMediaCodecInformation.AllocationMethod.LOUDNESS,
+        SbcMediaCodecInformation.AllocationMethod.SNR,
+    ][sbc_frame.allocation_method]
+    return MediaCodecCapabilities(
+        media_type=AVDTP_AUDIO_MEDIA_TYPE,
+        media_codec_type=A2DP_SBC_CODEC_TYPE,
+        media_codec_information=SbcMediaCodecInformation(
+            sampling_frequency=SbcMediaCodecInformation.SamplingFrequency.from_int(
+                sbc_frame.sampling_frequency
+            ),
+            channel_mode=channel_mode,
+            block_length=block_length,
+            subbands=subbands,
+            allocation_method=allocation_method,
+            minimum_bitpool_value=2,
+            maximum_bitpool_value=40,
+        ),
+    )
+
+
+# -----------------------------------------------------------------------------
+async def aac_codec_capabilities(read_function) -> MediaCodecCapabilities:
+    aac_parser = AacParser(read_function)
+    aac_frame: AacFrame
+    async for aac_frame in aac_parser.frames:
+        # We only need the first frame
+        print(color(f"AAC format: {aac_frame}", "cyan"))
+        break
+
+    sampling_frequency = AacMediaCodecInformation.SamplingFrequency.from_int(
+        aac_frame.sampling_frequency
+    )
+    channels = (
+        AacMediaCodecInformation.Channels.MONO
+        if aac_frame.channel_configuration == 1
+        else AacMediaCodecInformation.Channels.STEREO
+    )
+
+    return MediaCodecCapabilities(
+        media_type=AVDTP_AUDIO_MEDIA_TYPE,
+        media_codec_type=A2DP_MPEG_2_4_AAC_CODEC_TYPE,
+        media_codec_information=AacMediaCodecInformation(
+            object_type=AacMediaCodecInformation.ObjectType.MPEG_2_AAC_LC,
+            sampling_frequency=sampling_frequency,
+            channels=channels,
+            vbr=1,
+            bitrate=128000,
+        ),
+    )
+
+
+# -----------------------------------------------------------------------------
+async def opus_codec_capabilities(read_function) -> MediaCodecCapabilities:
+    opus_parser = OpusParser(read_function)
+    opus_packet: OpusPacket
+    async for opus_packet in opus_parser.packets:
+        # We only need the first packet
+        print(color(f"Opus format: {opus_packet}", "cyan"))
+        break
+
+    if opus_packet.channel_mode == OpusPacket.ChannelMode.MONO:
+        channel_mode = OpusMediaCodecInformation.ChannelMode.MONO
+    elif opus_packet.channel_mode == OpusPacket.ChannelMode.STEREO:
+        channel_mode = OpusMediaCodecInformation.ChannelMode.STEREO
+    else:
+        channel_mode = OpusMediaCodecInformation.ChannelMode.DUAL_MONO
+
+    if opus_packet.duration == 10:
+        frame_size = OpusMediaCodecInformation.FrameSize.FS_10MS
+    else:
+        frame_size = OpusMediaCodecInformation.FrameSize.FS_20MS
+
+    return MediaCodecCapabilities(
+        media_type=AVDTP_AUDIO_MEDIA_TYPE,
+        media_codec_type=A2DP_NON_A2DP_CODEC_TYPE,
+        media_codec_information=OpusMediaCodecInformation(
+            channel_mode=channel_mode,
+            sampling_frequency=OpusMediaCodecInformation.SamplingFrequency.SF_48000,
+            frame_size=frame_size,
+        ),
+    )
+
+
+# -----------------------------------------------------------------------------
+class Player:
+    def __init__(
+        self,
+        transport: str,
+        device_config: Optional[str],
+        authenticate: bool,
+        encrypt: bool,
+    ) -> None:
+        self.transport = transport
+        self.device_config = device_config
+        self.authenticate = authenticate
+        self.encrypt = encrypt
+        self.avrcp_protocol: Optional[AvrcpProtocol] = None
+        self.done: Optional[asyncio.Event]
+
+    async def run(self, workload) -> None:
+        self.done = asyncio.Event()
+        try:
+            await self._run(workload)
+        except Exception as error:
+            print(color(f"!!! ERROR: {error}", "red"))
+
+    async def _run(self, workload) -> None:
+        async with await open_transport(self.transport) as (hci_source, hci_sink):
+            # Create a device
+            device_config = DeviceConfiguration()
+            if self.device_config:
+                device_config.load_from_file(self.device_config)
+            else:
+                device_config.name = "Bumble Player"
+                device_config.class_of_device = DeviceClass.pack_class_of_device(
+                    DeviceClass.AUDIO_SERVICE_CLASS,
+                    DeviceClass.AUDIO_VIDEO_MAJOR_DEVICE_CLASS,
+                    DeviceClass.AUDIO_VIDEO_UNCATEGORIZED_MINOR_DEVICE_CLASS,
+                )
+                device_config.keystore = "JsonKeyStore"
+
+            device_config.classic_enabled = True
+            device_config.le_enabled = False
+            device_config.le_simultaneous_enabled = False
+            device_config.classic_sc_enabled = False
+            device_config.classic_smp_enabled = False
+            device = Device.from_config_with_hci(device_config, hci_source, hci_sink)
+
+            # Setup the SDP records to expose the SRC service
+            device.sdp_service_records = a2dp_source_sdp_records()
+
+            # Setup AVRCP
+            self.avrcp_protocol = AvrcpProtocol()
+            self.avrcp_protocol.listen(device)
+
+            # Don't require MITM when pairing.
+            device.pairing_config_factory = lambda connection: PairingConfig(mitm=False)
+
+            # Start the controller
+            await device.power_on()
+
+            # Print some of the config/properties
+            print(
+                "Player Bluetooth Address:",
+                color(
+                    device.public_address.to_string(with_type_qualifier=False),
+                    "yellow",
+                ),
+            )
+
+            # Listen for connections
+            device.on("connection", self.on_bluetooth_connection)
+
+            # Run the workload
+            try:
+                await workload(device)
+            except BumbleConnectionError as error:
+                if error.error_code == HCI_CONNECTION_ALREADY_EXISTS_ERROR:
+                    print(color("Connection already established", "blue"))
+                else:
+                    print(color(f"Failed to connect: {error}", "red"))
+
+            # Wait until it is time to exit
+            assert self.done is not None
+            await asyncio.wait(
+                [hci_source.terminated, asyncio.ensure_future(self.done.wait())],
+                return_when=asyncio.FIRST_COMPLETED,
+            )
+
+    def on_bluetooth_connection(self, connection: Connection) -> None:
+        print(color(f"--- Connected: {connection}", "cyan"))
+        connection.on("disconnection", self.on_bluetooth_disconnection)
+
+    def on_bluetooth_disconnection(self, reason) -> None:
+        print(color(f"--- Disconnected: {HCI_Constant.error_name(reason)}", "cyan"))
+        self.set_done()
+
+    async def connect(self, device: Device, address: str) -> Connection:
+        print(color(f"Connecting to {address}...", "green"))
+        connection = await device.connect(address, transport=PhysicalTransport.BR_EDR)
+
+        # Request authentication
+        if self.authenticate:
+            print(color("*** Authenticating...", "blue"))
+            await connection.authenticate()
+            print(color("*** Authenticated", "blue"))
+
+        # Enable encryption
+        if self.encrypt:
+            print(color("*** Enabling encryption...", "blue"))
+            await connection.encrypt()
+            print(color("*** Encryption on", "blue"))
+
+        return connection
+
+    async def create_avdtp_protocol(self, connection: Connection) -> AvdtpProtocol:
+        # Look for an A2DP service
+        avdtp_version = await find_avdtp_service_with_connection(connection)
+        if not avdtp_version:
+            raise RuntimeError("no A2DP service found")
+
+        print(color(f"AVDTP Version: {avdtp_version}"))
+
+        # Create a client to interact with the remote device
+        return await AvdtpProtocol.connect(connection, avdtp_version)
+
+    async def stream_packets(
+        self,
+        protocol: AvdtpProtocol,
+        codec_type: int,
+        vendor_id: int,
+        codec_id: int,
+        packet_source: Union[SbcPacketSource, AacPacketSource, OpusPacketSource],
+        codec_capabilities: MediaCodecCapabilities,
+    ):
+        # Discover all endpoints on the remote device
+        endpoints = await protocol.discover_remote_endpoints()
+        for endpoint in endpoints:
+            print('@@@', endpoint)
+
+        # Select a sink
+        sink = protocol.find_remote_sink_by_codec(
+            AVDTP_AUDIO_MEDIA_TYPE, codec_type, vendor_id, codec_id
+        )
+        if sink is None:
+            print(color('!!! no compatible sink found', 'red'))
+            return
+        print(f'### Selected sink: {sink.seid}')
+
+        # Check if the sink supports delay reporting
+        delay_reporting = False
+        for capability in sink.capabilities:
+            if capability.service_category == AVDTP_DELAY_REPORTING_SERVICE_CATEGORY:
+                delay_reporting = True
+                break
+
+        def on_delay_report(delay: int):
+            print(color(f"*** DELAY REPORT: {delay}", "blue"))
+
+        # Adjust the codec capabilities for certain codecs
+        for capability in sink.capabilities:
+            if isinstance(capability, MediaCodecCapabilities):
+                if isinstance(
+                    codec_capabilities.media_codec_information, SbcMediaCodecInformation
+                ) and isinstance(
+                    capability.media_codec_information, SbcMediaCodecInformation
+                ):
+                    codec_capabilities.media_codec_information.minimum_bitpool_value = (
+                        capability.media_codec_information.minimum_bitpool_value
+                    )
+                    codec_capabilities.media_codec_information.maximum_bitpool_value = (
+                        capability.media_codec_information.maximum_bitpool_value
+                    )
+                    print(color("Source media codec:", "green"), codec_capabilities)
+
+        # Stream the packets
+        packet_pump = MediaPacketPump(packet_source.packets)
+        source = protocol.add_source(codec_capabilities, packet_pump, delay_reporting)
+        source.on("delay_report", on_delay_report)
+        stream = await protocol.create_stream(source, sink)
+        await stream.start()
+
+        await packet_pump.wait_for_completion()
+
+    async def discover(self, device: Device) -> None:
+        @device.listens_to("inquiry_result")
+        def on_inquiry_result(
+            address: Address, class_of_device: int, data: AdvertisingData, rssi: int
+        ) -> None:
+            (
+                service_classes,
+                major_device_class,
+                minor_device_class,
+            ) = DeviceClass.split_class_of_device(class_of_device)
+            separator = "\n  "
+            print(f">>> {color(address.to_string(False), 'yellow')}:")
+            print(f"  Device Class (raw): {class_of_device:06X}")
+            major_class_name = DeviceClass.major_device_class_name(major_device_class)
+            print("  Device Major Class: " f"{major_class_name}")
+            minor_class_name = DeviceClass.minor_device_class_name(
+                major_device_class, minor_device_class
+            )
+            print("  Device Minor Class: " f"{minor_class_name}")
+            print(
+                "  Device Services: "
+                f"{', '.join(DeviceClass.service_class_labels(service_classes))}"
+            )
+            print(f"  RSSI: {rssi}")
+            if data.ad_structures:
+                print(f"  {data.to_string(separator)}")
+
+        await device.start_discovery()
+
+    async def pair(self, device: Device, address: str) -> None:
+        print(color(f"Connecting to {address}...", "green"))
+        connection = await device.connect(address, transport=PhysicalTransport.BR_EDR)
+
+        print(color("Pairing...", "magenta"))
+        await connection.authenticate()
+        print(color("Pairing completed", "magenta"))
+        self.set_done()
+
+    async def inquire(self, device: Device, address: str) -> None:
+        connection = await self.connect(device, address)
+        avdtp_protocol = await self.create_avdtp_protocol(connection)
+
+        # Discover the remote endpoints
+        endpoints = await avdtp_protocol.discover_remote_endpoints()
+        print(f'@@@ Found {len(list(endpoints))} endpoints')
+        for endpoint in endpoints:
+            print('@@@', endpoint)
+
+        self.set_done()
+
+    async def play(
+        self,
+        device: Device,
+        address: Optional[str],
+        audio_format: str,
+        audio_file: str,
+    ) -> None:
+        if audio_format == "auto":
+            if audio_file.endswith(".sbc"):
+                audio_format = "sbc"
+            elif audio_file.endswith(".aac") or audio_file.endswith(".adts"):
+                audio_format = "aac"
+            elif audio_file.endswith(".ogg"):
+                audio_format = "opus"
+            else:
+                raise ValueError("Unable to determine audio format from file extension")
+
+        device.on(
+            "connection",
+            lambda connection: AsyncRunner.spawn(on_connection(connection)),
+        )
+
+        async def on_connection(connection: Connection):
+            avdtp_protocol = await self.create_avdtp_protocol(connection)
+
+            with open(audio_file, 'rb') as input_file:
+                # NOTE: this should be using asyncio file reading, but blocking reads
+                # are good enough for this command line app.
+                async def read_audio_data(byte_count):
+                    return input_file.read(byte_count)
+
+                # Obtain the codec capabilities from the stream
+                packet_source: Union[SbcPacketSource, AacPacketSource, OpusPacketSource]
+                vendor_id = 0
+                codec_id = 0
+                if audio_format == "sbc":
+                    codec_type = A2DP_SBC_CODEC_TYPE
+                    codec_capabilities = await sbc_codec_capabilities(read_audio_data)
+                    packet_source = SbcPacketSource(
+                        read_audio_data,
+                        avdtp_protocol.l2cap_channel.peer_mtu,
+                    )
+                elif audio_format == "aac":
+                    codec_type = A2DP_MPEG_2_4_AAC_CODEC_TYPE
+                    codec_capabilities = await aac_codec_capabilities(read_audio_data)
+                    packet_source = AacPacketSource(
+                        read_audio_data,
+                        avdtp_protocol.l2cap_channel.peer_mtu,
+                    )
+                else:
+                    codec_type = A2DP_NON_A2DP_CODEC_TYPE
+                    vendor_id = OpusMediaCodecInformation.VENDOR_ID
+                    codec_id = OpusMediaCodecInformation.CODEC_ID
+                    codec_capabilities = await opus_codec_capabilities(read_audio_data)
+                    packet_source = OpusPacketSource(
+                        read_audio_data,
+                        avdtp_protocol.l2cap_channel.peer_mtu,
+                    )
+
+                # Rewind to the start
+                input_file.seek(0)
+
+                try:
+                    await self.stream_packets(
+                        avdtp_protocol,
+                        codec_type,
+                        vendor_id,
+                        codec_id,
+                        packet_source,
+                        codec_capabilities,
+                    )
+                except Exception as error:
+                    print(color(f"!!! Error while streaming: {error}", "red"))
+
+            self.set_done()
+
+        if address:
+            await self.connect(device, address)
+        else:
+            print(color("Waiting for an incoming connection...", "magenta"))
+
+    def set_done(self) -> None:
+        if self.done:
+            self.done.set()
+
+
+# -----------------------------------------------------------------------------
+def create_player(context) -> Player:
+    return Player(
+        transport=context.obj["hci_transport"],
+        device_config=context.obj["device_config"],
+        authenticate=context.obj["authenticate"],
+        encrypt=context.obj["encrypt"],
+    )
+
+
+# -----------------------------------------------------------------------------
+@click.group()
+@click.pass_context
+@click.option("--hci-transport", metavar="TRANSPORT", required=True)
+@click.option("--device-config", metavar="FILENAME", help="Device configuration file")
+@click.option(
+    "--authenticate",
+    is_flag=True,
+    help="Request authentication when connecting",
+    default=False,
+)
+@click.option(
+    "--encrypt", is_flag=True, help="Request encryption when connecting", default=True
+)
+def player_cli(ctx, hci_transport, device_config, authenticate, encrypt):
+    ctx.ensure_object(dict)
+    ctx.obj["hci_transport"] = hci_transport
+    ctx.obj["device_config"] = device_config
+    ctx.obj["authenticate"] = authenticate
+    ctx.obj["encrypt"] = encrypt
+
+
+@player_cli.command("discover")
+@click.pass_context
+def discover(context):
+    """Discover speakers or headphones"""
+    player = create_player(context)
+    asyncio.run(player.run(player.discover))
+
+
+@player_cli.command("inquire")
+@click.pass_context
+@click.argument(
+    "address",
+    metavar="ADDRESS",
+)
+def inquire(context, address):
+    """Connect to a speaker or headphone and inquire about their capabilities"""
+    player = create_player(context)
+    asyncio.run(player.run(lambda device: player.inquire(device, address)))
+
+
+@player_cli.command("pair")
+@click.pass_context
+@click.argument(
+    "address",
+    metavar="ADDRESS",
+)
+def pair(context, address):
+    """Pair with a speaker or headphone"""
+    player = create_player(context)
+    asyncio.run(player.run(lambda device: player.pair(device, address)))
+
+
+@player_cli.command("play")
+@click.pass_context
+@click.option(
+    "--connect",
+    "address",
+    metavar="ADDRESS",
+    help="Address or name to connect to",
+)
+@click.option(
+    "-f",
+    "--audio-format",
+    type=click.Choice(["auto", "sbc", "aac", "opus"]),
+    help="Audio file format (use 'auto' to infer the format from the file extension)",
+    default="auto",
+)
+@click.argument("audio_file")
+def play(context, address, audio_format, audio_file):
+    """Play and audio file"""
+    player = create_player(context)
+    asyncio.run(
+        player.run(
+            lambda device: player.play(device, address, audio_format, audio_file)
+        )
+    )
+
+
+# -----------------------------------------------------------------------------
+def main():
+    logging.basicConfig(level=os.environ.get("BUMBLE_LOGLEVEL", "WARNING").upper())
+    player_cli()
+
+
+# -----------------------------------------------------------------------------
+if __name__ == "__main__":
+    main()  # pylint: disable=no-value-for-parameter
diff --git a/apps/rfcomm_bridge.py b/apps/rfcomm_bridge.py
index 728e7cf..9fb55c9 100644
--- a/apps/rfcomm_bridge.py
+++ b/apps/rfcomm_bridge.py
@@ -237,6 +237,7 @@ class ClientBridge:
         address: str,
         tcp_host: str,
         tcp_port: int,
+        authenticate: bool,
         encrypt: bool,
     ):
         self.channel = channel
@@ -245,6 +246,7 @@ class ClientBridge:
         self.address = address
         self.tcp_host = tcp_host
         self.tcp_port = tcp_port
+        self.authenticate = authenticate
         self.encrypt = encrypt
         self.device: Optional[Device] = None
         self.connection: Optional[Connection] = None
@@ -269,11 +271,16 @@ class ClientBridge:
         print(color(f"@@@ Connecting to Bluetooth {self.address}", "blue"))
         assert self.device
         self.connection = await self.device.connect(
-            self.address, transport=core.BT_BR_EDR_TRANSPORT
+            self.address, transport=core.PhysicalTransport.BR_EDR
         )
         print(color(f"@@@ Bluetooth connection: {self.connection}", "blue"))
         self.connection.on("disconnection", self.on_disconnection)
 
+        if self.authenticate:
+            print(color("@@@ Authenticating Bluetooth connection", "blue"))
+            await self.connection.authenticate()
+            print(color("@@@ Bluetooth connection authenticated", "blue"))
+
         if self.encrypt:
             print(color("@@@ Encrypting Bluetooth connection", "blue"))
             await self.connection.encrypt()
@@ -491,8 +498,9 @@ def server(context, tcp_host, tcp_port):
 @click.argument("bluetooth-address")
 @click.option("--tcp-host", help="TCP host", default="_")
 @click.option("--tcp-port", help="TCP port", default=DEFAULT_CLIENT_TCP_PORT)
+@click.option("--authenticate", is_flag=True, help="Authenticate the connection")
 @click.option("--encrypt", is_flag=True, help="Encrypt the connection")
-def client(context, bluetooth_address, tcp_host, tcp_port, encrypt):
+def client(context, bluetooth_address, tcp_host, tcp_port, authenticate, encrypt):
     bridge = ClientBridge(
         context.obj["channel"],
         context.obj["uuid"],
@@ -500,6 +508,7 @@ def client(context, bluetooth_address, tcp_host, tcp_port, encrypt):
         bluetooth_address,
         tcp_host,
         tcp_port,
+        authenticate,
         encrypt,
     )
     asyncio.run(run(context.obj["device_config"], context.obj["hci_transport"], bridge))
diff --git a/apps/show.py b/apps/show.py
index 97640a3..8c38681 100644
--- a/apps/show.py
+++ b/apps/show.py
@@ -144,18 +144,18 @@ class Printer:
     help='Format of the input file',
 )
 @click.option(
-    '--vendors',
+    '--vendor',
     type=click.Choice(['android', 'zephyr']),
     multiple=True,
     help='Support vendor-specific commands (list one or more)',
 )
 @click.argument('filename')
 # pylint: disable=redefined-builtin
-def main(format, vendors, filename):
-    for vendor in vendors:
-        if vendor == 'android':
+def main(format, vendor, filename):
+    for vendor_name in vendor:
+        if vendor_name == 'android':
             import bumble.vendor.android.hci
-        elif vendor == 'zephyr':
+        elif vendor_name == 'zephyr':
             import bumble.vendor.zephyr.hci
 
     input = open(filename, 'rb')
@@ -180,7 +180,7 @@ def main(format, vendors, filename):
             else:
                 printer.print(color("[TRUNCATED]", "red"))
         except Exception as error:
-            logger.exception()
+            logger.exception('')
             print(color(f'!!! {error}', 'red'))
 
 
diff --git a/apps/speaker/speaker.html b/apps/speaker/speaker.html
index 550049b..3b807e1 100644
--- a/apps/speaker/speaker.html
+++ b/apps/speaker/speaker.html
@@ -15,6 +15,7 @@
           <tr><td>Codec</td><td><span id="codecText"></span></td></tr>
           <tr><td>Packets</td><td><span id="packetsReceivedText"></span></td></tr>
           <tr><td>Bytes</td><td><span id="bytesReceivedText"></span></td></tr>
+          <tr><td>Bitrate</td><td><span id="bitrate"></span></td></tr>
         </table>
       </td>
       <td>
diff --git a/apps/speaker/speaker.js b/apps/speaker/speaker.js
index 77cb1ff..9ab0457 100644
--- a/apps/speaker/speaker.js
+++ b/apps/speaker/speaker.js
@@ -7,17 +7,19 @@ let connectionText;
 let codecText;
 let packetsReceivedText;
 let bytesReceivedText;
+let bitrateText;
 let streamStateText;
 let connectionStateText;
 let controlsDiv;
 let audioOnButton;
-let mediaSource;
-let sourceBuffer;
-let audioElement;
+let audioDecoder;
+let audioCodec;
 let audioContext;
 let audioAnalyzer;
 let audioFrequencyBinCount;
 let audioFrequencyData;
+let nextAudioStartPosition = 0;
+let audioStartTime = 0;
 let packetsReceived = 0;
 let bytesReceived = 0;
 let audioState = "stopped";
@@ -29,20 +31,17 @@ let bandwidthCanvas;
 let bandwidthCanvasContext;
 let bandwidthBinCount;
 let bandwidthBins = [];
+let bitrateSamples = [];
 
 const FFT_WIDTH = 800;
 const FFT_HEIGHT = 256;
 const BANDWIDTH_WIDTH = 500;
 const BANDWIDTH_HEIGHT = 100;
-
-function hexToBytes(hex) {
-    return Uint8Array.from(hex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
-}
+const BITRATE_WINDOW = 30;
 
 function init() {
     initUI();
-    initMediaSource();
-    initAudioElement();
+    initAudioContext();
     initAnalyzer();
 
     connect();
@@ -56,6 +55,7 @@ function initUI() {
     codecText = document.getElementById("codecText");
     packetsReceivedText = document.getElementById("packetsReceivedText");
     bytesReceivedText = document.getElementById("bytesReceivedText");
+    bitrateText = document.getElementById("bitrate");
     streamStateText = document.getElementById("streamStateText");
     connectionStateText = document.getElementById("connectionStateText");
     audioSupportMessageText = document.getElementById("audioSupportMessageText");
@@ -67,17 +67,9 @@ function initUI() {
     requestAnimationFrame(onAnimationFrame);
 }
 
-function initMediaSource() {
-    mediaSource = new MediaSource();
-    mediaSource.onsourceopen = onMediaSourceOpen;
-    mediaSource.onsourceclose = onMediaSourceClose;
-    mediaSource.onsourceended = onMediaSourceEnd;
-}
-
-function initAudioElement() {
-    audioElement = document.getElementById("audio");
-    audioElement.src = URL.createObjectURL(mediaSource);
-    // audioElement.controls = true;
+function initAudioContext() {
+    audioContext = new AudioContext();
+    audioContext.onstatechange = () => console.log("AudioContext state:", audioContext.state);
 }
 
 function initAnalyzer() {
@@ -94,24 +86,16 @@ function initAnalyzer() {
     bandwidthCanvasContext = bandwidthCanvas.getContext('2d');
     bandwidthCanvasContext.fillStyle = "rgb(255, 255, 255)";
     bandwidthCanvasContext.fillRect(0, 0, BANDWIDTH_WIDTH, BANDWIDTH_HEIGHT);
-}
-
-function startAnalyzer() {
-    // FFT
-    if (audioElement.captureStream !== undefined) {
-        audioContext = new AudioContext();
-        audioAnalyzer = audioContext.createAnalyser();
-        audioAnalyzer.fftSize = 128;
-        audioFrequencyBinCount = audioAnalyzer.frequencyBinCount;
-        audioFrequencyData = new Uint8Array(audioFrequencyBinCount);
-        const stream = audioElement.captureStream();
-        const source = audioContext.createMediaStreamSource(stream);
-        source.connect(audioAnalyzer);
-    }
-
-    // Bandwidth
     bandwidthBinCount = BANDWIDTH_WIDTH / 2;
     bandwidthBins = [];
+    bitrateSamples = [];
+
+    audioAnalyzer = audioContext.createAnalyser();
+    audioAnalyzer.fftSize = 128;
+    audioFrequencyBinCount = audioAnalyzer.frequencyBinCount;
+    audioFrequencyData = new Uint8Array(audioFrequencyBinCount);
+
+    audioAnalyzer.connect(audioContext.destination)
 }
 
 function setConnectionText(message) {
@@ -148,7 +132,8 @@ function onAnimationFrame() {
     bandwidthCanvasContext.fillRect(0, 0, BANDWIDTH_WIDTH, BANDWIDTH_HEIGHT);
     bandwidthCanvasContext.fillStyle = `rgb(100, 100, 100)`;
     for (let t = 0; t < bandwidthBins.length; t++) {
-        const lineHeight = (bandwidthBins[t] / 1000) * BANDWIDTH_HEIGHT;
+        const bytesReceived = bandwidthBins[t]
+        const lineHeight = (bytesReceived / 1000) * BANDWIDTH_HEIGHT;
         bandwidthCanvasContext.fillRect(t * 2, BANDWIDTH_HEIGHT - lineHeight, 2, lineHeight);
     }
 
@@ -156,28 +141,14 @@ function onAnimationFrame() {
     requestAnimationFrame(onAnimationFrame);
 }
 
-function onMediaSourceOpen() {
-    console.log(this.readyState);
-    sourceBuffer = mediaSource.addSourceBuffer("audio/aac");
-}
-
-function onMediaSourceClose() {
-    console.log(this.readyState);
-}
-
-function onMediaSourceEnd() {
-    console.log(this.readyState);
-}
-
 async function startAudio() {
     try {
         console.log("starting audio...");
         audioOnButton.disabled = true;
         audioState = "starting";
-        await audioElement.play();
+        audioContext.resume();
         console.log("audio started");
         audioState = "playing";
-        startAnalyzer();
     } catch(error) {
         console.error(`play failed: ${error}`);
         audioState = "stopped";
@@ -185,12 +156,47 @@ async function startAudio() {
     }
 }
 
-function onAudioPacket(packet) {
-    if (audioState != "stopped") {
-        // Queue the audio packet.
-        sourceBuffer.appendBuffer(packet);
+function onDecodedAudio(audioData) {
+    const bufferSource = audioContext.createBufferSource()
+
+    const now = audioContext.currentTime;
+    let nextAudioStartTime = audioStartTime + (nextAudioStartPosition / audioData.sampleRate);
+    if (nextAudioStartTime < now) {
+        console.log("starting new audio time base")
+        audioStartTime = now;
+        nextAudioStartTime = now;
+        nextAudioStartPosition = 0;
+    } else {
+        console.log(`audio buffer scheduled in ${nextAudioStartTime - now}`)
+    }
+
+    const audioBuffer = audioContext.createBuffer(
+        audioData.numberOfChannels,
+        audioData.numberOfFrames,
+        audioData.sampleRate
+    );
+
+    for (let channel = 0; channel < audioData.numberOfChannels; channel++) {
+        audioData.copyTo(
+            audioBuffer.getChannelData(channel),
+            {
+                planeIndex: channel,
+                format: "f32-planar"
+            }
+        )
     }
 
+    bufferSource.buffer = audioBuffer;
+    bufferSource.connect(audioAnalyzer)
+    bufferSource.start(nextAudioStartTime);
+    nextAudioStartPosition += audioData.numberOfFrames;
+}
+
+function onCodecError(error) {
+    console.log("Codec error:", error)
+}
+
+async function onAudioPacket(packet) {
     packetsReceived += 1;
     packetsReceivedText.innerText = packetsReceived;
     bytesReceived += packet.byteLength;
@@ -200,6 +206,48 @@ function onAudioPacket(packet) {
     if (bandwidthBins.length > bandwidthBinCount) {
         bandwidthBins.shift();
     }
+    bitrateSamples[bitrateSamples.length] = {ts: Date.now(), bytes: packet.byteLength}
+    if (bitrateSamples.length > BITRATE_WINDOW) {
+        bitrateSamples.shift();
+    }
+    if (bitrateSamples.length >= 2) {
+        const windowBytes = bitrateSamples.reduce((accumulator, x) => accumulator + x.bytes, 0) - bitrateSamples[0].bytes;
+        const elapsed = bitrateSamples[bitrateSamples.length-1].ts - bitrateSamples[0].ts;
+        const bitrate = Math.floor(8 * windowBytes / elapsed)
+        bitrateText.innerText = `${bitrate} kb/s`
+    }
+
+    if (audioState == "stopped") {
+        return;
+    }
+
+    if (audioDecoder === undefined) {
+        let audioConfig;
+        if (audioCodec == 'aac') {
+            audioConfig = {
+                codec: 'mp4a.40.2',
+                sampleRate: 44100, // ignored
+                numberOfChannels: 2, // ignored
+            }
+        } else if (audioCodec == 'opus') {
+            audioConfig = {
+                codec: 'opus',
+                sampleRate: 48000, // ignored
+                numberOfChannels: 2, // ignored
+            }
+        }
+        audioDecoder = new AudioDecoder({ output: onDecodedAudio, error: onCodecError });
+        audioDecoder.configure(audioConfig)
+    }
+
+    const encodedAudio = new EncodedAudioChunk({
+        type: "key",
+        data: packet,
+        timestamp: 0,
+        transfer: [packet],
+    });
+
+    audioDecoder.decode(encodedAudio);
 }
 
 function onChannelOpen() {
@@ -249,16 +297,19 @@ function onChannelMessage(message) {
     }
 }
 
-function onHelloMessage(params) {
+async function onHelloMessage(params) {
     codecText.innerText = params.codec;
-    if (params.codec != "aac") {
-        audioOnButton.disabled = true;
-        audioSupportMessageText.innerText = "Only AAC can be played, audio will be disabled";
-        audioSupportMessageText.style.display = "inline-block";
-    } else {
+
+    if (params.codec == "aac" || params.codec == "opus") {
+        audioCodec = params.codec
         audioSupportMessageText.innerText = "";
         audioSupportMessageText.style.display = "none";
+    } else {
+        audioOnButton.disabled = true;
+        audioSupportMessageText.innerText = "Only AAC and Opus can be played, audio will be disabled";
+        audioSupportMessageText.style.display = "inline-block";
     }
+
     if (params.streamState) {
         setStreamState(params.streamState);
     }
diff --git a/apps/speaker/speaker.py b/apps/speaker/speaker.py
index fc2230a..2f0105c 100644
--- a/apps/speaker/speaker.py
+++ b/apps/speaker/speaker.py
@@ -34,7 +34,7 @@ from aiohttp import web
 
 import bumble
 from bumble.colors import color
-from bumble.core import BT_BR_EDR_TRANSPORT, CommandTimeoutError
+from bumble.core import PhysicalTransport, CommandTimeoutError
 from bumble.device import Connection, Device, DeviceConfiguration
 from bumble.hci import HCI_StatusError
 from bumble.pairing import PairingConfig
@@ -44,25 +44,20 @@ from bumble.avdtp import (
     AVDTP_AUDIO_MEDIA_TYPE,
     Listener,
     MediaCodecCapabilities,
-    MediaPacket,
     Protocol,
 )
 from bumble.a2dp import (
-    MPEG_2_AAC_LC_OBJECT_TYPE,
     make_audio_sink_service_sdp_records,
     A2DP_SBC_CODEC_TYPE,
     A2DP_MPEG_2_4_AAC_CODEC_TYPE,
-    SBC_MONO_CHANNEL_MODE,
-    SBC_DUAL_CHANNEL_MODE,
-    SBC_SNR_ALLOCATION_METHOD,
-    SBC_LOUDNESS_ALLOCATION_METHOD,
-    SBC_STEREO_CHANNEL_MODE,
-    SBC_JOINT_STEREO_CHANNEL_MODE,
+    A2DP_NON_A2DP_CODEC_TYPE,
     SbcMediaCodecInformation,
     AacMediaCodecInformation,
+    OpusMediaCodecInformation,
 )
 from bumble.utils import AsyncRunner
 from bumble.codecs import AacAudioRtpPacket
+from bumble.rtp import MediaPacket
 
 
 # -----------------------------------------------------------------------------
@@ -85,6 +80,8 @@ class AudioExtractor:
             return AacAudioExtractor()
         if codec == 'sbc':
             return SbcAudioExtractor()
+        if codec == 'opus':
+            return OpusAudioExtractor()
 
     def extract_audio(self, packet: MediaPacket) -> bytes:
         raise NotImplementedError()
@@ -93,7 +90,7 @@ class AudioExtractor:
 # -----------------------------------------------------------------------------
 class AacAudioExtractor:
     def extract_audio(self, packet: MediaPacket) -> bytes:
-        return AacAudioRtpPacket(packet.payload).to_adts()
+        return AacAudioRtpPacket.from_bytes(packet.payload).to_adts()
 
 
 # -----------------------------------------------------------------------------
@@ -109,6 +106,13 @@ class SbcAudioExtractor:
         return packet.payload[1:]
 
 
+# -----------------------------------------------------------------------------
+class OpusAudioExtractor:
+    def extract_audio(self, packet: MediaPacket) -> bytes:
+        # TODO: parse fields
+        return packet.payload[1:]
+
+
 # -----------------------------------------------------------------------------
 class Output:
     async def start(self) -> None:
@@ -242,7 +246,7 @@ class FfplayOutput(QueuedOutput):
         await super().start()
 
         self.subprocess = await asyncio.create_subprocess_shell(
-            f'ffplay -f {self.codec} pipe:0',
+            f'ffplay -probesize 32 -f {self.codec} pipe:0',
             stdin=asyncio.subprocess.PIPE,
             stdout=asyncio.subprocess.PIPE,
             stderr=asyncio.subprocess.PIPE,
@@ -406,10 +410,24 @@ class Speaker:
         STARTED = 2
         SUSPENDED = 3
 
-    def __init__(self, device_config, transport, codec, discover, outputs, ui_port):
+    def __init__(
+        self,
+        device_config,
+        transport,
+        codec,
+        sampling_frequencies,
+        bitrate,
+        vbr,
+        discover,
+        outputs,
+        ui_port,
+    ):
         self.device_config = device_config
         self.transport = transport
         self.codec = codec
+        self.sampling_frequencies = sampling_frequencies
+        self.bitrate = bitrate
+        self.vbr = vbr
         self.discover = discover
         self.ui_port = ui_port
         self.device = None
@@ -445,44 +463,92 @@ class Speaker:
         if self.codec == 'sbc':
             return self.sbc_codec_capabilities()
 
+        if self.codec == 'opus':
+            return self.opus_codec_capabilities()
+
         raise RuntimeError('unsupported codec')
 
     def aac_codec_capabilities(self) -> MediaCodecCapabilities:
+        supported_sampling_frequencies = AacMediaCodecInformation.SamplingFrequency(0)
+        for sampling_frequency in self.sampling_frequencies or [
+            8000,
+            11025,
+            12000,
+            16000,
+            22050,
+            24000,
+            32000,
+            44100,
+            48000,
+        ]:
+            supported_sampling_frequencies |= (
+                AacMediaCodecInformation.SamplingFrequency.from_int(sampling_frequency)
+            )
         return MediaCodecCapabilities(
             media_type=AVDTP_AUDIO_MEDIA_TYPE,
             media_codec_type=A2DP_MPEG_2_4_AAC_CODEC_TYPE,
-            media_codec_information=AacMediaCodecInformation.from_lists(
-                object_types=[MPEG_2_AAC_LC_OBJECT_TYPE],
-                sampling_frequencies=[48000, 44100],
-                channels=[1, 2],
-                vbr=1,
-                bitrate=256000,
+            media_codec_information=AacMediaCodecInformation(
+                object_type=AacMediaCodecInformation.ObjectType.MPEG_2_AAC_LC,
+                sampling_frequency=supported_sampling_frequencies,
+                channels=AacMediaCodecInformation.Channels.MONO
+                | AacMediaCodecInformation.Channels.STEREO,
+                vbr=1 if self.vbr else 0,
+                bitrate=self.bitrate or 256000,
             ),
         )
 
     def sbc_codec_capabilities(self) -> MediaCodecCapabilities:
+        supported_sampling_frequencies = SbcMediaCodecInformation.SamplingFrequency(0)
+        for sampling_frequency in self.sampling_frequencies or [
+            16000,
+            32000,
+            44100,
+            48000,
+        ]:
+            supported_sampling_frequencies |= (
+                SbcMediaCodecInformation.SamplingFrequency.from_int(sampling_frequency)
+            )
         return MediaCodecCapabilities(
             media_type=AVDTP_AUDIO_MEDIA_TYPE,
             media_codec_type=A2DP_SBC_CODEC_TYPE,
-            media_codec_information=SbcMediaCodecInformation.from_lists(
-                sampling_frequencies=[48000, 44100, 32000, 16000],
-                channel_modes=[
-                    SBC_MONO_CHANNEL_MODE,
-                    SBC_DUAL_CHANNEL_MODE,
-                    SBC_STEREO_CHANNEL_MODE,
-                    SBC_JOINT_STEREO_CHANNEL_MODE,
-                ],
-                block_lengths=[4, 8, 12, 16],
-                subbands=[4, 8],
-                allocation_methods=[
-                    SBC_LOUDNESS_ALLOCATION_METHOD,
-                    SBC_SNR_ALLOCATION_METHOD,
-                ],
+            media_codec_information=SbcMediaCodecInformation(
+                sampling_frequency=supported_sampling_frequencies,
+                channel_mode=SbcMediaCodecInformation.ChannelMode.MONO
+                | SbcMediaCodecInformation.ChannelMode.DUAL_CHANNEL
+                | SbcMediaCodecInformation.ChannelMode.STEREO
+                | SbcMediaCodecInformation.ChannelMode.JOINT_STEREO,
+                block_length=SbcMediaCodecInformation.BlockLength.BL_4
+                | SbcMediaCodecInformation.BlockLength.BL_8
+                | SbcMediaCodecInformation.BlockLength.BL_12
+                | SbcMediaCodecInformation.BlockLength.BL_16,
+                subbands=SbcMediaCodecInformation.Subbands.S_4
+                | SbcMediaCodecInformation.Subbands.S_8,
+                allocation_method=SbcMediaCodecInformation.AllocationMethod.LOUDNESS
+                | SbcMediaCodecInformation.AllocationMethod.SNR,
                 minimum_bitpool_value=2,
                 maximum_bitpool_value=53,
             ),
         )
 
+    def opus_codec_capabilities(self) -> MediaCodecCapabilities:
+        supported_sampling_frequencies = OpusMediaCodecInformation.SamplingFrequency(0)
+        for sampling_frequency in self.sampling_frequencies or [48000]:
+            supported_sampling_frequencies |= (
+                OpusMediaCodecInformation.SamplingFrequency.from_int(sampling_frequency)
+            )
+        return MediaCodecCapabilities(
+            media_type=AVDTP_AUDIO_MEDIA_TYPE,
+            media_codec_type=A2DP_NON_A2DP_CODEC_TYPE,
+            media_codec_information=OpusMediaCodecInformation(
+                frame_size=OpusMediaCodecInformation.FrameSize.FS_10MS
+                | OpusMediaCodecInformation.FrameSize.FS_20MS,
+                channel_mode=OpusMediaCodecInformation.ChannelMode.MONO
+                | OpusMediaCodecInformation.ChannelMode.STEREO
+                | OpusMediaCodecInformation.ChannelMode.DUAL_MONO,
+                sampling_frequency=supported_sampling_frequencies,
+            ),
+        )
+
     async def dispatch_to_outputs(self, function):
         for output in self.outputs:
             await function(output)
@@ -570,7 +636,9 @@ class Speaker:
     async def connect(self, address):
         # Connect to the source
         print(f'=== Connecting to {address}...')
-        connection = await self.device.connect(address, transport=BT_BR_EDR_TRANSPORT)
+        connection = await self.device.connect(
+            address, transport=PhysicalTransport.BR_EDR
+        )
         print(f'=== Connected to {connection.peer_address}')
 
         # Request authentication
@@ -675,7 +743,26 @@ def speaker_cli(ctx, device_config):
 
 @click.command()
 @click.option(
-    '--codec', type=click.Choice(['sbc', 'aac']), default='aac', show_default=True
+    '--codec',
+    type=click.Choice(['sbc', 'aac', 'opus']),
+    default='aac',
+    show_default=True,
+)
+@click.option(
+    '--sampling-frequency',
+    metavar='SAMPLING-FREQUENCY',
+    type=int,
+    multiple=True,
+    help='Enable a sampling frequency (may be specified more than once)',
+)
+@click.option(
+    '--bitrate',
+    metavar='BITRATE',
+    type=int,
+    help='Supported bitrate (AAC only)',
+)
+@click.option(
+    '--vbr/--no-vbr', is_flag=True, default=True, help='Enable VBR (AAC only)'
 )
 @click.option(
     '--discover', is_flag=True, help='Discover remote endpoints once connected'
@@ -706,7 +793,16 @@ def speaker_cli(ctx, device_config):
 @click.option('--device-config', metavar='FILENAME', help='Device configuration file')
 @click.argument('transport')
 def speaker(
-    transport, codec, connect_address, discover, output, ui_port, device_config
+    transport,
+    codec,
+    sampling_frequency,
+    bitrate,
+    vbr,
+    connect_address,
+    discover,
+    output,
+    ui_port,
+    device_config,
 ):
     """Run the speaker."""
 
@@ -721,15 +817,27 @@ def speaker(
             output = list(filter(lambda x: x != '@ffplay', output))
 
     asyncio.run(
-        Speaker(device_config, transport, codec, discover, output, ui_port).run(
-            connect_address
-        )
+        Speaker(
+            device_config,
+            transport,
+            codec,
+            sampling_frequency,
+            bitrate,
+            vbr,
+            discover,
+            output,
+            ui_port,
+        ).run(connect_address)
     )
 
 
 # -----------------------------------------------------------------------------
 def main():
-    logging.basicConfig(level=os.environ.get('BUMBLE_LOGLEVEL', 'WARNING').upper())
+    logging.basicConfig(
+        level=os.environ.get('BUMBLE_LOGLEVEL', 'WARNING').upper(),
+        format="[%(asctime)s.%(msecs)03d] %(levelname)s:%(name)s:%(message)s",
+        datefmt="%H:%M:%S",
+    )
     speaker()
 
 
diff --git a/bumble/a2dp.py b/bumble/a2dp.py
index cac14e9..ffcee46 100644
--- a/bumble/a2dp.py
+++ b/bumble/a2dp.py
@@ -17,14 +17,18 @@
 # -----------------------------------------------------------------------------
 from __future__ import annotations
 
+from collections.abc import AsyncGenerator
 import dataclasses
-import struct
+import enum
 import logging
-from collections.abc import AsyncGenerator
-from typing import List, Callable, Awaitable
+import struct
+from typing import Awaitable, Callable
+from typing_extensions import ClassVar, Self
+
 
-from .company_ids import COMPANY_IDENTIFIERS
-from .sdp import (
+from bumble.codecs import AacAudioRtpPacket
+from bumble.company_ids import COMPANY_IDENTIFIERS
+from bumble.sdp import (
     DataElement,
     ServiceAttribute,
     SDP_PUBLIC_BROWSE_ROOT,
@@ -34,7 +38,7 @@ from .sdp import (
     SDP_PROTOCOL_DESCRIPTOR_LIST_ATTRIBUTE_ID,
     SDP_BLUETOOTH_PROFILE_DESCRIPTOR_LIST_ATTRIBUTE_ID,
 )
-from .core import (
+from bumble.core import (
     BT_L2CAP_PROTOCOL_ID,
     BT_AUDIO_SOURCE_SERVICE,
     BT_AUDIO_SINK_SERVICE,
@@ -42,6 +46,7 @@ from .core import (
     BT_ADVANCED_AUDIO_DISTRIBUTION_SERVICE,
     name_or_number,
 )
+from bumble.rtp import MediaPacket
 
 
 # -----------------------------------------------------------------------------
@@ -103,6 +108,8 @@ SBC_ALLOCATION_METHOD_NAMES = {
     SBC_LOUDNESS_ALLOCATION_METHOD: 'SBC_LOUDNESS_ALLOCATION_METHOD'
 }
 
+SBC_MAX_FRAMES_IN_RTP_PAYLOAD = 15
+
 MPEG_2_4_AAC_SAMPLING_FREQUENCIES = [
     8000,
     11025,
@@ -130,6 +137,9 @@ MPEG_2_4_OBJECT_TYPE_NAMES = {
     MPEG_4_AAC_SCALABLE_OBJECT_TYPE: 'MPEG_4_AAC_SCALABLE_OBJECT_TYPE'
 }
 
+
+OPUS_MAX_FRAMES_IN_RTP_PAYLOAD = 15
+
 # fmt: on
 
 
@@ -145,7 +155,7 @@ def flags_to_list(flags, values):
 # -----------------------------------------------------------------------------
 def make_audio_source_service_sdp_records(service_record_handle, version=(1, 3)):
     # pylint: disable=import-outside-toplevel
-    from .avdtp import AVDTP_PSM
+    from bumble.avdtp import AVDTP_PSM
 
     version_int = version[0] << 8 | version[1]
     return [
@@ -199,7 +209,7 @@ def make_audio_source_service_sdp_records(service_record_handle, version=(1, 3))
 # -----------------------------------------------------------------------------
 def make_audio_sink_service_sdp_records(service_record_handle, version=(1, 3)):
     # pylint: disable=import-outside-toplevel
-    from .avdtp import AVDTP_PSM
+    from bumble.avdtp import AVDTP_PSM
 
     version_int = version[0] << 8 | version[1]
     return [
@@ -257,38 +267,61 @@ class SbcMediaCodecInformation:
     A2DP spec - 4.3.2 Codec Specific Information Elements
     '''
 
-    sampling_frequency: int
-    channel_mode: int
-    block_length: int
-    subbands: int
-    allocation_method: int
+    sampling_frequency: SamplingFrequency
+    channel_mode: ChannelMode
+    block_length: BlockLength
+    subbands: Subbands
+    allocation_method: AllocationMethod
     minimum_bitpool_value: int
     maximum_bitpool_value: int
 
-    SAMPLING_FREQUENCY_BITS = {16000: 1 << 3, 32000: 1 << 2, 44100: 1 << 1, 48000: 1}
-    CHANNEL_MODE_BITS = {
-        SBC_MONO_CHANNEL_MODE: 1 << 3,
-        SBC_DUAL_CHANNEL_MODE: 1 << 2,
-        SBC_STEREO_CHANNEL_MODE: 1 << 1,
-        SBC_JOINT_STEREO_CHANNEL_MODE: 1,
-    }
-    BLOCK_LENGTH_BITS = {4: 1 << 3, 8: 1 << 2, 12: 1 << 1, 16: 1}
-    SUBBANDS_BITS = {4: 1 << 1, 8: 1}
-    ALLOCATION_METHOD_BITS = {
-        SBC_SNR_ALLOCATION_METHOD: 1 << 1,
-        SBC_LOUDNESS_ALLOCATION_METHOD: 1,
-    }
+    class SamplingFrequency(enum.IntFlag):
+        SF_16000 = 1 << 3
+        SF_32000 = 1 << 2
+        SF_44100 = 1 << 1
+        SF_48000 = 1 << 0
+
+        @classmethod
+        def from_int(cls, sampling_frequency: int) -> Self:
+            sampling_frequencies = [
+                16000,
+                32000,
+                44100,
+                48000,
+            ]
+            index = sampling_frequencies.index(sampling_frequency)
+            return cls(1 << (len(sampling_frequencies) - index - 1))
 
-    @staticmethod
-    def from_bytes(data: bytes) -> SbcMediaCodecInformation:
-        sampling_frequency = (data[0] >> 4) & 0x0F
-        channel_mode = (data[0] >> 0) & 0x0F
-        block_length = (data[1] >> 4) & 0x0F
-        subbands = (data[1] >> 2) & 0x03
-        allocation_method = (data[1] >> 0) & 0x03
+    class ChannelMode(enum.IntFlag):
+        MONO = 1 << 3
+        DUAL_CHANNEL = 1 << 2
+        STEREO = 1 << 1
+        JOINT_STEREO = 1 << 0
+
+    class BlockLength(enum.IntFlag):
+        BL_4 = 1 << 3
+        BL_8 = 1 << 2
+        BL_12 = 1 << 1
+        BL_16 = 1 << 0
+
+    class Subbands(enum.IntFlag):
+        S_4 = 1 << 1
+        S_8 = 1 << 0
+
+    class AllocationMethod(enum.IntFlag):
+        SNR = 1 << 1
+        LOUDNESS = 1 << 0
+
+    @classmethod
+    def from_bytes(cls, data: bytes) -> Self:
+        sampling_frequency = cls.SamplingFrequency((data[0] >> 4) & 0x0F)
+        channel_mode = cls.ChannelMode((data[0] >> 0) & 0x0F)
+        block_length = cls.BlockLength((data[1] >> 4) & 0x0F)
+        subbands = cls.Subbands((data[1] >> 2) & 0x03)
+        allocation_method = cls.AllocationMethod((data[1] >> 0) & 0x03)
         minimum_bitpool_value = (data[2] >> 0) & 0xFF
         maximum_bitpool_value = (data[3] >> 0) & 0xFF
-        return SbcMediaCodecInformation(
+        return cls(
             sampling_frequency,
             channel_mode,
             block_length,
@@ -298,52 +331,6 @@ class SbcMediaCodecInformation:
             maximum_bitpool_value,
         )
 
-    @classmethod
-    def from_discrete_values(
-        cls,
-        sampling_frequency: int,
-        channel_mode: int,
-        block_length: int,
-        subbands: int,
-        allocation_method: int,
-        minimum_bitpool_value: int,
-        maximum_bitpool_value: int,
-    ) -> SbcMediaCodecInformation:
-        return SbcMediaCodecInformation(
-            sampling_frequency=cls.SAMPLING_FREQUENCY_BITS[sampling_frequency],
-            channel_mode=cls.CHANNEL_MODE_BITS[channel_mode],
-            block_length=cls.BLOCK_LENGTH_BITS[block_length],
-            subbands=cls.SUBBANDS_BITS[subbands],
-            allocation_method=cls.ALLOCATION_METHOD_BITS[allocation_method],
-            minimum_bitpool_value=minimum_bitpool_value,
-            maximum_bitpool_value=maximum_bitpool_value,
-        )
-
-    @classmethod
-    def from_lists(
-        cls,
-        sampling_frequencies: List[int],
-        channel_modes: List[int],
-        block_lengths: List[int],
-        subbands: List[int],
-        allocation_methods: List[int],
-        minimum_bitpool_value: int,
-        maximum_bitpool_value: int,
-    ) -> SbcMediaCodecInformation:
-        return SbcMediaCodecInformation(
-            sampling_frequency=sum(
-                cls.SAMPLING_FREQUENCY_BITS[x] for x in sampling_frequencies
-            ),
-            channel_mode=sum(cls.CHANNEL_MODE_BITS[x] for x in channel_modes),
-            block_length=sum(cls.BLOCK_LENGTH_BITS[x] for x in block_lengths),
-            subbands=sum(cls.SUBBANDS_BITS[x] for x in subbands),
-            allocation_method=sum(
-                cls.ALLOCATION_METHOD_BITS[x] for x in allocation_methods
-            ),
-            minimum_bitpool_value=minimum_bitpool_value,
-            maximum_bitpool_value=maximum_bitpool_value,
-        )
-
     def __bytes__(self) -> bytes:
         return bytes(
             [
@@ -356,23 +343,6 @@ class SbcMediaCodecInformation:
             ]
         )
 
-    def __str__(self) -> str:
-        channel_modes = ['MONO', 'DUAL_CHANNEL', 'STEREO', 'JOINT_STEREO']
-        allocation_methods = ['SNR', 'Loudness']
-        return '\n'.join(
-            # pylint: disable=line-too-long
-            [
-                'SbcMediaCodecInformation(',
-                f'  sampling_frequency:    {",".join([str(x) for x in flags_to_list(self.sampling_frequency, SBC_SAMPLING_FREQUENCIES)])}',
-                f'  channel_mode:          {",".join([str(x) for x in flags_to_list(self.channel_mode, channel_modes)])}',
-                f'  block_length:          {",".join([str(x) for x in flags_to_list(self.block_length, SBC_BLOCK_LENGTHS)])}',
-                f'  subbands:              {",".join([str(x) for x in flags_to_list(self.subbands, SBC_SUBBANDS)])}',
-                f'  allocation_method:     {",".join([str(x) for x in flags_to_list(self.allocation_method, allocation_methods)])}',
-                f'  minimum_bitpool_value: {self.minimum_bitpool_value}',
-                f'  maximum_bitpool_value: {self.maximum_bitpool_value}' ')',
-            ]
-        )
-
 
 # -----------------------------------------------------------------------------
 @dataclasses.dataclass
@@ -381,83 +351,66 @@ class AacMediaCodecInformation:
     A2DP spec - 4.5.2 Codec Specific Information Elements
     '''
 
-    object_type: int
-    sampling_frequency: int
-    channels: int
-    rfa: int
+    object_type: ObjectType
+    sampling_frequency: SamplingFrequency
+    channels: Channels
     vbr: int
     bitrate: int
 
-    OBJECT_TYPE_BITS = {
-        MPEG_2_AAC_LC_OBJECT_TYPE: 1 << 7,
-        MPEG_4_AAC_LC_OBJECT_TYPE: 1 << 6,
-        MPEG_4_AAC_LTP_OBJECT_TYPE: 1 << 5,
-        MPEG_4_AAC_SCALABLE_OBJECT_TYPE: 1 << 4,
-    }
-    SAMPLING_FREQUENCY_BITS = {
-        8000: 1 << 11,
-        11025: 1 << 10,
-        12000: 1 << 9,
-        16000: 1 << 8,
-        22050: 1 << 7,
-        24000: 1 << 6,
-        32000: 1 << 5,
-        44100: 1 << 4,
-        48000: 1 << 3,
-        64000: 1 << 2,
-        88200: 1 << 1,
-        96000: 1,
-    }
-    CHANNELS_BITS = {1: 1 << 1, 2: 1}
+    class ObjectType(enum.IntFlag):
+        MPEG_2_AAC_LC = 1 << 7
+        MPEG_4_AAC_LC = 1 << 6
+        MPEG_4_AAC_LTP = 1 << 5
+        MPEG_4_AAC_SCALABLE = 1 << 4
+
+    class SamplingFrequency(enum.IntFlag):
+        SF_8000 = 1 << 11
+        SF_11025 = 1 << 10
+        SF_12000 = 1 << 9
+        SF_16000 = 1 << 8
+        SF_22050 = 1 << 7
+        SF_24000 = 1 << 6
+        SF_32000 = 1 << 5
+        SF_44100 = 1 << 4
+        SF_48000 = 1 << 3
+        SF_64000 = 1 << 2
+        SF_88200 = 1 << 1
+        SF_96000 = 1 << 0
+
+        @classmethod
+        def from_int(cls, sampling_frequency: int) -> Self:
+            sampling_frequencies = [
+                8000,
+                11025,
+                12000,
+                16000,
+                22050,
+                24000,
+                32000,
+                44100,
+                48000,
+                64000,
+                88200,
+                96000,
+            ]
+            index = sampling_frequencies.index(sampling_frequency)
+            return cls(1 << (len(sampling_frequencies) - index - 1))
 
-    @staticmethod
-    def from_bytes(data: bytes) -> AacMediaCodecInformation:
-        object_type = data[0]
-        sampling_frequency = (data[1] << 4) | ((data[2] >> 4) & 0x0F)
-        channels = (data[2] >> 2) & 0x03
-        rfa = 0
-        vbr = (data[3] >> 7) & 0x01
-        bitrate = ((data[3] & 0x7F) << 16) | (data[4] << 8) | data[5]
-        return AacMediaCodecInformation(
-            object_type, sampling_frequency, channels, rfa, vbr, bitrate
-        )
+    class Channels(enum.IntFlag):
+        MONO = 1 << 1
+        STEREO = 1 << 0
 
     @classmethod
-    def from_discrete_values(
-        cls,
-        object_type: int,
-        sampling_frequency: int,
-        channels: int,
-        vbr: int,
-        bitrate: int,
-    ) -> AacMediaCodecInformation:
-        return AacMediaCodecInformation(
-            object_type=cls.OBJECT_TYPE_BITS[object_type],
-            sampling_frequency=cls.SAMPLING_FREQUENCY_BITS[sampling_frequency],
-            channels=cls.CHANNELS_BITS[channels],
-            rfa=0,
-            vbr=vbr,
-            bitrate=bitrate,
+    def from_bytes(cls, data: bytes) -> AacMediaCodecInformation:
+        object_type = cls.ObjectType(data[0])
+        sampling_frequency = cls.SamplingFrequency(
+            (data[1] << 4) | ((data[2] >> 4) & 0x0F)
         )
-
-    @classmethod
-    def from_lists(
-        cls,
-        object_types: List[int],
-        sampling_frequencies: List[int],
-        channels: List[int],
-        vbr: int,
-        bitrate: int,
-    ) -> AacMediaCodecInformation:
+        channels = cls.Channels((data[2] >> 2) & 0x03)
+        vbr = (data[3] >> 7) & 0x01
+        bitrate = ((data[3] & 0x7F) << 16) | (data[4] << 8) | data[5]
         return AacMediaCodecInformation(
-            object_type=sum(cls.OBJECT_TYPE_BITS[x] for x in object_types),
-            sampling_frequency=sum(
-                cls.SAMPLING_FREQUENCY_BITS[x] for x in sampling_frequencies
-            ),
-            channels=sum(cls.CHANNELS_BITS[x] for x in channels),
-            rfa=0,
-            vbr=vbr,
-            bitrate=bitrate,
+            object_type, sampling_frequency, channels, vbr, bitrate
         )
 
     def __bytes__(self) -> bytes:
@@ -472,30 +425,6 @@ class AacMediaCodecInformation:
             ]
         )
 
-    def __str__(self) -> str:
-        object_types = [
-            'MPEG_2_AAC_LC',
-            'MPEG_4_AAC_LC',
-            'MPEG_4_AAC_LTP',
-            'MPEG_4_AAC_SCALABLE',
-            '[4]',
-            '[5]',
-            '[6]',
-            '[7]',
-        ]
-        channels = [1, 2]
-        # pylint: disable=line-too-long
-        return '\n'.join(
-            [
-                'AacMediaCodecInformation(',
-                f'  object_type:        {",".join([str(x) for x in flags_to_list(self.object_type, object_types)])}',
-                f'  sampling_frequency: {",".join([str(x) for x in flags_to_list(self.sampling_frequency, MPEG_2_4_AAC_SAMPLING_FREQUENCIES)])}',
-                f'  channels:           {",".join([str(x) for x in flags_to_list(self.channels, channels)])}',
-                f'  vbr:                {self.vbr}',
-                f'  bitrate:            {self.bitrate}' ')',
-            ]
-        )
-
 
 @dataclasses.dataclass
 # -----------------------------------------------------------------------------
@@ -514,7 +443,7 @@ class VendorSpecificMediaCodecInformation:
         return VendorSpecificMediaCodecInformation(vendor_id, codec_id, data[6:])
 
     def __bytes__(self) -> bytes:
-        return struct.pack('<IH', self.vendor_id, self.codec_id, self.value)
+        return struct.pack('<IH', self.vendor_id, self.codec_id) + self.value
 
     def __str__(self) -> str:
         # pylint: disable=line-too-long
@@ -528,13 +457,75 @@ class VendorSpecificMediaCodecInformation:
         )
 
 
+# -----------------------------------------------------------------------------
+@dataclasses.dataclass
+class OpusMediaCodecInformation(VendorSpecificMediaCodecInformation):
+    vendor_id: int = dataclasses.field(init=False, repr=False)
+    codec_id: int = dataclasses.field(init=False, repr=False)
+    value: bytes = dataclasses.field(init=False, repr=False)
+    channel_mode: ChannelMode
+    frame_size: FrameSize
+    sampling_frequency: SamplingFrequency
+
+    class ChannelMode(enum.IntFlag):
+        MONO = 1 << 0
+        STEREO = 1 << 1
+        DUAL_MONO = 1 << 2
+
+    class FrameSize(enum.IntFlag):
+        FS_10MS = 1 << 0
+        FS_20MS = 1 << 1
+
+    class SamplingFrequency(enum.IntFlag):
+        SF_48000 = 1 << 0
+
+        @classmethod
+        def from_int(cls, sampling_frequency: int) -> Self:
+            if sampling_frequency != 48000:
+                raise ValueError("no such sampling frequency")
+            return cls(1)
+
+    VENDOR_ID: ClassVar[int] = 0x000000E0
+    CODEC_ID: ClassVar[int] = 0x0001
+
+    def __post_init__(self) -> None:
+        self.vendor_id = self.VENDOR_ID
+        self.codec_id = self.CODEC_ID
+        self.value = bytes(
+            [
+                self.channel_mode
+                | (self.frame_size << 3)
+                | (self.sampling_frequency << 7)
+            ]
+        )
+
+    @classmethod
+    def from_bytes(cls, data: bytes) -> Self:
+        """Create a new instance from the `value` part of the data, not including
+        the vendor id and codec id"""
+        channel_mode = cls.ChannelMode(data[0] & 0x07)
+        frame_size = cls.FrameSize((data[0] >> 3) & 0x03)
+        sampling_frequency = cls.SamplingFrequency((data[0] >> 7) & 0x01)
+
+        return cls(
+            channel_mode,
+            frame_size,
+            sampling_frequency,
+        )
+
+    def __str__(self) -> str:
+        return repr(self)
+
+
 # -----------------------------------------------------------------------------
 @dataclasses.dataclass
 class SbcFrame:
     sampling_frequency: int
     block_count: int
     channel_mode: int
+    allocation_method: int
     subband_count: int
+    bitpool: int
     payload: bytes
 
     @property
@@ -553,8 +544,10 @@ class SbcFrame:
         return (
             f'SBC(sf={self.sampling_frequency},'
             f'cm={self.channel_mode},'
+            f'am={self.allocation_method},'
             f'br={self.bitrate},'
             f'sc={self.sample_count},'
+            f'bp={self.bitpool},'
             f'size={len(self.payload)})'
         )
 
@@ -583,6 +576,7 @@ class SbcParser:
                 blocks = 4 * (1 + ((header[1] >> 4) & 3))
                 channel_mode = (header[1] >> 2) & 3
                 channels = 1 if channel_mode == SBC_MONO_CHANNEL_MODE else 2
+                allocation_method = (header[1] >> 1) & 1
                 subbands = 8 if ((header[1]) & 1) else 4
                 bitpool = header[2]
 
@@ -602,7 +596,13 @@ class SbcParser:
 
                 # Emit the next frame
                 yield SbcFrame(
-                    sampling_frequency, blocks, channel_mode, subbands, payload
+                    sampling_frequency,
+                    blocks,
+                    channel_mode,
+                    allocation_method,
+                    subbands,
+                    bitpool,
+                    payload,
                 )
 
         return generate_frames()
@@ -610,21 +610,15 @@ class SbcParser:
 
 # -----------------------------------------------------------------------------
 class SbcPacketSource:
-    def __init__(
-        self, read: Callable[[int], Awaitable[bytes]], mtu: int, codec_capabilities
-    ) -> None:
+    def __init__(self, read: Callable[[int], Awaitable[bytes]], mtu: int) -> None:
         self.read = read
         self.mtu = mtu
-        self.codec_capabilities = codec_capabilities
 
     @property
     def packets(self):
         async def generate_packets():
-            # pylint: disable=import-outside-toplevel
-            from .avdtp import MediaPacket  # Import here to avoid a circular reference
-
             sequence_number = 0
-            timestamp = 0
+            sample_count = 0
             frames = []
             frames_size = 0
             max_rtp_payload = self.mtu - 12 - 1
@@ -632,29 +626,29 @@ class SbcPacketSource:
             # NOTE: this doesn't support frame fragments
             sbc_parser = SbcParser(self.read)
             async for frame in sbc_parser.frames:
-                print(frame)
-
                 if (
                     frames_size + len(frame.payload) > max_rtp_payload
-                    or len(frames) == 16
+                    or len(frames) == SBC_MAX_FRAMES_IN_RTP_PAYLOAD
                 ):
                     # Need to flush what has been accumulated so far
+                    logger.debug(f"yielding {len(frames)} frames")
 
                     # Emit a packet
-                    sbc_payload = bytes([len(frames)]) + b''.join(
+                    sbc_payload = bytes([len(frames) & 0x0F]) + b''.join(
                         [frame.payload for frame in frames]
                     )
+                    timestamp_seconds = sample_count / frame.sampling_frequency
+                    timestamp = int(1000 * timestamp_seconds)
                     packet = MediaPacket(
                         2, 0, 0, 0, sequence_number, timestamp, 0, [], 96, sbc_payload
                     )
-                    packet.timestamp_seconds = timestamp / frame.sampling_frequency
+                    packet.timestamp_seconds = timestamp_seconds
                     yield packet
 
                     # Prepare for next packets
                     sequence_number += 1
                     sequence_number &= 0xFFFF
-                    timestamp += sum((frame.sample_count for frame in frames))
-                    timestamp &= 0xFFFFFFFF
+                    sample_count += sum((frame.sample_count for frame in frames))
                     frames = [frame]
                     frames_size = len(frame.payload)
                 else:
@@ -663,3 +657,315 @@ class SbcPacketSource:
                     frames_size += len(frame.payload)
 
         return generate_packets()
+
+
+# -----------------------------------------------------------------------------
+@dataclasses.dataclass
+class AacFrame:
+    class Profile(enum.IntEnum):
+        MAIN = 0
+        LC = 1
+        SSR = 2
+        LTP = 3
+
+    profile: Profile
+    sampling_frequency: int
+    channel_configuration: int
+    payload: bytes
+
+    @property
+    def sample_count(self) -> int:
+        return 1024
+
+    @property
+    def duration(self) -> float:
+        return self.sample_count / self.sampling_frequency
+
+    def __str__(self) -> str:
+        return (
+            f'AAC(sf={self.sampling_frequency},'
+            f'ch={self.channel_configuration},'
+            f'size={len(self.payload)})'
+        )
+
+
+# -----------------------------------------------------------------------------
+ADTS_AAC_SAMPLING_FREQUENCIES = [
+    96000,
+    88200,
+    64000,
+    48000,
+    44100,
+    32000,
+    24000,
+    22050,
+    16000,
+    12000,
+    11025,
+    8000,
+    7350,
+    0,
+    0,
+    0,
+]
+
+
+# -----------------------------------------------------------------------------
+class AacParser:
+    """Parser for AAC frames in an ADTS stream"""
+
+    def __init__(self, read: Callable[[int], Awaitable[bytes]]) -> None:
+        self.read = read
+
+    @property
+    def frames(self) -> AsyncGenerator[AacFrame, None]:
+        async def generate_frames() -> AsyncGenerator[AacFrame, None]:
+            while True:
+                header = await self.read(7)
+                if not header:
+                    return
+
+                sync_word = (header[0] << 4) | (header[1] >> 4)
+                if sync_word != 0b111111111111:
+                    raise ValueError(f"invalid sync word ({sync_word:06x})")
+                layer = (header[1] >> 1) & 0b11
+                profile = AacFrame.Profile((header[2] >> 6) & 0b11)
+                sampling_frequency = ADTS_AAC_SAMPLING_FREQUENCIES[
+                    (header[2] >> 2) & 0b1111
+                ]
+                channel_configuration = ((header[2] & 0b1) << 2) | (header[3] >> 6)
+                frame_length = (
+                    ((header[3] & 0b11) << 11) | (header[4] << 3) | (header[5] >> 5)
+                )
+
+                if layer != 0:
+                    raise ValueError("layer must be 0")
+
+                payload = await self.read(frame_length - 7)
+                if payload:
+                    yield AacFrame(
+                        profile, sampling_frequency, channel_configuration, payload
+                    )
+
+        return generate_frames()
+
+
+# -----------------------------------------------------------------------------
+class AacPacketSource:
+    def __init__(self, read: Callable[[int], Awaitable[bytes]], mtu: int) -> None:
+        self.read = read
+        self.mtu = mtu
+
+    @property
+    def packets(self):
+        async def generate_packets():
+            sequence_number = 0
+            sample_count = 0
+
+            aac_parser = AacParser(self.read)
+            async for frame in aac_parser.frames:
+                logger.debug("yielding one AAC frame")
+
+                # Emit a packet
+                aac_payload = bytes(
+                    AacAudioRtpPacket.for_simple_aac(
+                        frame.sampling_frequency,
+                        frame.channel_configuration,
+                        frame.payload,
+                    )
+                )
+                timestamp_seconds = sample_count / frame.sampling_frequency
+                timestamp = int(1000 * timestamp_seconds)
+                packet = MediaPacket(
+                    2, 0, 0, 0, sequence_number, timestamp, 0, [], 96, aac_payload
+                )
+                packet.timestamp_seconds = timestamp_seconds
+                yield packet
+
+                # Prepare for next packets
+                sequence_number += 1
+                sequence_number &= 0xFFFF
+                sample_count += frame.sample_count
+
+        return generate_packets()
+
+
+# -----------------------------------------------------------------------------
+@dataclasses.dataclass
+class OpusPacket:
+    class ChannelMode(enum.IntEnum):
+        MONO = 0
+        STEREO = 1
+        DUAL_MONO = 2
+
+    channel_mode: ChannelMode
+    duration: int  # Duration in ms.
+    sampling_frequency: int
+    payload: bytes
+
+    def __str__(self) -> str:
+        return (
+            f'Opus(ch={self.channel_mode.name}, '
+            f'd={self.duration}ms, '
+            f'size={len(self.payload)})'
+        )
+
+
+# -----------------------------------------------------------------------------
+class OpusParser:
+    """
+    Parser for Opus packets in an Ogg stream
+
+    See RFC 3533
+
+    NOTE: this parser only supports bitstreams with a single logical stream.
+    """
+
+    CAPTURE_PATTERN = b'OggS'
+
+    class HeaderType(enum.IntFlag):
+        CONTINUED = 0x01
+        FIRST = 0x02
+        LAST = 0x04
+
+    def __init__(self, read: Callable[[int], Awaitable[bytes]]) -> None:
+        self.read = read
+
+    @property
+    def packets(self) -> AsyncGenerator[OpusPacket, None]:
+        async def generate_frames() -> AsyncGenerator[OpusPacket, None]:
+            packet = b''
+            packet_count = 0
+            expected_bitstream_serial_number = None
+            expected_page_sequence_number = 0
+            channel_mode = OpusPacket.ChannelMode.STEREO
+
+            while True:
+                # Parse the page header
+                header = await self.read(27)
+                if len(header) != 27:
+                    logger.debug("end of stream")
+                    break
+
+                capture_pattern = header[:4]
+                if capture_pattern != self.CAPTURE_PATTERN:
+                    print(capture_pattern.hex())
+                    raise ValueError("invalid capture pattern at start of page")
+
+                version = header[4]
+                if version != 0:
+                    raise ValueError(f"version {version} not supported")
+
+                header_type = self.HeaderType(header[5])
+                (
+                    granule_position,
+                    bitstream_serial_number,
+                    page_sequence_number,
+                    crc_checksum,
+                    page_segments,
+                ) = struct.unpack_from("<QIIIB", header, 6)
+                segment_table = await self.read(page_segments)
+
+                if header_type & self.HeaderType.FIRST:
+                    if expected_bitstream_serial_number is None:
+                        # We will only accept pages for the first encountered stream
+                        logger.debug("BOS")
+                        expected_bitstream_serial_number = bitstream_serial_number
+                        expected_page_sequence_number = page_sequence_number
+
+                if (
+                    expected_bitstream_serial_number is None
+                    or expected_bitstream_serial_number != bitstream_serial_number
+                ):
+                    logger.debug("skipping page (not the first logical bitstream)")
+                    for lacing_value in segment_table:
+                        if lacing_value:
+                            await self.read(lacing_value)
+                    continue
+
+                if expected_page_sequence_number != page_sequence_number:
+                    raise ValueError(
+                        f"expected page sequence number {expected_page_sequence_number}"
+                        f" but got {page_sequence_number}"
+                    )
+                expected_page_sequence_number = page_sequence_number + 1
+
+                # Assemble the page
+                if not header_type & self.HeaderType.CONTINUED:
+                    packet = b''
+                for lacing_value in segment_table:
+                    if lacing_value:
+                        packet += await self.read(lacing_value)
+                    if lacing_value < 255:
+                        # End of packet
+                        packet_count += 1
+
+                        if packet_count == 1:
+                            # The first packet contains the identification header
+                            logger.debug("first packet (header)")
+                            if packet[:8] != b"OpusHead":
+                                raise ValueError("first packet is not OpusHead")
+                            packet_count = (
+                                OpusPacket.ChannelMode.MONO
+                                if packet[9] == 1
+                                else OpusPacket.ChannelMode.STEREO
+                            )
+
+                        elif packet_count == 2:
+                            # The second packet contains the comment header
+                            logger.debug("second packet (tags)")
+                            if packet[:8] != b"OpusTags":
+                                logger.warning("second packet is not OpusTags")
+                        else:
+                            yield OpusPacket(channel_mode, 20, 48000, packet)
+
+                        packet = b''
+
+                if header_type & self.HeaderType.LAST:
+                    logger.debug("EOS")
+
+        return generate_frames()
+
+
+# -----------------------------------------------------------------------------
+class OpusPacketSource:
+    def __init__(self, read: Callable[[int], Awaitable[bytes]], mtu: int) -> None:
+        self.read = read
+        self.mtu = mtu
+
+    @property
+    def packets(self):
+        async def generate_packets():
+            sequence_number = 0
+            elapsed_ms = 0
+
+            opus_parser = OpusParser(self.read)
+            async for opus_packet in opus_parser.packets:
+                # We only support sending one Opus frame per RTP packet
+                # TODO: check the spec for the first byte value here
+                opus_payload = bytes([1]) + opus_packet.payload
+                elapsed_s = elapsed_ms / 1000
+                timestamp = int(elapsed_s * opus_packet.sampling_frequency)
+                rtp_packet = MediaPacket(
+                    2, 0, 0, 0, sequence_number, timestamp, 0, [], 96, opus_payload
+                )
+                rtp_packet.timestamp_seconds = elapsed_s
+                yield rtp_packet
+
+                # Prepare for next packets
+                sequence_number += 1
+                sequence_number &= 0xFFFF
+                elapsed_ms += opus_packet.duration
+
+        return generate_packets()
+
+
+# -----------------------------------------------------------------------------
+# This map should be left at the end of the file so it can refer to the classes
+# above
+# -----------------------------------------------------------------------------
+A2DP_VENDOR_MEDIA_CODEC_INFORMATION_CLASSES = {
+    OpusMediaCodecInformation.VENDOR_ID: {
+        OpusMediaCodecInformation.CODEC_ID: OpusMediaCodecInformation
+    }
+}
diff --git a/bumble/att.py b/bumble/att.py
index aeae7c9..98a82d9 100644
--- a/bumble/att.py
+++ b/bumble/att.py
@@ -29,27 +29,32 @@ import functools
 import inspect
 import struct
 from typing import (
-    Any,
     Awaitable,
     Callable,
+    Generic,
     Dict,
     List,
     Optional,
     Type,
+    TypeVar,
     Union,
     TYPE_CHECKING,
 )
 
-from pyee import EventEmitter
 
 from bumble import utils
-from bumble.core import UUID, name_or_number, ProtocolError
+from bumble.core import UUID, name_or_number, InvalidOperationError, ProtocolError
 from bumble.hci import HCI_Object, key_with_value
 from bumble.colors import color
 
+# -----------------------------------------------------------------------------
+# Typing
+# -----------------------------------------------------------------------------
 if TYPE_CHECKING:
     from bumble.device import Connection
 
+_T = TypeVar('_T')
+
 # -----------------------------------------------------------------------------
 # Constants
 # -----------------------------------------------------------------------------
@@ -57,6 +62,7 @@ if TYPE_CHECKING:
 # pylint: disable=line-too-long
 
 ATT_CID = 0x04
+ATT_PSM = 0x001F
 
 ATT_ERROR_RESPONSE              = 0x01
 ATT_EXCHANGE_MTU_REQUEST        = 0x02
@@ -216,7 +222,12 @@ UUID_2_FIELD_SPEC    = lambda x, y: UUID.parse_uuid_2(x, y)  # noqa: E731
 # Exceptions
 # -----------------------------------------------------------------------------
 class ATT_Error(ProtocolError):
-    def __init__(self, error_code, att_handle=0x0000, message=''):
+    error_code: int
+    att_handle: int
+
+    def __init__(
+        self, error_code: int, att_handle: int = 0x0000, message: str = ''
+    ) -> None:
         super().__init__(
             error_code,
             error_namespace='att',
@@ -226,7 +237,10 @@ class ATT_Error(ProtocolError):
         self.message = message
 
     def __str__(self):
-        return f'ATT_Error(error={self.error_name}, handle={self.att_handle:04X}): {self.message}'
+        return (
+            f'ATT_Error(error={self.error_name}, '
+            f'handle={self.att_handle:04X}): {self.message}'
+        )
 
 
 # -----------------------------------------------------------------------------
@@ -291,9 +305,6 @@ class ATT_PDU:
     def init_from_bytes(self, pdu, offset):
         return HCI_Object.init_from_bytes(self, pdu, offset, self.fields)
 
-    def to_bytes(self):
-        return self.pdu
-
     @property
     def is_command(self):
         return ((self.op_code >> 6) & 1) == 1
@@ -303,7 +314,7 @@ class ATT_PDU:
         return ((self.op_code >> 7) & 1) == 1
 
     def __bytes__(self):
-        return self.to_bytes()
+        return self.pdu
 
     def __str__(self):
         result = color(self.name, 'yellow')
@@ -710,7 +721,7 @@ class ATT_Prepare_Write_Response(ATT_PDU):
 
 
 # -----------------------------------------------------------------------------
-@ATT_PDU.subclass([])
+@ATT_PDU.subclass([("flags", 1)])
 class ATT_Execute_Write_Request(ATT_PDU):
     '''
     See Bluetooth spec @ Vol 3, Part F - 3.4.6.3 Execute Write Request
@@ -750,7 +761,7 @@ class ATT_Handle_Value_Confirmation(ATT_PDU):
 
 
 # -----------------------------------------------------------------------------
-class AttributeValue:
+class AttributeValue(Generic[_T]):
     '''
     Attribute value where reading and/or writing is delegated to functions
     passed as arguments to the constructor.
@@ -759,33 +770,32 @@ class AttributeValue:
     def __init__(
         self,
         read: Union[
-            Callable[[Optional[Connection]], bytes],
-            Callable[[Optional[Connection]], Awaitable[bytes]],
+            Callable[[Connection], _T],
+            Callable[[Connection], Awaitable[_T]],
             None,
         ] = None,
         write: Union[
-            Callable[[Optional[Connection], bytes], None],
-            Callable[[Optional[Connection], bytes], Awaitable[None]],
+            Callable[[Connection, _T], None],
+            Callable[[Connection, _T], Awaitable[None]],
             None,
         ] = None,
     ):
         self._read = read
         self._write = write
 
-    def read(self, connection: Optional[Connection]) -> Union[bytes, Awaitable[bytes]]:
-        return self._read(connection) if self._read else b''
-
-    def write(
-        self, connection: Optional[Connection], value: bytes
-    ) -> Union[Awaitable[None], None]:
-        if self._write:
-            return self._write(connection, value)
+    def read(self, connection: Connection) -> Union[_T, Awaitable[_T]]:
+        if self._read is None:
+            raise InvalidOperationError('AttributeValue has no read function')
+        return self._read(connection)
 
-        return None
+    def write(self, connection: Connection, value: _T) -> Union[Awaitable[None], None]:
+        if self._write is None:
+            raise InvalidOperationError('AttributeValue has no write function')
+        return self._write(connection, value)
 
 
 # -----------------------------------------------------------------------------
-class Attribute(EventEmitter):
+class Attribute(utils.EventEmitter, Generic[_T]):
     class Permissions(enum.IntFlag):
         READABLE = 0x01
         WRITEABLE = 0x02
@@ -824,15 +834,18 @@ class Attribute(EventEmitter):
     READ_REQUIRES_AUTHORIZATION = Permissions.READ_REQUIRES_AUTHORIZATION
     WRITE_REQUIRES_AUTHORIZATION = Permissions.WRITE_REQUIRES_AUTHORIZATION
 
-    value: Union[bytes, AttributeValue]
+    EVENT_READ = "read"
+    EVENT_WRITE = "write"
+
+    value: Union[AttributeValue[_T], _T, None]
 
     def __init__(
         self,
         attribute_type: Union[str, bytes, UUID],
         permissions: Union[str, Attribute.Permissions],
-        value: Union[str, bytes, AttributeValue] = b'',
+        value: Union[AttributeValue[_T], _T, None] = None,
     ) -> None:
-        EventEmitter.__init__(self)
+        utils.EventEmitter.__init__(self)
         self.handle = 0
         self.end_group_handle = 0
         if isinstance(permissions, str):
@@ -848,19 +861,15 @@ class Attribute(EventEmitter):
         else:
             self.type = attribute_type
 
-        # Convert the value to a byte array
-        if isinstance(value, str):
-            self.value = bytes(value, 'utf-8')
-        else:
-            self.value = value
+        self.value = value
 
-    def encode_value(self, value: Any) -> bytes:
-        return value
+    def encode_value(self, value: _T) -> bytes:
+        return value  # type: ignore
 
-    def decode_value(self, value_bytes: bytes) -> Any:
-        return value_bytes
+    def decode_value(self, value: bytes) -> _T:
+        return value  # type: ignore
 
-    async def read_value(self, connection: Optional[Connection]) -> bytes:
+    async def read_value(self, connection: Connection) -> bytes:
         if (
             (self.permissions & self.READ_REQUIRES_ENCRYPTION)
             and connection is not None
@@ -883,11 +892,14 @@ class Attribute(EventEmitter):
                 error_code=ATT_INSUFFICIENT_AUTHORIZATION_ERROR, att_handle=self.handle
             )
 
-        if hasattr(self.value, 'read'):
+        value: Union[_T, None]
+        if isinstance(self.value, AttributeValue):
             try:
-                value = self.value.read(connection)
-                if inspect.isawaitable(value):
-                    value = await value
+                read_value = self.value.read(connection)
+                if inspect.isawaitable(read_value):
+                    value = await read_value
+                else:
+                    value = read_value
             except ATT_Error as error:
                 raise ATT_Error(
                     error_code=error.error_code, att_handle=self.handle
@@ -895,18 +907,24 @@ class Attribute(EventEmitter):
         else:
             value = self.value
 
-        return self.encode_value(value)
+        self.emit(self.EVENT_READ, connection, b'' if value is None else value)
+
+        return b'' if value is None else self.encode_value(value)
 
-    async def write_value(self, connection: Connection, value_bytes: bytes) -> None:
+    async def write_value(self, connection: Connection, value: bytes) -> None:
         if (
-            self.permissions & self.WRITE_REQUIRES_ENCRYPTION
-        ) and not connection.encryption:
+            (self.permissions & self.WRITE_REQUIRES_ENCRYPTION)
+            and connection is not None
+            and not connection.encryption
+        ):
             raise ATT_Error(
                 error_code=ATT_INSUFFICIENT_ENCRYPTION_ERROR, att_handle=self.handle
             )
         if (
-            self.permissions & self.WRITE_REQUIRES_AUTHENTICATION
-        ) and not connection.authenticated:
+            (self.permissions & self.WRITE_REQUIRES_AUTHENTICATION)
+            and connection is not None
+            and not connection.authenticated
+        ):
             raise ATT_Error(
                 error_code=ATT_INSUFFICIENT_AUTHENTICATION_ERROR, att_handle=self.handle
             )
@@ -916,11 +934,11 @@ class Attribute(EventEmitter):
                 error_code=ATT_INSUFFICIENT_AUTHORIZATION_ERROR, att_handle=self.handle
             )
 
-        value = self.decode_value(value_bytes)
+        decoded_value = self.decode_value(value)
 
-        if hasattr(self.value, 'write'):
+        if isinstance(self.value, AttributeValue):
             try:
-                result = self.value.write(connection, value)
+                result = self.value.write(connection, decoded_value)
                 if inspect.isawaitable(result):
                     await result
             except ATT_Error as error:
@@ -928,9 +946,9 @@ class Attribute(EventEmitter):
                     error_code=error.error_code, att_handle=self.handle
                 ) from error
         else:
-            self.value = value
+            self.value = decoded_value
 
-        self.emit('write', connection, value)
+        self.emit(self.EVENT_WRITE, connection, decoded_value)
 
     def __repr__(self):
         if isinstance(self.value, bytes):
diff --git a/setup.py b/bumble/audio/__init__.py
similarity index 73%
rename from setup.py
rename to bumble/audio/__init__.py
index 1380bc9..0626eee 100644
--- a/setup.py
+++ b/bumble/audio/__init__.py
@@ -1,4 +1,4 @@
-# Copyright 2021-2022 Google LLC
+# Copyright 2025 Google LLC
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -12,6 +12,6 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from setuptools import setup
-
-setup()
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
diff --git a/bumble/audio/io.py b/bumble/audio/io.py
new file mode 100644
index 0000000..e7c7fe2
--- /dev/null
+++ b/bumble/audio/io.py
@@ -0,0 +1,553 @@
+# Copyright 2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
+from __future__ import annotations
+
+import asyncio
+import abc
+from concurrent.futures import ThreadPoolExecutor
+import dataclasses
+import enum
+import logging
+import pathlib
+from typing import (
+    AsyncGenerator,
+    BinaryIO,
+    TYPE_CHECKING,
+)
+import sys
+import wave
+
+from bumble.colors import color
+
+if TYPE_CHECKING:
+    import sounddevice  # type: ignore[import-untyped]
+
+
+# -----------------------------------------------------------------------------
+# Logging
+# -----------------------------------------------------------------------------
+logger = logging.getLogger(__name__)
+
+
+# -----------------------------------------------------------------------------
+# Classes
+# -----------------------------------------------------------------------------
+@dataclasses.dataclass
+class PcmFormat:
+    class Endianness(enum.Enum):
+        LITTLE = 0
+        BIG = 1
+
+    class SampleType(enum.Enum):
+        FLOAT32 = 0
+        INT16 = 1
+
+    endianness: Endianness
+    sample_type: SampleType
+    sample_rate: int
+    channels: int
+
+    @classmethod
+    def from_str(cls, format_str: str) -> PcmFormat:
+        endianness = cls.Endianness.LITTLE  # Others not yet supported.
+        sample_type_str, sample_rate_str, channels_str = format_str.split(',')
+        if sample_type_str == 'int16le':
+            sample_type = cls.SampleType.INT16
+        elif sample_type_str == 'float32le':
+            sample_type = cls.SampleType.FLOAT32
+        else:
+            raise ValueError(f'sample type {sample_type_str} not supported')
+        sample_rate = int(sample_rate_str)
+        channels = int(channels_str)
+
+        return cls(endianness, sample_type, sample_rate, channels)
+
+    @property
+    def bytes_per_sample(self) -> int:
+        return 2 if self.sample_type == self.SampleType.INT16 else 4
+
+
+def check_audio_output(output: str) -> bool:
+    if output == 'device' or output.startswith('device:'):
+        try:
+            import sounddevice
+        except ImportError as exc:
+            raise ValueError(
+                'audio output not available (sounddevice python module not installed)'
+            ) from exc
+        except OSError as exc:
+            raise ValueError(
+                'audio output not available '
+                '(sounddevice python module failed to load: '
+                f'{exc})'
+            ) from exc
+
+        if output == 'device':
+            # Default device
+            return True
+
+        # Specific device
+        device = output[7:]
+        if device == '?':
+            print(color('Audio Devices:', 'yellow'))
+            for device_info in [
+                device_info
+                for device_info in sounddevice.query_devices()
+                if device_info['max_output_channels'] > 0
+            ]:
+                device_index = device_info['index']
+                is_default = (
+                    color(' [default]', 'green')
+                    if sounddevice.default.device[1] == device_index
+                    else ''
+                )
+                print(
+                    f'{color(device_index, "cyan")}: {device_info["name"]}{is_default}'
+                )
+            return False
+
+        try:
+            device_info = sounddevice.query_devices(int(device))
+        except sounddevice.PortAudioError as exc:
+            raise ValueError('No such audio device') from exc
+
+        if device_info['max_output_channels'] < 1:
+            raise ValueError(
+                f'Device {device} ({device_info["name"]}) does not have an output'
+            )
+
+    return True
+
+
+async def create_audio_output(output: str) -> AudioOutput:
+    if output == 'stdout':
+        return StreamAudioOutput(sys.stdout.buffer)
+
+    if output == 'device' or output.startswith('device:'):
+        device_name = '' if output == 'device' else output[7:]
+        return SoundDeviceAudioOutput(device_name)
+
+    if output == 'ffplay':
+        return SubprocessAudioOutput(
+            command=(
+                'ffplay -probesize 32 -fflags nobuffer -analyzeduration 0 '
+                '-ar {sample_rate} '
+                '-ch_layout {channel_layout} '
+                '-f f32le pipe:0'
+            )
+        )
+
+    if output.startswith('file:'):
+        return FileAudioOutput(output[5:])
+
+    raise ValueError('unsupported audio output')
+
+
+class AudioOutput(abc.ABC):
+    """Audio output to which PCM samples can be written."""
+
+    async def open(self, pcm_format: PcmFormat) -> None:
+        """Start the output."""
+
+    @abc.abstractmethod
+    def write(self, pcm_samples: bytes) -> None:
+        """Write PCM samples. Must not block."""
+
+    async def aclose(self) -> None:
+        """Close the output."""
+
+
+class ThreadedAudioOutput(AudioOutput):
+    """Base class for AudioOutput classes that may need to call blocking functions.
+
+    The actual writing is performed in a thread, so as to ensure that calling write()
+    does not block the caller.
+    """
+
+    def __init__(self) -> None:
+        self._thread_pool = ThreadPoolExecutor(1)
+        self._pcm_samples: asyncio.Queue[bytes] = asyncio.Queue()
+        self._write_task = asyncio.create_task(self._write_loop())
+
+    async def _write_loop(self) -> None:
+        while True:
+            pcm_samples = await self._pcm_samples.get()
+            await asyncio.get_running_loop().run_in_executor(
+                self._thread_pool, self._write, pcm_samples
+            )
+
+    @abc.abstractmethod
+    def _write(self, pcm_samples: bytes) -> None:
+        """This method does the actual writing and can block."""
+
+    def write(self, pcm_samples: bytes) -> None:
+        self._pcm_samples.put_nowait(pcm_samples)
+
+    def _close(self) -> None:
+        """This method does the actual closing and can block."""
+
+    async def aclose(self) -> None:
+        await asyncio.get_running_loop().run_in_executor(self._thread_pool, self._close)
+        self._write_task.cancel()
+        self._thread_pool.shutdown()
+
+
+class SoundDeviceAudioOutput(ThreadedAudioOutput):
+    def __init__(self, device_name: str) -> None:
+        super().__init__()
+        self._device = int(device_name) if device_name else None
+        self._stream: sounddevice.RawOutputStream | None = None
+
+    async def open(self, pcm_format: PcmFormat) -> None:
+        import sounddevice  # pylint: disable=import-error
+
+        self._stream = sounddevice.RawOutputStream(
+            samplerate=pcm_format.sample_rate,
+            device=self._device,
+            channels=pcm_format.channels,
+            dtype='float32',
+        )
+        self._stream.start()
+
+    def _write(self, pcm_samples: bytes) -> None:
+        if self._stream is None:
+            return
+
+        try:
+            self._stream.write(pcm_samples)
+        except Exception as error:
+            print(f'Sound device error: {error}')
+            raise
+
+    def _close(self):
+        self._stream.stop()
+        self._stream = None
+
+
+class StreamAudioOutput(ThreadedAudioOutput):
+    """AudioOutput where PCM samples are written to a stream that may block."""
+
+    def __init__(self, stream: BinaryIO) -> None:
+        super().__init__()
+        self._stream = stream
+
+    def _write(self, pcm_samples: bytes) -> None:
+        self._stream.write(pcm_samples)
+        self._stream.flush()
+
+
+class FileAudioOutput(StreamAudioOutput):
+    """AudioOutput where PCM samples are written to a file."""
+
+    def __init__(self, filename: str) -> None:
+        self._file = open(filename, "wb")
+        super().__init__(self._file)
+
+    async def shutdown(self):
+        self._file.close()
+        return await super().shutdown()
+
+
+class SubprocessAudioOutput(AudioOutput):
+    """AudioOutput where audio samples are written to a subprocess via stdin."""
+
+    def __init__(self, command: str) -> None:
+        self._command = command
+        self._subprocess: asyncio.subprocess.Process | None
+
+    async def open(self, pcm_format: PcmFormat) -> None:
+        if pcm_format.channels == 1:
+            channel_layout = 'mono'
+        elif pcm_format.channels == 2:
+            channel_layout = 'stereo'
+        else:
+            raise ValueError(f'{pcm_format.channels} channels not supported')
+
+        command = self._command.format(
+            sample_rate=pcm_format.sample_rate, channel_layout=channel_layout
+        )
+        self._subprocess = await asyncio.create_subprocess_shell(
+            command,
+            stdin=asyncio.subprocess.PIPE,
+            stdout=asyncio.subprocess.PIPE,
+            stderr=asyncio.subprocess.PIPE,
+        )
+
+    def write(self, pcm_samples: bytes) -> None:
+        if self._subprocess is None or self._subprocess.stdin is None:
+            return
+
+        self._subprocess.stdin.write(pcm_samples)
+
+    async def aclose(self):
+        if self._subprocess:
+            self._subprocess.terminate()
+
+
+def check_audio_input(input: str) -> bool:
+    if input == 'device' or input.startswith('device:'):
+        try:
+            import sounddevice  # pylint: disable=import-error
+        except ImportError as exc:
+            raise ValueError(
+                'audio input not available (sounddevice python module not installed)'
+            ) from exc
+        except OSError as exc:
+            raise ValueError(
+                'audio input not available '
+                '(sounddevice python module failed to load: '
+                f'{exc})'
+            ) from exc
+
+        if input == 'device':
+            # Default device
+            return True
+
+        # Specific device
+        device = input[7:]
+        if device == '?':
+            print(color('Audio Devices:', 'yellow'))
+            for device_info in [
+                device_info
+                for device_info in sounddevice.query_devices()
+                if device_info['max_input_channels'] > 0
+            ]:
+                device_index = device_info["index"]
+                is_mono = device_info['max_input_channels'] == 1
+                max_channels = color(f'[{"mono" if is_mono else "stereo"}]', 'cyan')
+                is_default = (
+                    color(' [default]', 'green')
+                    if sounddevice.default.device[0] == device_index
+                    else ''
+                )
+                print(
+                    f'{color(device_index, "cyan")}: {device_info["name"]}'
+                    f' {max_channels}{is_default}'
+                )
+            return False
+
+        try:
+            device_info = sounddevice.query_devices(int(device))
+        except sounddevice.PortAudioError as exc:
+            raise ValueError('No such audio device') from exc
+
+        if device_info['max_input_channels'] < 1:
+            raise ValueError(
+                f'Device {device} ({device_info["name"]}) does not have an input'
+            )
+
+    return True
+
+
+async def create_audio_input(input: str, input_format: str) -> AudioInput:
+    pcm_format: PcmFormat | None
+    if input_format == 'auto':
+        pcm_format = None
+    else:
+        pcm_format = PcmFormat.from_str(input_format)
+
+    if input == 'stdin':
+        if not pcm_format:
+            raise ValueError('input format details required for stdin')
+        return StreamAudioInput(sys.stdin.buffer, pcm_format)
+
+    if input == 'device' or input.startswith('device:'):
+        if not pcm_format:
+            raise ValueError('input format details required for device')
+        device_name = '' if input == 'device' else input[7:]
+        return SoundDeviceAudioInput(device_name, pcm_format)
+
+    # If there's no file: prefix, check if we can assume it is a file.
+    if pathlib.Path(input).is_file():
+        input = 'file:' + input
+
+    if input.startswith('file:'):
+        filename = input[5:]
+        if filename.endswith('.wav'):
+            if input_format != 'auto':
+                raise ValueError(".wav file only supported with 'auto' format")
+            return WaveAudioInput(filename)
+
+        if pcm_format is None:
+            raise ValueError('input format details required for raw PCM files')
+        return FileAudioInput(filename, pcm_format)
+
+    raise ValueError('input not supported')
+
+
+class AudioInput(abc.ABC):
+    """Audio input that produces PCM samples."""
+
+    @abc.abstractmethod
+    async def open(self) -> PcmFormat:
+        """Open the input."""
+
+    @abc.abstractmethod
+    def frames(self, frame_size: int) -> AsyncGenerator[bytes]:
+        """Generate one frame of PCM samples. Must not block."""
+
+    async def aclose(self) -> None:
+        """Close the input."""
+
+
+class ThreadedAudioInput(AudioInput):
+    """Base class for AudioInput implementation where reading samples may block."""
+
+    def __init__(self) -> None:
+        self._thread_pool = ThreadPoolExecutor(1)
+        self._pcm_samples: asyncio.Queue[bytes] = asyncio.Queue()
+
+    @abc.abstractmethod
+    def _read(self, frame_size: int) -> bytes:
+        pass
+
+    @abc.abstractmethod
+    def _open(self) -> PcmFormat:
+        pass
+
+    def _close(self) -> None:
+        pass
+
+    async def open(self) -> PcmFormat:
+        return await asyncio.get_running_loop().run_in_executor(
+            self._thread_pool, self._open
+        )
+
+    async def frames(self, frame_size: int) -> AsyncGenerator[bytes]:
+        while pcm_sample := await asyncio.get_running_loop().run_in_executor(
+            self._thread_pool, self._read, frame_size
+        ):
+            yield pcm_sample
+
+    async def aclose(self) -> None:
+        await asyncio.get_running_loop().run_in_executor(self._thread_pool, self._close)
+        self._thread_pool.shutdown()
+
+
+class WaveAudioInput(ThreadedAudioInput):
+    """Audio input that reads PCM samples from a .wav file."""
+
+    def __init__(self, filename: str) -> None:
+        super().__init__()
+        self._filename = filename
+        self._wav: wave.Wave_read | None = None
+        self._bytes_read = 0
+
+    def _open(self) -> PcmFormat:
+        self._wav = wave.open(self._filename, 'rb')
+        if self._wav.getsampwidth() != 2:
+            raise ValueError('sample width not supported')
+        return PcmFormat(
+            PcmFormat.Endianness.LITTLE,
+            PcmFormat.SampleType.INT16,
+            self._wav.getframerate(),
+            self._wav.getnchannels(),
+        )
+
+    def _read(self, frame_size: int) -> bytes:
+        if not self._wav:
+            return b''
+
+        pcm_samples = self._wav.readframes(frame_size)
+        if not pcm_samples and self._bytes_read:
+            # Loop around.
+            self._wav.rewind()
+            self._bytes_read = 0
+            pcm_samples = self._wav.readframes(frame_size)
+
+        self._bytes_read += len(pcm_samples)
+        return pcm_samples
+
+    def _close(self) -> None:
+        if self._wav:
+            self._wav.close()
+
+
+class StreamAudioInput(ThreadedAudioInput):
+    """AudioInput where samples are read from a raw PCM stream that may block."""
+
+    def __init__(self, stream: BinaryIO, pcm_format: PcmFormat) -> None:
+        super().__init__()
+        self._stream = stream
+        self._pcm_format = pcm_format
+
+    def _open(self) -> PcmFormat:
+        return self._pcm_format
+
+    def _read(self, frame_size: int) -> bytes:
+        return self._stream.read(
+            frame_size * self._pcm_format.channels * self._pcm_format.bytes_per_sample
+        )
+
+
+class FileAudioInput(StreamAudioInput):
+    """AudioInput where PCM samples are read from a raw PCM file."""
+
+    def __init__(self, filename: str, pcm_format: PcmFormat) -> None:
+        self._stream = open(filename, "rb")
+        super().__init__(self._stream, pcm_format)
+
+    def _close(self) -> None:
+        self._stream.close()
+
+
+class SoundDeviceAudioInput(ThreadedAudioInput):
+    def __init__(self, device_name: str, pcm_format: PcmFormat) -> None:
+        super().__init__()
+        self._device = int(device_name) if device_name else None
+        self._pcm_format = pcm_format
+        self._stream: sounddevice.RawInputStream | None = None
+
+    def _open(self) -> PcmFormat:
+        import sounddevice  # pylint: disable=import-error
+
+        self._stream = sounddevice.RawInputStream(
+            samplerate=self._pcm_format.sample_rate,
+            device=self._device,
+            channels=self._pcm_format.channels,
+            dtype='int16',
+        )
+        self._stream.start()
+
+        return PcmFormat(
+            PcmFormat.Endianness.LITTLE,
+            PcmFormat.SampleType.INT16,
+            self._pcm_format.sample_rate,
+            2,
+        )
+
+    def _read(self, frame_size: int) -> bytes:
+        if not self._stream:
+            return b''
+        pcm_buffer, overflowed = self._stream.read(frame_size)
+        if overflowed:
+            logger.warning("input overflow")
+
+        # Convert the buffer to stereo if needed
+        if self._pcm_format.channels == 1:
+            stereo_buffer = bytearray()
+            for i in range(frame_size):
+                sample = pcm_buffer[i * 2 : i * 2 + 2]
+                stereo_buffer += sample + sample
+            return stereo_buffer
+
+        return bytes(pcm_buffer)
+
+    def _close(self):
+        self._stream.stop()
+        self._stream = None
diff --git a/bumble/avc.py b/bumble/avc.py
index 8e6b968..f250221 100644
--- a/bumble/avc.py
+++ b/bumble/avc.py
@@ -21,7 +21,7 @@ import struct
 from typing import Dict, Type, Union, Tuple
 
 from bumble import core
-from bumble.utils import OpenIntEnum
+from bumble import utils
 
 
 # -----------------------------------------------------------------------------
@@ -43,7 +43,7 @@ class Frame:
         EXTENDED = 0x1E
         UNIT = 0x1F
 
-    class OperationCode(OpenIntEnum):
+    class OperationCode(utils.OpenIntEnum):
         # 0x00 - 0x0F: Unit and subunit commands
         VENDOR_DEPENDENT = 0x00
         RESERVE = 0x01
@@ -119,7 +119,7 @@ class Frame:
             # Not supported
             raise NotImplementedError("extended subunit types not supported")
 
-        if subunit_id < 5:
+        if subunit_id < 5 or subunit_id == 7:
             opcode_offset = 2
         elif subunit_id == 5:
             # Extended to the next byte
@@ -132,9 +132,10 @@ class Frame:
             else:
                 subunit_id = 5 + extension
                 opcode_offset = 3
-
         elif subunit_id == 6:
             raise core.InvalidPacketError("reserved subunit ID")
+        else:
+            raise core.InvalidPacketError("invalid subunit ID")
 
         opcode = Frame.OperationCode(data[opcode_offset])
         operands = data[opcode_offset + 1 :]
@@ -203,7 +204,7 @@ class Frame:
 
 # -----------------------------------------------------------------------------
 class CommandFrame(Frame):
-    class CommandType(OpenIntEnum):
+    class CommandType(utils.OpenIntEnum):
         # AV/C Digital Interface Command Set General Specification Version 4.1
         # Table 7.1
         CONTROL = 0x00
@@ -239,7 +240,7 @@ class CommandFrame(Frame):
 
 # -----------------------------------------------------------------------------
 class ResponseFrame(Frame):
-    class ResponseCode(OpenIntEnum):
+    class ResponseCode(utils.OpenIntEnum):
         # AV/C Digital Interface Command Set General Specification Version 4.1
         # Table 7.2
         NOT_IMPLEMENTED = 0x08
@@ -367,7 +368,7 @@ class PassThroughFrame:
         PRESSED = 0
         RELEASED = 1
 
-    class OperationId(OpenIntEnum):
+    class OperationId(utils.OpenIntEnum):
         SELECT = 0x00
         UP = 0x01
         DOWN = 0x01
diff --git a/bumble/avctp.py b/bumble/avctp.py
index 6d70256..c59d258 100644
--- a/bumble/avctp.py
+++ b/bumble/avctp.py
@@ -166,8 +166,8 @@ class Protocol:
 
         # Register to receive PDUs from the channel
         l2cap_channel.sink = self.on_pdu
-        l2cap_channel.on("open", self.on_l2cap_channel_open)
-        l2cap_channel.on("close", self.on_l2cap_channel_close)
+        l2cap_channel.on(l2cap_channel.EVENT_OPEN, self.on_l2cap_channel_open)
+        l2cap_channel.on(l2cap_channel.EVENT_CLOSE, self.on_l2cap_channel_close)
 
     def on_l2cap_channel_open(self):
         logger.debug(color("<<< AVCTP channel open", "magenta"))
diff --git a/bumble/avdtp.py b/bumble/avdtp.py
index fd79dc3..2593366 100644
--- a/bumble/avdtp.py
+++ b/bumble/avdtp.py
@@ -17,12 +17,10 @@
 # -----------------------------------------------------------------------------
 from __future__ import annotations
 import asyncio
-import struct
 import time
 import logging
 import enum
 import warnings
-from pyee import EventEmitter
 from typing import (
     Any,
     Awaitable,
@@ -39,24 +37,28 @@ from typing import (
     cast,
 )
 
-from .core import (
+
+from bumble.core import (
     BT_ADVANCED_AUDIO_DISTRIBUTION_SERVICE,
     InvalidStateError,
     ProtocolError,
     InvalidArgumentError,
     name_or_number,
 )
-from .a2dp import (
+from bumble.a2dp import (
     A2DP_CODEC_TYPE_NAMES,
     A2DP_MPEG_2_4_AAC_CODEC_TYPE,
     A2DP_NON_A2DP_CODEC_TYPE,
     A2DP_SBC_CODEC_TYPE,
+    A2DP_VENDOR_MEDIA_CODEC_INFORMATION_CLASSES,
     AacMediaCodecInformation,
     SbcMediaCodecInformation,
     VendorSpecificMediaCodecInformation,
 )
-from . import sdp, device, l2cap
-from .colors import color
+from bumble.rtp import MediaPacket
+from bumble import sdp, device, l2cap, utils
+from bumble.colors import color
+
 
 # -----------------------------------------------------------------------------
 # Logging
@@ -278,95 +280,6 @@ class RealtimeClock:
         await asyncio.sleep(duration)
 
 
-# -----------------------------------------------------------------------------
-class MediaPacket:
-    @staticmethod
-    def from_bytes(data: bytes) -> MediaPacket:
-        version = (data[0] >> 6) & 0x03
-        padding = (data[0] >> 5) & 0x01
-        extension = (data[0] >> 4) & 0x01
-        csrc_count = data[0] & 0x0F
-        marker = (data[1] >> 7) & 0x01
-        payload_type = data[1] & 0x7F
-        sequence_number = struct.unpack_from('>H', data, 2)[0]
-        timestamp = struct.unpack_from('>I', data, 4)[0]
-        ssrc = struct.unpack_from('>I', data, 8)[0]
-        csrc_list = [
-            struct.unpack_from('>I', data, 12 + i)[0] for i in range(csrc_count)
-        ]
-        payload = data[12 + csrc_count * 4 :]
-
-        return MediaPacket(
-            version,
-            padding,
-            extension,
-            marker,
-            sequence_number,
-            timestamp,
-            ssrc,
-            csrc_list,
-            payload_type,
-            payload,
-        )
-
-    def __init__(
-        self,
-        version: int,
-        padding: int,
-        extension: int,
-        marker: int,
-        sequence_number: int,
-        timestamp: int,
-        ssrc: int,
-        csrc_list: List[int],
-        payload_type: int,
-        payload: bytes,
-    ) -> None:
-        self.version = version
-        self.padding = padding
-        self.extension = extension
-        self.marker = marker
-        self.sequence_number = sequence_number & 0xFFFF
-        self.timestamp = timestamp & 0xFFFFFFFF
-        self.ssrc = ssrc
-        self.csrc_list = csrc_list
-        self.payload_type = payload_type
-        self.payload = payload
-
-    def __bytes__(self) -> bytes:
-        header = bytes(
-            [
-                self.version << 6
-                | self.padding << 5
-                | self.extension << 4
-                | len(self.csrc_list),
-                self.marker << 7 | self.payload_type,
-            ]
-        ) + struct.pack(
-            '>HII',
-            self.sequence_number,
-            self.timestamp,
-            self.ssrc,
-        )
-        for csrc in self.csrc_list:
-            header += struct.pack('>I', csrc)
-        return header + self.payload
-
-    def __str__(self) -> str:
-        return (
-            f'RTP(v={self.version},'
-            f'p={self.padding},'
-            f'x={self.extension},'
-            f'm={self.marker},'
-            f'pt={self.payload_type},'
-            f'sn={self.sequence_number},'
-            f'ts={self.timestamp},'
-            f'ssrc={self.ssrc},'
-            f'csrcs={self.csrc_list},'
-            f'payload_size={len(self.payload)})'
-        )
-
-
 # -----------------------------------------------------------------------------
 class MediaPacketPump:
     pump_task: Optional[asyncio.Task]
@@ -377,6 +290,7 @@ class MediaPacketPump:
         self.packets = packets
         self.clock = clock
         self.pump_task = None
+        self.completed = asyncio.Event()
 
     async def start(self, rtp_channel: l2cap.ClassicChannel) -> None:
         async def pump_packets():
@@ -406,6 +320,8 @@ class MediaPacketPump:
                     )
             except asyncio.exceptions.CancelledError:
                 logger.debug('pump canceled')
+            finally:
+                self.completed.set()
 
         # Pump packets
         self.pump_task = asyncio.create_task(pump_packets())
@@ -417,6 +333,9 @@ class MediaPacketPump:
             await self.pump_task
             self.pump_task = None
 
+    async def wait_for_completion(self) -> None:
+        await self.completed.wait()
+
 
 # -----------------------------------------------------------------------------
 class MessageAssembler:
@@ -615,11 +534,25 @@ class MediaCodecCapabilities(ServiceCapabilities):
                 self.media_codec_information
             )
         elif self.media_codec_type == A2DP_NON_A2DP_CODEC_TYPE:
-            self.media_codec_information = (
+            vendor_media_codec_information = (
                 VendorSpecificMediaCodecInformation.from_bytes(
                     self.media_codec_information
                 )
             )
+            if (
+                vendor_class_map := A2DP_VENDOR_MEDIA_CODEC_INFORMATION_CLASSES.get(
+                    vendor_media_codec_information.vendor_id
+                )
+            ) and (
+                media_codec_information_class := vendor_class_map.get(
+                    vendor_media_codec_information.codec_id
+                )
+            ):
+                self.media_codec_information = media_codec_information_class.from_bytes(
+                    vendor_media_codec_information.value
+                )
+            else:
+                self.media_codec_information = vendor_media_codec_information
 
     def __init__(
         self,
@@ -963,7 +896,7 @@ class Set_Configuration_Reject(Message):
         self.service_category = self.payload[0]
         self.error_code = self.payload[1]
 
-    def __init__(self, service_category, error_code):
+    def __init__(self, error_code: int, service_category: int = 0) -> None:
         super().__init__(payload=bytes([service_category, error_code]))
         self.service_category = service_category
         self.error_code = error_code
@@ -1199,6 +1132,14 @@ class Security_Control_Command(Message):
     See Bluetooth AVDTP spec - 8.17.1 Security Control Command
     '''
 
+    def init_from_payload(self):
+        # pylint: disable=attribute-defined-outside-init
+        self.acp_seid = self.payload[0] >> 2
+        self.data = self.payload[1:]
+
+    def __str__(self) -> str:
+        return self.to_string([f'ACP_SEID: {self.acp_seid}', f'data:    {self.data}'])
+
 
 # -----------------------------------------------------------------------------
 @Message.subclass
@@ -1260,13 +1201,16 @@ class DelayReport_Reject(Simple_Reject):
 
 
 # -----------------------------------------------------------------------------
-class Protocol(EventEmitter):
+class Protocol(utils.EventEmitter):
     local_endpoints: List[LocalStreamEndPoint]
     remote_endpoints: Dict[int, DiscoveredStreamEndPoint]
     streams: Dict[int, Stream]
     transaction_results: List[Optional[asyncio.Future[Message]]]
     channel_connector: Callable[[], Awaitable[l2cap.ClassicChannel]]
 
+    EVENT_OPEN = "open"
+    EVENT_CLOSE = "close"
+
     class PacketType(enum.IntEnum):
         SINGLE_PACKET = 0
         START_PACKET = 1
@@ -1306,8 +1250,8 @@ class Protocol(EventEmitter):
 
         # Register to receive PDUs from the channel
         l2cap_channel.sink = self.on_pdu
-        l2cap_channel.on('open', self.on_l2cap_channel_open)
-        l2cap_channel.on('close', self.on_l2cap_channel_close)
+        l2cap_channel.on(l2cap_channel.EVENT_OPEN, self.on_l2cap_channel_open)
+        l2cap_channel.on(l2cap_channel.EVENT_CLOSE, self.on_l2cap_channel_close)
 
     def get_local_endpoint_by_seid(self, seid: int) -> Optional[LocalStreamEndPoint]:
         if 0 < seid <= len(self.local_endpoints):
@@ -1316,10 +1260,20 @@ class Protocol(EventEmitter):
         return None
 
     def add_source(
-        self, codec_capabilities: MediaCodecCapabilities, packet_pump: MediaPacketPump
+        self,
+        codec_capabilities: MediaCodecCapabilities,
+        packet_pump: MediaPacketPump,
+        delay_reporting: bool = False,
     ) -> LocalSource:
         seid = len(self.local_endpoints) + 1
-        source = LocalSource(self, seid, codec_capabilities, packet_pump)
+        service_capabilities = (
+            [ServiceCapabilities(AVDTP_DELAY_REPORTING_SERVICE_CATEGORY)]
+            if delay_reporting
+            else []
+        )
+        source = LocalSource(
+            self, seid, codec_capabilities, service_capabilities, packet_pump
+        )
         self.local_endpoints.append(source)
 
         return source
@@ -1372,7 +1326,7 @@ class Protocol(EventEmitter):
         return self.remote_endpoints.values()
 
     def find_remote_sink_by_codec(
-        self, media_type: int, codec_type: int
+        self, media_type: int, codec_type: int, vendor_id: int = 0, codec_id: int = 0
     ) -> Optional[DiscoveredStreamEndPoint]:
         for endpoint in self.remote_endpoints.values():
             if (
@@ -1397,7 +1351,19 @@ class Protocol(EventEmitter):
                             codec_capabilities.media_type == AVDTP_AUDIO_MEDIA_TYPE
                             and codec_capabilities.media_codec_type == codec_type
                         ):
-                            has_codec = True
+                            if isinstance(
+                                codec_capabilities.media_codec_information,
+                                VendorSpecificMediaCodecInformation,
+                            ):
+                                if (
+                                    codec_capabilities.media_codec_information.vendor_id
+                                    == vendor_id
+                                    and codec_capabilities.media_codec_information.codec_id
+                                    == codec_id
+                                ):
+                                    has_codec = True
+                            else:
+                                has_codec = True
                 if has_media_transport and has_codec:
                     return endpoint
 
@@ -1455,20 +1421,20 @@ class Protocol(EventEmitter):
             self.transaction_results[transaction_label] = None
             self.transaction_semaphore.release()
 
-    def on_l2cap_connection(self, channel):
+    def on_l2cap_connection(self, channel: l2cap.ClassicChannel) -> None:
         # Forward the channel to the endpoint that's expecting it
         if self.channel_acceptor is None:
             logger.warning(color('!!! l2cap connection with no acceptor', 'red'))
             return
         self.channel_acceptor.on_l2cap_connection(channel)
 
-    def on_l2cap_channel_open(self):
+    def on_l2cap_channel_open(self) -> None:
         logger.debug(color('<<< L2CAP channel open', 'magenta'))
-        self.emit('open')
+        self.emit(self.EVENT_OPEN)
 
-    def on_l2cap_channel_close(self):
+    def on_l2cap_channel_close(self) -> None:
         logger.debug(color('<<< L2CAP channel close', 'magenta'))
-        self.emit('close')
+        self.emit(self.EVENT_CLOSE)
 
     def send_message(self, transaction_label: int, message: Message) -> None:
         logger.debug(
@@ -1586,28 +1552,34 @@ class Protocol(EventEmitter):
     async def abort(self, seid: int) -> Abort_Response:
         return await self.send_command(Abort_Command(seid))
 
-    def on_discover_command(self, _command):
+    def on_discover_command(self, command: Discover_Command) -> Optional[Message]:
         endpoint_infos = [
             EndPointInfo(endpoint.seid, 0, endpoint.media_type, endpoint.tsep)
             for endpoint in self.local_endpoints
         ]
         return Discover_Response(endpoint_infos)
 
-    def on_get_capabilities_command(self, command):
+    def on_get_capabilities_command(
+        self, command: Get_Capabilities_Command
+    ) -> Optional[Message]:
         endpoint = self.get_local_endpoint_by_seid(command.acp_seid)
         if endpoint is None:
             return Get_Capabilities_Reject(AVDTP_BAD_ACP_SEID_ERROR)
 
         return Get_Capabilities_Response(endpoint.capabilities)
 
-    def on_get_all_capabilities_command(self, command):
+    def on_get_all_capabilities_command(
+        self, command: Get_All_Capabilities_Command
+    ) -> Optional[Message]:
         endpoint = self.get_local_endpoint_by_seid(command.acp_seid)
         if endpoint is None:
             return Get_All_Capabilities_Reject(AVDTP_BAD_ACP_SEID_ERROR)
 
         return Get_All_Capabilities_Response(endpoint.capabilities)
 
-    def on_set_configuration_command(self, command):
+    def on_set_configuration_command(
+        self, command: Set_Configuration_Command
+    ) -> Optional[Message]:
         endpoint = self.get_local_endpoint_by_seid(command.acp_seid)
         if endpoint is None:
             return Set_Configuration_Reject(AVDTP_BAD_ACP_SEID_ERROR)
@@ -1623,7 +1595,9 @@ class Protocol(EventEmitter):
         result = stream.on_set_configuration_command(command.capabilities)
         return result or Set_Configuration_Response()
 
-    def on_get_configuration_command(self, command):
+    def on_get_configuration_command(
+        self, command: Get_Configuration_Command
+    ) -> Optional[Message]:
         endpoint = self.get_local_endpoint_by_seid(command.acp_seid)
         if endpoint is None:
             return Get_Configuration_Reject(AVDTP_BAD_ACP_SEID_ERROR)
@@ -1632,7 +1606,7 @@ class Protocol(EventEmitter):
 
         return endpoint.stream.on_get_configuration_command()
 
-    def on_reconfigure_command(self, command):
+    def on_reconfigure_command(self, command: Reconfigure_Command) -> Optional[Message]:
         endpoint = self.get_local_endpoint_by_seid(command.acp_seid)
         if endpoint is None:
             return Reconfigure_Reject(0, AVDTP_BAD_ACP_SEID_ERROR)
@@ -1642,7 +1616,7 @@ class Protocol(EventEmitter):
         result = endpoint.stream.on_reconfigure_command(command.capabilities)
         return result or Reconfigure_Response()
 
-    def on_open_command(self, command):
+    def on_open_command(self, command: Open_Command) -> Optional[Message]:
         endpoint = self.get_local_endpoint_by_seid(command.acp_seid)
         if endpoint is None:
             return Open_Reject(AVDTP_BAD_ACP_SEID_ERROR)
@@ -1652,25 +1626,26 @@ class Protocol(EventEmitter):
         result = endpoint.stream.on_open_command()
         return result or Open_Response()
 
-    def on_start_command(self, command):
+    def on_start_command(self, command: Start_Command) -> Optional[Message]:
         for seid in command.acp_seids:
             endpoint = self.get_local_endpoint_by_seid(seid)
             if endpoint is None:
                 return Start_Reject(seid, AVDTP_BAD_ACP_SEID_ERROR)
             if endpoint.stream is None:
-                return Start_Reject(AVDTP_BAD_STATE_ERROR)
+                return Start_Reject(seid, AVDTP_BAD_STATE_ERROR)
 
         # Start all streams
         # TODO: deal with partial failures
         for seid in command.acp_seids:
             endpoint = self.get_local_endpoint_by_seid(seid)
-            result = endpoint.stream.on_start_command()
-            if result is not None:
+            if not endpoint or not endpoint.stream:
+                raise InvalidStateError("Should already be checked!")
+            if (result := endpoint.stream.on_start_command()) is not None:
                 return result
 
         return Start_Response()
 
-    def on_suspend_command(self, command):
+    def on_suspend_command(self, command: Suspend_Command) -> Optional[Message]:
         for seid in command.acp_seids:
             endpoint = self.get_local_endpoint_by_seid(seid)
             if endpoint is None:
@@ -1682,13 +1657,14 @@ class Protocol(EventEmitter):
         # TODO: deal with partial failures
         for seid in command.acp_seids:
             endpoint = self.get_local_endpoint_by_seid(seid)
-            result = endpoint.stream.on_suspend_command()
-            if result is not None:
+            if not endpoint or not endpoint.stream:
+                raise InvalidStateError("Should already be checked!")
+            if (result := endpoint.stream.on_suspend_command()) is not None:
                 return result
 
         return Suspend_Response()
 
-    def on_close_command(self, command):
+    def on_close_command(self, command: Close_Command) -> Optional[Message]:
         endpoint = self.get_local_endpoint_by_seid(command.acp_seid)
         if endpoint is None:
             return Close_Reject(AVDTP_BAD_ACP_SEID_ERROR)
@@ -1698,7 +1674,7 @@ class Protocol(EventEmitter):
         result = endpoint.stream.on_close_command()
         return result or Close_Response()
 
-    def on_abort_command(self, command):
+    def on_abort_command(self, command: Abort_Command) -> Optional[Message]:
         endpoint = self.get_local_endpoint_by_seid(command.acp_seid)
         if endpoint is None or endpoint.stream is None:
             return Abort_Response()
@@ -1706,15 +1682,17 @@ class Protocol(EventEmitter):
         endpoint.stream.on_abort_command()
         return Abort_Response()
 
-    def on_security_control_command(self, command):
+    def on_security_control_command(
+        self, command: Security_Control_Command
+    ) -> Optional[Message]:
         endpoint = self.get_local_endpoint_by_seid(command.acp_seid)
         if endpoint is None:
             return Security_Control_Reject(AVDTP_BAD_ACP_SEID_ERROR)
 
-        result = endpoint.on_security_control_command(command.payload)
+        result = endpoint.on_security_control_command(command.data)
         return result or Security_Control_Response()
 
-    def on_delayreport_command(self, command):
+    def on_delayreport_command(self, command: DelayReport_Command) -> Optional[Message]:
         endpoint = self.get_local_endpoint_by_seid(command.acp_seid)
         if endpoint is None:
             return DelayReport_Reject(AVDTP_BAD_ACP_SEID_ERROR)
@@ -1724,9 +1702,11 @@ class Protocol(EventEmitter):
 
 
 # -----------------------------------------------------------------------------
-class Listener(EventEmitter):
+class Listener(utils.EventEmitter):
     servers: Dict[int, Protocol]
 
+    EVENT_CONNECTION = "connection"
+
     @staticmethod
     def create_registrar(device: device.Device):
         warnings.warn("Please use Listener.for_device()", DeprecationWarning)
@@ -1761,7 +1741,7 @@ class Listener(EventEmitter):
         l2cap_server = device.create_l2cap_server(
             spec=l2cap.ClassicChannelSpec(psm=AVDTP_PSM)
         )
-        l2cap_server.on('connection', listener.on_l2cap_connection)
+        l2cap_server.on(l2cap_server.EVENT_CONNECTION, listener.on_l2cap_connection)
         return listener
 
     def on_l2cap_connection(self, channel: l2cap.ClassicChannel) -> None:
@@ -1777,14 +1757,14 @@ class Listener(EventEmitter):
                 logger.debug('setting up new Protocol for the connection')
                 server = Protocol(channel, self.version)
                 self.set_server(channel.connection, server)
-                self.emit('connection', server)
+                self.emit(self.EVENT_CONNECTION, server)
 
             def on_channel_close():
                 logger.debug('removing Protocol for the connection')
                 self.remove_server(channel.connection)
 
-            channel.on('open', on_channel_open)
-            channel.on('close', on_channel_close)
+            channel.on(channel.EVENT_OPEN, on_channel_open)
+            channel.on(channel.EVENT_CLOSE, on_channel_close)
 
 
 # -----------------------------------------------------------------------------
@@ -1833,6 +1813,7 @@ class Stream:
         )
 
     async def start(self) -> None:
+        """[Source] Start streaming."""
         # Auto-open if needed
         if self.state == AVDTP_CONFIGURED_STATE:
             await self.open()
@@ -1849,6 +1830,7 @@ class Stream:
         self.change_state(AVDTP_STREAMING_STATE)
 
     async def stop(self) -> None:
+        """[Source] Stop streaming and transit to OPEN state."""
         if self.state != AVDTP_STREAMING_STATE:
             raise InvalidStateError('current state is not STREAMING')
 
@@ -1861,6 +1843,7 @@ class Stream:
         self.change_state(AVDTP_OPEN_STATE)
 
     async def close(self) -> None:
+        """[Source] Close channel and transit to IDLE state."""
         if self.state not in (AVDTP_OPEN_STATE, AVDTP_STREAMING_STATE):
             raise InvalidStateError('current state is not OPEN or STREAMING')
 
@@ -1892,7 +1875,7 @@ class Stream:
         self.change_state(AVDTP_CONFIGURED_STATE)
         return None
 
-    def on_get_configuration_command(self, configuration):
+    def on_get_configuration_command(self):
         if self.state not in (
             AVDTP_CONFIGURED_STATE,
             AVDTP_OPEN_STATE,
@@ -1900,7 +1883,7 @@ class Stream:
         ):
             return Get_Configuration_Reject(AVDTP_BAD_STATE_ERROR)
 
-        return self.local_endpoint.on_get_configuration_command(configuration)
+        return self.local_endpoint.on_get_configuration_command()
 
     def on_reconfigure_command(self, configuration):
         if self.state != AVDTP_OPEN_STATE:
@@ -1980,20 +1963,20 @@ class Stream:
             # Wait for the RTP channel to be closed
             self.change_state(AVDTP_ABORTING_STATE)
 
-    def on_l2cap_connection(self, channel):
+    def on_l2cap_connection(self, channel: l2cap.ClassicChannel) -> None:
         logger.debug(color('<<< stream channel connected', 'magenta'))
         self.rtp_channel = channel
-        channel.on('open', self.on_l2cap_channel_open)
-        channel.on('close', self.on_l2cap_channel_close)
+        channel.on(channel.EVENT_OPEN, self.on_l2cap_channel_open)
+        channel.on(channel.EVENT_CLOSE, self.on_l2cap_channel_close)
 
         # We don't need more channels
         self.protocol.channel_acceptor = None
 
-    def on_l2cap_channel_open(self):
+    def on_l2cap_channel_open(self) -> None:
         logger.debug(color('<<< stream channel open', 'magenta'))
         self.local_endpoint.on_rtp_channel_open()
 
-    def on_l2cap_channel_close(self):
+    def on_l2cap_channel_close(self) -> None:
         logger.debug(color('<<< stream channel closed', 'magenta'))
         self.local_endpoint.on_rtp_channel_close()
         self.local_endpoint.in_use = 0
@@ -2107,9 +2090,22 @@ class DiscoveredStreamEndPoint(StreamEndPoint, StreamEndPointProxy):
 
 
 # -----------------------------------------------------------------------------
-class LocalStreamEndPoint(StreamEndPoint, EventEmitter):
+class LocalStreamEndPoint(StreamEndPoint, utils.EventEmitter):
     stream: Optional[Stream]
 
+    EVENT_CONFIGURATION = "configuration"
+    EVENT_OPEN = "open"
+    EVENT_START = "start"
+    EVENT_STOP = "stop"
+    EVENT_RTP_PACKET = "rtp_packet"
+    EVENT_SUSPEND = "suspend"
+    EVENT_CLOSE = "close"
+    EVENT_ABORT = "abort"
+    EVENT_DELAY_REPORT = "delay_report"
+    EVENT_SECURITY_CONTROL = "security_control"
+    EVENT_RTP_CHANNEL_OPEN = "rtp_channel_open"
+    EVENT_RTP_CHANNEL_CLOSE = "rtp_channel_close"
+
     def __init__(
         self,
         protocol: Protocol,
@@ -2120,57 +2116,70 @@ class LocalStreamEndPoint(StreamEndPoint, EventEmitter):
         configuration: Optional[Iterable[ServiceCapabilities]] = None,
     ):
         StreamEndPoint.__init__(self, seid, media_type, tsep, 0, capabilities)
-        EventEmitter.__init__(self)
+        utils.EventEmitter.__init__(self)
         self.protocol = protocol
         self.configuration = configuration if configuration is not None else []
         self.stream = None
 
-    async def start(self):
-        pass
+    async def start(self) -> None:
+        """[Source Only] Handles when receiving start command."""
 
-    async def stop(self):
-        pass
+    async def stop(self) -> None:
+        """[Source Only] Handles when receiving stop command."""
 
-    async def close(self):
-        pass
+    async def close(self) -> None:
+        """[Source Only] Handles when receiving close command."""
 
-    def on_reconfigure_command(self, command):
-        pass
+    def on_reconfigure_command(self, command) -> Optional[Message]:
+        return None
 
-    def on_set_configuration_command(self, configuration):
+    def on_set_configuration_command(self, configuration) -> Optional[Message]:
         logger.debug(
             '<<< received configuration: '
             f'{",".join([str(capability) for capability in configuration])}'
         )
         self.configuration = configuration
-        self.emit('configuration')
+        self.emit(self.EVENT_CONFIGURATION)
+        return None
 
-    def on_get_configuration_command(self):
+    def on_get_configuration_command(self) -> Optional[Message]:
         return Get_Configuration_Response(self.configuration)
 
-    def on_open_command(self):
-        self.emit('open')
+    def on_open_command(self) -> Optional[Message]:
+        self.emit(self.EVENT_OPEN)
+        return None
 
-    def on_start_command(self):
-        self.emit('start')
+    def on_start_command(self) -> Optional[Message]:
+        self.emit(self.EVENT_START)
+        return None
 
-    def on_suspend_command(self):
-        self.emit('suspend')
+    def on_suspend_command(self) -> Optional[Message]:
+        self.emit(self.EVENT_SUSPEND)
+        return None
 
-    def on_close_command(self):
-        self.emit('close')
+    def on_close_command(self) -> Optional[Message]:
+        self.emit(self.EVENT_CLOSE)
+        return None
 
-    def on_abort_command(self):
-        self.emit('abort')
+    def on_abort_command(self) -> Optional[Message]:
+        self.emit(self.EVENT_ABORT)
+        return None
 
-    def on_delayreport_command(self, delay: int):
-        self.emit('delay_report', delay)
+    def on_delayreport_command(self, delay: int) -> Optional[Message]:
+        self.emit(self.EVENT_DELAY_REPORT, delay)
+        return None
 
-    def on_rtp_channel_open(self):
-        self.emit('rtp_channel_open')
+    def on_security_control_command(self, data: bytes) -> Optional[Message]:
+        self.emit(self.EVENT_SECURITY_CONTROL, data)
+        return None
 
-    def on_rtp_channel_close(self):
-        self.emit('rtp_channel_close')
+    def on_rtp_channel_open(self) -> None:
+        self.emit(self.EVENT_RTP_CHANNEL_OPEN)
+        return None
+
+    def on_rtp_channel_close(self) -> None:
+        self.emit(self.EVENT_RTP_CHANNEL_CLOSE)
+        return None
 
 
 # -----------------------------------------------------------------------------
@@ -2180,12 +2189,13 @@ class LocalSource(LocalStreamEndPoint):
         protocol: Protocol,
         seid: int,
         codec_capabilities: MediaCodecCapabilities,
+        other_capabilitiles: Iterable[ServiceCapabilities],
         packet_pump: MediaPacketPump,
     ) -> None:
         capabilities = [
             ServiceCapabilities(AVDTP_MEDIA_TRANSPORT_SERVICE_CATEGORY),
             codec_capabilities,
-        ]
+        ] + list(other_capabilitiles)
         super().__init__(
             protocol,
             seid,
@@ -2200,13 +2210,13 @@ class LocalSource(LocalStreamEndPoint):
         if self.packet_pump and self.stream and self.stream.rtp_channel:
             return await self.packet_pump.start(self.stream.rtp_channel)
 
-        self.emit('start')
+        self.emit(self.EVENT_START)
 
     async def stop(self) -> None:
         if self.packet_pump:
             return await self.packet_pump.stop()
 
-        self.emit('stop')
+        self.emit(self.EVENT_STOP)
 
     def on_start_command(self):
         asyncio.create_task(self.start())
@@ -2247,4 +2257,4 @@ class LocalSink(LocalStreamEndPoint):
             f'{color("<<< RTP Packet:", "green")} '
             f'{rtp_packet} {rtp_packet.payload[:16].hex()}'
         )
-        self.emit('rtp_packet', rtp_packet)
+        self.emit(self.EVENT_RTP_PACKET, rtp_packet)
diff --git a/bumble/avrcp.py b/bumble/avrcp.py
index e06a5a6..919e23e 100644
--- a/bumble/avrcp.py
+++ b/bumble/avrcp.py
@@ -38,7 +38,6 @@ from typing import (
     Union,
 )
 
-import pyee
 
 from bumble.colors import color
 from bumble.device import Device, Connection
@@ -53,7 +52,7 @@ from bumble.sdp import (
     DataElement,
     ServiceAttribute,
 )
-from bumble.utils import AsyncRunner, OpenIntEnum
+from bumble import utils
 from bumble.core import (
     InvalidArgumentError,
     ProtocolError,
@@ -307,7 +306,7 @@ class Command:
 
 # -----------------------------------------------------------------------------
 class GetCapabilitiesCommand(Command):
-    class CapabilityId(OpenIntEnum):
+    class CapabilityId(utils.OpenIntEnum):
         COMPANY_ID = 0x02
         EVENTS_SUPPORTED = 0x03
 
@@ -637,7 +636,7 @@ class RegisterNotificationResponse(Response):
 
 
 # -----------------------------------------------------------------------------
-class EventId(OpenIntEnum):
+class EventId(utils.OpenIntEnum):
     PLAYBACK_STATUS_CHANGED = 0x01
     TRACK_CHANGED = 0x02
     TRACK_REACHED_END = 0x03
@@ -657,12 +656,12 @@ class EventId(OpenIntEnum):
 
 
 # -----------------------------------------------------------------------------
-class CharacterSetId(OpenIntEnum):
+class CharacterSetId(utils.OpenIntEnum):
     UTF_8 = 0x06
 
 
 # -----------------------------------------------------------------------------
-class MediaAttributeId(OpenIntEnum):
+class MediaAttributeId(utils.OpenIntEnum):
     TITLE = 0x01
     ARTIST_NAME = 0x02
     ALBUM_NAME = 0x03
@@ -682,7 +681,7 @@ class MediaAttribute:
 
 
 # -----------------------------------------------------------------------------
-class PlayStatus(OpenIntEnum):
+class PlayStatus(utils.OpenIntEnum):
     STOPPED = 0x00
     PLAYING = 0x01
     PAUSED = 0x02
@@ -701,33 +700,33 @@ class SongAndPlayStatus:
 
 # -----------------------------------------------------------------------------
 class ApplicationSetting:
-    class AttributeId(OpenIntEnum):
+    class AttributeId(utils.OpenIntEnum):
         EQUALIZER_ON_OFF = 0x01
         REPEAT_MODE = 0x02
         SHUFFLE_ON_OFF = 0x03
         SCAN_ON_OFF = 0x04
 
-    class EqualizerOnOffStatus(OpenIntEnum):
+    class EqualizerOnOffStatus(utils.OpenIntEnum):
         OFF = 0x01
         ON = 0x02
 
-    class RepeatModeStatus(OpenIntEnum):
+    class RepeatModeStatus(utils.OpenIntEnum):
         OFF = 0x01
         SINGLE_TRACK_REPEAT = 0x02
         ALL_TRACK_REPEAT = 0x03
         GROUP_REPEAT = 0x04
 
-    class ShuffleOnOffStatus(OpenIntEnum):
+    class ShuffleOnOffStatus(utils.OpenIntEnum):
         OFF = 0x01
         ALL_TRACKS_SHUFFLE = 0x02
         GROUP_SHUFFLE = 0x03
 
-    class ScanOnOffStatus(OpenIntEnum):
+    class ScanOnOffStatus(utils.OpenIntEnum):
         OFF = 0x01
         ALL_TRACKS_SCAN = 0x02
         GROUP_SCAN = 0x03
 
-    class GenericValue(OpenIntEnum):
+    class GenericValue(utils.OpenIntEnum):
         pass
 
 
@@ -816,7 +815,7 @@ class PlayerApplicationSettingChangedEvent(Event):
     @dataclass
     class Setting:
         attribute_id: ApplicationSetting.AttributeId
-        value_id: OpenIntEnum
+        value_id: utils.OpenIntEnum
 
     player_application_settings: List[Setting]
 
@@ -824,7 +823,7 @@ class PlayerApplicationSettingChangedEvent(Event):
     def from_bytes(cls, pdu: bytes) -> PlayerApplicationSettingChangedEvent:
         def setting(attribute_id_int: int, value_id_int: int):
             attribute_id = ApplicationSetting.AttributeId(attribute_id_int)
-            value_id: OpenIntEnum
+            value_id: utils.OpenIntEnum
             if attribute_id == ApplicationSetting.AttributeId.EQUALIZER_ON_OFF:
                 value_id = ApplicationSetting.EqualizerOnOffStatus(value_id_int)
             elif attribute_id == ApplicationSetting.AttributeId.REPEAT_MODE:
@@ -994,16 +993,20 @@ class Delegate:
 
 
 # -----------------------------------------------------------------------------
-class Protocol(pyee.EventEmitter):
+class Protocol(utils.EventEmitter):
     """AVRCP Controller and Target protocol."""
 
+    EVENT_CONNECTION = "connection"
+    EVENT_START = "start"
+    EVENT_STOP = "stop"
+
     class PacketType(enum.IntEnum):
         SINGLE = 0b00
         START = 0b01
         CONTINUE = 0b10
         END = 0b11
 
-    class PduId(OpenIntEnum):
+    class PduId(utils.OpenIntEnum):
         GET_CAPABILITIES = 0x10
         LIST_PLAYER_APPLICATION_SETTING_ATTRIBUTES = 0x11
         LIST_PLAYER_APPLICATION_SETTING_VALUES = 0x12
@@ -1024,7 +1027,7 @@ class Protocol(pyee.EventEmitter):
         GET_FOLDER_ITEMS = 0x71
         GET_TOTAL_NUMBER_OF_ITEMS = 0x75
 
-    class StatusCode(OpenIntEnum):
+    class StatusCode(utils.OpenIntEnum):
         INVALID_COMMAND = 0x00
         INVALID_PARAMETER = 0x01
         PARAMETER_CONTENT_ERROR = 0x02
@@ -1457,16 +1460,18 @@ class Protocol(pyee.EventEmitter):
 
     def _on_avctp_connection(self, l2cap_channel: l2cap.ClassicChannel) -> None:
         logger.debug("AVCTP connection established")
-        l2cap_channel.on("open", lambda: self._on_avctp_channel_open(l2cap_channel))
+        l2cap_channel.on(
+            l2cap_channel.EVENT_OPEN, lambda: self._on_avctp_channel_open(l2cap_channel)
+        )
 
-        self.emit("connection")
+        self.emit(self.EVENT_CONNECTION)
 
     def _on_avctp_channel_open(self, l2cap_channel: l2cap.ClassicChannel) -> None:
         logger.debug("AVCTP channel open")
         if self.avctp_protocol is not None:
             # TODO: find a better strategy instead of just closing
             logger.warning("AVCTP protocol already active, closing connection")
-            AsyncRunner.spawn(l2cap_channel.disconnect())
+            utils.AsyncRunner.spawn(l2cap_channel.disconnect())
             return
 
         self.avctp_protocol = avctp.Protocol(l2cap_channel)
@@ -1474,15 +1479,15 @@ class Protocol(pyee.EventEmitter):
         self.avctp_protocol.register_response_handler(
             AVRCP_PID, self._on_avctp_response
         )
-        l2cap_channel.on("close", self._on_avctp_channel_close)
+        l2cap_channel.on(l2cap_channel.EVENT_CLOSE, self._on_avctp_channel_close)
 
-        self.emit("start")
+        self.emit(self.EVENT_START)
 
     def _on_avctp_channel_close(self) -> None:
         logger.debug("AVCTP channel closed")
         self.avctp_protocol = None
 
-        self.emit("stop")
+        self.emit(self.EVENT_STOP)
 
     def _on_avctp_command(
         self, transaction_label: int, command: avc.CommandFrame
@@ -1491,10 +1496,14 @@ class Protocol(pyee.EventEmitter):
             f"<<< AVCTP Command, transaction_label={transaction_label}: " f"{command}"
         )
 
-        # Only the PANEL subunit type with subunit ID 0 is supported in this profile.
-        if (
-            command.subunit_type != avc.Frame.SubunitType.PANEL
-            or command.subunit_id != 0
+        # Only addressing the unit, or the PANEL subunit with subunit ID 0 is supported
+        # in this profile.
+        if not (
+            command.subunit_type == avc.Frame.SubunitType.UNIT
+            and command.subunit_id == 7
+        ) and not (
+            command.subunit_type == avc.Frame.SubunitType.PANEL
+            and command.subunit_id == 0
         ):
             logger.debug("subunit not supported")
             self.send_not_implemented_response(transaction_label, command)
@@ -1528,8 +1537,8 @@ class Protocol(pyee.EventEmitter):
             # TODO: delegate
             response = avc.PassThroughResponseFrame(
                 avc.ResponseFrame.ResponseCode.ACCEPTED,
-                avc.Frame.SubunitType.PANEL,
-                0,
+                command.subunit_type,
+                command.subunit_id,
                 command.state_flag,
                 command.operation_id,
                 command.operation_data,
@@ -1846,6 +1855,15 @@ class Protocol(pyee.EventEmitter):
             RejectedResponse(pdu_id, status_code),
         )
 
+    def send_not_implemented_avrcp_response(
+        self, transaction_label: int, pdu_id: Protocol.PduId
+    ) -> None:
+        self.send_avrcp_response(
+            transaction_label,
+            avc.ResponseFrame.ResponseCode.NOT_IMPLEMENTED,
+            NotImplementedResponse(pdu_id, b''),
+        )
+
     def _on_get_capabilities_command(
         self, transaction_label: int, command: GetCapabilitiesCommand
     ) -> None:
@@ -1891,29 +1909,35 @@ class Protocol(pyee.EventEmitter):
         async def register_notification():
             # Check if the event is supported.
             supported_events = await self.delegate.get_supported_events()
-            if command.event_id in supported_events:
-                if command.event_id == EventId.VOLUME_CHANGED:
-                    volume = await self.delegate.get_absolute_volume()
-                    response = RegisterNotificationResponse(VolumeChangedEvent(volume))
-                    self.send_avrcp_response(
-                        transaction_label,
-                        avc.ResponseFrame.ResponseCode.INTERIM,
-                        response,
-                    )
-                    self._register_notification_listener(transaction_label, command)
-                    return
+            if command.event_id not in supported_events:
+                logger.debug("event not supported")
+                self.send_not_implemented_avrcp_response(
+                    transaction_label, self.PduId.REGISTER_NOTIFICATION
+                )
+                return
 
-                if command.event_id == EventId.PLAYBACK_STATUS_CHANGED:
-                    # TODO: testing only, use delegate
-                    response = RegisterNotificationResponse(
-                        PlaybackStatusChangedEvent(play_status=PlayStatus.PLAYING)
-                    )
-                    self.send_avrcp_response(
-                        transaction_label,
-                        avc.ResponseFrame.ResponseCode.INTERIM,
-                        response,
-                    )
-                    self._register_notification_listener(transaction_label, command)
-                    return
+            if command.event_id == EventId.VOLUME_CHANGED:
+                volume = await self.delegate.get_absolute_volume()
+                response = RegisterNotificationResponse(VolumeChangedEvent(volume))
+                self.send_avrcp_response(
+                    transaction_label,
+                    avc.ResponseFrame.ResponseCode.INTERIM,
+                    response,
+                )
+                self._register_notification_listener(transaction_label, command)
+                return
+
+            if command.event_id == EventId.PLAYBACK_STATUS_CHANGED:
+                # TODO: testing only, use delegate
+                response = RegisterNotificationResponse(
+                    PlaybackStatusChangedEvent(play_status=PlayStatus.PLAYING)
+                )
+                self.send_avrcp_response(
+                    transaction_label,
+                    avc.ResponseFrame.ResponseCode.INTERIM,
+                    response,
+                )
+                self._register_notification_listener(transaction_label, command)
+                return
 
         self._delegate_command(transaction_label, command, register_notification())
diff --git a/bumble/bridge.py b/bumble/bridge.py
index ac3ba8a..27ff3ab 100644
--- a/bumble/bridge.py
+++ b/bumble/bridge.py
@@ -17,8 +17,8 @@
 # -----------------------------------------------------------------------------
 import logging
 
-from .hci import HCI_Packet
-from .helpers import PacketTracer
+from bumble.hci import HCI_Packet
+from bumble.helpers import PacketTracer
 
 # -----------------------------------------------------------------------------
 # Logging
diff --git a/bumble/codecs.py b/bumble/codecs.py
index cfb3cad..4d4c48c 100644
--- a/bumble/codecs.py
+++ b/bumble/codecs.py
@@ -17,6 +17,7 @@
 # -----------------------------------------------------------------------------
 from __future__ import annotations
 from dataclasses import dataclass
+from typing_extensions import Self
 
 from bumble import core
 
@@ -101,12 +102,40 @@ class BitReader:
                 break
 
 
+# -----------------------------------------------------------------------------
+class BitWriter:
+    """Simple but not optimized bit stream writer."""
+
+    data: int
+    bit_count: int
+
+    def __init__(self) -> None:
+        self.data = 0
+        self.bit_count = 0
+
+    def write(self, value: int, bit_count: int) -> None:
+        self.data = (self.data << bit_count) | value
+        self.bit_count += bit_count
+
+    def write_bytes(self, data: bytes) -> None:
+        bit_count = 8 * len(data)
+        self.data = (self.data << bit_count) | int.from_bytes(data, 'big')
+        self.bit_count += bit_count
+
+    def __bytes__(self) -> bytes:
+        return (self.data << ((8 - (self.bit_count % 8)) % 8)).to_bytes(
+            (self.bit_count + 7) // 8, 'big'
+        )
+
+
 # -----------------------------------------------------------------------------
 class AacAudioRtpPacket:
     """AAC payload encapsulated in an RTP packet payload"""
 
+    audio_mux_element: AudioMuxElement
+
     @staticmethod
-    def latm_value(reader: BitReader) -> int:
+    def read_latm_value(reader: BitReader) -> int:
         bytes_for_value = reader.read(2)
         value = 0
         for _ in range(bytes_for_value + 1):
@@ -114,24 +143,33 @@ class AacAudioRtpPacket:
         return value
 
     @staticmethod
-    def program_config_element(reader: BitReader):
-        raise core.InvalidPacketError('program_config_element not supported')
+    def read_audio_object_type(reader: BitReader):
+        # GetAudioObjectType - ISO/EIC 14496-3 Table 1.16
+        audio_object_type = reader.read(5)
+        if audio_object_type == 31:
+            audio_object_type = 32 + reader.read(6)
+
+        return audio_object_type
 
     @dataclass
     class GASpecificConfig:
-        def __init__(
-            self, reader: BitReader, channel_configuration: int, audio_object_type: int
-        ) -> None:
+        audio_object_type: int
+        # NOTE: other fields not supported
+
+        @classmethod
+        def from_bits(
+            cls, reader: BitReader, channel_configuration: int, audio_object_type: int
+        ) -> Self:
             # GASpecificConfig - ISO/EIC 14496-3 Table 4.1
             frame_length_flag = reader.read(1)
             depends_on_core_coder = reader.read(1)
             if depends_on_core_coder:
-                self.core_coder_delay = reader.read(14)
+                core_coder_delay = reader.read(14)
             extension_flag = reader.read(1)
             if not channel_configuration:
-                AacAudioRtpPacket.program_config_element(reader)
+                raise core.InvalidPacketError('program_config_element not supported')
             if audio_object_type in (6, 20):
-                self.layer_nr = reader.read(3)
+                layer_nr = reader.read(3)
             if extension_flag:
                 if audio_object_type == 22:
                     num_of_sub_frame = reader.read(5)
@@ -144,14 +182,13 @@ class AacAudioRtpPacket:
                 if extension_flag_3 == 1:
                     raise core.InvalidPacketError('extensionFlag3 == 1 not supported')
 
-    @staticmethod
-    def audio_object_type(reader: BitReader):
-        # GetAudioObjectType - ISO/EIC 14496-3 Table 1.16
-        audio_object_type = reader.read(5)
-        if audio_object_type == 31:
-            audio_object_type = 32 + reader.read(6)
+            return cls(audio_object_type)
 
-        return audio_object_type
+        def to_bits(self, writer: BitWriter) -> None:
+            assert self.audio_object_type in (1, 2)
+            writer.write(0, 1)  # frame_length_flag = 0
+            writer.write(0, 1)  # depends_on_core_coder = 0
+            writer.write(0, 1)  # extension_flag = 0
 
     @dataclass
     class AudioSpecificConfig:
@@ -159,6 +196,7 @@ class AacAudioRtpPacket:
         sampling_frequency_index: int
         sampling_frequency: int
         channel_configuration: int
+        ga_specific_config: AacAudioRtpPacket.GASpecificConfig
         sbr_present_flag: int
         ps_present_flag: int
         extension_audio_object_type: int
@@ -182,44 +220,73 @@ class AacAudioRtpPacket:
             7350,
         ]
 
-        def __init__(self, reader: BitReader) -> None:
+        @classmethod
+        def for_simple_aac(
+            cls,
+            audio_object_type: int,
+            sampling_frequency: int,
+            channel_configuration: int,
+        ) -> Self:
+            if sampling_frequency not in cls.SAMPLING_FREQUENCIES:
+                raise ValueError(f'invalid sampling frequency {sampling_frequency}')
+
+            ga_specific_config = AacAudioRtpPacket.GASpecificConfig(audio_object_type)
+
+            return cls(
+                audio_object_type=audio_object_type,
+                sampling_frequency_index=cls.SAMPLING_FREQUENCIES.index(
+                    sampling_frequency
+                ),
+                sampling_frequency=sampling_frequency,
+                channel_configuration=channel_configuration,
+                ga_specific_config=ga_specific_config,
+                sbr_present_flag=0,
+                ps_present_flag=0,
+                extension_audio_object_type=0,
+                extension_sampling_frequency_index=0,
+                extension_sampling_frequency=0,
+                extension_channel_configuration=0,
+            )
+
+        @classmethod
+        def from_bits(cls, reader: BitReader) -> Self:
             # AudioSpecificConfig - ISO/EIC 14496-3 Table 1.15
-            self.audio_object_type = AacAudioRtpPacket.audio_object_type(reader)
-            self.sampling_frequency_index = reader.read(4)
-            if self.sampling_frequency_index == 0xF:
-                self.sampling_frequency = reader.read(24)
+            audio_object_type = AacAudioRtpPacket.read_audio_object_type(reader)
+            sampling_frequency_index = reader.read(4)
+            if sampling_frequency_index == 0xF:
+                sampling_frequency = reader.read(24)
             else:
-                self.sampling_frequency = self.SAMPLING_FREQUENCIES[
-                    self.sampling_frequency_index
-                ]
-            self.channel_configuration = reader.read(4)
-            self.sbr_present_flag = -1
-            self.ps_present_flag = -1
-            if self.audio_object_type in (5, 29):
-                self.extension_audio_object_type = 5
-                self.sbc_present_flag = 1
-                if self.audio_object_type == 29:
-                    self.ps_present_flag = 1
-                self.extension_sampling_frequency_index = reader.read(4)
-                if self.extension_sampling_frequency_index == 0xF:
-                    self.extension_sampling_frequency = reader.read(24)
+                sampling_frequency = cls.SAMPLING_FREQUENCIES[sampling_frequency_index]
+            channel_configuration = reader.read(4)
+            sbr_present_flag = 0
+            ps_present_flag = 0
+            extension_sampling_frequency_index = 0
+            extension_sampling_frequency = 0
+            extension_channel_configuration = 0
+            extension_audio_object_type = 0
+            if audio_object_type in (5, 29):
+                extension_audio_object_type = 5
+                sbr_present_flag = 1
+                if audio_object_type == 29:
+                    ps_present_flag = 1
+                extension_sampling_frequency_index = reader.read(4)
+                if extension_sampling_frequency_index == 0xF:
+                    extension_sampling_frequency = reader.read(24)
                 else:
-                    self.extension_sampling_frequency = self.SAMPLING_FREQUENCIES[
-                        self.extension_sampling_frequency_index
+                    extension_sampling_frequency = cls.SAMPLING_FREQUENCIES[
+                        extension_sampling_frequency_index
                     ]
-                self.audio_object_type = AacAudioRtpPacket.audio_object_type(reader)
-                if self.audio_object_type == 22:
-                    self.extension_channel_configuration = reader.read(4)
-            else:
-                self.extension_audio_object_type = 0
+                audio_object_type = AacAudioRtpPacket.read_audio_object_type(reader)
+                if audio_object_type == 22:
+                    extension_channel_configuration = reader.read(4)
 
-            if self.audio_object_type in (1, 2, 3, 4, 6, 7, 17, 19, 20, 21, 22, 23):
-                ga_specific_config = AacAudioRtpPacket.GASpecificConfig(
-                    reader, self.channel_configuration, self.audio_object_type
+            if audio_object_type in (1, 2, 3, 4, 6, 7, 17, 19, 20, 21, 22, 23):
+                ga_specific_config = AacAudioRtpPacket.GASpecificConfig.from_bits(
+                    reader, channel_configuration, audio_object_type
                 )
             else:
                 raise core.InvalidPacketError(
-                    f'audioObjectType {self.audio_object_type} not supported'
+                    f'audioObjectType {audio_object_type} not supported'
                 )
 
             # if self.extension_audio_object_type != 5 and bits_to_decode >= 16:
@@ -248,13 +315,44 @@ class AacAudioRtpPacket:
             #                     self.extension_sampling_frequency = self.SAMPLING_FREQUENCIES[self.extension_sampling_frequency_index]
             #             self.extension_channel_configuration = reader.read(4)
 
+            return cls(
+                audio_object_type,
+                sampling_frequency_index,
+                sampling_frequency,
+                channel_configuration,
+                ga_specific_config,
+                sbr_present_flag,
+                ps_present_flag,
+                extension_audio_object_type,
+                extension_sampling_frequency_index,
+                extension_sampling_frequency,
+                extension_channel_configuration,
+            )
+
+        def to_bits(self, writer: BitWriter) -> None:
+            if self.sampling_frequency_index >= 15:
+                raise ValueError(
+                    f"unsupported sampling frequency index {self.sampling_frequency_index}"
+                )
+
+            if self.audio_object_type not in (1, 2):
+                raise ValueError(
+                    f"unsupported audio object type {self.audio_object_type} "
+                )
+
+            writer.write(self.audio_object_type, 5)
+            writer.write(self.sampling_frequency_index, 4)
+            writer.write(self.channel_configuration, 4)
+            self.ga_specific_config.to_bits(writer)
+
     @dataclass
     class StreamMuxConfig:
         other_data_present: int
         other_data_len_bits: int
         audio_specific_config: AacAudioRtpPacket.AudioSpecificConfig
 
-        def __init__(self, reader: BitReader) -> None:
+        @classmethod
+        def from_bits(cls, reader: BitReader) -> Self:
             # StreamMuxConfig - ISO/EIC 14496-3 Table 1.42
             audio_mux_version = reader.read(1)
             if audio_mux_version == 1:
@@ -264,7 +362,7 @@ class AacAudioRtpPacket:
             if audio_mux_version_a != 0:
                 raise core.InvalidPacketError('audioMuxVersionA != 0 not supported')
             if audio_mux_version == 1:
-                tara_buffer_fullness = AacAudioRtpPacket.latm_value(reader)
+                tara_buffer_fullness = AacAudioRtpPacket.read_latm_value(reader)
             stream_cnt = 0
             all_streams_same_time_framing = reader.read(1)
             num_sub_frames = reader.read(6)
@@ -275,13 +373,13 @@ class AacAudioRtpPacket:
             if num_layer != 0:
                 raise core.InvalidPacketError('num_layer != 0 not supported')
             if audio_mux_version == 0:
-                self.audio_specific_config = AacAudioRtpPacket.AudioSpecificConfig(
+                audio_specific_config = AacAudioRtpPacket.AudioSpecificConfig.from_bits(
                     reader
                 )
             else:
-                asc_len = AacAudioRtpPacket.latm_value(reader)
+                asc_len = AacAudioRtpPacket.read_latm_value(reader)
                 marker = reader.bit_position
-                self.audio_specific_config = AacAudioRtpPacket.AudioSpecificConfig(
+                audio_specific_config = AacAudioRtpPacket.AudioSpecificConfig.from_bits(
                     reader
                 )
                 audio_specific_config_len = reader.bit_position - marker
@@ -299,36 +397,49 @@ class AacAudioRtpPacket:
                     f'frame_length_type {frame_length_type} not supported'
                 )
 
-            self.other_data_present = reader.read(1)
-            if self.other_data_present:
+            other_data_present = reader.read(1)
+            other_data_len_bits = 0
+            if other_data_present:
                 if audio_mux_version == 1:
-                    self.other_data_len_bits = AacAudioRtpPacket.latm_value(reader)
+                    other_data_len_bits = AacAudioRtpPacket.read_latm_value(reader)
                 else:
-                    self.other_data_len_bits = 0
                     while True:
-                        self.other_data_len_bits *= 256
+                        other_data_len_bits *= 256
                         other_data_len_esc = reader.read(1)
-                        self.other_data_len_bits += reader.read(8)
+                        other_data_len_bits += reader.read(8)
                         if other_data_len_esc == 0:
                             break
             crc_check_present = reader.read(1)
             if crc_check_present:
                 crc_checksum = reader.read(8)
 
+            return cls(other_data_present, other_data_len_bits, audio_specific_config)
+
+        def to_bits(self, writer: BitWriter) -> None:
+            writer.write(0, 1)  # audioMuxVersion = 0
+            writer.write(1, 1)  # allStreamsSameTimeFraming = 1
+            writer.write(0, 6)  # numSubFrames = 0
+            writer.write(0, 4)  # numProgram = 0
+            writer.write(0, 3)  # numLayer = 0
+            self.audio_specific_config.to_bits(writer)
+            writer.write(0, 3)  # frameLengthType = 0
+            writer.write(0, 8)  # latmBufferFullness = 0
+            writer.write(0, 1)  # otherDataPresent = 0
+            writer.write(0, 1)  # crcCheckPresent = 0
+
     @dataclass
     class AudioMuxElement:
-        payload: bytes
         stream_mux_config: AacAudioRtpPacket.StreamMuxConfig
+        payload: bytes
 
-        def __init__(self, reader: BitReader, mux_config_present: int):
-            if mux_config_present == 0:
-                raise core.InvalidPacketError('muxConfigPresent == 0 not supported')
-
+        @classmethod
+        def from_bits(cls, reader: BitReader) -> Self:
             # AudioMuxElement - ISO/EIC 14496-3 Table 1.41
+            # (only supports mux_config_present=1)
             use_same_stream_mux = reader.read(1)
             if use_same_stream_mux:
                 raise core.InvalidPacketError('useSameStreamMux == 1 not supported')
-            self.stream_mux_config = AacAudioRtpPacket.StreamMuxConfig(reader)
+            stream_mux_config = AacAudioRtpPacket.StreamMuxConfig.from_bits(reader)
 
             # We only support:
             # allStreamsSameTimeFraming == 1
@@ -344,19 +455,46 @@ class AacAudioRtpPacket:
                 if tmp != 255:
                     break
 
-            self.payload = reader.read_bytes(mux_slot_length_bytes)
+            payload = reader.read_bytes(mux_slot_length_bytes)
 
-            if self.stream_mux_config.other_data_present:
-                reader.skip(self.stream_mux_config.other_data_len_bits)
+            if stream_mux_config.other_data_present:
+                reader.skip(stream_mux_config.other_data_len_bits)
 
             # ByteAlign
             while reader.bit_position % 8:
                 reader.read(1)
 
-    def __init__(self, data: bytes) -> None:
+            return cls(stream_mux_config, payload)
+
+        def to_bits(self, writer: BitWriter) -> None:
+            writer.write(0, 1)  # useSameStreamMux = 0
+            self.stream_mux_config.to_bits(writer)
+            mux_slot_length_bytes = len(self.payload)
+            while mux_slot_length_bytes > 255:
+                writer.write(255, 8)
+                mux_slot_length_bytes -= 255
+            writer.write(mux_slot_length_bytes, 8)
+            if mux_slot_length_bytes == 255:
+                writer.write(0, 8)
+            writer.write_bytes(self.payload)
+
+    @classmethod
+    def from_bytes(cls, data: bytes) -> Self:
         # Parse the bit stream
         reader = BitReader(data)
-        self.audio_mux_element = self.AudioMuxElement(reader, mux_config_present=1)
+        return cls(cls.AudioMuxElement.from_bits(reader))
+
+    @classmethod
+    def for_simple_aac(
+        cls, sampling_frequency: int, channel_configuration: int, payload: bytes
+    ) -> Self:
+        audio_specific_config = cls.AudioSpecificConfig.for_simple_aac(
+            2, sampling_frequency, channel_configuration
+        )
+        stream_mux_config = cls.StreamMuxConfig(0, 0, audio_specific_config)
+        audio_mux_element = cls.AudioMuxElement(stream_mux_config, payload)
+
+        return cls(audio_mux_element)
 
     def to_adts(self):
         # pylint: disable=line-too-long
@@ -383,3 +521,11 @@ class AacAudioRtpPacket:
             )
             + self.audio_mux_element.payload
         )
+
+    def __init__(self, audio_mux_element: AudioMuxElement) -> None:
+        self.audio_mux_element = audio_mux_element
+
+    def __bytes__(self) -> bytes:
+        writer = BitWriter()
+        self.audio_mux_element.to_bits(writer)
+        return bytes(writer)
diff --git a/bumble/controller.py b/bumble/controller.py
index f4cbe95..20dfcc5 100644
--- a/bumble/controller.py
+++ b/bumble/controller.py
@@ -25,10 +25,7 @@ import random
 import struct
 from bumble.colors import color
 from bumble.core import (
-    BT_CENTRAL_ROLE,
-    BT_PERIPHERAL_ROLE,
-    BT_LE_TRANSPORT,
-    BT_BR_EDR_TRANSPORT,
+    PhysicalTransport,
 )
 
 from bumble.hci import (
@@ -47,6 +44,7 @@ from bumble.hci import (
     HCI_REMOTE_USER_TERMINATED_CONNECTION_ERROR,
     HCI_VERSION_BLUETOOTH_CORE_5_0,
     Address,
+    Role,
     HCI_AclDataPacket,
     HCI_AclDataPacketAssembler,
     HCI_Command_Complete_Event,
@@ -98,7 +96,7 @@ class CisLink:
 class Connection:
     controller: Controller
     handle: int
-    role: int
+    role: Role
     peer_address: Address
     link: Any
     transport: int
@@ -154,15 +152,17 @@ class Controller:
             '0000000060000000'
         )  # BR/EDR Not Supported, LE Supported (Controller)
         self.manufacturer_name = 0xFFFF
-        self.hc_data_packet_length = 27
-        self.hc_total_num_data_packets = 64
-        self.hc_le_data_packet_length = 27
-        self.hc_total_num_le_data_packets = 64
+        self.acl_data_packet_length = 27
+        self.total_num_acl_data_packets = 64
+        self.le_acl_data_packet_length = 27
+        self.total_num_le_acl_data_packets = 64
+        self.iso_data_packet_length = 960
+        self.total_num_iso_data_packets = 64
         self.event_mask = 0
         self.event_mask_page_2 = 0
         self.supported_commands = bytes.fromhex(
             '2000800000c000000000e4000000a822000000000000040000f7ffff7f000000'
-            '30f0f9ff01008004000000000000000000000000000000000000000000000000'
+            '30f0f9ff01008004002000000000000000000000000000000000000000000000'
         )
         self.le_event_mask = 0
         self.advertising_parameters = None
@@ -314,7 +314,7 @@ class Controller:
             f'{color("CONTROLLER -> HOST", "green")}: {packet}'
         )
         if self.host:
-            self.host.on_packet(packet.to_bytes())
+            self.host.on_packet(bytes(packet))
 
     # This method allows the controller to emulate the same API as a transport source
     async def wait_for_termination(self):
@@ -388,10 +388,10 @@ class Controller:
             connection = Connection(
                 controller=self,
                 handle=connection_handle,
-                role=BT_PERIPHERAL_ROLE,
+                role=Role.PERIPHERAL,
                 peer_address=peer_address,
                 link=self.link,
-                transport=BT_LE_TRANSPORT,
+                transport=PhysicalTransport.LE,
                 link_type=HCI_Connection_Complete_Event.ACL_LINK_TYPE,
             )
             self.peripheral_connections[peer_address] = connection
@@ -448,10 +448,10 @@ class Controller:
                 connection = Connection(
                     controller=self,
                     handle=connection_handle,
-                    role=BT_CENTRAL_ROLE,
+                    role=Role.CENTRAL,
                     peer_address=peer_address,
                     link=self.link,
-                    transport=BT_LE_TRANSPORT,
+                    transport=PhysicalTransport.LE,
                     link_type=HCI_Connection_Complete_Event.ACL_LINK_TYPE,
                 )
                 self.central_connections[peer_address] = connection
@@ -467,7 +467,7 @@ class Controller:
             HCI_LE_Connection_Complete_Event(
                 status=status,
                 connection_handle=connection.handle if connection else 0,
-                role=BT_CENTRAL_ROLE,
+                role=Role.CENTRAL,
                 peer_address_type=le_create_connection_command.peer_address_type,
                 peer_address=le_create_connection_command.peer_address,
                 connection_interval=le_create_connection_command.connection_interval_min,
@@ -529,7 +529,7 @@ class Controller:
 
     def on_link_acl_data(self, sender_address, transport, data):
         # Look for the connection to which this data belongs
-        if transport == BT_LE_TRANSPORT:
+        if transport == PhysicalTransport.LE:
             connection = self.find_le_connection_by_address(sender_address)
         else:
             connection = self.find_classic_connection_by_address(sender_address)
@@ -691,10 +691,10 @@ class Controller:
                     controller=self,
                     handle=connection_handle,
                     # Role doesn't matter in Classic because they are managed by HCI_Role_Change and HCI_Role_Discovery
-                    role=BT_CENTRAL_ROLE,
+                    role=Role.CENTRAL,
                     peer_address=peer_address,
                     link=self.link,
-                    transport=BT_BR_EDR_TRANSPORT,
+                    transport=PhysicalTransport.BR_EDR,
                     link_type=HCI_Connection_Complete_Event.ACL_LINK_TYPE,
                 )
                 self.classic_connections[peer_address] = connection
@@ -759,10 +759,10 @@ class Controller:
                 controller=self,
                 handle=connection_handle,
                 # Role doesn't matter in SCO.
-                role=BT_CENTRAL_ROLE,
+                role=Role.CENTRAL,
                 peer_address=peer_address,
                 link=self.link,
-                transport=BT_BR_EDR_TRANSPORT,
+                transport=PhysicalTransport.BR_EDR,
                 link_type=link_type,
             )
             self.classic_connections[peer_address] = connection
@@ -1181,9 +1181,9 @@ class Controller:
         return struct.pack(
             '<BHBHH',
             HCI_SUCCESS,
-            self.hc_data_packet_length,
+            self.acl_data_packet_length,
             0,
-            self.hc_total_num_data_packets,
+            self.total_num_acl_data_packets,
             0,
         )
 
@@ -1192,7 +1192,7 @@ class Controller:
         See Bluetooth spec Vol 4, Part E - 7.4.6 Read BD_ADDR Command
         '''
         bd_addr = (
-            self._public_address.to_bytes()
+            bytes(self._public_address)
             if self._public_address is not None
             else bytes(6)
         )
@@ -1212,8 +1212,21 @@ class Controller:
         return struct.pack(
             '<BHB',
             HCI_SUCCESS,
-            self.hc_le_data_packet_length,
-            self.hc_total_num_le_data_packets,
+            self.le_acl_data_packet_length,
+            self.total_num_le_acl_data_packets,
+        )
+
+    def on_hci_le_read_buffer_size_v2_command(self, _command):
+        '''
+        See Bluetooth spec Vol 4, Part E - 7.8.2 LE Read Buffer Size Command
+        '''
+        return struct.pack(
+            '<BHBHB',
+            HCI_SUCCESS,
+            self.le_acl_data_packet_length,
+            self.total_num_le_acl_data_packets,
+            self.iso_data_packet_length,
+            self.total_num_iso_data_packets,
         )
 
     def on_hci_le_read_local_supported_features_command(self, _command):
@@ -1543,6 +1556,41 @@ class Controller:
         }
         return bytes([HCI_SUCCESS])
 
+    def on_hci_le_set_advertising_set_random_address_command(self, _command):
+        '''
+        See Bluetooth spec Vol 4, Part E - 7.8.52 LE Set Advertising Set Random Address
+        Command
+        '''
+        return bytes([HCI_SUCCESS])
+
+    def on_hci_le_set_extended_advertising_parameters_command(self, _command):
+        '''
+        See Bluetooth spec Vol 4, Part E - 7.8.53 LE Set Extended Advertising Parameters
+        Command
+        '''
+        return bytes([HCI_SUCCESS, 0])
+
+    def on_hci_le_set_extended_advertising_data_command(self, _command):
+        '''
+        See Bluetooth spec Vol 4, Part E - 7.8.54 LE Set Extended Advertising Data
+        Command
+        '''
+        return bytes([HCI_SUCCESS])
+
+    def on_hci_le_set_extended_scan_response_data_command(self, _command):
+        '''
+        See Bluetooth spec Vol 4, Part E - 7.8.55 LE Set Extended Scan Response Data
+        Command
+        '''
+        return bytes([HCI_SUCCESS])
+
+    def on_hci_le_set_extended_advertising_enable_command(self, _command):
+        '''
+        See Bluetooth spec Vol 4, Part E - 7.8.56 LE Set Extended Advertising Enable
+        Command
+        '''
+        return bytes([HCI_SUCCESS])
+
     def on_hci_le_read_maximum_advertising_data_length_command(self, _command):
         '''
         See Bluetooth spec Vol 4, Part E - 7.8.57 LE Read Maximum Advertising Data
@@ -1557,6 +1605,27 @@ class Controller:
         '''
         return struct.pack('<BB', HCI_SUCCESS, 0xF0)
 
+    def on_hci_le_set_periodic_advertising_parameters_command(self, _command):
+        '''
+        See Bluetooth spec Vol 4, Part E - 7.8.61 LE Set Periodic Advertising Parameters
+        Command
+        '''
+        return bytes([HCI_SUCCESS])
+
+    def on_hci_le_set_periodic_advertising_data_command(self, _command):
+        '''
+        See Bluetooth spec Vol 4, Part E - 7.8.62 LE Set Periodic Advertising Data
+        Command
+        '''
+        return bytes([HCI_SUCCESS])
+
+    def on_hci_le_set_periodic_advertising_enable_command(self, _command):
+        '''
+        See Bluetooth spec Vol 4, Part E - 7.8.63 LE Set Periodic Advertising Enable
+        Command
+        '''
+        return bytes([HCI_SUCCESS])
+
     def on_hci_le_read_transmit_power_command(self, _command):
         '''
         See Bluetooth spec Vol 4, Part E - 7.8.74 LE Read Transmit Power Command
diff --git a/bumble/core.py b/bumble/core.py
index f6d42dd..b5822a4 100644
--- a/bumble/core.py
+++ b/bumble/core.py
@@ -1,4 +1,4 @@
-# Copyright 2021-2022 Google LLC
+# Copyright 2021-2025 Google LLC
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -16,14 +16,14 @@
 # Imports
 # -----------------------------------------------------------------------------
 from __future__ import annotations
-import dataclasses
+
 import enum
 import struct
-from typing import List, Optional, Tuple, Union, cast, Dict
+from typing import cast, overload, Literal, Union, Optional
 from typing_extensions import Self
 
 from bumble.company_ids import COMPANY_IDENTIFIERS
-from bumble.utils import OpenIntEnum
+from bumble import utils
 
 
 # -----------------------------------------------------------------------------
@@ -31,11 +31,12 @@ from bumble.utils import OpenIntEnum
 # -----------------------------------------------------------------------------
 # fmt: off
 
-BT_CENTRAL_ROLE    = 0
-BT_PERIPHERAL_ROLE = 1
+class PhysicalTransport(enum.IntEnum):
+    BR_EDR = 0
+    LE     = 1
 
-BT_BR_EDR_TRANSPORT = 0
-BT_LE_TRANSPORT     = 1
+BT_BR_EDR_TRANSPORT = PhysicalTransport.BR_EDR
+BT_LE_TRANSPORT     = PhysicalTransport.LE
 
 
 # fmt: on
@@ -57,7 +58,7 @@ def bit_flags_to_strings(bits, bit_flag_names):
     return names
 
 
-def name_or_number(dictionary: Dict[int, str], number: int, width: int = 2) -> str:
+def name_or_number(dictionary: dict[int, str], number: int, width: int = 2) -> str:
     name = dictionary.get(number)
     if name is not None:
         return name
@@ -200,7 +201,7 @@ class UUID:
     '''
 
     BASE_UUID = bytes.fromhex('00001000800000805F9B34FB')[::-1]  # little-endian
-    UUIDS: List[UUID] = []  # Registry of all instances created
+    UUIDS: list[UUID] = []  # Registry of all instances created
 
     uuid_bytes: bytes
     name: Optional[str]
@@ -259,11 +260,11 @@ class UUID:
         return cls.from_bytes(struct.pack('<I', uuid_32), name)
 
     @classmethod
-    def parse_uuid(cls, uuid_as_bytes: bytes, offset: int) -> Tuple[int, UUID]:
+    def parse_uuid(cls, uuid_as_bytes: bytes, offset: int) -> tuple[int, UUID]:
         return len(uuid_as_bytes), cls.from_bytes(uuid_as_bytes[offset:])
 
     @classmethod
-    def parse_uuid_2(cls, uuid_as_bytes: bytes, offset: int) -> Tuple[int, UUID]:
+    def parse_uuid_2(cls, uuid_as_bytes: bytes, offset: int) -> tuple[int, UUID]:
         return offset + 2, cls.from_bytes(uuid_as_bytes[offset : offset + 2])
 
     def to_bytes(self, force_128: bool = False) -> bytes:
@@ -729,7 +730,7 @@ class DeviceClass:
 # Appearance
 # -----------------------------------------------------------------------------
 class Appearance:
-    class Category(OpenIntEnum):
+    class Category(utils.OpenIntEnum):
         UNKNOWN = 0x0000
         PHONE = 0x0001
         COMPUTER = 0x0002
@@ -783,13 +784,13 @@ class Appearance:
         SPIROMETER = 0x0037
         OUTDOOR_SPORTS_ACTIVITY = 0x0051
 
-    class UnknownSubcategory(OpenIntEnum):
+    class UnknownSubcategory(utils.OpenIntEnum):
         GENERIC_UNKNOWN = 0x00
 
-    class PhoneSubcategory(OpenIntEnum):
+    class PhoneSubcategory(utils.OpenIntEnum):
         GENERIC_PHONE = 0x00
 
-    class ComputerSubcategory(OpenIntEnum):
+    class ComputerSubcategory(utils.OpenIntEnum):
         GENERIC_COMPUTER = 0x00
         DESKTOP_WORKSTATION = 0x01
         SERVER_CLASS_COMPUTER = 0x02
@@ -807,49 +808,49 @@ class Appearance:
         MINI_PC = 0x0E
         STICK_PC = 0x0F
 
-    class WatchSubcategory(OpenIntEnum):
-        GENENERIC_WATCH = 0x00
+    class WatchSubcategory(utils.OpenIntEnum):
+        GENERIC_WATCH = 0x00
         SPORTS_WATCH = 0x01
         SMARTWATCH = 0x02
 
-    class ClockSubcategory(OpenIntEnum):
+    class ClockSubcategory(utils.OpenIntEnum):
         GENERIC_CLOCK = 0x00
 
-    class DisplaySubcategory(OpenIntEnum):
+    class DisplaySubcategory(utils.OpenIntEnum):
         GENERIC_DISPLAY = 0x00
 
-    class RemoteControlSubcategory(OpenIntEnum):
+    class RemoteControlSubcategory(utils.OpenIntEnum):
         GENERIC_REMOTE_CONTROL = 0x00
 
-    class EyeglassesSubcategory(OpenIntEnum):
+    class EyeglassesSubcategory(utils.OpenIntEnum):
         GENERIC_EYEGLASSES = 0x00
 
-    class TagSubcategory(OpenIntEnum):
+    class TagSubcategory(utils.OpenIntEnum):
         GENERIC_TAG = 0x00
 
-    class KeyringSubcategory(OpenIntEnum):
+    class KeyringSubcategory(utils.OpenIntEnum):
         GENERIC_KEYRING = 0x00
 
-    class MediaPlayerSubcategory(OpenIntEnum):
+    class MediaPlayerSubcategory(utils.OpenIntEnum):
         GENERIC_MEDIA_PLAYER = 0x00
 
-    class BarcodeScannerSubcategory(OpenIntEnum):
+    class BarcodeScannerSubcategory(utils.OpenIntEnum):
         GENERIC_BARCODE_SCANNER = 0x00
 
-    class ThermometerSubcategory(OpenIntEnum):
+    class ThermometerSubcategory(utils.OpenIntEnum):
         GENERIC_THERMOMETER = 0x00
         EAR_THERMOMETER = 0x01
 
-    class HeartRateSensorSubcategory(OpenIntEnum):
+    class HeartRateSensorSubcategory(utils.OpenIntEnum):
         GENERIC_HEART_RATE_SENSOR = 0x00
         HEART_RATE_BELT = 0x01
 
-    class BloodPressureSubcategory(OpenIntEnum):
+    class BloodPressureSubcategory(utils.OpenIntEnum):
         GENERIC_BLOOD_PRESSURE = 0x00
         ARM_BLOOD_PRESSURE = 0x01
         WRIST_BLOOD_PRESSURE = 0x02
 
-    class HumanInterfaceDeviceSubcategory(OpenIntEnum):
+    class HumanInterfaceDeviceSubcategory(utils.OpenIntEnum):
         GENERIC_HUMAN_INTERFACE_DEVICE = 0x00
         KEYBOARD = 0x01
         MOUSE = 0x02
@@ -862,16 +863,16 @@ class Appearance:
         TOUCHPAD = 0x09
         PRESENTATION_REMOTE = 0x0A
 
-    class GlucoseMeterSubcategory(OpenIntEnum):
+    class GlucoseMeterSubcategory(utils.OpenIntEnum):
         GENERIC_GLUCOSE_METER = 0x00
 
-    class RunningWalkingSensorSubcategory(OpenIntEnum):
+    class RunningWalkingSensorSubcategory(utils.OpenIntEnum):
         GENERIC_RUNNING_WALKING_SENSOR = 0x00
         IN_SHOE_RUNNING_WALKING_SENSOR = 0x01
         ON_SHOW_RUNNING_WALKING_SENSOR = 0x02
         ON_HIP_RUNNING_WALKING_SENSOR = 0x03
 
-    class CyclingSubcategory(OpenIntEnum):
+    class CyclingSubcategory(utils.OpenIntEnum):
         GENERIC_CYCLING = 0x00
         CYCLING_COMPUTER = 0x01
         SPEED_SENSOR = 0x02
@@ -879,7 +880,7 @@ class Appearance:
         POWER_SENSOR = 0x04
         SPEED_AND_CADENCE_SENSOR = 0x05
 
-    class ControlDeviceSubcategory(OpenIntEnum):
+    class ControlDeviceSubcategory(utils.OpenIntEnum):
         GENERIC_CONTROL_DEVICE = 0x00
         SWITCH = 0x01
         MULTI_SWITCH = 0x02
@@ -894,13 +895,13 @@ class Appearance:
         ENERGY_HARVESTING_SWITCH = 0x0B
         PUSH_BUTTON = 0x0C
 
-    class NetworkDeviceSubcategory(OpenIntEnum):
+    class NetworkDeviceSubcategory(utils.OpenIntEnum):
         GENERIC_NETWORK_DEVICE = 0x00
         ACCESS_POINT = 0x01
         MESH_DEVICE = 0x02
         MESH_NETWORK_PROXY = 0x03
 
-    class SensorSubcategory(OpenIntEnum):
+    class SensorSubcategory(utils.OpenIntEnum):
         GENERIC_SENSOR = 0x00
         MOTION_SENSOR = 0x01
         AIR_QUALITY_SENSOR = 0x02
@@ -928,7 +929,7 @@ class Appearance:
         FLAME_DETECTOR = 0x18
         VEHICLE_TIRE_PRESSURE_SENSOR = 0x19
 
-    class LightFixturesSubcategory(OpenIntEnum):
+    class LightFixturesSubcategory(utils.OpenIntEnum):
         GENERIC_LIGHT_FIXTURES = 0x00
         WALL_LIGHT = 0x01
         CEILING_LIGHT = 0x02
@@ -956,7 +957,7 @@ class Appearance:
         LOW_BAY_LIGHT = 0x18
         HIGH_BAY_LIGHT = 0x19
 
-    class FanSubcategory(OpenIntEnum):
+    class FanSubcategory(utils.OpenIntEnum):
         GENERIC_FAN = 0x00
         CEILING_FAN = 0x01
         AXIAL_FAN = 0x02
@@ -965,7 +966,7 @@ class Appearance:
         DESK_FAN = 0x05
         WALL_FAN = 0x06
 
-    class HvacSubcategory(OpenIntEnum):
+    class HvacSubcategory(utils.OpenIntEnum):
         GENERIC_HVAC = 0x00
         THERMOSTAT = 0x01
         HUMIDIFIER = 0x02
@@ -979,13 +980,13 @@ class Appearance:
         FAN_HEATER = 0x0A
         AIR_CURTAIN = 0x0B
 
-    class AirConditioningSubcategory(OpenIntEnum):
+    class AirConditioningSubcategory(utils.OpenIntEnum):
         GENERIC_AIR_CONDITIONING = 0x00
 
-    class HumidifierSubcategory(OpenIntEnum):
+    class HumidifierSubcategory(utils.OpenIntEnum):
         GENERIC_HUMIDIFIER = 0x00
 
-    class HeatingSubcategory(OpenIntEnum):
+    class HeatingSubcategory(utils.OpenIntEnum):
         GENERIC_HEATING = 0x00
         RADIATOR = 0x01
         BOILER = 0x02
@@ -995,7 +996,7 @@ class Appearance:
         FAN_HEATER = 0x06
         AIR_CURTAIN = 0x07
 
-    class AccessControlSubcategory(OpenIntEnum):
+    class AccessControlSubcategory(utils.OpenIntEnum):
         GENERIC_ACCESS_CONTROL = 0x00
         ACCESS_DOOR = 0x01
         GARAGE_DOOR = 0x02
@@ -1007,7 +1008,7 @@ class Appearance:
         DOOR_LOCK = 0x08
         LOCKER = 0x09
 
-    class MotorizedDeviceSubcategory(OpenIntEnum):
+    class MotorizedDeviceSubcategory(utils.OpenIntEnum):
         GENERIC_MOTORIZED_DEVICE = 0x00
         MOTORIZED_GATE = 0x01
         AWNING = 0x02
@@ -1015,7 +1016,7 @@ class Appearance:
         CURTAINS = 0x04
         SCREEN = 0x05
 
-    class PowerDeviceSubcategory(OpenIntEnum):
+    class PowerDeviceSubcategory(utils.OpenIntEnum):
         GENERIC_POWER_DEVICE = 0x00
         POWER_OUTLET = 0x01
         POWER_STRIP = 0x02
@@ -1027,7 +1028,7 @@ class Appearance:
         CHARGE_CASE = 0x08
         POWER_BANK = 0x09
 
-    class LightSourceSubcategory(OpenIntEnum):
+    class LightSourceSubcategory(utils.OpenIntEnum):
         GENERIC_LIGHT_SOURCE = 0x00
         INCANDESCENT_LIGHT_BULB = 0x01
         LED_LAMP = 0x02
@@ -1038,7 +1039,7 @@ class Appearance:
         LOW_VOLTAGE_HALOGEN = 0x07
         ORGANIC_LIGHT_EMITTING_DIODE = 0x08
 
-    class WindowCoveringSubcategory(OpenIntEnum):
+    class WindowCoveringSubcategory(utils.OpenIntEnum):
         GENERIC_WINDOW_COVERING = 0x00
         WINDOW_SHADES = 0x01
         WINDOW_BLINDS = 0x02
@@ -1047,7 +1048,7 @@ class Appearance:
         EXTERIOR_SHUTTER = 0x05
         EXTERIOR_SCREEN = 0x06
 
-    class AudioSinkSubcategory(OpenIntEnum):
+    class AudioSinkSubcategory(utils.OpenIntEnum):
         GENERIC_AUDIO_SINK = 0x00
         STANDALONE_SPEAKER = 0x01
         SOUNDBAR = 0x02
@@ -1055,7 +1056,7 @@ class Appearance:
         STANDMOUNTED_SPEAKER = 0x04
         SPEAKERPHONE = 0x05
 
-    class AudioSourceSubcategory(OpenIntEnum):
+    class AudioSourceSubcategory(utils.OpenIntEnum):
         GENERIC_AUDIO_SOURCE = 0x00
         MICROPHONE = 0x01
         ALARM = 0x02
@@ -1067,7 +1068,7 @@ class Appearance:
         BROADCASTING_ROOM = 0x08
         AUDITORIUM = 0x09
 
-    class MotorizedVehicleSubcategory(OpenIntEnum):
+    class MotorizedVehicleSubcategory(utils.OpenIntEnum):
         GENERIC_MOTORIZED_VEHICLE = 0x00
         CAR = 0x01
         LARGE_GOODS_VEHICLE = 0x02
@@ -1085,7 +1086,7 @@ class Appearance:
         CAMPER_CARAVAN = 0x0E
         RECREATIONAL_VEHICLE_MOTOR_HOME = 0x0F
 
-    class DomesticApplianceSubcategory(OpenIntEnum):
+    class DomesticApplianceSubcategory(utils.OpenIntEnum):
         GENERIC_DOMESTIC_APPLIANCE = 0x00
         REFRIGERATOR = 0x01
         FREEZER = 0x02
@@ -1103,21 +1104,21 @@ class Appearance:
         RICE_COOKER = 0x0E
         CLOTHES_STEAMER = 0x0F
 
-    class WearableAudioDeviceSubcategory(OpenIntEnum):
+    class WearableAudioDeviceSubcategory(utils.OpenIntEnum):
         GENERIC_WEARABLE_AUDIO_DEVICE = 0x00
         EARBUD = 0x01
         HEADSET = 0x02
         HEADPHONES = 0x03
         NECK_BAND = 0x04
 
-    class AircraftSubcategory(OpenIntEnum):
+    class AircraftSubcategory(utils.OpenIntEnum):
         GENERIC_AIRCRAFT = 0x00
         LIGHT_AIRCRAFT = 0x01
         MICROLIGHT = 0x02
         PARAGLIDER = 0x03
         LARGE_PASSENGER_AIRCRAFT = 0x04
 
-    class AvEquipmentSubcategory(OpenIntEnum):
+    class AvEquipmentSubcategory(utils.OpenIntEnum):
         GENERIC_AV_EQUIPMENT = 0x00
         AMPLIFIER = 0x01
         RECEIVER = 0x02
@@ -1126,69 +1127,69 @@ class Appearance:
         TURNTABLE = 0x05
         CD_PLAYER = 0x06
         DVD_PLAYER = 0x07
-        BLUERAY_PLAYER = 0x08
+        BLURAY_PLAYER = 0x08
         OPTICAL_DISC_PLAYER = 0x09
         SET_TOP_BOX = 0x0A
 
-    class DisplayEquipmentSubcategory(OpenIntEnum):
+    class DisplayEquipmentSubcategory(utils.OpenIntEnum):
         GENERIC_DISPLAY_EQUIPMENT = 0x00
         TELEVISION = 0x01
         MONITOR = 0x02
         PROJECTOR = 0x03
 
-    class HearingAidSubcategory(OpenIntEnum):
+    class HearingAidSubcategory(utils.OpenIntEnum):
         GENERIC_HEARING_AID = 0x00
         IN_EAR_HEARING_AID = 0x01
         BEHIND_EAR_HEARING_AID = 0x02
         COCHLEAR_IMPLANT = 0x03
 
-    class GamingSubcategory(OpenIntEnum):
+    class GamingSubcategory(utils.OpenIntEnum):
         GENERIC_GAMING = 0x00
         HOME_VIDEO_GAME_CONSOLE = 0x01
         PORTABLE_HANDHELD_CONSOLE = 0x02
 
-    class SignageSubcategory(OpenIntEnum):
+    class SignageSubcategory(utils.OpenIntEnum):
         GENERIC_SIGNAGE = 0x00
         DIGITAL_SIGNAGE = 0x01
         ELECTRONIC_LABEL = 0x02
 
-    class PulseOximeterSubcategory(OpenIntEnum):
+    class PulseOximeterSubcategory(utils.OpenIntEnum):
         GENERIC_PULSE_OXIMETER = 0x00
         FINGERTIP_PULSE_OXIMETER = 0x01
         WRIST_WORN_PULSE_OXIMETER = 0x02
 
-    class WeightScaleSubcategory(OpenIntEnum):
+    class WeightScaleSubcategory(utils.OpenIntEnum):
         GENERIC_WEIGHT_SCALE = 0x00
 
-    class PersonalMobilityDeviceSubcategory(OpenIntEnum):
+    class PersonalMobilityDeviceSubcategory(utils.OpenIntEnum):
         GENERIC_PERSONAL_MOBILITY_DEVICE = 0x00
         POWERED_WHEELCHAIR = 0x01
         MOBILITY_SCOOTER = 0x02
 
-    class ContinuousGlucoseMonitorSubcategory(OpenIntEnum):
+    class ContinuousGlucoseMonitorSubcategory(utils.OpenIntEnum):
         GENERIC_CONTINUOUS_GLUCOSE_MONITOR = 0x00
 
-    class InsulinPumpSubcategory(OpenIntEnum):
+    class InsulinPumpSubcategory(utils.OpenIntEnum):
         GENERIC_INSULIN_PUMP = 0x00
         INSULIN_PUMP_DURABLE_PUMP = 0x01
         INSULIN_PUMP_PATCH_PUMP = 0x02
         INSULIN_PEN = 0x03
 
-    class MedicationDeliverySubcategory(OpenIntEnum):
+    class MedicationDeliverySubcategory(utils.OpenIntEnum):
         GENERIC_MEDICATION_DELIVERY = 0x00
 
-    class SpirometerSubcategory(OpenIntEnum):
+    class SpirometerSubcategory(utils.OpenIntEnum):
         GENERIC_SPIROMETER = 0x00
         HANDHELD_SPIROMETER = 0x01
 
-    class OutdoorSportsActivitySubcategory(OpenIntEnum):
+    class OutdoorSportsActivitySubcategory(utils.OpenIntEnum):
         GENERIC_OUTDOOR_SPORTS_ACTIVITY = 0x00
         LOCATION_DISPLAY = 0x01
         LOCATION_AND_NAVIGATION_DISPLAY = 0x02
         LOCATION_POD = 0x03
         LOCATION_AND_NAVIGATION_POD = 0x04
 
-    class _OpenSubcategory(OpenIntEnum):
+    class _OpenSubcategory(utils.OpenIntEnum):
         GENERIC = 0x00
 
     SUBCATEGORY_CLASSES = {
@@ -1280,13 +1281,13 @@ class Appearance:
 # Advertising Data
 # -----------------------------------------------------------------------------
 AdvertisingDataObject = Union[
-    List[UUID],
-    Tuple[UUID, bytes],
+    list[UUID],
+    tuple[UUID, bytes],
     bytes,
     str,
     int,
-    Tuple[int, int],
-    Tuple[int, bytes],
+    tuple[int, int],
+    tuple[int, bytes],
     Appearance,
 ]
 
@@ -1295,129 +1296,135 @@ class AdvertisingData:
     # fmt: off
     # pylint: disable=line-too-long
 
-    FLAGS                                            = 0x01
-    INCOMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS    = 0x02
-    COMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS      = 0x03
-    INCOMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS    = 0x04
-    COMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS      = 0x05
-    INCOMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS   = 0x06
-    COMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS     = 0x07
-    SHORTENED_LOCAL_NAME                             = 0x08
-    COMPLETE_LOCAL_NAME                              = 0x09
-    TX_POWER_LEVEL                                   = 0x0A
-    CLASS_OF_DEVICE                                  = 0x0D
-    SIMPLE_PAIRING_HASH_C                            = 0x0E
-    SIMPLE_PAIRING_HASH_C_192                        = 0x0E
-    SIMPLE_PAIRING_RANDOMIZER_R                      = 0x0F
-    SIMPLE_PAIRING_RANDOMIZER_R_192                  = 0x0F
-    DEVICE_ID                                        = 0x10
-    SECURITY_MANAGER_TK_VALUE                        = 0x10
-    SECURITY_MANAGER_OUT_OF_BAND_FLAGS               = 0x11
-    PERIPHERAL_CONNECTION_INTERVAL_RANGE             = 0x12
-    LIST_OF_16_BIT_SERVICE_SOLICITATION_UUIDS        = 0x14
-    LIST_OF_128_BIT_SERVICE_SOLICITATION_UUIDS       = 0x15
-    SERVICE_DATA                                     = 0x16
-    SERVICE_DATA_16_BIT_UUID                         = 0x16
-    PUBLIC_TARGET_ADDRESS                            = 0x17
-    RANDOM_TARGET_ADDRESS                            = 0x18
-    APPEARANCE                                       = 0x19
-    ADVERTISING_INTERVAL                             = 0x1A
-    LE_BLUETOOTH_DEVICE_ADDRESS                      = 0x1B
-    LE_ROLE                                          = 0x1C
-    SIMPLE_PAIRING_HASH_C_256                        = 0x1D
-    SIMPLE_PAIRING_RANDOMIZER_R_256                  = 0x1E
-    LIST_OF_32_BIT_SERVICE_SOLICITATION_UUIDS        = 0x1F
-    SERVICE_DATA_32_BIT_UUID                         = 0x20
-    SERVICE_DATA_128_BIT_UUID                        = 0x21
-    LE_SECURE_CONNECTIONS_CONFIRMATION_VALUE         = 0x22
-    LE_SECURE_CONNECTIONS_RANDOM_VALUE               = 0x23
-    URI                                              = 0x24
-    INDOOR_POSITIONING                               = 0x25
-    TRANSPORT_DISCOVERY_DATA                         = 0x26
-    LE_SUPPORTED_FEATURES                            = 0x27
-    CHANNEL_MAP_UPDATE_INDICATION                    = 0x28
-    PB_ADV                                           = 0x29
-    MESH_MESSAGE                                     = 0x2A
-    MESH_BEACON                                      = 0x2B
-    BIGINFO                                          = 0x2C
-    BROADCAST_CODE                                   = 0x2D
-    RESOLVABLE_SET_IDENTIFIER                        = 0x2E
-    ADVERTISING_INTERVAL_LONG                        = 0x2F
-    BROADCAST_NAME                                   = 0x30
-    ENCRYPTED_ADVERTISING_DATA                       = 0X31
-    PERIODIC_ADVERTISING_RESPONSE_TIMING_INFORMATION = 0X32
-    ELECTRONIC_SHELF_LABEL                           = 0X34
-    THREE_D_INFORMATION_DATA                         = 0x3D
-    MANUFACTURER_SPECIFIC_DATA                       = 0xFF
-
-    AD_TYPE_NAMES = {
-        FLAGS:                                            'FLAGS',
-        INCOMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS:    'INCOMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS',
-        COMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS:      'COMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS',
-        INCOMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS:    'INCOMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS',
-        COMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS:      'COMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS',
-        INCOMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS:   'INCOMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS',
-        COMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS:     'COMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS',
-        SHORTENED_LOCAL_NAME:                             'SHORTENED_LOCAL_NAME',
-        COMPLETE_LOCAL_NAME:                              'COMPLETE_LOCAL_NAME',
-        TX_POWER_LEVEL:                                   'TX_POWER_LEVEL',
-        CLASS_OF_DEVICE:                                  'CLASS_OF_DEVICE',
-        SIMPLE_PAIRING_HASH_C:                            'SIMPLE_PAIRING_HASH_C',
-        SIMPLE_PAIRING_HASH_C_192:                        'SIMPLE_PAIRING_HASH_C_192',
-        SIMPLE_PAIRING_RANDOMIZER_R:                      'SIMPLE_PAIRING_RANDOMIZER_R',
-        SIMPLE_PAIRING_RANDOMIZER_R_192:                  'SIMPLE_PAIRING_RANDOMIZER_R_192',
-        DEVICE_ID:                                        'DEVICE_ID',
-        SECURITY_MANAGER_TK_VALUE:                        'SECURITY_MANAGER_TK_VALUE',
-        SECURITY_MANAGER_OUT_OF_BAND_FLAGS:               'SECURITY_MANAGER_OUT_OF_BAND_FLAGS',
-        PERIPHERAL_CONNECTION_INTERVAL_RANGE:             'PERIPHERAL_CONNECTION_INTERVAL_RANGE',
-        LIST_OF_16_BIT_SERVICE_SOLICITATION_UUIDS:        'LIST_OF_16_BIT_SERVICE_SOLICITATION_UUIDS',
-        LIST_OF_128_BIT_SERVICE_SOLICITATION_UUIDS:       'LIST_OF_128_BIT_SERVICE_SOLICITATION_UUIDS',
-        SERVICE_DATA_16_BIT_UUID:                         'SERVICE_DATA_16_BIT_UUID',
-        PUBLIC_TARGET_ADDRESS:                            'PUBLIC_TARGET_ADDRESS',
-        RANDOM_TARGET_ADDRESS:                            'RANDOM_TARGET_ADDRESS',
-        APPEARANCE:                                       'APPEARANCE',
-        ADVERTISING_INTERVAL:                             'ADVERTISING_INTERVAL',
-        LE_BLUETOOTH_DEVICE_ADDRESS:                      'LE_BLUETOOTH_DEVICE_ADDRESS',
-        LE_ROLE:                                          'LE_ROLE',
-        SIMPLE_PAIRING_HASH_C_256:                        'SIMPLE_PAIRING_HASH_C_256',
-        SIMPLE_PAIRING_RANDOMIZER_R_256:                  'SIMPLE_PAIRING_RANDOMIZER_R_256',
-        LIST_OF_32_BIT_SERVICE_SOLICITATION_UUIDS:        'LIST_OF_32_BIT_SERVICE_SOLICITATION_UUIDS',
-        SERVICE_DATA_32_BIT_UUID:                         'SERVICE_DATA_32_BIT_UUID',
-        SERVICE_DATA_128_BIT_UUID:                        'SERVICE_DATA_128_BIT_UUID',
-        LE_SECURE_CONNECTIONS_CONFIRMATION_VALUE:         'LE_SECURE_CONNECTIONS_CONFIRMATION_VALUE',
-        LE_SECURE_CONNECTIONS_RANDOM_VALUE:               'LE_SECURE_CONNECTIONS_RANDOM_VALUE',
-        URI:                                              'URI',
-        INDOOR_POSITIONING:                               'INDOOR_POSITIONING',
-        TRANSPORT_DISCOVERY_DATA:                         'TRANSPORT_DISCOVERY_DATA',
-        LE_SUPPORTED_FEATURES:                            'LE_SUPPORTED_FEATURES',
-        CHANNEL_MAP_UPDATE_INDICATION:                    'CHANNEL_MAP_UPDATE_INDICATION',
-        PB_ADV:                                           'PB_ADV',
-        MESH_MESSAGE:                                     'MESH_MESSAGE',
-        MESH_BEACON:                                      'MESH_BEACON',
-        BIGINFO:                                          'BIGINFO',
-        BROADCAST_CODE:                                   'BROADCAST_CODE',
-        RESOLVABLE_SET_IDENTIFIER:                        'RESOLVABLE_SET_IDENTIFIER',
-        ADVERTISING_INTERVAL_LONG:                        'ADVERTISING_INTERVAL_LONG',
-        BROADCAST_NAME:                                   'BROADCAST_NAME',
-        ENCRYPTED_ADVERTISING_DATA:                       'ENCRYPTED_ADVERTISING_DATA',
-        PERIODIC_ADVERTISING_RESPONSE_TIMING_INFORMATION: 'PERIODIC_ADVERTISING_RESPONSE_TIMING_INFORMATION',
-        ELECTRONIC_SHELF_LABEL:                           'ELECTRONIC_SHELF_LABEL',
-        THREE_D_INFORMATION_DATA:                         'THREE_D_INFORMATION_DATA',
-        MANUFACTURER_SPECIFIC_DATA:                       'MANUFACTURER_SPECIFIC_DATA'
-    }
-
-    LE_LIMITED_DISCOVERABLE_MODE_FLAG = 0x01
-    LE_GENERAL_DISCOVERABLE_MODE_FLAG = 0x02
-    BR_EDR_NOT_SUPPORTED_FLAG         = 0x04
-    BR_EDR_CONTROLLER_FLAG            = 0x08
-    BR_EDR_HOST_FLAG                  = 0x10
-
-    ad_structures: List[Tuple[int, bytes]]
+    class Type(utils.OpenIntEnum):
+        FLAGS                                               = 0x01
+        INCOMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS       = 0x02
+        COMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS         = 0x03
+        INCOMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS       = 0x04
+        COMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS         = 0x05
+        INCOMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS      = 0x06
+        COMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS        = 0x07
+        SHORTENED_LOCAL_NAME                                = 0x08
+        COMPLETE_LOCAL_NAME                                 = 0x09
+        TX_POWER_LEVEL                                      = 0x0A
+        CLASS_OF_DEVICE                                     = 0x0D
+        SIMPLE_PAIRING_HASH_C                               = 0x0E
+        SIMPLE_PAIRING_HASH_C_192                           = 0x0E
+        SIMPLE_PAIRING_RANDOMIZER_R                         = 0x0F
+        SIMPLE_PAIRING_RANDOMIZER_R_192                     = 0x0F
+        DEVICE_ID                                           = 0x10
+        SECURITY_MANAGER_TK_VALUE                           = 0x10
+        SECURITY_MANAGER_OUT_OF_BAND_FLAGS                  = 0x11
+        PERIPHERAL_CONNECTION_INTERVAL_RANGE                = 0x12
+        LIST_OF_16_BIT_SERVICE_SOLICITATION_UUIDS           = 0x14
+        LIST_OF_128_BIT_SERVICE_SOLICITATION_UUIDS          = 0x15
+        SERVICE_DATA_16_BIT_UUID                            = 0x16
+        PUBLIC_TARGET_ADDRESS                               = 0x17
+        RANDOM_TARGET_ADDRESS                               = 0x18
+        APPEARANCE                                          = 0x19
+        ADVERTISING_INTERVAL                                = 0x1A
+        LE_BLUETOOTH_DEVICE_ADDRESS                         = 0x1B
+        LE_ROLE                                             = 0x1C
+        SIMPLE_PAIRING_HASH_C_256                           = 0x1D
+        SIMPLE_PAIRING_RANDOMIZER_R_256                     = 0x1E
+        LIST_OF_32_BIT_SERVICE_SOLICITATION_UUIDS           = 0x1F
+        SERVICE_DATA_32_BIT_UUID                            = 0x20
+        SERVICE_DATA_128_BIT_UUID                           = 0x21
+        LE_SECURE_CONNECTIONS_CONFIRMATION_VALUE            = 0x22
+        LE_SECURE_CONNECTIONS_RANDOM_VALUE                  = 0x23
+        URI                                                 = 0x24
+        INDOOR_POSITIONING                                  = 0x25
+        TRANSPORT_DISCOVERY_DATA                            = 0x26
+        LE_SUPPORTED_FEATURES                               = 0x27
+        CHANNEL_MAP_UPDATE_INDICATION                       = 0x28
+        PB_ADV                                              = 0x29
+        MESH_MESSAGE                                        = 0x2A
+        MESH_BEACON                                         = 0x2B
+        BIGINFO                                             = 0x2C
+        BROADCAST_CODE                                      = 0x2D
+        RESOLVABLE_SET_IDENTIFIER                           = 0x2E
+        ADVERTISING_INTERVAL_LONG                           = 0x2F
+        BROADCAST_NAME                                      = 0x30
+        ENCRYPTED_ADVERTISING_DATA                          = 0x31
+        PERIODIC_ADVERTISING_RESPONSE_TIMING_INFORMATION    = 0x32
+        ELECTRONIC_SHELF_LABEL                              = 0x34
+        THREE_D_INFORMATION_DATA                            = 0x3D
+        MANUFACTURER_SPECIFIC_DATA                          = 0xFF
+
+    class Flags(enum.IntFlag):
+        LE_LIMITED_DISCOVERABLE_MODE = 1 << 0
+        LE_GENERAL_DISCOVERABLE_MODE = 1 << 1
+        BR_EDR_NOT_SUPPORTED = 1 << 2
+        SIMULTANEOUS_LE_BR_EDR_CAPABLE = 1 << 3
+
+    # For backward-compatibility
+    FLAGS                                            = Type.FLAGS
+    INCOMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS    = Type.INCOMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS
+    COMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS      = Type.COMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS
+    INCOMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS    = Type.INCOMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS
+    COMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS      = Type.COMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS
+    INCOMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS   = Type.INCOMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS
+    COMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS     = Type.COMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS
+    SHORTENED_LOCAL_NAME                             = Type.SHORTENED_LOCAL_NAME
+    COMPLETE_LOCAL_NAME                              = Type.COMPLETE_LOCAL_NAME
+    TX_POWER_LEVEL                                   = Type.TX_POWER_LEVEL
+    CLASS_OF_DEVICE                                  = Type.CLASS_OF_DEVICE
+    SIMPLE_PAIRING_HASH_C                            = Type.SIMPLE_PAIRING_HASH_C
+    SIMPLE_PAIRING_HASH_C_192                        = Type.SIMPLE_PAIRING_HASH_C_192
+    SIMPLE_PAIRING_RANDOMIZER_R                      = Type.SIMPLE_PAIRING_RANDOMIZER_R
+    SIMPLE_PAIRING_RANDOMIZER_R_192                  = Type.SIMPLE_PAIRING_RANDOMIZER_R_192
+    DEVICE_ID                                        = Type.DEVICE_ID
+    SECURITY_MANAGER_TK_VALUE                        = Type.SECURITY_MANAGER_TK_VALUE
+    SECURITY_MANAGER_OUT_OF_BAND_FLAGS               = Type.SECURITY_MANAGER_OUT_OF_BAND_FLAGS
+    PERIPHERAL_CONNECTION_INTERVAL_RANGE             = Type.PERIPHERAL_CONNECTION_INTERVAL_RANGE
+    LIST_OF_16_BIT_SERVICE_SOLICITATION_UUIDS        = Type.LIST_OF_16_BIT_SERVICE_SOLICITATION_UUIDS
+    LIST_OF_128_BIT_SERVICE_SOLICITATION_UUIDS       = Type.LIST_OF_128_BIT_SERVICE_SOLICITATION_UUIDS
+    SERVICE_DATA                                     = Type.SERVICE_DATA_16_BIT_UUID
+    SERVICE_DATA_16_BIT_UUID                         = Type.SERVICE_DATA_16_BIT_UUID
+    PUBLIC_TARGET_ADDRESS                            = Type.PUBLIC_TARGET_ADDRESS
+    RANDOM_TARGET_ADDRESS                            = Type.RANDOM_TARGET_ADDRESS
+    APPEARANCE                                       = Type.APPEARANCE
+    ADVERTISING_INTERVAL                             = Type.ADVERTISING_INTERVAL
+    LE_BLUETOOTH_DEVICE_ADDRESS                      = Type.LE_BLUETOOTH_DEVICE_ADDRESS
+    LE_ROLE                                          = Type.LE_ROLE
+    SIMPLE_PAIRING_HASH_C_256                        = Type.SIMPLE_PAIRING_HASH_C_256
+    SIMPLE_PAIRING_RANDOMIZER_R_256                  = Type.SIMPLE_PAIRING_RANDOMIZER_R_256
+    LIST_OF_32_BIT_SERVICE_SOLICITATION_UUIDS        = Type.LIST_OF_32_BIT_SERVICE_SOLICITATION_UUIDS
+    SERVICE_DATA_32_BIT_UUID                         = Type.SERVICE_DATA_32_BIT_UUID
+    SERVICE_DATA_128_BIT_UUID                        = Type.SERVICE_DATA_128_BIT_UUID
+    LE_SECURE_CONNECTIONS_CONFIRMATION_VALUE         = Type.LE_SECURE_CONNECTIONS_CONFIRMATION_VALUE
+    LE_SECURE_CONNECTIONS_RANDOM_VALUE               = Type.LE_SECURE_CONNECTIONS_RANDOM_VALUE
+    URI                                              = Type.URI
+    INDOOR_POSITIONING                               = Type.INDOOR_POSITIONING
+    TRANSPORT_DISCOVERY_DATA                         = Type.TRANSPORT_DISCOVERY_DATA
+    LE_SUPPORTED_FEATURES                            = Type.LE_SUPPORTED_FEATURES
+    CHANNEL_MAP_UPDATE_INDICATION                    = Type.CHANNEL_MAP_UPDATE_INDICATION
+    PB_ADV                                           = Type.PB_ADV
+    MESH_MESSAGE                                     = Type.MESH_MESSAGE
+    MESH_BEACON                                      = Type.MESH_BEACON
+    BIGINFO                                          = Type.BIGINFO
+    BROADCAST_CODE                                   = Type.BROADCAST_CODE
+    RESOLVABLE_SET_IDENTIFIER                        = Type.RESOLVABLE_SET_IDENTIFIER
+    ADVERTISING_INTERVAL_LONG                        = Type.ADVERTISING_INTERVAL_LONG
+    BROADCAST_NAME                                   = Type.BROADCAST_NAME
+    ENCRYPTED_ADVERTISING_DATA                       = Type.ENCRYPTED_ADVERTISING_DATA
+    PERIODIC_ADVERTISING_RESPONSE_TIMING_INFORMATION = Type.PERIODIC_ADVERTISING_RESPONSE_TIMING_INFORMATION
+    ELECTRONIC_SHELF_LABEL                           = Type.ELECTRONIC_SHELF_LABEL
+    THREE_D_INFORMATION_DATA                         = Type.THREE_D_INFORMATION_DATA
+    MANUFACTURER_SPECIFIC_DATA                       = Type.MANUFACTURER_SPECIFIC_DATA
+
+    LE_LIMITED_DISCOVERABLE_MODE_FLAG = Flags.LE_LIMITED_DISCOVERABLE_MODE
+    LE_GENERAL_DISCOVERABLE_MODE_FLAG = Flags.LE_GENERAL_DISCOVERABLE_MODE
+    BR_EDR_NOT_SUPPORTED_FLAG         = Flags.BR_EDR_NOT_SUPPORTED
+    BR_EDR_CONTROLLER_FLAG            = Flags.SIMULTANEOUS_LE_BR_EDR_CAPABLE
+    BR_EDR_HOST_FLAG                  = 0x10 # Deprecated
+
+    ad_structures: list[tuple[int, bytes]]
 
     # fmt: on
     # pylint: enable=line-too-long
 
-    def __init__(self, ad_structures: Optional[List[Tuple[int, bytes]]] = None) -> None:
+    def __init__(self, ad_structures: Optional[list[tuple[int, bytes]]] = None) -> None:
         if ad_structures is None:
             ad_structures = []
         self.ad_structures = ad_structures[:]
@@ -1444,7 +1451,7 @@ class AdvertisingData:
         return ','.join(bit_flags_to_strings(flags, flag_names))
 
     @staticmethod
-    def uuid_list_to_objects(ad_data: bytes, uuid_size: int) -> List[UUID]:
+    def uuid_list_to_objects(ad_data: bytes, uuid_size: int) -> list[UUID]:
         uuids = []
         offset = 0
         while (offset + uuid_size) <= len(ad_data):
@@ -1461,8 +1468,8 @@ class AdvertisingData:
             ]
         )
 
-    @staticmethod
-    def ad_data_to_string(ad_type, ad_data):
+    @classmethod
+    def ad_data_to_string(cls, ad_type: int, ad_data: bytes) -> str:
         if ad_type == AdvertisingData.FLAGS:
             ad_type_str = 'Flags'
             ad_data_str = AdvertisingData.flags_to_string(ad_data[0], short=True)
@@ -1501,7 +1508,10 @@ class AdvertisingData:
             ad_data_str = f'"{ad_data.decode("utf-8")}"'
         elif ad_type == AdvertisingData.COMPLETE_LOCAL_NAME:
             ad_type_str = 'Complete Local Name'
-            ad_data_str = f'"{ad_data.decode("utf-8")}"'
+            try:
+                ad_data_str = f'"{ad_data.decode("utf-8")}"'
+            except UnicodeDecodeError:
+                ad_data_str = ad_data.hex()
         elif ad_type == AdvertisingData.TX_POWER_LEVEL:
             ad_type_str = 'TX Power Level'
             ad_data_str = str(ad_data[0])
@@ -1518,72 +1528,72 @@ class AdvertisingData:
             ad_type_str = 'Broadcast Name'
             ad_data_str = ad_data.decode('utf-8')
         else:
-            ad_type_str = AdvertisingData.AD_TYPE_NAMES.get(ad_type, f'0x{ad_type:02X}')
+            ad_type_str = AdvertisingData.Type(ad_type).name
             ad_data_str = ad_data.hex()
 
         return f'[{ad_type_str}]: {ad_data_str}'
 
     # pylint: disable=too-many-return-statements
-    @staticmethod
-    def ad_data_to_object(ad_type: int, ad_data: bytes) -> AdvertisingDataObject:
+    @classmethod
+    def ad_data_to_object(cls, ad_type: int, ad_data: bytes) -> AdvertisingDataObject:
         if ad_type in (
-            AdvertisingData.COMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS,
-            AdvertisingData.INCOMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS,
-            AdvertisingData.LIST_OF_16_BIT_SERVICE_SOLICITATION_UUIDS,
+            AdvertisingData.Type.COMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.INCOMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.LIST_OF_16_BIT_SERVICE_SOLICITATION_UUIDS,
         ):
             return AdvertisingData.uuid_list_to_objects(ad_data, 2)
 
         if ad_type in (
-            AdvertisingData.COMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS,
-            AdvertisingData.INCOMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS,
-            AdvertisingData.LIST_OF_32_BIT_SERVICE_SOLICITATION_UUIDS,
+            AdvertisingData.Type.COMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.INCOMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.LIST_OF_32_BIT_SERVICE_SOLICITATION_UUIDS,
         ):
             return AdvertisingData.uuid_list_to_objects(ad_data, 4)
 
         if ad_type in (
-            AdvertisingData.COMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS,
-            AdvertisingData.INCOMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS,
-            AdvertisingData.LIST_OF_128_BIT_SERVICE_SOLICITATION_UUIDS,
+            AdvertisingData.Type.COMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.INCOMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.LIST_OF_128_BIT_SERVICE_SOLICITATION_UUIDS,
         ):
             return AdvertisingData.uuid_list_to_objects(ad_data, 16)
 
-        if ad_type == AdvertisingData.SERVICE_DATA_16_BIT_UUID:
+        if ad_type == AdvertisingData.Type.SERVICE_DATA_16_BIT_UUID:
             return (UUID.from_bytes(ad_data[:2]), ad_data[2:])
 
-        if ad_type == AdvertisingData.SERVICE_DATA_32_BIT_UUID:
+        if ad_type == AdvertisingData.Type.SERVICE_DATA_32_BIT_UUID:
             return (UUID.from_bytes(ad_data[:4]), ad_data[4:])
 
-        if ad_type == AdvertisingData.SERVICE_DATA_128_BIT_UUID:
+        if ad_type == AdvertisingData.Type.SERVICE_DATA_128_BIT_UUID:
             return (UUID.from_bytes(ad_data[:16]), ad_data[16:])
 
         if ad_type in (
-            AdvertisingData.SHORTENED_LOCAL_NAME,
-            AdvertisingData.COMPLETE_LOCAL_NAME,
-            AdvertisingData.URI,
-            AdvertisingData.BROADCAST_NAME,
+            AdvertisingData.Type.SHORTENED_LOCAL_NAME,
+            AdvertisingData.Type.COMPLETE_LOCAL_NAME,
+            AdvertisingData.Type.URI,
+            AdvertisingData.Type.BROADCAST_NAME,
         ):
             return ad_data.decode("utf-8")
 
-        if ad_type in (AdvertisingData.TX_POWER_LEVEL, AdvertisingData.FLAGS):
+        if ad_type in (AdvertisingData.Type.TX_POWER_LEVEL, AdvertisingData.Type.FLAGS):
             return cast(int, struct.unpack('B', ad_data)[0])
 
-        if ad_type in (AdvertisingData.ADVERTISING_INTERVAL,):
+        if ad_type in (AdvertisingData.Type.ADVERTISING_INTERVAL,):
             return cast(int, struct.unpack('<H', ad_data)[0])
 
-        if ad_type == AdvertisingData.CLASS_OF_DEVICE:
+        if ad_type == AdvertisingData.Type.CLASS_OF_DEVICE:
             return cast(int, struct.unpack('<I', bytes([*ad_data, 0]))[0])
 
-        if ad_type == AdvertisingData.PERIPHERAL_CONNECTION_INTERVAL_RANGE:
-            return cast(Tuple[int, int], struct.unpack('<HH', ad_data))
-
-        if ad_type == AdvertisingData.MANUFACTURER_SPECIFIC_DATA:
-            return (cast(int, struct.unpack_from('<H', ad_data, 0)[0]), ad_data[2:])
+        if ad_type == AdvertisingData.Type.PERIPHERAL_CONNECTION_INTERVAL_RANGE:
+            return cast(tuple[int, int], struct.unpack('<HH', ad_data))
 
-        if ad_type == AdvertisingData.APPEARANCE:
+        if ad_type == AdvertisingData.Type.APPEARANCE:
             return Appearance.from_int(
                 cast(int, struct.unpack_from('<H', ad_data, 0)[0])
             )
 
+        if ad_type == AdvertisingData.Type.MANUFACTURER_SPECIFIC_DATA:
+            return (cast(int, struct.unpack_from('<H', ad_data, 0)[0]), ad_data[2:])
+
         return ad_data
 
     def append(self, data: bytes) -> None:
@@ -1597,7 +1607,80 @@ class AdvertisingData:
                 self.ad_structures.append((ad_type, ad_data))
             offset += length
 
-    def get_all(self, type_id: int, raw: bool = False) -> List[AdvertisingDataObject]:
+    @overload
+    def get_all(
+        self,
+        type_id: Literal[
+            AdvertisingData.Type.COMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.INCOMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.LIST_OF_16_BIT_SERVICE_SOLICITATION_UUIDS,
+            AdvertisingData.Type.COMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.INCOMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.LIST_OF_32_BIT_SERVICE_SOLICITATION_UUIDS,
+            AdvertisingData.Type.COMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.INCOMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.LIST_OF_128_BIT_SERVICE_SOLICITATION_UUIDS,
+        ],
+        raw: Literal[False] = False,
+    ) -> list[list[UUID]]: ...
+    @overload
+    def get_all(
+        self,
+        type_id: Literal[
+            AdvertisingData.Type.SERVICE_DATA_16_BIT_UUID,
+            AdvertisingData.Type.SERVICE_DATA_32_BIT_UUID,
+            AdvertisingData.Type.SERVICE_DATA_128_BIT_UUID,
+        ],
+        raw: Literal[False] = False,
+    ) -> list[tuple[UUID, bytes]]: ...
+    @overload
+    def get_all(
+        self,
+        type_id: Literal[
+            AdvertisingData.Type.SHORTENED_LOCAL_NAME,
+            AdvertisingData.Type.COMPLETE_LOCAL_NAME,
+            AdvertisingData.Type.URI,
+            AdvertisingData.Type.BROADCAST_NAME,
+        ],
+        raw: Literal[False] = False,
+    ) -> list[str]: ...
+    @overload
+    def get_all(
+        self,
+        type_id: Literal[
+            AdvertisingData.Type.TX_POWER_LEVEL,
+            AdvertisingData.Type.FLAGS,
+            AdvertisingData.Type.ADVERTISING_INTERVAL,
+            AdvertisingData.Type.CLASS_OF_DEVICE,
+        ],
+        raw: Literal[False] = False,
+    ) -> list[int]: ...
+    @overload
+    def get_all(
+        self,
+        type_id: Literal[AdvertisingData.Type.PERIPHERAL_CONNECTION_INTERVAL_RANGE,],
+        raw: Literal[False] = False,
+    ) -> list[tuple[int, int]]: ...
+    @overload
+    def get_all(
+        self,
+        type_id: Literal[AdvertisingData.Type.MANUFACTURER_SPECIFIC_DATA,],
+        raw: Literal[False] = False,
+    ) -> list[tuple[int, bytes]]: ...
+    @overload
+    def get_all(
+        self,
+        type_id: Literal[AdvertisingData.Type.APPEARANCE,],
+        raw: Literal[False] = False,
+    ) -> list[Appearance]: ...
+    @overload
+    def get_all(self, type_id: int, raw: Literal[True]) -> list[bytes]: ...
+    @overload
+    def get_all(
+        self, type_id: int, raw: bool = False
+    ) -> list[AdvertisingDataObject]: ...
+
+    def get_all(self, type_id: int, raw: bool = False) -> list[AdvertisingDataObject]:  # type: ignore[misc]
         '''
         Get Advertising Data Structure(s) with a given type
 
@@ -1609,6 +1692,79 @@ class AdvertisingData:
 
         return [process_ad_data(ad[1]) for ad in self.ad_structures if ad[0] == type_id]
 
+    @overload
+    def get(
+        self,
+        type_id: Literal[
+            AdvertisingData.Type.COMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.INCOMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.LIST_OF_16_BIT_SERVICE_SOLICITATION_UUIDS,
+            AdvertisingData.Type.COMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.INCOMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.LIST_OF_32_BIT_SERVICE_SOLICITATION_UUIDS,
+            AdvertisingData.Type.COMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.INCOMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS,
+            AdvertisingData.Type.LIST_OF_128_BIT_SERVICE_SOLICITATION_UUIDS,
+        ],
+        raw: Literal[False] = False,
+    ) -> Optional[list[UUID]]: ...
+    @overload
+    def get(
+        self,
+        type_id: Literal[
+            AdvertisingData.Type.SERVICE_DATA_16_BIT_UUID,
+            AdvertisingData.Type.SERVICE_DATA_32_BIT_UUID,
+            AdvertisingData.Type.SERVICE_DATA_128_BIT_UUID,
+        ],
+        raw: Literal[False] = False,
+    ) -> Optional[tuple[UUID, bytes]]: ...
+    @overload
+    def get(
+        self,
+        type_id: Literal[
+            AdvertisingData.Type.SHORTENED_LOCAL_NAME,
+            AdvertisingData.Type.COMPLETE_LOCAL_NAME,
+            AdvertisingData.Type.URI,
+            AdvertisingData.Type.BROADCAST_NAME,
+        ],
+        raw: Literal[False] = False,
+    ) -> Optional[Optional[str]]: ...
+    @overload
+    def get(
+        self,
+        type_id: Literal[
+            AdvertisingData.Type.TX_POWER_LEVEL,
+            AdvertisingData.Type.FLAGS,
+            AdvertisingData.Type.ADVERTISING_INTERVAL,
+            AdvertisingData.Type.CLASS_OF_DEVICE,
+        ],
+        raw: Literal[False] = False,
+    ) -> Optional[int]: ...
+    @overload
+    def get(
+        self,
+        type_id: Literal[AdvertisingData.Type.PERIPHERAL_CONNECTION_INTERVAL_RANGE,],
+        raw: Literal[False] = False,
+    ) -> Optional[tuple[int, int]]: ...
+    @overload
+    def get(
+        self,
+        type_id: Literal[AdvertisingData.Type.MANUFACTURER_SPECIFIC_DATA,],
+        raw: Literal[False] = False,
+    ) -> Optional[tuple[int, bytes]]: ...
+    @overload
+    def get(
+        self,
+        type_id: Literal[AdvertisingData.Type.APPEARANCE,],
+        raw: Literal[False] = False,
+    ) -> Optional[Appearance]: ...
+    @overload
+    def get(self, type_id: int, raw: Literal[True]) -> Optional[bytes]: ...
+    @overload
+    def get(
+        self, type_id: int, raw: bool = False
+    ) -> Optional[AdvertisingDataObject]: ...
+
     def get(self, type_id: int, raw: bool = False) -> Optional[AdvertisingDataObject]:
         '''
         Get Advertising Data Structure(s) with a given type
diff --git a/bumble/crypto.py b/bumble/crypto/__init__.py
similarity index 66%
rename from bumble/crypto.py
rename to bumble/crypto/__init__.py
index af95160..bcefdd9 100644
--- a/bumble/crypto.py
+++ b/bumble/crypto/__init__.py
@@ -1,6 +1,6 @@
-# Copyright 2021-2022 Google LLC
+# Copyright 2021-2025 Google LLC
 #
-# Licensed under the Apache License, Version 2.0 (the "License");
+# Licensed under the Apache License, Version 2.0 (the "License")
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
@@ -12,12 +12,6 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-# -----------------------------------------------------------------------------
-# Crypto support
-#
-# See Bluetooth spec Vol 3, Part H - 2.2 CRYPTOGRAPHIC TOOLBOX
-# -----------------------------------------------------------------------------
-
 # -----------------------------------------------------------------------------
 # Imports
 # -----------------------------------------------------------------------------
@@ -25,19 +19,15 @@ from __future__ import annotations
 
 import logging
 import operator
-
 import secrets
-from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
-from cryptography.hazmat.primitives.asymmetric.ec import (
-    generate_private_key,
-    ECDH,
-    EllipticCurvePrivateKey,
-    EllipticCurvePublicNumbers,
-    EllipticCurvePrivateNumbers,
-    SECP256R1,
-)
-from cryptography.hazmat.primitives import cmac
-from typing import Tuple
+
+try:
+    from bumble.crypto.cryptography import EccKey, e, aes_cmac
+except ImportError:
+    logging.getLogger(__name__).debug(
+        "Unable to import cryptography, use built-in primitives."
+    )
+    from bumble.crypto.builtin import EccKey, e, aes_cmac  # type: ignore[assignment]
 
 
 # -----------------------------------------------------------------------------
@@ -46,55 +36,6 @@ from typing import Tuple
 logger = logging.getLogger(__name__)
 
 
-# -----------------------------------------------------------------------------
-# Classes
-# -----------------------------------------------------------------------------
-class EccKey:
-    def __init__(self, private_key: EllipticCurvePrivateKey) -> None:
-        self.private_key = private_key
-
-    @classmethod
-    def generate(cls) -> EccKey:
-        private_key = generate_private_key(SECP256R1())
-        return cls(private_key)
-
-    @classmethod
-    def from_private_key_bytes(
-        cls, d_bytes: bytes, x_bytes: bytes, y_bytes: bytes
-    ) -> EccKey:
-        d = int.from_bytes(d_bytes, byteorder='big', signed=False)
-        x = int.from_bytes(x_bytes, byteorder='big', signed=False)
-        y = int.from_bytes(y_bytes, byteorder='big', signed=False)
-        private_key = EllipticCurvePrivateNumbers(
-            d, EllipticCurvePublicNumbers(x, y, SECP256R1())
-        ).private_key()
-        return cls(private_key)
-
-    @property
-    def x(self) -> bytes:
-        return (
-            self.private_key.public_key()
-            .public_numbers()
-            .x.to_bytes(32, byteorder='big')
-        )
-
-    @property
-    def y(self) -> bytes:
-        return (
-            self.private_key.public_key()
-            .public_numbers()
-            .y.to_bytes(32, byteorder='big')
-        )
-
-    def dh(self, public_key_x: bytes, public_key_y: bytes) -> bytes:
-        x = int.from_bytes(public_key_x, byteorder='big', signed=False)
-        y = int.from_bytes(public_key_y, byteorder='big', signed=False)
-        public_key = EllipticCurvePublicNumbers(x, y, SECP256R1()).public_key()
-        shared_key = self.private_key.exchange(ECDH(), public_key)
-
-        return shared_key
-
-
 # -----------------------------------------------------------------------------
 # Functions
 # -----------------------------------------------------------------------------
@@ -132,19 +73,6 @@ def r() -> bytes:
     return secrets.token_bytes(16)
 
 
-# -----------------------------------------------------------------------------
-def e(key: bytes, data: bytes) -> bytes:
-    '''
-    AES-128 ECB, expecting byte-swapped inputs and producing a byte-swapped output.
-
-    See Bluetooth spec Vol 3, Part H - 2.2.1 Security function e
-    '''
-
-    cipher = Cipher(algorithms.AES(reverse(key)), modes.ECB())
-    encryptor = cipher.encryptor()
-    return reverse(encryptor.update(reverse(data)))
-
-
 # -----------------------------------------------------------------------------
 def ah(k: bytes, r: bytes) -> bytes:  # pylint: disable=redefined-outer-name
     '''
@@ -187,18 +115,6 @@ def s1(k: bytes, r1: bytes, r2: bytes) -> bytes:
     return e(k, r2[0:8] + r1[0:8])
 
 
-# -----------------------------------------------------------------------------
-def aes_cmac(m: bytes, k: bytes) -> bytes:
-    '''
-    See Bluetooth spec, Vol 3, Part H - 2.2.5 FunctionAES-CMAC
-
-    NOTE: the input and output of this internal function are in big-endian byte order
-    '''
-    mac = cmac.CMAC(algorithms.AES(k))
-    mac.update(m)
-    return mac.finalize()
-
-
 # -----------------------------------------------------------------------------
 def f4(u: bytes, v: bytes, x: bytes, z: bytes) -> bytes:
     '''
@@ -209,7 +125,7 @@ def f4(u: bytes, v: bytes, x: bytes, z: bytes) -> bytes:
 
 
 # -----------------------------------------------------------------------------
-def f5(w: bytes, n1: bytes, n2: bytes, a1: bytes, a2: bytes) -> Tuple[bytes, bytes]:
+def f5(w: bytes, n1: bytes, n2: bytes, a1: bytes, a2: bytes) -> tuple[bytes, bytes]:
     '''
     See Bluetooth spec, Vol 3, Part H - 2.2.7 LE Secure Connections Key Generation
     Function f5
diff --git a/bumble/crypto/builtin.py b/bumble/crypto/builtin.py
new file mode 100644
index 0000000..adf8dd6
--- /dev/null
+++ b/bumble/crypto/builtin.py
@@ -0,0 +1,652 @@
+# Copyright 2021-2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License")
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# The implementation is modified from:
+# * AES - https://github.com/ricmoo/pyaes by Richard Moore under MIT License
+# * CMAC - https://github.com/pycrypto/pycrypto by contributors under pycrypto License.
+
+
+# -----------------------------------------------------------------------------
+# Built-in implementation of cryptography primitives.
+#
+# Note: It's very dangerous to use this library in the real world.
+# -----------------------------------------------------------------------------
+from __future__ import annotations
+
+import dataclasses
+import functools
+import copy
+import secrets
+import struct
+from typing import Optional
+
+from bumble import core
+
+
+def _compact_word(word: bytes) -> int:
+    return int.from_bytes(word, "big")
+
+
+def _shift_bytes(bs: bytes, xor_lsb: int = 0) -> bytes:
+    return ((int.from_bytes(bs, "big") << 1) ^ xor_lsb).to_bytes(len(bs) + 1, "big")[1:]
+
+
+def _xor(a: bytes, b: bytes) -> bytes:
+    return bytes(x ^ y for x, y in zip(a, b))
+
+
+# Based *largely* on the Rijndael implementation
+# See: http://csrc.nist.gov/publications/FIPS/FIPS197/FIPS-197.pdf
+class _AES:
+    '''Encapsulates the AES block cipher.
+
+    You generally should not need this. Use the AESModeOfOperation classes
+    below instead.'''
+
+    # fmt: off
+    # Number of rounds by key size
+    _NUMBER_OF_ROUNDS = {16: 10, 24: 12, 32: 14}
+
+    # Round constant words
+    _RCON = [ 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91 ]
+
+    # S-box and Inverse S-box (S is for Substitution)
+    _S = [ 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 ]
+    _S_INV =[ 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d ] 
+
+    # Transformations for encryption
+    _T1 = [ 0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a ]
+    _T2 = [ 0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616 ]
+    _T3 = [ 0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16 ]
+    _T4 = [ 0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c ]
+
+    # Transformations for decryption
+    _T5 = [ 0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742 ]
+    _T6 = [ 0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857 ]
+    _T7 = [ 0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8 ]
+    _T8 = [ 0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0 ]
+
+    # Transformations for decryption key expansion
+    _U1 = [ 0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3 ]
+    _U2 = [ 0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697 ]
+    _U3 = [ 0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46 ]
+    _U4 = [ 0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d ]
+    # fmt: on
+
+    def __init__(self, key: bytes) -> None:
+
+        if len(key) not in (16, 24, 32):
+            raise core.InvalidArgumentError(f'Invalid key size {len(key)}')
+
+        rounds = self._NUMBER_OF_ROUNDS[len(key)]
+
+        # Encryption round keys
+        self._ke = [[0] * 4 for i in range(rounds + 1)]
+
+        # Decryption round keys
+        self._kd = [[0] * 4 for i in range(rounds + 1)]
+
+        round_key_count = (rounds + 1) * 4
+        kc = len(key) // 4
+
+        # Convert the key into ints
+        tk = [struct.unpack('>i', key[i : i + 4])[0] for i in range(0, len(key), 4)]
+
+        # Copy values into round key arrays
+        for i in range(0, kc):
+            self._ke[i // 4][i % 4] = tk[i]
+            self._kd[rounds - (i // 4)][i % 4] = tk[i]
+
+        # Key expansion (FIPS-197 section 5.2)
+        r_con_pointer = 0
+        t = kc
+        while t < round_key_count:
+
+            tt = tk[kc - 1]
+            tk[0] ^= (
+                (self._S[(tt >> 16) & 0xFF] << 24)
+                ^ (self._S[(tt >> 8) & 0xFF] << 16)
+                ^ (self._S[tt & 0xFF] << 8)
+                ^ self._S[(tt >> 24) & 0xFF]
+                ^ (self._RCON[r_con_pointer] << 24)
+            )
+            r_con_pointer += 1
+
+            if kc != 8:
+                for i in range(1, kc):
+                    tk[i] ^= tk[i - 1]
+
+            # Key expansion for 256-bit keys is "slightly different" (FIPS-197)
+            else:
+                for i in range(1, kc // 2):
+                    tk[i] ^= tk[i - 1]
+                tt = tk[kc // 2 - 1]
+
+                tk[kc // 2] ^= (
+                    self._S[tt & 0xFF]
+                    ^ (self._S[(tt >> 8) & 0xFF] << 8)
+                    ^ (self._S[(tt >> 16) & 0xFF] << 16)
+                    ^ (self._S[(tt >> 24) & 0xFF] << 24)
+                )
+
+                for i in range(kc // 2 + 1, kc):
+                    tk[i] ^= tk[i - 1]
+
+            # Copy values into round key arrays
+            j = 0
+            while j < kc and t < round_key_count:
+                self._ke[t // 4][t % 4] = tk[j]
+                self._kd[rounds - (t // 4)][t % 4] = tk[j]
+                j += 1
+                t += 1
+
+        # Inverse-Cipher-ify the decryption round key (FIPS-197 section 5.3)
+        for r in range(1, rounds):
+            for j in range(0, 4):
+                tt = self._kd[r][j]
+                self._kd[r][j] = (
+                    self._U1[(tt >> 24) & 0xFF]
+                    ^ self._U2[(tt >> 16) & 0xFF]
+                    ^ self._U3[(tt >> 8) & 0xFF]
+                    ^ self._U4[tt & 0xFF]
+                )
+
+    def encrypt(self, plaintext: bytes) -> bytes:
+        """Encrypt a block of plain text using the AES block cipher."""
+
+        if len(plaintext) != 16:
+            raise core.InvalidArgumentError(f'wrong block length {len(plaintext)}')
+
+        rounds = len(self._ke) - 1
+        (s1, s2, s3) = [1, 2, 3]
+        a = [0, 0, 0, 0]
+
+        # Convert plaintext to (ints ^ key)
+        t = [
+            (_compact_word(plaintext[4 * i : 4 * i + 4]) ^ self._ke[0][i])
+            for i in range(0, 4)
+        ]
+
+        # Apply round transforms
+        for r in range(1, rounds):
+            for i in range(0, 4):
+                a[i] = (
+                    self._T1[(t[i] >> 24) & 0xFF]
+                    ^ self._T2[(t[(i + s1) % 4] >> 16) & 0xFF]
+                    ^ self._T3[(t[(i + s2) % 4] >> 8) & 0xFF]
+                    ^ self._T4[t[(i + s3) % 4] & 0xFF]
+                    ^ self._ke[r][i]
+                )
+            t = copy.copy(a)
+
+        # The last round is special
+        result = []
+        for i in range(0, 4):
+            tt = self._ke[rounds][i]
+            result.append((self._S[(t[i] >> 24) & 0xFF] ^ (tt >> 24)) & 0xFF)
+            result.append((self._S[(t[(i + s1) % 4] >> 16) & 0xFF] ^ (tt >> 16)) & 0xFF)
+            result.append((self._S[(t[(i + s2) % 4] >> 8) & 0xFF] ^ (tt >> 8)) & 0xFF)
+            result.append((self._S[t[(i + s3) % 4] & 0xFF] ^ tt) & 0xFF)
+
+        return bytes(result)
+
+    def decrypt(self, cipher_text: bytes) -> bytes:
+        """Decrypt a block of cipher text using the AES block cipher."""
+
+        if len(cipher_text) != 16:
+            raise core.InvalidArgumentError(f'wrong block length {len(cipher_text)}')
+
+        rounds = len(self._kd) - 1
+        (s1, s2, s3) = [3, 2, 1]
+        a = [0, 0, 0, 0]
+
+        # Convert ciphertext to (ints ^ key)
+        t = [
+            (_compact_word(cipher_text[4 * i : 4 * i + 4]) ^ self._kd[0][i])
+            for i in range(0, 4)
+        ]
+
+        # Apply round transforms
+        for r in range(1, rounds):
+            for i in range(0, 4):
+                a[i] = (
+                    self._T5[(t[i] >> 24) & 0xFF]
+                    ^ self._T6[(t[(i + s1) % 4] >> 16) & 0xFF]
+                    ^ self._T7[(t[(i + s2) % 4] >> 8) & 0xFF]
+                    ^ self._T8[t[(i + s3) % 4] & 0xFF]
+                    ^ self._kd[r][i]
+                )
+            t = copy.copy(a)
+
+        # The last round is special
+        result = []
+        for i in range(0, 4):
+            tt = self._kd[rounds][i]
+            result.append((self._S_INV[(t[i] >> 24) & 0xFF] ^ (tt >> 24)) & 0xFF)
+            result.append(
+                (self._S_INV[(t[(i + s1) % 4] >> 16) & 0xFF] ^ (tt >> 16)) & 0xFF
+            )
+            result.append(
+                (self._S_INV[(t[(i + s2) % 4] >> 8) & 0xFF] ^ (tt >> 8)) & 0xFF
+            )
+            result.append((self._S_INV[t[(i + s3) % 4] & 0xFF] ^ tt) & 0xFF)
+
+        return bytes(result)
+
+
+class _ECB:
+    def __init__(self, key: bytes):
+        self._aes = _AES(key)
+
+    def encrypt(self, plaintext: bytes) -> bytes:
+        return b"".join(
+            [
+                self._aes.encrypt(
+                    plaintext[offset : offset + 16].ljust(16, b"\x00")  # Pad 0.
+                )
+                for offset in range(0, len(plaintext), 16)
+            ]
+        )
+
+    def decrypt(self, cipher_text: bytes) -> bytes:
+        return b"".join(
+            [
+                self._aes.encrypt(cipher_text[offset : offset + 16])
+                for offset in range(0, len(cipher_text), 16)
+            ]
+        )
+
+
+class _CBC:
+
+    def __init__(self, key: bytes, iv: bytes = bytes(16)) -> None:
+        if len(iv) != 16:
+            raise core.InvalidArgumentError(
+                f'initialization vector must be 16 bytes, get {len(iv)}'
+            )
+        else:
+            self._last_cipher_block = iv
+        self._aes = _AES(key)
+
+    def encrypt(self, plaintext: bytes) -> bytes:
+        cipher_text = b""
+        for offset in range(0, len(plaintext), 16):
+            pre_cipher_block = _xor(
+                plaintext[offset : offset + 16], self._last_cipher_block
+            )
+            self._last_cipher_block = self._aes.encrypt(pre_cipher_block)
+            cipher_text += self._last_cipher_block
+        return cipher_text
+
+    def decrypt(self, cipher_text: bytes) -> bytes:
+        plaintext = b""
+        for offset in range(0, len(cipher_text), 16):
+            plaintext += _xor(
+                self._aes.decrypt(cipher_text[offset : offset + 16]),
+                self._last_cipher_block,
+            )
+            self._last_cipher_block = cipher_text[offset : offset + 16]
+
+        return plaintext
+
+
+class _CMAC:
+
+    def __init__(
+        self,
+        key: bytes,
+        msg: bytes = bytes(16),
+        mac_len: int = 16,
+        update_after_digest: bool = False,
+    ) -> None:
+        self.digest_size = mac_len
+        self._key = key
+        self._block_size = bs = 16
+        self._mac_tag: Optional[bytes] = None
+        self._update_after_digest = update_after_digest
+
+        # Section 5.3 of NIST SP 800 38B and Appendix B
+        if bs == 8:
+            const_Rb = 0x1B
+            self._max_size = 8 * (2**21)
+        elif bs == 16:
+            const_Rb = 0x87
+            self._max_size = 16 * (2**48)
+        else:
+            raise core.InvalidArgumentError(
+                f"CMAC requires a cipher with a block size of 8 or 16 bytes, not {bs}"
+            )
+
+        # Compute sub-keys
+        zero_block = bytes(bs)
+        self._ecb = _ECB(key)
+        L = self._ecb.encrypt(zero_block)
+        if L[0] & 0x80:
+            self._k1 = _shift_bytes(L, const_Rb)
+        else:
+            self._k1 = _shift_bytes(L)
+        if self._k1[0] & 0x80:
+            self._k2 = _shift_bytes(self._k1, const_Rb)
+        else:
+            self._k2 = _shift_bytes(self._k1)
+
+        # Initialize CBC cipher with zero IV
+        self._cbc = _CBC(key, zero_block)
+
+        # Cache for outstanding data to authenticate
+        self._cache = bytearray(bs)
+        self._cache_n = 0
+
+        # Last piece of cipher text produced
+        self._last_ct = zero_block
+
+        # Last block that was encrypted with AES
+        self._last_pt: Optional[bytes] = None
+
+        # Counter for total message size
+        self._data_size = 0
+
+        if msg:
+            self.update(msg)
+
+    def update(self, msg: bytes) -> _CMAC:
+        """Authenticate the next chunk of message.
+
+        Args:
+            data (byte string/byte array/memoryview): The next chunk of data
+        """
+
+        if self._mac_tag is not None and not self._update_after_digest:
+            raise core.InvalidStateError(
+                "update() cannot be called after digest() or verify()"
+            )
+
+        self._data_size += len(msg)
+        bs = self._block_size
+
+        if self._cache_n > 0:
+            filler = min(bs - self._cache_n, len(msg))
+            self._cache[self._cache_n : self._cache_n + filler] = msg[:filler]
+            self._cache_n += filler
+
+            if self._cache_n < bs:
+                return self
+
+            msg = msg[filler:]
+            self._update(self._cache)
+            self._cache_n = 0
+
+        remain = len(msg) % bs
+        if remain > 0:
+            self._update(msg[:-remain])
+            self._cache[:remain] = msg[-remain:]
+        else:
+            self._update(msg)
+        self._cache_n = remain
+        return self
+
+    def _update(self, data_block: bytes) -> None:
+        """Update a block aligned to the block boundary"""
+
+        bs = self._block_size
+        assert len(data_block) % bs == 0
+
+        if len(data_block) == 0:
+            return
+
+        ct = self._cbc.encrypt(data_block)
+        if len(data_block) == bs:
+            second_last = self._last_ct
+        else:
+            second_last = ct[-bs * 2 : -bs]
+        self._last_ct = ct[-bs:]
+        self._last_pt = _xor(second_last, data_block[-bs:])
+
+    def digest(self) -> bytes:
+
+        bs = self._block_size
+
+        if self._mac_tag is not None and not self._update_after_digest:
+            return self._mac_tag
+
+        if self._data_size > self._max_size:
+            raise core.InvalidArgumentError("MAC is unsafe for this message")
+
+        if self._cache_n == 0 and self._data_size > 0 and self._last_pt:
+            # Last block was full
+            pt = _xor(self._last_pt, self._k1)
+        else:
+            # Last block is partial (or message length is zero)
+            partial = self._cache[:]
+            partial[self._cache_n :] = b'\x80' + b'\x00' * (bs - self._cache_n - 1)
+            pt = _xor(_xor(self._last_ct, partial), self._k2)
+
+        self._mac_tag = self._ecb.encrypt(pt)[: self.digest_size]
+
+        return self._mac_tag
+
+
+# Define the original Point class for clarity and conversion purposes
+@dataclasses.dataclass
+class _Point:
+    """Represents a point on the elliptic curve in affine coordinates."""
+
+    curve: _EllipticCurve
+    x: int = 0
+    y: int = 0
+    infinite: bool = False
+
+
+@dataclasses.dataclass(frozen=True)
+class _JacobianPoint:
+    """Represents a point on the elliptic curve in Jacobian coordinates."""
+
+    curve: _EllipticCurve
+    x: int = 1  # For point at infinity (1:1:0)
+    y: int = 1
+    z: int = 0  # z = 0 indicates point at infinity
+
+    @classmethod
+    def point_at_infinity(cls, curve: _EllipticCurve) -> _JacobianPoint:
+        return _JacobianPoint(curve=curve, x=1, y=1, z=0)
+
+    @classmethod
+    def from_affine(cls, affine_point: _Point) -> _JacobianPoint:
+        if affine_point.infinite:
+            return _JacobianPoint.point_at_infinity(affine_point.curve)
+        # A simple conversion is (x, y, 1)
+        return _JacobianPoint(
+            curve=affine_point.curve, x=affine_point.x, y=affine_point.y, z=1
+        )
+
+    def to_affine(self) -> _Point:
+        if self.z == 0:
+            return _Point(infinite=True, curve=self.curve)
+
+        p = self.curve.p
+        inv_z = pow(self.z, -1, p)
+        affine_x = (self.x * inv_z**2) % p
+        affine_y = (self.y * inv_z**3) % p
+
+        return _Point(curve=self.curve, x=affine_x, y=affine_y, infinite=False)
+
+    def double(self) -> _JacobianPoint:
+        if self.z == 0 or self.y == 0:
+            return _JacobianPoint.point_at_infinity(self.curve)
+
+        s = 4 * self.x * self.y**2
+        m = 3 * self.x**2 + self.curve.a * self.z**4
+        x2 = m**2 - 2 * s
+        y2 = m * (s - x2) - 8 * self.y**4
+        z2 = 2 * self.y * self.z
+        p = self.curve.p
+
+        return _JacobianPoint(curve=self.curve, x=x2 % p, y=y2 % p, z=z2 % p)
+
+    def __add__(self, other: _JacobianPoint) -> _JacobianPoint:
+        if self.z == 0 and other.z == 0:
+            return _JacobianPoint.point_at_infinity(self.curve)
+        elif self.z == 0:
+            return other
+        elif other.z == 0:
+            return self
+
+        x1 = self.x
+        y1 = self.y
+        z1 = self.z
+        x2 = other.x
+        y2 = other.y
+        z2 = other.z
+        p = self.curve.p
+        u1 = (x1 * z2**2) % p
+        u2 = (x2 * z1**2) % p
+        s1 = (y1 * z2**3) % p
+        s2 = (y2 * z1**3) % p
+
+        if u1 == u2:
+            if s1 != s2:
+                return _JacobianPoint.point_at_infinity(self.curve)
+            else:
+                return self.double()
+        else:
+            h = u2 - u1
+            r = s2 - s1
+
+            h3 = h**3 % p
+            u1h2 = (u1 * h**2) % p
+            x3 = r**2 - h3 - 2 * u1h2
+            y3 = r * (u1h2 - x3) - s1 * h3
+            z3 = h * z1 * z2
+
+            return _JacobianPoint(self.curve, x3 % p, y3 % p, z3 % p)
+
+    def __mul__(self, k: int) -> _JacobianPoint:
+        addend = self
+        result = _JacobianPoint.point_at_infinity(self.curve)
+
+        while k > 0:
+            if k % 2 != 0:
+                result = result + addend
+            addend = addend.double()
+            k = k >> 1
+        return result
+
+    def __rmul__(self, k: int) -> _JacobianPoint:
+        return self * k
+
+
+@dataclasses.dataclass
+class _EllipticCurve:
+    p: int
+    a: int
+    b: int
+    n: int
+    g_x: int
+    g_y: int
+
+    _generator_jacobian: _JacobianPoint = dataclasses.field(init=False)
+
+    def __post_init__(self):
+        self._generator_jacobian = _JacobianPoint(
+            curve=self, x=self.g_x, y=self.g_y, z=1
+        )
+
+    @dataclasses.dataclass
+    class PrivateKey:
+        key: int
+        curve: _EllipticCurve
+
+    def generate_private_key(self) -> PrivateKey:
+        """Generates a random private key."""
+        return self.PrivateKey(key=secrets.randbelow(self.n), curve=self)
+
+    def generate_public_key(self, private_key: int) -> _Point:
+        """Generates a public key from a private key using Jacobian coordinates for scalar multiplication."""
+        public_key_jacobian = self._generator_jacobian * private_key
+        return public_key_jacobian.to_affine()
+
+    def ecdh_shared_secret(self, private_key: int, other_public_key: _Point) -> bytes:
+        """Computes the shared secret using ECDH."""
+        other_public_key_jacobian = _JacobianPoint.from_affine(other_public_key)
+        shared_point_jacobian = other_public_key_jacobian * private_key
+        shared_point_affine = shared_point_jacobian.to_affine()
+        if shared_point_affine.infinite:
+            raise core.InvalidPacketError(
+                "Shared secret calculation resulted in the point at infinite"
+            )
+        return shared_point_affine.x.to_bytes(32, 'big')
+
+    @classmethod
+    def SECP256R1(cls) -> _EllipticCurve:
+        p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF
+        a = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC
+        b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B
+        n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551  # Curve order
+        g_x = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296
+        g_y = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5
+
+        return _EllipticCurve(p=p, a=a, b=b, n=n, g_x=g_x, g_y=g_y)
+
+
+class EccKey:
+    def __init__(self, private_key: _EllipticCurve.PrivateKey) -> None:
+        self.private_key = private_key
+
+    @functools.cached_property
+    def x(self) -> bytes:
+        return self.private_key.curve.generate_public_key(
+            self.private_key.key
+        ).x.to_bytes(32, byteorder='big')
+
+    @functools.cached_property
+    def y(self) -> bytes:
+        return self.private_key.curve.generate_public_key(
+            self.private_key.key
+        ).y.to_bytes(32, byteorder='big')
+
+    def dh(self, public_key_x: bytes, public_key_y: bytes) -> bytes:
+        x = int.from_bytes(public_key_x, byteorder='big', signed=False)
+        y = int.from_bytes(public_key_y, byteorder='big', signed=False)
+        return self.private_key.curve.ecdh_shared_secret(
+            self.private_key.key,
+            _Point(x=x, y=y, curve=self.private_key.curve),
+        )
+
+    @classmethod
+    def generate(cls) -> EccKey:
+        return EccKey(_EllipticCurve.SECP256R1().generate_private_key())
+
+    @classmethod
+    def from_private_key_bytes(cls, d_bytes: bytes) -> EccKey:
+        d = int.from_bytes(d_bytes, byteorder='big', signed=False)
+        return EccKey(_EllipticCurve.PrivateKey(d, _EllipticCurve.SECP256R1()))
+
+
+def e(key: bytes, data: bytes) -> bytes:
+    '''
+    AES-128 ECB, expecting byte-swapped inputs and producing a byte-swapped output.
+
+    See Bluetooth spec Vol 3, Part H - 2.2.1 Security function e
+    '''
+
+    return _ECB(key[::-1]).encrypt(data[::-1])[::-1]
+
+
+def aes_cmac(m: bytes, k: bytes) -> bytes:
+    '''
+    See Bluetooth spec, Vol 3, Part H - 2.2.5 FunctionAES-CMAC
+
+    NOTE: the input and output of this internal function are in big-endian byte order
+    '''
+    return _CMAC(key=k, msg=m).digest()
diff --git a/bumble/crypto/cryptography.py b/bumble/crypto/cryptography.py
new file mode 100644
index 0000000..d78c804
--- /dev/null
+++ b/bumble/crypto/cryptography.py
@@ -0,0 +1,84 @@
+# Copyright 2021-2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License")
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from __future__ import annotations
+
+import functools
+
+from cryptography.hazmat.primitives import ciphers
+from cryptography.hazmat.primitives.ciphers import algorithms
+from cryptography.hazmat.primitives.ciphers import modes
+from cryptography.hazmat.primitives.asymmetric import ec
+from cryptography.hazmat.primitives import cmac
+
+
+def e(key: bytes, data: bytes) -> bytes:
+    '''
+    AES-128 ECB, expecting byte-swapped inputs and producing a byte-swapped output.
+
+    See Bluetooth spec Vol 3, Part H - 2.2.1 Security function e
+    '''
+
+    cipher = ciphers.Cipher(algorithms.AES(key[::-1]), modes.ECB())
+    encryptor = cipher.encryptor()
+    return encryptor.update(data[::-1])[::-1]
+
+
+class EccKey:
+    def __init__(self, private_key: ec.EllipticCurvePrivateKey) -> None:
+        self.private_key = private_key
+
+    @classmethod
+    def generate(cls) -> EccKey:
+        return EccKey(ec.generate_private_key(ec.SECP256R1()))
+
+    @classmethod
+    def from_private_key_bytes(cls, d_bytes: bytes) -> EccKey:
+        d = int.from_bytes(d_bytes, byteorder='big', signed=False)
+        return EccKey(ec.derive_private_key(d, ec.SECP256R1()))
+
+    @functools.cached_property
+    def x(self) -> bytes:
+        return (
+            self.private_key.public_key()
+            .public_numbers()
+            .x.to_bytes(32, byteorder='big')
+        )
+
+    @functools.cached_property
+    def y(self) -> bytes:
+        return (
+            self.private_key.public_key()
+            .public_numbers()
+            .y.to_bytes(32, byteorder='big')
+        )
+
+    def dh(self, public_key_x: bytes, public_key_y: bytes) -> bytes:
+        x = int.from_bytes(public_key_x, byteorder='big', signed=False)
+        y = int.from_bytes(public_key_y, byteorder='big', signed=False)
+        return self.private_key.exchange(
+            ec.ECDH(),
+            ec.EllipticCurvePublicNumbers(x, y, ec.SECP256R1()).public_key(),
+        )
+
+
+def aes_cmac(m: bytes, k: bytes) -> bytes:
+    '''
+    See Bluetooth spec, Vol 3, Part H - 2.2.5 FunctionAES-CMAC
+
+    NOTE: the input and output of this internal function are in big-endian byte order
+    '''
+    mac = cmac.CMAC(algorithms.AES(k))
+    mac.update(m)
+    return mac.finalize()
diff --git a/bumble/device.py b/bumble/device.py
index 38d0ca6..da407e4 100644
--- a/bumble/device.py
+++ b/bumble/device.py
@@ -17,7 +17,8 @@
 # -----------------------------------------------------------------------------
 from __future__ import annotations
 import asyncio
-from collections.abc import Iterable
+import collections
+from collections.abc import Iterable, Sequence
 from contextlib import (
     asynccontextmanager,
     AsyncExitStack,
@@ -36,10 +37,9 @@ from typing import (
     Any,
     Callable,
     ClassVar,
+    Deque,
     Dict,
-    List,
     Optional,
-    Tuple,
     Type,
     TypeVar,
     Union,
@@ -49,143 +49,18 @@ from typing import (
 )
 from typing_extensions import Self
 
-from pyee import EventEmitter
 
-from bumble import hci
-from .colors import color
-from .att import ATT_CID, ATT_DEFAULT_MTU, ATT_PDU
-from .gatt import Characteristic, Descriptor, Service
-from .hci import (
-    HCI_AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P_192_TYPE,
-    HCI_AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P_256_TYPE,
-    HCI_CENTRAL_ROLE,
-    HCI_PERIPHERAL_ROLE,
-    HCI_COMMAND_STATUS_PENDING,
-    HCI_CONNECTION_REJECTED_DUE_TO_LIMITED_RESOURCES_ERROR,
-    HCI_DISPLAY_YES_NO_IO_CAPABILITY,
-    HCI_DISPLAY_ONLY_IO_CAPABILITY,
-    HCI_EXTENDED_INQUIRY_MODE,
-    HCI_GENERAL_INQUIRY_LAP,
-    HCI_INVALID_HCI_COMMAND_PARAMETERS_ERROR,
-    HCI_KEYBOARD_ONLY_IO_CAPABILITY,
-    HCI_LE_1M_PHY,
-    HCI_LE_1M_PHY_BIT,
-    HCI_LE_2M_PHY,
-    HCI_LE_CODED_PHY,
-    HCI_LE_CODED_PHY_BIT,
-    HCI_LE_EXTENDED_CREATE_CONNECTION_COMMAND,
-    HCI_LE_RAND_COMMAND,
-    HCI_LE_READ_PHY_COMMAND,
-    HCI_LE_SET_PHY_COMMAND,
-    HCI_MITM_NOT_REQUIRED_GENERAL_BONDING_AUTHENTICATION_REQUIREMENTS,
-    HCI_MITM_NOT_REQUIRED_NO_BONDING_AUTHENTICATION_REQUIREMENTS,
-    HCI_MITM_REQUIRED_GENERAL_BONDING_AUTHENTICATION_REQUIREMENTS,
-    HCI_MITM_REQUIRED_NO_BONDING_AUTHENTICATION_REQUIREMENTS,
-    HCI_NO_INPUT_NO_OUTPUT_IO_CAPABILITY,
-    HCI_OPERATION_CANCELLED_BY_HOST_ERROR,
-    HCI_R2_PAGE_SCAN_REPETITION_MODE,
-    HCI_REMOTE_USER_TERMINATED_CONNECTION_ERROR,
-    HCI_SUCCESS,
-    HCI_WRITE_LE_HOST_SUPPORT_COMMAND,
-    HCI_Accept_Connection_Request_Command,
-    HCI_Authentication_Requested_Command,
-    HCI_Command_Status_Event,
-    HCI_Constant,
-    HCI_Create_Connection_Cancel_Command,
-    HCI_Create_Connection_Command,
-    HCI_Connection_Complete_Event,
-    HCI_Disconnect_Command,
-    HCI_Encryption_Change_Event,
-    HCI_Error,
-    HCI_IO_Capability_Request_Reply_Command,
-    HCI_Inquiry_Cancel_Command,
-    HCI_Inquiry_Command,
-    HCI_IsoDataPacket,
-    HCI_LE_Accept_CIS_Request_Command,
-    HCI_LE_Add_Device_To_Resolving_List_Command,
-    HCI_LE_Advertising_Report_Event,
-    HCI_LE_BIGInfo_Advertising_Report_Event,
-    HCI_LE_Clear_Resolving_List_Command,
-    HCI_LE_Connection_Update_Command,
-    HCI_LE_Create_Connection_Cancel_Command,
-    HCI_LE_Create_Connection_Command,
-    HCI_LE_Create_CIS_Command,
-    HCI_LE_Periodic_Advertising_Create_Sync_Command,
-    HCI_LE_Periodic_Advertising_Create_Sync_Cancel_Command,
-    HCI_LE_Periodic_Advertising_Report_Event,
-    HCI_LE_Periodic_Advertising_Sync_Transfer_Command,
-    HCI_LE_Periodic_Advertising_Terminate_Sync_Command,
-    HCI_LE_Enable_Encryption_Command,
-    HCI_LE_Extended_Advertising_Report_Event,
-    HCI_LE_Extended_Create_Connection_Command,
-    HCI_LE_Rand_Command,
-    HCI_LE_Read_PHY_Command,
-    HCI_LE_Read_Remote_Features_Command,
-    HCI_LE_Reject_CIS_Request_Command,
-    HCI_LE_Remove_Advertising_Set_Command,
-    HCI_LE_Set_Address_Resolution_Enable_Command,
-    HCI_LE_Set_Advertising_Data_Command,
-    HCI_LE_Set_Advertising_Enable_Command,
-    HCI_LE_Set_Advertising_Parameters_Command,
-    HCI_LE_Set_Advertising_Set_Random_Address_Command,
-    HCI_LE_Set_CIG_Parameters_Command,
-    HCI_LE_Set_Data_Length_Command,
-    HCI_LE_Set_Default_PHY_Command,
-    HCI_LE_Set_Extended_Scan_Enable_Command,
-    HCI_LE_Set_Extended_Scan_Parameters_Command,
-    HCI_LE_Set_Extended_Scan_Response_Data_Command,
-    HCI_LE_Set_Extended_Advertising_Data_Command,
-    HCI_LE_Set_Extended_Advertising_Enable_Command,
-    HCI_LE_Set_Extended_Advertising_Parameters_Command,
-    HCI_LE_Set_Host_Feature_Command,
-    HCI_LE_Set_Periodic_Advertising_Enable_Command,
-    HCI_LE_Set_PHY_Command,
-    HCI_LE_Set_Random_Address_Command,
-    HCI_LE_Set_Scan_Enable_Command,
-    HCI_LE_Set_Scan_Parameters_Command,
-    HCI_LE_Set_Scan_Response_Data_Command,
-    HCI_PIN_Code_Request_Reply_Command,
-    HCI_PIN_Code_Request_Negative_Reply_Command,
-    HCI_Read_BD_ADDR_Command,
-    HCI_Read_RSSI_Command,
-    HCI_Reject_Connection_Request_Command,
-    HCI_Remote_Name_Request_Command,
-    HCI_Switch_Role_Command,
-    HCI_Set_Connection_Encryption_Command,
-    HCI_StatusError,
-    HCI_SynchronousDataPacket,
-    HCI_User_Confirmation_Request_Negative_Reply_Command,
-    HCI_User_Confirmation_Request_Reply_Command,
-    HCI_User_Passkey_Request_Negative_Reply_Command,
-    HCI_User_Passkey_Request_Reply_Command,
-    HCI_Write_Class_Of_Device_Command,
-    HCI_Write_Extended_Inquiry_Response_Command,
-    HCI_Write_Inquiry_Mode_Command,
-    HCI_Write_LE_Host_Support_Command,
-    HCI_Write_Local_Name_Command,
-    HCI_Write_Scan_Enable_Command,
-    HCI_Write_Secure_Connections_Host_Support_Command,
-    HCI_Write_Simple_Pairing_Mode_Command,
-    Address,
-    OwnAddressType,
-    LeFeature,
-    LeFeatureMask,
-    LmpFeatureMask,
-    Phy,
-    phy_list_to_bits,
-)
-from .host import Host
-from .profiles.gap import GenericAccessService
-from .core import (
-    BT_BR_EDR_TRANSPORT,
-    BT_CENTRAL_ROLE,
-    BT_LE_TRANSPORT,
-    BT_PERIPHERAL_ROLE,
+from bumble.colors import color
+from bumble.att import ATT_CID, ATT_DEFAULT_MTU, ATT_PDU
+from bumble.gatt import Attribute, Characteristic, Descriptor, Service
+from bumble.host import DataPacketQueue, Host
+from bumble.profiles.gap import GenericAccessService
+from bumble.core import (
+    PhysicalTransport,
     AdvertisingData,
     BaseBumbleError,
     ConnectionParameterUpdateError,
     CommandTimeoutError,
-    ConnectionParameters,
     ConnectionPHY,
     InvalidArgumentError,
     InvalidOperationError,
@@ -194,19 +69,12 @@ from .core import (
     OutOfResourcesError,
     UnreachableError,
 )
-from .utils import (
-    AsyncRunner,
-    CompositeEventEmitter,
-    EventWatcher,
-    setup_event_forwarding,
-    composite_listener,
-    deprecated,
-    experimental,
-)
-from .keys import (
+from bumble import utils
+from bumble.keys import (
     KeyStore,
     PairingKeys,
 )
+from bumble import hci
 from bumble import pairing
 from bumble import gatt_client
 from bumble import gatt_server
@@ -214,9 +82,10 @@ from bumble import smp
 from bumble import sdp
 from bumble import l2cap
 from bumble import core
+from bumble.profiles import gatt_service
 
 if TYPE_CHECKING:
-    from .transport.common import TransportSource, TransportSink
+    from bumble.transport.common import TransportSource, TransportSink
 
 
 # -----------------------------------------------------------------------------
@@ -230,14 +99,18 @@ logger = logging.getLogger(__name__)
 # fmt: off
 # pylint: disable=line-too-long
 
-DEVICE_MIN_SCAN_INTERVAL                      = 25
+DEVICE_MIN_SCAN_INTERVAL                      = 2.5
 DEVICE_MAX_SCAN_INTERVAL                      = 10240
-DEVICE_MIN_SCAN_WINDOW                        = 25
+DEVICE_MIN_SCAN_WINDOW                        = 2.5
 DEVICE_MAX_SCAN_WINDOW                        = 10240
 DEVICE_MIN_LE_RSSI                            = -127
 DEVICE_MAX_LE_RSSI                            = 20
 DEVICE_MIN_EXTENDED_ADVERTISING_SET_HANDLE    = 0x00
 DEVICE_MAX_EXTENDED_ADVERTISING_SET_HANDLE    = 0xEF
+DEVICE_MIN_BIG_HANDLE                         = 0x00
+DEVICE_MAX_BIG_HANDLE                         = 0xEF
+DEVICE_MIN_CS_CONFIG_ID                       = 0x00
+DEVICE_MAX_CS_CONFIG_ID                       = 0x03
 
 DEVICE_DEFAULT_ADDRESS                        = '00:00:00:00:00:00'
 DEVICE_DEFAULT_ADVERTISING_INTERVAL           = 1000  # ms
@@ -262,7 +135,7 @@ DEVICE_DEFAULT_L2CAP_COC_MTU                  = l2cap.L2CAP_LE_CREDIT_BASED_CONN
 DEVICE_DEFAULT_L2CAP_COC_MPS                  = l2cap.L2CAP_LE_CREDIT_BASED_CONNECTION_DEFAULT_MPS
 DEVICE_DEFAULT_L2CAP_COC_MAX_CREDITS          = l2cap.L2CAP_LE_CREDIT_BASED_CONNECTION_DEFAULT_INITIAL_CREDITS
 DEVICE_DEFAULT_ADVERTISING_TX_POWER           = (
-    HCI_LE_Set_Extended_Advertising_Parameters_Command.TX_POWER_NO_PREFERENCE
+    hci.HCI_LE_Set_Extended_Advertising_Parameters_Command.TX_POWER_NO_PREFERENCE
 )
 DEVICE_DEFAULT_PERIODIC_ADVERTISING_SYNC_SKIP = 0
 DEVICE_DEFAULT_PERIODIC_ADVERTISING_SYNC_TIMEOUT = 5.0
@@ -286,8 +159,8 @@ class ObjectLookupError(BaseBumbleError):
 @dataclass
 class Advertisement:
     # Attributes
-    address: Address
-    rssi: int = HCI_LE_Extended_Advertising_Report_Event.RSSI_NOT_AVAILABLE
+    address: hci.Address
+    rssi: int = hci.HCI_LE_Extended_Advertising_Report_Event.RSSI_NOT_AVAILABLE
     is_legacy: bool = False
     is_anonymous: bool = False
     is_connectable: bool = False
@@ -299,17 +172,17 @@ class Advertisement:
     primary_phy: int = 0
     secondary_phy: int = 0
     tx_power: int = (
-        HCI_LE_Extended_Advertising_Report_Event.TX_POWER_INFORMATION_NOT_AVAILABLE
+        hci.HCI_LE_Extended_Advertising_Report_Event.TX_POWER_INFORMATION_NOT_AVAILABLE
     )
     sid: int = 0
     data_bytes: bytes = b''
 
     # Constants
     TX_POWER_NOT_AVAILABLE: ClassVar[int] = (
-        HCI_LE_Extended_Advertising_Report_Event.TX_POWER_INFORMATION_NOT_AVAILABLE
+        hci.HCI_LE_Extended_Advertising_Report_Event.TX_POWER_INFORMATION_NOT_AVAILABLE
     )
     RSSI_NOT_AVAILABLE: ClassVar[int] = (
-        HCI_LE_Extended_Advertising_Report_Event.RSSI_NOT_AVAILABLE
+        hci.HCI_LE_Extended_Advertising_Report_Event.RSSI_NOT_AVAILABLE
     )
 
     def __post_init__(self) -> None:
@@ -317,10 +190,10 @@ class Advertisement:
 
     @classmethod
     def from_advertising_report(cls, report) -> Optional[Advertisement]:
-        if isinstance(report, HCI_LE_Advertising_Report_Event.Report):
+        if isinstance(report, hci.HCI_LE_Advertising_Report_Event.Report):
             return LegacyAdvertisement.from_advertising_report(report)
 
-        if isinstance(report, HCI_LE_Extended_Advertising_Report_Event.Report):
+        if isinstance(report, hci.HCI_LE_Extended_Advertising_Report_Event.Report):
             return ExtendedAdvertisement.from_advertising_report(report)
 
         return None
@@ -336,18 +209,18 @@ class LegacyAdvertisement(Advertisement):
             is_legacy=True,
             is_connectable=report.event_type
             in (
-                HCI_LE_Advertising_Report_Event.ADV_IND,
-                HCI_LE_Advertising_Report_Event.ADV_DIRECT_IND,
+                hci.HCI_LE_Advertising_Report_Event.ADV_IND,
+                hci.HCI_LE_Advertising_Report_Event.ADV_DIRECT_IND,
             ),
             is_directed=report.event_type
-            == HCI_LE_Advertising_Report_Event.ADV_DIRECT_IND,
+            == hci.HCI_LE_Advertising_Report_Event.ADV_DIRECT_IND,
             is_scannable=report.event_type
             in (
-                HCI_LE_Advertising_Report_Event.ADV_IND,
-                HCI_LE_Advertising_Report_Event.ADV_SCAN_IND,
+                hci.HCI_LE_Advertising_Report_Event.ADV_IND,
+                hci.HCI_LE_Advertising_Report_Event.ADV_SCAN_IND,
             ),
             is_scan_response=report.event_type
-            == HCI_LE_Advertising_Report_Event.SCAN_RSP,
+            == hci.HCI_LE_Advertising_Report_Event.SCAN_RSP,
             data_bytes=report.data,
         )
 
@@ -361,19 +234,19 @@ class ExtendedAdvertisement(Advertisement):
         return cls(
             address          = report.address,
             rssi             = report.rssi,
-            is_legacy        = report.event_type & (1 << HCI_LE_Extended_Advertising_Report_Event.LEGACY_ADVERTISING_PDU_USED) != 0,
-            is_anonymous     = report.address.address_type == HCI_LE_Extended_Advertising_Report_Event.ANONYMOUS_ADDRESS_TYPE,
-            is_connectable   = report.event_type & (1 << HCI_LE_Extended_Advertising_Report_Event.CONNECTABLE_ADVERTISING) != 0,
-            is_directed      = report.event_type & (1 << HCI_LE_Extended_Advertising_Report_Event.DIRECTED_ADVERTISING) != 0,
-            is_scannable     = report.event_type & (1 << HCI_LE_Extended_Advertising_Report_Event.SCANNABLE_ADVERTISING) != 0,
-            is_scan_response = report.event_type & (1 << HCI_LE_Extended_Advertising_Report_Event.SCAN_RESPONSE) != 0,
-            is_complete      = (report.event_type >> 5 & 3)  == HCI_LE_Extended_Advertising_Report_Event.DATA_COMPLETE,
-            is_truncated     = (report.event_type >> 5 & 3)  == HCI_LE_Extended_Advertising_Report_Event.DATA_INCOMPLETE_TRUNCATED_NO_MORE_TO_COME,
+            is_legacy        = report.event_type & (1 << hci.HCI_LE_Extended_Advertising_Report_Event.LEGACY_ADVERTISING_PDU_USED) != 0,
+            is_anonymous     = report.address.address_type == hci.HCI_LE_Extended_Advertising_Report_Event.ANONYMOUS_ADDRESS_TYPE,
+            is_connectable   = report.event_type & (1 << hci.HCI_LE_Extended_Advertising_Report_Event.CONNECTABLE_ADVERTISING) != 0,
+            is_directed      = report.event_type & (1 << hci.HCI_LE_Extended_Advertising_Report_Event.DIRECTED_ADVERTISING) != 0,
+            is_scannable     = report.event_type & (1 << hci.HCI_LE_Extended_Advertising_Report_Event.SCANNABLE_ADVERTISING) != 0,
+            is_scan_response = report.event_type & (1 << hci.HCI_LE_Extended_Advertising_Report_Event.SCAN_RESPONSE) != 0,
+            is_complete      = (report.event_type >> 5 & 3)  == hci.HCI_LE_Extended_Advertising_Report_Event.DATA_COMPLETE,
+            is_truncated     = (report.event_type >> 5 & 3)  == hci.HCI_LE_Extended_Advertising_Report_Event.DATA_INCOMPLETE_TRUNCATED_NO_MORE_TO_COME,
             primary_phy      = report.primary_phy,
             secondary_phy    = report.secondary_phy,
             tx_power         = report.tx_power,
             sid              = report.advertising_sid,
-            data_bytes       = report.data
+            data_bytes       = report.data,
         )
         # fmt: on
 
@@ -473,15 +346,15 @@ class AdvertisingType(IntEnum):
 class LegacyAdvertiser:
     device: Device
     advertising_type: AdvertisingType
-    own_address_type: OwnAddressType
-    peer_address: Address
+    own_address_type: hci.OwnAddressType
+    peer_address: hci.Address
     auto_restart: bool
 
     async def start(self) -> None:
         # Set/update the advertising data if the advertising type allows it
         if self.advertising_type.has_data:
             await self.device.send_command(
-                HCI_LE_Set_Advertising_Data_Command(
+                hci.HCI_LE_Set_Advertising_Data_Command(
                     advertising_data=self.device.advertising_data
                 ),
                 check_result=True,
@@ -490,7 +363,7 @@ class LegacyAdvertiser:
         # Set/update the scan response data if the advertising is scannable
         if self.advertising_type.is_scannable:
             await self.device.send_command(
-                HCI_LE_Set_Scan_Response_Data_Command(
+                hci.HCI_LE_Set_Scan_Response_Data_Command(
                     scan_response_data=self.device.scan_response_data
                 ),
                 check_result=True,
@@ -498,9 +371,13 @@ class LegacyAdvertiser:
 
         # Set the advertising parameters
         await self.device.send_command(
-            HCI_LE_Set_Advertising_Parameters_Command(
-                advertising_interval_min=self.device.advertising_interval_min,
-                advertising_interval_max=self.device.advertising_interval_max,
+            hci.HCI_LE_Set_Advertising_Parameters_Command(
+                advertising_interval_min=int(
+                    self.device.advertising_interval_min / 0.625
+                ),
+                advertising_interval_max=int(
+                    self.device.advertising_interval_max / 0.625
+                ),
                 advertising_type=int(self.advertising_type),
                 own_address_type=self.own_address_type,
                 peer_address_type=self.peer_address.address_type,
@@ -513,14 +390,14 @@ class LegacyAdvertiser:
 
         # Enable advertising
         await self.device.send_command(
-            HCI_LE_Set_Advertising_Enable_Command(advertising_enable=1),
+            hci.HCI_LE_Set_Advertising_Enable_Command(advertising_enable=1),
             check_result=True,
         )
 
     async def stop(self) -> None:
         # Disable advertising
         await self.device.send_command(
-            HCI_LE_Set_Advertising_Enable_Command(advertising_enable=0),
+            hci.HCI_LE_Set_Advertising_Enable_Command(advertising_enable=0),
             check_result=True,
         )
 
@@ -537,8 +414,8 @@ class AdvertisingEventProperties:
     include_tx_power: bool = False
 
     def __int__(self) -> int:
-        properties = (
-            HCI_LE_Set_Extended_Advertising_Parameters_Command.AdvertisingProperties(0)
+        properties = hci.HCI_LE_Set_Extended_Advertising_Parameters_Command.AdvertisingProperties(
+            0
         )
         if self.is_connectable:
             properties |= properties.CONNECTABLE_ADVERTISING
@@ -576,21 +453,21 @@ class AdvertisingEventProperties:
 # -----------------------------------------------------------------------------
 @dataclass
 class PeriodicAdvertisement:
-    address: Address
+    address: hci.Address
     sid: int
     tx_power: int = (
-        HCI_LE_Periodic_Advertising_Report_Event.TX_POWER_INFORMATION_NOT_AVAILABLE
+        hci.HCI_LE_Periodic_Advertising_Report_Event.TX_POWER_INFORMATION_NOT_AVAILABLE
     )
-    rssi: int = HCI_LE_Periodic_Advertising_Report_Event.RSSI_NOT_AVAILABLE
+    rssi: int = hci.HCI_LE_Periodic_Advertising_Report_Event.RSSI_NOT_AVAILABLE
     is_truncated: bool = False
     data_bytes: bytes = b''
 
     # Constants
     TX_POWER_NOT_AVAILABLE: ClassVar[int] = (
-        HCI_LE_Periodic_Advertising_Report_Event.TX_POWER_INFORMATION_NOT_AVAILABLE
+        hci.HCI_LE_Periodic_Advertising_Report_Event.TX_POWER_INFORMATION_NOT_AVAILABLE
     )
     RSSI_NOT_AVAILABLE: ClassVar[int] = (
-        HCI_LE_Periodic_Advertising_Report_Event.RSSI_NOT_AVAILABLE
+        hci.HCI_LE_Periodic_Advertising_Report_Event.RSSI_NOT_AVAILABLE
     )
 
     def __post_init__(self) -> None:
@@ -602,36 +479,36 @@ class PeriodicAdvertisement:
 # -----------------------------------------------------------------------------
 @dataclass
 class BIGInfoAdvertisement:
-    address: Address
+    address: hci.Address
     sid: int
     num_bis: int
     nse: int
-    iso_interval: int
+    iso_interval: float
     bn: int
     pto: int
     irc: int
     max_pdu: int
     sdu_interval: int
     max_sdu: int
-    phy: Phy
+    phy: hci.Phy
     framed: bool
     encrypted: bool
 
     @classmethod
-    def from_report(cls, address: Address, sid: int, report) -> Self:
+    def from_report(cls, address: hci.Address, sid: int, report) -> Self:
         return cls(
             address,
             sid,
             report.num_bis,
             report.nse,
-            report.iso_interval,
+            report.iso_interval * 1.25,
             report.bn,
             report.pto,
             report.irc,
             report.max_pdu,
             report.sdu_interval,
             report.max_sdu,
-            Phy(report.phy),
+            hci.Phy(report.phy),
             report.framing != 0,
             report.encryption != 0,
         )
@@ -639,7 +516,9 @@ class BIGInfoAdvertisement:
 
 # -----------------------------------------------------------------------------
 # TODO: replace with typing.TypeAlias when the code base is all Python >= 3.10
-AdvertisingChannelMap = HCI_LE_Set_Extended_Advertising_Parameters_Command.ChannelMap
+AdvertisingChannelMap = (
+    hci.HCI_LE_Set_Extended_Advertising_Parameters_Command.ChannelMap
+)
 
 
 # -----------------------------------------------------------------------------
@@ -649,22 +528,22 @@ class AdvertisingParameters:
     advertising_event_properties: AdvertisingEventProperties = field(
         default_factory=AdvertisingEventProperties
     )
-    primary_advertising_interval_min: int = DEVICE_DEFAULT_ADVERTISING_INTERVAL
-    primary_advertising_interval_max: int = DEVICE_DEFAULT_ADVERTISING_INTERVAL
+    primary_advertising_interval_min: float = DEVICE_DEFAULT_ADVERTISING_INTERVAL
+    primary_advertising_interval_max: float = DEVICE_DEFAULT_ADVERTISING_INTERVAL
     primary_advertising_channel_map: (
-        HCI_LE_Set_Extended_Advertising_Parameters_Command.ChannelMap
+        hci.HCI_LE_Set_Extended_Advertising_Parameters_Command.ChannelMap
     ) = (
         AdvertisingChannelMap.CHANNEL_37
         | AdvertisingChannelMap.CHANNEL_38
         | AdvertisingChannelMap.CHANNEL_39
     )
-    own_address_type: OwnAddressType = OwnAddressType.RANDOM
-    peer_address: Address = Address.ANY
+    own_address_type: hci.OwnAddressType = hci.OwnAddressType.RANDOM
+    peer_address: hci.Address = hci.Address.ANY
     advertising_filter_policy: int = 0
     advertising_tx_power: int = DEVICE_DEFAULT_ADVERTISING_TX_POWER
-    primary_advertising_phy: Phy = Phy.LE_1M
+    primary_advertising_phy: hci.Phy = hci.Phy.LE_1M
     secondary_advertising_max_skip: int = 0
-    secondary_advertising_phy: Phy = Phy.LE_1M
+    secondary_advertising_phy: hci.Phy = hci.Phy.LE_1M
     advertising_sid: int = 0
     enable_scan_request_notifications: bool = False
     primary_advertising_phy_options: int = 0
@@ -674,17 +553,24 @@ class AdvertisingParameters:
 # -----------------------------------------------------------------------------
 @dataclass
 class PeriodicAdvertisingParameters:
-    # TODO implement this class
-    pass
+    periodic_advertising_interval_min: float = DEVICE_DEFAULT_ADVERTISING_INTERVAL
+    periodic_advertising_interval_max: float = DEVICE_DEFAULT_ADVERTISING_INTERVAL
+    periodic_advertising_properties: (
+        hci.HCI_LE_Set_Periodic_Advertising_Parameters_Command.Properties
+    ) = field(
+        default_factory=lambda: hci.HCI_LE_Set_Periodic_Advertising_Parameters_Command.Properties(
+            0
+        )
+    )
 
 
 # -----------------------------------------------------------------------------
 @dataclass
-class AdvertisingSet(EventEmitter):
+class AdvertisingSet(utils.EventEmitter):
     device: Device
     advertising_handle: int
     auto_restart: bool
-    random_address: Optional[Address]
+    random_address: Optional[hci.Address]
     advertising_parameters: AdvertisingParameters
     advertising_data: bytes
     scan_response_data: bytes
@@ -692,6 +578,13 @@ class AdvertisingSet(EventEmitter):
     periodic_advertising_data: bytes
     selected_tx_power: int = 0
     enabled: bool = False
+    periodic_enabled: bool = False
+
+    EVENT_START = "start"
+    EVENT_STOP = "stop"
+    EVENT_START_PERIODIC = "start_periodic"
+    EVENT_STOP_PERIODIC = "stop_periodic"
+    EVENT_TERMINATION = "termination"
 
     def __post_init__(self) -> None:
         super().__init__()
@@ -711,7 +604,7 @@ class AdvertisingSet(EventEmitter):
             )
 
         response = await self.device.send_command(
-            HCI_LE_Set_Extended_Advertising_Parameters_Command(
+            hci.HCI_LE_Set_Extended_Advertising_Parameters_Command(
                 advertising_handle=self.advertising_handle,
                 advertising_event_properties=int(
                     advertising_parameters.advertising_event_properties
@@ -720,7 +613,7 @@ class AdvertisingSet(EventEmitter):
                     int(advertising_parameters.primary_advertising_interval_min / 0.625)
                 ),
                 primary_advertising_interval_max=(
-                    int(advertising_parameters.primary_advertising_interval_min / 0.625)
+                    int(advertising_parameters.primary_advertising_interval_max / 0.625)
                 ),
                 primary_advertising_channel_map=int(
                     advertising_parameters.primary_advertising_channel_map
@@ -752,10 +645,10 @@ class AdvertisingSet(EventEmitter):
     async def set_advertising_data(self, advertising_data: bytes) -> None:
         # pylint: disable=line-too-long
         await self.device.send_command(
-            HCI_LE_Set_Extended_Advertising_Data_Command(
+            hci.HCI_LE_Set_Extended_Advertising_Data_Command(
                 advertising_handle=self.advertising_handle,
-                operation=HCI_LE_Set_Extended_Advertising_Data_Command.Operation.COMPLETE_DATA,
-                fragment_preference=HCI_LE_Set_Extended_Advertising_Parameters_Command.SHOULD_NOT_FRAGMENT,
+                operation=hci.HCI_LE_Set_Extended_Advertising_Data_Command.Operation.COMPLETE_DATA,
+                fragment_preference=hci.HCI_LE_Set_Extended_Advertising_Parameters_Command.SHOULD_NOT_FRAGMENT,
                 advertising_data=advertising_data,
             ),
             check_result=True,
@@ -775,10 +668,10 @@ class AdvertisingSet(EventEmitter):
             return
 
         await self.device.send_command(
-            HCI_LE_Set_Extended_Scan_Response_Data_Command(
+            hci.HCI_LE_Set_Extended_Scan_Response_Data_Command(
                 advertising_handle=self.advertising_handle,
-                operation=HCI_LE_Set_Extended_Advertising_Data_Command.Operation.COMPLETE_DATA,
-                fragment_preference=HCI_LE_Set_Extended_Advertising_Parameters_Command.SHOULD_NOT_FRAGMENT,
+                operation=hci.HCI_LE_Set_Extended_Advertising_Data_Command.Operation.COMPLETE_DATA,
+                fragment_preference=hci.HCI_LE_Set_Extended_Advertising_Parameters_Command.SHOULD_NOT_FRAGMENT,
                 scan_response_data=scan_response_data,
             ),
             check_result=True,
@@ -788,16 +681,35 @@ class AdvertisingSet(EventEmitter):
     async def set_periodic_advertising_parameters(
         self, advertising_parameters: PeriodicAdvertisingParameters
     ) -> None:
-        # TODO: send command
+        await self.device.send_command(
+            hci.HCI_LE_Set_Periodic_Advertising_Parameters_Command(
+                advertising_handle=self.advertising_handle,
+                periodic_advertising_interval_min=int(
+                    advertising_parameters.periodic_advertising_interval_min / 1.25
+                ),
+                periodic_advertising_interval_max=int(
+                    advertising_parameters.periodic_advertising_interval_max / 1.25
+                ),
+                periodic_advertising_properties=advertising_parameters.periodic_advertising_properties,
+            ),
+            check_result=True,
+        )
         self.periodic_advertising_parameters = advertising_parameters
 
     async def set_periodic_advertising_data(self, advertising_data: bytes) -> None:
-        # TODO: send command
+        await self.device.send_command(
+            hci.HCI_LE_Set_Periodic_Advertising_Data_Command(
+                advertising_handle=self.advertising_handle,
+                operation=hci.HCI_LE_Set_Extended_Advertising_Data_Command.Operation.COMPLETE_DATA,
+                advertising_data=advertising_data,
+            ),
+            check_result=True,
+        )
         self.periodic_advertising_data = advertising_data
 
-    async def set_random_address(self, random_address: Address) -> None:
+    async def set_random_address(self, random_address: hci.Address) -> None:
         await self.device.send_command(
-            HCI_LE_Set_Advertising_Set_Random_Address_Command(
+            hci.HCI_LE_Set_Advertising_Set_Random_Address_Command(
                 advertising_handle=self.advertising_handle,
                 random_address=(random_address or self.device.random_address),
             ),
@@ -818,7 +730,7 @@ class AdvertisingSet(EventEmitter):
           (the default) for an unlimited number of advertisements.
         """
         await self.device.send_command(
-            HCI_LE_Set_Extended_Advertising_Enable_Command(
+            hci.HCI_LE_Set_Extended_Advertising_Enable_Command(
                 enable=1,
                 advertising_handles=[self.advertising_handle],
                 durations=[round(duration * 100)],
@@ -828,22 +740,11 @@ class AdvertisingSet(EventEmitter):
         )
         self.enabled = True
 
-        self.emit('start')
-
-    async def start_periodic(self, include_adi: bool = False) -> None:
-        await self.device.send_command(
-            HCI_LE_Set_Periodic_Advertising_Enable_Command(
-                enable=1 | (2 if include_adi else 0),
-                advertising_handles=self.advertising_handle,
-            ),
-            check_result=True,
-        )
-
-        self.emit('start_periodic')
+        self.emit(self.EVENT_START)
 
     async def stop(self) -> None:
         await self.device.send_command(
-            HCI_LE_Set_Extended_Advertising_Enable_Command(
+            hci.HCI_LE_Set_Extended_Advertising_Enable_Command(
                 enable=0,
                 advertising_handles=[self.advertising_handle],
                 durations=[0],
@@ -853,35 +754,63 @@ class AdvertisingSet(EventEmitter):
         )
         self.enabled = False
 
-        self.emit('stop')
+        self.emit(self.EVENT_STOP)
+
+    async def start_periodic(self, include_adi: bool = False) -> None:
+        if self.periodic_enabled:
+            return
+        await self.device.send_command(
+            hci.HCI_LE_Set_Periodic_Advertising_Enable_Command(
+                enable=1 | (2 if include_adi else 0),
+                advertising_handle=self.advertising_handle,
+            ),
+            check_result=True,
+        )
+        self.periodic_enabled = True
+
+        self.emit(self.EVENT_START_PERIODIC)
 
     async def stop_periodic(self) -> None:
+        if not self.periodic_enabled:
+            return
         await self.device.send_command(
-            HCI_LE_Set_Periodic_Advertising_Enable_Command(
+            hci.HCI_LE_Set_Periodic_Advertising_Enable_Command(
                 enable=0,
-                advertising_handles=self.advertising_handle,
+                advertising_handle=self.advertising_handle,
             ),
             check_result=True,
         )
+        self.periodic_enabled = False
 
-        self.emit('stop_periodic')
+        self.emit(self.EVENT_STOP_PERIODIC)
 
     async def remove(self) -> None:
         await self.device.send_command(
-            HCI_LE_Remove_Advertising_Set_Command(
+            hci.HCI_LE_Remove_Advertising_Set_Command(
                 advertising_handle=self.advertising_handle
             ),
             check_result=True,
         )
         del self.device.extended_advertising_sets[self.advertising_handle]
 
+    async def transfer_periodic_info(
+        self, connection: Connection, service_data: int = 0
+    ) -> None:
+        if not self.periodic_enabled:
+            raise core.InvalidStateError(
+                f"Periodic Advertising is not enabled on Advertising Set 0x{self.advertising_handle:02X}"
+            )
+        await connection.transfer_periodic_set_info(
+            self.advertising_handle, service_data
+        )
+
     def on_termination(self, status: int) -> None:
         self.enabled = False
-        self.emit('termination', status)
+        self.emit(self.EVENT_TERMINATION, status)
 
 
 # -----------------------------------------------------------------------------
-class PeriodicAdvertisingSync(EventEmitter):
+class PeriodicAdvertisingSync(utils.EventEmitter):
     class State(Enum):
         INIT = 0
         PENDING = 1
@@ -893,20 +822,28 @@ class PeriodicAdvertisingSync(EventEmitter):
 
     _state: State
     sync_handle: Optional[int]
-    advertiser_address: Address
+    advertiser_address: hci.Address
     sid: int
     skip: int
     sync_timeout: float  # Sync timeout, in seconds
     filter_duplicates: bool
     status: int
     advertiser_phy: int
-    periodic_advertising_interval: int
+    periodic_advertising_interval: float  # Advertising interval, in milliseconds
     advertiser_clock_accuracy: int
 
+    EVENT_STATE_CHANGE = "state_change"
+    EVENT_ESTABLISHMENT = "establishment"
+    EVENT_CANCELLATION = "cancellation"
+    EVENT_ERROR = "error"
+    EVENT_LOSS = "loss"
+    EVENT_PERIODIC_ADVERTISEMENT = "periodic_advertisement"
+    EVENT_BIGINFO_ADVERTISEMENT = "biginfo_advertisement"
+
     def __init__(
         self,
         device: Device,
-        advertiser_address: Address,
+        advertiser_address: hci.Address,
         sid: int,
         skip: int,
         sync_timeout: float,
@@ -921,7 +858,7 @@ class PeriodicAdvertisingSync(EventEmitter):
         self.skip = skip
         self.sync_timeout = sync_timeout
         self.filter_duplicates = filter_duplicates
-        self.status = HCI_SUCCESS
+        self.status = hci.HCI_SUCCESS
         self.advertiser_phy = 0
         self.periodic_advertising_interval = 0
         self.advertiser_clock_accuracy = 0
@@ -935,20 +872,20 @@ class PeriodicAdvertisingSync(EventEmitter):
     def state(self, state: State) -> None:
         logger.debug(f'{self} -> {state.name}')
         self._state = state
-        self.emit('state_change')
+        self.emit(self.EVENT_STATE_CHANGE)
 
     async def establish(self) -> None:
         if self.state != self.State.INIT:
             raise InvalidStateError('sync not in init state')
 
-        options = HCI_LE_Periodic_Advertising_Create_Sync_Command.Options(0)
+        options = hci.HCI_LE_Periodic_Advertising_Create_Sync_Command.Options(0)
         if self.filter_duplicates:
             options |= (
-                HCI_LE_Periodic_Advertising_Create_Sync_Command.Options.DUPLICATE_FILTERING_INITIALLY_ENABLED
+                hci.HCI_LE_Periodic_Advertising_Create_Sync_Command.Options.DUPLICATE_FILTERING_INITIALLY_ENABLED
             )
 
         response = await self.device.send_command(
-            HCI_LE_Periodic_Advertising_Create_Sync_Command(
+            hci.HCI_LE_Periodic_Advertising_Create_Sync_Command(
                 options=options,
                 advertising_sid=self.sid,
                 advertiser_address_type=self.advertiser_address.address_type,
@@ -958,8 +895,8 @@ class PeriodicAdvertisingSync(EventEmitter):
                 sync_cte_type=0,
             )
         )
-        if response.status != HCI_Command_Status_Event.PENDING:
-            raise HCI_StatusError(response)
+        if response.status != hci.HCI_Command_Status_Event.PENDING:
+            raise hci.HCI_StatusError(response)
 
         self.state = self.State.PENDING
 
@@ -970,9 +907,9 @@ class PeriodicAdvertisingSync(EventEmitter):
         if self.state == self.State.PENDING:
             self.state = self.State.CANCELLED
             response = await self.device.send_command(
-                HCI_LE_Periodic_Advertising_Create_Sync_Cancel_Command(),
+                hci.HCI_LE_Periodic_Advertising_Create_Sync_Cancel_Command(),
             )
-            if response.return_parameters == HCI_SUCCESS:
+            if response.return_parameters == hci.HCI_SUCCESS:
                 if self in self.device.periodic_advertising_syncs:
                     self.device.periodic_advertising_syncs.remove(self)
             return
@@ -981,7 +918,7 @@ class PeriodicAdvertisingSync(EventEmitter):
             self.state = self.State.TERMINATED
             if self.sync_handle is not None:
                 await self.device.send_command(
-                    HCI_LE_Periodic_Advertising_Terminate_Sync_Command(
+                    hci.HCI_LE_Periodic_Advertising_Terminate_Sync_Command(
                         sync_handle=self.sync_handle
                     )
                 )
@@ -993,11 +930,11 @@ class PeriodicAdvertisingSync(EventEmitter):
 
     def on_establishment(
         self,
-        status,
-        sync_handle,
-        advertiser_phy,
-        periodic_advertising_interval,
-        advertiser_clock_accuracy,
+        status: int,
+        sync_handle: int,
+        advertiser_phy: int,
+        periodic_advertising_interval: int,
+        advertiser_clock_accuracy: int,
     ) -> None:
         self.status = status
 
@@ -1010,44 +947,44 @@ class PeriodicAdvertisingSync(EventEmitter):
                 "received established event for cancelled sync, will terminate"
             )
             self.state = self.State.ESTABLISHED
-            AsyncRunner.spawn(self.terminate())
+            utils.AsyncRunner.spawn(self.terminate())
             return
 
-        if status == HCI_SUCCESS:
+        if status == hci.HCI_SUCCESS:
             self.sync_handle = sync_handle
             self.advertiser_phy = advertiser_phy
-            self.periodic_advertising_interval = periodic_advertising_interval
+            self.periodic_advertising_interval = periodic_advertising_interval * 1.25
             self.advertiser_clock_accuracy = advertiser_clock_accuracy
             self.state = self.State.ESTABLISHED
-            self.emit('establishment')
+            self.emit(self.EVENT_ESTABLISHMENT)
             return
 
         # We don't need to keep a reference anymore
         if self in self.device.periodic_advertising_syncs:
             self.device.periodic_advertising_syncs.remove(self)
 
-        if status == HCI_OPERATION_CANCELLED_BY_HOST_ERROR:
+        if status == hci.HCI_OPERATION_CANCELLED_BY_HOST_ERROR:
             self.state = self.State.CANCELLED
-            self.emit('cancellation')
+            self.emit(self.EVENT_CANCELLATION)
             return
 
         self.state = self.State.ERROR
-        self.emit('error')
+        self.emit(self.EVENT_ERROR)
 
     def on_loss(self):
         self.state = self.State.LOST
-        self.emit('loss')
+        self.emit(self.EVENT_LOSS)
 
     def on_periodic_advertising_report(self, report) -> None:
         self.data_accumulator += report.data
         if (
             report.data_status
-            == HCI_LE_Periodic_Advertising_Report_Event.DataStatus.DATA_INCOMPLETE_MORE_TO_COME
+            == hci.HCI_LE_Periodic_Advertising_Report_Event.DataStatus.DATA_INCOMPLETE_MORE_TO_COME
         ):
             return
 
         self.emit(
-            'periodic_advertisement',
+            self.EVENT_PERIODIC_ADVERTISEMENT,
             PeriodicAdvertisement(
                 self.advertiser_address,
                 self.sid,
@@ -1055,7 +992,7 @@ class PeriodicAdvertisingSync(EventEmitter):
                 report.rssi,
                 is_truncated=(
                     report.data_status
-                    == HCI_LE_Periodic_Advertising_Report_Event.DataStatus.DATA_INCOMPLETE_TRUNCATED_NO_MORE_TO_COME
+                    == hci.HCI_LE_Periodic_Advertising_Report_Event.DataStatus.DATA_INCOMPLETE_TRUNCATED_NO_MORE_TO_COME
                 ),
                 data_bytes=self.data_accumulator,
             ),
@@ -1064,7 +1001,7 @@ class PeriodicAdvertisingSync(EventEmitter):
 
     def on_biginfo_advertising_report(self, report) -> None:
         self.emit(
-            'biginfo_advertisement',
+            self.EVENT_BIGINFO_ADVERTISEMENT,
             BIGInfoAdvertisement.from_report(self.advertiser_address, self.sid, report),
         )
 
@@ -1080,6 +1017,196 @@ class PeriodicAdvertisingSync(EventEmitter):
         )
 
 
+# -----------------------------------------------------------------------------
+@dataclass
+class BigParameters:
+    num_bis: int
+    sdu_interval: int
+    max_sdu: int
+    max_transport_latency: int
+    rtn: int
+    phy: hci.PhyBit = hci.PhyBit.LE_2M
+    packing: int = 0
+    framing: int = 0
+    broadcast_code: bytes | None = None
+
+
+# -----------------------------------------------------------------------------
+@dataclass
+class Big(utils.EventEmitter):
+    class State(IntEnum):
+        PENDING = 0
+        ACTIVE = 1
+        TERMINATED = 2
+
+    class Event(str, Enum):
+        ESTABLISHMENT = 'establishment'
+        ESTABLISHMENT_FAILURE = 'establishment_failure'
+        TERMINATION = 'termination'
+
+    big_handle: int
+    advertising_set: AdvertisingSet
+    parameters: BigParameters
+    state: State = State.PENDING
+
+    # Attributes provided by BIG Create Complete event
+    big_sync_delay: int = 0
+    transport_latency_big: int = 0
+    phy: int = 0
+    nse: int = 0
+    bn: int = 0
+    pto: int = 0
+    irc: int = 0
+    max_pdu: int = 0
+    iso_interval: float = 0.0
+    bis_links: Sequence[BisLink] = ()
+
+    def __post_init__(self) -> None:
+        super().__init__()
+        self.device = self.advertising_set.device
+
+    async def terminate(
+        self,
+        reason: int = hci.HCI_REMOTE_USER_TERMINATED_CONNECTION_ERROR,
+    ) -> None:
+        if self.state != Big.State.ACTIVE:
+            logger.error('BIG %d is not active.', self.big_handle)
+            return
+
+        with closing(utils.EventWatcher()) as watcher:
+            terminated = asyncio.Event()
+            watcher.once(self, Big.Event.TERMINATION, lambda _: terminated.set())
+            await self.device.send_command(
+                hci.HCI_LE_Terminate_BIG_Command(
+                    big_handle=self.big_handle, reason=reason
+                ),
+                check_result=True,
+            )
+            await terminated.wait()
+
+
+# -----------------------------------------------------------------------------
+@dataclass
+class BigSyncParameters:
+    big_sync_timeout: int
+    bis: Sequence[int]
+    mse: int = 0
+    broadcast_code: bytes | None = None
+
+
+# -----------------------------------------------------------------------------
+@dataclass
+class BigSync(utils.EventEmitter):
+    class State(IntEnum):
+        PENDING = 0
+        ACTIVE = 1
+        TERMINATED = 2
+
+    class Event(str, Enum):
+        ESTABLISHMENT = 'establishment'
+        ESTABLISHMENT_FAILURE = 'establishment_failure'
+        TERMINATION = 'termination'
+
+    big_handle: int
+    pa_sync: PeriodicAdvertisingSync
+    parameters: BigSyncParameters
+    state: State = State.PENDING
+
+    # Attributes provided by BIG Create Sync Complete event
+    transport_latency_big: int = 0
+    nse: int = 0
+    bn: int = 0
+    pto: int = 0
+    irc: int = 0
+    max_pdu: int = 0
+    iso_interval: float = 0.0
+    bis_links: Sequence[BisLink] = ()
+
+    def __post_init__(self) -> None:
+        super().__init__()
+        self.device = self.pa_sync.device
+
+    async def terminate(self) -> None:
+        if self.state != BigSync.State.ACTIVE:
+            logger.error('BIG Sync %d is not active.', self.big_handle)
+            return
+
+        with closing(utils.EventWatcher()) as watcher:
+            terminated = asyncio.Event()
+            watcher.once(self, BigSync.Event.TERMINATION, lambda _: terminated.set())
+            await self.device.send_command(
+                hci.HCI_LE_BIG_Terminate_Sync_Command(big_handle=self.big_handle),
+                check_result=True,
+            )
+            await terminated.wait()
+
+
+# -----------------------------------------------------------------------------
+@dataclass
+class ChannelSoundingCapabilities:
+    num_config_supported: int
+    max_consecutive_procedures_supported: int
+    num_antennas_supported: int
+    max_antenna_paths_supported: int
+    roles_supported: int
+    modes_supported: int
+    rtt_capability: int
+    rtt_aa_only_n: int
+    rtt_sounding_n: int
+    rtt_random_payload_n: int
+    nadm_sounding_capability: int
+    nadm_random_capability: int
+    cs_sync_phys_supported: int
+    subfeatures_supported: int
+    t_ip1_times_supported: int
+    t_ip2_times_supported: int
+    t_fcs_times_supported: int
+    t_pm_times_supported: int
+    t_sw_time_supported: int
+    tx_snr_capability: int
+
+
+# -----------------------------------------------------------------------------
+@dataclass
+class ChannelSoundingConfig:
+    config_id: int
+    main_mode_type: int
+    sub_mode_type: int
+    min_main_mode_steps: int
+    max_main_mode_steps: int
+    main_mode_repetition: int
+    mode_0_steps: int
+    role: int
+    rtt_type: int
+    cs_sync_phy: int
+    channel_map: bytes
+    channel_map_repetition: int
+    channel_selection_type: int
+    ch3c_shape: int
+    ch3c_jump: int
+    reserved: int
+    t_ip1_time: int
+    t_ip2_time: int
+    t_fcs_time: int
+    t_pm_time: int
+
+
+# -----------------------------------------------------------------------------
+@dataclass
+class ChannelSoundingProcedure:
+    config_id: int
+    state: int
+    tone_antenna_config_selection: int
+    selected_tx_power: int
+    subevent_len: int
+    subevents_per_event: int
+    subevent_interval: float  # milliseconds.
+    event_interval: int
+    procedure_interval: int
+    procedure_count: int
+    max_procedure_len: float  # milliseconds.
+
+
 # -----------------------------------------------------------------------------
 class LePhyOptions:
     # Coded PHY preference
@@ -1102,39 +1229,38 @@ class Peer:
     def __init__(self, connection: Connection) -> None:
         self.connection = connection
 
-        # Create a GATT client for the connection
-        self.gatt_client = gatt_client.Client(connection)
-        connection.gatt_client = self.gatt_client
+        # Shortcut to the connection's GATT client
+        self.gatt_client = connection.gatt_client
 
     @property
-    def services(self) -> List[gatt_client.ServiceProxy]:
+    def services(self) -> list[gatt_client.ServiceProxy]:
         return self.gatt_client.services
 
     async def request_mtu(self, mtu: int) -> int:
         mtu = await self.gatt_client.request_mtu(mtu)
-        self.connection.emit('connection_att_mtu_update')
+        self.connection.emit(self.connection.EVENT_CONNECTION_ATT_MTU_UPDATE)
         return mtu
 
     async def discover_service(
         self, uuid: Union[core.UUID, str]
-    ) -> List[gatt_client.ServiceProxy]:
+    ) -> list[gatt_client.ServiceProxy]:
         return await self.gatt_client.discover_service(uuid)
 
     async def discover_services(
         self, uuids: Iterable[core.UUID] = ()
-    ) -> List[gatt_client.ServiceProxy]:
+    ) -> list[gatt_client.ServiceProxy]:
         return await self.gatt_client.discover_services(uuids)
 
     async def discover_included_services(
         self, service: gatt_client.ServiceProxy
-    ) -> List[gatt_client.ServiceProxy]:
+    ) -> list[gatt_client.ServiceProxy]:
         return await self.gatt_client.discover_included_services(service)
 
     async def discover_characteristics(
         self,
         uuids: Iterable[Union[core.UUID, str]] = (),
         service: Optional[gatt_client.ServiceProxy] = None,
-    ) -> List[gatt_client.CharacteristicProxy]:
+    ) -> list[gatt_client.CharacteristicProxy[bytes]]:
         return await self.gatt_client.discover_characteristics(
             uuids=uuids, service=service
         )
@@ -1149,7 +1275,7 @@ class Peer:
             characteristic, start_handle, end_handle
         )
 
-    async def discover_attributes(self) -> List[gatt_client.AttributeProxy]:
+    async def discover_attributes(self) -> list[gatt_client.AttributeProxy[bytes]]:
         return await self.gatt_client.discover_attributes()
 
     async def discover_all(self):
@@ -1193,17 +1319,17 @@ class Peer:
 
     async def read_characteristics_by_uuid(
         self, uuid: core.UUID, service: Optional[gatt_client.ServiceProxy] = None
-    ) -> List[bytes]:
+    ) -> list[bytes]:
         return await self.gatt_client.read_characteristics_by_uuid(uuid, service)
 
-    def get_services_by_uuid(self, uuid: core.UUID) -> List[gatt_client.ServiceProxy]:
+    def get_services_by_uuid(self, uuid: core.UUID) -> list[gatt_client.ServiceProxy]:
         return self.gatt_client.get_services_by_uuid(uuid)
 
     def get_characteristics_by_uuid(
         self,
         uuid: core.UUID,
         service: Optional[Union[gatt_client.ServiceProxy, core.UUID]] = None,
-    ) -> List[gatt_client.CharacteristicProxy]:
+    ) -> list[gatt_client.CharacteristicProxy[bytes]]:
         if isinstance(service, core.UUID):
             return list(
                 itertools.chain(
@@ -1260,8 +1386,8 @@ class Peer:
 @dataclass
 class ConnectionParametersPreferences:
     default: ClassVar[ConnectionParametersPreferences]
-    connection_interval_min: int = DEVICE_DEFAULT_CONNECTION_INTERVAL_MIN
-    connection_interval_max: int = DEVICE_DEFAULT_CONNECTION_INTERVAL_MAX
+    connection_interval_min: float = DEVICE_DEFAULT_CONNECTION_INTERVAL_MIN
+    connection_interval_max: float = DEVICE_DEFAULT_CONNECTION_INTERVAL_MAX
     max_latency: int = DEVICE_DEFAULT_CONNECTION_MAX_LATENCY
     supervision_timeout: int = DEVICE_DEFAULT_CONNECTION_SUPERVISION_TIMEOUT
     min_ce_length: int = DEVICE_DEFAULT_CONNECTION_MIN_CE_LENGTH
@@ -1273,25 +1399,103 @@ ConnectionParametersPreferences.default = ConnectionParametersPreferences()
 
 # -----------------------------------------------------------------------------
 @dataclass
-class ScoLink(CompositeEventEmitter):
+class ScoLink(utils.CompositeEventEmitter):
     device: Device
     acl_connection: Connection
     handle: int
     link_type: int
-    sink: Optional[Callable[[HCI_SynchronousDataPacket], Any]] = None
+    sink: Optional[Callable[[hci.HCI_SynchronousDataPacket], Any]] = None
+
+    EVENT_DISCONNECTION: ClassVar[str] = "disconnection"
+    EVENT_DISCONNECTION_FAILURE: ClassVar[str] = "disconnection_failure"
 
     def __post_init__(self) -> None:
         super().__init__()
 
     async def disconnect(
-        self, reason: int = HCI_REMOTE_USER_TERMINATED_CONNECTION_ERROR
+        self, reason: int = hci.HCI_REMOTE_USER_TERMINATED_CONNECTION_ERROR
     ) -> None:
         await self.device.disconnect(self, reason)
 
 
+# -----------------------------------------------------------------------------
+class _IsoLink:
+    handle: int
+    device: Device
+    sink: Callable[[hci.HCI_IsoDataPacket], Any] | None = None
+
+    class Direction(IntEnum):
+        HOST_TO_CONTROLLER = (
+            hci.HCI_LE_Setup_ISO_Data_Path_Command.Direction.HOST_TO_CONTROLLER
+        )
+        CONTROLLER_TO_HOST = (
+            hci.HCI_LE_Setup_ISO_Data_Path_Command.Direction.CONTROLLER_TO_HOST
+        )
+
+    async def setup_data_path(
+        self,
+        direction: _IsoLink.Direction,
+        data_path_id: int = 0,
+        codec_id: hci.CodingFormat | None = None,
+        controller_delay: int = 0,
+        codec_configuration: bytes = b'',
+    ) -> None:
+        """Create a data path between controller and given entry.
+
+        Args:
+            direction: Direction of data path.
+            data_path_id: ID of data path. Default is 0 (HCI).
+            codec_id: Codec ID. Default is Transparent.
+            controller_delay: Controller delay in microseconds. Default is 0.
+            codec_configuration: Codec-specific configuration.
+
+        Raises:
+            HCI_Error: When command complete status is not HCI_SUCCESS.
+        """
+        await self.device.send_command(
+            hci.HCI_LE_Setup_ISO_Data_Path_Command(
+                connection_handle=self.handle,
+                data_path_direction=direction,
+                data_path_id=data_path_id,
+                codec_id=codec_id or hci.CodingFormat(hci.CodecID.TRANSPARENT),
+                controller_delay=controller_delay,
+                codec_configuration=codec_configuration,
+            ),
+            check_result=True,
+        )
+
+    async def remove_data_path(self, directions: Iterable[_IsoLink.Direction]) -> int:
+        """Remove a data path with controller on given direction.
+
+        Args:
+            direction: Direction of data path.
+
+        Returns:
+            Command status.
+        """
+        response = await self.device.send_command(
+            hci.HCI_LE_Remove_ISO_Data_Path_Command(
+                connection_handle=self.handle,
+                data_path_direction=sum(
+                    1 << direction for direction in set(directions)
+                ),
+            ),
+            check_result=False,
+        )
+        return response.return_parameters.status
+
+    def write(self, sdu: bytes) -> None:
+        """Write an ISO SDU."""
+        self.device.host.send_iso_sdu(connection_handle=self.handle, sdu=sdu)
+
+    @property
+    def data_packet_queue(self) -> DataPacketQueue | None:
+        return self.device.host.get_data_packet_queue(self.handle)
+
+
 # -----------------------------------------------------------------------------
 @dataclass
-class CisLink(CompositeEventEmitter):
+class CisLink(utils.EventEmitter, _IsoLink):
     class State(IntEnum):
         PENDING = 0
         ESTABLISHED = 1
@@ -1302,37 +1506,133 @@ class CisLink(CompositeEventEmitter):
     cis_id: int  # CIS ID assigned by Central device
     cig_id: int  # CIG ID assigned by Central device
     state: State = State.PENDING
-    sink: Optional[Callable[[HCI_IsoDataPacket], Any]] = None
+    sink: Callable[[hci.HCI_IsoDataPacket], Any] | None = None
+
+    EVENT_DISCONNECTION: ClassVar[str] = "disconnection"
+    EVENT_DISCONNECTION_FAILURE: ClassVar[str] = "disconnection_failure"
+    EVENT_ESTABLISHMENT: ClassVar[str] = "establishment"
+    EVENT_ESTABLISHMENT_FAILURE: ClassVar[str] = "establishment_failure"
 
     def __post_init__(self) -> None:
         super().__init__()
 
     async def disconnect(
-        self, reason: int = HCI_REMOTE_USER_TERMINATED_CONNECTION_ERROR
+        self, reason: int = hci.HCI_REMOTE_USER_TERMINATED_CONNECTION_ERROR
     ) -> None:
         await self.device.disconnect(self, reason)
 
 
 # -----------------------------------------------------------------------------
-class Connection(CompositeEventEmitter):
+@dataclass
+class BisLink(_IsoLink):
+    handle: int
+    big: Big | BigSync
+    sink: Callable[[hci.HCI_IsoDataPacket], Any] | None = None
+
+    def __post_init__(self) -> None:
+        self.device = self.big.device
+
+
+# -----------------------------------------------------------------------------
+class IsoPacketStream:
+    """Async stream that can write SDUs to a CIS or BIS, with a maximum queue size."""
+
+    iso_link: _IsoLink
+    data_packet_queue: DataPacketQueue
+
+    def __init__(self, iso_link: _IsoLink, max_queue_size: int) -> None:
+        if iso_link.data_packet_queue is None:
+            raise ValueError('link has no data packet queue')
+
+        self.iso_link = iso_link
+        self.data_packet_queue = iso_link.data_packet_queue
+        self.data_packet_queue.on('flow', self._on_flow)
+        self._thresholds: Deque[int] = collections.deque()
+        self._semaphore = asyncio.Semaphore(max_queue_size)
+
+    def _on_flow(self) -> None:
+        # Release the semaphore once for each completed packet.
+        while (
+            self._thresholds and self.data_packet_queue.completed >= self._thresholds[0]
+        ):
+            self._thresholds.popleft()
+            self._semaphore.release()
+
+    async def write(self, sdu: bytes) -> None:
+        """
+        Write an SDU to the queue.
+
+        This method blocks until there are fewer than max_queue_size packets queued
+        but not yet completed.
+        """
+
+        # Wait until there's space in the queue.
+        await self._semaphore.acquire()
+
+        # Queue the packet.
+        self.iso_link.write(sdu)
+
+        # Remember the position of the packet so we can know when it is completed.
+        self._thresholds.append(self.data_packet_queue.queued)
+
+
+# -----------------------------------------------------------------------------
+class Connection(utils.CompositeEventEmitter):
     device: Device
     handle: int
-    transport: int
-    self_address: Address
-    self_resolvable_address: Optional[Address]
-    peer_address: Address
-    peer_resolvable_address: Optional[Address]
-    peer_le_features: Optional[LeFeatureMask]
-    role: int
+    transport: core.PhysicalTransport
+    self_address: hci.Address
+    self_resolvable_address: Optional[hci.Address]
+    peer_address: hci.Address
+    peer_resolvable_address: Optional[hci.Address]
+    peer_le_features: Optional[hci.LeFeatureMask]
+    role: hci.Role
     encryption: int
+    encryption_key_size: int
     authenticated: bool
     sc: bool
-    link_key_type: int
     gatt_client: gatt_client.Client
     pairing_peer_io_capability: Optional[int]
     pairing_peer_authentication_requirements: Optional[int]
-
-    @composite_listener
+    cs_configs: dict[int, ChannelSoundingConfig]  # Config ID to Configuration
+    cs_procedures: dict[int, ChannelSoundingProcedure]  # Config ID to Procedures
+
+    EVENT_CONNECTION_ATT_MTU_UPDATE = "connection_att_mtu_update"
+    EVENT_DISCONNECTION = "disconnection"
+    EVENT_DISCONNECTION_FAILURE = "disconnection_failure"
+    EVENT_CONNECTION_AUTHENTICATION = "connection_authentication"
+    EVENT_CONNECTION_AUTHENTICATION_FAILURE = "connection_authentication_failure"
+    EVENT_REMOTE_NAME = "remote_name"
+    EVENT_REMOTE_NAME_FAILURE = "remote_name_failure"
+    EVENT_CONNECTION_ENCRYPTION_CHANGE = "connection_encryption_change"
+    EVENT_CONNECTION_ENCRYPTION_FAILURE = "connection_encryption_failure"
+    EVENT_CONNECTION_ENCRYPTION_KEY_REFRESH = "connection_encryption_key_refresh"
+    EVENT_CONNECTION_PARAMETERS_UPDATE = "connection_parameters_update"
+    EVENT_CONNECTION_PARAMETERS_UPDATE_FAILURE = "connection_parameters_update_failure"
+    EVENT_CONNECTION_PHY_UPDATE = "connection_phy_update"
+    EVENT_CONNECTION_PHY_UPDATE_FAILURE = "connection_phy_update_failure"
+    EVENT_CONNECTION_ATT_MTU_UPDATE = "connection_att_mtu_update"
+    EVENT_CONNECTION_DATA_LENGTH_CHANGE = "connection_data_length_change"
+    EVENT_CHANNEL_SOUNDING_CAPABILITIES_FAILURE = (
+        "channel_sounding_capabilities_failure"
+    )
+    EVENT_CHANNEL_SOUNDING_CAPABILITIES = "channel_sounding_capabilities"
+    EVENT_CHANNEL_SOUNDING_CONFIG_FAILURE = "channel_sounding_config_failure"
+    EVENT_CHANNEL_SOUNDING_CONFIG = "channel_sounding_config"
+    EVENT_CHANNEL_SOUNDING_CONFIG_REMOVED = "channel_sounding_config_removed"
+    EVENT_CHANNEL_SOUNDING_PROCEDURE_FAILURE = "channel_sounding_procedure_failure"
+    EVENT_CHANNEL_SOUNDING_PROCEDURE = "channel_sounding_procedure"
+    EVENT_ROLE_CHANGE = "role_change"
+    EVENT_ROLE_CHANGE_FAILURE = "role_change_failure"
+    EVENT_CLASSIC_PAIRING = "classic_pairing"
+    EVENT_CLASSIC_PAIRING_FAILURE = "classic_pairing_failure"
+    EVENT_PAIRING_START = "pairing_start"
+    EVENT_PAIRING = "pairing"
+    EVENT_PAIRING_FAILURE = "pairing_failure"
+    EVENT_SECURITY_REQUEST = "security_request"
+    EVENT_LINK_KEY = "link_key"
+
+    @utils.composite_listener
     class Listener:
         def on_disconnection(self, reason):
             pass
@@ -1346,7 +1646,7 @@ class Connection(CompositeEventEmitter):
         def on_connection_data_length_change(self):
             pass
 
-        def on_connection_phy_update(self):
+        def on_connection_phy_update(self, phy):
             pass
 
         def on_connection_phy_update_failure(self, error):
@@ -1361,18 +1661,23 @@ class Connection(CompositeEventEmitter):
         def on_connection_encryption_key_refresh(self):
             pass
 
+    @dataclass
+    class Parameters:
+        connection_interval: float  # Connection interval, in milliseconds. [LE only]
+        peripheral_latency: int  # Peripheral latency, in number of intervals. [LE only]
+        supervision_timeout: float  # Supervision timeout, in milliseconds.
+
     def __init__(
         self,
-        device,
-        handle,
-        transport,
-        self_address,
-        self_resolvable_address,
-        peer_address,
-        peer_resolvable_address,
-        role,
-        parameters,
-        phy,
+        device: Device,
+        handle: int,
+        transport: core.PhysicalTransport,
+        self_address: hci.Address,
+        self_resolvable_address: Optional[hci.Address],
+        peer_address: hci.Address,
+        peer_resolvable_address: Optional[hci.Address],
+        role: hci.Role,
+        parameters: Parameters,
     ):
         super().__init__()
         self.device = device
@@ -1386,19 +1691,20 @@ class Connection(CompositeEventEmitter):
         self.role = role
         self.parameters = parameters
         self.encryption = 0
+        self.encryption_key_size = 0
         self.authenticated = False
         self.sc = False
-        self.link_key_type = None
-        self.phy = phy
         self.att_mtu = ATT_DEFAULT_MTU
         self.data_length = DEVICE_DEFAULT_DATA_LENGTH
-        self.gatt_client = None  # Per-connection client
+        self.gatt_client = gatt_client.Client(self)  # Per-connection client
         self.gatt_server = (
             device.gatt_server
         )  # By default, use the device's shared server
         self.pairing_peer_io_capability = None
         self.pairing_peer_authentication_requirements = None
         self.peer_le_features = None
+        self.cs_configs = {}
+        self.cs_procedures = {}
 
     # [Classic only]
     @classmethod
@@ -1411,14 +1717,13 @@ class Connection(CompositeEventEmitter):
         return cls(
             device,
             None,
-            BT_BR_EDR_TRANSPORT,
+            PhysicalTransport.BR_EDR,
             device.public_address,
             None,
             peer_address,
             None,
             role,
             None,
-            None,
         )
 
     # [Classic only]
@@ -1427,7 +1732,7 @@ class Connection(CompositeEventEmitter):
         Finish an incomplete connection upon completion.
         """
         assert self.handle is None
-        assert self.transport == BT_BR_EDR_TRANSPORT
+        assert self.transport == PhysicalTransport.BR_EDR
         self.handle = handle
         self.parameters = parameters
 
@@ -1435,9 +1740,9 @@ class Connection(CompositeEventEmitter):
     def role_name(self):
         if self.role is None:
             return 'NOT-SET'
-        if self.role == BT_CENTRAL_ROLE:
+        if self.role == hci.Role.CENTRAL:
             return 'CENTRAL'
-        if self.role == BT_PERIPHERAL_ROLE:
+        if self.role == hci.Role.PERIPHERAL:
             return 'PERIPHERAL'
         return f'UNKNOWN[{self.role}]'
 
@@ -1452,7 +1757,7 @@ class Connection(CompositeEventEmitter):
     def send_l2cap_pdu(self, cid: int, pdu: bytes) -> None:
         self.device.send_l2cap_pdu(self.handle, cid, pdu)
 
-    @deprecated("Please use create_l2cap_channel()")
+    @utils.deprecated("Please use create_l2cap_channel()")
     async def open_l2cap_channel(
         self,
         psm,
@@ -1478,7 +1783,7 @@ class Connection(CompositeEventEmitter):
         return await self.device.create_l2cap_channel(connection=self, spec=spec)
 
     async def disconnect(
-        self, reason: int = HCI_REMOTE_USER_TERMINATED_CONNECTION_ERROR
+        self, reason: int = hci.HCI_REMOTE_USER_TERMINATED_CONNECTION_ERROR
     ) -> None:
         await self.device.disconnect(self, reason)
 
@@ -1495,33 +1800,45 @@ class Connection(CompositeEventEmitter):
     async def encrypt(self, enable: bool = True) -> None:
         return await self.device.encrypt(self, enable)
 
-    async def switch_role(self, role: int) -> None:
+    async def switch_role(self, role: hci.Role) -> None:
         return await self.device.switch_role(self, role)
 
     async def sustain(self, timeout: Optional[float] = None) -> None:
         """Idles the current task waiting for a disconnect or timeout"""
 
         abort = asyncio.get_running_loop().create_future()
-        self.on('disconnection', abort.set_result)
-        self.on('disconnection_failure', abort.set_exception)
+        self.on(self.EVENT_DISCONNECTION, abort.set_result)
+        self.on(self.EVENT_DISCONNECTION_FAILURE, abort.set_exception)
 
         try:
-            await asyncio.wait_for(self.device.abort_on('flush', abort), timeout)
+            await asyncio.wait_for(
+                utils.cancel_on_event(self.device, Device.EVENT_FLUSH, abort), timeout
+            )
         finally:
-            self.remove_listener('disconnection', abort.set_result)
-            self.remove_listener('disconnection_failure', abort.set_exception)
+            self.remove_listener(self.EVENT_DISCONNECTION, abort.set_result)
+            self.remove_listener(self.EVENT_DISCONNECTION_FAILURE, abort.set_exception)
 
     async def set_data_length(self, tx_octets, tx_time) -> None:
         return await self.device.set_data_length(self, tx_octets, tx_time)
 
     async def update_parameters(
         self,
-        connection_interval_min,
-        connection_interval_max,
-        max_latency,
-        supervision_timeout,
+        connection_interval_min: float,
+        connection_interval_max: float,
+        max_latency: int,
+        supervision_timeout: float,
         use_l2cap=False,
-    ):
+    ) -> None:
+        """
+        Request an update of the connection parameters.
+
+        Args:
+          connection_interval_min: Minimum interval, in milliseconds.
+          connection_interval_max: Maximum interval, in milliseconds.
+          max_latency: Latency, in number of intervals.
+          supervision_timeout: Timeout, in milliseconds.
+          use_l2cap: Request the update via L2CAP.
+        """
         return await self.device.update_connection_parameters(
             self,
             connection_interval_min,
@@ -1534,22 +1851,29 @@ class Connection(CompositeEventEmitter):
     async def set_phy(self, tx_phys=None, rx_phys=None, phy_options=None):
         return await self.device.set_connection_phy(self, tx_phys, rx_phys, phy_options)
 
+    async def get_phy(self) -> ConnectionPHY:
+        return await self.device.get_connection_phy(self)
+
     async def get_rssi(self):
         return await self.device.get_connection_rssi(self)
 
-    async def get_phy(self):
-        return await self.device.get_connection_phy(self)
-
     async def transfer_periodic_sync(
         self, sync_handle: int, service_data: int = 0
     ) -> None:
         await self.device.transfer_periodic_sync(self, sync_handle, service_data)
 
+    async def transfer_periodic_set_info(
+        self, advertising_handle: int, service_data: int = 0
+    ) -> None:
+        await self.device.transfer_periodic_set_info(
+            self, advertising_handle, service_data
+        )
+
     # [Classic only]
     async def request_remote_name(self):
         return await self.device.request_remote_name(self)
 
-    async def get_remote_le_features(self) -> LeFeatureMask:
+    async def get_remote_le_features(self) -> hci.LeFeatureMask:
         """[LE Only] Reads remote LE supported features.
 
         Returns:
@@ -1558,6 +1882,10 @@ class Connection(CompositeEventEmitter):
         self.peer_le_features = await self.device.get_remote_le_features(self)
         return self.peer_le_features
 
+    @property
+    def data_packet_queue(self) -> DataPacketQueue | None:
+        return self.device.host.get_data_packet_queue(self.handle)
+
     async def __aenter__(self):
         return self
 
@@ -1565,20 +1893,28 @@ class Connection(CompositeEventEmitter):
         if exc_type is None:
             try:
                 await self.disconnect()
-            except HCI_StatusError as error:
+            except hci.HCI_StatusError as error:
                 # Invalid parameter means the connection is no longer valid
-                if error.error_code != HCI_INVALID_HCI_COMMAND_PARAMETERS_ERROR:
+                if error.error_code != hci.HCI_INVALID_HCI_COMMAND_PARAMETERS_ERROR:
                     raise
 
     def __str__(self):
-        return (
-            f'Connection(handle=0x{self.handle:04X}, '
-            f'role={self.role_name}, '
-            f'self_address={self.self_address}, '
-            f'self_resolvable_address={self.self_resolvable_address}, '
-            f'peer_address={self.peer_address}, '
-            f'peer_resolvable_address={self.peer_resolvable_address})'
-        )
+        if self.transport == PhysicalTransport.LE:
+            return (
+                f'Connection(transport=LE, handle=0x{self.handle:04X}, '
+                f'role={self.role_name}, '
+                f'self_address={self.self_address}, '
+                f'self_resolvable_address={self.self_resolvable_address}, '
+                f'peer_address={self.peer_address}, '
+                f'peer_resolvable_address={self.peer_resolvable_address})'
+            )
+        else:
+            return (
+                f'Connection(transport=BR/EDR, handle=0x{self.handle:04X}, '
+                f'role={self.role_name}, '
+                f'self_address={self.self_address}, '
+                f'peer_address={self.peer_address})'
+            )
 
 
 # -----------------------------------------------------------------------------
@@ -1586,11 +1922,11 @@ class Connection(CompositeEventEmitter):
 class DeviceConfiguration:
     # Setup defaults
     name: str = DEVICE_DEFAULT_NAME
-    address: Address = Address(DEVICE_DEFAULT_ADDRESS)
+    address: hci.Address = hci.Address(DEVICE_DEFAULT_ADDRESS)
     class_of_device: int = DEVICE_DEFAULT_CLASS_OF_DEVICE
     scan_response_data: bytes = DEVICE_DEFAULT_SCAN_RESPONSE_DATA
-    advertising_interval_min: int = DEVICE_DEFAULT_ADVERTISING_INTERVAL
-    advertising_interval_max: int = DEVICE_DEFAULT_ADVERTISING_INTERVAL
+    advertising_interval_min: float = DEVICE_DEFAULT_ADVERTISING_INTERVAL
+    advertising_interval_max: float = DEVICE_DEFAULT_ADVERTISING_INTERVAL
     le_enabled: bool = True
     le_simultaneous_enabled: bool = False
     le_privacy_enabled: bool = False
@@ -1613,23 +1949,26 @@ class DeviceConfiguration:
     address_resolution_offload: bool = False
     address_generation_offload: bool = False
     cis_enabled: bool = False
+    channel_sounding_enabled: bool = False
     identity_address_type: Optional[int] = None
     io_capability: int = pairing.PairingDelegate.IoCapability.NO_OUTPUT_NO_INPUT
+    gap_service_enabled: bool = True
+    gatt_service_enabled: bool = True
 
     def __post_init__(self) -> None:
-        self.gatt_services: List[Dict[str, Any]] = []
+        self.gatt_services: list[Dict[str, Any]] = []
 
     def load_from_dict(self, config: Dict[str, Any]) -> None:
         config = copy.deepcopy(config)
 
         # Load simple properties
         if address := config.pop('address', None):
-            self.address = Address(address)
+            self.address = hci.Address(address)
 
         # Load or synthesize an IRK
         if irk := config.pop('irk', None):
             self.irk = bytes.fromhex(irk)
-        elif self.address != Address(DEVICE_DEFAULT_ADDRESS):
+        elif self.address != hci.Address(DEVICE_DEFAULT_ADDRESS):
             # Construct an IRK from the address bytes
             # NOTE: this is not secure, but will always give the same IRK for the same
             # address
@@ -1652,6 +1991,10 @@ class DeviceConfiguration:
                 )
             )
 
+        # Load scan response data
+        if scan_response_data := config.pop('scan_response_data', None):
+            self.scan_response_data = bytes.fromhex(scan_response_data)
+
         # Load advertising interval (for backward compatibility)
         if advertising_interval := config.pop('advertising_interval', None):
             self.advertising_interval_min = advertising_interval
@@ -1760,35 +2103,63 @@ def host_event_handler(function):
 # List of host event handlers for the Device class.
 # (we define this list outside the class, because referencing a class in method
 #  decorators is not straightforward)
-device_host_event_handlers: List[str] = []
+device_host_event_handlers: list[str] = []
 
 
 # -----------------------------------------------------------------------------
-class Device(CompositeEventEmitter):
+class Device(utils.CompositeEventEmitter):
     # Incomplete list of fields.
-    random_address: Address  # Random private address that may change periodically
-    public_address: Address  # Public address that is globally unique (from controller)
-    static_address: Address  # Random static address that does not change once set
+    random_address: hci.Address  # Random private address that may change periodically
+    public_address: (
+        hci.Address
+    )  # Public address that is globally unique (from controller)
+    static_address: hci.Address  # Random static address that does not change once set
     classic_enabled: bool
     name: str
     class_of_device: int
     gatt_server: gatt_server.Server
     advertising_data: bytes
     scan_response_data: bytes
+    cs_capabilities: ChannelSoundingCapabilities | None = None
     connections: Dict[int, Connection]
-    pending_connections: Dict[Address, Connection]
+    pending_connections: Dict[hci.Address, Connection]
     classic_pending_accepts: Dict[
-        Address, List[asyncio.Future[Union[Connection, Tuple[Address, int, int]]]]
+        hci.Address,
+        list[asyncio.Future[Union[Connection, tuple[hci.Address, int, int]]]],
     ]
-    advertisement_accumulators: Dict[Address, AdvertisementDataAccumulator]
-    periodic_advertising_syncs: List[PeriodicAdvertisingSync]
+    advertisement_accumulators: Dict[hci.Address, AdvertisementDataAccumulator]
+    periodic_advertising_syncs: list[PeriodicAdvertisingSync]
     config: DeviceConfiguration
     legacy_advertiser: Optional[LegacyAdvertiser]
     sco_links: Dict[int, ScoLink]
     cis_links: Dict[int, CisLink]
-    _pending_cis: Dict[int, Tuple[int, int]]
-
-    @composite_listener
+    bigs: dict[int, Big]
+    bis_links: dict[int, BisLink]
+    big_syncs: dict[int, BigSync]
+    _pending_cis: Dict[int, tuple[int, int]]
+    gatt_service: gatt_service.GenericAttributeProfileService | None = None
+
+    EVENT_ADVERTISEMENT = "advertisement"
+    EVENT_PERIODIC_ADVERTISING_SYNC_TRANSFER = "periodic_advertising_sync_transfer"
+    EVENT_KEY_STORE_UPDATE = "key_store_update"
+    EVENT_FLUSH = "flush"
+    EVENT_CONNECTION = "connection"
+    EVENT_CONNECTION_FAILURE = "connection_failure"
+    EVENT_SCO_REQUEST = "sco_request"
+    EVENT_INQUIRY_COMPLETE = "inquiry_complete"
+    EVENT_REMOTE_NAME = "remote_name"
+    EVENT_REMOTE_NAME_FAILURE = "remote_name_failure"
+    EVENT_SCO_CONNECTION = "sco_connection"
+    EVENT_SCO_CONNECTION_FAILURE = "sco_connection_failure"
+    EVENT_CIS_REQUEST = "cis_request"
+    EVENT_CIS_ESTABLISHMENT = "cis_establishment"
+    EVENT_CIS_ESTABLISHMENT_FAILURE = "cis_establishment_failure"
+    EVENT_ROLE_CHANGE_FAILURE = "role_change_failure"
+    EVENT_INQUIRY_RESULT = "inquiry_result"
+    EVENT_REMOTE_NAME = "remote_name"
+    EVENT_REMOTE_NAME_FAILURE = "remote_name_failure"
+
+    @utils.composite_listener
     class Listener:
         def on_advertisement(self, advertisement):
             pass
@@ -1814,7 +2185,7 @@ class Device(CompositeEventEmitter):
     def with_hci(
         cls,
         name: str,
-        address: Address,
+        address: hci.Address,
         hci_source: TransportSource,
         hci_sink: TransportSink,
     ) -> Device:
@@ -1850,10 +2221,9 @@ class Device(CompositeEventEmitter):
     def __init__(
         self,
         name: Optional[str] = None,
-        address: Optional[Address] = None,
+        address: Optional[hci.Address] = None,
         config: Optional[DeviceConfiguration] = None,
         host: Optional[Host] = None,
-        generic_access_service: bool = True,
     ) -> None:
         super().__init__()
 
@@ -1878,12 +2248,15 @@ class Device(CompositeEventEmitter):
         self.sco_links = {}  # ScoLinks, by connection handle (BR/EDR only)
         self.cis_links = {}  # CisLinks, by connection handle (LE only)
         self._pending_cis = {}  # (CIS_ID, CIG_ID), by CIS_handle
+        self.bigs = {}
+        self.bis_links = {}
+        self.big_syncs = {}
         self.classic_enabled = False
         self.inquiry_response = None
         self.address_resolver = None
         self.classic_pending_accepts = {
-            Address.ANY: []
-        }  # Futures, by BD address OR [Futures] for Address.ANY
+            hci.Address.ANY: []
+        }  # Futures, by BD address OR [Futures] for hci.Address.ANY
 
         # In Python <= 3.9 + Rust Runtime, asyncio.Lock cannot be properly initiated.
         if sys.version_info >= (3, 10):
@@ -1899,7 +2272,7 @@ class Device(CompositeEventEmitter):
         self.config = config
 
         self.name = config.name
-        self.public_address = Address.ANY
+        self.public_address = hci.Address.ANY
         self.random_address = config.address
         self.static_address = config.address
         self.class_of_device = config.class_of_device
@@ -1955,7 +2328,7 @@ class Device(CompositeEventEmitter):
                         permissions=descriptor["permissions"],
                     )
                     descriptors.append(new_descriptor)
-                new_characteristic = Characteristic(
+                new_characteristic: Characteristic[bytes] = Characteristic(
                     uuid=characteristic["uuid"],
                     properties=Characteristic.Properties.from_string(
                         characteristic["properties"]
@@ -1974,7 +2347,7 @@ class Device(CompositeEventEmitter):
         # If an address is passed, override the address from the config
         if address:
             if isinstance(address, str):
-                address = Address(address)
+                address = hci.Address(address)
             self.random_address = address
             self.static_address = address
 
@@ -2000,11 +2373,16 @@ class Device(CompositeEventEmitter):
         # Register the SDP server with the L2CAP Channel Manager
         self.sdp_server.register(self.l2cap_channel_manager)
 
-        self.add_default_services(generic_access_service)
+        self.add_default_services(
+            add_gap_service=config.gap_service_enabled,
+            add_gatt_service=config.gatt_service_enabled,
+        )
         self.l2cap_channel_manager.register_fixed_channel(ATT_CID, self.on_gatt_pdu)
 
         # Forward some events
-        setup_event_forwarding(self.gatt_server, self, 'characteristic_subscription')
+        utils.setup_event_forwarding(
+            self.gatt_server, self, 'characteristic_subscription'
+        )
 
         # Set the initial host
         if host:
@@ -2054,12 +2432,12 @@ class Device(CompositeEventEmitter):
 
     def find_connection_by_bd_addr(
         self,
-        bd_addr: Address,
+        bd_addr: hci.Address,
         transport: Optional[int] = None,
         check_address_type: bool = False,
     ) -> Optional[Connection]:
         for connection in self.connections.values():
-            if connection.peer_address.to_bytes() == bd_addr.to_bytes():
+            if bytes(connection.peer_address) == bytes(bd_addr):
                 if (
                     check_address_type
                     and connection.peer_address.address_type != bd_addr.address_type
@@ -2082,11 +2460,22 @@ class Device(CompositeEventEmitter):
             None,
         )
 
-    @deprecated("Please use create_l2cap_server()")
+    def next_big_handle(self) -> int | None:
+        return next(
+            (
+                handle
+                for handle in range(DEVICE_MIN_BIG_HANDLE, DEVICE_MAX_BIG_HANDLE + 1)
+                if handle
+                not in itertools.chain(self.bigs.keys(), self.big_syncs.keys())
+            ),
+            None,
+        )
+
+    @utils.deprecated("Please use create_l2cap_server()")
     def register_l2cap_server(self, psm, server) -> int:
         return self.l2cap_channel_manager.register_server(psm, server)
 
-    @deprecated("Please use create_l2cap_server()")
+    @utils.deprecated("Please use create_l2cap_server()")
     def register_l2cap_channel_server(
         self,
         psm,
@@ -2099,7 +2488,7 @@ class Device(CompositeEventEmitter):
             psm, server, max_credits, mtu, mps
         )
 
-    @deprecated("Please use create_l2cap_channel()")
+    @utils.deprecated("Please use create_l2cap_channel()")
     async def open_l2cap_channel(
         self,
         connection,
@@ -2193,8 +2582,8 @@ class Device(CompositeEventEmitter):
         await self.host.reset()
 
         # Try to get the public address from the controller
-        response = await self.send_command(HCI_Read_BD_ADDR_Command())
-        if response.return_parameters.status == HCI_SUCCESS:
+        response = await self.send_command(hci.HCI_Read_BD_ADDR_Command())
+        if response.return_parameters.status == hci.HCI_SUCCESS:
             logger.debug(
                 color(f'BD_ADDR: {response.return_parameters.bd_addr}', 'yellow')
             )
@@ -2211,9 +2600,9 @@ class Device(CompositeEventEmitter):
                 smp.SMP_BR_CID, self.on_smp_pdu
             )
 
-        if self.host.supports_command(HCI_WRITE_LE_HOST_SUPPORT_COMMAND):
+        if self.host.supports_command(hci.HCI_WRITE_LE_HOST_SUPPORT_COMMAND):
             await self.send_command(
-                HCI_Write_LE_Host_Support_Command(
+                hci.HCI_Write_LE_Host_Support_Command(
                     le_supported_host=int(self.le_enabled),
                     simultaneous_le_host=int(self.le_simultaneous_enabled),
                 ),
@@ -2222,12 +2611,12 @@ class Device(CompositeEventEmitter):
 
         if self.le_enabled:
             # Generate a random address if not set.
-            if self.static_address == Address.ANY_RANDOM:
-                self.static_address = Address.generate_static_address()
+            if self.static_address == hci.Address.ANY_RANDOM:
+                self.static_address = hci.Address.generate_static_address()
 
             # If LE Privacy is enabled, generate an RPA
             if self.le_privacy_enabled:
-                self.random_address = Address.generate_private_address(self.irk)
+                self.random_address = hci.Address.generate_private_address(self.irk)
                 logger.info(f'Initial RPA: {self.random_address}')
                 if self.le_rpa_timeout > 0:
                     # Start a task to periodically generate a new RPA
@@ -2237,7 +2626,7 @@ class Device(CompositeEventEmitter):
             else:
                 self.random_address = self.static_address
 
-            if self.random_address != Address.ANY_RANDOM:
+            if self.random_address != hci.Address.ANY_RANDOM:
                 logger.debug(
                     color(
                         f'LE Random Address: {self.random_address}',
@@ -2245,7 +2634,7 @@ class Device(CompositeEventEmitter):
                     )
                 )
                 await self.send_command(
-                    HCI_LE_Set_Random_Address_Command(
+                    hci.HCI_LE_Set_Random_Address_Command(
                         random_address=self.random_address
                     ),
                     check_result=True,
@@ -2258,7 +2647,7 @@ class Device(CompositeEventEmitter):
             # Enable address resolution
             if self.address_resolution_offload:
                 await self.send_command(
-                    HCI_LE_Set_Address_Resolution_Enable_Command(
+                    hci.HCI_LE_Set_Address_Resolution_Enable_Command(
                         address_resolution_enable=1
                     ),
                     check_result=True,
@@ -2266,27 +2655,64 @@ class Device(CompositeEventEmitter):
 
             if self.cis_enabled:
                 await self.send_command(
-                    HCI_LE_Set_Host_Feature_Command(
-                        bit_number=LeFeature.CONNECTED_ISOCHRONOUS_STREAM,
+                    hci.HCI_LE_Set_Host_Feature_Command(
+                        bit_number=hci.LeFeature.CONNECTED_ISOCHRONOUS_STREAM,
+                        bit_value=1,
+                    ),
+                    check_result=True,
+                )
+
+            if self.config.channel_sounding_enabled:
+                await self.send_command(
+                    hci.HCI_LE_Set_Host_Feature_Command(
+                        bit_number=hci.LeFeature.CHANNEL_SOUNDING_HOST_SUPPORT,
                         bit_value=1,
                     ),
                     check_result=True,
                 )
+                result = await self.send_command(
+                    hci.HCI_LE_CS_Read_Local_Supported_Capabilities_Command(),
+                    check_result=True,
+                )
+                self.cs_capabilities = ChannelSoundingCapabilities(
+                    num_config_supported=result.return_parameters.num_config_supported,
+                    max_consecutive_procedures_supported=result.return_parameters.max_consecutive_procedures_supported,
+                    num_antennas_supported=result.return_parameters.num_antennas_supported,
+                    max_antenna_paths_supported=result.return_parameters.max_antenna_paths_supported,
+                    roles_supported=result.return_parameters.roles_supported,
+                    modes_supported=result.return_parameters.modes_supported,
+                    rtt_capability=result.return_parameters.rtt_capability,
+                    rtt_aa_only_n=result.return_parameters.rtt_aa_only_n,
+                    rtt_sounding_n=result.return_parameters.rtt_sounding_n,
+                    rtt_random_payload_n=result.return_parameters.rtt_random_payload_n,
+                    nadm_sounding_capability=result.return_parameters.nadm_sounding_capability,
+                    nadm_random_capability=result.return_parameters.nadm_random_capability,
+                    cs_sync_phys_supported=result.return_parameters.cs_sync_phys_supported,
+                    subfeatures_supported=result.return_parameters.subfeatures_supported,
+                    t_ip1_times_supported=result.return_parameters.t_ip1_times_supported,
+                    t_ip2_times_supported=result.return_parameters.t_ip2_times_supported,
+                    t_fcs_times_supported=result.return_parameters.t_fcs_times_supported,
+                    t_pm_times_supported=result.return_parameters.t_pm_times_supported,
+                    t_sw_time_supported=result.return_parameters.t_sw_time_supported,
+                    tx_snr_capability=result.return_parameters.tx_snr_capability,
+                )
 
         if self.classic_enabled:
             await self.send_command(
-                HCI_Write_Local_Name_Command(local_name=self.name.encode('utf8'))
+                hci.HCI_Write_Local_Name_Command(local_name=self.name.encode('utf8'))
             )
             await self.send_command(
-                HCI_Write_Class_Of_Device_Command(class_of_device=self.class_of_device)
+                hci.HCI_Write_Class_Of_Device_Command(
+                    class_of_device=self.class_of_device
+                )
             )
             await self.send_command(
-                HCI_Write_Simple_Pairing_Mode_Command(
+                hci.HCI_Write_Simple_Pairing_Mode_Command(
                     simple_pairing_mode=int(self.classic_ssp_enabled)
                 )
             )
             await self.send_command(
-                HCI_Write_Secure_Connections_Host_Support_Command(
+                hci.HCI_Write_Secure_Connections_Host_Support_Command(
                     secure_connections_host_support=int(self.classic_sc_enabled)
                 )
             )
@@ -2294,14 +2720,16 @@ class Device(CompositeEventEmitter):
             await self.set_discoverable(self.discoverable)
 
             if self.classic_interlaced_scan_enabled:
-                if self.host.supports_lmp_features(LmpFeatureMask.INTERLACED_PAGE_SCAN):
+                if self.host.supports_lmp_features(
+                    hci.LmpFeatureMask.INTERLACED_PAGE_SCAN
+                ):
                     await self.send_command(
                         hci.HCI_Write_Page_Scan_Type_Command(page_scan_type=1),
                         check_result=True,
                     )
 
                 if self.host.supports_lmp_features(
-                    LmpFeatureMask.INTERLACED_INQUIRY_SCAN
+                    hci.LmpFeatureMask.INTERLACED_INQUIRY_SCAN
                 ):
                     await self.send_command(
                         hci.HCI_Write_Inquiry_Scan_Type_Command(scan_type=1),
@@ -2336,11 +2764,11 @@ class Device(CompositeEventEmitter):
             logger.debug('skipping RPA update')
             return False
 
-        random_address = Address.generate_private_address(self.irk)
+        random_address = hci.Address.generate_private_address(self.irk)
         response = await self.send_command(
-            HCI_LE_Set_Random_Address_Command(random_address=self.random_address)
+            hci.HCI_LE_Set_Random_Address_Command(random_address=self.random_address)
         )
-        if response.return_parameters == HCI_SUCCESS:
+        if response.return_parameters == hci.HCI_SUCCESS:
             logger.info(f'new RPA: {random_address}')
             self.random_address = random_address
             return True
@@ -2352,7 +2780,7 @@ class Device(CompositeEventEmitter):
         """Update the RPA periodically"""
         while self.le_rpa_timeout != 0:
             await asyncio.sleep(self.le_rpa_timeout)
-            if not self.update_rpa():
+            if not await self.update_rpa():
                 logger.debug("periodic RPA update failed")
 
     async def refresh_resolving_list(self) -> None:
@@ -2363,13 +2791,13 @@ class Device(CompositeEventEmitter):
         self.address_resolver = smp.AddressResolver(resolving_keys)
 
         if self.address_resolution_offload or self.address_generation_offload:
-            await self.send_command(HCI_LE_Clear_Resolving_List_Command())
+            await self.send_command(hci.HCI_LE_Clear_Resolving_List_Command())
 
             # Add an empty entry for non-directed address generation.
             await self.send_command(
-                HCI_LE_Add_Device_To_Resolving_List_Command(
-                    peer_identity_address_type=Address.ANY.address_type,
-                    peer_identity_address=Address.ANY,
+                hci.HCI_LE_Add_Device_To_Resolving_List_Command(
+                    peer_identity_address_type=hci.Address.ANY.address_type,
+                    peer_identity_address=hci.Address.ANY,
                     peer_irk=bytes(16),
                     local_irk=self.irk,
                 )
@@ -2377,7 +2805,7 @@ class Device(CompositeEventEmitter):
 
             for irk, address in resolving_keys:
                 await self.send_command(
-                    HCI_LE_Add_Device_To_Resolving_List_Command(
+                    hci.HCI_LE_Add_Device_To_Resolving_List_Command(
                         peer_identity_address_type=address.address_type,
                         peer_identity_address=address,
                         peer_irk=irk,
@@ -2385,16 +2813,16 @@ class Device(CompositeEventEmitter):
                     )
                 )
 
-    def supports_le_features(self, feature: LeFeatureMask) -> bool:
+    def supports_le_features(self, feature: hci.LeFeatureMask) -> bool:
         return self.host.supports_le_features(feature)
 
     def supports_le_phy(self, phy: int) -> bool:
-        if phy == HCI_LE_1M_PHY:
+        if phy == hci.HCI_LE_1M_PHY:
             return True
 
-        feature_map = {
-            HCI_LE_2M_PHY: LeFeatureMask.LE_2M_PHY,
-            HCI_LE_CODED_PHY: LeFeatureMask.LE_CODED_PHY,
+        feature_map: dict[int, hci.LeFeatureMask] = {
+            hci.HCI_LE_2M_PHY: hci.LeFeatureMask.LE_2M_PHY,
+            hci.HCI_LE_CODED_PHY: hci.LeFeatureMask.LE_CODED_PHY,
         }
         if phy not in feature_map:
             raise InvalidArgumentError('invalid PHY')
@@ -2403,22 +2831,22 @@ class Device(CompositeEventEmitter):
 
     @property
     def supports_le_extended_advertising(self):
-        return self.supports_le_features(LeFeatureMask.LE_EXTENDED_ADVERTISING)
+        return self.supports_le_features(hci.LeFeatureMask.LE_EXTENDED_ADVERTISING)
 
     @property
     def supports_le_periodic_advertising(self):
-        return self.supports_le_features(LeFeatureMask.LE_PERIODIC_ADVERTISING)
+        return self.supports_le_features(hci.LeFeatureMask.LE_PERIODIC_ADVERTISING)
 
     async def start_advertising(
         self,
         advertising_type: AdvertisingType = AdvertisingType.UNDIRECTED_CONNECTABLE_SCANNABLE,
-        target: Optional[Address] = None,
-        own_address_type: int = OwnAddressType.RANDOM,
+        target: Optional[hci.Address] = None,
+        own_address_type: hci.OwnAddressType = hci.OwnAddressType.RANDOM,
         auto_restart: bool = False,
         advertising_data: Optional[bytes] = None,
         scan_response_data: Optional[bytes] = None,
-        advertising_interval_min: Optional[int] = None,
-        advertising_interval_max: Optional[int] = None,
+        advertising_interval_min: Optional[float] = None,
+        advertising_interval_max: Optional[float] = None,
     ) -> None:
         """Start legacy advertising.
 
@@ -2464,7 +2892,7 @@ class Device(CompositeEventEmitter):
                 raise InvalidArgumentError('directed advertising requires a target')
             peer_address = target
         else:
-            peer_address = Address.ANY
+            peer_address = hci.Address.ANY
 
         # If we're already advertising, stop now because we'll be re-creating
         # a new advertiser or advertising set.
@@ -2486,7 +2914,7 @@ class Device(CompositeEventEmitter):
                     ),
                     primary_advertising_interval_min=self.advertising_interval_min,
                     primary_advertising_interval_max=self.advertising_interval_max,
-                    own_address_type=OwnAddressType(own_address_type),
+                    own_address_type=hci.OwnAddressType(own_address_type),
                     peer_address=peer_address,
                 ),
                 advertising_data=(
@@ -2501,7 +2929,7 @@ class Device(CompositeEventEmitter):
             self.legacy_advertiser = LegacyAdvertiser(
                 device=self,
                 advertising_type=advertising_type,
-                own_address_type=OwnAddressType(own_address_type),
+                own_address_type=hci.OwnAddressType(own_address_type),
                 peer_address=peer_address,
                 auto_restart=auto_restart,
             )
@@ -2523,7 +2951,7 @@ class Device(CompositeEventEmitter):
     async def create_advertising_set(
         self,
         advertising_parameters: Optional[AdvertisingParameters] = None,
-        random_address: Optional[Address] = None,
+        random_address: Optional[hci.Address] = None,
         advertising_data: bytes = b'',
         scan_response_data: bytes = b'',
         periodic_advertising_parameters: Optional[PeriodicAdvertisingParameters] = None,
@@ -2563,14 +2991,27 @@ class Device(CompositeEventEmitter):
         if advertising_parameters is None:
             advertising_parameters = AdvertisingParameters()
 
+        if periodic_advertising_data and periodic_advertising_parameters is None:
+            periodic_advertising_parameters = PeriodicAdvertisingParameters()
+
         if (
             not advertising_parameters.advertising_event_properties.is_legacy
             and advertising_data
             and scan_response_data
         ):
             raise InvalidArgumentError(
-                "Extended advertisements can't have both data and scan \
-                              response data"
+                "Extended advertisements can't have both data and scan response data"
+            )
+
+        if periodic_advertising_parameters and (
+            advertising_parameters.advertising_event_properties.is_connectable
+            or advertising_parameters.advertising_event_properties.is_scannable
+            or advertising_parameters.advertising_event_properties.is_anonymous
+            or advertising_parameters.advertising_event_properties.is_legacy
+        ):
+            raise InvalidArgumentError(
+                "Periodic advertising set cannot be connectable, scannable, anonymous,"
+                "or legacy"
             )
 
         # Allocate a new handle
@@ -2592,7 +3033,7 @@ class Device(CompositeEventEmitter):
         # provided.
         if (
             advertising_parameters.own_address_type
-            in (OwnAddressType.RANDOM, OwnAddressType.RESOLVABLE_OR_RANDOM)
+            in (hci.OwnAddressType.RANDOM, hci.OwnAddressType.RESOLVABLE_OR_RANDOM)
             and random_address is None
         ):
             random_address = self.random_address
@@ -2625,18 +3066,20 @@ class Device(CompositeEventEmitter):
                 await advertising_set.set_scan_response_data(scan_response_data)
 
             if periodic_advertising_parameters:
-                # TODO: call LE Set Periodic Advertising Parameters command
-                raise NotImplementedError('periodic advertising not yet supported')
+                await advertising_set.set_periodic_advertising_parameters(
+                    periodic_advertising_parameters
+                )
 
             if periodic_advertising_data:
-                # TODO: call LE Set Periodic Advertising Data command
-                raise NotImplementedError('periodic advertising not yet supported')
+                await advertising_set.set_periodic_advertising_data(
+                    periodic_advertising_data
+                )
 
-        except HCI_Error as error:
+        except hci.HCI_Error as error:
             # Remove the advertising set so that it doesn't stay dangling in the
             # controller.
             await self.send_command(
-                HCI_LE_Remove_Advertising_Set_Command(
+                hci.HCI_LE_Remove_Advertising_Set_Command(
                     advertising_handle=advertising_handle
                 ),
                 check_result=False,
@@ -2677,11 +3120,11 @@ class Device(CompositeEventEmitter):
         self,
         legacy: bool = False,
         active: bool = True,
-        scan_interval: int = DEVICE_DEFAULT_SCAN_INTERVAL,  # Scan interval in ms
-        scan_window: int = DEVICE_DEFAULT_SCAN_WINDOW,  # Scan window in ms
-        own_address_type: int = OwnAddressType.RANDOM,
+        scan_interval: float = DEVICE_DEFAULT_SCAN_INTERVAL,  # Scan interval in ms
+        scan_window: float = DEVICE_DEFAULT_SCAN_WINDOW,  # Scan window in ms
+        own_address_type: hci.OwnAddressType = hci.OwnAddressType.RANDOM,
         filter_duplicates: bool = False,
-        scanning_phys: List[int] = [HCI_LE_1M_PHY, HCI_LE_CODED_PHY],
+        scanning_phys: Sequence[int] = (hci.HCI_LE_1M_PHY, hci.HCI_LE_CODED_PHY),
     ) -> None:
         # Check that the arguments are legal
         if scan_interval < scan_window:
@@ -2701,34 +3144,34 @@ class Device(CompositeEventEmitter):
         if not legacy and self.supports_le_extended_advertising:
             # Set the scanning parameters
             scan_type = (
-                HCI_LE_Set_Extended_Scan_Parameters_Command.ACTIVE_SCANNING
+                hci.HCI_LE_Set_Extended_Scan_Parameters_Command.ACTIVE_SCANNING
                 if active
-                else HCI_LE_Set_Extended_Scan_Parameters_Command.PASSIVE_SCANNING
+                else hci.HCI_LE_Set_Extended_Scan_Parameters_Command.PASSIVE_SCANNING
             )
             scanning_filter_policy = (
-                HCI_LE_Set_Extended_Scan_Parameters_Command.BASIC_UNFILTERED_POLICY
+                hci.HCI_LE_Set_Extended_Scan_Parameters_Command.BASIC_UNFILTERED_POLICY
             )  # TODO: support other types
 
             scanning_phy_count = 0
             scanning_phys_bits = 0
-            if HCI_LE_1M_PHY in scanning_phys:
-                scanning_phys_bits |= 1 << HCI_LE_1M_PHY_BIT
+            if hci.HCI_LE_1M_PHY in scanning_phys:
+                scanning_phys_bits |= 1 << hci.HCI_LE_1M_PHY_BIT
                 scanning_phy_count += 1
-            if HCI_LE_CODED_PHY in scanning_phys:
-                if self.supports_le_features(LeFeatureMask.LE_CODED_PHY):
-                    scanning_phys_bits |= 1 << HCI_LE_CODED_PHY_BIT
+            if hci.HCI_LE_CODED_PHY in scanning_phys:
+                if self.supports_le_features(hci.LeFeatureMask.LE_CODED_PHY):
+                    scanning_phys_bits |= 1 << hci.HCI_LE_CODED_PHY_BIT
                     scanning_phy_count += 1
 
             if scanning_phy_count == 0:
                 raise InvalidArgumentError('at least one scanning PHY must be enabled')
 
             await self.send_command(
-                HCI_LE_Set_Extended_Scan_Parameters_Command(
+                hci.HCI_LE_Set_Extended_Scan_Parameters_Command(
                     own_address_type=own_address_type,
                     scanning_filter_policy=scanning_filter_policy,
                     scanning_phys=scanning_phys_bits,
                     scan_types=[scan_type] * scanning_phy_count,
-                    scan_intervals=[int(scan_window / 0.625)] * scanning_phy_count,
+                    scan_intervals=[int(scan_interval / 0.625)] * scanning_phy_count,
                     scan_windows=[int(scan_window / 0.625)] * scanning_phy_count,
                 ),
                 check_result=True,
@@ -2736,7 +3179,7 @@ class Device(CompositeEventEmitter):
 
             # Enable scanning
             await self.send_command(
-                HCI_LE_Set_Extended_Scan_Enable_Command(
+                hci.HCI_LE_Set_Extended_Scan_Enable_Command(
                     enable=1,
                     filter_duplicates=1 if filter_duplicates else 0,
                     duration=0,  # TODO allow other values
@@ -2747,25 +3190,25 @@ class Device(CompositeEventEmitter):
         else:
             # Set the scanning parameters
             scan_type = (
-                HCI_LE_Set_Scan_Parameters_Command.ACTIVE_SCANNING
+                hci.HCI_LE_Set_Scan_Parameters_Command.ACTIVE_SCANNING
                 if active
-                else HCI_LE_Set_Scan_Parameters_Command.PASSIVE_SCANNING
+                else hci.HCI_LE_Set_Scan_Parameters_Command.PASSIVE_SCANNING
             )
             await self.send_command(
                 # pylint: disable=line-too-long
-                HCI_LE_Set_Scan_Parameters_Command(
+                hci.HCI_LE_Set_Scan_Parameters_Command(
                     le_scan_type=scan_type,
-                    le_scan_interval=int(scan_window / 0.625),
+                    le_scan_interval=int(scan_interval / 0.625),
                     le_scan_window=int(scan_window / 0.625),
                     own_address_type=own_address_type,
-                    scanning_filter_policy=HCI_LE_Set_Scan_Parameters_Command.BASIC_UNFILTERED_POLICY,
+                    scanning_filter_policy=hci.HCI_LE_Set_Scan_Parameters_Command.BASIC_UNFILTERED_POLICY,
                 ),
                 check_result=True,
             )
 
             # Enable scanning
             await self.send_command(
-                HCI_LE_Set_Scan_Enable_Command(
+                hci.HCI_LE_Set_Scan_Enable_Command(
                     le_scan_enable=1, filter_duplicates=1 if filter_duplicates else 0
                 ),
                 check_result=True,
@@ -2778,14 +3221,16 @@ class Device(CompositeEventEmitter):
         # Disable scanning
         if not legacy and self.supports_le_extended_advertising:
             await self.send_command(
-                HCI_LE_Set_Extended_Scan_Enable_Command(
+                hci.HCI_LE_Set_Extended_Scan_Enable_Command(
                     enable=0, filter_duplicates=0, duration=0, period=0
                 ),
                 check_result=True,
             )
         else:
             await self.send_command(
-                HCI_LE_Set_Scan_Enable_Command(le_scan_enable=0, filter_duplicates=0),
+                hci.HCI_LE_Set_Scan_Enable_Command(
+                    le_scan_enable=0, filter_duplicates=0
+                ),
                 check_result=True,
             )
 
@@ -2801,11 +3246,11 @@ class Device(CompositeEventEmitter):
             accumulator = AdvertisementDataAccumulator(passive=self.scanning_is_passive)
             self.advertisement_accumulators[report.address] = accumulator
         if advertisement := accumulator.update(report):
-            self.emit('advertisement', advertisement)
+            self.emit(self.EVENT_ADVERTISEMENT, advertisement)
 
     async def create_periodic_advertising_sync(
         self,
-        advertiser_address: Address,
+        advertiser_address: hci.Address,
         sid: int,
         skip: int = DEVICE_DEFAULT_PERIODIC_ADVERTISING_SYNC_SKIP,
         sync_timeout: float = DEVICE_DEFAULT_PERIODIC_ADVERTISING_SYNC_TIMEOUT,
@@ -2866,7 +3311,7 @@ class Device(CompositeEventEmitter):
         status: int,
         sync_handle: int,
         advertising_sid: int,
-        advertiser_address: Address,
+        advertiser_address: hci.Address,
         advertiser_phy: int,
         periodic_advertising_interval: int,
         advertiser_clock_accuracy: int,
@@ -2884,7 +3329,7 @@ class Device(CompositeEventEmitter):
                     advertiser_clock_accuracy,
                 )
 
-                AsyncRunner.spawn(self._update_periodic_advertising_syncs())
+                utils.AsyncRunner.spawn(self._update_periodic_advertising_syncs())
 
                 return
 
@@ -2892,6 +3337,41 @@ class Device(CompositeEventEmitter):
             "periodic advertising sync establishment for unknown address/sid"
         )
 
+    @host_event_handler
+    def on_periodic_advertising_sync_transfer(
+        self,
+        status: int,
+        connection_handle: int,
+        sync_handle: int,
+        advertising_sid: int,
+        advertiser_address: hci.Address,
+        advertiser_phy: int,
+        periodic_advertising_interval: int,
+        advertiser_clock_accuracy: int,
+    ) -> None:
+        if not (connection := self.lookup_connection(connection_handle)):
+            logger.error(
+                "Receive PAST from unknown connection 0x%04X", connection_handle
+            )
+
+        pa_sync = PeriodicAdvertisingSync(
+            device=self,
+            advertiser_address=advertiser_address,
+            sid=advertising_sid,
+            skip=0,
+            sync_timeout=0.0,
+            filter_duplicates=False,
+        )
+        self.periodic_advertising_syncs.append(pa_sync)
+        pa_sync.on_establishment(
+            status=status,
+            sync_handle=sync_handle,
+            advertiser_phy=advertiser_phy,
+            periodic_advertising_interval=periodic_advertising_interval,
+            advertiser_clock_accuracy=advertiser_clock_accuracy,
+        )
+        self.emit(self.EVENT_PERIODIC_ADVERTISING_SYNC_TRANSFER, pa_sync, connection)
+
     @host_event_handler
     @with_periodic_advertising_sync_from_handle
     def on_periodic_advertising_sync_loss(
@@ -2904,7 +3384,7 @@ class Device(CompositeEventEmitter):
     def on_periodic_advertising_report(
         self,
         periodic_advertising_sync: PeriodicAdvertisingSync,
-        report: HCI_LE_Periodic_Advertising_Report_Event,
+        report: hci.HCI_LE_Periodic_Advertising_Report_Event,
     ):
         periodic_advertising_sync.on_periodic_advertising_report(report)
 
@@ -2913,40 +3393,42 @@ class Device(CompositeEventEmitter):
     def on_biginfo_advertising_report(
         self,
         periodic_advertising_sync: PeriodicAdvertisingSync,
-        report: HCI_LE_BIGInfo_Advertising_Report_Event,
+        report: hci.HCI_LE_BIGInfo_Advertising_Report_Event,
     ):
         periodic_advertising_sync.on_biginfo_advertising_report(report)
 
     async def start_discovery(self, auto_restart: bool = True) -> None:
         await self.send_command(
-            HCI_Write_Inquiry_Mode_Command(inquiry_mode=HCI_EXTENDED_INQUIRY_MODE),
+            hci.HCI_Write_Inquiry_Mode_Command(
+                inquiry_mode=hci.HCI_EXTENDED_INQUIRY_MODE
+            ),
             check_result=True,
         )
 
         response = await self.send_command(
-            HCI_Inquiry_Command(
-                lap=HCI_GENERAL_INQUIRY_LAP,
+            hci.HCI_Inquiry_Command(
+                lap=hci.HCI_GENERAL_INQUIRY_LAP,
                 inquiry_length=DEVICE_DEFAULT_INQUIRY_LENGTH,
                 num_responses=0,  # Unlimited number of responses.
             )
         )
-        if response.status != HCI_Command_Status_Event.PENDING:
+        if response.status != hci.HCI_Command_Status_Event.PENDING:
             self.discovering = False
-            raise HCI_StatusError(response)
+            raise hci.HCI_StatusError(response)
 
         self.auto_restart_inquiry = auto_restart
         self.discovering = True
 
     async def stop_discovery(self) -> None:
         if self.discovering:
-            await self.send_command(HCI_Inquiry_Cancel_Command(), check_result=True)
+            await self.send_command(hci.HCI_Inquiry_Cancel_Command(), check_result=True)
         self.auto_restart_inquiry = True
         self.discovering = False
 
     @host_event_handler
     def on_inquiry_result(self, address, class_of_device, data, rssi):
         self.emit(
-            'inquiry_result',
+            self.EVENT_INQUIRY_RESULT,
             address,
             class_of_device,
             AdvertisingData.from_bytes(data),
@@ -2964,7 +3446,7 @@ class Device(CompositeEventEmitter):
             scan_enable = 0x00
 
         return await self.send_command(
-            HCI_Write_Scan_Enable_Command(scan_enable=scan_enable)
+            hci.HCI_Write_Scan_Enable_Command(scan_enable=scan_enable)
         )
 
     async def set_discoverable(self, discoverable: bool = True) -> None:
@@ -2985,7 +3467,7 @@ class Device(CompositeEventEmitter):
 
             # Update the controller
             await self.send_command(
-                HCI_Write_Extended_Inquiry_Response_Command(
+                hci.HCI_Write_Extended_Inquiry_Response_Command(
                     fec_required=0, extended_inquiry_response=self.inquiry_response
                 ),
                 check_result=True,
@@ -3005,12 +3487,12 @@ class Device(CompositeEventEmitter):
 
     async def connect(
         self,
-        peer_address: Union[Address, str],
-        transport: int = BT_LE_TRANSPORT,
+        peer_address: Union[hci.Address, str],
+        transport: core.PhysicalTransport = PhysicalTransport.LE,
         connection_parameters_preferences: Optional[
-            Dict[int, ConnectionParametersPreferences]
+            dict[hci.Phy, ConnectionParametersPreferences]
         ] = None,
-        own_address_type: int = OwnAddressType.RANDOM,
+        own_address_type: hci.OwnAddressType = hci.OwnAddressType.RANDOM,
         timeout: Optional[float] = DEVICE_DEFAULT_CONNECT_TIMEOUT,
         always_resolve: bool = False,
     ) -> Connection:
@@ -3022,7 +3504,7 @@ class Device(CompositeEventEmitter):
 
         Args:
           peer_address:
-            Address or name of the device to connect to.
+            hci.Address or name of the device to connect to.
             If a string is passed:
               If the string is an address followed by a `@` suffix, the `always_resolve`
               argument is implicitly set to True, so the connection is made to the
@@ -3042,8 +3524,8 @@ class Device(CompositeEventEmitter):
 
           own_address_type:
             (BLE only, ignored for BR/EDR)
-            OwnAddressType.RANDOM to use this device's random address, or
-            OwnAddressType.PUBLIC to use this device's public address.
+            hci.OwnAddressType.RANDOM to use this device's random address, or
+            hci.OwnAddressType.PUBLIC to use this device's public address.
 
           timeout:
             Maximum time to wait for a connection to be established, in seconds.
@@ -3056,29 +3538,30 @@ class Device(CompositeEventEmitter):
         '''
 
         # Check parameters
-        if transport not in (BT_LE_TRANSPORT, BT_BR_EDR_TRANSPORT):
+        if transport not in (PhysicalTransport.LE, PhysicalTransport.BR_EDR):
             raise InvalidArgumentError('invalid transport')
+        transport = core.PhysicalTransport(transport)
 
         # Adjust the transport automatically if we need to
-        if transport == BT_LE_TRANSPORT and not self.le_enabled:
-            transport = BT_BR_EDR_TRANSPORT
-        elif transport == BT_BR_EDR_TRANSPORT and not self.classic_enabled:
-            transport = BT_LE_TRANSPORT
+        if transport == PhysicalTransport.LE and not self.le_enabled:
+            transport = PhysicalTransport.BR_EDR
+        elif transport == PhysicalTransport.BR_EDR and not self.classic_enabled:
+            transport = PhysicalTransport.LE
 
         # Check that there isn't already a pending connection
-        if transport == BT_LE_TRANSPORT and self.is_le_connecting:
+        if transport == PhysicalTransport.LE and self.is_le_connecting:
             raise InvalidStateError('connection already pending')
 
         if isinstance(peer_address, str):
             try:
-                if transport == BT_LE_TRANSPORT and peer_address.endswith('@'):
-                    peer_address = Address.from_string_for_transport(
+                if transport == PhysicalTransport.LE and peer_address.endswith('@'):
+                    peer_address = hci.Address.from_string_for_transport(
                         peer_address[:-1], transport
                     )
                     always_resolve = True
                     logger.debug('forcing address resolution')
                 else:
-                    peer_address = Address.from_string_for_transport(
+                    peer_address = hci.Address.from_string_for_transport(
                         peer_address, transport
                     )
             except (InvalidArgumentError, ValueError):
@@ -3091,21 +3574,21 @@ class Device(CompositeEventEmitter):
         else:
             # All BR/EDR addresses should be public addresses
             if (
-                transport == BT_BR_EDR_TRANSPORT
-                and peer_address.address_type != Address.PUBLIC_DEVICE_ADDRESS
+                transport == PhysicalTransport.BR_EDR
+                and peer_address.address_type != hci.Address.PUBLIC_DEVICE_ADDRESS
             ):
                 raise InvalidArgumentError('BR/EDR addresses must be PUBLIC')
 
-        assert isinstance(peer_address, Address)
+        assert isinstance(peer_address, hci.Address)
 
-        if transport == BT_LE_TRANSPORT and always_resolve:
+        if transport == PhysicalTransport.LE and always_resolve:
             logger.debug('resolving address')
             peer_address = await self.find_peer_by_identity_address(
                 peer_address
             )  # TODO: timeout
 
         def on_connection(connection):
-            if transport == BT_LE_TRANSPORT or (
+            if transport == PhysicalTransport.LE or (
                 # match BR/EDR connection event against peer address
                 connection.transport == transport
                 and connection.peer_address == peer_address
@@ -3113,7 +3596,7 @@ class Device(CompositeEventEmitter):
                 pending_connection.set_result(connection)
 
         def on_connection_failure(error):
-            if transport == BT_LE_TRANSPORT or (
+            if transport == PhysicalTransport.LE or (
                 # match BR/EDR connection failure event against peer address
                 error.transport == transport
                 and error.peer_address == peer_address
@@ -3122,22 +3605,22 @@ class Device(CompositeEventEmitter):
 
         # Create a future so that we can wait for the connection's result
         pending_connection = asyncio.get_running_loop().create_future()
-        self.on('connection', on_connection)
-        self.on('connection_failure', on_connection_failure)
+        self.on(self.EVENT_CONNECTION, on_connection)
+        self.on(self.EVENT_CONNECTION_FAILURE, on_connection_failure)
 
         try:
             # Tell the controller to connect
-            if transport == BT_LE_TRANSPORT:
+            if transport == PhysicalTransport.LE:
                 if connection_parameters_preferences is None:
                     if connection_parameters_preferences is None:
                         connection_parameters_preferences = {
-                            HCI_LE_1M_PHY: ConnectionParametersPreferences.default
+                            hci.HCI_LE_1M_PHY: ConnectionParametersPreferences.default
                         }
 
                 self.connect_own_address_type = own_address_type
 
                 if self.host.supports_command(
-                    HCI_LE_EXTENDED_CREATE_CONNECTION_COMMAND
+                    hci.HCI_LE_EXTENDED_CREATE_CONNECTION_COMMAND
                 ):
                     # Only keep supported PHYs
                     phys = sorted(
@@ -3154,7 +3637,7 @@ class Device(CompositeEventEmitter):
                         raise InvalidArgumentError('at least one supported PHY needed')
 
                     phy_count = len(phys)
-                    initiating_phys = phy_list_to_bits(phys)
+                    initiating_phys = hci.phy_list_to_bits(phys)
 
                     connection_interval_mins = [
                         int(
@@ -3199,7 +3682,7 @@ class Device(CompositeEventEmitter):
                     ]
 
                     result = await self.send_command(
-                        HCI_LE_Extended_Create_Connection_Command(
+                        hci.HCI_LE_Extended_Create_Connection_Command(
                             initiator_filter_policy=0,
                             own_address_type=own_address_type,
                             peer_address_type=peer_address.address_type,
@@ -3222,12 +3705,12 @@ class Device(CompositeEventEmitter):
                         )
                     )
                 else:
-                    if HCI_LE_1M_PHY not in connection_parameters_preferences:
+                    if hci.HCI_LE_1M_PHY not in connection_parameters_preferences:
                         raise InvalidArgumentError('1M PHY preferences required')
 
-                    prefs = connection_parameters_preferences[HCI_LE_1M_PHY]
+                    prefs = connection_parameters_preferences[hci.HCI_LE_1M_PHY]
                     result = await self.send_command(
-                        HCI_LE_Create_Connection_Command(
+                        hci.HCI_LE_Create_Connection_Command(
                             le_scan_interval=int(
                                 DEVICE_DEFAULT_CONNECT_SCAN_INTERVAL / 0.625
                             ),
@@ -3253,51 +3736,57 @@ class Device(CompositeEventEmitter):
             else:
                 # Save pending connection
                 self.pending_connections[peer_address] = Connection.incomplete(
-                    self, peer_address, BT_CENTRAL_ROLE
+                    self, peer_address, hci.Role.CENTRAL
                 )
 
                 # TODO: allow passing other settings
                 result = await self.send_command(
-                    HCI_Create_Connection_Command(
+                    hci.HCI_Create_Connection_Command(
                         bd_addr=peer_address,
                         packet_type=0xCC18,  # FIXME: change
-                        page_scan_repetition_mode=HCI_R2_PAGE_SCAN_REPETITION_MODE,
+                        page_scan_repetition_mode=hci.HCI_R2_PAGE_SCAN_REPETITION_MODE,
                         clock_offset=0x0000,
                         allow_role_switch=0x01,
                         reserved=0,
                     )
                 )
 
-            if result.status != HCI_Command_Status_Event.PENDING:
-                raise HCI_StatusError(result)
+            if result.status != hci.HCI_Command_Status_Event.PENDING:
+                raise hci.HCI_StatusError(result)
 
             # Wait for the connection process to complete
-            if transport == BT_LE_TRANSPORT:
+            if transport == PhysicalTransport.LE:
                 self.le_connecting = True
 
             if timeout is None:
-                return await self.abort_on('flush', pending_connection)
+                return await utils.cancel_on_event(
+                    self, Device.EVENT_FLUSH, pending_connection
+                )
 
             try:
                 return await asyncio.wait_for(
                     asyncio.shield(pending_connection), timeout
                 )
             except asyncio.TimeoutError:
-                if transport == BT_LE_TRANSPORT:
-                    await self.send_command(HCI_LE_Create_Connection_Cancel_Command())
+                if transport == PhysicalTransport.LE:
+                    await self.send_command(
+                        hci.HCI_LE_Create_Connection_Cancel_Command()
+                    )
                 else:
                     await self.send_command(
-                        HCI_Create_Connection_Cancel_Command(bd_addr=peer_address)
+                        hci.HCI_Create_Connection_Cancel_Command(bd_addr=peer_address)
                     )
 
                 try:
-                    return await self.abort_on('flush', pending_connection)
+                    return await utils.cancel_on_event(
+                        self, Device.EVENT_FLUSH, pending_connection
+                    )
                 except core.ConnectionError as error:
                     raise core.TimeoutError() from error
         finally:
-            self.remove_listener('connection', on_connection)
-            self.remove_listener('connection_failure', on_connection_failure)
-            if transport == BT_LE_TRANSPORT:
+            self.remove_listener(self.EVENT_CONNECTION, on_connection)
+            self.remove_listener(self.EVENT_CONNECTION_FAILURE, on_connection_failure)
+            if transport == PhysicalTransport.LE:
                 self.le_connecting = False
                 self.connect_own_address_type = None
             else:
@@ -3305,8 +3794,8 @@ class Device(CompositeEventEmitter):
 
     async def accept(
         self,
-        peer_address: Union[Address, str] = Address.ANY,
-        role: int = BT_PERIPHERAL_ROLE,
+        peer_address: Union[hci.Address, str] = hci.Address.ANY,
+        role: hci.Role = hci.Role.PERIPHERAL,
         timeout: Optional[float] = DEVICE_DEFAULT_CONNECT_TIMEOUT,
     ) -> Connection:
         '''
@@ -3322,24 +3811,24 @@ class Device(CompositeEventEmitter):
 
         if isinstance(peer_address, str):
             try:
-                peer_address = Address(peer_address)
+                peer_address = hci.Address(peer_address)
             except InvalidArgumentError:
                 # If the address is not parsable, assume it is a name instead
                 logger.debug('looking for peer by name')
                 peer_address = await self.find_peer_by_name(
-                    peer_address, BT_BR_EDR_TRANSPORT
+                    peer_address, PhysicalTransport.BR_EDR
                 )  # TODO: timeout
 
-        assert isinstance(peer_address, Address)
+        assert isinstance(peer_address, hci.Address)
 
-        if peer_address == Address.NIL:
+        if peer_address == hci.Address.NIL:
             raise InvalidArgumentError('accept on nil address')
 
         # Create a future so that we can wait for the request
         pending_request_fut = asyncio.get_running_loop().create_future()
 
-        if peer_address == Address.ANY:
-            self.classic_pending_accepts[Address.ANY].append(pending_request_fut)
+        if peer_address == hci.Address.ANY:
+            self.classic_pending_accepts[hci.Address.ANY].append(pending_request_fut)
         elif peer_address in self.classic_pending_accepts:
             raise InvalidStateError('accept connection already pending')
         else:
@@ -3347,7 +3836,9 @@ class Device(CompositeEventEmitter):
 
         try:
             # Wait for a request or a completed connection
-            pending_request = self.abort_on('flush', pending_request_fut)
+            pending_request = utils.cancel_on_event(
+                self, Device.EVENT_FLUSH, pending_request_fut
+            )
             result = await (
                 asyncio.wait_for(pending_request, timeout)
                 if timeout
@@ -3355,8 +3846,10 @@ class Device(CompositeEventEmitter):
             )
         except Exception:
             # Remove future from device context
-            if peer_address == Address.ANY:
-                self.classic_pending_accepts[Address.ANY].remove(pending_request_fut)
+            if peer_address == hci.Address.ANY:
+                self.classic_pending_accepts[hci.Address.ANY].remove(
+                    pending_request_fut
+                )
             else:
                 self.classic_pending_accepts.pop(peer_address)
             raise
@@ -3368,48 +3861,52 @@ class Device(CompositeEventEmitter):
 
         # Otherwise, result came from `on_connection_request`
         peer_address, _class_of_device, _link_type = result
-        assert isinstance(peer_address, Address)
+        assert isinstance(peer_address, hci.Address)
 
         # Create a future so that we can wait for the connection's result
         pending_connection = asyncio.get_running_loop().create_future()
 
         def on_connection(connection):
             if (
-                connection.transport == BT_BR_EDR_TRANSPORT
+                connection.transport == PhysicalTransport.BR_EDR
                 and connection.peer_address == peer_address
             ):
                 pending_connection.set_result(connection)
 
         def on_connection_failure(error):
             if (
-                error.transport == BT_BR_EDR_TRANSPORT
+                error.transport == PhysicalTransport.BR_EDR
                 and error.peer_address == peer_address
             ):
                 pending_connection.set_exception(error)
 
-        self.on('connection', on_connection)
-        self.on('connection_failure', on_connection_failure)
+        self.on(self.EVENT_CONNECTION, on_connection)
+        self.on(self.EVENT_CONNECTION_FAILURE, on_connection_failure)
 
-        # Save pending connection, with the Peripheral role.
-        # Even if we requested a role switch in the HCI_Accept_Connection_Request
+        # Save pending connection, with the Peripheral hci.role.
+        # Even if we requested a role switch in the hci.HCI_Accept_Connection_Request
         # command, this connection is still considered Peripheral until an eventual
         # role change event.
         self.pending_connections[peer_address] = Connection.incomplete(
-            self, peer_address, BT_PERIPHERAL_ROLE
+            self, peer_address, hci.Role.PERIPHERAL
         )
 
         try:
             # Accept connection request
             await self.send_command(
-                HCI_Accept_Connection_Request_Command(bd_addr=peer_address, role=role)
+                hci.HCI_Accept_Connection_Request_Command(
+                    bd_addr=peer_address, role=role
+                )
             )
 
             # Wait for connection complete
-            return await self.abort_on('flush', pending_connection)
+            return await utils.cancel_on_event(
+                self, Device.EVENT_FLUSH, pending_connection
+            )
 
         finally:
-            self.remove_listener('connection', on_connection)
-            self.remove_listener('connection_failure', on_connection_failure)
+            self.remove_listener(self.EVENT_CONNECTION, on_connection)
+            self.remove_listener(self.EVENT_CONNECTION_FAILURE, on_connection_failure)
             self.pending_connections.pop(peer_address, None)
 
     @asynccontextmanager
@@ -3436,7 +3933,7 @@ class Device(CompositeEventEmitter):
             if not self.is_le_connecting:
                 return
             await self.send_command(
-                HCI_LE_Create_Connection_Cancel_Command(), check_result=True
+                hci.HCI_LE_Create_Connection_Cancel_Command(), check_result=True
             )
 
         # BR/EDR: try to cancel to ongoing connection
@@ -3445,16 +3942,16 @@ class Device(CompositeEventEmitter):
         else:
             if isinstance(peer_address, str):
                 try:
-                    peer_address = Address(peer_address)
+                    peer_address = hci.Address(peer_address)
                 except InvalidArgumentError:
                     # If the address is not parsable, assume it is a name instead
                     logger.debug('looking for peer by name')
                     peer_address = await self.find_peer_by_name(
-                        peer_address, BT_BR_EDR_TRANSPORT
+                        peer_address, PhysicalTransport.BR_EDR
                     )  # TODO: timeout
 
             await self.send_command(
-                HCI_Create_Connection_Cancel_Command(bd_addr=peer_address),
+                hci.HCI_Create_Connection_Cancel_Command(bd_addr=peer_address),
                 check_result=True,
             )
 
@@ -3463,27 +3960,34 @@ class Device(CompositeEventEmitter):
     ) -> None:
         # Create a future so that we can wait for the disconnection's result
         pending_disconnection = asyncio.get_running_loop().create_future()
-        connection.on('disconnection', pending_disconnection.set_result)
-        connection.on('disconnection_failure', pending_disconnection.set_exception)
+        connection.on(connection.EVENT_DISCONNECTION, pending_disconnection.set_result)
+        connection.on(
+            connection.EVENT_DISCONNECTION_FAILURE, pending_disconnection.set_exception
+        )
 
         # Request a disconnection
         result = await self.send_command(
-            HCI_Disconnect_Command(connection_handle=connection.handle, reason=reason)
+            hci.HCI_Disconnect_Command(
+                connection_handle=connection.handle, reason=reason
+            )
         )
 
         try:
-            if result.status != HCI_Command_Status_Event.PENDING:
-                raise HCI_StatusError(result)
+            if result.status != hci.HCI_Command_Status_Event.PENDING:
+                raise hci.HCI_StatusError(result)
 
             # Wait for the disconnection process to complete
             self.disconnecting = True
-            return await self.abort_on('flush', pending_disconnection)
+            return await utils.cancel_on_event(
+                self, Device.EVENT_FLUSH, pending_disconnection
+            )
         finally:
             connection.remove_listener(
-                'disconnection', pending_disconnection.set_result
+                connection.EVENT_DISCONNECTION, pending_disconnection.set_result
             )
             connection.remove_listener(
-                'disconnection_failure', pending_disconnection.set_exception
+                connection.EVENT_DISCONNECTION_FAILURE,
+                pending_disconnection.set_exception,
             )
             self.disconnecting = False
 
@@ -3495,7 +3999,7 @@ class Device(CompositeEventEmitter):
             raise InvalidArgumentError('tx_time must be between 0x0148 and 0x4290')
 
         return await self.send_command(
-            HCI_LE_Set_Data_Length_Command(
+            hci.HCI_LE_Set_Data_Length_Command(
                 connection_handle=connection.handle,
                 tx_octets=tx_octets,
                 tx_time=tx_time,
@@ -3505,22 +4009,41 @@ class Device(CompositeEventEmitter):
 
     async def update_connection_parameters(
         self,
-        connection,
-        connection_interval_min,
-        connection_interval_max,
-        max_latency,
-        supervision_timeout,
-        min_ce_length=0,
-        max_ce_length=0,
-        use_l2cap=False,
+        connection: Connection,
+        connection_interval_min: float,
+        connection_interval_max: float,
+        max_latency: int,
+        supervision_timeout: float,
+        min_ce_length: float = 0.0,
+        max_ce_length: float = 0.0,
+        use_l2cap: bool = False,
     ) -> None:
         '''
+        Request an update of the connection parameters.
+
+        Args:
+          connection: The connection to update
+          connection_interval_min: Minimum interval, in milliseconds.
+          connection_interval_max: Maximum interval, in milliseconds.
+          max_latency: Latency, in number of intervals.
+          supervision_timeout: Timeout, in milliseconds.
+          min_ce_length: Minimum connection event length, in milliseconds.
+          max_ce_length: Maximum connection event length, in milliseconds.
+          use_l2cap: Request the update via L2CAP.
+
         NOTE: the name of the parameters may look odd, but it just follows the names
         used in the Bluetooth spec.
         '''
 
+        # Convert the input parameters
+        connection_interval_min = int(connection_interval_min / 1.25)
+        connection_interval_max = int(connection_interval_max / 1.25)
+        supervision_timeout = int(supervision_timeout / 10)
+        min_ce_length = int(min_ce_length / 0.625)
+        max_ce_length = int(max_ce_length / 0.625)
+
         if use_l2cap:
-            if connection.role != BT_PERIPHERAL_ROLE:
+            if connection.role != hci.Role.PERIPHERAL:
                 raise InvalidStateError(
                     'only peripheral can update connection parameters with l2cap'
                 )
@@ -3536,8 +4059,10 @@ class Device(CompositeEventEmitter):
             if l2cap_result != l2cap.L2CAP_CONNECTION_PARAMETERS_ACCEPTED_RESULT:
                 raise ConnectionParameterUpdateError(l2cap_result)
 
+            return
+
         result = await self.send_command(
-            HCI_LE_Connection_Update_Command(
+            hci.HCI_LE_Connection_Update_Command(
                 connection_handle=connection.handle,
                 connection_interval_min=connection_interval_min,
                 connection_interval_max=connection_interval_max,
@@ -3547,26 +4072,31 @@ class Device(CompositeEventEmitter):
                 max_ce_length=max_ce_length,
             )
         )
-        if result.status != HCI_Command_Status_Event.PENDING:
-            raise HCI_StatusError(result)
+        if result.status != hci.HCI_Command_Status_Event.PENDING:
+            raise hci.HCI_StatusError(result)
 
     async def get_connection_rssi(self, connection):
         result = await self.send_command(
-            HCI_Read_RSSI_Command(handle=connection.handle), check_result=True
+            hci.HCI_Read_RSSI_Command(handle=connection.handle), check_result=True
         )
         return result.return_parameters.rssi
 
-    async def get_connection_phy(self, connection):
+    async def get_connection_phy(self, connection: Connection) -> ConnectionPHY:
+        if not self.host.supports_command(hci.HCI_LE_READ_PHY_COMMAND):
+            return ConnectionPHY(hci.Phy.LE_1M, hci.Phy.LE_1M)
+
         result = await self.send_command(
-            HCI_LE_Read_PHY_Command(connection_handle=connection.handle),
+            hci.HCI_LE_Read_PHY_Command(connection_handle=connection.handle),
             check_result=True,
         )
-        return (result.return_parameters.tx_phy, result.return_parameters.rx_phy)
+        return ConnectionPHY(
+            result.return_parameters.tx_phy, result.return_parameters.rx_phy
+        )
 
     async def set_connection_phy(
         self, connection, tx_phys=None, rx_phys=None, phy_options=None
     ):
-        if not self.host.supports_command(HCI_LE_SET_PHY_COMMAND):
+        if not self.host.supports_command(hci.HCI_LE_SET_PHY_COMMAND):
             logger.warning('ignoring request, command not supported')
             return
 
@@ -3575,21 +4105,21 @@ class Device(CompositeEventEmitter):
         )
 
         result = await self.send_command(
-            HCI_LE_Set_PHY_Command(
+            hci.HCI_LE_Set_PHY_Command(
                 connection_handle=connection.handle,
                 all_phys=all_phys_bits,
-                tx_phys=phy_list_to_bits(tx_phys),
-                rx_phys=phy_list_to_bits(rx_phys),
+                tx_phys=hci.phy_list_to_bits(tx_phys),
+                rx_phys=hci.phy_list_to_bits(rx_phys),
                 phy_options=0 if phy_options is None else int(phy_options),
             )
         )
 
-        if result.status != HCI_COMMAND_STATUS_PENDING:
+        if result.status != hci.HCI_COMMAND_STATUS_PENDING:
             logger.warning(
                 'HCI_LE_Set_PHY_Command failed: '
-                f'{HCI_Constant.error_name(result.status)}'
+                f'{hci.HCI_Constant.error_name(result.status)}'
             )
-            raise HCI_StatusError(result)
+            raise hci.HCI_StatusError(result)
 
     async def set_default_phy(self, tx_phys=None, rx_phys=None):
         all_phys_bits = (1 if tx_phys is None else 0) | (
@@ -3597,10 +4127,10 @@ class Device(CompositeEventEmitter):
         )
 
         return await self.send_command(
-            HCI_LE_Set_Default_PHY_Command(
+            hci.HCI_LE_Set_Default_PHY_Command(
                 all_phys=all_phys_bits,
-                tx_phys=phy_list_to_bits(tx_phys),
-                rx_phys=phy_list_to_bits(rx_phys),
+                tx_phys=hci.phy_list_to_bits(tx_phys),
+                rx_phys=hci.phy_list_to_bits(rx_phys),
             ),
             check_result=True,
         )
@@ -3609,7 +4139,7 @@ class Device(CompositeEventEmitter):
         self, connection: Connection, sync_handle: int, service_data: int = 0
     ) -> None:
         return await self.send_command(
-            HCI_LE_Periodic_Advertising_Sync_Transfer_Command(
+            hci.HCI_LE_Periodic_Advertising_Sync_Transfer_Command(
                 connection_handle=connection.handle,
                 service_data=service_data,
                 sync_handle=sync_handle,
@@ -3617,7 +4147,19 @@ class Device(CompositeEventEmitter):
             check_result=True,
         )
 
-    async def find_peer_by_name(self, name, transport=BT_LE_TRANSPORT):
+    async def transfer_periodic_set_info(
+        self, connection: Connection, advertising_handle: int, service_data: int = 0
+    ) -> None:
+        return await self.send_command(
+            hci.HCI_LE_Periodic_Advertising_Set_Info_Transfer_Command(
+                connection_handle=connection.handle,
+                service_data=service_data,
+                advertising_handle=advertising_handle,
+            ),
+            check_result=True,
+        )
+
+    async def find_peer_by_name(self, name, transport=PhysicalTransport.LE):
         """
         Scan for a peer with a given name and return its address.
         """
@@ -3625,19 +4167,18 @@ class Device(CompositeEventEmitter):
         # Create a future to wait for an address to be found
         peer_address = asyncio.get_running_loop().create_future()
 
-        def on_peer_found(address, ad_data):
-            local_name = ad_data.get(AdvertisingData.COMPLETE_LOCAL_NAME, raw=True)
-            if local_name is None:
-                local_name = ad_data.get(AdvertisingData.SHORTENED_LOCAL_NAME, raw=True)
-            if local_name is not None:
-                if local_name.decode('utf-8') == name:
-                    peer_address.set_result(address)
+        def on_peer_found(address: hci.Address, ad_data: AdvertisingData) -> None:
+            local_name = ad_data.get(
+                AdvertisingData.Type.COMPLETE_LOCAL_NAME
+            ) or ad_data.get(AdvertisingData.Type.SHORTENED_LOCAL_NAME)
+            if local_name == name:
+                peer_address.set_result(address)
 
         listener = None
         was_scanning = self.scanning
         was_discovering = self.discovering
         try:
-            if transport == BT_LE_TRANSPORT:
+            if transport == PhysicalTransport.LE:
                 event_name = 'advertisement'
                 listener = self.on(
                     event_name,
@@ -3649,7 +4190,7 @@ class Device(CompositeEventEmitter):
                 if not self.scanning:
                     await self.start_scanning(filter_duplicates=True)
 
-            elif transport == BT_BR_EDR_TRANSPORT:
+            elif transport == PhysicalTransport.BR_EDR:
                 event_name = 'inquiry_result'
                 listener = self.on(
                     event_name,
@@ -3663,17 +4204,19 @@ class Device(CompositeEventEmitter):
             else:
                 return None
 
-            return await self.abort_on('flush', peer_address)
+            return await utils.cancel_on_event(self, Device.EVENT_FLUSH, peer_address)
         finally:
             if listener is not None:
                 self.remove_listener(event_name, listener)
 
-            if transport == BT_LE_TRANSPORT and not was_scanning:
+            if transport == PhysicalTransport.LE and not was_scanning:
                 await self.stop_scanning()
-            elif transport == BT_BR_EDR_TRANSPORT and not was_discovering:
+            elif transport == PhysicalTransport.BR_EDR and not was_discovering:
                 await self.stop_discovery()
 
-    async def find_peer_by_identity_address(self, identity_address: Address) -> Address:
+    async def find_peer_by_identity_address(
+        self, identity_address: hci.Address
+    ) -> hci.Address:
         """
         Scan for a peer with a resolvable address that can be resolved to a given
         identity address.
@@ -3711,7 +4254,7 @@ class Device(CompositeEventEmitter):
             if not self.scanning:
                 await self.start_scanning(filter_duplicates=True)
 
-            return await self.abort_on('flush', peer_address)
+            return await utils.cancel_on_event(self, Device.EVENT_FLUSH, peer_address)
         finally:
             if listener is not None:
                 self.remove_listener(event_name, listener)
@@ -3762,14 +4305,14 @@ class Device(CompositeEventEmitter):
                 if keys.ltk:
                     return keys.ltk.value
 
-                if connection.role == BT_CENTRAL_ROLE and keys.ltk_central:
+                if connection.role == hci.Role.CENTRAL and keys.ltk_central:
                     return keys.ltk_central.value
 
-                if connection.role == BT_PERIPHERAL_ROLE and keys.ltk_peripheral:
+                if connection.role == hci.Role.PERIPHERAL and keys.ltk_peripheral:
                     return keys.ltk_peripheral.value
         return None
 
-    async def get_link_key(self, address: Address) -> Optional[bytes]:
+    async def get_link_key(self, address: hci.Address) -> Optional[bytes]:
         if self.keystore is None:
             return None
 
@@ -3787,7 +4330,7 @@ class Device(CompositeEventEmitter):
         return keys.link_key.value
 
     # [Classic only]
-    async def authenticate(self, connection):
+    async def authenticate(self, connection: Connection) -> None:
         # Set up event handlers
         pending_authentication = asyncio.get_running_loop().create_future()
 
@@ -3795,35 +4338,43 @@ class Device(CompositeEventEmitter):
             pending_authentication.set_result(None)
 
         def on_authentication_failure(error_code):
-            pending_authentication.set_exception(HCI_Error(error_code))
+            pending_authentication.set_exception(hci.HCI_Error(error_code))
 
-        connection.on('connection_authentication', on_authentication)
-        connection.on('connection_authentication_failure', on_authentication_failure)
+        connection.on(connection.EVENT_CONNECTION_AUTHENTICATION, on_authentication)
+        connection.on(
+            connection.EVENT_CONNECTION_AUTHENTICATION_FAILURE,
+            on_authentication_failure,
+        )
 
         # Request the authentication
         try:
             result = await self.send_command(
-                HCI_Authentication_Requested_Command(
+                hci.HCI_Authentication_Requested_Command(
                     connection_handle=connection.handle
                 )
             )
-            if result.status != HCI_COMMAND_STATUS_PENDING:
+            if result.status != hci.HCI_COMMAND_STATUS_PENDING:
                 logger.warning(
                     'HCI_Authentication_Requested_Command failed: '
-                    f'{HCI_Constant.error_name(result.status)}'
+                    f'{hci.HCI_Constant.error_name(result.status)}'
                 )
-                raise HCI_StatusError(result)
+                raise hci.HCI_StatusError(result)
 
             # Wait for the authentication to complete
-            await connection.abort_on('disconnection', pending_authentication)
+            await utils.cancel_on_event(
+                connection, Connection.EVENT_DISCONNECTION, pending_authentication
+            )
         finally:
-            connection.remove_listener('connection_authentication', on_authentication)
             connection.remove_listener(
-                'connection_authentication_failure', on_authentication_failure
+                connection.EVENT_CONNECTION_AUTHENTICATION, on_authentication
+            )
+            connection.remove_listener(
+                connection.EVENT_CONNECTION_AUTHENTICATION_FAILURE,
+                on_authentication_failure,
             )
 
     async def encrypt(self, connection, enable=True):
-        if not enable and connection.transport == BT_LE_TRANSPORT:
+        if not enable and connection.transport == PhysicalTransport.LE:
             raise InvalidArgumentError('`enable` parameter is classic only.')
 
         # Set up event handlers
@@ -3833,14 +4384,18 @@ class Device(CompositeEventEmitter):
             pending_encryption.set_result(None)
 
         def on_encryption_failure(error_code):
-            pending_encryption.set_exception(HCI_Error(error_code))
+            pending_encryption.set_exception(hci.HCI_Error(error_code))
 
-        connection.on('connection_encryption_change', on_encryption_change)
-        connection.on('connection_encryption_failure', on_encryption_failure)
+        connection.on(
+            connection.EVENT_CONNECTION_ENCRYPTION_CHANGE, on_encryption_change
+        )
+        connection.on(
+            connection.EVENT_CONNECTION_ENCRYPTION_FAILURE, on_encryption_failure
+        )
 
         # Request the encryption
         try:
-            if connection.transport == BT_LE_TRANSPORT:
+            if connection.transport == PhysicalTransport.LE:
                 # Look for a key in the key store
                 if self.keystore is None:
                     raise InvalidOperationError('no key store')
@@ -3861,11 +4416,11 @@ class Device(CompositeEventEmitter):
                 else:
                     raise InvalidOperationError('no LTK found for peer')
 
-                if connection.role != HCI_CENTRAL_ROLE:
+                if connection.role != hci.Role.CENTRAL:
                     raise InvalidStateError('only centrals can start encryption')
 
                 result = await self.send_command(
-                    HCI_LE_Enable_Encryption_Command(
+                    hci.HCI_LE_Enable_Encryption_Command(
                         connection_handle=connection.handle,
                         random_number=rand,
                         encrypted_diversifier=ediv,
@@ -3873,35 +4428,37 @@ class Device(CompositeEventEmitter):
                     )
                 )
 
-                if result.status != HCI_COMMAND_STATUS_PENDING:
+                if result.status != hci.HCI_COMMAND_STATUS_PENDING:
                     logger.warning(
                         'HCI_LE_Enable_Encryption_Command failed: '
-                        f'{HCI_Constant.error_name(result.status)}'
+                        f'{hci.HCI_Constant.error_name(result.status)}'
                     )
-                    raise HCI_StatusError(result)
+                    raise hci.HCI_StatusError(result)
             else:
                 result = await self.send_command(
-                    HCI_Set_Connection_Encryption_Command(
+                    hci.HCI_Set_Connection_Encryption_Command(
                         connection_handle=connection.handle,
                         encryption_enable=0x01 if enable else 0x00,
                     )
                 )
 
-                if result.status != HCI_COMMAND_STATUS_PENDING:
+                if result.status != hci.HCI_COMMAND_STATUS_PENDING:
                     logger.warning(
                         'HCI_Set_Connection_Encryption_Command failed: '
-                        f'{HCI_Constant.error_name(result.status)}'
+                        f'{hci.HCI_Constant.error_name(result.status)}'
                     )
-                    raise HCI_StatusError(result)
+                    raise hci.HCI_StatusError(result)
 
             # Wait for the result
-            await connection.abort_on('disconnection', pending_encryption)
+            await utils.cancel_on_event(
+                connection, Connection.EVENT_DISCONNECTION, pending_encryption
+            )
         finally:
             connection.remove_listener(
-                'connection_encryption_change', on_encryption_change
+                connection.EVENT_CONNECTION_ENCRYPTION_CHANGE, on_encryption_change
             )
             connection.remove_listener(
-                'connection_encryption_failure', on_encryption_failure
+                connection.EVENT_CONNECTION_ENCRYPTION_FAILURE, on_encryption_failure
             )
 
     async def update_keys(self, address: str, keys: PairingKeys) -> None:
@@ -3914,45 +4471,51 @@ class Device(CompositeEventEmitter):
         except Exception as error:
             logger.warning(f'!!! error while storing keys: {error}')
         else:
-            self.emit('key_store_update')
+            self.emit(self.EVENT_KEY_STORE_UPDATE)
 
     # [Classic only]
-    async def switch_role(self, connection: Connection, role: int):
+    async def switch_role(self, connection: Connection, role: hci.Role):
         pending_role_change = asyncio.get_running_loop().create_future()
 
         def on_role_change(new_role):
             pending_role_change.set_result(new_role)
 
         def on_role_change_failure(error_code):
-            pending_role_change.set_exception(HCI_Error(error_code))
+            pending_role_change.set_exception(hci.HCI_Error(error_code))
 
-        connection.on('role_change', on_role_change)
-        connection.on('role_change_failure', on_role_change_failure)
+        connection.on(connection.EVENT_ROLE_CHANGE, on_role_change)
+        connection.on(connection.EVENT_ROLE_CHANGE_FAILURE, on_role_change_failure)
 
         try:
             result = await self.send_command(
-                HCI_Switch_Role_Command(bd_addr=connection.peer_address, role=role)
+                hci.HCI_Switch_Role_Command(bd_addr=connection.peer_address, role=role)
             )
-            if result.status != HCI_COMMAND_STATUS_PENDING:
+            if result.status != hci.HCI_COMMAND_STATUS_PENDING:
                 logger.warning(
                     'HCI_Switch_Role_Command failed: '
-                    f'{HCI_Constant.error_name(result.status)}'
+                    f'{hci.HCI_Constant.error_name(result.status)}'
                 )
-                raise HCI_StatusError(result)
-            await connection.abort_on('disconnection', pending_role_change)
+                raise hci.HCI_StatusError(result)
+            await utils.cancel_on_event(
+                connection, Connection.EVENT_DISCONNECTION, pending_role_change
+            )
         finally:
-            connection.remove_listener('role_change', on_role_change)
-            connection.remove_listener('role_change_failure', on_role_change_failure)
+            connection.remove_listener(connection.EVENT_ROLE_CHANGE, on_role_change)
+            connection.remove_listener(
+                connection.EVENT_ROLE_CHANGE_FAILURE, on_role_change_failure
+            )
 
     # [Classic only]
-    async def request_remote_name(self, remote: Union[Address, Connection]) -> str:
+    async def request_remote_name(self, remote: Union[hci.Address, Connection]) -> str:
         # Set up event handlers
         pending_name = asyncio.get_running_loop().create_future()
 
-        peer_address = remote if isinstance(remote, Address) else remote.peer_address
+        peer_address = (
+            remote if isinstance(remote, hci.Address) else remote.peer_address
+        )
 
         handler = self.on(
-            'remote_name',
+            self.EVENT_REMOTE_NAME,
             lambda address, remote_name: (
                 pending_name.set_result(remote_name)
                 if address == peer_address
@@ -3960,9 +4523,9 @@ class Device(CompositeEventEmitter):
             ),
         )
         failure_handler = self.on(
-            'remote_name_failure',
+            self.EVENT_REMOTE_NAME_FAILURE,
             lambda address, error_code: (
-                pending_name.set_exception(HCI_Error(error_code))
+                pending_name.set_exception(hci.HCI_Error(error_code))
                 if address == peer_address
                 else None
             ),
@@ -3970,40 +4533,40 @@ class Device(CompositeEventEmitter):
 
         try:
             result = await self.send_command(
-                HCI_Remote_Name_Request_Command(
+                hci.HCI_Remote_Name_Request_Command(
                     bd_addr=peer_address,
-                    page_scan_repetition_mode=HCI_Remote_Name_Request_Command.R2,
+                    page_scan_repetition_mode=hci.HCI_Remote_Name_Request_Command.R2,
                     reserved=0,
                     clock_offset=0,  # TODO investigate non-0 values
                 )
             )
 
-            if result.status != HCI_COMMAND_STATUS_PENDING:
+            if result.status != hci.HCI_COMMAND_STATUS_PENDING:
                 logger.warning(
                     'HCI_Remote_Name_Request_Command failed: '
-                    f'{HCI_Constant.error_name(result.status)}'
+                    f'{hci.HCI_Constant.error_name(result.status)}'
                 )
-                raise HCI_StatusError(result)
+                raise hci.HCI_StatusError(result)
 
             # Wait for the result
-            return await self.abort_on('flush', pending_name)
+            return await utils.cancel_on_event(self, Device.EVENT_FLUSH, pending_name)
         finally:
-            self.remove_listener('remote_name', handler)
-            self.remove_listener('remote_name_failure', failure_handler)
+            self.remove_listener(self.EVENT_REMOTE_NAME, handler)
+            self.remove_listener(self.EVENT_REMOTE_NAME_FAILURE, failure_handler)
 
     # [LE only]
-    @experimental('Only for testing.')
+    @utils.experimental('Only for testing.')
     async def setup_cig(
         self,
         cig_id: int,
-        cis_id: List[int],
-        sdu_interval: Tuple[int, int],
+        cis_id: Sequence[int],
+        sdu_interval: tuple[int, int],
         framing: int,
-        max_sdu: Tuple[int, int],
+        max_sdu: tuple[int, int],
         retransmission_number: int,
-        max_transport_latency: Tuple[int, int],
-    ) -> List[int]:
-        """Sends HCI_LE_Set_CIG_Parameters_Command.
+        max_transport_latency: tuple[int, int],
+    ) -> list[int]:
+        """Sends hci.HCI_LE_Set_CIG_Parameters_Command.
 
         Args:
             cig_id: CIG_ID.
@@ -4021,7 +4584,7 @@ class Device(CompositeEventEmitter):
         num_cis = len(cis_id)
 
         response = await self.send_command(
-            HCI_LE_Set_CIG_Parameters_Command(
+            hci.HCI_LE_Set_CIG_Parameters_Command(
                 cig_id=cig_id,
                 sdu_interval_c_to_p=sdu_interval[0],
                 sdu_interval_p_to_c=sdu_interval[1],
@@ -4033,8 +4596,8 @@ class Device(CompositeEventEmitter):
                 cis_id=cis_id,
                 max_sdu_c_to_p=[max_sdu[0]] * num_cis,
                 max_sdu_p_to_c=[max_sdu[1]] * num_cis,
-                phy_c_to_p=[HCI_LE_2M_PHY] * num_cis,
-                phy_p_to_c=[HCI_LE_2M_PHY] * num_cis,
+                phy_c_to_p=[hci.HCI_LE_2M_PHY] * num_cis,
+                phy_p_to_c=[hci.HCI_LE_2M_PHY] * num_cis,
                 rtn_c_to_p=[retransmission_number] * num_cis,
                 rtn_p_to_c=[retransmission_number] * num_cis,
             ),
@@ -4050,8 +4613,10 @@ class Device(CompositeEventEmitter):
         return cis_handles
 
     # [LE only]
-    @experimental('Only for testing.')
-    async def create_cis(self, cis_acl_pairs: List[Tuple[int, int]]) -> List[CisLink]:
+    @utils.experimental('Only for testing.')
+    async def create_cis(
+        self, cis_acl_pairs: Sequence[tuple[int, int]]
+    ) -> list[CisLink]:
         for cis_handle, acl_handle in cis_acl_pairs:
             acl_connection = self.lookup_connection(acl_handle)
             assert acl_connection
@@ -4064,7 +4629,7 @@ class Device(CompositeEventEmitter):
                 cig_id=cig_id,
             )
 
-        with closing(EventWatcher()) as watcher:
+        with closing(utils.EventWatcher()) as watcher:
             pending_cis_establishments = {
                 cis_handle: asyncio.get_running_loop().create_future()
                 for cis_handle, _ in cis_acl_pairs
@@ -4076,12 +4641,14 @@ class Device(CompositeEventEmitter):
 
             def on_cis_establishment_failure(cis_handle: int, status: int) -> None:
                 if pending_future := pending_cis_establishments.get(cis_handle):
-                    pending_future.set_exception(HCI_Error(status))
+                    pending_future.set_exception(hci.HCI_Error(status))
 
-            watcher.on(self, 'cis_establishment', on_cis_establishment)
-            watcher.on(self, 'cis_establishment_failure', on_cis_establishment_failure)
+            watcher.on(self, self.EVENT_CIS_ESTABLISHMENT, on_cis_establishment)
+            watcher.on(
+                self, self.EVENT_CIS_ESTABLISHMENT_FAILURE, on_cis_establishment_failure
+            )
             await self.send_command(
-                HCI_LE_Create_CIS_Command(
+                hci.HCI_LE_Create_CIS_Command(
                     cis_connection_handle=[p[0] for p in cis_acl_pairs],
                     acl_connection_handle=[p[1] for p in cis_acl_pairs],
                 ),
@@ -4091,7 +4658,7 @@ class Device(CompositeEventEmitter):
             return await asyncio.gather(*pending_cis_establishments.values())
 
     # [LE only]
-    @experimental('Only for testing.')
+    @utils.experimental('Only for testing.')
     async def accept_cis_request(self, handle: int) -> CisLink:
         """[LE Only] Accepts an incoming CIS request.
 
@@ -4113,20 +4680,24 @@ class Device(CompositeEventEmitter):
             if cis_link.state == CisLink.State.ESTABLISHED:
                 return cis_link
 
-            with closing(EventWatcher()) as watcher:
+            with closing(utils.EventWatcher()) as watcher:
                 pending_establishment = asyncio.get_running_loop().create_future()
 
                 def on_establishment() -> None:
                     pending_establishment.set_result(None)
 
                 def on_establishment_failure(status: int) -> None:
-                    pending_establishment.set_exception(HCI_Error(status))
+                    pending_establishment.set_exception(hci.HCI_Error(status))
 
-                watcher.on(cis_link, 'establishment', on_establishment)
-                watcher.on(cis_link, 'establishment_failure', on_establishment_failure)
+                watcher.on(cis_link, cis_link.EVENT_ESTABLISHMENT, on_establishment)
+                watcher.on(
+                    cis_link,
+                    cis_link.EVENT_ESTABLISHMENT_FAILURE,
+                    on_establishment_failure,
+                )
 
                 await self.send_command(
-                    HCI_LE_Accept_CIS_Request_Command(connection_handle=handle),
+                    hci.HCI_LE_Accept_CIS_Request_Command(connection_handle=handle),
                     check_result=True,
                 )
 
@@ -4137,18 +4708,120 @@ class Device(CompositeEventEmitter):
         raise UnreachableError()
 
     # [LE only]
-    @experimental('Only for testing.')
+    @utils.experimental('Only for testing.')
     async def reject_cis_request(
         self,
         handle: int,
-        reason: int = HCI_REMOTE_USER_TERMINATED_CONNECTION_ERROR,
+        reason: int = hci.HCI_REMOTE_USER_TERMINATED_CONNECTION_ERROR,
     ) -> None:
         await self.send_command(
-            HCI_LE_Reject_CIS_Request_Command(connection_handle=handle, reason=reason),
+            hci.HCI_LE_Reject_CIS_Request_Command(
+                connection_handle=handle, reason=reason
+            ),
             check_result=True,
         )
 
-    async def get_remote_le_features(self, connection: Connection) -> LeFeatureMask:
+    # [LE only]
+    @utils.experimental('Only for testing.')
+    async def create_big(
+        self, advertising_set: AdvertisingSet, parameters: BigParameters
+    ) -> Big:
+        if (big_handle := self.next_big_handle()) is None:
+            raise core.OutOfResourcesError("All valid BIG handles already in use")
+
+        with closing(utils.EventWatcher()) as watcher:
+            big = Big(
+                big_handle=big_handle,
+                parameters=parameters,
+                advertising_set=advertising_set,
+            )
+            self.bigs[big_handle] = big
+            established = asyncio.get_running_loop().create_future()
+            watcher.once(
+                big, big.Event.ESTABLISHMENT, lambda: established.set_result(None)
+            )
+            watcher.once(
+                big,
+                big.Event.ESTABLISHMENT_FAILURE,
+                lambda status: established.set_exception(hci.HCI_Error(status)),
+            )
+
+            try:
+                await self.send_command(
+                    hci.HCI_LE_Create_BIG_Command(
+                        big_handle=big_handle,
+                        advertising_handle=advertising_set.advertising_handle,
+                        num_bis=parameters.num_bis,
+                        sdu_interval=parameters.sdu_interval,
+                        max_sdu=parameters.max_sdu,
+                        max_transport_latency=parameters.max_transport_latency,
+                        rtn=parameters.rtn,
+                        phy=parameters.phy,
+                        packing=parameters.packing,
+                        framing=parameters.framing,
+                        encryption=1 if parameters.broadcast_code else 0,
+                        broadcast_code=parameters.broadcast_code or bytes(16),
+                    ),
+                    check_result=True,
+                )
+                await established
+            except hci.HCI_Error:
+                del self.bigs[big_handle]
+                raise
+
+        return big
+
+    # [LE only]
+    @utils.experimental('Only for testing.')
+    async def create_big_sync(
+        self, pa_sync: PeriodicAdvertisingSync, parameters: BigSyncParameters
+    ) -> BigSync:
+        if (big_handle := self.next_big_handle()) is None:
+            raise core.OutOfResourcesError("All valid BIG handles already in use")
+
+        if (pa_sync_handle := pa_sync.sync_handle) is None:
+            raise core.InvalidStateError("PA Sync is not established")
+
+        with closing(utils.EventWatcher()) as watcher:
+            big_sync = BigSync(
+                big_handle=big_handle,
+                parameters=parameters,
+                pa_sync=pa_sync,
+            )
+            self.big_syncs[big_handle] = big_sync
+            established = asyncio.get_running_loop().create_future()
+            watcher.once(
+                big_sync,
+                big_sync.Event.ESTABLISHMENT,
+                lambda: established.set_result(None),
+            )
+            watcher.once(
+                big_sync,
+                big_sync.Event.ESTABLISHMENT_FAILURE,
+                lambda status: established.set_exception(hci.HCI_Error(status)),
+            )
+
+            try:
+                await self.send_command(
+                    hci.HCI_LE_BIG_Create_Sync_Command(
+                        big_handle=big_handle,
+                        sync_handle=pa_sync_handle,
+                        encryption=1 if parameters.broadcast_code else 0,
+                        broadcast_code=parameters.broadcast_code or bytes(16),
+                        mse=parameters.mse,
+                        big_sync_timeout=parameters.big_sync_timeout,
+                        bis=parameters.bis,
+                    ),
+                    check_result=True,
+                )
+                await established
+            except hci.HCI_Error:
+                del self.big_syncs[big_handle]
+                raise
+
+        return big_sync
+
+    async def get_remote_le_features(self, connection: Connection) -> hci.LeFeatureMask:
         """[LE Only] Reads remote LE supported features.
 
         Args:
@@ -4157,56 +4830,265 @@ class Device(CompositeEventEmitter):
         Returns:
             LE features supported by the remote device.
         """
-        with closing(EventWatcher()) as watcher:
-            read_feature_future: asyncio.Future[LeFeatureMask] = (
+        with closing(utils.EventWatcher()) as watcher:
+            read_feature_future: asyncio.Future[hci.LeFeatureMask] = (
                 asyncio.get_running_loop().create_future()
             )
 
             def on_le_remote_features(handle: int, features: int):
                 if handle == connection.handle:
-                    read_feature_future.set_result(LeFeatureMask(features))
+                    read_feature_future.set_result(hci.LeFeatureMask(features))
 
             def on_failure(handle: int, status: int):
                 if handle == connection.handle:
-                    read_feature_future.set_exception(HCI_Error(status))
+                    read_feature_future.set_exception(hci.HCI_Error(status))
 
             watcher.on(self.host, 'le_remote_features', on_le_remote_features)
             watcher.on(self.host, 'le_remote_features_failure', on_failure)
             await self.send_command(
-                HCI_LE_Read_Remote_Features_Command(
+                hci.HCI_LE_Read_Remote_Features_Command(
                     connection_handle=connection.handle
                 ),
                 check_result=True,
             )
             return await read_feature_future
 
+    @utils.experimental('Only for testing.')
+    async def get_remote_cs_capabilities(
+        self, connection: Connection
+    ) -> ChannelSoundingCapabilities:
+        complete_future: asyncio.Future[ChannelSoundingCapabilities] = (
+            asyncio.get_running_loop().create_future()
+        )
+
+        with closing(utils.EventWatcher()) as watcher:
+            watcher.once(
+                connection, 'channel_sounding_capabilities', complete_future.set_result
+            )
+            watcher.once(
+                connection,
+                'channel_sounding_capabilities_failure',
+                lambda status: complete_future.set_exception(hci.HCI_Error(status)),
+            )
+            await self.send_command(
+                hci.HCI_LE_CS_Read_Remote_Supported_Capabilities_Command(
+                    connection_handle=connection.handle
+                ),
+                check_result=True,
+            )
+            return await complete_future
+
+    @utils.experimental('Only for testing.')
+    async def set_default_cs_settings(
+        self,
+        connection: Connection,
+        role_enable: int = (
+            hci.CsRoleMask.INITIATOR | hci.CsRoleMask.REFLECTOR
+        ),  # Both role
+        cs_sync_antenna_selection: int = 0xFF,  # No Preference
+        max_tx_power: int = 0x04,  # 4 dB
+    ) -> None:
+        await self.send_command(
+            hci.HCI_LE_CS_Set_Default_Settings_Command(
+                connection_handle=connection.handle,
+                role_enable=role_enable,
+                cs_sync_antenna_selection=cs_sync_antenna_selection,
+                max_tx_power=max_tx_power,
+            ),
+            check_result=True,
+        )
+
+    @utils.experimental('Only for testing.')
+    async def create_cs_config(
+        self,
+        connection: Connection,
+        config_id: int | None = None,
+        create_context: int = 0x01,
+        main_mode_type: int = 0x02,
+        sub_mode_type: int = 0xFF,
+        min_main_mode_steps: int = 0x02,
+        max_main_mode_steps: int = 0x05,
+        main_mode_repetition: int = 0x00,
+        mode_0_steps: int = 0x03,
+        role: int = hci.CsRole.INITIATOR,
+        rtt_type: int = hci.RttType.AA_ONLY,
+        cs_sync_phy: int = hci.CsSyncPhy.LE_1M,
+        channel_map: bytes = b'\x54\x55\x55\x54\x55\x55\x55\x55\x55\x15',
+        channel_map_repetition: int = 0x01,
+        channel_selection_type: int = hci.HCI_LE_CS_Create_Config_Command.ChannelSelectionType.ALGO_3B,
+        ch3c_shape: int = hci.HCI_LE_CS_Create_Config_Command.Ch3cShape.HAT,
+        ch3c_jump: int = 0x03,
+    ) -> ChannelSoundingConfig:
+        complete_future: asyncio.Future[ChannelSoundingConfig] = (
+            asyncio.get_running_loop().create_future()
+        )
+        if config_id is None:
+            # Allocate an ID.
+            config_id = next(
+                (
+                    i
+                    for i in range(DEVICE_MIN_CS_CONFIG_ID, DEVICE_MAX_CS_CONFIG_ID + 1)
+                    if i not in connection.cs_configs
+                ),
+                None,
+            )
+        if config_id is None:
+            raise OutOfResourcesError("No available config ID on this connection!")
+
+        with closing(utils.EventWatcher()) as watcher:
+            watcher.once(
+                connection, 'channel_sounding_config', complete_future.set_result
+            )
+            watcher.once(
+                connection,
+                'channel_sounding_config_failure',
+                lambda status: complete_future.set_exception(hci.HCI_Error(status)),
+            )
+            await self.send_command(
+                hci.HCI_LE_CS_Create_Config_Command(
+                    connection_handle=connection.handle,
+                    config_id=config_id,
+                    create_context=create_context,
+                    main_mode_type=main_mode_type,
+                    sub_mode_type=sub_mode_type,
+                    min_main_mode_steps=min_main_mode_steps,
+                    max_main_mode_steps=max_main_mode_steps,
+                    main_mode_repetition=main_mode_repetition,
+                    mode_0_steps=mode_0_steps,
+                    role=role,
+                    rtt_type=rtt_type,
+                    cs_sync_phy=cs_sync_phy,
+                    channel_map=channel_map,
+                    channel_map_repetition=channel_map_repetition,
+                    channel_selection_type=channel_selection_type,
+                    ch3c_shape=ch3c_shape,
+                    ch3c_jump=ch3c_jump,
+                    reserved=0x00,
+                ),
+                check_result=True,
+            )
+            return await complete_future
+
+    @utils.experimental('Only for testing.')
+    async def enable_cs_security(self, connection: Connection) -> None:
+        complete_future: asyncio.Future[None] = (
+            asyncio.get_running_loop().create_future()
+        )
+        with closing(utils.EventWatcher()) as watcher:
+
+            def on_event(event: hci.HCI_LE_CS_Security_Enable_Complete_Event) -> None:
+                if event.connection_handle != connection.handle:
+                    return
+                if event.status == hci.HCI_SUCCESS:
+                    complete_future.set_result(None)
+                else:
+                    complete_future.set_exception(hci.HCI_Error(event.status))
+
+            watcher.once(self.host, 'cs_security', on_event)
+            await self.send_command(
+                hci.HCI_LE_CS_Security_Enable_Command(
+                    connection_handle=connection.handle
+                ),
+                check_result=True,
+            )
+            return await complete_future
+
+    @utils.experimental('Only for testing.')
+    async def set_cs_procedure_parameters(
+        self,
+        connection: Connection,
+        config: ChannelSoundingConfig,
+        tone_antenna_config_selection=0x00,
+        preferred_peer_antenna=0x00,
+        max_procedure_len=0x2710,  # 6.25s
+        min_procedure_interval=0x01,
+        max_procedure_interval=0xFF,
+        max_procedure_count=0x01,
+        min_subevent_len=0x0004E2,  # 1250us
+        max_subevent_len=0x1E8480,  # 2s
+        phy=hci.CsSyncPhy.LE_1M,
+        tx_power_delta=0x00,
+        snr_control_initiator=hci.CsSnr.NOT_APPLIED,
+        snr_control_reflector=hci.CsSnr.NOT_APPLIED,
+    ) -> None:
+        await self.send_command(
+            hci.HCI_LE_CS_Set_Procedure_Parameters_Command(
+                connection_handle=connection.handle,
+                config_id=config.config_id,
+                max_procedure_len=max_procedure_len,
+                min_procedure_interval=min_procedure_interval,
+                max_procedure_interval=max_procedure_interval,
+                max_procedure_count=max_procedure_count,
+                min_subevent_len=min_subevent_len,
+                max_subevent_len=max_subevent_len,
+                tone_antenna_config_selection=tone_antenna_config_selection,
+                phy=phy,
+                tx_power_delta=tx_power_delta,
+                preferred_peer_antenna=preferred_peer_antenna,
+                snr_control_initiator=snr_control_initiator,
+                snr_control_reflector=snr_control_reflector,
+            ),
+            check_result=True,
+        )
+
+    @utils.experimental('Only for testing.')
+    async def enable_cs_procedure(
+        self,
+        connection: Connection,
+        config: ChannelSoundingConfig,
+        enabled: bool = True,
+    ) -> ChannelSoundingProcedure:
+        complete_future: asyncio.Future[ChannelSoundingProcedure] = (
+            asyncio.get_running_loop().create_future()
+        )
+        with closing(utils.EventWatcher()) as watcher:
+            watcher.once(
+                connection, 'channel_sounding_procedure', complete_future.set_result
+            )
+            watcher.once(
+                connection,
+                'channel_sounding_procedure_failure',
+                lambda x: complete_future.set_exception(hci.HCI_Error(x)),
+            )
+            await self.send_command(
+                hci.HCI_LE_CS_Procedure_Enable_Command(
+                    connection_handle=connection.handle,
+                    config_id=config.config_id,
+                    enable=enabled,
+                ),
+                check_result=True,
+            )
+            return await complete_future
+
     @host_event_handler
     def on_flush(self):
-        self.emit('flush')
+        self.emit(self.EVENT_FLUSH)
         for _, connection in self.connections.items():
-            connection.emit('disconnection', 0)
+            connection.emit(connection.EVENT_DISCONNECTION, 0)
         self.connections = {}
 
     # [Classic only]
     @host_event_handler
-    def on_link_key(self, bd_addr, link_key, key_type):
+    def on_link_key(self, bd_addr: hci.Address, link_key: bytes, key_type: int) -> None:
         # Store the keys in the key store
         if self.keystore:
             authenticated = key_type in (
-                HCI_AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P_192_TYPE,
-                HCI_AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P_256_TYPE,
+                hci.HCI_AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P_192_TYPE,
+                hci.HCI_AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P_256_TYPE,
             )
-            pairing_keys = PairingKeys()
-            pairing_keys.link_key = PairingKeys.Key(
-                value=link_key, authenticated=authenticated
+            pairing_keys = PairingKeys(
+                link_key=PairingKeys.Key(value=link_key, authenticated=authenticated),
+                link_key_type=key_type,
             )
 
-            self.abort_on('flush', self.update_keys(str(bd_addr), pairing_keys))
+            utils.cancel_on_event(
+                self, Device.EVENT_FLUSH, self.update_keys(str(bd_addr), pairing_keys)
+            )
 
         if connection := self.find_connection_by_bd_addr(
-            bd_addr, transport=BT_BR_EDR_TRANSPORT
+            bd_addr, transport=PhysicalTransport.BR_EDR
         ):
-            connection.link_key_type = key_type
+            connection.emit(connection.EVENT_LINK_KEY)
 
     def add_service(self, service):
         self.gatt_server.add_service(service)
@@ -4214,21 +5096,94 @@ class Device(CompositeEventEmitter):
     def add_services(self, services):
         self.gatt_server.add_services(services)
 
-    def add_default_services(self, generic_access_service=True):
+    def add_default_services(
+        self, add_gap_service: bool = True, add_gatt_service: bool = True
+    ) -> None:
         # Add a GAP Service if requested
-        if generic_access_service:
+        if add_gap_service:
             self.gatt_server.add_service(GenericAccessService(self.name))
+        if add_gatt_service:
+            self.gatt_service = gatt_service.GenericAttributeProfileService()
+            self.gatt_server.add_service(self.gatt_service)
 
-    async def notify_subscriber(self, connection, attribute, value=None, force=False):
+    async def notify_subscriber(
+        self,
+        connection: Connection,
+        attribute: Attribute,
+        value: Optional[Any] = None,
+        force: bool = False,
+    ) -> None:
+        """
+        Send a notification to an attribute subscriber.
+
+        Args:
+           connection:
+             The connection of the subscriber.
+           attribute:
+             The attribute whose value is notified.
+           value:
+             The value of the attribute (if None, the value is read from the attribute)
+            force:
+              If True, send a notification even if there is no subscriber.
+        """
         await self.gatt_server.notify_subscriber(connection, attribute, value, force)
 
-    async def notify_subscribers(self, attribute, value=None, force=False):
+    async def notify_subscribers(
+        self, attribute: Attribute, value=None, force=False
+    ) -> None:
+        """
+        Send a notification to all the subscribers of an attribute.
+
+        Args:
+           attribute:
+             The attribute whose value is notified.
+           value:
+             The value of the attribute (if None, the value is read from the attribute)
+            force:
+              If True, send a notification for every connection even if there is no
+              subscriber.
+        """
         await self.gatt_server.notify_subscribers(attribute, value, force)
 
-    async def indicate_subscriber(self, connection, attribute, value=None, force=False):
+    async def indicate_subscriber(
+        self,
+        connection: Connection,
+        attribute: Attribute,
+        value: Optional[Any] = None,
+        force: bool = False,
+    ):
+        """
+        Send an indication to an attribute subscriber.
+
+        This method returns when the response to the indication has been received.
+
+        Args:
+           connection:
+             The connection of the subscriber.
+           attribute:
+             The attribute whose value is indicated.
+           value:
+             The value of the attribute (if None, the value is read from the attribute)
+            force:
+              If True, send an indication even if there is no subscriber.
+        """
         await self.gatt_server.indicate_subscriber(connection, attribute, value, force)
 
-    async def indicate_subscribers(self, attribute, value=None, force=False):
+    async def indicate_subscribers(
+        self, attribute: Attribute, value: Optional[Any] = None, force: bool = False
+    ):
+        """
+        Send an indication to all the subscribers of an attribute.
+
+        Args:
+           attribute:
+             The attribute whose value is notified.
+           value:
+             The value of the attribute (if None, the value is read from the attribute)
+            force:
+              If True, send an indication for every connection even if there is no
+              subscriber.
+        """
         await self.gatt_server.indicate_subscribers(attribute, value, force)
 
     @host_event_handler
@@ -4248,7 +5203,7 @@ class Device(CompositeEventEmitter):
 
         advertising_set.on_termination(status)
 
-        if status != HCI_SUCCESS:
+        if status != hci.HCI_SUCCESS:
             logger.debug(
                 f'advertising set {advertising_handle} '
                 f'terminated with status {status}'
@@ -4269,6 +5224,112 @@ class Device(CompositeEventEmitter):
         )
         self.connecting_extended_advertising_sets[connection_handle] = advertising_set
 
+    @host_event_handler
+    def on_big_establishment(
+        self,
+        status: int,
+        big_handle: int,
+        bis_handles: list[int],
+        big_sync_delay: int,
+        transport_latency_big: int,
+        phy: int,
+        nse: int,
+        bn: int,
+        pto: int,
+        irc: int,
+        max_pdu: int,
+        iso_interval: int,
+    ) -> None:
+        if not (big := self.bigs.get(big_handle)):
+            logger.warning('BIG %d not found', big_handle)
+            return
+
+        if status != hci.HCI_SUCCESS:
+            del self.bigs[big_handle]
+            logger.debug('Unable to create BIG %d', big_handle)
+            big.state = Big.State.TERMINATED
+            big.emit(Big.Event.ESTABLISHMENT_FAILURE, status)
+            return
+
+        big.bis_links = [BisLink(handle=handle, big=big) for handle in bis_handles]
+        big.big_sync_delay = big_sync_delay
+        big.transport_latency_big = transport_latency_big
+        big.phy = phy
+        big.nse = nse
+        big.bn = bn
+        big.pto = pto
+        big.irc = irc
+        big.max_pdu = max_pdu
+        big.iso_interval = iso_interval * 1.25
+        big.state = Big.State.ACTIVE
+
+        for bis_link in big.bis_links:
+            self.bis_links[bis_link.handle] = bis_link
+        big.emit(Big.Event.ESTABLISHMENT)
+
+    @host_event_handler
+    def on_big_termination(self, reason: int, big_handle: int) -> None:
+        if not (big := self.bigs.pop(big_handle, None)):
+            logger.warning('BIG %d not found', big_handle)
+            return
+
+        big.state = Big.State.TERMINATED
+        for bis_link in big.bis_links:
+            self.bis_links.pop(bis_link.handle, None)
+        big.emit(Big.Event.TERMINATION, reason)
+
+    @host_event_handler
+    def on_big_sync_establishment(
+        self,
+        status: int,
+        big_handle: int,
+        transport_latency_big: int,
+        nse: int,
+        bn: int,
+        pto: int,
+        irc: int,
+        max_pdu: int,
+        iso_interval: int,
+        bis_handles: list[int],
+    ) -> None:
+        if not (big_sync := self.big_syncs.get(big_handle)):
+            logger.warning('BIG Sync %d not found', big_handle)
+            return
+
+        if status != hci.HCI_SUCCESS:
+            del self.big_syncs[big_handle]
+            logger.debug('Unable to create BIG Sync %d', big_handle)
+            big_sync.state = BigSync.State.TERMINATED
+            big_sync.emit(BigSync.Event.ESTABLISHMENT_FAILURE, status)
+            return
+
+        big_sync.transport_latency_big = transport_latency_big
+        big_sync.nse = nse
+        big_sync.bn = bn
+        big_sync.pto = pto
+        big_sync.irc = irc
+        big_sync.max_pdu = max_pdu
+        big_sync.iso_interval = iso_interval * 1.25
+        big_sync.bis_links = [
+            BisLink(handle=handle, big=big_sync) for handle in bis_handles
+        ]
+        big_sync.state = BigSync.State.ACTIVE
+
+        for bis_link in big_sync.bis_links:
+            self.bis_links[bis_link.handle] = bis_link
+        big_sync.emit(BigSync.Event.ESTABLISHMENT)
+
+    @host_event_handler
+    def on_big_sync_lost(self, big_handle: int, reason: int) -> None:
+        if not (big_sync := self.big_syncs.pop(big_handle, None)):
+            logger.warning('BIG %d not found', big_handle)
+            return
+
+        for bis_link in big_sync.bis_links:
+            self.bis_links.pop(bis_link.handle, None)
+        big_sync.state = BigSync.State.TERMINATED
+        big_sync.emit(BigSync.Event.TERMINATION, reason)
+
     def _complete_le_extended_advertising_connection(
         self, connection: Connection, advertising_set: AdvertisingSet
     ) -> None:
@@ -4277,108 +5338,89 @@ class Device(CompositeEventEmitter):
             advertising_set.random_address
             if advertising_set.random_address is not None
             and advertising_set.advertising_parameters.own_address_type
-            in (OwnAddressType.RANDOM, OwnAddressType.RESOLVABLE_OR_RANDOM)
+            in (hci.OwnAddressType.RANDOM, hci.OwnAddressType.RESOLVABLE_OR_RANDOM)
             else self.public_address
         )
 
         if advertising_set.advertising_parameters.own_address_type in (
-            OwnAddressType.RANDOM,
-            OwnAddressType.PUBLIC,
+            hci.OwnAddressType.RANDOM,
+            hci.OwnAddressType.PUBLIC,
         ):
             connection.self_resolvable_address = None
 
         # Setup auto-restart of the advertising set if needed.
         if advertising_set.auto_restart:
             connection.once(
-                'disconnection',
-                lambda _: self.abort_on('flush', advertising_set.start()),
+                Connection.EVENT_DISCONNECTION,
+                lambda _: utils.cancel_on_event(
+                    self, Device.EVENT_FLUSH, advertising_set.start()
+                ),
             )
 
-        self._emit_le_connection(connection)
-
-    def _emit_le_connection(self, connection: Connection) -> None:
-        # If supported, read which PHY we're connected with before
-        # notifying listeners of the new connection.
-        if self.host.supports_command(HCI_LE_READ_PHY_COMMAND):
-
-            async def read_phy():
-                result = await self.send_command(
-                    HCI_LE_Read_PHY_Command(connection_handle=connection.handle),
-                    check_result=True,
-                )
-                connection.phy = ConnectionPHY(
-                    result.return_parameters.tx_phy, result.return_parameters.rx_phy
-                )
-                # Emit an event to notify listeners of the new connection
-                self.emit('connection', connection)
-
-            # Do so asynchronously to not block the current event handler
-            connection.abort_on('disconnection', read_phy())
-
-            return
-
-        self.emit('connection', connection)
+        self.emit(self.EVENT_CONNECTION, connection)
 
     @host_event_handler
     def on_connection(
         self,
         connection_handle: int,
-        transport: int,
-        peer_address: Address,
-        self_resolvable_address: Optional[Address],
-        peer_resolvable_address: Optional[Address],
-        role: int,
-        connection_parameters: ConnectionParameters,
+        transport: core.PhysicalTransport,
+        peer_address: hci.Address,
+        self_resolvable_address: Optional[hci.Address],
+        peer_resolvable_address: Optional[hci.Address],
+        role: hci.Role,
+        connection_parameters: Optional[core.ConnectionParameters],
     ) -> None:
         # Convert all-zeros addresses into None.
-        if self_resolvable_address == Address.ANY_RANDOM:
+        if self_resolvable_address == hci.Address.ANY_RANDOM:
             self_resolvable_address = None
         if (
-            peer_resolvable_address == Address.ANY_RANDOM
+            peer_resolvable_address == hci.Address.ANY_RANDOM
             or not peer_address.is_resolved
         ):
             peer_resolvable_address = None
 
         logger.debug(
             f'*** Connection: [0x{connection_handle:04X}] '
-            f'{peer_address} {"" if role is None else HCI_Constant.role_name(role)}'
+            f'{peer_address} {"" if role is None else hci.HCI_Constant.role_name(role)}'
         )
         if connection_handle in self.connections:
             logger.warning(
                 'new connection reuses the same handle as a previous connection'
             )
 
-        if transport == BT_BR_EDR_TRANSPORT:
+        if transport == PhysicalTransport.BR_EDR:
             # Create a new connection
             connection = self.pending_connections.pop(peer_address)
             connection.complete(connection_handle, connection_parameters)
             self.connections[connection_handle] = connection
 
             # Emit an event to notify listeners of the new connection
-            self.emit('connection', connection)
+            self.emit(self.EVENT_CONNECTION, connection)
 
             return
 
+        assert connection_parameters is not None
+
         if peer_resolvable_address is None:
             # Resolve the peer address if we can
             if self.address_resolver:
                 if peer_address.is_resolvable:
                     resolved_address = self.address_resolver.resolve(peer_address)
                     if resolved_address is not None:
-                        logger.debug(f'*** Address resolved as {resolved_address}')
+                        logger.debug(f'*** hci.Address resolved as {resolved_address}')
                         peer_resolvable_address = peer_address
                         peer_address = resolved_address
 
         self_address = None
-        own_address_type: Optional[int] = None
-        if role == HCI_CENTRAL_ROLE:
+        own_address_type: Optional[hci.OwnAddressType] = None
+        if role == hci.Role.CENTRAL:
             own_address_type = self.connect_own_address_type
             assert own_address_type is not None
         else:
             if self.supports_le_extended_advertising:
                 # We'll know the address when the advertising set terminates,
                 # Use a temporary placeholder value for self_address.
-                self_address = Address.ANY_RANDOM
+                self_address = hci.Address.ANY_RANDOM
             else:
                 # We were connected via a legacy advertisement.
                 if self.legacy_advertiser:
@@ -4393,15 +5435,15 @@ class Device(CompositeEventEmitter):
                 self.public_address
                 if own_address_type
                 in (
-                    OwnAddressType.PUBLIC,
-                    OwnAddressType.RESOLVABLE_OR_PUBLIC,
+                    hci.OwnAddressType.PUBLIC,
+                    hci.OwnAddressType.RESOLVABLE_OR_PUBLIC,
                 )
                 else self.random_address
             )
 
         # Some controllers may return local resolvable address even not using address
         # generation offloading. Ignore the value to prevent SMP failure.
-        if own_address_type in (OwnAddressType.RANDOM, OwnAddressType.PUBLIC):
+        if own_address_type in (hci.OwnAddressType.RANDOM, hci.OwnAddressType.PUBLIC):
             self_resolvable_address = None
 
         # Create a connection.
@@ -4414,27 +5456,32 @@ class Device(CompositeEventEmitter):
             peer_address,
             peer_resolvable_address,
             role,
-            connection_parameters,
-            ConnectionPHY(HCI_LE_1M_PHY, HCI_LE_1M_PHY),
+            Connection.Parameters(
+                connection_parameters.connection_interval * 1.25,
+                connection_parameters.peripheral_latency,
+                connection_parameters.supervision_timeout * 10.0,
+            ),
         )
         self.connections[connection_handle] = connection
 
-        if role == HCI_PERIPHERAL_ROLE and self.legacy_advertiser:
+        if role == hci.Role.PERIPHERAL and self.legacy_advertiser:
             if self.legacy_advertiser.auto_restart:
                 advertiser = self.legacy_advertiser
                 connection.once(
-                    'disconnection',
-                    lambda _: self.abort_on('flush', advertiser.start()),
+                    Connection.EVENT_DISCONNECTION,
+                    lambda _: utils.cancel_on_event(
+                        self, Device.EVENT_FLUSH, advertiser.start()
+                    ),
                 )
             else:
                 self.legacy_advertiser = None
 
-        if role == HCI_CENTRAL_ROLE or not self.supports_le_extended_advertising:
+        if role == hci.Role.CENTRAL or not self.supports_le_extended_advertising:
             # We can emit now, we have all the info we need
-            self._emit_le_connection(connection)
+            self.emit(self.EVENT_CONNECTION, connection)
             return
 
-        if role == HCI_PERIPHERAL_ROLE and self.supports_le_extended_advertising:
+        if role == hci.Role.PERIPHERAL and self.supports_le_extended_advertising:
             if advertising_set := self.connecting_extended_advertising_sets.pop(
                 connection_handle, None
             ):
@@ -4445,11 +5492,13 @@ class Device(CompositeEventEmitter):
 
     @host_event_handler
     def on_connection_failure(self, transport, peer_address, error_code):
-        logger.debug(f'*** Connection failed: {HCI_Constant.error_name(error_code)}')
+        logger.debug(
+            f'*** Connection failed: {hci.HCI_Constant.error_name(error_code)}'
+        )
 
         # For directed advertising, this means a timeout
         if (
-            transport == BT_LE_TRANSPORT
+            transport == PhysicalTransport.LE
             and self.legacy_advertiser
             and self.legacy_advertiser.advertising_type.is_directed
         ):
@@ -4461,9 +5510,9 @@ class Device(CompositeEventEmitter):
             transport,
             peer_address,
             'hci',
-            HCI_Constant.error_name(error_code),
+            hci.HCI_Constant.error_name(error_code),
         )
-        self.emit('connection_failure', error)
+        self.emit(self.EVENT_CONNECTION_FAILURE, error)
 
     # FIXME: Explore a delegate-model for BR/EDR wait connection #56.
     @host_event_handler
@@ -4472,13 +5521,13 @@ class Device(CompositeEventEmitter):
 
         # Handle SCO request.
         if link_type in (
-            HCI_Connection_Complete_Event.SCO_LINK_TYPE,
-            HCI_Connection_Complete_Event.ESCO_LINK_TYPE,
+            hci.HCI_Connection_Complete_Event.SCO_LINK_TYPE,
+            hci.HCI_Connection_Complete_Event.ESCO_LINK_TYPE,
         ):
             if connection := self.find_connection_by_bd_addr(
-                bd_addr, transport=BT_BR_EDR_TRANSPORT
+                bd_addr, transport=PhysicalTransport.BR_EDR
             ):
-                self.emit('sco_request', connection, link_type)
+                self.emit(self.EVENT_SCO_REQUEST, connection, link_type)
             else:
                 logger.error(f'SCO request from a non-connected device {bd_addr}')
             return
@@ -4489,19 +5538,19 @@ class Device(CompositeEventEmitter):
             future.set_result((bd_addr, class_of_device, link_type))
 
         # match first pending future for ANY address
-        elif len(self.classic_pending_accepts[Address.ANY]) > 0:
-            future = self.classic_pending_accepts[Address.ANY].pop(0)
+        elif len(self.classic_pending_accepts[hci.Address.ANY]) > 0:
+            future = self.classic_pending_accepts[hci.Address.ANY].pop(0)
             future.set_result((bd_addr, class_of_device, link_type))
 
         # device configuration is set to accept any incoming connection
         elif self.classic_accept_any:
             # Save pending connection
             self.pending_connections[bd_addr] = Connection.incomplete(
-                self, bd_addr, BT_PERIPHERAL_ROLE
+                self, bd_addr, hci.Role.PERIPHERAL
             )
 
             self.host.send_command_sync(
-                HCI_Accept_Connection_Request_Command(
+                hci.HCI_Accept_Connection_Request_Command(
                     bd_addr=bd_addr, role=0x01  # Remain the peripheral
                 )
             )
@@ -4509,9 +5558,9 @@ class Device(CompositeEventEmitter):
         # reject incoming connection
         else:
             self.host.send_command_sync(
-                HCI_Reject_Connection_Request_Command(
+                hci.HCI_Reject_Connection_Request_Command(
                     bd_addr=bd_addr,
-                    reason=HCI_CONNECTION_REJECTED_DUE_TO_LIMITED_RESOURCES_ERROR,
+                    reason=hci.HCI_CONNECTION_REJECTED_DUE_TO_LIMITED_RESOURCES_ERROR,
                 )
             )
 
@@ -4522,14 +5571,14 @@ class Device(CompositeEventEmitter):
                 f'*** Disconnection: [0x{connection.handle:04X}] '
                 f'{connection.peer_address} as {connection.role_name}, reason={reason}'
             )
-            connection.emit('disconnection', reason)
+            connection.emit(connection.EVENT_DISCONNECTION, reason)
 
             # Cleanup subsystems that maintain per-connection state
             self.gatt_server.on_disconnection(connection)
         elif sco_link := self.sco_links.pop(connection_handle, None):
-            sco_link.emit('disconnection', reason)
+            sco_link.emit(sco_link.EVENT_DISCONNECTION, reason)
         elif cis_link := self.cis_links.pop(connection_handle, None):
-            cis_link.emit('disconnection', reason)
+            cis_link.emit(cis_link.EVENT_DISCONNECTION, reason)
         else:
             logger.error(
                 f'*** Unknown disconnection handle=0x{connection_handle}, reason={reason} ***'
@@ -4537,19 +5586,19 @@ class Device(CompositeEventEmitter):
 
     @host_event_handler
     @with_connection_from_handle
-    def on_disconnection_failure(self, connection, error_code):
+    def on_disconnection_failure(self, connection: Connection, error_code: int):
         logger.debug(f'*** Disconnection failed: {error_code}')
         error = core.ConnectionError(
             error_code,
             connection.transport,
             connection.peer_address,
             'hci',
-            HCI_Constant.error_name(error_code),
+            hci.HCI_Constant.error_name(error_code),
         )
-        connection.emit('disconnection_failure', error)
+        connection.emit(connection.EVENT_DISCONNECTION_FAILURE, error)
 
     @host_event_handler
-    @AsyncRunner.run_in_task()
+    @utils.AsyncRunner.run_in_task()
     async def on_inquiry_complete(self):
         if self.auto_restart_inquiry:
             # Inquire again
@@ -4557,7 +5606,7 @@ class Device(CompositeEventEmitter):
         else:
             self.auto_restart_inquiry = True
             self.discovering = False
-            self.emit('inquiry_complete')
+            self.emit(self.EVENT_INQUIRY_COMPLETE)
 
     @host_event_handler
     @with_connection_from_handle
@@ -4567,7 +5616,7 @@ class Device(CompositeEventEmitter):
             f'{connection.peer_address} as {connection.role_name}'
         )
         connection.authenticated = True
-        connection.emit('connection_authentication')
+        connection.emit(connection.EVENT_CONNECTION_AUTHENTICATION)
 
     @host_event_handler
     @with_connection_from_handle
@@ -4576,7 +5625,7 @@ class Device(CompositeEventEmitter):
             f'*** Connection Authentication Failure: [0x{connection.handle:04X}] '
             f'{connection.peer_address} as {connection.role_name}, error={error}'
         )
-        connection.emit('connection_authentication_failure', error)
+        connection.emit(connection.EVENT_CONNECTION_AUTHENTICATION_FAILURE, error)
 
     # [Classic only]
     @host_event_handler
@@ -4589,19 +5638,19 @@ class Device(CompositeEventEmitter):
         authentication_requirements = (
             # No Bonding
             (
-                HCI_MITM_NOT_REQUIRED_NO_BONDING_AUTHENTICATION_REQUIREMENTS,
-                HCI_MITM_REQUIRED_NO_BONDING_AUTHENTICATION_REQUIREMENTS,
+                hci.HCI_MITM_NOT_REQUIRED_NO_BONDING_AUTHENTICATION_REQUIREMENTS,
+                hci.HCI_MITM_REQUIRED_NO_BONDING_AUTHENTICATION_REQUIREMENTS,
             ),
             # General Bonding
             (
-                HCI_MITM_NOT_REQUIRED_GENERAL_BONDING_AUTHENTICATION_REQUIREMENTS,
-                HCI_MITM_REQUIRED_GENERAL_BONDING_AUTHENTICATION_REQUIREMENTS,
+                hci.HCI_MITM_NOT_REQUIRED_GENERAL_BONDING_AUTHENTICATION_REQUIREMENTS,
+                hci.HCI_MITM_REQUIRED_GENERAL_BONDING_AUTHENTICATION_REQUIREMENTS,
             ),
         )[1 if pairing_config.bonding else 0][1 if pairing_config.mitm else 0]
 
         # Respond
         self.host.send_command_sync(
-            HCI_IO_Capability_Request_Reply_Command(
+            hci.HCI_IO_Capability_Request_Reply_Command(
                 bd_addr=connection.peer_address,
                 io_capability=pairing_config.delegate.classic_io_capability,
                 oob_data_present=0x00,  # Not present
@@ -4651,29 +5700,29 @@ class Device(CompositeEventEmitter):
 
         # See Bluetooth spec @ Vol 3, Part C 5.2.2.6
         methods = {
-            HCI_DISPLAY_ONLY_IO_CAPABILITY: {
-                HCI_DISPLAY_ONLY_IO_CAPABILITY: display_auto_confirm,
-                HCI_DISPLAY_YES_NO_IO_CAPABILITY: display_confirm,
-                HCI_KEYBOARD_ONLY_IO_CAPABILITY: na,
-                HCI_NO_INPUT_NO_OUTPUT_IO_CAPABILITY: auto_confirm,
+            hci.HCI_DISPLAY_ONLY_IO_CAPABILITY: {
+                hci.HCI_DISPLAY_ONLY_IO_CAPABILITY: display_auto_confirm,
+                hci.HCI_DISPLAY_YES_NO_IO_CAPABILITY: display_confirm,
+                hci.HCI_KEYBOARD_ONLY_IO_CAPABILITY: na,
+                hci.HCI_NO_INPUT_NO_OUTPUT_IO_CAPABILITY: auto_confirm,
             },
-            HCI_DISPLAY_YES_NO_IO_CAPABILITY: {
-                HCI_DISPLAY_ONLY_IO_CAPABILITY: display_auto_confirm,
-                HCI_DISPLAY_YES_NO_IO_CAPABILITY: display_confirm,
-                HCI_KEYBOARD_ONLY_IO_CAPABILITY: na,
-                HCI_NO_INPUT_NO_OUTPUT_IO_CAPABILITY: auto_confirm,
+            hci.HCI_DISPLAY_YES_NO_IO_CAPABILITY: {
+                hci.HCI_DISPLAY_ONLY_IO_CAPABILITY: display_auto_confirm,
+                hci.HCI_DISPLAY_YES_NO_IO_CAPABILITY: display_confirm,
+                hci.HCI_KEYBOARD_ONLY_IO_CAPABILITY: na,
+                hci.HCI_NO_INPUT_NO_OUTPUT_IO_CAPABILITY: auto_confirm,
             },
-            HCI_KEYBOARD_ONLY_IO_CAPABILITY: {
-                HCI_DISPLAY_ONLY_IO_CAPABILITY: na,
-                HCI_DISPLAY_YES_NO_IO_CAPABILITY: na,
-                HCI_KEYBOARD_ONLY_IO_CAPABILITY: na,
-                HCI_NO_INPUT_NO_OUTPUT_IO_CAPABILITY: auto_confirm,
+            hci.HCI_KEYBOARD_ONLY_IO_CAPABILITY: {
+                hci.HCI_DISPLAY_ONLY_IO_CAPABILITY: na,
+                hci.HCI_DISPLAY_YES_NO_IO_CAPABILITY: na,
+                hci.HCI_KEYBOARD_ONLY_IO_CAPABILITY: na,
+                hci.HCI_NO_INPUT_NO_OUTPUT_IO_CAPABILITY: auto_confirm,
             },
-            HCI_NO_INPUT_NO_OUTPUT_IO_CAPABILITY: {
-                HCI_DISPLAY_ONLY_IO_CAPABILITY: confirm,
-                HCI_DISPLAY_YES_NO_IO_CAPABILITY: confirm,
-                HCI_KEYBOARD_ONLY_IO_CAPABILITY: auto_confirm,
-                HCI_NO_INPUT_NO_OUTPUT_IO_CAPABILITY: auto_confirm,
+            hci.HCI_NO_INPUT_NO_OUTPUT_IO_CAPABILITY: {
+                hci.HCI_DISPLAY_ONLY_IO_CAPABILITY: confirm,
+                hci.HCI_DISPLAY_YES_NO_IO_CAPABILITY: confirm,
+                hci.HCI_KEYBOARD_ONLY_IO_CAPABILITY: auto_confirm,
+                hci.HCI_NO_INPUT_NO_OUTPUT_IO_CAPABILITY: auto_confirm,
             },
         }
 
@@ -4681,9 +5730,11 @@ class Device(CompositeEventEmitter):
 
         async def reply() -> None:
             try:
-                if await connection.abort_on('disconnection', method()):
+                if await utils.cancel_on_event(
+                    connection, Connection.EVENT_DISCONNECTION, method()
+                ):
                     await self.host.send_command(
-                        HCI_User_Confirmation_Request_Reply_Command(
+                        hci.HCI_User_Confirmation_Request_Reply_Command(
                             bd_addr=connection.peer_address
                         )
                     )
@@ -4692,12 +5743,12 @@ class Device(CompositeEventEmitter):
                 logger.warning(f'exception while confirming: {error}')
 
             await self.host.send_command(
-                HCI_User_Confirmation_Request_Negative_Reply_Command(
+                hci.HCI_User_Confirmation_Request_Negative_Reply_Command(
                     bd_addr=connection.peer_address
                 )
             )
 
-        AsyncRunner.spawn(reply())
+        utils.AsyncRunner.spawn(reply())
 
     # [Classic only]
     @host_event_handler
@@ -4708,12 +5759,14 @@ class Device(CompositeEventEmitter):
 
         async def reply() -> None:
             try:
-                number = await connection.abort_on(
-                    'disconnection', pairing_config.delegate.get_number()
+                number = await utils.cancel_on_event(
+                    connection,
+                    Connection.EVENT_DISCONNECTION,
+                    pairing_config.delegate.get_number(),
                 )
                 if number is not None:
                     await self.host.send_command(
-                        HCI_User_Passkey_Request_Reply_Command(
+                        hci.HCI_User_Passkey_Request_Reply_Command(
                             bd_addr=connection.peer_address, numeric_value=number
                         )
                     )
@@ -4722,12 +5775,12 @@ class Device(CompositeEventEmitter):
                 logger.warning(f'exception while asking for pass-key: {error}')
 
             await self.host.send_command(
-                HCI_User_Passkey_Request_Negative_Reply_Command(
+                hci.HCI_User_Passkey_Request_Negative_Reply_Command(
                     bd_addr=connection.peer_address
                 )
             )
 
-        AsyncRunner.spawn(reply())
+        utils.AsyncRunner.spawn(reply())
 
     # [Classic only]
     @host_event_handler
@@ -4739,11 +5792,13 @@ class Device(CompositeEventEmitter):
         io_capability = pairing_config.delegate.classic_io_capability
 
         # Respond
-        if io_capability == HCI_KEYBOARD_ONLY_IO_CAPABILITY:
+        if io_capability == hci.HCI_KEYBOARD_ONLY_IO_CAPABILITY:
             # Ask the user to enter a string
             async def get_pin_code():
-                pin_code = await connection.abort_on(
-                    'disconnection', pairing_config.delegate.get_string(16)
+                pin_code = await utils.cancel_on_event(
+                    connection,
+                    Connection.EVENT_DISCONNECTION,
+                    pairing_config.delegate.get_string(16),
                 )
 
                 if pin_code is not None:
@@ -4751,7 +5806,7 @@ class Device(CompositeEventEmitter):
                     pin_code_len = len(pin_code)
                     assert 0 < pin_code_len <= 16, "pin_code should be 1-16 bytes"
                     await self.host.send_command(
-                        HCI_PIN_Code_Request_Reply_Command(
+                        hci.HCI_PIN_Code_Request_Reply_Command(
                             bd_addr=connection.peer_address,
                             pin_code_length=pin_code_len,
                             pin_code=pin_code,
@@ -4760,7 +5815,7 @@ class Device(CompositeEventEmitter):
                 else:
                     logger.debug("delegate.get_string() returned None")
                     await self.host.send_command(
-                        HCI_PIN_Code_Request_Negative_Reply_Command(
+                        hci.HCI_PIN_Code_Request_Negative_Reply_Command(
                             bd_addr=connection.peer_address
                         )
                     )
@@ -4768,7 +5823,7 @@ class Device(CompositeEventEmitter):
             asyncio.create_task(get_pin_code())
         else:
             self.host.send_command_sync(
-                HCI_PIN_Code_Request_Negative_Reply_Command(
+                hci.HCI_PIN_Code_Request_Negative_Reply_Command(
                     bd_addr=connection.peer_address
                 )
             )
@@ -4781,8 +5836,10 @@ class Device(CompositeEventEmitter):
         pairing_config = self.pairing_config_factory(connection)
 
         # Show the passkey to the user
-        connection.abort_on(
-            'disconnection', pairing_config.delegate.display_number(passkey)
+        utils.cancel_on_event(
+            connection,
+            Connection.EVENT_DISCONNECTION,
+            pairing_config.delegate.display_number(passkey, digits=6),
         )
 
     # [Classic only]
@@ -4794,27 +5851,27 @@ class Device(CompositeEventEmitter):
             remote_name = remote_name.decode('utf-8')
             if connection:
                 connection.peer_name = remote_name
-                connection.emit('remote_name')
-            self.emit('remote_name', address, remote_name)
+                connection.emit(connection.EVENT_REMOTE_NAME)
+            self.emit(self.EVENT_REMOTE_NAME, address, remote_name)
         except UnicodeDecodeError as error:
             logger.warning('peer name is not valid UTF-8')
             if connection:
-                connection.emit('remote_name_failure', error)
+                connection.emit(connection.EVENT_REMOTE_NAME_FAILURE, error)
             else:
-                self.emit('remote_name_failure', address, error)
+                self.emit(self.EVENT_REMOTE_NAME_FAILURE, address, error)
 
     # [Classic only]
     @host_event_handler
     @try_with_connection_from_address
     def on_remote_name_failure(self, connection: Connection, address, error):
         if connection:
-            connection.emit('remote_name_failure', error)
-        self.emit('remote_name_failure', address, error)
+            connection.emit(connection.EVENT_REMOTE_NAME_FAILURE, error)
+        self.emit(self.EVENT_REMOTE_NAME_FAILURE, address, error)
 
     # [Classic only]
     @host_event_handler
     @with_connection_from_address
-    @experimental('Only for testing.')
+    @utils.experimental('Only for testing.')
     def on_sco_connection(
         self, acl_connection: Connection, sco_handle: int, link_type: int
     ) -> None:
@@ -4829,29 +5886,31 @@ class Device(CompositeEventEmitter):
             handle=sco_handle,
             link_type=link_type,
         )
-        self.emit('sco_connection', sco_link)
+        self.emit(self.EVENT_SCO_CONNECTION, sco_link)
 
     # [Classic only]
     @host_event_handler
     @with_connection_from_address
-    @experimental('Only for testing.')
+    @utils.experimental('Only for testing.')
     def on_sco_connection_failure(
         self, acl_connection: Connection, status: int
     ) -> None:
         logger.debug(f'*** SCO connection failure: {acl_connection.peer_address}***')
-        self.emit('sco_connection_failure')
+        self.emit(self.EVENT_SCO_CONNECTION_FAILURE)
 
     # [Classic only]
     @host_event_handler
-    @experimental('Only for testing')
-    def on_sco_packet(self, sco_handle: int, packet: HCI_SynchronousDataPacket) -> None:
+    @utils.experimental('Only for testing')
+    def on_sco_packet(
+        self, sco_handle: int, packet: hci.HCI_SynchronousDataPacket
+    ) -> None:
         if (sco_link := self.sco_links.get(sco_handle)) and sco_link.sink:
             sco_link.sink(packet)
 
     # [LE only]
     @host_event_handler
     @with_connection_from_handle
-    @experimental('Only for testing')
+    @utils.experimental('Only for testing')
     def on_cis_request(
         self,
         acl_connection: Connection,
@@ -4874,11 +5933,11 @@ class Device(CompositeEventEmitter):
             cig_id=cig_id,
             cis_id=cis_id,
         )
-        self.emit('cis_request', acl_connection, cis_handle, cig_id, cis_id)
+        self.emit(self.EVENT_CIS_REQUEST, acl_connection, cis_handle, cig_id, cis_id)
 
     # [LE only]
     @host_event_handler
-    @experimental('Only for testing')
+    @utils.experimental('Only for testing')
     def on_cis_establishment(self, cis_handle: int) -> None:
         cis_link = self.cis_links[cis_handle]
         cis_link.state = CisLink.State.ESTABLISHED
@@ -4893,49 +5952,55 @@ class Device(CompositeEventEmitter):
             f'cis_id=[0x{cis_link.cis_id:02X}] ***'
         )
 
-        cis_link.emit('establishment')
-        self.emit('cis_establishment', cis_link)
+        cis_link.emit(cis_link.EVENT_ESTABLISHMENT)
+        self.emit(self.EVENT_CIS_ESTABLISHMENT, cis_link)
 
     # [LE only]
     @host_event_handler
-    @experimental('Only for testing')
+    @utils.experimental('Only for testing')
     def on_cis_establishment_failure(self, cis_handle: int, status: int) -> None:
         logger.debug(f'*** CIS Establishment Failure: cis=[0x{cis_handle:04X}] ***')
         if cis_link := self.cis_links.pop(cis_handle):
-            cis_link.emit('establishment_failure', status)
-        self.emit('cis_establishment_failure', cis_handle, status)
+            cis_link.emit(cis_link.EVENT_ESTABLISHMENT_FAILURE, status)
+        self.emit(self.EVENT_CIS_ESTABLISHMENT_FAILURE, cis_handle, status)
 
     # [LE only]
     @host_event_handler
-    @experimental('Only for testing')
-    def on_iso_packet(self, handle: int, packet: HCI_IsoDataPacket) -> None:
+    @utils.experimental('Only for testing')
+    def on_iso_packet(self, handle: int, packet: hci.HCI_IsoDataPacket) -> None:
         if (cis_link := self.cis_links.get(handle)) and cis_link.sink:
             cis_link.sink(packet)
+        elif (bis_link := self.bis_links.get(handle)) and bis_link.sink:
+            bis_link.sink(packet)
 
     @host_event_handler
     @with_connection_from_handle
-    def on_connection_encryption_change(self, connection, encryption):
+    def on_connection_encryption_change(
+        self, connection, encryption, encryption_key_size
+    ):
         logger.debug(
             f'*** Connection Encryption Change: [0x{connection.handle:04X}] '
             f'{connection.peer_address} as {connection.role_name}, '
-            f'encryption={encryption}'
+            f'encryption={encryption}, '
+            f'key_size={encryption_key_size}'
         )
         connection.encryption = encryption
+        connection.encryption_key_size = encryption_key_size
         if (
             not connection.authenticated
-            and connection.transport == BT_BR_EDR_TRANSPORT
-            and encryption == HCI_Encryption_Change_Event.AES_CCM
+            and connection.transport == PhysicalTransport.BR_EDR
+            and encryption == hci.HCI_Encryption_Change_Event.AES_CCM
         ):
             connection.authenticated = True
             connection.sc = True
         if (
             not connection.authenticated
-            and connection.transport == BT_LE_TRANSPORT
-            and encryption == HCI_Encryption_Change_Event.E0_OR_AES_CCM
+            and connection.transport == PhysicalTransport.LE
+            and encryption == hci.HCI_Encryption_Change_Event.E0_OR_AES_CCM
         ):
             connection.authenticated = True
             connection.sc = True
-        connection.emit('connection_encryption_change')
+        connection.emit(connection.EVENT_CONNECTION_ENCRYPTION_CHANGE)
 
     @host_event_handler
     @with_connection_from_handle
@@ -4945,7 +6010,7 @@ class Device(CompositeEventEmitter):
             f'{connection.peer_address} as {connection.role_name}, '
             f'error={error}'
         )
-        connection.emit('connection_encryption_failure', error)
+        connection.emit(connection.EVENT_CONNECTION_ENCRYPTION_FAILURE, error)
 
     @host_event_handler
     @with_connection_from_handle
@@ -4954,7 +6019,7 @@ class Device(CompositeEventEmitter):
             f'*** Connection Key Refresh: [0x{connection.handle:04X}] '
             f'{connection.peer_address} as {connection.role_name}'
         )
-        connection.emit('connection_encryption_key_refresh')
+        connection.emit(connection.EVENT_CONNECTION_ENCRYPTION_KEY_REFRESH)
 
     @host_event_handler
     @with_connection_from_handle
@@ -4965,7 +6030,7 @@ class Device(CompositeEventEmitter):
             f'{connection_parameters}'
         )
         connection.parameters = connection_parameters
-        connection.emit('connection_parameters_update')
+        connection.emit(connection.EVENT_CONNECTION_PARAMETERS_UPDATE)
 
     @host_event_handler
     @with_connection_from_handle
@@ -4975,18 +6040,17 @@ class Device(CompositeEventEmitter):
             f'{connection.peer_address} as {connection.role_name}, '
             f'error={error}'
         )
-        connection.emit('connection_parameters_update_failure', error)
+        connection.emit(connection.EVENT_CONNECTION_PARAMETERS_UPDATE_FAILURE, error)
 
     @host_event_handler
     @with_connection_from_handle
-    def on_connection_phy_update(self, connection, connection_phy):
+    def on_connection_phy_update(self, connection, phy):
         logger.debug(
             f'*** Connection PHY Update: [0x{connection.handle:04X}] '
             f'{connection.peer_address} as {connection.role_name}, '
-            f'{connection_phy}'
+            f'{phy}'
         )
-        connection.phy = connection_phy
-        connection.emit('connection_phy_update')
+        connection.emit(connection.EVENT_CONNECTION_PHY_UPDATE, phy)
 
     @host_event_handler
     @with_connection_from_handle
@@ -4996,7 +6060,7 @@ class Device(CompositeEventEmitter):
             f'{connection.peer_address} as {connection.role_name}, '
             f'error={error}'
         )
-        connection.emit('connection_phy_update_failure', error)
+        connection.emit(connection.EVENT_CONNECTION_PHY_UPDATE_FAILURE, error)
 
     @host_event_handler
     @with_connection_from_handle
@@ -5007,7 +6071,7 @@ class Device(CompositeEventEmitter):
             f'{att_mtu}'
         )
         connection.att_mtu = att_mtu
-        connection.emit('connection_att_mtu_update')
+        connection.emit(connection.EVENT_CONNECTION_ATT_MTU_UPDATE)
 
     @host_event_handler
     @with_connection_from_handle
@@ -5024,42 +6088,150 @@ class Device(CompositeEventEmitter):
             max_rx_octets,
             max_rx_time,
         )
-        connection.emit('connection_data_length_change')
+        connection.emit(connection.EVENT_CONNECTION_DATA_LENGTH_CHANGE)
+
+    @host_event_handler
+    def on_cs_remote_supported_capabilities(
+        self, event: hci.HCI_LE_CS_Read_Remote_Supported_Capabilities_Complete_Event
+    ):
+        if not (connection := self.lookup_connection(event.connection_handle)):
+            return
+
+        if event.status != hci.HCI_SUCCESS:
+            connection.emit(
+                connection.EVENT_CHANNEL_SOUNDING_CAPABILITIES_FAILURE, event.status
+            )
+            return
+
+        capabilities = ChannelSoundingCapabilities(
+            num_config_supported=event.num_config_supported,
+            max_consecutive_procedures_supported=event.max_consecutive_procedures_supported,
+            num_antennas_supported=event.num_antennas_supported,
+            max_antenna_paths_supported=event.max_antenna_paths_supported,
+            roles_supported=event.roles_supported,
+            modes_supported=event.modes_supported,
+            rtt_capability=event.rtt_capability,
+            rtt_aa_only_n=event.rtt_aa_only_n,
+            rtt_sounding_n=event.rtt_sounding_n,
+            rtt_random_payload_n=event.rtt_random_payload_n,
+            nadm_sounding_capability=event.nadm_sounding_capability,
+            nadm_random_capability=event.nadm_random_capability,
+            cs_sync_phys_supported=event.cs_sync_phys_supported,
+            subfeatures_supported=event.subfeatures_supported,
+            t_ip1_times_supported=event.t_ip1_times_supported,
+            t_ip2_times_supported=event.t_ip2_times_supported,
+            t_fcs_times_supported=event.t_fcs_times_supported,
+            t_pm_times_supported=event.t_pm_times_supported,
+            t_sw_time_supported=event.t_sw_time_supported,
+            tx_snr_capability=event.tx_snr_capability,
+        )
+        connection.emit(connection.EVENT_CHANNEL_SOUNDING_CAPABILITIES, capabilities)
+
+    @host_event_handler
+    def on_cs_config(self, event: hci.HCI_LE_CS_Config_Complete_Event):
+        if not (connection := self.lookup_connection(event.connection_handle)):
+            return
+
+        if event.status != hci.HCI_SUCCESS:
+            connection.emit(
+                connection.EVENT_CHANNEL_SOUNDING_CONFIG_FAILURE, event.status
+            )
+            return
+        if event.action == hci.HCI_LE_CS_Config_Complete_Event.Action.CREATED:
+            config = ChannelSoundingConfig(
+                config_id=event.config_id,
+                main_mode_type=event.main_mode_type,
+                sub_mode_type=event.sub_mode_type,
+                min_main_mode_steps=event.min_main_mode_steps,
+                max_main_mode_steps=event.max_main_mode_steps,
+                main_mode_repetition=event.main_mode_repetition,
+                mode_0_steps=event.mode_0_steps,
+                role=event.role,
+                rtt_type=event.rtt_type,
+                cs_sync_phy=event.cs_sync_phy,
+                channel_map=event.channel_map,
+                channel_map_repetition=event.channel_map_repetition,
+                channel_selection_type=event.channel_selection_type,
+                ch3c_shape=event.ch3c_shape,
+                ch3c_jump=event.ch3c_jump,
+                reserved=event.reserved,
+                t_ip1_time=event.t_ip1_time,
+                t_ip2_time=event.t_ip2_time,
+                t_fcs_time=event.t_fcs_time,
+                t_pm_time=event.t_pm_time,
+            )
+            connection.cs_configs[event.config_id] = config
+            connection.emit(connection.EVENT_CHANNEL_SOUNDING_CONFIG, config)
+        elif event.action == hci.HCI_LE_CS_Config_Complete_Event.Action.REMOVED:
+            try:
+                config = connection.cs_configs.pop(event.config_id)
+                connection.emit(
+                    connection.EVENT_CHANNEL_SOUNDING_CONFIG_REMOVED, config.config_id
+                )
+            except KeyError:
+                logger.error('Removing unknown config %d', event.config_id)
+
+    @host_event_handler
+    def on_cs_procedure(self, event: hci.HCI_LE_CS_Procedure_Enable_Complete_Event):
+        if not (connection := self.lookup_connection(event.connection_handle)):
+            return
+
+        if event.status != hci.HCI_SUCCESS:
+            connection.emit(
+                connection.EVENT_CHANNEL_SOUNDING_PROCEDURE_FAILURE, event.status
+            )
+            return
+
+        procedure = ChannelSoundingProcedure(
+            config_id=event.config_id,
+            state=event.state,
+            tone_antenna_config_selection=event.tone_antenna_config_selection,
+            selected_tx_power=event.selected_tx_power,
+            subevent_len=event.subevent_len,
+            subevents_per_event=event.subevents_per_event,
+            subevent_interval=event.subevent_interval,
+            event_interval=event.event_interval,
+            procedure_interval=event.procedure_interval,
+            procedure_count=event.procedure_count,
+            max_procedure_len=event.max_procedure_len,
+        )
+        connection.cs_procedures[procedure.config_id] = procedure
+        connection.emit(connection.EVENT_CHANNEL_SOUNDING_PROCEDURE, procedure)
 
     # [Classic only]
     @host_event_handler
     @with_connection_from_address
     def on_role_change(self, connection, new_role):
         connection.role = new_role
-        connection.emit('role_change', new_role)
+        connection.emit(connection.EVENT_ROLE_CHANGE, new_role)
 
     # [Classic only]
     @host_event_handler
     @try_with_connection_from_address
     def on_role_change_failure(self, connection, address, error):
         if connection:
-            connection.emit('role_change_failure', error)
-        self.emit('role_change_failure', address, error)
+            connection.emit(connection.EVENT_ROLE_CHANGE_FAILURE, error)
+        self.emit(self.EVENT_ROLE_CHANGE_FAILURE, address, error)
 
     # [Classic only]
     @host_event_handler
     @with_connection_from_address
     def on_classic_pairing(self, connection: Connection) -> None:
-        connection.emit('classic_pairing')
+        connection.emit(connection.EVENT_CLASSIC_PAIRING)
 
     # [Classic only]
     @host_event_handler
     @with_connection_from_address
     def on_classic_pairing_failure(self, connection: Connection, status) -> None:
-        connection.emit('classic_pairing_failure', status)
+        connection.emit(connection.EVENT_CLASSIC_PAIRING_FAILURE, status)
 
     def on_pairing_start(self, connection: Connection) -> None:
-        connection.emit('pairing_start')
+        connection.emit(connection.EVENT_PAIRING_START)
 
     def on_pairing(
         self,
         connection: Connection,
-        identity_address: Optional[Address],
+        identity_address: Optional[hci.Address],
         keys: PairingKeys,
         sc: bool,
     ) -> None:
@@ -5068,10 +6240,10 @@ class Device(CompositeEventEmitter):
             connection.peer_address = identity_address
         connection.sc = sc
         connection.authenticated = True
-        connection.emit('pairing', keys)
+        connection.emit(connection.EVENT_PAIRING, keys)
 
     def on_pairing_failure(self, connection: Connection, reason: int) -> None:
-        connection.emit('pairing_failure', reason)
+        connection.emit(connection.EVENT_PAIRING_FAILURE, reason)
 
     @with_connection_from_handle
     def on_gatt_pdu(self, connection, pdu):
@@ -5083,14 +6255,14 @@ class Device(CompositeEventEmitter):
         if att_pdu.op_code & 1:
             if connection.gatt_client is None:
                 logger.warning(
-                    color('no GATT client for connection 0x{connection_handle:04X}')
+                    'No GATT client for connection 0x%04X', connection.handle
                 )
                 return
             connection.gatt_client.on_gatt_pdu(att_pdu)
         else:
             if connection.gatt_server is None:
                 logger.warning(
-                    color('no GATT server for connection 0x{connection_handle:04X}')
+                    'No GATT server for connection 0x%04X', connection.handle
                 )
                 return
             connection.gatt_server.on_gatt_pdu(connection, att_pdu)
diff --git a/bumble/drivers/__init__.py b/bumble/drivers/__init__.py
index 1e72665..c186b48 100644
--- a/bumble/drivers/__init__.py
+++ b/bumble/drivers/__init__.py
@@ -25,8 +25,8 @@ import pathlib
 import platform
 from typing import Dict, Iterable, Optional, Type, TYPE_CHECKING
 
-from . import rtk, intel
-from .common import Driver
+from bumble.drivers import rtk, intel
+from bumble.drivers.common import Driver
 
 if TYPE_CHECKING:
     from bumble.host import Host
diff --git a/bumble/drivers/common.py b/bumble/drivers/common.py
index a4c0427..42a545c 100644
--- a/bumble/drivers/common.py
+++ b/bumble/drivers/common.py
@@ -20,6 +20,8 @@ Common types for drivers.
 # -----------------------------------------------------------------------------
 import abc
 
+from bumble import core
+
 
 # -----------------------------------------------------------------------------
 # Classes
diff --git a/bumble/drivers/intel.py b/bumble/drivers/intel.py
index e613c1e..1c3d009 100644
--- a/bumble/drivers/intel.py
+++ b/bumble/drivers/intel.py
@@ -11,18 +11,33 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
+"""
+Support for Intel USB controllers.
+Loosely based on the Fuchsia OS implementation.
+"""
 
 # -----------------------------------------------------------------------------
 # Imports
 # -----------------------------------------------------------------------------
+from __future__ import annotations
+import asyncio
+import collections
+import dataclasses
 import logging
+import os
+import pathlib
+import platform
+import struct
+from typing import Any, Deque, Optional, TYPE_CHECKING
 
+from bumble import core
 from bumble.drivers import common
-from bumble.hci import (
-    hci_vendor_command_op_code,  # type: ignore
-    HCI_Command,
-    HCI_Reset_Command,
-)
+from bumble import hci
+from bumble import utils
+
+if TYPE_CHECKING:
+    from bumble.host import Host
+
 
 # -----------------------------------------------------------------------------
 # Logging
@@ -34,39 +49,330 @@ logger = logging.getLogger(__name__)
 # -----------------------------------------------------------------------------
 
 INTEL_USB_PRODUCTS = {
-    # Intel AX210
-    (0x8087, 0x0032),
-    # Intel BE200
-    (0x8087, 0x0036),
+    (0x8087, 0x0032),  # AX210
+    (0x8087, 0x0033),  # AX211
+    (0x8087, 0x0036),  # BE200
 }
 
+INTEL_FW_IMAGE_NAMES = [
+    "ibt-0040-0041",
+    "ibt-0040-1020",
+    "ibt-0040-1050",
+    "ibt-0040-2120",
+    "ibt-0040-4150",
+    "ibt-0041-0041",
+    "ibt-0180-0041",
+    "ibt-0180-1050",
+    "ibt-0180-4150",
+    "ibt-0291-0291",
+    "ibt-1040-0041",
+    "ibt-1040-1020",
+    "ibt-1040-1050",
+    "ibt-1040-2120",
+    "ibt-1040-4150",
+]
+
+INTEL_FIRMWARE_DIR_ENV = "BUMBLE_INTEL_FIRMWARE_DIR"
+INTEL_LINUX_FIRMWARE_DIR = "/lib/firmware/intel"
+
+_MAX_FRAGMENT_SIZE = 252
+_POST_RESET_DELAY = 0.2
+
 # -----------------------------------------------------------------------------
 # HCI Commands
 # -----------------------------------------------------------------------------
-HCI_INTEL_DDC_CONFIG_WRITE_COMMAND = hci_vendor_command_op_code(0xFC8B)  # type: ignore
-HCI_INTEL_DDC_CONFIG_WRITE_PAYLOAD = [0x03, 0xE4, 0x02, 0x00]
+HCI_INTEL_WRITE_DEVICE_CONFIG_COMMAND = hci.hci_vendor_command_op_code(0x008B)
+HCI_INTEL_READ_VERSION_COMMAND = hci.hci_vendor_command_op_code(0x0005)
+HCI_INTEL_RESET_COMMAND = hci.hci_vendor_command_op_code(0x0001)
+HCI_INTEL_SECURE_SEND_COMMAND = hci.hci_vendor_command_op_code(0x0009)
+HCI_INTEL_WRITE_BOOT_PARAMS_COMMAND = hci.hci_vendor_command_op_code(0x000E)
+
+hci.HCI_Command.register_commands(globals())
+
+
+@hci.HCI_Command.command(
+    fields=[
+        ("param0", 1),
+    ],
+    return_parameters_fields=[
+        ("status", hci.STATUS_SPEC),
+        ("tlv", "*"),
+    ],
+)
+class HCI_Intel_Read_Version_Command(hci.HCI_Command):
+    pass
+
+
+@hci.HCI_Command.command(
+    fields=[("data_type", 1), ("data", "*")],
+    return_parameters_fields=[
+        ("status", 1),
+    ],
+)
+class Hci_Intel_Secure_Send_Command(hci.HCI_Command):
+    pass
 
-HCI_Command.register_commands(globals())
+
+@hci.HCI_Command.command(
+    fields=[
+        ("reset_type", 1),
+        ("patch_enable", 1),
+        ("ddc_reload", 1),
+        ("boot_option", 1),
+        ("boot_address", 4),
+    ],
+    return_parameters_fields=[
+        ("data", "*"),
+    ],
+)
+class HCI_Intel_Reset_Command(hci.HCI_Command):
+    pass
 
 
-@HCI_Command.command(  # type: ignore
-    fields=[("params", "*")],
+@hci.HCI_Command.command(
+    fields=[("data", "*")],
     return_parameters_fields=[
+        ("status", hci.STATUS_SPEC),
         ("params", "*"),
     ],
 )
-class Hci_Intel_DDC_Config_Write_Command(HCI_Command):
+class Hci_Intel_Write_Device_Config_Command(hci.HCI_Command):
     pass
 
 
+# -----------------------------------------------------------------------------
+# Functions
+# -----------------------------------------------------------------------------
+def intel_firmware_dir() -> pathlib.Path:
+    """
+    Returns:
+        A path to a subdir of the project data dir for Intel firmware.
+         The directory is created if it doesn't exist.
+    """
+    from bumble.drivers import project_data_dir
+
+    p = project_data_dir() / "firmware" / "intel"
+    p.mkdir(parents=True, exist_ok=True)
+    return p
+
+
+def _find_binary_path(file_name: str) -> pathlib.Path | None:
+    # First check if an environment variable is set
+    if INTEL_FIRMWARE_DIR_ENV in os.environ:
+        if (
+            path := pathlib.Path(os.environ[INTEL_FIRMWARE_DIR_ENV]) / file_name
+        ).is_file():
+            logger.debug(f"{file_name} found in env dir")
+            return path
+
+        # When the environment variable is set, don't look elsewhere
+        return None
+
+    # Then, look where the firmware download tool writes by default
+    if (path := intel_firmware_dir() / file_name).is_file():
+        logger.debug(f"{file_name} found in project data dir")
+        return path
+
+    # Then, look in the package's driver directory
+    if (path := pathlib.Path(__file__).parent / "intel_fw" / file_name).is_file():
+        logger.debug(f"{file_name} found in package dir")
+        return path
+
+    # On Linux, check the system's FW directory
+    if (
+        platform.system() == "Linux"
+        and (path := pathlib.Path(INTEL_LINUX_FIRMWARE_DIR) / file_name).is_file()
+    ):
+        logger.debug(f"{file_name} found in Linux system FW dir")
+        return path
+
+    # Finally look in the current directory
+    if (path := pathlib.Path.cwd() / file_name).is_file():
+        logger.debug(f"{file_name} found in CWD")
+        return path
+
+    return None
+
+
+def _parse_tlv(data: bytes) -> list[tuple[ValueType, Any]]:
+    result: list[tuple[ValueType, Any]] = []
+    while len(data) >= 2:
+        value_type = ValueType(data[0])
+        value_length = data[1]
+        value = data[2 : 2 + value_length]
+        typed_value: Any
+
+        if value_type == ValueType.END:
+            break
+
+        if value_type in (ValueType.CNVI, ValueType.CNVR):
+            (v,) = struct.unpack("<I", value)
+            typed_value = (
+                (((v >> 0) & 0xF) << 12)
+                | (((v >> 4) & 0xF) << 0)
+                | (((v >> 8) & 0xF) << 4)
+                | (((v >> 24) & 0xF) << 8)
+            )
+        elif value_type == ValueType.HARDWARE_INFO:
+            (v,) = struct.unpack("<I", value)
+            typed_value = HardwareInfo(
+                HardwarePlatform((v >> 8) & 0xFF), HardwareVariant((v >> 16) & 0x3F)
+            )
+        elif value_type in (
+            ValueType.USB_VENDOR_ID,
+            ValueType.USB_PRODUCT_ID,
+            ValueType.DEVICE_REVISION,
+        ):
+            (typed_value,) = struct.unpack("<H", value)
+        elif value_type == ValueType.CURRENT_MODE_OF_OPERATION:
+            typed_value = ModeOfOperation(value[0])
+        elif value_type in (
+            ValueType.BUILD_TYPE,
+            ValueType.BUILD_NUMBER,
+            ValueType.SECURE_BOOT,
+            ValueType.OTP_LOCK,
+            ValueType.API_LOCK,
+            ValueType.DEBUG_LOCK,
+            ValueType.SECURE_BOOT_ENGINE_TYPE,
+        ):
+            typed_value = value[0]
+        elif value_type == ValueType.TIMESTAMP:
+            typed_value = Timestamp(value[0], value[1])
+        elif value_type == ValueType.FIRMWARE_BUILD:
+            typed_value = FirmwareBuild(value[0], Timestamp(value[1], value[2]))
+        elif value_type == ValueType.BLUETOOTH_ADDRESS:
+            typed_value = hci.Address(
+                value, address_type=hci.Address.PUBLIC_DEVICE_ADDRESS
+            )
+        else:
+            typed_value = value
+
+        result.append((value_type, typed_value))
+        data = data[2 + value_length :]
+
+    return result
+
+
+# -----------------------------------------------------------------------------
+# Classes
+# -----------------------------------------------------------------------------
+class DriverError(core.BaseBumbleError):
+    def __init__(self, message: str) -> None:
+        super().__init__(message)
+        self.message = message
+
+    def __str__(self) -> str:
+        return f"IntelDriverError({self.message})"
+
+
+class ValueType(utils.OpenIntEnum):
+    END = 0x00
+    CNVI = 0x10
+    CNVR = 0x11
+    HARDWARE_INFO = 0x12
+    DEVICE_REVISION = 0x16
+    CURRENT_MODE_OF_OPERATION = 0x1C
+    USB_VENDOR_ID = 0x17
+    USB_PRODUCT_ID = 0x18
+    TIMESTAMP = 0x1D
+    BUILD_TYPE = 0x1E
+    BUILD_NUMBER = 0x1F
+    SECURE_BOOT = 0x28
+    OTP_LOCK = 0x2A
+    API_LOCK = 0x2B
+    DEBUG_LOCK = 0x2C
+    FIRMWARE_BUILD = 0x2D
+    SECURE_BOOT_ENGINE_TYPE = 0x2F
+    BLUETOOTH_ADDRESS = 0x30
+
+
+class HardwarePlatform(utils.OpenIntEnum):
+    INTEL_37 = 0x37
+
+
+class HardwareVariant(utils.OpenIntEnum):
+    # This is a just a partial list.
+    # Add other constants here as new hardware is encountered and tested.
+    TYPHOON_PEAK = 0x17
+    GARFIELD_PEAK = 0x19
+    GALE_PEAK = 0x1C
+
+
+@dataclasses.dataclass
+class HardwareInfo:
+    platform: HardwarePlatform
+    variant: HardwareVariant
+
+
+@dataclasses.dataclass
+class Timestamp:
+    week: int
+    year: int
+
+
+@dataclasses.dataclass
+class FirmwareBuild:
+    build_number: int
+    timestamp: Timestamp
+
+
+class ModeOfOperation(utils.OpenIntEnum):
+    BOOTLOADER = 0x01
+    INTERMEDIATE = 0x02
+    OPERATIONAL = 0x03
+
+
+class SecureBootEngineType(utils.OpenIntEnum):
+    RSA = 0x00
+    ECDSA = 0x01
+
+
+@dataclasses.dataclass
+class BootParams:
+    css_header_offset: int
+    css_header_size: int
+    pki_offset: int
+    pki_size: int
+    sig_offset: int
+    sig_size: int
+    write_offset: int
+
+
+_BOOT_PARAMS = {
+    SecureBootEngineType.RSA: BootParams(0, 128, 128, 256, 388, 256, 964),
+    SecureBootEngineType.ECDSA: BootParams(644, 128, 772, 96, 868, 96, 964),
+}
+
+
 class Driver(common.Driver):
-    def __init__(self, host):
+    def __init__(self, host: Host) -> None:
         self.host = host
+        self.max_in_flight_firmware_load_commands = 1
+        self.pending_firmware_load_commands: Deque[hci.HCI_Command] = (
+            collections.deque()
+        )
+        self.can_send_firmware_load_command = asyncio.Event()
+        self.can_send_firmware_load_command.set()
+        self.firmware_load_complete = asyncio.Event()
+        self.reset_complete = asyncio.Event()
+
+        # Parse configuration options from the driver name.
+        self.ddc_addon: Optional[bytes] = None
+        self.ddc_override: Optional[bytes] = None
+        driver = host.hci_metadata.get("driver")
+        if driver is not None and driver.startswith("intel/"):
+            for key, value in [
+                key_eq_value.split(":") for key_eq_value in driver[6:].split("+")
+            ]:
+                if key == "ddc_addon":
+                    self.ddc_addon = bytes.fromhex(value)
+                elif key == "ddc_override":
+                    self.ddc_override = bytes.fromhex(value)
 
     @staticmethod
-    def check(host):
+    def check(host: Host) -> bool:
         driver = host.hci_metadata.get("driver")
-        if driver == "intel":
+        if driver == "intel" or driver is not None and driver.startswith("intel/"):
             return True
 
         vendor_id = host.hci_metadata.get("vendor_id")
@@ -85,18 +391,284 @@ class Driver(common.Driver):
         return True
 
     @classmethod
-    async def for_host(cls, host, force=False):  # type: ignore
+    async def for_host(cls, host: Host, force: bool = False):
         # Only instantiate this driver if explicitly selected
         if not force and not cls.check(host):
             return None
 
         return cls(host)
 
-    async def init_controller(self):
+    def on_packet(self, packet: bytes) -> None:
+        """Handler for event packets that are received from an ACL channel"""
+        event = hci.HCI_Event.from_bytes(packet)
+
+        if not isinstance(event, hci.HCI_Command_Complete_Event):
+            self.host.on_hci_event_packet(event)
+            return
+
+        if not event.return_parameters == hci.HCI_SUCCESS:
+            raise DriverError("HCI_Command_Complete_Event error")
+
+        if self.max_in_flight_firmware_load_commands != event.num_hci_command_packets:
+            logger.debug(
+                "max_in_flight_firmware_load_commands update: "
+                f"{event.num_hci_command_packets}"
+            )
+            self.max_in_flight_firmware_load_commands = event.num_hci_command_packets
+        logger.debug(f"event: {event}")
+        self.pending_firmware_load_commands.popleft()
+        in_flight = len(self.pending_firmware_load_commands)
+        logger.debug(f"event received, {in_flight} still in flight")
+        if in_flight < self.max_in_flight_firmware_load_commands:
+            self.can_send_firmware_load_command.set()
+
+    async def send_firmware_load_command(self, command: hci.HCI_Command) -> None:
+        # Wait until we can send.
+        await self.can_send_firmware_load_command.wait()
+
+        # Send the command and adjust counters.
+        self.host.send_hci_packet(command)
+        self.pending_firmware_load_commands.append(command)
+        in_flight = len(self.pending_firmware_load_commands)
+        if in_flight >= self.max_in_flight_firmware_load_commands:
+            logger.debug(f"max commands in flight reached [{in_flight}]")
+            self.can_send_firmware_load_command.clear()
+
+    async def send_firmware_data(self, data_type: int, data: bytes) -> None:
+        while data:
+            fragment_size = min(len(data), _MAX_FRAGMENT_SIZE)
+            fragment = data[:fragment_size]
+            data = data[fragment_size:]
+
+            await self.send_firmware_load_command(
+                Hci_Intel_Secure_Send_Command(data_type=data_type, data=fragment)
+            )
+
+    async def load_firmware(self) -> None:
         self.host.ready = True
-        await self.host.send_command(HCI_Reset_Command(), check_result=True)
-        await self.host.send_command(
-            Hci_Intel_DDC_Config_Write_Command(
-                params=HCI_INTEL_DDC_CONFIG_WRITE_PAYLOAD
+        device_info = await self.read_device_info()
+        logger.debug(
+            "device info: \n%s",
+            "\n".join(
+                [
+                    f"  {value_type.name}: {value}"
+                    for value_type, value in device_info.items()
+                ]
+            ),
+        )
+
+        # Check if the firmware is already loaded.
+        if (
+            device_info.get(ValueType.CURRENT_MODE_OF_OPERATION)
+            == ModeOfOperation.OPERATIONAL
+        ):
+            logger.debug("firmware already loaded")
+            return
+
+        # We only support some platforms and variants.
+        hardware_info = device_info.get(ValueType.HARDWARE_INFO)
+        if hardware_info is None:
+            raise DriverError("hardware info missing")
+        if hardware_info.platform != HardwarePlatform.INTEL_37:
+            raise DriverError("hardware platform not supported")
+        if hardware_info.variant not in (
+            HardwareVariant.TYPHOON_PEAK,
+            HardwareVariant.GARFIELD_PEAK,
+            HardwareVariant.GALE_PEAK,
+        ):
+            raise DriverError("hardware variant not supported")
+
+        # Compute the firmware name.
+        if ValueType.CNVI not in device_info or ValueType.CNVR not in device_info:
+            raise DriverError("insufficient device info, missing CNVI or CNVR")
+
+        firmware_base_name = (
+            "ibt-"
+            f"{device_info[ValueType.CNVI]:04X}-"
+            f"{device_info[ValueType.CNVR]:04X}"
+        )
+        logger.debug(f"FW base name: {firmware_base_name}")
+
+        firmware_name = f"{firmware_base_name}.sfi"
+        firmware_path = _find_binary_path(firmware_name)
+        if not firmware_path:
+            logger.warning(f"Firmware file {firmware_name} not found")
+            logger.warning("See https://google.github.io/bumble/drivers/intel.html")
+            return None
+        logger.debug(f"loading firmware from {firmware_path}")
+        firmware_image = firmware_path.read_bytes()
+
+        engine_type = device_info.get(ValueType.SECURE_BOOT_ENGINE_TYPE)
+        if engine_type is None:
+            raise DriverError("secure boot engine type missing")
+        if engine_type not in _BOOT_PARAMS:
+            raise DriverError("secure boot engine type not supported")
+
+        boot_params = _BOOT_PARAMS[engine_type]
+        if len(firmware_image) < boot_params.write_offset:
+            raise DriverError("firmware image too small")
+
+        # Register to receive vendor events.
+        def on_vendor_event(event: hci.HCI_Vendor_Event):
+            logger.debug(f"vendor event: {event}")
+            event_type = event.parameters[0]
+            if event_type == 0x02:
+                # Boot event
+                logger.debug("boot complete")
+                self.reset_complete.set()
+            elif event_type == 0x06:
+                # Firmware load event
+                logger.debug("download complete")
+                self.firmware_load_complete.set()
+            else:
+                logger.debug(f"ignoring vendor event type {event_type}")
+
+        self.host.on("vendor_event", on_vendor_event)
+
+        # We need to temporarily intercept packets from the controller,
+        # because they are formatted as HCI event packets but are received
+        # on the ACL channel, so the host parser would get confused.
+        saved_on_packet = self.host.on_packet
+        self.host.on_packet = self.on_packet  # type: ignore
+        self.firmware_load_complete.clear()
+
+        # Send the CSS header
+        data = firmware_image[
+            boot_params.css_header_offset : boot_params.css_header_offset
+            + boot_params.css_header_size
+        ]
+        await self.send_firmware_data(0x00, data)
+
+        # Send the PKI header
+        data = firmware_image[
+            boot_params.pki_offset : boot_params.pki_offset + boot_params.pki_size
+        ]
+        await self.send_firmware_data(0x03, data)
+
+        # Send the Signature header
+        data = firmware_image[
+            boot_params.sig_offset : boot_params.sig_offset + boot_params.sig_size
+        ]
+        await self.send_firmware_data(0x02, data)
+
+        # Send the rest of the image.
+        # The payload consists of command objects, which are sent when they add up
+        # to a multiple of 4 bytes.
+        boot_address = 0
+        offset = boot_params.write_offset
+        fragment_size = 0
+        while offset + 3 < len(firmware_image):
+            (command_opcode,) = struct.unpack_from(
+                "<H", firmware_image, offset + fragment_size
+            )
+            command_size = firmware_image[offset + fragment_size + 2]
+            if command_opcode == HCI_INTEL_WRITE_BOOT_PARAMS_COMMAND:
+                (boot_address,) = struct.unpack_from(
+                    "<I", firmware_image, offset + fragment_size + 3
+                )
+                logger.debug(
+                    "found HCI_INTEL_WRITE_BOOT_PARAMS_COMMAND, "
+                    f"boot_address={boot_address}"
+                )
+            fragment_size += 3 + command_size
+            if fragment_size % 4 == 0:
+                await self.send_firmware_data(
+                    0x01, firmware_image[offset : offset + fragment_size]
+                )
+                logger.debug(f"sent {fragment_size} bytes")
+                offset += fragment_size
+                fragment_size = 0
+
+        # Wait for the firmware loading to be complete.
+        logger.debug("waiting for firmware to be loaded")
+        await self.firmware_load_complete.wait()
+        logger.debug("firmware loaded")
+
+        # Restore the original packet handler.
+        self.host.on_packet = saved_on_packet  # type: ignore
+
+        # Reset
+        self.reset_complete.clear()
+        self.host.send_hci_packet(
+            HCI_Intel_Reset_Command(
+                reset_type=0x00,
+                patch_enable=0x01,
+                ddc_reload=0x00,
+                boot_option=0x01,
+                boot_address=boot_address,
             )
         )
+        logger.debug("waiting for reset completion")
+        await self.reset_complete.wait()
+        logger.debug("reset complete")
+
+        # Load the device config if there is one.
+        if self.ddc_override:
+            logger.debug("loading overridden DDC")
+            await self.load_device_config(self.ddc_override)
+        else:
+            ddc_name = f"{firmware_base_name}.ddc"
+            ddc_path = _find_binary_path(ddc_name)
+            if ddc_path:
+                logger.debug(f"loading DDC from {ddc_path}")
+                ddc_data = ddc_path.read_bytes()
+                await self.load_device_config(ddc_data)
+        if self.ddc_addon:
+            logger.debug("loading DDC addon")
+            await self.load_device_config(self.ddc_addon)
+
+    async def load_device_config(self, ddc_data: bytes) -> None:
+        while ddc_data:
+            ddc_len = 1 + ddc_data[0]
+            ddc_payload = ddc_data[:ddc_len]
+            await self.host.send_command(
+                Hci_Intel_Write_Device_Config_Command(data=ddc_payload)
+            )
+            ddc_data = ddc_data[ddc_len:]
+
+    async def reboot_bootloader(self) -> None:
+        self.host.send_hci_packet(
+            HCI_Intel_Reset_Command(
+                reset_type=0x01,
+                patch_enable=0x01,
+                ddc_reload=0x01,
+                boot_option=0x00,
+                boot_address=0,
+            )
+        )
+        await asyncio.sleep(_POST_RESET_DELAY)
+
+    async def read_device_info(self) -> dict[ValueType, Any]:
+        self.host.ready = True
+        response = await self.host.send_command(hci.HCI_Reset_Command())
+        if not (
+            isinstance(response, hci.HCI_Command_Complete_Event)
+            and response.return_parameters
+            in (hci.HCI_UNKNOWN_HCI_COMMAND_ERROR, hci.HCI_SUCCESS)
+        ):
+            # When the controller is in operational mode, the response is a
+            # successful response.
+            # When the controller is in bootloader mode,
+            # HCI_UNKNOWN_HCI_COMMAND_ERROR is the expected response. Anything
+            # else is a failure.
+            logger.warning(f"unexpected response: {response}")
+            raise DriverError("unexpected HCI response")
+
+        # Read the firmware version.
+        response = await self.host.send_command(
+            HCI_Intel_Read_Version_Command(param0=0xFF)
+        )
+        if not isinstance(response, hci.HCI_Command_Complete_Event):
+            raise DriverError("unexpected HCI response")
+
+        if response.return_parameters.status != 0:  # type: ignore
+            raise DriverError("HCI_Intel_Read_Version_Command error")
+
+        tlvs = _parse_tlv(response.return_parameters.tlv)  # type: ignore
+
+        # Convert the list to a dict. That's Ok here because we only expect each type
+        # to appear just once.
+        return dict(tlvs)
+
+    async def init_controller(self):
+        await self.load_firmware()
diff --git a/bumble/gap.py b/bumble/gap.py
index c07a30d..e2dddb9 100644
--- a/bumble/gap.py
+++ b/bumble/gap.py
@@ -18,7 +18,7 @@
 import logging
 import struct
 
-from .gatt import (
+from bumble.gatt import (
     Service,
     Characteristic,
     GATT_GENERIC_ACCESS_SERVICE,
diff --git a/bumble/gatt.py b/bumble/gatt.py
index ea65116..701d8d0 100644
--- a/bumble/gatt.py
+++ b/bumble/gatt.py
@@ -27,25 +27,16 @@ import enum
 import functools
 import logging
 import struct
-from typing import (
-    Callable,
-    Dict,
-    Iterable,
-    List,
-    Optional,
-    Sequence,
-    Union,
-    TYPE_CHECKING,
-)
+from typing import Iterable, List, Optional, Sequence, TypeVar, Union
 
 from bumble.colors import color
 from bumble.core import BaseBumbleError, UUID
 from bumble.att import Attribute, AttributeValue
 
-if TYPE_CHECKING:
-    from bumble.gatt_client import AttributeProxy
-    from bumble.device import Connection
-
+# -----------------------------------------------------------------------------
+# Typing
+# -----------------------------------------------------------------------------
+_T = TypeVar('_T')
 
 # -----------------------------------------------------------------------------
 # Logging
@@ -275,6 +266,13 @@ GATT_SOURCE_AUDIO_LOCATION_CHARACTERISTIC       = UUID.from_16_bits(0x2BCC, 'Sou
 GATT_AVAILABLE_AUDIO_CONTEXTS_CHARACTERISTIC    = UUID.from_16_bits(0x2BCD, 'Available Audio Contexts')
 GATT_SUPPORTED_AUDIO_CONTEXTS_CHARACTERISTIC    = UUID.from_16_bits(0x2BCE, 'Supported Audio Contexts')
 
+# Gaming Audio Service (GMAS)
+GATT_GMAP_ROLE_CHARACTERISTIC    = UUID.from_16_bits(0x2C00, 'GMAP Role')
+GATT_UGG_FEATURES_CHARACTERISTIC = UUID.from_16_bits(0x2C01, 'UGG Features')
+GATT_UGT_FEATURES_CHARACTERISTIC = UUID.from_16_bits(0x2C02, 'UGT Features')
+GATT_BGS_FEATURES_CHARACTERISTIC = UUID.from_16_bits(0x2C03, 'BGS Features')
+GATT_BGR_FEATURES_CHARACTERISTIC = UUID.from_16_bits(0x2C04, 'BGR Features')
+
 # Hearing Access Service
 GATT_HEARING_AID_FEATURES_CHARACTERISTIC             = UUID.from_16_bits(0x2BDA, 'Hearing Aid Features')
 GATT_HEARING_AID_PRESET_CONTROL_POINT_CHARACTERISTIC = UUID.from_16_bits(0x2BDB, 'Hearing Aid Preset Control Point')
@@ -288,6 +286,22 @@ GATT_ASHA_AUDIO_STATUS_CHARACTERISTIC         = UUID('38663f1a-e711-4cac-b641-32
 GATT_ASHA_VOLUME_CHARACTERISTIC               = UUID('00e4ca9e-ab14-41e4-8823-f9e70c7e91df', 'Volume')
 GATT_ASHA_LE_PSM_OUT_CHARACTERISTIC           = UUID('2d410339-82b6-42aa-b34e-e2e01df8cc1a', 'LE_PSM_OUT')
 
+# Apple Notification Center Service
+GATT_ANCS_SERVICE                            = UUID('7905F431-B5CE-4E99-A40F-4B1E122D00D0', 'Apple Notification Center')
+GATT_ANCS_NOTIFICATION_SOURCE_CHARACTERISTIC = UUID('9FBF120D-6301-42D9-8C58-25E699A21DBD', 'Notification Source')
+GATT_ANCS_CONTROL_POINT_CHARACTERISTIC       = UUID('69D1D8F3-45E1-49A8-9821-9BBDFDAAD9D9', 'Control Point')
+GATT_ANCS_DATA_SOURCE_CHARACTERISTIC         = UUID('22EAC6E9-24D6-4BB5-BE44-B36ACE7C7BFB', 'Data Source')
+
+# Apple Media Service
+GATT_AMS_SERVICE                         = UUID('89D3502B-0F36-433A-8EF4-C502AD55F8DC', 'Apple Media')
+GATT_AMS_REMOTE_COMMAND_CHARACTERISTIC   = UUID('9B3C81D8-57B1-4A8A-B8DF-0E56F7CA51C2', 'Remote Command')
+GATT_AMS_ENTITY_UPDATE_CHARACTERISTIC    = UUID('2F7CABCE-808D-411F-9A0C-BB92BA96C102', 'Entity Update')
+GATT_AMS_ENTITY_ATTRIBUTE_CHARACTERISTIC = UUID('C6B2F38C-23AB-46D8-A6AB-A3A870BBD5D7', 'Entity Attribute')
+
+# Misc Apple Services
+GATT_APPLE_CONTINUITY_SERVICE = UUID('D0611E78-BBB4-4591-A5F8-487910AE4366', 'Apple Continuity')
+GATT_APPLE_NEARBY_SERVICE     = UUID('9FA480E0-4967-4542-9390-D343DC5D04AE', 'Apple Nearby')
+
 # Misc
 GATT_DEVICE_NAME_CHARACTERISTIC                                = UUID.from_16_bits(0x2A00, 'Device Name')
 GATT_APPEARANCE_CHARACTERISTIC                                 = UUID.from_16_bits(0x2A01, 'Appearance')
@@ -304,6 +318,7 @@ GATT_CENTRAL_ADDRESS_RESOLUTION__CHARACTERISTIC                = UUID.from_16_bi
 GATT_CLIENT_SUPPORTED_FEATURES_CHARACTERISTIC                  = UUID.from_16_bits(0x2B29, 'Client Supported Features')
 GATT_DATABASE_HASH_CHARACTERISTIC                              = UUID.from_16_bits(0x2B2A, 'Database Hash')
 GATT_SERVER_SUPPORTED_FEATURES_CHARACTERISTIC                  = UUID.from_16_bits(0x2B3A, 'Server Supported Features')
+GATT_LE_GATT_SECURITY_LEVELS_CHARACTERISTIC                    = UUID.from_16_bits(0x2BF5, 'E GATT Security Levels')
 
 # fmt: on
 # pylint: enable=line-too-long
@@ -312,8 +327,6 @@ GATT_SERVER_SUPPORTED_FEATURES_CHARACTERISTIC                  = UUID.from_16_bi
 # -----------------------------------------------------------------------------
 # Utils
 # -----------------------------------------------------------------------------
-
-
 def show_services(services: Iterable[Service]) -> None:
     for service in services:
         print(color(str(service), 'cyan'))
@@ -343,7 +356,7 @@ class Service(Attribute):
     def __init__(
         self,
         uuid: Union[str, UUID],
-        characteristics: List[Characteristic],
+        characteristics: Iterable[Characteristic],
         primary=True,
         included_services: Iterable[Service] = (),
     ) -> None:
@@ -362,7 +375,7 @@ class Service(Attribute):
         )
         self.uuid = uuid
         self.included_services = list(included_services)
-        self.characteristics = characteristics[:]
+        self.characteristics = list(characteristics)
         self.primary = primary
 
     def get_advertising_data(self) -> Optional[bytes]:
@@ -393,7 +406,7 @@ class TemplateService(Service):
 
     def __init__(
         self,
-        characteristics: List[Characteristic],
+        characteristics: Iterable[Characteristic],
         primary: bool = True,
         included_services: Iterable[Service] = (),
     ) -> None:
@@ -410,7 +423,7 @@ class IncludedServiceDeclaration(Attribute):
 
     def __init__(self, service: Service) -> None:
         declaration_bytes = struct.pack(
-            '<HH2s', service.handle, service.end_group_handle, service.uuid.to_bytes()
+            '<HH2s', service.handle, service.end_group_handle, bytes(service.uuid)
         )
         super().__init__(
             GATT_INCLUDE_ATTRIBUTE_TYPE, Attribute.READABLE, declaration_bytes
@@ -427,7 +440,7 @@ class IncludedServiceDeclaration(Attribute):
 
 
 # -----------------------------------------------------------------------------
-class Characteristic(Attribute):
+class Characteristic(Attribute[_T]):
     '''
     See Vol 3, Part G - 3.3 CHARACTERISTIC DEFINITION
     '''
@@ -435,6 +448,8 @@ class Characteristic(Attribute):
     uuid: UUID
     properties: Characteristic.Properties
 
+    EVENT_SUBSCRIPTION = "subscription"
+
     class Properties(enum.IntFlag):
         """Property flags"""
 
@@ -490,7 +505,7 @@ class Characteristic(Attribute):
         uuid: Union[str, bytes, UUID],
         properties: Characteristic.Properties,
         permissions: Union[str, Attribute.Permissions],
-        value: Union[str, bytes, CharacteristicValue] = b'',
+        value: Union[AttributeValue[_T], _T, None] = None,
         descriptors: Sequence[Descriptor] = (),
     ):
         super().__init__(uuid, permissions, value)
@@ -525,7 +540,11 @@ class CharacteristicDeclaration(Attribute):
 
     characteristic: Characteristic
 
-    def __init__(self, characteristic: Characteristic, value_handle: int) -> None:
+    def __init__(
+        self,
+        characteristic: Characteristic,
+        value_handle: int,
+    ) -> None:
         declaration_bytes = (
             struct.pack('<BH', characteristic.properties, value_handle)
             + characteristic.uuid.to_pdu_bytes()
@@ -546,195 +565,10 @@ class CharacteristicDeclaration(Attribute):
 
 
 # -----------------------------------------------------------------------------
-class CharacteristicValue(AttributeValue):
+class CharacteristicValue(AttributeValue[_T]):
     """Same as AttributeValue, for backward compatibility"""
 
 
-# -----------------------------------------------------------------------------
-class CharacteristicAdapter:
-    '''
-    An adapter that can adapt Characteristic and AttributeProxy objects
-    by wrapping their `read_value()` and `write_value()` methods with ones that
-    return/accept encoded/decoded values.
-
-    For proxies (i.e used by a GATT client), the adaptation is one where the return
-    value of `read_value()` is decoded and the value passed to `write_value()` is
-    encoded. The `subscribe()` method, is wrapped with one where the values are decoded
-    before being passed to the subscriber.
-
-    For local values (i.e hosted by a GATT server) the adaptation is one where the
-    return value of `read_value()` is encoded and the value passed to `write_value()`
-    is decoded.
-    '''
-
-    read_value: Callable
-    write_value: Callable
-
-    def __init__(self, characteristic: Union[Characteristic, AttributeProxy]):
-        self.wrapped_characteristic = characteristic
-        self.subscribers: Dict[Callable, Callable] = (
-            {}
-        )  # Map from subscriber to proxy subscriber
-
-        if isinstance(characteristic, Characteristic):
-            self.read_value = self.read_encoded_value
-            self.write_value = self.write_encoded_value
-        else:
-            self.read_value = self.read_decoded_value
-            self.write_value = self.write_decoded_value
-            self.subscribe = self.wrapped_subscribe
-            self.unsubscribe = self.wrapped_unsubscribe
-
-    def __getattr__(self, name):
-        return getattr(self.wrapped_characteristic, name)
-
-    def __setattr__(self, name, value):
-        if name in (
-            'wrapped_characteristic',
-            'subscribers',
-            'read_value',
-            'write_value',
-            'subscribe',
-            'unsubscribe',
-        ):
-            super().__setattr__(name, value)
-        else:
-            setattr(self.wrapped_characteristic, name, value)
-
-    async def read_encoded_value(self, connection):
-        return self.encode_value(
-            await self.wrapped_characteristic.read_value(connection)
-        )
-
-    async def write_encoded_value(self, connection, value):
-        return await self.wrapped_characteristic.write_value(
-            connection, self.decode_value(value)
-        )
-
-    async def read_decoded_value(self):
-        return self.decode_value(await self.wrapped_characteristic.read_value())
-
-    async def write_decoded_value(self, value, with_response=False):
-        return await self.wrapped_characteristic.write_value(
-            self.encode_value(value), with_response
-        )
-
-    def encode_value(self, value):
-        return value
-
-    def decode_value(self, value):
-        return value
-
-    def wrapped_subscribe(self, subscriber=None):
-        if subscriber is not None:
-            if subscriber in self.subscribers:
-                # We already have a proxy subscriber
-                subscriber = self.subscribers[subscriber]
-            else:
-                # Create and register a proxy that will decode the value
-                original_subscriber = subscriber
-
-                def on_change(value):
-                    original_subscriber(self.decode_value(value))
-
-                self.subscribers[subscriber] = on_change
-                subscriber = on_change
-
-        return self.wrapped_characteristic.subscribe(subscriber)
-
-    def wrapped_unsubscribe(self, subscriber=None):
-        if subscriber in self.subscribers:
-            subscriber = self.subscribers.pop(subscriber)
-
-        return self.wrapped_characteristic.unsubscribe(subscriber)
-
-    def __str__(self) -> str:
-        wrapped = str(self.wrapped_characteristic)
-        return f'{self.__class__.__name__}({wrapped})'
-
-
-# -----------------------------------------------------------------------------
-class DelegatedCharacteristicAdapter(CharacteristicAdapter):
-    '''
-    Adapter that converts bytes values using an encode and a decode function.
-    '''
-
-    def __init__(self, characteristic, encode=None, decode=None):
-        super().__init__(characteristic)
-        self.encode = encode
-        self.decode = decode
-
-    def encode_value(self, value):
-        return self.encode(value) if self.encode else value
-
-    def decode_value(self, value):
-        return self.decode(value) if self.decode else value
-
-
-# -----------------------------------------------------------------------------
-class PackedCharacteristicAdapter(CharacteristicAdapter):
-    '''
-    Adapter that packs/unpacks characteristic values according to a standard
-    Python `struct` format.
-    For formats with a single value, the adapted `read_value` and `write_value`
-    methods return/accept single values. For formats with multiple values,
-    they return/accept a tuple with the same number of elements as is required for
-    the format.
-    '''
-
-    def __init__(self, characteristic, pack_format):
-        super().__init__(characteristic)
-        self.struct = struct.Struct(pack_format)
-
-    def pack(self, *values):
-        return self.struct.pack(*values)
-
-    def unpack(self, buffer):
-        return self.struct.unpack(buffer)
-
-    def encode_value(self, value):
-        return self.pack(*value if isinstance(value, tuple) else (value,))
-
-    def decode_value(self, value):
-        unpacked = self.unpack(value)
-        return unpacked[0] if len(unpacked) == 1 else unpacked
-
-
-# -----------------------------------------------------------------------------
-class MappedCharacteristicAdapter(PackedCharacteristicAdapter):
-    '''
-    Adapter that packs/unpacks characteristic values according to a standard
-    Python `struct` format.
-    The adapted `read_value` and `write_value` methods return/accept aa dictionary which
-    is packed/unpacked according to format, with the arguments extracted from the
-    dictionary by key, in the same order as they occur in the `keys` parameter.
-    '''
-
-    def __init__(self, characteristic, pack_format, keys):
-        super().__init__(characteristic, pack_format)
-        self.keys = keys
-
-    # pylint: disable=arguments-differ
-    def pack(self, values):
-        return super().pack(*(values[key] for key in self.keys))
-
-    def unpack(self, buffer):
-        return dict(zip(self.keys, super().unpack(buffer)))
-
-
-# -----------------------------------------------------------------------------
-class UTF8CharacteristicAdapter(CharacteristicAdapter):
-    '''
-    Adapter that converts strings to/from bytes using UTF-8 encoding
-    '''
-
-    def encode_value(self, value: str) -> bytes:
-        return value.encode('utf-8')
-
-    def decode_value(self, value: bytes) -> str:
-        return value.decode('utf-8')
-
-
 # -----------------------------------------------------------------------------
 class Descriptor(Attribute):
     '''
@@ -745,11 +579,7 @@ class Descriptor(Attribute):
         if isinstance(self.value, bytes):
             value_str = self.value.hex()
         elif isinstance(self.value, CharacteristicValue):
-            value = self.value.read(None)
-            if isinstance(value, bytes):
-                value_str = value.hex()
-            else:
-                value_str = '<async>'
+            value_str = '<dynamic>'
         else:
             value_str = '<...>'
         return (
@@ -769,3 +599,23 @@ class ClientCharacteristicConfigurationBits(enum.IntFlag):
     DEFAULT = 0x0000
     NOTIFICATION = 0x0001
     INDICATION = 0x0002
+
+
+# -----------------------------------------------------------------------------
+class ClientSupportedFeatures(enum.IntFlag):
+    '''
+    See Vol 3, Part G - 7.2 - Table 7.6: Client Supported Features bit assignments.
+    '''
+
+    ROBUST_CACHING = 0x01
+    ENHANCED_ATT_BEARER = 0x02
+    MULTIPLE_HANDLE_VALUE_NOTIFICATIONS = 0x04
+
+
+# -----------------------------------------------------------------------------
+class ServerSupportedFeatures(enum.IntFlag):
+    '''
+    See Vol 3, Part G - 7.4 - Table 7.11: Server Supported Features bit assignments.
+    '''
+
+    EATT_SUPPORTED = 0x01
diff --git a/bumble/gatt_adapters.py b/bumble/gatt_adapters.py
new file mode 100644
index 0000000..86a6198
--- /dev/null
+++ b/bumble/gatt_adapters.py
@@ -0,0 +1,374 @@
+# Copyright 2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# -----------------------------------------------------------------------------
+# GATT - Type Adapters
+# -----------------------------------------------------------------------------
+
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
+from __future__ import annotations
+import struct
+from typing import (
+    Any,
+    Callable,
+    Generic,
+    Iterable,
+    Literal,
+    Optional,
+    Type,
+    TypeVar,
+)
+
+from bumble.core import InvalidOperationError
+from bumble.gatt import Characteristic
+from bumble.gatt_client import CharacteristicProxy
+from bumble import utils
+
+
+# -----------------------------------------------------------------------------
+# Typing
+# -----------------------------------------------------------------------------
+_T = TypeVar('_T')
+_T2 = TypeVar('_T2', bound=utils.ByteSerializable)
+_T3 = TypeVar('_T3', bound=utils.IntConvertible)
+
+
+# -----------------------------------------------------------------------------
+class CharacteristicAdapter(Characteristic, Generic[_T]):
+    '''Base class for GATT Characteristic adapters.'''
+
+    def __init__(self, characteristic: Characteristic) -> None:
+        super().__init__(
+            characteristic.uuid,
+            characteristic.properties,
+            characteristic.permissions,
+            characteristic.value,
+            characteristic.descriptors,
+        )
+
+
+# -----------------------------------------------------------------------------
+class CharacteristicProxyAdapter(CharacteristicProxy[_T]):
+    '''Base class for GATT CharacteristicProxy adapters.'''
+
+    def __init__(self, characteristic_proxy: CharacteristicProxy):
+        super().__init__(
+            characteristic_proxy.client,
+            characteristic_proxy.handle,
+            characteristic_proxy.end_group_handle,
+            characteristic_proxy.uuid,
+            characteristic_proxy.properties,
+        )
+
+
+# -----------------------------------------------------------------------------
+class DelegatedCharacteristicAdapter(CharacteristicAdapter[_T]):
+    '''
+    Adapter that converts bytes values using an encode and/or a decode function.
+    '''
+
+    def __init__(
+        self,
+        characteristic: Characteristic,
+        encode: Optional[Callable[[_T], bytes]] = None,
+        decode: Optional[Callable[[bytes], _T]] = None,
+    ):
+        super().__init__(characteristic)
+        self.encode = encode
+        self.decode = decode
+
+    def encode_value(self, value: _T) -> bytes:
+        if self.encode is None:
+            raise InvalidOperationError('delegated adapter does not have an encoder')
+        return self.encode(value)
+
+    def decode_value(self, value: bytes) -> _T:
+        if self.decode is None:
+            raise InvalidOperationError('delegate adapter does not have a decoder')
+        return self.decode(value)
+
+
+# -----------------------------------------------------------------------------
+class DelegatedCharacteristicProxyAdapter(CharacteristicProxyAdapter[_T]):
+    '''
+    Adapter that converts bytes values using an encode and a decode function.
+    '''
+
+    def __init__(
+        self,
+        characteristic_proxy: CharacteristicProxy,
+        encode: Optional[Callable[[_T], bytes]] = None,
+        decode: Optional[Callable[[bytes], _T]] = None,
+    ):
+        super().__init__(characteristic_proxy)
+        self.encode = encode
+        self.decode = decode
+
+    def encode_value(self, value: _T) -> bytes:
+        if self.encode is None:
+            raise InvalidOperationError('delegated adapter does not have an encoder')
+        return self.encode(value)
+
+    def decode_value(self, value: bytes) -> _T:
+        if self.decode is None:
+            raise InvalidOperationError('delegate adapter does not have a decoder')
+        return self.decode(value)
+
+
+# -----------------------------------------------------------------------------
+class PackedCharacteristicAdapter(CharacteristicAdapter):
+    '''
+    Adapter that packs/unpacks characteristic values according to a standard
+    Python `struct` format.
+    For formats with a single value, the adapted `read_value` and `write_value`
+    methods return/accept single values. For formats with multiple values,
+    they return/accept a tuple with the same number of elements as is required for
+    the format.
+    '''
+
+    def __init__(self, characteristic: Characteristic, pack_format: str) -> None:
+        super().__init__(characteristic)
+        self.struct = struct.Struct(pack_format)
+
+    def pack(self, *values) -> bytes:
+        return self.struct.pack(*values)
+
+    def unpack(self, buffer: bytes) -> tuple:
+        return self.struct.unpack(buffer)
+
+    def encode_value(self, value: Any) -> bytes:
+        return self.pack(*value if isinstance(value, tuple) else (value,))
+
+    def decode_value(self, value: bytes) -> Any:
+        unpacked = self.unpack(value)
+        return unpacked[0] if len(unpacked) == 1 else unpacked
+
+
+# -----------------------------------------------------------------------------
+class PackedCharacteristicProxyAdapter(CharacteristicProxyAdapter):
+    '''
+    Adapter that packs/unpacks characteristic values according to a standard
+    Python `struct` format.
+    For formats with a single value, the adapted `read_value` and `write_value`
+    methods return/accept single values. For formats with multiple values,
+    they return/accept a tuple with the same number of elements as is required for
+    the format.
+    '''
+
+    def __init__(self, characteristic_proxy, pack_format):
+        super().__init__(characteristic_proxy)
+        self.struct = struct.Struct(pack_format)
+
+    def pack(self, *values) -> bytes:
+        return self.struct.pack(*values)
+
+    def unpack(self, buffer: bytes) -> tuple:
+        return self.struct.unpack(buffer)
+
+    def encode_value(self, value: Any) -> bytes:
+        return self.pack(*value if isinstance(value, tuple) else (value,))
+
+    def decode_value(self, value: bytes) -> Any:
+        unpacked = self.unpack(value)
+        return unpacked[0] if len(unpacked) == 1 else unpacked
+
+
+# -----------------------------------------------------------------------------
+class MappedCharacteristicAdapter(PackedCharacteristicAdapter):
+    '''
+    Adapter that packs/unpacks characteristic values according to a standard
+    Python `struct` format.
+    The adapted `read_value` and `write_value` methods return/accept a dictionary which
+    is packed/unpacked according to format, with the arguments extracted from the
+    dictionary by key, in the same order as they occur in the `keys` parameter.
+    '''
+
+    def __init__(
+        self, characteristic: Characteristic, pack_format: str, keys: Iterable[str]
+    ) -> None:
+        super().__init__(characteristic, pack_format)
+        self.keys = keys
+
+    # pylint: disable=arguments-differ
+    def pack(self, values) -> bytes:
+        return super().pack(*(values[key] for key in self.keys))
+
+    def unpack(self, buffer: bytes) -> Any:
+        return dict(zip(self.keys, super().unpack(buffer)))
+
+
+# -----------------------------------------------------------------------------
+class MappedCharacteristicProxyAdapter(PackedCharacteristicProxyAdapter):
+    '''
+    Adapter that packs/unpacks characteristic values according to a standard
+    Python `struct` format.
+    The adapted `read_value` and `write_value` methods return/accept a dictionary which
+    is packed/unpacked according to format, with the arguments extracted from the
+    dictionary by key, in the same order as they occur in the `keys` parameter.
+    '''
+
+    def __init__(
+        self,
+        characteristic_proxy: CharacteristicProxy,
+        pack_format: str,
+        keys: Iterable[str],
+    ) -> None:
+        super().__init__(characteristic_proxy, pack_format)
+        self.keys = keys
+
+    # pylint: disable=arguments-differ
+    def pack(self, values) -> bytes:
+        return super().pack(*(values[key] for key in self.keys))
+
+    def unpack(self, buffer: bytes) -> Any:
+        return dict(zip(self.keys, super().unpack(buffer)))
+
+
+# -----------------------------------------------------------------------------
+class UTF8CharacteristicAdapter(CharacteristicAdapter[str]):
+    '''
+    Adapter that converts strings to/from bytes using UTF-8 encoding
+    '''
+
+    def encode_value(self, value: str) -> bytes:
+        return value.encode('utf-8')
+
+    def decode_value(self, value: bytes) -> str:
+        return value.decode('utf-8')
+
+
+# -----------------------------------------------------------------------------
+class UTF8CharacteristicProxyAdapter(CharacteristicProxyAdapter[str]):
+    '''
+    Adapter that converts strings to/from bytes using UTF-8 encoding
+    '''
+
+    def encode_value(self, value: str) -> bytes:
+        return value.encode('utf-8')
+
+    def decode_value(self, value: bytes) -> str:
+        return value.decode('utf-8')
+
+
+# -----------------------------------------------------------------------------
+class SerializableCharacteristicAdapter(CharacteristicAdapter[_T2]):
+    '''
+    Adapter that converts any class to/from bytes using the class'
+    `to_bytes` and `__bytes__` methods, respectively.
+    '''
+
+    def __init__(self, characteristic: Characteristic, cls: Type[_T2]) -> None:
+        super().__init__(characteristic)
+        self.cls = cls
+
+    def encode_value(self, value: _T2) -> bytes:
+        return bytes(value)
+
+    def decode_value(self, value: bytes) -> _T2:
+        return self.cls.from_bytes(value)
+
+
+# -----------------------------------------------------------------------------
+class SerializableCharacteristicProxyAdapter(CharacteristicProxyAdapter[_T2]):
+    '''
+    Adapter that converts any class to/from bytes using the class'
+    `to_bytes` and `__bytes__` methods, respectively.
+    '''
+
+    def __init__(
+        self, characteristic_proxy: CharacteristicProxy, cls: Type[_T2]
+    ) -> None:
+        super().__init__(characteristic_proxy)
+        self.cls = cls
+
+    def encode_value(self, value: _T2) -> bytes:
+        return bytes(value)
+
+    def decode_value(self, value: bytes) -> _T2:
+        return self.cls.from_bytes(value)
+
+
+# -----------------------------------------------------------------------------
+class EnumCharacteristicAdapter(CharacteristicAdapter[_T3]):
+    '''
+    Adapter that converts int-enum-like classes to/from bytes using the class'
+    `int().to_bytes()` and `from_bytes()` methods, respectively.
+    '''
+
+    def __init__(
+        self,
+        characteristic: Characteristic,
+        cls: Type[_T3],
+        length: int,
+        byteorder: Literal['little', 'big'] = 'little',
+    ):
+        """
+        Initialize an instance.
+
+        Params:
+          characteristic: the Characteristic to adapt to/from
+          cls: the class to/from which to convert integer values
+          length: number of bytes used to represent integer values
+          byteorder: byte order of the byte representation of integers.
+        """
+        super().__init__(characteristic)
+        self.cls = cls
+        self.length = length
+        self.byteorder = byteorder
+
+    def encode_value(self, value: _T3) -> bytes:
+        return int(value).to_bytes(self.length, self.byteorder)
+
+    def decode_value(self, value: bytes) -> _T3:
+        int_value = int.from_bytes(value, self.byteorder)
+        return self.cls(int_value)
+
+
+# -----------------------------------------------------------------------------
+class EnumCharacteristicProxyAdapter(CharacteristicProxyAdapter[_T3]):
+    '''
+    Adapter that converts int-enum-like classes to/from bytes using the class'
+    `int().to_bytes()` and `from_bytes()` methods, respectively.
+    '''
+
+    def __init__(
+        self,
+        characteristic_proxy: CharacteristicProxy,
+        cls: Type[_T3],
+        length: int,
+        byteorder: Literal['little', 'big'] = 'little',
+    ):
+        """
+        Initialize an instance.
+
+        Params:
+          characteristic_proxy: the CharacteristicProxy to adapt to/from
+          cls: the class to/from which to convert integer values
+          length: number of bytes used to represent integer values
+          byteorder: byte order of the byte representation of integers.
+        """
+        super().__init__(characteristic_proxy)
+        self.cls = cls
+        self.length = length
+        self.byteorder = byteorder
+
+    def encode_value(self, value: _T3) -> bytes:
+        return int(value).to_bytes(self.length, self.byteorder)
+
+    def decode_value(self, value: bytes) -> _T3:
+        int_value = int.from_bytes(value, self.byteorder)
+        a = self.cls(int_value)
+        return self.cls(int_value)
diff --git a/bumble/gatt_client.py b/bumble/gatt_client.py
index b975a31..c2f23e3 100644
--- a/bumble/gatt_client.py
+++ b/bumble/gatt_client.py
@@ -29,24 +29,25 @@ import logging
 import struct
 from datetime import datetime
 from typing import (
+    Any,
+    Callable,
+    Dict,
+    Generic,
+    Iterable,
     List,
     Optional,
-    Dict,
+    Set,
     Tuple,
-    Callable,
     Union,
-    Any,
-    Iterable,
     Type,
-    Set,
+    TypeVar,
     TYPE_CHECKING,
 )
 
-from pyee import EventEmitter
 
-from .colors import color
-from .hci import HCI_Constant
-from .att import (
+from bumble.colors import color
+from bumble.hci import HCI_Constant
+from bumble.att import (
     ATT_ATTRIBUTE_NOT_FOUND_ERROR,
     ATT_ATTRIBUTE_NOT_LONG_ERROR,
     ATT_CID,
@@ -67,9 +68,10 @@ from .att import (
     ATT_Write_Request,
     ATT_Error,
 )
-from . import core
-from .core import UUID, InvalidStateError
-from .gatt import (
+from bumble import utils
+from bumble import core
+from bumble.core import UUID, InvalidStateError
+from bumble.gatt import (
     GATT_CHARACTERISTIC_ATTRIBUTE_TYPE,
     GATT_CLIENT_CHARACTERISTIC_CONFIGURATION_DESCRIPTOR,
     GATT_PRIMARY_SERVICE_ATTRIBUTE_TYPE,
@@ -78,12 +80,18 @@ from .gatt import (
     GATT_INCLUDE_ATTRIBUTE_TYPE,
     Characteristic,
     ClientCharacteristicConfigurationBits,
+    InvalidServiceError,
     TemplateService,
 )
 
+# -----------------------------------------------------------------------------
+# Typing
+# -----------------------------------------------------------------------------
 if TYPE_CHECKING:
     from bumble.device import Connection
 
+_T = TypeVar('_T')
+
 # -----------------------------------------------------------------------------
 # Logging
 # -----------------------------------------------------------------------------
@@ -109,31 +117,31 @@ def show_services(services: Iterable[ServiceProxy]) -> None:
 # -----------------------------------------------------------------------------
 # Proxies
 # -----------------------------------------------------------------------------
-class AttributeProxy(EventEmitter):
+class AttributeProxy(utils.EventEmitter, Generic[_T]):
     def __init__(
         self, client: Client, handle: int, end_group_handle: int, attribute_type: UUID
     ) -> None:
-        EventEmitter.__init__(self)
+        utils.EventEmitter.__init__(self)
         self.client = client
         self.handle = handle
         self.end_group_handle = end_group_handle
         self.type = attribute_type
 
-    async def read_value(self, no_long_read: bool = False) -> bytes:
+    async def read_value(self, no_long_read: bool = False) -> _T:
         return self.decode_value(
             await self.client.read_value(self.handle, no_long_read)
         )
 
-    async def write_value(self, value, with_response=False):
+    async def write_value(self, value: _T, with_response=False):
         return await self.client.write_value(
             self.handle, self.encode_value(value), with_response
         )
 
-    def encode_value(self, value: Any) -> bytes:
-        return value
+    def encode_value(self, value: _T) -> bytes:
+        return value  # type: ignore
 
-    def decode_value(self, value_bytes: bytes) -> Any:
-        return value_bytes
+    def decode_value(self, value: bytes) -> _T:
+        return value  # type: ignore
 
     def __str__(self) -> str:
         return f'Attribute(handle=0x{self.handle:04X}, type={self.type})'
@@ -141,7 +149,7 @@ class AttributeProxy(EventEmitter):
 
 class ServiceProxy(AttributeProxy):
     uuid: UUID
-    characteristics: List[CharacteristicProxy]
+    characteristics: List[CharacteristicProxy[bytes]]
     included_services: List[ServiceProxy]
 
     @staticmethod
@@ -162,29 +170,48 @@ class ServiceProxy(AttributeProxy):
         self.uuid = uuid
         self.characteristics = []
 
-    async def discover_characteristics(self, uuids=()):
+    async def discover_characteristics(
+        self, uuids=()
+    ) -> list[CharacteristicProxy[bytes]]:
         return await self.client.discover_characteristics(uuids, self)
 
-    def get_characteristics_by_uuid(self, uuid):
+    def get_characteristics_by_uuid(
+        self, uuid: UUID
+    ) -> list[CharacteristicProxy[bytes]]:
+        """Get all the characteristics with a specified UUID."""
         return self.client.get_characteristics_by_uuid(uuid, self)
 
+    def get_required_characteristic_by_uuid(
+        self, uuid: UUID
+    ) -> CharacteristicProxy[bytes]:
+        """
+        Get the first characteristic with a specified UUID.
+
+        If no characteristic with that UUID is found, an InvalidServiceError is raised.
+        """
+        if not (characteristics := self.get_characteristics_by_uuid(uuid)):
+            raise InvalidServiceError(f'{uuid} characteristic not found')
+        return characteristics[0]
+
     def __str__(self) -> str:
         return f'Service(handle=0x{self.handle:04X}, uuid={self.uuid})'
 
 
-class CharacteristicProxy(AttributeProxy):
+class CharacteristicProxy(AttributeProxy[_T]):
     properties: Characteristic.Properties
     descriptors: List[DescriptorProxy]
-    subscribers: Dict[Any, Callable[[bytes], Any]]
+    subscribers: Dict[Any, Callable[[_T], Any]]
+
+    EVENT_UPDATE = "update"
 
     def __init__(
         self,
-        client,
-        handle,
-        end_group_handle,
-        uuid,
+        client: Client,
+        handle: int,
+        end_group_handle: int,
+        uuid: UUID,
         properties: int,
-    ):
+    ) -> None:
         super().__init__(client, handle, end_group_handle, uuid)
         self.uuid = uuid
         self.properties = Characteristic.Properties(properties)
@@ -192,21 +219,21 @@ class CharacteristicProxy(AttributeProxy):
         self.descriptors_discovered = False
         self.subscribers = {}  # Map from subscriber to proxy subscriber
 
-    def get_descriptor(self, descriptor_type):
+    def get_descriptor(self, descriptor_type: UUID) -> Optional[DescriptorProxy]:
         for descriptor in self.descriptors:
             if descriptor.type == descriptor_type:
                 return descriptor
 
         return None
 
-    async def discover_descriptors(self):
+    async def discover_descriptors(self) -> list[DescriptorProxy]:
         return await self.client.discover_descriptors(self)
 
     async def subscribe(
         self,
-        subscriber: Optional[Callable[[bytes], Any]] = None,
+        subscriber: Optional[Callable[[_T], Any]] = None,
         prefer_notify: bool = True,
-    ):
+    ) -> None:
         if subscriber is not None:
             if subscriber in self.subscribers:
                 # We already have a proxy subscriber
@@ -221,13 +248,13 @@ class CharacteristicProxy(AttributeProxy):
                 self.subscribers[subscriber] = on_change
                 subscriber = on_change
 
-        return await self.client.subscribe(self, subscriber, prefer_notify)
+        await self.client.subscribe(self, subscriber, prefer_notify)
 
-    async def unsubscribe(self, subscriber=None, force=False):
+    async def unsubscribe(self, subscriber=None, force=False) -> None:
         if subscriber in self.subscribers:
             subscriber = self.subscribers.pop(subscriber)
 
-        return await self.client.unsubscribe(self, subscriber, force)
+        await self.client.unsubscribe(self, subscriber, force)
 
     def __str__(self) -> str:
         return (
@@ -237,8 +264,8 @@ class CharacteristicProxy(AttributeProxy):
         )
 
 
-class DescriptorProxy(AttributeProxy):
-    def __init__(self, client, handle, descriptor_type):
+class DescriptorProxy(AttributeProxy[bytes]):
+    def __init__(self, client: Client, handle: int, descriptor_type: UUID) -> None:
         super().__init__(client, handle, 0, descriptor_type)
 
     def __str__(self) -> str:
@@ -283,7 +310,7 @@ class Client:
         self.services = []
         self.cached_values = {}
 
-        connection.on('disconnection', self.on_disconnection)
+        connection.on(connection.EVENT_DISCONNECTION, self.on_disconnection)
 
     def send_gatt_pdu(self, pdu: bytes) -> None:
         self.connection.send_l2cap_pdu(ATT_CID, pdu)
@@ -292,7 +319,7 @@ class Client:
         logger.debug(
             f'GATT Command from client: [0x{self.connection.handle:04X}] {command}'
         )
-        self.send_gatt_pdu(command.to_bytes())
+        self.send_gatt_pdu(bytes(command))
 
     async def send_request(self, request: ATT_PDU):
         logger.debug(
@@ -310,7 +337,7 @@ class Client:
             self.pending_request = request
 
             try:
-                self.send_gatt_pdu(request.to_bytes())
+                self.send_gatt_pdu(bytes(request))
                 response = await asyncio.wait_for(
                     self.pending_response, GATT_REQUEST_TIMEOUT
                 )
@@ -328,7 +355,7 @@ class Client:
             f'GATT Confirmation from client: [0x{self.connection.handle:04X}] '
             f'{confirmation}'
         )
-        self.send_gatt_pdu(confirmation.to_bytes())
+        self.send_gatt_pdu(bytes(confirmation))
 
     async def request_mtu(self, mtu: int) -> int:
         # Check the range
@@ -357,7 +384,7 @@ class Client:
 
     def get_characteristics_by_uuid(
         self, uuid: UUID, service: Optional[ServiceProxy] = None
-    ) -> List[CharacteristicProxy]:
+    ) -> List[CharacteristicProxy[bytes]]:
         services = [service] if service else self.services
         return [
             c
@@ -609,7 +636,7 @@ class Client:
 
     async def discover_characteristics(
         self, uuids, service: Optional[ServiceProxy]
-    ) -> List[CharacteristicProxy]:
+    ) -> List[CharacteristicProxy[bytes]]:
         '''
         See Vol 3, Part G - 4.6.1 Discover All Characteristics of a Service and 4.6.2
         Discover Characteristics by UUID
@@ -622,12 +649,12 @@ class Client:
         services = [service] if service else self.services
 
         # Perform characteristic discovery for each service
-        discovered_characteristics: List[CharacteristicProxy] = []
+        discovered_characteristics: List[CharacteristicProxy[bytes]] = []
         for service in services:
             starting_handle = service.handle
             ending_handle = service.end_group_handle
 
-            characteristics: List[CharacteristicProxy] = []
+            characteristics: List[CharacteristicProxy[bytes]] = []
             while starting_handle <= ending_handle:
                 response = await self.send_request(
                     ATT_Read_By_Type_Request(
@@ -667,7 +694,7 @@ class Client:
 
                     properties, handle = struct.unpack_from('<BH', attribute_value)
                     characteristic_uuid = UUID.from_bytes(attribute_value[3:])
-                    characteristic = CharacteristicProxy(
+                    characteristic = CharacteristicProxy[bytes](
                         self, handle, 0, characteristic_uuid, properties
                     )
 
@@ -760,7 +787,7 @@ class Client:
 
         return descriptors
 
-    async def discover_attributes(self) -> List[AttributeProxy]:
+    async def discover_attributes(self) -> List[AttributeProxy[bytes]]:
         '''
         Discover all attributes, regardless of type
         '''
@@ -793,7 +820,7 @@ class Client:
                     logger.warning(f'bogus handle value: {attribute_handle}')
                     return []
 
-                attribute = AttributeProxy(
+                attribute = AttributeProxy[bytes](
                     self, attribute_handle, 0, UUID.from_bytes(attribute_uuid)
                 )
                 attributes.append(attribute)
@@ -806,7 +833,7 @@ class Client:
     async def subscribe(
         self,
         characteristic: CharacteristicProxy,
-        subscriber: Optional[Callable[[bytes], Any]] = None,
+        subscriber: Optional[Callable[[Any], Any]] = None,
         prefer_notify: bool = True,
     ) -> None:
         # If we haven't already discovered the descriptors for this characteristic,
@@ -856,7 +883,7 @@ class Client:
     async def unsubscribe(
         self,
         characteristic: CharacteristicProxy,
-        subscriber: Optional[Callable[[bytes], Any]] = None,
+        subscriber: Optional[Callable[[Any], Any]] = None,
         force: bool = False,
     ) -> None:
         '''
@@ -898,6 +925,12 @@ class Client:
                 ) and subscriber in subscribers:
                     subscribers.remove(subscriber)
 
+                    # The characteristic itself is added as subscriber. If it is the
+                    # last remaining subscriber, we remove it, such that the clean up
+                    # works correctly. Otherwise the CCCD never is set back to 0.
+                    if len(subscribers) == 1 and characteristic in subscribers:
+                        subscribers.remove(characteristic)
+
                     # Cleanup if we removed the last one
                     if not subscribers:
                         del subscriber_set[characteristic.handle]
@@ -1111,7 +1144,7 @@ class Client:
             if callable(subscriber):
                 subscriber(notification.attribute_value)
             else:
-                subscriber.emit('update', notification.attribute_value)
+                subscriber.emit(subscriber.EVENT_UPDATE, notification.attribute_value)
 
     def on_att_handle_value_indication(self, indication):
         # Call all subscribers
@@ -1126,7 +1159,7 @@ class Client:
             if callable(subscriber):
                 subscriber(indication.attribute_value)
             else:
-                subscriber.emit('update', indication.attribute_value)
+                subscriber.emit(subscriber.EVENT_UPDATE, indication.attribute_value)
 
         # Confirm that we received the indication
         self.send_confirmation(ATT_Handle_Value_Confirmation())
diff --git a/bumble/gatt_server.py b/bumble/gatt_server.py
index 0ee673c..a3a4ff8 100644
--- a/bumble/gatt_server.py
+++ b/bumble/gatt_server.py
@@ -28,8 +28,16 @@ import asyncio
 import logging
 from collections import defaultdict
 import struct
-from typing import List, Tuple, Optional, TypeVar, Type, Dict, Iterable, TYPE_CHECKING
-from pyee import EventEmitter
+from typing import (
+    Dict,
+    Iterable,
+    List,
+    Optional,
+    Tuple,
+    TypeVar,
+    Type,
+    TYPE_CHECKING,
+)
 
 from bumble.colors import color
 from bumble.core import UUID
@@ -74,7 +82,7 @@ from bumble.gatt import (
     Descriptor,
     Service,
 )
-from bumble.utils import AsyncRunner
+from bumble import utils
 
 if TYPE_CHECKING:
     from bumble.device import Device, Connection
@@ -94,7 +102,7 @@ GATT_SERVER_DEFAULT_MAX_MTU = 517
 # -----------------------------------------------------------------------------
 # GATT Server
 # -----------------------------------------------------------------------------
-class Server(EventEmitter):
+class Server(utils.EventEmitter):
     attributes: List[Attribute]
     services: List[Service]
     attributes_by_handle: Dict[int, Attribute]
@@ -102,6 +110,8 @@ class Server(EventEmitter):
     indication_semaphores: defaultdict[int, asyncio.Semaphore]
     pending_confirmations: defaultdict[int, Optional[asyncio.futures.Future]]
 
+    EVENT_CHARACTERISTIC_SUBSCRIPTION = "characteristic_subscription"
+
     def __init__(self, device: Device) -> None:
         super().__init__()
         self.device = device
@@ -305,11 +315,8 @@ class Server(EventEmitter):
             self.add_service(service)
 
     def read_cccd(
-        self, connection: Optional[Connection], characteristic: Characteristic
+        self, connection: Connection, characteristic: Characteristic
     ) -> bytes:
-        if connection is None:
-            return bytes([0, 0])
-
         subscribers = self.subscribers.get(connection.handle)
         cccd = None
         if subscribers:
@@ -339,10 +346,13 @@ class Server(EventEmitter):
         notify_enabled = value[0] & 0x01 != 0
         indicate_enabled = value[0] & 0x02 != 0
         characteristic.emit(
-            'subscription', connection, notify_enabled, indicate_enabled
+            characteristic.EVENT_SUBSCRIPTION,
+            connection,
+            notify_enabled,
+            indicate_enabled,
         )
         self.emit(
-            'characteristic_subscription',
+            self.EVENT_CHARACTERISTIC_SUBSCRIPTION,
             connection,
             characteristic,
             notify_enabled,
@@ -353,7 +363,7 @@ class Server(EventEmitter):
         logger.debug(
             f'GATT Response from server: [0x{connection.handle:04X}] {response}'
         )
-        self.send_gatt_pdu(connection.handle, response.to_bytes())
+        self.send_gatt_pdu(connection.handle, bytes(response))
 
     async def notify_subscriber(
         self,
@@ -450,7 +460,7 @@ class Server(EventEmitter):
             )
 
             try:
-                self.send_gatt_pdu(connection.handle, indication.to_bytes())
+                self.send_gatt_pdu(connection.handle, bytes(indication))
                 await asyncio.wait_for(pending_confirmation, GATT_REQUEST_TIMEOUT)
             except asyncio.TimeoutError as error:
                 logger.warning(color('!!! GATT Indicate timeout', 'red'))
@@ -458,7 +468,7 @@ class Server(EventEmitter):
             finally:
                 self.pending_confirmations[connection.handle] = None
 
-    async def notify_or_indicate_subscribers(
+    async def _notify_or_indicate_subscribers(
         self,
         indicate: bool,
         attribute: Attribute,
@@ -492,7 +502,9 @@ class Server(EventEmitter):
         value: Optional[bytes] = None,
         force: bool = False,
     ):
-        return await self.notify_or_indicate_subscribers(False, attribute, value, force)
+        return await self._notify_or_indicate_subscribers(
+            False, attribute, value, force
+        )
 
     async def indicate_subscribers(
         self,
@@ -500,7 +512,7 @@ class Server(EventEmitter):
         value: Optional[bytes] = None,
         force: bool = False,
     ):
-        return await self.notify_or_indicate_subscribers(True, attribute, value, force)
+        return await self._notify_or_indicate_subscribers(True, attribute, value, force)
 
     def on_disconnection(self, connection: Connection) -> None:
         if connection.handle in self.subscribers:
@@ -651,7 +663,7 @@ class Server(EventEmitter):
 
         self.send_response(connection, response)
 
-    @AsyncRunner.run_in_task()
+    @utils.AsyncRunner.run_in_task()
     async def on_att_find_by_type_value_request(self, connection, request):
         '''
         See Bluetooth spec Vol 3, Part F - 3.4.3.3 Find By Type Value Request
@@ -704,7 +716,7 @@ class Server(EventEmitter):
 
         self.send_response(connection, response)
 
-    @AsyncRunner.run_in_task()
+    @utils.AsyncRunner.run_in_task()
     async def on_att_read_by_type_request(self, connection, request):
         '''
         See Bluetooth spec Vol 3, Part F - 3.4.4.1 Read By Type Request
@@ -770,7 +782,7 @@ class Server(EventEmitter):
 
         self.send_response(connection, response)
 
-    @AsyncRunner.run_in_task()
+    @utils.AsyncRunner.run_in_task()
     async def on_att_read_request(self, connection, request):
         '''
         See Bluetooth spec Vol 3, Part F - 3.4.4.3 Read Request
@@ -796,7 +808,7 @@ class Server(EventEmitter):
             )
         self.send_response(connection, response)
 
-    @AsyncRunner.run_in_task()
+    @utils.AsyncRunner.run_in_task()
     async def on_att_read_blob_request(self, connection, request):
         '''
         See Bluetooth spec Vol 3, Part F - 3.4.4.5 Read Blob Request
@@ -841,7 +853,7 @@ class Server(EventEmitter):
             )
         self.send_response(connection, response)
 
-    @AsyncRunner.run_in_task()
+    @utils.AsyncRunner.run_in_task()
     async def on_att_read_by_group_type_request(self, connection, request):
         '''
         See Bluetooth spec Vol 3, Part F - 3.4.4.9 Read by Group Type Request
@@ -909,7 +921,7 @@ class Server(EventEmitter):
 
         self.send_response(connection, response)
 
-    @AsyncRunner.run_in_task()
+    @utils.AsyncRunner.run_in_task()
     async def on_att_write_request(self, connection, request):
         '''
         See Bluetooth spec Vol 3, Part F - 3.4.5.1 Write Request
@@ -956,7 +968,7 @@ class Server(EventEmitter):
             response = ATT_Write_Response()
         self.send_response(connection, response)
 
-    @AsyncRunner.run_in_task()
+    @utils.AsyncRunner.run_in_task()
     async def on_att_write_command(self, connection, request):
         '''
         See Bluetooth spec Vol 3, Part F - 3.4.5.3 Write Command
diff --git a/bumble/hci.py b/bumble/hci.py
index f79098a..029c2dc 100644
--- a/bumble/hci.py
+++ b/bumble/hci.py
@@ -24,21 +24,22 @@ import logging
 import secrets
 import struct
 from typing import Any, Callable, Dict, Iterable, List, Optional, Type, Union, ClassVar
+from typing_extensions import Self
 
 from bumble import crypto
 from bumble.colors import color
 from bumble.core import (
-    BT_BR_EDR_TRANSPORT,
     AdvertisingData,
     DeviceClass,
     InvalidArgumentError,
     InvalidPacketError,
+    PhysicalTransport,
     ProtocolError,
     bit_flags_to_strings,
     name_or_number,
     padded_bytes,
 )
-from bumble.utils import OpenIntEnum
+from bumble import utils
 
 
 # -----------------------------------------------------------------------------
@@ -94,7 +95,7 @@ def map_class_of_device(class_of_device):
     )
 
 
-def phy_list_to_bits(phys: Optional[Iterable[int]]) -> int:
+def phy_list_to_bits(phys: Optional[Iterable[Phy]]) -> int:
     if phys is None:
         return 0
 
@@ -129,6 +130,7 @@ HCI_VERSION_BLUETOOTH_CORE_5_1     = 10
 HCI_VERSION_BLUETOOTH_CORE_5_2     = 11
 HCI_VERSION_BLUETOOTH_CORE_5_3     = 12
 HCI_VERSION_BLUETOOTH_CORE_5_4     = 13
+HCI_VERSION_BLUETOOTH_CORE_6_0     = 14
 
 HCI_VERSION_NAMES = {
     HCI_VERSION_BLUETOOTH_CORE_1_0B:    'HCI_VERSION_BLUETOOTH_CORE_1_0B',
@@ -145,6 +147,7 @@ HCI_VERSION_NAMES = {
     HCI_VERSION_BLUETOOTH_CORE_5_2:     'HCI_VERSION_BLUETOOTH_CORE_5_2',
     HCI_VERSION_BLUETOOTH_CORE_5_3:     'HCI_VERSION_BLUETOOTH_CORE_5_3',
     HCI_VERSION_BLUETOOTH_CORE_5_4:     'HCI_VERSION_BLUETOOTH_CORE_5_4',
+    HCI_VERSION_BLUETOOTH_CORE_6_0:     'HCI_VERSION_BLUETOOTH_CORE_6_0',
 }
 
 # LMP Version
@@ -221,6 +224,7 @@ HCI_CONNECTIONLESS_PERIPHERAL_BROADCAST_CHANNEL_MAP_CHANGE_EVENT = 0X55
 HCI_INQUIRY_RESPONSE_NOTIFICATION_EVENT                          = 0X56
 HCI_AUTHENTICATED_PAYLOAD_TIMEOUT_EXPIRED_EVENT                  = 0X57
 HCI_SAM_STATUS_CHANGE_EVENT                                      = 0X58
+HCI_ENCRYPTION_CHANGE_V2_EVENT                                   = 0x59
 
 HCI_VENDOR_EVENT = 0xFF
 
@@ -273,7 +277,7 @@ HCI_LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES_COMPLETE_EVENT = 0x2C
 HCI_LE_CS_READ_REMOTE_FAE_TABLE_COMPLETE_EVENT              = 0x2D
 HCI_LE_CS_SECURITY_ENABLE_COMPLETE_EVENT                    = 0x2E
 HCI_LE_CS_CONFIG_COMPLETE_EVENT                             = 0x2F
-HCI_LE_CS_PROCEDURE_ENABLE_EVENT                            = 0x30
+HCI_LE_CS_PROCEDURE_ENABLE_COMPLETE_EVENT                   = 0x30
 HCI_LE_CS_SUBEVENT_RESULT_EVENT                             = 0x31
 HCI_LE_CS_SUBEVENT_RESULT_CONTINUE_EVENT                    = 0x32
 HCI_LE_CS_TEST_END_COMPLETE_EVENT                           = 0x33
@@ -597,7 +601,7 @@ HCI_LE_READ_ALL_LOCAL_SUPPORTED_FEATURES_COMMAND                         = hci_c
 HCI_LE_READ_ALL_REMOTE_FEATURES_COMMAND                                  = hci_command_op_code(0x08, 0x0088)
 HCI_LE_CS_READ_LOCAL_SUPPORTED_CAPABILITIES_COMMAND                      = hci_command_op_code(0x08, 0x0089)
 HCI_LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES_COMMAND                     = hci_command_op_code(0x08, 0x008A)
-HCI_LE_CS_WRITE_CACHED_REMOTE_SUPPORTED_CAPABILITIES                     = hci_command_op_code(0x08, 0x008B)
+HCI_LE_CS_WRITE_CACHED_REMOTE_SUPPORTED_CAPABILITIES_COMMAND             = hci_command_op_code(0x08, 0x008B)
 HCI_LE_CS_SECURITY_ENABLE_COMMAND                                        = hci_command_op_code(0x08, 0x008C)
 HCI_LE_CS_SET_DEFAULT_SETTINGS_COMMAND                                   = hci_command_op_code(0x08, 0x008D)
 HCI_LE_CS_READ_REMOTE_FAE_TABLE_COMMAND                                  = hci_command_op_code(0x08, 0x008E)
@@ -698,30 +702,22 @@ HCI_ERROR_NAMES[HCI_SUCCESS] = 'HCI_SUCCESS'
 HCI_COMMAND_STATUS_PENDING = 0
 
 
+class Phy(enum.IntEnum):
+    LE_1M    = 1
+    LE_2M    = 2
+    LE_CODED = 3
+
+
 # ACL
 HCI_ACL_PB_FIRST_NON_FLUSHABLE = 0
 HCI_ACL_PB_CONTINUATION        = 1
 HCI_ACL_PB_FIRST_FLUSHABLE     = 2
 HCI_ACK_PB_COMPLETE_L2CAP      = 3
 
-# Roles
-HCI_CENTRAL_ROLE    = 0
-HCI_PERIPHERAL_ROLE = 1
-
-HCI_ROLE_NAMES = {
-    HCI_CENTRAL_ROLE:    'CENTRAL',
-    HCI_PERIPHERAL_ROLE: 'PERIPHERAL'
-}
-
-# LE PHY Types
-HCI_LE_1M_PHY    = 1
-HCI_LE_2M_PHY    = 2
-HCI_LE_CODED_PHY = 3
-
-HCI_LE_PHY_NAMES = {
-    HCI_LE_1M_PHY:    'LE 1M',
-    HCI_LE_2M_PHY:    'LE 2M',
-    HCI_LE_CODED_PHY: 'LE Coded'
+HCI_LE_PHY_NAMES: dict[int,str] = {
+    Phy.LE_1M:    'LE 1M',
+    Phy.LE_2M:    'LE 2M',
+    Phy.LE_CODED: 'LE Coded'
 }
 
 HCI_LE_1M_PHY_BIT    = 0
@@ -730,25 +726,93 @@ HCI_LE_CODED_PHY_BIT = 2
 
 HCI_LE_PHY_BIT_NAMES = ['LE_1M_PHY', 'LE_2M_PHY', 'LE_CODED_PHY']
 
-HCI_LE_PHY_TYPE_TO_BIT = {
-    HCI_LE_1M_PHY:    HCI_LE_1M_PHY_BIT,
-    HCI_LE_2M_PHY:    HCI_LE_2M_PHY_BIT,
-    HCI_LE_CODED_PHY: HCI_LE_CODED_PHY_BIT
+HCI_LE_PHY_TYPE_TO_BIT: dict[Phy, int] = {
+    Phy.LE_1M:    HCI_LE_1M_PHY_BIT,
+    Phy.LE_2M:    HCI_LE_2M_PHY_BIT,
+    Phy.LE_CODED: HCI_LE_CODED_PHY_BIT,
 }
 
 
-class Phy(enum.IntEnum):
-    LE_1M    = HCI_LE_1M_PHY
-    LE_2M    = HCI_LE_2M_PHY
-    LE_CODED = HCI_LE_CODED_PHY
-
-
 class PhyBit(enum.IntFlag):
     LE_1M    = 1 << HCI_LE_1M_PHY_BIT
     LE_2M    = 1 << HCI_LE_2M_PHY_BIT
     LE_CODED = 1 << HCI_LE_CODED_PHY_BIT
 
 
+class CsRole(utils.OpenIntEnum):
+    INITIATOR = 0x00
+    REFLECTOR = 0x01
+
+
+class CsRoleMask(enum.IntFlag):
+    INITIATOR = 0x01
+    REFLECTOR = 0x02
+
+
+class CsSyncPhy(utils.OpenIntEnum):
+    LE_1M     = 1
+    LE_2M     = 2
+    LE_2M_2BT = 3
+
+
+class CsSyncPhySupported(enum.IntFlag):
+    LE_2M     = 0x01
+    LE_2M_2BT = 0x02
+
+
+class RttType(utils.OpenIntEnum):
+    AA_ONLY = 0x00
+    SOUNDING_SEQUENCE_32_BIT = 0x01
+    SOUNDING_SEQUENCE_96_BIT = 0x02
+    RANDOM_SEQUENCE_32_BIT = 0x03
+    RANDOM_SEQUENCE_64_BIT = 0x04
+    RANDOM_SEQUENCE_96_BIT = 0x05
+    RANDOM_SEQUENCE_128_BIT = 0x06
+
+
+class CsSnr(utils.OpenIntEnum):
+    SNR_18_DB = 0x00
+    SNR_21_DB = 0x01
+    SNR_24_DB = 0x02
+    SNR_27_DB = 0x03
+    SNR_30_DB = 0x04
+    NOT_APPLIED = 0xFF
+
+
+class CsDoneStatus(utils.OpenIntEnum):
+    ALL_RESULTS_COMPLETED = 0x00
+    PARTIAL = 0x01
+    ABORTED = 0x0F
+
+
+class CsProcedureAbortReason(utils.OpenIntEnum):
+    NO_ABORT = 0x00
+    LOCAL_HOST_OR_REMOTE_REQUEST = 0x01
+    CHANNEL_MAP_UPDATE_INSTANT_PASSED = 0x02
+    UNSPECIFIED = 0x0F
+
+
+class CsSubeventAbortReason(utils.OpenIntEnum):
+    NO_ABORT = 0x00
+    LOCAL_HOST_OR_REMOTE_REQUEST = 0x01
+    NO_CS_SYNC_RECEIVED = 0x02
+    SCHEDULING_CONFLICT_OR_LIMITED_RESOURCES = 0x03
+    UNSPECIFIED = 0x0F
+
+class Role(enum.IntEnum):
+    CENTRAL    = 0
+    PERIPHERAL = 1
+
+# For Backward Compatibility.
+HCI_CENTRAL_ROLE    = Role.CENTRAL
+HCI_PERIPHERAL_ROLE = Role.PERIPHERAL
+
+
+HCI_LE_1M_PHY    = Phy.LE_1M
+HCI_LE_2M_PHY    = Phy.LE_2M
+HCI_LE_CODED_PHY = Phy.LE_CODED
+
+
 # Connection Parameters
 HCI_CONNECTION_INTERVAL_MS_PER_UNIT = 1.25
 HCI_CONNECTION_LATENCY_MS_PER_UNIT  = 1.25
@@ -826,10 +890,15 @@ HCI_LINK_TYPE_NAMES = {
 }
 
 # Address types
-HCI_PUBLIC_DEVICE_ADDRESS_TYPE   = 0x00
-HCI_RANDOM_DEVICE_ADDRESS_TYPE   = 0x01
-HCI_PUBLIC_IDENTITY_ADDRESS_TYPE = 0x02
-HCI_RANDOM_IDENTITY_ADDRESS_TYPE = 0x03
+class AddressType(utils.OpenIntEnum):
+    PUBLIC_DEVICE   = 0x00
+    RANDOM_DEVICE   = 0x01
+    PUBLIC_IDENTITY = 0x02
+    RANDOM_IDENTITY = 0x03
+    # (Directed Only) Address is RPA, but controller cannot resolve.
+    UNABLE_TO_RESOLVE = 0xFE
+    # (Extended Only) No address.
+    ANONYMOUS       = 0xFF
 
 # Supported Commands Masks
 # See Bluetooth spec @ 6.27 SUPPORTED COMMANDS
@@ -915,6 +984,8 @@ HCI_SUPPORTED_COMMANDS_MASKS = {
     HCI_READ_CURRENT_IAC_LAP_COMMAND                                          : 1 << (11*8+3),
     HCI_WRITE_CURRENT_IAC_LAP_COMMAND                                         : 1 << (11*8+4),
     HCI_SET_AFH_HOST_CHANNEL_CLASSIFICATION_COMMAND                           : 1 << (12*8+1),
+    HCI_LE_CS_READ_REMOTE_FAE_TABLE_COMMAND                                   : 1 << (12*8+2),
+    HCI_LE_CS_WRITE_CACHED_REMOTE_FAE_TABLE_COMMAND                           : 1 << (12*8+3),
     HCI_READ_INQUIRY_SCAN_TYPE_COMMAND                                        : 1 << (12*8+4),
     HCI_WRITE_INQUIRY_SCAN_TYPE_COMMAND                                       : 1 << (12*8+5),
     HCI_READ_INQUIRY_MODE_COMMAND                                             : 1 << (12*8+6),
@@ -940,6 +1011,8 @@ HCI_SUPPORTED_COMMANDS_MASKS = {
     HCI_SETUP_SYNCHRONOUS_CONNECTION_COMMAND                                  : 1 << (16*8+3),
     HCI_ACCEPT_SYNCHRONOUS_CONNECTION_REQUEST_COMMAND                         : 1 << (16*8+4),
     HCI_REJECT_SYNCHRONOUS_CONNECTION_REQUEST_COMMAND                         : 1 << (16*8+5),
+    HCI_LE_CS_CREATE_CONFIG_COMMAND                                           : 1 << (16*8+6),
+    HCI_LE_CS_REMOVE_CONFIG_COMMAND                                           : 1 << (16*8+7),
     HCI_READ_EXTENDED_INQUIRY_RESPONSE_COMMAND                                : 1 << (17*8+0),
     HCI_WRITE_EXTENDED_INQUIRY_RESPONSE_COMMAND                               : 1 << (17*8+1),
     HCI_REFRESH_ENCRYPTION_KEY_COMMAND                                        : 1 << (17*8+2),
@@ -963,13 +1036,20 @@ HCI_SUPPORTED_COMMANDS_MASKS = {
     HCI_SEND_KEYPRESS_NOTIFICATION_COMMAND                                    : 1 << (20*8+2),
     HCI_IO_CAPABILITY_REQUEST_NEGATIVE_REPLY_COMMAND                          : 1 << (20*8+3),
     HCI_READ_ENCRYPTION_KEY_SIZE_COMMAND                                      : 1 << (20*8+4),
+    HCI_LE_CS_READ_LOCAL_SUPPORTED_CAPABILITIES_COMMAND                       : 1 << (20*8+5),
+    HCI_LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES_COMMAND                      : 1 << (20*8+6),
+    HCI_LE_CS_WRITE_CACHED_REMOTE_SUPPORTED_CAPABILITIES_COMMAND              : 1 << (20*8+7),
     HCI_SET_EVENT_MASK_PAGE_2_COMMAND                                         : 1 << (22*8+2),
     HCI_READ_FLOW_CONTROL_MODE_COMMAND                                        : 1 << (23*8+0),
     HCI_WRITE_FLOW_CONTROL_MODE_COMMAND                                       : 1 << (23*8+1),
     HCI_READ_DATA_BLOCK_SIZE_COMMAND                                          : 1 << (23*8+2),
+    HCI_LE_CS_TEST_COMMAND                                                    : 1 << (23*8+3),
+    HCI_LE_CS_TEST_END_COMMAND                                                : 1 << (23*8+4),
     HCI_READ_ENHANCED_TRANSMIT_POWER_LEVEL_COMMAND                            : 1 << (24*8+0),
+    HCI_LE_CS_SECURITY_ENABLE_COMMAND                                         : 1 << (24*8+1),
     HCI_READ_LE_HOST_SUPPORT_COMMAND                                          : 1 << (24*8+5),
     HCI_WRITE_LE_HOST_SUPPORT_COMMAND                                         : 1 << (24*8+6),
+    HCI_LE_CS_SET_DEFAULT_SETTINGS_COMMAND                                    : 1 << (24*8+7),
     HCI_LE_SET_EVENT_MASK_COMMAND                                             : 1 << (25*8+0),
     HCI_LE_READ_BUFFER_SIZE_COMMAND                                           : 1 << (25*8+1),
     HCI_LE_READ_LOCAL_SUPPORTED_FEATURES_COMMAND                              : 1 << (25*8+2),
@@ -1000,6 +1080,10 @@ HCI_SUPPORTED_COMMANDS_MASKS = {
     HCI_LE_RECEIVER_TEST_COMMAND                                              : 1 << (28*8+4),
     HCI_LE_TRANSMITTER_TEST_COMMAND                                           : 1 << (28*8+5),
     HCI_LE_TEST_END_COMMAND                                                   : 1 << (28*8+6),
+    HCI_LE_ENABLE_MONITORING_ADVERTISERS_COMMAND                              : 1 << (28*8+7),
+    HCI_LE_CS_SET_CHANNEL_CLASSIFICATION_COMMAND                              : 1 << (29*8+0),
+    HCI_LE_CS_SET_PROCEDURE_PARAMETERS_COMMAND                                : 1 << (29*8+1),
+    HCI_LE_CS_PROCEDURE_ENABLE_COMMAND                                        : 1 << (29*8+2),
     HCI_ENHANCED_SETUP_SYNCHRONOUS_CONNECTION_COMMAND                         : 1 << (29*8+3),
     HCI_ENHANCED_ACCEPT_SYNCHRONOUS_CONNECTION_REQUEST_COMMAND                : 1 << (29*8+4),
     HCI_READ_LOCAL_SUPPORTED_CODECS_COMMAND                                   : 1 << (29*8+5),
@@ -1136,16 +1220,26 @@ HCI_SUPPORTED_COMMANDS_MASKS = {
     HCI_LE_SET_DEFAULT_SUBRATE_COMMAND                                        : 1 << (46*8+0),
     HCI_LE_SUBRATE_REQUEST_COMMAND                                            : 1 << (46*8+1),
     HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V2_COMMAND                     : 1 << (46*8+2),
+    HCI_LE_SET_DECISION_DATA_COMMAND                                          : 1 << (46*8+3),
+    HCI_LE_SET_DECISION_INSTRUCTIONS_COMMAND                                  : 1 << (46*8+4),
     HCI_LE_SET_PERIODIC_ADVERTISING_SUBEVENT_DATA_COMMAND                     : 1 << (46*8+5),
     HCI_LE_SET_PERIODIC_ADVERTISING_RESPONSE_DATA_COMMAND                     : 1 << (46*8+6),
     HCI_LE_SET_PERIODIC_SYNC_SUBEVENT_COMMAND                                 : 1 << (46*8+7),
     HCI_LE_EXTENDED_CREATE_CONNECTION_V2_COMMAND                              : 1 << (47*8+0),
     HCI_LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V2_COMMAND                     : 1 << (47*8+1),
+    HCI_LE_READ_ALL_LOCAL_SUPPORTED_FEATURES_COMMAND                          : 1 << (47*8+2),
+    HCI_LE_READ_ALL_REMOTE_FEATURES_COMMAND                                   : 1 << (47*8+3),
+    HCI_LE_SET_HOST_FEATURE_V2_COMMAND                                        : 1 << (47*8+4),
+    HCI_LE_ADD_DEVICE_TO_MONITORED_ADVERTISERS_LIST_COMMAND                   : 1 << (47*8+5),
+    HCI_LE_REMOVE_DEVICE_FROM_MONITORED_ADVERTISERS_LIST_COMMAND              : 1 << (47*8+6),
+    HCI_LE_CLEAR_MONITORED_ADVERTISERS_LIST_COMMAND                           : 1 << (47*8+7),
+    HCI_LE_READ_MONITORED_ADVERTISERS_LIST_SIZE_COMMAND                       : 1 << (48*8+0),
+    HCI_LE_FRAME_SPACE_UPDATE_COMMAND                                         : 1 << (48*8+1),
 }
 
 # LE Supported Features
 # See Bluetooth spec @ Vol 6, Part B, 4.6 FEATURE SUPPORT
-class LeFeature(OpenIntEnum):
+class LeFeature(utils.OpenIntEnum):
     LE_ENCRYPTION                                  = 0
     CONNECTION_PARAMETERS_REQUEST_PROCEDURE        = 1
     EXTENDED_REJECT_INDICATION                     = 2
@@ -1435,9 +1529,15 @@ class LmpFeatureMask(enum.IntFlag):
 # -----------------------------------------------------------------------------
 # pylint: disable-next=unnecessary-lambda
 STATUS_SPEC = {'size': 1, 'mapper': lambda x: HCI_Constant.status_name(x)}
+CS_ROLE_SPEC = {'size': 1, 'mapper': lambda x: CsRole(x).name}
+CS_ROLE_MASK_SPEC = {'size': 1, 'mapper': lambda x: CsRoleMask(x).name}
+CS_SYNC_PHY_SPEC = {'size': 1, 'mapper': lambda x: CsSyncPhy(x).name}
+CS_SYNC_PHY_SUPPORTED_SPEC = {'size': 1, 'mapper': lambda x: CsSyncPhySupported(x).name}
+RTT_TYPE_SPEC = {'size': 1, 'mapper': lambda x: RttType(x).name}
+CS_SNR_SPEC = {'size': 1, 'mapper': lambda x: CsSnr(x).name}
 
 
-class CodecID(OpenIntEnum):
+class CodecID(utils.OpenIntEnum):
     # fmt: off
     U_LOG           = 0x00
     A_LOG           = 0x01
@@ -1457,7 +1557,7 @@ class CodingFormat:
     vendor_specific_codec_id: int = 0
 
     @classmethod
-    def parse_from_bytes(cls, data: bytes, offset: int):
+    def parse_from_bytes(cls, data: bytes, offset: int) -> tuple[int, CodingFormat]:
         (codec_id, company_id, vendor_specific_codec_id) = struct.unpack_from(
             '<BHH', data, offset
         )
@@ -1467,14 +1567,15 @@ class CodingFormat:
             vendor_specific_codec_id=vendor_specific_codec_id,
         )
 
-    def to_bytes(self) -> bytes:
+    @classmethod
+    def from_bytes(cls, data: bytes) -> CodingFormat:
+        return cls.parse_from_bytes(data, 0)[1]
+
+    def __bytes__(self) -> bytes:
         return struct.pack(
             '<BHH', self.codec_id, self.company_id, self.vendor_specific_codec_id
         )
 
-    def __bytes__(self) -> bytes:
-        return self.to_bytes()
-
 
 # -----------------------------------------------------------------------------
 class HCI_Constant:
@@ -1487,8 +1588,8 @@ class HCI_Constant:
         return HCI_ERROR_NAMES.get(status, f'0x{status:02X}')
 
     @staticmethod
-    def role_name(role):
-        return HCI_ROLE_NAMES.get(role, str(role))
+    def role_name(role: int) -> str:
+        return Role(role).name
 
     @staticmethod
     def le_phy_name(phy):
@@ -1691,7 +1792,7 @@ class HCI_Object:
             field_length = len(field_bytes)
             field_bytes = bytes([field_length]) + field_bytes
         elif isinstance(field_value, (bytes, bytearray)) or hasattr(
-            field_value, 'to_bytes'
+            field_value, '__bytes__'
         ):
             field_bytes = bytes(field_value)
             if isinstance(field_type, int) and 4 < field_type <= 256:
@@ -1736,7 +1837,7 @@ class HCI_Object:
     def from_bytes(cls, data, offset, fields):
         return cls(fields, **cls.dict_from_bytes(data, offset, fields))
 
-    def to_bytes(self):
+    def __bytes__(self):
         return HCI_Object.dict_to_bytes(self.__dict__, self.fields)
 
     @staticmethod
@@ -1831,9 +1932,6 @@ class HCI_Object:
             for field_name, field_value in field_strings
         )
 
-    def __bytes__(self):
-        return self.to_bytes()
-
     def __init__(self, fields, **kwargs):
         self.fields = fields
         self.init_from_fields(self, fields, kwargs)
@@ -1857,17 +1955,10 @@ class Address:
     address[0] is the LSB of the address, address[5] is the MSB.
     '''
 
-    PUBLIC_DEVICE_ADDRESS = 0x00
-    RANDOM_DEVICE_ADDRESS = 0x01
-    PUBLIC_IDENTITY_ADDRESS = 0x02
-    RANDOM_IDENTITY_ADDRESS = 0x03
-
-    ADDRESS_TYPE_NAMES = {
-        PUBLIC_DEVICE_ADDRESS: 'PUBLIC_DEVICE_ADDRESS',
-        RANDOM_DEVICE_ADDRESS: 'RANDOM_DEVICE_ADDRESS',
-        PUBLIC_IDENTITY_ADDRESS: 'PUBLIC_IDENTITY_ADDRESS',
-        RANDOM_IDENTITY_ADDRESS: 'RANDOM_IDENTITY_ADDRESS',
-    }
+    PUBLIC_DEVICE_ADDRESS = AddressType.PUBLIC_DEVICE
+    RANDOM_DEVICE_ADDRESS = AddressType.RANDOM_DEVICE
+    PUBLIC_IDENTITY_ADDRESS = AddressType.PUBLIC_IDENTITY
+    RANDOM_IDENTITY_ADDRESS = AddressType.RANDOM_IDENTITY
 
     # Type declarations
     NIL: Address
@@ -1877,40 +1968,44 @@ class Address:
     # pylint: disable-next=unnecessary-lambda
     ADDRESS_TYPE_SPEC = {'size': 1, 'mapper': lambda x: Address.address_type_name(x)}
 
-    @staticmethod
-    def address_type_name(address_type):
-        return name_or_number(Address.ADDRESS_TYPE_NAMES, address_type)
+    @classmethod
+    def address_type_name(cls: type[Self], address_type: int) -> str:
+        return AddressType(address_type).name
 
-    @staticmethod
-    def from_string_for_transport(string, transport):
-        if transport == BT_BR_EDR_TRANSPORT:
+    @classmethod
+    def from_string_for_transport(
+        cls: type[Self], string: str, transport: PhysicalTransport
+    ) -> Self:
+        if transport == PhysicalTransport.BR_EDR:
             address_type = Address.PUBLIC_DEVICE_ADDRESS
         else:
             address_type = Address.RANDOM_DEVICE_ADDRESS
-        return Address(string, address_type)
+        return cls(string, address_type)
 
-    @staticmethod
-    def parse_address(data, offset):
+    @classmethod
+    def parse_address(cls: type[Self], data: bytes, offset: int) -> tuple[int, Self]:
         # Fix the type to a default value. This is used for parsing type-less Classic
         # addresses
-        return Address.parse_address_with_type(
-            data, offset, Address.PUBLIC_DEVICE_ADDRESS
-        )
+        return cls.parse_address_with_type(data, offset, Address.PUBLIC_DEVICE_ADDRESS)
 
-    @staticmethod
-    def parse_random_address(data, offset):
-        return Address.parse_address_with_type(
-            data, offset, Address.RANDOM_DEVICE_ADDRESS
-        )
+    @classmethod
+    def parse_random_address(
+        cls: type[Self], data: bytes, offset: int
+    ) -> tuple[int, Self]:
+        return cls.parse_address_with_type(data, offset, Address.RANDOM_DEVICE_ADDRESS)
 
-    @staticmethod
-    def parse_address_with_type(data, offset, address_type):
-        return offset + 6, Address(data[offset : offset + 6], address_type)
+    @classmethod
+    def parse_address_with_type(
+        cls: type[Self], data: bytes, offset: int, address_type: AddressType
+    ) -> tuple[int, Self]:
+        return offset + 6, cls(data[offset : offset + 6], address_type)
 
-    @staticmethod
-    def parse_address_preceded_by_type(data, offset):
-        address_type = data[offset - 1]
-        return Address.parse_address_with_type(data, offset, address_type)
+    @classmethod
+    def parse_address_preceded_by_type(
+        cls: type[Self], data: bytes, offset: int
+    ) -> tuple[int, Self]:
+        address_type = AddressType(data[offset - 1])
+        return cls.parse_address_with_type(data, offset, address_type)
 
     @classmethod
     def generate_static_address(cls) -> Address:
@@ -1950,8 +2045,10 @@ class Address:
         )
 
     def __init__(
-        self, address: Union[bytes, str], address_type: int = RANDOM_DEVICE_ADDRESS
-    ):
+        self,
+        address: Union[bytes, str],
+        address_type: AddressType = RANDOM_DEVICE_ADDRESS,
+    ) -> None:
         '''
         Initialize an instance. `address` may be a byte array in little-endian
         format, or a hex string in big-endian format (with optional ':'
@@ -2008,9 +2105,6 @@ class Address:
     def is_static(self):
         return self.is_random and (self.address_bytes[5] >> 6 == 3)
 
-    def to_bytes(self):
-        return self.address_bytes
-
     def to_string(self, with_type_qualifier=True):
         '''
         String representation of the address, MSB first, with an optional type
@@ -2022,7 +2116,7 @@ class Address:
         return result + '/P'
 
     def __bytes__(self):
-        return self.to_bytes()
+        return self.address_bytes
 
     def __hash__(self):
         return hash(self.address_bytes)
@@ -2228,16 +2322,13 @@ class HCI_Command(HCI_Packet):
         self.op_code = op_code
         self.parameters = parameters
 
-    def to_bytes(self):
+    def __bytes__(self):
         parameters = b'' if self.parameters is None else self.parameters
         return (
             struct.pack('<BHB', HCI_COMMAND_PACKET, self.op_code, len(parameters))
             + parameters
         )
 
-    def __bytes__(self):
-        return self.to_bytes()
-
     def __str__(self):
         result = color(self.name, 'green')
         if fields := getattr(self, 'fields', None):
@@ -3273,6 +3364,20 @@ class HCI_Set_Event_Mask_Page_2_Command(HCI_Command):
     See Bluetooth spec @ 7.3.69 Set Event Mask Page 2 Command
     '''
 
+    @staticmethod
+    def mask(event_codes: Iterable[int]) -> bytes:
+        '''
+        Compute the event mask value for a list of events.
+        '''
+        # NOTE: this implementation takes advantage of the fact that as of version 6.0
+        # of the core specification, the bit number for each event code is equal to 64
+        # less than the event code.
+        # If future versions of the specification deviate from that, a different
+        # implementation would be needed.
+        return sum((1 << event_code - 64) for event_code in event_codes).to_bytes(
+            8, 'little'
+        )
+
 
 # -----------------------------------------------------------------------------
 @HCI_Command.command(
@@ -3520,8 +3625,8 @@ class HCI_LE_Set_Event_Mask_Command(HCI_Command):
 @HCI_Command.command(
     return_parameters_fields=[
         ('status', STATUS_SPEC),
-        ('hc_le_acl_data_packet_length', 2),
-        ('hc_total_num_le_acl_data_packets', 1),
+        ('le_acl_data_packet_length', 2),
+        ('total_num_le_acl_data_packets', 1),
     ]
 )
 class HCI_LE_Read_Buffer_Size_Command(HCI_Command):
@@ -3530,6 +3635,22 @@ class HCI_LE_Read_Buffer_Size_Command(HCI_Command):
     '''
 
 
+# -----------------------------------------------------------------------------
+@HCI_Command.command(
+    return_parameters_fields=[
+        ('status', STATUS_SPEC),
+        ('le_acl_data_packet_length', 2),
+        ('total_num_le_acl_data_packets', 1),
+        ('iso_data_packet_length', 2),
+        ('total_num_iso_data_packets', 1),
+    ]
+)
+class HCI_LE_Read_Buffer_Size_V2_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.2 LE Read Buffer Size V2 Command
+    '''
+
+
 # -----------------------------------------------------------------------------
 @HCI_Command.command(
     return_parameters_fields=[('status', STATUS_SPEC), ('le_features', 8)]
@@ -4302,6 +4423,61 @@ class HCI_LE_Clear_Advertising_Sets_Command(HCI_Command):
     '''
 
 
+# -----------------------------------------------------------------------------
+@HCI_Command.command(
+    [
+        ('advertising_handle', 1),
+        ('periodic_advertising_interval_min', 2),
+        ('periodic_advertising_interval_max', 2),
+        ('periodic_advertising_properties', 2),
+    ]
+)
+class HCI_LE_Set_Periodic_Advertising_Parameters_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.61 LE Set Periodic Advertising Parameters command
+    '''
+
+    class Properties(enum.IntFlag):
+        INCLUDE_TX_POWER = 1 << 6
+
+    advertising_handle: int
+    periodic_advertising_interval_min: int
+    periodic_advertising_interval_max: int
+    periodic_advertising_properties: int
+
+
+# -----------------------------------------------------------------------------
+@HCI_Command.command(
+    [
+        ('advertising_handle', 1),
+        (
+            'operation',
+            {
+                'size': 1,
+                'mapper': lambda x: HCI_LE_Set_Extended_Advertising_Data_Command.Operation(
+                    x
+                ).name,
+            },
+        ),
+        (
+            'advertising_data',
+            {
+                'parser': HCI_Object.parse_length_prefixed_bytes,
+                'serializer': HCI_Object.serialize_length_prefixed_bytes,
+            },
+        ),
+    ]
+)
+class HCI_LE_Set_Periodic_Advertising_Data_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.62 LE Set Periodic Advertising Data command
+    '''
+
+    advertising_handle: int
+    operation: int
+    advertising_data: bytes
+
+
 # -----------------------------------------------------------------------------
 @HCI_Command.command([('enable', 1), ('advertising_handle', 1)])
 class HCI_LE_Set_Periodic_Advertising_Enable_Command(HCI_Command):
@@ -4721,6 +4897,76 @@ class HCI_LE_Periodic_Advertising_Sync_Transfer_Command(HCI_Command):
     '''
 
 
+# -----------------------------------------------------------------------------
+@HCI_Command.command(
+    fields=[('connection_handle', 2), ('service_data', 2), ('advertising_handle', 1)],
+    return_parameters_fields=[
+        ('status', STATUS_SPEC),
+        ('connection_handle', 2),
+    ],
+)
+class HCI_LE_Periodic_Advertising_Set_Info_Transfer_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.90 LE Periodic Advertising Set Info Transfer Command
+    '''
+
+
+# -----------------------------------------------------------------------------
+@HCI_Command.command(
+    fields=[
+        ('connection_handle', 2),
+        ('mode', 1),
+        ('skip', 2),
+        ('sync_timeout', 2),
+        (
+            'cte_type',
+            {
+                'size': 1,
+                'mapper': lambda x: HCI_LE_Periodic_Advertising_Report_Event.CteType(
+                    x
+                ).name,
+            },
+        ),
+    ],
+    return_parameters_fields=[
+        ('status', STATUS_SPEC),
+        ('connection_handle', 2),
+    ],
+)
+class HCI_LE_Set_Periodic_Advertising_Sync_Transfer_Parameters_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.91 LE Set Periodic Advertising Sync Transfer Parameters command
+    '''
+
+
+# -----------------------------------------------------------------------------
+@HCI_Command.command(
+    fields=[
+        ('mode', 1),
+        ('skip', 2),
+        ('sync_timeout', 2),
+        (
+            'cte_type',
+            {
+                'size': 1,
+                'mapper': lambda x: HCI_LE_Periodic_Advertising_Report_Event.CteType(
+                    x
+                ).name,
+            },
+        ),
+    ],
+    return_parameters_fields=[
+        ('status', STATUS_SPEC),
+    ],
+)
+class HCI_LE_Set_Default_Periodic_Advertising_Sync_Transfer_Parameters_Command(
+    HCI_Command
+):
+    '''
+    See Bluetooth spec @ 7.8.92 LE Set Default Periodic Advertising Sync Transfer Parameters command
+    '''
+
+
 # -----------------------------------------------------------------------------
 @HCI_Command.command(
     fields=[
@@ -4862,7 +5108,7 @@ class HCI_LE_Create_BIG_Command(HCI_Command):
     packing: int
     framing: int
     encryption: int
-    broadcast_code: int
+    broadcast_code: bytes
 
 
 # -----------------------------------------------------------------------------
@@ -4986,45 +5232,315 @@ class HCI_LE_Set_Host_Feature_Command(HCI_Command):
 
 
 # -----------------------------------------------------------------------------
-# HCI Events
+@HCI_Command.command(
+    return_parameters_fields=[
+        ('status', STATUS_SPEC),
+        ('num_config_supported', 1),
+        ('max_consecutive_procedures_supported', 2),
+        ('num_antennas_supported', 1),
+        ('max_antenna_paths_supported', 1),
+        ('roles_supported', 1),
+        ('modes_supported', 1),
+        ('rtt_capability', 1),
+        ('rtt_aa_only_n', 1),
+        ('rtt_sounding_n', 1),
+        ('rtt_random_payload_n', 1),
+        ('nadm_sounding_capability', 2),
+        ('nadm_random_capability', 2),
+        ('cs_sync_phys_supported', CS_SYNC_PHY_SUPPORTED_SPEC),
+        ('subfeatures_supported', 2),
+        ('t_ip1_times_supported', 2),
+        ('t_ip2_times_supported', 2),
+        ('t_fcs_times_supported', 2),
+        ('t_pm_times_supported', 2),
+        ('t_sw_time_supported', 1),
+        ('tx_snr_capability', CS_SNR_SPEC),
+    ]
+)
+class HCI_LE_CS_Read_Local_Supported_Capabilities_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.130 LE CS Read Local Supported Capabilities command
+    '''
+
+
 # -----------------------------------------------------------------------------
-class HCI_Event(HCI_Packet):
+@HCI_Command.command([('connection_handle', 2)])
+class HCI_LE_CS_Read_Remote_Supported_Capabilities_Command(HCI_Command):
     '''
-    See Bluetooth spec @ Vol 2, Part E - 5.4.4 HCI Event Packet
+    See Bluetooth spec @ 7.8.131 LE CS Read Remote Supported Capabilities command
     '''
 
-    hci_packet_type = HCI_EVENT_PACKET
-    event_names: Dict[int, str] = {}
-    event_classes: Dict[int, Type[HCI_Event]] = {}
 
-    @staticmethod
-    def event(fields=()):
-        '''
-        Decorator used to declare and register subclasses
-        '''
+# -----------------------------------------------------------------------------
+@HCI_Command.command(
+    [
+        ('connection_handle', 2),
+        ('num_config_supported', 1),
+        ('max_consecutive_procedures_supported', 2),
+        ('num_antennas_supported', 1),
+        ('max_antenna_paths_supported', 1),
+        ('roles_supported', 1),
+        ('modes_supported', 1),
+        ('rtt_capability', 1),
+        ('rtt_aa_only_n', 1),
+        ('rtt_sounding_n', 1),
+        ('rtt_random_payload_n', 1),
+        ('nadm_sounding_capability', 2),
+        ('nadm_random_capability', 2),
+        ('cs_sync_phys_supported', CS_SYNC_PHY_SUPPORTED_SPEC),
+        ('subfeatures_supported', 2),
+        ('t_ip1_times_supported', 2),
+        ('t_ip2_times_supported', 2),
+        ('t_fcs_times_supported', 2),
+        ('t_pm_times_supported', 2),
+        ('t_sw_time_supported', 1),
+        ('tx_snr_capability', CS_SNR_SPEC),
+    ],
+    return_parameters_fields=[
+        ('status', STATUS_SPEC),
+        ('connection_handle', 2),
+    ],
+)
+class HCI_LE_CS_Write_Cached_Remote_Supported_Capabilities_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.132 LE CS Write Cached Remote Supported Capabilities command
+    '''
 
-        def inner(cls):
-            cls.name = cls.__name__.upper()
-            cls.event_code = key_with_value(cls.event_names, cls.name)
-            if cls.event_code is None:
-                raise KeyError(f'event {cls.name} not found in event_names')
-            cls.fields = fields
 
-            # Patch the __init__ method to fix the event_code
-            def init(self, parameters=None, **kwargs):
-                return HCI_Event.__init__(self, cls.event_code, parameters, **kwargs)
+# -----------------------------------------------------------------------------
+@HCI_Command.command([('connection_handle', 2)])
+class HCI_LE_CS_Security_Enable_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.133 LE CS Security Enable command
+    '''
 
-            cls.__init__ = init
 
-            # Register a factory for this class
-            HCI_Event.event_classes[cls.event_code] = cls
+# -----------------------------------------------------------------------------
+@HCI_Command.command(
+    [
+        ('connection_handle', 2),
+        (
+            'role_enable',
+            CS_ROLE_MASK_SPEC,
+        ),
+        ('cs_sync_antenna_selection', 1),
+        ('max_tx_power', 1),
+    ],
+    return_parameters_fields=[('status', STATUS_SPEC), ('connection_handle', 2)],
+)
+class HCI_LE_CS_Set_Default_Settings_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.134 LE CS Security Enable command
+    '''
 
-            return cls
 
-        return inner
+# -----------------------------------------------------------------------------
+@HCI_Command.command([('connection_handle', 2)])
+class HCI_LE_CS_Read_Remote_FAE_Table_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.135 LE CS Read Remote FAE Table command
+    '''
 
-    @staticmethod
-    def event_map(symbols: Dict[str, Any]) -> Dict[int, str]:
+
+# -----------------------------------------------------------------------------
+@HCI_Command.command(
+    [
+        ('connection_handle', 2),
+        ('remote_fae_table', 72),
+    ],
+    return_parameters_fields=[('status', STATUS_SPEC), ('connection_handle', 2)],
+)
+class HCI_LE_CS_Write_Cached_Remote_FAE_Table_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.136  LE CS Write Cached Remote FAE Table command
+    '''
+
+
+# -----------------------------------------------------------------------------
+@HCI_Command.command(
+    [
+        ('connection_handle', 2),
+        ('config_id', 1),
+        ('create_context', 1),
+        ('main_mode_type', 1),
+        ('sub_mode_type', 1),
+        ('min_main_mode_steps', 1),
+        ('max_main_mode_steps', 1),
+        ('main_mode_repetition', 1),
+        ('mode_0_steps', 1),
+        ('role', CS_ROLE_SPEC),
+        ('rtt_type', RTT_TYPE_SPEC),
+        ('cs_sync_phy', CS_SYNC_PHY_SPEC),
+        ('channel_map', 10),
+        ('channel_map_repetition', 1),
+        ('channel_selection_type', 1),
+        ('ch3c_shape', 1),
+        ('ch3c_jump', 1),
+        ('reserved', 1),
+    ],
+)
+class HCI_LE_CS_Create_Config_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.137 LE CS Create Config command
+    '''
+
+    class ChannelSelectionType(utils.OpenIntEnum):
+        ALGO_3B = 0
+        ALGO_3C = 1
+
+    class Ch3cShape(utils.OpenIntEnum):
+        HAT = 0x00
+        X = 0x01
+
+
+# -----------------------------------------------------------------------------
+@HCI_Command.command(
+    [
+        ('connection_handle', 2),
+        ('config_id', 1),
+    ],
+)
+class HCI_LE_CS_Remove_Config_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.138 LE CS Remove Config command
+    '''
+
+
+# -----------------------------------------------------------------------------
+@HCI_Command.command(
+    [('channel_classification', 10)], return_parameters_fields=[('status', STATUS_SPEC)]
+)
+class HCI_LE_CS_Set_Channel_Classification_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.139 LE CS Set Channel Classification command
+    '''
+
+
+# -----------------------------------------------------------------------------
+@HCI_Command.command(
+    [
+        ('connection_handle', 2),
+        ('config_id', 1),
+        ('max_procedure_len', 2),
+        ('min_procedure_interval', 2),
+        ('max_procedure_interval', 2),
+        ('max_procedure_count', 2),
+        ('min_subevent_len', 3),
+        ('max_subevent_len', 3),
+        ('tone_antenna_config_selection', 1),
+        ('phy', 1),
+        ('tx_power_delta', 1),
+        ('preferred_peer_antenna', 1),
+        ('snr_control_initiator', CS_SNR_SPEC),
+        ('snr_control_reflector', CS_SNR_SPEC),
+    ],
+    return_parameters_fields=[('status', STATUS_SPEC), ('connection_handle', 2)],
+)
+class HCI_LE_CS_Set_Procedure_Parameters_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.140 LE CS Set Procedure Parameters command
+    '''
+
+
+# -----------------------------------------------------------------------------
+@HCI_Command.command(
+    [
+        ('connection_handle', 2),
+        ('config_id', 1),
+        ('enable', 1),
+    ],
+)
+class HCI_LE_CS_Procedure_Enable_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.141 LE CS Procedure Enable command
+    '''
+
+
+# -----------------------------------------------------------------------------
+@HCI_Command.command(
+    [
+        ('main_mode_type', 1),
+        ('sub_mode_type', 1),
+        ('main_mode_repetition', 1),
+        ('mode_0_steps', 1),
+        ('role', CS_ROLE_SPEC),
+        ('rtt_type', RTT_TYPE_SPEC),
+        ('cs_sync_phy', CS_SYNC_PHY_SPEC),
+        ('cs_sync_antenna_selection', 1),
+        ('subevent_len', 3),
+        ('subevent_interval', 2),
+        ('max_num_subevents', 1),
+        ('transmit_power_level', 1),
+        ('t_ip1_time', 1),
+        ('t_ip2_time', 1),
+        ('t_fcs_time', 1),
+        ('t_pm_time', 1),
+        ('t_sw_time', 1),
+        ('tone_antenna_config_selection', 1),
+        ('reserved', 1),
+        ('snr_control_initiator', CS_SNR_SPEC),
+        ('snr_control_reflector', CS_SNR_SPEC),
+        ('drbg_nonce', 2),
+        ('channel_map_repetition', 1),
+        ('override_config', 2),
+        ('override_parameters_data', 'v'),
+    ],
+)
+class HCI_LE_CS_Test_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.142 LE CS Test command
+    '''
+
+
+# -----------------------------------------------------------------------------
+@HCI_Command.command()
+class HCI_LE_CS_Test_End_Command(HCI_Command):
+    '''
+    See Bluetooth spec @ 7.8.143 LE CS Test End command
+    '''
+
+
+# -----------------------------------------------------------------------------
+# HCI Events
+# -----------------------------------------------------------------------------
+class HCI_Event(HCI_Packet):
+    '''
+    See Bluetooth spec @ Vol 2, Part E - 5.4.4 HCI Event Packet
+    '''
+
+    hci_packet_type = HCI_EVENT_PACKET
+    event_names: Dict[int, str] = {}
+    event_classes: Dict[int, Type[HCI_Event]] = {}
+    vendor_factories: list[Callable[[bytes], Optional[HCI_Event]]] = []
+
+    @staticmethod
+    def event(fields=()):
+        '''
+        Decorator used to declare and register subclasses
+        '''
+
+        def inner(cls):
+            cls.name = cls.__name__.upper()
+            cls.event_code = key_with_value(cls.event_names, cls.name)
+            if cls.event_code is None:
+                raise KeyError(f'event {cls.name} not found in event_names')
+            cls.fields = fields
+
+            # Patch the __init__ method to fix the event_code
+            def init(self, parameters=None, **kwargs):
+                return HCI_Event.__init__(self, cls.event_code, parameters, **kwargs)
+
+            cls.__init__ = init
+
+            # Register a factory for this class
+            HCI_Event.event_classes[cls.event_code] = cls
+
+            return cls
+
+        return inner
+
+    @staticmethod
+    def event_map(symbols: Dict[str, Any]) -> Dict[int, str]:
         return {
             event_code: event_name
             for (event_name, event_code) in symbols.items()
@@ -5053,37 +5569,54 @@ class HCI_Event(HCI_Packet):
 
         return event_class
 
-    @staticmethod
-    def from_bytes(packet: bytes) -> HCI_Event:
+    @classmethod
+    def add_vendor_factory(
+        cls, factory: Callable[[bytes], Optional[HCI_Event]]
+    ) -> None:
+        cls.vendor_factories.append(factory)
+
+    @classmethod
+    def remove_vendor_factory(
+        cls, factory: Callable[[bytes], Optional[HCI_Event]]
+    ) -> None:
+        if factory in cls.vendor_factories:
+            cls.vendor_factories.remove(factory)
+
+    @classmethod
+    def from_bytes(cls, packet: bytes) -> HCI_Event:
         event_code = packet[1]
         length = packet[2]
         parameters = packet[3:]
         if len(parameters) != length:
             raise InvalidPacketError('invalid packet length')
 
-        cls: Any
+        subclass: Any
         if event_code == HCI_LE_META_EVENT:
             # We do this dispatch here and not in the subclass in order to avoid call
             # loops
             subevent_code = parameters[0]
-            cls = HCI_LE_Meta_Event.subevent_classes.get(subevent_code)
-            if cls is None:
+            subclass = HCI_LE_Meta_Event.subevent_classes.get(subevent_code)
+            if subclass is None:
                 # No class registered, just use a generic class instance
                 return HCI_LE_Meta_Event(subevent_code, parameters)
         elif event_code == HCI_VENDOR_EVENT:
-            subevent_code = parameters[0]
-            cls = HCI_Vendor_Event.subevent_classes.get(subevent_code)
-            if cls is None:
-                # No class registered, just use a generic class instance
-                return HCI_Vendor_Event(subevent_code, parameters)
+            # Invoke all the registered factories to see if any of them can handle
+            # the event
+            for vendor_factory in cls.vendor_factories:
+                if event := vendor_factory(parameters):
+                    return event
+
+            # No factory, or the factory could not create an instance,
+            # return a generic vendor event
+            return HCI_Vendor_Event(data=parameters)
         else:
-            cls = HCI_Event.event_classes.get(event_code)
-            if cls is None:
+            subclass = HCI_Event.event_classes.get(event_code)
+            if subclass is None:
                 # No class registered, just use a generic class instance
                 return HCI_Event(event_code, parameters)
 
         # Invoke the factory to create a new instance
-        return cls.from_parameters(parameters)  # type: ignore
+        return subclass.from_parameters(parameters)  # type: ignore
 
     @classmethod
     def from_parameters(cls, parameters):
@@ -5106,13 +5639,10 @@ class HCI_Event(HCI_Packet):
         self.event_code = event_code
         self.parameters = parameters
 
-    def to_bytes(self):
+    def __bytes__(self):
         parameters = b'' if self.parameters is None else self.parameters
         return bytes([HCI_EVENT_PACKET, self.event_code, len(parameters)]) + parameters
 
-    def __bytes__(self):
-        return self.to_bytes()
-
     def __str__(self):
         result = color(self.name, 'magenta')
         if fields := getattr(self, 'fields', None):
@@ -5129,11 +5659,11 @@ HCI_Event.register_events(globals())
 # -----------------------------------------------------------------------------
 class HCI_Extended_Event(HCI_Event):
     '''
-    HCI_Event subclass for events that has a subevent code.
+    HCI_Event subclass for events that have a subevent code.
     '''
 
     subevent_names: Dict[int, str] = {}
-    subevent_classes: Dict[int, Type[HCI_Extended_Event]]
+    subevent_classes: Dict[int, Type[HCI_Extended_Event]] = {}
 
     @classmethod
     def event(cls, fields=()):
@@ -5184,7 +5714,22 @@ class HCI_Extended_Event(HCI_Event):
         cls.subevent_names.update(cls.subevent_map(symbols))
 
     @classmethod
-    def from_parameters(cls, parameters):
+    def subclass_from_parameters(
+        cls, parameters: bytes
+    ) -> Optional[HCI_Extended_Event]:
+        """
+        Factory method that parses the subevent code, finds a registered subclass,
+        and creates an instance if found.
+        """
+        subevent_code = parameters[0]
+        if subclass := cls.subevent_classes.get(subevent_code):
+            return subclass.from_parameters(parameters)
+
+        return None
+
+    @classmethod
+    def from_parameters(cls, parameters: bytes) -> HCI_Extended_Event:
+        """Factory method for subclasses (the subevent code has already been parsed)"""
         self = cls.__new__(cls)
         HCI_Extended_Event.__init__(self, self.subevent_code, parameters)
         if fields := getattr(self, 'fields', None):
@@ -5225,12 +5770,6 @@ class HCI_LE_Meta_Event(HCI_Extended_Event):
 HCI_LE_Meta_Event.register_subevents(globals())
 
 
-# -----------------------------------------------------------------------------
-class HCI_Vendor_Event(HCI_Extended_Event):
-    event_code: int = HCI_VENDOR_EVENT
-    subevent_classes = {}
-
-
 # -----------------------------------------------------------------------------
 @HCI_LE_Meta_Event.event(
     [
@@ -5300,12 +5839,18 @@ class HCI_LE_Advertising_Report_Event(HCI_LE_Meta_Event):
             return HCI_LE_Advertising_Report_Event.event_type_name(self.event_type)
 
         def to_string(self, indentation='', _=None):
+            def data_to_str(data):
+                try:
+                    return data.hex() + ': ' + str(AdvertisingData.from_bytes(data))
+                except Exception:
+                    return data.hex()
+
             return super().to_string(
                 indentation,
                 {
                     'event_type': HCI_LE_Advertising_Report_Event.event_type_name,
                     'address_type': Address.address_type_name,
-                    'data': lambda x: str(AdvertisingData.from_bytes(x)),
+                    'data': data_to_str,
                 },
             )
 
@@ -5440,6 +5985,33 @@ class HCI_LE_Enhanced_Connection_Complete_Event(HCI_LE_Meta_Event):
     '''
 
 
+# -----------------------------------------------------------------------------
+@HCI_LE_Meta_Event.event(
+    [
+        ('status', STATUS_SPEC),
+        ('connection_handle', 2),
+        (
+            'role',
+            {'size': 1, 'mapper': lambda x: 'CENTRAL' if x == 0 else 'PERIPHERAL'},
+        ),
+        ('peer_address_type', Address.ADDRESS_TYPE_SPEC),
+        ('peer_address', Address.parse_address_preceded_by_type),
+        ('local_resolvable_private_address', Address.parse_random_address),
+        ('peer_resolvable_private_address', Address.parse_random_address),
+        ('connection_interval', 2),
+        ('peripheral_latency', 2),
+        ('supervision_timeout', 2),
+        ('central_clock_accuracy', 1),
+        ('advertising_handle', 1),
+        ('sync_handle', 2),
+    ]
+)
+class HCI_LE_Enhanced_Connection_Complete_V2_Event(HCI_LE_Meta_Event):
+    '''
+    See Bluetooth spec @ 7.7.65.10 LE Enhanced Connection Complete Event
+    '''
+
+
 # -----------------------------------------------------------------------------
 @HCI_LE_Meta_Event.event(
     [
@@ -5530,12 +6102,18 @@ class HCI_LE_Extended_Advertising_Report_Event(HCI_LE_Meta_Event):
 
         def to_string(self, indentation='', _=None):
             # pylint: disable=line-too-long
+            def data_to_str(data):
+                try:
+                    return data.hex() + ': ' + str(AdvertisingData.from_bytes(data))
+                except Exception:
+                    return data.hex()
+
             return super().to_string(
                 indentation,
                 {
                     'event_type': HCI_LE_Extended_Advertising_Report_Event.event_type_string,
                     'address_type': Address.address_type_name,
-                    'data': lambda x: str(AdvertisingData.from_bytes(x)),
+                    'data': data_to_str,
                 },
             )
 
@@ -5678,13 +6256,13 @@ class HCI_LE_Periodic_Advertising_Report_Event(HCI_LE_Meta_Event):
     TX_POWER_INFORMATION_NOT_AVAILABLE = 0x7F
     RSSI_NOT_AVAILABLE = 0x7F
 
-    class CteType(OpenIntEnum):
+    class CteType(utils.OpenIntEnum):
         AOA_CONSTANT_TONE_EXTENSION = 0x00
         AOD_CONSTANT_TONE_EXTENSION_1US = 0x01
         AOD_CONSTANT_TONE_EXTENSION_2US = 0x02
         NO_CONSTANT_TONE_EXTENSION = 0xFF
 
-    class DataStatus(OpenIntEnum):
+    class DataStatus(utils.OpenIntEnum):
         DATA_COMPLETE = 0x00
         DATA_INCOMPLETE_MORE_TO_COME = 0x01
         DATA_INCOMPLETE_TRUNCATED_NO_MORE_TO_COME = 0x02
@@ -5740,7 +6318,7 @@ class HCI_LE_Periodic_Advertising_Sync_Lost_Event(HCI_LE_Meta_Event):
 # -----------------------------------------------------------------------------
 @HCI_LE_Meta_Event.event(
     [
-        ('status', 1),
+        ('status', STATUS_SPEC),
         ('advertising_handle', 1),
         ('connection_handle', 2),
         ('num_completed_extended_advertising_events', 1),
@@ -5781,6 +6359,31 @@ class HCI_LE_Periodic_Advertising_Sync_Transfer_Received_Event(HCI_LE_Meta_Event
     '''
 
 
+# -----------------------------------------------------------------------------
+@HCI_LE_Meta_Event.event(
+    [
+        ('status', STATUS_SPEC),
+        ('connection_handle', 2),
+        ('service_data', 2),
+        ('sync_handle', 2),
+        ('advertising_sid', 1),
+        ('advertiser_address_type', Address.ADDRESS_TYPE_SPEC),
+        ('advertiser_address', Address.parse_address_preceded_by_type),
+        ('advertiser_phy', 1),
+        ('periodic_advertising_interval', 2),
+        ('advertiser_clock_accuracy', 1),
+        ('num_subevents', 1),
+        ('subevent_interval', 1),
+        ('response_slot_delay', 1),
+        ('response_slot_spacing', 1),
+    ]
+)
+class HCI_LE_Periodic_Advertising_Sync_Transfer_Received_V2_Event(HCI_LE_Meta_Event):
+    '''
+    See Bluetooth spec @ 7.7.65.24 LE Periodic Advertising Sync Transfer Received Event
+    '''
+
+
 # -----------------------------------------------------------------------------
 @HCI_LE_Meta_Event.event(
     [
@@ -5823,6 +6426,70 @@ class HCI_LE_CIS_Request_Event(HCI_LE_Meta_Event):
     '''
 
 
+# -----------------------------------------------------------------------------
+@HCI_LE_Meta_Event.event(
+    [
+        ('status', STATUS_SPEC),
+        ('big_handle', 1),
+        ('big_sync_delay', 3),
+        ('transport_latency_big', 3),
+        ('phy', 1),
+        ('nse', 1),
+        ('bn', 1),
+        ('pto', 1),
+        ('irc', 1),
+        ('max_pdu', 2),
+        ('iso_interval', 2),
+        [('connection_handle', 2)],
+    ]
+)
+class HCI_LE_Create_BIG_Complete_Event(HCI_LE_Meta_Event):
+    '''
+    See Bluetooth spec @ 7.7.65.27 LE Create BIG Complete Event
+    '''
+
+
+# -----------------------------------------------------------------------------
+@HCI_LE_Meta_Event.event([('big_handle', 1), ('reason', 1)])
+class HCI_LE_Terminate_BIG_Complete_Event(HCI_LE_Meta_Event):
+    '''
+    See Bluetooth spec @ 7.7.65.28 LE Terminate BIG Complete Event
+    '''
+
+
+# -----------------------------------------------------------------------------
+
+
+@HCI_LE_Meta_Event.event(
+    [
+        ('status', STATUS_SPEC),
+        ('big_handle', 1),
+        ('transport_latency_big', 3),
+        ('nse', 1),
+        ('bn', 1),
+        ('pto', 1),
+        ('irc', 1),
+        ('max_pdu', 2),
+        ('iso_interval', 2),
+        [('connection_handle', 2)],
+    ]
+)
+class HCI_LE_BIG_Sync_Established_Event(HCI_LE_Meta_Event):
+    '''
+    See Bluetooth spec @ 7.7.65.29 LE BIG Sync Established event
+    '''
+
+
+# -----------------------------------------------------------------------------
+
+
+@HCI_LE_Meta_Event.event([('big_handle', 1), ('reason', 1)])
+class HCI_LE_BIG_Sync_Lost_Event(HCI_LE_Meta_Event):
+    '''
+    See Bluetooth spec @ 7.7.65.30 LE BIG Sync Lost event
+    '''
+
+
 # -----------------------------------------------------------------------------
 @HCI_LE_Meta_Event.event(
     [
@@ -5847,6 +6514,291 @@ class HCI_LE_BIGInfo_Advertising_Report_Event(HCI_LE_Meta_Event):
     '''
 
 
+# -----------------------------------------------------------------------------
+@HCI_LE_Meta_Event.event(
+    [
+        ('status', STATUS_SPEC),
+        ('connection_handle', 2),
+        ('num_config_supported', 1),
+        ('max_consecutive_procedures_supported', 2),
+        ('num_antennas_supported', 1),
+        ('max_antenna_paths_supported', 1),
+        ('roles_supported', 1),
+        ('modes_supported', 1),
+        ('rtt_capability', 1),
+        ('rtt_aa_only_n', 1),
+        ('rtt_sounding_n', 1),
+        ('rtt_random_payload_n', 1),
+        ('nadm_sounding_capability', 2),
+        ('nadm_random_capability', 2),
+        ('cs_sync_phys_supported', CS_SYNC_PHY_SUPPORTED_SPEC),
+        ('subfeatures_supported', 2),
+        ('t_ip1_times_supported', 2),
+        ('t_ip2_times_supported', 2),
+        ('t_fcs_times_supported', 2),
+        ('t_pm_times_supported', 2),
+        ('t_sw_time_supported', 1),
+        ('tx_snr_capability', CS_SNR_SPEC),
+    ]
+)
+class HCI_LE_CS_Read_Remote_Supported_Capabilities_Complete_Event(HCI_LE_Meta_Event):
+    '''
+    See Bluetooth spec @ 7.7.65.39 LE CS Read Remote Supported Capabilities Complete event
+    '''
+
+    status: int
+    connection_handle: int
+    num_config_supported: int
+    max_consecutive_procedures_supported: int
+    num_antennas_supported: int
+    max_antenna_paths_supported: int
+    roles_supported: int
+    modes_supported: int
+    rtt_capability: int
+    rtt_aa_only_n: int
+    rtt_sounding_n: int
+    rtt_random_payload_n: int
+    nadm_sounding_capability: int
+    nadm_random_capability: int
+    cs_sync_phys_supported: int
+    subfeatures_supported: int
+    t_ip1_times_supported: int
+    t_ip2_times_supported: int
+    t_fcs_times_supported: int
+    t_pm_times_supported: int
+    t_sw_time_supported: int
+    tx_snr_capability: int
+
+
+# -----------------------------------------------------------------------------
+@HCI_LE_Meta_Event.event(
+    [
+        ('status', STATUS_SPEC),
+        ('connection_handle', 2),
+        ('remote_fae_table', 72),
+    ]
+)
+class HCI_LE_CS_Read_Remote_FAE_Table_Complete_Event(HCI_LE_Meta_Event):
+    '''
+    See Bluetooth spec @ 7.7.65.40 LE CS Read Remote FAE Table Complete event
+    '''
+
+    status: int
+    connection_handle: int
+    remote_fae_table: bytes
+
+
+# -----------------------------------------------------------------------------
+@HCI_LE_Meta_Event.event(
+    [
+        ('status', STATUS_SPEC),
+        ('connection_handle', 2),
+    ]
+)
+class HCI_LE_CS_Security_Enable_Complete_Event(HCI_LE_Meta_Event):
+    '''
+    See Bluetooth spec @ 7.7.65.41 LE CS Security Enable Complete event
+    '''
+
+    status: int
+    connection_handle: int
+
+
+# -----------------------------------------------------------------------------
+@HCI_LE_Meta_Event.event(
+    [
+        ('status', STATUS_SPEC),
+        ('connection_handle', 2),
+        ('config_id', 1),
+        (
+            'action',
+            {
+                'size': 1,
+                'mapper': lambda x: HCI_LE_CS_Config_Complete_Event.Action(x).name,
+            },
+        ),
+        ('main_mode_type', 1),
+        ('sub_mode_type', 1),
+        ('min_main_mode_steps', 1),
+        ('max_main_mode_steps', 1),
+        ('main_mode_repetition', 1),
+        ('mode_0_steps', 1),
+        ('role', CS_ROLE_SPEC),
+        ('rtt_type', RTT_TYPE_SPEC),
+        ('cs_sync_phy', CS_SYNC_PHY_SPEC),
+        ('channel_map', 10),
+        ('channel_map_repetition', 1),
+        ('channel_selection_type', 1),
+        ('ch3c_shape', 1),
+        ('ch3c_jump', 1),
+        ('reserved', 1),
+        ('t_ip1_time', 1),
+        ('t_ip2_time', 1),
+        ('t_fcs_time', 1),
+        ('t_pm_time', 1),
+    ]
+)
+class HCI_LE_CS_Config_Complete_Event(HCI_LE_Meta_Event):
+    '''
+    See Bluetooth spec @ 7.7.65.42 LE CS Config Complete event
+    '''
+
+    class Action(utils.OpenIntEnum):
+        REMOVED = 0
+        CREATED = 1
+
+    status: int
+    connection_handle: int
+    config_id: int
+    action: int
+    main_mode_type: int
+    sub_mode_type: int
+    min_main_mode_steps: int
+    max_main_mode_steps: int
+    main_mode_repetition: int
+    mode_0_steps: int
+    role: int
+    rtt_type: int
+    cs_sync_phy: int
+    channel_map: bytes
+    channel_map_repetition: int
+    channel_selection_type: int
+    ch3c_shape: int
+    ch3c_jump: int
+    reserved: int
+    t_ip1_time: int
+    t_ip2_time: int
+    t_fcs_time: int
+    t_pm_time: int
+
+
+# -----------------------------------------------------------------------------
+@HCI_LE_Meta_Event.event(
+    [
+        ('status', STATUS_SPEC),
+        ('connection_handle', 2),
+        ('config_id', 1),
+        ('state', 1),
+        ('tone_antenna_config_selection', 1),
+        ('selected_tx_power', -1),
+        ('subevent_len', 3),
+        ('subevents_per_event', 1),
+        ('subevent_interval', 2),
+        ('event_interval', 2),
+        ('procedure_interval', 2),
+        ('procedure_count', 2),
+        ('max_procedure_len', 2),
+    ]
+)
+class HCI_LE_CS_Procedure_Enable_Complete_Event(HCI_LE_Meta_Event):
+    '''
+    See Bluetooth spec @ 7.7.65.43 LE CS Procedure Enable Complete event
+    '''
+
+    class State(utils.OpenIntEnum):
+        DISABLED = 0
+        ENABLED = 1
+
+    status: int
+    connection_handle: int
+    config_id: int
+    state: int
+    tone_antenna_config_selection: int
+    selected_tx_power: int
+    subevent_len: int
+    subevents_per_event: int
+    subevent_interval: int
+    event_interval: int
+    procedure_interval: int
+    procedure_count: int
+    max_procedure_len: int
+
+
+# -----------------------------------------------------------------------------
+@HCI_LE_Meta_Event.event(
+    [
+        ('connection_handle', 2),
+        ('config_id', 1),
+        ('start_acl_conn_event_counter', 2),
+        ('procedure_counter', 2),
+        ('frequency_compensation', 2),
+        ('reference_power_level', -1),
+        ('procedure_done_status', 1),
+        ('subevent_done_status', 1),
+        ('abort_reason', 1),
+        ('num_antenna_paths', 1),
+        [
+            ('step_mode', 1),
+            ('step_channel', 1),
+            ('step_data', 'v'),
+        ],
+    ]
+)
+class HCI_LE_CS_Subevent_Result_Event(HCI_LE_Meta_Event):
+    '''
+    See Bluetooth spec @ 7.7.65.44 LE CS Subevent Result event
+    '''
+
+    connection_handle: int
+    config_id: int
+    start_acl_conn_event_counter: int
+    procedure_counter: int
+    frequency_compensation: int
+    reference_power_level: int
+    procedure_done_status: int
+    subevent_done_status: int
+    abort_reason: int
+    num_antenna_paths: int
+    step_mode: list[int]
+    step_channel: list[int]
+    step_data: list[bytes]
+
+
+# -----------------------------------------------------------------------------
+@HCI_LE_Meta_Event.event(
+    [
+        ('connection_handle', 2),
+        ('config_id', 1),
+        ('procedure_done_status', 1),
+        ('subevent_done_status', 1),
+        ('abort_reason', 1),
+        ('num_antenna_paths', 1),
+        [
+            ('step_mode', 1),
+            ('step_channel', 1),
+            ('step_data', 'v'),
+        ],
+    ]
+)
+class HCI_LE_CS_Subevent_Result_Continue_Event(HCI_LE_Meta_Event):
+    '''
+    See Bluetooth spec @ 7.7.65.45 LE CS Subevent Result Continue event
+    '''
+
+    connection_handle: int
+    config_id: int
+    procedure_done_status: int
+    subevent_done_status: int
+    abort_reason: int
+    num_antenna_paths: int
+    step_mode: list[int]
+    step_channel: list[int]
+    step_data: list[bytes]
+
+
+# -----------------------------------------------------------------------------
+@HCI_LE_Meta_Event.event(
+    [
+        ('connection_handle', 2),
+        ('status', STATUS_SPEC),
+    ]
+)
+class HCI_LE_CS_Test_End_Complete_Event(HCI_LE_Meta_Event):
+    '''
+    See Bluetooth spec @ 7.7.65.46 LE CS Test End Complete event
+    '''
+
+
 # -----------------------------------------------------------------------------
 @HCI_Event.event([('status', STATUS_SPEC)])
 class HCI_Inquiry_Complete_Event(HCI_Event):
@@ -6039,6 +6991,30 @@ class HCI_Encryption_Change_Event(HCI_Event):
         )
 
 
+# -----------------------------------------------------------------------------
+@HCI_Event.event(
+    [
+        ('status', STATUS_SPEC),
+        ('connection_handle', 2),
+        (
+            'encryption_enabled',
+            {
+                'size': 1,
+                # pylint: disable-next=unnecessary-lambda
+                'mapper': lambda x: HCI_Encryption_Change_Event.encryption_enabled_name(
+                    x
+                ),
+            },
+        ),
+        ('encryption_key_size', 1),
+    ]
+)
+class HCI_Encryption_Change_V2_Event(HCI_Event):
+    '''
+    See Bluetooth spec @ 7.7.8 Encryption Change Event
+    '''
+
+
 # -----------------------------------------------------------------------------
 @HCI_Event.event(
     [('status', STATUS_SPEC), ('connection_handle', 2), ('lmp_features', 8)]
@@ -6065,6 +7041,32 @@ class HCI_Read_Remote_Version_Information_Complete_Event(HCI_Event):
     '''
 
 
+# -----------------------------------------------------------------------------
+@HCI_Event.event(
+    [
+        ('status', STATUS_SPEC),
+        ('connection_handle', 2),
+        ('unused', 1),
+        (
+            'service_type',
+            {
+                'size': 1,
+                'mapper': lambda x: HCI_QOS_Setup_Complete_Event.ServiceType(x).name,
+            },
+        ),
+    ]
+)
+class HCI_QOS_Setup_Complete_Event(HCI_Event):
+    '''
+    See Bluetooth spec @ 7.7.13 QoS Setup Complete Event
+    '''
+
+    class ServiceType(utils.OpenIntEnum):
+        NO_TRAFFIC_AVAILABLE = 0x00
+        BEST_EFFORT_AVAILABLE = 0x01
+        GUARANTEED_AVAILABLE = 0x02
+
+
 # -----------------------------------------------------------------------------
 @HCI_Event.event(
     [
@@ -6078,8 +7080,9 @@ class HCI_Command_Complete_Event(HCI_Event):
     See Bluetooth spec @ 7.7.14 Command Complete Event
     '''
 
-    return_parameters = b''
+    num_hci_command_packets: int
     command_opcode: int
+    return_parameters = b''
 
     def map_return_parameters(self, return_parameters):
         '''Map simple 'status' return parameters to their named constant form'''
@@ -6615,6 +7618,14 @@ class HCI_Remote_Host_Supported_Features_Notification_Event(HCI_Event):
     '''
 
 
+# -----------------------------------------------------------------------------
+@HCI_Event.event([('data', "*")])
+class HCI_Vendor_Event(HCI_Event):
+    '''
+    See Bluetooth spec @ 5.4.4 HCI Event packet
+    '''
+
+
 # -----------------------------------------------------------------------------
 class HCI_AclDataPacket(HCI_Packet):
     '''
@@ -6637,7 +7648,7 @@ class HCI_AclDataPacket(HCI_Packet):
             connection_handle, pb_flag, bc_flag, data_total_length, data
         )
 
-    def to_bytes(self):
+    def __bytes__(self):
         h = (self.pb_flag << 12) | (self.bc_flag << 14) | self.connection_handle
         return (
             struct.pack('<BHH', HCI_ACL_DATA_PACKET, h, self.data_total_length)
@@ -6651,9 +7662,6 @@ class HCI_AclDataPacket(HCI_Packet):
         self.data_total_length = data_total_length
         self.data = data
 
-    def __bytes__(self):
-        return self.to_bytes()
-
     def __str__(self):
         return (
             f'{color("ACL", "blue")}: '
@@ -6687,7 +7695,7 @@ class HCI_SynchronousDataPacket(HCI_Packet):
             connection_handle, packet_status, data_total_length, data
         )
 
-    def to_bytes(self) -> bytes:
+    def __bytes__(self) -> bytes:
         h = (self.packet_status << 12) | self.connection_handle
         return (
             struct.pack('<BHB', HCI_SYNCHRONOUS_DATA_PACKET, h, self.data_total_length)
@@ -6706,9 +7714,6 @@ class HCI_SynchronousDataPacket(HCI_Packet):
         self.data_total_length = data_total_length
         self.data = data
 
-    def __bytes__(self) -> bytes:
-        return self.to_bytes()
-
     def __str__(self) -> str:
         return (
             f'{color("SCO", "blue")}: '
@@ -6764,7 +7769,7 @@ class HCI_IsoDataPacket(HCI_Packet):
         if should_include_sdu_info:
             packet_sequence_number, sdu_info = struct.unpack_from('<HH', packet, pos)
             iso_sdu_length = sdu_info & 0xFFF
-            packet_status_flag = sdu_info >> 14
+            packet_status_flag = (sdu_info >> 15) & 1
             pos += 4
 
         iso_sdu_fragment = packet[pos:]
@@ -6781,9 +7786,6 @@ class HCI_IsoDataPacket(HCI_Packet):
         )
 
     def __bytes__(self) -> bytes:
-        return self.to_bytes()
-
-    def to_bytes(self) -> bytes:
         fmt = '<BHH'
         args = [
             HCI_ISO_DATA_PACKET,
@@ -6801,7 +7803,7 @@ class HCI_IsoDataPacket(HCI_Packet):
             fmt += 'HH'
             args += [
                 self.packet_sequence_number,
-                self.iso_sdu_length | self.packet_status_flag << 14,
+                self.iso_sdu_length | self.packet_status_flag << 15,
             ]
         return struct.pack(fmt, *args) + self.iso_sdu_fragment
 
@@ -6809,9 +7811,10 @@ class HCI_IsoDataPacket(HCI_Packet):
         return (
             f'{color("ISO", "blue")}: '
             f'handle=0x{self.connection_handle:04x}, '
+            f'pb={self.pb_flag}, '
             f'ps={self.packet_status_flag}, '
             f'data_total_length={self.data_total_length}, '
-            f'sdu={self.iso_sdu_fragment.hex()}'
+            f'sdu_fragment={self.iso_sdu_fragment.hex()}'
         )
 
 
diff --git a/bumble/hfp.py b/bumble/hfp.py
index 69dab26..76d622f 100644
--- a/bumble/hfp.py
+++ b/bumble/hfp.py
@@ -24,7 +24,6 @@ import asyncio
 import dataclasses
 import enum
 import traceback
-import pyee
 import re
 from typing import (
     Dict,
@@ -45,6 +44,7 @@ from bumble import at
 from bumble import device
 from bumble import rfcomm
 from bumble import sdp
+from bumble import utils
 from bumble.colors import color
 from bumble.core import (
     ProtocolError,
@@ -141,7 +141,7 @@ class HfFeature(enum.IntFlag):
     """
     HF supported features (AT+BRSF=) (normative).
 
-    Hands-Free Profile v1.8, 4.34.2, AT Capabilities Re-Used from GSM 07.07 and 3GPP 27.007.
+    Hands-Free Profile v1.9, 4.34.2, AT Capabilities Re-Used from GSM 07.07 and 3GPP 27.007.
     """
 
     EC_NR = 0x001  # Echo Cancel & Noise reduction
@@ -155,14 +155,14 @@ class HfFeature(enum.IntFlag):
     HF_INDICATORS = 0x100
     ESCO_S4_SETTINGS_SUPPORTED = 0x200
     ENHANCED_VOICE_RECOGNITION_STATUS = 0x400
-    VOICE_RECOGNITION_TEST = 0x800
+    VOICE_RECOGNITION_TEXT = 0x800
 
 
 class AgFeature(enum.IntFlag):
     """
     AG supported features (+BRSF:) (normative).
 
-    Hands-Free Profile v1.8, 4.34.2, AT Capabilities Re-Used from GSM 07.07 and 3GPP 27.007.
+    Hands-Free Profile v1.9, 4.34.2, AT Capabilities Re-Used from GSM 07.07 and 3GPP 27.007.
     """
 
     THREE_WAY_CALLING = 0x001
@@ -178,7 +178,7 @@ class AgFeature(enum.IntFlag):
     HF_INDICATORS = 0x400
     ESCO_S4_SETTINGS_SUPPORTED = 0x800
     ENHANCED_VOICE_RECOGNITION_STATUS = 0x1000
-    VOICE_RECOGNITION_TEST = 0x2000
+    VOICE_RECOGNITION_TEXT = 0x2000
 
 
 class AudioCodec(enum.IntEnum):
@@ -690,7 +690,7 @@ class HfIndicatorState:
     current_status: int = 0
 
 
-class HfProtocol(pyee.EventEmitter):
+class HfProtocol(utils.EventEmitter):
     """
     Implementation for the Hands-Free side of the Hands-Free profile.
 
@@ -720,6 +720,14 @@ class HfProtocol(pyee.EventEmitter):
                 vrec: VoiceRecognitionState
     """
 
+    EVENT_CODEC_NEGOTIATION = "codec_negotiation"
+    EVENT_AG_INDICATOR = "ag_indicator"
+    EVENT_SPEAKER_VOLUME = "speaker_volume"
+    EVENT_MICROPHONE_VOLUME = "microphone_volume"
+    EVENT_RING = "ring"
+    EVENT_CLI_NOTIFICATION = "cli_notification"
+    EVENT_VOICE_RECOGNITION = "voice_recognition"
+
     class HfLoopTermination(HfpProtocolError):
         """Termination signal for run() loop."""
 
@@ -777,7 +785,8 @@ class HfProtocol(pyee.EventEmitter):
         self.dlc.sink = self._read_at
         # Stop the run() loop when L2CAP is closed.
         self.dlc.multiplexer.l2cap_channel.on(
-            'close', lambda: self.unsolicited_queue.put_nowait(None)
+            self.dlc.multiplexer.l2cap_channel.EVENT_CLOSE,
+            lambda: self.unsolicited_queue.put_nowait(None),
         )
 
     def supports_hf_feature(self, feature: HfFeature) -> bool:
@@ -795,29 +804,32 @@ class HfProtocol(pyee.EventEmitter):
         # Append to the read buffer.
         self.read_buffer.extend(data)
 
-        # Locate header and trailer.
-        header = self.read_buffer.find(b'\r\n')
-        trailer = self.read_buffer.find(b'\r\n', header + 2)
-        if header == -1 or trailer == -1:
-            return
-
-        # Isolate the AT response code and parameters.
-        raw_response = self.read_buffer[header + 2 : trailer]
-        response = AtResponse.parse_from(raw_response)
-        logger.debug(f"<<< {raw_response.decode()}")
-
-        # Consume the response bytes.
-        self.read_buffer = self.read_buffer[trailer + 2 :]
-
-        # Forward the received code to the correct queue.
-        if self.command_lock.locked() and (
-            response.code in STATUS_CODES or response.code in RESPONSE_CODES
-        ):
-            self.response_queue.put_nowait(response)
-        elif response.code in UNSOLICITED_CODES:
-            self.unsolicited_queue.put_nowait(response)
-        else:
-            logger.warning(f"dropping unexpected response with code '{response.code}'")
+        while self.read_buffer:
+            # Locate header and trailer.
+            header = self.read_buffer.find(b'\r\n')
+            trailer = self.read_buffer.find(b'\r\n', header + 2)
+            if header == -1 or trailer == -1:
+                return
+
+            # Isolate the AT response code and parameters.
+            raw_response = self.read_buffer[header + 2 : trailer]
+            response = AtResponse.parse_from(raw_response)
+            logger.debug(f"<<< {raw_response.decode()}")
+
+            # Consume the response bytes.
+            self.read_buffer = self.read_buffer[trailer + 2 :]
+
+            # Forward the received code to the correct queue.
+            if self.command_lock.locked() and (
+                response.code in STATUS_CODES or response.code in RESPONSE_CODES
+            ):
+                self.response_queue.put_nowait(response)
+            elif response.code in UNSOLICITED_CODES:
+                self.unsolicited_queue.put_nowait(response)
+            else:
+                logger.warning(
+                    f"dropping unexpected response with code '{response.code}'"
+                )
 
     async def execute_command(
         self,
@@ -1031,7 +1043,7 @@ class HfProtocol(pyee.EventEmitter):
         # ID. The HF shall be ready to accept the synchronous connection
         # establishment as soon as it has sent the AT commands AT+BCS=<Codec ID>.
         self.active_codec = AudioCodec(codec_id)
-        self.emit('codec_negotiation', self.active_codec)
+        self.emit(self.EVENT_CODEC_NEGOTIATION, self.active_codec)
 
         logger.info("codec connection setup completed")
 
@@ -1092,7 +1104,7 @@ class HfProtocol(pyee.EventEmitter):
         # CIEV is in 1-index, while ag_indicators is in 0-index.
         ag_indicator = self.ag_indicators[index - 1]
         ag_indicator.current_status = value
-        self.emit('ag_indicator', ag_indicator)
+        self.emit(self.EVENT_AG_INDICATOR, ag_indicator)
         logger.info(f"AG indicator updated: {ag_indicator.indicator}, {value}")
 
     async def handle_unsolicited(self):
@@ -1107,19 +1119,21 @@ class HfProtocol(pyee.EventEmitter):
                 int(result.parameters[0]), int(result.parameters[1])
             )
         elif result.code == "+VGS":
-            self.emit('speaker_volume', int(result.parameters[0]))
+            self.emit(self.EVENT_SPEAKER_VOLUME, int(result.parameters[0]))
         elif result.code == "+VGM":
-            self.emit('microphone_volume', int(result.parameters[0]))
+            self.emit(self.EVENT_MICROPHONE_VOLUME, int(result.parameters[0]))
         elif result.code == "RING":
-            self.emit('ring')
+            self.emit(self.EVENT_RING)
         elif result.code == "+CLIP":
             self.emit(
-                'cli_notification', CallLineIdentification.parse_from(result.parameters)
+                self.EVENT_CLI_NOTIFICATION,
+                CallLineIdentification.parse_from(result.parameters),
             )
         elif result.code == "+BVRA":
             # TODO: Support Enhanced Voice Recognition.
             self.emit(
-                'voice_recognition', VoiceRecognitionState(int(result.parameters[0]))
+                self.EVENT_VOICE_RECOGNITION,
+                VoiceRecognitionState(int(result.parameters[0])),
             )
         else:
             logging.info(f"unhandled unsolicited response {result.code}")
@@ -1143,7 +1157,7 @@ class HfProtocol(pyee.EventEmitter):
             logger.error(traceback.format_exc())
 
 
-class AgProtocol(pyee.EventEmitter):
+class AgProtocol(utils.EventEmitter):
     """
     Implementation for the Audio-Gateway side of the Hands-Free profile.
 
@@ -1176,6 +1190,19 @@ class AgProtocol(pyee.EventEmitter):
                 volume: Int
     """
 
+    EVENT_SLC_COMPLETE = "slc_complete"
+    EVENT_SUPPORTED_AUDIO_CODECS = "supported_audio_codecs"
+    EVENT_CODEC_NEGOTIATION = "codec_negotiation"
+    EVENT_VOICE_RECOGNITION = "voice_recognition"
+    EVENT_CALL_HOLD = "call_hold"
+    EVENT_HF_INDICATOR = "hf_indicator"
+    EVENT_CODEC_CONNECTION_REQUEST = "codec_connection_request"
+    EVENT_ANSWER = "answer"
+    EVENT_DIAL = "dial"
+    EVENT_HANG_UP = "hang_up"
+    EVENT_SPEAKER_VOLUME = "speaker_volume"
+    EVENT_MICROPHONE_VOLUME = "microphone_volume"
+
     supported_hf_features: int
     supported_hf_indicators: Set[HfIndicator]
     supported_audio_codecs: List[AudioCodec]
@@ -1244,31 +1271,32 @@ class AgProtocol(pyee.EventEmitter):
         # Append to the read buffer.
         self.read_buffer.extend(data)
 
-        # Locate the trailer.
-        trailer = self.read_buffer.find(b'\r')
-        if trailer == -1:
-            return
-
-        # Isolate the AT response code and parameters.
-        raw_command = self.read_buffer[:trailer]
-        command = AtCommand.parse_from(raw_command)
-        logger.debug(f"<<< {raw_command.decode()}")
-
-        # Consume the response bytes.
-        self.read_buffer = self.read_buffer[trailer + 1 :]
-
-        if command.sub_code == AtCommand.SubCode.TEST:
-            handler_name = f'_on_{command.code.lower()}_test'
-        elif command.sub_code == AtCommand.SubCode.READ:
-            handler_name = f'_on_{command.code.lower()}_read'
-        else:
-            handler_name = f'_on_{command.code.lower()}'
-
-        if handler := getattr(self, handler_name, None):
-            handler(*command.parameters)
-        else:
-            logger.warning('Handler %s not found', handler_name)
-            self.send_response('ERROR')
+        while self.read_buffer:
+            # Locate the trailer.
+            trailer = self.read_buffer.find(b'\r')
+            if trailer == -1:
+                return
+
+            # Isolate the AT response code and parameters.
+            raw_command = self.read_buffer[:trailer]
+            command = AtCommand.parse_from(raw_command)
+            logger.debug(f"<<< {raw_command.decode()}")
+
+            # Consume the response bytes.
+            self.read_buffer = self.read_buffer[trailer + 1 :]
+
+            if command.sub_code == AtCommand.SubCode.TEST:
+                handler_name = f'_on_{command.code.lower()}_test'
+            elif command.sub_code == AtCommand.SubCode.READ:
+                handler_name = f'_on_{command.code.lower()}_read'
+            else:
+                handler_name = f'_on_{command.code.lower()}'
+
+            if handler := getattr(self, handler_name, None):
+                handler(*command.parameters)
+            else:
+                logger.warning('Handler %s not found', handler_name)
+                self.send_response('ERROR')
 
     def send_response(self, response: str) -> None:
         """Sends an AT response."""
@@ -1367,7 +1395,7 @@ class AgProtocol(pyee.EventEmitter):
 
     def _check_remained_slc_commands(self) -> None:
         if not self._remained_slc_setup_features:
-            self.emit('slc_complete')
+            self.emit(self.EVENT_SLC_COMPLETE)
 
     def _on_brsf(self, hf_features: bytes) -> None:
         self.supported_hf_features = int(hf_features)
@@ -1386,16 +1414,17 @@ class AgProtocol(pyee.EventEmitter):
 
     def _on_bac(self, *args) -> None:
         self.supported_audio_codecs = [AudioCodec(int(value)) for value in args]
+        self.emit(self.EVENT_SUPPORTED_AUDIO_CODECS, self.supported_audio_codecs)
         self.send_ok()
 
     def _on_bcs(self, codec: bytes) -> None:
         self.active_codec = AudioCodec(int(codec))
         self.send_ok()
-        self.emit('codec_negotiation', self.active_codec)
+        self.emit(self.EVENT_CODEC_NEGOTIATION, self.active_codec)
 
     def _on_bvra(self, vrec: bytes) -> None:
         self.send_ok()
-        self.emit('voice_recognition', VoiceRecognitionState(int(vrec)))
+        self.emit(self.EVENT_VOICE_RECOGNITION, VoiceRecognitionState(int(vrec)))
 
     def _on_chld(self, operation_code: bytes) -> None:
         call_index: Optional[int] = None
@@ -1422,7 +1451,7 @@ class AgProtocol(pyee.EventEmitter):
         # Real three-way calls have more complicated situations, but this is not a popular issue - let users to handle the remaining :)
 
         self.send_ok()
-        self.emit('call_hold', operation, call_index)
+        self.emit(self.EVENT_CALL_HOLD, operation, call_index)
 
     def _on_chld_test(self) -> None:
         if not self.supports_ag_feature(AgFeature.THREE_WAY_CALLING):
@@ -1548,7 +1577,7 @@ class AgProtocol(pyee.EventEmitter):
             return
 
         self.hf_indicators[index].current_status = int(value_bytes)
-        self.emit('hf_indicator', self.hf_indicators[index])
+        self.emit(self.EVENT_HF_INDICATOR, self.hf_indicators[index])
         self.send_ok()
 
     def _on_bia(self, *args) -> None:
@@ -1557,21 +1586,21 @@ class AgProtocol(pyee.EventEmitter):
         self.send_ok()
 
     def _on_bcc(self) -> None:
-        self.emit('codec_connection_request')
+        self.emit(self.EVENT_CODEC_CONNECTION_REQUEST)
         self.send_ok()
 
     def _on_a(self) -> None:
         """ATA handler."""
-        self.emit('answer')
+        self.emit(self.EVENT_ANSWER)
         self.send_ok()
 
     def _on_d(self, number: bytes) -> None:
         """ATD handler."""
-        self.emit('dial', number.decode())
+        self.emit(self.EVENT_DIAL, number.decode())
         self.send_ok()
 
     def _on_chup(self) -> None:
-        self.emit('hang_up')
+        self.emit(self.EVENT_HANG_UP)
         self.send_ok()
 
     def _on_clcc(self) -> None:
@@ -1597,11 +1626,11 @@ class AgProtocol(pyee.EventEmitter):
         self.send_ok()
 
     def _on_vgs(self, level: bytes) -> None:
-        self.emit('speaker_volume', int(level))
+        self.emit(self.EVENT_SPEAKER_VOLUME, int(level))
         self.send_ok()
 
     def _on_vgm(self, level: bytes) -> None:
-        self.emit('microphone_volume', int(level))
+        self.emit(self.EVENT_MICROPHONE_VOLUME, int(level))
         self.send_ok()
 
 
@@ -1614,7 +1643,7 @@ class ProfileVersion(enum.IntEnum):
     """
     Profile version (normative).
 
-    Hands-Free Profile v1.8, 5.3 SDP Interoperability Requirements.
+    Hands-Free Profile v1.8, 6.3 SDP Interoperability Requirements.
     """
 
     V1_5 = 0x0105
@@ -1628,7 +1657,7 @@ class HfSdpFeature(enum.IntFlag):
     """
     HF supported features (normative).
 
-    Hands-Free Profile v1.8, 5.3 SDP Interoperability Requirements.
+    Hands-Free Profile v1.9, 6.3 SDP Interoperability Requirements.
     """
 
     EC_NR = 0x01  # Echo Cancel & Noise reduction
@@ -1636,16 +1665,17 @@ class HfSdpFeature(enum.IntFlag):
     CLI_PRESENTATION_CAPABILITY = 0x04
     VOICE_RECOGNITION_ACTIVATION = 0x08
     REMOTE_VOLUME_CONTROL = 0x10
-    WIDE_BAND = 0x20  # Wide band speech
+    WIDE_BAND_SPEECH = 0x20
     ENHANCED_VOICE_RECOGNITION_STATUS = 0x40
-    VOICE_RECOGNITION_TEST = 0x80
+    VOICE_RECOGNITION_TEXT = 0x80
+    SUPER_WIDE_BAND = 0x100
 
 
 class AgSdpFeature(enum.IntFlag):
     """
     AG supported features (normative).
 
-    Hands-Free Profile v1.8, 5.3 SDP Interoperability Requirements.
+    Hands-Free Profile v1.9, 6.3 SDP Interoperability Requirements.
     """
 
     THREE_WAY_CALLING = 0x01
@@ -1653,9 +1683,10 @@ class AgSdpFeature(enum.IntFlag):
     VOICE_RECOGNITION_FUNCTION = 0x04
     IN_BAND_RING_TONE_CAPABILITY = 0x08
     VOICE_TAG = 0x10  # Attach a number to voice tag
-    WIDE_BAND = 0x20  # Wide band speech
+    WIDE_BAND_SPEECH = 0x20
     ENHANCED_VOICE_RECOGNITION_STATUS = 0x40
-    VOICE_RECOGNITION_TEST = 0x80
+    VOICE_RECOGNITION_TEXT = 0x80
+    SUPER_WIDE_BAND_SPEED_SPEECH = 0x100
 
 
 def make_hf_sdp_records(
@@ -1688,11 +1719,11 @@ def make_hf_sdp_records(
         in configuration.supported_hf_features
     ):
         hf_supported_features |= HfSdpFeature.ENHANCED_VOICE_RECOGNITION_STATUS
-    if HfFeature.VOICE_RECOGNITION_TEST in configuration.supported_hf_features:
-        hf_supported_features |= HfSdpFeature.VOICE_RECOGNITION_TEST
+    if HfFeature.VOICE_RECOGNITION_TEXT in configuration.supported_hf_features:
+        hf_supported_features |= HfSdpFeature.VOICE_RECOGNITION_TEXT
 
     if AudioCodec.MSBC in configuration.supported_audio_codecs:
-        hf_supported_features |= HfSdpFeature.WIDE_BAND
+        hf_supported_features |= HfSdpFeature.WIDE_BAND_SPEECH
 
     return [
         sdp.ServiceAttribute(
@@ -1768,14 +1799,14 @@ def make_ag_sdp_records(
         in configuration.supported_ag_features
     ):
         ag_supported_features |= AgSdpFeature.ENHANCED_VOICE_RECOGNITION_STATUS
-    if AgFeature.VOICE_RECOGNITION_TEST in configuration.supported_ag_features:
-        ag_supported_features |= AgSdpFeature.VOICE_RECOGNITION_TEST
+    if AgFeature.VOICE_RECOGNITION_TEXT in configuration.supported_ag_features:
+        ag_supported_features |= AgSdpFeature.VOICE_RECOGNITION_TEXT
     if AgFeature.IN_BAND_RING_TONE_CAPABILITY in configuration.supported_ag_features:
         ag_supported_features |= AgSdpFeature.IN_BAND_RING_TONE_CAPABILITY
     if AgFeature.VOICE_RECOGNITION_FUNCTION in configuration.supported_ag_features:
         ag_supported_features |= AgSdpFeature.VOICE_RECOGNITION_FUNCTION
     if AudioCodec.MSBC in configuration.supported_audio_codecs:
-        ag_supported_features |= AgSdpFeature.WIDE_BAND
+        ag_supported_features |= AgSdpFeature.WIDE_BAND_SPEECH
 
     return [
         sdp.ServiceAttribute(
diff --git a/bumble/hid.py b/bumble/hid.py
index d4a2a72..edcfc98 100644
--- a/bumble/hid.py
+++ b/bumble/hid.py
@@ -22,11 +22,12 @@ import enum
 import struct
 
 from abc import ABC, abstractmethod
-from pyee import EventEmitter
 from typing import Optional, Callable
 from typing_extensions import override
 
-from bumble import l2cap, device
+from bumble import l2cap
+from bumble import device
+from bumble import utils
 from bumble.core import InvalidStateError, ProtocolError
 from bumble.hci import Address
 
@@ -195,11 +196,18 @@ class SendHandshakeMessage(Message):
 
 
 # -----------------------------------------------------------------------------
-class HID(ABC, EventEmitter):
+class HID(ABC, utils.EventEmitter):
     l2cap_ctrl_channel: Optional[l2cap.ClassicChannel] = None
     l2cap_intr_channel: Optional[l2cap.ClassicChannel] = None
     connection: Optional[device.Connection] = None
 
+    EVENT_INTERRUPT_DATA = "interrupt_data"
+    EVENT_CONTROL_DATA = "control_data"
+    EVENT_SUSPEND = "suspend"
+    EVENT_EXIT_SUSPEND = "exit_suspend"
+    EVENT_VIRTUAL_CABLE_UNPLUG = "virtual_cable_unplug"
+    EVENT_HANDSHAKE = "handshake"
+
     class Role(enum.IntEnum):
         HOST = 0x00
         DEVICE = 0x01
@@ -214,7 +222,7 @@ class HID(ABC, EventEmitter):
         device.register_l2cap_server(HID_CONTROL_PSM, self.on_l2cap_connection)
         device.register_l2cap_server(HID_INTERRUPT_PSM, self.on_l2cap_connection)
 
-        device.on('connection', self.on_device_connection)
+        device.on(device.EVENT_CONNECTION, self.on_device_connection)
 
     async def connect_control_channel(self) -> None:
         # Create a new L2CAP connection - control channel
@@ -257,15 +265,20 @@ class HID(ABC, EventEmitter):
     def on_device_connection(self, connection: device.Connection) -> None:
         self.connection = connection
         self.remote_device_bd_address = connection.peer_address
-        connection.on('disconnection', self.on_device_disconnection)
+        connection.on(connection.EVENT_DISCONNECTION, self.on_device_disconnection)
 
     def on_device_disconnection(self, reason: int) -> None:
         self.connection = None
 
     def on_l2cap_connection(self, l2cap_channel: l2cap.ClassicChannel) -> None:
         logger.debug(f'+++ New L2CAP connection: {l2cap_channel}')
-        l2cap_channel.on('open', lambda: self.on_l2cap_channel_open(l2cap_channel))
-        l2cap_channel.on('close', lambda: self.on_l2cap_channel_close(l2cap_channel))
+        l2cap_channel.on(
+            l2cap_channel.EVENT_OPEN, lambda: self.on_l2cap_channel_open(l2cap_channel)
+        )
+        l2cap_channel.on(
+            l2cap_channel.EVENT_CLOSE,
+            lambda: self.on_l2cap_channel_close(l2cap_channel),
+        )
 
     def on_l2cap_channel_open(self, l2cap_channel: l2cap.ClassicChannel) -> None:
         if l2cap_channel.psm == HID_CONTROL_PSM:
@@ -289,7 +302,7 @@ class HID(ABC, EventEmitter):
 
     def on_intr_pdu(self, pdu: bytes) -> None:
         logger.debug(f'<<< HID INTERRUPT PDU: {pdu.hex()}')
-        self.emit("interrupt_data", pdu)
+        self.emit(self.EVENT_INTERRUPT_DATA, pdu)
 
     def send_pdu_on_ctrl(self, msg: bytes) -> None:
         assert self.l2cap_ctrl_channel
@@ -362,17 +375,17 @@ class Device(HID):
             self.handle_set_protocol(pdu)
         elif message_type == Message.MessageType.DATA:
             logger.debug('<<< HID CONTROL DATA')
-            self.emit('control_data', pdu)
+            self.emit(self.EVENT_CONTROL_DATA, pdu)
         elif message_type == Message.MessageType.CONTROL:
             if param == Message.ControlCommand.SUSPEND:
                 logger.debug('<<< HID SUSPEND')
-                self.emit('suspend')
+                self.emit(self.EVENT_SUSPEND)
             elif param == Message.ControlCommand.EXIT_SUSPEND:
                 logger.debug('<<< HID EXIT SUSPEND')
-                self.emit('exit_suspend')
+                self.emit(self.EVENT_EXIT_SUSPEND)
             elif param == Message.ControlCommand.VIRTUAL_CABLE_UNPLUG:
                 logger.debug('<<< HID VIRTUAL CABLE UNPLUG')
-                self.emit('virtual_cable_unplug')
+                self.emit(self.EVENT_VIRTUAL_CABLE_UNPLUG)
             else:
                 logger.debug('<<< HID CONTROL OPERATION UNSUPPORTED')
         else:
@@ -537,14 +550,14 @@ class Host(HID):
         message_type = pdu[0] >> 4
         if message_type == Message.MessageType.HANDSHAKE:
             logger.debug(f'<<< HID HANDSHAKE: {Message.Handshake(param).name}')
-            self.emit('handshake', Message.Handshake(param))
+            self.emit(self.EVENT_HANDSHAKE, Message.Handshake(param))
         elif message_type == Message.MessageType.DATA:
             logger.debug('<<< HID CONTROL DATA')
-            self.emit('control_data', pdu)
+            self.emit(self.EVENT_CONTROL_DATA, pdu)
         elif message_type == Message.MessageType.CONTROL:
             if param == Message.ControlCommand.VIRTUAL_CABLE_UNPLUG:
                 logger.debug('<<< HID VIRTUAL CABLE UNPLUG')
-                self.emit('virtual_cable_unplug')
+                self.emit(self.EVENT_VIRTUAL_CABLE_UNPLUG)
             else:
                 logger.debug('<<< HID CONTROL OPERATION UNSUPPORTED')
         else:
diff --git a/bumble/host.py b/bumble/host.py
index a3d3dad..755732a 100644
--- a/bumble/host.py
+++ b/bumble/host.py
@@ -1,4 +1,4 @@
-# Copyright 2021-2022 Google LLC
+# Copyright 2021-2025 Google LLC
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -34,22 +34,23 @@ from typing import (
     TYPE_CHECKING,
 )
 
+
 from bumble.colors import color
 from bumble.l2cap import L2CAP_PDU
 from bumble.snoop import Snooper
 from bumble import drivers
 from bumble import hci
 from bumble.core import (
-    BT_BR_EDR_TRANSPORT,
-    BT_LE_TRANSPORT,
+    PhysicalTransport,
+    PhysicalTransport,
     ConnectionPHY,
     ConnectionParameters,
 )
-from bumble.utils import AbortableEventEmitter
+from bumble import utils
 from bumble.transport.common import TransportLostError
 
 if TYPE_CHECKING:
-    from .transport.common import TransportSink, TransportSource
+    from bumble.transport.common import TransportSink, TransportSource
 
 
 # -----------------------------------------------------------------------------
@@ -59,7 +60,19 @@ logger = logging.getLogger(__name__)
 
 
 # -----------------------------------------------------------------------------
-class AclPacketQueue:
+class DataPacketQueue(utils.EventEmitter):
+    """
+    Flow-control queue for host->controller data packets (ACL, ISO).
+
+    The queue holds packets associated with a connection handle. The packets
+    are sent to the controller, up to a maximum total number of packets in flight.
+    A packet is considered to be "in flight" when it has been sent to the controller
+    but not completed yet. Packets are no longer "in flight" when the controller
+    declares them as completed.
+
+    The queue emits a 'flow' event whenever one or more packets are completed.
+    """
+
     max_packet_size: int
 
     def __init__(
@@ -68,55 +81,124 @@ class AclPacketQueue:
         max_in_flight: int,
         send: Callable[[hci.HCI_Packet], None],
     ) -> None:
+        super().__init__()
         self.max_packet_size = max_packet_size
         self.max_in_flight = max_in_flight
-        self.in_flight = 0
-        self.send = send
-        self.packets: Deque[hci.HCI_AclDataPacket] = collections.deque()
+        self._in_flight = 0  # Total number of packets in flight across all connections
+        self._in_flight_per_connection: dict[int, int] = collections.defaultdict(
+            int
+        )  # Number of packets in flight per connection
+        self._send = send
+        self._packets: Deque[tuple[hci.HCI_Packet, int]] = collections.deque()
+        self._queued = 0
+        self._completed = 0
 
-    def enqueue(self, packet: hci.HCI_AclDataPacket) -> None:
-        self.packets.appendleft(packet)
-        self.check_queue()
+    @property
+    def queued(self) -> int:
+        """Total number of packets queued since creation."""
+        return self._queued
+
+    @property
+    def completed(self) -> int:
+        """Total number of packets completed since creation."""
+        return self._completed
+
+    @property
+    def pending(self) -> int:
+        """Number of packets that have been queued but not completed."""
+        return self._queued - self._completed
 
-        if self.packets:
+    def enqueue(self, packet: hci.HCI_Packet, connection_handle: int) -> None:
+        """Enqueue a packet associated with a connection"""
+        self._packets.appendleft((packet, connection_handle))
+        self._queued += 1
+        self._check_queue()
+
+        if self._packets:
             logger.debug(
-                f'{self.in_flight} ACL packets in flight, '
-                f'{len(self.packets)} in queue'
+                f'{self._in_flight} packets in flight, '
+                f'{len(self._packets)} in queue'
             )
 
-    def check_queue(self) -> None:
-        while self.packets and self.in_flight < self.max_in_flight:
-            packet = self.packets.pop()
-            self.send(packet)
-            self.in_flight += 1
+    def flush(self, connection_handle: int) -> None:
+        """
+        Remove all packets associated with a connection.
+
+        All packets associated with the connection that are in flight are implicitly
+        marked as completed, but no 'flow' event is emitted.
+        """
 
-    def on_packets_completed(self, packet_count: int) -> None:
-        if packet_count > self.in_flight:
+        packets_to_keep = [
+            (packet, handle)
+            for (packet, handle) in self._packets
+            if handle != connection_handle
+        ]
+        if flushed_count := len(self._packets) - len(packets_to_keep):
+            self._completed += flushed_count
+            self._packets = collections.deque(packets_to_keep)
+
+        if connection_handle in self._in_flight_per_connection:
+            in_flight = self._in_flight_per_connection[connection_handle]
+            self._completed += in_flight
+            self._in_flight -= in_flight
+            del self._in_flight_per_connection[connection_handle]
+
+    def _check_queue(self) -> None:
+        while self._packets and self._in_flight < self.max_in_flight:
+            packet, connection_handle = self._packets.pop()
+            self._send(packet)
+            self._in_flight += 1
+            self._in_flight_per_connection[connection_handle] += 1
+
+    def on_packets_completed(self, packet_count: int, connection_handle: int) -> None:
+        """Mark one or more packets associated with a connection as completed."""
+        if connection_handle not in self._in_flight_per_connection:
             logger.warning(
-                color(
-                    '!!! {packet_count} completed but only '
-                    f'{self.in_flight} in flight'
-                )
+                f'received completion for unknown connection {connection_handle}'
             )
-            packet_count = self.in_flight
+            return
 
-        self.in_flight -= packet_count
-        self.check_queue()
+        in_flight_for_connection = self._in_flight_per_connection[connection_handle]
+        if packet_count <= in_flight_for_connection:
+            self._in_flight_per_connection[connection_handle] -= packet_count
+        else:
+            logger.warning(
+                f'{packet_count} completed for {connection_handle} '
+                f'but only {in_flight_for_connection} in flight'
+            )
+            self._in_flight_per_connection[connection_handle] = 0
+
+        if packet_count <= self._in_flight:
+            self._in_flight -= packet_count
+            self._completed += packet_count
+        else:
+            logger.warning(
+                f'{packet_count} completed but only {self._in_flight} in flight'
+            )
+            self._in_flight = 0
+            self._completed = self._queued
+
+        self._check_queue()
+        self.emit('flow')
 
 
 # -----------------------------------------------------------------------------
 class Connection:
     def __init__(
-        self, host: Host, handle: int, peer_address: hci.Address, transport: int
+        self,
+        host: Host,
+        handle: int,
+        peer_address: hci.Address,
+        transport: PhysicalTransport,
     ):
         self.host = host
         self.handle = handle
         self.peer_address = peer_address
         self.assembler = hci.HCI_AclDataPacketAssembler(self.on_acl_pdu)
         self.transport = transport
-        acl_packet_queue: Optional[AclPacketQueue] = (
+        acl_packet_queue: Optional[DataPacketQueue] = (
             host.le_acl_packet_queue
-            if transport == BT_LE_TRANSPORT
+            if transport == PhysicalTransport.LE
             else host.acl_packet_queue
         )
         assert acl_packet_queue
@@ -129,28 +211,37 @@ class Connection:
         l2cap_pdu = L2CAP_PDU.from_bytes(pdu)
         self.host.on_l2cap_pdu(self, l2cap_pdu.cid, l2cap_pdu.payload)
 
+    def __str__(self) -> str:
+        return (
+            f'Connection(transport={self.transport}, peer_address={self.peer_address})'
+        )
+
 
 # -----------------------------------------------------------------------------
 @dataclasses.dataclass
 class ScoLink:
     peer_address: hci.Address
-    handle: int
+    connection_handle: int
 
 
 # -----------------------------------------------------------------------------
 @dataclasses.dataclass
-class CisLink:
-    peer_address: hci.Address
+class IsoLink:
     handle: int
+    packet_queue: DataPacketQueue = dataclasses.field(repr=False)
+    packet_sequence_number: int = 0
 
 
 # -----------------------------------------------------------------------------
-class Host(AbortableEventEmitter):
+class Host(utils.EventEmitter):
     connections: Dict[int, Connection]
-    cis_links: Dict[int, CisLink]
+    cis_links: Dict[int, IsoLink]
+    bis_links: Dict[int, IsoLink]
     sco_links: Dict[int, ScoLink]
-    acl_packet_queue: Optional[AclPacketQueue] = None
-    le_acl_packet_queue: Optional[AclPacketQueue] = None
+    bigs: dict[int, set[int]]
+    acl_packet_queue: Optional[DataPacketQueue] = None
+    le_acl_packet_queue: Optional[DataPacketQueue] = None
+    iso_packet_queue: Optional[DataPacketQueue] = None
     hci_sink: Optional[TransportSink] = None
     hci_metadata: Dict[str, Any]
     long_term_key_provider: Optional[
@@ -169,7 +260,9 @@ class Host(AbortableEventEmitter):
         self.ready = False  # True when we can accept incoming packets
         self.connections = {}  # Connections, by connection handle
         self.cis_links = {}  # CIS links, by connection handle
+        self.bis_links = {}  # BIS links, by connection handle
         self.sco_links = {}  # SCO links, by connection handle
+        self.bigs = {}  # BIG Handle to BIS Handles
         self.pending_command = None
         self.pending_response: Optional[asyncio.Future[Any]] = None
         self.number_of_supported_advertising_sets = 0
@@ -199,7 +292,7 @@ class Host(AbortableEventEmitter):
         check_address_type: bool = False,
     ) -> Optional[Connection]:
         for connection in self.connections.values():
-            if connection.peer_address.to_bytes() == bd_addr.to_bytes():
+            if bytes(connection.peer_address) == bytes(bd_addr):
                 if (
                     check_address_type
                     and connection.peer_address.address_type != bd_addr.address_type
@@ -342,6 +435,14 @@ class Host(AbortableEventEmitter):
                 )
             )
         )
+        if self.supports_command(hci.HCI_SET_EVENT_MASK_PAGE_2_COMMAND):
+            await self.send_command(
+                hci.HCI_Set_Event_Mask_Page_2_Command(
+                    event_mask_page_2=hci.HCI_Set_Event_Mask_Page_2_Command.mask(
+                        [hci.HCI_ENCRYPTION_CHANGE_V2_EVENT]
+                    )
+                )
+            )
 
         if (
             self.local_version is not None
@@ -363,6 +464,7 @@ class Host(AbortableEventEmitter):
                     hci.HCI_LE_READ_LOCAL_P_256_PUBLIC_KEY_COMPLETE_EVENT,
                     hci.HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT,
                     hci.HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT,
+                    hci.HCI_LE_ENHANCED_CONNECTION_COMPLETE_V2_EVENT,
                     hci.HCI_LE_DIRECTED_ADVERTISING_REPORT_EVENT,
                     hci.HCI_LE_PHY_UPDATE_COMPLETE_EVENT,
                     hci.HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT,
@@ -387,6 +489,12 @@ class Host(AbortableEventEmitter):
                     hci.HCI_LE_TRANSMIT_POWER_REPORTING_EVENT,
                     hci.HCI_LE_BIGINFO_ADVERTISING_REPORT_EVENT,
                     hci.HCI_LE_SUBRATE_CHANGE_EVENT,
+                    hci.HCI_LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES_COMPLETE_EVENT,
+                    hci.HCI_LE_CS_PROCEDURE_ENABLE_COMPLETE_EVENT,
+                    hci.HCI_LE_CS_SECURITY_ENABLE_COMPLETE_EVENT,
+                    hci.HCI_LE_CS_CONFIG_COMPLETE_EVENT,
+                    hci.HCI_LE_CS_SUBEVENT_RESULT_EVENT,
+                    hci.HCI_LE_CS_SUBEVENT_RESULT_CONTINUE_EVENT,
                 ]
             )
 
@@ -411,39 +519,70 @@ class Host(AbortableEventEmitter):
                 f'hc_total_num_acl_data_packets={hc_total_num_acl_data_packets}'
             )
 
-            self.acl_packet_queue = AclPacketQueue(
+            self.acl_packet_queue = DataPacketQueue(
                 max_packet_size=hc_acl_data_packet_length,
                 max_in_flight=hc_total_num_acl_data_packets,
                 send=self.send_hci_packet,
             )
 
-        hc_le_acl_data_packet_length = 0
-        hc_total_num_le_acl_data_packets = 0
-        if self.supports_command(hci.HCI_LE_READ_BUFFER_SIZE_COMMAND):
+        le_acl_data_packet_length = 0
+        total_num_le_acl_data_packets = 0
+        iso_data_packet_length = 0
+        total_num_iso_data_packets = 0
+        if self.supports_command(hci.HCI_LE_READ_BUFFER_SIZE_V2_COMMAND):
+            response = await self.send_command(
+                hci.HCI_LE_Read_Buffer_Size_V2_Command(), check_result=True
+            )
+            le_acl_data_packet_length = (
+                response.return_parameters.le_acl_data_packet_length
+            )
+            total_num_le_acl_data_packets = (
+                response.return_parameters.total_num_le_acl_data_packets
+            )
+            iso_data_packet_length = response.return_parameters.iso_data_packet_length
+            total_num_iso_data_packets = (
+                response.return_parameters.total_num_iso_data_packets
+            )
+
+            logger.debug(
+                'HCI LE flow control: '
+                f'le_acl_data_packet_length={le_acl_data_packet_length},'
+                f'total_num_le_acl_data_packets={total_num_le_acl_data_packets}'
+                f'iso_data_packet_length={iso_data_packet_length},'
+                f'total_num_iso_data_packets={total_num_iso_data_packets}'
+            )
+        elif self.supports_command(hci.HCI_LE_READ_BUFFER_SIZE_COMMAND):
             response = await self.send_command(
                 hci.HCI_LE_Read_Buffer_Size_Command(), check_result=True
             )
-            hc_le_acl_data_packet_length = (
-                response.return_parameters.hc_le_acl_data_packet_length
+            le_acl_data_packet_length = (
+                response.return_parameters.le_acl_data_packet_length
             )
-            hc_total_num_le_acl_data_packets = (
-                response.return_parameters.hc_total_num_le_acl_data_packets
+            total_num_le_acl_data_packets = (
+                response.return_parameters.total_num_le_acl_data_packets
             )
 
             logger.debug(
                 'HCI LE ACL flow control: '
-                f'hc_le_acl_data_packet_length={hc_le_acl_data_packet_length},'
-                f'hc_total_num_le_acl_data_packets={hc_total_num_le_acl_data_packets}'
+                f'le_acl_data_packet_length={le_acl_data_packet_length},'
+                f'total_num_le_acl_data_packets={total_num_le_acl_data_packets}'
             )
 
-        if hc_le_acl_data_packet_length == 0 or hc_total_num_le_acl_data_packets == 0:
+        if le_acl_data_packet_length == 0 or total_num_le_acl_data_packets == 0:
             # LE and Classic share the same queue
             self.le_acl_packet_queue = self.acl_packet_queue
         else:
             # Create a separate queue for LE
-            self.le_acl_packet_queue = AclPacketQueue(
-                max_packet_size=hc_le_acl_data_packet_length,
-                max_in_flight=hc_total_num_le_acl_data_packets,
+            self.le_acl_packet_queue = DataPacketQueue(
+                max_packet_size=le_acl_data_packet_length,
+                max_in_flight=total_num_le_acl_data_packets,
+                send=self.send_hci_packet,
+            )
+
+        if iso_data_packet_length and total_num_iso_data_packets:
+            self.iso_packet_queue = DataPacketQueue(
+                max_packet_size=iso_data_packet_length,
+                max_in_flight=total_num_iso_data_packets,
                 send=self.send_hci_packet,
             )
 
@@ -552,7 +691,7 @@ class Host(AbortableEventEmitter):
 
                 return response
             except Exception as error:
-                logger.warning(
+                logger.exception(
                     f'{color("!!! Exception while sending command:", "red")} {error}'
                 )
                 raise error
@@ -595,11 +734,78 @@ class Host(AbortableEventEmitter):
                 data=l2cap_pdu[offset : offset + data_total_length],
             )
             logger.debug(f'>>> ACL packet enqueue: (CID={cid}) {acl_packet}')
-            packet_queue.enqueue(acl_packet)
+            packet_queue.enqueue(acl_packet, connection_handle)
             pb_flag = 1
             offset += data_total_length
             bytes_remaining -= data_total_length
 
+    def get_data_packet_queue(self, connection_handle: int) -> DataPacketQueue | None:
+        if connection := self.connections.get(connection_handle):
+            return connection.acl_packet_queue
+
+        if iso_link := self.cis_links.get(connection_handle) or self.bis_links.get(
+            connection_handle
+        ):
+            return iso_link.packet_queue
+
+        return None
+
+    def send_iso_sdu(self, connection_handle: int, sdu: bytes) -> None:
+        if not (
+            iso_link := self.cis_links.get(connection_handle)
+            or self.bis_links.get(connection_handle)
+        ):
+            logger.warning(f"no ISO link for connection handle {connection_handle}")
+            return
+
+        if iso_link.packet_queue is None:
+            logger.warning("ISO link has no data packet queue")
+            return
+
+        bytes_remaining = len(sdu)
+        offset = 0
+        while bytes_remaining:
+            is_first_fragment = offset == 0
+            header_length = 4 if is_first_fragment else 0
+            assert iso_link.packet_queue.max_packet_size > header_length
+            fragment_length = min(
+                bytes_remaining, iso_link.packet_queue.max_packet_size - header_length
+            )
+            is_last_fragment = bytes_remaining == fragment_length
+            iso_sdu_fragment = sdu[offset : offset + fragment_length]
+            iso_link.packet_queue.enqueue(
+                (
+                    hci.HCI_IsoDataPacket(
+                        connection_handle=connection_handle,
+                        data_total_length=header_length + fragment_length,
+                        packet_sequence_number=iso_link.packet_sequence_number,
+                        pb_flag=0b10 if is_last_fragment else 0b00,
+                        packet_status_flag=0,
+                        iso_sdu_length=len(sdu),
+                        iso_sdu_fragment=iso_sdu_fragment,
+                    )
+                    if is_first_fragment
+                    else hci.HCI_IsoDataPacket(
+                        connection_handle=connection_handle,
+                        data_total_length=fragment_length,
+                        pb_flag=0b11 if is_last_fragment else 0b01,
+                        iso_sdu_fragment=iso_sdu_fragment,
+                    )
+                ),
+                connection_handle,
+            )
+
+            offset += fragment_length
+            bytes_remaining -= fragment_length
+
+        iso_link.packet_sequence_number = (iso_link.packet_sequence_number + 1) & 0xFFFF
+
+    def remove_big(self, big_handle: int) -> None:
+        if big := self.bigs.pop(big_handle, None):
+            for connection_handle in big:
+                if bis_link := self.bis_links.pop(connection_handle, None):
+                    bis_link.packet_queue.flush(bis_link.handle)
+
     def supports_command(self, op_code: int) -> bool:
         return (
             self.local_supported_commands
@@ -727,16 +933,17 @@ class Host(AbortableEventEmitter):
     def on_hci_command_status_event(self, event):
         return self.on_command_processed(event)
 
-    def on_hci_number_of_completed_packets_event(self, event):
+    def on_hci_number_of_completed_packets_event(
+        self, event: hci.HCI_Number_Of_Completed_Packets_Event
+    ) -> None:
         for connection_handle, num_completed_packets in zip(
             event.connection_handles, event.num_completed_packets
         ):
-            if connection := self.connections.get(connection_handle):
-                connection.acl_packet_queue.on_packets_completed(num_completed_packets)
-            elif not (
-                self.cis_links.get(connection_handle)
-                or self.sco_links.get(connection_handle)
-            ):
+            if queue := self.get_data_packet_queue(connection_handle):
+                queue.on_packets_completed(num_completed_packets, connection_handle)
+                continue
+
+            if connection_handle not in self.sco_links:
                 logger.warning(
                     'received packet completion event for unknown handle '
                     f'0x{connection_handle:04X}'
@@ -767,7 +974,7 @@ class Host(AbortableEventEmitter):
                     self,
                     event.connection_handle,
                     event.peer_address,
-                    BT_LE_TRANSPORT,
+                    PhysicalTransport.LE,
                 )
                 self.connections[event.connection_handle] = connection
 
@@ -780,11 +987,11 @@ class Host(AbortableEventEmitter):
             self.emit(
                 'connection',
                 event.connection_handle,
-                BT_LE_TRANSPORT,
+                PhysicalTransport.LE,
                 event.peer_address,
                 getattr(event, 'local_resolvable_private_address', None),
                 getattr(event, 'peer_resolvable_private_address', None),
-                event.role,
+                hci.Role(event.role),
                 connection_parameters,
             )
         else:
@@ -792,7 +999,10 @@ class Host(AbortableEventEmitter):
 
             # Notify the listeners
             self.emit(
-                'connection_failure', BT_LE_TRANSPORT, event.peer_address, event.status
+                'connection_failure',
+                PhysicalTransport.LE,
+                event.peer_address,
+                event.status,
             )
 
     def on_hci_le_enhanced_connection_complete_event(self, event):
@@ -817,7 +1027,7 @@ class Host(AbortableEventEmitter):
                     self,
                     event.connection_handle,
                     event.bd_addr,
-                    BT_BR_EDR_TRANSPORT,
+                    PhysicalTransport.BR_EDR,
                 )
                 self.connections[event.connection_handle] = connection
 
@@ -825,7 +1035,7 @@ class Host(AbortableEventEmitter):
             self.emit(
                 'connection',
                 event.connection_handle,
-                BT_BR_EDR_TRANSPORT,
+                PhysicalTransport.BR_EDR,
                 event.bd_addr,
                 None,
                 None,
@@ -837,7 +1047,10 @@ class Host(AbortableEventEmitter):
 
             # Notify the client
             self.emit(
-                'connection_failure', BT_BR_EDR_TRANSPORT, event.bd_addr, event.status
+                'connection_failure',
+                PhysicalTransport.BR_EDR,
+                event.bd_addr,
+                event.status,
             )
 
     def on_hci_disconnection_complete_event(self, event):
@@ -854,11 +1067,7 @@ class Host(AbortableEventEmitter):
             return
 
         if event.status == hci.HCI_SUCCESS:
-            logger.debug(
-                f'### DISCONNECTION: [0x{handle:04X}] '
-                f'{connection.peer_address} '
-                f'reason={event.reason}'
-            )
+            logger.debug(f'### DISCONNECTION: {connection}, reason={event.reason}')
 
             # Notify the listeners
             self.emit('disconnection', handle, event.reason)
@@ -869,6 +1078,14 @@ class Host(AbortableEventEmitter):
                 or self.cis_links.pop(handle, 0)
                 or self.sco_links.pop(handle, 0)
             )
+
+            # Flush the data queues
+            if self.acl_packet_queue:
+                self.acl_packet_queue.flush(handle)
+            if self.le_acl_packet_queue:
+                self.le_acl_packet_queue.flush(handle)
+            if self.iso_packet_queue:
+                self.iso_packet_queue.flush(handle)
         else:
             logger.debug(f'### DISCONNECTION FAILED: {event.status}')
 
@@ -902,8 +1119,11 @@ class Host(AbortableEventEmitter):
 
         # Notify the client
         if event.status == hci.HCI_SUCCESS:
-            connection_phy = ConnectionPHY(event.tx_phy, event.rx_phy)
-            self.emit('connection_phy_update', connection.handle, connection_phy)
+            self.emit(
+                'connection_phy_update',
+                connection.handle,
+                ConnectionPHY(event.tx_phy, event.rx_phy),
+            )
         else:
             self.emit('connection_phy_update_failure', connection.handle, event.status)
 
@@ -953,12 +1173,94 @@ class Host(AbortableEventEmitter):
             event.cis_id,
         )
 
+    def on_hci_le_create_big_complete_event(self, event):
+        self.bigs[event.big_handle] = set(event.connection_handle)
+        if self.iso_packet_queue is None:
+            logger.warning("BIS established but ISO packets not supported")
+
+        for connection_handle in event.connection_handle:
+            self.bis_links[connection_handle] = IsoLink(
+                connection_handle, self.iso_packet_queue
+            )
+
+        self.emit(
+            'big_establishment',
+            event.status,
+            event.big_handle,
+            event.connection_handle,
+            event.big_sync_delay,
+            event.transport_latency_big,
+            event.phy,
+            event.nse,
+            event.bn,
+            event.pto,
+            event.irc,
+            event.max_pdu,
+            event.iso_interval,
+        )
+
+    def on_hci_le_big_sync_established_event(self, event):
+        self.bigs[event.big_handle] = set(event.connection_handle)
+        for connection_handle in event.connection_handle:
+            self.bis_links[connection_handle] = IsoLink(
+                connection_handle, self.iso_packet_queue
+            )
+
+        self.emit(
+            'big_sync_establishment',
+            event.status,
+            event.big_handle,
+            event.transport_latency_big,
+            event.nse,
+            event.bn,
+            event.pto,
+            event.irc,
+            event.max_pdu,
+            event.iso_interval,
+            event.connection_handle,
+        )
+
+    def on_hci_le_big_sync_lost_event(self, event):
+        self.remove_big(event.big_handle)
+        self.emit('big_sync_lost', event.big_handle, event.reason)
+
+    def on_hci_le_terminate_big_complete_event(self, event):
+        self.remove_big(event.big_handle)
+        self.emit('big_termination', event.reason, event.big_handle)
+
+    def on_hci_le_periodic_advertising_sync_transfer_received_event(self, event):
+        self.emit(
+            'periodic_advertising_sync_transfer',
+            event.status,
+            event.connection_handle,
+            event.sync_handle,
+            event.advertising_sid,
+            event.advertiser_address,
+            event.advertiser_phy,
+            event.periodic_advertising_interval,
+            event.advertiser_clock_accuracy,
+        )
+
+    def on_hci_le_periodic_advertising_sync_transfer_received_v2_event(self, event):
+        self.emit(
+            'periodic_advertising_sync_transfer',
+            event.status,
+            event.connection_handle,
+            event.sync_handle,
+            event.advertising_sid,
+            event.advertiser_address,
+            event.advertiser_phy,
+            event.periodic_advertising_interval,
+            event.advertiser_clock_accuracy,
+        )
+
     def on_hci_le_cis_established_event(self, event):
         # The remaining parameters are unused for now.
         if event.status == hci.HCI_SUCCESS:
-            self.cis_links[event.connection_handle] = CisLink(
-                handle=event.connection_handle,
-                peer_address=hci.Address.ANY,
+            if self.iso_packet_queue is None:
+                logger.warning("CIS established but ISO packets not supported")
+            self.cis_links[event.connection_handle] = IsoLink(
+                handle=event.connection_handle, packet_queue=self.iso_packet_queue
             )
             self.emit('cis_establishment', event.connection_handle)
         else:
@@ -995,7 +1297,8 @@ class Host(AbortableEventEmitter):
                 logger.debug('no long term key provider')
                 long_term_key = None
             else:
-                long_term_key = await self.abort_on(
+                long_term_key = await utils.cancel_on_event(
+                    self,
                     'flush',
                     # pylint: disable-next=not-callable
                     self.long_term_key_provider(
@@ -1028,7 +1331,7 @@ class Host(AbortableEventEmitter):
 
             self.sco_links[event.connection_handle] = ScoLink(
                 peer_address=event.bd_addr,
-                handle=event.connection_handle,
+                connection_handle=event.connection_handle,
             )
 
             # Notify the client
@@ -1053,7 +1356,7 @@ class Host(AbortableEventEmitter):
                 f'role change for {event.bd_addr}: '
                 f'{hci.HCI_Constant.role_name(event.new_role)}'
             )
-            self.emit('role_change', event.bd_addr, event.new_role)
+            self.emit('role_change', event.bd_addr, hci.Role(event.new_role))
         else:
             logger.debug(
                 f'role change for {event.bd_addr} failed: '
@@ -1089,6 +1392,21 @@ class Host(AbortableEventEmitter):
                 'connection_encryption_change',
                 event.connection_handle,
                 event.encryption_enabled,
+                0,
+            )
+        else:
+            self.emit(
+                'connection_encryption_failure', event.connection_handle, event.status
+            )
+
+    def on_hci_encryption_change_v2_event(self, event):
+        # Notify the client
+        if event.status == hci.HCI_SUCCESS:
+            self.emit(
+                'connection_encryption_change',
+                event.connection_handle,
+                event.encryption_enabled,
+                event.encryption_key_size,
             )
         else:
             self.emit(
@@ -1106,6 +1424,18 @@ class Host(AbortableEventEmitter):
                 event.status,
             )
 
+    def on_hci_qos_setup_complete_event(self, event):
+        if event.status == hci.HCI_SUCCESS:
+            self.emit(
+                'connection_qos_setup', event.connection_handle, event.service_type
+            )
+        else:
+            self.emit(
+                'connection_qos_setup_failure',
+                event.connection_handle,
+                event.status,
+            )
+
     def on_hci_link_supervision_timeout_changed_event(self, event):
         pass
 
@@ -1141,7 +1471,8 @@ class Host(AbortableEventEmitter):
                 logger.debug('no link key provider')
                 link_key = None
             else:
-                link_key = await self.abort_on(
+                link_key = await utils.cancel_on_event(
+                    self,
                     'flush',
                     # pylint: disable-next=not-callable
                     self.link_key_provider(event.bd_addr),
@@ -1236,3 +1567,24 @@ class Host(AbortableEventEmitter):
                 event.connection_handle,
                 int.from_bytes(event.le_features, 'little'),
             )
+
+    def on_hci_le_cs_read_remote_supported_capabilities_complete_event(self, event):
+        self.emit('cs_remote_supported_capabilities', event)
+
+    def on_hci_le_cs_security_enable_complete_event(self, event):
+        self.emit('cs_security', event)
+
+    def on_hci_le_cs_config_complete_event(self, event):
+        self.emit('cs_config', event)
+
+    def on_hci_le_cs_procedure_enable_complete_event(self, event):
+        self.emit('cs_procedure', event)
+
+    def on_hci_le_cs_subevent_result_event(self, event):
+        self.emit('cs_subevent_result', event)
+
+    def on_hci_le_cs_subevent_result_continue_event(self, event):
+        self.emit('cs_subevent_result_continue', event)
+
+    def on_hci_vendor_event(self, event):
+        self.emit('vendor_event', event)
diff --git a/bumble/keys.py b/bumble/keys.py
index facaa37..2573b1d 100644
--- a/bumble/keys.py
+++ b/bumble/keys.py
@@ -22,17 +22,18 @@
 # -----------------------------------------------------------------------------
 from __future__ import annotations
 import asyncio
+import dataclasses
 import logging
 import os
 import json
-from typing import TYPE_CHECKING, Dict, List, Optional, Tuple, Type
+from typing import TYPE_CHECKING, Dict, List, Optional, Tuple, Type, Any
 from typing_extensions import Self
 
-from .colors import color
-from .hci import Address
+from bumble.colors import color
+from bumble import hci
 
 if TYPE_CHECKING:
-    from .device import Device
+    from bumble.device import Device
 
 
 # -----------------------------------------------------------------------------
@@ -42,16 +43,17 @@ logger = logging.getLogger(__name__)
 
 
 # -----------------------------------------------------------------------------
+@dataclasses.dataclass
 class PairingKeys:
+    @dataclasses.dataclass
     class Key:
-        def __init__(self, value, authenticated=False, ediv=None, rand=None):
-            self.value = value
-            self.authenticated = authenticated
-            self.ediv = ediv
-            self.rand = rand
+        value: bytes
+        authenticated: bool = False
+        ediv: Optional[int] = None
+        rand: Optional[bytes] = None
 
         @classmethod
-        def from_dict(cls, key_dict):
+        def from_dict(cls, key_dict: dict[str, Any]) -> PairingKeys.Key:
             value = bytes.fromhex(key_dict['value'])
             authenticated = key_dict.get('authenticated', False)
             ediv = key_dict.get('ediv')
@@ -61,7 +63,7 @@ class PairingKeys:
 
             return cls(value, authenticated, ediv, rand)
 
-        def to_dict(self):
+        def to_dict(self) -> dict[str, Any]:
             key_dict = {'value': self.value.hex(), 'authenticated': self.authenticated}
             if self.ediv is not None:
                 key_dict['ediv'] = self.ediv
@@ -70,39 +72,42 @@ class PairingKeys:
 
             return key_dict
 
-    def __init__(self):
-        self.address_type = None
-        self.ltk = None
-        self.ltk_central = None
-        self.ltk_peripheral = None
-        self.irk = None
-        self.csrk = None
-        self.link_key = None  # Classic
-
-    @staticmethod
-    def key_from_dict(keys_dict, key_name):
+    address_type: Optional[hci.AddressType] = None
+    ltk: Optional[Key] = None
+    ltk_central: Optional[Key] = None
+    ltk_peripheral: Optional[Key] = None
+    irk: Optional[Key] = None
+    csrk: Optional[Key] = None
+    link_key: Optional[Key] = None  # Classic
+    link_key_type: Optional[int] = None  # Classic
+
+    @classmethod
+    def key_from_dict(cls, keys_dict: dict[str, Any], key_name: str) -> Optional[Key]:
         key_dict = keys_dict.get(key_name)
         if key_dict is None:
             return None
 
         return PairingKeys.Key.from_dict(key_dict)
 
-    @staticmethod
-    def from_dict(keys_dict):
-        keys = PairingKeys()
-
-        keys.address_type = keys_dict.get('address_type')
-        keys.ltk = PairingKeys.key_from_dict(keys_dict, 'ltk')
-        keys.ltk_central = PairingKeys.key_from_dict(keys_dict, 'ltk_central')
-        keys.ltk_peripheral = PairingKeys.key_from_dict(keys_dict, 'ltk_peripheral')
-        keys.irk = PairingKeys.key_from_dict(keys_dict, 'irk')
-        keys.csrk = PairingKeys.key_from_dict(keys_dict, 'csrk')
-        keys.link_key = PairingKeys.key_from_dict(keys_dict, 'link_key')
-
-        return keys
-
-    def to_dict(self):
-        keys = {}
+    @classmethod
+    def from_dict(cls, keys_dict: dict[str, Any]) -> PairingKeys:
+        return PairingKeys(
+            address_type=(
+                hci.AddressType(t)
+                if (t := keys_dict.get('address_type')) is not None
+                else None
+            ),
+            ltk=PairingKeys.key_from_dict(keys_dict, 'ltk'),
+            ltk_central=PairingKeys.key_from_dict(keys_dict, 'ltk_central'),
+            ltk_peripheral=PairingKeys.key_from_dict(keys_dict, 'ltk_peripheral'),
+            irk=PairingKeys.key_from_dict(keys_dict, 'irk'),
+            csrk=PairingKeys.key_from_dict(keys_dict, 'csrk'),
+            link_key=PairingKeys.key_from_dict(keys_dict, 'link_key'),
+            link_key_type=keys_dict.get('link_key_type'),
+        )
+
+    def to_dict(self) -> dict[str, Any]:
+        keys: dict[str, Any] = {}
 
         if self.address_type is not None:
             keys['address_type'] = self.address_type
@@ -125,9 +130,12 @@ class PairingKeys:
         if self.link_key is not None:
             keys['link_key'] = self.link_key.to_dict()
 
+        if self.link_key_type is not None:
+            keys['link_key_type'] = self.link_key_type
+
         return keys
 
-    def print(self, prefix=''):
+    def print(self, prefix: str = '') -> None:
         keys_dict = self.to_dict()
         for container_property, value in keys_dict.items():
             if isinstance(value, dict):
@@ -156,20 +164,28 @@ class KeyStore:
         all_keys = await self.get_all()
         await asyncio.gather(*(self.delete(name) for (name, _) in all_keys))
 
-    async def get_resolving_keys(self):
+    async def get_resolving_keys(self) -> list[tuple[bytes, hci.Address]]:
         all_keys = await self.get_all()
         resolving_keys = []
         for name, keys in all_keys:
             if keys.irk is not None:
-                if keys.address_type is None:
-                    address_type = Address.RANDOM_DEVICE_ADDRESS
-                else:
-                    address_type = keys.address_type
-                resolving_keys.append((keys.irk.value, Address(name, address_type)))
+                resolving_keys.append(
+                    (
+                        keys.irk.value,
+                        hci.Address(
+                            name,
+                            (
+                                keys.address_type
+                                if keys.address_type is not None
+                                else hci.Address.RANDOM_DEVICE_ADDRESS
+                            ),
+                        ),
+                    )
+                )
 
         return resolving_keys
 
-    async def print(self, prefix=''):
+    async def print(self, prefix: str = '') -> None:
         entries = await self.get_all()
         separator = ''
         for name, keys in entries:
@@ -177,8 +193,8 @@ class KeyStore:
             keys.print(prefix=prefix + '  ')
             separator = '\n'
 
-    @staticmethod
-    def create_for_device(device: Device) -> KeyStore:
+    @classmethod
+    def create_for_device(cls, device: Device) -> KeyStore:
         if device.config.keystore is None:
             return MemoryKeyStore()
 
@@ -266,9 +282,9 @@ class JsonKeyStore(KeyStore):
                     filename = params[0]
 
         # Use a namespace based on the device address
-        if device.public_address not in (Address.ANY, Address.ANY_RANDOM):
+        if device.public_address not in (hci.Address.ANY, hci.Address.ANY_RANDOM):
             namespace = str(device.public_address)
-        elif device.random_address != Address.ANY_RANDOM:
+        elif device.random_address != hci.Address.ANY_RANDOM:
             namespace = str(device.random_address)
         else:
             namespace = JsonKeyStore.DEFAULT_NAMESPACE
diff --git a/bumble/l2cap.py b/bumble/l2cap.py
index 53c84d5..08d8edf 100644
--- a/bumble/l2cap.py
+++ b/bumble/l2cap.py
@@ -23,7 +23,6 @@ import logging
 import struct
 
 from collections import deque
-from pyee import EventEmitter
 from typing import (
     Dict,
     Type,
@@ -39,19 +38,19 @@ from typing import (
     TYPE_CHECKING,
 )
 
-from .utils import deprecated
-from .colors import color
-from .core import (
-    BT_CENTRAL_ROLE,
+from bumble import utils
+from bumble.colors import color
+from bumble.core import (
     InvalidStateError,
     InvalidArgumentError,
     InvalidPacketError,
     OutOfResourcesError,
     ProtocolError,
 )
-from .hci import (
+from bumble.hci import (
     HCI_LE_Connection_Update_Command,
     HCI_Object,
+    Role,
     key_with_value,
     name_or_number,
 )
@@ -225,7 +224,7 @@ class L2CAP_PDU:
 
         return L2CAP_PDU(l2cap_pdu_cid, l2cap_pdu_payload)
 
-    def to_bytes(self) -> bytes:
+    def __bytes__(self) -> bytes:
         header = struct.pack('<HH', len(self.payload), self.cid)
         return header + self.payload
 
@@ -233,9 +232,6 @@ class L2CAP_PDU:
         self.cid = cid
         self.payload = payload
 
-    def __bytes__(self) -> bytes:
-        return self.to_bytes()
-
     def __str__(self) -> str:
         return f'{color("L2CAP", "green")} [CID={self.cid}]: {self.payload.hex()}'
 
@@ -333,11 +329,8 @@ class L2CAP_Control_Frame:
     def init_from_bytes(self, pdu, offset):
         return HCI_Object.init_from_bytes(self, pdu, offset, self.fields)
 
-    def to_bytes(self) -> bytes:
-        return self.pdu
-
     def __bytes__(self) -> bytes:
-        return self.to_bytes()
+        return self.pdu
 
     def __str__(self) -> str:
         result = f'{color(self.name, "yellow")} [ID={self.identifier}]'
@@ -726,7 +719,7 @@ class L2CAP_LE_Flow_Control_Credit(L2CAP_Control_Frame):
 
 
 # -----------------------------------------------------------------------------
-class ClassicChannel(EventEmitter):
+class ClassicChannel(utils.EventEmitter):
     class State(enum.IntEnum):
         # States
         CLOSED = 0x00
@@ -751,6 +744,9 @@ class ClassicChannel(EventEmitter):
         WAIT_FINAL_RSP = 0x16
         WAIT_CONTROL_IND = 0x17
 
+    EVENT_OPEN = "open"
+    EVENT_CLOSE = "close"
+
     connection_result: Optional[asyncio.Future[None]]
     disconnection_result: Optional[asyncio.Future[None]]
     response: Optional[asyncio.Future[bytes]]
@@ -779,7 +775,6 @@ class ClassicChannel(EventEmitter):
         self.psm = psm
         self.source_cid = source_cid
         self.destination_cid = 0
-        self.response = None
         self.connection_result = None
         self.disconnection_result = None
         self.sink = None
@@ -789,27 +784,15 @@ class ClassicChannel(EventEmitter):
         self.state = new_state
 
     def send_pdu(self, pdu: Union[SupportsBytes, bytes]) -> None:
+        if self.state != self.State.OPEN:
+            raise InvalidStateError('channel not open')
         self.manager.send_pdu(self.connection, self.destination_cid, pdu)
 
     def send_control_frame(self, frame: L2CAP_Control_Frame) -> None:
         self.manager.send_control_frame(self.connection, self.signaling_cid, frame)
 
-    async def send_request(self, request: SupportsBytes) -> bytes:
-        # Check that there isn't already a request pending
-        if self.response:
-            raise InvalidStateError('request already pending')
-        if self.state != self.State.OPEN:
-            raise InvalidStateError('channel not open')
-
-        self.response = asyncio.get_running_loop().create_future()
-        self.send_pdu(request)
-        return await self.response
-
     def on_pdu(self, pdu: bytes) -> None:
-        if self.response:
-            self.response.set_result(pdu)
-            self.response = None
-        elif self.sink:
+        if self.sink:
             # pylint: disable=not-callable
             self.sink(pdu)
         else:
@@ -840,8 +823,8 @@ class ClassicChannel(EventEmitter):
 
         # Wait for the connection to succeed or fail
         try:
-            return await self.connection.abort_on(
-                'disconnection', self.connection_result
+            return await utils.cancel_on_event(
+                self.connection, 'disconnection', self.connection_result
             )
         finally:
             self.connection_result = None
@@ -867,7 +850,7 @@ class ClassicChannel(EventEmitter):
     def abort(self) -> None:
         if self.state == self.State.OPEN:
             self._change_state(self.State.CLOSED)
-            self.emit('close')
+            self.emit(self.EVENT_CLOSE)
 
     def send_configure_request(self) -> None:
         options = L2CAP_Control_Frame.encode_configuration_options(
@@ -960,7 +943,7 @@ class ClassicChannel(EventEmitter):
             if self.connection_result:
                 self.connection_result.set_result(None)
                 self.connection_result = None
-            self.emit('open')
+            self.emit(self.EVENT_OPEN)
         elif self.state == self.State.WAIT_CONFIG_REQ_RSP:
             self._change_state(self.State.WAIT_CONFIG_RSP)
 
@@ -976,7 +959,7 @@ class ClassicChannel(EventEmitter):
                 if self.connection_result:
                     self.connection_result.set_result(None)
                     self.connection_result = None
-                self.emit('open')
+                self.emit(self.EVENT_OPEN)
             else:
                 logger.warning(color('invalid state', 'red'))
         elif (
@@ -1011,7 +994,7 @@ class ClassicChannel(EventEmitter):
                 )
             )
             self._change_state(self.State.CLOSED)
-            self.emit('close')
+            self.emit(self.EVENT_CLOSE)
             self.manager.on_channel_closed(self)
         else:
             logger.warning(color('invalid state', 'red'))
@@ -1032,7 +1015,7 @@ class ClassicChannel(EventEmitter):
         if self.disconnection_result:
             self.disconnection_result.set_result(None)
             self.disconnection_result = None
-        self.emit('close')
+        self.emit(self.EVENT_CLOSE)
         self.manager.on_channel_closed(self)
 
     def __str__(self) -> str:
@@ -1045,7 +1028,7 @@ class ClassicChannel(EventEmitter):
 
 
 # -----------------------------------------------------------------------------
-class LeCreditBasedChannel(EventEmitter):
+class LeCreditBasedChannel(utils.EventEmitter):
     """
     LE Credit-based Connection Oriented Channel
     """
@@ -1067,6 +1050,9 @@ class LeCreditBasedChannel(EventEmitter):
     connection: Connection
     sink: Optional[Callable[[bytes], Any]]
 
+    EVENT_OPEN = "open"
+    EVENT_CLOSE = "close"
+
     def __init__(
         self,
         manager: ChannelManager,
@@ -1118,9 +1104,9 @@ class LeCreditBasedChannel(EventEmitter):
         self.state = new_state
 
         if new_state == self.State.CONNECTED:
-            self.emit('open')
+            self.emit(self.EVENT_OPEN)
         elif new_state == self.State.DISCONNECTED:
-            self.emit('close')
+            self.emit(self.EVENT_CLOSE)
 
     def send_pdu(self, pdu: Union[SupportsBytes, bytes]) -> None:
         self.manager.send_pdu(self.connection, self.destination_cid, pdu)
@@ -1400,7 +1386,9 @@ class LeCreditBasedChannel(EventEmitter):
 
 
 # -----------------------------------------------------------------------------
-class ClassicChannelServer(EventEmitter):
+class ClassicChannelServer(utils.EventEmitter):
+    EVENT_CONNECTION = "connection"
+
     def __init__(
         self,
         manager: ChannelManager,
@@ -1415,7 +1403,7 @@ class ClassicChannelServer(EventEmitter):
         self.mtu = mtu
 
     def on_connection(self, channel: ClassicChannel) -> None:
-        self.emit('connection', channel)
+        self.emit(self.EVENT_CONNECTION, channel)
         if self.handler:
             self.handler(channel)
 
@@ -1425,7 +1413,9 @@ class ClassicChannelServer(EventEmitter):
 
 
 # -----------------------------------------------------------------------------
-class LeCreditBasedChannelServer(EventEmitter):
+class LeCreditBasedChannelServer(utils.EventEmitter):
+    EVENT_CONNECTION = "connection"
+
     def __init__(
         self,
         manager: ChannelManager,
@@ -1444,7 +1434,7 @@ class LeCreditBasedChannelServer(EventEmitter):
         self.mps = mps
 
     def on_connection(self, channel: LeCreditBasedChannel) -> None:
-        self.emit('connection', channel)
+        self.emit(self.EVENT_CONNECTION, channel)
         if self.handler:
             self.handler(channel)
 
@@ -1540,6 +1530,9 @@ class ChannelManager:
 
     def next_identifier(self, connection: Connection) -> int:
         identifier = (self.identifiers.setdefault(connection.handle, 0) + 1) % 256
+        # 0x00 is an invalid ID (BT Core Spec, Vol 3, Part A, Sect 4
+        if identifier == 0:
+            identifier = 1
         self.identifiers[connection.handle] = identifier
         return identifier
 
@@ -1552,7 +1545,7 @@ class ChannelManager:
         if cid in self.fixed_channels:
             del self.fixed_channels[cid]
 
-    @deprecated("Please use create_classic_server")
+    @utils.deprecated("Please use create_classic_server")
     def register_server(
         self,
         psm: int,
@@ -1598,7 +1591,7 @@ class ChannelManager:
 
         return self.servers[spec.psm]
 
-    @deprecated("Please use create_le_credit_based_server()")
+    @utils.deprecated("Please use create_le_credit_based_server()")
     def register_le_coc_server(
         self,
         psm: int,
@@ -1911,6 +1904,7 @@ class ChannelManager:
             data = sum(1 << cid for cid in self.fixed_channels).to_bytes(8, 'little')
         else:
             result = L2CAP_Information_Response.NOT_SUPPORTED
+            data = b''
 
         self.send_control_frame(
             connection,
@@ -1926,7 +1920,7 @@ class ChannelManager:
     def on_l2cap_connection_parameter_update_request(
         self, connection: Connection, cid: int, request
     ):
-        if connection.role == BT_CENTRAL_ROLE:
+        if connection.role == Role.CENTRAL:
             self.send_control_frame(
                 connection,
                 cid,
@@ -2141,7 +2135,7 @@ class ChannelManager:
             if channel.source_cid in connection_channels:
                 del connection_channels[channel.source_cid]
 
-    @deprecated("Please use create_le_credit_based_channel()")
+    @utils.deprecated("Please use create_le_credit_based_channel()")
     async def open_le_coc(
         self, connection: Connection, psm: int, max_credits: int, mtu: int, mps: int
     ) -> LeCreditBasedChannel:
@@ -2198,7 +2192,7 @@ class ChannelManager:
 
         return channel
 
-    @deprecated("Please use create_classic_channel()")
+    @utils.deprecated("Please use create_classic_channel()")
     async def connect(self, connection: Connection, psm: int) -> ClassicChannel:
         return await self.create_classic_channel(
             connection=connection, spec=ClassicChannelSpec(psm=psm)
@@ -2248,12 +2242,12 @@ class ChannelManager:
 
 
 class Channel(ClassicChannel):
-    @deprecated("Please use ClassicChannel")
+    @utils.deprecated("Please use ClassicChannel")
     def __init__(self, *args, **kwargs) -> None:
         super().__init__(*args, **kwargs)
 
 
 class LeConnectionOrientedChannel(LeCreditBasedChannel):
-    @deprecated("Please use LeCreditBasedChannel")
+    @utils.deprecated("Please use LeCreditBasedChannel")
     def __init__(self, *args, **kwargs) -> None:
         super().__init__(*args, **kwargs)
diff --git a/bumble/link.py b/bumble/link.py
index 8971e21..971b6fb 100644
--- a/bumble/link.py
+++ b/bumble/link.py
@@ -20,14 +20,13 @@ import asyncio
 from functools import partial
 
 from bumble.core import (
-    BT_PERIPHERAL_ROLE,
-    BT_BR_EDR_TRANSPORT,
-    BT_LE_TRANSPORT,
+    PhysicalTransport,
     InvalidStateError,
 )
 from bumble.colors import color
 from bumble.hci import (
     Address,
+    Role,
     HCI_SUCCESS,
     HCI_CONNECTION_ACCEPT_TIMEOUT_ERROR,
     HCI_CONNECTION_TIMEOUT_ERROR,
@@ -116,12 +115,14 @@ class LocalLink:
 
     def send_acl_data(self, sender_controller, destination_address, transport, data):
         # Send the data to the first controller with a matching address
-        if transport == BT_LE_TRANSPORT:
+        if transport == PhysicalTransport.LE:
             destination_controller = self.find_controller(destination_address)
             source_address = sender_controller.random_address
-        elif transport == BT_BR_EDR_TRANSPORT:
+        elif transport == PhysicalTransport.BR_EDR:
             destination_controller = self.find_classic_controller(destination_address)
             source_address = sender_controller.public_address
+        else:
+            raise ValueError("unsupported transport type")
 
         if destination_controller is not None:
             destination_controller.on_link_acl_data(source_address, transport, data)
@@ -290,7 +291,7 @@ class LocalLink:
             return
 
         async def task():
-            if responder_role != BT_PERIPHERAL_ROLE:
+            if responder_role != Role.PERIPHERAL:
                 initiator_controller.on_classic_role_change(
                     responder_controller.public_address, int(not (responder_role))
                 )
diff --git a/bumble/pairing.py b/bumble/pairing.py
index 5614e84..5331b49 100644
--- a/bumble/pairing.py
+++ b/bumble/pairing.py
@@ -1,4 +1,4 @@
-# Copyright 2021-2023 Google LLC
+# Copyright 2021-2025 Google LLC
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -20,14 +20,14 @@ import enum
 from dataclasses import dataclass
 from typing import Optional, Tuple
 
-from .hci import (
+from bumble.hci import (
     Address,
     HCI_NO_INPUT_NO_OUTPUT_IO_CAPABILITY,
     HCI_DISPLAY_ONLY_IO_CAPABILITY,
     HCI_DISPLAY_YES_NO_IO_CAPABILITY,
     HCI_KEYBOARD_ONLY_IO_CAPABILITY,
 )
-from .smp import (
+from bumble.smp import (
     SMP_NO_INPUT_NO_OUTPUT_IO_CAPABILITY,
     SMP_KEYBOARD_ONLY_IO_CAPABILITY,
     SMP_DISPLAY_ONLY_IO_CAPABILITY,
@@ -41,7 +41,7 @@ from .smp import (
     OobLegacyContext,
     OobSharedData,
 )
-from .core import AdvertisingData, LeRole
+from bumble.core import AdvertisingData, LeRole
 
 
 # -----------------------------------------------------------------------------
@@ -76,18 +76,18 @@ class OobData:
         return instance
 
     def to_ad(self) -> AdvertisingData:
-        ad_structures = []
+        ad_structures: list[tuple[int, bytes]] = []
         if self.address is not None:
             ad_structures.append(
-                (AdvertisingData.LE_BLUETOOTH_DEVICE_ADDRESS, bytes(self.address))
+                (AdvertisingData.Type.LE_BLUETOOTH_DEVICE_ADDRESS, bytes(self.address))
             )
         if self.role is not None:
-            ad_structures.append((AdvertisingData.LE_ROLE, bytes([self.role])))
+            ad_structures.append((AdvertisingData.Type.LE_ROLE, bytes([self.role])))
         if self.shared_data is not None:
             ad_structures.extend(self.shared_data.to_ad().ad_structures)
         if self.legacy_context is not None:
             ad_structures.append(
-                (AdvertisingData.SECURITY_MANAGER_TK_VALUE, self.legacy_context.tk)
+                (AdvertisingData.Type.SECURITY_MANAGER_TK_VALUE, self.legacy_context.tk)
             )
 
         return AdvertisingData(ad_structures)
@@ -139,16 +139,19 @@ class PairingDelegate:
     io_capability: IoCapability
     local_initiator_key_distribution: KeyDistribution
     local_responder_key_distribution: KeyDistribution
+    maximum_encryption_key_size: int
 
     def __init__(
         self,
         io_capability: IoCapability = NO_OUTPUT_NO_INPUT,
         local_initiator_key_distribution: KeyDistribution = DEFAULT_KEY_DISTRIBUTION,
         local_responder_key_distribution: KeyDistribution = DEFAULT_KEY_DISTRIBUTION,
+        maximum_encryption_key_size: int = 16,
     ) -> None:
         self.io_capability = io_capability
         self.local_initiator_key_distribution = local_initiator_key_distribution
         self.local_responder_key_distribution = local_responder_key_distribution
+        self.maximum_encryption_key_size = maximum_encryption_key_size
 
     @property
     def classic_io_capability(self) -> int:
diff --git a/bumble/pandora/__init__.py b/bumble/pandora/__init__.py
index 8fb4b6e..ae4039d 100644
--- a/bumble/pandora/__init__.py
+++ b/bumble/pandora/__init__.py
@@ -22,11 +22,11 @@ __version__ = "0.0.1"
 import grpc
 import grpc.aio
 
-from .config import Config
-from .device import PandoraDevice
-from .host import HostService
-from .l2cap import L2CAPService
-from .security import SecurityService, SecurityStorageService
+from bumble.pandora.config import Config
+from bumble.pandora.device import PandoraDevice
+from bumble.pandora.host import HostService
+from bumble.pandora.l2cap import L2CAPService
+from bumble.pandora.security import SecurityService, SecurityStorageService
 from pandora.host_grpc_aio import add_HostServicer_to_server
 from pandora.l2cap_grpc_aio import add_L2CAPServicer_to_server
 from pandora.security_grpc_aio import (
diff --git a/bumble/pandora/host.py b/bumble/pandora/host.py
index aff063c..515c1d5 100644
--- a/bumble/pandora/host.py
+++ b/bumble/pandora/host.py
@@ -20,12 +20,11 @@ import grpc.aio
 import logging
 import struct
 
-from . import utils
-from .config import Config
+import bumble.utils
+from bumble.pandora import utils
+from bumble.pandora.config import Config
 from bumble.core import (
-    BT_BR_EDR_TRANSPORT,
-    BT_LE_TRANSPORT,
-    BT_PERIPHERAL_ROLE,
+    PhysicalTransport,
     UUID,
     AdvertisingData,
     Appearance,
@@ -39,7 +38,6 @@ from bumble.device import (
     AdvertisingEventProperties,
     AdvertisingType,
     Device,
-    Phy,
 )
 from bumble.gatt import Service
 from bumble.hci import (
@@ -47,6 +45,9 @@ from bumble.hci import (
     HCI_PAGE_TIMEOUT_ERROR,
     HCI_REMOTE_USER_TERMINATED_CONNECTION_ERROR,
     Address,
+    Phy,
+    Role,
+    OwnAddressType,
 )
 from google.protobuf import any_pb2  # pytype: disable=pyi-error
 from google.protobuf import empty_pb2  # pytype: disable=pyi-error
@@ -114,11 +115,11 @@ SECONDARY_PHY_TO_BUMBLE_PHY_MAP: Dict[SecondaryPhy, Phy] = {
     SECONDARY_CODED: Phy.LE_CODED,
 }
 
-OWN_ADDRESS_MAP: Dict[host_pb2.OwnAddressType, bumble.hci.OwnAddressType] = {
-    host_pb2.PUBLIC: bumble.hci.OwnAddressType.PUBLIC,
-    host_pb2.RANDOM: bumble.hci.OwnAddressType.RANDOM,
-    host_pb2.RESOLVABLE_OR_PUBLIC: bumble.hci.OwnAddressType.RESOLVABLE_OR_PUBLIC,
-    host_pb2.RESOLVABLE_OR_RANDOM: bumble.hci.OwnAddressType.RESOLVABLE_OR_RANDOM,
+OWN_ADDRESS_MAP: Dict[host_pb2.OwnAddressType, OwnAddressType] = {
+    host_pb2.PUBLIC: OwnAddressType.PUBLIC,
+    host_pb2.RANDOM: OwnAddressType.RANDOM,
+    host_pb2.RESOLVABLE_OR_PUBLIC: OwnAddressType.RESOLVABLE_OR_PUBLIC,
+    host_pb2.RESOLVABLE_OR_RANDOM: OwnAddressType.RESOLVABLE_OR_RANDOM,
 }
 
 
@@ -184,7 +185,7 @@ class HostService(HostServicer):
 
         try:
             connection = await self.device.connect(
-                address, transport=BT_BR_EDR_TRANSPORT
+                address, transport=PhysicalTransport.BR_EDR
             )
         except ConnectionError as e:
             if e.error_code == HCI_PAGE_TIMEOUT_ERROR:
@@ -217,7 +218,7 @@ class HostService(HostServicer):
         self.log.debug(f"WaitConnection from {address}...")
 
         connection = self.device.find_connection_by_bd_addr(
-            address, transport=BT_BR_EDR_TRANSPORT
+            address, transport=PhysicalTransport.BR_EDR
         )
         if connection and id(connection) in self.waited_connections:
             # this connection was already returned: wait for a new one.
@@ -249,8 +250,8 @@ class HostService(HostServicer):
         try:
             connection = await self.device.connect(
                 address,
-                transport=BT_LE_TRANSPORT,
-                own_address_type=request.own_address_type,
+                transport=PhysicalTransport.LE,
+                own_address_type=OwnAddressType(request.own_address_type),
             )
         except ConnectionError as e:
             if e.error_code == HCI_PAGE_TIMEOUT_ERROR:
@@ -295,12 +296,12 @@ class HostService(HostServicer):
             def on_disconnection(_: None) -> None:
                 disconnection_future.set_result(None)
 
-            connection.on('disconnection', on_disconnection)
+            connection.on(connection.EVENT_DISCONNECTION, on_disconnection)
             try:
                 await disconnection_future
                 self.log.debug("Disconnected")
             finally:
-                connection.remove_listener('disconnection', on_disconnection)  # type: ignore
+                connection.remove_listener(connection.EVENT_DISCONNECTION, on_disconnection)  # type: ignore
 
         return empty_pb2.Empty()
 
@@ -371,20 +372,18 @@ class HostService(HostServicer):
             scan_response_data=scan_response_data,
         )
 
-        pending_connection: asyncio.Future[bumble.device.Connection] = (
-            asyncio.get_running_loop().create_future()
-        )
+        connections: asyncio.Queue[bumble.device.Connection] = asyncio.Queue()
 
         if request.connectable:
 
             def on_connection(connection: bumble.device.Connection) -> None:
                 if (
-                    connection.transport == BT_LE_TRANSPORT
-                    and connection.role == BT_PERIPHERAL_ROLE
+                    connection.transport == PhysicalTransport.LE
+                    and connection.role == Role.PERIPHERAL
                 ):
-                    pending_connection.set_result(connection)
+                    connections.put_nowait(connection)
 
-            self.device.on('connection', on_connection)
+            self.device.on(self.device.EVENT_CONNECTION, on_connection)
 
         try:
             # Advertise until RPC is canceled
@@ -397,8 +396,7 @@ class HostService(HostServicer):
                     await asyncio.sleep(1)
                     continue
 
-                connection = await pending_connection
-                pending_connection = asyncio.get_running_loop().create_future()
+                connection = await connections.get()
 
                 cookie = any_pb2.Any(value=connection.handle.to_bytes(4, 'big'))
                 yield AdvertiseResponse(connection=Connection(cookie=cookie))
@@ -492,16 +490,18 @@ class HostService(HostServicer):
                 target = Address(target_bytes, Address.RANDOM_DEVICE_ADDRESS)
                 advertising_type = AdvertisingType.DIRECTED_CONNECTABLE_LOW_DUTY
 
+        connections: asyncio.Queue[bumble.device.Connection] = asyncio.Queue()
+
         if request.connectable:
 
             def on_connection(connection: bumble.device.Connection) -> None:
                 if (
-                    connection.transport == BT_LE_TRANSPORT
-                    and connection.role == BT_PERIPHERAL_ROLE
+                    connection.transport == PhysicalTransport.LE
+                    and connection.role == Role.PERIPHERAL
                 ):
-                    pending_connection.set_result(connection)
+                    connections.put_nowait(connection)
 
-            self.device.on('connection', on_connection)
+            self.device.on(self.device.EVENT_CONNECTION, on_connection)
 
         try:
             while True:
@@ -510,19 +510,15 @@ class HostService(HostServicer):
                     await self.device.start_advertising(
                         target=target,
                         advertising_type=advertising_type,
-                        own_address_type=request.own_address_type,
+                        own_address_type=OwnAddressType(request.own_address_type),
                     )
 
                 if not request.connectable:
                     await asyncio.sleep(1)
                     continue
 
-                pending_connection: asyncio.Future[bumble.device.Connection] = (
-                    asyncio.get_running_loop().create_future()
-                )
-
                 self.log.debug('Wait for LE connection...')
-                connection = await pending_connection
+                connection = await connections.get()
 
                 self.log.debug(
                     f"Advertise: Connected to {connection.peer_address} (handle={connection.handle})"
@@ -535,11 +531,13 @@ class HostService(HostServicer):
                 await asyncio.sleep(1)
         finally:
             if request.connectable:
-                self.device.remove_listener('connection', on_connection)  # type: ignore
+                self.device.remove_listener(self.device.EVENT_CONNECTION, on_connection)  # type: ignore
 
             try:
                 self.log.debug('Stop advertising')
-                await self.device.abort_on('flush', self.device.stop_advertising())
+                await bumble.utils.cancel_on_event(
+                    self.device, 'flush', self.device.stop_advertising()
+                )
             except:
                 pass
 
@@ -559,11 +557,11 @@ class HostService(HostServicer):
             scanning_phys = [int(Phy.LE_1M), int(Phy.LE_CODED)]
 
         scan_queue: asyncio.Queue[Advertisement] = asyncio.Queue()
-        handler = self.device.on('advertisement', scan_queue.put_nowait)
+        handler = self.device.on(self.device.EVENT_ADVERTISEMENT, scan_queue.put_nowait)
         await self.device.start_scanning(
             legacy=request.legacy,
             active=not request.passive,
-            own_address_type=request.own_address_type,
+            own_address_type=OwnAddressType(request.own_address_type),
             scan_interval=(
                 int(request.interval)
                 if request.interval
@@ -604,10 +602,12 @@ class HostService(HostServicer):
                 yield sr
 
         finally:
-            self.device.remove_listener('advertisement', handler)  # type: ignore
+            self.device.remove_listener(self.device.EVENT_ADVERTISEMENT, handler)  # type: ignore
             try:
                 self.log.debug('Stop scanning')
-                await self.device.abort_on('flush', self.device.stop_scanning())
+                await bumble.utils.cancel_on_event(
+                    self.device, 'flush', self.device.stop_scanning()
+                )
             except:
                 pass
 
@@ -621,10 +621,10 @@ class HostService(HostServicer):
             Optional[Tuple[Address, int, AdvertisingData, int]]
         ] = asyncio.Queue()
         complete_handler = self.device.on(
-            'inquiry_complete', lambda: inquiry_queue.put_nowait(None)
+            self.device.EVENT_INQUIRY_COMPLETE, lambda: inquiry_queue.put_nowait(None)
         )
         result_handler = self.device.on(  # type: ignore
-            'inquiry_result',
+            self.device.EVENT_INQUIRY_RESULT,
             lambda address, class_of_device, eir_data, rssi: inquiry_queue.put_nowait(  # type: ignore
                 (address, class_of_device, eir_data, rssi)  # type: ignore
             ),
@@ -643,11 +643,13 @@ class HostService(HostServicer):
                 )
 
         finally:
-            self.device.remove_listener('inquiry_complete', complete_handler)  # type: ignore
-            self.device.remove_listener('inquiry_result', result_handler)  # type: ignore
+            self.device.remove_listener(self.device.EVENT_INQUIRY_COMPLETE, complete_handler)  # type: ignore
+            self.device.remove_listener(self.device.EVENT_INQUIRY_RESULT, result_handler)  # type: ignore
             try:
                 self.log.debug('Stop inquiry')
-                await self.device.abort_on('flush', self.device.stop_discovery())
+                await bumble.utils.cancel_on_event(
+                    self.device, 'flush', self.device.stop_discovery()
+                )
             except:
                 pass
 
diff --git a/bumble/pandora/l2cap.py b/bumble/pandora/l2cap.py
index 488478c..94b042c 100644
--- a/bumble/pandora/l2cap.py
+++ b/bumble/pandora/l2cap.py
@@ -19,8 +19,8 @@ import logging
 
 from asyncio import Queue as AsyncQueue, Future
 
-from . import utils
-from .config import Config
+from bumble.pandora import utils
+from bumble.pandora.config import Config
 from bumble.core import OutOfResourcesError, InvalidArgumentError
 from bumble.device import Device
 from bumble.l2cap import (
@@ -83,7 +83,7 @@ class L2CAPService(L2CAPServicer):
             close_future.set_result(None)
 
         l2cap_channel.sink = on_channel_sdu
-        l2cap_channel.on('close', on_close)
+        l2cap_channel.on(l2cap_channel.EVENT_CLOSE, on_close)
 
         return ChannelContext(close_future, sdu_queue)
 
@@ -151,7 +151,7 @@ class L2CAPService(L2CAPServicer):
                 spec=spec, handler=on_l2cap_channel
             )
         else:
-            l2cap_server.on('connection', on_l2cap_channel)
+            l2cap_server.on(l2cap_server.EVENT_CONNECTION, on_l2cap_channel)
 
         try:
             self.log.debug('Waiting for a channel connection.')
diff --git a/bumble/pandora/security.py b/bumble/pandora/security.py
index 2cbb78a..1b9f21b 100644
--- a/bumble/pandora/security.py
+++ b/bumble/pandora/security.py
@@ -15,21 +15,21 @@
 from __future__ import annotations
 import asyncio
 import contextlib
+from collections.abc import Awaitable
 import grpc
 import logging
 
-from . import utils
-from .config import Config
+from bumble.pandora import utils
+from bumble.pandora.config import Config
 from bumble import hci
 from bumble.core import (
-    BT_BR_EDR_TRANSPORT,
-    BT_LE_TRANSPORT,
-    BT_PERIPHERAL_ROLE,
+    PhysicalTransport,
     ProtocolError,
+    InvalidArgumentError,
 )
+import bumble.utils
 from bumble.device import Connection as BumbleConnection, Device
-from bumble.hci import HCI_Error
-from bumble.utils import EventWatcher
+from bumble.hci import HCI_Error, Role
 from bumble.pairing import PairingConfig, PairingDelegate as BasePairingDelegate
 from google.protobuf import any_pb2  # pytype: disable=pyi-error
 from google.protobuf import empty_pb2  # pytype: disable=pyi-error
@@ -95,7 +95,7 @@ class PairingDelegate(BasePairingDelegate):
         else:
             # In BR/EDR, connection may not be complete,
             # use address instead
-            assert self.connection.transport == BT_BR_EDR_TRANSPORT
+            assert self.connection.transport == PhysicalTransport.BR_EDR
             ev.address = bytes(reversed(bytes(self.connection.peer_address)))
 
         return ev
@@ -174,7 +174,7 @@ class PairingDelegate(BasePairingDelegate):
 
     async def display_number(self, number: int, digits: int = 6) -> None:
         if (
-            self.connection.transport == BT_BR_EDR_TRANSPORT
+            self.connection.transport == PhysicalTransport.BR_EDR
             and self.io_capability == BasePairingDelegate.DISPLAY_OUTPUT_ONLY
         ):
             return
@@ -190,35 +190,6 @@ class PairingDelegate(BasePairingDelegate):
         self.service.event_queue.put_nowait(event)
 
 
-BR_LEVEL_REACHED: Dict[SecurityLevel, Callable[[BumbleConnection], bool]] = {
-    LEVEL0: lambda connection: True,
-    LEVEL1: lambda connection: connection.encryption == 0 or connection.authenticated,
-    LEVEL2: lambda connection: connection.encryption != 0 and connection.authenticated,
-    LEVEL3: lambda connection: connection.encryption != 0
-    and connection.authenticated
-    and connection.link_key_type
-    in (
-        hci.HCI_AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P_192_TYPE,
-        hci.HCI_AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P_256_TYPE,
-    ),
-    LEVEL4: lambda connection: connection.encryption
-    == hci.HCI_Encryption_Change_Event.AES_CCM
-    and connection.authenticated
-    and connection.link_key_type
-    == hci.HCI_AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P_256_TYPE,
-}
-
-LE_LEVEL_REACHED: Dict[LESecurityLevel, Callable[[BumbleConnection], bool]] = {
-    LE_LEVEL1: lambda connection: True,
-    LE_LEVEL2: lambda connection: connection.encryption != 0,
-    LE_LEVEL3: lambda connection: connection.encryption != 0
-    and connection.authenticated,
-    LE_LEVEL4: lambda connection: connection.encryption != 0
-    and connection.authenticated
-    and connection.sc,
-}
-
-
 class SecurityService(SecurityServicer):
     def __init__(self, device: Device, config: Config) -> None:
         self.log = utils.BumbleServerLoggerAdapter(
@@ -250,6 +221,59 @@ class SecurityService(SecurityServicer):
 
         self.device.pairing_config_factory = pairing_config_factory
 
+    async def _classic_level_reached(
+        self, level: SecurityLevel, connection: BumbleConnection
+    ) -> bool:
+        if level == LEVEL0:
+            return True
+        if level == LEVEL1:
+            return connection.encryption == 0 or connection.authenticated
+        if level == LEVEL2:
+            return connection.encryption != 0 and connection.authenticated
+
+        link_key_type: Optional[int] = None
+        if (keystore := connection.device.keystore) and (
+            keys := await keystore.get(str(connection.peer_address))
+        ):
+            link_key_type = keys.link_key_type
+        self.log.debug("link_key_type: %d", link_key_type)
+
+        if level == LEVEL3:
+            return (
+                connection.encryption != 0
+                and connection.authenticated
+                and link_key_type
+                in (
+                    hci.HCI_AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P_192_TYPE,
+                    hci.HCI_AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P_256_TYPE,
+                )
+            )
+        if level == LEVEL4:
+            return (
+                connection.encryption == hci.HCI_Encryption_Change_Event.AES_CCM
+                and connection.authenticated
+                and link_key_type
+                == hci.HCI_AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P_256_TYPE
+            )
+        raise InvalidArgumentError(f"Unexpected level {level}")
+
+    def _le_level_reached(
+        self, level: LESecurityLevel, connection: BumbleConnection
+    ) -> bool:
+        if level == LE_LEVEL1:
+            return True
+        if level == LE_LEVEL2:
+            return connection.encryption != 0
+        if level == LE_LEVEL3:
+            return connection.encryption != 0 and connection.authenticated
+        if level == LE_LEVEL4:
+            return (
+                connection.encryption != 0
+                and connection.authenticated
+                and connection.sc
+            )
+        raise InvalidArgumentError(f"Unexpected level {level}")
+
     @utils.rpc
     async def OnPairing(
         self, request: AsyncIterator[PairingEventAnswer], context: grpc.ServicerContext
@@ -287,12 +311,12 @@ class SecurityService(SecurityServicer):
 
         oneof = request.WhichOneof('level')
         level = getattr(request, oneof)
-        assert {BT_BR_EDR_TRANSPORT: 'classic', BT_LE_TRANSPORT: 'le'}[
+        assert {PhysicalTransport.BR_EDR: 'classic', PhysicalTransport.LE: 'le'}[
             connection.transport
         ] == oneof
 
         # security level already reached
-        if self.reached_security_level(connection, level):
+        if await self.reached_security_level(connection, level):
             return SecureResponse(success=empty_pb2.Empty())
 
         # trigger pairing if needed
@@ -302,23 +326,23 @@ class SecurityService(SecurityServicer):
 
                 security_result = asyncio.get_running_loop().create_future()
 
-                with contextlib.closing(EventWatcher()) as watcher:
+                with contextlib.closing(bumble.utils.EventWatcher()) as watcher:
 
-                    @watcher.on(connection, 'pairing')
+                    @watcher.on(connection, connection.EVENT_PAIRING)
                     def on_pairing(*_: Any) -> None:
                         security_result.set_result('success')
 
-                    @watcher.on(connection, 'pairing_failure')
+                    @watcher.on(connection, connection.EVENT_PAIRING_FAILURE)
                     def on_pairing_failure(*_: Any) -> None:
                         security_result.set_result('pairing_failure')
 
-                    @watcher.on(connection, 'disconnection')
+                    @watcher.on(connection, connection.EVENT_DISCONNECTION)
                     def on_disconnection(*_: Any) -> None:
                         security_result.set_result('connection_died')
 
                     if (
-                        connection.transport == BT_LE_TRANSPORT
-                        and connection.role == BT_PERIPHERAL_ROLE
+                        connection.transport == PhysicalTransport.LE
+                        and connection.role == Role.PERIPHERAL
                     ):
                         connection.request_pairing()
                     else:
@@ -363,7 +387,7 @@ class SecurityService(SecurityServicer):
                 return SecureResponse(encryption_failure=empty_pb2.Empty())
 
         # security level has been reached ?
-        if self.reached_security_level(connection, level):
+        if await self.reached_security_level(connection, level):
             return SecureResponse(success=empty_pb2.Empty())
         return SecureResponse(not_reached=empty_pb2.Empty())
 
@@ -379,7 +403,7 @@ class SecurityService(SecurityServicer):
 
         assert request.level
         level = request.level
-        assert {BT_BR_EDR_TRANSPORT: 'classic', BT_LE_TRANSPORT: 'le'}[
+        assert {PhysicalTransport.BR_EDR: 'classic', PhysicalTransport.LE: 'le'}[
             connection.transport
         ] == request.level_variant()
 
@@ -390,13 +414,10 @@ class SecurityService(SecurityServicer):
         pair_task: Optional[asyncio.Future[None]] = None
 
         async def authenticate() -> None:
-            assert connection
             if (encryption := connection.encryption) != 0:
                 self.log.debug('Disable encryption...')
-                try:
+                with contextlib.suppress(Exception):
                     await connection.encrypt(enable=False)
-                except:
-                    pass
                 self.log.debug('Disable encryption: done')
 
             self.log.debug('Authenticate...')
@@ -415,19 +436,17 @@ class SecurityService(SecurityServicer):
 
             return wrapper
 
-        def try_set_success(*_: Any) -> None:
-            assert connection
-            if self.reached_security_level(connection, level):
+        async def try_set_success(*_: Any) -> None:
+            if await self.reached_security_level(connection, level):
                 self.log.debug('Wait for security: done')
                 wait_for_security.set_result('success')
 
-        def on_encryption_change(*_: Any) -> None:
-            assert connection
-            if self.reached_security_level(connection, level):
+        async def on_encryption_change(*_: Any) -> None:
+            if await self.reached_security_level(connection, level):
                 self.log.debug('Wait for security: done')
                 wait_for_security.set_result('success')
             elif (
-                connection.transport == BT_BR_EDR_TRANSPORT
+                connection.transport == PhysicalTransport.BR_EDR
                 and self.need_authentication(connection, level)
             ):
                 nonlocal authenticate_task
@@ -438,7 +457,7 @@ class SecurityService(SecurityServicer):
             if self.need_pairing(connection, level):
                 pair_task = asyncio.create_task(connection.pair())
 
-        listeners: Dict[str, Callable[..., None]] = {
+        listeners: Dict[str, Callable[..., Union[None, Awaitable[None]]]] = {
             'disconnection': set_failure('connection_died'),
             'pairing_failure': set_failure('pairing_failure'),
             'connection_authentication_failure': set_failure('authentication_failure'),
@@ -451,13 +470,13 @@ class SecurityService(SecurityServicer):
             'security_request': pair,
         }
 
-        with contextlib.closing(EventWatcher()) as watcher:
+        with contextlib.closing(bumble.utils.EventWatcher()) as watcher:
             # register event handlers
             for event, listener in listeners.items():
                 watcher.on(connection, event, listener)
 
             # security level already reached
-            if self.reached_security_level(connection, level):
+            if await self.reached_security_level(connection, level):
                 return WaitSecurityResponse(success=empty_pb2.Empty())
 
             self.log.debug('Wait for security...')
@@ -467,24 +486,20 @@ class SecurityService(SecurityServicer):
         # wait for `authenticate` to finish if any
         if authenticate_task is not None:
             self.log.debug('Wait for authentication...')
-            try:
+            with contextlib.suppress(Exception):
                 await authenticate_task  # type: ignore
-            except:
-                pass
             self.log.debug('Authenticated')
 
         # wait for `pair` to finish if any
         if pair_task is not None:
             self.log.debug('Wait for authentication...')
-            try:
+            with contextlib.suppress(Exception):
                 await pair_task  # type: ignore
-            except:
-                pass
             self.log.debug('paired')
 
         return WaitSecurityResponse(**kwargs)
 
-    def reached_security_level(
+    async def reached_security_level(
         self, connection: BumbleConnection, level: Union[SecurityLevel, LESecurityLevel]
     ) -> bool:
         self.log.debug(
@@ -494,23 +509,22 @@ class SecurityService(SecurityServicer):
                     'encryption': connection.encryption,
                     'authenticated': connection.authenticated,
                     'sc': connection.sc,
-                    'link_key_type': connection.link_key_type,
                 }
             )
         )
 
         if isinstance(level, LESecurityLevel):
-            return LE_LEVEL_REACHED[level](connection)
+            return self._le_level_reached(level, connection)
 
-        return BR_LEVEL_REACHED[level](connection)
+        return await self._classic_level_reached(level, connection)
 
     def need_pairing(self, connection: BumbleConnection, level: int) -> bool:
-        if connection.transport == BT_LE_TRANSPORT:
+        if connection.transport == PhysicalTransport.LE:
             return level >= LE_LEVEL3 and not connection.authenticated
         return False
 
     def need_authentication(self, connection: BumbleConnection, level: int) -> bool:
-        if connection.transport == BT_LE_TRANSPORT:
+        if connection.transport == PhysicalTransport.LE:
             return False
         if level == LEVEL2 and connection.encryption != 0:
             return not connection.authenticated
@@ -518,7 +532,7 @@ class SecurityService(SecurityServicer):
 
     def need_encryption(self, connection: BumbleConnection, level: int) -> bool:
         # TODO(abel): need to support MITM
-        if connection.transport == BT_LE_TRANSPORT:
+        if connection.transport == PhysicalTransport.LE:
             return level == LE_LEVEL2 and not connection.encryption
         return level >= LEVEL2 and not connection.encryption
 
diff --git a/bumble/pandora/utils.py b/bumble/pandora/utils.py
index fba4b72..a6171a9 100644
--- a/bumble/pandora/utils.py
+++ b/bumble/pandora/utils.py
@@ -20,11 +20,11 @@ import inspect
 import logging
 
 from bumble.device import Device
-from bumble.hci import Address
+from bumble.hci import Address, AddressType
 from google.protobuf.message import Message  # pytype: disable=pyi-error
 from typing import Any, Dict, Generator, MutableMapping, Optional, Tuple
 
-ADDRESS_TYPES: Dict[str, int] = {
+ADDRESS_TYPES: Dict[str, AddressType] = {
     "public": Address.PUBLIC_DEVICE_ADDRESS,
     "random": Address.RANDOM_DEVICE_ADDRESS,
     "public_identity": Address.PUBLIC_IDENTITY_ADDRESS,
diff --git a/bumble/profiles/aics.py b/bumble/profiles/aics.py
index 3a69627..f242435 100644
--- a/bumble/profiles/aics.py
+++ b/bumble/profiles/aics.py
@@ -17,21 +17,20 @@
 # -----------------------------------------------------------------------------
 # Imports
 # -----------------------------------------------------------------------------
+from __future__ import annotations
 import logging
 import struct
 
 from dataclasses import dataclass
 from typing import Optional
 
-from bumble import gatt
 from bumble.device import Connection
 from bumble.att import ATT_Error
 from bumble.gatt import (
+    Attribute,
     Characteristic,
-    DelegatedCharacteristicAdapter,
     TemplateService,
     CharacteristicValue,
-    PackedCharacteristicAdapter,
     GATT_AUDIO_INPUT_CONTROL_SERVICE,
     GATT_AUDIO_INPUT_STATE_CHARACTERISTIC,
     GATT_GAIN_SETTINGS_ATTRIBUTE_CHARACTERISTIC,
@@ -40,8 +39,16 @@ from bumble.gatt import (
     GATT_AUDIO_INPUT_CONTROL_POINT_CHARACTERISTIC,
     GATT_AUDIO_INPUT_DESCRIPTION_CHARACTERISTIC,
 )
+from bumble.gatt_adapters import (
+    CharacteristicProxy,
+    PackedCharacteristicProxyAdapter,
+    SerializableCharacteristicAdapter,
+    SerializableCharacteristicProxyAdapter,
+    UTF8CharacteristicAdapter,
+    UTF8CharacteristicProxyAdapter,
+)
 from bumble.gatt_client import ProfileServiceProxy, ServiceProxy
-from bumble.utils import OpenIntEnum
+from bumble import utils
 
 # -----------------------------------------------------------------------------
 # Logging
@@ -57,7 +64,7 @@ GAIN_SETTINGS_MIN_VALUE = 0
 GAIN_SETTINGS_MAX_VALUE = 255
 
 
-class ErrorCode(OpenIntEnum):
+class ErrorCode(utils.OpenIntEnum):
     '''
     Cf. 1.6 Application error codes
     '''
@@ -69,7 +76,7 @@ class ErrorCode(OpenIntEnum):
     GAIN_MODE_CHANGE_NOT_ALLOWED = 0x84
 
 
-class Mute(OpenIntEnum):
+class Mute(utils.OpenIntEnum):
     '''
     Cf. 2.2.1.2 Mute Field
     '''
@@ -79,7 +86,7 @@ class Mute(OpenIntEnum):
     DISABLED = 0x02
 
 
-class GainMode(OpenIntEnum):
+class GainMode(utils.OpenIntEnum):
     '''
     Cf. 2.2.1.3 Gain Mode
     '''
@@ -90,21 +97,21 @@ class GainMode(OpenIntEnum):
     AUTOMATIC = 0x03
 
 
-class AudioInputStatus(OpenIntEnum):
+class AudioInputStatus(utils.OpenIntEnum):
     '''
     Cf. 3.4 Audio Input Status
     '''
 
-    INATIVE = 0x00
+    INACTIVE = 0x00
     ACTIVE = 0x01
 
 
-class AudioInputControlPointOpCode(OpenIntEnum):
+class AudioInputControlPointOpCode(utils.OpenIntEnum):
     '''
     Cf. 3.5.1 Audio Input Control Point procedure requirements
     '''
 
-    SET_GAIN_SETTING = 0x00
+    SET_GAIN_SETTING = 0x01
     UNMUTE = 0x02
     MUTE = 0x03
     SET_MANUAL_GAIN_MODE = 0x04
@@ -122,7 +129,7 @@ class AudioInputState:
     mute: Mute = Mute.NOT_MUTED
     gain_mode: GainMode = GainMode.MANUAL
     change_counter: int = 0
-    attribute_value: Optional[CharacteristicValue] = None
+    attribute: Optional[Attribute] = None
 
     def __bytes__(self) -> bytes:
         return bytes(
@@ -149,13 +156,8 @@ class AudioInputState:
         self.change_counter = (self.change_counter + 1) % (CHANGE_COUNTER_MAX_VALUE + 1)
 
     async def notify_subscribers_via_connection(self, connection: Connection) -> None:
-        assert self.attribute_value is not None
-        await connection.device.notify_subscribers(
-            attribute=self.attribute_value, value=bytes(self)
-        )
-
-    def on_read(self, _connection: Optional[Connection]) -> bytes:
-        return bytes(self)
+        assert self.attribute is not None
+        await connection.device.notify_subscribers(attribute=self.attribute)
 
 
 @dataclass
@@ -173,7 +175,7 @@ class GainSettingsProperties:
         (gain_settings_unit, gain_settings_minimum, gain_settings_maximum) = (
             struct.unpack('BBB', data)
         )
-        GainSettingsProperties(
+        return GainSettingsProperties(
             gain_settings_unit, gain_settings_minimum, gain_settings_maximum
         )
 
@@ -186,9 +188,6 @@ class GainSettingsProperties:
             ]
         )
 
-    def on_read(self, _connection: Optional[Connection]) -> bytes:
-        return bytes(self)
-
 
 @dataclass
 class AudioInputControlPoint:
@@ -199,8 +198,7 @@ class AudioInputControlPoint:
     audio_input_state: AudioInputState
     gain_settings_properties: GainSettingsProperties
 
-    async def on_write(self, connection: Optional[Connection], value: bytes) -> None:
-        assert connection
+    async def on_write(self, connection: Connection, value: bytes) -> None:
 
         opcode = AudioInputControlPointOpCode(value[0])
 
@@ -239,7 +237,7 @@ class AudioInputControlPoint:
             or gain_settings_operand
             > self.gain_settings_properties.gain_settings_maximum
         ):
-            logger.error("gain_seetings value out of range")
+            logger.error("gain_settings value out of range")
             raise ATT_Error(ErrorCode.VALUE_OUT_OF_RANGE)
 
         if self.audio_input_state.gain_settings != gain_settings_operand:
@@ -319,31 +317,27 @@ class AudioInputDescription:
     '''
 
     audio_input_description: str = "Bluetooth"
-    attribute_value: Optional[CharacteristicValue] = None
-
-    @classmethod
-    def from_bytes(cls, data: bytes):
-        return cls(audio_input_description=data.decode('utf-8'))
+    attribute: Optional[Attribute] = None
 
-    def __bytes__(self) -> bytes:
-        return self.audio_input_description.encode('utf-8')
+    def on_read(self, _connection: Connection) -> str:
+        return self.audio_input_description
 
-    def on_read(self, _connection: Optional[Connection]) -> bytes:
-        return self.audio_input_description.encode('utf-8')
+    async def on_write(self, connection: Connection, value: str) -> None:
+        assert self.attribute
 
-    async def on_write(self, connection: Optional[Connection], value: bytes) -> None:
-        assert connection
-        assert self.attribute_value
-
-        self.audio_input_description = value.decode('utf-8')
-        await connection.device.notify_subscribers(
-            attribute=self.attribute_value, value=value
-        )
+        self.audio_input_description = value
+        await connection.device.notify_subscribers(attribute=self.attribute)
 
 
 class AICSService(TemplateService):
     UUID = GATT_AUDIO_INPUT_CONTROL_SERVICE
 
+    audio_input_state_characteristic: Characteristic[AudioInputState]
+    audio_input_type_characteristic: Characteristic[bytes]
+    audio_input_status_characteristic: Characteristic[bytes]
+    audio_input_control_point_characteristic: Characteristic[bytes]
+    gain_settings_properties_characteristic: Characteristic[GainSettingsProperties]
+
     def __init__(
         self,
         audio_input_state: Optional[AudioInputState] = None,
@@ -375,26 +369,27 @@ class AICSService(TemplateService):
             self.audio_input_state, self.gain_settings_properties
         )
 
-        self.audio_input_state_characteristic = DelegatedCharacteristicAdapter(
+        self.audio_input_state_characteristic = SerializableCharacteristicAdapter(
             Characteristic(
                 uuid=GATT_AUDIO_INPUT_STATE_CHARACTERISTIC,
                 properties=Characteristic.Properties.READ
                 | Characteristic.Properties.NOTIFY,
                 permissions=Characteristic.Permissions.READ_REQUIRES_ENCRYPTION,
-                value=CharacteristicValue(read=self.audio_input_state.on_read),
+                value=self.audio_input_state,
             ),
-            encode=lambda value: bytes(value),
-        )
-        self.audio_input_state.attribute_value = (
-            self.audio_input_state_characteristic.value
+            AudioInputState,
         )
-
-        self.gain_settings_properties_characteristic = DelegatedCharacteristicAdapter(
-            Characteristic(
-                uuid=GATT_GAIN_SETTINGS_ATTRIBUTE_CHARACTERISTIC,
-                properties=Characteristic.Properties.READ,
-                permissions=Characteristic.Permissions.READ_REQUIRES_ENCRYPTION,
-                value=CharacteristicValue(read=self.gain_settings_properties.on_read),
+        self.audio_input_state.attribute = self.audio_input_state_characteristic
+
+        self.gain_settings_properties_characteristic = (
+            SerializableCharacteristicAdapter(
+                Characteristic(
+                    uuid=GATT_GAIN_SETTINGS_ATTRIBUTE_CHARACTERISTIC,
+                    properties=Characteristic.Properties.READ,
+                    permissions=Characteristic.Permissions.READ_REQUIRES_ENCRYPTION,
+                    value=self.gain_settings_properties,
+                ),
+                GainSettingsProperties,
             )
         )
 
@@ -402,7 +397,7 @@ class AICSService(TemplateService):
             uuid=GATT_AUDIO_INPUT_TYPE_CHARACTERISTIC,
             properties=Characteristic.Properties.READ,
             permissions=Characteristic.Permissions.READ_REQUIRES_ENCRYPTION,
-            value=audio_input_type,
+            value=bytes(audio_input_type, 'utf-8'),
         )
 
         self.audio_input_status_characteristic = Characteristic(
@@ -412,18 +407,14 @@ class AICSService(TemplateService):
             value=bytes([self.audio_input_status]),
         )
 
-        self.audio_input_control_point_characteristic = DelegatedCharacteristicAdapter(
-            Characteristic(
-                uuid=GATT_AUDIO_INPUT_CONTROL_POINT_CHARACTERISTIC,
-                properties=Characteristic.Properties.WRITE,
-                permissions=Characteristic.Permissions.WRITE_REQUIRES_ENCRYPTION,
-                value=CharacteristicValue(
-                    write=self.audio_input_control_point.on_write
-                ),
-            )
+        self.audio_input_control_point_characteristic = Characteristic(
+            uuid=GATT_AUDIO_INPUT_CONTROL_POINT_CHARACTERISTIC,
+            properties=Characteristic.Properties.WRITE,
+            permissions=Characteristic.Permissions.WRITE_REQUIRES_ENCRYPTION,
+            value=CharacteristicValue(write=self.audio_input_control_point.on_write),
         )
 
-        self.audio_input_description_characteristic = DelegatedCharacteristicAdapter(
+        self.audio_input_description_characteristic = UTF8CharacteristicAdapter(
             Characteristic(
                 uuid=GATT_AUDIO_INPUT_DESCRIPTION_CHARACTERISTIC,
                 properties=Characteristic.Properties.READ
@@ -437,8 +428,8 @@ class AICSService(TemplateService):
                 ),
             )
         )
-        self.audio_input_description.attribute_value = (
-            self.audio_input_control_point_characteristic.value
+        self.audio_input_description.attribute = (
+            self.audio_input_control_point_characteristic
         )
 
         super().__init__(
@@ -460,61 +451,43 @@ class AICSService(TemplateService):
 class AICSServiceProxy(ProfileServiceProxy):
     SERVICE_CLASS = AICSService
 
+    audio_input_state: CharacteristicProxy[AudioInputState]
+    gain_settings_properties: CharacteristicProxy[GainSettingsProperties]
+    audio_input_status: CharacteristicProxy[int]
+    audio_input_control_point: CharacteristicProxy[bytes]
+
     def __init__(self, service_proxy: ServiceProxy) -> None:
         self.service_proxy = service_proxy
 
-        if not (
-            characteristics := service_proxy.get_characteristics_by_uuid(
+        self.audio_input_state = SerializableCharacteristicProxyAdapter(
+            service_proxy.get_required_characteristic_by_uuid(
                 GATT_AUDIO_INPUT_STATE_CHARACTERISTIC
-            )
-        ):
-            raise gatt.InvalidServiceError("Audio Input State Characteristic not found")
-        self.audio_input_state = DelegatedCharacteristicAdapter(
-            characteristic=characteristics[0], decode=AudioInputState.from_bytes
+            ),
+            AudioInputState,
         )
 
-        if not (
-            characteristics := service_proxy.get_characteristics_by_uuid(
+        self.gain_settings_properties = SerializableCharacteristicProxyAdapter(
+            service_proxy.get_required_characteristic_by_uuid(
                 GATT_GAIN_SETTINGS_ATTRIBUTE_CHARACTERISTIC
-            )
-        ):
-            raise gatt.InvalidServiceError(
-                "Gain Settings Attribute Characteristic not found"
-            )
-        self.gain_settings_properties = PackedCharacteristicAdapter(
-            characteristics[0],
-            'BBB',
+            ),
+            GainSettingsProperties,
         )
 
-        if not (
-            characteristics := service_proxy.get_characteristics_by_uuid(
+        self.audio_input_status = PackedCharacteristicProxyAdapter(
+            service_proxy.get_required_characteristic_by_uuid(
                 GATT_AUDIO_INPUT_STATUS_CHARACTERISTIC
-            )
-        ):
-            raise gatt.InvalidServiceError(
-                "Audio Input Status Characteristic not found"
-            )
-        self.audio_input_status = PackedCharacteristicAdapter(
-            characteristics[0],
+            ),
             'B',
         )
 
-        if not (
-            characteristics := service_proxy.get_characteristics_by_uuid(
+        self.audio_input_control_point = (
+            service_proxy.get_required_characteristic_by_uuid(
                 GATT_AUDIO_INPUT_CONTROL_POINT_CHARACTERISTIC
             )
-        ):
-            raise gatt.InvalidServiceError(
-                "Audio Input Control Point Characteristic not found"
-            )
-        self.audio_input_control_point = characteristics[0]
+        )
 
-        if not (
-            characteristics := service_proxy.get_characteristics_by_uuid(
+        self.audio_input_description = UTF8CharacteristicProxyAdapter(
+            service_proxy.get_required_characteristic_by_uuid(
                 GATT_AUDIO_INPUT_DESCRIPTION_CHARACTERISTIC
             )
-        ):
-            raise gatt.InvalidServiceError(
-                "Audio Input Description Characteristic not found"
-            )
-        self.audio_input_description = characteristics[0]
+        )
diff --git a/bumble/profiles/ancs.py b/bumble/profiles/ancs.py
new file mode 100644
index 0000000..6bf93f1
--- /dev/null
+++ b/bumble/profiles/ancs.py
@@ -0,0 +1,515 @@
+# Copyright 2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""
+Apple Notification Center Service (ANCS).
+"""
+
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
+from __future__ import annotations
+import asyncio
+import dataclasses
+import datetime
+import enum
+import logging
+import struct
+from typing import Optional, Sequence, Union
+
+
+from bumble.att import ATT_Error
+from bumble.device import Peer
+from bumble.gatt import (
+    Characteristic,
+    GATT_ANCS_SERVICE,
+    GATT_ANCS_NOTIFICATION_SOURCE_CHARACTERISTIC,
+    GATT_ANCS_CONTROL_POINT_CHARACTERISTIC,
+    GATT_ANCS_DATA_SOURCE_CHARACTERISTIC,
+    TemplateService,
+)
+from bumble.gatt_client import CharacteristicProxy, ProfileServiceProxy, ServiceProxy
+from bumble.gatt_adapters import SerializableCharacteristicProxyAdapter
+from bumble import utils
+
+
+# -----------------------------------------------------------------------------
+# Constants
+# -----------------------------------------------------------------------------
+_DEFAULT_ATTRIBUTE_MAX_LENGTH = 65535
+
+
+# -----------------------------------------------------------------------------
+# Logging
+# -----------------------------------------------------------------------------
+logger = logging.getLogger(__name__)
+
+
+# -----------------------------------------------------------------------------
+# Protocol
+# -----------------------------------------------------------------------------
+class ActionId(utils.OpenIntEnum):
+    POSITIVE = 0
+    NEGATIVE = 1
+
+
+class AppAttributeId(utils.OpenIntEnum):
+    DISPLAY_NAME = 0
+
+
+class CategoryId(utils.OpenIntEnum):
+    OTHER = 0
+    INCOMING_CALL = 1
+    MISSED_CALL = 2
+    VOICEMAIL = 3
+    SOCIAL = 4
+    SCHEDULE = 5
+    EMAIL = 6
+    NEWS = 7
+    HEALTH_AND_FITNESS = 8
+    BUSINESS_AND_FINANCE = 9
+    LOCATION = 10
+    ENTERTAINMENT = 11
+
+
+class CommandId(utils.OpenIntEnum):
+    GET_NOTIFICATION_ATTRIBUTES = 0
+    GET_APP_ATTRIBUTES = 1
+    PERFORM_NOTIFICATION_ACTION = 2
+
+
+class EventId(utils.OpenIntEnum):
+    NOTIFICATION_ADDED = 0
+    NOTIFICATION_MODIFIED = 1
+    NOTIFICATION_REMOVED = 2
+
+
+class EventFlags(enum.IntFlag):
+    SILENT = 1 << 0
+    IMPORTANT = 1 << 1
+    PRE_EXISTING = 1 << 2
+    POSITIVE_ACTION = 1 << 3
+    NEGATIVE_ACTION = 1 << 4
+
+
+class NotificationAttributeId(utils.OpenIntEnum):
+    APP_IDENTIFIER = 0
+    TITLE = 1
+    SUBTITLE = 2
+    MESSAGE = 3
+    MESSAGE_SIZE = 4
+    DATE = 5
+    POSITIVE_ACTION_LABEL = 6
+    NEGATIVE_ACTION_LABEL = 7
+
+
+@dataclasses.dataclass
+class NotificationAttribute:
+    attribute_id: NotificationAttributeId
+    value: Union[str, int, datetime.datetime]
+
+
+@dataclasses.dataclass
+class AppAttribute:
+    attribute_id: AppAttributeId
+    value: str
+
+
+@dataclasses.dataclass
+class Notification:
+    event_id: EventId
+    event_flags: EventFlags
+    category_id: CategoryId
+    category_count: int
+    notification_uid: int
+
+    @classmethod
+    def from_bytes(cls, data: bytes) -> Notification:
+        return cls(
+            event_id=EventId(data[0]),
+            event_flags=EventFlags(data[1]),
+            category_id=CategoryId(data[2]),
+            category_count=data[3],
+            notification_uid=int.from_bytes(data[4:8], 'little'),
+        )
+
+    def __bytes__(self) -> bytes:
+        return struct.pack(
+            "<BBBBI",
+            self.event_id,
+            self.event_flags,
+            self.category_id,
+            self.category_count,
+            self.notification_uid,
+        )
+
+
+class ErrorCode(utils.OpenIntEnum):
+    UNKNOWN_COMMAND = 0xA0
+    INVALID_COMMAND = 0xA1
+    INVALID_PARAMETER = 0xA2
+    ACTION_FAILED = 0xA3
+
+
+class ProtocolError(Exception):
+    pass
+
+
+class CommandError(Exception):
+    def __init__(self, error_code: ErrorCode) -> None:
+        self.error_code = error_code
+
+    def __str__(self) -> str:
+        return f"CommandError(error_code={self.error_code.name})"
+
+
+# -----------------------------------------------------------------------------
+# GATT Server-side
+# -----------------------------------------------------------------------------
+class Ancs(TemplateService):
+    UUID = GATT_ANCS_SERVICE
+
+    notification_source_characteristic: Characteristic
+    data_source_characteristic: Characteristic
+    control_point_characteristic: Characteristic
+
+    def __init__(self) -> None:
+        # TODO not the final implementation
+        self.notification_source_characteristic = Characteristic(
+            GATT_ANCS_NOTIFICATION_SOURCE_CHARACTERISTIC,
+            Characteristic.Properties.NOTIFY,
+            Characteristic.Permissions.READABLE,
+        )
+
+        # TODO not the final implementation
+        self.data_source_characteristic = Characteristic(
+            GATT_ANCS_DATA_SOURCE_CHARACTERISTIC,
+            Characteristic.Properties.NOTIFY,
+            Characteristic.Permissions.READABLE,
+        )
+
+        # TODO not the final implementation
+        self.control_point_characteristic = Characteristic(
+            GATT_ANCS_CONTROL_POINT_CHARACTERISTIC,
+            Characteristic.Properties.WRITE,
+            Characteristic.Permissions.WRITEABLE,
+        )
+
+        super().__init__(
+            [
+                self.notification_source_characteristic,
+                self.data_source_characteristic,
+                self.control_point_characteristic,
+            ]
+        )
+
+
+# -----------------------------------------------------------------------------
+# GATT Client-side
+# -----------------------------------------------------------------------------
+class AncsProxy(ProfileServiceProxy):
+    SERVICE_CLASS = Ancs
+
+    notification_source: CharacteristicProxy[Notification]
+    data_source: CharacteristicProxy
+    control_point: CharacteristicProxy[bytes]
+
+    def __init__(self, service_proxy: ServiceProxy):
+        self.notification_source = SerializableCharacteristicProxyAdapter(
+            service_proxy.get_required_characteristic_by_uuid(
+                GATT_ANCS_NOTIFICATION_SOURCE_CHARACTERISTIC
+            ),
+            Notification,
+        )
+
+        self.data_source = service_proxy.get_required_characteristic_by_uuid(
+            GATT_ANCS_DATA_SOURCE_CHARACTERISTIC
+        )
+
+        self.control_point = service_proxy.get_required_characteristic_by_uuid(
+            GATT_ANCS_CONTROL_POINT_CHARACTERISTIC
+        )
+
+
+class AncsClient(utils.EventEmitter):
+    _expected_response_command_id: Optional[CommandId]
+    _expected_response_notification_uid: Optional[int]
+    _expected_response_app_identifier: Optional[str]
+    _expected_app_identifier: Optional[str]
+    _expected_response_tuples: int
+    _response_accumulator: bytes
+
+    EVENT_NOTIFICATION = "notification"
+
+    def __init__(self, ancs_proxy: AncsProxy) -> None:
+        super().__init__()
+        self._ancs_proxy = ancs_proxy
+        self._command_semaphore = asyncio.Semaphore()
+        self._response: Optional[asyncio.Future] = None
+        self._reset_response()
+        self._started = False
+
+    @classmethod
+    async def for_peer(cls, peer: Peer) -> Optional[AncsClient]:
+        ancs_proxy = await peer.discover_service_and_create_proxy(AncsProxy)
+        if ancs_proxy is None:
+            return None
+        return cls(ancs_proxy)
+
+    async def start(self) -> None:
+        await self._ancs_proxy.notification_source.subscribe(self._on_notification)
+        await self._ancs_proxy.data_source.subscribe(self._on_data)
+        self._started = True
+
+    async def stop(self) -> None:
+        await self._ancs_proxy.notification_source.unsubscribe(self._on_notification)
+        await self._ancs_proxy.data_source.unsubscribe(self._on_data)
+        self._started = False
+
+    def _reset_response(self) -> None:
+        self._expected_response_command_id = None
+        self._expected_response_notification_uid = None
+        self._expected_app_identifier = None
+        self._expected_response_tuples = 0
+        self._response_accumulator = b""
+
+    def _on_notification(self, notification: Notification) -> None:
+        logger.debug(f"ANCS NOTIFICATION: {notification}")
+        self.emit(self.EVENT_NOTIFICATION, notification)
+
+    def _on_data(self, data: bytes) -> None:
+        logger.debug(f"ANCS DATA: {data.hex()}")
+
+        if not self._response:
+            logger.warning("received unexpected data, discarding")
+            return
+
+        self._response_accumulator += data
+
+        # Try to parse the accumulated data until we have all we need.
+        if not self._response_accumulator:
+            logger.warning("empty data from data source")
+            return
+
+        command_id = self._response_accumulator[0]
+        if command_id != self._expected_response_command_id:
+            logger.warning(
+                "unexpected response command id: "
+                f"expected {self._expected_response_command_id} "
+                f"but got {command_id}"
+            )
+            self._reset_response()
+            if not self._response.done():
+                self._response.set_exception(ProtocolError())
+
+        if len(self._response_accumulator) < 5:
+            # Not enough data yet.
+            return
+
+        attributes: list[Union[NotificationAttribute, AppAttribute]] = []
+
+        if command_id == CommandId.GET_NOTIFICATION_ATTRIBUTES:
+            (notification_uid,) = struct.unpack_from(
+                "<I", self._response_accumulator, 1
+            )
+            if notification_uid != self._expected_response_notification_uid:
+                logger.warning(
+                    "unexpected response notification uid: "
+                    f"expected {self._expected_response_notification_uid} "
+                    f"but got {notification_uid}"
+                )
+                self._reset_response()
+                if not self._response.done():
+                    self._response.set_exception(ProtocolError())
+
+            attribute_data = self._response_accumulator[5:]
+            while len(attribute_data) >= 3:
+                attribute_id, attribute_data_length = struct.unpack_from(
+                    "<BH", attribute_data, 0
+                )
+                if len(attribute_data) < 3 + attribute_data_length:
+                    return
+                str_value = attribute_data[3 : 3 + attribute_data_length].decode(
+                    "utf-8"
+                )
+                value: Union[str, int, datetime.datetime]
+                if attribute_id == NotificationAttributeId.MESSAGE_SIZE:
+                    value = int(str_value)
+                elif attribute_id == NotificationAttributeId.DATE:
+                    year = int(str_value[:4])
+                    month = int(str_value[4:6])
+                    day = int(str_value[6:8])
+                    hour = int(str_value[9:11])
+                    minute = int(str_value[11:13])
+                    second = int(str_value[13:15])
+                    value = datetime.datetime(year, month, day, hour, minute, second)
+                else:
+                    value = str_value
+                attributes.append(
+                    NotificationAttribute(NotificationAttributeId(attribute_id), value)
+                )
+                attribute_data = attribute_data[3 + attribute_data_length :]
+        elif command_id == CommandId.GET_APP_ATTRIBUTES:
+            if 0 not in self._response_accumulator[1:]:
+                # No null-terminated string yet.
+                return
+
+            app_identifier_length = self._response_accumulator.find(0, 1) - 1
+            app_identifier = self._response_accumulator[
+                1 : 1 + app_identifier_length
+            ].decode("utf-8")
+            if app_identifier != self._expected_response_app_identifier:
+                logger.warning(
+                    "unexpected response app identifier: "
+                    f"expected {self._expected_response_app_identifier} "
+                    f"but got {app_identifier}"
+                )
+                self._reset_response()
+                if not self._response.done():
+                    self._response.set_exception(ProtocolError())
+
+            attribute_data = self._response_accumulator[1 + app_identifier_length + 1 :]
+            while len(attribute_data) >= 3:
+                attribute_id, attribute_data_length = struct.unpack_from(
+                    "<BH", attribute_data, 0
+                )
+                if len(attribute_data) < 3 + attribute_data_length:
+                    return
+                attributes.append(
+                    AppAttribute(
+                        AppAttributeId(attribute_id),
+                        attribute_data[3 : 3 + attribute_data_length].decode("utf-8"),
+                    )
+                )
+                attribute_data = attribute_data[3 + attribute_data_length :]
+        else:
+            logger.warning(f"unexpected response command id {command_id}")
+            return
+
+        if len(attributes) < self._expected_response_tuples:
+            # We have not received all the tuples yet.
+            return
+
+        if not self._response.done():
+            self._response.set_result(attributes)
+
+    async def _send_command(self, command: bytes) -> None:
+        try:
+            await self._ancs_proxy.control_point.write_value(
+                command, with_response=True
+            )
+        except ATT_Error as error:
+            raise CommandError(error_code=ErrorCode(error.error_code)) from error
+
+    async def get_notification_attributes(
+        self,
+        notification_uid: int,
+        attributes: Sequence[
+            Union[NotificationAttributeId, tuple[NotificationAttributeId, int]]
+        ],
+    ) -> list[NotificationAttribute]:
+        if not self._started:
+            raise RuntimeError("client not started")
+
+        command = struct.pack(
+            "<BI", CommandId.GET_NOTIFICATION_ATTRIBUTES, notification_uid
+        )
+        for attribute in attributes:
+            attribute_max_length = 0
+            if isinstance(attribute, tuple):
+                attribute_id, attribute_max_length = attribute
+                if attribute_id not in (
+                    NotificationAttributeId.TITLE,
+                    NotificationAttributeId.SUBTITLE,
+                    NotificationAttributeId.MESSAGE,
+                ):
+                    raise ValueError(
+                        "this attribute does not allow specifying a max length"
+                    )
+            else:
+                attribute_id = attribute
+                if attribute_id in (
+                    NotificationAttributeId.TITLE,
+                    NotificationAttributeId.SUBTITLE,
+                    NotificationAttributeId.MESSAGE,
+                ):
+                    attribute_max_length = _DEFAULT_ATTRIBUTE_MAX_LENGTH
+
+            if attribute_max_length:
+                command += struct.pack("<BH", attribute_id, attribute_max_length)
+            else:
+                command += struct.pack("B", attribute_id)
+
+        try:
+            async with self._command_semaphore:
+                self._expected_response_notification_uid = notification_uid
+                self._expected_response_tuples = len(attributes)
+                self._expected_response_command_id = (
+                    CommandId.GET_NOTIFICATION_ATTRIBUTES
+                )
+                self._response = asyncio.Future()
+
+                # Send the command.
+                await self._send_command(command)
+
+                # Wait for the response.
+                return await self._response
+        finally:
+            self._reset_response()
+
+    async def get_app_attributes(
+        self, app_identifier: str, attributes: Sequence[AppAttributeId]
+    ) -> list[AppAttribute]:
+        if not self._started:
+            raise RuntimeError("client not started")
+
+        command = (
+            bytes([CommandId.GET_APP_ATTRIBUTES])
+            + app_identifier.encode("utf-8")
+            + b"\0"
+        )
+        for attribute_id in attributes:
+            command += struct.pack("B", attribute_id)
+
+        try:
+            async with self._command_semaphore:
+                self._expected_response_app_identifier = app_identifier
+                self._expected_response_tuples = len(attributes)
+                self._expected_response_command_id = CommandId.GET_APP_ATTRIBUTES
+                self._response = asyncio.Future()
+
+                # Send the command.
+                await self._send_command(command)
+
+                # Wait for the response.
+                return await self._response
+        finally:
+            self._reset_response()
+
+    async def perform_action(self, notification_uid: int, action: ActionId) -> None:
+        if not self._started:
+            raise RuntimeError("client not started")
+
+        command = struct.pack(
+            "<BIB", CommandId.PERFORM_NOTIFICATION_ACTION, notification_uid, action
+        )
+
+        async with self._command_semaphore:
+            await self._send_command(command)
+
+    async def perform_positive_action(self, notification_uid: int) -> None:
+        return await self.perform_action(notification_uid, ActionId.POSITIVE)
+
+    async def perform_negative_action(self, notification_uid: int) -> None:
+        return await self.perform_action(notification_uid, ActionId.NEGATIVE)
diff --git a/bumble/profiles/ascs.py b/bumble/profiles/ascs.py
index 35f4594..a8bdce3 100644
--- a/bumble/profiles/ascs.py
+++ b/bumble/profiles/ascs.py
@@ -17,11 +17,13 @@
 # Imports
 # -----------------------------------------------------------------------------
 from __future__ import annotations
+
 import enum
 import logging
 import struct
 from typing import Any, Dict, List, Optional, Sequence, Tuple, Type, Union
 
+from bumble import utils
 from bumble import colors
 from bumble.profiles.bap import CodecSpecificConfiguration
 from bumble.profiles import le_audio
@@ -258,8 +260,8 @@ class AseReasonCode(enum.IntEnum):
 
 # -----------------------------------------------------------------------------
 class AudioRole(enum.IntEnum):
-    SINK = hci.HCI_LE_Setup_ISO_Data_Path_Command.Direction.CONTROLLER_TO_HOST
-    SOURCE = hci.HCI_LE_Setup_ISO_Data_Path_Command.Direction.HOST_TO_CONTROLLER
+    SINK = device.CisLink.Direction.CONTROLLER_TO_HOST
+    SOURCE = device.CisLink.Direction.HOST_TO_CONTROLLER
 
 
 # -----------------------------------------------------------------------------
@@ -274,6 +276,8 @@ class AseStateMachine(gatt.Characteristic):
         DISABLING        = 0x05
         RELEASING        = 0x06
 
+    EVENT_STATE_CHANGE = "state_change"
+
     cis_link: Optional[device.CisLink] = None
 
     # Additional parameters in CODEC_CONFIGURED State
@@ -300,7 +304,7 @@ class AseStateMachine(gatt.Characteristic):
     presentation_delay = 0
 
     # Additional parameters in ENABLING, STREAMING, DISABLING State
-    metadata = le_audio.Metadata()
+    metadata: le_audio.Metadata
 
     def __init__(
         self,
@@ -312,6 +316,7 @@ class AseStateMachine(gatt.Characteristic):
         self.ase_id = ase_id
         self._state = AseStateMachine.State.IDLE
         self.role = role
+        self.metadata = le_audio.Metadata()
 
         uuid = (
             gatt.GATT_SINK_ASE_CHARACTERISTIC
@@ -326,8 +331,12 @@ class AseStateMachine(gatt.Characteristic):
             value=gatt.CharacteristicValue(read=self.on_read),
         )
 
-        self.service.device.on('cis_request', self.on_cis_request)
-        self.service.device.on('cis_establishment', self.on_cis_establishment)
+        self.service.device.on(
+            self.service.device.EVENT_CIS_REQUEST, self.on_cis_request
+        )
+        self.service.device.on(
+            self.service.device.EVENT_CIS_ESTABLISHMENT, self.on_cis_establishment
+        )
 
     def on_cis_request(
         self,
@@ -341,8 +350,10 @@ class AseStateMachine(gatt.Characteristic):
             and cis_id == self.cis_id
             and self.state == self.State.ENABLING
         ):
-            acl_connection.abort_on(
-                'flush', self.service.device.accept_cis_request(cis_handle)
+            utils.cancel_on_event(
+                acl_connection,
+                'flush',
+                self.service.device.accept_cis_request(cis_handle),
             )
 
     def on_cis_establishment(self, cis_link: device.CisLink) -> None:
@@ -351,24 +362,17 @@ class AseStateMachine(gatt.Characteristic):
             and cis_link.cis_id == self.cis_id
             and self.state == self.State.ENABLING
         ):
-            cis_link.on('disconnection', self.on_cis_disconnection)
+            cis_link.on(cis_link.EVENT_DISCONNECTION, self.on_cis_disconnection)
 
             async def post_cis_established():
-                await self.service.device.send_command(
-                    hci.HCI_LE_Setup_ISO_Data_Path_Command(
-                        connection_handle=cis_link.handle,
-                        data_path_direction=self.role,
-                        data_path_id=0x00,  # Fixed HCI
-                        codec_id=hci.CodingFormat(hci.CodecID.TRANSPARENT),
-                        controller_delay=0,
-                        codec_configuration=b'',
-                    )
-                )
+                await cis_link.setup_data_path(direction=self.role)
                 if self.role == AudioRole.SINK:
                     self.state = self.State.STREAMING
                 await self.service.device.notify_subscribers(self, self.value)
 
-            cis_link.acl_connection.abort_on('flush', post_cis_established())
+            utils.cancel_on_event(
+                cis_link.acl_connection, 'flush', post_cis_established()
+            )
             self.cis_link = cis_link
 
     def on_cis_disconnection(self, _reason) -> None:
@@ -511,16 +515,12 @@ class AseStateMachine(gatt.Characteristic):
         self.state = self.State.RELEASING
 
         async def remove_cis_async():
-            await self.service.device.send_command(
-                hci.HCI_LE_Remove_ISO_Data_Path_Command(
-                    connection_handle=self.cis_link.handle,
-                    data_path_direction=self.role,
-                )
-            )
+            if self.cis_link:
+                await self.cis_link.remove_data_path([self.role])
             self.state = self.State.IDLE
             await self.service.device.notify_subscribers(self, self.value)
 
-        self.service.device.abort_on('flush', remove_cis_async())
+        utils.cancel_on_event(self.service.device, 'flush', remove_cis_async())
         return (AseResponseCode.SUCCESS, AseReasonCode.NONE)
 
     @property
@@ -531,7 +531,7 @@ class AseStateMachine(gatt.Characteristic):
     def state(self, new_state: State) -> None:
         logger.debug(f'{self} state change -> {colors.color(new_state.name, "cyan")}')
         self._state = new_state
-        self.emit('state_change')
+        self.emit(self.EVENT_STATE_CHANGE)
 
     @property
     def value(self):
@@ -590,7 +590,7 @@ class AseStateMachine(gatt.Characteristic):
         # Readonly. Do nothing in the setter.
         pass
 
-    def on_read(self, _: Optional[device.Connection]) -> bytes:
+    def on_read(self, _: device.Connection) -> bytes:
         return self.value
 
     def __str__(self) -> str:
@@ -605,7 +605,7 @@ class AudioStreamControlService(gatt.TemplateService):
     UUID = gatt.GATT_AUDIO_STREAM_CONTROL_SERVICE
 
     ase_state_machines: Dict[int, AseStateMachine]
-    ase_control_point: gatt.Characteristic
+    ase_control_point: gatt.Characteristic[bytes]
     _active_client: Optional[device.Connection] = None
 
     def __init__(
@@ -702,7 +702,8 @@ class AudioStreamControlService(gatt.TemplateService):
         control_point_notification = bytes(
             [operation.op_code, len(responses)]
         ) + b''.join(map(bytes, responses))
-        self.device.abort_on(
+        utils.cancel_on_event(
+            self.device,
             'flush',
             self.device.notify_subscribers(
                 self.ase_control_point, control_point_notification
@@ -711,7 +712,8 @@ class AudioStreamControlService(gatt.TemplateService):
 
         for ase_id, *_ in responses:
             if ase := self.ase_state_machines.get(ase_id):
-                self.device.abort_on(
+                utils.cancel_on_event(
+                    self.device,
                     'flush',
                     self.device.notify_subscribers(ase, ase.value),
                 )
@@ -721,9 +723,9 @@ class AudioStreamControlService(gatt.TemplateService):
 class AudioStreamControlServiceProxy(gatt_client.ProfileServiceProxy):
     SERVICE_CLASS = AudioStreamControlService
 
-    sink_ase: List[gatt_client.CharacteristicProxy]
-    source_ase: List[gatt_client.CharacteristicProxy]
-    ase_control_point: gatt_client.CharacteristicProxy
+    sink_ase: List[gatt_client.CharacteristicProxy[bytes]]
+    source_ase: List[gatt_client.CharacteristicProxy[bytes]]
+    ase_control_point: gatt_client.CharacteristicProxy[bytes]
 
     def __init__(self, service_proxy: gatt_client.ServiceProxy):
         self.service_proxy = service_proxy
diff --git a/bumble/profiles/asha.py b/bumble/profiles/asha.py
index b2aa441..1a8f498 100644
--- a/bumble/profiles/asha.py
+++ b/bumble/profiles/asha.py
@@ -88,6 +88,11 @@ class AudioStatus(utils.OpenIntEnum):
 class AshaService(gatt.TemplateService):
     UUID = gatt.GATT_ASHA_SERVICE
 
+    EVENT_STARTED = "started"
+    EVENT_STOPPED = "stopped"
+    EVENT_DISCONNECTED = "disconnected"
+    EVENT_VOLUME_CHANGED = "volume_changed"
+
     audio_sink: Optional[Callable[[bytes], Any]]
     active_codec: Optional[Codec] = None
     audio_type: Optional[AudioType] = None
@@ -134,12 +139,14 @@ class AshaService(gatt.TemplateService):
             ),
         )
 
-        self.audio_control_point_characteristic = gatt.Characteristic(
-            gatt.GATT_ASHA_AUDIO_CONTROL_POINT_CHARACTERISTIC,
-            gatt.Characteristic.Properties.WRITE
-            | gatt.Characteristic.Properties.WRITE_WITHOUT_RESPONSE,
-            gatt.Characteristic.WRITEABLE,
-            gatt.CharacteristicValue(write=self._on_audio_control_point_write),
+        self.audio_control_point_characteristic: gatt.Characteristic[bytes] = (
+            gatt.Characteristic(
+                gatt.GATT_ASHA_AUDIO_CONTROL_POINT_CHARACTERISTIC,
+                gatt.Characteristic.Properties.WRITE
+                | gatt.Characteristic.Properties.WRITE_WITHOUT_RESPONSE,
+                gatt.Characteristic.WRITEABLE,
+                gatt.CharacteristicValue(write=self._on_audio_control_point_write),
+            )
         )
         self.audio_status_characteristic = gatt.Characteristic(
             gatt.GATT_ASHA_AUDIO_STATUS_CHARACTERISTIC,
@@ -147,7 +154,7 @@ class AshaService(gatt.TemplateService):
             gatt.Characteristic.READABLE,
             bytes([AudioStatus.OK]),
         )
-        self.volume_characteristic = gatt.Characteristic(
+        self.volume_characteristic: gatt.Characteristic[bytes] = gatt.Characteristic(
             gatt.GATT_ASHA_VOLUME_CHARACTERISTIC,
             gatt.Characteristic.Properties.WRITE_WITHOUT_RESPONSE,
             gatt.Characteristic.WRITEABLE,
@@ -166,13 +173,13 @@ class AshaService(gatt.TemplateService):
             struct.pack('<H', self.psm),
         )
 
-        characteristics = [
+        characteristics = (
             self.read_only_properties_characteristic,
             self.audio_control_point_characteristic,
             self.audio_status_characteristic,
             self.volume_characteristic,
             self.le_psm_out_characteristic,
-        ]
+        )
 
         super().__init__(characteristics)
 
@@ -193,7 +200,7 @@ class AshaService(gatt.TemplateService):
 
     # Handler for audio control commands
     async def _on_audio_control_point_write(
-        self, connection: Optional[Connection], value: bytes
+        self, connection: Connection, value: bytes
     ) -> None:
         _logger.debug(f'--- AUDIO CONTROL POINT Write:{value.hex()}')
         opcode = value[0]
@@ -209,14 +216,14 @@ class AshaService(gatt.TemplateService):
                 f'volume={self.volume}, '
                 f'other_state={self.other_state}'
             )
-            self.emit('started')
+            self.emit(self.EVENT_STARTED)
         elif opcode == OpCode.STOP:
             _logger.debug('### STOP')
             self.active_codec = None
             self.audio_type = None
             self.volume = None
             self.other_state = None
-            self.emit('stopped')
+            self.emit(self.EVENT_STOPPED)
         elif opcode == OpCode.STATUS:
             _logger.debug('### STATUS: %s', PeripheralStatus(value[1]).name)
 
@@ -229,7 +236,7 @@ class AshaService(gatt.TemplateService):
                 self.audio_type = None
                 self.volume = None
                 self.other_state = None
-                self.emit('disconnected')
+                self.emit(self.EVENT_DISCONNECTED)
 
             connection.once('disconnection', on_disconnection)
 
@@ -240,10 +247,10 @@ class AshaService(gatt.TemplateService):
             )
 
     # Handler for volume control
-    def _on_volume_write(self, connection: Optional[Connection], value: bytes) -> None:
+    def _on_volume_write(self, connection: Connection, value: bytes) -> None:
         _logger.debug(f'--- VOLUME Write:{value[0]}')
         self.volume = value[0]
-        self.emit('volume_changed')
+        self.emit(self.EVENT_VOLUME_CHANGED)
 
     # Register an L2CAP CoC server
     def _on_connection(self, channel: l2cap.LeCreditBasedChannel) -> None:
@@ -257,11 +264,11 @@ class AshaService(gatt.TemplateService):
 # -----------------------------------------------------------------------------
 class AshaServiceProxy(gatt_client.ProfileServiceProxy):
     SERVICE_CLASS = AshaService
-    read_only_properties_characteristic: gatt_client.CharacteristicProxy
-    audio_control_point_characteristic: gatt_client.CharacteristicProxy
-    audio_status_point_characteristic: gatt_client.CharacteristicProxy
-    volume_characteristic: gatt_client.CharacteristicProxy
-    psm_characteristic: gatt_client.CharacteristicProxy
+    read_only_properties_characteristic: gatt_client.CharacteristicProxy[bytes]
+    audio_control_point_characteristic: gatt_client.CharacteristicProxy[bytes]
+    audio_status_point_characteristic: gatt_client.CharacteristicProxy[bytes]
+    volume_characteristic: gatt_client.CharacteristicProxy[bytes]
+    psm_characteristic: gatt_client.CharacteristicProxy[bytes]
 
     def __init__(self, service_proxy: gatt_client.ServiceProxy) -> None:
         self.service_proxy = service_proxy
@@ -288,8 +295,8 @@ class AshaServiceProxy(gatt_client.ProfileServiceProxy):
                 'psm_characteristic',
             ),
         ):
-            if not (
-                characteristics := self.service_proxy.get_characteristics_by_uuid(uuid)
-            ):
-                raise gatt.InvalidServiceError(f"Missing {uuid} Characteristic")
-            setattr(self, attribute_name, characteristics[0])
+            setattr(
+                self,
+                attribute_name,
+                self.service_proxy.get_required_characteristic_by_uuid(uuid),
+            )
diff --git a/bumble/profiles/bap.py b/bumble/profiles/bap.py
index 8a00eaf..fb1afa6 100644
--- a/bumble/profiles/bap.py
+++ b/bumble/profiles/bap.py
@@ -102,6 +102,7 @@ class ContextType(enum.IntFlag):
 
     # fmt: off
     PROHIBITED       = 0x0000
+    UNSPECIFIED      = 0x0001
     CONVERSATIONAL   = 0x0002
     MEDIA            = 0x0004
     GAME             = 0x0008
@@ -264,7 +265,7 @@ class UnicastServerAdvertisingData:
                         core.AdvertisingData.SERVICE_DATA_16_BIT_UUID,
                         struct.pack(
                             '<2sBIB',
-                            gatt.GATT_AUDIO_STREAM_CONTROL_SERVICE.to_bytes(),
+                            bytes(gatt.GATT_AUDIO_STREAM_CONTROL_SERVICE),
                             self.announcement_type,
                             self.available_audio_contexts,
                             len(self.metadata),
@@ -350,6 +351,7 @@ class CodecSpecificCapabilities:
                 supported_max_codec_frames_per_sdu = value
 
         # It is expected here that if some fields are missing, an error should be raised.
+        # pylint: disable=possibly-used-before-assignment,used-before-assignment
         return CodecSpecificCapabilities(
             supported_sampling_frequencies=supported_sampling_frequencies,
             supported_frame_durations=supported_frame_durations,
@@ -396,18 +398,21 @@ class CodecSpecificConfiguration:
         OCTETS_PER_FRAME         = 0x04
         CODEC_FRAMES_PER_SDU     = 0x05
 
-    sampling_frequency: SamplingFrequency
-    frame_duration: FrameDuration
-    audio_channel_allocation: AudioLocation
-    octets_per_codec_frame: int
-    codec_frames_per_sdu: int
+    sampling_frequency: SamplingFrequency | None = None
+    frame_duration: FrameDuration | None = None
+    audio_channel_allocation: AudioLocation | None = None
+    octets_per_codec_frame: int | None = None
+    codec_frames_per_sdu: int | None = None
 
     @classmethod
     def from_bytes(cls, data: bytes) -> CodecSpecificConfiguration:
         offset = 0
-        # Allowed default values.
-        audio_channel_allocation = AudioLocation.NOT_ALLOWED
-        codec_frames_per_sdu = 1
+        sampling_frequency: SamplingFrequency | None = None
+        frame_duration: FrameDuration | None = None
+        audio_channel_allocation: AudioLocation | None = None
+        octets_per_codec_frame: int | None = None
+        codec_frames_per_sdu: int | None = None
+
         while offset < len(data):
             length, type = struct.unpack_from('BB', data, offset)
             offset += 2
@@ -425,7 +430,6 @@ class CodecSpecificConfiguration:
             elif type == CodecSpecificConfiguration.Type.CODEC_FRAMES_PER_SDU:
                 codec_frames_per_sdu = value
 
-        # It is expected here that if some fields are missing, an error should be raised.
         return CodecSpecificConfiguration(
             sampling_frequency=sampling_frequency,
             frame_duration=frame_duration,
@@ -435,23 +439,43 @@ class CodecSpecificConfiguration:
         )
 
     def __bytes__(self) -> bytes:
-        return struct.pack(
-            '<BBBBBBBBIBBHBBB',
-            2,
-            CodecSpecificConfiguration.Type.SAMPLING_FREQUENCY,
-            self.sampling_frequency,
-            2,
-            CodecSpecificConfiguration.Type.FRAME_DURATION,
-            self.frame_duration,
-            5,
-            CodecSpecificConfiguration.Type.AUDIO_CHANNEL_ALLOCATION,
-            self.audio_channel_allocation,
-            3,
-            CodecSpecificConfiguration.Type.OCTETS_PER_FRAME,
-            self.octets_per_codec_frame,
-            2,
-            CodecSpecificConfiguration.Type.CODEC_FRAMES_PER_SDU,
-            self.codec_frames_per_sdu,
+        return b''.join(
+            [
+                struct.pack(fmt, length, tag, value)
+                for fmt, length, tag, value in [
+                    (
+                        '<BBB',
+                        2,
+                        CodecSpecificConfiguration.Type.SAMPLING_FREQUENCY,
+                        self.sampling_frequency,
+                    ),
+                    (
+                        '<BBB',
+                        2,
+                        CodecSpecificConfiguration.Type.FRAME_DURATION,
+                        self.frame_duration,
+                    ),
+                    (
+                        '<BBI',
+                        5,
+                        CodecSpecificConfiguration.Type.AUDIO_CHANNEL_ALLOCATION,
+                        self.audio_channel_allocation,
+                    ),
+                    (
+                        '<BBH',
+                        3,
+                        CodecSpecificConfiguration.Type.OCTETS_PER_FRAME,
+                        self.octets_per_codec_frame,
+                    ),
+                    (
+                        '<BBB',
+                        2,
+                        CodecSpecificConfiguration.Type.CODEC_FRAMES_PER_SDU,
+                        self.codec_frames_per_sdu,
+                    ),
+                ]
+                if value is not None
+            ]
         )
 
 
@@ -463,6 +487,24 @@ class BroadcastAudioAnnouncement:
     def from_bytes(cls, data: bytes) -> Self:
         return cls(int.from_bytes(data[:3], 'little'))
 
+    def __bytes__(self) -> bytes:
+        return self.broadcast_id.to_bytes(3, 'little')
+
+    def get_advertising_data(self) -> bytes:
+        return bytes(
+            core.AdvertisingData(
+                [
+                    (
+                        core.AdvertisingData.SERVICE_DATA_16_BIT_UUID,
+                        (
+                            bytes(gatt.GATT_BROADCAST_AUDIO_ANNOUNCEMENT_SERVICE)
+                            + bytes(self)
+                        ),
+                    )
+                ]
+            )
+        )
+
 
 @dataclasses.dataclass
 class BasicAudioAnnouncement:
@@ -471,26 +513,37 @@ class BasicAudioAnnouncement:
         index: int
         codec_specific_configuration: CodecSpecificConfiguration
 
-    @dataclasses.dataclass
-    class CodecInfo:
-        coding_format: hci.CodecID
-        company_id: int
-        vendor_specific_codec_id: int
-
-        @classmethod
-        def from_bytes(cls, data: bytes) -> Self:
-            coding_format = hci.CodecID(data[0])
-            company_id = int.from_bytes(data[1:3], 'little')
-            vendor_specific_codec_id = int.from_bytes(data[3:5], 'little')
-            return cls(coding_format, company_id, vendor_specific_codec_id)
+        def __bytes__(self) -> bytes:
+            codec_specific_configuration_bytes = bytes(
+                self.codec_specific_configuration
+            )
+            return (
+                bytes([self.index, len(codec_specific_configuration_bytes)])
+                + codec_specific_configuration_bytes
+            )
 
     @dataclasses.dataclass
     class Subgroup:
-        codec_id: BasicAudioAnnouncement.CodecInfo
+        codec_id: hci.CodingFormat
         codec_specific_configuration: CodecSpecificConfiguration
         metadata: le_audio.Metadata
         bis: List[BasicAudioAnnouncement.BIS]
 
+        def __bytes__(self) -> bytes:
+            metadata_bytes = bytes(self.metadata)
+            codec_specific_configuration_bytes = bytes(
+                self.codec_specific_configuration
+            )
+            return (
+                bytes([len(self.bis)])
+                + bytes(self.codec_id)
+                + bytes([len(codec_specific_configuration_bytes)])
+                + codec_specific_configuration_bytes
+                + bytes([len(metadata_bytes)])
+                + metadata_bytes
+                + b''.join(map(bytes, self.bis))
+            )
+
     presentation_delay: int
     subgroups: List[BasicAudioAnnouncement.Subgroup]
 
@@ -502,7 +555,7 @@ class BasicAudioAnnouncement:
         for _ in range(data[3]):
             num_bis = data[offset]
             offset += 1
-            codec_id = cls.CodecInfo.from_bytes(data[offset : offset + 5])
+            codec_id = hci.CodingFormat.from_bytes(data[offset : offset + 5])
             offset += 5
             codec_specific_configuration_length = data[offset]
             offset += 1
@@ -546,3 +599,25 @@ class BasicAudioAnnouncement:
             )
 
         return cls(presentation_delay, subgroups)
+
+    def __bytes__(self) -> bytes:
+        return (
+            self.presentation_delay.to_bytes(3, 'little')
+            + bytes([len(self.subgroups)])
+            + b''.join(map(bytes, self.subgroups))
+        )
+
+    def get_advertising_data(self) -> bytes:
+        return bytes(
+            core.AdvertisingData(
+                [
+                    (
+                        core.AdvertisingData.SERVICE_DATA_16_BIT_UUID,
+                        (
+                            bytes(gatt.GATT_BASIC_AUDIO_ANNOUNCEMENT_SERVICE)
+                            + bytes(self)
+                        ),
+                    )
+                ]
+            )
+        )
diff --git a/bumble/profiles/bass.py b/bumble/profiles/bass.py
index 57531db..67599a0 100644
--- a/bumble/profiles/bass.py
+++ b/bumble/profiles/bass.py
@@ -20,11 +20,12 @@ from __future__ import annotations
 import dataclasses
 import logging
 import struct
-from typing import ClassVar, List, Optional, Sequence
+from typing import ClassVar, Optional, Sequence
 
 from bumble import core
 from bumble import device
 from bumble import gatt
+from bumble import gatt_adapters
 from bumble import gatt_client
 from bumble import hci
 from bumble import utils
@@ -52,7 +53,7 @@ def encode_subgroups(subgroups: Sequence[SubgroupInfo]) -> bytes:
     )
 
 
-def decode_subgroups(data: bytes) -> List[SubgroupInfo]:
+def decode_subgroups(data: bytes) -> list[SubgroupInfo]:
     num_subgroups = data[0]
     offset = 1
     subgroups = []
@@ -273,13 +274,10 @@ class BroadcastReceiveState:
     pa_sync_state: PeriodicAdvertisingSyncState
     big_encryption: BigEncryption
     bad_code: bytes
-    subgroups: List[SubgroupInfo]
+    subgroups: list[SubgroupInfo]
 
     @classmethod
-    def from_bytes(cls, data: bytes) -> Optional[BroadcastReceiveState]:
-        if not data:
-            return None
-
+    def from_bytes(cls, data: bytes) -> BroadcastReceiveState:
         source_id = data[0]
         _, source_address = hci.Address.parse_address_preceded_by_type(data, 2)
         source_adv_sid = data[8]
@@ -356,35 +354,28 @@ class BroadcastAudioScanService(gatt.TemplateService):
 class BroadcastAudioScanServiceProxy(gatt_client.ProfileServiceProxy):
     SERVICE_CLASS = BroadcastAudioScanService
 
-    broadcast_audio_scan_control_point: gatt_client.CharacteristicProxy
-    broadcast_receive_states: List[gatt.DelegatedCharacteristicAdapter]
+    broadcast_audio_scan_control_point: gatt_client.CharacteristicProxy[bytes]
+    broadcast_receive_states: list[
+        gatt_client.CharacteristicProxy[Optional[BroadcastReceiveState]]
+    ]
 
     def __init__(self, service_proxy: gatt_client.ServiceProxy):
         self.service_proxy = service_proxy
 
-        if not (
-            characteristics := service_proxy.get_characteristics_by_uuid(
+        self.broadcast_audio_scan_control_point = (
+            service_proxy.get_required_characteristic_by_uuid(
                 gatt.GATT_BROADCAST_AUDIO_SCAN_CONTROL_POINT_CHARACTERISTIC
             )
-        ):
-            raise gatt.InvalidServiceError(
-                "Broadcast Audio Scan Control Point characteristic not found"
-            )
-        self.broadcast_audio_scan_control_point = characteristics[0]
+        )
 
-        if not (
-            characteristics := service_proxy.get_characteristics_by_uuid(
-                gatt.GATT_BROADCAST_RECEIVE_STATE_CHARACTERISTIC
-            )
-        ):
-            raise gatt.InvalidServiceError(
-                "Broadcast Receive State characteristic not found"
-            )
         self.broadcast_receive_states = [
-            gatt.DelegatedCharacteristicAdapter(
-                characteristic, decode=BroadcastReceiveState.from_bytes
+            gatt_adapters.DelegatedCharacteristicProxyAdapter(
+                characteristic,
+                decode=lambda x: BroadcastReceiveState.from_bytes(x) if x else None,
+            )
+            for characteristic in service_proxy.get_characteristics_by_uuid(
+                gatt.GATT_BROADCAST_RECEIVE_STATE_CHARACTERISTIC
             )
-            for characteristic in characteristics
         ]
 
     async def send_control_point_operation(
diff --git a/bumble/profiles/battery_service.py b/bumble/profiles/battery_service.py
index 211fee0..464bbb5 100644
--- a/bumble/profiles/battery_service.py
+++ b/bumble/profiles/battery_service.py
@@ -16,14 +16,20 @@
 # -----------------------------------------------------------------------------
 # Imports
 # -----------------------------------------------------------------------------
-from ..gatt_client import ProfileServiceProxy
-from ..gatt import (
+from typing import Optional
+
+from bumble.gatt_client import ProfileServiceProxy
+from bumble.gatt import (
     GATT_BATTERY_SERVICE,
     GATT_BATTERY_LEVEL_CHARACTERISTIC,
     TemplateService,
     Characteristic,
     CharacteristicValue,
+)
+from bumble.gatt_client import CharacteristicProxy
+from bumble.gatt_adapters import (
     PackedCharacteristicAdapter,
+    PackedCharacteristicProxyAdapter,
 )
 
 
@@ -32,6 +38,8 @@ class BatteryService(TemplateService):
     UUID = GATT_BATTERY_SERVICE
     BATTERY_LEVEL_FORMAT = 'B'
 
+    battery_level_characteristic: Characteristic[int]
+
     def __init__(self, read_battery_level):
         self.battery_level_characteristic = PackedCharacteristicAdapter(
             Characteristic(
@@ -49,13 +57,15 @@ class BatteryService(TemplateService):
 class BatteryServiceProxy(ProfileServiceProxy):
     SERVICE_CLASS = BatteryService
 
+    battery_level: Optional[CharacteristicProxy[int]]
+
     def __init__(self, service_proxy):
         self.service_proxy = service_proxy
 
         if characteristics := service_proxy.get_characteristics_by_uuid(
             GATT_BATTERY_LEVEL_CHARACTERISTIC
         ):
-            self.battery_level = PackedCharacteristicAdapter(
+            self.battery_level = PackedCharacteristicProxyAdapter(
                 characteristics[0], pack_format=BatteryService.BATTERY_LEVEL_FORMAT
             )
         else:
diff --git a/bumble/profiles/csip.py b/bumble/profiles/csip.py
index 9ba3baf..07eed77 100644
--- a/bumble/profiles/csip.py
+++ b/bumble/profiles/csip.py
@@ -99,10 +99,10 @@ class CoordinatedSetIdentificationService(gatt.TemplateService):
     UUID = gatt.GATT_COORDINATED_SET_IDENTIFICATION_SERVICE
 
     set_identity_resolving_key: bytes
-    set_identity_resolving_key_characteristic: gatt.Characteristic
-    coordinated_set_size_characteristic: Optional[gatt.Characteristic] = None
-    set_member_lock_characteristic: Optional[gatt.Characteristic] = None
-    set_member_rank_characteristic: Optional[gatt.Characteristic] = None
+    set_identity_resolving_key_characteristic: gatt.Characteristic[bytes]
+    coordinated_set_size_characteristic: Optional[gatt.Characteristic[bytes]] = None
+    set_member_lock_characteristic: Optional[gatt.Characteristic[bytes]] = None
+    set_member_rank_characteristic: Optional[gatt.Characteristic[bytes]] = None
 
     def __init__(
         self,
@@ -164,13 +164,11 @@ class CoordinatedSetIdentificationService(gatt.TemplateService):
 
         super().__init__(characteristics)
 
-    async def on_sirk_read(self, connection: Optional[device.Connection]) -> bytes:
+    async def on_sirk_read(self, connection: device.Connection) -> bytes:
         if self.set_identity_resolving_key_type == SirkType.PLAINTEXT:
             sirk_bytes = self.set_identity_resolving_key
         else:
-            assert connection
-
-            if connection.transport == core.BT_LE_TRANSPORT:
+            if connection.transport == core.PhysicalTransport.LE:
                 key = await connection.device.get_long_term_key(
                     connection_handle=connection.handle, rand=b'', ediv=0
                 )
@@ -203,10 +201,10 @@ class CoordinatedSetIdentificationService(gatt.TemplateService):
 class CoordinatedSetIdentificationProxy(gatt_client.ProfileServiceProxy):
     SERVICE_CLASS = CoordinatedSetIdentificationService
 
-    set_identity_resolving_key: gatt_client.CharacteristicProxy
-    coordinated_set_size: Optional[gatt_client.CharacteristicProxy] = None
-    set_member_lock: Optional[gatt_client.CharacteristicProxy] = None
-    set_member_rank: Optional[gatt_client.CharacteristicProxy] = None
+    set_identity_resolving_key: gatt_client.CharacteristicProxy[bytes]
+    coordinated_set_size: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    set_member_lock: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    set_member_rank: Optional[gatt_client.CharacteristicProxy[bytes]] = None
 
     def __init__(self, service_proxy: gatt_client.ServiceProxy) -> None:
         self.service_proxy = service_proxy
@@ -242,7 +240,7 @@ class CoordinatedSetIdentificationProxy(gatt_client.ProfileServiceProxy):
         else:
             connection = self.service_proxy.client.connection
             device = connection.device
-            if connection.transport == core.BT_LE_TRANSPORT:
+            if connection.transport == core.PhysicalTransport.LE:
                 key = await device.get_long_term_key(
                     connection_handle=connection.handle, rand=b'', ediv=0
                 )
diff --git a/bumble/profiles/device_information_service.py b/bumble/profiles/device_information_service.py
index ecb1c0f..25b3475 100644
--- a/bumble/profiles/device_information_service.py
+++ b/bumble/profiles/device_information_service.py
@@ -19,7 +19,6 @@
 import struct
 from typing import Optional, Tuple
 
-from bumble.gatt_client import ServiceProxy, ProfileServiceProxy, CharacteristicProxy
 from bumble.gatt import (
     GATT_DEVICE_INFORMATION_SERVICE,
     GATT_FIRMWARE_REVISION_STRING_CHARACTERISTIC,
@@ -32,9 +31,12 @@ from bumble.gatt import (
     GATT_REGULATORY_CERTIFICATION_DATA_LIST_CHARACTERISTIC,
     TemplateService,
     Characteristic,
-    DelegatedCharacteristicAdapter,
-    UTF8CharacteristicAdapter,
 )
+from bumble.gatt_adapters import (
+    DelegatedCharacteristicProxyAdapter,
+    UTF8CharacteristicProxyAdapter,
+)
+from bumble.gatt_client import CharacteristicProxy, ProfileServiceProxy, ServiceProxy
 
 
 # -----------------------------------------------------------------------------
@@ -62,9 +64,12 @@ class DeviceInformationService(TemplateService):
         ieee_regulatory_certification_data_list: Optional[bytes] = None,
         # TODO: pnp_id
     ):
-        characteristics = [
+        characteristics: list[Characteristic[bytes]] = [
             Characteristic(
-                uuid, Characteristic.Properties.READ, Characteristic.READABLE, field
+                uuid,
+                Characteristic.Properties.READ,
+                Characteristic.READABLE,
+                bytes(field, 'utf-8'),
             )
             for (field, uuid) in (
                 (manufacturer_name, GATT_MANUFACTURER_NAME_STRING_CHARACTERISTIC),
@@ -104,14 +109,14 @@ class DeviceInformationService(TemplateService):
 class DeviceInformationServiceProxy(ProfileServiceProxy):
     SERVICE_CLASS = DeviceInformationService
 
-    manufacturer_name: Optional[UTF8CharacteristicAdapter]
-    model_number: Optional[UTF8CharacteristicAdapter]
-    serial_number: Optional[UTF8CharacteristicAdapter]
-    hardware_revision: Optional[UTF8CharacteristicAdapter]
-    firmware_revision: Optional[UTF8CharacteristicAdapter]
-    software_revision: Optional[UTF8CharacteristicAdapter]
-    system_id: Optional[DelegatedCharacteristicAdapter]
-    ieee_regulatory_certification_data_list: Optional[CharacteristicProxy]
+    manufacturer_name: Optional[CharacteristicProxy[str]]
+    model_number: Optional[CharacteristicProxy[str]]
+    serial_number: Optional[CharacteristicProxy[str]]
+    hardware_revision: Optional[CharacteristicProxy[str]]
+    firmware_revision: Optional[CharacteristicProxy[str]]
+    software_revision: Optional[CharacteristicProxy[str]]
+    system_id: Optional[CharacteristicProxy[tuple[int, int]]]
+    ieee_regulatory_certification_data_list: Optional[CharacteristicProxy[bytes]]
 
     def __init__(self, service_proxy: ServiceProxy):
         self.service_proxy = service_proxy
@@ -125,7 +130,7 @@ class DeviceInformationServiceProxy(ProfileServiceProxy):
             ('software_revision', GATT_SOFTWARE_REVISION_STRING_CHARACTERISTIC),
         ):
             if characteristics := service_proxy.get_characteristics_by_uuid(uuid):
-                characteristic = UTF8CharacteristicAdapter(characteristics[0])
+                characteristic = UTF8CharacteristicProxyAdapter(characteristics[0])
             else:
                 characteristic = None
             self.__setattr__(field, characteristic)
@@ -133,7 +138,7 @@ class DeviceInformationServiceProxy(ProfileServiceProxy):
         if characteristics := service_proxy.get_characteristics_by_uuid(
             GATT_SYSTEM_ID_CHARACTERISTIC
         ):
-            self.system_id = DelegatedCharacteristicAdapter(
+            self.system_id = DelegatedCharacteristicProxyAdapter(
                 characteristics[0],
                 encode=lambda v: DeviceInformationService.pack_system_id(*v),
                 decode=DeviceInformationService.unpack_system_id,
diff --git a/bumble/profiles/gap.py b/bumble/profiles/gap.py
index 0dd6e51..bb13031 100644
--- a/bumble/profiles/gap.py
+++ b/bumble/profiles/gap.py
@@ -25,14 +25,15 @@ from bumble.core import Appearance
 from bumble.gatt import (
     TemplateService,
     Characteristic,
-    CharacteristicAdapter,
-    DelegatedCharacteristicAdapter,
-    UTF8CharacteristicAdapter,
     GATT_GENERIC_ACCESS_SERVICE,
     GATT_DEVICE_NAME_CHARACTERISTIC,
     GATT_APPEARANCE_CHARACTERISTIC,
 )
-from bumble.gatt_client import ProfileServiceProxy, ServiceProxy
+from bumble.gatt_adapters import (
+    DelegatedCharacteristicProxyAdapter,
+    UTF8CharacteristicProxyAdapter,
+)
+from bumble.gatt_client import CharacteristicProxy, ProfileServiceProxy, ServiceProxy
 
 # -----------------------------------------------------------------------------
 # Logging
@@ -49,6 +50,9 @@ logger = logging.getLogger(__name__)
 class GenericAccessService(TemplateService):
     UUID = GATT_GENERIC_ACCESS_SERVICE
 
+    device_name_characteristic: Characteristic[bytes]
+    appearance_characteristic: Characteristic[bytes]
+
     def __init__(
         self, device_name: str, appearance: Union[Appearance, Tuple[int, int], int] = 0
     ):
@@ -84,8 +88,8 @@ class GenericAccessService(TemplateService):
 class GenericAccessServiceProxy(ProfileServiceProxy):
     SERVICE_CLASS = GenericAccessService
 
-    device_name: Optional[CharacteristicAdapter]
-    appearance: Optional[DelegatedCharacteristicAdapter]
+    device_name: Optional[CharacteristicProxy[str]]
+    appearance: Optional[CharacteristicProxy[Appearance]]
 
     def __init__(self, service_proxy: ServiceProxy):
         self.service_proxy = service_proxy
@@ -93,14 +97,14 @@ class GenericAccessServiceProxy(ProfileServiceProxy):
         if characteristics := service_proxy.get_characteristics_by_uuid(
             GATT_DEVICE_NAME_CHARACTERISTIC
         ):
-            self.device_name = UTF8CharacteristicAdapter(characteristics[0])
+            self.device_name = UTF8CharacteristicProxyAdapter(characteristics[0])
         else:
             self.device_name = None
 
         if characteristics := service_proxy.get_characteristics_by_uuid(
             GATT_APPEARANCE_CHARACTERISTIC
         ):
-            self.appearance = DelegatedCharacteristicAdapter(
+            self.appearance = DelegatedCharacteristicProxyAdapter(
                 characteristics[0],
                 decode=lambda value: Appearance.from_int(
                     struct.unpack_from('<H', value, 0)[0],
diff --git a/bumble/profiles/gatt_service.py b/bumble/profiles/gatt_service.py
new file mode 100644
index 0000000..e2d7a19
--- /dev/null
+++ b/bumble/profiles/gatt_service.py
@@ -0,0 +1,165 @@
+# Copyright 2021-2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from __future__ import annotations
+
+import struct
+from typing import TYPE_CHECKING
+
+from bumble import att
+from bumble import gatt
+from bumble import gatt_client
+from bumble import crypto
+
+if TYPE_CHECKING:
+    from bumble import device
+
+
+# -----------------------------------------------------------------------------
+class GenericAttributeProfileService(gatt.TemplateService):
+    '''See Vol 3, Part G - 7 - DEFINED GENERIC ATTRIBUTE PROFILE SERVICE.'''
+
+    UUID = gatt.GATT_GENERIC_ATTRIBUTE_SERVICE
+
+    client_supported_features_characteristic: gatt.Characteristic[bytes] | None = None
+    server_supported_features_characteristic: gatt.Characteristic[bytes] | None = None
+    database_hash_characteristic: gatt.Characteristic[bytes] | None = None
+    service_changed_characteristic: gatt.Characteristic[bytes] | None = None
+
+    def __init__(
+        self,
+        server_supported_features: gatt.ServerSupportedFeatures | None = None,
+        database_hash_enabled: bool = True,
+        service_change_enabled: bool = True,
+    ) -> None:
+
+        if server_supported_features is not None:
+            self.server_supported_features_characteristic = gatt.Characteristic(
+                uuid=gatt.GATT_SERVER_SUPPORTED_FEATURES_CHARACTERISTIC,
+                properties=gatt.Characteristic.Properties.READ,
+                permissions=gatt.Characteristic.Permissions.READABLE,
+                value=bytes([server_supported_features]),
+            )
+
+        if database_hash_enabled:
+            self.database_hash_characteristic = gatt.Characteristic(
+                uuid=gatt.GATT_DATABASE_HASH_CHARACTERISTIC,
+                properties=gatt.Characteristic.Properties.READ,
+                permissions=gatt.Characteristic.Permissions.READABLE,
+                value=gatt.CharacteristicValue(read=self.get_database_hash),
+            )
+
+        if service_change_enabled:
+            self.service_changed_characteristic = gatt.Characteristic(
+                uuid=gatt.GATT_SERVICE_CHANGED_CHARACTERISTIC,
+                properties=gatt.Characteristic.Properties.INDICATE,
+                permissions=gatt.Characteristic.Permissions(0),
+                value=b'',
+            )
+
+        if (database_hash_enabled and service_change_enabled) or (
+            server_supported_features
+            and (
+                server_supported_features & gatt.ServerSupportedFeatures.EATT_SUPPORTED
+            )
+        ):  # TODO: Support Multiple Handle Value Notifications
+            self.client_supported_features_characteristic = gatt.Characteristic(
+                uuid=gatt.GATT_CLIENT_SUPPORTED_FEATURES_CHARACTERISTIC,
+                properties=(
+                    gatt.Characteristic.Properties.READ
+                    | gatt.Characteristic.Properties.WRITE
+                ),
+                permissions=(
+                    gatt.Characteristic.Permissions.READABLE
+                    | gatt.Characteristic.Permissions.WRITEABLE
+                ),
+                value=bytes(1),
+            )
+
+        super().__init__(
+            characteristics=[
+                c
+                for c in (
+                    self.service_changed_characteristic,
+                    self.client_supported_features_characteristic,
+                    self.database_hash_characteristic,
+                    self.server_supported_features_characteristic,
+                )
+                if c is not None
+            ],
+            primary=True,
+        )
+
+    @classmethod
+    def get_attribute_data(cls, attribute: att.Attribute) -> bytes:
+        if attribute.type in (
+            gatt.GATT_PRIMARY_SERVICE_ATTRIBUTE_TYPE,
+            gatt.GATT_SECONDARY_SERVICE_ATTRIBUTE_TYPE,
+            gatt.GATT_INCLUDE_ATTRIBUTE_TYPE,
+            gatt.GATT_CHARACTERISTIC_ATTRIBUTE_TYPE,
+            gatt.GATT_CHARACTERISTIC_EXTENDED_PROPERTIES_DESCRIPTOR,
+        ):
+            assert isinstance(attribute.value, bytes)
+            return (
+                struct.pack("<H", attribute.handle)
+                + attribute.type.to_bytes()
+                + attribute.value
+            )
+        elif attribute.type in (
+            gatt.GATT_CHARACTERISTIC_USER_DESCRIPTION_DESCRIPTOR,
+            gatt.GATT_CLIENT_CHARACTERISTIC_CONFIGURATION_DESCRIPTOR,
+            gatt.GATT_SERVER_CHARACTERISTIC_CONFIGURATION_DESCRIPTOR,
+            gatt.GATT_CHARACTERISTIC_PRESENTATION_FORMAT_DESCRIPTOR,
+            gatt.GATT_CHARACTERISTIC_AGGREGATE_FORMAT_DESCRIPTOR,
+        ):
+            return struct.pack("<H", attribute.handle) + attribute.type.to_bytes()
+
+        return b''
+
+    def get_database_hash(self, connection: device.Connection) -> bytes:
+        m = b''.join(
+            [
+                self.get_attribute_data(attribute)
+                for attribute in connection.device.gatt_server.attributes
+            ]
+        )
+
+        return crypto.aes_cmac(m=m, k=bytes(16))
+
+
+class GenericAttributeProfileServiceProxy(gatt_client.ProfileServiceProxy):
+    SERVICE_CLASS = GenericAttributeProfileService
+
+    client_supported_features_characteristic: (
+        gatt_client.CharacteristicProxy[bytes] | None
+    ) = None
+    server_supported_features_characteristic: (
+        gatt_client.CharacteristicProxy[bytes] | None
+    ) = None
+    database_hash_characteristic: gatt_client.CharacteristicProxy[bytes] | None = None
+    service_changed_characteristic: gatt_client.CharacteristicProxy[bytes] | None = None
+
+    _CHARACTERISTICS = {
+        gatt.GATT_CLIENT_SUPPORTED_FEATURES_CHARACTERISTIC: 'client_supported_features_characteristic',
+        gatt.GATT_SERVER_SUPPORTED_FEATURES_CHARACTERISTIC: 'server_supported_features_characteristic',
+        gatt.GATT_DATABASE_HASH_CHARACTERISTIC: 'database_hash_characteristic',
+        gatt.GATT_SERVICE_CHANGED_CHARACTERISTIC: 'service_changed_characteristic',
+    }
+
+    def __init__(self, service_proxy: gatt_client.ServiceProxy) -> None:
+        self.service_proxy = service_proxy
+
+        for uuid, attribute_name in self._CHARACTERISTICS.items():
+            if characteristics := self.service_proxy.get_characteristics_by_uuid(uuid):
+                setattr(self, attribute_name, characteristics[0])
diff --git a/bumble/profiles/gmap.py b/bumble/profiles/gmap.py
new file mode 100644
index 0000000..d646f89
--- /dev/null
+++ b/bumble/profiles/gmap.py
@@ -0,0 +1,198 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""LE Audio - Gaming Audio Profile"""
+
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
+import struct
+from typing import Optional
+
+from bumble.gatt import (
+    TemplateService,
+    Characteristic,
+    GATT_GAMING_AUDIO_SERVICE,
+    GATT_GMAP_ROLE_CHARACTERISTIC,
+    GATT_UGG_FEATURES_CHARACTERISTIC,
+    GATT_UGT_FEATURES_CHARACTERISTIC,
+    GATT_BGS_FEATURES_CHARACTERISTIC,
+    GATT_BGR_FEATURES_CHARACTERISTIC,
+)
+from bumble.gatt_adapters import DelegatedCharacteristicProxyAdapter
+from bumble.gatt_client import CharacteristicProxy, ProfileServiceProxy, ServiceProxy
+from enum import IntFlag
+
+
+# -----------------------------------------------------------------------------
+# Classes
+# -----------------------------------------------------------------------------
+class GmapRole(IntFlag):
+    UNICAST_GAME_GATEWAY = 1 << 0
+    UNICAST_GAME_TERMINAL = 1 << 1
+    BROADCAST_GAME_SENDER = 1 << 2
+    BROADCAST_GAME_RECEIVER = 1 << 3
+
+
+class UggFeatures(IntFlag):
+    UGG_MULTIPLEX = 1 << 0
+    UGG_96_KBPS_SOURCE = 1 << 1
+    UGG_MULTISINK = 1 << 2
+
+
+class UgtFeatures(IntFlag):
+    UGT_SOURCE = 1 << 0
+    UGT_80_KBPS_SOURCE = 1 << 1
+    UGT_SINK = 1 << 2
+    UGT_64_KBPS_SINK = 1 << 3
+    UGT_MULTIPLEX = 1 << 4
+    UGT_MULTISINK = 1 << 5
+    UGT_MULTISOURCE = 1 << 6
+
+
+class BgsFeatures(IntFlag):
+    BGS_96_KBPS = 1 << 0
+
+
+class BgrFeatures(IntFlag):
+    BGR_MULTISINK = 1 << 0
+    BGR_MULTIPLEX = 1 << 1
+
+
+# -----------------------------------------------------------------------------
+# Server
+# -----------------------------------------------------------------------------
+class GamingAudioService(TemplateService):
+    UUID = GATT_GAMING_AUDIO_SERVICE
+
+    gmap_role: Characteristic
+    ugg_features: Optional[Characteristic] = None
+    ugt_features: Optional[Characteristic] = None
+    bgs_features: Optional[Characteristic] = None
+    bgr_features: Optional[Characteristic] = None
+
+    def __init__(
+        self,
+        gmap_role: GmapRole,
+        ugg_features: Optional[UggFeatures] = None,
+        ugt_features: Optional[UgtFeatures] = None,
+        bgs_features: Optional[BgsFeatures] = None,
+        bgr_features: Optional[BgrFeatures] = None,
+    ) -> None:
+        characteristics = []
+
+        ugg_features = UggFeatures(0) if ugg_features is None else ugg_features
+        ugt_features = UgtFeatures(0) if ugt_features is None else ugt_features
+        bgs_features = BgsFeatures(0) if bgs_features is None else bgs_features
+        bgr_features = BgrFeatures(0) if bgr_features is None else bgr_features
+
+        self.gmap_role = Characteristic(
+            uuid=GATT_GMAP_ROLE_CHARACTERISTIC,
+            properties=Characteristic.Properties.READ,
+            permissions=Characteristic.Permissions.READABLE,
+            value=struct.pack('B', gmap_role),
+        )
+        characteristics.append(self.gmap_role)
+
+        if gmap_role & GmapRole.UNICAST_GAME_GATEWAY:
+            self.ugg_features = Characteristic(
+                uuid=GATT_UGG_FEATURES_CHARACTERISTIC,
+                properties=Characteristic.Properties.READ,
+                permissions=Characteristic.Permissions.READABLE,
+                value=struct.pack('B', ugg_features),
+            )
+            characteristics.append(self.ugg_features)
+
+        if gmap_role & GmapRole.UNICAST_GAME_TERMINAL:
+            self.ugt_features = Characteristic(
+                uuid=GATT_UGT_FEATURES_CHARACTERISTIC,
+                properties=Characteristic.Properties.READ,
+                permissions=Characteristic.Permissions.READABLE,
+                value=struct.pack('B', ugt_features),
+            )
+            characteristics.append(self.ugt_features)
+
+        if gmap_role & GmapRole.BROADCAST_GAME_SENDER:
+            self.bgs_features = Characteristic(
+                uuid=GATT_BGS_FEATURES_CHARACTERISTIC,
+                properties=Characteristic.Properties.READ,
+                permissions=Characteristic.Permissions.READABLE,
+                value=struct.pack('B', bgs_features),
+            )
+            characteristics.append(self.bgs_features)
+
+        if gmap_role & GmapRole.BROADCAST_GAME_RECEIVER:
+            self.bgr_features = Characteristic(
+                uuid=GATT_BGR_FEATURES_CHARACTERISTIC,
+                properties=Characteristic.Properties.READ,
+                permissions=Characteristic.Permissions.READABLE,
+                value=struct.pack('B', bgr_features),
+            )
+            characteristics.append(self.bgr_features)
+
+        super().__init__(characteristics)
+
+
+# -----------------------------------------------------------------------------
+# Client
+# -----------------------------------------------------------------------------
+class GamingAudioServiceProxy(ProfileServiceProxy):
+    SERVICE_CLASS = GamingAudioService
+
+    ugg_features: Optional[CharacteristicProxy[UggFeatures]] = None
+    ugt_features: Optional[CharacteristicProxy[UgtFeatures]] = None
+    bgs_features: Optional[CharacteristicProxy[BgsFeatures]] = None
+    bgr_features: Optional[CharacteristicProxy[BgrFeatures]] = None
+
+    def __init__(self, service_proxy: ServiceProxy) -> None:
+        self.service_proxy = service_proxy
+
+        self.gmap_role = DelegatedCharacteristicProxyAdapter(
+            service_proxy.get_required_characteristic_by_uuid(
+                GATT_GMAP_ROLE_CHARACTERISTIC
+            ),
+            decode=lambda value: GmapRole(value[0]),
+        )
+
+        if characteristics := service_proxy.get_characteristics_by_uuid(
+            GATT_UGG_FEATURES_CHARACTERISTIC
+        ):
+            self.ugg_features = DelegatedCharacteristicProxyAdapter(
+                characteristics[0],
+                decode=lambda value: UggFeatures(value[0]),
+            )
+
+        if characteristics := service_proxy.get_characteristics_by_uuid(
+            GATT_UGT_FEATURES_CHARACTERISTIC
+        ):
+            self.ugt_features = DelegatedCharacteristicProxyAdapter(
+                characteristics[0],
+                decode=lambda value: UgtFeatures(value[0]),
+            )
+
+        if characteristics := service_proxy.get_characteristics_by_uuid(
+            GATT_BGS_FEATURES_CHARACTERISTIC
+        ):
+            self.bgs_features = DelegatedCharacteristicProxyAdapter(
+                characteristics[0],
+                decode=lambda value: BgsFeatures(value[0]),
+            )
+
+        if characteristics := service_proxy.get_characteristics_by_uuid(
+            GATT_BGR_FEATURES_CHARACTERISTIC
+        ):
+            self.bgr_features = DelegatedCharacteristicProxyAdapter(
+                characteristics[0],
+                decode=lambda value: BgrFeatures(value[0]),
+            )
diff --git a/bumble/profiles/hap.py b/bumble/profiles/hap.py
index 5c912d8..d4abd12 100644
--- a/bumble/profiles/hap.py
+++ b/bumble/profiles/hap.py
@@ -18,20 +18,21 @@
 from __future__ import annotations
 import asyncio
 import functools
-from bumble import att, gatt, gatt_client
-from bumble.core import InvalidArgumentError, InvalidStateError
-from bumble.device import Device, Connection
-from bumble.utils import AsyncRunner, OpenIntEnum
-from bumble.hci import Address
 from dataclasses import dataclass, field
 import logging
 from typing import Any, Dict, List, Optional, Set, Union
 
+from bumble import att, gatt, gatt_adapters, gatt_client
+from bumble.core import InvalidArgumentError, InvalidStateError
+from bumble.device import Device, Connection
+from bumble import utils
+from bumble.hci import Address
+
 
 # -----------------------------------------------------------------------------
 # Constants
 # -----------------------------------------------------------------------------
-class ErrorCode(OpenIntEnum):
+class ErrorCode(utils.OpenIntEnum):
     '''See Hearing Access Service 2.4. Attribute Profile error codes.'''
 
     INVALID_OPCODE = 0x80
@@ -41,7 +42,7 @@ class ErrorCode(OpenIntEnum):
     INVALID_PARAMETERS_LENGTH = 0x84
 
 
-class HearingAidType(OpenIntEnum):
+class HearingAidType(utils.OpenIntEnum):
     '''See Hearing Access Service 3.1. Hearing Aid Features.'''
 
     BINAURAL_HEARING_AID = 0b00
@@ -49,35 +50,35 @@ class HearingAidType(OpenIntEnum):
     BANDED_HEARING_AID = 0b10
 
 
-class PresetSynchronizationSupport(OpenIntEnum):
+class PresetSynchronizationSupport(utils.OpenIntEnum):
     '''See Hearing Access Service 3.1. Hearing Aid Features.'''
 
     PRESET_SYNCHRONIZATION_IS_NOT_SUPPORTED = 0b0
     PRESET_SYNCHRONIZATION_IS_SUPPORTED = 0b1
 
 
-class IndependentPresets(OpenIntEnum):
+class IndependentPresets(utils.OpenIntEnum):
     '''See Hearing Access Service 3.1. Hearing Aid Features.'''
 
     IDENTICAL_PRESET_RECORD = 0b0
     DIFFERENT_PRESET_RECORD = 0b1
 
 
-class DynamicPresets(OpenIntEnum):
+class DynamicPresets(utils.OpenIntEnum):
     '''See Hearing Access Service 3.1. Hearing Aid Features.'''
 
     PRESET_RECORDS_DOES_NOT_CHANGE = 0b0
     PRESET_RECORDS_MAY_CHANGE = 0b1
 
 
-class WritablePresetsSupport(OpenIntEnum):
+class WritablePresetsSupport(utils.OpenIntEnum):
     '''See Hearing Access Service 3.1. Hearing Aid Features.'''
 
     WRITABLE_PRESET_RECORDS_NOT_SUPPORTED = 0b0
     WRITABLE_PRESET_RECORDS_SUPPORTED = 0b1
 
 
-class HearingAidPresetControlPointOpcode(OpenIntEnum):
+class HearingAidPresetControlPointOpcode(utils.OpenIntEnum):
     '''See Hearing Access Service 3.3.1 Hearing Aid Preset Control Point operation requirements.'''
 
     # fmt: off
@@ -129,7 +130,7 @@ def HearingAidFeatures_from_bytes(data: int) -> HearingAidFeatures:
 class PresetChangedOperation:
     '''See Hearing Access Service 3.2.2.2. Preset Changed operation.'''
 
-    class ChangeId(OpenIntEnum):
+    class ChangeId(utils.OpenIntEnum):
         # fmt: off
         GENERIC_UPDATE            = 0x00
         PRESET_RECORD_DELETED     = 0x01
@@ -189,11 +190,11 @@ class PresetRecord:
 
     @dataclass
     class Property:
-        class Writable(OpenIntEnum):
+        class Writable(utils.OpenIntEnum):
             CANNOT_BE_WRITTEN = 0b0
             CAN_BE_WRITTEN = 0b1
 
-        class IsAvailable(OpenIntEnum):
+        class IsAvailable(utils.OpenIntEnum):
             IS_UNAVAILABLE = 0b0
             IS_AVAILABLE = 0b1
 
@@ -223,9 +224,9 @@ class PresetRecord:
 class HearingAccessService(gatt.TemplateService):
     UUID = gatt.GATT_HEARING_ACCESS_SERVICE
 
-    hearing_aid_features_characteristic: gatt.Characteristic
-    hearing_aid_preset_control_point: gatt.Characteristic
-    active_preset_index_characteristic: gatt.Characteristic
+    hearing_aid_features_characteristic: gatt.Characteristic[bytes]
+    hearing_aid_preset_control_point: gatt.Characteristic[bytes]
+    active_preset_index_characteristic: gatt.Characteristic[bytes]
     active_preset_index: int
     active_preset_index_per_device: Dict[Address, int]
 
@@ -235,6 +236,8 @@ class HearingAccessService(gatt.TemplateService):
     preset_records: Dict[int, PresetRecord]  # key is the preset index
     read_presets_request_in_progress: bool
 
+    other_server_in_binaural_set: Optional[HearingAccessService] = None
+
     preset_changed_operations_history_per_device: Dict[
         Address, List[PresetChangedOperation]
     ]
@@ -265,13 +268,13 @@ class HearingAccessService(gatt.TemplateService):
         # associate the lowest index as the current active preset at startup
         self.active_preset_index = sorted(self.preset_records.keys())[0]
 
-        @device.on('connection')  # type: ignore
+        @device.on(device.EVENT_CONNECTION)
         def on_connection(connection: Connection) -> None:
-            @connection.on('disconnection')  # type: ignore
+            @connection.on(connection.EVENT_DISCONNECTION)
             def on_disconnection(_reason) -> None:
                 self.currently_connected_clients.remove(connection)
 
-            @connection.on('pairing')  # type: ignore
+            @connection.on(connection.EVENT_PAIRING)
             def on_pairing(*_: Any) -> None:
                 self.on_incoming_paired_connection(connection)
 
@@ -332,11 +335,10 @@ class HearingAccessService(gatt.TemplateService):
             # Update the active preset index if needed
             await self.notify_active_preset_for_connection(connection)
 
-        connection.abort_on('disconnection', on_connection_async())
+        utils.cancel_on_event(connection, 'disconnection', on_connection_async())
 
-    def _on_read_active_preset_index(
-        self, __connection__: Optional[Connection]
-    ) -> bytes:
+    def _on_read_active_preset_index(self, connection: Connection) -> bytes:
+        del connection  # Unused
         return bytes([self.active_preset_index])
 
     # TODO this need to be triggered when device is unbonded
@@ -344,18 +346,13 @@ class HearingAccessService(gatt.TemplateService):
         self.preset_changed_operations_history_per_device.pop(addr)
 
     async def _on_write_hearing_aid_preset_control_point(
-        self, connection: Optional[Connection], value: bytes
+        self, connection: Connection, value: bytes
     ):
-        assert connection
-
         opcode = HearingAidPresetControlPointOpcode(value[0])
         handler = getattr(self, '_on_' + opcode.name.lower())
         await handler(connection, value)
 
-    async def _on_read_presets_request(
-        self, connection: Optional[Connection], value: bytes
-    ):
-        assert connection
+    async def _on_read_presets_request(self, connection: Connection, value: bytes):
         if connection.att_mtu < 49:  # 2.5. GATT sub-procedure requirements
             logging.warning(f'HAS require MTU >= 49: {connection}')
 
@@ -381,7 +378,7 @@ class HearingAccessService(gatt.TemplateService):
         if len(presets) == 0:
             raise att.ATT_Error(att.ErrorCode.OUT_OF_RANGE)
 
-        AsyncRunner.spawn(self._read_preset_response(connection, presets))
+        utils.AsyncRunner.spawn(self._read_preset_response(connection, presets))
 
     async def _read_preset_response(
         self, connection: Connection, presets: List[PresetRecord]
@@ -470,10 +467,7 @@ class HearingAccessService(gatt.TemplateService):
         for connection in self.currently_connected_clients:
             await self._preset_changed_operation(connection)
 
-    async def _on_write_preset_name(
-        self, connection: Optional[Connection], value: bytes
-    ):
-        assert connection
+    async def _on_write_preset_name(self, connection: Connection, value: bytes):
 
         if self.read_presets_request_in_progress:
             raise att.ATT_Error(att.ErrorCode.PROCEDURE_ALREADY_IN_PROGRESS)
@@ -521,10 +515,7 @@ class HearingAccessService(gatt.TemplateService):
         for connection in self.currently_connected_clients:
             await self.notify_active_preset_for_connection(connection)
 
-    async def set_active_preset(
-        self, connection: Optional[Connection], value: bytes
-    ) -> None:
-        assert connection
+    async def set_active_preset(self, value: bytes) -> None:
         index = value[1]
         preset = self.preset_records.get(index, None)
         if (
@@ -541,16 +532,11 @@ class HearingAccessService(gatt.TemplateService):
         self.active_preset_index = index
         await self.notify_active_preset()
 
-    async def _on_set_active_preset(
-        self, connection: Optional[Connection], value: bytes
-    ):
-        await self.set_active_preset(connection, value)
+    async def _on_set_active_preset(self, _: Connection, value: bytes):
+        await self.set_active_preset(value)
 
-    async def set_next_or_previous_preset(
-        self, connection: Optional[Connection], is_previous
-    ):
+    async def set_next_or_previous_preset(self, is_previous):
         '''Set the next or the previous preset as active'''
-        assert connection
 
         if self.active_preset_index == 0x00:
             raise att.ATT_Error(ErrorCode.PRESET_OPERATION_NOT_POSSIBLE)
@@ -579,48 +565,47 @@ class HearingAccessService(gatt.TemplateService):
             self.active_preset_index = first_preset.index
         await self.notify_active_preset()
 
-    async def _on_set_next_preset(
-        self, connection: Optional[Connection], __value__: bytes
-    ) -> None:
-        await self.set_next_or_previous_preset(connection, False)
+    async def _on_set_next_preset(self, _: Connection, __value__: bytes) -> None:
+        await self.set_next_or_previous_preset(False)
 
-    async def _on_set_previous_preset(
-        self, connection: Optional[Connection], __value__: bytes
-    ) -> None:
-        await self.set_next_or_previous_preset(connection, True)
+    async def _on_set_previous_preset(self, _: Connection, __value__: bytes) -> None:
+        await self.set_next_or_previous_preset(True)
 
     async def _on_set_active_preset_synchronized_locally(
-        self, connection: Optional[Connection], value: bytes
+        self, _: Connection, value: bytes
     ):
         if (
             self.server_features.preset_synchronization_support
-            == PresetSynchronizationSupport.PRESET_SYNCHRONIZATION_IS_SUPPORTED
+            == PresetSynchronizationSupport.PRESET_SYNCHRONIZATION_IS_NOT_SUPPORTED
         ):
             raise att.ATT_Error(ErrorCode.PRESET_SYNCHRONIZATION_NOT_SUPPORTED)
-        await self.set_active_preset(connection, value)
-        # TODO (low priority) inform other server of the change
+        await self.set_active_preset(value)
+        if self.other_server_in_binaural_set:
+            await self.other_server_in_binaural_set.set_active_preset(value)
 
     async def _on_set_next_preset_synchronized_locally(
-        self, connection: Optional[Connection], __value__: bytes
+        self, _: Connection, __value__: bytes
     ):
         if (
             self.server_features.preset_synchronization_support
-            == PresetSynchronizationSupport.PRESET_SYNCHRONIZATION_IS_SUPPORTED
+            == PresetSynchronizationSupport.PRESET_SYNCHRONIZATION_IS_NOT_SUPPORTED
         ):
             raise att.ATT_Error(ErrorCode.PRESET_SYNCHRONIZATION_NOT_SUPPORTED)
-        await self.set_next_or_previous_preset(connection, False)
-        # TODO (low priority) inform other server of the change
+        await self.set_next_or_previous_preset(False)
+        if self.other_server_in_binaural_set:
+            await self.other_server_in_binaural_set.set_next_or_previous_preset(False)
 
     async def _on_set_previous_preset_synchronized_locally(
-        self, connection: Optional[Connection], __value__: bytes
+        self, _: Connection, __value__: bytes
     ):
         if (
             self.server_features.preset_synchronization_support
-            == PresetSynchronizationSupport.PRESET_SYNCHRONIZATION_IS_SUPPORTED
+            == PresetSynchronizationSupport.PRESET_SYNCHRONIZATION_IS_NOT_SUPPORTED
         ):
             raise att.ATT_Error(ErrorCode.PRESET_SYNCHRONIZATION_NOT_SUPPORTED)
-        await self.set_next_or_previous_preset(connection, True)
-        # TODO (low priority) inform other server of the change
+        await self.set_next_or_previous_preset(True)
+        if self.other_server_in_binaural_set:
+            await self.other_server_in_binaural_set.set_next_or_previous_preset(True)
 
 
 # -----------------------------------------------------------------------------
@@ -631,11 +616,12 @@ class HearingAccessServiceProxy(gatt_client.ProfileServiceProxy):
 
     hearing_aid_preset_control_point: gatt_client.CharacteristicProxy
     preset_control_point_indications: asyncio.Queue
+    active_preset_index_notification: asyncio.Queue
 
     def __init__(self, service_proxy: gatt_client.ServiceProxy) -> None:
         self.service_proxy = service_proxy
 
-        self.server_features = gatt.PackedCharacteristicAdapter(
+        self.server_features = gatt_adapters.PackedCharacteristicProxyAdapter(
             service_proxy.get_characteristics_by_uuid(
                 gatt.GATT_HEARING_AID_FEATURES_CHARACTERISTIC
             )[0],
@@ -648,7 +634,7 @@ class HearingAccessServiceProxy(gatt_client.ProfileServiceProxy):
             )[0]
         )
 
-        self.active_preset_index = gatt.PackedCharacteristicAdapter(
+        self.active_preset_index = gatt_adapters.PackedCharacteristicProxyAdapter(
             service_proxy.get_characteristics_by_uuid(
                 gatt.GATT_ACTIVE_PRESET_INDEX_CHARACTERISTIC
             )[0],
diff --git a/bumble/profiles/heart_rate_service.py b/bumble/profiles/heart_rate_service.py
index 0c9a12f..090951b 100644
--- a/bumble/profiles/heart_rate_service.py
+++ b/bumble/profiles/heart_rate_service.py
@@ -16,13 +16,14 @@
 # -----------------------------------------------------------------------------
 # Imports
 # -----------------------------------------------------------------------------
+from __future__ import annotations
 from enum import IntEnum
 import struct
+from typing import Optional
 
 from bumble import core
-from ..gatt_client import ProfileServiceProxy
-from ..att import ATT_Error
-from ..gatt import (
+from bumble.att import ATT_Error
+from bumble.gatt import (
     GATT_HEART_RATE_SERVICE,
     GATT_HEART_RATE_MEASUREMENT_CHARACTERISTIC,
     GATT_BODY_SENSOR_LOCATION_CHARACTERISTIC,
@@ -30,9 +31,13 @@ from ..gatt import (
     TemplateService,
     Characteristic,
     CharacteristicValue,
+)
+from bumble.gatt_adapters import (
     DelegatedCharacteristicAdapter,
     PackedCharacteristicAdapter,
+    SerializableCharacteristicAdapter,
 )
+from bumble.gatt_client import CharacteristicProxy, ProfileServiceProxy
 
 
 # -----------------------------------------------------------------------------
@@ -42,6 +47,10 @@ class HeartRateService(TemplateService):
     CONTROL_POINT_NOT_SUPPORTED = 0x80
     RESET_ENERGY_EXPENDED = 0x01
 
+    heart_rate_measurement_characteristic: Characteristic[HeartRateMeasurement]
+    body_sensor_location_characteristic: Characteristic[BodySensorLocation]
+    heart_rate_control_point_characteristic: Characteristic[int]
+
     class BodySensorLocation(IntEnum):
         OTHER = 0
         CHEST = 1
@@ -150,15 +159,14 @@ class HeartRateService(TemplateService):
         body_sensor_location=None,
         reset_energy_expended=None,
     ):
-        self.heart_rate_measurement_characteristic = DelegatedCharacteristicAdapter(
+        self.heart_rate_measurement_characteristic = SerializableCharacteristicAdapter(
             Characteristic(
                 GATT_HEART_RATE_MEASUREMENT_CHARACTERISTIC,
                 Characteristic.Properties.NOTIFY,
                 0,
                 CharacteristicValue(read=read_heart_rate_measurement),
             ),
-            # pylint: disable=unnecessary-lambda
-            encode=lambda value: bytes(value),
+            HeartRateService.HeartRateMeasurement,
         )
         characteristics = [self.heart_rate_measurement_characteristic]
 
@@ -198,15 +206,22 @@ class HeartRateService(TemplateService):
 class HeartRateServiceProxy(ProfileServiceProxy):
     SERVICE_CLASS = HeartRateService
 
+    heart_rate_measurement: Optional[
+        CharacteristicProxy[HeartRateService.HeartRateMeasurement]
+    ]
+    body_sensor_location: Optional[
+        CharacteristicProxy[HeartRateService.BodySensorLocation]
+    ]
+    heart_rate_control_point: Optional[CharacteristicProxy[int]]
+
     def __init__(self, service_proxy):
         self.service_proxy = service_proxy
 
         if characteristics := service_proxy.get_characteristics_by_uuid(
             GATT_HEART_RATE_MEASUREMENT_CHARACTERISTIC
         ):
-            self.heart_rate_measurement = DelegatedCharacteristicAdapter(
-                characteristics[0],
-                decode=HeartRateService.HeartRateMeasurement.from_bytes,
+            self.heart_rate_measurement = SerializableCharacteristicAdapter(
+                characteristics[0], HeartRateService.HeartRateMeasurement
             )
         else:
             self.heart_rate_measurement = None
diff --git a/bumble/profiles/le_audio.py b/bumble/profiles/le_audio.py
index b152fd9..19afee4 100644
--- a/bumble/profiles/le_audio.py
+++ b/bumble/profiles/le_audio.py
@@ -17,23 +17,35 @@
 # -----------------------------------------------------------------------------
 from __future__ import annotations
 import dataclasses
+import enum
 import struct
-from typing import List, Type
+from typing import Any, List, Type
 from typing_extensions import Self
 
+from bumble.profiles import bap
 from bumble import utils
 
 
 # -----------------------------------------------------------------------------
 # Classes
 # -----------------------------------------------------------------------------
+class AudioActiveState(utils.OpenIntEnum):
+    NO_AUDIO_DATA_TRANSMITTED = 0x00
+    AUDIO_DATA_TRANSMITTED = 0x01
+
+
+class AssistedListeningStream(utils.OpenIntEnum):
+    UNSPECIFIED_AUDIO_ENHANCEMENT = 0x00
+
+
 @dataclasses.dataclass
 class Metadata:
     '''Bluetooth Assigned Numbers, Section 6.12.6 - Metadata LTV structures.
 
-    As Metadata fields may extend, and Spec doesn't forbid duplication, we don't parse
-    Metadata into a key-value style dataclass here. Rather, we encourage users to parse
-    again outside the lib.
+    As Metadata fields may extend, and the spec may not guarantee the uniqueness of
+    tags, we don't automatically parse the Metadata data into specific classes.
+    Users of this class may decode the data by themselves, or use the Entry.decode
+    method.
     '''
 
     class Tag(utils.OpenIntEnum):
@@ -57,6 +69,44 @@ class Metadata:
         tag: Metadata.Tag
         data: bytes
 
+        def decode(self) -> Any:
+            """
+            Decode the data into an object, if possible.
+
+            If no specific object class exists to represent the data, the raw data
+            bytes are returned.
+            """
+
+            if self.tag in (
+                Metadata.Tag.PREFERRED_AUDIO_CONTEXTS,
+                Metadata.Tag.STREAMING_AUDIO_CONTEXTS,
+            ):
+                return bap.ContextType(struct.unpack("<H", self.data)[0])
+
+            if self.tag in (
+                Metadata.Tag.PROGRAM_INFO,
+                Metadata.Tag.PROGRAM_INFO_URI,
+                Metadata.Tag.BROADCAST_NAME,
+            ):
+                return self.data.decode("utf-8")
+
+            if self.tag == Metadata.Tag.LANGUAGE:
+                return self.data.decode("ascii")
+
+            if self.tag == Metadata.Tag.CCID_LIST:
+                return list(self.data)
+
+            if self.tag == Metadata.Tag.PARENTAL_RATING:
+                return self.data[0]
+
+            if self.tag == Metadata.Tag.AUDIO_ACTIVE_STATE:
+                return AudioActiveState(self.data[0])
+
+            if self.tag == Metadata.Tag.ASSISTED_LISTENING_STREAM:
+                return AssistedListeningStream(self.data[0])
+
+            return self.data
+
         @classmethod
         def from_bytes(cls: Type[Self], data: bytes) -> Self:
             return cls(tag=Metadata.Tag(data[0]), data=data[1:])
@@ -66,6 +116,29 @@ class Metadata:
 
     entries: List[Entry] = dataclasses.field(default_factory=list)
 
+    def pretty_print(self, indent: str) -> str:
+        """Convenience method to generate a string with one key-value pair per line."""
+
+        max_key_length = 0
+        keys = []
+        values = []
+        for entry in self.entries:
+            key = entry.tag.name
+            max_key_length = max(max_key_length, len(key))
+            keys.append(key)
+            decoded = entry.decode()
+            if isinstance(decoded, enum.Enum):
+                values.append(decoded.name)
+            elif isinstance(decoded, bytes):
+                values.append(decoded.hex())
+            else:
+                values.append(str(decoded))
+
+        return '\n'.join(
+            f'{indent}{key}: {" " * (max_key_length-len(key))}{value}'
+            for key, value in zip(keys, values)
+        )
+
     @classmethod
     def from_bytes(cls: Type[Self], data: bytes) -> Self:
         entries = []
@@ -81,3 +154,13 @@ class Metadata:
 
     def __bytes__(self) -> bytes:
         return b''.join([bytes(entry) for entry in self.entries])
+
+    def __str__(self) -> str:
+        entries_str = []
+        for entry in self.entries:
+            decoded = entry.decode()
+            entries_str.append(
+                f'{entry.tag.name}: '
+                f'{decoded.hex() if isinstance(decoded, bytes) else decoded!r}'
+            )
+        return f'Metadata(entries={", ".join(entry_str for entry_str in entries_str)})'
diff --git a/bumble/profiles/mcp.py b/bumble/profiles/mcp.py
index 5e12573..e2ca8b1 100644
--- a/bumble/profiles/mcp.py
+++ b/bumble/profiles/mcp.py
@@ -208,7 +208,7 @@ class MediaControlService(gatt.TemplateService):
             properties=gatt.Characteristic.Properties.READ
             | gatt.Characteristic.Properties.NOTIFY,
             permissions=gatt.Characteristic.Permissions.READ_REQUIRES_ENCRYPTION,
-            value=media_player_name or 'Bumble Player',
+            value=(media_player_name or 'Bumble Player').encode(),
         )
         self.track_changed_characteristic = gatt.Characteristic(
             uuid=gatt.GATT_TRACK_CHANGED_CHARACTERISTIC,
@@ -247,14 +247,16 @@ class MediaControlService(gatt.TemplateService):
             permissions=gatt.Characteristic.Permissions.READ_REQUIRES_ENCRYPTION,
             value=b'',
         )
-        self.media_control_point_characteristic = gatt.Characteristic(
-            uuid=gatt.GATT_MEDIA_CONTROL_POINT_CHARACTERISTIC,
-            properties=gatt.Characteristic.Properties.WRITE
-            | gatt.Characteristic.Properties.WRITE_WITHOUT_RESPONSE
-            | gatt.Characteristic.Properties.NOTIFY,
-            permissions=gatt.Characteristic.Permissions.READ_REQUIRES_ENCRYPTION
-            | gatt.Characteristic.Permissions.WRITE_REQUIRES_ENCRYPTION,
-            value=gatt.CharacteristicValue(write=self.on_media_control_point),
+        self.media_control_point_characteristic: gatt.Characteristic[bytes] = (
+            gatt.Characteristic(
+                uuid=gatt.GATT_MEDIA_CONTROL_POINT_CHARACTERISTIC,
+                properties=gatt.Characteristic.Properties.WRITE
+                | gatt.Characteristic.Properties.WRITE_WITHOUT_RESPONSE
+                | gatt.Characteristic.Properties.NOTIFY,
+                permissions=gatt.Characteristic.Permissions.READ_REQUIRES_ENCRYPTION
+                | gatt.Characteristic.Permissions.WRITE_REQUIRES_ENCRYPTION,
+                value=gatt.CharacteristicValue(write=self.on_media_control_point),
+            )
         )
         self.media_control_point_opcodes_supported_characteristic = gatt.Characteristic(
             uuid=gatt.GATT_MEDIA_CONTROL_POINT_OPCODES_SUPPORTED_CHARACTERISTIC,
@@ -285,11 +287,8 @@ class MediaControlService(gatt.TemplateService):
         )
 
     async def on_media_control_point(
-        self, connection: Optional[device.Connection], data: bytes
+        self, connection: device.Connection, data: bytes
     ) -> None:
-        if not connection:
-            raise core.InvalidStateError()
-
         opcode = MediaControlPointOpcode(data[0])
 
         await connection.device.notify_subscriber(
@@ -336,30 +335,38 @@ class MediaControlServiceProxy(
         'content_control_id': gatt.GATT_CONTENT_CONTROL_ID_CHARACTERISTIC,
     }
 
-    media_player_name: Optional[gatt_client.CharacteristicProxy] = None
-    media_player_icon_object_id: Optional[gatt_client.CharacteristicProxy] = None
-    media_player_icon_url: Optional[gatt_client.CharacteristicProxy] = None
-    track_changed: Optional[gatt_client.CharacteristicProxy] = None
-    track_title: Optional[gatt_client.CharacteristicProxy] = None
-    track_duration: Optional[gatt_client.CharacteristicProxy] = None
-    track_position: Optional[gatt_client.CharacteristicProxy] = None
-    playback_speed: Optional[gatt_client.CharacteristicProxy] = None
-    seeking_speed: Optional[gatt_client.CharacteristicProxy] = None
-    current_track_segments_object_id: Optional[gatt_client.CharacteristicProxy] = None
-    current_track_object_id: Optional[gatt_client.CharacteristicProxy] = None
-    next_track_object_id: Optional[gatt_client.CharacteristicProxy] = None
-    parent_group_object_id: Optional[gatt_client.CharacteristicProxy] = None
-    current_group_object_id: Optional[gatt_client.CharacteristicProxy] = None
-    playing_order: Optional[gatt_client.CharacteristicProxy] = None
-    playing_orders_supported: Optional[gatt_client.CharacteristicProxy] = None
-    media_state: Optional[gatt_client.CharacteristicProxy] = None
-    media_control_point: Optional[gatt_client.CharacteristicProxy] = None
-    media_control_point_opcodes_supported: Optional[gatt_client.CharacteristicProxy] = (
-        None
-    )
-    search_control_point: Optional[gatt_client.CharacteristicProxy] = None
-    search_results_object_id: Optional[gatt_client.CharacteristicProxy] = None
-    content_control_id: Optional[gatt_client.CharacteristicProxy] = None
+    EVENT_MEDIA_STATE = "media_state"
+    EVENT_TRACK_CHANGED = "track_changed"
+    EVENT_TRACK_TITLE = "track_title"
+    EVENT_TRACK_DURATION = "track_duration"
+    EVENT_TRACK_POSITION = "track_position"
+
+    media_player_name: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    media_player_icon_object_id: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    media_player_icon_url: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    track_changed: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    track_title: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    track_duration: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    track_position: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    playback_speed: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    seeking_speed: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    current_track_segments_object_id: Optional[
+        gatt_client.CharacteristicProxy[bytes]
+    ] = None
+    current_track_object_id: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    next_track_object_id: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    parent_group_object_id: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    current_group_object_id: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    playing_order: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    playing_orders_supported: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    media_state: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    media_control_point: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    media_control_point_opcodes_supported: Optional[
+        gatt_client.CharacteristicProxy[bytes]
+    ] = None
+    search_control_point: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    search_results_object_id: Optional[gatt_client.CharacteristicProxy[bytes]] = None
+    content_control_id: Optional[gatt_client.CharacteristicProxy[bytes]] = None
 
     if TYPE_CHECKING:
         media_control_point_notifications: asyncio.Queue[bytes]
@@ -428,20 +435,20 @@ class MediaControlServiceProxy(
         self.media_control_point_notifications.put_nowait(data)
 
     def _on_media_state(self, data: bytes) -> None:
-        self.emit('media_state', MediaState(data[0]))
+        self.emit(self.EVENT_MEDIA_STATE, MediaState(data[0]))
 
     def _on_track_changed(self, data: bytes) -> None:
         del data
-        self.emit('track_changed')
+        self.emit(self.EVENT_TRACK_CHANGED)
 
     def _on_track_title(self, data: bytes) -> None:
-        self.emit('track_title', data.decode("utf-8"))
+        self.emit(self.EVENT_TRACK_TITLE, data.decode("utf-8"))
 
     def _on_track_duration(self, data: bytes) -> None:
-        self.emit('track_duration', struct.unpack_from('<i', data)[0])
+        self.emit(self.EVENT_TRACK_DURATION, struct.unpack_from('<i', data)[0])
 
     def _on_track_position(self, data: bytes) -> None:
-        self.emit('track_position', struct.unpack_from('<i', data)[0])
+        self.emit(self.EVENT_TRACK_POSITION, struct.unpack_from('<i', data)[0])
 
 
 class GenericMediaControlServiceProxy(MediaControlServiceProxy):
diff --git a/bumble/profiles/pacs.py b/bumble/profiles/pacs.py
index adab088..585afcb 100644
--- a/bumble/profiles/pacs.py
+++ b/bumble/profiles/pacs.py
@@ -25,6 +25,7 @@ from typing import Optional, Sequence, Union
 from bumble.profiles.bap import AudioLocation, CodecSpecificCapabilities, ContextType
 from bumble.profiles import le_audio
 from bumble import gatt
+from bumble import gatt_adapters
 from bumble import gatt_client
 from bumble import hci
 
@@ -72,6 +73,19 @@ class PacRecord:
             metadata=metadata,
         )
 
+    @classmethod
+    def list_from_bytes(cls, data: bytes) -> list[PacRecord]:
+        """Parse a serialized list of records preceded by a one byte list length."""
+        record_count = data[0]
+        records = []
+        offset = 1
+        for _ in range(record_count):
+            record = PacRecord.from_bytes(data[offset:])
+            offset += len(bytes(record))
+            records.append(record)
+
+        return records
+
     def __bytes__(self) -> bytes:
         capabilities_bytes = bytes(self.codec_specific_capabilities)
         metadata_bytes = bytes(self.metadata)
@@ -90,12 +104,12 @@ class PacRecord:
 class PublishedAudioCapabilitiesService(gatt.TemplateService):
     UUID = gatt.GATT_PUBLISHED_AUDIO_CAPABILITIES_SERVICE
 
-    sink_pac: Optional[gatt.Characteristic]
-    sink_audio_locations: Optional[gatt.Characteristic]
-    source_pac: Optional[gatt.Characteristic]
-    source_audio_locations: Optional[gatt.Characteristic]
-    available_audio_contexts: gatt.Characteristic
-    supported_audio_contexts: gatt.Characteristic
+    sink_pac: Optional[gatt.Characteristic[bytes]]
+    sink_audio_locations: Optional[gatt.Characteristic[bytes]]
+    source_pac: Optional[gatt.Characteristic[bytes]]
+    source_audio_locations: Optional[gatt.Characteristic[bytes]]
+    available_audio_contexts: gatt.Characteristic[bytes]
+    supported_audio_contexts: gatt.Characteristic[bytes]
 
     def __init__(
         self,
@@ -172,39 +186,70 @@ class PublishedAudioCapabilitiesService(gatt.TemplateService):
 class PublishedAudioCapabilitiesServiceProxy(gatt_client.ProfileServiceProxy):
     SERVICE_CLASS = PublishedAudioCapabilitiesService
 
-    sink_pac: Optional[gatt_client.CharacteristicProxy] = None
-    sink_audio_locations: Optional[gatt_client.CharacteristicProxy] = None
-    source_pac: Optional[gatt_client.CharacteristicProxy] = None
-    source_audio_locations: Optional[gatt_client.CharacteristicProxy] = None
-    available_audio_contexts: gatt_client.CharacteristicProxy
-    supported_audio_contexts: gatt_client.CharacteristicProxy
+    sink_pac: Optional[gatt_client.CharacteristicProxy[list[PacRecord]]] = None
+    sink_audio_locations: Optional[gatt_client.CharacteristicProxy[AudioLocation]] = (
+        None
+    )
+    source_pac: Optional[gatt_client.CharacteristicProxy[list[PacRecord]]] = None
+    source_audio_locations: Optional[gatt_client.CharacteristicProxy[AudioLocation]] = (
+        None
+    )
+    available_audio_contexts: gatt_client.CharacteristicProxy[tuple[ContextType, ...]]
+    supported_audio_contexts: gatt_client.CharacteristicProxy[tuple[ContextType, ...]]
 
     def __init__(self, service_proxy: gatt_client.ServiceProxy):
         self.service_proxy = service_proxy
 
-        self.available_audio_contexts = service_proxy.get_characteristics_by_uuid(
-            gatt.GATT_AVAILABLE_AUDIO_CONTEXTS_CHARACTERISTIC
-        )[0]
-        self.supported_audio_contexts = service_proxy.get_characteristics_by_uuid(
-            gatt.GATT_SUPPORTED_AUDIO_CONTEXTS_CHARACTERISTIC
-        )[0]
+        self.available_audio_contexts = (
+            gatt_adapters.DelegatedCharacteristicProxyAdapter(
+                service_proxy.get_required_characteristic_by_uuid(
+                    gatt.GATT_AVAILABLE_AUDIO_CONTEXTS_CHARACTERISTIC
+                ),
+                decode=lambda x: tuple(map(ContextType, struct.unpack('<HH', x))),
+            )
+        )
+
+        self.supported_audio_contexts = (
+            gatt_adapters.DelegatedCharacteristicProxyAdapter(
+                service_proxy.get_required_characteristic_by_uuid(
+                    gatt.GATT_SUPPORTED_AUDIO_CONTEXTS_CHARACTERISTIC
+                ),
+                decode=lambda x: tuple(map(ContextType, struct.unpack('<HH', x))),
+            )
+        )
 
         if characteristics := service_proxy.get_characteristics_by_uuid(
             gatt.GATT_SINK_PAC_CHARACTERISTIC
         ):
-            self.sink_pac = characteristics[0]
+            self.sink_pac = gatt_adapters.DelegatedCharacteristicProxyAdapter(
+                characteristics[0],
+                decode=PacRecord.list_from_bytes,
+            )
 
         if characteristics := service_proxy.get_characteristics_by_uuid(
             gatt.GATT_SOURCE_PAC_CHARACTERISTIC
         ):
-            self.source_pac = characteristics[0]
+            self.source_pac = gatt_adapters.DelegatedCharacteristicProxyAdapter(
+                characteristics[0],
+                decode=PacRecord.list_from_bytes,
+            )
 
         if characteristics := service_proxy.get_characteristics_by_uuid(
             gatt.GATT_SINK_AUDIO_LOCATION_CHARACTERISTIC
         ):
-            self.sink_audio_locations = characteristics[0]
+            self.sink_audio_locations = (
+                gatt_adapters.DelegatedCharacteristicProxyAdapter(
+                    characteristics[0],
+                    decode=lambda x: AudioLocation(struct.unpack('<I', x)[0]),
+                )
+            )
 
         if characteristics := service_proxy.get_characteristics_by_uuid(
             gatt.GATT_SOURCE_AUDIO_LOCATION_CHARACTERISTIC
         ):
-            self.source_audio_locations = characteristics[0]
+            self.source_audio_locations = (
+                gatt_adapters.DelegatedCharacteristicProxyAdapter(
+                    characteristics[0],
+                    decode=lambda x: AudioLocation(struct.unpack('<I', x)[0]),
+                )
+            )
diff --git a/bumble/profiles/pbp.py b/bumble/profiles/pbp.py
index 058bd6d..d905dd9 100644
--- a/bumble/profiles/pbp.py
+++ b/bumble/profiles/pbp.py
@@ -40,7 +40,7 @@ class PublicBroadcastAnnouncement:
     def from_bytes(cls, data: bytes) -> Self:
         features = cls.Features(data[0])
         metadata_length = data[1]
-        metadata_ltv = data[1 : 1 + metadata_length]
+        metadata_ltv = data[2 : 2 + metadata_length]
         return cls(
             features=features, metadata=le_audio.Metadata.from_bytes(metadata_ltv)
         )
diff --git a/bumble/profiles/tmap.py b/bumble/profiles/tmap.py
index 7b65015..20f899c 100644
--- a/bumble/profiles/tmap.py
+++ b/bumble/profiles/tmap.py
@@ -24,12 +24,11 @@ import struct
 from bumble.gatt import (
     TemplateService,
     Characteristic,
-    DelegatedCharacteristicAdapter,
-    InvalidServiceError,
     GATT_TELEPHONY_AND_MEDIA_AUDIO_SERVICE,
     GATT_TMAP_ROLE_CHARACTERISTIC,
 )
-from bumble.gatt_client import ProfileServiceProxy, ServiceProxy
+from bumble.gatt_adapters import DelegatedCharacteristicProxyAdapter
+from bumble.gatt_client import CharacteristicProxy, ProfileServiceProxy, ServiceProxy
 
 
 # -----------------------------------------------------------------------------
@@ -54,6 +53,8 @@ class Role(enum.IntFlag):
 class TelephonyAndMediaAudioService(TemplateService):
     UUID = GATT_TELEPHONY_AND_MEDIA_AUDIO_SERVICE
 
+    role_characteristic: Characteristic[bytes]
+
     def __init__(self, role: Role):
         self.role_characteristic = Characteristic(
             GATT_TMAP_ROLE_CHARACTERISTIC,
@@ -69,20 +70,15 @@ class TelephonyAndMediaAudioService(TemplateService):
 class TelephonyAndMediaAudioServiceProxy(ProfileServiceProxy):
     SERVICE_CLASS = TelephonyAndMediaAudioService
 
-    role: DelegatedCharacteristicAdapter
+    role: CharacteristicProxy[Role]
 
     def __init__(self, service_proxy: ServiceProxy):
         self.service_proxy = service_proxy
 
-        if not (
-            characteristics := service_proxy.get_characteristics_by_uuid(
+        self.role = DelegatedCharacteristicProxyAdapter(
+            service_proxy.get_required_characteristic_by_uuid(
                 GATT_TMAP_ROLE_CHARACTERISTIC
-            )
-        ):
-            raise InvalidServiceError('TMAP Role characteristic not found')
-
-        self.role = DelegatedCharacteristicAdapter(
-            characteristics[0],
+            ),
             decode=lambda value: Role(
                 struct.unpack_from('<H', value, 0)[0],
             ),
diff --git a/bumble/profiles/vcp.py b/bumble/profiles/vcs.py
similarity index 79%
rename from bumble/profiles/vcp.py
rename to bumble/profiles/vcs.py
index 57452d9..2d1424e 100644
--- a/bumble/profiles/vcp.py
+++ b/bumble/profiles/vcs.py
@@ -1,4 +1,4 @@
-# Copyright 2021-2024 Google LLC
+# Copyright 2021-2025 Google LLC
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -17,14 +17,18 @@
 # Imports
 # -----------------------------------------------------------------------------
 from __future__ import annotations
+import dataclasses
 import enum
 
+from typing import Optional, Sequence
+
 from bumble import att
+from bumble import utils
 from bumble import device
 from bumble import gatt
+from bumble import gatt_adapters
 from bumble import gatt_client
 
-from typing import Optional, Sequence
 
 # -----------------------------------------------------------------------------
 # Constants
@@ -67,15 +71,31 @@ class VolumeControlPointOpcode(enum.IntEnum):
     MUTE                        = 0x06
 
 
+@dataclasses.dataclass
+class VolumeState:
+    volume_setting: int
+    mute: int
+    change_counter: int
+
+    @classmethod
+    def from_bytes(cls, data: bytes) -> VolumeState:
+        return cls(data[0], data[1], data[2])
+
+    def __bytes__(self) -> bytes:
+        return bytes([self.volume_setting, self.mute, self.change_counter])
+
+
 # -----------------------------------------------------------------------------
 # Server
 # -----------------------------------------------------------------------------
 class VolumeControlService(gatt.TemplateService):
     UUID = gatt.GATT_VOLUME_CONTROL_SERVICE
 
-    volume_state: gatt.Characteristic
-    volume_control_point: gatt.Characteristic
-    volume_flags: gatt.Characteristic
+    EVENT_VOLUME_STATE_CHANGE = "volume_state_change"
+
+    volume_state: gatt.Characteristic[bytes]
+    volume_control_point: gatt.Characteristic[bytes]
+    volume_flags: gatt.Characteristic[bytes]
 
     volume_setting: int
     muted: int
@@ -126,22 +146,12 @@ class VolumeControlService(gatt.TemplateService):
             included_services=list(included_services),
         )
 
-    @property
-    def volume_state_bytes(self) -> bytes:
-        return bytes([self.volume_setting, self.muted, self.change_counter])
-
-    @volume_state_bytes.setter
-    def volume_state_bytes(self, new_value: bytes) -> None:
-        self.volume_setting, self.muted, self.change_counter = new_value
-
-    def _on_read_volume_state(self, _connection: Optional[device.Connection]) -> bytes:
-        return self.volume_state_bytes
+    def _on_read_volume_state(self, _connection: device.Connection) -> bytes:
+        return bytes(VolumeState(self.volume_setting, self.muted, self.change_counter))
 
     def _on_write_volume_control_point(
-        self, connection: Optional[device.Connection], value: bytes
+        self, connection: device.Connection, value: bytes
     ) -> None:
-        assert connection
-
         opcode = VolumeControlPointOpcode(value[0])
         change_counter = value[1]
 
@@ -151,16 +161,12 @@ class VolumeControlService(gatt.TemplateService):
         handler = getattr(self, '_on_' + opcode.name.lower())
         if handler(*value[2:]):
             self.change_counter = (self.change_counter + 1) % 256
-            connection.abort_on(
+            utils.cancel_on_event(
+                connection,
                 'disconnection',
-                connection.device.notify_subscribers(
-                    attribute=self.volume_state,
-                    value=self.volume_state_bytes,
-                ),
-            )
-            self.emit(
-                'volume_state', self.volume_setting, self.muted, self.change_counter
+                connection.device.notify_subscribers(attribute=self.volume_state),
             )
+            self.emit(self.EVENT_VOLUME_STATE_CHANGE)
 
     def _on_relative_volume_down(self) -> bool:
         old_volume = self.volume_setting
@@ -206,25 +212,27 @@ class VolumeControlService(gatt.TemplateService):
 class VolumeControlServiceProxy(gatt_client.ProfileServiceProxy):
     SERVICE_CLASS = VolumeControlService
 
-    volume_control_point: gatt_client.CharacteristicProxy
+    volume_control_point: gatt_client.CharacteristicProxy[bytes]
+    volume_state: gatt_client.CharacteristicProxy[VolumeState]
+    volume_flags: gatt_client.CharacteristicProxy[VolumeFlags]
 
     def __init__(self, service_proxy: gatt_client.ServiceProxy) -> None:
         self.service_proxy = service_proxy
 
-        self.volume_state = gatt.PackedCharacteristicAdapter(
-            service_proxy.get_characteristics_by_uuid(
+        self.volume_state = gatt_adapters.SerializableCharacteristicProxyAdapter(
+            service_proxy.get_required_characteristic_by_uuid(
                 gatt.GATT_VOLUME_STATE_CHARACTERISTIC
-            )[0],
-            'BBB',
+            ),
+            VolumeState,
         )
 
-        self.volume_control_point = service_proxy.get_characteristics_by_uuid(
+        self.volume_control_point = service_proxy.get_required_characteristic_by_uuid(
             gatt.GATT_VOLUME_CONTROL_POINT_CHARACTERISTIC
-        )[0]
+        )
 
-        self.volume_flags = gatt.PackedCharacteristicAdapter(
-            service_proxy.get_characteristics_by_uuid(
+        self.volume_flags = gatt_adapters.DelegatedCharacteristicProxyAdapter(
+            service_proxy.get_required_characteristic_by_uuid(
                 gatt.GATT_VOLUME_FLAGS_CHARACTERISTIC
-            )[0],
-            'B',
+            ),
+            decode=lambda data: VolumeFlags(data[0]),
         )
diff --git a/bumble/profiles/vocs.py b/bumble/profiles/vocs.py
new file mode 100644
index 0000000..7ce5ddd
--- /dev/null
+++ b/bumble/profiles/vocs.py
@@ -0,0 +1,304 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
+import struct
+from dataclasses import dataclass
+from typing import Optional
+
+from bumble.device import Connection
+from bumble.att import ATT_Error
+from bumble.gatt import (
+    Characteristic,
+    TemplateService,
+    CharacteristicValue,
+    GATT_VOLUME_OFFSET_CONTROL_SERVICE,
+    GATT_VOLUME_OFFSET_STATE_CHARACTERISTIC,
+    GATT_AUDIO_LOCATION_CHARACTERISTIC,
+    GATT_VOLUME_OFFSET_CONTROL_POINT_CHARACTERISTIC,
+    GATT_AUDIO_OUTPUT_DESCRIPTION_CHARACTERISTIC,
+)
+from bumble.gatt_adapters import (
+    DelegatedCharacteristicProxyAdapter,
+    SerializableCharacteristicProxyAdapter,
+    UTF8CharacteristicProxyAdapter,
+)
+from bumble.gatt_client import ProfileServiceProxy, ServiceProxy
+from bumble import utils
+from bumble.profiles.bap import AudioLocation
+
+# -----------------------------------------------------------------------------
+# Constants
+# -----------------------------------------------------------------------------
+
+MIN_VOLUME_OFFSET = -255
+MAX_VOLUME_OFFSET = 255
+CHANGE_COUNTER_MAX_VALUE = 0xFF
+
+
+class SetVolumeOffsetOpCode(utils.OpenIntEnum):
+    SET_VOLUME_OFFSET = 0x01
+
+
+class ErrorCode(utils.OpenIntEnum):
+    """
+    See Volume Offset Control Service 1.6. Application error codes.
+    """
+
+    INVALID_CHANGE_COUNTER = 0x80
+    OPCODE_NOT_SUPPORTED = 0x81
+    VALUE_OUT_OF_RANGE = 0x82
+
+
+# -----------------------------------------------------------------------------
+@dataclass
+class VolumeOffsetState:
+    volume_offset: int = 0
+    change_counter: int = 0
+    attribute: Optional[Characteristic] = None
+
+    def __bytes__(self) -> bytes:
+        return struct.pack('<hB', self.volume_offset, self.change_counter)
+
+    @classmethod
+    def from_bytes(cls, data: bytes):
+        volume_offset, change_counter = struct.unpack('<hB', data)
+        return cls(volume_offset, change_counter)
+
+    def increment_change_counter(self) -> None:
+        self.change_counter = (self.change_counter + 1) % (CHANGE_COUNTER_MAX_VALUE + 1)
+
+    async def notify_subscribers_via_connection(self, connection: Connection) -> None:
+        assert self.attribute is not None
+        await connection.device.notify_subscribers(attribute=self.attribute)
+
+    def on_read(self, _connection: Connection) -> bytes:
+        return bytes(self)
+
+
+@dataclass
+class VocsAudioLocation:
+    audio_location: AudioLocation = AudioLocation.NOT_ALLOWED
+    attribute: Optional[Characteristic] = None
+
+    def __bytes__(self) -> bytes:
+        return struct.pack('<I', self.audio_location)
+
+    @classmethod
+    def from_bytes(cls, data: bytes):
+        audio_location = AudioLocation(struct.unpack('<I', data)[0])
+        return cls(audio_location)
+
+    def on_read(self, _connection: Connection) -> bytes:
+        return bytes(self)
+
+    async def on_write(self, connection: Connection, value: bytes) -> None:
+        assert self.attribute
+
+        self.audio_location = AudioLocation(int.from_bytes(value, 'little'))
+        await connection.device.notify_subscribers(attribute=self.attribute)
+
+
+@dataclass
+class VolumeOffsetControlPoint:
+    volume_offset_state: VolumeOffsetState
+
+    async def on_write(self, connection: Connection, value: bytes) -> None:
+
+        opcode = value[0]
+        if opcode != SetVolumeOffsetOpCode.SET_VOLUME_OFFSET:
+            raise ATT_Error(ErrorCode.OPCODE_NOT_SUPPORTED)
+
+        change_counter, volume_offset = struct.unpack('<Bh', value[1:])
+        await self._set_volume_offset(connection, change_counter, volume_offset)
+
+    async def _set_volume_offset(
+        self,
+        connection: Connection,
+        change_counter_operand: int,
+        volume_offset_operand: int,
+    ) -> None:
+        change_counter = self.volume_offset_state.change_counter
+
+        if change_counter != change_counter_operand:
+            raise ATT_Error(ErrorCode.INVALID_CHANGE_COUNTER)
+
+        if not MIN_VOLUME_OFFSET <= volume_offset_operand <= MAX_VOLUME_OFFSET:
+            raise ATT_Error(ErrorCode.VALUE_OUT_OF_RANGE)
+
+        self.volume_offset_state.volume_offset = volume_offset_operand
+        self.volume_offset_state.increment_change_counter()
+        await self.volume_offset_state.notify_subscribers_via_connection(connection)
+
+
+@dataclass
+class AudioOutputDescription:
+    audio_output_description: str = ''
+    attribute: Optional[Characteristic] = None
+
+    @classmethod
+    def from_bytes(cls, data: bytes):
+        return cls(audio_output_description=data.decode('utf-8'))
+
+    def __bytes__(self) -> bytes:
+        return self.audio_output_description.encode('utf-8')
+
+    def on_read(self, _connection: Connection) -> bytes:
+        return bytes(self)
+
+    async def on_write(self, connection: Connection, value: bytes) -> None:
+        assert self.attribute
+
+        self.audio_output_description = value.decode('utf-8')
+        await connection.device.notify_subscribers(attribute=self.attribute)
+
+
+# -----------------------------------------------------------------------------
+class VolumeOffsetControlService(TemplateService):
+    UUID = GATT_VOLUME_OFFSET_CONTROL_SERVICE
+
+    def __init__(
+        self,
+        volume_offset_state: Optional[VolumeOffsetState] = None,
+        audio_location: Optional[VocsAudioLocation] = None,
+        audio_output_description: Optional[AudioOutputDescription] = None,
+    ) -> None:
+
+        self.volume_offset_state = (
+            VolumeOffsetState() if volume_offset_state is None else volume_offset_state
+        )
+
+        self.audio_location = (
+            VocsAudioLocation() if audio_location is None else audio_location
+        )
+
+        self.audio_output_description = (
+            AudioOutputDescription()
+            if audio_output_description is None
+            else audio_output_description
+        )
+
+        self.volume_offset_control_point: VolumeOffsetControlPoint = (
+            VolumeOffsetControlPoint(self.volume_offset_state)
+        )
+
+        self.volume_offset_state_characteristic: Characteristic[bytes] = Characteristic(
+            uuid=GATT_VOLUME_OFFSET_STATE_CHARACTERISTIC,
+            properties=(
+                Characteristic.Properties.READ | Characteristic.Properties.NOTIFY
+            ),
+            permissions=Characteristic.Permissions.READ_REQUIRES_ENCRYPTION,
+            value=CharacteristicValue(read=self.volume_offset_state.on_read),
+        )
+
+        self.audio_location_characteristic: Characteristic[bytes] = Characteristic(
+            uuid=GATT_AUDIO_LOCATION_CHARACTERISTIC,
+            properties=(
+                Characteristic.Properties.READ
+                | Characteristic.Properties.NOTIFY
+                | Characteristic.Properties.WRITE_WITHOUT_RESPONSE
+            ),
+            permissions=(
+                Characteristic.Permissions.READ_REQUIRES_ENCRYPTION
+                | Characteristic.Permissions.WRITE_REQUIRES_ENCRYPTION
+            ),
+            value=CharacteristicValue(
+                read=self.audio_location.on_read,
+                write=self.audio_location.on_write,
+            ),
+        )
+        self.audio_location.attribute = self.audio_location_characteristic
+
+        self.volume_offset_control_point_characteristic: Characteristic[bytes] = (
+            Characteristic(
+                uuid=GATT_VOLUME_OFFSET_CONTROL_POINT_CHARACTERISTIC,
+                properties=Characteristic.Properties.WRITE,
+                permissions=Characteristic.Permissions.WRITE_REQUIRES_ENCRYPTION,
+                value=CharacteristicValue(
+                    write=self.volume_offset_control_point.on_write
+                ),
+            )
+        )
+
+        self.audio_output_description_characteristic: Characteristic[bytes] = (
+            Characteristic(
+                uuid=GATT_AUDIO_OUTPUT_DESCRIPTION_CHARACTERISTIC,
+                properties=(
+                    Characteristic.Properties.READ
+                    | Characteristic.Properties.NOTIFY
+                    | Characteristic.Properties.WRITE_WITHOUT_RESPONSE
+                ),
+                permissions=(
+                    Characteristic.Permissions.READ_REQUIRES_ENCRYPTION
+                    | Characteristic.Permissions.WRITE_REQUIRES_ENCRYPTION
+                ),
+                value=CharacteristicValue(
+                    read=self.audio_output_description.on_read,
+                    write=self.audio_output_description.on_write,
+                ),
+            )
+        )
+        self.audio_output_description.attribute = (
+            self.audio_output_description_characteristic
+        )
+
+        super().__init__(
+            characteristics=[
+                self.volume_offset_state_characteristic,  # type: ignore
+                self.audio_location_characteristic,  # type: ignore
+                self.volume_offset_control_point_characteristic,  # type: ignore
+                self.audio_output_description_characteristic,  # type: ignore
+            ],
+            primary=False,
+        )
+
+
+# -----------------------------------------------------------------------------
+# Client
+# -----------------------------------------------------------------------------
+class VolumeOffsetControlServiceProxy(ProfileServiceProxy):
+    SERVICE_CLASS = VolumeOffsetControlService
+
+    def __init__(self, service_proxy: ServiceProxy) -> None:
+        self.service_proxy = service_proxy
+
+        self.volume_offset_state = SerializableCharacteristicProxyAdapter(
+            service_proxy.get_required_characteristic_by_uuid(
+                GATT_VOLUME_OFFSET_STATE_CHARACTERISTIC
+            ),
+            VolumeOffsetState,
+        )
+
+        self.audio_location = DelegatedCharacteristicProxyAdapter(
+            service_proxy.get_required_characteristic_by_uuid(
+                GATT_AUDIO_LOCATION_CHARACTERISTIC
+            ),
+            encode=lambda value: bytes([int(value)]),
+            decode=lambda data: AudioLocation(data[0]),
+        )
+
+        self.volume_offset_control_point = (
+            service_proxy.get_required_characteristic_by_uuid(
+                GATT_VOLUME_OFFSET_CONTROL_POINT_CHARACTERISTIC
+            )
+        )
+
+        self.audio_output_description = UTF8CharacteristicProxyAdapter(
+            service_proxy.get_required_characteristic_by_uuid(
+                GATT_AUDIO_OUTPUT_DESCRIPTION_CHARACTERISTIC
+            )
+        )
diff --git a/bumble/rfcomm.py b/bumble/rfcomm.py
index 2de7374..fe5038b 100644
--- a/bumble/rfcomm.py
+++ b/bumble/rfcomm.py
@@ -25,16 +25,16 @@ import enum
 from typing import Callable, Dict, List, Optional, Tuple, Union, TYPE_CHECKING
 from typing_extensions import Self
 
-from pyee import EventEmitter
 
 from bumble import core
 from bumble import l2cap
 from bumble import sdp
-from .colors import color
-from .core import (
+from bumble import utils
+from bumble.colors import color
+from bumble.core import (
     UUID,
     BT_RFCOMM_PROTOCOL_ID,
-    BT_BR_EDR_TRANSPORT,
+    PhysicalTransport,
     BT_L2CAP_PROTOCOL_ID,
     InvalidArgumentError,
     InvalidStateError,
@@ -441,7 +441,10 @@ class RFCOMM_MCC_MSC:
 
 
 # -----------------------------------------------------------------------------
-class DLC(EventEmitter):
+class DLC(utils.EventEmitter):
+    EVENT_OPEN = "open"
+    EVENT_CLOSE = "close"
+
     class State(enum.IntEnum):
         INIT = 0x00
         CONNECTING = 0x01
@@ -529,7 +532,7 @@ class DLC(EventEmitter):
         self.send_frame(RFCOMM_Frame.uih(c_r=self.c_r, dlci=0, information=mcc))
 
         self.change_state(DLC.State.CONNECTED)
-        self.emit('open')
+        self.emit(self.EVENT_OPEN)
 
     def on_ua_frame(self, _frame: RFCOMM_Frame) -> None:
         if self.state == DLC.State.CONNECTING:
@@ -550,7 +553,7 @@ class DLC(EventEmitter):
                 self.disconnection_result.set_result(None)
                 self.disconnection_result = None
             self.multiplexer.on_dlc_disconnection(self)
-            self.emit('close')
+            self.emit(self.EVENT_CLOSE)
         else:
             logger.warning(
                 color(
@@ -733,7 +736,7 @@ class DLC(EventEmitter):
             self.disconnection_result.cancel()
             self.disconnection_result = None
         self.change_state(DLC.State.RESET)
-        self.emit('close')
+        self.emit(self.EVENT_CLOSE)
 
     def __str__(self) -> str:
         return (
@@ -749,7 +752,7 @@ class DLC(EventEmitter):
 
 
 # -----------------------------------------------------------------------------
-class Multiplexer(EventEmitter):
+class Multiplexer(utils.EventEmitter):
     class Role(enum.IntEnum):
         INITIATOR = 0x00
         RESPONDER = 0x01
@@ -763,6 +766,8 @@ class Multiplexer(EventEmitter):
         DISCONNECTED = 0x05
         RESET = 0x06
 
+    EVENT_DLC = "dlc"
+
     connection_result: Optional[asyncio.Future]
     disconnection_result: Optional[asyncio.Future]
     open_result: Optional[asyncio.Future]
@@ -785,7 +790,7 @@ class Multiplexer(EventEmitter):
         # Become a sink for the L2CAP channel
         l2cap_channel.sink = self.on_pdu
 
-        l2cap_channel.on('close', self.on_l2cap_channel_close)
+        l2cap_channel.on(l2cap_channel.EVENT_CLOSE, self.on_l2cap_channel_close)
 
     def change_state(self, new_state: State) -> None:
         logger.debug(f'{self} state change -> {color(new_state.name, "cyan")}')
@@ -845,7 +850,7 @@ class Multiplexer(EventEmitter):
                 self.open_result.set_exception(
                     core.ConnectionError(
                         core.ConnectionError.CONNECTION_REFUSED,
-                        BT_BR_EDR_TRANSPORT,
+                        PhysicalTransport.BR_EDR,
                         self.l2cap_channel.connection.peer_address,
                         'rfcomm',
                     )
@@ -901,7 +906,7 @@ class Multiplexer(EventEmitter):
                         self.dlcs[pn.dlci] = dlc
 
                         # Re-emit the handshake completion event
-                        dlc.on('open', lambda: self.emit('dlc', dlc))
+                        dlc.on(dlc.EVENT_OPEN, lambda: self.emit(self.EVENT_DLC, dlc))
 
                         # Respond to complete the handshake
                         dlc.accept()
@@ -1075,7 +1080,9 @@ class Client:
 
 
 # -----------------------------------------------------------------------------
-class Server(EventEmitter):
+class Server(utils.EventEmitter):
+    EVENT_START = "start"
+
     def __init__(
         self, device: Device, l2cap_mtu: int = RFCOMM_DEFAULT_L2CAP_MTU
     ) -> None:
@@ -1122,7 +1129,9 @@ class Server(EventEmitter):
 
     def on_connection(self, l2cap_channel: l2cap.ClassicChannel) -> None:
         logger.debug(f'+++ new L2CAP connection: {l2cap_channel}')
-        l2cap_channel.on('open', lambda: self.on_l2cap_channel_open(l2cap_channel))
+        l2cap_channel.on(
+            l2cap_channel.EVENT_OPEN, lambda: self.on_l2cap_channel_open(l2cap_channel)
+        )
 
     def on_l2cap_channel_open(self, l2cap_channel: l2cap.ClassicChannel) -> None:
         logger.debug(f'$$$ L2CAP channel open: {l2cap_channel}')
@@ -1130,10 +1139,10 @@ class Server(EventEmitter):
         # Create a new multiplexer for the channel
         multiplexer = Multiplexer(l2cap_channel, Multiplexer.Role.RESPONDER)
         multiplexer.acceptor = self.accept_dlc
-        multiplexer.on('dlc', self.on_dlc)
+        multiplexer.on(multiplexer.EVENT_DLC, self.on_dlc)
 
         # Notify
-        self.emit('start', multiplexer)
+        self.emit(self.EVENT_START, multiplexer)
 
     def accept_dlc(self, channel_number: int) -> Optional[Tuple[int, int]]:
         return self.dlc_configs.get(channel_number)
diff --git a/bumble/rtp.py b/bumble/rtp.py
new file mode 100644
index 0000000..4ec68db
--- /dev/null
+++ b/bumble/rtp.py
@@ -0,0 +1,110 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
+from __future__ import annotations
+import struct
+from typing import List
+
+
+# -----------------------------------------------------------------------------
+class MediaPacket:
+    @staticmethod
+    def from_bytes(data: bytes) -> MediaPacket:
+        version = (data[0] >> 6) & 0x03
+        padding = (data[0] >> 5) & 0x01
+        extension = (data[0] >> 4) & 0x01
+        csrc_count = data[0] & 0x0F
+        marker = (data[1] >> 7) & 0x01
+        payload_type = data[1] & 0x7F
+        sequence_number = struct.unpack_from('>H', data, 2)[0]
+        timestamp = struct.unpack_from('>I', data, 4)[0]
+        ssrc = struct.unpack_from('>I', data, 8)[0]
+        csrc_list = [
+            struct.unpack_from('>I', data, 12 + i)[0] for i in range(csrc_count)
+        ]
+        payload = data[12 + csrc_count * 4 :]
+
+        return MediaPacket(
+            version,
+            padding,
+            extension,
+            marker,
+            sequence_number,
+            timestamp,
+            ssrc,
+            csrc_list,
+            payload_type,
+            payload,
+        )
+
+    def __init__(
+        self,
+        version: int,
+        padding: int,
+        extension: int,
+        marker: int,
+        sequence_number: int,
+        timestamp: int,
+        ssrc: int,
+        csrc_list: List[int],
+        payload_type: int,
+        payload: bytes,
+    ) -> None:
+        self.version = version
+        self.padding = padding
+        self.extension = extension
+        self.marker = marker
+        self.sequence_number = sequence_number & 0xFFFF
+        self.timestamp = timestamp & 0xFFFFFFFF
+        self.timestamp_seconds = 0.0
+        self.ssrc = ssrc
+        self.csrc_list = csrc_list
+        self.payload_type = payload_type
+        self.payload = payload
+
+    def __bytes__(self) -> bytes:
+        header = bytes(
+            [
+                self.version << 6
+                | self.padding << 5
+                | self.extension << 4
+                | len(self.csrc_list),
+                self.marker << 7 | self.payload_type,
+            ]
+        ) + struct.pack(
+            '>HII',
+            self.sequence_number,
+            self.timestamp,
+            self.ssrc,
+        )
+        for csrc in self.csrc_list:
+            header += struct.pack('>I', csrc)
+        return header + self.payload
+
+    def __str__(self) -> str:
+        return (
+            f'RTP(v={self.version},'
+            f'p={self.padding},'
+            f'x={self.extension},'
+            f'm={self.marker},'
+            f'pt={self.payload_type},'
+            f'sn={self.sequence_number},'
+            f'ts={self.timestamp},'
+            f'ssrc={self.ssrc},'
+            f'csrcs={self.csrc_list},'
+            f'payload_size={len(self.payload)})'
+        )
diff --git a/bumble/sdp.py b/bumble/sdp.py
index 88c575d..6b9fae9 100644
--- a/bumble/sdp.py
+++ b/bumble/sdp.py
@@ -16,18 +16,24 @@
 # Imports
 # -----------------------------------------------------------------------------
 from __future__ import annotations
+import asyncio
 import logging
 import struct
-from typing import Dict, List, Type, Optional, Tuple, Union, NewType, TYPE_CHECKING
+from typing import Iterable, NewType, Optional, Union, Sequence, Type, TYPE_CHECKING
 from typing_extensions import Self
 
-from . import core, l2cap
-from .colors import color
-from .core import InvalidStateError, InvalidArgumentError, InvalidPacketError
-from .hci import HCI_Object, name_or_number, key_with_value
+from bumble import core, l2cap
+from bumble.colors import color
+from bumble.core import (
+    InvalidStateError,
+    InvalidArgumentError,
+    InvalidPacketError,
+    ProtocolError,
+)
+from bumble.hci import HCI_Object, name_or_number, key_with_value
 
 if TYPE_CHECKING:
-    from .device import Device, Connection
+    from bumble.device import Device, Connection
 
 # -----------------------------------------------------------------------------
 # Logging
@@ -124,7 +130,7 @@ SDP_ATTRIBUTE_ID_NAMES = {
 SDP_PUBLIC_BROWSE_ROOT = core.UUID.from_16_bits(0x1002, 'PublicBrowseRoot')
 
 # To be used in searches where an attribute ID list allows a range to be specified
-SDP_ALL_ATTRIBUTES_RANGE = (0x0000FFFF, 4)  # Express this as tuple so we can convey the desired encoding size
+SDP_ALL_ATTRIBUTES_RANGE = (0x0000, 0xFFFF)
 
 # fmt: on
 # pylint: enable=line-too-long
@@ -242,11 +248,11 @@ class DataElement:
         return DataElement(DataElement.BOOLEAN, value)
 
     @staticmethod
-    def sequence(value: List[DataElement]) -> DataElement:
+    def sequence(value: Iterable[DataElement]) -> DataElement:
         return DataElement(DataElement.SEQUENCE, value)
 
     @staticmethod
-    def alternative(value: List[DataElement]) -> DataElement:
+    def alternative(value: Iterable[DataElement]) -> DataElement:
         return DataElement(DataElement.ALTERNATIVE, value)
 
     @staticmethod
@@ -344,9 +350,6 @@ class DataElement:
         ]  # Keep a copy so we can re-serialize to an exact replica
         return result
 
-    def to_bytes(self):
-        return bytes(self)
-
     def __bytes__(self):
         # Return early if we have a cache
         if self.bytes:
@@ -434,6 +437,8 @@ class DataElement:
             if size != 1:
                 raise InvalidArgumentError('boolean must be 1 byte')
             size_index = 0
+        else:
+            raise RuntimeError("internal error - self.type not supported")
 
         self.bytes = bytes([self.type << 3 | size_index]) + size_bytes + data
         return self.bytes
@@ -474,7 +479,9 @@ class ServiceAttribute:
         self.value = value
 
     @staticmethod
-    def list_from_data_elements(elements: List[DataElement]) -> List[ServiceAttribute]:
+    def list_from_data_elements(
+        elements: Sequence[DataElement],
+    ) -> list[ServiceAttribute]:
         attribute_list = []
         for i in range(0, len(elements) // 2):
             attribute_id, attribute_value = elements[2 * i : 2 * (i + 1)]
@@ -487,7 +494,7 @@ class ServiceAttribute:
 
     @staticmethod
     def find_attribute_in_list(
-        attribute_list: List[ServiceAttribute], attribute_id: int
+        attribute_list: Iterable[ServiceAttribute], attribute_id: int
     ) -> Optional[DataElement]:
         return next(
             (
@@ -535,7 +542,12 @@ class SDP_PDU:
     See Bluetooth spec @ Vol 3, Part B - 4.2 PROTOCOL DATA UNIT FORMAT
     '''
 
-    sdp_pdu_classes: Dict[int, Type[SDP_PDU]] = {}
+    RESPONSE_PDU_IDS = {
+        SDP_SERVICE_SEARCH_REQUEST: SDP_SERVICE_SEARCH_RESPONSE,
+        SDP_SERVICE_ATTRIBUTE_REQUEST: SDP_SERVICE_ATTRIBUTE_RESPONSE,
+        SDP_SERVICE_SEARCH_ATTRIBUTE_REQUEST: SDP_SERVICE_SEARCH_ATTRIBUTE_RESPONSE,
+    }
+    sdp_pdu_classes: dict[int, Type[SDP_PDU]] = {}
     name = None
     pdu_id = 0
 
@@ -559,7 +571,7 @@ class SDP_PDU:
     @staticmethod
     def parse_service_record_handle_list_preceded_by_count(
         data: bytes, offset: int
-    ) -> Tuple[int, List[int]]:
+    ) -> tuple[int, list[int]]:
         count = struct.unpack_from('>H', data, offset - 2)[0]
         handle_list = [
             struct.unpack_from('>I', data, offset + x * 4)[0] for x in range(count)
@@ -621,11 +633,8 @@ class SDP_PDU:
     def init_from_bytes(self, pdu, offset):
         return HCI_Object.init_from_bytes(self, pdu, offset, self.fields)
 
-    def to_bytes(self):
-        return self.pdu
-
     def __bytes__(self):
-        return self.to_bytes()
+        return self.pdu
 
     def __str__(self):
         result = f'{color(self.name, "blue")} [TID={self.transaction_id}]'
@@ -643,6 +652,8 @@ class SDP_ErrorResponse(SDP_PDU):
     See Bluetooth spec @ Vol 3, Part B - 4.4.1 SDP_ErrorResponse PDU
     '''
 
+    error_code: int
+
 
 # -----------------------------------------------------------------------------
 @SDP_PDU.subclass(
@@ -679,7 +690,7 @@ class SDP_ServiceSearchResponse(SDP_PDU):
     See Bluetooth spec @ Vol 3, Part B - 4.5.2 SDP_ServiceSearchResponse PDU
     '''
 
-    service_record_handle_list: List[int]
+    service_record_handle_list: list[int]
     total_service_record_count: int
     current_service_record_count: int
     continuation_state: bytes
@@ -756,31 +767,99 @@ class SDP_ServiceSearchAttributeResponse(SDP_PDU):
     See Bluetooth spec @ Vol 3, Part B - 4.7.2 SDP_ServiceSearchAttributeResponse PDU
     '''
 
-    attribute_list_byte_count: int
-    attribute_list: bytes
+    attribute_lists_byte_count: int
+    attribute_lists: bytes
     continuation_state: bytes
 
 
 # -----------------------------------------------------------------------------
 class Client:
-    channel: Optional[l2cap.ClassicChannel]
-
-    def __init__(self, connection: Connection) -> None:
+    def __init__(self, connection: Connection, mtu: int = 0) -> None:
         self.connection = connection
-        self.pending_request = None
-        self.channel = None
+        self.channel: Optional[l2cap.ClassicChannel] = None
+        self.mtu = mtu
+        self.request_semaphore = asyncio.Semaphore(1)
+        self.pending_request: Optional[SDP_PDU] = None
+        self.pending_response: Optional[asyncio.futures.Future[SDP_PDU]] = None
+        self.next_transaction_id = 0
 
     async def connect(self) -> None:
         self.channel = await self.connection.create_l2cap_channel(
-            spec=l2cap.ClassicChannelSpec(SDP_PSM)
+            spec=(
+                l2cap.ClassicChannelSpec(SDP_PSM, self.mtu)
+                if self.mtu
+                else l2cap.ClassicChannelSpec(SDP_PSM)
+            )
         )
+        self.channel.sink = self.on_pdu
 
     async def disconnect(self) -> None:
         if self.channel:
             await self.channel.disconnect()
             self.channel = None
 
-    async def search_services(self, uuids: List[core.UUID]) -> List[int]:
+    def make_transaction_id(self) -> int:
+        transaction_id = self.next_transaction_id
+        self.next_transaction_id = (self.next_transaction_id + 1) & 0xFFFF
+        return transaction_id
+
+    def on_pdu(self, pdu: bytes) -> None:
+        if not self.pending_request:
+            logger.warning('received response with no pending request')
+            return
+        assert self.pending_response is not None
+
+        response = SDP_PDU.from_bytes(pdu)
+
+        # Check that the transaction ID is what we expect
+        if self.pending_request.transaction_id != response.transaction_id:
+            logger.warning(
+                f"received response with transaction ID {response.transaction_id} "
+                f"but expected {self.pending_request.transaction_id}"
+            )
+            return
+
+        # Check if the response is an error
+        if isinstance(response, SDP_ErrorResponse):
+            self.pending_response.set_exception(
+                ProtocolError(error_code=response.error_code)
+            )
+            return
+
+        # Check that the type of the response matches the request
+        if response.pdu_id != SDP_PDU.RESPONSE_PDU_IDS.get(self.pending_request.pdu_id):
+            logger.warning("response type mismatch")
+            return
+
+        self.pending_response.set_result(response)
+
+    async def send_request(self, request: SDP_PDU) -> SDP_PDU:
+        assert self.channel is not None
+        async with self.request_semaphore:
+            assert self.pending_request is None
+            assert self.pending_response is None
+
+            # Create a future value to hold the eventual response
+            self.pending_response = asyncio.get_running_loop().create_future()
+            self.pending_request = request
+
+            try:
+                self.channel.send_pdu(bytes(request))
+                return await self.pending_response
+            finally:
+                self.pending_request = None
+                self.pending_response = None
+
+    async def search_services(self, uuids: Iterable[core.UUID]) -> list[int]:
+        """
+        Search for services by UUID.
+
+        Args:
+          uuids: service the UUIDs to search for.
+
+        Returns:
+          A list of matching service record handles.
+        """
         if self.pending_request is not None:
             raise InvalidStateError('request already pending')
         if self.channel is None:
@@ -795,16 +874,16 @@ class Client:
         continuation_state = bytes([0])
         watchdog = SDP_CONTINUATION_WATCHDOG
         while watchdog > 0:
-            response_pdu = await self.channel.send_request(
+            response = await self.send_request(
                 SDP_ServiceSearchRequest(
-                    transaction_id=0,  # Transaction ID TODO: pick a real value
+                    transaction_id=self.make_transaction_id(),
                     service_search_pattern=service_search_pattern,
                     maximum_service_record_count=0xFFFF,
                     continuation_state=continuation_state,
                 )
             )
-            response = SDP_PDU.from_bytes(response_pdu)
             logger.debug(f'<<< Response: {response}')
+            assert isinstance(response, SDP_ServiceSearchResponse)
             service_record_handle_list += response.service_record_handle_list
             continuation_state = response.continuation_state
             if len(continuation_state) == 1 and continuation_state[0] == 0:
@@ -815,8 +894,21 @@ class Client:
         return service_record_handle_list
 
     async def search_attributes(
-        self, uuids: List[core.UUID], attribute_ids: List[Union[int, Tuple[int, int]]]
-    ) -> List[List[ServiceAttribute]]:
+        self,
+        uuids: Iterable[core.UUID],
+        attribute_ids: Iterable[Union[int, tuple[int, int]]],
+    ) -> list[list[ServiceAttribute]]:
+        """
+        Search for attributes by UUID and attribute IDs.
+
+        Args:
+          uuids: the service UUIDs to search for.
+          attribute_ids: list of attribute IDs or (start, end) attribute ID ranges.
+          (use (0, 0xFFFF) to include all attributes)
+
+        Returns:
+          A list of list of attributes, one list per matching service.
+        """
         if self.pending_request is not None:
             raise InvalidStateError('request already pending')
         if self.channel is None:
@@ -828,8 +920,8 @@ class Client:
         attribute_id_list = DataElement.sequence(
             [
                 (
-                    DataElement.unsigned_integer(
-                        attribute_id[0], value_size=attribute_id[1]
+                    DataElement.unsigned_integer_32(
+                        attribute_id[0] << 16 | attribute_id[1]
                     )
                     if isinstance(attribute_id, tuple)
                     else DataElement.unsigned_integer_16(attribute_id)
@@ -843,17 +935,17 @@ class Client:
         continuation_state = bytes([0])
         watchdog = SDP_CONTINUATION_WATCHDOG
         while watchdog > 0:
-            response_pdu = await self.channel.send_request(
+            response = await self.send_request(
                 SDP_ServiceSearchAttributeRequest(
-                    transaction_id=0,  # Transaction ID TODO: pick a real value
+                    transaction_id=self.make_transaction_id(),
                     service_search_pattern=service_search_pattern,
                     maximum_attribute_byte_count=0xFFFF,
                     attribute_id_list=attribute_id_list,
                     continuation_state=continuation_state,
                 )
             )
-            response = SDP_PDU.from_bytes(response_pdu)
             logger.debug(f'<<< Response: {response}')
+            assert isinstance(response, SDP_ServiceSearchAttributeResponse)
             accumulator += response.attribute_lists
             continuation_state = response.continuation_state
             if len(continuation_state) == 1 and continuation_state[0] == 0:
@@ -876,8 +968,18 @@ class Client:
     async def get_attributes(
         self,
         service_record_handle: int,
-        attribute_ids: List[Union[int, Tuple[int, int]]],
-    ) -> List[ServiceAttribute]:
+        attribute_ids: Iterable[Union[int, tuple[int, int]]],
+    ) -> list[ServiceAttribute]:
+        """
+        Get attributes for a service.
+
+        Args:
+          service_record_handle: the handle for a service
+          attribute_ids: list or attribute IDs or (start, end) attribute ID handles.
+
+        Returns:
+          A list of attributes.
+        """
         if self.pending_request is not None:
             raise InvalidStateError('request already pending')
         if self.channel is None:
@@ -886,8 +988,8 @@ class Client:
         attribute_id_list = DataElement.sequence(
             [
                 (
-                    DataElement.unsigned_integer(
-                        attribute_id[0], value_size=attribute_id[1]
+                    DataElement.unsigned_integer_32(
+                        attribute_id[0] << 16 | attribute_id[1]
                     )
                     if isinstance(attribute_id, tuple)
                     else DataElement.unsigned_integer_16(attribute_id)
@@ -901,17 +1003,17 @@ class Client:
         continuation_state = bytes([0])
         watchdog = SDP_CONTINUATION_WATCHDOG
         while watchdog > 0:
-            response_pdu = await self.channel.send_request(
+            response = await self.send_request(
                 SDP_ServiceAttributeRequest(
-                    transaction_id=0,  # Transaction ID TODO: pick a real value
+                    transaction_id=self.make_transaction_id(),
                     service_record_handle=service_record_handle,
                     maximum_attribute_byte_count=0xFFFF,
                     attribute_id_list=attribute_id_list,
                     continuation_state=continuation_state,
                 )
             )
-            response = SDP_PDU.from_bytes(response_pdu)
             logger.debug(f'<<< Response: {response}')
+            assert isinstance(response, SDP_ServiceAttributeResponse)
             accumulator += response.attribute_list
             continuation_state = response.continuation_state
             if len(continuation_state) == 1 and continuation_state[0] == 0:
@@ -937,17 +1039,17 @@ class Client:
 
 # -----------------------------------------------------------------------------
 class Server:
-    CONTINUATION_STATE = bytes([0x01, 0x43])
+    CONTINUATION_STATE = bytes([0x01, 0x00])
     channel: Optional[l2cap.ClassicChannel]
-    Service = NewType('Service', List[ServiceAttribute])
-    service_records: Dict[int, Service]
-    current_response: Union[None, bytes, Tuple[int, List[int]]]
+    Service = NewType('Service', list[ServiceAttribute])
+    service_records: dict[int, Service]
+    current_response: Union[None, bytes, tuple[int, list[int]]]
 
     def __init__(self, device: Device) -> None:
         self.device = device
         self.service_records = {}  # Service records maps, by record handle
         self.channel = None
-        self.current_response = None
+        self.current_response = None  # Current response data, used for continuations
 
     def register(self, l2cap_channel_manager: l2cap.ChannelManager) -> None:
         l2cap_channel_manager.create_classic_server(
@@ -958,7 +1060,7 @@ class Server:
         logger.debug(f'{color(">>> Sending SDP Response", "blue")}: {response}')
         self.channel.send_pdu(response)
 
-    def match_services(self, search_pattern: DataElement) -> Dict[int, Service]:
+    def match_services(self, search_pattern: DataElement) -> dict[int, Service]:
         # Find the services for which the attributes in the pattern is a subset of the
         # service's attribute values (NOTE: the value search recurses into sequences)
         matching_services = {}
@@ -1015,6 +1117,31 @@ class Server:
                 )
             )
 
+    def check_continuation(
+        self,
+        continuation_state: bytes,
+        transaction_id: int,
+    ) -> Optional[bool]:
+        # Check if this is a valid continuation
+        if len(continuation_state) > 1:
+            if (
+                self.current_response is None
+                or continuation_state != self.CONTINUATION_STATE
+            ):
+                self.send_response(
+                    SDP_ErrorResponse(
+                        transaction_id=transaction_id,
+                        error_code=SDP_INVALID_CONTINUATION_STATE_ERROR,
+                    )
+                )
+                return None
+            return True
+
+        # Cleanup any partial response leftover
+        self.current_response = None
+
+        return False
+
     def get_next_response_payload(self, maximum_size):
         if len(self.current_response) > maximum_size:
             payload = self.current_response[:maximum_size]
@@ -1029,7 +1156,7 @@ class Server:
 
     @staticmethod
     def get_service_attributes(
-        service: Service, attribute_ids: List[DataElement]
+        service: Service, attribute_ids: Iterable[DataElement]
     ) -> DataElement:
         attributes = []
         for attribute_id in attribute_ids:
@@ -1057,30 +1184,24 @@ class Server:
 
     def on_sdp_service_search_request(self, request: SDP_ServiceSearchRequest) -> None:
         # Check if this is a continuation
-        if len(request.continuation_state) > 1:
-            if self.current_response is None:
-                self.send_response(
-                    SDP_ErrorResponse(
-                        transaction_id=request.transaction_id,
-                        error_code=SDP_INVALID_CONTINUATION_STATE_ERROR,
-                    )
-                )
-                return
-        else:
-            # Cleanup any partial response leftover
-            self.current_response = None
+        if (
+            continuation := self.check_continuation(
+                request.continuation_state, request.transaction_id
+            )
+        ) is None:
+            return
 
+        if not continuation:
             # Find the matching services
             matching_services = self.match_services(request.service_search_pattern)
             service_record_handles = list(matching_services.keys())
+            logger.debug(f'Service Record Handles: {service_record_handles}')
 
             # Only return up to the maximum requested
             service_record_handles_subset = service_record_handles[
                 : request.maximum_service_record_count
             ]
 
-            # Serialize to a byte array, and remember the total count
-            logger.debug(f'Service Record Handles: {service_record_handles}')
             self.current_response = (
                 len(service_record_handles),
                 service_record_handles_subset,
@@ -1088,15 +1209,21 @@ class Server:
 
         # Respond, keeping any unsent handles for later
         assert isinstance(self.current_response, tuple)
-        service_record_handles = self.current_response[1][
-            : request.maximum_service_record_count
+        assert self.channel is not None
+        total_service_record_count, service_record_handles = self.current_response
+        maximum_service_record_count = (self.channel.peer_mtu - 11) // 4
+        service_record_handles_remaining = service_record_handles[
+            maximum_service_record_count:
         ]
+        service_record_handles = service_record_handles[:maximum_service_record_count]
         self.current_response = (
-            self.current_response[0],
-            self.current_response[1][request.maximum_service_record_count :],
+            total_service_record_count,
+            service_record_handles_remaining,
         )
         continuation_state = (
-            Server.CONTINUATION_STATE if self.current_response[1] else bytes([0])
+            Server.CONTINUATION_STATE
+            if service_record_handles_remaining
+            else bytes([0])
         )
         service_record_handle_list = b''.join(
             [struct.pack('>I', handle) for handle in service_record_handles]
@@ -1104,7 +1231,7 @@ class Server:
         self.send_response(
             SDP_ServiceSearchResponse(
                 transaction_id=request.transaction_id,
-                total_service_record_count=self.current_response[0],
+                total_service_record_count=total_service_record_count,
                 current_service_record_count=len(service_record_handles),
                 service_record_handle_list=service_record_handle_list,
                 continuation_state=continuation_state,
@@ -1115,19 +1242,14 @@ class Server:
         self, request: SDP_ServiceAttributeRequest
     ) -> None:
         # Check if this is a continuation
-        if len(request.continuation_state) > 1:
-            if self.current_response is None:
-                self.send_response(
-                    SDP_ErrorResponse(
-                        transaction_id=request.transaction_id,
-                        error_code=SDP_INVALID_CONTINUATION_STATE_ERROR,
-                    )
-                )
-                return
-        else:
-            # Cleanup any partial response leftover
-            self.current_response = None
+        if (
+            continuation := self.check_continuation(
+                request.continuation_state, request.transaction_id
+            )
+        ) is None:
+            return
 
+        if not continuation:
             # Check that the service exists
             service = self.service_records.get(request.service_record_handle)
             if service is None:
@@ -1149,14 +1271,18 @@ class Server:
             self.current_response = bytes(attribute_list)
 
         # Respond, keeping any pending chunks for later
+        assert self.channel is not None
+        maximum_attribute_byte_count = min(
+            request.maximum_attribute_byte_count, self.channel.peer_mtu - 9
+        )
         attribute_list_response, continuation_state = self.get_next_response_payload(
-            request.maximum_attribute_byte_count
+            maximum_attribute_byte_count
         )
         self.send_response(
             SDP_ServiceAttributeResponse(
                 transaction_id=request.transaction_id,
                 attribute_list_byte_count=len(attribute_list_response),
-                attribute_list=attribute_list,
+                attribute_list=attribute_list_response,
                 continuation_state=continuation_state,
             )
         )
@@ -1165,18 +1291,14 @@ class Server:
         self, request: SDP_ServiceSearchAttributeRequest
     ) -> None:
         # Check if this is a continuation
-        if len(request.continuation_state) > 1:
-            if self.current_response is None:
-                self.send_response(
-                    SDP_ErrorResponse(
-                        transaction_id=request.transaction_id,
-                        error_code=SDP_INVALID_CONTINUATION_STATE_ERROR,
-                    )
-                )
-        else:
-            # Cleanup any partial response leftover
-            self.current_response = None
+        if (
+            continuation := self.check_continuation(
+                request.continuation_state, request.transaction_id
+            )
+        ) is None:
+            return
 
+        if not continuation:
             # Find the matching services
             matching_services = self.match_services(
                 request.service_search_pattern
@@ -1196,14 +1318,18 @@ class Server:
             self.current_response = bytes(attribute_lists)
 
         # Respond, keeping any pending chunks for later
+        assert self.channel is not None
+        maximum_attribute_byte_count = min(
+            request.maximum_attribute_byte_count, self.channel.peer_mtu - 9
+        )
         attribute_lists_response, continuation_state = self.get_next_response_payload(
-            request.maximum_attribute_byte_count
+            maximum_attribute_byte_count
         )
         self.send_response(
             SDP_ServiceSearchAttributeResponse(
                 transaction_id=request.transaction_id,
                 attribute_lists_byte_count=len(attribute_lists_response),
-                attribute_lists=attribute_lists,
+                attribute_lists=attribute_lists_response,
                 continuation_state=continuation_state,
             )
         )
diff --git a/bumble/smp.py b/bumble/smp.py
index c055e71..bd47fc8 100644
--- a/bumble/smp.py
+++ b/bumble/smp.py
@@ -41,26 +41,25 @@ from typing import (
     cast,
 )
 
-from pyee import EventEmitter
 
-from .colors import color
-from .hci import (
+from bumble.colors import color
+from bumble.hci import (
     Address,
+    Role,
     HCI_LE_Enable_Encryption_Command,
     HCI_Object,
     key_with_value,
 )
-from .core import (
-    BT_BR_EDR_TRANSPORT,
-    BT_CENTRAL_ROLE,
-    BT_LE_TRANSPORT,
+from bumble.core import (
+    PhysicalTransport,
     AdvertisingData,
     InvalidArgumentError,
     ProtocolError,
     name_or_number,
 )
-from .keys import PairingKeys
-from . import crypto
+from bumble.keys import PairingKeys
+from bumble import crypto
+from bumble import utils
 
 if TYPE_CHECKING:
     from bumble.device import Connection, Device
@@ -298,11 +297,8 @@ class SMP_Command:
     def init_from_bytes(self, pdu: bytes, offset: int) -> None:
         return HCI_Object.init_from_bytes(self, pdu, offset, self.fields)
 
-    def to_bytes(self):
-        return self.pdu
-
     def __bytes__(self):
-        return self.to_bytes()
+        return self.pdu
 
     def __str__(self):
         result = color(self.name, 'yellow')
@@ -698,6 +694,7 @@ class Session:
         self.ltk_ediv = 0
         self.ltk_rand = bytes(8)
         self.link_key: Optional[bytes] = None
+        self.maximum_encryption_key_size: int = 0
         self.initiator_key_distribution: int = 0
         self.responder_key_distribution: int = 0
         self.peer_random_value: Optional[bytes] = None
@@ -727,12 +724,13 @@ class Session:
         self.is_responder = not self.is_initiator
 
         # Listen for connection events
-        connection.on('disconnection', self.on_disconnection)
+        connection.on(connection.EVENT_DISCONNECTION, self.on_disconnection)
         connection.on(
-            'connection_encryption_change', self.on_connection_encryption_change
+            connection.EVENT_CONNECTION_ENCRYPTION_CHANGE,
+            self.on_connection_encryption_change,
         )
         connection.on(
-            'connection_encryption_key_refresh',
+            connection.EVENT_CONNECTION_ENCRYPTION_KEY_REFRESH,
             self.on_connection_encryption_key_refresh,
         )
 
@@ -744,6 +742,10 @@ class Session:
         else:
             self.pairing_result = None
 
+        self.maximum_encryption_key_size = (
+            pairing_config.delegate.maximum_encryption_key_size
+        )
+
         # Key Distribution (default values before negotiation)
         self.initiator_key_distribution = (
             pairing_config.delegate.local_initiator_key_distribution
@@ -855,7 +857,7 @@ class Session:
         initiator_io_capability: int,
         responder_io_capability: int,
     ) -> None:
-        if self.connection.transport == BT_BR_EDR_TRANSPORT:
+        if self.connection.transport == PhysicalTransport.BR_EDR:
             self.pairing_method = PairingMethod.CTKD_OVER_CLASSIC
             return
         if (not self.mitm) and (auth_req & SMP_MITM_AUTHREQ == 0):
@@ -898,7 +900,7 @@ class Session:
 
             self.send_pairing_failed(SMP_CONFIRM_VALUE_FAILED_ERROR)
 
-        self.connection.abort_on('disconnection', prompt())
+        utils.cancel_on_event(self.connection, 'disconnection', prompt())
 
     def prompt_user_for_numeric_comparison(
         self, code: int, next_steps: Callable[[], None]
@@ -917,7 +919,7 @@ class Session:
 
             self.send_pairing_failed(SMP_CONFIRM_VALUE_FAILED_ERROR)
 
-        self.connection.abort_on('disconnection', prompt())
+        utils.cancel_on_event(self.connection, 'disconnection', prompt())
 
     def prompt_user_for_number(self, next_steps: Callable[[int], None]) -> None:
         async def prompt() -> None:
@@ -934,7 +936,7 @@ class Session:
                 logger.warning(f'exception while prompting: {error}')
                 self.send_pairing_failed(SMP_PASSKEY_ENTRY_FAILED_ERROR)
 
-        self.connection.abort_on('disconnection', prompt())
+        utils.cancel_on_event(self.connection, 'disconnection', prompt())
 
     def display_passkey(self) -> None:
         # Generate random Passkey/PIN code
@@ -949,7 +951,8 @@ class Session:
             logger.debug(f'TK from passkey = {self.tk.hex()}')
 
         try:
-            self.connection.abort_on(
+            utils.cancel_on_event(
+                self.connection,
                 'disconnection',
                 self.pairing_config.delegate.display_number(self.passkey, digits=6),
             )
@@ -996,7 +999,7 @@ class Session:
             io_capability=self.io_capability,
             oob_data_flag=self.oob_data_flag,
             auth_req=self.auth_req,
-            maximum_encryption_key_size=16,
+            maximum_encryption_key_size=self.maximum_encryption_key_size,
             initiator_key_distribution=self.initiator_key_distribution,
             responder_key_distribution=self.responder_key_distribution,
         )
@@ -1008,7 +1011,7 @@ class Session:
             io_capability=self.io_capability,
             oob_data_flag=self.oob_data_flag,
             auth_req=self.auth_req,
-            maximum_encryption_key_size=16,
+            maximum_encryption_key_size=self.maximum_encryption_key_size,
             initiator_key_distribution=self.initiator_key_distribution,
             responder_key_distribution=self.responder_key_distribution,
         )
@@ -1048,7 +1051,7 @@ class Session:
                 )
 
             # Perform the next steps asynchronously in case we need to wait for input
-            self.connection.abort_on('disconnection', next_steps())
+            utils.cancel_on_event(self.connection, 'disconnection', next_steps())
         else:
             confirm_value = crypto.c1(
                 self.tk,
@@ -1168,11 +1171,11 @@ class Session:
         if self.is_initiator:
             # CTKD: Derive LTK from LinkKey
             if (
-                self.connection.transport == BT_BR_EDR_TRANSPORT
+                self.connection.transport == PhysicalTransport.BR_EDR
                 and self.initiator_key_distribution & SMP_ENC_KEY_DISTRIBUTION_FLAG
             ):
-                self.ctkd_task = self.connection.abort_on(
-                    'disconnection', self.get_link_key_and_derive_ltk()
+                self.ctkd_task = utils.cancel_on_event(
+                    self.connection, 'disconnection', self.get_link_key_and_derive_ltk()
                 )
             elif not self.sc:
                 # Distribute the LTK, EDIV and RAND
@@ -1207,11 +1210,11 @@ class Session:
         else:
             # CTKD: Derive LTK from LinkKey
             if (
-                self.connection.transport == BT_BR_EDR_TRANSPORT
+                self.connection.transport == PhysicalTransport.BR_EDR
                 and self.responder_key_distribution & SMP_ENC_KEY_DISTRIBUTION_FLAG
             ):
-                self.ctkd_task = self.connection.abort_on(
-                    'disconnection', self.get_link_key_and_derive_ltk()
+                self.ctkd_task = utils.cancel_on_event(
+                    self.connection, 'disconnection', self.get_link_key_and_derive_ltk()
                 )
             # Distribute the LTK, EDIV and RAND
             elif not self.sc:
@@ -1246,7 +1249,7 @@ class Session:
     def compute_peer_expected_distributions(self, key_distribution_flags: int) -> None:
         # Set our expectations for what to wait for in the key distribution phase
         self.peer_expected_distributions = []
-        if not self.sc and self.connection.transport == BT_LE_TRANSPORT:
+        if not self.sc and self.connection.transport == PhysicalTransport.LE:
             if key_distribution_flags & SMP_ENC_KEY_DISTRIBUTION_FLAG != 0:
                 self.peer_expected_distributions.append(
                     SMP_Encryption_Information_Command
@@ -1303,15 +1306,20 @@ class Session:
 
         # Wait for the pairing process to finish
         assert self.pairing_result
-        await self.connection.abort_on('disconnection', self.pairing_result)
+        await utils.cancel_on_event(
+            self.connection, 'disconnection', self.pairing_result
+        )
 
     def on_disconnection(self, _: int) -> None:
-        self.connection.remove_listener('disconnection', self.on_disconnection)
         self.connection.remove_listener(
-            'connection_encryption_change', self.on_connection_encryption_change
+            self.connection.EVENT_DISCONNECTION, self.on_disconnection
         )
         self.connection.remove_listener(
-            'connection_encryption_key_refresh',
+            self.connection.EVENT_CONNECTION_ENCRYPTION_CHANGE,
+            self.on_connection_encryption_change,
+        )
+        self.connection.remove_listener(
+            self.connection.EVENT_CONNECTION_ENCRYPTION_KEY_REFRESH,
             self.on_connection_encryption_key_refresh,
         )
         self.manager.on_session_end(self)
@@ -1321,10 +1329,10 @@ class Session:
         if self.is_initiator:
             self.distribute_keys()
 
-        self.connection.abort_on('disconnection', self.on_pairing())
+        utils.cancel_on_event(self.connection, 'disconnection', self.on_pairing())
 
     def on_connection_encryption_change(self) -> None:
-        if self.connection.is_encrypted:
+        if self.connection.is_encrypted and not self.completed:
             if self.is_responder:
                 # The responder distributes its keys first, the initiator later
                 self.distribute_keys()
@@ -1363,7 +1371,7 @@ class Session:
         keys = PairingKeys()
         keys.address_type = peer_address.address_type
         authenticated = self.pairing_method != PairingMethod.JUST_WORKS
-        if self.sc or self.connection.transport == BT_BR_EDR_TRANSPORT:
+        if self.sc or self.connection.transport == PhysicalTransport.BR_EDR:
             keys.ltk = PairingKeys.Key(value=self.ltk, authenticated=authenticated)
         else:
             our_ltk_key = PairingKeys.Key(
@@ -1372,8 +1380,10 @@ class Session:
                 ediv=self.ltk_ediv,
                 rand=self.ltk_rand,
             )
+            if not self.peer_ltk:
+                logger.error("peer_ltk is None")
             peer_ltk_key = PairingKeys.Key(
-                value=self.peer_ltk,
+                value=self.peer_ltk or b'',
                 authenticated=authenticated,
                 ediv=self.peer_ediv,
                 rand=self.peer_rand,
@@ -1430,8 +1440,10 @@ class Session:
     def on_smp_pairing_request_command(
         self, command: SMP_Pairing_Request_Command
     ) -> None:
-        self.connection.abort_on(
-            'disconnection', self.on_smp_pairing_request_command_async(command)
+        utils.cancel_on_event(
+            self.connection,
+            'disconnection',
+            self.on_smp_pairing_request_command_async(command),
         )
 
     async def on_smp_pairing_request_command_async(
@@ -1504,7 +1516,7 @@ class Session:
         # CTKD over BR/EDR should happen after the connection has been encrypted,
         # so when receiving pairing requests, responder should start distributing keys
         if (
-            self.connection.transport == BT_BR_EDR_TRANSPORT
+            self.connection.transport == PhysicalTransport.BR_EDR
             and self.connection.is_encrypted
             and self.is_responder
             and accepted
@@ -1839,7 +1851,7 @@ class Session:
         if self.is_initiator:
             if self.pairing_method == PairingMethod.OOB:
                 self.send_pairing_random_command()
-            else:
+            elif self.pairing_method == PairingMethod.PASSKEY:
                 self.send_pairing_confirm_command()
         else:
             if self.pairing_method == PairingMethod.PASSKEY:
@@ -1876,7 +1888,7 @@ class Session:
                     self.wait_before_continuing = None
                     self.send_pairing_dhkey_check_command()
 
-                self.connection.abort_on('disconnection', next_steps())
+                utils.cancel_on_event(self.connection, 'disconnection', next_steps())
             else:
                 self.send_pairing_dhkey_check_command()
         else:
@@ -1920,7 +1932,7 @@ class Session:
 
 
 # -----------------------------------------------------------------------------
-class Manager(EventEmitter):
+class Manager(utils.EventEmitter):
     '''
     Implements the Initiator and Responder roles of the Security Manager Protocol
     '''
@@ -1948,13 +1960,15 @@ class Manager(EventEmitter):
             f'>>> Sending SMP Command on connection [0x{connection.handle:04X}] '
             f'{connection.peer_address}: {command}'
         )
-        cid = SMP_BR_CID if connection.transport == BT_BR_EDR_TRANSPORT else SMP_CID
-        connection.send_l2cap_pdu(cid, command.to_bytes())
+        cid = (
+            SMP_BR_CID if connection.transport == PhysicalTransport.BR_EDR else SMP_CID
+        )
+        connection.send_l2cap_pdu(cid, bytes(command))
 
     def on_smp_security_request_command(
         self, connection: Connection, request: SMP_Security_Request_Command
     ) -> None:
-        connection.emit('security_request', request.auth_req)
+        connection.emit(connection.EVENT_SECURITY_REQUEST, request.auth_req)
 
     def on_smp_pdu(self, connection: Connection, pdu: bytes) -> None:
         # Parse the L2CAP payload into an SMP Command object
@@ -1973,7 +1987,7 @@ class Manager(EventEmitter):
 
         # Look for a session with this connection, and create one if none exists
         if not (session := self.sessions.get(connection.handle)):
-            if connection.role == BT_CENTRAL_ROLE:
+            if connection.role == Role.CENTRAL:
                 logger.warning('Remote starts pairing as Peripheral!')
             pairing_config = self.pairing_config_factory(connection)
             session = self.session_proxy(
@@ -1993,7 +2007,7 @@ class Manager(EventEmitter):
 
     async def pair(self, connection: Connection) -> None:
         # TODO: check if there's already a session for this connection
-        if connection.role != BT_CENTRAL_ROLE:
+        if connection.role != Role.CENTRAL:
             logger.warning('Start pairing as Peripheral!')
         pairing_config = self.pairing_config_factory(connection)
         session = self.session_proxy(
diff --git a/bumble/transport/__init__.py b/bumble/transport/__init__.py
index 0d42343..34bf374 100644
--- a/bumble/transport/__init__.py
+++ b/bumble/transport/__init__.py
@@ -20,8 +20,13 @@ import logging
 import os
 from typing import Optional
 
-from .common import Transport, AsyncPipeSink, SnoopingTransport, TransportSpecError
-from ..snoop import create_snooper
+from bumble.transport.common import (
+    Transport,
+    AsyncPipeSink,
+    SnoopingTransport,
+    TransportSpecError,
+)
+from bumble.snoop import create_snooper
 
 # -----------------------------------------------------------------------------
 # Logging
@@ -108,80 +113,80 @@ async def _open_transport(scheme: str, spec: Optional[str]) -> Transport:
     # pylint: disable=too-many-return-statements
 
     if scheme == 'serial' and spec:
-        from .serial import open_serial_transport
+        from bumble.transport.serial import open_serial_transport
 
         return await open_serial_transport(spec)
 
     if scheme == 'udp' and spec:
-        from .udp import open_udp_transport
+        from bumble.transport.udp import open_udp_transport
 
         return await open_udp_transport(spec)
 
     if scheme == 'tcp-client' and spec:
-        from .tcp_client import open_tcp_client_transport
+        from bumble.transport.tcp_client import open_tcp_client_transport
 
         return await open_tcp_client_transport(spec)
 
     if scheme == 'tcp-server' and spec:
-        from .tcp_server import open_tcp_server_transport
+        from bumble.transport.tcp_server import open_tcp_server_transport
 
         return await open_tcp_server_transport(spec)
 
     if scheme == 'ws-client' and spec:
-        from .ws_client import open_ws_client_transport
+        from bumble.transport.ws_client import open_ws_client_transport
 
         return await open_ws_client_transport(spec)
 
     if scheme == 'ws-server' and spec:
-        from .ws_server import open_ws_server_transport
+        from bumble.transport.ws_server import open_ws_server_transport
 
         return await open_ws_server_transport(spec)
 
     if scheme == 'pty':
-        from .pty import open_pty_transport
+        from bumble.transport.pty import open_pty_transport
 
         return await open_pty_transport(spec)
 
     if scheme == 'file':
-        from .file import open_file_transport
+        from bumble.transport.file import open_file_transport
 
         assert spec is not None
         return await open_file_transport(spec)
 
     if scheme == 'vhci':
-        from .vhci import open_vhci_transport
+        from bumble.transport.vhci import open_vhci_transport
 
         return await open_vhci_transport(spec)
 
     if scheme == 'hci-socket':
-        from .hci_socket import open_hci_socket_transport
+        from bumble.transport.hci_socket import open_hci_socket_transport
 
         return await open_hci_socket_transport(spec)
 
     if scheme == 'usb':
-        from .usb import open_usb_transport
+        from bumble.transport.usb import open_usb_transport
 
         assert spec
         return await open_usb_transport(spec)
 
     if scheme == 'pyusb':
-        from .pyusb import open_pyusb_transport
+        from bumble.transport.pyusb import open_pyusb_transport
 
         assert spec
         return await open_pyusb_transport(spec)
 
     if scheme == 'android-emulator':
-        from .android_emulator import open_android_emulator_transport
+        from bumble.transport.android_emulator import open_android_emulator_transport
 
         return await open_android_emulator_transport(spec)
 
     if scheme == 'android-netsim':
-        from .android_netsim import open_android_netsim_transport
+        from bumble.transport.android_netsim import open_android_netsim_transport
 
         return await open_android_netsim_transport(spec)
 
     if scheme == 'unix':
-        from .unix import open_unix_client_transport
+        from bumble.transport.unix import open_unix_client_transport
 
         assert spec
         return await open_unix_client_transport(spec)
@@ -204,8 +209,8 @@ async def open_transport_or_link(name: str) -> Transport:
     """
     if name.startswith('link-relay:'):
         logger.warning('Link Relay has been deprecated.')
-        from ..controller import Controller
-        from ..link import RemoteLink  # lazy import
+        from bumble.controller import Controller
+        from bumble.link import RemoteLink  # lazy import
 
         link = RemoteLink(name[11:])
         await link.wait_until_connected()
diff --git a/bumble/transport/android_emulator.py b/bumble/transport/android_emulator.py
index d2bc8ef..5796412 100644
--- a/bumble/transport/android_emulator.py
+++ b/bumble/transport/android_emulator.py
@@ -20,7 +20,7 @@ import grpc.aio
 
 from typing import Optional, Union
 
-from .common import (
+from bumble.transport.common import (
     PumpedTransport,
     PumpedPacketSource,
     PumpedPacketSink,
@@ -29,9 +29,13 @@ from .common import (
 )
 
 # pylint: disable=no-name-in-module
-from .grpc_protobuf.emulated_bluetooth_pb2_grpc import EmulatedBluetoothServiceStub
-from .grpc_protobuf.emulated_bluetooth_packets_pb2 import HCIPacket
-from .grpc_protobuf.emulated_bluetooth_vhci_pb2_grpc import VhciForwardingServiceStub
+from bumble.transport.grpc_protobuf.emulated_bluetooth_pb2_grpc import (
+    EmulatedBluetoothServiceStub,
+)
+from bumble.transport.grpc_protobuf.emulated_bluetooth_packets_pb2 import HCIPacket
+from bumble.transport.grpc_protobuf.emulated_bluetooth_vhci_pb2_grpc import (
+    VhciForwardingServiceStub,
+)
 
 
 # -----------------------------------------------------------------------------
diff --git a/bumble/transport/android_netsim.py b/bumble/transport/android_netsim.py
index 9a3e016..f4943e4 100644
--- a/bumble/transport/android_netsim.py
+++ b/bumble/transport/android_netsim.py
@@ -20,12 +20,14 @@ import atexit
 import logging
 import os
 import pathlib
+import platform
 import sys
 from typing import Dict, Optional
 
 import grpc.aio
 
-from .common import (
+import bumble
+from bumble.transport.common import (
     ParserSource,
     PumpedTransport,
     PumpedPacketSource,
@@ -36,15 +38,18 @@ from .common import (
 )
 
 # pylint: disable=no-name-in-module
-from .grpc_protobuf.packet_streamer_pb2_grpc import (
+from bumble.transport.grpc_protobuf.netsim.packet_streamer_pb2_grpc import (
     PacketStreamerStub,
     PacketStreamerServicer,
     add_PacketStreamerServicer_to_server,
 )
-from .grpc_protobuf.packet_streamer_pb2 import PacketRequest, PacketResponse
-from .grpc_protobuf.hci_packet_pb2 import HCIPacket
-from .grpc_protobuf.startup_pb2 import Chip, ChipInfo
-from .grpc_protobuf.common_pb2 import ChipKind
+from bumble.transport.grpc_protobuf.netsim.packet_streamer_pb2 import (
+    PacketRequest,
+    PacketResponse,
+)
+from bumble.transport.grpc_protobuf.netsim.hci_packet_pb2 import HCIPacket
+from bumble.transport.grpc_protobuf.netsim.startup_pb2 import Chip, ChipInfo, DeviceInfo
+from bumble.transport.grpc_protobuf.netsim.common_pb2 import ChipKind
 
 
 # -----------------------------------------------------------------------------
@@ -58,6 +63,7 @@ logger = logging.getLogger(__name__)
 # -----------------------------------------------------------------------------
 DEFAULT_NAME = 'bumble0'
 DEFAULT_MANUFACTURER = 'Bumble'
+DEFAULT_VARIANT = ''
 
 
 # -----------------------------------------------------------------------------
@@ -199,7 +205,6 @@ async def open_android_netsim_controller_transport(
                 data = (
                     bytes([request.hci_packet.packet_type]) + request.hci_packet.packet
                 )
-                logger.debug(f'<<< PACKET: {data.hex()}')
                 self.on_data_received(data)
 
         async def send_packet(self, data):
@@ -253,7 +258,7 @@ async def open_android_netsim_controller_transport(
 
             # Check that we don't already have a device
             if self.device:
-                logger.debug('busy, already serving a device')
+                logger.debug('Busy, already serving a device')
                 return PacketResponse(error='Busy')
 
             # Instantiate a new device
@@ -312,16 +317,24 @@ async def open_android_netsim_host_transport_with_channel(
 ):
     # Wrapper for I/O operations
     class HciDevice:
-        def __init__(self, name, manufacturer, hci_device):
+        def __init__(self, name, variant, manufacturer, hci_device):
             self.name = name
+            self.variant = variant
             self.manufacturer = manufacturer
             self.hci_device = hci_device
 
         async def start(self):  # Send the startup info
-            chip_info = ChipInfo(
+            device_info = DeviceInfo(
                 name=self.name,
-                chip=Chip(kind=ChipKind.BLUETOOTH, manufacturer=self.manufacturer),
+                kind='BUMBLE',
+                version=bumble.__version__,
+                sdk_version=platform.python_version(),
+                build_id=platform.platform(),
+                arch=platform.machine(),
+                variant=self.variant,
             )
+            chip = Chip(kind=ChipKind.BLUETOOTH, manufacturer=self.manufacturer)
+            chip_info = ChipInfo(name=self.name, chip=chip, device_info=device_info)
             logger.debug(f'Sending chip info to netsim: {chip_info}')
             await self.hci_device.write(PacketRequest(initial_info=chip_info))
 
@@ -349,12 +362,16 @@ async def open_android_netsim_host_transport_with_channel(
             )
 
     name = DEFAULT_NAME if options is None else options.get('name', DEFAULT_NAME)
+    variant = (
+        DEFAULT_VARIANT if options is None else options.get('variant', DEFAULT_VARIANT)
+    )
     manufacturer = DEFAULT_MANUFACTURER
 
     # Connect as a host
     service = PacketStreamerStub(channel)
     hci_device = HciDevice(
         name=name,
+        variant=variant,
         manufacturer=manufacturer,
         hci_device=service.StreamPackets(),
     )
@@ -404,6 +421,9 @@ async def open_android_netsim_transport(spec: Optional[str]) -> Transport:
           The "chip" name, used to identify the "chip" instance. This
           may be useful when several clients are connected, since each needs to use a
           different name.
+        variant=<variant>
+          The device info variant field, which may be used to convey a device or
+          application type (ex: "virtual-speaker", or "keyboard")
 
     In `controller` mode:
       The <host>:<port> part is required. <host> may be the address of a local network
diff --git a/bumble/transport/common.py b/bumble/transport/common.py
index f2c7fcb..b1dd000 100644
--- a/bumble/transport/common.py
+++ b/bumble/transport/common.py
@@ -139,6 +139,7 @@ class PacketParser:
                         packet_type
                     ) or self.extended_packet_info.get(packet_type)
                     if self.packet_info is None:
+                        self.reset()
                         raise core.InvalidPacketError(
                             f'invalid packet type {packet_type}'
                         )
@@ -302,7 +303,10 @@ class ParserSource(BaseSource):
 # -----------------------------------------------------------------------------
 class StreamPacketSource(asyncio.Protocol, ParserSource):
     def data_received(self, data: bytes) -> None:
-        self.parser.feed_data(data)
+        try:
+            self.parser.feed_data(data)
+        except core.InvalidPacketError:
+            logger.warning("invalid packet, ignoring data")
 
 
 # -----------------------------------------------------------------------------
@@ -370,11 +374,13 @@ class PumpedPacketSource(ParserSource):
                     self.parser.feed_data(packet)
                 except asyncio.CancelledError:
                     logger.debug('source pump task done')
-                    self.terminated.set_result(None)
+                    if not self.terminated.done():
+                        self.terminated.set_result(None)
                     break
                 except Exception as error:
                     logger.warning(f'exception while waiting for packet: {error}')
-                    self.terminated.set_exception(error)
+                    if not self.terminated.done():
+                        self.terminated.set_exception(error)
                     break
 
         self.pump_task = asyncio.create_task(pump_packets())
diff --git a/bumble/transport/file.py b/bumble/transport/file.py
index dee1c23..3fe9ee5 100644
--- a/bumble/transport/file.py
+++ b/bumble/transport/file.py
@@ -19,7 +19,7 @@ import asyncio
 import io
 import logging
 
-from .common import Transport, StreamPacketSource, StreamPacketSink
+from bumble.transport.common import Transport, StreamPacketSource, StreamPacketSink
 
 # -----------------------------------------------------------------------------
 # Logging
diff --git a/bumble/transport/grpc_protobuf/hci_packet_pb2.py b/bumble/transport/grpc_protobuf/hci_packet_pb2.py
deleted file mode 100644
index ef014c4..0000000
--- a/bumble/transport/grpc_protobuf/hci_packet_pb2.py
+++ /dev/null
@@ -1,28 +0,0 @@
-# -*- coding: utf-8 -*-
-# Generated by the protocol buffer compiler.  DO NOT EDIT!
-# source: hci_packet.proto
-"""Generated protocol buffer code."""
-from google.protobuf.internal import builder as _builder
-from google.protobuf import descriptor as _descriptor
-from google.protobuf import descriptor_pool as _descriptor_pool
-from google.protobuf import symbol_database as _symbol_database
-# @@protoc_insertion_point(imports)
-
-_sym_db = _symbol_database.Default()
-
-
-
-
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x10hci_packet.proto\x12\rnetsim.packet\"\xb2\x01\n\tHCIPacket\x12\x38\n\x0bpacket_type\x18\x01 \x01(\x0e\x32#.netsim.packet.HCIPacket.PacketType\x12\x0e\n\x06packet\x18\x02 \x01(\x0c\"[\n\nPacketType\x12\x1a\n\x16HCI_PACKET_UNSPECIFIED\x10\x00\x12\x0b\n\x07\x43OMMAND\x10\x01\x12\x07\n\x03\x41\x43L\x10\x02\x12\x07\n\x03SCO\x10\x03\x12\t\n\x05\x45VENT\x10\x04\x12\x07\n\x03ISO\x10\x05\x42J\n\x1f\x63om.android.emulation.bluetoothP\x01\xf8\x01\x01\xa2\x02\x03\x41\x45\x42\xaa\x02\x1b\x41ndroid.Emulation.Bluetoothb\x06proto3')
-
-_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, globals())
-_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'hci_packet_pb2', globals())
-if _descriptor._USE_C_DESCRIPTORS == False:
-
-  DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'\n\037com.android.emulation.bluetoothP\001\370\001\001\242\002\003AEB\252\002\033Android.Emulation.Bluetooth'
-  _HCIPACKET._serialized_start=36
-  _HCIPACKET._serialized_end=214
-  _HCIPACKET_PACKETTYPE._serialized_start=123
-  _HCIPACKET_PACKETTYPE._serialized_end=214
-# @@protoc_insertion_point(module_scope)
diff --git a/bumble/transport/grpc_protobuf/netsim/__init__.py b/bumble/transport/grpc_protobuf/netsim/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/bumble/transport/grpc_protobuf/common_pb2.py b/bumble/transport/grpc_protobuf/netsim/common_pb2.py
similarity index 53%
rename from bumble/transport/grpc_protobuf/common_pb2.py
rename to bumble/transport/grpc_protobuf/netsim/common_pb2.py
index c54a2e0..d5721b6 100644
--- a/bumble/transport/grpc_protobuf/common_pb2.py
+++ b/bumble/transport/grpc_protobuf/netsim/common_pb2.py
@@ -1,11 +1,12 @@
 # -*- coding: utf-8 -*-
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
-# source: common.proto
+# source: netsim/common.proto
+# Protobuf Python Version: 4.25.1
 """Generated protocol buffer code."""
-from google.protobuf.internal import builder as _builder
 from google.protobuf import descriptor as _descriptor
 from google.protobuf import descriptor_pool as _descriptor_pool
 from google.protobuf import symbol_database as _symbol_database
+from google.protobuf.internal import builder as _builder
 # @@protoc_insertion_point(imports)
 
 _sym_db = _symbol_database.Default()
@@ -13,13 +14,13 @@ _sym_db = _symbol_database.Default()
 
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x0c\x63ommon.proto\x12\rnetsim.common*=\n\x08\x43hipKind\x12\x0f\n\x0bUNSPECIFIED\x10\x00\x12\r\n\tBLUETOOTH\x10\x01\x12\x08\n\x04WIFI\x10\x02\x12\x07\n\x03UWB\x10\x03\x62\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x13netsim/common.proto\x12\rnetsim.common*S\n\x08\x43hipKind\x12\x0f\n\x0bUNSPECIFIED\x10\x00\x12\r\n\tBLUETOOTH\x10\x01\x12\x08\n\x04WIFI\x10\x02\x12\x07\n\x03UWB\x10\x03\x12\x14\n\x10\x42LUETOOTH_BEACON\x10\x04\x62\x06proto3')
 
-_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, globals())
-_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'common_pb2', globals())
+_globals = globals()
+_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
+_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'netsim.common_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
-
   DESCRIPTOR._options = None
-  _CHIPKIND._serialized_start=31
-  _CHIPKIND._serialized_end=92
+  _globals['_CHIPKIND']._serialized_start=38
+  _globals['_CHIPKIND']._serialized_end=121
 # @@protoc_insertion_point(module_scope)
diff --git a/bumble/transport/grpc_protobuf/common_pb2.pyi b/bumble/transport/grpc_protobuf/netsim/common_pb2.pyi
similarity index 61%
rename from bumble/transport/grpc_protobuf/common_pb2.pyi
rename to bumble/transport/grpc_protobuf/netsim/common_pb2.pyi
index 4cc934d..0330a91 100644
--- a/bumble/transport/grpc_protobuf/common_pb2.pyi
+++ b/bumble/transport/grpc_protobuf/netsim/common_pb2.pyi
@@ -2,11 +2,17 @@ from google.protobuf.internal import enum_type_wrapper as _enum_type_wrapper
 from google.protobuf import descriptor as _descriptor
 from typing import ClassVar as _ClassVar
 
-BLUETOOTH: ChipKind
 DESCRIPTOR: _descriptor.FileDescriptor
-UNSPECIFIED: ChipKind
-UWB: ChipKind
-WIFI: ChipKind
 
 class ChipKind(int, metaclass=_enum_type_wrapper.EnumTypeWrapper):
-    __slots__ = []
+    __slots__ = ()
+    UNSPECIFIED: _ClassVar[ChipKind]
+    BLUETOOTH: _ClassVar[ChipKind]
+    WIFI: _ClassVar[ChipKind]
+    UWB: _ClassVar[ChipKind]
+    BLUETOOTH_BEACON: _ClassVar[ChipKind]
+UNSPECIFIED: ChipKind
+BLUETOOTH: ChipKind
+WIFI: ChipKind
+UWB: ChipKind
+BLUETOOTH_BEACON: ChipKind
diff --git a/bumble/transport/grpc_protobuf/common_pb2_grpc.py b/bumble/transport/grpc_protobuf/netsim/common_pb2_grpc.py
similarity index 100%
rename from bumble/transport/grpc_protobuf/common_pb2_grpc.py
rename to bumble/transport/grpc_protobuf/netsim/common_pb2_grpc.py
diff --git a/bumble/transport/grpc_protobuf/netsim/hci_packet_pb2.py b/bumble/transport/grpc_protobuf/netsim/hci_packet_pb2.py
new file mode 100644
index 0000000..1f3e85d
--- /dev/null
+++ b/bumble/transport/grpc_protobuf/netsim/hci_packet_pb2.py
@@ -0,0 +1,29 @@
+# -*- coding: utf-8 -*-
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: netsim/hci_packet.proto
+# Protobuf Python Version: 4.25.1
+"""Generated protocol buffer code."""
+from google.protobuf import descriptor as _descriptor
+from google.protobuf import descriptor_pool as _descriptor_pool
+from google.protobuf import symbol_database as _symbol_database
+from google.protobuf.internal import builder as _builder
+# @@protoc_insertion_point(imports)
+
+_sym_db = _symbol_database.Default()
+
+
+
+
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x17netsim/hci_packet.proto\x12\rnetsim.packet\"\xb2\x01\n\tHCIPacket\x12\x38\n\x0bpacket_type\x18\x01 \x01(\x0e\x32#.netsim.packet.HCIPacket.PacketType\x12\x0e\n\x06packet\x18\x02 \x01(\x0c\"[\n\nPacketType\x12\x1a\n\x16HCI_PACKET_UNSPECIFIED\x10\x00\x12\x0b\n\x07\x43OMMAND\x10\x01\x12\x07\n\x03\x41\x43L\x10\x02\x12\x07\n\x03SCO\x10\x03\x12\t\n\x05\x45VENT\x10\x04\x12\x07\n\x03ISO\x10\x05\x42J\n\x1f\x63om.android.emulation.bluetoothP\x01\xf8\x01\x01\xa2\x02\x03\x41\x45\x42\xaa\x02\x1b\x41ndroid.Emulation.Bluetoothb\x06proto3')
+
+_globals = globals()
+_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
+_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'netsim.hci_packet_pb2', _globals)
+if _descriptor._USE_C_DESCRIPTORS == False:
+  _globals['DESCRIPTOR']._options = None
+  _globals['DESCRIPTOR']._serialized_options = b'\n\037com.android.emulation.bluetoothP\001\370\001\001\242\002\003AEB\252\002\033Android.Emulation.Bluetooth'
+  _globals['_HCIPACKET']._serialized_start=43
+  _globals['_HCIPACKET']._serialized_end=221
+  _globals['_HCIPACKET_PACKETTYPE']._serialized_start=130
+  _globals['_HCIPACKET_PACKETTYPE']._serialized_end=221
+# @@protoc_insertion_point(module_scope)
diff --git a/bumble/transport/grpc_protobuf/hci_packet_pb2.pyi b/bumble/transport/grpc_protobuf/netsim/hci_packet_pb2.pyi
similarity index 71%
rename from bumble/transport/grpc_protobuf/hci_packet_pb2.pyi
rename to bumble/transport/grpc_protobuf/netsim/hci_packet_pb2.pyi
index 04bb972..e49ddc8 100644
--- a/bumble/transport/grpc_protobuf/hci_packet_pb2.pyi
+++ b/bumble/transport/grpc_protobuf/netsim/hci_packet_pb2.pyi
@@ -6,17 +6,23 @@ from typing import ClassVar as _ClassVar, Optional as _Optional, Union as _Union
 DESCRIPTOR: _descriptor.FileDescriptor
 
 class HCIPacket(_message.Message):
-    __slots__ = ["packet", "packet_type"]
+    __slots__ = ("packet_type", "packet")
     class PacketType(int, metaclass=_enum_type_wrapper.EnumTypeWrapper):
-        __slots__ = []
-    ACL: HCIPacket.PacketType
+        __slots__ = ()
+        HCI_PACKET_UNSPECIFIED: _ClassVar[HCIPacket.PacketType]
+        COMMAND: _ClassVar[HCIPacket.PacketType]
+        ACL: _ClassVar[HCIPacket.PacketType]
+        SCO: _ClassVar[HCIPacket.PacketType]
+        EVENT: _ClassVar[HCIPacket.PacketType]
+        ISO: _ClassVar[HCIPacket.PacketType]
+    HCI_PACKET_UNSPECIFIED: HCIPacket.PacketType
     COMMAND: HCIPacket.PacketType
+    ACL: HCIPacket.PacketType
+    SCO: HCIPacket.PacketType
     EVENT: HCIPacket.PacketType
-    HCI_PACKET_UNSPECIFIED: HCIPacket.PacketType
     ISO: HCIPacket.PacketType
-    PACKET_FIELD_NUMBER: _ClassVar[int]
     PACKET_TYPE_FIELD_NUMBER: _ClassVar[int]
-    SCO: HCIPacket.PacketType
-    packet: bytes
+    PACKET_FIELD_NUMBER: _ClassVar[int]
     packet_type: HCIPacket.PacketType
+    packet: bytes
     def __init__(self, packet_type: _Optional[_Union[HCIPacket.PacketType, str]] = ..., packet: _Optional[bytes] = ...) -> None: ...
diff --git a/bumble/transport/grpc_protobuf/hci_packet_pb2_grpc.py b/bumble/transport/grpc_protobuf/netsim/hci_packet_pb2_grpc.py
similarity index 100%
rename from bumble/transport/grpc_protobuf/hci_packet_pb2_grpc.py
rename to bumble/transport/grpc_protobuf/netsim/hci_packet_pb2_grpc.py
diff --git a/bumble/transport/grpc_protobuf/netsim/model_pb2.py b/bumble/transport/grpc_protobuf/netsim/model_pb2.py
new file mode 100644
index 0000000..1339883
--- /dev/null
+++ b/bumble/transport/grpc_protobuf/netsim/model_pb2.py
@@ -0,0 +1,63 @@
+# -*- coding: utf-8 -*-
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: netsim/model.proto
+# Protobuf Python Version: 4.25.1
+"""Generated protocol buffer code."""
+from google.protobuf import descriptor as _descriptor
+from google.protobuf import descriptor_pool as _descriptor_pool
+from google.protobuf import symbol_database as _symbol_database
+from google.protobuf.internal import builder as _builder
+# @@protoc_insertion_point(imports)
+
+_sym_db = _symbol_database.Default()
+
+
+from bumble.transport.grpc_protobuf.netsim import common_pb2 as netsim_dot_common__pb2
+from google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2
+from bumble.transport.grpc_protobuf.rootcanal import configuration_pb2 as rootcanal_dot_configuration__pb2
+
+
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x12netsim/model.proto\x12\x0cnetsim.model\x1a\x13netsim/common.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1drootcanal/configuration.proto\"+\n\x08Position\x12\t\n\x01x\x18\x01 \x01(\x02\x12\t\n\x01y\x18\x02 \x01(\x02\x12\t\n\x01z\x18\x03 \x01(\x02\"7\n\x0bOrientation\x12\x0b\n\x03yaw\x18\x01 \x01(\x02\x12\r\n\x05pitch\x18\x02 \x01(\x02\x12\x0c\n\x04roll\x18\x03 \x01(\x02\"\x84\x0c\n\x04\x43hip\x12%\n\x04kind\x18\x01 \x01(\x0e\x32\x17.netsim.common.ChipKind\x12\n\n\x02id\x18\x02 \x01(\r\x12\x0c\n\x04name\x18\x03 \x01(\t\x12\x14\n\x0cmanufacturer\x18\x04 \x01(\t\x12\x14\n\x0cproduct_name\x18\x05 \x01(\t\x12*\n\x02\x62t\x18\x06 \x01(\x0b\x32\x1c.netsim.model.Chip.BluetoothH\x00\x12\x32\n\nble_beacon\x18\t \x01(\x0b\x32\x1c.netsim.model.Chip.BleBeaconH\x00\x12\'\n\x03uwb\x18\x07 \x01(\x0b\x32\x18.netsim.model.Chip.RadioH\x00\x12(\n\x04wifi\x18\x08 \x01(\x0b\x32\x18.netsim.model.Chip.RadioH\x00\x12+\n\x06offset\x18\x0f \x01(\x0b\x32\x16.netsim.model.PositionH\x01\x88\x01\x01\x1aX\n\x05Radio\x12\x12\n\x05state\x18\x01 \x01(\x08H\x00\x88\x01\x01\x12\r\n\x05range\x18\x02 \x01(\x02\x12\x10\n\x08tx_count\x18\x03 \x01(\x05\x12\x10\n\x08rx_count\x18\x04 \x01(\x05\x42\x08\n\x06_state\x1a\xb1\x01\n\tBluetooth\x12,\n\nlow_energy\x18\x01 \x01(\x0b\x32\x18.netsim.model.Chip.Radio\x12)\n\x07\x63lassic\x18\x02 \x01(\x0b\x32\x18.netsim.model.Chip.Radio\x12\x0f\n\x07\x61\x64\x64ress\x18\x03 \x01(\t\x12:\n\rbt_properties\x18\x04 \x01(\x0b\x32#.rootcanal.configuration.Controller\x1a\x8d\x07\n\tBleBeacon\x12(\n\x02\x62t\x18\x01 \x01(\x0b\x32\x1c.netsim.model.Chip.Bluetooth\x12\x0f\n\x07\x61\x64\x64ress\x18\x02 \x01(\t\x12@\n\x08settings\x18\x03 \x01(\x0b\x32..netsim.model.Chip.BleBeacon.AdvertiseSettings\x12<\n\x08\x61\x64v_data\x18\x04 \x01(\x0b\x32*.netsim.model.Chip.BleBeacon.AdvertiseData\x12\x41\n\rscan_response\x18\x05 \x01(\x0b\x32*.netsim.model.Chip.BleBeacon.AdvertiseData\x1a\xaa\x03\n\x11\x41\x64vertiseSettings\x12V\n\x0e\x61\x64vertise_mode\x18\x01 \x01(\x0e\x32<.netsim.model.Chip.BleBeacon.AdvertiseSettings.AdvertiseModeH\x00\x12\x16\n\x0cmilliseconds\x18\x02 \x01(\x04H\x00\x12Y\n\x0etx_power_level\x18\x03 \x01(\x0e\x32?.netsim.model.Chip.BleBeacon.AdvertiseSettings.AdvertiseTxPowerH\x01\x12\r\n\x03\x64\x62m\x18\x04 \x01(\x05H\x01\x12\x11\n\tscannable\x18\x05 \x01(\x08\x12\x0f\n\x07timeout\x18\x06 \x01(\x04\"=\n\rAdvertiseMode\x12\r\n\tLOW_POWER\x10\x00\x12\x0c\n\x08\x42\x41LANCED\x10\x01\x12\x0f\n\x0bLOW_LATENCY\x10\x02\"@\n\x10\x41\x64vertiseTxPower\x12\r\n\tULTRA_LOW\x10\x00\x12\x07\n\x03LOW\x10\x01\x12\n\n\x06MEDIUM\x10\x02\x12\x08\n\x04HIGH\x10\x03\x42\n\n\x08intervalB\n\n\x08tx_power\x1a\xd4\x01\n\rAdvertiseData\x12\x1b\n\x13include_device_name\x18\x01 \x01(\x08\x12\x1e\n\x16include_tx_power_level\x18\x02 \x01(\x08\x12\x19\n\x11manufacturer_data\x18\x03 \x01(\x0c\x12\x44\n\x08services\x18\x04 \x03(\x0b\x32\x32.netsim.model.Chip.BleBeacon.AdvertiseData.Service\x1a%\n\x07Service\x12\x0c\n\x04uuid\x18\x01 \x01(\t\x12\x0c\n\x04\x64\x61ta\x18\x02 \x01(\x0c\x42\x06\n\x04\x63hipB\t\n\x07_offset\"\xea\x03\n\nChipCreate\x12%\n\x04kind\x18\x01 \x01(\x0e\x32\x17.netsim.common.ChipKind\x12\x0f\n\x07\x61\x64\x64ress\x18\x02 \x01(\t\x12\x0c\n\x04name\x18\x03 \x01(\t\x12\x14\n\x0cmanufacturer\x18\x04 \x01(\t\x12\x14\n\x0cproduct_name\x18\x05 \x01(\t\x12>\n\nble_beacon\x18\x06 \x01(\x0b\x32(.netsim.model.ChipCreate.BleBeaconCreateH\x00\x12:\n\rbt_properties\x18\x07 \x01(\x0b\x32#.rootcanal.configuration.Controller\x1a\xe5\x01\n\x0f\x42leBeaconCreate\x12\x0f\n\x07\x61\x64\x64ress\x18\x01 \x01(\t\x12@\n\x08settings\x18\x03 \x01(\x0b\x32..netsim.model.Chip.BleBeacon.AdvertiseSettings\x12<\n\x08\x61\x64v_data\x18\x04 \x01(\x0b\x32*.netsim.model.Chip.BleBeacon.AdvertiseData\x12\x41\n\rscan_response\x18\x05 \x01(\x0b\x32*.netsim.model.Chip.BleBeacon.AdvertiseDataB\x06\n\x04\x63hip\"\xc1\x01\n\x06\x44\x65vice\x12\n\n\x02id\x18\x01 \x01(\r\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x14\n\x07visible\x18\x03 \x01(\x08H\x00\x88\x01\x01\x12(\n\x08position\x18\x04 \x01(\x0b\x32\x16.netsim.model.Position\x12.\n\x0borientation\x18\x05 \x01(\x0b\x32\x19.netsim.model.Orientation\x12!\n\x05\x63hips\x18\x06 \x03(\x0b\x32\x12.netsim.model.ChipB\n\n\x08_visible\"\x9f\x01\n\x0c\x44\x65viceCreate\x12\x0c\n\x04name\x18\x01 \x01(\t\x12(\n\x08position\x18\x02 \x01(\x0b\x32\x16.netsim.model.Position\x12.\n\x0borientation\x18\x03 \x01(\x0b\x32\x19.netsim.model.Orientation\x12\'\n\x05\x63hips\x18\x04 \x03(\x0b\x32\x18.netsim.model.ChipCreate\".\n\x05Scene\x12%\n\x07\x64\x65vices\x18\x01 \x03(\x0b\x32\x14.netsim.model.Device\"\xd1\x01\n\x07\x43\x61pture\x12\n\n\x02id\x18\x01 \x01(\r\x12*\n\tchip_kind\x18\x02 \x01(\x0e\x32\x17.netsim.common.ChipKind\x12\x13\n\x0b\x64\x65vice_name\x18\x03 \x01(\t\x12\x12\n\x05state\x18\x04 \x01(\x08H\x00\x88\x01\x01\x12\x0c\n\x04size\x18\x05 \x01(\x05\x12\x0f\n\x07records\x18\x06 \x01(\x05\x12-\n\ttimestamp\x18\x07 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\r\n\x05valid\x18\x08 \x01(\x08\x42\x08\n\x06_state*e\n\x07PhyKind\x12\x08\n\x04NONE\x10\x00\x12\x15\n\x11\x42LUETOOTH_CLASSIC\x10\x01\x12\x18\n\x14\x42LUETOOTH_LOW_ENERGY\x10\x02\x12\x08\n\x04WIFI\x10\x03\x12\x07\n\x03UWB\x10\x04\x12\x0c\n\x08WIFI_RTT\x10\x05\x62\x06proto3')
+
+_globals = globals()
+_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
+_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'netsim.model_pb2', _globals)
+if _descriptor._USE_C_DESCRIPTORS == False:
+  DESCRIPTOR._options = None
+  _globals['_PHYKIND']._serialized_start=2877
+  _globals['_PHYKIND']._serialized_end=2978
+  _globals['_POSITION']._serialized_start=121
+  _globals['_POSITION']._serialized_end=164
+  _globals['_ORIENTATION']._serialized_start=166
+  _globals['_ORIENTATION']._serialized_end=221
+  _globals['_CHIP']._serialized_start=224
+  _globals['_CHIP']._serialized_end=1764
+  _globals['_CHIP_RADIO']._serialized_start=565
+  _globals['_CHIP_RADIO']._serialized_end=653
+  _globals['_CHIP_BLUETOOTH']._serialized_start=656
+  _globals['_CHIP_BLUETOOTH']._serialized_end=833
+  _globals['_CHIP_BLEBEACON']._serialized_start=836
+  _globals['_CHIP_BLEBEACON']._serialized_end=1745
+  _globals['_CHIP_BLEBEACON_ADVERTISESETTINGS']._serialized_start=1104
+  _globals['_CHIP_BLEBEACON_ADVERTISESETTINGS']._serialized_end=1530
+  _globals['_CHIP_BLEBEACON_ADVERTISESETTINGS_ADVERTISEMODE']._serialized_start=1379
+  _globals['_CHIP_BLEBEACON_ADVERTISESETTINGS_ADVERTISEMODE']._serialized_end=1440
+  _globals['_CHIP_BLEBEACON_ADVERTISESETTINGS_ADVERTISETXPOWER']._serialized_start=1442
+  _globals['_CHIP_BLEBEACON_ADVERTISESETTINGS_ADVERTISETXPOWER']._serialized_end=1506
+  _globals['_CHIP_BLEBEACON_ADVERTISEDATA']._serialized_start=1533
+  _globals['_CHIP_BLEBEACON_ADVERTISEDATA']._serialized_end=1745
+  _globals['_CHIP_BLEBEACON_ADVERTISEDATA_SERVICE']._serialized_start=1708
+  _globals['_CHIP_BLEBEACON_ADVERTISEDATA_SERVICE']._serialized_end=1745
+  _globals['_CHIPCREATE']._serialized_start=1767
+  _globals['_CHIPCREATE']._serialized_end=2257
+  _globals['_CHIPCREATE_BLEBEACONCREATE']._serialized_start=2020
+  _globals['_CHIPCREATE_BLEBEACONCREATE']._serialized_end=2249
+  _globals['_DEVICE']._serialized_start=2260
+  _globals['_DEVICE']._serialized_end=2453
+  _globals['_DEVICECREATE']._serialized_start=2456
+  _globals['_DEVICECREATE']._serialized_end=2615
+  _globals['_SCENE']._serialized_start=2617
+  _globals['_SCENE']._serialized_end=2663
+  _globals['_CAPTURE']._serialized_start=2666
+  _globals['_CAPTURE']._serialized_end=2875
+# @@protoc_insertion_point(module_scope)
diff --git a/bumble/transport/grpc_protobuf/netsim/model_pb2.pyi b/bumble/transport/grpc_protobuf/netsim/model_pb2.pyi
new file mode 100644
index 0000000..95c3f07
--- /dev/null
+++ b/bumble/transport/grpc_protobuf/netsim/model_pb2.pyi
@@ -0,0 +1,238 @@
+from bumble.transport.grpc_protobuf.netsim import common_pb2 as _common_pb2
+from google.protobuf import timestamp_pb2 as _timestamp_pb2
+from bumble.transport.grpc_protobuf.rootcanal import configuration_pb2 as _configuration_pb2
+from google.protobuf.internal import containers as _containers
+from google.protobuf.internal import enum_type_wrapper as _enum_type_wrapper
+from google.protobuf import descriptor as _descriptor
+from google.protobuf import message as _message
+from typing import ClassVar as _ClassVar, Iterable as _Iterable, Mapping as _Mapping, Optional as _Optional, Union as _Union
+
+DESCRIPTOR: _descriptor.FileDescriptor
+
+class PhyKind(int, metaclass=_enum_type_wrapper.EnumTypeWrapper):
+    __slots__ = ()
+    NONE: _ClassVar[PhyKind]
+    BLUETOOTH_CLASSIC: _ClassVar[PhyKind]
+    BLUETOOTH_LOW_ENERGY: _ClassVar[PhyKind]
+    WIFI: _ClassVar[PhyKind]
+    UWB: _ClassVar[PhyKind]
+    WIFI_RTT: _ClassVar[PhyKind]
+NONE: PhyKind
+BLUETOOTH_CLASSIC: PhyKind
+BLUETOOTH_LOW_ENERGY: PhyKind
+WIFI: PhyKind
+UWB: PhyKind
+WIFI_RTT: PhyKind
+
+class Position(_message.Message):
+    __slots__ = ("x", "y", "z")
+    X_FIELD_NUMBER: _ClassVar[int]
+    Y_FIELD_NUMBER: _ClassVar[int]
+    Z_FIELD_NUMBER: _ClassVar[int]
+    x: float
+    y: float
+    z: float
+    def __init__(self, x: _Optional[float] = ..., y: _Optional[float] = ..., z: _Optional[float] = ...) -> None: ...
+
+class Orientation(_message.Message):
+    __slots__ = ("yaw", "pitch", "roll")
+    YAW_FIELD_NUMBER: _ClassVar[int]
+    PITCH_FIELD_NUMBER: _ClassVar[int]
+    ROLL_FIELD_NUMBER: _ClassVar[int]
+    yaw: float
+    pitch: float
+    roll: float
+    def __init__(self, yaw: _Optional[float] = ..., pitch: _Optional[float] = ..., roll: _Optional[float] = ...) -> None: ...
+
+class Chip(_message.Message):
+    __slots__ = ("kind", "id", "name", "manufacturer", "product_name", "bt", "ble_beacon", "uwb", "wifi", "offset")
+    class Radio(_message.Message):
+        __slots__ = ("state", "range", "tx_count", "rx_count")
+        STATE_FIELD_NUMBER: _ClassVar[int]
+        RANGE_FIELD_NUMBER: _ClassVar[int]
+        TX_COUNT_FIELD_NUMBER: _ClassVar[int]
+        RX_COUNT_FIELD_NUMBER: _ClassVar[int]
+        state: bool
+        range: float
+        tx_count: int
+        rx_count: int
+        def __init__(self, state: bool = ..., range: _Optional[float] = ..., tx_count: _Optional[int] = ..., rx_count: _Optional[int] = ...) -> None: ...
+    class Bluetooth(_message.Message):
+        __slots__ = ("low_energy", "classic", "address", "bt_properties")
+        LOW_ENERGY_FIELD_NUMBER: _ClassVar[int]
+        CLASSIC_FIELD_NUMBER: _ClassVar[int]
+        ADDRESS_FIELD_NUMBER: _ClassVar[int]
+        BT_PROPERTIES_FIELD_NUMBER: _ClassVar[int]
+        low_energy: Chip.Radio
+        classic: Chip.Radio
+        address: str
+        bt_properties: _configuration_pb2.Controller
+        def __init__(self, low_energy: _Optional[_Union[Chip.Radio, _Mapping]] = ..., classic: _Optional[_Union[Chip.Radio, _Mapping]] = ..., address: _Optional[str] = ..., bt_properties: _Optional[_Union[_configuration_pb2.Controller, _Mapping]] = ...) -> None: ...
+    class BleBeacon(_message.Message):
+        __slots__ = ("bt", "address", "settings", "adv_data", "scan_response")
+        class AdvertiseSettings(_message.Message):
+            __slots__ = ("advertise_mode", "milliseconds", "tx_power_level", "dbm", "scannable", "timeout")
+            class AdvertiseMode(int, metaclass=_enum_type_wrapper.EnumTypeWrapper):
+                __slots__ = ()
+                LOW_POWER: _ClassVar[Chip.BleBeacon.AdvertiseSettings.AdvertiseMode]
+                BALANCED: _ClassVar[Chip.BleBeacon.AdvertiseSettings.AdvertiseMode]
+                LOW_LATENCY: _ClassVar[Chip.BleBeacon.AdvertiseSettings.AdvertiseMode]
+            LOW_POWER: Chip.BleBeacon.AdvertiseSettings.AdvertiseMode
+            BALANCED: Chip.BleBeacon.AdvertiseSettings.AdvertiseMode
+            LOW_LATENCY: Chip.BleBeacon.AdvertiseSettings.AdvertiseMode
+            class AdvertiseTxPower(int, metaclass=_enum_type_wrapper.EnumTypeWrapper):
+                __slots__ = ()
+                ULTRA_LOW: _ClassVar[Chip.BleBeacon.AdvertiseSettings.AdvertiseTxPower]
+                LOW: _ClassVar[Chip.BleBeacon.AdvertiseSettings.AdvertiseTxPower]
+                MEDIUM: _ClassVar[Chip.BleBeacon.AdvertiseSettings.AdvertiseTxPower]
+                HIGH: _ClassVar[Chip.BleBeacon.AdvertiseSettings.AdvertiseTxPower]
+            ULTRA_LOW: Chip.BleBeacon.AdvertiseSettings.AdvertiseTxPower
+            LOW: Chip.BleBeacon.AdvertiseSettings.AdvertiseTxPower
+            MEDIUM: Chip.BleBeacon.AdvertiseSettings.AdvertiseTxPower
+            HIGH: Chip.BleBeacon.AdvertiseSettings.AdvertiseTxPower
+            ADVERTISE_MODE_FIELD_NUMBER: _ClassVar[int]
+            MILLISECONDS_FIELD_NUMBER: _ClassVar[int]
+            TX_POWER_LEVEL_FIELD_NUMBER: _ClassVar[int]
+            DBM_FIELD_NUMBER: _ClassVar[int]
+            SCANNABLE_FIELD_NUMBER: _ClassVar[int]
+            TIMEOUT_FIELD_NUMBER: _ClassVar[int]
+            advertise_mode: Chip.BleBeacon.AdvertiseSettings.AdvertiseMode
+            milliseconds: int
+            tx_power_level: Chip.BleBeacon.AdvertiseSettings.AdvertiseTxPower
+            dbm: int
+            scannable: bool
+            timeout: int
+            def __init__(self, advertise_mode: _Optional[_Union[Chip.BleBeacon.AdvertiseSettings.AdvertiseMode, str]] = ..., milliseconds: _Optional[int] = ..., tx_power_level: _Optional[_Union[Chip.BleBeacon.AdvertiseSettings.AdvertiseTxPower, str]] = ..., dbm: _Optional[int] = ..., scannable: bool = ..., timeout: _Optional[int] = ...) -> None: ...
+        class AdvertiseData(_message.Message):
+            __slots__ = ("include_device_name", "include_tx_power_level", "manufacturer_data", "services")
+            class Service(_message.Message):
+                __slots__ = ("uuid", "data")
+                UUID_FIELD_NUMBER: _ClassVar[int]
+                DATA_FIELD_NUMBER: _ClassVar[int]
+                uuid: str
+                data: bytes
+                def __init__(self, uuid: _Optional[str] = ..., data: _Optional[bytes] = ...) -> None: ...
+            INCLUDE_DEVICE_NAME_FIELD_NUMBER: _ClassVar[int]
+            INCLUDE_TX_POWER_LEVEL_FIELD_NUMBER: _ClassVar[int]
+            MANUFACTURER_DATA_FIELD_NUMBER: _ClassVar[int]
+            SERVICES_FIELD_NUMBER: _ClassVar[int]
+            include_device_name: bool
+            include_tx_power_level: bool
+            manufacturer_data: bytes
+            services: _containers.RepeatedCompositeFieldContainer[Chip.BleBeacon.AdvertiseData.Service]
+            def __init__(self, include_device_name: bool = ..., include_tx_power_level: bool = ..., manufacturer_data: _Optional[bytes] = ..., services: _Optional[_Iterable[_Union[Chip.BleBeacon.AdvertiseData.Service, _Mapping]]] = ...) -> None: ...
+        BT_FIELD_NUMBER: _ClassVar[int]
+        ADDRESS_FIELD_NUMBER: _ClassVar[int]
+        SETTINGS_FIELD_NUMBER: _ClassVar[int]
+        ADV_DATA_FIELD_NUMBER: _ClassVar[int]
+        SCAN_RESPONSE_FIELD_NUMBER: _ClassVar[int]
+        bt: Chip.Bluetooth
+        address: str
+        settings: Chip.BleBeacon.AdvertiseSettings
+        adv_data: Chip.BleBeacon.AdvertiseData
+        scan_response: Chip.BleBeacon.AdvertiseData
+        def __init__(self, bt: _Optional[_Union[Chip.Bluetooth, _Mapping]] = ..., address: _Optional[str] = ..., settings: _Optional[_Union[Chip.BleBeacon.AdvertiseSettings, _Mapping]] = ..., adv_data: _Optional[_Union[Chip.BleBeacon.AdvertiseData, _Mapping]] = ..., scan_response: _Optional[_Union[Chip.BleBeacon.AdvertiseData, _Mapping]] = ...) -> None: ...
+    KIND_FIELD_NUMBER: _ClassVar[int]
+    ID_FIELD_NUMBER: _ClassVar[int]
+    NAME_FIELD_NUMBER: _ClassVar[int]
+    MANUFACTURER_FIELD_NUMBER: _ClassVar[int]
+    PRODUCT_NAME_FIELD_NUMBER: _ClassVar[int]
+    BT_FIELD_NUMBER: _ClassVar[int]
+    BLE_BEACON_FIELD_NUMBER: _ClassVar[int]
+    UWB_FIELD_NUMBER: _ClassVar[int]
+    WIFI_FIELD_NUMBER: _ClassVar[int]
+    OFFSET_FIELD_NUMBER: _ClassVar[int]
+    kind: _common_pb2.ChipKind
+    id: int
+    name: str
+    manufacturer: str
+    product_name: str
+    bt: Chip.Bluetooth
+    ble_beacon: Chip.BleBeacon
+    uwb: Chip.Radio
+    wifi: Chip.Radio
+    offset: Position
+    def __init__(self, kind: _Optional[_Union[_common_pb2.ChipKind, str]] = ..., id: _Optional[int] = ..., name: _Optional[str] = ..., manufacturer: _Optional[str] = ..., product_name: _Optional[str] = ..., bt: _Optional[_Union[Chip.Bluetooth, _Mapping]] = ..., ble_beacon: _Optional[_Union[Chip.BleBeacon, _Mapping]] = ..., uwb: _Optional[_Union[Chip.Radio, _Mapping]] = ..., wifi: _Optional[_Union[Chip.Radio, _Mapping]] = ..., offset: _Optional[_Union[Position, _Mapping]] = ...) -> None: ...
+
+class ChipCreate(_message.Message):
+    __slots__ = ("kind", "address", "name", "manufacturer", "product_name", "ble_beacon", "bt_properties")
+    class BleBeaconCreate(_message.Message):
+        __slots__ = ("address", "settings", "adv_data", "scan_response")
+        ADDRESS_FIELD_NUMBER: _ClassVar[int]
+        SETTINGS_FIELD_NUMBER: _ClassVar[int]
+        ADV_DATA_FIELD_NUMBER: _ClassVar[int]
+        SCAN_RESPONSE_FIELD_NUMBER: _ClassVar[int]
+        address: str
+        settings: Chip.BleBeacon.AdvertiseSettings
+        adv_data: Chip.BleBeacon.AdvertiseData
+        scan_response: Chip.BleBeacon.AdvertiseData
+        def __init__(self, address: _Optional[str] = ..., settings: _Optional[_Union[Chip.BleBeacon.AdvertiseSettings, _Mapping]] = ..., adv_data: _Optional[_Union[Chip.BleBeacon.AdvertiseData, _Mapping]] = ..., scan_response: _Optional[_Union[Chip.BleBeacon.AdvertiseData, _Mapping]] = ...) -> None: ...
+    KIND_FIELD_NUMBER: _ClassVar[int]
+    ADDRESS_FIELD_NUMBER: _ClassVar[int]
+    NAME_FIELD_NUMBER: _ClassVar[int]
+    MANUFACTURER_FIELD_NUMBER: _ClassVar[int]
+    PRODUCT_NAME_FIELD_NUMBER: _ClassVar[int]
+    BLE_BEACON_FIELD_NUMBER: _ClassVar[int]
+    BT_PROPERTIES_FIELD_NUMBER: _ClassVar[int]
+    kind: _common_pb2.ChipKind
+    address: str
+    name: str
+    manufacturer: str
+    product_name: str
+    ble_beacon: ChipCreate.BleBeaconCreate
+    bt_properties: _configuration_pb2.Controller
+    def __init__(self, kind: _Optional[_Union[_common_pb2.ChipKind, str]] = ..., address: _Optional[str] = ..., name: _Optional[str] = ..., manufacturer: _Optional[str] = ..., product_name: _Optional[str] = ..., ble_beacon: _Optional[_Union[ChipCreate.BleBeaconCreate, _Mapping]] = ..., bt_properties: _Optional[_Union[_configuration_pb2.Controller, _Mapping]] = ...) -> None: ...
+
+class Device(_message.Message):
+    __slots__ = ("id", "name", "visible", "position", "orientation", "chips")
+    ID_FIELD_NUMBER: _ClassVar[int]
+    NAME_FIELD_NUMBER: _ClassVar[int]
+    VISIBLE_FIELD_NUMBER: _ClassVar[int]
+    POSITION_FIELD_NUMBER: _ClassVar[int]
+    ORIENTATION_FIELD_NUMBER: _ClassVar[int]
+    CHIPS_FIELD_NUMBER: _ClassVar[int]
+    id: int
+    name: str
+    visible: bool
+    position: Position
+    orientation: Orientation
+    chips: _containers.RepeatedCompositeFieldContainer[Chip]
+    def __init__(self, id: _Optional[int] = ..., name: _Optional[str] = ..., visible: bool = ..., position: _Optional[_Union[Position, _Mapping]] = ..., orientation: _Optional[_Union[Orientation, _Mapping]] = ..., chips: _Optional[_Iterable[_Union[Chip, _Mapping]]] = ...) -> None: ...
+
+class DeviceCreate(_message.Message):
+    __slots__ = ("name", "position", "orientation", "chips")
+    NAME_FIELD_NUMBER: _ClassVar[int]
+    POSITION_FIELD_NUMBER: _ClassVar[int]
+    ORIENTATION_FIELD_NUMBER: _ClassVar[int]
+    CHIPS_FIELD_NUMBER: _ClassVar[int]
+    name: str
+    position: Position
+    orientation: Orientation
+    chips: _containers.RepeatedCompositeFieldContainer[ChipCreate]
+    def __init__(self, name: _Optional[str] = ..., position: _Optional[_Union[Position, _Mapping]] = ..., orientation: _Optional[_Union[Orientation, _Mapping]] = ..., chips: _Optional[_Iterable[_Union[ChipCreate, _Mapping]]] = ...) -> None: ...
+
+class Scene(_message.Message):
+    __slots__ = ("devices",)
+    DEVICES_FIELD_NUMBER: _ClassVar[int]
+    devices: _containers.RepeatedCompositeFieldContainer[Device]
+    def __init__(self, devices: _Optional[_Iterable[_Union[Device, _Mapping]]] = ...) -> None: ...
+
+class Capture(_message.Message):
+    __slots__ = ("id", "chip_kind", "device_name", "state", "size", "records", "timestamp", "valid")
+    ID_FIELD_NUMBER: _ClassVar[int]
+    CHIP_KIND_FIELD_NUMBER: _ClassVar[int]
+    DEVICE_NAME_FIELD_NUMBER: _ClassVar[int]
+    STATE_FIELD_NUMBER: _ClassVar[int]
+    SIZE_FIELD_NUMBER: _ClassVar[int]
+    RECORDS_FIELD_NUMBER: _ClassVar[int]
+    TIMESTAMP_FIELD_NUMBER: _ClassVar[int]
+    VALID_FIELD_NUMBER: _ClassVar[int]
+    id: int
+    chip_kind: _common_pb2.ChipKind
+    device_name: str
+    state: bool
+    size: int
+    records: int
+    timestamp: _timestamp_pb2.Timestamp
+    valid: bool
+    def __init__(self, id: _Optional[int] = ..., chip_kind: _Optional[_Union[_common_pb2.ChipKind, str]] = ..., device_name: _Optional[str] = ..., state: bool = ..., size: _Optional[int] = ..., records: _Optional[int] = ..., timestamp: _Optional[_Union[_timestamp_pb2.Timestamp, _Mapping]] = ..., valid: bool = ...) -> None: ...
diff --git a/bumble/transport/grpc_protobuf/startup_pb2_grpc.py b/bumble/transport/grpc_protobuf/netsim/model_pb2_grpc.py
similarity index 100%
rename from bumble/transport/grpc_protobuf/startup_pb2_grpc.py
rename to bumble/transport/grpc_protobuf/netsim/model_pb2_grpc.py
diff --git a/bumble/transport/grpc_protobuf/netsim/packet_streamer_pb2.py b/bumble/transport/grpc_protobuf/netsim/packet_streamer_pb2.py
new file mode 100644
index 0000000..3c616cf
--- /dev/null
+++ b/bumble/transport/grpc_protobuf/netsim/packet_streamer_pb2.py
@@ -0,0 +1,32 @@
+# -*- coding: utf-8 -*-
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: netsim/packet_streamer.proto
+# Protobuf Python Version: 4.25.1
+"""Generated protocol buffer code."""
+from google.protobuf import descriptor as _descriptor
+from google.protobuf import descriptor_pool as _descriptor_pool
+from google.protobuf import symbol_database as _symbol_database
+from google.protobuf.internal import builder as _builder
+# @@protoc_insertion_point(imports)
+
+_sym_db = _symbol_database.Default()
+
+
+from bumble.transport.grpc_protobuf.netsim import hci_packet_pb2 as netsim_dot_hci__packet__pb2
+from bumble.transport.grpc_protobuf.netsim import startup_pb2 as netsim_dot_startup__pb2
+
+
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1cnetsim/packet_streamer.proto\x12\rnetsim.packet\x1a\x17netsim/hci_packet.proto\x1a\x14netsim/startup.proto\"\x93\x01\n\rPacketRequest\x12\x30\n\x0cinitial_info\x18\x01 \x01(\x0b\x32\x18.netsim.startup.ChipInfoH\x00\x12.\n\nhci_packet\x18\x02 \x01(\x0b\x32\x18.netsim.packet.HCIPacketH\x00\x12\x10\n\x06packet\x18\x03 \x01(\x0cH\x00\x42\x0e\n\x0crequest_type\"t\n\x0ePacketResponse\x12\x0f\n\x05\x65rror\x18\x01 \x01(\tH\x00\x12.\n\nhci_packet\x18\x02 \x01(\x0b\x32\x18.netsim.packet.HCIPacketH\x00\x12\x10\n\x06packet\x18\x03 \x01(\x0cH\x00\x42\x0f\n\rresponse_type2b\n\x0ePacketStreamer\x12P\n\rStreamPackets\x12\x1c.netsim.packet.PacketRequest\x1a\x1d.netsim.packet.PacketResponse(\x01\x30\x01\x62\x06proto3')
+
+_globals = globals()
+_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
+_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'netsim.packet_streamer_pb2', _globals)
+if _descriptor._USE_C_DESCRIPTORS == False:
+  DESCRIPTOR._options = None
+  _globals['_PACKETREQUEST']._serialized_start=95
+  _globals['_PACKETREQUEST']._serialized_end=242
+  _globals['_PACKETRESPONSE']._serialized_start=244
+  _globals['_PACKETRESPONSE']._serialized_end=360
+  _globals['_PACKETSTREAMER']._serialized_start=362
+  _globals['_PACKETSTREAMER']._serialized_end=460
+# @@protoc_insertion_point(module_scope)
diff --git a/bumble/transport/grpc_protobuf/packet_streamer_pb2.pyi b/bumble/transport/grpc_protobuf/netsim/packet_streamer_pb2.pyi
similarity index 80%
rename from bumble/transport/grpc_protobuf/packet_streamer_pb2.pyi
rename to bumble/transport/grpc_protobuf/netsim/packet_streamer_pb2.pyi
index d867613..8765feb 100644
--- a/bumble/transport/grpc_protobuf/packet_streamer_pb2.pyi
+++ b/bumble/transport/grpc_protobuf/netsim/packet_streamer_pb2.pyi
@@ -1,5 +1,5 @@
-from . import hci_packet_pb2 as _hci_packet_pb2
-from . import startup_pb2 as _startup_pb2
+from bumble.transport.grpc_protobuf.netsim import hci_packet_pb2 as _hci_packet_pb2
+from bumble.transport.grpc_protobuf.netsim import startup_pb2 as _startup_pb2
 from google.protobuf import descriptor as _descriptor
 from google.protobuf import message as _message
 from typing import ClassVar as _ClassVar, Mapping as _Mapping, Optional as _Optional, Union as _Union
@@ -7,17 +7,17 @@ from typing import ClassVar as _ClassVar, Mapping as _Mapping, Optional as _Opti
 DESCRIPTOR: _descriptor.FileDescriptor
 
 class PacketRequest(_message.Message):
-    __slots__ = ["hci_packet", "initial_info", "packet"]
-    HCI_PACKET_FIELD_NUMBER: _ClassVar[int]
+    __slots__ = ("initial_info", "hci_packet", "packet")
     INITIAL_INFO_FIELD_NUMBER: _ClassVar[int]
+    HCI_PACKET_FIELD_NUMBER: _ClassVar[int]
     PACKET_FIELD_NUMBER: _ClassVar[int]
-    hci_packet: _hci_packet_pb2.HCIPacket
     initial_info: _startup_pb2.ChipInfo
+    hci_packet: _hci_packet_pb2.HCIPacket
     packet: bytes
     def __init__(self, initial_info: _Optional[_Union[_startup_pb2.ChipInfo, _Mapping]] = ..., hci_packet: _Optional[_Union[_hci_packet_pb2.HCIPacket, _Mapping]] = ..., packet: _Optional[bytes] = ...) -> None: ...
 
 class PacketResponse(_message.Message):
-    __slots__ = ["error", "hci_packet", "packet"]
+    __slots__ = ("error", "hci_packet", "packet")
     ERROR_FIELD_NUMBER: _ClassVar[int]
     HCI_PACKET_FIELD_NUMBER: _ClassVar[int]
     PACKET_FIELD_NUMBER: _ClassVar[int]
diff --git a/bumble/transport/grpc_protobuf/packet_streamer_pb2_grpc.py b/bumble/transport/grpc_protobuf/netsim/packet_streamer_pb2_grpc.py
similarity index 85%
rename from bumble/transport/grpc_protobuf/packet_streamer_pb2_grpc.py
rename to bumble/transport/grpc_protobuf/netsim/packet_streamer_pb2_grpc.py
index 45ab653..92b2be0 100644
--- a/bumble/transport/grpc_protobuf/packet_streamer_pb2_grpc.py
+++ b/bumble/transport/grpc_protobuf/netsim/packet_streamer_pb2_grpc.py
@@ -2,7 +2,7 @@
 """Client and server classes corresponding to protobuf-defined services."""
 import grpc
 
-from . import packet_streamer_pb2 as packet__streamer__pb2
+from bumble.transport.grpc_protobuf.netsim import packet_streamer_pb2 as netsim_dot_packet__streamer__pb2
 
 
 class PacketStreamerStub(object):
@@ -30,8 +30,8 @@ class PacketStreamerStub(object):
         """
         self.StreamPackets = channel.stream_stream(
                 '/netsim.packet.PacketStreamer/StreamPackets',
-                request_serializer=packet__streamer__pb2.PacketRequest.SerializeToString,
-                response_deserializer=packet__streamer__pb2.PacketResponse.FromString,
+                request_serializer=netsim_dot_packet__streamer__pb2.PacketRequest.SerializeToString,
+                response_deserializer=netsim_dot_packet__streamer__pb2.PacketResponse.FromString,
                 )
 
 
@@ -64,8 +64,8 @@ def add_PacketStreamerServicer_to_server(servicer, server):
     rpc_method_handlers = {
             'StreamPackets': grpc.stream_stream_rpc_method_handler(
                     servicer.StreamPackets,
-                    request_deserializer=packet__streamer__pb2.PacketRequest.FromString,
-                    response_serializer=packet__streamer__pb2.PacketResponse.SerializeToString,
+                    request_deserializer=netsim_dot_packet__streamer__pb2.PacketRequest.FromString,
+                    response_serializer=netsim_dot_packet__streamer__pb2.PacketResponse.SerializeToString,
             ),
     }
     generic_handler = grpc.method_handlers_generic_handler(
@@ -103,7 +103,7 @@ class PacketStreamer(object):
             timeout=None,
             metadata=None):
         return grpc.experimental.stream_stream(request_iterator, target, '/netsim.packet.PacketStreamer/StreamPackets',
-            packet__streamer__pb2.PacketRequest.SerializeToString,
-            packet__streamer__pb2.PacketResponse.FromString,
+            netsim_dot_packet__streamer__pb2.PacketRequest.SerializeToString,
+            netsim_dot_packet__streamer__pb2.PacketResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
diff --git a/bumble/transport/grpc_protobuf/netsim/startup_pb2.py b/bumble/transport/grpc_protobuf/netsim/startup_pb2.py
new file mode 100644
index 0000000..91a821e
--- /dev/null
+++ b/bumble/transport/grpc_protobuf/netsim/startup_pb2.py
@@ -0,0 +1,41 @@
+# -*- coding: utf-8 -*-
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: netsim/startup.proto
+# Protobuf Python Version: 4.25.1
+"""Generated protocol buffer code."""
+from google.protobuf import descriptor as _descriptor
+from google.protobuf import descriptor_pool as _descriptor_pool
+from google.protobuf import symbol_database as _symbol_database
+from google.protobuf.internal import builder as _builder
+# @@protoc_insertion_point(imports)
+
+_sym_db = _symbol_database.Default()
+
+
+from bumble.transport.grpc_protobuf.netsim import common_pb2 as netsim_dot_common__pb2
+from bumble.transport.grpc_protobuf.netsim import model_pb2 as netsim_dot_model__pb2
+from bumble.transport.grpc_protobuf.rootcanal import configuration_pb2 as rootcanal_dot_configuration__pb2
+
+
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x14netsim/startup.proto\x12\x0enetsim.startup\x1a\x13netsim/common.proto\x1a\x12netsim/model.proto\x1a\x1drootcanal/configuration.proto\"\xb4\x01\n\x0bStartupInfo\x12\x33\n\x07\x64\x65vices\x18\x01 \x03(\x0b\x32\".netsim.startup.StartupInfo.Device\x1ap\n\x06\x44\x65vice\x12\x10\n\x04name\x18\x01 \x01(\tB\x02\x18\x01\x12#\n\x05\x63hips\x18\x02 \x03(\x0b\x32\x14.netsim.startup.Chip\x12/\n\x0b\x64\x65vice_info\x18\x03 \x01(\x0b\x32\x1a.netsim.startup.DeviceInfo\"q\n\x08\x43hipInfo\x12\x10\n\x04name\x18\x01 \x01(\tB\x02\x18\x01\x12\"\n\x04\x63hip\x18\x02 \x01(\x0b\x32\x14.netsim.startup.Chip\x12/\n\x0b\x64\x65vice_info\x18\x03 \x01(\x0b\x32\x1a.netsim.startup.DeviceInfo\"\x7f\n\nDeviceInfo\x12\x0c\n\x04name\x18\x01 \x01(\t\x12\x0c\n\x04kind\x18\x02 \x01(\t\x12\x0f\n\x07version\x18\x03 \x01(\t\x12\x13\n\x0bsdk_version\x18\x04 \x01(\t\x12\x10\n\x08\x62uild_id\x18\x05 \x01(\t\x12\x0f\n\x07variant\x18\x06 \x01(\t\x12\x0c\n\x04\x61rch\x18\x07 \x01(\t\"\x9b\x02\n\x04\x43hip\x12%\n\x04kind\x18\x01 \x01(\x0e\x32\x17.netsim.common.ChipKind\x12\n\n\x02id\x18\x02 \x01(\t\x12\x14\n\x0cmanufacturer\x18\x03 \x01(\t\x12\x14\n\x0cproduct_name\x18\x04 \x01(\t\x12\r\n\x05\x66\x64_in\x18\x05 \x01(\x05\x12\x0e\n\x06\x66\x64_out\x18\x06 \x01(\x05\x12\x10\n\x08loopback\x18\x07 \x01(\x08\x12:\n\rbt_properties\x18\x08 \x01(\x0b\x32#.rootcanal.configuration.Controller\x12\x0f\n\x07\x61\x64\x64ress\x18\t \x01(\t\x12+\n\x06offset\x18\n \x01(\x0b\x32\x16.netsim.model.PositionH\x00\x88\x01\x01\x42\t\n\x07_offsetb\x06proto3')
+
+_globals = globals()
+_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
+_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'netsim.startup_pb2', _globals)
+if _descriptor._USE_C_DESCRIPTORS == False:
+  DESCRIPTOR._options = None
+  _globals['_STARTUPINFO_DEVICE'].fields_by_name['name']._options = None
+  _globals['_STARTUPINFO_DEVICE'].fields_by_name['name']._serialized_options = b'\030\001'
+  _globals['_CHIPINFO'].fields_by_name['name']._options = None
+  _globals['_CHIPINFO'].fields_by_name['name']._serialized_options = b'\030\001'
+  _globals['_STARTUPINFO']._serialized_start=113
+  _globals['_STARTUPINFO']._serialized_end=293
+  _globals['_STARTUPINFO_DEVICE']._serialized_start=181
+  _globals['_STARTUPINFO_DEVICE']._serialized_end=293
+  _globals['_CHIPINFO']._serialized_start=295
+  _globals['_CHIPINFO']._serialized_end=408
+  _globals['_DEVICEINFO']._serialized_start=410
+  _globals['_DEVICEINFO']._serialized_end=537
+  _globals['_CHIP']._serialized_start=540
+  _globals['_CHIP']._serialized_end=823
+# @@protoc_insertion_point(module_scope)
diff --git a/bumble/transport/grpc_protobuf/netsim/startup_pb2.pyi b/bumble/transport/grpc_protobuf/netsim/startup_pb2.pyi
new file mode 100644
index 0000000..3f4ea7b
--- /dev/null
+++ b/bumble/transport/grpc_protobuf/netsim/startup_pb2.pyi
@@ -0,0 +1,76 @@
+from bumble.transport.grpc_protobuf.netsim import common_pb2 as _common_pb2
+from bumble.transport.grpc_protobuf.netsim import model_pb2 as _model_pb2
+from bumble.transport.grpc_protobuf.rootcanal import configuration_pb2 as _configuration_pb2
+from google.protobuf.internal import containers as _containers
+from google.protobuf import descriptor as _descriptor
+from google.protobuf import message as _message
+from typing import ClassVar as _ClassVar, Iterable as _Iterable, Mapping as _Mapping, Optional as _Optional, Union as _Union
+
+DESCRIPTOR: _descriptor.FileDescriptor
+
+class StartupInfo(_message.Message):
+    __slots__ = ("devices",)
+    class Device(_message.Message):
+        __slots__ = ("name", "chips", "device_info")
+        NAME_FIELD_NUMBER: _ClassVar[int]
+        CHIPS_FIELD_NUMBER: _ClassVar[int]
+        DEVICE_INFO_FIELD_NUMBER: _ClassVar[int]
+        name: str
+        chips: _containers.RepeatedCompositeFieldContainer[Chip]
+        device_info: DeviceInfo
+        def __init__(self, name: _Optional[str] = ..., chips: _Optional[_Iterable[_Union[Chip, _Mapping]]] = ..., device_info: _Optional[_Union[DeviceInfo, _Mapping]] = ...) -> None: ...
+    DEVICES_FIELD_NUMBER: _ClassVar[int]
+    devices: _containers.RepeatedCompositeFieldContainer[StartupInfo.Device]
+    def __init__(self, devices: _Optional[_Iterable[_Union[StartupInfo.Device, _Mapping]]] = ...) -> None: ...
+
+class ChipInfo(_message.Message):
+    __slots__ = ("name", "chip", "device_info")
+    NAME_FIELD_NUMBER: _ClassVar[int]
+    CHIP_FIELD_NUMBER: _ClassVar[int]
+    DEVICE_INFO_FIELD_NUMBER: _ClassVar[int]
+    name: str
+    chip: Chip
+    device_info: DeviceInfo
+    def __init__(self, name: _Optional[str] = ..., chip: _Optional[_Union[Chip, _Mapping]] = ..., device_info: _Optional[_Union[DeviceInfo, _Mapping]] = ...) -> None: ...
+
+class DeviceInfo(_message.Message):
+    __slots__ = ("name", "kind", "version", "sdk_version", "build_id", "variant", "arch")
+    NAME_FIELD_NUMBER: _ClassVar[int]
+    KIND_FIELD_NUMBER: _ClassVar[int]
+    VERSION_FIELD_NUMBER: _ClassVar[int]
+    SDK_VERSION_FIELD_NUMBER: _ClassVar[int]
+    BUILD_ID_FIELD_NUMBER: _ClassVar[int]
+    VARIANT_FIELD_NUMBER: _ClassVar[int]
+    ARCH_FIELD_NUMBER: _ClassVar[int]
+    name: str
+    kind: str
+    version: str
+    sdk_version: str
+    build_id: str
+    variant: str
+    arch: str
+    def __init__(self, name: _Optional[str] = ..., kind: _Optional[str] = ..., version: _Optional[str] = ..., sdk_version: _Optional[str] = ..., build_id: _Optional[str] = ..., variant: _Optional[str] = ..., arch: _Optional[str] = ...) -> None: ...
+
+class Chip(_message.Message):
+    __slots__ = ("kind", "id", "manufacturer", "product_name", "fd_in", "fd_out", "loopback", "bt_properties", "address", "offset")
+    KIND_FIELD_NUMBER: _ClassVar[int]
+    ID_FIELD_NUMBER: _ClassVar[int]
+    MANUFACTURER_FIELD_NUMBER: _ClassVar[int]
+    PRODUCT_NAME_FIELD_NUMBER: _ClassVar[int]
+    FD_IN_FIELD_NUMBER: _ClassVar[int]
+    FD_OUT_FIELD_NUMBER: _ClassVar[int]
+    LOOPBACK_FIELD_NUMBER: _ClassVar[int]
+    BT_PROPERTIES_FIELD_NUMBER: _ClassVar[int]
+    ADDRESS_FIELD_NUMBER: _ClassVar[int]
+    OFFSET_FIELD_NUMBER: _ClassVar[int]
+    kind: _common_pb2.ChipKind
+    id: str
+    manufacturer: str
+    product_name: str
+    fd_in: int
+    fd_out: int
+    loopback: bool
+    bt_properties: _configuration_pb2.Controller
+    address: str
+    offset: _model_pb2.Position
+    def __init__(self, kind: _Optional[_Union[_common_pb2.ChipKind, str]] = ..., id: _Optional[str] = ..., manufacturer: _Optional[str] = ..., product_name: _Optional[str] = ..., fd_in: _Optional[int] = ..., fd_out: _Optional[int] = ..., loopback: bool = ..., bt_properties: _Optional[_Union[_configuration_pb2.Controller, _Mapping]] = ..., address: _Optional[str] = ..., offset: _Optional[_Union[_model_pb2.Position, _Mapping]] = ...) -> None: ...
diff --git a/bumble/transport/grpc_protobuf/netsim/startup_pb2_grpc.py b/bumble/transport/grpc_protobuf/netsim/startup_pb2_grpc.py
new file mode 100644
index 0000000..2daafff
--- /dev/null
+++ b/bumble/transport/grpc_protobuf/netsim/startup_pb2_grpc.py
@@ -0,0 +1,4 @@
+# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
+"""Client and server classes corresponding to protobuf-defined services."""
+import grpc
+
diff --git a/bumble/transport/grpc_protobuf/packet_streamer_pb2.py b/bumble/transport/grpc_protobuf/packet_streamer_pb2.py
deleted file mode 100644
index ea07940..0000000
--- a/bumble/transport/grpc_protobuf/packet_streamer_pb2.py
+++ /dev/null
@@ -1,31 +0,0 @@
-# -*- coding: utf-8 -*-
-# Generated by the protocol buffer compiler.  DO NOT EDIT!
-# source: packet_streamer.proto
-"""Generated protocol buffer code."""
-from google.protobuf.internal import builder as _builder
-from google.protobuf import descriptor as _descriptor
-from google.protobuf import descriptor_pool as _descriptor_pool
-from google.protobuf import symbol_database as _symbol_database
-# @@protoc_insertion_point(imports)
-
-_sym_db = _symbol_database.Default()
-
-
-from . import hci_packet_pb2 as hci__packet__pb2
-from . import startup_pb2 as startup__pb2
-
-
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x15packet_streamer.proto\x12\rnetsim.packet\x1a\x10hci_packet.proto\x1a\rstartup.proto\"\x93\x01\n\rPacketRequest\x12\x30\n\x0cinitial_info\x18\x01 \x01(\x0b\x32\x18.netsim.startup.ChipInfoH\x00\x12.\n\nhci_packet\x18\x02 \x01(\x0b\x32\x18.netsim.packet.HCIPacketH\x00\x12\x10\n\x06packet\x18\x03 \x01(\x0cH\x00\x42\x0e\n\x0crequest_type\"t\n\x0ePacketResponse\x12\x0f\n\x05\x65rror\x18\x01 \x01(\tH\x00\x12.\n\nhci_packet\x18\x02 \x01(\x0b\x32\x18.netsim.packet.HCIPacketH\x00\x12\x10\n\x06packet\x18\x03 \x01(\x0cH\x00\x42\x0f\n\rresponse_type2b\n\x0ePacketStreamer\x12P\n\rStreamPackets\x12\x1c.netsim.packet.PacketRequest\x1a\x1d.netsim.packet.PacketResponse(\x01\x30\x01\x62\x06proto3')
-
-_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, globals())
-_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'packet_streamer_pb2', globals())
-if _descriptor._USE_C_DESCRIPTORS == False:
-
-  DESCRIPTOR._options = None
-  _PACKETREQUEST._serialized_start=74
-  _PACKETREQUEST._serialized_end=221
-  _PACKETRESPONSE._serialized_start=223
-  _PACKETRESPONSE._serialized_end=339
-  _PACKETSTREAMER._serialized_start=341
-  _PACKETSTREAMER._serialized_end=439
-# @@protoc_insertion_point(module_scope)
diff --git a/bumble/transport/grpc_protobuf/rootcanal/__init__.py b/bumble/transport/grpc_protobuf/rootcanal/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/bumble/transport/grpc_protobuf/rootcanal/configuration_pb2.py b/bumble/transport/grpc_protobuf/rootcanal/configuration_pb2.py
new file mode 100644
index 0000000..a336981
--- /dev/null
+++ b/bumble/transport/grpc_protobuf/rootcanal/configuration_pb2.py
@@ -0,0 +1,39 @@
+# -*- coding: utf-8 -*-
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: rootcanal/configuration.proto
+# Protobuf Python Version: 4.25.1
+"""Generated protocol buffer code."""
+from google.protobuf import descriptor as _descriptor
+from google.protobuf import descriptor_pool as _descriptor_pool
+from google.protobuf import symbol_database as _symbol_database
+from google.protobuf.internal import builder as _builder
+# @@protoc_insertion_point(imports)
+
+_sym_db = _symbol_database.Default()
+
+
+
+
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1drootcanal/configuration.proto\x12\x17rootcanal.configuration\"\xbc\x01\n\x12\x43ontrollerFeatures\x12\x1f\n\x17le_extended_advertising\x18\x01 \x01(\x08\x12\x1f\n\x17le_periodic_advertising\x18\x02 \x01(\x08\x12\x12\n\nll_privacy\x18\x03 \x01(\x08\x12\x11\n\tle_2m_phy\x18\x04 \x01(\x08\x12\x14\n\x0cle_coded_phy\x18\x05 \x01(\x08\x12\'\n\x1fle_connected_isochronous_stream\x18\x06 \x01(\x08\"\x8d\x01\n\x10\x43ontrollerQuirks\x12\x30\n(send_acl_data_before_connection_complete\x18\x01 \x01(\x08\x12\"\n\x1ahas_default_random_address\x18\x02 \x01(\x08\x12#\n\x1bhardware_error_before_reset\x18\x03 \x01(\x08\".\n\x0eVendorFeatures\x12\x0b\n\x03\x63sr\x18\x01 \x01(\x08\x12\x0f\n\x07\x61ndroid\x18\x02 \x01(\x08\"\x8a\x02\n\nController\x12\x39\n\x06preset\x18\x01 \x01(\x0e\x32).rootcanal.configuration.ControllerPreset\x12=\n\x08\x66\x65\x61tures\x18\x02 \x01(\x0b\x32+.rootcanal.configuration.ControllerFeatures\x12\x39\n\x06quirks\x18\x03 \x01(\x0b\x32).rootcanal.configuration.ControllerQuirks\x12\x0e\n\x06strict\x18\x04 \x01(\x08\x12\x37\n\x06vendor\x18\x05 \x01(\x0b\x32\'.rootcanal.configuration.VendorFeatures\"Y\n\tTcpServer\x12\x10\n\x08tcp_port\x18\x01 \x02(\x05\x12:\n\rconfiguration\x18\x02 \x01(\x0b\x32#.rootcanal.configuration.Controller\"G\n\rConfiguration\x12\x36\n\ntcp_server\x18\x01 \x03(\x0b\x32\".rootcanal.configuration.TcpServer*H\n\x10\x43ontrollerPreset\x12\x0b\n\x07\x44\x45\x46\x41ULT\x10\x00\x12\x0f\n\x0bLAIRD_BL654\x10\x01\x12\x16\n\x12\x43SR_RCK_PTS_DONGLE\x10\x02\x42\x02H\x02')
+
+_globals = globals()
+_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
+_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'rootcanal.configuration_pb2', _globals)
+if _descriptor._USE_C_DESCRIPTORS == False:
+  _globals['DESCRIPTOR']._options = None
+  _globals['DESCRIPTOR']._serialized_options = b'H\002'
+  _globals['_CONTROLLERPRESET']._serialized_start=874
+  _globals['_CONTROLLERPRESET']._serialized_end=946
+  _globals['_CONTROLLERFEATURES']._serialized_start=59
+  _globals['_CONTROLLERFEATURES']._serialized_end=247
+  _globals['_CONTROLLERQUIRKS']._serialized_start=250
+  _globals['_CONTROLLERQUIRKS']._serialized_end=391
+  _globals['_VENDORFEATURES']._serialized_start=393
+  _globals['_VENDORFEATURES']._serialized_end=439
+  _globals['_CONTROLLER']._serialized_start=442
+  _globals['_CONTROLLER']._serialized_end=708
+  _globals['_TCPSERVER']._serialized_start=710
+  _globals['_TCPSERVER']._serialized_end=799
+  _globals['_CONFIGURATION']._serialized_start=801
+  _globals['_CONFIGURATION']._serialized_end=872
+# @@protoc_insertion_point(module_scope)
diff --git a/bumble/transport/grpc_protobuf/rootcanal/configuration_pb2.pyi b/bumble/transport/grpc_protobuf/rootcanal/configuration_pb2.pyi
new file mode 100644
index 0000000..4b01f6c
--- /dev/null
+++ b/bumble/transport/grpc_protobuf/rootcanal/configuration_pb2.pyi
@@ -0,0 +1,78 @@
+from google.protobuf.internal import containers as _containers
+from google.protobuf.internal import enum_type_wrapper as _enum_type_wrapper
+from google.protobuf import descriptor as _descriptor
+from google.protobuf import message as _message
+from typing import ClassVar as _ClassVar, Iterable as _Iterable, Mapping as _Mapping, Optional as _Optional, Union as _Union
+
+DESCRIPTOR: _descriptor.FileDescriptor
+
+class ControllerPreset(int, metaclass=_enum_type_wrapper.EnumTypeWrapper):
+    __slots__ = ()
+    DEFAULT: _ClassVar[ControllerPreset]
+    LAIRD_BL654: _ClassVar[ControllerPreset]
+    CSR_RCK_PTS_DONGLE: _ClassVar[ControllerPreset]
+DEFAULT: ControllerPreset
+LAIRD_BL654: ControllerPreset
+CSR_RCK_PTS_DONGLE: ControllerPreset
+
+class ControllerFeatures(_message.Message):
+    __slots__ = ("le_extended_advertising", "le_periodic_advertising", "ll_privacy", "le_2m_phy", "le_coded_phy", "le_connected_isochronous_stream")
+    LE_EXTENDED_ADVERTISING_FIELD_NUMBER: _ClassVar[int]
+    LE_PERIODIC_ADVERTISING_FIELD_NUMBER: _ClassVar[int]
+    LL_PRIVACY_FIELD_NUMBER: _ClassVar[int]
+    LE_2M_PHY_FIELD_NUMBER: _ClassVar[int]
+    LE_CODED_PHY_FIELD_NUMBER: _ClassVar[int]
+    LE_CONNECTED_ISOCHRONOUS_STREAM_FIELD_NUMBER: _ClassVar[int]
+    le_extended_advertising: bool
+    le_periodic_advertising: bool
+    ll_privacy: bool
+    le_2m_phy: bool
+    le_coded_phy: bool
+    le_connected_isochronous_stream: bool
+    def __init__(self, le_extended_advertising: bool = ..., le_periodic_advertising: bool = ..., ll_privacy: bool = ..., le_2m_phy: bool = ..., le_coded_phy: bool = ..., le_connected_isochronous_stream: bool = ...) -> None: ...
+
+class ControllerQuirks(_message.Message):
+    __slots__ = ("send_acl_data_before_connection_complete", "has_default_random_address", "hardware_error_before_reset")
+    SEND_ACL_DATA_BEFORE_CONNECTION_COMPLETE_FIELD_NUMBER: _ClassVar[int]
+    HAS_DEFAULT_RANDOM_ADDRESS_FIELD_NUMBER: _ClassVar[int]
+    HARDWARE_ERROR_BEFORE_RESET_FIELD_NUMBER: _ClassVar[int]
+    send_acl_data_before_connection_complete: bool
+    has_default_random_address: bool
+    hardware_error_before_reset: bool
+    def __init__(self, send_acl_data_before_connection_complete: bool = ..., has_default_random_address: bool = ..., hardware_error_before_reset: bool = ...) -> None: ...
+
+class VendorFeatures(_message.Message):
+    __slots__ = ("csr", "android")
+    CSR_FIELD_NUMBER: _ClassVar[int]
+    ANDROID_FIELD_NUMBER: _ClassVar[int]
+    csr: bool
+    android: bool
+    def __init__(self, csr: bool = ..., android: bool = ...) -> None: ...
+
+class Controller(_message.Message):
+    __slots__ = ("preset", "features", "quirks", "strict", "vendor")
+    PRESET_FIELD_NUMBER: _ClassVar[int]
+    FEATURES_FIELD_NUMBER: _ClassVar[int]
+    QUIRKS_FIELD_NUMBER: _ClassVar[int]
+    STRICT_FIELD_NUMBER: _ClassVar[int]
+    VENDOR_FIELD_NUMBER: _ClassVar[int]
+    preset: ControllerPreset
+    features: ControllerFeatures
+    quirks: ControllerQuirks
+    strict: bool
+    vendor: VendorFeatures
+    def __init__(self, preset: _Optional[_Union[ControllerPreset, str]] = ..., features: _Optional[_Union[ControllerFeatures, _Mapping]] = ..., quirks: _Optional[_Union[ControllerQuirks, _Mapping]] = ..., strict: bool = ..., vendor: _Optional[_Union[VendorFeatures, _Mapping]] = ...) -> None: ...
+
+class TcpServer(_message.Message):
+    __slots__ = ("tcp_port", "configuration")
+    TCP_PORT_FIELD_NUMBER: _ClassVar[int]
+    CONFIGURATION_FIELD_NUMBER: _ClassVar[int]
+    tcp_port: int
+    configuration: Controller
+    def __init__(self, tcp_port: _Optional[int] = ..., configuration: _Optional[_Union[Controller, _Mapping]] = ...) -> None: ...
+
+class Configuration(_message.Message):
+    __slots__ = ("tcp_server",)
+    TCP_SERVER_FIELD_NUMBER: _ClassVar[int]
+    tcp_server: _containers.RepeatedCompositeFieldContainer[TcpServer]
+    def __init__(self, tcp_server: _Optional[_Iterable[_Union[TcpServer, _Mapping]]] = ...) -> None: ...
diff --git a/bumble/transport/grpc_protobuf/rootcanal/configuration_pb2_grpc.py b/bumble/transport/grpc_protobuf/rootcanal/configuration_pb2_grpc.py
new file mode 100644
index 0000000..2daafff
--- /dev/null
+++ b/bumble/transport/grpc_protobuf/rootcanal/configuration_pb2_grpc.py
@@ -0,0 +1,4 @@
+# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
+"""Client and server classes corresponding to protobuf-defined services."""
+import grpc
+
diff --git a/bumble/transport/grpc_protobuf/startup_pb2.py b/bumble/transport/grpc_protobuf/startup_pb2.py
deleted file mode 100644
index 532ac0e..0000000
--- a/bumble/transport/grpc_protobuf/startup_pb2.py
+++ /dev/null
@@ -1,32 +0,0 @@
-# -*- coding: utf-8 -*-
-# Generated by the protocol buffer compiler.  DO NOT EDIT!
-# source: startup.proto
-"""Generated protocol buffer code."""
-from google.protobuf.internal import builder as _builder
-from google.protobuf import descriptor as _descriptor
-from google.protobuf import descriptor_pool as _descriptor_pool
-from google.protobuf import symbol_database as _symbol_database
-# @@protoc_insertion_point(imports)
-
-_sym_db = _symbol_database.Default()
-
-
-from . import common_pb2 as common__pb2
-
-
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\rstartup.proto\x12\x0enetsim.startup\x1a\x0c\x63ommon.proto\"\x7f\n\x0bStartupInfo\x12\x33\n\x07\x64\x65vices\x18\x01 \x03(\x0b\x32\".netsim.startup.StartupInfo.Device\x1a;\n\x06\x44\x65vice\x12\x0c\n\x04name\x18\x01 \x01(\t\x12#\n\x05\x63hips\x18\x02 \x03(\x0b\x32\x14.netsim.startup.Chip\"<\n\x08\x43hipInfo\x12\x0c\n\x04name\x18\x01 \x01(\t\x12\"\n\x04\x63hip\x18\x02 \x01(\x0b\x32\x14.netsim.startup.Chip\"\x96\x01\n\x04\x43hip\x12%\n\x04kind\x18\x01 \x01(\x0e\x32\x17.netsim.common.ChipKind\x12\n\n\x02id\x18\x02 \x01(\t\x12\x14\n\x0cmanufacturer\x18\x03 \x01(\t\x12\x14\n\x0cproduct_name\x18\x04 \x01(\t\x12\r\n\x05\x66\x64_in\x18\x05 \x01(\x05\x12\x0e\n\x06\x66\x64_out\x18\x06 \x01(\x05\x12\x10\n\x08loopback\x18\x07 \x01(\x08\x62\x06proto3')
-
-_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, globals())
-_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'startup_pb2', globals())
-if _descriptor._USE_C_DESCRIPTORS == False:
-
-  DESCRIPTOR._options = None
-  _STARTUPINFO._serialized_start=47
-  _STARTUPINFO._serialized_end=174
-  _STARTUPINFO_DEVICE._serialized_start=115
-  _STARTUPINFO_DEVICE._serialized_end=174
-  _CHIPINFO._serialized_start=176
-  _CHIPINFO._serialized_end=236
-  _CHIP._serialized_start=239
-  _CHIP._serialized_end=389
-# @@protoc_insertion_point(module_scope)
diff --git a/bumble/transport/grpc_protobuf/startup_pb2.pyi b/bumble/transport/grpc_protobuf/startup_pb2.pyi
deleted file mode 100644
index 604d915..0000000
--- a/bumble/transport/grpc_protobuf/startup_pb2.pyi
+++ /dev/null
@@ -1,46 +0,0 @@
-from . import common_pb2 as _common_pb2
-from google.protobuf.internal import containers as _containers
-from google.protobuf import descriptor as _descriptor
-from google.protobuf import message as _message
-from typing import ClassVar as _ClassVar, Iterable as _Iterable, Mapping as _Mapping, Optional as _Optional, Union as _Union
-
-DESCRIPTOR: _descriptor.FileDescriptor
-
-class Chip(_message.Message):
-    __slots__ = ["fd_in", "fd_out", "id", "kind", "loopback", "manufacturer", "product_name"]
-    FD_IN_FIELD_NUMBER: _ClassVar[int]
-    FD_OUT_FIELD_NUMBER: _ClassVar[int]
-    ID_FIELD_NUMBER: _ClassVar[int]
-    KIND_FIELD_NUMBER: _ClassVar[int]
-    LOOPBACK_FIELD_NUMBER: _ClassVar[int]
-    MANUFACTURER_FIELD_NUMBER: _ClassVar[int]
-    PRODUCT_NAME_FIELD_NUMBER: _ClassVar[int]
-    fd_in: int
-    fd_out: int
-    id: str
-    kind: _common_pb2.ChipKind
-    loopback: bool
-    manufacturer: str
-    product_name: str
-    def __init__(self, kind: _Optional[_Union[_common_pb2.ChipKind, str]] = ..., id: _Optional[str] = ..., manufacturer: _Optional[str] = ..., product_name: _Optional[str] = ..., fd_in: _Optional[int] = ..., fd_out: _Optional[int] = ..., loopback: bool = ...) -> None: ...
-
-class ChipInfo(_message.Message):
-    __slots__ = ["chip", "name"]
-    CHIP_FIELD_NUMBER: _ClassVar[int]
-    NAME_FIELD_NUMBER: _ClassVar[int]
-    chip: Chip
-    name: str
-    def __init__(self, name: _Optional[str] = ..., chip: _Optional[_Union[Chip, _Mapping]] = ...) -> None: ...
-
-class StartupInfo(_message.Message):
-    __slots__ = ["devices"]
-    class Device(_message.Message):
-        __slots__ = ["chips", "name"]
-        CHIPS_FIELD_NUMBER: _ClassVar[int]
-        NAME_FIELD_NUMBER: _ClassVar[int]
-        chips: _containers.RepeatedCompositeFieldContainer[Chip]
-        name: str
-        def __init__(self, name: _Optional[str] = ..., chips: _Optional[_Iterable[_Union[Chip, _Mapping]]] = ...) -> None: ...
-    DEVICES_FIELD_NUMBER: _ClassVar[int]
-    devices: _containers.RepeatedCompositeFieldContainer[StartupInfo.Device]
-    def __init__(self, devices: _Optional[_Iterable[_Union[StartupInfo.Device, _Mapping]]] = ...) -> None: ...
diff --git a/bumble/transport/hci_socket.py b/bumble/transport/hci_socket.py
index 4125043..6ea6793 100644
--- a/bumble/transport/hci_socket.py
+++ b/bumble/transport/hci_socket.py
@@ -25,7 +25,7 @@ import collections
 
 from typing import Optional
 
-from .common import Transport, ParserSource
+from bumble.transport.common import Transport, ParserSource
 
 
 # -----------------------------------------------------------------------------
diff --git a/bumble/transport/pty.py b/bumble/transport/pty.py
index 2f46e75..75f30a2 100644
--- a/bumble/transport/pty.py
+++ b/bumble/transport/pty.py
@@ -25,7 +25,7 @@ import logging
 
 from typing import Optional
 
-from .common import Transport, StreamPacketSource, StreamPacketSink
+from bumble.transport.common import Transport, StreamPacketSource, StreamPacketSink
 
 # -----------------------------------------------------------------------------
 # Logging
diff --git a/bumble/transport/pyusb.py b/bumble/transport/pyusb.py
index 1fabe14..454474a 100644
--- a/bumble/transport/pyusb.py
+++ b/bumble/transport/pyusb.py
@@ -29,9 +29,9 @@ from usb.core import USBError
 from usb.util import CTRL_TYPE_CLASS, CTRL_RECIPIENT_OTHER
 from usb.legacy import REQ_SET_FEATURE, REQ_CLEAR_FEATURE, CLASS_HUB
 
-from .common import Transport, ParserSource, TransportInitError
-from .. import hci
-from ..colors import color
+from bumble.transport.common import Transport, ParserSource, TransportInitError
+from bumble import hci
+from bumble.colors import color
 
 
 # -----------------------------------------------------------------------------
diff --git a/bumble/transport/serial.py b/bumble/transport/serial.py
index c48cdc6..9c5a299 100644
--- a/bumble/transport/serial.py
+++ b/bumble/transport/serial.py
@@ -19,7 +19,7 @@ import asyncio
 import logging
 import serial_asyncio
 
-from .common import Transport, StreamPacketSource, StreamPacketSink
+from bumble.transport.common import Transport, StreamPacketSource, StreamPacketSink
 
 # -----------------------------------------------------------------------------
 # Logging
diff --git a/bumble/transport/tcp_client.py b/bumble/transport/tcp_client.py
index 4fb268a..0d73e28 100644
--- a/bumble/transport/tcp_client.py
+++ b/bumble/transport/tcp_client.py
@@ -18,7 +18,7 @@
 import asyncio
 import logging
 
-from .common import Transport, StreamPacketSource, StreamPacketSink
+from bumble.transport.common import Transport, StreamPacketSource, StreamPacketSink
 
 # -----------------------------------------------------------------------------
 # Logging
diff --git a/bumble/transport/tcp_server.py b/bumble/transport/tcp_server.py
index 0a648fd..58e15dc 100644
--- a/bumble/transport/tcp_server.py
+++ b/bumble/transport/tcp_server.py
@@ -20,7 +20,7 @@ import asyncio
 import logging
 import socket
 
-from .common import Transport, StreamPacketSource
+from bumble.transport.common import Transport, StreamPacketSource
 
 # -----------------------------------------------------------------------------
 # Logging
diff --git a/bumble/transport/udp.py b/bumble/transport/udp.py
index faa9bf0..99f6665 100644
--- a/bumble/transport/udp.py
+++ b/bumble/transport/udp.py
@@ -18,7 +18,7 @@
 import asyncio
 import logging
 
-from .common import Transport, ParserSource
+from bumble.transport.common import Transport, ParserSource
 
 # -----------------------------------------------------------------------------
 # Logging
diff --git a/bumble/transport/unix.py b/bumble/transport/unix.py
index 973872b..2e9ae4b 100644
--- a/bumble/transport/unix.py
+++ b/bumble/transport/unix.py
@@ -18,7 +18,7 @@
 import asyncio
 import logging
 
-from .common import Transport, StreamPacketSource, StreamPacketSink
+from bumble.transport.common import Transport, StreamPacketSource, StreamPacketSink
 
 # -----------------------------------------------------------------------------
 # Logging
diff --git a/bumble/transport/usb.py b/bumble/transport/usb.py
index 0b865cf..9718853 100644
--- a/bumble/transport/usb.py
+++ b/bumble/transport/usb.py
@@ -115,9 +115,7 @@ async def open_usb_transport(spec: str) -> Transport:
             self.acl_out = acl_out
             self.acl_out_transfer = device.getTransfer()
             self.acl_out_transfer_ready = asyncio.Semaphore(1)
-            self.packets: asyncio.Queue[bytes] = (
-                asyncio.Queue()
-            )  # Queue of packets waiting to be sent
+            self.packets = asyncio.Queue[bytes]()  # Queue of packets waiting to be sent
             self.loop = asyncio.get_running_loop()
             self.queue_task = None
             self.cancel_done = self.loop.create_future()
@@ -149,7 +147,10 @@ async def open_usb_transport(spec: str) -> Transport:
 
             if status != usb1.TRANSFER_COMPLETED:
                 logger.warning(
-                    color(f'!!! OUT transfer not completed: status={status}', 'red')
+                    color(
+                        f'!!! OUT transfer not completed: status={status}',
+                        'red',
+                    )
                 )
 
         async def process_queue(self):
@@ -275,7 +276,10 @@ async def open_usb_transport(spec: str) -> Transport:
                 )
             else:
                 logger.warning(
-                    color(f'!!! IN transfer not completed: status={status}', 'red')
+                    color(
+                        f'!!! IN[{packet_type}] transfer not completed: status={status}',
+                        'red',
+                    )
                 )
                 self.loop.call_soon_threadsafe(self.on_transport_lost)
 
diff --git a/bumble/transport/vhci.py b/bumble/transport/vhci.py
index 2b19085..dc60202 100644
--- a/bumble/transport/vhci.py
+++ b/bumble/transport/vhci.py
@@ -19,8 +19,8 @@ import logging
 
 from typing import Optional
 
-from .common import Transport
-from .file import open_file_transport
+from bumble.transport.common import Transport
+from bumble.transport.file import open_file_transport
 
 # -----------------------------------------------------------------------------
 # Logging
diff --git a/bumble/transport/ws_client.py b/bumble/transport/ws_client.py
index 902001e..86b7e9c 100644
--- a/bumble/transport/ws_client.py
+++ b/bumble/transport/ws_client.py
@@ -18,7 +18,12 @@
 import logging
 import websockets.client
 
-from .common import PumpedPacketSource, PumpedPacketSink, PumpedTransport, Transport
+from bumble.transport.common import (
+    PumpedPacketSource,
+    PumpedPacketSink,
+    PumpedTransport,
+    Transport,
+)
 
 # -----------------------------------------------------------------------------
 # Logging
diff --git a/bumble/transport/ws_server.py b/bumble/transport/ws_server.py
index 3c72c36..b45bc4e 100644
--- a/bumble/transport/ws_server.py
+++ b/bumble/transport/ws_server.py
@@ -18,7 +18,7 @@
 import logging
 import websockets
 
-from .common import Transport, ParserSource, PumpedPacketSink
+from bumble.transport.common import Transport, ParserSource, PumpedPacketSink
 
 # -----------------------------------------------------------------------------
 # Logging
diff --git a/bumble/utils.py b/bumble/utils.py
index 4c9407f..af16118 100644
--- a/bumble/utils.py
+++ b/bumble/utils.py
@@ -24,21 +24,24 @@ import logging
 import sys
 import warnings
 from typing import (
+    Any,
     Awaitable,
-    Set,
-    TypeVar,
-    List,
-    Tuple,
     Callable,
-    Any,
+    List,
     Optional,
+    Protocol,
+    Set,
+    Tuple,
+    TypeVar,
     Union,
     overload,
 )
+from typing_extensions import Self
 
-from pyee import EventEmitter
+import pyee
+import pyee.asyncio
 
-from .colors import color
+from bumble.colors import color
 
 # -----------------------------------------------------------------------------
 # Logging
@@ -54,6 +57,48 @@ def setup_event_forwarding(emitter, forwarder, event_name):
     emitter.on(event_name, emit)
 
 
+# -----------------------------------------------------------------------------
+def wrap_async(function):
+    """
+    Wraps the provided function in an async function.
+    """
+    return functools.partial(async_call, function)
+
+
+# -----------------------------------------------------------------------------
+def deprecated(msg: str):
+    """
+    Throw deprecation warning before execution.
+    """
+
+    def wrapper(function):
+        @functools.wraps(function)
+        def inner(*args, **kwargs):
+            warnings.warn(msg, DeprecationWarning, stacklevel=2)
+            return function(*args, **kwargs)
+
+        return inner
+
+    return wrapper
+
+
+# -----------------------------------------------------------------------------
+def experimental(msg: str):
+    """
+    Throws a future warning before execution.
+    """
+
+    def wrapper(function):
+        @functools.wraps(function)
+        def inner(*args, **kwargs):
+            warnings.warn(msg, FutureWarning, stacklevel=2)
+            return function(*args, **kwargs)
+
+        return inner
+
+    return wrapper
+
+
 # -----------------------------------------------------------------------------
 def composite_listener(cls):
     """
@@ -111,21 +156,23 @@ class EventWatcher:
     ```
     '''
 
-    handlers: List[Tuple[EventEmitter, str, Callable[..., Any]]]
+    handlers: List[Tuple[pyee.EventEmitter, str, Callable[..., Any]]]
 
     def __init__(self) -> None:
         self.handlers = []
 
     @overload
     def on(
-        self, emitter: EventEmitter, event: str
+        self, emitter: pyee.EventEmitter, event: str
     ) -> Callable[[_Handler], _Handler]: ...
 
     @overload
-    def on(self, emitter: EventEmitter, event: str, handler: _Handler) -> _Handler: ...
+    def on(
+        self, emitter: pyee.EventEmitter, event: str, handler: _Handler
+    ) -> _Handler: ...
 
     def on(
-        self, emitter: EventEmitter, event: str, handler: Optional[_Handler] = None
+        self, emitter: pyee.EventEmitter, event: str, handler: Optional[_Handler] = None
     ) -> Union[_Handler, Callable[[_Handler], _Handler]]:
         '''Watch an event until the context is closed.
 
@@ -145,16 +192,16 @@ class EventWatcher:
 
     @overload
     def once(
-        self, emitter: EventEmitter, event: str
+        self, emitter: pyee.EventEmitter, event: str
     ) -> Callable[[_Handler], _Handler]: ...
 
     @overload
     def once(
-        self, emitter: EventEmitter, event: str, handler: _Handler
+        self, emitter: pyee.EventEmitter, event: str, handler: _Handler
     ) -> _Handler: ...
 
     def once(
-        self, emitter: EventEmitter, event: str, handler: Optional[_Handler] = None
+        self, emitter: pyee.EventEmitter, event: str, handler: Optional[_Handler] = None
     ) -> Union[_Handler, Callable[[_Handler], _Handler]]:
         '''Watch an event for once.
 
@@ -182,38 +229,48 @@ class EventWatcher:
 _T = TypeVar('_T')
 
 
-class AbortableEventEmitter(EventEmitter):
-    def abort_on(self, event: str, awaitable: Awaitable[_T]) -> Awaitable[_T]:
-        """
-        Set a coroutine or future to abort when an event occur.
-        """
-        future = asyncio.ensure_future(awaitable)
+def cancel_on_event(
+    emitter: pyee.EventEmitter, event: str, awaitable: Awaitable[_T]
+) -> Awaitable[_T]:
+    """Set a coroutine or future to cancel when an event occur."""
+    future = asyncio.ensure_future(awaitable)
+    if future.done():
+        return future
+
+    def on_event(*args, **kwargs) -> None:
+        del args, kwargs
         if future.done():
-            return future
-
-        def on_event(*_):
-            if future.done():
-                return
-            msg = f'abort: {event} event occurred.'
-            if isinstance(future, asyncio.Task):
-                # python < 3.9 does not support passing a message on `Task.cancel`
-                if sys.version_info < (3, 9, 0):
-                    future.cancel()
-                else:
-                    future.cancel(msg)
+            return
+        msg = f'abort: {event} event occurred.'
+        if isinstance(future, asyncio.Task):
+            # python < 3.9 does not support passing a message on `Task.cancel`
+            if sys.version_info < (3, 9, 0):
+                future.cancel()
             else:
-                future.set_exception(asyncio.CancelledError(msg))
+                future.cancel(msg)
+        else:
+            future.set_exception(asyncio.CancelledError(msg))
 
-        def on_done(_):
-            self.remove_listener(event, on_event)
+    def on_done(_):
+        emitter.remove_listener(event, on_event)
 
-        self.on(event, on_event)
-        future.add_done_callback(on_done)
-        return future
+    emitter.on(event, on_event)
+    future.add_done_callback(on_done)
+    return future
+
+
+# -----------------------------------------------------------------------------
+class EventEmitter(pyee.asyncio.AsyncIOEventEmitter):
+    """A Base EventEmitter for Bumble."""
+
+    @deprecated("Use `cancel_on_event` instead.")
+    def abort_on(self, event: str, awaitable: Awaitable[_T]) -> Awaitable[_T]:
+        """Set a coroutine or future to abort when an event occur."""
+        return cancel_on_event(self, event, awaitable)
 
 
 # -----------------------------------------------------------------------------
-class CompositeEventEmitter(AbortableEventEmitter):
+class CompositeEventEmitter(EventEmitter):
     def __init__(self):
         super().__init__()
         self._listener = None
@@ -429,61 +486,42 @@ async def async_call(function, *args, **kwargs):
 
 
 # -----------------------------------------------------------------------------
-def wrap_async(function):
-    """
-    Wraps the provided function in an async function.
-    """
-    return functools.partial(async_call, function)
-
-
-# -----------------------------------------------------------------------------
-def deprecated(msg: str):
+class OpenIntEnum(enum.IntEnum):
     """
-    Throw deprecation warning before execution.
+    Subclass of enum.IntEnum that can hold integer values outside the set of
+    predefined values. This is convenient for implementing protocols where some
+    integer constants may be added over time.
     """
 
-    def wrapper(function):
-        @functools.wraps(function)
-        def inner(*args, **kwargs):
-            warnings.warn(msg, DeprecationWarning)
-            return function(*args, **kwargs)
-
-        return inner
+    @classmethod
+    def _missing_(cls, value):
+        if not isinstance(value, int):
+            return None
 
-    return wrapper
+        obj = int.__new__(cls, value)
+        obj._value_ = value
+        obj._name_ = f"{cls.__name__}[{value}]"
+        return obj
 
 
 # -----------------------------------------------------------------------------
-def experimental(msg: str):
+class ByteSerializable(Protocol):
     """
-    Throws a future warning before execution.
+    Type protocol for classes that can be instantiated from bytes and serialized
+    to bytes.
     """
 
-    def wrapper(function):
-        @functools.wraps(function)
-        def inner(*args, **kwargs):
-            warnings.warn(msg, FutureWarning)
-            return function(*args, **kwargs)
+    @classmethod
+    def from_bytes(cls, data: bytes) -> Self: ...
 
-        return inner
-
-    return wrapper
+    def __bytes__(self) -> bytes: ...
 
 
 # -----------------------------------------------------------------------------
-class OpenIntEnum(enum.IntEnum):
+class IntConvertible(Protocol):
     """
-    Subclass of enum.IntEnum that can hold integer values outside the set of
-    predefined values. This is convenient for implementing protocols where some
-    integer constants may be added over time.
+    Type protocol for classes that can be instantiated from int and converted to int.
     """
 
-    @classmethod
-    def _missing_(cls, value):
-        if not isinstance(value, int):
-            return None
-
-        obj = int.__new__(cls, value)
-        obj._value_ = value
-        obj._name_ = f"{cls.__name__}[{value}]"
-        return obj
+    def __init__(self, value: int) -> None: ...
+    def __int__(self) -> int: ...
diff --git a/bumble/vendor/android/hci.py b/bumble/vendor/android/hci.py
index c411ecf..e89dcdd 100644
--- a/bumble/vendor/android/hci.py
+++ b/bumble/vendor/android/hci.py
@@ -16,6 +16,7 @@
 # Imports
 # -----------------------------------------------------------------------------
 import struct
+from typing import Dict, Optional, Type
 
 from bumble.hci import (
     name_or_number,
@@ -24,7 +25,9 @@ from bumble.hci import (
     HCI_Constant,
     HCI_Object,
     HCI_Command,
-    HCI_Vendor_Event,
+    HCI_Event,
+    HCI_Extended_Event,
+    HCI_VENDOR_EVENT,
     STATUS_SPEC,
 )
 
@@ -48,7 +51,6 @@ HCI_DYNAMIC_AUDIO_BUFFER_COMMAND = hci_vendor_command_op_code(0x15F)
 HCI_BLUETOOTH_QUALITY_REPORT_EVENT = 0x58
 
 HCI_Command.register_commands(globals())
-HCI_Vendor_Event.register_subevents(globals())
 
 
 # -----------------------------------------------------------------------------
@@ -279,7 +281,29 @@ class HCI_Dynamic_Audio_Buffer_Command(HCI_Command):
 
 
 # -----------------------------------------------------------------------------
-@HCI_Vendor_Event.event(
+class HCI_Android_Vendor_Event(HCI_Extended_Event):
+    event_code: int = HCI_VENDOR_EVENT
+    subevent_classes: Dict[int, Type[HCI_Extended_Event]] = {}
+
+    @classmethod
+    def subclass_from_parameters(
+        cls, parameters: bytes
+    ) -> Optional[HCI_Extended_Event]:
+        subevent_code = parameters[0]
+        if subevent_code == HCI_BLUETOOTH_QUALITY_REPORT_EVENT:
+            quality_report_id = parameters[1]
+            if quality_report_id in (0x01, 0x02, 0x03, 0x04, 0x07, 0x08, 0x09):
+                return HCI_Bluetooth_Quality_Report_Event.from_parameters(parameters)
+
+        return None
+
+
+HCI_Android_Vendor_Event.register_subevents(globals())
+HCI_Event.add_vendor_factory(HCI_Android_Vendor_Event.subclass_from_parameters)
+
+
+# -----------------------------------------------------------------------------
+@HCI_Extended_Event.event(
     fields=[
         ('quality_report_id', 1),
         ('packet_types', 1),
@@ -308,10 +332,11 @@ class HCI_Dynamic_Audio_Buffer_Command(HCI_Command):
         ('tx_last_subevent_packets', 4),
         ('crc_error_packets', 4),
         ('rx_duplicate_packets', 4),
+        ('rx_unreceived_packets', 4),
         ('vendor_specific_parameters', '*'),
     ]
 )
-class HCI_Bluetooth_Quality_Report_Event(HCI_Vendor_Event):
+class HCI_Bluetooth_Quality_Report_Event(HCI_Android_Vendor_Event):
     # pylint: disable=line-too-long
     '''
     See https://source.android.com/docs/core/connect/bluetooth/hci_requirements#bluetooth-quality-report-sub-event
diff --git a/docs/mkdocs/mkdocs.yml b/docs/mkdocs/mkdocs.yml
index 6590d12..f8e92b4 100644
--- a/docs/mkdocs/mkdocs.yml
+++ b/docs/mkdocs/mkdocs.yml
@@ -39,12 +39,14 @@ nav:
   - Drivers:
     - drivers/index.md
     - Realtek: drivers/realtek.md
+    - Intel: drivers/intel.md
   - API:
     - Guide: api/guide.md
     - Examples: api/examples.md
     - Reference: api/reference.md
   - Apps & Tools:
     - apps_and_tools/index.md
+    - Auracast: apps_and_tools/auracast.md
     - Console: apps_and_tools/console.md
     - Bench: apps_and_tools/bench.md
     - Speaker: apps_and_tools/speaker.md
@@ -108,8 +110,8 @@ markdown_extensions:
   - pymdownx.details
   - pymdownx.superfences
   - pymdownx.emoji:
-      emoji_index: !!python/name:materialx.emoji.twemoji
-      emoji_generator: !!python/name:materialx.emoji.to_svg
+      emoji_index: !!python/name:material.extensions.emoji.twemoji
+      emoji_generator: !!python/name:material.extensions.emoji.to_svg
   - pymdownx.tabbed:
       alternate_style: true
   - codehilite:
diff --git a/docs/mkdocs/src/apps_and_tools/auracast.md b/docs/mkdocs/src/apps_and_tools/auracast.md
new file mode 100644
index 0000000..fca9f5a
--- /dev/null
+++ b/docs/mkdocs/src/apps_and_tools/auracast.md
@@ -0,0 +1,202 @@
+AURACAST TOOL
+=============
+
+The "auracast" tool implements commands that implement broadcasting, receiving
+and controlling LE Audio broadcasts.
+
+=== "Running as an installed package"
+    ```
+    $ bumble-auracast
+    ```
+
+=== "Running from source"
+    ```
+    $ python3 apps/auracast.py <args>
+    ```
+
+# Python Dependencies
+Try installing the optional `[auracast]` dependencies:
+
+=== "From source"
+    ```bash
+    $ python3 -m pip install ".[auracast]"
+    ```
+
+=== "From PyPI"
+    ```bash
+    $ python3 -m pip install "bumble[auracast]"
+    ```
+
+## LC3
+The `auracast` app depends on the `lc3` python module, which is available
+either as PyPI module (currently only available for Linux x86_64).
+When installing Bumble with the optional `auracast` dependency, the `lc3`
+module will be installed from the `lc3py` PyPI package if available.
+If not, you will need to install it separately. This can be done with:
+```bash
+$ python3 -m pip install "git+https://github.com/google/liblc3.git"
+```
+
+## SoundDevice
+The `sounddevice` module is required for audio output to the host's sound
+output device(s) and/or input from the host's input device(s).
+If not installed, the `auracast` app is still functional, but will be limited
+to non-device inputs and output (files, external processes, ...)
+
+On macOS and Windows, the `sounddevice` module gets installed with the
+native PortAudio libraries included.
+
+For Linux, however, PortAudio must be installed separately.
+This is typically done with a command like:
+```bash
+$ sudo apt install libportaudio2
+```
+
+Visit the [sounddevice documentation](https://python-sounddevice.readthedocs.io/)
+for details.
+
+
+# General Usage
+```
+Usage: bumble-auracast [OPTIONS] COMMAND [ARGS]...
+
+Options:
+  --help  Show this message and exit.
+
+Commands:
+  assist    Scan for broadcasts on behalf of an audio server
+  pair      Pair with an audio server
+  receive   Receive a broadcast source
+  scan      Scan for public broadcasts
+  transmit  Transmit a broadcast source
+```
+
+Use `bumble-auracast <command> --help` to get more detailed usage information
+for a specific `<command>`.
+
+## `assist`
+Act as a broadcast assistant.
+
+Use `bumble-auracast assist --help` for details on the commands and options.
+
+The assistant commands are:
+
+### `monitor-state`
+Subscribe to the state characteristic and monitor changes.
+
+### `add-source`
+Add a broadcast source. This will instruct the device to start
+receiving a broadcast.
+
+### `modify-source`
+Modify a broadcast source.
+
+### `remove-source`
+Remote a broadcast source.
+
+## `pair`
+Pair with a device.
+
+## `receive`
+Receive a broadcast source.
+
+The `--output` option specifies where to send the decoded audio samples.
+The following outputs are supported:
+
+### Sound Device
+The `--output` argument is either `device`, to send the audio to the hosts's default sound device, or `device:<DEVICE_ID>` where `<DEVICE_ID>`
+is the integer ID of one of the available sound devices.
+When invoked with `--output "device:?"`, a list of available devices and
+their IDs is printed out.
+
+### Standard Output
+With `--output stdout`, the decoded audio samples are written to the
+standard output (currently always as float32 PCM samples)
+
+### FFPlay
+With `--output ffplay`, the decoded audio samples are piped to `ffplay`
+in a child process. This option is only available if `ffplay` is a command that is available on the host.
+
+### File
+With `--output <filename>` or `--output file:<filename>`, the decoded audio
+samples are written to a file (currently always as float32 PCM)
+
+## `transmit`
+Broadcast an audio source as a transmitter.
+
+The `--input` and `--input-format` options specify what audio input
+source to transmit.
+The following inputs are supported:
+
+### Sound Device
+The `--input` argument is either `device`, to use the host's default sound
+device (typically a builtin microphone), or `device:<DEVICE_ID>` where
+`<DEVICE_ID>` is the integer ID of one of the available sound devices.
+When invoked with `--input "device:?"`, a list of available devices and their
+IDs is printed out.
+
+### Standard Input
+With `--input stdout`, the audio samples are read from the standard input.
+(currently always as int16 PCM).
+
+### File
+With `--input <filename>` or `--input file:<filename>`, the audio samples
+are read from a .wav or raw PCM file.
+
+Use the `--input-format <FORMAT>` option to specify the format of the audio
+samples in raw PCM files. `<FORMAT>` is expressed as:
+`<sample-type>,<sample-rate>,<channels>`
+(the only supported <sample-type> currently is 'int16le' for 16 bit signed integers with little-endian byte order)
+
+## `scan`
+Scan for public broadcasts.
+
+A live display of the available broadcasts is displayed continuously.
+
+# Compatibility With Some Products
+The `auracast` app has been tested for compatibility with a few products.
+The list is still very limited. Please let us know if there are products
+that are not working well, or if there are specific instructions that should
+be shared to allow better compatibiity with certain products.
+
+## Transmitters
+
+The `receive` command has been tested to successfully receive broadcasts from
+the following transmitters:
+
+  * JBL GO 4
+  * Flairmesh FlooGoo FMA120
+  * Eppfun AK3040Pro Max
+  * HIGHGAZE BA-25T
+  * Nexum Audio VOCE and USB dongle
+
+## Receivers
+
+### Pixel Buds Pro 2
+
+The Pixel Buds Pro 2 can be used as a broadcast receiver, controlled by the
+`auracast assist` command, instructing the buds to receive a broadcast.
+
+Use the `assist --command add-source` command to tell the buds to receive a
+broadcast.
+
+Use the `assist --command monitor-state` command to monitor the current sync/receive
+state of the buds.
+
+### JBL
+The JBL GO 4 and other JBL products that support the Auracast feature can be used
+as transmitters or receivers.
+
+When running in receiver mode (pressing the Auracast button while not already playing),
+the JBL speaker will scan for broadcast advertisements with a specific manufacturer data.
+Use the `--manufacturer-data` option of the `transmit` command in order to include data
+that will let the speaker recognize the broadcast as a compatible source.
+
+The manufacturer ID for JBL is 87.
+Using an option like `--manufacturer-data 87:00000000000000000000000000000000dffd` should work (tested on the
+JBL GO 4. The `dffd` value at the end of the payload may be different on other models?).
+
+
+### Others
+
+  * Nexum Audio VOCE and USB dongle
\ No newline at end of file
diff --git a/docs/mkdocs/src/apps_and_tools/bench.md b/docs/mkdocs/src/apps_and_tools/bench.md
index be68161..45c0a52 100644
--- a/docs/mkdocs/src/apps_and_tools/bench.md
+++ b/docs/mkdocs/src/apps_and_tools/bench.md
@@ -11,32 +11,44 @@ Usage: bumble-bench [OPTIONS] COMMAND [ARGS]...
 
 Options:
   --device-config FILENAME        Device configuration file
-  --role [sender|receiver|ping|pong]
+  --scenario [send|receive|ping|pong]
   --mode [gatt-client|gatt-server|l2cap-client|l2cap-server|rfcomm-client|rfcomm-server]
   --att-mtu MTU                   GATT MTU (gatt-client mode)  [23<=x<=517]
   --extended-data-length TEXT     Request a data length upon connection,
                                   specified as tx_octets/tx_time
-  --rfcomm-channel INTEGER        RFComm channel to use
+  --role-switch [central|peripheral]
+                                  Request role switch upon connection (central
+                                  or peripheral)
+  --rfcomm-channel INTEGER        RFComm channel to use (specify 0 for channel
+                                  discovery via SDP)
   --rfcomm-uuid TEXT              RFComm service UUID to use (ignored if
                                   --rfcomm-channel is not 0)
+  --rfcomm-l2cap-mtu INTEGER      RFComm L2CAP MTU
+  --rfcomm-max-frame-size INTEGER
+                                  RFComm maximum frame size
+  --rfcomm-initial-credits INTEGER
+                                  RFComm initial credits
+  --rfcomm-max-credits INTEGER    RFComm max credits
+  --rfcomm-credits-threshold INTEGER
+                                  RFComm credits threshold
   --l2cap-psm INTEGER             L2CAP PSM to use
   --l2cap-mtu INTEGER             L2CAP MTU to use
   --l2cap-mps INTEGER             L2CAP MPS to use
   --l2cap-max-credits INTEGER     L2CAP maximum number of credits allowed for
                                   the peer
-  -s, --packet-size SIZE          Packet size (client or ping role)
-                                  [8<=x<=4096]
-  -c, --packet-count COUNT        Packet count (client or ping role)
-  -sd, --start-delay SECONDS      Start delay (client or ping role)
-  --repeat N                      Repeat the run N times (client and ping
-                                  roles)(0, which is the fault, to run just
+  -s, --packet-size SIZE          Packet size (send or ping scenario)
+                                  [8<=x<=8192]
+  -c, --packet-count COUNT        Packet count (send or ping scenario)
+  -sd, --start-delay SECONDS      Start delay (send or ping scenario)
+  --repeat N                      Repeat the run N times (send and ping
+                                  scenario)(0, which is the fault, to run just
                                   once)
   --repeat-delay SECONDS          Delay, in seconds, between repeats
   --pace MILLISECONDS             Wait N milliseconds between packets (0,
                                   which is the fault, to send as fast as
                                   possible)
-  --linger                        Don't exit at the end of a run (server and
-                                  pong roles)
+  --linger                        Don't exit at the end of a run (receive and
+                                  pong scenarios)
   --help                          Show this message and exit.
 
 Commands:
@@ -71,19 +83,19 @@ using the ``--peripheral`` option. The address will be printed by the Peripheral
 it starts.
 
 Independently of whether the device is the Central or Peripheral, each device selects a
-``mode`` and and ``role`` to run as. The ``mode`` and ``role`` of the Central and Peripheral
+``mode`` and and ``scenario`` to run as. The ``mode`` and ``scenario`` of the Central and Peripheral
 must be compatible.
 
-Device 1 mode     | Device 2 mode
+Device 1 scenario | Device 2 scenario
 ------------------|------------------
 ``gatt-client``   | ``gatt-server``
 ``l2cap-client``  | ``l2cap-server``
 ``rfcomm-client`` | ``rfcomm-server``
 
-Device 1 role | Device 2 role
---------------|--------------
-``sender``    | ``receiver``
-``ping``      | ``pong``
+Device 1 scenario | Device 2 scenario
+------------------|--------------
+``send``          | ``receive``
+``ping``          | ``pong``
 
 
 # Examples
@@ -92,7 +104,7 @@ In the following examples, we have two USB Bluetooth controllers, one on `usb:0`
 the other on `usb:1`, and two consoles/terminals. We will run a command in each.
 
 !!! example "GATT Throughput"
-    Using the default mode and role for the Central and Peripheral.
+    Using the default mode and scenario for the Central and Peripheral.
 
     In the first console/terminal:
     ```
@@ -137,12 +149,12 @@ the other on `usb:1`, and two consoles/terminals. We will run a command in each.
 !!! example "Ping/Pong Latency"
     In the first console/terminal:
     ```
-    $ bumble-bench --role pong peripheral usb:0
+    $ bumble-bench --scenario pong peripheral usb:0
     ```
 
     In the second console/terminal:
     ```
-    $ bumble-bench --role ping central usb:1
+    $ bumble-bench --scenario ping central usb:1
     ```
 
 !!! example "Reversed modes with GATT and custom connection interval"
@@ -167,13 +179,13 @@ the other on `usb:1`, and two consoles/terminals. We will run a command in each.
     $ bumble-bench --mode l2cap-server central --phy 2m usb:1
     ```
 
-!!! example "Reversed roles with L2CAP"
+!!! example "Reversed scenarios with L2CAP"
     In the first console/terminal:
     ```
-    $ bumble-bench --mode l2cap-client --role sender peripheral usb:0
+    $ bumble-bench --mode l2cap-client --scenario send peripheral usb:0
     ```
 
     In the second console/terminal:
     ```
-    $ bumble-bench --mode l2cap-server --role receiver central usb:1
+    $ bumble-bench --mode l2cap-server --scenario receive central usb:1
     ```
diff --git a/docs/mkdocs/src/apps_and_tools/index.md b/docs/mkdocs/src/apps_and_tools/index.md
index 0c2b4d5..e99a018 100644
--- a/docs/mkdocs/src/apps_and_tools/index.md
+++ b/docs/mkdocs/src/apps_and_tools/index.md
@@ -4,12 +4,13 @@ APPS & TOOLS
 Included in the project are a few apps and tools, built on top of the core libraries.
 These include:
 
-  * [Console](console.md) - an interactive text-based console
-  * [Bench](bench.md) - Speed and Latency benchmarking between two devices (LE and Classic)
-  * [Pair](pair.md) - Pair/bond two devices (LE and Classic)
-  * [Unbond](unbond.md) - Remove a previously established bond
-  * [HCI Bridge](hci_bridge.md) - a HCI transport bridge to connect two HCI transports and filter/snoop the HCI packets
-  * [Golden Gate Bridge](gg_bridge.md) - a bridge between GATT and UDP to use with the Golden Gate "stack tool"
-  * [Show](show.md) - Parse a file with HCI packets and print the details of each packet in a human readable form
+  * [Auracast](auracast.md) - Commands to broadcast, receive and/or control LE Audio.
+  * [Console](console.md) - An interactive text-based console.
+  * [Bench](bench.md) - Speed and Latency benchmarking between two devices (LE and Classic).
+  * [Pair](pair.md) - Pair/bond two devices (LE and Classic).
+  * [Unbond](unbond.md) - Remove a previously established bond.
+  * [HCI Bridge](hci_bridge.md) - An HCI transport bridge to connect two HCI transports and filter/snoop the HCI packets.
+  * [Golden Gate Bridge](gg_bridge.md) - Bridge between GATT and UDP to use with the Golden Gate "stack tool".
+  * [Show](show.md) - Parse a file with HCI packets and print the details of each packet in a human readable form.
   * [Speaker](speaker.md) - Virtual Bluetooth speaker, with a command line and browser-based UI.
   * [Link Relay](link_relay.md) - WebSocket relay for virtual RemoteLink instances to communicate with each other.
diff --git a/docs/mkdocs/src/drivers/index.md b/docs/mkdocs/src/drivers/index.md
index aa5f0a1..e741126 100644
--- a/docs/mkdocs/src/drivers/index.md
+++ b/docs/mkdocs/src/drivers/index.md
@@ -16,4 +16,5 @@ USB vendor ID and product ID.
 
 Drivers included in the module are:
 
-  * [Realtek](realtek.md): Loading of Firmware and Config for Realtek USB dongles.
\ No newline at end of file
+  * [Realtek](realtek.md): Loading of Firmware and Config for Realtek USB dongles.
+  * [Intel](intel.md): Loading of Firmware and Config for Intel USB controllers.
\ No newline at end of file
diff --git a/docs/mkdocs/src/drivers/intel.md b/docs/mkdocs/src/drivers/intel.md
new file mode 100644
index 0000000..372b6c5
--- /dev/null
+++ b/docs/mkdocs/src/drivers/intel.md
@@ -0,0 +1,73 @@
+INTEL DRIVER
+==============
+
+This driver supports loading firmware images and optional config data to
+Intel USB controllers.
+A number of USB dongles are supported, but likely not all.
+The initial implementation has been tested on BE200 and AX210 controllers.
+When using a USB controller, the USB product ID and vendor ID are used
+to find whether a matching set of firmware image and config data
+is needed for that specific model. If a match exists, the driver will try
+load the firmware image and, if needed, config data.
+Alternatively, the metadata property ``driver=intel`` may be specified in a transport
+name to force that driver to be used (ex: ``usb:[driver=intel]0`` instead of just
+``usb:0`` for the first USB device).
+The driver will look for the firmware and config files by name, in order, in:
+
+  * The directory specified by the environment variable `BUMBLE_INTEL_FIRMWARE_DIR`
+    if set.
+  * The directory `<package-dir>/drivers/intel_fw` where `<package-dir>` is the directory
+    where the `bumble` package is installed.
+  * The current directory.
+
+It is also possible to override or extend the config data with parameters passed via the
+transport name. The driver name `intel` may be suffixed with `/<param:value>[+<param:value>]...`
+The supported params are:
+  * `ddc_addon`: configuration data to add to the data loaded from the config data file
+  * `ddc_override`: configuration data to use instead of the data loaded from the config data file.
+
+With both `dcc_addon` and `dcc_override`, the param value is a hex-encoded byte array containing
+the config data (same format as the config file).
+Example transport name:
+`usb:[driver=intel/dcc_addon:03E40200]0`
+
+
+Obtaining Firmware Images and Config Data
+-----------------------------------------
+
+Firmware images and config data may be obtained from a variety of online
+sources.
+To facilitate finding a downloading the, the utility program `bumble-intel-fw-download`
+may be used.
+
+```
+Usage: bumble-intel-fw-download [OPTIONS]
+
+  Download Intel firmware images and configs.
+
+Options:
+  --output-dir TEXT        Output directory where the files will be saved.
+                           Defaults to the OS-specific app data dir, which the
+                           driver will check when trying to find firmware
+  --source [linux-kernel]  [default: linux-kernel]
+  --single TEXT            Only download a single image set, by its base name
+  --force                  Overwrite files if they already exist
+  --help                   Show this message and exit.
+```
+
+Utility
+-------
+
+The `bumble-intel-util` utility may be used to interact with an Intel USB controller.
+
+```
+Usage: bumble-intel-util [OPTIONS] COMMAND [ARGS]...
+
+Options:
+  --help  Show this message and exit.
+
+Commands:
+  bootloader  Reboot in bootloader mode.
+  info        Get the firmware info.
+  load        Load a firmware image.
+```
\ No newline at end of file
diff --git a/docs/mkdocs/src/getting_started.md b/docs/mkdocs/src/getting_started.md
index b2063d1..9570849 100644
--- a/docs/mkdocs/src/getting_started.md
+++ b/docs/mkdocs/src/getting_started.md
@@ -3,17 +3,15 @@ GETTING STARTED WITH BUMBLE
 
 # Prerequisites
 
-You need Python 3.8 or above. Python >= 3.9 is recommended, but 3.8 should be sufficient if
-necessary (there may be some optional functionality that will not work on some platforms with
-python 3.8).
+You need Python 3.9 or above.
 Visit the [Python site](https://www.python.org/) for instructions on how to install Python
 for your platform.
 Throughout the documentation, when shell commands are shown, it is assumed that you can
 invoke Python as
 ```
-$ python
+$ python3
 ```
-If invoking python is different on your platform (it may be `python3` for example, or just `py` or `py.exe`),
+If invoking python is different on your platform (it may be `python` for example, or just `py` or `py.exe`),
 adjust accordingly.
 
 You may be simply using Bumble as a module for your own application or as a dependency to your own
@@ -32,12 +30,18 @@ manager, or from source.
     python environment, or in a virtual environment, such as a `venv`, `pyenv` or `conda` environment.
     See the [Python Environments page](development/python_environments.md) page for details.
 
+### Install from PyPI
+
+```
+$ python3 -m pip install bumble
+```
+
 ### Install From Source
 
 Install with `pip`. Run in a command shell in the directory where you downloaded the source
 distribution
 ```
-$ python -m pip install -e .
+$ python3 -m pip install -e .
 ```
 
 ### Install from GitHub
@@ -46,21 +50,21 @@ You can install directly from GitHub without first downloading the repo.
 
 Install the latest commit from the main branch with `pip`:
 ```
-$ python -m pip install git+https://github.com/google/bumble.git
+$ python3 -m pip install git+https://github.com/google/bumble.git
 ```
 
 You can specify a specific tag.
 
 Install tag `v0.0.1` with `pip`:
 ```
-$ python -m pip install git+https://github.com/google/bumble.git@v0.0.1
+$ python3 -m pip install git+https://github.com/google/bumble.git@v0.0.1
 ```
 
 You can also specify a specific commit.
 
 Install commit `27c0551` with `pip`:
 ```
-$ python -m pip install git+https://github.com/google/bumble.git@27c0551
+$ python3 -m pip install git+https://github.com/google/bumble.git@27c0551
 ```
 
 # Working On The Bumble Code
@@ -80,21 +84,21 @@ directory of the project.
 
 ```bash
 $ export PYTHONPATH=.
-$ python apps/console.py serial:/dev/tty.usbmodem0006839912171
+$ python3 apps/console.py serial:/dev/tty.usbmodem0006839912171
 ```
 
 or running an example, with the working directory set to the `examples` subdirectory
 ```bash
 $ cd examples
 $ export PYTHONPATH=..
-$ python run_scanner.py usb:0
+$ python3 run_scanner.py usb:0
 ```
 
 Or course, `export PYTHONPATH` only needs to be invoked once, not before each app/script execution.
 
 Setting `PYTHONPATH` locally with each command would look something like:
 ```
-$ PYTHONPATH=. python examples/run_advertiser.py examples/device1.json serial:/dev/tty.usbmodem0006839912171
+$ PYTHONPATH=. python3 examples/run_advertiser.py examples/device1.json serial:/dev/tty.usbmodem0006839912171
 ```
 
 # Where To Go Next
diff --git a/docs/mkdocs/src/index.md b/docs/mkdocs/src/index.md
index aae6e54..8c057c8 100644
--- a/docs/mkdocs/src/index.md
+++ b/docs/mkdocs/src/index.md
@@ -31,7 +31,7 @@ Some of the configurations that may be useful:
 
 See the [use cases page](use_cases/index.md) for more use cases.
 
-The project is implemented in Python (Python >= 3.8 is required). A number of APIs for functionality that is inherently I/O bound is implemented in terms of python coroutines with async IO. This means that all of the concurrent tasks run in the same thread, which makes everything much simpler and more predictable.
+The project is implemented in Python (Python >= 3.9 is required). A number of APIs for functionality that is inherently I/O bound is implemented in terms of python coroutines with async IO. This means that all of the concurrent tasks run in the same thread, which makes everything much simpler and more predictable.
 
 ![layers](images/bumble_layers.svg)
 
diff --git a/docs/mkdocs/src/platforms/android.md b/docs/mkdocs/src/platforms/android.md
index 4b08d88..fda3356 100644
--- a/docs/mkdocs/src/platforms/android.md
+++ b/docs/mkdocs/src/platforms/android.md
@@ -35,11 +35,11 @@ the command line.
     visit [this Android Studio user guide page](https://developer.android.com/studio/run/emulator-commandline)
 
 The `-packet-streamer-endpoint <endpoint>` command line option may be used to enable
-Bluetooth emulation and tell the emulator which virtual controller to connect to. 
+Bluetooth emulation and tell the emulator which virtual controller to connect to.
 
 ## Connecting to Netsim
 
-If the emulator doesn't have Bluetooth emulation enabled by default, use the 
+If the emulator doesn't have Bluetooth emulation enabled by default, use the
 `-packet-streamer-endpoint default` option to tell it to connect to Netsim.
 If Netsim is not running, the emulator will start it automatically.
 
@@ -60,17 +60,17 @@ the Bumble `android-netsim` transport in `host` mode (the default).
 
 !!! example "Run the example GATT server connected to the emulator via Netsim"
     ``` shell
-    $ python run_gatt_server.py device1.json android-netsim
+    $ python3 run_gatt_server.py device1.json android-netsim
     ```
 
 By default, the Bumble `android-netsim` transport will try to automatically discover
 the port number on which the netsim process is exposing its gRPC server interface. If
-that discovery process fails, or if you want to specify the interface manually, you 
+that discovery process fails, or if you want to specify the interface manually, you
 can pass a `hostname` and `port` as parameters to the transport, as: `android-netsim:<host>:<port>`.
 
 !!! example "Run the example GATT server connected to the emulator via Netsim on a localhost, port 8877"
     ``` shell
-    $ python run_gatt_server.py device1.json android-netsim:localhost:8877
+    $ python3 run_gatt_server.py device1.json android-netsim:localhost:8877
     ```
 
 ### Multiple Instances
@@ -84,7 +84,7 @@ For example: `android-netsim:localhost:8877,name=bumble1`
 This is an advanced use case, which may not be officially supported, but should work in recent
 versions of the emulator.
 
-The first step is to run the Bumble HCI bridge, specifying netsim as the "host" end of the 
+The first step is to run the Bumble HCI bridge, specifying netsim as the "host" end of the
 bridge, and another controller (typically a USB Bluetooth dongle, but any other supported
 transport can work as well) as the "controller" end of the bridge.
 
diff --git a/docs/mkdocs/src/platforms/index.md b/docs/mkdocs/src/platforms/index.md
index 858785f..9bf7c29 100644
--- a/docs/mkdocs/src/platforms/index.md
+++ b/docs/mkdocs/src/platforms/index.md
@@ -1,7 +1,7 @@
 PLATFORMS
 =========
 
-Most of the code included in the project should run on any platform that supports Python >= 3.8. Not all features are supported on all platforms (for example, USB dongle support is only available on platforms where the python USB library is functional).
+Most of the code included in the project should run on any platform that supports Python >= 3.9. Not all features are supported on all platforms (for example, USB dongle support is only available on platforms where the python USB library is functional).
 
 For platform-specific information, see the following pages:
 
diff --git a/environment.yml b/environment.yml
index 2e927cb..bb65722 100644
--- a/environment.yml
+++ b/environment.yml
@@ -4,6 +4,6 @@ channels:
   - conda-forge
 dependencies:
   - pip=23
-  - python=3.8
+  - python=3.9
   - pip:
     - --editable .[development,documentation,test]
diff --git a/examples/cs_initiator.json b/examples/cs_initiator.json
new file mode 100644
index 0000000..82adc09
--- /dev/null
+++ b/examples/cs_initiator.json
@@ -0,0 +1,9 @@
+{
+    "name": "Bumble CS Initiator",
+    "address": "F0:F1:F2:F3:F4:F5",
+    "advertising_interval": 100,
+    "keystore": "JsonKeyStore",
+    "irk": "865F81FF5A8B486EAAE29A27AD9F77DC",
+    "identity_address_type": 1,
+    "channel_sounding_enabled": true
+}
diff --git a/examples/cs_reflector.json b/examples/cs_reflector.json
new file mode 100644
index 0000000..d76edb6
--- /dev/null
+++ b/examples/cs_reflector.json
@@ -0,0 +1,9 @@
+{
+    "name": "Bumble CS Reflector",
+    "address": "F0:F1:F2:F3:F4:F6",
+    "advertising_interval": 100,
+    "keystore": "JsonKeyStore",
+    "irk": "0c7d74db03a1c98e7be691f76141d53d",
+    "identity_address_type": 1,
+    "channel_sounding_enabled": true
+}
diff --git a/examples/heart_rate_server.py b/examples/heart_rate_server.py
index e40d5db..3ccf192 100644
--- a/examples/heart_rate_server.py
+++ b/examples/heart_rate_server.py
@@ -102,7 +102,6 @@ async def main() -> None:
         )
 
         # Notify subscribers of the current value as soon as they subscribe
-        @heart_rate_service.heart_rate_measurement_characteristic.on('subscription')
         def on_subscription(connection, notify_enabled, indicate_enabled):
             if notify_enabled or indicate_enabled:
                 AsyncRunner.spawn(
@@ -112,6 +111,10 @@ async def main() -> None:
                     )
                 )
 
+        heart_rate_service.heart_rate_measurement_characteristic.on(
+            'subscription', on_subscription
+        )
+
         # Go!
         await device.power_on()
         await device.start_advertising(auto_restart=True)
diff --git a/examples/keyboard.py b/examples/keyboard.py
index f2afe18..52a4c78 100644
--- a/examples/keyboard.py
+++ b/examples/keyboard.py
@@ -282,7 +282,7 @@ async def keyboard_device(device, command):
                         GATT_MANUFACTURER_NAME_STRING_CHARACTERISTIC,
                         Characteristic.Properties.READ,
                         Characteristic.READABLE,
-                        'Bumble',
+                        bytes('Bumble', 'utf-8'),
                     )
                 ],
             ),
diff --git a/examples/mobly/bench/one_device_bench_test.py b/examples/mobly/bench/one_device_bench_test.py
new file mode 100644
index 0000000..c715885
--- /dev/null
+++ b/examples/mobly/bench/one_device_bench_test.py
@@ -0,0 +1,69 @@
+from mobly import base_test
+from mobly import test_runner
+from mobly.controllers import android_device
+
+
+class OneDeviceBenchTest(base_test.BaseTestClass):
+
+    def setup_class(self):
+        self.ads = self.register_controller(android_device)
+        self.dut = self.ads[0]
+        self.dut.load_snippet("bench", "com.github.google.bumble.btbench")
+
+    def test_rfcomm_client_ping(self):
+        runner = self.dut.bench.runRfcommClient(
+            "ping", "DC:E5:5B:E5:51:2C", 100, 970, 100
+        )
+        print("### Initial status:", runner)
+        final_status = self.dut.bench.waitForRunnerCompletion(runner["id"])
+        print("### Final status:", final_status)
+
+    def test_rfcomm_client_send(self):
+        runner = self.dut.bench.runRfcommClient(
+            "send", "DC:E5:5B:E5:51:2C", 100, 970, 0
+        )
+        print("### Initial status:", runner)
+        final_status = self.dut.bench.waitForRunnerCompletion(runner["id"])
+        print("### Final status:", final_status)
+
+    def test_l2cap_client_ping(self):
+        runner = self.dut.bench.runL2capClient(
+            "ping", "4B:2A:67:76:2B:E3", 128, True, 100, 970, 100, "HIGH"
+        )
+        print("### Initial status:", runner)
+        final_status = self.dut.bench.waitForRunnerCompletion(runner["id"])
+        print("### Final status:", final_status)
+
+    def test_l2cap_client_send(self):
+        runner = self.dut.bench.runL2capClient(
+            "send",
+            "F1:F1:F1:F1:F1:F1",
+            128,
+            True,
+            100,
+            970,
+            0,
+            "HIGH",
+            10000,
+        )
+        print("### Initial status:", runner)
+        final_status = self.dut.bench.waitForRunnerCompletion(runner["id"])
+        print("### Final status:", final_status)
+
+    def test_gatt_client_send(self):
+        runner = self.dut.bench.runGattClient(
+            "send", "F1:F1:F1:F1:F1:F1", 128, True, 100, 970, 100, "HIGH"
+        )
+        print("### Initial status:", runner)
+        final_status = self.dut.bench.waitForRunnerCompletion(runner["id"])
+        print("### Final status:", final_status)
+
+    def test_gatt_server_receive(self):
+        runner = self.dut.bench.runGattServer("receive")
+        print("### Initial status:", runner)
+        final_status = self.dut.bench.waitForRunnerCompletion(runner["id"])
+        print("### Final status:", final_status)
+
+
+if __name__ == "__main__":
+    test_runner.main()
diff --git a/examples/mobly/bench/sample_config.yml b/examples/mobly/bench/sample_config.yml
new file mode 100644
index 0000000..50823a4
--- /dev/null
+++ b/examples/mobly/bench/sample_config.yml
@@ -0,0 +1,9 @@
+TestBeds:
+  - Name: BenchTestBed
+    Controllers:
+        AndroidDevice:
+          - serial: emulator-5554
+            local_bt_address: 94:45:60:5E:03:B0
+
+          #- serial: 23071FDEE001F7
+          #  local_bt_address: DC:E5:5B:E5:51:2C
diff --git a/examples/mobly/bench/two_devices_bench_test.py b/examples/mobly/bench/two_devices_bench_test.py
new file mode 100644
index 0000000..4a47263
--- /dev/null
+++ b/examples/mobly/bench/two_devices_bench_test.py
@@ -0,0 +1,38 @@
+import time
+
+from mobly import base_test
+from mobly import test_runner
+from mobly.controllers import android_device
+
+
+class TwoDevicesBenchTest(base_test.BaseTestClass):
+    def setup_class(self):
+        self.ads = self.register_controller(android_device)
+        self.dut1 = self.ads[0]
+        self.dut1.load_snippet("bench", "com.github.google.bumble.btbench")
+        self.dut2 = self.ads[1]
+        self.dut2.load_snippet("bench", "com.github.google.bumble.btbench")
+
+    def test_rfcomm_client_send_receive(self):
+        print("### Starting Receiver")
+        receiver = self.dut2.bench.runRfcommServer("receive")
+        receiver_id = receiver["id"]
+        print("--- Receiver status:", receiver)
+        while not receiver["model"]["running"]:
+            print("--- Waiting for Receiver to be running...")
+            time.sleep(1)
+            receiver = self.dut2.bench.getRunner(receiver_id)
+
+        print("### Starting Sender")
+        sender = self.dut1.bench.runRfcommClient(
+            "send", "DC:E5:5B:E5:51:2C", 100, 970, 100
+        )
+        print("--- Sender status:", sender)
+
+        print("--- Waiting for Sender to complete...")
+        sender_result = self.dut1.bench.waitForRunnerCompletion(sender["id"])
+        print("--- Sender result:", sender_result)
+
+
+if __name__ == "__main__":
+    test_runner.main()
diff --git a/examples/run_a2dp_info.py b/examples/run_a2dp_info.py
index e05c87e..ff8ded8 100644
--- a/examples/run_a2dp_info.py
+++ b/examples/run_a2dp_info.py
@@ -24,7 +24,7 @@ from bumble.colors import color
 from bumble.device import Device
 from bumble.transport import open_transport_or_link
 from bumble.core import (
-    BT_BR_EDR_TRANSPORT,
+    PhysicalTransport,
     BT_AVDTP_PROTOCOL_ID,
     BT_AUDIO_SINK_SERVICE,
     BT_L2CAP_PROTOCOL_ID,
@@ -165,7 +165,9 @@ async def main() -> None:
         # Connect to a peer
         target_address = sys.argv[3]
         print(f'=== Connecting to {target_address}...')
-        connection = await device.connect(target_address, transport=BT_BR_EDR_TRANSPORT)
+        connection = await device.connect(
+            target_address, transport=PhysicalTransport.BR_EDR
+        )
         print(f'=== Connected to {connection.peer_address}!')
 
         # Request authentication
diff --git a/examples/run_a2dp_sink.py b/examples/run_a2dp_sink.py
index ca1af84..f5d337c 100644
--- a/examples/run_a2dp_sink.py
+++ b/examples/run_a2dp_sink.py
@@ -23,7 +23,7 @@ from typing import Any, Dict
 
 from bumble.device import Device
 from bumble.transport import open_transport_or_link
-from bumble.core import BT_BR_EDR_TRANSPORT
+from bumble.core import PhysicalTransport
 from bumble.avdtp import (
     AVDTP_AUDIO_MEDIA_TYPE,
     Protocol,
@@ -33,12 +33,6 @@ from bumble.avdtp import (
 from bumble.a2dp import (
     make_audio_sink_service_sdp_records,
     A2DP_SBC_CODEC_TYPE,
-    SBC_MONO_CHANNEL_MODE,
-    SBC_DUAL_CHANNEL_MODE,
-    SBC_SNR_ALLOCATION_METHOD,
-    SBC_LOUDNESS_ALLOCATION_METHOD,
-    SBC_STEREO_CHANNEL_MODE,
-    SBC_JOINT_STEREO_CHANNEL_MODE,
     SbcMediaCodecInformation,
 )
 
@@ -61,20 +55,23 @@ def codec_capabilities():
     return MediaCodecCapabilities(
         media_type=AVDTP_AUDIO_MEDIA_TYPE,
         media_codec_type=A2DP_SBC_CODEC_TYPE,
-        media_codec_information=SbcMediaCodecInformation.from_lists(
-            sampling_frequencies=[48000, 44100, 32000, 16000],
-            channel_modes=[
-                SBC_MONO_CHANNEL_MODE,
-                SBC_DUAL_CHANNEL_MODE,
-                SBC_STEREO_CHANNEL_MODE,
-                SBC_JOINT_STEREO_CHANNEL_MODE,
-            ],
-            block_lengths=[4, 8, 12, 16],
-            subbands=[4, 8],
-            allocation_methods=[
-                SBC_LOUDNESS_ALLOCATION_METHOD,
-                SBC_SNR_ALLOCATION_METHOD,
-            ],
+        media_codec_information=SbcMediaCodecInformation(
+            sampling_frequency=SbcMediaCodecInformation.SamplingFrequency.SF_48000
+            | SbcMediaCodecInformation.SamplingFrequency.SF_44100
+            | SbcMediaCodecInformation.SamplingFrequency.SF_32000
+            | SbcMediaCodecInformation.SamplingFrequency.SF_16000,
+            channel_mode=SbcMediaCodecInformation.ChannelMode.MONO
+            | SbcMediaCodecInformation.ChannelMode.DUAL_CHANNEL
+            | SbcMediaCodecInformation.ChannelMode.STEREO
+            | SbcMediaCodecInformation.ChannelMode.JOINT_STEREO,
+            block_length=SbcMediaCodecInformation.BlockLength.BL_4
+            | SbcMediaCodecInformation.BlockLength.BL_8
+            | SbcMediaCodecInformation.BlockLength.BL_12
+            | SbcMediaCodecInformation.BlockLength.BL_16,
+            subbands=SbcMediaCodecInformation.Subbands.S_4
+            | SbcMediaCodecInformation.Subbands.S_8,
+            allocation_method=SbcMediaCodecInformation.AllocationMethod.LOUDNESS
+            | SbcMediaCodecInformation.AllocationMethod.SNR,
             minimum_bitpool_value=2,
             maximum_bitpool_value=53,
         ),
@@ -142,7 +139,7 @@ async def main() -> None:
                 target_address = sys.argv[4]
                 print(f'=== Connecting to {target_address}...')
                 connection = await device.connect(
-                    target_address, transport=BT_BR_EDR_TRANSPORT
+                    target_address, transport=PhysicalTransport.BR_EDR
                 )
                 print(f'=== Connected to {connection.peer_address}!')
 
diff --git a/examples/run_a2dp_source.py b/examples/run_a2dp_source.py
index a1f955b..ba4e24e 100644
--- a/examples/run_a2dp_source.py
+++ b/examples/run_a2dp_source.py
@@ -23,7 +23,7 @@ import logging
 from bumble.colors import color
 from bumble.device import Device
 from bumble.transport import open_transport_or_link
-from bumble.core import BT_BR_EDR_TRANSPORT
+from bumble.core import PhysicalTransport
 from bumble.avdtp import (
     find_avdtp_service_with_connection,
     AVDTP_AUDIO_MEDIA_TYPE,
@@ -33,8 +33,6 @@ from bumble.avdtp import (
     Listener,
 )
 from bumble.a2dp import (
-    SBC_JOINT_STEREO_CHANNEL_MODE,
-    SBC_LOUDNESS_ALLOCATION_METHOD,
     make_audio_source_service_sdp_records,
     A2DP_SBC_CODEC_TYPE,
     SbcMediaCodecInformation,
@@ -59,12 +57,12 @@ def codec_capabilities():
     return MediaCodecCapabilities(
         media_type=AVDTP_AUDIO_MEDIA_TYPE,
         media_codec_type=A2DP_SBC_CODEC_TYPE,
-        media_codec_information=SbcMediaCodecInformation.from_discrete_values(
-            sampling_frequency=44100,
-            channel_mode=SBC_JOINT_STEREO_CHANNEL_MODE,
-            block_length=16,
-            subbands=8,
-            allocation_method=SBC_LOUDNESS_ALLOCATION_METHOD,
+        media_codec_information=SbcMediaCodecInformation(
+            sampling_frequency=SbcMediaCodecInformation.SamplingFrequency.SF_44100,
+            channel_mode=SbcMediaCodecInformation.ChannelMode.JOINT_STEREO,
+            block_length=SbcMediaCodecInformation.BlockLength.BL_16,
+            subbands=SbcMediaCodecInformation.Subbands.S_8,
+            allocation_method=SbcMediaCodecInformation.AllocationMethod.LOUDNESS,
             minimum_bitpool_value=2,
             maximum_bitpool_value=53,
         ),
@@ -73,11 +71,9 @@ def codec_capabilities():
 
 # -----------------------------------------------------------------------------
 def on_avdtp_connection(read_function, protocol):
-    packet_source = SbcPacketSource(
-        read_function, protocol.l2cap_channel.peer_mtu, codec_capabilities()
-    )
+    packet_source = SbcPacketSource(read_function, protocol.l2cap_channel.peer_mtu)
     packet_pump = MediaPacketPump(packet_source.packets)
-    protocol.add_source(packet_source.codec_capabilities, packet_pump)
+    protocol.add_source(codec_capabilities(), packet_pump)
 
 
 # -----------------------------------------------------------------------------
@@ -97,11 +93,9 @@ async def stream_packets(read_function, protocol):
     print(f'### Selected sink: {sink.seid}')
 
     # Stream the packets
-    packet_source = SbcPacketSource(
-        read_function, protocol.l2cap_channel.peer_mtu, codec_capabilities()
-    )
+    packet_source = SbcPacketSource(read_function, protocol.l2cap_channel.peer_mtu)
     packet_pump = MediaPacketPump(packet_source.packets)
-    source = protocol.add_source(packet_source.codec_capabilities, packet_pump)
+    source = protocol.add_source(codec_capabilities(), packet_pump)
     stream = await protocol.create_stream(source, sink)
     await stream.start()
     await asyncio.sleep(5)
@@ -152,7 +146,7 @@ async def main() -> None:
                 target_address = sys.argv[4]
                 print(f'=== Connecting to {target_address}...')
                 connection = await device.connect(
-                    target_address, transport=BT_BR_EDR_TRANSPORT
+                    target_address, transport=PhysicalTransport.BR_EDR
                 )
                 print(f'=== Connected to {connection.peer_address}!')
 
diff --git a/examples/run_ancs_client.py b/examples/run_ancs_client.py
new file mode 100644
index 0000000..e6ec108
--- /dev/null
+++ b/examples/run_ancs_client.py
@@ -0,0 +1,215 @@
+# Copyright 2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
+import asyncio
+import sys
+import os
+import logging
+from bumble.colors import color
+
+from bumble.device import Device, Peer
+from bumble.transport import open_transport
+from bumble.profiles.ancs import (
+    AncsClient,
+    AppAttribute,
+    AppAttributeId,
+    EventFlags,
+    EventId,
+    Notification,
+    NotificationAttributeId,
+)
+
+
+# -----------------------------------------------------------------------------
+_cached_app_names: dict[str, str] = {}
+_notification_queue = asyncio.Queue[Notification]()
+
+
+async def process_notifications(ancs_client: AncsClient):
+    while True:
+        notification = await _notification_queue.get()
+
+        prefix = " "
+        if notification.event_id == EventId.NOTIFICATION_ADDED:
+            print_color = "green"
+            if notification.event_flags & EventFlags.PRE_EXISTING:
+                prefix = " Existing "
+            else:
+                prefix = " New "
+        elif notification.event_id == EventId.NOTIFICATION_REMOVED:
+            print_color = "red"
+        elif notification.event_id == EventId.NOTIFICATION_MODIFIED:
+            print_color = "yellow"
+        else:
+            print_color = "white"
+
+        print(
+            color(
+                (
+                    f"[{notification.event_id.name}]{prefix}Notification "
+                    f"({notification.notification_uid}):"
+                ),
+                print_color,
+            )
+        )
+        print(color("  Event ID:      ", "yellow"), notification.event_id.name)
+        print(color("  Event Flags:   ", "yellow"), notification.event_flags.name)
+        print(color("  Category ID:   ", "yellow"), notification.category_id.name)
+        print(color("  Category Count:", "yellow"), notification.category_count)
+
+        if notification.event_id not in (
+            EventId.NOTIFICATION_ADDED,
+            EventId.NOTIFICATION_MODIFIED,
+        ):
+            continue
+
+        requested_attributes = [
+            NotificationAttributeId.APP_IDENTIFIER,
+            NotificationAttributeId.TITLE,
+            NotificationAttributeId.SUBTITLE,
+            NotificationAttributeId.MESSAGE,
+            NotificationAttributeId.DATE,
+        ]
+        if notification.event_flags & EventFlags.NEGATIVE_ACTION:
+            requested_attributes.append(NotificationAttributeId.NEGATIVE_ACTION_LABEL)
+        if notification.event_flags & EventFlags.POSITIVE_ACTION:
+            requested_attributes.append(NotificationAttributeId.POSITIVE_ACTION_LABEL)
+
+        attributes = await ancs_client.get_notification_attributes(
+            notification.notification_uid, requested_attributes
+        )
+        max_attribute_name_width = max(
+            (len(attribute.attribute_id.name) for attribute in attributes)
+        )
+        app_identifier = str(
+            next(
+                (
+                    attribute.value
+                    for attribute in attributes
+                    if attribute.attribute_id == NotificationAttributeId.APP_IDENTIFIER
+                )
+            )
+        )
+        if app_identifier not in _cached_app_names:
+            app_attributes = await ancs_client.get_app_attributes(
+                app_identifier, [AppAttributeId.DISPLAY_NAME]
+            )
+            _cached_app_names[app_identifier] = app_attributes[0].value
+        app_name = _cached_app_names[app_identifier]
+
+        for attribute in attributes:
+            padding = ' ' * (
+                max_attribute_name_width - len(attribute.attribute_id.name)
+            )
+            suffix = (
+                f" ({app_name})"
+                if attribute.attribute_id == NotificationAttributeId.APP_IDENTIFIER
+                else ""
+            )
+            print(
+                color(f"  {attribute.attribute_id.name}:{padding}", "blue"),
+                f"{attribute.value}{suffix}",
+            )
+
+        print()
+
+
+def on_ancs_notification(notification: Notification) -> None:
+    _notification_queue.put_nowait(notification)
+
+
+async def handle_command_client(
+    ancs_client: AncsClient, reader: asyncio.StreamReader, writer: asyncio.StreamWriter
+) -> None:
+    while True:
+        command = (await reader.readline()).decode("utf-8").strip()
+
+        try:
+            command_name, command_args = command.split(" ", 1)
+            if command_name == "+":
+                notification_uid = int(command_args)
+                await ancs_client.perform_positive_action(notification_uid)
+            elif command_name == "-":
+                notification_uid = int(command_args)
+                await ancs_client.perform_negative_action(notification_uid)
+            else:
+                writer.write(f"unknown command {command_name}".encode("utf-8"))
+        except Exception as error:
+            writer.write(f"ERROR: {error}\n".encode("utf-8"))
+
+
+# -----------------------------------------------------------------------------
+async def main() -> None:
+    if len(sys.argv) < 3:
+        print(
+            'Usage: run_ancs_client.py <device-config> <transport-spec> '
+            '<bluetooth-address> <mtu>'
+        )
+        print('example: run_ancs_client.py device1.json usb:0 E1:CA:72:48:C4:E8 512')
+        return
+    device_config, transport_spec, bluetooth_address, mtu = sys.argv[1:]
+
+    print('<<< connecting to HCI...')
+    async with await open_transport(transport_spec) as hci_transport:
+        print('<<< connected')
+
+        # Create a device to manage the host, with a custom listener
+        device = Device.from_config_file_with_hci(
+            device_config, hci_transport.source, hci_transport.sink
+        )
+        await device.power_on()
+
+        # Connect to the peer
+        print(f'=== Connecting to {bluetooth_address}...')
+        connection = await device.connect(bluetooth_address)
+        print(f'=== Connected: {connection}')
+
+        await connection.encrypt()
+
+        peer = Peer(connection)
+        mtu_int = int(mtu)
+        if mtu_int:
+            new_mtu = await peer.request_mtu(mtu_int)
+            print(f'ATT MTU = {new_mtu}')
+        ancs_client = await AncsClient.for_peer(peer)
+        if ancs_client is None:
+            print("!!! no ANCS service found")
+            return
+        await ancs_client.start()
+
+        print('Subscribing to updates')
+        ancs_client.on("notification", on_ancs_notification)
+
+        # Process all notifications in a task.
+        notification_processing_task = asyncio.create_task(
+            process_notifications(ancs_client)
+        )
+
+        # Accept a TCP connection to handle commands.
+        tcp_server = await asyncio.start_server(
+            lambda reader, writer: handle_command_client(ancs_client, reader, writer),
+            '127.0.0.1',
+            9000,
+        )
+        print("Accepting command client on port 9000")
+        async with tcp_server:
+            await tcp_server.serve_forever()
+
+
+# -----------------------------------------------------------------------------
+logging.basicConfig(level=os.environ.get('BUMBLE_LOGLEVEL', 'INFO').upper())
+asyncio.run(main())
diff --git a/examples/run_avrcp.py b/examples/run_avrcp.py
index 793e000..eb31b0f 100644
--- a/examples/run_avrcp.py
+++ b/examples/run_avrcp.py
@@ -25,7 +25,7 @@ import websockets
 
 from bumble.device import Device
 from bumble.transport import open_transport_or_link
-from bumble.core import BT_BR_EDR_TRANSPORT
+from bumble.core import PhysicalTransport
 from bumble import avc
 from bumble import avrcp
 from bumble import avdtp
@@ -60,20 +60,23 @@ def codec_capabilities():
     return avdtp.MediaCodecCapabilities(
         media_type=avdtp.AVDTP_AUDIO_MEDIA_TYPE,
         media_codec_type=a2dp.A2DP_SBC_CODEC_TYPE,
-        media_codec_information=a2dp.SbcMediaCodecInformation.from_lists(
-            sampling_frequencies=[48000, 44100, 32000, 16000],
-            channel_modes=[
-                a2dp.SBC_MONO_CHANNEL_MODE,
-                a2dp.SBC_DUAL_CHANNEL_MODE,
-                a2dp.SBC_STEREO_CHANNEL_MODE,
-                a2dp.SBC_JOINT_STEREO_CHANNEL_MODE,
-            ],
-            block_lengths=[4, 8, 12, 16],
-            subbands=[4, 8],
-            allocation_methods=[
-                a2dp.SBC_LOUDNESS_ALLOCATION_METHOD,
-                a2dp.SBC_SNR_ALLOCATION_METHOD,
-            ],
+        media_codec_information=a2dp.SbcMediaCodecInformation(
+            sampling_frequency=a2dp.SbcMediaCodecInformation.SamplingFrequency.SF_48000
+            | a2dp.SbcMediaCodecInformation.SamplingFrequency.SF_44100
+            | a2dp.SbcMediaCodecInformation.SamplingFrequency.SF_32000
+            | a2dp.SbcMediaCodecInformation.SamplingFrequency.SF_16000,
+            channel_mode=a2dp.SbcMediaCodecInformation.ChannelMode.MONO
+            | a2dp.SbcMediaCodecInformation.ChannelMode.DUAL_CHANNEL
+            | a2dp.SbcMediaCodecInformation.ChannelMode.STEREO
+            | a2dp.SbcMediaCodecInformation.ChannelMode.JOINT_STEREO,
+            block_length=a2dp.SbcMediaCodecInformation.BlockLength.BL_4
+            | a2dp.SbcMediaCodecInformation.BlockLength.BL_8
+            | a2dp.SbcMediaCodecInformation.BlockLength.BL_12
+            | a2dp.SbcMediaCodecInformation.BlockLength.BL_16,
+            subbands=a2dp.SbcMediaCodecInformation.Subbands.S_4
+            | a2dp.SbcMediaCodecInformation.Subbands.S_8,
+            allocation_method=a2dp.SbcMediaCodecInformation.AllocationMethod.LOUDNESS
+            | a2dp.SbcMediaCodecInformation.AllocationMethod.SNR,
             minimum_bitpool_value=2,
             maximum_bitpool_value=53,
         ),
@@ -376,7 +379,7 @@ async def main() -> None:
             target_address = sys.argv[4]
             print(f'=== Connecting to {target_address}...')
             connection = await device.connect(
-                target_address, transport=BT_BR_EDR_TRANSPORT
+                target_address, transport=PhysicalTransport.BR_EDR
             )
             print(f'=== Connected to {connection.peer_address}!')
 
diff --git a/examples/run_channel_sounding.py b/examples/run_channel_sounding.py
new file mode 100644
index 0000000..346b775
--- /dev/null
+++ b/examples/run_channel_sounding.py
@@ -0,0 +1,154 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
+from __future__ import annotations
+
+import asyncio
+import logging
+import sys
+import os
+import functools
+
+from bumble import core
+from bumble import hci
+from bumble.device import Connection, Device, ChannelSoundingCapabilities
+from bumble.transport import open_transport_or_link
+
+# From https://cs.android.com/android/platform/superproject/main/+/main:packages/modules/Bluetooth/system/gd/hci/distance_measurement_manager.cc.
+CS_TONE_ANTENNA_CONFIG_MAPPING_TABLE = [
+    [0, 4, 5, 6],
+    [1, 7, 7, 7],
+    [2, 7, 7, 7],
+    [3, 7, 7, 7],
+]
+CS_PREFERRED_PEER_ANTENNA_MAPPING_TABLE = [1, 1, 1, 1, 3, 7, 15, 3]
+CS_ANTENNA_PERMUTATION_ARRAY = [
+    [1, 2, 3, 4],
+    [2, 1, 3, 4],
+    [1, 3, 2, 4],
+    [3, 1, 2, 4],
+    [3, 2, 1, 4],
+    [2, 3, 1, 4],
+    [1, 2, 4, 3],
+    [2, 1, 4, 3],
+    [1, 4, 2, 3],
+    [4, 1, 2, 3],
+    [4, 2, 1, 3],
+    [2, 4, 1, 3],
+    [1, 4, 3, 2],
+    [4, 1, 3, 2],
+    [1, 3, 4, 2],
+    [3, 1, 4, 2],
+    [3, 4, 1, 2],
+    [4, 3, 1, 2],
+    [4, 2, 3, 1],
+    [2, 4, 3, 1],
+    [4, 3, 2, 1],
+    [3, 4, 2, 1],
+    [3, 2, 4, 1],
+    [2, 3, 4, 1],
+]
+
+
+# -----------------------------------------------------------------------------
+async def main() -> None:
+    if len(sys.argv) < 3:
+        print(
+            'Usage: run_channel_sounding.py <config-file> <transport-spec-for-device>'
+            '[target_address](If missing, run as reflector)'
+        )
+        print('example: run_channel_sounding.py cs_reflector.json usb:0')
+        print(
+            'example: run_channel_sounding.py cs_initiator.json usb:0 F0:F1:F2:F3:F4:F5'
+        )
+        return
+
+    print('<<< connecting to HCI...')
+    async with await open_transport_or_link(sys.argv[2]) as hci_transport:
+        print('<<< connected')
+
+        device = Device.from_config_file_with_hci(
+            sys.argv[1], hci_transport.source, hci_transport.sink
+        )
+        await device.power_on()
+        assert (local_cs_capabilities := device.cs_capabilities)
+
+        if len(sys.argv) == 3:
+            print('<<< Start Advertising')
+            await device.start_advertising(
+                own_address_type=hci.OwnAddressType.RANDOM, auto_restart=True
+            )
+
+            def on_cs_capabilities(
+                connection: Connection, capabilities: ChannelSoundingCapabilities
+            ):
+                del capabilities
+                print('<<< Set CS Settings')
+                asyncio.create_task(device.set_default_cs_settings(connection))
+
+            device.on(
+                'connection',
+                lambda connection: connection.on(
+                    'channel_sounding_capabilities',
+                    functools.partial(on_cs_capabilities, connection),
+                ),
+            )
+        else:
+            target_address = hci.Address(sys.argv[3])
+
+            print(f'<<< Connecting to {target_address}')
+            connection = await device.connect(
+                target_address, transport=core.PhysicalTransport.LE
+            )
+            print('<<< ACL Connected')
+            if not (await device.get_long_term_key(connection.handle, b'', 0)):
+                print('<<< No bond, start pairing')
+                await connection.pair()
+                print('<<< Pairing complete')
+
+            print('<<< Encrypting Connection')
+            await connection.encrypt()
+
+            print('<<< Getting remote CS Capabilities...')
+            remote_capabilities = await device.get_remote_cs_capabilities(connection)
+            print('<<< Set CS Settings...')
+            await device.set_default_cs_settings(connection)
+            print('<<< Set CS Config...')
+            config = await device.create_cs_config(connection)
+            print('<<< Enable CS Security...')
+            await device.enable_cs_security(connection)
+            tone_antenna_config_selection = CS_TONE_ANTENNA_CONFIG_MAPPING_TABLE[
+                local_cs_capabilities.num_antennas_supported - 1
+            ][remote_capabilities.num_antennas_supported - 1]
+            print('<<< Set CS Procedure Parameters...')
+            await device.set_cs_procedure_parameters(
+                connection=connection,
+                config=config,
+                tone_antenna_config_selection=tone_antenna_config_selection,
+                preferred_peer_antenna=CS_PREFERRED_PEER_ANTENNA_MAPPING_TABLE[
+                    tone_antenna_config_selection
+                ],
+            )
+            print('<<< Enable CS Procedure...')
+            await device.enable_cs_procedure(connection=connection, config=config)
+
+        await hci_transport.source.terminated
+
+
+# -----------------------------------------------------------------------------
+logging.basicConfig(level=os.environ.get('BUMBLE_LOGLEVEL', 'DEBUG').upper())
+asyncio.run(main())
diff --git a/examples/run_cig_setup.py b/examples/run_cig_setup.py
index b0a0fe1..6fa6092 100644
--- a/examples/run_cig_setup.py
+++ b/examples/run_cig_setup.py
@@ -19,12 +19,8 @@ import asyncio
 import logging
 import sys
 import os
-from bumble.device import (
-    Device,
-    Connection,
-    AdvertisingParameters,
-    AdvertisingEventProperties,
-)
+from bumble import utils
+from bumble.device import Device, Connection
 from bumble.hci import (
     OwnAddressType,
 )
@@ -79,7 +75,9 @@ async def main() -> None:
     def on_cis_request(
         connection: Connection, cis_handle: int, _cig_id: int, _cis_id: int
     ):
-        connection.abort_on('disconnection', devices[0].accept_cis_request(cis_handle))
+        utils.cancel_on_event(
+            connection, 'disconnection', devices[0].accept_cis_request(cis_handle)
+        )
 
     devices[0].on('cis_request', on_cis_request)
 
diff --git a/examples/run_classic_connect.py b/examples/run_classic_connect.py
index 362e6b8..652858b 100644
--- a/examples/run_classic_connect.py
+++ b/examples/run_classic_connect.py
@@ -23,7 +23,7 @@ from bumble.colors import color
 
 from bumble.device import Device
 from bumble.transport import open_transport_or_link
-from bumble.core import BT_BR_EDR_TRANSPORT, BT_L2CAP_PROTOCOL_ID, CommandTimeoutError
+from bumble.core import PhysicalTransport, BT_L2CAP_PROTOCOL_ID, CommandTimeoutError
 from bumble.sdp import (
     Client as SDP_Client,
     SDP_PUBLIC_BROWSE_ROOT,
@@ -57,7 +57,7 @@ async def main() -> None:
             print(f'=== Connecting to {target_address}...')
             try:
                 connection = await device.connect(
-                    target_address, transport=BT_BR_EDR_TRANSPORT
+                    target_address, transport=PhysicalTransport.BR_EDR
                 )
             except CommandTimeoutError:
                 print('!!! Connection timed out')
diff --git a/examples/run_esco_connection.py b/examples/run_esco_connection.py
index 6f3e800..3681df7 100644
--- a/examples/run_esco_connection.py
+++ b/examples/run_esco_connection.py
@@ -16,11 +16,10 @@
 # Imports
 # -----------------------------------------------------------------------------
 import asyncio
-import dataclasses
 import logging
 import sys
 import os
-from bumble.core import BT_BR_EDR_TRANSPORT
+from bumble.core import PhysicalTransport
 from bumble.device import Device, ScoLink
 from bumble.hci import HCI_Enhanced_Setup_Synchronous_Connection_Command
 from bumble.hfp import DefaultCodecParameters, ESCO_PARAMETERS
@@ -61,7 +60,9 @@ async def main() -> None:
 
     connections = await asyncio.gather(
         devices[0].accept(devices[1].public_address),
-        devices[1].connect(devices[0].public_address, transport=BT_BR_EDR_TRANSPORT),
+        devices[1].connect(
+            devices[0].public_address, transport=PhysicalTransport.BR_EDR
+        ),
     )
 
     def on_sco(sco_link: ScoLink):
diff --git a/examples/run_extended_advertiser_2.py b/examples/run_extended_advertiser_2.py
index 735e1c5..6f8d123 100644
--- a/examples/run_extended_advertiser_2.py
+++ b/examples/run_extended_advertiser_2.py
@@ -64,6 +64,7 @@ async def main() -> None:
                 [(AdvertisingData.COMPLETE_LOCAL_NAME, "Bumble 2".encode("utf-8"))]
             )
 
+        # pylint: disable=possibly-used-before-assignment
         if device.host.number_of_supported_advertising_sets >= 2:
             set2 = await device.create_advertising_set(
                 random_address=Address("F0:F0:F0:F0:F0:F1"),
diff --git a/examples/run_gatt_client_and_server.py b/examples/run_gatt_client_and_server.py
index e25d14c..0811d74 100644
--- a/examples/run_gatt_client_and_server.py
+++ b/examples/run_gatt_client_and_server.py
@@ -70,13 +70,13 @@ async def main() -> None:
     descriptor = Descriptor(
         GATT_CHARACTERISTIC_USER_DESCRIPTION_DESCRIPTOR,
         Descriptor.READABLE,
-        'My Description',
+        'My Description'.encode(),
     )
-    manufacturer_name_characteristic = Characteristic(
+    manufacturer_name_characteristic = Characteristic[bytes](
         GATT_MANUFACTURER_NAME_STRING_CHARACTERISTIC,
         Characteristic.Properties.READ,
         Characteristic.READABLE,
-        "Fitbit",
+        "Fitbit".encode(),
         [descriptor],
     )
     device_info_service = Service(
diff --git a/examples/run_gatt_server.py b/examples/run_gatt_server.py
index 874115c..1860cf2 100644
--- a/examples/run_gatt_server.py
+++ b/examples/run_gatt_server.py
@@ -94,13 +94,13 @@ async def main() -> None:
         descriptor = Descriptor(
             GATT_CHARACTERISTIC_USER_DESCRIPTION_DESCRIPTOR,
             Descriptor.READABLE,
-            'My Description',
+            'My Description'.encode(),
         )
         manufacturer_name_characteristic = Characteristic(
             GATT_MANUFACTURER_NAME_STRING_CHARACTERISTIC,
             Characteristic.Properties.READ,
             Characteristic.READABLE,
-            'Fitbit',
+            'Fitbit'.encode(),
             [descriptor],
         )
         device_info_service = Service(
@@ -127,7 +127,7 @@ async def main() -> None:
                     '486F64C6-4B5F-4B3B-8AFF-EDE134A8446A',
                     Characteristic.Properties.READ | Characteristic.Properties.NOTIFY,
                     Characteristic.READABLE,
-                    'hello',
+                    bytes('hello', 'utf-8'),
                 ),
             ],
         )
diff --git a/examples/run_gatt_with_adapters.py b/examples/run_gatt_with_adapters.py
new file mode 100644
index 0000000..ba6b95a
--- /dev/null
+++ b/examples/run_gatt_with_adapters.py
@@ -0,0 +1,436 @@
+# Copyright 2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
+from __future__ import annotations
+import asyncio
+import dataclasses
+import functools
+import enum
+import logging
+import os
+import random
+import struct
+import sys
+from typing import Any, List, Union
+
+from bumble.device import Device, Peer
+from bumble import transport
+from bumble import gatt
+from bumble import gatt_adapters
+from bumble import gatt_client
+from bumble import hci
+from bumble import core
+
+
+# -----------------------------------------------------------------------------
+SERVICE_UUID = core.UUID("50DB505C-8AC4-4738-8448-3B1D9CC09CC5")
+CHARACTERISTIC_UUID_BASE = "D901B45B-4916-412E-ACCA-0000000000"
+
+DEFAULT_CLIENT_ADDRESS = "F0:F1:F2:F3:F4:F5"
+DEFAULT_SERVER_ADDRESS = "F1:F2:F3:F4:F5:F6"
+
+
+# -----------------------------------------------------------------------------
+@dataclasses.dataclass
+class CustomSerializableClass:
+    x: int
+    y: int
+
+    @classmethod
+    def from_bytes(cls, data: bytes) -> CustomSerializableClass:
+        return cls(*struct.unpack(">II", data))
+
+    def __bytes__(self) -> bytes:
+        return struct.pack(">II", self.x, self.y)
+
+
+# -----------------------------------------------------------------------------
+@dataclasses.dataclass
+class CustomClass:
+    a: int
+    b: int
+
+    @classmethod
+    def decode(cls, data: bytes) -> CustomClass:
+        return cls(*struct.unpack(">II", data))
+
+    def encode(self) -> bytes:
+        return struct.pack(">II", self.a, self.b)
+
+
+# -----------------------------------------------------------------------------
+class CustomEnum(enum.IntEnum):
+    FOO = 1234
+    BAR = 5678
+
+
+# -----------------------------------------------------------------------------
+async def client(device: Device, address: hci.Address) -> None:
+    print(f'=== Connecting to {address}...')
+    connection = await device.connect(address)
+    print('=== Connected')
+
+    # Discover all characteristics.
+    peer = Peer(connection)
+    print("*** Discovering services and characteristics...")
+    await peer.discover_all()
+    print("*** Discovery complete")
+
+    service = peer.get_services_by_uuid(SERVICE_UUID)[0]
+    characteristics: list[gatt_client.CharacteristicProxy] = []
+    for index in range(1, 10):
+        characteristics.append(
+            service.get_characteristics_by_uuid(
+                core.UUID(CHARACTERISTIC_UUID_BASE + f"{index:02X}")
+            )[0]
+        )
+
+    # Read all characteristics as raw bytes.
+    for characteristic in characteristics:
+        value = await characteristic.read_value()
+        print(f"### {characteristic} = {value!r} ({value.hex()})")
+
+    # Subscribe to all characteristics as a raw bytes listener.
+    def on_raw_characteristic_update(characteristic, value):
+        print(f"^^^ Update[RAW] {characteristic.uuid} value = {value.hex()}")
+
+    for characteristic in characteristics:
+        await characteristic.subscribe(
+            functools.partial(on_raw_characteristic_update, characteristic)
+        )
+
+    # Function to subscribe to adapted characteristics
+    def on_adapted_characteristic_update(characteristic, value):
+        print(
+            f"^^^ Update[ADAPTED] {characteristic.uuid} value = {value!r}, "
+            f"type={type(value)}"
+        )
+
+    # Static characteristic with a bytes value.
+    c1 = characteristics[0]
+    c1_value = await c1.read_value()
+    print(f"@@@ C1 {c1} value = {c1_value!r} (type={type(c1_value)})")
+    await c1.write_value("happy π day".encode("utf-8"))
+    await c1.subscribe(functools.partial(on_adapted_characteristic_update, c1))
+
+    # Static characteristic with a string value.
+    c2 = gatt_adapters.UTF8CharacteristicProxyAdapter(characteristics[1])
+    c2_value = await c2.read_value()
+    print(f"@@@ C2 {c2} value = {c2_value} (type={type(c2_value)})")
+    await c2.write_value("happy π day")
+    await c2.subscribe(functools.partial(on_adapted_characteristic_update, c2))
+
+    # Static characteristic with a tuple value.
+    c3 = gatt_adapters.PackedCharacteristicProxyAdapter(characteristics[2], ">III")
+    c3_value = await c3.read_value()
+    print(f"@@@ C3 {c3} value = {c3_value} (type={type(c3_value)})")
+    await c3.write_value((2001, 2002, 2003))
+    await c3.subscribe(functools.partial(on_adapted_characteristic_update, c3))
+
+    # Static characteristic with a named tuple value.
+    c4 = gatt_adapters.MappedCharacteristicProxyAdapter(
+        characteristics[3], ">III", ["f1", "f2", "f3"]
+    )
+    c4_value = await c4.read_value()
+    print(f"@@@ C4 {c4} value = {c4_value} (type={type(c4_value)})")
+    await c4.write_value({"f1": 4001, "f2": 4002, "f3": 4003})
+    await c4.subscribe(functools.partial(on_adapted_characteristic_update, c4))
+
+    # Static characteristic with a serializable value.
+    c5 = gatt_adapters.SerializableCharacteristicProxyAdapter(
+        characteristics[4], CustomSerializableClass
+    )
+    c5_value = await c5.read_value()
+    print(f"@@@ C5 {c5} value = {c5_value} (type={type(c5_value)})")
+    await c5.write_value(CustomSerializableClass(56, 57))
+    await c5.subscribe(functools.partial(on_adapted_characteristic_update, c5))
+
+    # Static characteristic with a delegated value.
+    c6 = gatt_adapters.DelegatedCharacteristicProxyAdapter(
+        characteristics[5], encode=CustomClass.encode, decode=CustomClass.decode
+    )
+    c6_value = await c6.read_value()
+    print(f"@@@ C6 {c6} value = {c6_value} (type={type(c6_value)})")
+    await c6.write_value(CustomClass(6, 7))
+    await c6.subscribe(functools.partial(on_adapted_characteristic_update, c6))
+
+    # Dynamic characteristic with a bytes value.
+    c7 = characteristics[6]
+    c7_value = await c7.read_value()
+    print(f"@@@ C7 {c7} value = {c7_value!r} (type={type(c7_value)})")
+    await c7.write_value(bytes.fromhex("01020304"))
+    await c7.subscribe(functools.partial(on_adapted_characteristic_update, c7))
+
+    # Dynamic characteristic with a string value.
+    c8 = gatt_adapters.UTF8CharacteristicProxyAdapter(characteristics[7])
+    c8_value = await c8.read_value()
+    print(f"@@@ C8 {c8} value = {c8_value} (type={type(c8_value)})")
+    await c8.write_value("howdy")
+    await c8.subscribe(functools.partial(on_adapted_characteristic_update, c8))
+
+    # Static characteristic with an enum value
+    c9 = gatt_adapters.EnumCharacteristicProxyAdapter(
+        characteristics[8], CustomEnum, 3, 'big'
+    )
+    c9_value = await c9.read_value()
+    print(f"@@@ C9 {c9} value = {c9_value.name} (type={type(c9_value)})")
+    await c9.write_value(CustomEnum.BAR)
+    await c9.subscribe(functools.partial(on_adapted_characteristic_update, c9))
+
+
+# -----------------------------------------------------------------------------
+def dynamic_read(selector: str) -> Union[bytes, str]:
+    if selector == "bytes":
+        print("$$$ Returning random bytes")
+        return random.randbytes(7)
+    elif selector == "string":
+        print("$$$ Returning random string")
+        return random.randbytes(7).hex()
+
+    raise ValueError("invalid selector")
+
+
+# -----------------------------------------------------------------------------
+def dynamic_write(selector: str, value: Any) -> None:
+    print(f"$$$ Received[{selector}]: {value} (type={type(value)})")
+
+
+# -----------------------------------------------------------------------------
+def on_characteristic_read(characteristic: gatt.Characteristic, value: Any) -> None:
+    """Event listener invoked when a characteristic is read."""
+    print(f"<<< READ: {characteristic} -> {value} ({type(value)})")
+
+
+# -----------------------------------------------------------------------------
+def on_characteristic_write(characteristic: gatt.Characteristic, value: Any) -> None:
+    """Event listener invoked when a characteristic is written."""
+    print(f"<<< WRITE: {characteristic} <- {value}  ({type(value)})")
+
+
+# -----------------------------------------------------------------------------
+async def server(device: Device) -> None:
+    # Static characteristic with a bytes value.
+    c1 = gatt.Characteristic(
+        CHARACTERISTIC_UUID_BASE + "01",
+        gatt.Characteristic.Properties.READ
+        | gatt.Characteristic.Properties.WRITE
+        | gatt.Characteristic.Properties.NOTIFY,
+        gatt.Characteristic.READABLE | gatt.Characteristic.WRITEABLE,
+        b'hello',
+    )
+
+    # Static characteristic with a string value.
+    c2 = gatt_adapters.UTF8CharacteristicAdapter(
+        gatt.Characteristic(
+            CHARACTERISTIC_UUID_BASE + "02",
+            gatt.Characteristic.Properties.READ
+            | gatt.Characteristic.Properties.WRITE
+            | gatt.Characteristic.Properties.NOTIFY,
+            gatt.Characteristic.READABLE | gatt.Characteristic.WRITEABLE,
+            'hello',
+        )
+    )
+
+    # Static characteristic with a tuple value.
+    c3 = gatt_adapters.PackedCharacteristicAdapter(
+        gatt.Characteristic(
+            CHARACTERISTIC_UUID_BASE + "03",
+            gatt.Characteristic.Properties.READ
+            | gatt.Characteristic.Properties.WRITE
+            | gatt.Characteristic.Properties.NOTIFY,
+            gatt.Characteristic.READABLE | gatt.Characteristic.WRITEABLE,
+            (1007, 1008, 1009),
+        ),
+        ">III",
+    )
+
+    # Static characteristic with a named tuple value.
+    c4 = gatt_adapters.MappedCharacteristicAdapter(
+        gatt.Characteristic(
+            CHARACTERISTIC_UUID_BASE + "04",
+            gatt.Characteristic.Properties.READ
+            | gatt.Characteristic.Properties.WRITE
+            | gatt.Characteristic.Properties.NOTIFY,
+            gatt.Characteristic.READABLE | gatt.Characteristic.WRITEABLE,
+            {"f1": 3007, "f2": 3008, "f3": 3009},
+        ),
+        ">III",
+        ["f1", "f2", "f3"],
+    )
+
+    # Static characteristic with a serializable value.
+    c5 = gatt_adapters.SerializableCharacteristicAdapter(
+        gatt.Characteristic(
+            CHARACTERISTIC_UUID_BASE + "05",
+            gatt.Characteristic.Properties.READ
+            | gatt.Characteristic.Properties.WRITE
+            | gatt.Characteristic.Properties.NOTIFY,
+            gatt.Characteristic.READABLE | gatt.Characteristic.WRITEABLE,
+            CustomSerializableClass(11, 12),
+        ),
+        CustomSerializableClass,
+    )
+
+    # Static characteristic with a delegated value.
+    c6 = gatt_adapters.DelegatedCharacteristicAdapter(
+        gatt.Characteristic(
+            CHARACTERISTIC_UUID_BASE + "06",
+            gatt.Characteristic.Properties.READ
+            | gatt.Characteristic.Properties.WRITE
+            | gatt.Characteristic.Properties.NOTIFY,
+            gatt.Characteristic.READABLE | gatt.Characteristic.WRITEABLE,
+            CustomClass(1, 2),
+        ),
+        encode=CustomClass.encode,
+        decode=CustomClass.decode,
+    )
+
+    # Dynamic characteristic with a bytes value.
+    c7 = gatt.Characteristic(
+        CHARACTERISTIC_UUID_BASE + "07",
+        gatt.Characteristic.Properties.READ
+        | gatt.Characteristic.Properties.WRITE
+        | gatt.Characteristic.Properties.NOTIFY,
+        gatt.Characteristic.READABLE | gatt.Characteristic.WRITEABLE,
+        gatt.CharacteristicValue(
+            read=lambda connection: dynamic_read("bytes"),
+            write=lambda connection, value: dynamic_write("bytes", value),
+        ),
+    )
+
+    # Dynamic characteristic with a string value.
+    c8 = gatt_adapters.UTF8CharacteristicAdapter(
+        gatt.Characteristic(
+            CHARACTERISTIC_UUID_BASE + "08",
+            gatt.Characteristic.Properties.READ
+            | gatt.Characteristic.Properties.WRITE
+            | gatt.Characteristic.Properties.NOTIFY,
+            gatt.Characteristic.READABLE | gatt.Characteristic.WRITEABLE,
+            gatt.CharacteristicValue(
+                read=lambda connection: dynamic_read("string"),
+                write=lambda connection, value: dynamic_write("string", value),
+            ),
+        )
+    )
+
+    # Static characteristic with an enum value
+    c9 = gatt_adapters.EnumCharacteristicAdapter(
+        gatt.Characteristic(
+            CHARACTERISTIC_UUID_BASE + "09",
+            gatt.Characteristic.Properties.READ
+            | gatt.Characteristic.Properties.WRITE
+            | gatt.Characteristic.Properties.NOTIFY,
+            gatt.Characteristic.READABLE | gatt.Characteristic.WRITEABLE,
+            CustomEnum.FOO,
+        ),
+        cls=CustomEnum,
+        length=3,
+        byteorder='big',
+    )
+
+    characteristics: List[gatt.Characteristic] = [
+        c1,
+        c2,
+        c3,
+        c4,
+        c5,
+        c6,
+        c7,
+        c8,
+        c9,
+    ]
+
+    # Listen for read and write events.
+    for characteristic in characteristics:
+        characteristic.on(
+            "read",
+            lambda _, value, c=characteristic: on_characteristic_read(c, value),
+        )
+        characteristic.on(
+            "write",
+            lambda _, value, c=characteristic: on_characteristic_write(c, value),
+        )
+
+    device.add_service(gatt.Service(SERVICE_UUID, characteristics))
+
+    # Notify every 3 seconds
+    i = 0
+    while True:
+        await asyncio.sleep(3)
+
+        # Notifying can be done with the characteristic's current value, or
+        # by explicitly passing a value to notify with. Both variants are used
+        # here: for c1..c4 we set the value and then notify, for c4..c9 we notify
+        # with an explicit value.
+        c1.value = f'hello c1 {i}'.encode()
+        await device.notify_subscribers(c1)
+        c2.value = f'hello c2 {i}'
+        await device.notify_subscribers(c2)
+        c3.value = (1000 + i, 2000 + i, 3000 + i)
+        await device.notify_subscribers(c3)
+        c4.value = {"f1": 4000 + i, "f2": 5000 + i, "f3": 6000 + i}
+        await device.notify_subscribers(c4)
+        await device.notify_subscribers(c5, CustomSerializableClass(1000 + i, 2000 + i))
+        await device.notify_subscribers(c6, CustomClass(3000 + i, 4000 + i))
+        await device.notify_subscribers(c7, bytes([1, 2, 3, i % 256]))
+        await device.notify_subscribers(c8, f'hello c8 {i}')
+        await device.notify_subscribers(
+            c9, CustomEnum.FOO if i % 2 == 0 else CustomEnum.BAR
+        )
+
+        i += 1
+
+
+# -----------------------------------------------------------------------------
+async def main() -> None:
+    if len(sys.argv) < 2:
+        print("Usage: run_gatt_with_adapters.py <transport-spec> client|server")
+        print("example: run_gatt_with_adapters.py usb:0 F0:F1:F2:F3:F4:F5")
+        return
+
+    async with await transport.open_transport(sys.argv[1]) as hci_transport:
+        is_client = sys.argv[2] == "client"
+
+        # Create a device to manage the host
+        device = Device.with_hci(
+            "Bumble",
+            hci.Address(
+                DEFAULT_CLIENT_ADDRESS if is_client else DEFAULT_SERVER_ADDRESS
+            ),
+            hci_transport.source,
+            hci_transport.sink,
+        )
+
+        # Get things going
+        await device.power_on()
+
+        if is_client:
+            # Connect a client to a peer
+            await client(device, hci.Address(DEFAULT_SERVER_ADDRESS))
+        else:
+            # Advertise so a peer can connect
+            await device.start_advertising(auto_restart=True)
+
+            # Setup a server
+            await server(device)
+
+        await hci_transport.source.wait_for_termination()
+
+
+# -----------------------------------------------------------------------------
+logging.basicConfig(level=os.environ.get('BUMBLE_LOGLEVEL', 'INFO').upper())
+asyncio.run(main())
diff --git a/examples/run_hfp_gateway.py b/examples/run_hfp_gateway.py
index 851f97c..7b2bb80 100644
--- a/examples/run_hfp_gateway.py
+++ b/examples/run_hfp_gateway.py
@@ -21,16 +21,14 @@ import sys
 import os
 import io
 import logging
-import websockets
+from typing import Iterable, Optional
 
-from typing import Optional
+import websockets
 
 import bumble.core
 from bumble.device import Device, ScoLink
 from bumble.transport import open_transport_or_link
-from bumble.core import (
-    BT_BR_EDR_TRANSPORT,
-)
+from bumble.core import PhysicalTransport
 from bumble import hci, rfcomm, hfp
 
 
@@ -82,6 +80,10 @@ def on_microphone_volume(level: int):
     send_message(type='microphone_volume', level=level)
 
 
+def on_supported_audio_codecs(codecs: Iterable[hfp.AudioCodec]):
+    send_message(type='supported_audio_codecs', codecs=[codec.name for codec in codecs])
+
+
 def on_sco_state_change(codec: int):
     if codec == hfp.AudioCodec.CVSD:
         sample_rate = 8000
@@ -207,6 +209,7 @@ async def main() -> None:
             ag_protocol = hfp.AgProtocol(dlc, configuration)
             ag_protocol.on('speaker_volume', on_speaker_volume)
             ag_protocol.on('microphone_volume', on_microphone_volume)
+            ag_protocol.on('supported_audio_codecs', on_supported_audio_codecs)
             on_hfp_state_change(True)
             dlc.multiplexer.l2cap_channel.on(
                 'close', lambda: on_hfp_state_change(False)
@@ -229,7 +232,7 @@ async def main() -> None:
             target_address = sys.argv[3]
             print(f'=== Connecting to {target_address}...')
             connection = await device.connect(
-                target_address, transport=BT_BR_EDR_TRANSPORT
+                target_address, transport=PhysicalTransport.BR_EDR
             )
             print(f'=== Connected to {connection.peer_address}!')
 
@@ -241,7 +244,7 @@ async def main() -> None:
             # Pick the first one
             channel, version, hf_sdp_features = hfp_record
             print(f'HF version: {version}')
-            print(f'HF features: {hf_sdp_features}')
+            print(f'HF features: {hf_sdp_features.name}')
 
             # Request authentication
             print('*** Authenticating...')
diff --git a/examples/run_hfp_handsfree.py b/examples/run_hfp_handsfree.py
index 5433284..2f9f205 100644
--- a/examples/run_hfp_handsfree.py
+++ b/examples/run_hfp_handsfree.py
@@ -25,6 +25,7 @@ import websockets
 import functools
 from typing import Optional
 
+from bumble import utils
 from bumble import rfcomm
 from bumble import hci
 from bumble.device import Device, Connection
@@ -57,7 +58,11 @@ def on_dlc(dlc: rfcomm.DLC, configuration: hfp.HfConfiguration):
                 esco_parameters = hfp.ESCO_PARAMETERS[
                     hfp.DefaultCodecParameters.ESCO_CVSD_S4
                 ]
-            connection.abort_on(
+            else:
+                raise RuntimeError("unknown active codec")
+
+            utils.cancel_on_event(
+                connection,
                 'disconnection',
                 connection.device.send_command(
                     hci.HCI_Enhanced_Accept_Synchronous_Connection_Request_Command(
diff --git a/examples/run_hid_device.py b/examples/run_hid_device.py
index 160e395..d9e5b73 100644
--- a/examples/run_hid_device.py
+++ b/examples/run_hid_device.py
@@ -26,7 +26,7 @@ import struct
 from bumble.device import Device
 from bumble.transport import open_transport_or_link
 from bumble.core import (
-    BT_BR_EDR_TRANSPORT,
+    PhysicalTransport,
     BT_L2CAP_PROTOCOL_ID,
     BT_HUMAN_INTERFACE_DEVICE_SERVICE,
     BT_HIDP_PROTOCOL_ID,
@@ -721,7 +721,7 @@ async def main() -> None:
                 elif choice == '9':
                     hid_host_bd_addr = str(hid_device.remote_device_bd_address)
                     connection = await device.connect(
-                        hid_host_bd_addr, transport=BT_BR_EDR_TRANSPORT
+                        hid_host_bd_addr, transport=PhysicalTransport.BR_EDR
                     )
                     await connection.authenticate()
                     await connection.encrypt()
diff --git a/examples/run_hid_host.py b/examples/run_hid_host.py
index cc17cc1..12d0108 100644
--- a/examples/run_hid_host.py
+++ b/examples/run_hid_host.py
@@ -26,7 +26,7 @@ from bumble.device import Device
 from bumble.transport import open_transport_or_link
 from bumble.core import (
     BT_HUMAN_INTERFACE_DEVICE_SERVICE,
-    BT_BR_EDR_TRANSPORT,
+    PhysicalTransport,
 )
 from bumble.hci import Address
 from bumble.hid import Host, Message
@@ -349,7 +349,9 @@ async def main() -> None:
         # Connect to a peer
         target_address = sys.argv[3]
         print(f'=== Connecting to {target_address}...')
-        connection = await device.connect(target_address, transport=BT_BR_EDR_TRANSPORT)
+        connection = await device.connect(
+            target_address, transport=PhysicalTransport.BR_EDR
+        )
         print(f'=== Connected to {connection.peer_address}!')
 
         # Request authentication
@@ -519,10 +521,10 @@ async def main() -> None:
 
                 elif choice == '13':
                     peer_address = Address.from_string_for_transport(
-                        target_address, transport=BT_BR_EDR_TRANSPORT
+                        target_address, transport=PhysicalTransport.BR_EDR
                     )
                     connection = device.find_connection_by_bd_addr(
-                        peer_address, transport=BT_BR_EDR_TRANSPORT
+                        peer_address, transport=PhysicalTransport.BR_EDR
                     )
                     if connection is not None:
                         await connection.disconnect()
@@ -538,7 +540,7 @@ async def main() -> None:
 
                 elif choice == '15':
                     connection = await device.connect(
-                        target_address, transport=BT_BR_EDR_TRANSPORT
+                        target_address, transport=PhysicalTransport.BR_EDR
                     )
                     await connection.authenticate()
                     await connection.encrypt()
diff --git a/examples/run_mcp_client.py b/examples/run_mcp_client.py
index 83dad5b..aba329f 100644
--- a/examples/run_mcp_client.py
+++ b/examples/run_mcp_client.py
@@ -22,6 +22,7 @@ import os
 import websockets
 import json
 
+from bumble import utils
 from bumble.core import AdvertisingData
 from bumble.device import (
     Device,
@@ -169,7 +170,7 @@ async def main() -> None:
                     mcp.on('track_position', on_track_position)
                     await mcp.subscribe_characteristics()
 
-            connection.abort_on('disconnection', on_connection_async())
+            utils.cancel_on_event(connection, 'disconnection', on_connection_async())
 
         device.on('connection', on_connection)
 
diff --git a/examples/run_rfcomm_client.py b/examples/run_rfcomm_client.py
index 9232dc9..7b97fc8 100644
--- a/examples/run_rfcomm_client.py
+++ b/examples/run_rfcomm_client.py
@@ -28,7 +28,7 @@ from bumble.transport import open_transport_or_link
 from bumble.core import (
     BT_L2CAP_PROTOCOL_ID,
     BT_RFCOMM_PROTOCOL_ID,
-    BT_BR_EDR_TRANSPORT,
+    PhysicalTransport,
 )
 from bumble.rfcomm import Client
 from bumble.sdp import (
@@ -191,7 +191,9 @@ async def main() -> None:
         # Connect to a peer
         target_address = sys.argv[3]
         print(f'=== Connecting to {target_address}...')
-        connection = await device.connect(target_address, transport=BT_BR_EDR_TRANSPORT)
+        connection = await device.connect(
+            target_address, transport=PhysicalTransport.BR_EDR
+        )
         print(f'=== Connected to {connection.peer_address}!')
 
         channel_str = sys.argv[4]
diff --git a/examples/run_unicast_server.py b/examples/run_unicast_server.py
index 3ff1c96..b475eb1 100644
--- a/examples/run_unicast_server.py
+++ b/examples/run_unicast_server.py
@@ -161,7 +161,13 @@ async def main() -> None:
             else:
                 file_output = open(f'{datetime.datetime.now().isoformat()}.lc3', 'wb')
                 codec_configuration = ase.codec_specific_configuration
-                assert isinstance(codec_configuration, CodecSpecificConfiguration)
+                if (
+                    not isinstance(codec_configuration, CodecSpecificConfiguration)
+                    or codec_configuration.sampling_frequency is None
+                    or codec_configuration.audio_channel_allocation is None
+                    or codec_configuration.frame_duration is None
+                ):
+                    return
                 # Write a LC3 header.
                 file_output.write(
                     bytes([0x1C, 0xCC])  # Header.
diff --git a/examples/run_vcp_renderer.py b/examples/run_vcp_renderer.py
index ba9c840..116d4d6 100644
--- a/examples/run_vcp_renderer.py
+++ b/examples/run_vcp_renderer.py
@@ -42,7 +42,7 @@ from bumble.profiles.bap import (
 from bumble.profiles.pacs import PacRecord, PublishedAudioCapabilitiesService
 from bumble.profiles.cap import CommonAudioServiceService
 from bumble.profiles.csip import CoordinatedSetIdentificationService, SirkType
-from bumble.profiles.vcp import VolumeControlService
+from bumble.profiles.vcs import VolumeControlService
 
 from bumble.transport import open_transport_or_link
 
@@ -117,13 +117,17 @@ async def main() -> None:
 
         ws: Optional[websockets.WebSocketServerProtocol] = None
 
-        def on_volume_state(volume_setting: int, muted: int, change_counter: int):
+        def on_volume_state_change():
             if ws:
                 asyncio.create_task(
-                    ws.send(dumps_volume_state(volume_setting, muted, change_counter))
+                    ws.send(
+                        dumps_volume_state(
+                            vcs.volume_setting, vcs.muted, vcs.change_counter
+                        )
+                    )
                 )
 
-        vcs.on('volume_state', on_volume_state)
+        vcs.on('volume_state_change', on_volume_state_change)
 
         advertising_data = (
             bytes(
@@ -170,16 +174,10 @@ async def main() -> None:
             ws = websocket
             async for message in websocket:
                 volume_state = json.loads(message)
-                vcs.volume_state_bytes = bytes(
-                    [
-                        volume_state['volume_setting'],
-                        volume_state['muted'],
-                        volume_state['change_counter'],
-                    ]
-                )
-                await device.notify_subscribers(
-                    vcs.volume_state, vcs.volume_state_bytes
-                )
+                vcs.volume_setting = volume_state['volume_setting']
+                vcs.muted = volume_state['muted']
+                vcs.change_counter = volume_state['change_counter']
+                await device.notify_subscribers(vcs.volume_state)
             ws = None
 
         await websockets.serve(serve, 'localhost', 8989)
diff --git a/extras/android/BtBench/.gitignore b/extras/android/BtBench/.gitignore
index aa724b7..87f66f5 100644
--- a/extras/android/BtBench/.gitignore
+++ b/extras/android/BtBench/.gitignore
@@ -1,12 +1,7 @@
 *.iml
 .gradle
 /local.properties
-/.idea/caches
-/.idea/libraries
-/.idea/modules.xml
-/.idea/workspace.xml
-/.idea/navEditor.xml
-/.idea/assetWizardSettings.xml
+.idea/
 .DS_Store
 /build
 /captures
diff --git a/extras/android/BtBench/app/build.gradle.kts b/extras/android/BtBench/app/build.gradle.kts
index ffde197..887be16 100644
--- a/extras/android/BtBench/app/build.gradle.kts
+++ b/extras/android/BtBench/app/build.gradle.kts
@@ -10,7 +10,7 @@ android {
 
     defaultConfig {
         applicationId = "com.github.google.bumble.btbench"
-        minSdk = 30
+        minSdk = 33
         targetSdk = 34
         versionCode = 1
         versionName = "1.0"
@@ -60,6 +60,8 @@ dependencies {
     implementation(libs.ui.graphics)
     implementation(libs.ui.tooling.preview)
     implementation(libs.material3)
+    implementation(libs.mobly.snippet)
+    implementation(libs.androidx.core)
     testImplementation(libs.junit)
     androidTestImplementation(libs.androidx.test.ext.junit)
     androidTestImplementation(libs.espresso.core)
diff --git a/extras/android/BtBench/app/src/main/AndroidManifest.xml b/extras/android/BtBench/app/src/main/AndroidManifest.xml
index c77eb1a..1349991 100644
--- a/extras/android/BtBench/app/src/main/AndroidManifest.xml
+++ b/extras/android/BtBench/app/src/main/AndroidManifest.xml
@@ -1,14 +1,17 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.github.google.bumble.btbench">
-     <uses-sdk android:minSdkVersion="30" android:targetSdkVersion="34" />
+     <uses-sdk android:minSdkVersion="33" android:targetSdkVersion="34" />
     <!-- Request legacy Bluetooth permissions on older devices. -->
     <uses-permission android:name="android.permission.BLUETOOTH" android:maxSdkVersion="30" />
     <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" android:maxSdkVersion="30" />
+    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
 
     <uses-permission android:name="android.permission.BLUETOOTH_SCAN" android:usesPermissionFlags="neverForLocation"/>
     <uses-permission android:name="android.permission.BLUETOOTH_ADVERTISE" />
     <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+    <uses-permission android:name="android.permission.INTERNET" />
 
     <uses-feature android:name="android.hardware.bluetooth" android:required="true"/>
     <uses-feature android:name="android.hardware.bluetooth_le" android:required="true"/>
@@ -23,6 +26,9 @@
         android:supportsRtl="true"
         android:theme="@style/Theme.BTBench"
         >
+        <meta-data
+            android:name="mobly-snippets"
+            android:value="com.github.google.bumble.btbench.AutomationSnippet"/>
         <activity
             android:name=".MainActivity"
             android:exported="true"
@@ -35,5 +41,7 @@
         </activity>
 <!--        <profileable android:shell="true"/>-->
     </application>
-
-</manifest>
\ No newline at end of file
+    <instrumentation
+        android:name="com.google.android.mobly.snippet.SnippetRunner"
+        android:targetPackage="com.github.google.bumble.btbench" />
+</manifest>
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Advertiser.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Advertiser.kt
new file mode 100644
index 0000000..7205420
--- /dev/null
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Advertiser.kt
@@ -0,0 +1,41 @@
+package com.github.google.bumble.btbench
+
+import android.annotation.SuppressLint
+import android.bluetooth.BluetoothAdapter
+import android.bluetooth.le.AdvertiseCallback
+import android.bluetooth.le.AdvertiseData
+import android.bluetooth.le.AdvertiseSettings
+import android.bluetooth.le.AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY
+import androidx.annotation.RequiresApi
+import java.util.logging.Logger
+
+private val Log = Logger.getLogger("btbench.advertiser")
+
+class Advertiser(private val bluetoothAdapter: BluetoothAdapter) : AdvertiseCallback() {
+    @SuppressLint("MissingPermission")
+    @RequiresApi(34)
+    fun start() {
+        val advertiseSettingsBuilder = AdvertiseSettings.Builder()
+            .setAdvertiseMode(ADVERTISE_MODE_LOW_LATENCY)
+            .setConnectable(true)
+        advertiseSettingsBuilder.setDiscoverable(true)
+        val advertiseSettings = advertiseSettingsBuilder.build()
+        val advertiseData = AdvertiseData.Builder().build()
+        val scanData = AdvertiseData.Builder().setIncludeDeviceName(true).build()
+        bluetoothAdapter.bluetoothLeAdvertiser.startAdvertising(advertiseSettings, advertiseData, scanData, this)
+    }
+
+    @SuppressLint("MissingPermission")
+    fun stop() {
+        Log.info("stopping advertiser")
+        bluetoothAdapter.bluetoothLeAdvertiser.stopAdvertising(this)
+    }
+
+    override fun onStartFailure(errorCode: Int) {
+        Log.warning("failed to start advertising: $errorCode")
+    }
+
+    override fun onStartSuccess(settingsInEffect: AdvertiseSettings) {
+        Log.info("advertising started: $settingsInEffect")
+    }
+}
\ No newline at end of file
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/AutomationSnippet.java b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/AutomationSnippet.java
new file mode 100644
index 0000000..ca7d41d
--- /dev/null
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/AutomationSnippet.java
@@ -0,0 +1,383 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.github.google.bumble.btbench;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothManager;
+import android.content.Context;
+
+import androidx.test.core.app.ApplicationProvider;
+
+import com.google.android.mobly.snippet.Snippet;
+import com.google.android.mobly.snippet.rpc.Rpc;
+import com.google.android.mobly.snippet.rpc.RpcOptional;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.security.InvalidParameterException;
+import java.util.ArrayList;
+import java.util.UUID;
+
+class Runner {
+    public UUID mId;
+    private final Mode mMode;
+    private final String mModeName;
+    private final String mScenario;
+    private final AppViewModel mModel;
+
+    Runner(Mode mode, String modeName, String scenario, AppViewModel model) {
+        this.mId = UUID.randomUUID();
+        this.mMode = mode;
+        this.mModeName = modeName;
+        this.mScenario = scenario;
+        this.mModel = model;
+    }
+
+    public JSONObject toJson() throws JSONException {
+        JSONObject result = new JSONObject();
+        result.put("id", mId.toString());
+        result.put("mode", mModeName);
+        result.put("scenario", mScenario);
+        result.put("model", AutomationSnippet.modelToJson(mModel));
+
+        return result;
+    }
+
+    public void stop() {
+        mModel.abort();
+    }
+
+    public void waitForCompletion() {
+        mMode.waitForCompletion();
+    }
+}
+
+public class AutomationSnippet implements Snippet {
+    private static final String TAG = "btbench.snippet";
+    private final BluetoothAdapter mBluetoothAdapter;
+    private final Context mContext;
+    private final ArrayList<Runner> mRunners = new ArrayList<>();
+
+    public AutomationSnippet() throws IOException {
+        mContext = ApplicationProvider.getApplicationContext();
+        BluetoothManager bluetoothManager = mContext.getSystemService(BluetoothManager.class);
+        mBluetoothAdapter = bluetoothManager.getAdapter();
+        if (mBluetoothAdapter == null) {
+            throw new IOException("bluetooth not supported");
+        }
+        if (!mBluetoothAdapter.isEnabled()) {
+            throw new IOException("bluetooth not enabled");
+        }
+    }
+
+    private Runner runScenario(AppViewModel model, String mode, String scenario) {
+        Mode runnable;
+        switch (mode) {
+            case "rfcomm-client":
+                runnable = new RfcommClient(model, mBluetoothAdapter,
+                                            (PacketIO packetIO) -> createIoClient(model, scenario,
+                                                                                  packetIO));
+                break;
+
+            case "rfcomm-server":
+                runnable = new RfcommServer(model, mBluetoothAdapter,
+                                            (PacketIO packetIO) -> createIoClient(model, scenario,
+                                                                                  packetIO));
+                break;
+
+            case "l2cap-client":
+                runnable = new L2capClient(model, mBluetoothAdapter, mContext,
+                                           (PacketIO packetIO) -> createIoClient(model, scenario,
+                                                                                 packetIO));
+                break;
+
+            case "l2cap-server":
+                runnable = new L2capServer(model, mBluetoothAdapter,
+                                           (PacketIO packetIO) -> createIoClient(model, scenario,
+                                                                                 packetIO));
+                break;
+
+            case "gatt-client":
+                runnable = new GattClient(model, mBluetoothAdapter, mContext,
+                                          (PacketIO packetIO) -> createIoClient(model, scenario,
+                                                                                packetIO));
+                break;
+
+            case "gatt-server":
+                runnable = new GattServer(model, mBluetoothAdapter, mContext,
+                                          (PacketIO packetIO) -> createIoClient(model, scenario,
+                                                                                packetIO));
+                break;
+
+            default:
+                return null;
+        }
+
+        model.setMode(mode);
+        model.setScenario(scenario);
+        runnable.run();
+        Runner runner = new Runner(runnable, mode, scenario, model);
+        mRunners.add(runner);
+        return runner;
+    }
+
+    private IoClient createIoClient(AppViewModel model, String scenario, PacketIO packetIO) {
+        switch (scenario) {
+            case "send":
+                return new Sender(model, packetIO);
+
+            case "receive":
+                return new Receiver(model, packetIO);
+
+            case "ping":
+                return new Pinger(model, packetIO);
+
+            case "pong":
+                return new Ponger(model, packetIO);
+
+            default:
+                return null;
+        }
+    }
+
+    public static JSONObject modelToJson(AppViewModel model) throws JSONException {
+        JSONObject result = new JSONObject();
+        result.put("status", model.getStatus());
+        result.put("running", model.getRunning());
+        result.put("peer_bluetooth_address", model.getPeerBluetoothAddress());
+        result.put("mode", model.getMode());
+        result.put("scenario", model.getScenario());
+        result.put("sender_packet_size", model.getSenderPacketSize());
+        result.put("sender_packet_count", model.getSenderPacketCount());
+        result.put("sender_packet_interval", model.getSenderPacketInterval());
+        result.put("packets_sent", model.getPacketsSent());
+        result.put("packets_received", model.getPacketsReceived());
+        result.put("l2cap_psm", model.getL2capPsm());
+        result.put("use_2m_phy", model.getUse2mPhy());
+        result.put("connection_priority", model.getConnectionPriority());
+        result.put("mtu", model.getMtu());
+        result.put("rx_phy", model.getRxPhy());
+        result.put("tx_phy", model.getTxPhy());
+        result.put("startup_delay", model.getStartupDelay());
+        if (model.getStatus().equals("OK")) {
+            JSONObject stats = new JSONObject();
+            result.put("stats", stats);
+            stats.put("throughput", model.getThroughput());
+            JSONObject rttStats = new JSONObject();
+            stats.put("rtt", rttStats);
+            rttStats.put("compound", model.getStats());
+        } else {
+            result.put("last_error", model.getLastError());
+        }
+
+        return result;
+    }
+
+    private Runner findRunner(String runnerId) {
+        for (Runner runner : mRunners) {
+            if (runner.mId.toString().equals(runnerId)) {
+                return runner;
+            }
+        }
+
+        return null;
+    }
+
+    @Rpc(description = "Run a scenario in RFComm Client mode")
+    public JSONObject runRfcommClient(String scenario, String peerBluetoothAddress, int packetCount,
+                                      int packetSize, int packetInterval,
+                                      @RpcOptional Integer startupDelay) throws JSONException {
+        // We only support "send" and "ping" for this mode for now
+        if (!(scenario.equals("send") || scenario.equals("ping"))) {
+            throw new InvalidParameterException(
+                    "only 'send' and 'ping' are supported for this mode");
+        }
+
+        AppViewModel model = new AppViewModel();
+        model.setPeerBluetoothAddress(peerBluetoothAddress);
+        model.setSenderPacketCount(packetCount);
+        model.setSenderPacketSize(packetSize);
+        model.setSenderPacketInterval(packetInterval);
+        if (startupDelay != null) {
+            model.setStartupDelay(startupDelay);
+        }
+
+        Runner runner = runScenario(model, "rfcomm-client", scenario);
+        assert runner != null;
+        return runner.toJson();
+    }
+
+    @Rpc(description = "Run a scenario in RFComm Server mode")
+    public JSONObject runRfcommServer(String scenario,
+                                      @RpcOptional Integer startupDelay) throws JSONException {
+        // We only support "receive" and "pong" for this mode for now
+        if (!(scenario.equals("receive") || scenario.equals("pong"))) {
+            throw new InvalidParameterException(
+                    "only 'receive' and 'pong' are supported for this mode");
+        }
+
+        AppViewModel model = new AppViewModel();
+        if (startupDelay != null) {
+            model.setStartupDelay(startupDelay);
+        }
+
+        Runner runner = runScenario(model, "rfcomm-server", scenario);
+        assert runner != null;
+        return runner.toJson();
+    }
+
+    @Rpc(description = "Run a scenario in L2CAP Client mode")
+    public JSONObject runL2capClient(String scenario, String peerBluetoothAddress, int psm,
+                                     boolean use_2m_phy, int packetCount, int packetSize,
+                                     int packetInterval, @RpcOptional String connectionPriority,
+                                     @RpcOptional Integer startupDelay) throws JSONException {
+        // We only support "send" and "ping" for this mode for now
+        if (!(scenario.equals("send") || scenario.equals("ping"))) {
+            throw new InvalidParameterException(
+                    "only 'send' and 'ping' are supported for this mode");
+        }
+
+        AppViewModel model = new AppViewModel();
+        model.setPeerBluetoothAddress(peerBluetoothAddress);
+        model.setL2capPsm(psm);
+        model.setUse2mPhy(use_2m_phy);
+        model.setSenderPacketCount(packetCount);
+        model.setSenderPacketSize(packetSize);
+        model.setSenderPacketInterval(packetInterval);
+        if (connectionPriority != null) {
+            model.setConnectionPriority(connectionPriority);
+        }
+        if (startupDelay != null) {
+            model.setStartupDelay(startupDelay);
+        }
+        Runner runner = runScenario(model, "l2cap-client", scenario);
+        assert runner != null;
+        return runner.toJson();
+    }
+
+    @Rpc(description = "Run a scenario in L2CAP Server mode")
+    public JSONObject runL2capServer(String scenario,
+                                     @RpcOptional Integer startupDelay) throws JSONException {
+        // We only support "receive" and "pong" for this mode for now
+        if (!(scenario.equals("receive") || scenario.equals("pong"))) {
+            throw new InvalidParameterException(
+                    "only 'receive' and 'pong' are supported for this mode");
+        }
+
+        AppViewModel model = new AppViewModel();
+        if (startupDelay != null) {
+            model.setStartupDelay(startupDelay);
+        }
+
+        Runner runner = runScenario(model, "l2cap-server", scenario);
+        assert runner != null;
+        return runner.toJson();
+    }
+
+    @Rpc(description = "Run a scenario in GATT Client mode")
+    public JSONObject runGattClient(String scenario, String peerBluetoothAddress,
+                                    boolean use_2m_phy, int packetCount, int packetSize,
+                                    int packetInterval, @RpcOptional String connectionPriority,
+                                    @RpcOptional Integer startupDelay) throws JSONException {
+        // We only support "send" and "ping" for this mode for now
+        if (!(scenario.equals("send") || scenario.equals("ping"))) {
+            throw new InvalidParameterException(
+                    "only 'send' and 'ping' are supported for this mode");
+        }
+
+        AppViewModel model = new AppViewModel();
+        model.setPeerBluetoothAddress(peerBluetoothAddress);
+        model.setUse2mPhy(use_2m_phy);
+        model.setSenderPacketCount(packetCount);
+        model.setSenderPacketSize(packetSize);
+        model.setSenderPacketInterval(packetInterval);
+        if (connectionPriority != null) {
+            model.setConnectionPriority(connectionPriority);
+        }
+        if (startupDelay != null) {
+            model.setStartupDelay(startupDelay);
+        }
+        Runner runner = runScenario(model, "gatt-client", scenario);
+        assert runner != null;
+        return runner.toJson();
+    }
+
+    @Rpc(description = "Run a scenario in GATT Server mode")
+    public JSONObject runGattServer(String scenario,
+                                    @RpcOptional Integer startupDelay) throws JSONException {
+        // We only support "receive" and "pong" for this mode for now
+        if (!(scenario.equals("receive") || scenario.equals("pong"))) {
+            throw new InvalidParameterException(
+                    "only 'receive' and 'pong' are supported for this mode");
+        }
+
+        AppViewModel model = new AppViewModel();
+        if (startupDelay != null) {
+            model.setStartupDelay(startupDelay);
+        }
+
+        Runner runner = runScenario(model, "gatt-server", scenario);
+        assert runner != null;
+        return runner.toJson();
+    }
+
+    @Rpc(description = "Stop a Runner")
+    public JSONObject stopRunner(String runnerId) throws JSONException {
+        Runner runner = findRunner(runnerId);
+        if (runner == null) {
+            return new JSONObject();
+        }
+        runner.stop();
+        return runner.toJson();
+    }
+
+    @Rpc(description = "Wait for a Runner to complete")
+    public JSONObject waitForRunnerCompletion(String runnerId) throws JSONException {
+        Runner runner = findRunner(runnerId);
+        if (runner == null) {
+            return new JSONObject();
+        }
+        runner.waitForCompletion();
+        return runner.toJson();
+    }
+
+    @Rpc(description = "Get a Runner by ID")
+    public JSONObject getRunner(String runnerId) throws JSONException {
+        Runner runner = findRunner(runnerId);
+        if (runner == null) {
+            return new JSONObject();
+        }
+        return runner.toJson();
+    }
+
+    @Rpc(description = "Get all Runners")
+    public JSONObject getRunners() throws JSONException {
+        JSONObject result = new JSONObject();
+        JSONArray runners = new JSONArray();
+        result.put("runners", runners);
+        for (Runner runner : mRunners) {
+            runners.put(runner.toJson());
+        }
+
+        return result;
+    }
+
+    @Override
+    public void shutdown() {
+    }
+}
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Connection.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Connection.kt
new file mode 100644
index 0000000..df46521
--- /dev/null
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Connection.kt
@@ -0,0 +1,109 @@
+package com.github.google.bumble.btbench
+
+import android.annotation.SuppressLint
+import android.bluetooth.BluetoothAdapter
+import android.bluetooth.BluetoothDevice
+import android.bluetooth.BluetoothGatt
+import android.bluetooth.BluetoothGattCallback
+import android.bluetooth.BluetoothManager
+import android.bluetooth.BluetoothProfile
+import android.content.Context
+import android.os.Build
+import androidx.core.content.ContextCompat
+import java.util.logging.Logger
+
+private val Log = Logger.getLogger("btbench.connection")
+
+open class Connection(
+    private val viewModel: AppViewModel,
+    private val bluetoothAdapter: BluetoothAdapter,
+    private val context: Context
+) : BluetoothGattCallback() {
+    var remoteDevice: BluetoothDevice? = null
+    var gatt: BluetoothGatt? = null
+
+    @SuppressLint("MissingPermission")
+    open fun connect() {
+        val addressIsPublic = viewModel.peerBluetoothAddress.endsWith("/P")
+        val address = viewModel.peerBluetoothAddress.take(17)
+        remoteDevice = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+            bluetoothAdapter.getRemoteLeDevice(
+                address,
+                if (addressIsPublic) {
+                    BluetoothDevice.ADDRESS_TYPE_PUBLIC
+                } else {
+                    BluetoothDevice.ADDRESS_TYPE_RANDOM
+                }
+            )
+        } else {
+            bluetoothAdapter.getRemoteDevice(address)
+        }
+
+        gatt = remoteDevice?.connectGatt(
+            context,
+            false,
+            this,
+            BluetoothDevice.TRANSPORT_LE,
+            if (viewModel.use2mPhy) BluetoothDevice.PHY_LE_2M_MASK else BluetoothDevice.PHY_LE_1M_MASK
+        )
+    }
+
+    @SuppressLint("MissingPermission")
+    open fun disconnect() {
+        gatt?.disconnect()
+    }
+
+    override fun onMtuChanged(gatt: BluetoothGatt, mtu: Int, status: Int) {
+        Log.info("MTU update: mtu=$mtu status=$status")
+        viewModel.mtu = mtu
+    }
+
+    override fun onPhyUpdate(gatt: BluetoothGatt, txPhy: Int, rxPhy: Int, status: Int) {
+        Log.info("PHY update: tx=$txPhy, rx=$rxPhy, status=$status")
+        viewModel.txPhy = txPhy
+        viewModel.rxPhy = rxPhy
+    }
+
+    override fun onPhyRead(gatt: BluetoothGatt, txPhy: Int, rxPhy: Int, status: Int) {
+        Log.info("PHY: tx=$txPhy, rx=$rxPhy, status=$status")
+        viewModel.txPhy = txPhy
+        viewModel.rxPhy = rxPhy
+    }
+
+    @SuppressLint("MissingPermission")
+    override fun onConnectionStateChange(
+        gatt: BluetoothGatt?, status: Int, newState: Int
+    ) {
+        if (status != BluetoothGatt.GATT_SUCCESS) {
+            Log.warning("onConnectionStateChange status=$status")
+        }
+
+        if (gatt != null && newState == BluetoothProfile.STATE_CONNECTED) {
+            if (viewModel.use2mPhy) {
+                Log.info("requesting 2M PHY")
+                gatt.setPreferredPhy(
+                    BluetoothDevice.PHY_LE_2M_MASK,
+                    BluetoothDevice.PHY_LE_2M_MASK,
+                    BluetoothDevice.PHY_OPTION_NO_PREFERRED
+                )
+            }
+            gatt.readPhy()
+
+            // Request an MTU update, even though we don't use GATT, because Android
+            // won't request a larger link layer maximum data length otherwise.
+            gatt.requestMtu(517)
+
+            // Request a specific connection priority
+            val connectionPriority = when (viewModel.connectionPriority) {
+                "BALANCED" -> BluetoothGatt.CONNECTION_PRIORITY_BALANCED
+                "LOW_POWER" -> BluetoothGatt.CONNECTION_PRIORITY_LOW_POWER
+                "HIGH" -> BluetoothGatt.CONNECTION_PRIORITY_HIGH
+                "DCK" -> BluetoothGatt.CONNECTION_PRIORITY_DCK
+                else -> 0
+            }
+            if (!gatt.requestConnectionPriority(connectionPriority)) {
+                Log.warning("requestConnectionPriority failed")
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Gatt.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Gatt.kt
new file mode 100644
index 0000000..126c5bc
--- /dev/null
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Gatt.kt
@@ -0,0 +1,23 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.github.google.bumble.btbench
+
+import java.util.UUID
+
+var CCCD_UUID = UUID.fromString("00002902-0000-1000-8000-00805F9B34FB")
+
+val BENCH_SERVICE_UUID = UUID.fromString("50DB505C-8AC4-4738-8448-3B1D9CC09CC5")
+val BENCH_TX_UUID = UUID.fromString("E789C754-41A1-45F4-A948-A0A1A90DBA53")
+val BENCH_RX_UUID = UUID.fromString("016A2CC7-E14B-4819-935F-1F56EAE4098D")
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/GattClient.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/GattClient.kt
new file mode 100644
index 0000000..fe7080e
--- /dev/null
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/GattClient.kt
@@ -0,0 +1,224 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.github.google.bumble.btbench
+
+import android.annotation.SuppressLint
+import android.bluetooth.BluetoothAdapter
+import android.bluetooth.BluetoothGatt
+import android.bluetooth.BluetoothGattCharacteristic
+import android.bluetooth.BluetoothGattDescriptor
+import android.bluetooth.BluetoothProfile
+import android.content.Context
+import java.io.IOException
+import java.util.UUID
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.Semaphore
+import java.util.logging.Logger
+import kotlin.concurrent.thread
+
+private val Log = Logger.getLogger("btbench.gatt-client")
+
+
+class GattClientConnection(
+    viewModel: AppViewModel,
+    bluetoothAdapter: BluetoothAdapter,
+    context: Context
+) : Connection(viewModel, bluetoothAdapter, context), PacketIO {
+    override var packetSink: PacketSink? = null
+    private val discoveryDone: CountDownLatch = CountDownLatch(1)
+    private val writeSemaphore: Semaphore = Semaphore(1)
+    var rxCharacteristic: BluetoothGattCharacteristic? = null
+    var txCharacteristic: BluetoothGattCharacteristic? = null
+
+    override fun connect() {
+        super.connect()
+
+        // Check if we're already connected and have discovered the services
+        if (gatt?.getService(BENCH_SERVICE_UUID) != null) {
+            Log.fine("already connected")
+            onServicesDiscovered(gatt, BluetoothGatt.GATT_SUCCESS)
+        }
+    }
+
+    @SuppressLint("MissingPermission")
+    override fun onConnectionStateChange(
+        gatt: BluetoothGatt?, status: Int, newState: Int
+    ) {
+        super.onConnectionStateChange(gatt, status, newState)
+        if (status != BluetoothGatt.GATT_SUCCESS) {
+            Log.warning("onConnectionStateChange status=$status")
+            discoveryDone.countDown()
+            return
+        }
+        if (gatt != null && newState == BluetoothProfile.STATE_CONNECTED) {
+            if (!gatt.discoverServices()) {
+                Log.warning("discoverServices could not start")
+                discoveryDone.countDown()
+            }
+        }
+    }
+
+    @SuppressLint("MissingPermission")
+    override fun onServicesDiscovered(gatt: BluetoothGatt?, status: Int) {
+        Log.fine("onServicesDiscovered")
+
+        if (status != BluetoothGatt.GATT_SUCCESS) {
+            Log.warning("failed to discover services: ${status}")
+            discoveryDone.countDown()
+            return
+        }
+
+        // Find the service
+        val service = gatt!!.getService(BENCH_SERVICE_UUID)
+        if (service == null) {
+            Log.warning("GATT Service not found")
+            discoveryDone.countDown()
+            return
+        }
+
+        // Find the RX and TX characteristics
+        rxCharacteristic = service.getCharacteristic(BENCH_RX_UUID)
+        if (rxCharacteristic == null) {
+            Log.warning("GATT RX Characteristics not found")
+            discoveryDone.countDown()
+            return
+        }
+        txCharacteristic = service.getCharacteristic(BENCH_TX_UUID)
+        if (txCharacteristic == null) {
+            Log.warning("GATT TX Characteristics not found")
+            discoveryDone.countDown()
+            return
+        }
+
+        // Subscribe to the RX characteristic
+        Log.fine("subscribing to RX")
+        gatt.setCharacteristicNotification(rxCharacteristic, true)
+        val cccdDescriptor = rxCharacteristic!!.getDescriptor(CCCD_UUID)
+        gatt.writeDescriptor(cccdDescriptor, BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
+
+        Log.info("GATT discovery complete")
+        discoveryDone.countDown()
+    }
+
+    override fun onCharacteristicWrite(
+        gatt: BluetoothGatt?,
+        characteristic: BluetoothGattCharacteristic?,
+        status: Int
+    ) {
+        // Now we can write again
+        writeSemaphore.release()
+
+        if (status != BluetoothGatt.GATT_SUCCESS) {
+            Log.warning("onCharacteristicWrite failed: $status")
+            return
+        }
+    }
+
+    override fun onCharacteristicChanged(
+        gatt: BluetoothGatt,
+        characteristic: BluetoothGattCharacteristic,
+        value: ByteArray
+    ) {
+        if (characteristic.uuid == BENCH_RX_UUID && packetSink != null) {
+            val packet = Packet.from(value)
+            packetSink!!.onPacket(packet)
+        }
+    }
+
+    @SuppressLint("MissingPermission")
+    override fun sendPacket(packet: Packet) {
+        if (txCharacteristic == null) {
+            Log.warning("No TX characteristic, dropping")
+            return
+        }
+
+        // Wait until we can write
+        writeSemaphore.acquire()
+
+        // Write the data
+        val data = packet.toBytes()
+        val clampedData = if (data.size > 512) {
+            // Clamp the data to the maximum allowed characteristic data size
+            data.copyOf(512)
+        } else {
+            data
+        }
+        gatt?.writeCharacteristic(
+            txCharacteristic!!,
+            clampedData,
+            BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE
+        )
+    }
+
+    override
+    fun disconnect() {
+        super.disconnect()
+        discoveryDone.countDown()
+    }
+
+    fun waitForDiscoveryCompletion() {
+        discoveryDone.await()
+    }
+}
+
+class GattClient(
+    private val viewModel: AppViewModel,
+    bluetoothAdapter: BluetoothAdapter,
+    context: Context,
+    private val createIoClient: (packetIo: PacketIO) -> IoClient
+) : Mode {
+    private var connection: GattClientConnection =
+        GattClientConnection(viewModel, bluetoothAdapter, context)
+    private var clientThread: Thread? = null
+
+    @SuppressLint("MissingPermission")
+    override fun run() {
+        viewModel.running = true
+
+        clientThread = thread(name = "GattClient") {
+            connection.connect()
+
+            viewModel.aborter = {
+                connection.disconnect()
+            }
+
+            // Discover the rx and tx characteristics
+            connection.waitForDiscoveryCompletion()
+            if (connection.rxCharacteristic == null || connection.txCharacteristic == null) {
+                connection.disconnect()
+                viewModel.running = false
+                return@thread
+            }
+
+            val ioClient = createIoClient(connection)
+
+            try {
+                ioClient.run()
+                viewModel.status = "OK"
+            } catch (error: IOException) {
+                Log.info("run ended abruptly")
+                viewModel.status = "ABORTED"
+                viewModel.lastError = "IO_ERROR"
+            } finally {
+                connection.disconnect()
+                viewModel.running = false
+            }
+        }
+    }
+
+    override fun waitForCompletion() {
+        clientThread?.join()
+    }
+}
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/GattServer.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/GattServer.kt
new file mode 100644
index 0000000..a4a024c
--- /dev/null
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/GattServer.kt
@@ -0,0 +1,246 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.github.google.bumble.btbench
+
+import android.annotation.SuppressLint
+import android.bluetooth.BluetoothAdapter
+import android.bluetooth.BluetoothDevice
+import android.bluetooth.BluetoothGatt
+import android.bluetooth.BluetoothGattCharacteristic
+import android.bluetooth.BluetoothGattDescriptor
+import android.bluetooth.BluetoothGattServer
+import android.bluetooth.BluetoothGattServerCallback
+import android.bluetooth.BluetoothGattService
+import android.bluetooth.BluetoothManager
+import android.bluetooth.BluetoothStatusCodes
+import android.content.Context
+import android.os.Build
+import androidx.annotation.RequiresApi
+import androidx.core.content.ContextCompat
+import java.io.IOException
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.LinkedBlockingQueue
+import java.util.concurrent.Semaphore
+import java.util.logging.Logger
+import kotlin.concurrent.thread
+import kotlin.experimental.and
+
+private val Log = Logger.getLogger("btbench.gatt-server")
+
+@SuppressLint("MissingPermission")
+class GattServer(
+    private val viewModel: AppViewModel,
+    private val bluetoothAdapter: BluetoothAdapter,
+    context: Context,
+    private val createIoClient: (packetIo: PacketIO) -> IoClient
+) : Mode, PacketIO, BluetoothGattServerCallback() {
+    override var packetSink: PacketSink? = null
+    private val gattServer: BluetoothGattServer
+    private val rxCharacteristic: BluetoothGattCharacteristic?
+    private val txCharacteristic: BluetoothGattCharacteristic?
+    private val notifySemaphore: Semaphore = Semaphore(1)
+    private val ready: CountDownLatch = CountDownLatch(1)
+    private var peerDevice: BluetoothDevice? = null
+    private var clientThread: Thread? = null
+    private var sinkQueue: LinkedBlockingQueue<Packet>? = null
+
+    init {
+        val bluetoothManager = ContextCompat.getSystemService(context, BluetoothManager::class.java)
+        gattServer = bluetoothManager!!.openGattServer(context, this)
+        val benchService = gattServer.getService(BENCH_SERVICE_UUID)
+        if (benchService == null) {
+            rxCharacteristic = BluetoothGattCharacteristic(
+                BENCH_RX_UUID,
+                BluetoothGattCharacteristic.PROPERTY_NOTIFY,
+                0
+            )
+            txCharacteristic = BluetoothGattCharacteristic(
+                BENCH_TX_UUID,
+                BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE,
+                BluetoothGattCharacteristic.PERMISSION_WRITE
+            )
+            val rxCCCD = BluetoothGattDescriptor(
+                CCCD_UUID,
+                BluetoothGattDescriptor.PERMISSION_READ or BluetoothGattDescriptor.PERMISSION_WRITE
+            )
+            rxCharacteristic.addDescriptor(rxCCCD)
+
+            val service =
+                BluetoothGattService(BENCH_SERVICE_UUID, BluetoothGattService.SERVICE_TYPE_PRIMARY)
+            service.addCharacteristic(rxCharacteristic)
+            service.addCharacteristic(txCharacteristic)
+
+            gattServer.addService(service)
+        } else {
+            rxCharacteristic = benchService.getCharacteristic(BENCH_RX_UUID)
+            txCharacteristic = benchService.getCharacteristic(BENCH_TX_UUID)
+        }
+    }
+
+    override fun onCharacteristicWriteRequest(
+        device: BluetoothDevice?,
+        requestId: Int,
+        characteristic: BluetoothGattCharacteristic?,
+        preparedWrite: Boolean,
+        responseNeeded: Boolean,
+        offset: Int,
+        value: ByteArray?
+    ) {
+        Log.info("onCharacteristicWriteRequest")
+        if (characteristic != null && characteristic.uuid == BENCH_TX_UUID) {
+            if (packetSink == null) {
+                Log.warning("no sink, dropping")
+            } else if (offset != 0) {
+                Log.warning("offset != 0")
+            } else if (value == null) {
+                Log.warning("no value")
+            } else {
+                // Deliver the packet in a separate thread so that we don't block this
+                // callback.
+                sinkQueue?.put(Packet.from(value))
+            }
+        }
+
+        if (responseNeeded) {
+            gattServer.sendResponse(device, requestId, BluetoothGatt.GATT_SUCCESS, offset, value)
+        }
+    }
+
+    override fun onNotificationSent(device: BluetoothDevice?, status: Int) {
+        if (status == BluetoothGatt.GATT_SUCCESS) {
+            notifySemaphore.release()
+        }
+    }
+
+    override fun onDescriptorWriteRequest(
+        device: BluetoothDevice?,
+        requestId: Int,
+        descriptor: BluetoothGattDescriptor?,
+        preparedWrite: Boolean,
+        responseNeeded: Boolean,
+        offset: Int,
+        value: ByteArray?
+    ) {
+        if (descriptor?.uuid == CCCD_UUID && descriptor?.characteristic?.uuid == BENCH_RX_UUID) {
+            if (offset == 0 && value?.size == 2) {
+                if (value[0].and(1).toInt() != 0) {
+                    // Subscription
+                    Log.fine("peer subscribed to RX")
+                    peerDevice = device
+                    ready.countDown()
+                }
+            }
+        }
+
+        if (responseNeeded) {
+            gattServer.sendResponse(device, requestId, BluetoothGatt.GATT_SUCCESS, offset, value)
+        }
+    }
+
+    @SuppressLint("MissingPermission")
+    override fun sendPacket(packet: Packet) {
+        if (peerDevice == null) {
+            Log.warning("no peer device, cannot send")
+            return
+        }
+        if (rxCharacteristic == null) {
+            Log.warning("no RX characteristic, cannot send")
+            return
+        }
+
+        // Wait until we can notify
+        notifySemaphore.acquire()
+
+        // Send the packet via a notification
+        val result = gattServer.notifyCharacteristicChanged(
+            peerDevice!!,
+            rxCharacteristic,
+            false,
+            packet.toBytes()
+        )
+        if (result != BluetoothStatusCodes.SUCCESS) {
+            Log.warning("notifyCharacteristicChanged failed: $result")
+            notifySemaphore.release()
+        }
+    }
+
+    @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    override fun run() {
+        viewModel.running = true
+
+        // Start advertising
+        Log.fine("starting advertiser")
+        val advertiser = Advertiser(bluetoothAdapter)
+        advertiser.start()
+
+        clientThread = thread(name = "GattServer") {
+            // Wait for a subscriber
+            Log.info("waiting for RX subscriber")
+            viewModel.aborter = {
+                ready.countDown()
+            }
+            ready.await()
+            if (peerDevice == null) {
+                Log.warning("server interrupted")
+                viewModel.running = false
+                gattServer.close()
+                return@thread
+            }
+            Log.info("RX subscriber accepted")
+
+            // Stop advertising
+            Log.info("stopping advertiser")
+            advertiser.stop()
+
+            sinkQueue = LinkedBlockingQueue()
+            val sinkWriterThread = thread(name = "SinkWriter") {
+                while (true) {
+                    try {
+                        val packet = sinkQueue!!.take()
+                        if (packetSink == null) {
+                            Log.warning("no sink, dropping packet")
+                            continue
+                        }
+                        packetSink!!.onPacket(packet)
+                    } catch (error: InterruptedException) {
+                        Log.warning("sink writer interrupted")
+                        break
+                    }
+                }
+            }
+
+            val ioClient = createIoClient(this)
+
+            try {
+                ioClient.run()
+                viewModel.status = "OK"
+            } catch (error: IOException) {
+                Log.info("run ended abruptly")
+                viewModel.status = "ABORTED"
+                viewModel.lastError = "IO_ERROR"
+            } finally {
+                sinkWriterThread.interrupt()
+                sinkWriterThread.join()
+                gattServer.close()
+                viewModel.running = false
+            }
+        }
+    }
+
+    override fun waitForCompletion() {
+        clientThread?.join()
+        Log.info("server thread completed")
+    }
+}
\ No newline at end of file
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/IoClient.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/IoClient.kt
new file mode 100644
index 0000000..77dcc42
--- /dev/null
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/IoClient.kt
@@ -0,0 +1,20 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.github.google.bumble.btbench
+
+interface IoClient {
+    fun run()
+    fun abort()
+}
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/L2capClient.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/L2capClient.kt
index 95cdae6..1049411 100644
--- a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/L2capClient.kt
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/L2capClient.kt
@@ -16,86 +16,30 @@ package com.github.google.bumble.btbench
 
 import android.annotation.SuppressLint
 import android.bluetooth.BluetoothAdapter
-import android.bluetooth.BluetoothDevice
-import android.bluetooth.BluetoothGatt
-import android.bluetooth.BluetoothGattCallback
-import android.bluetooth.BluetoothProfile
 import android.content.Context
-import android.os.Build
 import java.util.logging.Logger
 
 private val Log = Logger.getLogger("btbench.l2cap-client")
 
 class L2capClient(
     private val viewModel: AppViewModel,
-    private val bluetoothAdapter: BluetoothAdapter,
-    private val context: Context
-) {
+    bluetoothAdapter: BluetoothAdapter,
+    context: Context,
+    private val createIoClient: (packetIo: PacketIO) -> IoClient
+) : Mode {
+    private var connection: Connection = Connection(viewModel, bluetoothAdapter, context)
+    private var socketClient: SocketClient? = null
+
     @SuppressLint("MissingPermission")
-    fun run() {
+    override fun run() {
         viewModel.running = true
-        val addressIsPublic = viewModel.peerBluetoothAddress.endsWith("/P")
-        val address = viewModel.peerBluetoothAddress.take(17)
-        val remoteDevice = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
-            bluetoothAdapter.getRemoteLeDevice(
-                address,
-                if (addressIsPublic) {
-                    BluetoothDevice.ADDRESS_TYPE_PUBLIC
-                } else {
-                    BluetoothDevice.ADDRESS_TYPE_RANDOM
-                }
-            )
-        } else {
-            bluetoothAdapter.getRemoteDevice(address)
-        }
-
-        val gatt = remoteDevice.connectGatt(
-            context,
-            false,
-            object : BluetoothGattCallback() {
-                override fun onMtuChanged(gatt: BluetoothGatt, mtu: Int, status: Int) {
-                    Log.info("MTU update: mtu=$mtu status=$status")
-                    viewModel.mtu = mtu
-                }
-
-                override fun onPhyUpdate(gatt: BluetoothGatt, txPhy: Int, rxPhy: Int, status: Int) {
-                    Log.info("PHY update: tx=$txPhy, rx=$rxPhy, status=$status")
-                    viewModel.txPhy = txPhy
-                    viewModel.rxPhy = rxPhy
-                }
-
-                override fun onPhyRead(gatt: BluetoothGatt, txPhy: Int, rxPhy: Int, status: Int) {
-                    Log.info("PHY: tx=$txPhy, rx=$rxPhy, status=$status")
-                    viewModel.txPhy = txPhy
-                    viewModel.rxPhy = rxPhy
-                }
-
-                override fun onConnectionStateChange(
-                    gatt: BluetoothGatt?, status: Int, newState: Int
-                ) {
-                    if (gatt != null && newState == BluetoothProfile.STATE_CONNECTED) {
-                        if (viewModel.use2mPhy) {
-                            gatt.setPreferredPhy(
-                                BluetoothDevice.PHY_LE_2M_MASK,
-                                BluetoothDevice.PHY_LE_2M_MASK,
-                                BluetoothDevice.PHY_OPTION_NO_PREFERRED
-                            )
-                        }
-                        gatt.readPhy()
-
-                        // Request an MTU update, even though we don't use GATT, because Android
-                        // won't request a larger link layer maximum data length otherwise.
-                        gatt.requestMtu(517)
-                    }
-                }
-            },
-            BluetoothDevice.TRANSPORT_LE,
-            if (viewModel.use2mPhy) BluetoothDevice.PHY_LE_2M_MASK else BluetoothDevice.PHY_LE_1M_MASK
-        )
-
-        val socket = remoteDevice.createInsecureL2capChannel(viewModel.l2capPsm)
+        connection.connect()
+        val socket = connection.remoteDevice!!.createInsecureL2capChannel(viewModel.l2capPsm)
+        socketClient = SocketClient(viewModel, socket, createIoClient)
+        socketClient!!.run()
+    }
 
-        val client = SocketClient(viewModel, socket)
-        client.run()
+    override fun waitForCompletion() {
+        socketClient?.waitForCompletion()
     }
-}
\ No newline at end of file
+}
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/L2capServer.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/L2capServer.kt
index 76c297b..3bfc5c1 100644
--- a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/L2capServer.kt
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/L2capServer.kt
@@ -16,46 +16,36 @@ package com.github.google.bumble.btbench
 
 import android.annotation.SuppressLint
 import android.bluetooth.BluetoothAdapter
-import android.bluetooth.le.AdvertiseCallback
-import android.bluetooth.le.AdvertiseData
-import android.bluetooth.le.AdvertiseSettings
-import android.bluetooth.le.AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY
 import android.os.Build
-import java.io.IOException
+import androidx.annotation.RequiresApi
 import java.util.logging.Logger
-import kotlin.concurrent.thread
 
 private val Log = Logger.getLogger("btbench.l2cap-server")
 
-class L2capServer(private val viewModel: AppViewModel, private val bluetoothAdapter: BluetoothAdapter) {
+class L2capServer(
+    private val viewModel: AppViewModel,
+    private val bluetoothAdapter: BluetoothAdapter,
+    private val createIoClient: (packetIo: PacketIO) -> IoClient
+) : Mode {
+    private var socketServer: SocketServer? = null
+
+    @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
     @SuppressLint("MissingPermission")
-    fun run() {
+    override fun run() {
         // Advertise so that the peer can find us and connect.
-        val callback = object: AdvertiseCallback() {
-            override fun onStartFailure(errorCode: Int) {
-                Log.warning("failed to start advertising: $errorCode")
-            }
-
-            override fun onStartSuccess(settingsInEffect: AdvertiseSettings) {
-                Log.info("advertising started: $settingsInEffect")
-            }
-        }
-        val advertiseSettingsBuilder = AdvertiseSettings.Builder()
-            .setAdvertiseMode(ADVERTISE_MODE_LOW_LATENCY)
-            .setConnectable(true)
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
-            advertiseSettingsBuilder.setDiscoverable(true)
-        }
-        val advertiseSettings = advertiseSettingsBuilder.build()
-        val advertiseData = AdvertiseData.Builder().build()
-        val scanData = AdvertiseData.Builder().setIncludeDeviceName(true).build()
-        val advertiser = bluetoothAdapter.bluetoothLeAdvertiser
-
+        val advertiser = Advertiser(bluetoothAdapter)
         val serverSocket = bluetoothAdapter.listenUsingInsecureL2capChannel()
         viewModel.l2capPsm = serverSocket.psm
         Log.info("psm = $serverSocket.psm")
 
-        val server = SocketServer(viewModel, serverSocket)
-        server.run({ advertiser.stopAdvertising(callback) }, { advertiser.startAdvertising(advertiseSettings, advertiseData, scanData, callback) })
+        socketServer = SocketServer(viewModel, serverSocket, createIoClient)
+        socketServer!!.run(
+            { advertiser.stop() },
+            { advertiser.start() }
+        )
+    }
+
+    override fun waitForCompletion() {
+        socketServer?.waitForCompletion()
     }
-}
\ No newline at end of file
+}
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/MainActivity.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/MainActivity.kt
index dea3e3c..7b1fb4d 100644
--- a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/MainActivity.kt
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/MainActivity.kt
@@ -17,9 +17,12 @@ package com.github.google.bumble.btbench
 import android.Manifest
 import android.annotation.SuppressLint
 import android.bluetooth.BluetoothAdapter
+import android.bluetooth.BluetoothDevice
 import android.bluetooth.BluetoothManager
+import android.content.BroadcastReceiver
 import android.content.Context
 import android.content.Intent
+import android.content.IntentFilter
 import android.content.pm.PackageManager
 import android.os.Build
 import android.os.Bundle
@@ -34,12 +37,15 @@ import androidx.compose.foundation.layout.fillMaxSize
 import androidx.compose.foundation.layout.fillMaxWidth
 import androidx.compose.foundation.layout.padding
 import androidx.compose.foundation.rememberScrollState
+import androidx.compose.foundation.selection.selectable
+import androidx.compose.foundation.selection.selectableGroup
 import androidx.compose.foundation.text.KeyboardActions
 import androidx.compose.foundation.text.KeyboardOptions
 import androidx.compose.foundation.verticalScroll
 import androidx.compose.material3.Button
 import androidx.compose.material3.Divider
 import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.RadioButton
 import androidx.compose.material3.Slider
 import androidx.compose.material3.Surface
 import androidx.compose.material3.Switch
@@ -54,6 +60,7 @@ import androidx.compose.ui.focus.FocusRequester
 import androidx.compose.ui.focus.focusRequester
 import androidx.compose.ui.platform.LocalFocusManager
 import androidx.compose.ui.platform.LocalSoftwareKeyboardController
+import androidx.compose.ui.semantics.Role
 import androidx.compose.ui.text.font.FontWeight
 import androidx.compose.ui.text.input.ImeAction
 import androidx.compose.ui.text.input.KeyboardType
@@ -62,6 +69,7 @@ import androidx.compose.ui.unit.dp
 import androidx.compose.ui.unit.sp
 import androidx.core.content.ContextCompat
 import com.github.google.bumble.btbench.ui.theme.BTBenchTheme
+import java.io.IOException
 import java.util.logging.Logger
 
 private val Log = Logger.getLogger("bumble.main-activity")
@@ -69,6 +77,10 @@ private val Log = Logger.getLogger("bumble.main-activity")
 const val PEER_BLUETOOTH_ADDRESS_PREF_KEY = "peer_bluetooth_address"
 const val SENDER_PACKET_COUNT_PREF_KEY = "sender_packet_count"
 const val SENDER_PACKET_SIZE_PREF_KEY = "sender_packet_size"
+const val SENDER_PACKET_INTERVAL_PREF_KEY = "sender_packet_interval"
+const val SCENARIO_PREF_KEY = "scenario"
+const val MODE_PREF_KEY = "mode"
+const val CONNECTION_PRIORITY_PREF_KEY = "connection_priority"
 
 class MainActivity : ComponentActivity() {
     private val appViewModel = AppViewModel()
@@ -77,6 +89,47 @@ class MainActivity : ComponentActivity() {
         super.onCreate(savedInstanceState)
         appViewModel.loadPreferences(getPreferences(Context.MODE_PRIVATE))
         checkPermissions()
+        registerReceivers()
+    }
+
+    private fun registerReceivers() {
+        val pairingRequestIntentFilter = IntentFilter(BluetoothDevice.ACTION_PAIRING_REQUEST)
+        registerReceiver(object: BroadcastReceiver() {
+            @SuppressLint("MissingPermission")
+            override fun onReceive(context: Context, intent: Intent) {
+                Log.info("ACTION_PAIRING_REQUEST")
+                val extras = intent.extras
+                if (extras != null) {
+                    for (key in extras.keySet()) {
+                        Log.info("$key: ${extras.get(key)}")
+                    }
+                }
+                val device: BluetoothDevice? = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)
+                if (device != null) {
+                    if (checkSelfPermission(Manifest.permission.BLUETOOTH_PRIVILEGED) == PackageManager.PERMISSION_GRANTED) {
+                        Log.info("confirming pairing")
+                        device.setPairingConfirmation(true)
+                    } else {
+                        Log.info("we don't have BLUETOOTH_PRIVILEGED, not confirming")
+                    }
+                }
+
+            }
+        }, pairingRequestIntentFilter)
+
+        val bondStateChangedIntentFilter = IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED)
+        registerReceiver(object: BroadcastReceiver() {
+            @SuppressLint("MissingPermission")
+            override fun onReceive(context: Context, intent: Intent) {
+                Log.info("ACTION_BOND_STATE_CHANGED")
+                val extras = intent.extras
+                if (extras != null) {
+                    for (key in extras.keySet()) {
+                        Log.info("$key: ${extras.get(key)}")
+                    }
+                }
+            }
+        }, bondStateChangedIntentFilter)
     }
 
     private fun checkPermissions() {
@@ -137,12 +190,7 @@ class MainActivity : ComponentActivity() {
         initBluetooth()
         setContent {
             MainView(
-                appViewModel,
-                ::becomeDiscoverable,
-                ::runRfcommClient,
-                ::runRfcommServer,
-                ::runL2capClient,
-                ::runL2capServer,
+                appViewModel, ::becomeDiscoverable, ::runScenario
             )
         }
 
@@ -159,37 +207,61 @@ class MainActivity : ComponentActivity() {
         if (packetSize > 0) {
             appViewModel.senderPacketSize = packetSize
         }
+        val packetInterval = intent.getIntExtra("packet-interval", 0)
+        if (packetInterval > 0) {
+            appViewModel.senderPacketInterval = packetInterval
+        }
         appViewModel.updateSenderPacketSizeSlider()
+        intent.getStringExtra("scenario")?.let {
+            when (it) {
+                "send" -> appViewModel.scenario = SEND_SCENARIO
+                "receive" -> appViewModel.scenario = RECEIVE_SCENARIO
+                "ping" -> appViewModel.scenario = PING_SCENARIO
+                "pong" -> appViewModel.scenario = PONG_SCENARIO
+            }
+        }
+        intent.getStringExtra("mode")?.let {
+            when (it) {
+                "rfcomm-client" -> appViewModel.mode = RFCOMM_CLIENT_MODE
+                "rfcomm-server" -> appViewModel.mode = RFCOMM_SERVER_MODE
+                "l2cap-client" -> appViewModel.mode = L2CAP_CLIENT_MODE
+                "l2cap-server" -> appViewModel.mode = L2CAP_SERVER_MODE
+                "gatt-client" -> appViewModel.mode = GATT_CLIENT_MODE
+                "gatt-server" -> appViewModel.mode = GATT_SERVER_MODE
+            }
+        }
         intent.getStringExtra("autostart")?.let {
             when (it) {
-                "rfcomm-client" -> runRfcommClient()
-                "rfcomm-server" -> runRfcommServer()
-                "l2cap-client" -> runL2capClient()
-                "l2cap-server" -> runL2capServer()
+                "run-scenario" -> runScenario()
                 "scan-start" -> runScan(true)
                 "stop-start" -> runScan(false)
             }
         }
     }
 
-    private fun runRfcommClient() {
-        val rfcommClient = bluetoothAdapter?.let { RfcommClient(appViewModel, it) }
-        rfcommClient?.run()
-    }
+    private fun runScenario() {
+        if (bluetoothAdapter == null) {
+            throw IOException("bluetooth not enabled")
+        }
 
-    private fun runRfcommServer() {
-        val rfcommServer = bluetoothAdapter?.let { RfcommServer(appViewModel, it) }
-        rfcommServer?.run()
-    }
+        val runner = when (appViewModel.mode) {
+            RFCOMM_CLIENT_MODE -> RfcommClient(appViewModel, bluetoothAdapter!!, ::createIoClient)
+            RFCOMM_SERVER_MODE -> RfcommServer(appViewModel, bluetoothAdapter!!, ::createIoClient)
+            L2CAP_CLIENT_MODE -> L2capClient(
+                appViewModel, bluetoothAdapter!!, baseContext, ::createIoClient
+            )
 
-    private fun runL2capClient() {
-        val l2capClient = bluetoothAdapter?.let { L2capClient(appViewModel, it, baseContext) }
-        l2capClient?.run()
-    }
+            L2CAP_SERVER_MODE -> L2capServer(appViewModel, bluetoothAdapter!!, ::createIoClient)
+            GATT_CLIENT_MODE -> GattClient(
+                appViewModel, bluetoothAdapter!!, baseContext, ::createIoClient
+            )
+            GATT_SERVER_MODE -> GattServer(
+                appViewModel, bluetoothAdapter!!, baseContext, ::createIoClient
+            )
 
-    private fun runL2capServer() {
-        val l2capServer = bluetoothAdapter?.let { L2capServer(appViewModel, it) }
-        l2capServer?.run()
+            else -> throw IllegalStateException()
+        }
+        runner.run()
     }
 
     private fun runScan(startScan: Boolean) {
@@ -197,6 +269,17 @@ class MainActivity : ComponentActivity() {
         scan?.run(startScan)
     }
 
+    private fun createIoClient(packetIo: PacketIO): IoClient {
+        return when (appViewModel.scenario) {
+            SEND_SCENARIO -> Sender(appViewModel, packetIo)
+            RECEIVE_SCENARIO -> Receiver(appViewModel, packetIo)
+            PING_SCENARIO -> Pinger(appViewModel, packetIo)
+            PONG_SCENARIO -> Ponger(appViewModel, packetIo)
+            else -> throw IllegalStateException()
+        }
+    }
+
+
     @SuppressLint("MissingPermission")
     fun becomeDiscoverable() {
         val discoverableIntent = Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE)
@@ -210,10 +293,7 @@ class MainActivity : ComponentActivity() {
 fun MainView(
     appViewModel: AppViewModel,
     becomeDiscoverable: () -> Unit,
-    runRfcommClient: () -> Unit,
-    runRfcommServer: () -> Unit,
-    runL2capClient: () -> Unit,
-    runL2capServer: () -> Unit,
+    runScenario: () -> Unit,
 ) {
     BTBenchTheme {
         val scrollState = rememberScrollState()
@@ -239,7 +319,9 @@ fun MainView(
                         Text(text = "Peer Bluetooth Address")
                     },
                     value = appViewModel.peerBluetoothAddress,
-                    modifier = Modifier.fillMaxWidth().focusRequester(focusRequester),
+                    modifier = Modifier
+                        .fillMaxWidth()
+                        .focusRequester(focusRequester),
                     keyboardOptions = KeyboardOptions.Default.copy(
                         keyboardType = KeyboardType.Ascii, imeAction = ImeAction.Done
                     ),
@@ -249,14 +331,18 @@ fun MainView(
                     keyboardActions = KeyboardActions(onDone = {
                         keyboardController?.hide()
                         focusManager.clearFocus()
-                    })
+                    }),
+                    enabled = (appViewModel.mode == RFCOMM_CLIENT_MODE || appViewModel.mode == L2CAP_CLIENT_MODE || appViewModel.mode == GATT_CLIENT_MODE)
                 )
                 Divider()
-                TextField(label = {
-                    Text(text = "L2CAP PSM")
-                },
+                TextField(
+                    label = {
+                        Text(text = "L2CAP PSM")
+                    },
                     value = appViewModel.l2capPsm.toString(),
-                    modifier = Modifier.fillMaxWidth().focusRequester(focusRequester),
+                    modifier = Modifier
+                        .fillMaxWidth()
+                        .focusRequester(focusRequester),
                     keyboardOptions = KeyboardOptions.Default.copy(
                         keyboardType = KeyboardType.Number, imeAction = ImeAction.Done
                     ),
@@ -271,7 +357,8 @@ fun MainView(
                     keyboardActions = KeyboardActions(onDone = {
                         keyboardController?.hide()
                         focusManager.clearFocus()
-                    })
+                    }),
+                    enabled = (appViewModel.mode == L2CAP_CLIENT_MODE)
                 )
                 Divider()
                 Slider(
@@ -290,44 +377,158 @@ fun MainView(
                 )
                 Text(text = "Packet Size: " + appViewModel.senderPacketSize.toString())
                 Divider()
-                ActionButton(
-                    text = "Become Discoverable", onClick = becomeDiscoverable, true
+                TextField(
+                    label = {
+                        Text(text = "Packet Interval (ms)")
+                    },
+                    value = (if (appViewModel.senderPacketInterval != 0) appViewModel.senderPacketInterval else "").toString(),
+                    modifier = Modifier
+                        .fillMaxWidth()
+                        .focusRequester(focusRequester),
+                    keyboardOptions = KeyboardOptions.Default.copy(
+                        keyboardType = KeyboardType.Number, imeAction = ImeAction.Done
+                    ),
+                    onValueChange = {
+                        if (it.isEmpty()) {
+                            appViewModel.updateSenderPacketInterval(0)
+                        } else {
+                            val interval = it.toIntOrNull()
+                            if (interval != null) {
+                                appViewModel.updateSenderPacketInterval(interval)
+                            }
+                        }
+                    },
+                    keyboardActions = KeyboardActions(onDone = {
+                        keyboardController?.hide()
+                        focusManager.clearFocus()
+                    }),
+                    enabled = (appViewModel.scenario == PING_SCENARIO || appViewModel.scenario == SEND_SCENARIO)
                 )
+                Divider()
                 Row(
                     horizontalArrangement = Arrangement.SpaceBetween,
                     verticalAlignment = Alignment.CenterVertically
                 ) {
                     Text(text = "2M PHY")
                     Spacer(modifier = Modifier.padding(start = 8.dp))
-                    Switch(
+                    Switch(enabled = (appViewModel.mode == L2CAP_CLIENT_MODE || appViewModel.mode == L2CAP_SERVER_MODE || appViewModel.mode == GATT_CLIENT_MODE || appViewModel.mode == GATT_SERVER_MODE),
                         checked = appViewModel.use2mPhy,
-                        onCheckedChange = { appViewModel.use2mPhy = it }
-                    )
-
+                        onCheckedChange = { appViewModel.use2mPhy = it })
+                    Column(Modifier.selectableGroup()) {
+                        listOf(
+                            "BALANCED", "LOW", "HIGH", "DCK"
+                        ).forEach { text ->
+                            Row(
+                                Modifier
+                                    .selectable(
+                                        selected = (text == appViewModel.connectionPriority),
+                                        onClick = { appViewModel.updateConnectionPriority(text) },
+                                        role = Role.RadioButton,
+                                    )
+                                    .padding(horizontal = 16.dp),
+                                verticalAlignment = Alignment.CenterVertically
+                            ) {
+                                RadioButton(
+                                    selected = (text == appViewModel.connectionPriority),
+                                    onClick = null,
+                                    enabled = (appViewModel.mode == L2CAP_CLIENT_MODE || appViewModel.mode == L2CAP_SERVER_MODE || appViewModel.mode == GATT_CLIENT_MODE || appViewModel.mode == GATT_SERVER_MODE)
+                                )
+                                Text(
+                                    text = text,
+                                    style = MaterialTheme.typography.bodyLarge,
+                                    modifier = Modifier.padding(start = 16.dp)
+                                )
+                            }
+                        }
+                    }
                 }
                 Row {
-                    ActionButton(
-                        text = "RFCOMM Client", onClick = runRfcommClient, !appViewModel.running
-                    )
-                    ActionButton(
-                        text = "RFCOMM Server", onClick = runRfcommServer, !appViewModel.running
-                    )
+                    Column(Modifier.selectableGroup()) {
+                        listOf(
+                            RFCOMM_CLIENT_MODE,
+                            RFCOMM_SERVER_MODE,
+                            L2CAP_CLIENT_MODE,
+                            L2CAP_SERVER_MODE,
+                            GATT_CLIENT_MODE,
+                            GATT_SERVER_MODE
+                        ).forEach { text ->
+                            Row(
+                                Modifier
+                                    .selectable(
+                                        selected = (text == appViewModel.mode),
+                                        onClick = { appViewModel.updateMode(text) },
+                                        role = Role.RadioButton
+                                    )
+                                    .padding(horizontal = 16.dp),
+                                verticalAlignment = Alignment.CenterVertically
+                            ) {
+                                RadioButton(
+                                    selected = (text == appViewModel.mode), onClick = null
+                                )
+                                Text(
+                                    text = text,
+                                    style = MaterialTheme.typography.bodyLarge,
+                                    modifier = Modifier.padding(start = 16.dp)
+                                )
+                            }
+                        }
+                    }
+                    Column(Modifier.selectableGroup()) {
+                        listOf(
+                            SEND_SCENARIO, RECEIVE_SCENARIO, PING_SCENARIO, PONG_SCENARIO
+                        ).forEach { text ->
+                            Row(
+                                Modifier
+                                    .selectable(
+                                        selected = (text == appViewModel.scenario),
+                                        onClick = { appViewModel.updateScenario(text) },
+                                        role = Role.RadioButton
+                                    )
+                                    .padding(horizontal = 16.dp),
+                                verticalAlignment = Alignment.CenterVertically
+                            ) {
+                                RadioButton(
+                                    selected = (text == appViewModel.scenario), onClick = null
+                                )
+                                Text(
+                                    text = text,
+                                    style = MaterialTheme.typography.bodyLarge,
+                                    modifier = Modifier.padding(start = 16.dp)
+                                )
+                            }
+                        }
+                    }
                 }
                 Row {
                     ActionButton(
-                        text = "L2CAP Client", onClick = runL2capClient, !appViewModel.running
+                        text = "Start", onClick = runScenario, enabled = !appViewModel.running
                     )
                     ActionButton(
-                        text = "L2CAP Server", onClick = runL2capServer, !appViewModel.running
+                        text = "Stop", onClick = appViewModel::abort, enabled = appViewModel.running
+                    )
+                    ActionButton(
+                        text = "Become Discoverable", onClick = becomeDiscoverable, true
                     )
                 }
                 Divider()
+                if (appViewModel.mtu != 0) {
+                    Text(
+                        text = "MTU: ${appViewModel.mtu}"
+                    )
+                }
+                if (appViewModel.rxPhy != 0) {
+                    Text(
+                        text = "PHY: tx=${appViewModel.txPhy}, rx=${appViewModel.rxPhy}"
+                    )
+                }
                 Text(
-                    text = if (appViewModel.mtu != 0) "MTU: ${appViewModel.mtu}" else ""
-                )
-                Text(
-                    text = if (appViewModel.rxPhy != 0 || appViewModel.txPhy != 0) "PHY: tx=${appViewModel.txPhy}, rx=${appViewModel.rxPhy}" else ""
+                    text = "Status: ${appViewModel.status}"
                 )
+                if (appViewModel.lastError.isNotEmpty()) {
+                    Text(
+                        text = "Last Error: ${appViewModel.lastError}"
+                    )
+                }
                 Text(
                     text = "Packets Sent: ${appViewModel.packetsSent}"
                 )
@@ -337,9 +538,8 @@ fun MainView(
                 Text(
                     text = "Throughput: ${appViewModel.throughput}"
                 )
-                Divider()
-                ActionButton(
-                    text = "Abort", onClick = appViewModel::abort, appViewModel.running
+                Text(
+                    text = "Stats: ${appViewModel.stats}"
                 )
             }
         }
@@ -351,4 +551,4 @@ fun ActionButton(text: String, onClick: () -> Unit, enabled: Boolean) {
     Button(onClick = onClick, enabled = enabled) {
         Text(text = text)
     }
-}
\ No newline at end of file
+}
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Mode.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Mode.kt
new file mode 100644
index 0000000..3d7965c
--- /dev/null
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Mode.kt
@@ -0,0 +1,20 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.github.google.bumble.btbench
+
+interface Mode {
+    fun run()
+    fun waitForCompletion()
+}
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Model.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Model.kt
index 66ceb0d..74c81fa 100644
--- a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Model.kt
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Model.kt
@@ -25,15 +25,35 @@ import java.util.UUID
 
 val DEFAULT_RFCOMM_UUID: UUID = UUID.fromString("E6D55659-C8B4-4B85-96BB-B1143AF6D3AE")
 const val DEFAULT_PEER_BLUETOOTH_ADDRESS = "AA:BB:CC:DD:EE:FF"
+const val DEFAULT_STARTUP_DELAY = 3000
 const val DEFAULT_SENDER_PACKET_COUNT = 100
-const val DEFAULT_SENDER_PACKET_SIZE = 1024
+const val DEFAULT_SENDER_PACKET_SIZE = 970 // 970 is a value that works well on Android.
+const val DEFAULT_SENDER_PACKET_INTERVAL = 0
 const val DEFAULT_PSM = 128
 
+const val L2CAP_CLIENT_MODE = "L2CAP Client"
+const val L2CAP_SERVER_MODE = "L2CAP Server"
+const val RFCOMM_CLIENT_MODE = "RFCOMM Client"
+const val RFCOMM_SERVER_MODE = "RFCOMM Server"
+const val GATT_CLIENT_MODE = "GATT Client"
+const val GATT_SERVER_MODE = "GATT Server"
+
+const val SEND_SCENARIO = "Send"
+const val RECEIVE_SCENARIO = "Receive"
+const val PING_SCENARIO = "Ping"
+const val PONG_SCENARIO = "Pong"
+
 class AppViewModel : ViewModel() {
     private var preferences: SharedPreferences? = null
+    var status by mutableStateOf("")
+    var lastError by mutableStateOf("")
+    var mode by mutableStateOf(RFCOMM_SERVER_MODE)
+    var scenario by mutableStateOf(RECEIVE_SCENARIO)
     var peerBluetoothAddress by mutableStateOf(DEFAULT_PEER_BLUETOOTH_ADDRESS)
+    var startupDelay by mutableIntStateOf(DEFAULT_STARTUP_DELAY)
     var l2capPsm by mutableIntStateOf(DEFAULT_PSM)
     var use2mPhy by mutableStateOf(true)
+    var connectionPriority by mutableStateOf("BALANCED")
     var mtu by mutableIntStateOf(0)
     var rxPhy by mutableIntStateOf(0)
     var txPhy by mutableIntStateOf(0)
@@ -41,9 +61,11 @@ class AppViewModel : ViewModel() {
     var senderPacketSizeSlider by mutableFloatStateOf(0.0F)
     var senderPacketCount by mutableIntStateOf(DEFAULT_SENDER_PACKET_COUNT)
     var senderPacketSize by mutableIntStateOf(DEFAULT_SENDER_PACKET_SIZE)
+    var senderPacketInterval by mutableIntStateOf(DEFAULT_SENDER_PACKET_INTERVAL)
     var packetsSent by mutableIntStateOf(0)
     var packetsReceived by mutableIntStateOf(0)
     var throughput by mutableIntStateOf(0)
+    var stats by mutableStateOf("")
     var running by mutableStateOf(false)
     var aborter: (() -> Unit)? = null
 
@@ -66,6 +88,26 @@ class AppViewModel : ViewModel() {
             senderPacketSize = savedSenderPacketSize
         }
         updateSenderPacketSizeSlider()
+
+        val savedSenderPacketInterval = preferences.getInt(SENDER_PACKET_INTERVAL_PREF_KEY, -1)
+        if (savedSenderPacketInterval != -1) {
+            senderPacketInterval = savedSenderPacketInterval
+        }
+
+        val savedMode = preferences.getString(MODE_PREF_KEY, null)
+        if (savedMode != null) {
+            mode = savedMode
+        }
+
+        val savedScenario = preferences.getString(SCENARIO_PREF_KEY, null)
+        if (savedScenario != null) {
+            scenario = savedScenario
+        }
+
+        val savedConnectionPriority = preferences.getString(CONNECTION_PRIORITY_PREF_KEY, null)
+        if (savedConnectionPriority != null) {
+            connectionPriority = savedConnectionPriority
+        }
     }
 
     fun updatePeerBluetoothAddress(peerBluetoothAddress: String) {
@@ -150,7 +192,6 @@ class AppViewModel : ViewModel() {
         } else if (senderPacketSizeSlider < 0.5F) {
             512
         } else if (senderPacketSizeSlider < 0.7F) {
-            // 970 is a value that works well on Android.
             970
         } else if (senderPacketSizeSlider < 0.9F) {
             2048
@@ -164,6 +205,50 @@ class AppViewModel : ViewModel() {
         }
     }
 
+    fun updateSenderPacketInterval(senderPacketInterval: Int) {
+        this.senderPacketInterval = senderPacketInterval
+        with(preferences!!.edit()) {
+            putInt(SENDER_PACKET_INTERVAL_PREF_KEY, senderPacketInterval)
+            apply()
+        }
+    }
+
+    fun updateScenario(scenario: String) {
+        this.scenario = scenario
+        with(preferences!!.edit()) {
+            putString(SCENARIO_PREF_KEY, scenario)
+            apply()
+        }
+    }
+
+    fun updateMode(mode: String) {
+        this.mode = mode
+        with(preferences!!.edit()) {
+            putString(MODE_PREF_KEY, mode)
+            apply()
+        }
+    }
+
+    fun updateConnectionPriority(connectionPriority: String) {
+        this.connectionPriority = connectionPriority
+        with(preferences!!.edit()) {
+            putString(CONNECTION_PRIORITY_PREF_KEY, connectionPriority)
+            apply()
+        }
+    }
+
+    fun clear() {
+        status = ""
+        lastError = ""
+        mtu = 0
+        rxPhy = 0
+        txPhy = 0
+        packetsSent = 0
+        packetsReceived = 0
+        throughput = 0
+        stats = ""
+    }
+
     fun abort() {
         aborter?.let { it() }
     }
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Packet.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Packet.kt
index 0fa8500..b1cf174 100644
--- a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Packet.kt
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Packet.kt
@@ -17,6 +17,7 @@ package com.github.google.bumble.btbench
 import android.bluetooth.BluetoothSocket
 import java.io.IOException
 import java.nio.ByteBuffer
+import java.nio.ByteOrder
 import java.util.logging.Logger
 import kotlin.math.min
 
@@ -37,11 +38,16 @@ abstract class Packet(val type: Int, val payload: ByteArray = ByteArray(0)) {
                 RESET -> ResetPacket()
                 SEQUENCE -> SequencePacket(
                     data[1].toInt(),
-                    ByteBuffer.wrap(data, 2, 4).getInt(),
-                    data.sliceArray(6..<data.size)
+                    ByteBuffer.wrap(data, 2, 4).order(ByteOrder.LITTLE_ENDIAN).getInt(),
+                    ByteBuffer.wrap(data, 6, 4).order(ByteOrder.LITTLE_ENDIAN).getInt(),
+                    data.sliceArray(10..<data.size)
+                )
+
+                ACK -> AckPacket(
+                    data[1].toInt(),
+                    ByteBuffer.wrap(data, 2, 4).order(ByteOrder.LITTLE_ENDIAN).getInt()
                 )
 
-                ACK -> AckPacket(data[1].toInt(), ByteBuffer.wrap(data, 2, 4).getInt())
                 else -> GenericPacket(data[0].toInt(), data.sliceArray(1..<data.size))
             }
         }
@@ -57,16 +63,24 @@ class ResetPacket : Packet(RESET)
 
 class AckPacket(val flags: Int, val sequenceNumber: Int) : Packet(ACK) {
     override fun toBytes(): ByteArray {
-        return ByteBuffer.allocate(1 + 1 + 4).put(type.toByte()).put(flags.toByte())
+        return ByteBuffer.allocate(6).order(
+            ByteOrder.LITTLE_ENDIAN
+        ).put(type.toByte()).put(flags.toByte())
             .putInt(sequenceNumber).array()
     }
 }
 
-class SequencePacket(val flags: Int, val sequenceNumber: Int, payload: ByteArray) :
+class SequencePacket(
+    val flags: Int,
+    val sequenceNumber: Int,
+    val timestamp: Int,
+    payload: ByteArray
+) :
     Packet(SEQUENCE, payload) {
     override fun toBytes(): ByteArray {
-        return ByteBuffer.allocate(1 + 1 + 4 + payload.size).put(type.toByte()).put(flags.toByte())
-            .putInt(sequenceNumber).put(payload).array()
+        return ByteBuffer.allocate(10 + payload.size).order(ByteOrder.LITTLE_ENDIAN)
+            .put(type.toByte()).put(flags.toByte())
+            .putInt(sequenceNumber).putInt(timestamp).put(payload).array()
     }
 }
 
@@ -74,13 +88,13 @@ abstract class PacketSink {
     fun onPacket(packet: Packet) {
         when (packet) {
             is ResetPacket -> onResetPacket()
-            is AckPacket -> onAckPacket()
+            is AckPacket -> onAckPacket(packet)
             is SequencePacket -> onSequencePacket(packet)
         }
     }
 
     abstract fun onResetPacket()
-    abstract fun onAckPacket()
+    abstract fun onAckPacket(packet: AckPacket)
     abstract fun onSequencePacket(packet: SequencePacket)
 }
 
@@ -175,4 +189,4 @@ class SocketDataSource(
         } while (true)
         Log.info("end of stream")
     }
-}
\ No newline at end of file
+}
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Pinger.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Pinger.kt
new file mode 100644
index 0000000..be00644
--- /dev/null
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Pinger.kt
@@ -0,0 +1,106 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.github.google.bumble.btbench
+
+import java.util.concurrent.Semaphore
+import java.util.logging.Logger
+import kotlin.time.Duration.Companion.milliseconds
+import kotlin.time.TimeSource
+
+private val Log = Logger.getLogger("btbench.pinger")
+
+class Pinger(private val viewModel: AppViewModel, private val packetIO: PacketIO) : IoClient,
+    PacketSink() {
+    private val pingTimes: ArrayList<TimeSource.Monotonic.ValueTimeMark> = ArrayList()
+    private val rtts: ArrayList<Long> = ArrayList()
+    private val done = Semaphore(0)
+
+    init {
+        packetIO.packetSink = this
+    }
+
+    override fun run() {
+        viewModel.clear()
+
+        Log.info("startup delay: ${viewModel.startupDelay}")
+        Thread.sleep(viewModel.startupDelay.toLong());
+        Log.info("running")
+
+        Log.info("sending reset")
+        packetIO.sendPacket(ResetPacket())
+
+        val packetCount = viewModel.senderPacketCount
+        val packetSize = viewModel.senderPacketSize
+
+        val startTime = TimeSource.Monotonic.markNow()
+        for (i in 0..<packetCount) {
+            var now = TimeSource.Monotonic.markNow()
+            if (viewModel.senderPacketInterval > 0) {
+                val targetTime = startTime + (i * viewModel.senderPacketInterval).milliseconds
+                val delay = targetTime - now
+                if (delay.isPositive()) {
+                    Log.info("sleeping ${delay.inWholeMilliseconds} ms")
+                    Thread.sleep(delay.inWholeMilliseconds)
+                    now = TimeSource.Monotonic.markNow()
+                }
+            }
+            pingTimes.add(TimeSource.Monotonic.markNow())
+            packetIO.sendPacket(
+                SequencePacket(
+                    if (i < packetCount - 1) 0 else Packet.LAST_FLAG,
+                    i,
+                    (now - startTime).inWholeMicroseconds.toInt(),
+                    ByteArray(packetSize - 10)
+                )
+            )
+            viewModel.packetsSent = i + 1
+        }
+
+        // Wait for the last ACK
+        Log.info("waiting for last ACK")
+        done.acquire()
+        Log.info("got last ACK")
+    }
+
+    override fun abort() {
+        done.release()
+    }
+
+    override fun onResetPacket() {
+    }
+
+    override fun onAckPacket(packet: AckPacket) {
+        val now = TimeSource.Monotonic.markNow()
+        viewModel.packetsReceived += 1
+        if (packet.sequenceNumber < pingTimes.size) {
+            val rtt = (now - pingTimes[packet.sequenceNumber]).inWholeMilliseconds
+            rtts.add(rtt)
+            Log.info("received ACK ${packet.sequenceNumber}, RTT=$rtt")
+        } else {
+            Log.warning("received ACK with unexpected sequence ${packet.sequenceNumber}")
+        }
+
+        if (packet.flags and Packet.LAST_FLAG != 0) {
+            Log.info("last packet received")
+            val stats = "RTTs: min=${rtts.min()}, max=${rtts.max()}, avg=${rtts.sum() / rtts.size}"
+            Log.info(stats)
+            viewModel.stats = stats
+            done.release()
+        }
+    }
+
+    override fun onSequencePacket(packet: SequencePacket) {
+    }
+}
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Ponger.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Ponger.kt
new file mode 100644
index 0000000..16c366b
--- /dev/null
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Ponger.kt
@@ -0,0 +1,70 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.github.google.bumble.btbench
+
+import java.util.concurrent.CountDownLatch
+import java.util.logging.Logger
+import kotlin.time.TimeSource
+
+private val Log = Logger.getLogger("btbench.receiver")
+
+class Ponger(private val viewModel: AppViewModel, private val packetIO: PacketIO) : IoClient, PacketSink() {
+    private var startTime: TimeSource.Monotonic.ValueTimeMark = TimeSource.Monotonic.markNow()
+    private var lastPacketTime: TimeSource.Monotonic.ValueTimeMark = TimeSource.Monotonic.markNow()
+    private var expectedSequenceNumber: Int = 0
+    private val done = CountDownLatch(1)
+
+    init {
+        packetIO.packetSink = this
+    }
+
+    override fun run() {
+        viewModel.clear()
+        done.await()
+    }
+
+    override fun abort() {}
+
+    override fun onResetPacket() {
+        startTime = TimeSource.Monotonic.markNow()
+        lastPacketTime = startTime
+        expectedSequenceNumber = 0
+        viewModel.packetsSent = 0
+        viewModel.packetsReceived = 0
+        viewModel.stats = ""
+    }
+
+    override fun onAckPacket(packet: AckPacket) {
+    }
+
+    override fun onSequencePacket(packet: SequencePacket) {
+        val now = TimeSource.Monotonic.markNow()
+        lastPacketTime = now
+        viewModel.packetsReceived += 1
+
+        if (packet.sequenceNumber != expectedSequenceNumber) {
+            Log.warning("unexpected packet sequence number (expected ${expectedSequenceNumber}, got ${packet.sequenceNumber})")
+        }
+        expectedSequenceNumber += 1
+
+        packetIO.sendPacket(AckPacket(packet.flags, packet.sequenceNumber))
+        viewModel.packetsSent += 1
+
+        if (packet.flags and Packet.LAST_FLAG != 0) {
+            Log.info("received last packet")
+            done.countDown()
+        }
+    }
+}
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Receiver.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Receiver.kt
index c3844b8..1dc1750 100644
--- a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Receiver.kt
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Receiver.kt
@@ -14,21 +14,30 @@
 
 package com.github.google.bumble.btbench
 
+import java.util.concurrent.CountDownLatch
 import java.util.logging.Logger
 import kotlin.time.DurationUnit
 import kotlin.time.TimeSource
 
 private val Log = Logger.getLogger("btbench.receiver")
 
-class Receiver(private val viewModel: AppViewModel, private val packetIO: PacketIO) : PacketSink() {
+class Receiver(private val viewModel: AppViewModel, private val packetIO: PacketIO) : IoClient, PacketSink() {
     private var startTime: TimeSource.Monotonic.ValueTimeMark = TimeSource.Monotonic.markNow()
     private var lastPacketTime: TimeSource.Monotonic.ValueTimeMark = TimeSource.Monotonic.markNow()
     private var bytesReceived = 0
+    private val done = CountDownLatch(1)
 
     init {
         packetIO.packetSink = this
     }
 
+    override fun run() {
+        viewModel.clear()
+        done.await()
+    }
+
+    override fun abort() {}
+
     override fun onResetPacket() {
         startTime = TimeSource.Monotonic.markNow()
         lastPacketTime = startTime
@@ -36,9 +45,10 @@ class Receiver(private val viewModel: AppViewModel, private val packetIO: Packet
         viewModel.throughput = 0
         viewModel.packetsSent = 0
         viewModel.packetsReceived = 0
+        viewModel.stats = ""
     }
 
-    override fun onAckPacket() {
+    override fun onAckPacket(packet: AckPacket) {
 
     }
 
@@ -55,6 +65,7 @@ class Receiver(private val viewModel: AppViewModel, private val packetIO: Packet
             Log.info("throughput: $throughput")
             viewModel.throughput = throughput
             packetIO.sendPacket(AckPacket(packet.flags, packet.sequenceNumber))
+            done.countDown()
         }
     }
 }
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/RfcommClient.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/RfcommClient.kt
index e976c42..da47fbb 100644
--- a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/RfcommClient.kt
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/RfcommClient.kt
@@ -16,22 +16,30 @@ package com.github.google.bumble.btbench
 
 import android.annotation.SuppressLint
 import android.bluetooth.BluetoothAdapter
-import java.io.IOException
 import java.util.logging.Logger
-import kotlin.concurrent.thread
 
 private val Log = Logger.getLogger("btbench.rfcomm-client")
 
-class RfcommClient(private val viewModel: AppViewModel, val bluetoothAdapter: BluetoothAdapter) {
+class RfcommClient(
+    private val viewModel: AppViewModel,
+    private val bluetoothAdapter: BluetoothAdapter,
+    private val createIoClient: (packetIo: PacketIO) -> IoClient
+) : Mode {
+    private var socketClient: SocketClient? = null
+
     @SuppressLint("MissingPermission")
-    fun run() {
+    override fun run() {
         val address = viewModel.peerBluetoothAddress.take(17)
         val remoteDevice = bluetoothAdapter.getRemoteDevice(address)
         val socket = remoteDevice.createInsecureRfcommSocketToServiceRecord(
             DEFAULT_RFCOMM_UUID
         )
 
-        val client = SocketClient(viewModel, socket)
-        client.run()
+        socketClient = SocketClient(viewModel, socket, createIoClient)
+        socketClient!!.run()
+    }
+
+    override fun waitForCompletion() {
+        socketClient?.waitForCompletion()
     }
 }
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/RfcommServer.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/RfcommServer.kt
index 69612c5..818ad0e 100644
--- a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/RfcommServer.kt
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/RfcommServer.kt
@@ -16,20 +16,27 @@ package com.github.google.bumble.btbench
 
 import android.annotation.SuppressLint
 import android.bluetooth.BluetoothAdapter
-import java.io.IOException
 import java.util.logging.Logger
-import kotlin.concurrent.thread
 
 private val Log = Logger.getLogger("btbench.rfcomm-server")
 
-class RfcommServer(private val viewModel: AppViewModel, val bluetoothAdapter: BluetoothAdapter) {
+class RfcommServer(
+    private val viewModel: AppViewModel,
+    private val bluetoothAdapter: BluetoothAdapter,
+    private val createIoClient: (packetIo: PacketIO) -> IoClient
+) : Mode {
+    private var socketServer: SocketServer? = null
+
     @SuppressLint("MissingPermission")
-    fun run() {
+    override fun run() {
         val serverSocket = bluetoothAdapter.listenUsingInsecureRfcommWithServiceRecord(
             "BumbleBench", DEFAULT_RFCOMM_UUID
         )
+        socketServer = SocketServer(viewModel, serverSocket, createIoClient)
+        socketServer!!.run({}, {})
+    }
 
-        val server = SocketServer(viewModel, serverSocket)
-        server.run({}, {})
+    override fun waitForCompletion() {
+        socketServer?.waitForCompletion()
     }
-}
\ No newline at end of file
+}
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Scan.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Scan.kt
index 7cb8e7a..b5d57d0 100644
--- a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Scan.kt
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Scan.kt
@@ -35,4 +35,4 @@ class Scan(val bluetoothAdapter: BluetoothAdapter) {
             bluetoothLeScanner?.stopScan(scanCallback)
         }
     }
-}
\ No newline at end of file
+}
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Sender.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Sender.kt
index 293ac9a..50af553 100644
--- a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Sender.kt
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/Sender.kt
@@ -16,12 +16,14 @@ package com.github.google.bumble.btbench
 
 import java.util.concurrent.Semaphore
 import java.util.logging.Logger
+import kotlin.time.Duration.Companion.milliseconds
 import kotlin.time.DurationUnit
 import kotlin.time.TimeSource
 
 private val Log = Logger.getLogger("btbench.sender")
 
-class Sender(private val viewModel: AppViewModel, private val packetIO: PacketIO) : PacketSink() {
+class Sender(private val viewModel: AppViewModel, private val packetIO: PacketIO) : IoClient,
+    PacketSink() {
     private var startTime: TimeSource.Monotonic.ValueTimeMark = TimeSource.Monotonic.markNow()
     private var bytesSent = 0
     private val done = Semaphore(0)
@@ -30,10 +32,12 @@ class Sender(private val viewModel: AppViewModel, private val packetIO: PacketIO
         packetIO.packetSink = this
     }
 
-    fun run() {
-        viewModel.packetsSent = 0
-        viewModel.packetsReceived = 0
-        viewModel.throughput = 0
+    override fun run() {
+        viewModel.clear()
+
+        Log.info("startup delay: ${viewModel.startupDelay}")
+        Thread.sleep(viewModel.startupDelay.toLong());
+        Log.info("running")
 
         Log.info("sending reset")
         packetIO.sendPacket(ResetPacket())
@@ -42,20 +46,32 @@ class Sender(private val viewModel: AppViewModel, private val packetIO: PacketIO
 
         val packetCount = viewModel.senderPacketCount
         val packetSize = viewModel.senderPacketSize
-        for (i in 0..<packetCount - 1) {
-            packetIO.sendPacket(SequencePacket(0, i, ByteArray(packetSize - 6)))
+        for (i in 0..<packetCount) {
+            var now = TimeSource.Monotonic.markNow()
+            if (viewModel.senderPacketInterval > 0) {
+                val targetTime = startTime + (i * viewModel.senderPacketInterval).milliseconds
+                val delay = targetTime - now
+                if (delay.isPositive()) {
+                    Log.info("sleeping ${delay.inWholeMilliseconds} ms")
+                    Thread.sleep(delay.inWholeMilliseconds)
+                }
+                now = TimeSource.Monotonic.markNow()
+            }
+            val flags = when (i) {
+                packetCount - 1 -> Packet.LAST_FLAG
+                else -> 0
+            }
+            packetIO.sendPacket(
+                SequencePacket(
+                    flags,
+                    i,
+                    (now - startTime).inWholeMicroseconds.toInt(),
+                    ByteArray(packetSize - 10)
+                )
+            )
             bytesSent += packetSize
             viewModel.packetsSent = i + 1
         }
-        packetIO.sendPacket(
-            SequencePacket(
-                Packet.LAST_FLAG,
-                packetCount - 1,
-                ByteArray(packetSize - 6)
-            )
-        )
-        bytesSent += packetSize
-        viewModel.packetsSent = packetCount
 
         // Wait for the ACK
         Log.info("waiting for ACK")
@@ -63,14 +79,14 @@ class Sender(private val viewModel: AppViewModel, private val packetIO: PacketIO
         Log.info("got ACK")
     }
 
-    fun abort() {
+    override fun abort() {
         done.release()
     }
 
     override fun onResetPacket() {
     }
 
-    override fun onAckPacket() {
+    override fun onAckPacket(packet: AckPacket) {
         Log.info("received ACK")
         val elapsed = TimeSource.Monotonic.markNow() - startTime
         val throughput = (bytesSent / elapsed.toDouble(DurationUnit.SECONDS)).toInt()
@@ -81,4 +97,4 @@ class Sender(private val viewModel: AppViewModel, private val packetIO: PacketIO
 
     override fun onSequencePacket(packet: SequencePacket) {
     }
-}
\ No newline at end of file
+}
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/SocketClient.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/SocketClient.kt
index 46a014a..89413ef 100644
--- a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/SocketClient.kt
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/SocketClient.kt
@@ -22,16 +22,20 @@ import kotlin.concurrent.thread
 
 private val Log = Logger.getLogger("btbench.socket-client")
 
-private const val DEFAULT_STARTUP_DELAY = 3000
+class SocketClient(
+    private val viewModel: AppViewModel,
+    private val socket: BluetoothSocket,
+    private val createIoClient: (packetIo: PacketIO) -> IoClient
+) {
+    private var clientThread: Thread? = null
 
-class SocketClient(private val viewModel: AppViewModel, private val socket: BluetoothSocket) {
     @SuppressLint("MissingPermission")
     fun run() {
         viewModel.running = true
         val socketDataSink = SocketDataSink(socket)
         val streamIO = StreamedPacketIO(socketDataSink)
         val socketDataSource = SocketDataSource(socket, streamIO::onData)
-        val sender = Sender(viewModel, streamIO)
+        val ioClient = createIoClient(streamIO)
 
         fun cleanup() {
             socket.close()
@@ -39,9 +43,9 @@ class SocketClient(private val viewModel: AppViewModel, private val socket: Blue
             viewModel.running = false
         }
 
-        thread(name = "SocketClient") {
+        clientThread = thread(name = "SocketClient") {
             viewModel.aborter = {
-                sender.abort()
+                ioClient.abort()
                 socket.close()
             }
             Log.info("connecting to remote")
@@ -49,27 +53,37 @@ class SocketClient(private val viewModel: AppViewModel, private val socket: Blue
                 socket.connect()
             } catch (error: IOException) {
                 Log.warning("connection failed")
+                viewModel.status = "ABORTED"
+                viewModel.lastError = "CONNECTION_FAILED"
                 cleanup()
                 return@thread
             }
             Log.info("connected")
 
-            thread {
+            val sourceThread = thread {
                 socketDataSource.receive()
                 socket.close()
-                sender.abort()
+                ioClient.abort()
             }
 
-            Log.info("Startup delay: $DEFAULT_STARTUP_DELAY")
-            Thread.sleep(DEFAULT_STARTUP_DELAY.toLong());
-            Log.info("Starting to send")
-
             try {
-                sender.run()
+                ioClient.run()
+                socket.close()
+                viewModel.status = "OK"
             } catch (error: IOException) {
                 Log.info("run ended abruptly")
+                viewModel.status = "ABORTED"
+                viewModel.lastError = "IO_ERROR"
             }
+
+            Log.info("waiting for source thread to finish")
+            sourceThread.join()
+
             cleanup()
         }
     }
-}
\ No newline at end of file
+
+    fun waitForCompletion() {
+        clientThread?.join()
+    }
+}
diff --git a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/SocketServer.kt b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/SocketServer.kt
index e83a47f..72f09da 100644
--- a/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/SocketServer.kt
+++ b/extras/android/BtBench/app/src/main/java/com/github/google/bumble/btbench/SocketServer.kt
@@ -21,7 +21,13 @@ import kotlin.concurrent.thread
 
 private val Log = Logger.getLogger("btbench.socket-server")
 
-class SocketServer(private val viewModel: AppViewModel, private val serverSocket: BluetoothServerSocket) {
+class SocketServer(
+    private val viewModel: AppViewModel,
+    private val serverSocket: BluetoothServerSocket,
+    private val createIoClient: (packetIo: PacketIO) -> IoClient
+) {
+    private var serverThread: Thread? = null
+
     fun run(onConnected: () -> Unit, onDisconnected: () -> Unit) {
         var aborted = false
         viewModel.running = true
@@ -31,7 +37,7 @@ class SocketServer(private val viewModel: AppViewModel, private val serverSocket
             viewModel.running = false
         }
 
-        thread(name = "SocketServer") {
+        serverThread = thread(name = "SocketServer") {
             while (!aborted) {
                 viewModel.aborter = {
                     serverSocket.close()
@@ -46,6 +52,8 @@ class SocketServer(private val viewModel: AppViewModel, private val serverSocket
                     return@thread
                 }
                 Log.info("got connection from ${socket.remoteDevice.address}")
+                Log.info("maxReceivePacketSize=${socket.maxReceivePacketSize}")
+                Log.info("maxTransmitPacketSize=${socket.maxTransmitPacketSize}")
                 onConnected()
 
                 viewModel.aborter = {
@@ -57,11 +65,22 @@ class SocketServer(private val viewModel: AppViewModel, private val serverSocket
                 val socketDataSink = SocketDataSink(socket)
                 val streamIO = StreamedPacketIO(socketDataSink)
                 val socketDataSource = SocketDataSource(socket, streamIO::onData)
-                val receiver = Receiver(viewModel, streamIO)
+
+                val ioThread = thread(name = "IoClient") {
+                    val ioClient = createIoClient(streamIO)
+                    ioClient.run()
+                }
+
                 socketDataSource.receive()
                 socket.close()
+                ioThread.join()
             }
             cleanup()
         }
+
+    }
+
+    fun waitForCompletion() {
+        serverThread?.join()
     }
-}
\ No newline at end of file
+}
diff --git a/extras/android/BtBench/gradle/libs.versions.toml b/extras/android/BtBench/gradle/libs.versions.toml
index 26945a9..dd85dbc 100644
--- a/extras/android/BtBench/gradle/libs.versions.toml
+++ b/extras/android/BtBench/gradle/libs.versions.toml
@@ -1,5 +1,5 @@
 [versions]
-agp = "8.2.0"
+agp = "8.4.0"
 kotlin = "1.9.0"
 core-ktx = "1.12.0"
 junit = "4.13.2"
@@ -8,6 +8,8 @@ espresso-core = "3.5.1"
 lifecycle-runtime-ktx = "2.6.2"
 activity-compose = "1.7.2"
 compose-bom = "2023.08.00"
+mobly-snippet = "1.4.0"
+core = "1.6.1"
 
 [libraries]
 core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "core-ktx" }
@@ -24,6 +26,8 @@ ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview
 ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
 ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
 material3 = { group = "androidx.compose.material3", name = "material3" }
+mobly-snippet = { group = "com.google.android.mobly", name = "mobly-snippet-lib", version.ref = "mobly.snippet" }
+androidx-core = { group = "androidx.test", name = "core", version.ref = "core" }
 
 [plugins]
 androidApplication = { id = "com.android.application", version.ref = "agp" }
diff --git a/extras/android/BtBench/gradle/wrapper/gradle-wrapper.properties b/extras/android/BtBench/gradle/wrapper/gradle-wrapper.properties
index 8ef5972..cc96ba9 100644
--- a/extras/android/BtBench/gradle/wrapper/gradle-wrapper.properties
+++ b/extras/android/BtBench/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
 #Wed Oct 25 07:40:52 PDT 2023
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.4-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-bin.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/extras/android/RemoteHCI/app/src/main/java/com/github/google/bumble/remotehci/HciProxy.java b/extras/android/RemoteHCI/app/src/main/java/com/github/google/bumble/remotehci/HciProxy.java
index 1949a63..0b177f2 100644
--- a/extras/android/RemoteHCI/app/src/main/java/com/github/google/bumble/remotehci/HciProxy.java
+++ b/extras/android/RemoteHCI/app/src/main/java/com/github/google/bumble/remotehci/HciProxy.java
@@ -23,6 +23,7 @@ public class HciProxy {
         HciHal hciHal = HciHal.create(new HciHalCallback() {
             @Override
             public void onPacket(HciPacket.Type type, byte[] packet) {
+                Log.d(TAG, String.format("CONTROLLER->HOST: type=%s, size=%d", type, packet.length));
                 mServer.sendPacket(type, packet);
 
                 switch (type) {
@@ -83,7 +84,7 @@ public class HciProxy {
 
             @Override
             public void onPacket(HciPacket.Type type, byte[] packet) {
-                Log.d(TAG, String.format("onPacket: type=%s, size=%d", type, packet.length));
+                Log.d(TAG, String.format("HOST->CONTROLLER: type=%s, size=%d", type, packet.length));
                 hciHal.sendPacket(type, packet);
 
                 switch (type) {
diff --git a/pyproject.toml b/pyproject.toml
index 8662723..9474cd1 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -1,21 +1,135 @@
 [build-system]
-requires = ["setuptools>=52", "wheel", "setuptools_scm>=6.2"]
+requires = ["setuptools>=61", "wheel", "setuptools_scm>=8"]
 build-backend = "setuptools.build_meta"
 
+[project]
+name = "bumble"
+dynamic = ["version"]
+description = "Bluetooth Stack for Apps, Emulation, Test and Experimentation"
+readme = "README.md"
+authors = [{ name = "Google", email = "bumble-dev@google.com" }]
+requires-python = ">=3.8"
+dependencies = [
+    "aiohttp ~= 3.8; platform_system!='Emscripten'",
+    "appdirs >= 1.4; platform_system!='Emscripten'",
+    "click >= 8.1.3; platform_system!='Emscripten'",
+    "cryptography >= 44.0.3; platform_system!='Emscripten'",
+    # Pyodide bundles a version of cryptography that is built for wasm, which may not match the
+    # versions available on PyPI. Relax the version requirement since it's better than being
+    # completely unable to import the package in case of version mismatch.
+    "cryptography >= 44.0.3; platform_system=='Emscripten'",
+    "grpcio >= 1.62.1; platform_system!='Emscripten'",
+    "humanize >= 4.6.0; platform_system!='Emscripten'",
+    "libusb1 >= 2.0.1; platform_system!='Emscripten'",
+    "libusb-package == 1.0.26.1; platform_system!='Emscripten'",
+    "platformdirs >= 3.10.0; platform_system!='Emscripten'",
+    "prompt_toolkit >= 3.0.16; platform_system!='Emscripten'",
+    "prettytable >= 3.6.0; platform_system!='Emscripten'",
+    "protobuf >= 3.12.4; platform_system!='Emscripten'",
+    "pyee >= 13.0.0",
+    "pyserial-asyncio >= 0.5; platform_system!='Emscripten'",
+    "pyserial >= 3.5; platform_system!='Emscripten'",
+    "pyusb >= 1.2; platform_system!='Emscripten'",
+    "websockets == 13.1; platform_system!='Emscripten'",
+]
+
+[project.optional-dependencies]
+build = ["build >= 0.7"]
+test = [
+    "pytest >= 8.2",
+    "pytest-asyncio >= 0.23.5",
+    "pytest-html >= 3.2.0",
+    "coverage >= 6.4",
+]
+development = [
+    "black == 24.3",
+    "bt-test-interfaces >= 0.0.6",
+    "grpcio-tools >= 1.62.1",
+    "invoke >= 1.7.3",
+    "mobly >= 1.12.2",
+    "mypy == 1.12.0",
+    "nox >= 2022",
+    "pylint == 3.3.1",
+    "pyyaml >= 6.0",
+    "types-appdirs >= 1.4.3",
+    "types-invoke >= 1.7.3",
+    "types-protobuf >= 4.21.0",
+]
+avatar = [
+    "pandora-avatar == 0.0.10",
+    "rootcanal == 1.11.1 ; python_version>='3.10'",
+]
+pandora = ["bt-test-interfaces >= 0.0.6"]
+documentation = [
+    "mkdocs >= 1.6.0",
+    "mkdocs-material >= 9.6",
+    "mkdocstrings[python] >= 0.27.0",
+]
+auracast = [
+    "lc3py >= 1.1.3; python_version>='3.10' and ((platform_system=='Linux' and platform_machine=='x86_64') or (platform_system=='Darwin' and platform_machine=='arm64'))",
+    "sounddevice >= 0.5.1",
+]
+
+[project.scripts]
+bumble-auracast = "bumble.apps.auracast:main"
+bumble-ble-rpa-tool = "bumble.apps.ble_rpa_tool:main"
+bumble-console = "bumble.apps.console:main"
+bumble-controller-info = "bumble.apps.controller_info:main"
+bumble-controller-loopback = "bumble.apps.controller_loopback:main"
+bumble-gatt-dump = "bumble.apps.gatt_dump:main"
+bumble-hci-bridge = "bumble.apps.hci_bridge:main"
+bumble-l2cap-bridge = "bumble.apps.l2cap_bridge:main"
+bumble-rfcomm-bridge = "bumble.apps.rfcomm_bridge:main"
+bumble-pair = "bumble.apps.pair:main"
+bumble-scan = "bumble.apps.scan:main"
+bumble-show = "bumble.apps.show:main"
+bumble-unbond = "bumble.apps.unbond:main"
+bumble-usb-probe = "bumble.apps.usb_probe:main"
+bumble-link-relay = "bumble.apps.link_relay.link_relay:main"
+bumble-bench = "bumble.apps.bench:main"
+bumble-player = "bumble.apps.player.player:main"
+bumble-speaker = "bumble.apps.speaker.speaker:main"
+bumble-pandora-server = "bumble.apps.pandora_server:main"
+bumble-rtk-util = "bumble.tools.rtk_util:main"
+bumble-rtk-fw-download = "bumble.tools.rtk_fw_download:main"
+bumble-intel-util = "bumble.tools.intel_util:main"
+bumble-intel-fw-download = "bumble.tools.intel_fw_download:main"
+
+
+[project.urls]
+Homepage = "https://github.com/google/bumble"
+
+[tool.setuptools]
+packages = [
+    "bumble",
+    "bumble.transport",
+    "bumble.transport.grpc_protobuf",
+    "bumble.drivers",
+    "bumble.profiles",
+    "bumble.apps",
+    "bumble.apps.link_relay",
+    "bumble.pandora",
+    "bumble.tools",
+]
+
+[tool.setuptools.package-dir]
+"bumble" = "bumble"
+"bumble.apps" = "apps"
+"bumble.tools" = "tools"
+
 [tool.setuptools_scm]
 write_to = "bumble/_version.py"
 
+[tool.setuptools.package-data]
+"*" = ["*.pyi", "py.typed"]
+
 [tool.pytest.ini_options]
 pythonpath = "."
-testpaths = [
-    "tests"
-]
+testpaths = ["tests"]
 
 [tool.pylint.master]
 init-hook = 'import sys; sys.path.append(".")'
-ignore-paths = [
-    '.*_pb2(_grpc)?.py'
-]
+ignore-paths = ['.*_pb2(_grpc)?.py']
 
 [tool.pylint.messages_control]
 max-line-length = "88"
@@ -25,8 +139,8 @@ disable = [
     "fixme",
     "logging-fstring-interpolation",
     "logging-not-lazy",
-    "no-member", # Temporary until pylint works better with class/method decorators
-    "no-value-for-parameter", # Temporary until pylint works better with class/method decorators
+    "no-member",                     # Temporary until pylint works better with class/method decorators
+    "no-value-for-parameter",        # Temporary until pylint works better with class/method decorators
     "missing-class-docstring",
     "missing-function-docstring",
     "missing-module-docstring",
@@ -41,10 +155,11 @@ disable = [
 ]
 
 [tool.pylint.main]
-ignore="pandora" # FIXME: pylint does not support stubs yet:
+ignore=["pandora", "mobly"] # FIXME: pylint does not support stubs yet
 
 [tool.pylint.typecheck]
-signature-mutators="AsyncRunner.run_in_task"
+signature-mutators = "AsyncRunner.run_in_task"
+disable = "not-callable"
 
 [tool.black]
 skip-string-normalization = true
@@ -55,7 +170,7 @@ extend-exclude = '''
 '''
 
 [tool.mypy]
-exclude = ['bumble/transport/grpc_protobuf']
+exclude = ['bumble/transport/grpc_protobuf', 'examples/mobly/bench']
 
 [[tool.mypy.overrides]]
 module = "bumble.transport.grpc_protobuf.*"
@@ -77,6 +192,10 @@ ignore_missing_imports = true
 module = "serial_asyncio.*"
 ignore_missing_imports = true
 
+[[tool.mypy.overrides]]
+module = "sounddevice.*"
+ignore_missing_imports = true
+
 [[tool.mypy.overrides]]
 module = "usb.*"
 ignore_missing_imports = true
@@ -84,4 +203,3 @@ ignore_missing_imports = true
 [[tool.mypy.overrides]]
 module = "usb1.*"
 ignore_missing_imports = true
-
diff --git a/rust/README.md b/rust/README.md
index e08ef25..17a10f4 100644
--- a/rust/README.md
+++ b/rust/README.md
@@ -69,3 +69,68 @@ To regenerate the assigned number tables based on the Python codebase:
 ```
 PYTHONPATH=.. cargo run --bin gen-assigned-numbers --features dev-tools
 ```
+
+## HCI packets
+
+Sending a command packet from a device is composed to of two major steps.
+There are more generalized ways of dealing with packets in other scenarios.
+
+### Construct the command
+Pick a command from `src/internal/hci/packets.pdl` and construct its associated "builder" struct.
+
+```rust
+// The "LE Set Scan Enable" command can be found in the Core Bluetooth Spec.
+// It can also be found in `packets.pdl` as `packet LeSetScanEnable : Command`
+fn main() {
+    let device = init_device_as_desired();
+    
+    let le_set_scan_enable_command_builder = LeSetScanEnableBuilder {
+        filter_duplicates: Enable::Disabled,
+        le_scan_enable: Enable::Enabled,
+    };
+}
+```
+
+### Send the command and interpret the event response
+Send the command from an initialized device, and then receive the response.
+
+```rust
+fn main() {
+    // ...
+    
+    // `check_result` to false to receive the event response even if the controller returns a failure code
+    let event = device.send_command(le_set_scan_enable_command_builder.into(), /*check_result*/ false);
+    // Coerce the event into the expected format. A `Command` should have an associated event response
+    // "<command name>Complete".
+    let le_set_scan_enable_complete_event: LeSetScanEnableComplete = event.try_into().unwrap();
+}
+```
+
+### Generic packet handling
+At the very least, you should expect to at least know _which_ kind of base packet you are dealing with. Base packets in 
+`packets.pdl` can be identified because they do not extend any other packet. They are easily found with the regex:
+`^packet [^:]* \{`. For Bluetooth LE (BLE) HCI, one should find some kind of header preceding the packet with the purpose of
+packet disambiguation. We do some of that disambiguation for H4 BLE packets using the `WithPacketHeader` trait at `internal/hci/mod.rs`.
+
+Say you've identified a series of bytes that are certainly an `Acl` packet. They can be parsed using the `Acl` struct.
+```rust
+fn main() {
+    let bytes = bytes_that_are_certainly_acl();
+    let acl_packet = Acl::parse(bytes).unwrap();
+}
+```
+
+Since you don't yet know what kind of `Acl` packet it is, you need to specialize it and then handle the various
+potential cases.
+```rust
+fn main() {
+    // ...
+    match acl_packet.specialize() {
+        Payload(bytes) => do_something(bytes),
+        None => do_something_else(),
+    }
+}
+```
+
+Some packets may yet further embed other packets, in which case you may need to further specialize until no more
+specialization is needed.
diff --git a/rust/examples/broadcast.rs b/rust/examples/broadcast.rs
index affe21e..7b24b76 100644
--- a/rust/examples/broadcast.rs
+++ b/rust/examples/broadcast.rs
@@ -25,7 +25,6 @@ use clap::Parser as _;
 use pyo3::PyResult;
 use rand::Rng;
 use std::path;
-
 #[pyo3_asyncio::tokio::main]
 async fn main() -> PyResult<()> {
     env_logger::builder()
diff --git a/rust/pytests/wrapper/hci.rs b/rust/pytests/wrapper/hci.rs
index c4ce20d..7512c36 100644
--- a/rust/pytests/wrapper/hci.rs
+++ b/rust/pytests/wrapper/hci.rs
@@ -28,7 +28,7 @@ use bumble::wrapper::{
 };
 use pyo3::{
     exceptions::PyException,
-    {PyErr, PyResult},
+    FromPyObject, IntoPy, Python, {PyErr, PyResult},
 };
 
 #[pyo3_asyncio::tokio::test]
@@ -78,6 +78,28 @@ async fn test_hci_roundtrip_success_and_failure() -> PyResult<()> {
     Ok(())
 }
 
+#[pyo3_asyncio::tokio::test]
+fn valid_error_code_extraction_succeeds() -> PyResult<()> {
+    let error_code = Python::with_gil(|py| {
+        let python_error_code_success = 0x00_u8.into_py(py);
+        ErrorCode::extract(python_error_code_success.as_ref(py))
+    })?;
+
+    assert_eq!(ErrorCode::Success, error_code);
+    Ok(())
+}
+
+#[pyo3_asyncio::tokio::test]
+fn invalid_error_code_extraction_fails() -> PyResult<()> {
+    let failed_extraction = Python::with_gil(|py| {
+        let python_invalid_error_code = 0xFE_u8.into_py(py);
+        ErrorCode::extract(python_invalid_error_code.as_ref(py))
+    });
+
+    assert!(failed_extraction.is_err());
+    Ok(())
+}
+
 async fn create_local_device(address: Address) -> PyResult<Device> {
     let link = Link::new_local_link()?;
     let controller = Controller::new("C1", None, None, Some(link), Some(address.clone())).await?;
diff --git a/rust/src/wrapper/hci.rs b/rust/src/wrapper/hci.rs
index 52480c8..f2ec049 100644
--- a/rust/src/wrapper/hci.rs
+++ b/rust/src/wrapper/hci.rs
@@ -80,7 +80,7 @@ impl Address {
     /// Creates a new [Address] object.
     pub fn new(address: &str, address_type: AddressType) -> PyResult<Self> {
         Python::with_gil(|py| {
-            PyModule::import(py, intern!(py, "bumble.device"))?
+            PyModule::import(py, intern!(py, "bumble.hci"))?
                 .getattr(intern!(py, "Address"))?
                 .call1((address, address_type))
                 .map(|any| Self(any.into()))
@@ -178,7 +178,11 @@ impl IntoPy<PyObject> for AddressType {
 
 impl<'source> FromPyObject<'source> for ErrorCode {
     fn extract(ob: &'source PyAny) -> PyResult<Self> {
-        ob.extract()
+        // Bumble represents error codes simply as a single-byte number (in Rust, u8)
+        let value: u8 = ob.extract()?;
+        ErrorCode::try_from(value).map_err(|b| {
+            PyErr::new::<PyException, _>(format!("Failed to map {b} to an error code"))
+        })
     }
 }
 
diff --git a/scripts/process_android_netsim_protos.sh b/scripts/process_android_netsim_protos.sh
index 5a26602..d2615d3 100644
--- a/scripts/process_android_netsim_protos.sh
+++ b/scripts/process_android_netsim_protos.sh
@@ -1,14 +1,23 @@
-# Invoke this script with an argument pointing to where the AOSP `tools/netsim/src/proto` is
+# Invoke this script with two arguments:
+# Arg 1: directory path where the AOSP `tools/netsim/proto` directory is located
+# Arg 2: directory path where the RootCanal `proto/rootcanal` directory is located
 PROTOC_OUT=bumble/transport/grpc_protobuf
 
-proto_files=(common.proto packet_streamer.proto hci_packet.proto startup.proto)
-for proto_file in "${proto_files[@]}"
+netsim_proto_files=(netsim/common.proto netsim/packet_streamer.proto netsim/hci_packet.proto netsim/startup.proto netsim/model.proto)
+for proto_file in "${netsim_proto_files[@]}"
 do
-    python -m grpc_tools.protoc -I$1 --proto_path=bumble/transport --python_out=$PROTOC_OUT --pyi_out=$PROTOC_OUT --grpc_python_out=$PROTOC_OUT $1/$proto_file
+    python -m grpc_tools.protoc -I$1 -I$2 --proto_path=bumble/transport --python_out=$PROTOC_OUT --pyi_out=$PROTOC_OUT --grpc_python_out=$PROTOC_OUT $1/$proto_file
 done
 
-python_files=(packet_streamer_pb2_grpc.py packet_streamer_pb2.py hci_packet_pb2.py startup_pb2.py)
+rootcanal_proto_files=(rootcanal/configuration.proto)
+for proto_file in "${rootcanal_proto_files[@]}"
+do
+    python -m grpc_tools.protoc -I$1 -I$2 --proto_path=bumble/transport --python_out=$PROTOC_OUT --pyi_out=$PROTOC_OUT --grpc_python_out=$PROTOC_OUT $2/$proto_file
+done
+
+python_files=(netsim/*.py netsim/*.pyi)
 for python_file in "${python_files[@]}"
 do
-    sed -i 's/^import .*_pb2 as/from . \0/' $PROTOC_OUT/$python_file
+    sed -i '' 's/^from netsim/from bumble.transport.grpc_protobuf.netsim/' $PROTOC_OUT/$python_file
+    sed -i '' 's/^from rootcanal/from bumble.transport.grpc_protobuf.rootcanal/' $PROTOC_OUT/$python_file
 done
diff --git a/setup.cfg b/setup.cfg
deleted file mode 100644
index 305357a..0000000
--- a/setup.cfg
+++ /dev/null
@@ -1,109 +0,0 @@
-# Copyright 2021-2023 Google LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      https://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-[metadata]
-name = bumble
-use_scm_version = True
-description = Bluetooth Stack for Apps, Emulation, Test and Experimentation
-long_description = file: README.md
-long_description_content_type = text/markdown
-author = Google
-author_email = tbd@tbd.com
-url = https://github.com/google/bumble
-
-[options]
-python_requires = >=3.8
-packages = bumble, bumble.transport, bumble.transport.grpc_protobuf, bumble.drivers, bumble.profiles, bumble.apps, bumble.apps.link_relay, bumble.pandora, bumble.tools
-package_dir =
-    bumble = bumble
-    bumble.apps = apps
-    bumble.tools = tools
-include_package_data = True
-install_requires =
-    aiohttp ~= 3.8; platform_system!='Emscripten'
-    appdirs >= 1.4; platform_system!='Emscripten'
-    click >= 8.1.3; platform_system!='Emscripten'
-    cryptography == 39; platform_system!='Emscripten'
-    # Pyodide bundles a version of cryptography that is built for wasm, which may not match the
-    # versions available on PyPI. Relax the version requirement since it's better than being
-    # completely unable to import the package in case of version mismatch.
-    cryptography >= 39.0; platform_system=='Emscripten'
-    grpcio >= 1.62.1; platform_system!='Emscripten'
-    humanize >= 4.6.0; platform_system!='Emscripten'
-    libusb1 >= 2.0.1; platform_system!='Emscripten'
-    libusb-package == 1.0.26.1; platform_system!='Emscripten'
-    platformdirs >= 3.10.0; platform_system!='Emscripten'
-    prompt_toolkit >= 3.0.16; platform_system!='Emscripten'
-    prettytable >= 3.6.0; platform_system!='Emscripten'
-    protobuf >= 3.12.4; platform_system!='Emscripten'
-    pyee >= 8.2.2
-    pyserial-asyncio >= 0.5; platform_system!='Emscripten'
-    pyserial >= 3.5; platform_system!='Emscripten'
-    pyusb >= 1.2; platform_system!='Emscripten'
-    websockets >= 12.0; platform_system!='Emscripten'
-
-[options.entry_points]
-console_scripts =
-    bumble-ble-rpa-tool = bumble.apps.ble_rpa_tool:main
-    bumble-console = bumble.apps.console:main
-    bumble-controller-info = bumble.apps.controller_info:main
-    bumble-controller-loopback = bumble.apps.controller_loopback:main
-    bumble-gatt-dump = bumble.apps.gatt_dump:main
-    bumble-hci-bridge = bumble.apps.hci_bridge:main
-    bumble-l2cap-bridge = bumble.apps.l2cap_bridge:main
-    bumble-rfcomm-bridge = bumble.apps.rfcomm_bridge:main
-    bumble-pair = bumble.apps.pair:main
-    bumble-scan = bumble.apps.scan:main
-    bumble-show = bumble.apps.show:main
-    bumble-unbond = bumble.apps.unbond:main
-    bumble-usb-probe = bumble.apps.usb_probe:main
-    bumble-link-relay = bumble.apps.link_relay.link_relay:main
-    bumble-bench = bumble.apps.bench:main
-    bumble-speaker = bumble.apps.speaker.speaker:main
-    bumble-pandora-server = bumble.apps.pandora_server:main
-    bumble-rtk-util = bumble.tools.rtk_util:main
-    bumble-rtk-fw-download = bumble.tools.rtk_fw_download:main
-
-[options.package_data]
-* = py.typed, *.pyi
-
-[options.extras_require]
-build =
-    build >= 0.7
-test =
-    pytest >= 8.2
-    pytest-asyncio >= 0.23.5
-    pytest-html >= 3.2.0
-    coverage >= 6.4
-development =
-    black == 24.3
-    grpcio-tools >= 1.62.1
-    invoke >= 1.7.3
-    mypy == 1.10.0
-    nox >= 2022
-    pylint == 3.1.0
-    pyyaml >= 6.0
-    types-appdirs >= 1.4.3
-    types-invoke >= 1.7.3
-    types-protobuf >= 4.21.0
-    wasmtime == 20.0.0
-avatar =
-    pandora-avatar == 0.0.10
-    rootcanal == 1.10.0 ; python_version>='3.10'
-pandora =
-    bt-test-interfaces >= 0.0.6
-documentation =
-    mkdocs >= 1.4.0
-    mkdocs-material >= 8.5.6
-    mkdocstrings[python] >= 0.19.0
diff --git a/tests/a2dp_test.py b/tests/a2dp_test.py
index ca59890..2a359b5 100644
--- a/tests/a2dp_test.py
+++ b/tests/a2dp_test.py
@@ -21,7 +21,7 @@ import os
 import pytest
 
 from bumble.controller import Controller
-from bumble.core import BT_BR_EDR_TRANSPORT
+from bumble.core import PhysicalTransport
 from bumble.link import LocalLink
 from bumble.device import Device
 from bumble.host import Host
@@ -33,20 +33,16 @@ from bumble.avdtp import (
     Protocol,
     Listener,
     MediaCodecCapabilities,
-    MediaPacket,
     AVDTP_AUDIO_MEDIA_TYPE,
     AVDTP_TSEP_SNK,
     A2DP_SBC_CODEC_TYPE,
 )
 from bumble.a2dp import (
+    AacMediaCodecInformation,
+    OpusMediaCodecInformation,
     SbcMediaCodecInformation,
-    SBC_MONO_CHANNEL_MODE,
-    SBC_DUAL_CHANNEL_MODE,
-    SBC_STEREO_CHANNEL_MODE,
-    SBC_JOINT_STEREO_CHANNEL_MODE,
-    SBC_LOUDNESS_ALLOCATION_METHOD,
-    SBC_SNR_ALLOCATION_METHOD,
 )
+from bumble.rtp import MediaPacket
 
 # -----------------------------------------------------------------------------
 # Logging
@@ -110,7 +106,7 @@ async def test_self_connection():
     # Connect the two devices
     await asyncio.gather(
         two_devices.devices[0].connect(
-            two_devices.devices[1].public_address, transport=BT_BR_EDR_TRANSPORT
+            two_devices.devices[1].public_address, transport=PhysicalTransport.BR_EDR
         ),
         two_devices.devices[1].accept(two_devices.devices[0].public_address),
     )
@@ -125,12 +121,12 @@ def source_codec_capabilities():
     return MediaCodecCapabilities(
         media_type=AVDTP_AUDIO_MEDIA_TYPE,
         media_codec_type=A2DP_SBC_CODEC_TYPE,
-        media_codec_information=SbcMediaCodecInformation.from_discrete_values(
-            sampling_frequency=44100,
-            channel_mode=SBC_JOINT_STEREO_CHANNEL_MODE,
-            block_length=16,
-            subbands=8,
-            allocation_method=SBC_LOUDNESS_ALLOCATION_METHOD,
+        media_codec_information=SbcMediaCodecInformation(
+            sampling_frequency=SbcMediaCodecInformation.SamplingFrequency.SF_44100,
+            channel_mode=SbcMediaCodecInformation.ChannelMode.JOINT_STEREO,
+            block_length=SbcMediaCodecInformation.BlockLength.BL_16,
+            subbands=SbcMediaCodecInformation.Subbands.S_8,
+            allocation_method=SbcMediaCodecInformation.AllocationMethod.LOUDNESS,
             minimum_bitpool_value=2,
             maximum_bitpool_value=53,
         ),
@@ -142,20 +138,23 @@ def sink_codec_capabilities():
     return MediaCodecCapabilities(
         media_type=AVDTP_AUDIO_MEDIA_TYPE,
         media_codec_type=A2DP_SBC_CODEC_TYPE,
-        media_codec_information=SbcMediaCodecInformation.from_lists(
-            sampling_frequencies=[48000, 44100, 32000, 16000],
-            channel_modes=[
-                SBC_MONO_CHANNEL_MODE,
-                SBC_DUAL_CHANNEL_MODE,
-                SBC_STEREO_CHANNEL_MODE,
-                SBC_JOINT_STEREO_CHANNEL_MODE,
-            ],
-            block_lengths=[4, 8, 12, 16],
-            subbands=[4, 8],
-            allocation_methods=[
-                SBC_LOUDNESS_ALLOCATION_METHOD,
-                SBC_SNR_ALLOCATION_METHOD,
-            ],
+        media_codec_information=SbcMediaCodecInformation(
+            sampling_frequency=SbcMediaCodecInformation.SamplingFrequency.SF_48000
+            | SbcMediaCodecInformation.SamplingFrequency.SF_44100
+            | SbcMediaCodecInformation.SamplingFrequency.SF_32000
+            | SbcMediaCodecInformation.SamplingFrequency.SF_16000,
+            channel_mode=SbcMediaCodecInformation.ChannelMode.MONO
+            | SbcMediaCodecInformation.ChannelMode.DUAL_CHANNEL
+            | SbcMediaCodecInformation.ChannelMode.STEREO
+            | SbcMediaCodecInformation.ChannelMode.JOINT_STEREO,
+            block_length=SbcMediaCodecInformation.BlockLength.BL_4
+            | SbcMediaCodecInformation.BlockLength.BL_8
+            | SbcMediaCodecInformation.BlockLength.BL_12
+            | SbcMediaCodecInformation.BlockLength.BL_16,
+            subbands=SbcMediaCodecInformation.Subbands.S_4
+            | SbcMediaCodecInformation.Subbands.S_8,
+            allocation_method=SbcMediaCodecInformation.AllocationMethod.LOUDNESS
+            | SbcMediaCodecInformation.AllocationMethod.SNR,
             minimum_bitpool_value=2,
             maximum_bitpool_value=53,
         ),
@@ -191,7 +190,7 @@ async def test_source_sink_1():
     async def make_connection():
         connections = await asyncio.gather(
             two_devices.devices[0].connect(
-                two_devices.devices[1].public_address, BT_BR_EDR_TRANSPORT
+                two_devices.devices[1].public_address, PhysicalTransport.BR_EDR
             ),
             two_devices.devices[1].accept(two_devices.devices[0].public_address),
         )
@@ -273,7 +272,125 @@ async def test_source_sink_1():
 
 
 # -----------------------------------------------------------------------------
-async def run_test_self():
+def test_sbc_codec_specific_information():
+    sbc_info = SbcMediaCodecInformation.from_bytes(bytes.fromhex("3fff0235"))
+    assert (
+        sbc_info.sampling_frequency
+        == SbcMediaCodecInformation.SamplingFrequency.SF_44100
+        | SbcMediaCodecInformation.SamplingFrequency.SF_48000
+    )
+    assert (
+        sbc_info.channel_mode
+        == SbcMediaCodecInformation.ChannelMode.MONO
+        | SbcMediaCodecInformation.ChannelMode.DUAL_CHANNEL
+        | SbcMediaCodecInformation.ChannelMode.STEREO
+        | SbcMediaCodecInformation.ChannelMode.JOINT_STEREO
+    )
+    assert (
+        sbc_info.block_length
+        == SbcMediaCodecInformation.BlockLength.BL_4
+        | SbcMediaCodecInformation.BlockLength.BL_8
+        | SbcMediaCodecInformation.BlockLength.BL_12
+        | SbcMediaCodecInformation.BlockLength.BL_16
+    )
+    assert (
+        sbc_info.subbands
+        == SbcMediaCodecInformation.Subbands.S_4 | SbcMediaCodecInformation.Subbands.S_8
+    )
+    assert (
+        sbc_info.allocation_method
+        == SbcMediaCodecInformation.AllocationMethod.SNR
+        | SbcMediaCodecInformation.AllocationMethod.LOUDNESS
+    )
+    assert sbc_info.minimum_bitpool_value == 2
+    assert sbc_info.maximum_bitpool_value == 53
+
+    sbc_info2 = SbcMediaCodecInformation(
+        SbcMediaCodecInformation.SamplingFrequency.SF_44100
+        | SbcMediaCodecInformation.SamplingFrequency.SF_48000,
+        SbcMediaCodecInformation.ChannelMode.MONO
+        | SbcMediaCodecInformation.ChannelMode.DUAL_CHANNEL
+        | SbcMediaCodecInformation.ChannelMode.STEREO
+        | SbcMediaCodecInformation.ChannelMode.JOINT_STEREO,
+        SbcMediaCodecInformation.BlockLength.BL_4
+        | SbcMediaCodecInformation.BlockLength.BL_8
+        | SbcMediaCodecInformation.BlockLength.BL_12
+        | SbcMediaCodecInformation.BlockLength.BL_16,
+        SbcMediaCodecInformation.Subbands.S_4 | SbcMediaCodecInformation.Subbands.S_8,
+        SbcMediaCodecInformation.AllocationMethod.SNR
+        | SbcMediaCodecInformation.AllocationMethod.LOUDNESS,
+        2,
+        53,
+    )
+    assert sbc_info == sbc_info2
+    assert bytes(sbc_info2) == bytes.fromhex("3fff0235")
+
+
+# -----------------------------------------------------------------------------
+def test_aac_codec_specific_information():
+    aac_info = AacMediaCodecInformation.from_bytes(bytes.fromhex("f0018c83e800"))
+    assert (
+        aac_info.object_type
+        == AacMediaCodecInformation.ObjectType.MPEG_2_AAC_LC
+        | AacMediaCodecInformation.ObjectType.MPEG_4_AAC_LC
+        | AacMediaCodecInformation.ObjectType.MPEG_4_AAC_LTP
+        | AacMediaCodecInformation.ObjectType.MPEG_4_AAC_SCALABLE
+    )
+    assert (
+        aac_info.sampling_frequency
+        == AacMediaCodecInformation.SamplingFrequency.SF_44100
+        | AacMediaCodecInformation.SamplingFrequency.SF_48000
+    )
+    assert (
+        aac_info.channels
+        == AacMediaCodecInformation.Channels.MONO
+        | AacMediaCodecInformation.Channels.STEREO
+    )
+    assert aac_info.vbr == 1
+    assert aac_info.bitrate == 256000
+
+    aac_info2 = AacMediaCodecInformation(
+        AacMediaCodecInformation.ObjectType.MPEG_2_AAC_LC
+        | AacMediaCodecInformation.ObjectType.MPEG_4_AAC_LC
+        | AacMediaCodecInformation.ObjectType.MPEG_4_AAC_LTP
+        | AacMediaCodecInformation.ObjectType.MPEG_4_AAC_SCALABLE,
+        AacMediaCodecInformation.SamplingFrequency.SF_44100
+        | AacMediaCodecInformation.SamplingFrequency.SF_48000,
+        AacMediaCodecInformation.Channels.MONO
+        | AacMediaCodecInformation.Channels.STEREO,
+        1,
+        256000,
+    )
+    assert aac_info == aac_info2
+    assert bytes(aac_info2) == bytes.fromhex("f0018c83e800")
+
+
+# -----------------------------------------------------------------------------
+def test_opus_codec_specific_information():
+    opus_info = OpusMediaCodecInformation.from_bytes(bytes([0x92]))
+    assert opus_info.vendor_id == OpusMediaCodecInformation.VENDOR_ID
+    assert opus_info.codec_id == OpusMediaCodecInformation.CODEC_ID
+    assert opus_info.frame_size == OpusMediaCodecInformation.FrameSize.FS_20MS
+    assert opus_info.channel_mode == OpusMediaCodecInformation.ChannelMode.STEREO
+    assert (
+        opus_info.sampling_frequency
+        == OpusMediaCodecInformation.SamplingFrequency.SF_48000
+    )
+
+    opus_info2 = OpusMediaCodecInformation(
+        OpusMediaCodecInformation.ChannelMode.STEREO,
+        OpusMediaCodecInformation.FrameSize.FS_20MS,
+        OpusMediaCodecInformation.SamplingFrequency.SF_48000,
+    )
+    assert opus_info2 == opus_info
+    assert opus_info2.value == bytes([0x92])
+
+
+# -----------------------------------------------------------------------------
+async def async_main():
+    test_sbc_codec_specific_information()
+    test_aac_codec_specific_information()
+    test_opus_codec_specific_information()
     await test_self_connection()
     await test_source_sink_1()
 
@@ -281,4 +398,4 @@ async def run_test_self():
 # -----------------------------------------------------------------------------
 if __name__ == '__main__':
     logging.basicConfig(level=os.environ.get('BUMBLE_LOGLEVEL', 'INFO').upper())
-    asyncio.run(run_test_self())
+    asyncio.run(async_main())
diff --git a/tests/aics_test.py b/tests/aics_test.py
index 9526558..b044c39 100644
--- a/tests/aics_test.py
+++ b/tests/aics_test.py
@@ -28,11 +28,12 @@ from bumble.profiles.aics import (
     AudioInputState,
     AICSServiceProxy,
     GainMode,
+    GainSettingsProperties,
     AudioInputStatus,
     AudioInputControlPointOpCode,
     ErrorCode,
 )
-from bumble.profiles.vcp import VolumeControlService, VolumeControlServiceProxy
+from bumble.profiles.vcs import VolumeControlService, VolumeControlServiceProxy
 
 from .test_utils import TwoDevices
 
@@ -82,7 +83,12 @@ async def test_init_service(aics_client: AICSServiceProxy):
         gain_mode=GainMode.MANUAL,
         change_counter=0,
     )
-    assert await aics_client.gain_settings_properties.read_value() == (1, 0, 255)
+    assert (
+        await aics_client.gain_settings_properties.read_value()
+        == GainSettingsProperties(
+            gain_settings_unit=1, gain_settings_minimum=0, gain_settings_maximum=255
+        )
+    )
     assert await aics_client.audio_input_status.read_value() == (
         AudioInputStatus.ACTIVE
     )
@@ -481,12 +487,12 @@ async def test_set_automatic_gain_mode_when_automatic_only(
 @pytest.mark.asyncio
 async def test_audio_input_description_initial_value(aics_client: AICSServiceProxy):
     description = await aics_client.audio_input_description.read_value()
-    assert description.decode('utf-8') == "Bluetooth"
+    assert description == "Bluetooth"
 
 
 @pytest.mark.asyncio
 async def test_audio_input_description_write_and_read(aics_client: AICSServiceProxy):
-    new_description = "Line Input".encode('utf-8')
+    new_description = "Line Input"
 
     await aics_client.audio_input_description.write_value(new_description)
 
diff --git a/tests/avdtp_test.py b/tests/avdtp_test.py
index 666a84c..09c4d86 100644
--- a/tests/avdtp_test.py
+++ b/tests/avdtp_test.py
@@ -23,13 +23,12 @@ from bumble.avdtp import (
     AVDTP_MEDIA_TRANSPORT_SERVICE_CATEGORY,
     AVDTP_SET_CONFIGURATION,
     Message,
-    MediaPacket,
     Get_Capabilities_Response,
     Set_Configuration_Command,
-    Set_Configuration_Response,
     ServiceCapabilities,
     MediaCodecCapabilities,
 )
+from bumble.rtp import MediaPacket
 
 
 # -----------------------------------------------------------------------------
diff --git a/tests/avrcp_test.py b/tests/avrcp_test.py
index 103f360..71955ea 100644
--- a/tests/avrcp_test.py
+++ b/tests/avrcp_test.py
@@ -70,7 +70,7 @@ class TwoDevices:
 
         self.connections = await asyncio.gather(
             self.devices[0].connect(
-                self.devices[1].public_address, core.BT_BR_EDR_TRANSPORT
+                self.devices[1].public_address, core.PhysicalTransport.BR_EDR
             ),
             self.devices[1].accept(self.devices[0].public_address),
         )
diff --git a/tests/bap_test.py b/tests/bap_test.py
index 0b57fcd..aad635e 100644
--- a/tests/bap_test.py
+++ b/tests/bap_test.py
@@ -39,6 +39,8 @@ from bumble.profiles.ascs import (
 )
 from bumble.profiles.bap import (
     AudioLocation,
+    BasicAudioAnnouncement,
+    BroadcastAudioAnnouncement,
     SupportedFrameDuration,
     SupportedSamplingFrequency,
     SamplingFrequency,
@@ -200,6 +202,56 @@ def test_codec_specific_configuration() -> None:
     assert CodecSpecificConfiguration.from_bytes(bytes(config)) == config
 
 
+# -----------------------------------------------------------------------------
+def test_broadcast_audio_announcement() -> None:
+    broadcast_audio_announcement = BroadcastAudioAnnouncement(123456)
+    assert (
+        BroadcastAudioAnnouncement.from_bytes(bytes(broadcast_audio_announcement))
+        == broadcast_audio_announcement
+    )
+
+
+# -----------------------------------------------------------------------------
+def test_basic_audio_announcement() -> None:
+    basic_audio_announcement = BasicAudioAnnouncement(
+        presentation_delay=40000,
+        subgroups=[
+            BasicAudioAnnouncement.Subgroup(
+                codec_id=CodingFormat(codec_id=CodecID.LC3),
+                codec_specific_configuration=CodecSpecificConfiguration(
+                    sampling_frequency=SamplingFrequency.FREQ_48000,
+                    frame_duration=FrameDuration.DURATION_10000_US,
+                    octets_per_codec_frame=100,
+                ),
+                metadata=Metadata(
+                    [
+                        Metadata.Entry(tag=Metadata.Tag.LANGUAGE, data=b'eng'),
+                        Metadata.Entry(tag=Metadata.Tag.PROGRAM_INFO, data=b'Disco'),
+                    ]
+                ),
+                bis=[
+                    BasicAudioAnnouncement.BIS(
+                        index=0,
+                        codec_specific_configuration=CodecSpecificConfiguration(
+                            audio_channel_allocation=AudioLocation.FRONT_LEFT
+                        ),
+                    ),
+                    BasicAudioAnnouncement.BIS(
+                        index=1,
+                        codec_specific_configuration=CodecSpecificConfiguration(
+                            audio_channel_allocation=AudioLocation.FRONT_RIGHT
+                        ),
+                    ),
+                ],
+            )
+        ],
+    )
+    assert (
+        BasicAudioAnnouncement.from_bytes(bytes(basic_audio_announcement))
+        == basic_audio_announcement
+    )
+
+
 # -----------------------------------------------------------------------------
 @pytest.mark.asyncio
 async def test_pacs():
diff --git a/tests/codecs_test.py b/tests/codecs_test.py
index b8affad..2a44e1e 100644
--- a/tests/codecs_test.py
+++ b/tests/codecs_test.py
@@ -15,8 +15,9 @@
 # -----------------------------------------------------------------------------
 # Imports
 # -----------------------------------------------------------------------------
+import random
 import pytest
-from bumble.codecs import AacAudioRtpPacket, BitReader
+from bumble.codecs import AacAudioRtpPacket, BitReader, BitWriter
 
 
 # -----------------------------------------------------------------------------
@@ -49,19 +50,58 @@ def test_reader():
     assert value == int.from_bytes(data, byteorder='big')
 
 
+def test_writer():
+    writer = BitWriter()
+    assert bytes(writer) == b''
+
+    for i in range(100):
+        for j in range(1, 10):
+            writer = BitWriter()
+            chunks = []
+            for k in range(j):
+                n_bits = random.randint(1, 32)
+                random_bits = random.getrandbits(n_bits)
+                chunks.append((n_bits, random_bits))
+                writer.write(random_bits, n_bits)
+
+            written_data = bytes(writer)
+            reader = BitReader(written_data)
+            for n_bits, written_bits in chunks:
+                read_bits = reader.read(n_bits)
+                assert read_bits == written_bits
+
+
 def test_aac_rtp():
     # pylint: disable=line-too-long
     packet_data = bytes.fromhex(
         '47fc0000b090800300202066000198000de120000000000000000000000000000000000000000000001c'
     )
-    packet = AacAudioRtpPacket(packet_data)
+    packet = AacAudioRtpPacket.from_bytes(packet_data)
     adts = packet.to_adts()
     assert adts == bytes.fromhex(
         'fff1508004fffc2066000198000de120000000000000000000000000000000000000000000001c'
     )
 
+    payload = bytes(list(range(1, 200)))
+    rtp = AacAudioRtpPacket.for_simple_aac(44100, 2, payload)
+    assert rtp.audio_mux_element.payload == payload
+    assert (
+        rtp.audio_mux_element.stream_mux_config.audio_specific_config.sampling_frequency
+        == 44100
+    )
+    assert (
+        rtp.audio_mux_element.stream_mux_config.audio_specific_config.channel_configuration
+        == 2
+    )
+    rtp2 = AacAudioRtpPacket.from_bytes(bytes(rtp))
+    assert str(rtp2.audio_mux_element.stream_mux_config) == str(
+        rtp.audio_mux_element.stream_mux_config
+    )
+    assert rtp2.audio_mux_element.payload == rtp.audio_mux_element.payload
+
 
 # -----------------------------------------------------------------------------
 if __name__ == '__main__':
     test_reader()
+    test_writer()
     test_aac_rtp()
diff --git a/tests/device_test.py b/tests/device_test.py
index 45b84ce..3478e3e 100644
--- a/tests/device_test.py
+++ b/tests/device_test.py
@@ -19,18 +19,20 @@ import asyncio
 import functools
 import logging
 import os
-from types import LambdaType
 import pytest
-from unittest import mock
 
 from bumble.core import (
-    BT_BR_EDR_TRANSPORT,
-    BT_LE_TRANSPORT,
-    BT_PERIPHERAL_ROLE,
+    PhysicalTransport,
     ConnectionParameters,
 )
-from bumble.device import AdvertisingParameters, Connection, Device
-from bumble.host import AclPacketQueue, Host
+from bumble.device import (
+    AdvertisingEventProperties,
+    AdvertisingParameters,
+    Connection,
+    Device,
+    PeriodicAdvertisingParameters,
+)
+from bumble.host import DataPacketQueue, Host
 from bumble.hci import (
     HCI_ACCEPT_CONNECTION_REQUEST_COMMAND,
     HCI_COMMAND_STATUS_PENDING,
@@ -39,6 +41,7 @@ from bumble.hci import (
     HCI_CONNECTION_FAILED_TO_BE_ESTABLISHED_ERROR,
     Address,
     OwnAddressType,
+    Role,
     HCI_Command_Complete_Event,
     HCI_Command_Status_Event,
     HCI_Connection_Complete_Event,
@@ -46,12 +49,8 @@ from bumble.hci import (
     HCI_Error,
     HCI_Packet,
 )
-from bumble.gatt import (
-    GATT_GENERIC_ACCESS_SERVICE,
-    GATT_CHARACTERISTIC_ATTRIBUTE_TYPE,
-    GATT_DEVICE_NAME_CHARACTERISTIC,
-    GATT_APPEARANCE_CHARACTERISTIC,
-)
+from bumble import utils
+from bumble import gatt
 
 from .test_utils import TwoDevices, async_barrier
 
@@ -86,9 +85,9 @@ async def test_device_connect_parallel():
     def _send(packet):
         pass
 
-    d0.host.acl_packet_queue = AclPacketQueue(0, 0, _send)
-    d1.host.acl_packet_queue = AclPacketQueue(0, 0, _send)
-    d2.host.acl_packet_queue = AclPacketQueue(0, 0, _send)
+    d0.host.acl_packet_queue = DataPacketQueue(0, 0, _send)
+    d1.host.acl_packet_queue = DataPacketQueue(0, 0, _send)
+    d2.host.acl_packet_queue = DataPacketQueue(0, 0, _send)
 
     # enable classic
     d0.classic_enabled = True
@@ -230,10 +229,10 @@ async def test_device_connect_parallel():
     [c01, c02, a10, a20] = await asyncio.gather(
         *[
             asyncio.create_task(
-                d0.connect(d1.public_address, transport=BT_BR_EDR_TRANSPORT)
+                d0.connect(d1.public_address, transport=PhysicalTransport.BR_EDR)
             ),
             asyncio.create_task(
-                d0.connect(d2.public_address, transport=BT_BR_EDR_TRANSPORT)
+                d0.connect(d2.public_address, transport=PhysicalTransport.BR_EDR)
             ),
             d1_accept_task,
             d2_accept_task,
@@ -253,7 +252,7 @@ async def test_device_connect_parallel():
 @pytest.mark.asyncio
 async def test_flush():
     d0 = Device(host=Host(None, None))
-    task = d0.abort_on('flush', asyncio.sleep(10000))
+    task = utils.cancel_on_event(d0, 'flush', asyncio.sleep(10000))
     await d0.host.flush()
     try:
         await task
@@ -265,7 +264,8 @@ async def test_flush():
 # -----------------------------------------------------------------------------
 @pytest.mark.asyncio
 async def test_legacy_advertising():
-    device = Device(host=mock.AsyncMock(Host))
+    device = TwoDevices()[0]
+    await device.power_on()
 
     # Start advertising
     await device.start_advertising()
@@ -283,16 +283,19 @@ async def test_legacy_advertising():
 )
 @pytest.mark.asyncio
 async def test_legacy_advertising_disconnection(auto_restart):
-    device = Device(host=mock.AsyncMock(spec=Host))
+    devices = TwoDevices()
+    device = devices[0]
+    devices.controllers[0].le_features = bytes.fromhex('ffffffffffffffff')
+    await device.power_on()
     peer_address = Address('F0:F1:F2:F3:F4:F5')
     await device.start_advertising(auto_restart=auto_restart)
     device.on_connection(
         0x0001,
-        BT_LE_TRANSPORT,
+        PhysicalTransport.LE,
         peer_address,
         None,
         None,
-        BT_PERIPHERAL_ROLE,
+        Role.PERIPHERAL,
         ConnectionParameters(0, 0, 0),
     )
 
@@ -305,6 +308,11 @@ async def test_legacy_advertising_disconnection(auto_restart):
     await async_barrier()
 
     if auto_restart:
+        assert device.legacy_advertising_set
+        started = asyncio.Event()
+        if not device.is_advertising:
+            device.legacy_advertising_set.once('start', started.set)
+            await asyncio.wait_for(started.wait(), _TIMEOUT)
         assert device.is_advertising
     else:
         assert not device.is_advertising
@@ -313,7 +321,8 @@ async def test_legacy_advertising_disconnection(auto_restart):
 # -----------------------------------------------------------------------------
 @pytest.mark.asyncio
 async def test_extended_advertising():
-    device = Device(host=mock.AsyncMock(Host))
+    device = TwoDevices()[0]
+    await device.power_on()
 
     # Start advertising
     advertising_set = await device.create_advertising_set()
@@ -332,18 +341,19 @@ async def test_extended_advertising():
 )
 @pytest.mark.asyncio
 async def test_extended_advertising_connection(own_address_type):
-    device = Device(host=mock.AsyncMock(spec=Host))
+    device = TwoDevices()[0]
+    await device.power_on()
     peer_address = Address('F0:F1:F2:F3:F4:F5')
     advertising_set = await device.create_advertising_set(
         advertising_parameters=AdvertisingParameters(own_address_type=own_address_type)
     )
     device.on_connection(
         0x0001,
-        BT_LE_TRANSPORT,
+        PhysicalTransport.LE,
         peer_address,
         None,
         None,
-        BT_PERIPHERAL_ROLE,
+        Role.PERIPHERAL,
         ConnectionParameters(0, 0, 0),
     )
     device.on_advertising_set_termination(
@@ -368,8 +378,10 @@ async def test_extended_advertising_connection(own_address_type):
 )
 @pytest.mark.asyncio
 async def test_extended_advertising_connection_out_of_order(own_address_type):
-    device = Device(host=mock.AsyncMock(spec=Host))
-    peer_address = Address('F0:F1:F2:F3:F4:F5')
+    devices = TwoDevices()
+    device = devices[0]
+    devices.controllers[0].le_features = bytes.fromhex('ffffffffffffffff')
+    await device.power_on()
     advertising_set = await device.create_advertising_set(
         advertising_parameters=AdvertisingParameters(own_address_type=own_address_type)
     )
@@ -381,11 +393,11 @@ async def test_extended_advertising_connection_out_of_order(own_address_type):
     )
     device.on_connection(
         0x0001,
-        BT_LE_TRANSPORT,
-        peer_address,
+        PhysicalTransport.LE,
+        Address('F0:F1:F2:F3:F4:F5'),
         None,
         None,
-        BT_PERIPHERAL_ROLE,
+        Role.PERIPHERAL,
         ConnectionParameters(0, 0, 0),
     )
 
@@ -397,6 +409,34 @@ async def test_extended_advertising_connection_out_of_order(own_address_type):
     await async_barrier()
 
 
+# -----------------------------------------------------------------------------
+@pytest.mark.asyncio
+async def test_periodic_advertising():
+    device = TwoDevices()[0]
+    await device.power_on()
+
+    # Start advertising
+    advertising_set = await device.create_advertising_set(
+        advertising_parameters=AdvertisingParameters(
+            advertising_event_properties=AdvertisingEventProperties(
+                is_connectable=False
+            )
+        ),
+        advertising_data=b'123',
+        periodic_advertising_parameters=PeriodicAdvertisingParameters(),
+        periodic_advertising_data=b'abc',
+    )
+    assert device.extended_advertising_sets
+    assert advertising_set.enabled
+    assert not advertising_set.periodic_enabled
+
+    await advertising_set.start_periodic()
+    assert advertising_set.periodic_enabled
+
+    await advertising_set.stop_periodic()
+    assert not advertising_set.periodic_enabled
+
+
 # -----------------------------------------------------------------------------
 @pytest.mark.asyncio
 async def test_get_remote_le_features():
@@ -443,8 +483,8 @@ async def test_cis():
         _cig_id: int,
         _cis_id: int,
     ):
-        acl_connection.abort_on(
-            'disconnection', devices[1].accept_cis_request(cis_handle)
+        utils.cancel_on_event(
+            acl_connection, 'disconnection', devices[1].accept_cis_request(cis_handle)
         )
         peripheral_cis_futures[cis_handle] = asyncio.get_running_loop().create_future()
 
@@ -547,32 +587,54 @@ async def test_power_on_default_static_address_should_not_be_any():
 
 
 # -----------------------------------------------------------------------------
-def test_gatt_services_with_gas():
+def test_gatt_services_with_gas_and_gatt():
     device = Device(host=Host(None, None))
 
-    # there should be one service and two chars, therefore 5 attributes
-    assert len(device.gatt_server.attributes) == 5
-    assert device.gatt_server.attributes[0].uuid == GATT_GENERIC_ACCESS_SERVICE
-    assert device.gatt_server.attributes[1].type == GATT_CHARACTERISTIC_ATTRIBUTE_TYPE
-    assert device.gatt_server.attributes[2].uuid == GATT_DEVICE_NAME_CHARACTERISTIC
-    assert device.gatt_server.attributes[3].type == GATT_CHARACTERISTIC_ATTRIBUTE_TYPE
-    assert device.gatt_server.attributes[4].uuid == GATT_APPEARANCE_CHARACTERISTIC
-
-
-# -----------------------------------------------------------------------------
-def test_gatt_services_without_gas():
-    device = Device(host=Host(None, None), generic_access_service=False)
+    # there should be 2 service, 5 chars, and 1 descriptors, therefore 13 attributes
+    assert len(device.gatt_server.attributes) == 13
+    assert device.gatt_server.attributes[0].uuid == gatt.GATT_GENERIC_ACCESS_SERVICE
+    assert (
+        device.gatt_server.attributes[1].type == gatt.GATT_CHARACTERISTIC_ATTRIBUTE_TYPE
+    )
+    assert device.gatt_server.attributes[2].uuid == gatt.GATT_DEVICE_NAME_CHARACTERISTIC
+    assert (
+        device.gatt_server.attributes[3].type == gatt.GATT_CHARACTERISTIC_ATTRIBUTE_TYPE
+    )
+    assert device.gatt_server.attributes[4].uuid == gatt.GATT_APPEARANCE_CHARACTERISTIC
 
-    # there should be no services
-    assert len(device.gatt_server.attributes) == 0
+    assert device.gatt_server.attributes[5].uuid == gatt.GATT_GENERIC_ATTRIBUTE_SERVICE
+    assert (
+        device.gatt_server.attributes[6].type == gatt.GATT_CHARACTERISTIC_ATTRIBUTE_TYPE
+    )
+    assert (
+        device.gatt_server.attributes[7].uuid
+        == gatt.GATT_SERVICE_CHANGED_CHARACTERISTIC
+    )
+    assert (
+        device.gatt_server.attributes[8].type
+        == gatt.GATT_CLIENT_CHARACTERISTIC_CONFIGURATION_DESCRIPTOR
+    )
+    assert (
+        device.gatt_server.attributes[9].type == gatt.GATT_CHARACTERISTIC_ATTRIBUTE_TYPE
+    )
+    assert (
+        device.gatt_server.attributes[10].uuid
+        == gatt.GATT_CLIENT_SUPPORTED_FEATURES_CHARACTERISTIC
+    )
+    assert (
+        device.gatt_server.attributes[11].type
+        == gatt.GATT_CHARACTERISTIC_ATTRIBUTE_TYPE
+    )
+    assert (
+        device.gatt_server.attributes[12].uuid == gatt.GATT_DATABASE_HASH_CHARACTERISTIC
+    )
 
 
 # -----------------------------------------------------------------------------
 async def run_test_device():
     await test_device_connect_parallel()
     await test_flush()
-    await test_gatt_services_with_gas()
-    await test_gatt_services_without_gas()
+    await test_gatt_services_with_gas_and_gatt()
 
 
 # -----------------------------------------------------------------------------
diff --git a/tests/gatt_service_test.py b/tests/gatt_service_test.py
new file mode 100644
index 0000000..d8e4477
--- /dev/null
+++ b/tests/gatt_service_test.py
@@ -0,0 +1,143 @@
+# Copyright 2021-2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
+from __future__ import annotations
+import pytest
+
+from . import test_utils
+
+from bumble import device
+from bumble import gatt
+from bumble.profiles import gatt_service
+
+
+# -----------------------------------------------------------------------------
+@pytest.mark.asyncio
+async def test_database_hash():
+    devices = await test_utils.TwoDevices.create_with_connection()
+    devices[0].gatt_server.services.clear()
+    devices[0].gatt_server.attributes.clear()
+    devices[0].gatt_server.attributes_by_handle.clear()
+    devices[0].add_service(
+        gatt.Service(
+            gatt.GATT_GENERIC_ACCESS_SERVICE,
+            characteristics=[
+                gatt.Characteristic(
+                    gatt.GATT_DEVICE_NAME_CHARACTERISTIC,
+                    (
+                        gatt.Characteristic.Properties.READ
+                        | gatt.Characteristic.Properties.WRITE
+                    ),
+                    gatt.Characteristic.Permissions.READ_REQUIRES_AUTHENTICATION,
+                ),
+                gatt.Characteristic(
+                    gatt.GATT_APPEARANCE_CHARACTERISTIC,
+                    gatt.Characteristic.Properties.READ,
+                    gatt.Characteristic.Permissions.READ_REQUIRES_AUTHENTICATION,
+                ),
+            ],
+        )
+    )
+    devices[0].add_service(
+        gatt_service.GenericAttributeProfileService(
+            server_supported_features=None,
+            database_hash_enabled=True,
+            service_change_enabled=True,
+        )
+    )
+    devices[0].gatt_server.add_attribute(
+        gatt.Service(gatt.GATT_GLUCOSE_SERVICE, characteristics=[])
+    )
+    # There is a special attribute order in the spec, so we need to add attribute one by
+    # one here.
+    battery_service = gatt.Service(
+        gatt.GATT_BATTERY_SERVICE,
+        characteristics=[
+            gatt.Characteristic(
+                gatt.GATT_BATTERY_LEVEL_CHARACTERISTIC,
+                properties=gatt.Characteristic.Properties.READ,
+                permissions=gatt.Characteristic.Permissions.READ_REQUIRES_AUTHENTICATION,
+            )
+        ],
+        primary=False,
+    )
+    battery_service.handle = 0x0014
+    battery_service.end_group_handle = 0x0016
+    devices[0].gatt_server.add_attribute(
+        gatt.IncludedServiceDeclaration(battery_service)
+    )
+    c = gatt.Characteristic(
+        '2A18',
+        properties=(
+            gatt.Characteristic.Properties.READ
+            | gatt.Characteristic.Properties.INDICATE
+            | gatt.Characteristic.Properties.EXTENDED_PROPERTIES
+        ),
+        permissions=gatt.Characteristic.Permissions.READ_REQUIRES_AUTHENTICATION,
+    )
+    devices[0].gatt_server.add_attribute(
+        gatt.CharacteristicDeclaration(c, devices[0].gatt_server.next_handle() + 1)
+    )
+    devices[0].gatt_server.add_attribute(c)
+    devices[0].gatt_server.add_attribute(
+        gatt.Descriptor(
+            gatt.GATT_CLIENT_CHARACTERISTIC_CONFIGURATION_DESCRIPTOR,
+            gatt.Descriptor.Permissions.READ_REQUIRES_AUTHENTICATION,
+            b'\x02\x00',
+        ),
+    )
+    devices[0].gatt_server.add_attribute(
+        gatt.Descriptor(
+            gatt.GATT_CHARACTERISTIC_EXTENDED_PROPERTIES_DESCRIPTOR,
+            gatt.Descriptor.Permissions.READ_REQUIRES_AUTHENTICATION,
+            b'\x00\x00',
+        ),
+    )
+    devices[0].add_service(battery_service)
+
+    peer = device.Peer(devices.connections[1])
+    client = await peer.discover_service_and_create_proxy(
+        gatt_service.GenericAttributeProfileServiceProxy
+    )
+    assert client.database_hash_characteristic
+    assert await client.database_hash_characteristic.read_value() == bytes.fromhex(
+        'F1CA2D48ECF58BAC8A8830BBB9FBA990'
+    )
+
+
+# -----------------------------------------------------------------------------
+@pytest.mark.asyncio
+async def test_service_changed():
+    devices = await test_utils.TwoDevices.create_with_connection()
+    assert (service := devices[0].gatt_service)
+
+    peer = device.Peer(devices.connections[1])
+    assert (
+        client := await peer.discover_service_and_create_proxy(
+            gatt_service.GenericAttributeProfileServiceProxy
+        )
+    )
+    assert client.service_changed_characteristic
+    indications = []
+    await client.service_changed_characteristic.subscribe(
+        indications.append, prefer_notify=False
+    )
+    await devices[0].indicate_subscribers(
+        service.service_changed_characteristic, b'1234'
+    )
+    await test_utils.async_barrier()
+    assert indications[0] == b'1234'
diff --git a/tests/gatt_test.py b/tests/gatt_test.py
index f783cae..c27f2d3 100644
--- a/tests/gatt_test.py
+++ b/tests/gatt_test.py
@@ -15,31 +15,45 @@
 # -----------------------------------------------------------------------------
 # Imports
 # -----------------------------------------------------------------------------
+from __future__ import annotations
 import asyncio
+import enum
 import logging
 import os
 import struct
 import pytest
+from typing import Any
+from typing_extensions import Self
 from unittest.mock import AsyncMock, Mock, ANY
 
 from bumble.controller import Controller
-from bumble.gatt_client import CharacteristicProxy
 from bumble.link import LocalLink
 from bumble.device import Device, Peer
 from bumble.host import Host
 from bumble.gatt import (
     GATT_BATTERY_LEVEL_CHARACTERISTIC,
     GATT_CLIENT_CHARACTERISTIC_CONFIGURATION_DESCRIPTOR,
-    CharacteristicAdapter,
-    DelegatedCharacteristicAdapter,
-    PackedCharacteristicAdapter,
-    MappedCharacteristicAdapter,
-    UTF8CharacteristicAdapter,
     Service,
     Characteristic,
     CharacteristicValue,
     Descriptor,
 )
+from bumble.gatt_client import CharacteristicProxy
+from bumble.gatt_adapters import (
+    CharacteristicProxyAdapter,
+    SerializableCharacteristicAdapter,
+    SerializableCharacteristicProxyAdapter,
+    DelegatedCharacteristicAdapter,
+    DelegatedCharacteristicProxyAdapter,
+    PackedCharacteristicAdapter,
+    PackedCharacteristicProxyAdapter,
+    MappedCharacteristicAdapter,
+    MappedCharacteristicProxyAdapter,
+    UTF8CharacteristicAdapter,
+    UTF8CharacteristicProxyAdapter,
+    EnumCharacteristicAdapter,
+    EnumCharacteristicProxyAdapter,
+)
 from bumble.transport import AsyncPipeSink
 from bumble.core import UUID
 from bumble.att import (
@@ -57,7 +71,7 @@ from .test_utils import async_barrier
 
 # -----------------------------------------------------------------------------
 def basic_check(x):
-    pdu = x.to_bytes()
+    pdu = bytes(x)
     parsed = ATT_PDU.from_bytes(pdu)
     x_str = str(x)
     parsed_str = str(parsed)
@@ -74,7 +88,7 @@ def test_UUID():
     assert str(u) == '61A3512C-09BE-4DDC-A6A6-0B03667AAFC6'
     v = UUID(str(u))
     assert str(v) == '61A3512C-09BE-4DDC-A6A6-0B03667AAFC6'
-    w = UUID.from_bytes(v.to_bytes())
+    w = UUID.from_bytes(bytes(v))
     assert str(w) == '61A3512C-09BE-4DDC-A6A6-0B03667AAFC6'
 
     u1 = UUID.from_16_bits(0x1234)
@@ -122,9 +136,9 @@ async def test_characteristic_encoding():
         Characteristic.READABLE,
         123,
     )
-    x = await c.read_value(None)
+    x = await c.read_value(Mock())
     assert x == bytes([123])
-    await c.write_value(None, bytes([122]))
+    await c.write_value(Mock(), bytes([122]))
     assert c.value == 122
 
     class FooProxy(CharacteristicProxy):
@@ -196,7 +210,7 @@ async def test_characteristic_encoding():
     await async_barrier()
     assert characteristic.value == bytes([125])
 
-    cd = DelegatedCharacteristicAdapter(c, encode=lambda x: bytes([x // 2]))
+    cd = DelegatedCharacteristicProxyAdapter(c, encode=lambda x: bytes([x // 2]))
     await cd.write_value(100, with_response=True)
     await async_barrier()
     assert characteristic.value == bytes([50])
@@ -204,7 +218,7 @@ async def test_characteristic_encoding():
     c2 = peer.get_characteristics_by_uuid(async_characteristic.uuid)
     assert len(c2) == 1
     c2 = c2[0]
-    cd2 = PackedCharacteristicAdapter(c2, ">I")
+    cd2 = PackedCharacteristicProxyAdapter(c2, ">I")
     cd2v = await cd2.read_value()
     assert cd2v == 0x05060708
 
@@ -246,7 +260,7 @@ async def test_characteristic_encoding():
     await async_barrier()
     assert last_change is None
 
-    cd = DelegatedCharacteristicAdapter(c, decode=lambda x: x[0])
+    cd = DelegatedCharacteristicProxyAdapter(c, decode=lambda x: x[0])
     await cd.subscribe(on_change)
     await server.notify_subscribers(characteristic)
     await async_barrier()
@@ -310,86 +324,268 @@ async def test_attribute_getters():
 
 # -----------------------------------------------------------------------------
 @pytest.mark.asyncio
-async def test_CharacteristicAdapter():
-    # Check that the CharacteristicAdapter base class is transparent
+async def test_CharacteristicAdapter() -> None:
     v = bytes([1, 2, 3])
-    c = Characteristic(
+    c: Characteristic[Any] = Characteristic(
         GATT_BATTERY_LEVEL_CHARACTERISTIC,
         Characteristic.Properties.READ,
         Characteristic.READABLE,
         v,
     )
-    a = CharacteristicAdapter(c)
-
-    value = await a.read_value(None)
-    assert value == v
 
     v = bytes([3, 4, 5])
-    await a.write_value(None, v)
+    await c.write_value(Mock(), v)
     assert c.value == v
 
     # Simple delegated adapter
-    a = DelegatedCharacteristicAdapter(
+    delegated = DelegatedCharacteristicAdapter(
         c, lambda x: bytes(reversed(x)), lambda x: bytes(reversed(x))
     )
 
-    value = await a.read_value(None)
-    assert value == bytes(reversed(v))
+    delegated_value = await delegated.read_value(Mock())
+    assert delegated_value == bytes(reversed(v))
 
-    v = bytes([3, 4, 5])
-    await a.write_value(None, v)
-    assert a.value == bytes(reversed(v))
+    delegated_value2 = bytes([3, 4, 5])
+    await delegated.write_value(Mock(), delegated_value2)
+    assert delegated.value == bytes(reversed(delegated_value2))
 
     # Packed adapter with single element format
-    v = 1234
-    pv = struct.pack('>H', v)
-    c.value = v
-    a = PackedCharacteristicAdapter(c, '>H')
+    packed_value_ref = 1234
+    packed_value_bytes = struct.pack('>H', packed_value_ref)
+    c.value = packed_value_ref
+    packed = PackedCharacteristicAdapter(c, '>H')
 
-    value = await a.read_value(None)
-    assert value == pv
-    c.value = None
-    await a.write_value(None, pv)
-    assert a.value == v
+    packed_value_read = await packed.read_value(Mock())
+    assert packed_value_read == packed_value_bytes
+    c.value = b''
+    await packed.write_value(Mock(), packed_value_bytes)
+    assert packed.value == packed_value_ref
 
     # Packed adapter with multi-element format
     v1 = 1234
     v2 = 5678
-    pv = struct.pack('>HH', v1, v2)
+    packed_multi_value_bytes = struct.pack('>HH', v1, v2)
     c.value = (v1, v2)
-    a = PackedCharacteristicAdapter(c, '>HH')
+    packed_multi = PackedCharacteristicAdapter(c, '>HH')
 
-    value = await a.read_value(None)
-    assert value == pv
-    c.value = None
-    await a.write_value(None, pv)
-    assert a.value == (v1, v2)
+    packed_multi_read_value = await packed_multi.read_value(Mock())
+    assert packed_multi_read_value == packed_multi_value_bytes
+    packed_multi.value = b''
+    await packed_multi.write_value(Mock(), packed_multi_value_bytes)
+    assert packed_multi.value == (v1, v2)
 
     # Mapped adapter
     v1 = 1234
     v2 = 5678
-    pv = struct.pack('>HH', v1, v2)
+    packed_mapped_value_bytes = struct.pack('>HH', v1, v2)
     mapped = {'v1': v1, 'v2': v2}
     c.value = mapped
-    a = MappedCharacteristicAdapter(c, '>HH', ('v1', 'v2'))
+    packed_mapped = MappedCharacteristicAdapter(c, '>HH', ('v1', 'v2'))
 
-    value = await a.read_value(None)
-    assert value == pv
-    c.value = None
-    await a.write_value(None, pv)
-    assert a.value == mapped
+    packed_mapped_read_value = await packed_mapped.read_value(Mock())
+    assert packed_mapped_read_value == packed_mapped_value_bytes
+    c.value = b''
+    await packed_mapped.write_value(Mock(), packed_mapped_value_bytes)
+    assert packed_mapped.value == mapped
 
     # UTF-8 adapter
-    v = 'Hello π'
-    ev = v.encode('utf-8')
-    c.value = v
-    a = UTF8CharacteristicAdapter(c)
+    string_value = 'Hello π'
+    string_value_bytes = string_value.encode('utf-8')
+    c.value = string_value
+    string_c = UTF8CharacteristicAdapter(c)
+
+    string_read_value = await string_c.read_value(Mock())
+    assert string_read_value == string_value_bytes
+    c.value = b''
+    await string_c.write_value(Mock(), string_value_bytes)
+    assert string_c.value == string_value
+
+    # Class adapter
+    class BlaBla:
+        def __init__(self, a: int, b: int) -> None:
+            self.a = a
+            self.b = b
+
+        @classmethod
+        def from_bytes(cls, data: bytes) -> Self:
+            a, b = struct.unpack(">II", data)
+            return cls(a, b)
+
+        def __bytes__(self) -> bytes:
+            return struct.pack(">II", self.a, self.b)
+
+    class_value = BlaBla(3, 4)
+    class_value_bytes = struct.pack(">II", 3, 4)
+    c.value = class_value
+    class_c = SerializableCharacteristicAdapter(c, BlaBla)
+
+    class_read_value = await class_c.read_value(Mock())
+    assert class_read_value == class_value_bytes
+    class_c.value = b''
+    await class_c.write_value(Mock(), class_value_bytes)
+    assert isinstance(class_c.value, BlaBla)
+    assert class_c.value.a == class_value.a
+    assert class_c.value.b == class_value.b
+
+    # Enum adapter
+    class MyEnum(enum.IntEnum):
+        ENUM_1 = 1234
+        ENUM_2 = 5678
+
+    enum_value = MyEnum.ENUM_2
+    enum_value_bytes = int(enum_value).to_bytes(3, 'big')
+    c.value = enum_value
+    enum_c = EnumCharacteristicAdapter(c, MyEnum, 3, 'big')
+    enum_read_value = await enum_c.read_value(Mock())
+    assert enum_read_value == enum_value_bytes
+    enum_c.value = b''
+    await enum_c.write_value(Mock(), enum_value_bytes)
+    assert isinstance(enum_c.value, MyEnum)
+    assert enum_c.value == enum_value
+
+
+# -----------------------------------------------------------------------------
+@pytest.mark.asyncio
+async def test_CharacteristicProxyAdapter() -> None:
+    class Client:
+        def __init__(self, value):
+            self.value = value
+
+        async def read_value(self, handle, no_long_read=False) -> bytes:
+            return self.value
+
+        async def write_value(self, handle, value, with_response=False):
+            self.value = value
+
+    class TestAttributeProxy(CharacteristicProxy):
+        def __init__(self, value) -> None:
+            super().__init__(Client(value), 0, 0, None, 0)  # type: ignore
+
+        @property
+        def value(self):
+            return self.client.value
+
+        @value.setter
+        def value(self, value):
+            self.client.value = value
+
+    v = bytes([1, 2, 3])
+    c = TestAttributeProxy(v)
+    a: CharacteristicProxyAdapter = CharacteristicProxyAdapter(c)
+
+    value = await a.read_value()
+    assert value == v
+
+    v = bytes([3, 4, 5])
+    await a.write_value(v)
+    assert c.value == v
+
+    # Simple delegated adapter
+    delegated = DelegatedCharacteristicProxyAdapter(
+        c, lambda x: bytes(reversed(x)), lambda x: bytes(reversed(x))
+    )
 
-    value = await a.read_value(None)
-    assert value == ev
+    delegated_value = await delegated.read_value()
+    assert delegated_value == bytes(reversed(v))
+
+    delegated_value2 = bytes([3, 4, 5])
+    await delegated.write_value(delegated_value2)
+    assert c.value == bytes(reversed(delegated_value2))
+
+    # Packed adapter with single element format
+    packed_value_ref = 1234
+    packed_value_bytes = struct.pack('>H', packed_value_ref)
+    c.value = packed_value_bytes
+    packed = PackedCharacteristicProxyAdapter(c, '>H')
+
+    packed_value_read = await packed.read_value()
+    assert packed_value_read == packed_value_ref
     c.value = None
-    await a.write_value(None, ev)
-    assert a.value == v
+    await packed.write_value(packed_value_ref)
+    assert c.value == packed_value_bytes
+
+    # Packed adapter with multi-element format
+    v1 = 1234
+    v2 = 5678
+    packed_multi_value_bytes = struct.pack('>HH', v1, v2)
+    c.value = packed_multi_value_bytes
+    packed_multi = PackedCharacteristicProxyAdapter(c, '>HH')
+
+    packed_multi_read_value = await packed_multi.read_value()
+    assert packed_multi_read_value == (v1, v2)
+    c.value = b''
+    await packed_multi.write_value((v1, v2))
+    assert c.value == packed_multi_value_bytes
+
+    # Mapped adapter
+    v1 = 1234
+    v2 = 5678
+    packed_mapped_value_bytes = struct.pack('>HH', v1, v2)
+    mapped = {'v1': v1, 'v2': v2}
+    c.value = packed_mapped_value_bytes
+    packed_mapped = MappedCharacteristicProxyAdapter(c, '>HH', ('v1', 'v2'))
+
+    packed_mapped_read_value = await packed_mapped.read_value()
+    assert packed_mapped_read_value == mapped
+    c.value = b''
+    await packed_mapped.write_value(mapped)
+    assert c.value == packed_mapped_value_bytes
+
+    # UTF-8 adapter
+    string_value = 'Hello π'
+    string_value_bytes = string_value.encode('utf-8')
+    c.value = string_value_bytes
+    string_c = UTF8CharacteristicProxyAdapter(c)
+
+    string_read_value = await string_c.read_value()
+    assert string_read_value == string_value
+    c.value = b''
+    await string_c.write_value(string_value)
+    assert c.value == string_value_bytes
+
+    # Class adapter
+    class BlaBla:
+        def __init__(self, a: int, b: int) -> None:
+            self.a = a
+            self.b = b
+
+        @classmethod
+        def from_bytes(cls, data: bytes) -> Self:
+            a, b = struct.unpack(">II", data)
+            return cls(a, b)
+
+        def __bytes__(self) -> bytes:
+            return struct.pack(">II", self.a, self.b)
+
+    class_value = BlaBla(3, 4)
+    class_value_bytes = struct.pack(">II", 3, 4)
+    c.value = class_value_bytes
+    class_c = SerializableCharacteristicProxyAdapter(c, BlaBla)
+
+    class_read_value = await class_c.read_value()
+    assert isinstance(class_read_value, BlaBla)
+    assert class_read_value.a == class_value.a
+    assert class_read_value.b == class_value.b
+    c.value = b''
+    await class_c.write_value(class_value)
+    assert c.value == class_value_bytes
+
+    # Enum adapter
+    class MyEnum(enum.IntEnum):
+        ENUM_1 = 1234
+        ENUM_2 = 5678
+
+    enum_value = MyEnum.ENUM_1
+    enum_value_bytes = int(enum_value).to_bytes(3, 'little')
+    c.value = enum_value_bytes
+    enum_c = EnumCharacteristicProxyAdapter(c, MyEnum, 3)
+
+    enum_read_value = await enum_c.read_value()
+    assert isinstance(enum_read_value, MyEnum)
+    assert enum_read_value == enum_value
+    c.value = b''
+    await enum_c.write_value(enum_value)
+    assert c.value == enum_value_bytes
 
 
 # -----------------------------------------------------------------------------
@@ -571,7 +767,7 @@ async def test_read_write2():
     v1 = await c1.read_value()
     assert v1 == v
 
-    a1 = PackedCharacteristicAdapter(c1, '>I')
+    a1 = PackedCharacteristicProxyAdapter(c1, '>I')
     v1 = await a1.read_value()
     assert v1 == struct.unpack('>I', v)[0]
 
@@ -851,7 +1047,12 @@ async def test_unsubscribe():
     await async_barrier()
     mock1.assert_called_once_with(ANY, True, False)
 
-    await c2.subscribe()
+    assert len(server.gatt_server.subscribers) == 1
+
+    def callback(_):
+        pass
+
+    await c2.subscribe(callback)
     await async_barrier()
     mock2.assert_called_once_with(ANY, True, False)
 
@@ -861,10 +1062,16 @@ async def test_unsubscribe():
     mock1.assert_called_once_with(ANY, False, False)
 
     mock2.reset_mock()
-    await c2.unsubscribe()
+    await c2.unsubscribe(callback)
     await async_barrier()
     mock2.assert_called_once_with(ANY, False, False)
 
+    # All CCCDs should be zeros now
+    assert list(server.gatt_server.subscribers.values())[0] == {
+        c1.handle: bytes([0, 0]),
+        c2.handle: bytes([0, 0]),
+    }
+
     mock1.reset_mock()
     await c1.unsubscribe()
     await async_barrier()
@@ -916,11 +1123,12 @@ async def test_discover_all():
     peer = Peer(connection)
 
     await peer.discover_all()
-    assert len(peer.gatt_client.services) == 3
-    # service 1800 gets added automatically
+    assert len(peer.gatt_client.services) == 4
+    # service 1800 and 1801 get added automatically
     assert peer.gatt_client.services[0].uuid == UUID('1800')
-    assert peer.gatt_client.services[1].uuid == service1.uuid
-    assert peer.gatt_client.services[2].uuid == service2.uuid
+    assert peer.gatt_client.services[1].uuid == UUID('1801')
+    assert peer.gatt_client.services[2].uuid == service1.uuid
+    assert peer.gatt_client.services[3].uuid == service2.uuid
     s = peer.get_services_by_uuid(service1.uuid)
     assert len(s) == 1
     assert len(s[0].characteristics) == 2
@@ -1043,10 +1251,18 @@ CharacteristicDeclaration(handle=0x0002, value_handle=0x0003, uuid=UUID-16:2A00
 Characteristic(handle=0x0003, end=0x0003, uuid=UUID-16:2A00 (Device Name), READ)
 CharacteristicDeclaration(handle=0x0004, value_handle=0x0005, uuid=UUID-16:2A01 (Appearance), READ)
 Characteristic(handle=0x0005, end=0x0005, uuid=UUID-16:2A01 (Appearance), READ)
-Service(handle=0x0006, end=0x0009, uuid=3A657F47-D34F-46B3-B1EC-698E29B6B829)
-CharacteristicDeclaration(handle=0x0007, value_handle=0x0008, uuid=FDB159DB-036C-49E3-B3DB-6325AC750806, READ|WRITE|NOTIFY)
-Characteristic(handle=0x0008, end=0x0009, uuid=FDB159DB-036C-49E3-B3DB-6325AC750806, READ|WRITE|NOTIFY)
-Descriptor(handle=0x0009, type=UUID-16:2902 (Client Characteristic Configuration), value=0000)"""
+Service(handle=0x0006, end=0x000D, uuid=UUID-16:1801 (Generic Attribute))
+CharacteristicDeclaration(handle=0x0007, value_handle=0x0008, uuid=UUID-16:2A05 (Service Changed), INDICATE)
+Characteristic(handle=0x0008, end=0x0009, uuid=UUID-16:2A05 (Service Changed), INDICATE)
+Descriptor(handle=0x0009, type=UUID-16:2902 (Client Characteristic Configuration), value=<dynamic>)
+CharacteristicDeclaration(handle=0x000A, value_handle=0x000B, uuid=UUID-16:2B29 (Client Supported Features), READ|WRITE)
+Characteristic(handle=0x000B, end=0x000B, uuid=UUID-16:2B29 (Client Supported Features), READ|WRITE)
+CharacteristicDeclaration(handle=0x000C, value_handle=0x000D, uuid=UUID-16:2B2A (Database Hash), READ)
+Characteristic(handle=0x000D, end=0x000D, uuid=UUID-16:2B2A (Database Hash), READ)
+Service(handle=0x000E, end=0x0011, uuid=3A657F47-D34F-46B3-B1EC-698E29B6B829)
+CharacteristicDeclaration(handle=0x000F, value_handle=0x0010, uuid=FDB159DB-036C-49E3-B3DB-6325AC750806, READ|WRITE|NOTIFY)
+Characteristic(handle=0x0010, end=0x0011, uuid=FDB159DB-036C-49E3-B3DB-6325AC750806, READ|WRITE|NOTIFY)
+Descriptor(handle=0x0011, type=UUID-16:2902 (Client Characteristic Configuration), value=<dynamic>)"""
     )
 
 
@@ -1064,6 +1280,7 @@ async def async_main():
     await test_CharacteristicValue()
     await test_CharacteristicValue_async()
     await test_CharacteristicAdapter()
+    await test_CharacteristicProxyAdapter()
 
 
 # -----------------------------------------------------------------------------
diff --git a/tests/gmap_test.py b/tests/gmap_test.py
new file mode 100644
index 0000000..9901267
--- /dev/null
+++ b/tests/gmap_test.py
@@ -0,0 +1,88 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
+import pytest
+import pytest_asyncio
+
+from bumble import device
+from bumble.profiles.gmap import (
+    GamingAudioService,
+    GamingAudioServiceProxy,
+    GmapRole,
+    UggFeatures,
+    UgtFeatures,
+    BgrFeatures,
+    BgsFeatures,
+)
+
+from .test_utils import TwoDevices
+
+# -----------------------------------------------------------------------------
+# Tests
+# -----------------------------------------------------------------------------
+gmas_service = GamingAudioService(
+    gmap_role=GmapRole.UNICAST_GAME_GATEWAY
+    | GmapRole.UNICAST_GAME_TERMINAL
+    | GmapRole.BROADCAST_GAME_RECEIVER
+    | GmapRole.BROADCAST_GAME_SENDER,
+    ugg_features=UggFeatures.UGG_MULTISINK,
+    ugt_features=UgtFeatures.UGT_SOURCE,
+    bgr_features=BgrFeatures.BGR_MULTISINK,
+    bgs_features=BgsFeatures.BGS_96_KBPS,
+)
+
+
+@pytest_asyncio.fixture
+async def gmap_client():
+    devices = TwoDevices()
+    devices[0].add_service(gmas_service)
+
+    await devices.setup_connection()
+
+    assert devices.connections[0]
+    assert devices.connections[1]
+
+    devices.connections[0].encryption = 1
+    devices.connections[1].encryption = 1
+
+    peer = device.Peer(devices.connections[1])
+
+    gmap_client = await peer.discover_service_and_create_proxy(GamingAudioServiceProxy)
+
+    assert gmap_client
+    yield gmap_client
+
+
+# -----------------------------------------------------------------------------
+@pytest.mark.asyncio
+async def test_init_service(gmap_client: GamingAudioServiceProxy):
+    assert (
+        await gmap_client.gmap_role.read_value()
+        == GmapRole.UNICAST_GAME_GATEWAY
+        | GmapRole.UNICAST_GAME_TERMINAL
+        | GmapRole.BROADCAST_GAME_RECEIVER
+        | GmapRole.BROADCAST_GAME_SENDER
+    )
+    assert gmap_client.ugg_features is not None
+    assert await gmap_client.ugg_features.read_value() == UggFeatures.UGG_MULTISINK
+    assert gmap_client.ugt_features is not None
+    assert await gmap_client.ugt_features.read_value() == UgtFeatures.UGT_SOURCE
+    assert gmap_client.bgr_features is not None
+    assert await gmap_client.bgr_features.read_value() == BgrFeatures.BGR_MULTISINK
+    assert gmap_client.bgs_features is not None
+    assert await gmap_client.bgs_features.read_value() == BgsFeatures.BGS_96_KBPS
diff --git a/tests/hci_test.py b/tests/hci_test.py
index 1b69cda..eac641e 100644
--- a/tests/hci_test.py
+++ b/tests/hci_test.py
@@ -15,6 +15,7 @@
 # -----------------------------------------------------------------------------
 # Imports
 # -----------------------------------------------------------------------------
+import struct
 
 from bumble.hci import (
     HCI_DISCONNECT_COMMAND,
@@ -22,6 +23,7 @@ from bumble.hci import (
     HCI_LE_CODED_PHY_BIT,
     HCI_LE_READ_BUFFER_SIZE_COMMAND,
     HCI_RESET_COMMAND,
+    HCI_VENDOR_EVENT,
     HCI_SUCCESS,
     HCI_LE_CONNECTION_COMPLETE_EVENT,
     HCI_LE_ENHANCED_CONNECTION_COMPLETE_V2_EVENT,
@@ -67,6 +69,7 @@ from bumble.hci import (
     HCI_Read_Local_Version_Information_Command,
     HCI_Reset_Command,
     HCI_Set_Event_Mask_Command,
+    HCI_Vendor_Event,
 )
 
 
@@ -75,13 +78,13 @@ from bumble.hci import (
 
 
 def basic_check(x):
-    packet = x.to_bytes()
+    packet = bytes(x)
     print(packet.hex())
     parsed = HCI_Packet.from_bytes(packet)
     x_str = str(x)
     parsed_str = str(parsed)
     print(x_str)
-    parsed_bytes = parsed.to_bytes()
+    parsed_bytes = bytes(parsed)
     assert x_str == parsed_str
     assert packet == parsed_bytes
 
@@ -167,8 +170,8 @@ def test_HCI_Command_Complete_Event():
         command_opcode=HCI_LE_READ_BUFFER_SIZE_COMMAND,
         return_parameters=HCI_LE_Read_Buffer_Size_Command.create_return_parameters(
             status=0,
-            hc_le_acl_data_packet_length=1234,
-            hc_total_num_le_acl_data_packets=56,
+            le_acl_data_packet_length=1234,
+            total_num_le_acl_data_packets=56,
         ),
     )
     basic_check(event)
@@ -188,7 +191,7 @@ def test_HCI_Command_Complete_Event():
         return_parameters=bytes([7]),
     )
     basic_check(event)
-    event = HCI_Packet.from_bytes(event.to_bytes())
+    event = HCI_Packet.from_bytes(bytes(event))
     assert event.return_parameters == 7
 
     # With a simple status as an integer status
@@ -213,6 +216,41 @@ def test_HCI_Number_Of_Completed_Packets_Event():
     basic_check(event)
 
 
+# -----------------------------------------------------------------------------
+def test_HCI_Vendor_Event():
+    data = bytes.fromhex('01020304')
+    event = HCI_Vendor_Event(data=data)
+    event_bytes = bytes(event)
+    parsed = HCI_Packet.from_bytes(event_bytes)
+    assert isinstance(parsed, HCI_Vendor_Event)
+    assert parsed.data == data
+
+    class HCI_Custom_Event(HCI_Event):
+        def __init__(self, blabla):
+            super().__init__(HCI_VENDOR_EVENT, parameters=struct.pack("<I", blabla))
+            self.name = 'HCI_CUSTOM_EVENT'
+            self.blabla = blabla
+
+    def create_event(payload):
+        if payload[0] == 1:
+            return HCI_Custom_Event(blabla=struct.unpack('<I', payload)[0])
+        return None
+
+    HCI_Event.add_vendor_factory(create_event)
+    parsed = HCI_Packet.from_bytes(event_bytes)
+    assert isinstance(parsed, HCI_Custom_Event)
+    assert parsed.blabla == 0x04030201
+    event_bytes2 = event_bytes[:3] + bytes([7]) + event_bytes[4:]
+    parsed = HCI_Packet.from_bytes(event_bytes2)
+    assert not isinstance(parsed, HCI_Custom_Event)
+    assert isinstance(parsed, HCI_Vendor_Event)
+    HCI_Event.remove_vendor_factory(create_event)
+
+    parsed = HCI_Packet.from_bytes(event_bytes)
+    assert not isinstance(parsed, HCI_Custom_Event)
+    assert isinstance(parsed, HCI_Vendor_Event)
+
+
 # -----------------------------------------------------------------------------
 def test_HCI_Command():
     command = HCI_Command(0x5566)
@@ -562,7 +600,7 @@ def test_iso_data_packet():
         '6281bc77ed6a3206d984bcdabee6be831c699cb50e2'
     )
 
-    assert packet.to_bytes() == data
+    assert bytes(packet) == data
 
 
 # -----------------------------------------------------------------------------
@@ -576,6 +614,7 @@ def run_test_events():
     test_HCI_Command_Complete_Event()
     test_HCI_Command_Status_Event()
     test_HCI_Number_Of_Completed_Packets_Event()
+    test_HCI_Vendor_Event()
 
 
 # -----------------------------------------------------------------------------
diff --git a/tests/hfp_test.py b/tests/hfp_test.py
index 83b0d35..1926342 100644
--- a/tests/hfp_test.py
+++ b/tests/hfp_test.py
@@ -61,7 +61,7 @@ def _default_hf_configuration() -> hfp.HfConfiguration:
 # -----------------------------------------------------------------------------
 def _default_hf_sdp_features() -> hfp.HfSdpFeature:
     return (
-        hfp.HfSdpFeature.WIDE_BAND
+        hfp.HfSdpFeature.WIDE_BAND_SPEECH
         | hfp.HfSdpFeature.THREE_WAY_CALLING
         | hfp.HfSdpFeature.CLI_PRESENTATION_CAPABILITY
     )
@@ -108,7 +108,7 @@ def _default_ag_configuration() -> hfp.AgConfiguration:
 # -----------------------------------------------------------------------------
 def _default_ag_sdp_features() -> hfp.AgSdpFeature:
     return (
-        hfp.AgSdpFeature.WIDE_BAND
+        hfp.AgSdpFeature.WIDE_BAND_SPEECH
         | hfp.AgSdpFeature.IN_BAND_RING_TONE_CAPABILITY
         | hfp.AgSdpFeature.THREE_WAY_CALLING
     )
@@ -522,7 +522,7 @@ async def test_sco_setup():
 
     connections = await asyncio.gather(
         devices[0].connect(
-            devices[1].public_address, transport=core.BT_BR_EDR_TRANSPORT
+            devices[1].public_address, transport=core.PhysicalTransport.BR_EDR
         ),
         devices[1].accept(devices[0].public_address),
     )
@@ -569,6 +569,37 @@ async def test_sco_setup():
     await asyncio.gather(*sco_disconnection_futures)
 
 
+# -----------------------------------------------------------------------------
+@pytest.mark.asyncio
+async def test_hf_batched_response(
+    hfp_connections: Tuple[hfp.HfProtocol, hfp.AgProtocol]
+):
+    hf, ag = hfp_connections
+
+    ag.dlc.write(b'\r\n+BIND: (1,2)\r\n\r\nOK\r\n')
+
+    await hf.execute_command("AT+BIND=?", response_type=hfp.AtResponseType.SINGLE)
+
+
+# -----------------------------------------------------------------------------
+@pytest.mark.asyncio
+async def test_ag_batched_commands(
+    hfp_connections: Tuple[hfp.HfProtocol, hfp.AgProtocol]
+):
+    hf, ag = hfp_connections
+
+    answer_future = asyncio.get_running_loop().create_future()
+    ag.on('answer', lambda: answer_future.set_result(None))
+
+    hang_up_future = asyncio.get_running_loop().create_future()
+    ag.on('hang_up', lambda: hang_up_future.set_result(None))
+
+    hf.dlc.write(b'ATA\rAT+CHUP\r')
+
+    await answer_future
+    await hang_up_future
+
+
 # -----------------------------------------------------------------------------
 async def run():
     await test_slc()
diff --git a/tests/host_test.py b/tests/host_test.py
index 5170497..ac3af9d 100644
--- a/tests/host_test.py
+++ b/tests/host_test.py
@@ -16,11 +16,14 @@
 # Imports
 # -----------------------------------------------------------------------------
 import logging
+import unittest.mock
 import pytest
+import unittest
 
 from bumble.controller import Controller
-from bumble.host import Host
+from bumble.host import Host, DataPacketQueue
 from bumble.transport import AsyncPipeSink
+from bumble.hci import HCI_AclDataPacket
 
 # -----------------------------------------------------------------------------
 # Logging
@@ -60,3 +63,90 @@ async def test_reset(supported_commands: str, lmp_features: str):
     assert host.local_lmp_features == int.from_bytes(
         bytes.fromhex(lmp_features), 'little'
     )
+
+
+# -----------------------------------------------------------------------------
+def test_data_packet_queue():
+    controller = unittest.mock.Mock()
+    queue = DataPacketQueue(10, 2, controller.send)
+    assert queue.queued == 0
+    assert queue.completed == 0
+    packet = HCI_AclDataPacket(
+        connection_handle=123, pb_flag=0, bc_flag=0, data_total_length=0, data=b''
+    )
+
+    queue.enqueue(packet, packet.connection_handle)
+    assert queue.queued == 1
+    assert queue.completed == 0
+    assert controller.send.call_count == 1
+
+    queue.enqueue(packet, packet.connection_handle)
+    assert queue.queued == 2
+    assert queue.completed == 0
+    assert controller.send.call_count == 2
+
+    queue.enqueue(packet, packet.connection_handle)
+    assert queue.queued == 3
+    assert queue.completed == 0
+    assert controller.send.call_count == 2
+
+    queue.on_packets_completed(1, 8000)
+    assert queue.queued == 3
+    assert queue.completed == 0
+    assert controller.send.call_count == 2
+
+    queue.on_packets_completed(1, 123)
+    assert queue.queued == 3
+    assert queue.completed == 1
+    assert controller.send.call_count == 3
+
+    queue.enqueue(packet, packet.connection_handle)
+    assert queue.queued == 4
+    assert queue.completed == 1
+    assert controller.send.call_count == 3
+
+    queue.on_packets_completed(2, 123)
+    assert queue.queued == 4
+    assert queue.completed == 3
+    assert controller.send.call_count == 4
+
+    queue.on_packets_completed(1, 123)
+    assert queue.queued == 4
+    assert queue.completed == 4
+    assert controller.send.call_count == 4
+
+    queue.enqueue(packet, 123)
+    queue.enqueue(packet, 123)
+    queue.enqueue(packet, 123)
+    queue.enqueue(packet, 124)
+    queue.enqueue(packet, 124)
+    queue.enqueue(packet, 124)
+    queue.on_packets_completed(1, 123)
+    assert queue.queued == 10
+    assert queue.completed == 5
+    queue.flush(123)
+    queue.flush(124)
+    assert queue.queued == 10
+    assert queue.completed == 10
+
+    queue.enqueue(packet, 123)
+    queue.on_packets_completed(1, 124)
+    assert queue.queued == 11
+    assert queue.completed == 10
+    queue.on_packets_completed(1000, 123)
+    assert queue.queued == 11
+    assert queue.completed == 11
+
+    drain_listener = unittest.mock.Mock()
+    queue.on('flow', drain_listener.on_flow)
+    queue.enqueue(packet, 123)
+    assert drain_listener.on_flow.call_count == 0
+    queue.on_packets_completed(1, 123)
+    assert drain_listener.on_flow.call_count == 1
+    queue.enqueue(packet, 123)
+    queue.enqueue(packet, 123)
+    queue.enqueue(packet, 123)
+    queue.flush(123)
+    assert drain_listener.on_flow.call_count == 1
+    assert queue.queued == 15
+    assert queue.completed == 15
diff --git a/tests/import_test.py b/tests/import_test.py
index 9542511..b868c0d 100644
--- a/tests/import_test.py
+++ b/tests/import_test.py
@@ -53,7 +53,7 @@ def test_import():
         le_audio,
         pacs,
         pbp,
-        vcp,
+        vcs,
     )
 
     assert att
@@ -87,7 +87,7 @@ def test_import():
     assert le_audio
     assert pacs
     assert pbp
-    assert vcp
+    assert vcs
 
 
 # -----------------------------------------------------------------------------
diff --git a/tests/sdp_test.py b/tests/sdp_test.py
index 91835e7..26d9d38 100644
--- a/tests/sdp_test.py
+++ b/tests/sdp_test.py
@@ -20,12 +20,11 @@ import logging
 import os
 import pytest
 
-from bumble.core import UUID, BT_L2CAP_PROTOCOL_ID, BT_RFCOMM_PROTOCOL_ID
+from bumble.core import UUID, BT_L2CAP_PROTOCOL_ID
 from bumble.sdp import (
     DataElement,
     ServiceAttribute,
     Client,
-    Server,
     SDP_SERVICE_RECORD_HANDLE_ATTRIBUTE_ID,
     SDP_BROWSE_GROUP_LIST_ATTRIBUTE_ID,
     SDP_PUBLIC_BROWSE_ROOT,
@@ -174,9 +173,10 @@ def test_data_elements() -> None:
 
 
 # -----------------------------------------------------------------------------
-def sdp_records():
+def sdp_records(record_count=1):
     return {
-        0x00010001: [
+        0x00010001
+        + i: [
             ServiceAttribute(
                 SDP_SERVICE_RECORD_HANDLE_ATTRIBUTE_ID,
                 DataElement.unsigned_integer_32(0x00010001),
@@ -200,6 +200,7 @@ def sdp_records():
                 ),
             ),
         ]
+        for i in range(record_count)
     }
 
 
@@ -216,19 +217,55 @@ async def test_service_search():
     devices.devices[0].sdp_server.service_records.update(sdp_records())
 
     # Search for service
-    client = Client(devices.connections[1])
-    await client.connect()
-    services = await client.search_services(
-        [UUID('E6D55659-C8B4-4B85-96BB-B1143AF6D3AE')]
-    )
+    async with Client(devices.connections[1]) as client:
+        services = await client.search_services(
+            [UUID('E6D55659-C8B4-4B85-96BB-B1143AF6D3AF')]
+        )
+        assert len(services) == 0
+
+        services = await client.search_services(
+            [UUID('E6D55659-C8B4-4B85-96BB-B1143AF6D3AE')]
+        )
+        assert len(services) == 1
+        assert services[0] == 0x00010001
+
+        services = await client.search_services(
+            [BT_L2CAP_PROTOCOL_ID, SDP_PUBLIC_BROWSE_ROOT]
+        )
+        assert len(services) == 1
+        assert services[0] == 0x00010001
+
+        services = await client.search_services(
+            [BT_L2CAP_PROTOCOL_ID, SDP_PUBLIC_BROWSE_ROOT]
+        )
+        assert len(services) == 1
+        assert services[0] == 0x00010001
+
+
+# -----------------------------------------------------------------------------
+@pytest.mark.asyncio
+async def test_service_search_with_continuation():
+    # Setup connections
+    devices = TwoDevices()
+    await devices.setup_connection()
 
-    # Then
-    assert services[0] == 0x00010001
+    # Register SDP service
+    records = sdp_records(100)
+    devices.devices[0].sdp_server.service_records.update(records)
+
+    # Search for service
+    async with Client(devices.connections[1], mtu=48) as client:
+        services = await client.search_services(
+            [UUID('E6D55659-C8B4-4B85-96BB-B1143AF6D3AE')]
+        )
+        assert len(services) == len(records)
+        for i in range(len(records)):
+            assert services[i] == 0x00010001 + i
 
 
 # -----------------------------------------------------------------------------
 @pytest.mark.asyncio
-async def test_service_attribute():
+async def test_service_attributes():
     # Setup connections
     devices = TwoDevices()
     await devices.setup_connection()
@@ -236,15 +273,43 @@ async def test_service_attribute():
     # Register SDP service
     devices.devices[0].sdp_server.service_records.update(sdp_records())
 
-    # Search for service
-    client = Client(devices.connections[1])
-    await client.connect()
-    attributes = await client.get_attributes(
-        0x00010001, [SDP_SERVICE_RECORD_HANDLE_ATTRIBUTE_ID]
-    )
+    # Get attributes
+    async with Client(devices.connections[1]) as client:
+        attributes = await client.get_attributes(0x00010001, [1234])
+        assert len(attributes) == 0
 
-    # Then
-    assert attributes[0].value.value == sdp_records()[0x00010001][0].value.value
+        attributes = await client.get_attributes(
+            0x00010001, [SDP_SERVICE_RECORD_HANDLE_ATTRIBUTE_ID]
+        )
+        assert len(attributes) == 1
+        assert attributes[0].value.value == sdp_records()[0x00010001][0].value.value
+
+
+# -----------------------------------------------------------------------------
+@pytest.mark.asyncio
+async def test_service_attributes_with_continuation():
+    # Setup connections
+    devices = TwoDevices()
+    await devices.setup_connection()
+
+    # Register SDP service
+    records = {
+        0x00010001: [
+            ServiceAttribute(
+                x,
+                DataElement.unsigned_integer_32(0x00010001),
+            )
+            for x in range(100)
+        ]
+    }
+    devices.devices[0].sdp_server.service_records.update(records)
+
+    # Get attributes
+    async with Client(devices.connections[1], mtu=48) as client:
+        attributes = await client.get_attributes(0x00010001, list(range(100)))
+        assert len(attributes) == 100
+        for i, attribute in enumerate(attributes):
+            assert attribute.id == i
 
 
 # -----------------------------------------------------------------------------
@@ -255,19 +320,81 @@ async def test_service_search_attribute():
     await devices.setup_connection()
 
     # Register SDP service
-    devices.devices[0].sdp_server.service_records.update(sdp_records())
+    records = {
+        0x00010001: [
+            ServiceAttribute(
+                4,
+                DataElement.sequence(
+                    [DataElement.uuid(UUID('E6D55659-C8B4-4B85-96BB-B1143AF6D3AE'))]
+                ),
+            ),
+            ServiceAttribute(
+                3,
+                DataElement.sequence(
+                    [DataElement.uuid(UUID('E6D55659-C8B4-4B85-96BB-B1143AF6D3AE'))]
+                ),
+            ),
+            ServiceAttribute(
+                1,
+                DataElement.sequence(
+                    [DataElement.uuid(UUID('E6D55659-C8B4-4B85-96BB-B1143AF6D3AE'))]
+                ),
+            ),
+        ]
+    }
+
+    devices.devices[0].sdp_server.service_records.update(records)
 
     # Search for service
-    client = Client(devices.connections[1])
-    await client.connect()
-    attributes = await client.search_attributes(
-        [UUID('E6D55659-C8B4-4B85-96BB-B1143AF6D3AE')], [(0x0000FFFF, 8)]
-    )
+    async with Client(devices.connections[1]) as client:
+        attributes = await client.search_attributes(
+            [UUID('E6D55659-C8B4-4B85-96BB-B1143AF6D3AE')], [(0, 0xFFFF)]
+        )
+        assert len(attributes) == 1
+        assert len(attributes[0]) == 3
+        assert attributes[0][0].id == 1
+        assert attributes[0][1].id == 3
+        assert attributes[0][2].id == 4
+
+        attributes = await client.search_attributes(
+            [UUID('E6D55659-C8B4-4B85-96BB-B1143AF6D3AE')], [1, 2, 3]
+        )
+        assert len(attributes) == 1
+        assert len(attributes[0]) == 2
+        assert attributes[0][0].id == 1
+        assert attributes[0][1].id == 3
 
-    # Then
-    for expect, actual in zip(attributes, sdp_records().values()):
-        assert expect.id == actual.id
-        assert expect.value == actual.value
+
+# -----------------------------------------------------------------------------
+@pytest.mark.asyncio
+async def test_service_search_attribute_with_continuation():
+    # Setup connections
+    devices = TwoDevices()
+    await devices.setup_connection()
+
+    # Register SDP service
+    records = {
+        0x00010001: [
+            ServiceAttribute(
+                x,
+                DataElement.sequence(
+                    [DataElement.uuid(UUID('E6D55659-C8B4-4B85-96BB-B1143AF6D3AE'))]
+                ),
+            )
+            for x in range(100)
+        ]
+    }
+    devices.devices[0].sdp_server.service_records.update(records)
+
+    # Search for service
+    async with Client(devices.connections[1], mtu=48) as client:
+        attributes = await client.search_attributes(
+            [UUID('E6D55659-C8B4-4B85-96BB-B1143AF6D3AE')], [(0, 0xFFFF)]
+        )
+        assert len(attributes) == 1
+        assert len(attributes[0]) == 100
+        for i in range(100):
+            assert attributes[0][i].id == i
 
 
 # -----------------------------------------------------------------------------
@@ -287,9 +414,12 @@ async def test_client_async_context():
 # -----------------------------------------------------------------------------
 async def run():
     test_data_elements()
-    await test_service_attribute()
+    await test_service_attributes()
+    await test_service_attributes_with_continuation()
     await test_service_search()
+    await test_service_search_with_continuation()
     await test_service_search_attribute()
+    await test_service_search_attribute_with_continuation()
 
 
 # -----------------------------------------------------------------------------
diff --git a/tests/self_test.py b/tests/self_test.py
index 5c68ea0..2456742 100644
--- a/tests/self_test.py
+++ b/tests/self_test.py
@@ -24,7 +24,7 @@ import pytest
 from unittest.mock import AsyncMock, MagicMock, patch
 
 from bumble.controller import Controller
-from bumble.core import BT_BR_EDR_TRANSPORT, BT_PERIPHERAL_ROLE, BT_CENTRAL_ROLE
+from bumble.core import PhysicalTransport
 from bumble.link import LocalLink
 from bumble.device import Device, Peer
 from bumble.host import Host
@@ -39,6 +39,7 @@ from bumble.smp import (
 )
 from bumble.core import ProtocolError
 from bumble.keys import PairingKeys
+from bumble.hci import Role
 
 
 # -----------------------------------------------------------------------------
@@ -111,7 +112,7 @@ async def test_self_connection():
 @pytest.mark.asyncio
 @pytest.mark.parametrize(
     'responder_role,',
-    (BT_CENTRAL_ROLE, BT_PERIPHERAL_ROLE),
+    (Role.CENTRAL, Role.PERIPHERAL),
 )
 async def test_self_classic_connection(responder_role):
     # Create two devices, each with a controller, attached to the same link
@@ -136,7 +137,7 @@ async def test_self_classic_connection(responder_role):
     # Connect the two devices
     await asyncio.gather(
         two_devices.devices[0].connect(
-            two_devices.devices[1].public_address, transport=BT_BR_EDR_TRANSPORT
+            two_devices.devices[1].public_address, transport=PhysicalTransport.BR_EDR
         ),
         two_devices.devices[1].accept(
             two_devices.devices[0].public_address, responder_role
@@ -240,7 +241,7 @@ async def test_self_gatt():
     result = await peer.discover_included_services(result[0])
     assert len(result) == 2
     # Service UUID is only present when the UUID is 16-bit Bluetooth UUID
-    assert result[1].uuid.to_bytes() == s3.uuid.to_bytes()
+    assert bytes(result[1].uuid) == bytes(s3.uuid)
 
 
 # -----------------------------------------------------------------------------
@@ -506,7 +507,7 @@ async def test_self_smp_over_classic():
     # Connect the two devices
     await asyncio.gather(
         two_devices.devices[0].connect(
-            two_devices.devices[1].public_address, transport=BT_BR_EDR_TRANSPORT
+            two_devices.devices[1].public_address, transport=PhysicalTransport.BR_EDR
         ),
         two_devices.devices[1].accept(two_devices.devices[0].public_address),
     )
diff --git a/tests/smp_test.py b/tests/smp_test.py
index 7f17bc2..89b6c88 100644
--- a/tests/smp_test.py
+++ b/tests/smp_test.py
@@ -21,17 +21,30 @@ from unittest import mock
 
 from bumble import smp
 from bumble import pairing
+from bumble import crypto
 from bumble.crypto import EccKey, aes_cmac, ah, c1, f4, f5, f6, g2, h6, h7, s1
 from bumble.pairing import OobData, OobSharedData, LeRole
 from bumble.hci import Address
 from bumble.core import AdvertisingData
 from bumble.device import Device
 
-from typing import Optional
+from typing import Optional, Any
+
 
 # -----------------------------------------------------------------------------
 # pylint: disable=invalid-name
 # -----------------------------------------------------------------------------
+@pytest.fixture(
+    scope="session", params=["bumble.crypto.builtin", "bumble.crypto.cryptography"]
+)
+def crypto_backend(request):
+    backend = pytest.importorskip(request.param)
+    with (
+        mock.patch.object(crypto, "e", backend.e),
+        mock.patch.object(crypto, "aes_cmac", backend.aes_cmac),
+        mock.patch.object(crypto, "EccKey", backend.EccKey),
+    ):
+        yield
 
 
 # -----------------------------------------------------------------------------
@@ -40,7 +53,7 @@ def reversed_hex(hex_str: str) -> bytes:
 
 
 # -----------------------------------------------------------------------------
-def test_ecc():
+def test_ecc(crypto_backend):
     key = EccKey.generate()
     x = key.x
     y = key.y
@@ -69,21 +82,17 @@ def test_ecc():
     )
     dhkey = 'ec0234a3 57c8ad05 341010a6 0a397d9b 99796b13 b4f866f1 868d34f3 73bfa698'
 
-    key_a = EccKey.from_private_key_bytes(
-        bytes.fromhex(private_A), bytes.fromhex(public_A_x), bytes.fromhex(public_A_y)
-    )
+    key_a = EccKey.from_private_key_bytes(bytes.fromhex(private_A))
     shared_key = key_a.dh(bytes.fromhex(public_B_x), bytes.fromhex(public_B_y))
     assert shared_key == bytes.fromhex(dhkey)
 
-    key_b = EccKey.from_private_key_bytes(
-        bytes.fromhex(private_B), bytes.fromhex(public_B_x), bytes.fromhex(public_B_y)
-    )
+    key_b = EccKey.from_private_key_bytes(bytes.fromhex(private_B))
     shared_key = key_b.dh(bytes.fromhex(public_A_x), bytes.fromhex(public_A_y))
     assert shared_key == bytes.fromhex(dhkey)
 
 
 # -----------------------------------------------------------------------------
-def test_c1():
+def test_c1(crypto_backend):
     k = bytes(16)
     r = reversed_hex('5783D52156AD6F0E6388274EC6702EE0')
     pres = reversed_hex('05000800000302')
@@ -97,7 +106,7 @@ def test_c1():
 
 
 # -----------------------------------------------------------------------------
-def test_s1():
+def test_s1(crypto_backend):
     k = bytes(16)
     r1 = reversed_hex('000F0E0D0C0B0A091122334455667788')
     r2 = reversed_hex('010203040506070899AABBCCDDEEFF00')
@@ -106,7 +115,7 @@ def test_s1():
 
 
 # -----------------------------------------------------------------------------
-def test_aes_cmac():
+def test_aes_cmac(crypto_backend):
     m = b''
     k = bytes.fromhex('2b7e1516 28aed2a6 abf71588 09cf4f3c')
     cmac = aes_cmac(m, k)
@@ -135,7 +144,7 @@ def test_aes_cmac():
 
 
 # -----------------------------------------------------------------------------
-def test_f4():
+def test_f4(crypto_backend):
     u = reversed_hex(
         '20b003d2 f297be2c 5e2c83a7 e9f9a5b9 eff49111 acf4fddb cc030148 0e359de6'
     )
@@ -149,7 +158,7 @@ def test_f4():
 
 
 # -----------------------------------------------------------------------------
-def test_f5():
+def test_f5(crypto_backend):
     w = reversed_hex(
         'ec0234a3 57c8ad05 341010a6 0a397d9b 99796b13 b4f866f1 868d34f3 73bfa698'
     )
@@ -163,7 +172,7 @@ def test_f5():
 
 
 # -----------------------------------------------------------------------------
-def test_f6():
+def test_f6(crypto_backend):
     n1 = reversed_hex('d5cb8454 d177733e ffffb2ec 712baeab')
     n2 = reversed_hex('a6e8e7cc 25a75f6e 216583f7 ff3dc4cf')
     mac_key = reversed_hex('2965f176 a1084a02 fd3f6a20 ce636e20')
@@ -176,7 +185,7 @@ def test_f6():
 
 
 # -----------------------------------------------------------------------------
-def test_g2():
+def test_g2(crypto_backend):
     u = reversed_hex(
         '20b003d2 f297be2c 5e2c83a7 e9f9a5b9 eff49111 acf4fddb cc030148 0e359de6'
     )
@@ -190,21 +199,21 @@ def test_g2():
 
 
 # -----------------------------------------------------------------------------
-def test_h6():
+def test_h6(crypto_backend):
     KEY = reversed_hex('ec0234a3 57c8ad05 341010a6 0a397d9b')
     KEY_ID = bytes.fromhex('6c656272')
     assert h6(KEY, KEY_ID) == reversed_hex('2d9ae102 e76dc91c e8d3a9e2 80b16399')
 
 
 # -----------------------------------------------------------------------------
-def test_h7():
+def test_h7(crypto_backend):
     KEY = reversed_hex('ec0234a3 57c8ad05 341010a6 0a397d9b')
     SALT = bytes.fromhex('00000000 00000000 00000000 746D7031')
     assert h7(SALT, KEY) == reversed_hex('fb173597 c6a3c0ec d2998c2a 75a57011')
 
 
 # -----------------------------------------------------------------------------
-def test_ah():
+def test_ah(crypto_backend):
     irk = reversed_hex('ec0234a3 57c8ad05 341010a6 0a397d9b')
     prand = reversed_hex('708194')
     value = ah(irk, prand)
@@ -213,7 +222,7 @@ def test_ah():
 
 
 # -----------------------------------------------------------------------------
-def test_oob_data():
+def test_oob_data(crypto_backend):
     oob_data = OobData(
         address=Address("F0:F1:F2:F3:F4:F5"),
         role=LeRole.BOTH_PERIPHERAL_PREFERRED,
@@ -237,7 +246,7 @@ def test_oob_data():
         (True, '287ad379 dca40253 0a39f1f4 3047b835'),
     ],
 )
-def test_ltk_to_link_key(ct2: bool, expected: str):
+def test_ltk_to_link_key(ct2: bool, expected: str, crypto_backend: Any):
     LTK = reversed_hex('368df9bc e3264b58 bd066c33 334fbf64')
     assert smp.Session.derive_link_key(LTK, ct2) == reversed_hex(expected)
 
@@ -250,7 +259,7 @@ def test_ltk_to_link_key(ct2: bool, expected: str):
         (True, 'e85e09eb 5eccb3e2 69418a13 3211bc79'),
     ],
 )
-def test_link_key_to_ltk(ct2: bool, expected: str):
+def test_link_key_to_ltk(ct2: bool, expected: str, crypto_backend: Any):
     LINK_KEY = reversed_hex('05040302 01000908 07060504 03020100')
     assert smp.Session.derive_ltk(LINK_KEY, ct2) == reversed_hex(expected)
 
@@ -291,6 +300,7 @@ async def test_send_identity_address_command(
     public_address: Address,
     random_address: Address,
     expected_identity_address: Address,
+    crypto_backend: Any,
 ):
     device = Device()
     device.public_address = public_address
@@ -304,19 +314,3 @@ async def test_send_identity_address_command(
     actual_command = mock_method.call_args.args[0]
     assert actual_command.addr_type == expected_identity_address.address_type
     assert actual_command.bd_addr == expected_identity_address
-
-
-# -----------------------------------------------------------------------------
-if __name__ == '__main__':
-    test_ecc()
-    test_c1()
-    test_s1()
-    test_aes_cmac()
-    test_f4()
-    test_f5()
-    test_f6()
-    test_g2()
-    test_h6()
-    test_h7()
-    test_ah()
-    test_oob_data()
diff --git a/tests/vcp_test.py b/tests/vcp_test.py
index 5853ed9..4876cb6 100644
--- a/tests/vcp_test.py
+++ b/tests/vcp_test.py
@@ -20,7 +20,7 @@ import pytest_asyncio
 import logging
 
 from bumble import device
-from bumble.profiles import vcp
+from bumble.profiles import vcs
 from .test_utils import TwoDevices
 
 # -----------------------------------------------------------------------------
@@ -34,7 +34,7 @@ logger = logging.getLogger(__name__)
 async def vcp_client():
     devices = TwoDevices()
     devices[0].add_service(
-        vcp.VolumeControlService(volume_setting=32, muted=1, volume_flags=1)
+        vcs.VolumeControlService(volume_setting=32, muted=1, volume_flags=1)
     )
 
     await devices.setup_connection()
@@ -48,76 +48,76 @@ async def vcp_client():
 
     peer = device.Peer(devices.connections[1])
     vcp_client = await peer.discover_service_and_create_proxy(
-        vcp.VolumeControlServiceProxy
+        vcs.VolumeControlServiceProxy
     )
     yield vcp_client
 
 
 # -----------------------------------------------------------------------------
 @pytest.mark.asyncio
-async def test_init_service(vcp_client: vcp.VolumeControlServiceProxy):
+async def test_init_service(vcp_client: vcs.VolumeControlServiceProxy):
     assert (await vcp_client.volume_flags.read_value()) == 1
-    assert (await vcp_client.volume_state.read_value()) == (32, 1, 0)
+    assert (await vcp_client.volume_state.read_value()) == vcs.VolumeState(32, 1, 0)
 
 
 # -----------------------------------------------------------------------------
 @pytest.mark.asyncio
-async def test_relative_volume_down(vcp_client: vcp.VolumeControlServiceProxy):
+async def test_relative_volume_down(vcp_client: vcs.VolumeControlServiceProxy):
     await vcp_client.volume_control_point.write_value(
-        bytes([vcp.VolumeControlPointOpcode.RELATIVE_VOLUME_DOWN, 0])
+        bytes([vcs.VolumeControlPointOpcode.RELATIVE_VOLUME_DOWN, 0])
     )
-    assert (await vcp_client.volume_state.read_value()) == (16, 1, 1)
+    assert (await vcp_client.volume_state.read_value()) == vcs.VolumeState(16, 1, 1)
 
 
 # -----------------------------------------------------------------------------
 @pytest.mark.asyncio
-async def test_relative_volume_up(vcp_client: vcp.VolumeControlServiceProxy):
+async def test_relative_volume_up(vcp_client: vcs.VolumeControlServiceProxy):
     await vcp_client.volume_control_point.write_value(
-        bytes([vcp.VolumeControlPointOpcode.RELATIVE_VOLUME_UP, 0])
+        bytes([vcs.VolumeControlPointOpcode.RELATIVE_VOLUME_UP, 0])
     )
-    assert (await vcp_client.volume_state.read_value()) == (48, 1, 1)
+    assert (await vcp_client.volume_state.read_value()) == vcs.VolumeState(48, 1, 1)
 
 
 # -----------------------------------------------------------------------------
 @pytest.mark.asyncio
-async def test_unmute_relative_volume_down(vcp_client: vcp.VolumeControlServiceProxy):
+async def test_unmute_relative_volume_down(vcp_client: vcs.VolumeControlServiceProxy):
     await vcp_client.volume_control_point.write_value(
-        bytes([vcp.VolumeControlPointOpcode.UNMUTE_RELATIVE_VOLUME_DOWN, 0])
+        bytes([vcs.VolumeControlPointOpcode.UNMUTE_RELATIVE_VOLUME_DOWN, 0])
     )
-    assert (await vcp_client.volume_state.read_value()) == (16, 0, 1)
+    assert (await vcp_client.volume_state.read_value()) == vcs.VolumeState(16, 0, 1)
 
 
 # -----------------------------------------------------------------------------
 @pytest.mark.asyncio
-async def test_unmute_relative_volume_up(vcp_client: vcp.VolumeControlServiceProxy):
+async def test_unmute_relative_volume_up(vcp_client: vcs.VolumeControlServiceProxy):
     await vcp_client.volume_control_point.write_value(
-        bytes([vcp.VolumeControlPointOpcode.UNMUTE_RELATIVE_VOLUME_UP, 0])
+        bytes([vcs.VolumeControlPointOpcode.UNMUTE_RELATIVE_VOLUME_UP, 0])
     )
-    assert (await vcp_client.volume_state.read_value()) == (48, 0, 1)
+    assert (await vcp_client.volume_state.read_value()) == vcs.VolumeState(48, 0, 1)
 
 
 # -----------------------------------------------------------------------------
 @pytest.mark.asyncio
-async def test_set_absolute_volume(vcp_client: vcp.VolumeControlServiceProxy):
+async def test_set_absolute_volume(vcp_client: vcs.VolumeControlServiceProxy):
     await vcp_client.volume_control_point.write_value(
-        bytes([vcp.VolumeControlPointOpcode.SET_ABSOLUTE_VOLUME, 0, 255])
+        bytes([vcs.VolumeControlPointOpcode.SET_ABSOLUTE_VOLUME, 0, 255])
     )
-    assert (await vcp_client.volume_state.read_value()) == (255, 1, 1)
+    assert (await vcp_client.volume_state.read_value()) == vcs.VolumeState(255, 1, 1)
 
 
 # -----------------------------------------------------------------------------
 @pytest.mark.asyncio
-async def test_mute(vcp_client: vcp.VolumeControlServiceProxy):
+async def test_mute(vcp_client: vcs.VolumeControlServiceProxy):
     await vcp_client.volume_control_point.write_value(
-        bytes([vcp.VolumeControlPointOpcode.MUTE, 0])
+        bytes([vcs.VolumeControlPointOpcode.MUTE, 0])
     )
-    assert (await vcp_client.volume_state.read_value()) == (32, 1, 0)
+    assert (await vcp_client.volume_state.read_value()) == vcs.VolumeState(32, 1, 0)
 
 
 # -----------------------------------------------------------------------------
 @pytest.mark.asyncio
-async def test_unmute(vcp_client: vcp.VolumeControlServiceProxy):
+async def test_unmute(vcp_client: vcs.VolumeControlServiceProxy):
     await vcp_client.volume_control_point.write_value(
-        bytes([vcp.VolumeControlPointOpcode.UNMUTE, 0])
+        bytes([vcs.VolumeControlPointOpcode.UNMUTE, 0])
     )
-    assert (await vcp_client.volume_state.read_value()) == (32, 0, 1)
+    assert (await vcp_client.volume_state.read_value()) == vcs.VolumeState(32, 0, 1)
diff --git a/tests/vocs_test.py b/tests/vocs_test.py
new file mode 100644
index 0000000..599fc6d
--- /dev/null
+++ b/tests/vocs_test.py
@@ -0,0 +1,179 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
+import pytest
+import pytest_asyncio
+import struct
+
+from bumble import device
+
+from bumble.att import ATT_Error
+
+from bumble.profiles.vocs import (
+    VolumeOffsetControlService,
+    ErrorCode,
+    MIN_VOLUME_OFFSET,
+    MAX_VOLUME_OFFSET,
+    SetVolumeOffsetOpCode,
+    VolumeOffsetControlServiceProxy,
+    VolumeOffsetState,
+)
+from bumble.profiles.vcs import VolumeControlService, VolumeControlServiceProxy
+from bumble.profiles.bap import AudioLocation
+
+from .test_utils import TwoDevices
+
+
+# -----------------------------------------------------------------------------
+# Tests
+# -----------------------------------------------------------------------------
+vocs_service = VolumeOffsetControlService()
+vcp_service = VolumeControlService(included_services=[vocs_service])
+
+
+@pytest_asyncio.fixture
+async def vocs_client():
+    devices = TwoDevices()
+    devices[0].add_service(vcp_service)
+
+    await devices.setup_connection()
+
+    assert devices.connections[0]
+    assert devices.connections[1]
+
+    devices.connections[0].encryption = 1
+    devices.connections[1].encryption = 1
+
+    peer = device.Peer(devices.connections[1])
+
+    vcp_client = await peer.discover_service_and_create_proxy(VolumeControlServiceProxy)
+
+    assert vcp_client
+    included_services = await peer.discover_included_services(vcp_client.service_proxy)
+    assert included_services
+    vocs_service_discovered = included_services[0]
+    await peer.discover_characteristics(service=vocs_service_discovered)
+    vocs_client = VolumeOffsetControlServiceProxy(vocs_service_discovered)
+
+    yield vocs_client
+
+
+# -----------------------------------------------------------------------------
+@pytest.mark.asyncio
+async def test_init_service(vocs_client: VolumeOffsetControlServiceProxy):
+    assert await vocs_client.volume_offset_state.read_value() == VolumeOffsetState(
+        volume_offset=0,
+        change_counter=0,
+    )
+    assert await vocs_client.audio_location.read_value() == AudioLocation.NOT_ALLOWED
+    description = await vocs_client.audio_output_description.read_value()
+    assert description == ''
+
+
+@pytest.mark.asyncio
+async def test_wrong_opcode_raise_error(vocs_client: VolumeOffsetControlServiceProxy):
+    with pytest.raises(ATT_Error) as e:
+        await vocs_client.volume_offset_control_point.write_value(
+            bytes(
+                [
+                    0xFF,
+                ]
+            ),
+            with_response=True,
+        )
+
+    assert e.value.error_code == ErrorCode.OPCODE_NOT_SUPPORTED
+
+
+@pytest.mark.asyncio
+async def test_wrong_change_counter_raise_error(
+    vocs_client: VolumeOffsetControlServiceProxy,
+):
+    initial_offset = vocs_service.volume_offset_state.volume_offset
+    initial_counter = vocs_service.volume_offset_state.change_counter
+    wrong_counter = initial_counter + 1
+
+    with pytest.raises(ATT_Error) as e:
+        await vocs_client.volume_offset_control_point.write_value(
+            struct.pack(
+                '<BBh', SetVolumeOffsetOpCode.SET_VOLUME_OFFSET, wrong_counter, 0
+            ),
+            with_response=True,
+        )
+    assert e.value.error_code == ErrorCode.INVALID_CHANGE_COUNTER
+
+    counter = await vocs_client.volume_offset_state.read_value()
+    assert counter == VolumeOffsetState(initial_offset, initial_counter)
+
+
+@pytest.mark.asyncio
+async def test_wrong_volume_offset_raise_error(
+    vocs_client: VolumeOffsetControlServiceProxy,
+):
+    invalid_offset_low = MIN_VOLUME_OFFSET - 1
+    invalid_offset_high = MAX_VOLUME_OFFSET + 1
+
+    with pytest.raises(ATT_Error) as e_low:
+        await vocs_client.volume_offset_control_point.write_value(
+            struct.pack(
+                '<BBh', SetVolumeOffsetOpCode.SET_VOLUME_OFFSET, 0, invalid_offset_low
+            ),
+            with_response=True,
+        )
+    assert e_low.value.error_code == ErrorCode.VALUE_OUT_OF_RANGE
+
+    with pytest.raises(ATT_Error) as e_high:
+        await vocs_client.volume_offset_control_point.write_value(
+            struct.pack(
+                '<BBh', SetVolumeOffsetOpCode.SET_VOLUME_OFFSET, 0, invalid_offset_high
+            ),
+            with_response=True,
+        )
+    assert e_high.value.error_code == ErrorCode.VALUE_OUT_OF_RANGE
+
+
+@pytest.mark.asyncio
+async def test_set_volume_offset(vocs_client: VolumeOffsetControlServiceProxy):
+    await vocs_client.volume_offset_control_point.write_value(
+        struct.pack('<BBh', SetVolumeOffsetOpCode.SET_VOLUME_OFFSET, 0, -255),
+    )
+    assert await vocs_client.volume_offset_state.read_value() == VolumeOffsetState(
+        -255, 1
+    )
+
+
+@pytest.mark.asyncio
+async def test_set_audio_channel_location(vocs_client: VolumeOffsetControlServiceProxy):
+    new_audio_location = AudioLocation.FRONT_LEFT
+
+    await vocs_client.audio_location.write_value(new_audio_location)
+
+    location = await vocs_client.audio_location.read_value()
+    assert location == new_audio_location
+
+
+@pytest.mark.asyncio
+async def test_set_audio_output_description(
+    vocs_client: VolumeOffsetControlServiceProxy,
+):
+    new_description = 'Left Speaker'
+
+    await vocs_client.audio_output_description.write_value(new_description)
+
+    description = await vocs_client.audio_output_description.read_value()
+    assert description == new_description
diff --git a/tools/intel_fw_download.py b/tools/intel_fw_download.py
new file mode 100644
index 0000000..b34c314
--- /dev/null
+++ b/tools/intel_fw_download.py
@@ -0,0 +1,130 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
+import logging
+import pathlib
+import urllib.request
+import urllib.error
+
+import click
+
+from bumble.colors import color
+from bumble.drivers import intel
+
+
+# -----------------------------------------------------------------------------
+# Logging
+# -----------------------------------------------------------------------------
+logger = logging.getLogger(__name__)
+
+
+# -----------------------------------------------------------------------------
+# Constants
+# -----------------------------------------------------------------------------
+LINUX_KERNEL_GIT_SOURCE = "https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/intel"
+
+
+# -----------------------------------------------------------------------------
+# Functions
+# -----------------------------------------------------------------------------
+def download_file(base_url, name):
+    url = f"{base_url}/{name}"
+    with urllib.request.urlopen(url) as file:
+        data = file.read()
+        print(f"Downloaded {name}: {len(data)} bytes")
+        return data
+
+
+# -----------------------------------------------------------------------------
+@click.command
+@click.option(
+    "--output-dir",
+    default="",
+    help="Output directory where the files will be saved. Defaults to the OS-specific"
+    "app data dir, which the driver will check when trying to find firmware",
+    show_default=True,
+)
+@click.option(
+    "--source",
+    type=click.Choice(["linux-kernel"]),
+    default="linux-kernel",
+    show_default=True,
+)
+@click.option("--single", help="Only download a single image set, by its base name")
+@click.option("--force", is_flag=True, help="Overwrite files if they already exist")
+def main(output_dir, source, single, force):
+    """Download Intel firmware images and configs."""
+
+    # Check that the output dir exists
+    if output_dir == '':
+        output_dir = intel.intel_firmware_dir()
+    else:
+        output_dir = pathlib.Path(output_dir)
+    if not output_dir.is_dir():
+        print("Output dir does not exist or is not a directory")
+        return
+
+    base_url = {
+        "linux-kernel": LINUX_KERNEL_GIT_SOURCE,
+    }[source]
+
+    print("Downloading")
+    print(color("FROM:", "green"), base_url)
+    print(color("TO:", "green"), output_dir)
+
+    if single:
+        images = [(f"{single}.sfi", f"{single}.ddc")]
+    else:
+        images = [
+            (f"{base_name}.sfi", f"{base_name}.ddc")
+            for base_name in intel.INTEL_FW_IMAGE_NAMES
+        ]
+
+    for fw_name, config_name in images:
+        print(color("---", "yellow"))
+        fw_image_out = output_dir / fw_name
+        if not force and fw_image_out.exists():
+            print(color(f"{fw_image_out} already exists, skipping", "red"))
+            continue
+        if config_name:
+            config_image_out = output_dir / config_name
+            if not force and config_image_out.exists():
+                print(color("f{config_image_out} already exists, skipping", "red"))
+                continue
+
+        try:
+            fw_image = download_file(base_url, fw_name)
+        except urllib.error.HTTPError as error:
+            print(f"Failed to download {fw_name}: {error}")
+            continue
+
+        config_image = None
+        if config_name:
+            try:
+                config_image = download_file(base_url, config_name)
+            except urllib.error.HTTPError as error:
+                print(f"Failed to download {config_name}: {error}")
+                continue
+
+        fw_image_out.write_bytes(fw_image)
+        if config_image:
+            config_image_out.write_bytes(config_image)
+
+
+# -----------------------------------------------------------------------------
+if __name__ == '__main__':
+    main()
diff --git a/tools/intel_util.py b/tools/intel_util.py
new file mode 100644
index 0000000..0333a01
--- /dev/null
+++ b/tools/intel_util.py
@@ -0,0 +1,154 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# -----------------------------------------------------------------------------
+# Imports
+# -----------------------------------------------------------------------------
+import logging
+import asyncio
+import os
+from typing import Any, Optional
+
+import click
+
+from bumble.colors import color
+from bumble import transport
+from bumble.drivers import intel
+from bumble.host import Host
+
+# -----------------------------------------------------------------------------
+# Logging
+# -----------------------------------------------------------------------------
+logger = logging.getLogger(__name__)
+
+
+# -----------------------------------------------------------------------------
+def print_device_info(device_info: dict[intel.ValueType, Any]) -> None:
+    if (mode := device_info.get(intel.ValueType.CURRENT_MODE_OF_OPERATION)) is not None:
+        print(
+            color("MODE:", "yellow"),
+            mode.name,
+        )
+    print(color("DETAILS:", "yellow"))
+    for key, value in device_info.items():
+        print(f"  {color(key.name, 'green')}: {value}")
+
+
+# -----------------------------------------------------------------------------
+async def get_driver(host: Host, force: bool) -> Optional[intel.Driver]:
+    # Create a driver
+    driver = await intel.Driver.for_host(host, force)
+    if driver is None:
+        print("Device does not appear to be an Intel device")
+        return None
+
+    return driver
+
+
+# -----------------------------------------------------------------------------
+async def do_info(usb_transport, force):
+    async with await transport.open_transport(usb_transport) as (
+        hci_source,
+        hci_sink,
+    ):
+        host = Host(hci_source, hci_sink)
+        driver = await get_driver(host, force)
+        if driver is None:
+            return
+
+        # Get and print the device info
+        print_device_info(await driver.read_device_info())
+
+
+# -----------------------------------------------------------------------------
+async def do_load(usb_transport: str, force: bool) -> None:
+    async with await transport.open_transport(usb_transport) as (
+        hci_source,
+        hci_sink,
+    ):
+        host = Host(hci_source, hci_sink)
+        driver = await get_driver(host, force)
+        if driver is None:
+            return
+
+        # Reboot in bootloader mode
+        await driver.load_firmware()
+
+        # Get and print the device info
+        print_device_info(await driver.read_device_info())
+
+
+# -----------------------------------------------------------------------------
+async def do_bootloader(usb_transport: str, force: bool) -> None:
+    async with await transport.open_transport(usb_transport) as (
+        hci_source,
+        hci_sink,
+    ):
+        host = Host(hci_source, hci_sink)
+        driver = await get_driver(host, force)
+        if driver is None:
+            return
+
+        # Reboot in bootloader mode
+        await driver.reboot_bootloader()
+
+
+# -----------------------------------------------------------------------------
+@click.group()
+def main():
+    logging.basicConfig(level=os.environ.get('BUMBLE_LOGLEVEL', 'INFO').upper())
+
+
+@main.command
+@click.argument("usb_transport")
+@click.option(
+    "--force",
+    is_flag=True,
+    default=False,
+    help="Try to get the device info even if the USB info doesn't match",
+)
+def info(usb_transport, force):
+    """Get the firmware info."""
+    asyncio.run(do_info(usb_transport, force))
+
+
+@main.command
+@click.argument("usb_transport")
+@click.option(
+    "--force",
+    is_flag=True,
+    default=False,
+    help="Load even if the USB info doesn't match",
+)
+def load(usb_transport, force):
+    """Load a firmware image."""
+    asyncio.run(do_load(usb_transport, force))
+
+
+@main.command
+@click.argument("usb_transport")
+@click.option(
+    "--force",
+    is_flag=True,
+    default=False,
+    help="Attempt to reboot event if the USB info doesn't match",
+)
+def bootloader(usb_transport, force):
+    """Reboot in bootloader mode."""
+    asyncio.run(do_bootloader(usb_transport, force))
+
+
+# -----------------------------------------------------------------------------
+if __name__ == '__main__':
+    main()
diff --git a/web/scanner/scanner.py b/web/scanner/scanner.py
index 69ee43a..0c3f950 100644
--- a/web/scanner/scanner.py
+++ b/web/scanner/scanner.py
@@ -15,14 +15,14 @@
 # -----------------------------------------------------------------------------
 # Imports
 # -----------------------------------------------------------------------------
-import pyee
 
+from bumble import utils
 from bumble.device import Device
 from bumble.hci import HCI_Reset_Command
 
 
 # -----------------------------------------------------------------------------
-class Scanner(pyee.EventEmitter):
+class Scanner(utils.EventEmitter):
     """
     Scanner web app
 
diff --git a/web/speaker/speaker.py b/web/speaker/speaker.py
index 2b8ce00..e70d0a2 100644
--- a/web/speaker/speaker.py
+++ b/web/speaker/speaker.py
@@ -20,7 +20,7 @@ import enum
 import logging
 from typing import Dict, List
 
-from bumble.core import BT_BR_EDR_TRANSPORT, CommandTimeoutError
+from bumble.core import PhysicalTransport, CommandTimeoutError
 from bumble.device import Device, DeviceConfiguration
 from bumble.pairing import PairingConfig
 from bumble.sdp import ServiceAttribute
@@ -28,26 +28,18 @@ from bumble.avdtp import (
     AVDTP_AUDIO_MEDIA_TYPE,
     Listener,
     MediaCodecCapabilities,
-    MediaPacket,
     Protocol,
 )
 from bumble.a2dp import (
     make_audio_sink_service_sdp_records,
-    MPEG_2_AAC_LC_OBJECT_TYPE,
     A2DP_SBC_CODEC_TYPE,
     A2DP_MPEG_2_4_AAC_CODEC_TYPE,
-    SBC_MONO_CHANNEL_MODE,
-    SBC_DUAL_CHANNEL_MODE,
-    SBC_SNR_ALLOCATION_METHOD,
-    SBC_LOUDNESS_ALLOCATION_METHOD,
-    SBC_STEREO_CHANNEL_MODE,
-    SBC_JOINT_STEREO_CHANNEL_MODE,
     SbcMediaCodecInformation,
     AacMediaCodecInformation,
 )
-from bumble.utils import AsyncRunner
 from bumble.codecs import AacAudioRtpPacket
 from bumble.hci import HCI_Reset_Command
+from bumble.rtp import MediaPacket
 
 
 # -----------------------------------------------------------------------------
@@ -72,7 +64,7 @@ class AudioExtractor:
 # -----------------------------------------------------------------------------
 class AacAudioExtractor:
     def extract_audio(self, packet: MediaPacket) -> bytes:
-        return AacAudioRtpPacket(packet.payload).to_adts()
+        return AacAudioRtpPacket.from_bytes(packet.payload).to_adts()
 
 
 # -----------------------------------------------------------------------------
@@ -130,10 +122,12 @@ class Speaker:
         return MediaCodecCapabilities(
             media_type=AVDTP_AUDIO_MEDIA_TYPE,
             media_codec_type=A2DP_MPEG_2_4_AAC_CODEC_TYPE,
-            media_codec_information=AacMediaCodecInformation.from_lists(
-                object_types=[MPEG_2_AAC_LC_OBJECT_TYPE],
-                sampling_frequencies=[48000, 44100],
-                channels=[1, 2],
+            media_codec_information=AacMediaCodecInformation(
+                object_type=AacMediaCodecInformation.ObjectType.MPEG_2_AAC_LC,
+                sampling_frequency=AacMediaCodecInformation.SamplingFrequency.SF_48000
+                | AacMediaCodecInformation.SamplingFrequency.SF_44100,
+                channels=AacMediaCodecInformation.Channels.MONO
+                | AacMediaCodecInformation.Channels.STEREO,
                 vbr=1,
                 bitrate=256000,
             ),
@@ -143,20 +137,23 @@ class Speaker:
         return MediaCodecCapabilities(
             media_type=AVDTP_AUDIO_MEDIA_TYPE,
             media_codec_type=A2DP_SBC_CODEC_TYPE,
-            media_codec_information=SbcMediaCodecInformation.from_lists(
-                sampling_frequencies=[48000, 44100, 32000, 16000],
-                channel_modes=[
-                    SBC_MONO_CHANNEL_MODE,
-                    SBC_DUAL_CHANNEL_MODE,
-                    SBC_STEREO_CHANNEL_MODE,
-                    SBC_JOINT_STEREO_CHANNEL_MODE,
-                ],
-                block_lengths=[4, 8, 12, 16],
-                subbands=[4, 8],
-                allocation_methods=[
-                    SBC_LOUDNESS_ALLOCATION_METHOD,
-                    SBC_SNR_ALLOCATION_METHOD,
-                ],
+            media_codec_information=SbcMediaCodecInformation(
+                sampling_frequency=SbcMediaCodecInformation.SamplingFrequency.SF_48000
+                | SbcMediaCodecInformation.SamplingFrequency.SF_44100
+                | SbcMediaCodecInformation.SamplingFrequency.SF_32000
+                | SbcMediaCodecInformation.SamplingFrequency.SF_16000,
+                channel_mode=SbcMediaCodecInformation.ChannelMode.MONO
+                | SbcMediaCodecInformation.ChannelMode.DUAL_CHANNEL
+                | SbcMediaCodecInformation.ChannelMode.STEREO
+                | SbcMediaCodecInformation.ChannelMode.JOINT_STEREO,
+                block_length=SbcMediaCodecInformation.BlockLength.BL_4
+                | SbcMediaCodecInformation.BlockLength.BL_8
+                | SbcMediaCodecInformation.BlockLength.BL_12
+                | SbcMediaCodecInformation.BlockLength.BL_16,
+                subbands=SbcMediaCodecInformation.Subbands.S_4
+                | SbcMediaCodecInformation.Subbands.S_8,
+                allocation_method=SbcMediaCodecInformation.AllocationMethod.LOUDNESS
+                | SbcMediaCodecInformation.AllocationMethod.SNR,
                 minimum_bitpool_value=2,
                 maximum_bitpool_value=53,
             ),
@@ -232,7 +229,9 @@ class Speaker:
     async def connect(self, address):
         # Connect to the source
         print(f'=== Connecting to {address}...')
-        connection = await self.device.connect(address, transport=BT_BR_EDR_TRANSPORT)
+        connection = await self.device.connect(
+            address, transport=PhysicalTransport.BR_EDR
+        )
         print(f'=== Connected to {connection.peer_address}')
 
         # Request authentication
@@ -282,9 +281,6 @@ class Speaker:
             mitm=False
         )
 
-        # Start the controller
-        await self.device.power_on()
-
         # Listen for Bluetooth connections
         self.device.on('connection', self.on_bluetooth_connection)
 
@@ -295,6 +291,9 @@ class Speaker:
         self.avdtp_listener = Listener.for_device(self.device)
         self.avdtp_listener.on('connection', self.on_avdtp_connection)
 
+        # Start the controller
+        await self.device.power_on()
+
         print(f'Speaker ready to play, codec={self.codec}')
 
         if connect_address:
```

