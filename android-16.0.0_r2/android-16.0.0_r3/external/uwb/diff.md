```diff
diff --git a/Android.bp b/Android.bp
deleted file mode 100755
index 6f64cef..0000000
--- a/Android.bp
+++ /dev/null
@@ -1,10 +0,0 @@
-package {
-    default_applicable_licenses: ["external_uwb_license"],
-}
-
-license {
-    name: "external_uwb_license",
-    license_kinds: ["SPDX-license-identifier-Apache-2.0"],
-    license_text: ["LICENSE"],
-}
-subdirs = ["src"]
diff --git a/DIR_METADATA b/DIR_METADATA
deleted file mode 100644
index 6021b9b..0000000
--- a/DIR_METADATA
+++ /dev/null
@@ -1,4 +0,0 @@
-buganizer {
-  component_id: 1042770  # Android > Android OS & Apps > Systems > UWB
-}
-team_email: "android-uwb-team@google.com"
diff --git a/LICENSE b/LICENSE
deleted file mode 120000
index 132d13f..0000000
--- a/LICENSE
+++ /dev/null
@@ -1 +0,0 @@
-NOTICE
\ No newline at end of file
diff --git a/METADATA b/METADATA
deleted file mode 100644
index 999c6c2..0000000
--- a/METADATA
+++ /dev/null
@@ -1,14 +0,0 @@
-name: "uwb"
-description:
-    "Native stack for UWB subsystem. This contains the UCI protocol "
-    "implementation as defined in the FIRA specifications."
-
-third_party {
-  url {
-    type: OTHER
-    value: "Delivered by partner upstream: go/pag/1948389"
-  }
-  version: "https://partner-android-review.googlesource.com/c/platform/system/uwb/+/1948389"
-  last_upgrade_date { year: 2021 month: 8 day: 2 }
-  license_type: NOTICE
-}
diff --git a/MODULE_LICENSE_APACHE2 b/MODULE_LICENSE_APACHE2
deleted file mode 100755
index e69de29..0000000
diff --git a/NOTICE b/NOTICE
deleted file mode 100755
index da14657..0000000
--- a/NOTICE
+++ /dev/null
@@ -1,16 +0,0 @@
-Notice of Rights Limitations – Important User Information
-AOSP may include one or more implementations of 
-Specifications or draft Specifications developed by the FiRa Consortium. The 
-FiRa Consortium is a non­profit organization formed for the purposes of defining 
-one or more specifications, best practices, implementation guidelines and 
-certification programs to promote the availability of compliant implementations 
-of FiRa Specifications. Information on becoming a Member, including information 
-about the benefits thereof, can be found at http://firaconsortium.org.
-
-AOSP is not affiliated with or endorsed by the FiRa 
-Consortium. Implementation of this AOSP code does not 
-assure compliance with any FiRa Specifications and does not convey the right to 
-identify any final product as FiRa certified. Members of the FiRa Consortium or 
-others may hold patents and other intellectual property rights relating to FiRa 
-Specifications. The FiRa Intellectual Property Rights Policy can be found at 
-https://www.firaconsortium.org/membership/documents.
diff --git a/OWNERS b/OWNERS
deleted file mode 100644
index b6f8933..0000000
--- a/OWNERS
+++ /dev/null
@@ -1,5 +0,0 @@
-include platform/packages/modules/Uwb:/OWNERS
-
-# This repo is shared with ChromeOS, so add the ChromeOS UWB team as the owners.
-# include /OWNERS_chromeos
-include platform/system/core:/janitors/OWNERS #{LAST_RESORT_SUGGESTION}
diff --git a/OWNERS_chromeos b/OWNERS_chromeos
deleted file mode 100644
index f95e0d2..0000000
--- a/OWNERS_chromeos
+++ /dev/null
@@ -1,6 +0,0 @@
-# ChromeOS UWB team
-akahuang@google.com
-alainmichaud@google.com
-phuleh@google.com
-ningyuan@google.com
-yanivt@google.com
diff --git a/PREUPLOAD.cfg b/PREUPLOAD.cfg
deleted file mode 100644
index 75ed57c..0000000
--- a/PREUPLOAD.cfg
+++ /dev/null
@@ -1,5 +0,0 @@
-[Builtin Hooks]
-rustfmt = true
-
-[Builtin Hooks Options]
-rustfmt = --config-path=rustfmt.toml
diff --git a/Readme.txt b/Readme.txt
new file mode 100644
index 0000000..eaa0b3d
--- /dev/null
+++ b/Readme.txt
@@ -0,0 +1 @@
+Code moved to packages/modules/Uwb/libuwb-uci
diff --git a/rustfmt.toml b/rustfmt.toml
deleted file mode 120000
index ee92d9e..0000000
--- a/rustfmt.toml
+++ /dev/null
@@ -1 +0,0 @@
-../../build/soong/scripts/rustfmt.toml
\ No newline at end of file
diff --git a/src/Android.bp b/src/Android.bp
deleted file mode 100755
index e7d8c9d..0000000
--- a/src/Android.bp
+++ /dev/null
@@ -1,385 +0,0 @@
-package {
-    default_applicable_licenses: ["external_uwb_license"],
-}
-
-rust_defaults {
-    name: "libuwb_uci_packet_defaults",
-    srcs: [
-        "rust/uwb_uci_packets/src/lib.rs",
-        ":UwbGeneratedPackets_rust",
-    ],
-    edition: "2021",
-    proc_macros: ["libnum_derive"],
-    rustlibs: [
-        "libbytes",
-        "liblog_rust",
-        "libnum_traits",
-        "libpdl_runtime",
-        "libzeroize",
-    ],
-    host_supported: true,
-}
-
-rust_test {
-    name: "libuwb_uci_packet_tests",
-    defaults: ["libuwb_uci_packet_defaults"],
-    target: {
-        android: {
-            test_suites: [
-                "general-tests",
-                "mts-uwb",
-            ],
-            test_config_template: "uwb_rust_test_config_template.xml",
-        },
-        host: {
-            test_suites: [
-                "general-tests",
-            ],
-            // See b/268061150
-            stem: "libuwb_uci_packet_tests_host",
-        },
-    },
-    // Support multilib variants (using different suffix per sub-architecture), which is needed on
-    // build targets with secondary architectures, as the MTS test suite packaging logic flattens
-    // all test artifacts into a single `testcases` directory.
-    compile_multilib: "both",
-    multilib: {
-        lib32: {
-            suffix: "32",
-        },
-        lib64: {
-            suffix: "64",
-        },
-    },
-    auto_gen_config: true,
-    min_sdk_version: "33",
-}
-
-rust_library {
-    name: "libuwb_uci_packets",
-    defaults: ["libuwb_uci_packet_defaults"],
-    crate_name: "uwb_uci_packets",
-    apex_available: [
-        "//apex_available:platform",
-        "com.android.uwb",
-    ],
-    min_sdk_version: "Tiramisu",
-    vendor_available: true,
-}
-
-genrule {
-    name: "UwbGeneratedPackets_rust",
-    defaults: ["pdl_rust_legacy_generator_defaults"],
-    srcs: [
-        "rust/uwb_uci_packets/uci_packets.pdl",
-    ],
-    out: [
-        "rust/uwb_uci_packets/uci_packets.rs",
-    ],
-}
-
-rust_defaults {
-    name: "libuwb_core_defaults",
-    srcs: ["rust/uwb_core/src/lib.rs"],
-    edition: "2021",
-    lints: "android",
-    clippy_lints: "android",
-    rustlibs: [
-        "libbytes",
-        "libnum_traits",
-        "liblog_rust",
-        "libpdl_runtime",
-        "libthiserror",
-        "libtokio",
-        "libuwb_uci_packets",
-        "libzeroize",
-    ],
-    proc_macros: [
-        "libasync_trait",
-        "libnum_derive",
-    ],
-    min_sdk_version: "Tiramisu",
-}
-
-// Build uwb_core library with the production version of Aconfig flags lib.
-rust_library {
-    name: "libuwb_core",
-    defaults: ["libuwb_core_defaults"],
-    crate_name: "uwb_core",
-    apex_available: [
-        "com.android.uwb",
-    ],
-}
-
-// Builds uwb_core library with "mock-utils" enabled.
-// This enables mock methods to be used for testing external crates.
-rust_library {
-    name: "libuwb_core_with_mock",
-    defaults: ["libuwb_core_defaults"],
-    crate_name: "uwb_core",
-    features: ["mock-utils"],
-    host_supported: true,
-    native_coverage: false,
-}
-
-// The test target uses the test version of Aconfig flags lib, as that has
-// support for setting the flag values in unit tests.
-rust_test {
-    name: "libuwb_core_tests",
-    defaults: ["libuwb_core_defaults"],
-    rustlibs: [
-        "libenv_logger",
-        "libtempfile",
-    ],
-    target: {
-        android: {
-            test_suites: [
-                "general-tests",
-                "mts-uwb",
-            ],
-            test_config_template: "uwb_rust_test_config_template.xml",
-        },
-    },
-    // Support multilib variants (using different suffix per sub-architecture), which is needed on
-    // build targets with secondary architectures, as the MTS test suite packaging logic flattens
-    // all test artifacts into a single `testcases` directory.
-    compile_multilib: "both",
-    multilib: {
-        lib32: {
-            suffix: "32",
-        },
-        lib64: {
-            suffix: "64",
-        },
-    },
-    auto_gen_config: true,
-    min_sdk_version: "33",
-}
-
-rust_binary {
-    name: "uwb_core_examples",
-    srcs: ["rust/uwb_core/examples/main.rs"],
-    rustlibs: [
-        "libenv_logger",
-        "liblog_rust",
-        "libtokio",
-        "libuwb_core",
-    ],
-    proc_macros: [
-        "libasync_trait",
-    ],
-
-    lints: "android",
-    clippy_lints: "android",
-    min_sdk_version: "Tiramisu",
-}
-
-// Build the uwb_core library with "proto" feature enabled.
-// It's used for fuzzer test.
-rust_library {
-    name: "libuwb_core_with_proto",
-    defaults: ["libuwb_core_defaults"],
-    crate_name: "uwb_core",
-    srcs: [
-        // Generate the protobuf bindings.
-        // These genrule follows the logic of rust/uwb_core/build.rs.
-        ":gen_uwb_core_proto",
-        ":include_uwb_core_proto",
-    ],
-    rustlibs: [
-        "libprotobuf",
-    ],
-    flags: [
-        // Required due to the protoc-gen-rust tool emitting invalid
-        // annotations.  This can be removed when we upgrade to protobuf-4,
-        // if we patch  protobuf-3 to no longer emit `#![allow(box_pointers)]`,
-        // or switch to using a `rust_protobuf` rule instead of a `genrule`.
-        "-A renamed_and_removed_lints",
-    ],
-    features: ["proto"],
-    host_supported: true,
-    native_coverage: false,
-}
-
-genrule {
-    name: "gen_uwb_core_proto",
-    tools: [
-        "aprotoc",
-        "protoc-gen-rust",
-    ],
-    cmd: "$(location aprotoc)" +
-        " --proto_path=`dirname $(in)`" +
-        " --plugin=protoc-gen-rust=$(location protoc-gen-rust)" +
-        " --rust_out=$(genDir) $(in)",
-    srcs: [
-        "rust/uwb_core/protos/uwb_service.proto",
-    ],
-    out: [
-        "uwb_service.rs",
-    ],
-}
-
-genrule {
-    name: "include_uwb_core_proto",
-    cmd: "echo '#[path = \"uwb_service.rs\"]' > $(out);" +
-        "echo 'pub mod bindings;' >> $(out);",
-    out: [
-        "proto_bindings.rs",
-    ],
-}
-
-rust_fuzz {
-    name: "uwb_core_fuzzer",
-    srcs: [
-        "rust/uwb_core/fuzz/proto_uwb_service_fuzzer.rs",
-    ],
-    rustlibs: [
-        "libarbitrary",
-        "libuwb_core_with_proto",
-    ],
-    fuzz_config: {
-        cc: [
-            "android-uwb-team@google.com",
-        ],
-        componentid: 1042770,
-        fuzz_on_haiku_device: false,
-        fuzz_on_haiku_host: false,
-    },
-
-}
-
-rust_defaults {
-    name: "libuci_hal_android_defaults",
-    crate_name: "uci_hal_android",
-    lints: "android",
-    clippy_lints: "android",
-    rustlibs: [
-        "android.hardware.uwb-V1-rust",
-        "libanyhow",
-        "libbinder_rs",
-        "libbinder_tokio_rs",
-        "libbytes",
-        "libjni_legacy",
-        "liblog_rust",
-        "libpdl_runtime",
-        "libthiserror",
-        "libtokio",
-        "libuwb_uci_packets",
-    ],
-    target: {
-        android: {
-            rustlibs: [
-                "librustutils",
-            ],
-        },
-    },
-    proc_macros: [
-        "libasync_trait",
-    ],
-    apex_available: [
-        "com.android.uwb",
-        "//apex_available:platform",
-    ],
-    min_sdk_version: "Tiramisu",
-    srcs: [
-        "rust/uci_hal_android/lib.rs",
-    ],
-}
-
-rust_library {
-    name: "libuci_hal_android",
-    defaults: ["libuci_hal_android_defaults"],
-    rustlibs: [
-        "libuwb_core",
-    ],
-}
-
-// uci_hal_android built with uwb_core_with_mock.
-// Used to replace uci_hal_android in place where mock version of uwb_core is
-// used.
-rust_library {
-    name: "libuci_hal_android_with_mock",
-    defaults: ["libuci_hal_android_defaults"],
-    rustlibs: [
-        "libuwb_core_with_mock",
-    ],
-    native_coverage: false,
-}
-
-rust_test {
-    name: "libuci_hal_android_tests",
-    defaults: ["libuci_hal_android_defaults"],
-    rustlibs: [
-        "libenv_logger",
-        "libtempfile",
-        "libuwb_core",
-    ],
-    target: {
-        android: {
-            test_suites: [
-                "general-tests",
-                "mts-uwb",
-            ],
-            test_config_template: "uwb_rust_test_config_template.xml",
-        },
-    },
-    // Support multilib variants (using different suffix per sub-architecture), which is needed on
-    // build targets with secondary architectures, as the MTS test suite packaging logic flattens
-    // all test artifacts into a single `testcases` directory.
-    compile_multilib: "both",
-    multilib: {
-        lib32: {
-            suffix: "32",
-        },
-        lib64: {
-            suffix: "64",
-        },
-    },
-    auto_gen_config: true,
-    min_sdk_version: "33",
-}
-
-// Generate the artifacts zip for uwb_core library and its dependencies.
-genrule {
-    name: "uwb_core_artifacts",
-    tools: [
-        "pdlc",
-        "soong_zip",
-    ],
-    srcs: [
-        "rust/uwb_core/**/*",
-        "rust/uwb_uci_packets/**/*",
-        "rust/Cargo.toml",
-    ],
-    cmd: "mkdir $(genDir)/artifacts && " + // Create a artifacts directory and copy the source code into it.
-        "cp -r external/uwb/src/rust/uwb_core " +
-        "      external/uwb/src/rust/uwb_uci_packets " +
-        "      external/uwb/src/rust/Cargo.toml " +
-        "      $(genDir)/artifacts && " +
-
-        // Generate uci_packets.rs at $(genDir)/artifacts/uwb_uci_packets/.
-        "$(location pdlc) --output-format rust " +
-        "      external/uwb/src/rust/uwb_uci_packets/uci_packets.pdl " +
-        "      > $(genDir)/artifacts/uwb_uci_packets/uci_packets.rs && " +
-
-        // Pack the artifacts directory and clean up the directory.
-        "$(location soong_zip) -o $(out) " +
-        "                      -C $(genDir)/artifacts " +
-        "                      -D $(genDir)/artifacts && " +
-        "rm -rf $(genDir)/artifacts",
-    out: [
-        "uwb_core_artifacts.zip",
-    ],
-}
-
-// Verify if the uwb_core library can be built via cargo system.
-sh_test_host {
-    name: "libuwb_core_cargo_test",
-    src: "tests/libuwb_core_cargo_test.sh",
-    test_config: "tests/libuwb_core_cargo_test.xml",
-    test_suites: ["general-tests"],
-    data: [":uwb_core_artifacts"],
-    test_options: {
-        unit_test: false,
-    },
-}
diff --git a/src/TEST_MAPPING b/src/TEST_MAPPING
deleted file mode 100644
index 3713fda..0000000
--- a/src/TEST_MAPPING
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "libuwb_uci_packet_tests"
-    },
-    {
-      "name": "libuwb_core_tests"
-    },
-    {
-      "name": "CtsUwbTestCases"
-    }
-  ]
-}
diff --git a/src/rust/Cargo.toml b/src/rust/Cargo.toml
deleted file mode 100644
index 5b56877..0000000
--- a/src/rust/Cargo.toml
+++ /dev/null
@@ -1,6 +0,0 @@
-[workspace]
-
-members = [
-  "uwb_uci_packets",
-  "uwb_core",
-]
diff --git a/src/rust/uci_hal_android/error.rs b/src/rust/uci_hal_android/error.rs
deleted file mode 100644
index 60fa755..0000000
--- a/src/rust/uci_hal_android/error.rs
+++ /dev/null
@@ -1,271 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Defines error type for uci_hal_android
-
-use android_hardware_uwb::binder::{ExceptionCode, Status as BinderStatus, StatusCode};
-use uwb_core::error::Error as UwbCoreError;
-
-/// Union of the different errors with into implementations that project the error to the nearest
-/// equivalent in each error type.
-#[derive(Debug, thiserror::Error, PartialEq, Eq)]
-pub enum Error {
-    /// uwb_core::error::Error
-    #[error("UwbCore error: {0:?}")]
-    UwbCoreError(#[from] UwbCoreError),
-    /// android_hardware_uwb::binder::StatusCode
-    #[error("Binder StatusCode error: {0:?}")]
-    StatusCode(#[from] StatusCode),
-    /// android_hardware_uwb::binder::Status
-    #[error("Binder Status error: {0:?}")]
-    BinderStatus(#[from] BinderStatus),
-}
-
-/// The From traits allow conversion of Result types and ? macro.
-impl From<Error> for BinderStatus {
-    fn from(error: Error) -> BinderStatus {
-        match error {
-            Error::BinderStatus(a) => a,
-            Error::StatusCode(StatusCode::OK) => BinderStatus::ok(),
-            Error::StatusCode(e) => {
-                BinderStatus::new_exception(status_code_to_exception_code(e), None)
-            }
-            Error::UwbCoreError(e) => {
-                BinderStatus::new_exception(uwb_core_error_to_exception_code(e), None)
-            }
-        }
-    }
-}
-
-impl From<Error> for UwbCoreError {
-    fn from(error: Error) -> UwbCoreError {
-        match error {
-            Error::BinderStatus(e) => exception_code_to_uwb_error(e.exception_code()),
-            Error::StatusCode(e) => status_code_to_uwb_core_error(e),
-            Error::UwbCoreError(a) => a,
-        }
-    }
-}
-
-fn status_code_to_exception_code(status_code: StatusCode) -> ExceptionCode {
-    match status_code {
-        // StatusCode::OK should not be reached from a Result type.
-        StatusCode::OK => ExceptionCode::NONE,
-        StatusCode::NO_MEMORY => ExceptionCode::TRANSACTION_FAILED,
-        StatusCode::INVALID_OPERATION => ExceptionCode::ILLEGAL_ARGUMENT,
-        StatusCode::BAD_VALUE => ExceptionCode::ILLEGAL_ARGUMENT,
-        StatusCode::BAD_TYPE => ExceptionCode::ILLEGAL_ARGUMENT,
-        StatusCode::NAME_NOT_FOUND => ExceptionCode::ILLEGAL_ARGUMENT,
-        StatusCode::PERMISSION_DENIED => ExceptionCode::SECURITY,
-        StatusCode::NO_INIT => ExceptionCode::ILLEGAL_ARGUMENT,
-        StatusCode::ALREADY_EXISTS => ExceptionCode::ILLEGAL_ARGUMENT,
-        StatusCode::DEAD_OBJECT => ExceptionCode::ILLEGAL_ARGUMENT,
-        StatusCode::FAILED_TRANSACTION => ExceptionCode::TRANSACTION_FAILED,
-        StatusCode::BAD_INDEX => ExceptionCode::ILLEGAL_ARGUMENT,
-        StatusCode::NOT_ENOUGH_DATA => ExceptionCode::ILLEGAL_ARGUMENT,
-        StatusCode::WOULD_BLOCK => ExceptionCode::TRANSACTION_FAILED,
-        StatusCode::TIMED_OUT => ExceptionCode::TRANSACTION_FAILED,
-        StatusCode::UNKNOWN_TRANSACTION => ExceptionCode::ILLEGAL_ARGUMENT,
-        StatusCode::FDS_NOT_ALLOWED => ExceptionCode::ILLEGAL_ARGUMENT,
-        StatusCode::UNEXPECTED_NULL => ExceptionCode::ILLEGAL_ARGUMENT,
-        _ => ExceptionCode::TRANSACTION_FAILED,
-    }
-}
-
-fn status_code_to_uwb_core_error(status_code: StatusCode) -> UwbCoreError {
-    match status_code {
-        // StatusCode::OK should not be reached from a Result type.
-        StatusCode::OK => UwbCoreError::Unknown,
-        StatusCode::NO_MEMORY => UwbCoreError::Unknown,
-        StatusCode::INVALID_OPERATION => UwbCoreError::BadParameters,
-        StatusCode::BAD_VALUE => UwbCoreError::BadParameters,
-        StatusCode::BAD_TYPE => UwbCoreError::BadParameters,
-        StatusCode::NAME_NOT_FOUND => UwbCoreError::BadParameters,
-        StatusCode::PERMISSION_DENIED => UwbCoreError::BadParameters,
-        StatusCode::NO_INIT => UwbCoreError::BadParameters,
-        StatusCode::ALREADY_EXISTS => UwbCoreError::Unknown,
-        StatusCode::DEAD_OBJECT => UwbCoreError::Unknown,
-        StatusCode::FAILED_TRANSACTION => UwbCoreError::Unknown,
-        StatusCode::BAD_INDEX => UwbCoreError::BadParameters,
-        StatusCode::NOT_ENOUGH_DATA => UwbCoreError::BadParameters,
-        StatusCode::WOULD_BLOCK => UwbCoreError::Unknown,
-        StatusCode::TIMED_OUT => UwbCoreError::Timeout,
-        StatusCode::UNKNOWN_TRANSACTION => UwbCoreError::BadParameters,
-        StatusCode::FDS_NOT_ALLOWED => UwbCoreError::Unknown,
-        StatusCode::UNEXPECTED_NULL => UwbCoreError::Unknown,
-        _ => UwbCoreError::Unknown,
-    }
-}
-
-fn uwb_core_error_to_exception_code(uwb_core_error: UwbCoreError) -> ExceptionCode {
-    match uwb_core_error {
-        UwbCoreError::BadParameters => ExceptionCode::ILLEGAL_ARGUMENT,
-        _ => ExceptionCode::TRANSACTION_FAILED,
-    }
-}
-
-fn exception_code_to_uwb_error(exception_code: ExceptionCode) -> UwbCoreError {
-    match exception_code {
-        ExceptionCode::ILLEGAL_ARGUMENT
-        | ExceptionCode::ILLEGAL_STATE
-        | ExceptionCode::UNSUPPORTED_OPERATION
-        | ExceptionCode::NULL_POINTER => UwbCoreError::BadParameters,
-        _ => UwbCoreError::Unknown,
-    }
-}
-/// Result type associated with Error:
-pub type Result<T> = std::result::Result<T, Error>;
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    use android_hardware_uwb::binder::ExceptionCode;
-    use uwb_core::error::Error as UwbCoreError;
-
-    #[test]
-    fn test_uwb_core_error_to_exception_code() {
-        let mut exception = uwb_core_error_to_exception_code(UwbCoreError::BadParameters);
-        assert_eq!(exception, ExceptionCode::ILLEGAL_ARGUMENT);
-
-        exception = uwb_core_error_to_exception_code(UwbCoreError::ForeignFunctionInterface);
-        assert_eq!(exception, ExceptionCode::TRANSACTION_FAILED);
-    }
-
-    #[test]
-    fn test_exception_code_to_uwb_error() {
-        let mut error = exception_code_to_uwb_error(ExceptionCode::ILLEGAL_ARGUMENT);
-        assert_eq!(error, UwbCoreError::BadParameters);
-
-        error = exception_code_to_uwb_error(ExceptionCode::ILLEGAL_STATE);
-        assert_eq!(error, UwbCoreError::BadParameters);
-
-        error = exception_code_to_uwb_error(ExceptionCode::UNSUPPORTED_OPERATION);
-        assert_eq!(error, UwbCoreError::BadParameters);
-
-        error = exception_code_to_uwb_error(ExceptionCode::NULL_POINTER);
-        assert_eq!(error, UwbCoreError::BadParameters);
-    }
-
-    #[test]
-    fn test_status_code_to_exception_code() {
-        let mut exception = status_code_to_exception_code(StatusCode::OK);
-        assert_eq!(exception, ExceptionCode::NONE);
-
-        exception = status_code_to_exception_code(StatusCode::NO_MEMORY);
-        assert_eq!(exception, ExceptionCode::TRANSACTION_FAILED);
-
-        exception = status_code_to_exception_code(StatusCode::INVALID_OPERATION);
-        assert_eq!(exception, ExceptionCode::ILLEGAL_ARGUMENT);
-
-        exception = status_code_to_exception_code(StatusCode::BAD_VALUE);
-        assert_eq!(exception, ExceptionCode::ILLEGAL_ARGUMENT);
-
-        exception = status_code_to_exception_code(StatusCode::BAD_TYPE);
-        assert_eq!(exception, ExceptionCode::ILLEGAL_ARGUMENT);
-
-        exception = status_code_to_exception_code(StatusCode::NAME_NOT_FOUND);
-        assert_eq!(exception, ExceptionCode::ILLEGAL_ARGUMENT);
-
-        exception = status_code_to_exception_code(StatusCode::PERMISSION_DENIED);
-        assert_eq!(exception, ExceptionCode::SECURITY);
-
-        exception = status_code_to_exception_code(StatusCode::NO_INIT);
-        assert_eq!(exception, ExceptionCode::ILLEGAL_ARGUMENT);
-
-        exception = status_code_to_exception_code(StatusCode::ALREADY_EXISTS);
-        assert_eq!(exception, ExceptionCode::ILLEGAL_ARGUMENT);
-
-        exception = status_code_to_exception_code(StatusCode::DEAD_OBJECT);
-        assert_eq!(exception, ExceptionCode::ILLEGAL_ARGUMENT);
-
-        exception = status_code_to_exception_code(StatusCode::FAILED_TRANSACTION);
-        assert_eq!(exception, ExceptionCode::TRANSACTION_FAILED);
-
-        exception = status_code_to_exception_code(StatusCode::BAD_INDEX);
-        assert_eq!(exception, ExceptionCode::ILLEGAL_ARGUMENT);
-
-        exception = status_code_to_exception_code(StatusCode::NOT_ENOUGH_DATA);
-        assert_eq!(exception, ExceptionCode::ILLEGAL_ARGUMENT);
-
-        exception = status_code_to_exception_code(StatusCode::WOULD_BLOCK);
-        assert_eq!(exception, ExceptionCode::TRANSACTION_FAILED);
-
-        exception = status_code_to_exception_code(StatusCode::TIMED_OUT);
-        assert_eq!(exception, ExceptionCode::TRANSACTION_FAILED);
-
-        exception = status_code_to_exception_code(StatusCode::UNKNOWN_TRANSACTION);
-        assert_eq!(exception, ExceptionCode::ILLEGAL_ARGUMENT);
-
-        exception = status_code_to_exception_code(StatusCode::FDS_NOT_ALLOWED);
-        assert_eq!(exception, ExceptionCode::ILLEGAL_ARGUMENT);
-
-        exception = status_code_to_exception_code(StatusCode::UNEXPECTED_NULL);
-        assert_eq!(exception, ExceptionCode::ILLEGAL_ARGUMENT);
-    }
-
-    #[test]
-    fn test_status_code_to_uwb_core_error() {
-        let mut error = status_code_to_uwb_core_error(StatusCode::OK);
-        assert_eq!(error, UwbCoreError::Unknown);
-
-        error = status_code_to_uwb_core_error(StatusCode::NO_MEMORY);
-        assert_eq!(error, UwbCoreError::Unknown);
-
-        error = status_code_to_uwb_core_error(StatusCode::BAD_VALUE);
-        assert_eq!(error, UwbCoreError::BadParameters);
-
-        error = status_code_to_uwb_core_error(StatusCode::BAD_TYPE);
-        assert_eq!(error, UwbCoreError::BadParameters);
-
-        error = status_code_to_uwb_core_error(StatusCode::NAME_NOT_FOUND);
-        assert_eq!(error, UwbCoreError::BadParameters);
-
-        error = status_code_to_uwb_core_error(StatusCode::PERMISSION_DENIED);
-        assert_eq!(error, UwbCoreError::BadParameters);
-
-        error = status_code_to_uwb_core_error(StatusCode::NO_INIT);
-        assert_eq!(error, UwbCoreError::BadParameters);
-
-        error = status_code_to_uwb_core_error(StatusCode::ALREADY_EXISTS);
-        assert_eq!(error, UwbCoreError::Unknown);
-
-        error = status_code_to_uwb_core_error(StatusCode::DEAD_OBJECT);
-        assert_eq!(error, UwbCoreError::Unknown);
-
-        error = status_code_to_uwb_core_error(StatusCode::FAILED_TRANSACTION);
-        assert_eq!(error, UwbCoreError::Unknown);
-
-        error = status_code_to_uwb_core_error(StatusCode::BAD_INDEX);
-        assert_eq!(error, UwbCoreError::BadParameters);
-
-        error = status_code_to_uwb_core_error(StatusCode::NOT_ENOUGH_DATA);
-        assert_eq!(error, UwbCoreError::BadParameters);
-
-        error = status_code_to_uwb_core_error(StatusCode::WOULD_BLOCK);
-        assert_eq!(error, UwbCoreError::Unknown);
-
-        error = status_code_to_uwb_core_error(StatusCode::TIMED_OUT);
-        assert_eq!(error, UwbCoreError::Timeout);
-
-        error = status_code_to_uwb_core_error(StatusCode::UNKNOWN_TRANSACTION);
-        assert_eq!(error, UwbCoreError::BadParameters);
-
-        error = status_code_to_uwb_core_error(StatusCode::FDS_NOT_ALLOWED);
-        assert_eq!(error, UwbCoreError::Unknown);
-
-        error = status_code_to_uwb_core_error(StatusCode::UNEXPECTED_NULL);
-        assert_eq!(error, UwbCoreError::Unknown);
-    }
-}
diff --git a/src/rust/uci_hal_android/lib.rs b/src/rust/uci_hal_android/lib.rs
deleted file mode 100644
index 2de9c94..0000000
--- a/src/rust/uci_hal_android/lib.rs
+++ /dev/null
@@ -1,18 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This library provides adaptation to UWB core from Android UCI HAL library.
-
-pub mod error;
-pub mod uci_hal_android;
diff --git a/src/rust/uci_hal_android/uci_hal_android.rs b/src/rust/uci_hal_android/uci_hal_android.rs
deleted file mode 100644
index 86c9c93..0000000
--- a/src/rust/uci_hal_android/uci_hal_android.rs
+++ /dev/null
@@ -1,344 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Implements UciHal trait for Android.
-
-use std::sync::Arc;
-
-use android_hardware_uwb::aidl::android::hardware::uwb::{
-    IUwb::IUwbAsync,
-    IUwbChip::IUwbChipAsync,
-    IUwbClientCallback::{BnUwbClientCallback, IUwbClientCallbackAsyncServer},
-    UwbEvent::UwbEvent,
-    UwbStatus::UwbStatus,
-};
-use android_hardware_uwb::binder::{
-    BinderFeatures, DeathRecipient, ExceptionCode, IBinder, Interface, Result as BinderResult,
-    Status as BinderStatus, Strong,
-};
-use async_trait::async_trait;
-use binder_tokio::{Tokio, TokioRuntime};
-use log::error;
-use pdl_runtime::Packet;
-use tokio::runtime::Handle;
-use tokio::sync::{mpsc, Mutex};
-use uwb_core::error::{Error as UwbCoreError, Result as UwbCoreResult};
-use uwb_core::params::uci_packets::SessionId;
-use uwb_core::uci::uci_hal::{UciHal, UciHalPacket};
-use uwb_uci_packets::{DeviceState, DeviceStatusNtfBuilder};
-
-use crate::error::{Error, Result};
-
-fn input_uci_hal_packet<T: Into<uwb_uci_packets::UciControlPacket>>(
-    builder: T,
-) -> Vec<UciHalPacket> {
-    let packets: Vec<uwb_uci_packets::UciControlPacketHal> = builder.into().into();
-    packets.into_iter().map(|packet| packet.encode_to_vec().unwrap()).collect()
-}
-
-/// Send device status notification with error state.
-fn send_device_state_error_notification(
-    uci_sender: &mpsc::UnboundedSender<UciHalPacket>,
-) -> UwbCoreResult<()> {
-    let raw_message_packets = input_uci_hal_packet(DeviceStatusNtfBuilder {
-        device_state: DeviceState::DeviceStateError,
-    });
-    for raw_message_packet in raw_message_packets {
-        if let Err(e) = uci_sender.send(raw_message_packet) {
-            error!("Error sending device state error notification: {:?}", e);
-            return Err(UwbCoreError::BadParameters);
-        }
-    }
-    Ok(())
-}
-
-/// Redirects the raw UCI callbacks to UciHalAndroid and manages the HalEvent.
-///
-/// RawUciCallback Redirects Raw UCI callbacks upstream, and manages HalEvent.
-/// RawUciCallback is declared as a seprate struct as a struct with IUwbClientCallbackAsyncServer
-/// trait is consumed by BnUwbClientCallback, thus it cannot be implemented for UciHalAndroid.
-#[derive(Clone, Debug)]
-struct RawUciCallback {
-    uci_sender: mpsc::UnboundedSender<UciHalPacket>,
-    hal_open_result_sender: mpsc::Sender<Result<()>>,
-    hal_close_result_sender: mpsc::Sender<Result<()>>,
-}
-
-impl RawUciCallback {
-    pub fn new(
-        uci_sender: mpsc::UnboundedSender<UciHalPacket>,
-        hal_open_result_sender: mpsc::Sender<Result<()>>,
-        hal_close_result_sender: mpsc::Sender<Result<()>>,
-    ) -> Self {
-        Self { uci_sender, hal_open_result_sender, hal_close_result_sender }
-    }
-}
-
-impl Interface for RawUciCallback {}
-
-#[async_trait]
-impl IUwbClientCallbackAsyncServer for RawUciCallback {
-    async fn onHalEvent(&self, event: UwbEvent, _event_status: UwbStatus) -> BinderResult<()> {
-        match event {
-            // UwbEvent::ERROR is processed differently by UciHalAndroid depending on its state.
-            //
-            // If error occurs before POST_INIT_CPLT received: UciHalAndroid handles the error.
-            // If error occurs after POST_INIT_CPLT received: UciHalAndroid redirects the error
-            // upstream by converting it to UCI DeviceStatusNtf.
-            // Both are attempted as RawUciCallback is not aware of the state for UciHalAndroid.
-            // Similarly, error due to close of hal cannot be reported as both the reason of the
-            // error and expectation of UciHalAndroid are unknown.
-            UwbEvent::ERROR => {
-                // Error sending hal_open_result_sender is not meaningful, as RawUciCallback do not
-                // know the reason for UwbEvent::ERROR. The receiving end only listens to
-                // hal_open_result_sender when it is expecting POST_INIT_CPLT or ERROR.
-                let _ = self.hal_open_result_sender.try_send(Err(Error::BinderStatus(
-                    BinderStatus::new_exception(ExceptionCode::TRANSACTION_FAILED, None),
-                )));
-
-                send_device_state_error_notification(&self.uci_sender)
-                    .map_err(|e| BinderStatus::from(Error::from(e)))
-            }
-            UwbEvent::POST_INIT_CPLT => self.hal_open_result_sender.try_send(Ok(())).map_err(|e| {
-                error!("Failed sending POST_INIT_CPLT: {:?}", e);
-                BinderStatus::new_exception(ExceptionCode::TRANSACTION_FAILED, None)
-            }),
-            UwbEvent::CLOSE_CPLT => self.hal_close_result_sender.try_send(Ok(())).map_err(|e| {
-                error!("Failed sending CLOSE_CPLT: {:?}", e);
-                BinderStatus::new_exception(ExceptionCode::TRANSACTION_FAILED, None)
-            }),
-            _ => Ok(()),
-        }
-    }
-
-    async fn onUciMessage(&self, data: &[u8]) -> BinderResult<()> {
-        self.uci_sender.send(data.to_owned()).map_err(|e| {
-            error!("Failed sending UCI response or notification: {:?}", e);
-            BinderStatus::new_exception(ExceptionCode::TRANSACTION_FAILED, None)
-        })
-    }
-}
-
-/// Implentation of UciHal trait for Android.
-#[derive(Default)]
-pub struct UciHalAndroid {
-    chip_id: String,
-    hal_close_result_receiver: Option<mpsc::Receiver<Result<()>>>,
-    hal_death_recipient: Option<Arc<Mutex<DeathRecipient>>>,
-    hal_uci_recipient: Option<Strong<dyn IUwbChipAsync<Tokio>>>,
-}
-
-#[allow(dead_code)]
-impl UciHalAndroid {
-    /// Constructor for empty UciHal.
-    pub fn new(chip_id: &str) -> Self {
-        Self {
-            chip_id: chip_id.to_owned(),
-            hal_close_result_receiver: None,
-            hal_death_recipient: None,
-            hal_uci_recipient: None,
-        }
-    }
-}
-
-#[async_trait]
-impl UciHal for UciHalAndroid {
-    /// Open the UCI HAL and power on the UWBS.
-    async fn open(
-        &mut self,
-        packet_sender: mpsc::UnboundedSender<UciHalPacket>,
-    ) -> UwbCoreResult<()> {
-        // Returns error if UciHalAndroid is already open.
-        if self.hal_uci_recipient.is_some() {
-            return Err(UwbCoreError::BadParameters);
-        }
-
-        // Get hal service.
-        let service_name = "android.hardware.uwb.IUwb/default";
-        let i_uwb: Strong<dyn IUwbAsync<Tokio>> = binder_tokio::wait_for_interface(service_name)
-            .await
-            .map_err(|e| UwbCoreError::from(Error::from(e)))?;
-        let chip_names = i_uwb.getChips().await.map_err(|e| UwbCoreError::from(Error::from(e)))?;
-        if chip_names.is_empty() {
-            error!("No UWB chip available.");
-            return Err(UwbCoreError::BadParameters);
-        }
-        let chip_name: &str = match &self.chip_id == "default" {
-            true => &chip_names[0],
-            false => &self.chip_id,
-        };
-        if !chip_names.contains(&chip_name.to_string()) {
-            return Err(UwbCoreError::BadParameters);
-        }
-        let i_uwb_chip = i_uwb
-            .getChip(chip_name)
-            .await
-            .map_err(|e| UwbCoreError::from(Error::from(e)))?
-            .into_async();
-
-        // If the binder object unexpectedly goes away (typically because its hosting process has
-        // been killed), then the `DeathRecipient`'s callback will be called.
-        let packet_sender_clone = packet_sender.clone();
-        let mut bare_death_recipient = DeathRecipient::new(move || {
-            send_device_state_error_notification(&packet_sender_clone).unwrap_or_else(|e| {
-                error!("Error sending device state error notification: {:?}", e);
-            });
-        });
-        i_uwb_chip
-            .as_binder()
-            .link_to_death(&mut bare_death_recipient)
-            .map_err(|e| UwbCoreError::from(Error::from(e)))?;
-
-        // Connect callback to packet_sender.
-        let (hal_open_result_sender, mut hal_open_result_receiver) = mpsc::channel::<Result<()>>(1);
-        let (hal_close_result_sender, hal_close_result_receiver) = mpsc::channel::<Result<()>>(1);
-        let m_cback = BnUwbClientCallback::new_async_binder(
-            RawUciCallback::new(
-                packet_sender.clone(),
-                hal_open_result_sender,
-                hal_close_result_sender,
-            ),
-            TokioRuntime(Handle::current()),
-            BinderFeatures::default(),
-        );
-        i_uwb_chip.open(&m_cback).await.map_err(|e| UwbCoreError::from(Error::from(e)))?;
-        // Initialize core and wait for POST_INIT_CPLT.
-        i_uwb_chip.coreInit().await.map_err(|e| UwbCoreError::from(Error::from(e)))?;
-        match hal_open_result_receiver.recv().await {
-            Some(Ok(())) => {
-                // Workaround while http://b/243140882 is not fixed:
-                // Send DEVICE_STATE_READY notification as chip is not sending this notification.
-                let device_ready_ntfs = input_uci_hal_packet(
-                    DeviceStatusNtfBuilder { device_state: DeviceState::DeviceStateReady }.build(),
-                );
-                for device_ready_ntf in device_ready_ntfs {
-                    packet_sender.send(device_ready_ntf).unwrap_or_else(|e| {
-                        error!("UCI HAL: failed to send device ready notification: {:?}", e);
-                    });
-                }
-                // End of workaround.
-                self.hal_uci_recipient.replace(i_uwb_chip);
-                self.hal_death_recipient.replace(Arc::new(Mutex::new(bare_death_recipient)));
-                self.hal_close_result_receiver.replace(hal_close_result_receiver);
-                Ok(())
-            }
-            _ => {
-                error!("POST_INIT_CPLT event is not received");
-                Err(UwbCoreError::Unknown)
-            }
-        }
-    }
-
-    async fn close(&mut self) -> UwbCoreResult<()> {
-        // Reset UciHalAndroid regardless of whether hal_close is successful or not.
-        let hal_uci_recipient = self.hal_uci_recipient.take();
-        let _hal_death_recipient = self.hal_death_recipient.take();
-        let hal_close_result_receiver = self.hal_close_result_receiver.take();
-        match hal_uci_recipient {
-            Some(i_uwb_chip) => {
-                i_uwb_chip.close().await.map_err(|e| UwbCoreError::from(Error::from(e)))
-            }
-            None => Err(UwbCoreError::BadParameters),
-        }?;
-        match hal_close_result_receiver.unwrap().recv().await {
-            // When RawUciCallback received an error due to this close() function, currently none of
-            // the error messages will be triggered, and this close() will be pending until timeout,
-            // as the reason for the UwbEvent::ERROR cannot be determined.
-            Some(result) => result.map_err(|_| UwbCoreError::Unknown),
-            None => Err(UwbCoreError::Unknown),
-        }
-    }
-
-    async fn send_packet(&mut self, packet: UciHalPacket) -> UwbCoreResult<()> {
-        match &self.hal_uci_recipient {
-            Some(i_uwb_chip) => {
-                let bytes_written = i_uwb_chip
-                    .sendUciMessage(&packet)
-                    .await
-                    .map_err(|e| UwbCoreError::from(Error::from(e)))?;
-                if bytes_written != packet.len() as i32 {
-                    log::error!(
-                        "sendUciMessage did not write the full packet: {} != {}",
-                        bytes_written,
-                        packet.len()
-                    );
-                    Err(UwbCoreError::PacketTxError)
-                } else {
-                    Ok(())
-                }
-            }
-            None => Err(UwbCoreError::BadParameters),
-        }
-    }
-
-    async fn notify_session_initialized(&mut self, session_id: SessionId) -> UwbCoreResult<()> {
-        match &self.hal_uci_recipient {
-            Some(i_uwb_chip) => {
-                i_uwb_chip
-                    // HAL API accepts signed int, so cast received session_id as i32.
-                    .sessionInit(session_id as i32)
-                    .await
-                    .map_err(|e| UwbCoreError::from(Error::from(e)))?;
-                Ok(())
-            }
-            None => Err(UwbCoreError::BadParameters),
-        }
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_send_device_state_error_notification() {
-        let (uci_sender, _) = mpsc::unbounded_channel();
-        let res = send_device_state_error_notification(&uci_sender);
-        assert_eq!(res, Err(UwbCoreError::BadParameters));
-    }
-
-    #[tokio::test]
-    async fn test_new() {
-        let chip_id = "test_chip_id";
-        let hal = UciHalAndroid::new(chip_id);
-        assert_eq!(hal.chip_id, chip_id);
-        assert!(hal.hal_close_result_receiver.is_none());
-        assert!(hal.hal_death_recipient.is_none());
-        assert!(hal.hal_uci_recipient.is_none());
-    }
-
-    #[tokio::test]
-    async fn test_open_error() {
-        let chip_id = "test_chip_id";
-        let mut hal = UciHalAndroid::new(chip_id);
-        let packet_sender = mpsc::unbounded_channel().0;
-        let res = hal.open(packet_sender).await;
-        assert_eq!(res, Err(UwbCoreError::BadParameters));
-    }
-
-    #[tokio::test]
-    async fn test_close() {
-        let chip_id = "test_chip_id";
-        let mut hal = UciHalAndroid::new(chip_id);
-        let (_, receiver) = mpsc::channel::<Result<()>>(1);
-        let death_recipient = Arc::new(Mutex::new(DeathRecipient::new(|| {})));
-        hal.hal_close_result_receiver = Some(receiver);
-        hal.hal_death_recipient = Some(death_recipient.clone());
-        let res = hal.close().await;
-        assert_eq!(res, Err(UwbCoreError::BadParameters));
-        assert!(hal.hal_close_result_receiver.is_none());
-        assert!(hal.hal_death_recipient.is_none());
-        assert!(hal.hal_uci_recipient.is_none());
-    }
-}
diff --git a/src/rust/uwb_core/Cargo.toml b/src/rust/uwb_core/Cargo.toml
deleted file mode 100644
index 9814721..0000000
--- a/src/rust/uwb_core/Cargo.toml
+++ /dev/null
@@ -1,28 +0,0 @@
-[package]
-name = "uwb_core"
-version = "0.0.1"
-edition = "2021"
-
-[build-dependencies]
-protoc-rust = "2.24.1"
-
-[dependencies]
-async-trait = "0.1.32"
-bytes = "1.1.0"
-log = "0.4.14"
-protobuf = { version = "2.24.1", optional = true }
-num-traits = "0.2.12"
-num-derive = "0.3.3"
-thiserror = "1.0.30"
-tokio = { version = "1.14.0", features = ["macros", "rt", "rt-multi-thread", "sync", "time"] }
-zeroize = "1.5.1"
-
-uwb_uci_packets = { path = "../uwb_uci_packets" }  # provided by ebuild
-
-[dev-dependencies]
-env_logger = "0.9.0"
-tempfile = "3"
-
-[features]
-proto = ["dep:protobuf"]
-mock-util = []
\ No newline at end of file
diff --git a/src/rust/uwb_core/README.md b/src/rust/uwb_core/README.md
deleted file mode 100644
index f59c22b..0000000
--- a/src/rust/uwb_core/README.md
+++ /dev/null
@@ -1,90 +0,0 @@
-# Development with Cargo
-
-Although this library are built by Android build system officially, we can also
-build and test the library by cargo.
-
-## Building `uwb_uci_packets` package
-
-The `uwb_uci_packets` package depends on `pdlc and thus simply using `cargo
-build` will fail. Follow the steps below before using cargo.
-
-1. Enter Android environment by `source build/make/rbesetup.sh; lunch <target>`
-2. Run `m pdlc` to compile the `pdlc` Rust binary.
-
-After that, we could build or test the package by `cargo test --features proto`.
-
-## Enable logging for a certain test case of uwb\_core library
-
-When debugging a certain test case, we could enable the logging and run the
-single test case.
-
-1. Add `crate::utils::init_test_logging();` at the beginning of the test case
-2. Run the single test case by:
-```
-RUST_LOG=debug cargo test -p uwb_core <test_case_name> -- --nocapture
-```
-
-# Code Architecture
-
-This section describes the main modules of this library. The modules below are
-listed in reversed topological order.
-
-## The uwb\_uci\_packets crate
-
-The `uwb_uci_packets` crate is aimed for encoding and decoding the UCI packets.
-All the details of the UCI packet format should be encapsulated here. That
-means, the client of this crate should not be aware of how the UCI messages are
-constructed to or parsed from raw byte buffers.
-
-The crate is mainly generated from the PDL file. However, in the case where a
-UCI feature cannot be achieved using PDL alone, a workaround should be created
-inside this crate to complete this feature (i.e. define structs and implement
-the parsing methods manually) to encapsulate the details of UCI packet format.
-
-Note that the interface of the workaround should be as close to PDL-generated
-code as possible.
-
-
-## params
-
-The params modules defines the parameters types, including UCI, FiRa, and CCC
-specification.
-
-This module depends on the `uwb_uci_packets` crate. To prevent the client of
-this module directly depending on the `uwb_uci_packets` crate, we re-expose all
-the needed enums and structs at `params/uci_packets.rs`.
-
-## UCI
-
-The `uci` module is aimed to provide a rust-idiomatic way that implements the
-UCI interface, such as:
-- Declare meaningful arguments types
-- Create a public method for each UCI command, and wait for its corresponding
-  response
-- Create a callback method for each UCI notification
-
-According to the asynchronous nature of the UCI interface, the `UciManager`
-struct provides asynchronous methods using the actor model. For easier usage,
-the `UciManagerSync` struct works as a thin synchronous wrapper.
-
-This module depends on the `params` module.
-
-## Session
-
-The `session` module implements the ranging session-related logic. We support
-the FiRa and CCC specification here.
-
-This module depends on the `params` and `UCI` modules.
-
-## service
-
-The `service` module is aimed to provide a "top-shim", the main entry of this
-library. Similar to the `UciManagerSync`, the `UwbService` struct provides a
-simple synchronous interface to the client of the library. `examples/main.rs` is
-a simple example for using the `UwbService` struct.
-
-If we want to provide the UWB across the process or language boundary, then
-`ProtoUwbService` provices a simple wrapper that converts all the arguments and
-responses to protobuf-encoded byte buffers.
-
-The `service` module depends on `params`, `uci`, and `session` modules.
diff --git a/src/rust/uwb_core/build.rs b/src/rust/uwb_core/build.rs
deleted file mode 100644
index f29a5e1..0000000
--- a/src/rust/uwb_core/build.rs
+++ /dev/null
@@ -1,59 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::fs::File;
-use std::io::Write;
-use std::path::PathBuf;
-
-/// Generate the protobuf bindings inside the uwb_core library.
-///
-/// The protobuf are mainly used to represent the elements of uwb_uci_packets. If we use
-/// Android's rust_protobuf build target to split the protobuf bindings to a dedicated crate, then
-/// we cannot implement the conversion trait (i.e. std::convert::From) between the protobuf
-/// bindings and the uwb_uci_packets's elements due to Rust's orphan rule.
-fn generate_proto_bindings() {
-    let out_dir = std::env::var_os("OUT_DIR").unwrap();
-
-    // Generate the protobuf bindings to "${OUT_DIR}/uwb_service.rs".
-    protoc_rust::Codegen::new()
-        .out_dir(&out_dir)
-        .input("./protos/uwb_service.proto")
-        .run()
-        .expect("Running protoc failed.");
-
-    // Including the protobuf bindings directly hits the issue:
-    // "error: an inner attribute is not permitted in this context".
-    //
-    // To workaround this, first we create the file "${OUT_DIR}/proto_bindings.rs" that contains
-    // ```
-    // #[path = "${OUT_DIR}/uwb_service.rs"]
-    // pub mod bindings;
-    // ```
-    //
-    // Then include the generated file at proto.rs by:
-    // ```
-    // include!(concat!(env!("OUT_DIR"), "/proto_bindings.rs"));
-    // ```
-    let file_path = PathBuf::from(&out_dir).join("proto_bindings.rs");
-    let file = File::create(file_path).expect("Failed to create the generated file");
-    writeln!(&file, "#[path = \"{}/uwb_service.rs\"]", out_dir.to_str().unwrap())
-        .expect("Failed to write to the generated file");
-    writeln!(&file, "pub mod bindings;").expect("Failed to write to the generated file");
-}
-
-fn main() {
-    if std::env::var("CARGO_FEATURE_PROTO") == Ok("1".to_string()) {
-        generate_proto_bindings();
-    }
-}
diff --git a/src/rust/uwb_core/examples/main.rs b/src/rust/uwb_core/examples/main.rs
deleted file mode 100644
index 5f298c6..0000000
--- a/src/rust/uwb_core/examples/main.rs
+++ /dev/null
@@ -1,63 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! A simple example for the usage of the uwb_core library.
-
-use log::debug;
-
-use uwb_core::error::{Error as UwbError, Result as UwbResult};
-use uwb_core::service::{
-    default_runtime, NopUwbServiceCallback, UwbServiceBuilder, UwbServiceCallbackSendBuilder,
-};
-use uwb_core::uci::{NopUciHal, NopUciLoggerFactory};
-
-fn main() {
-    env_logger::init();
-
-    // The UwbService needs an outlived Tokio Runtime.
-    let runtime = default_runtime().unwrap();
-    // Initialize the UWB service.
-    let service = UwbServiceBuilder::new()
-        .runtime_handle(runtime.handle().to_owned())
-        .callback_builder(UwbServiceCallbackSendBuilder::new(NopUwbServiceCallback {}))
-        .uci_hal(NopUciHal {})
-        .uci_logger_factory(NopUciLoggerFactory {})
-        .build()
-        .unwrap();
-
-    // Call the public methods of UWB service under tokio runtime.
-    let result: UwbResult<()> = service.enable();
-
-    // Enumerate the error code for backward-compatibility.
-    // WARNING: Modifying or removing the current fields are prohibited in general,
-    // unless we could confirm that there is no client using the modified field.
-    if let Err(err) = result {
-        match err {
-            UwbError::BadParameters => {}
-            UwbError::MaxSessionsExceeded => {}
-            UwbError::MaxRrRetryReached => {}
-            UwbError::ProtocolSpecific => {}
-            UwbError::RemoteRequest => {}
-            UwbError::Timeout => {}
-            UwbError::CommandRetry => {}
-            UwbError::DuplicatedSessionId => {}
-            UwbError::RegulationUwbOff => {}
-            UwbError::Unknown => {}
-
-            // UwbError is non_exhaustive so we need to add a wild branch here.
-            // With this wild branch, adding a new enum field doesn't break the build.
-            _ => debug!("Received unknown error: {:?}", err),
-        }
-    }
-}
diff --git a/src/rust/uwb_core/fuzz/.gitignore b/src/rust/uwb_core/fuzz/.gitignore
deleted file mode 100644
index 1a45eee..0000000
--- a/src/rust/uwb_core/fuzz/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-target
-corpus
-artifacts
-coverage
diff --git a/src/rust/uwb_core/fuzz/Cargo.toml b/src/rust/uwb_core/fuzz/Cargo.toml
deleted file mode 100644
index e6ea9f4..0000000
--- a/src/rust/uwb_core/fuzz/Cargo.toml
+++ /dev/null
@@ -1,26 +0,0 @@
-[package]
-name = "uwb_core-fuzz"
-version = "0.0.1"
-publish = false
-edition = "2021"
-
-[package.metadata]
-cargo-fuzz = true
-
-[dependencies]
-arbitrary = {version = "1", features = ["derive"] }
-libfuzzer-sys = "0.4"
-uwb_core = { path = "..", features = ["proto"] }
-
-# Prevent this from interfering with workspaces
-[workspace]
-members = ["."]
-
-[profile.release]
-debug = 1
-
-[[bin]]
-name = "proto_uwb_service_fuzzer"
-path = "proto_uwb_service_fuzzer.rs"
-test = false
-doc = false
diff --git a/src/rust/uwb_core/fuzz/proto_uwb_service_fuzzer.rs b/src/rust/uwb_core/fuzz/proto_uwb_service_fuzzer.rs
deleted file mode 100644
index 850d8a1..0000000
--- a/src/rust/uwb_core/fuzz/proto_uwb_service_fuzzer.rs
+++ /dev/null
@@ -1,87 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#![no_main]
-
-use libfuzzer_sys::{arbitrary::Arbitrary, fuzz_target};
-use uwb_core::service::{
-    default_runtime, NopUwbServiceCallback, ProtoUwbService, UwbServiceBuilder,
-    UwbServiceCallbackSendBuilder,
-};
-use uwb_core::uci::{NopUciHal, NopUciLoggerFactory};
-
-/// The list of the ProtoUwbService's methods that take the argument.
-#[derive(Arbitrary, Debug)]
-enum Command {
-    SetLoggerMode,
-    InitSession,
-    DeinitSession,
-    StartRanging,
-    StopRanging,
-    Reconfigure,
-    UpdateControllerMulticastList,
-    AndroidSetCountryCode,
-    SendVendorCmd,
-    SessionParams,
-}
-
-fuzz_target!(|methods: Vec<(Command, &[u8])>| {
-    // Setup the ProtoUwbService.
-    let runtime = default_runtime().unwrap();
-    let service = UwbServiceBuilder::new()
-        .runtime_handle(runtime.handle().to_owned())
-        .callback_builder(UwbServiceCallbackSendBuilder::new(NopUwbServiceCallback {}))
-        .uci_hal(NopUciHal {})
-        .uci_logger_factory(NopUciLoggerFactory {})
-        .build()
-        .unwrap();
-    let mut proto_service = ProtoUwbService::new(service);
-    let _ = proto_service.enable();
-
-    // Call the methods of ProtoUwbService that takes the argument.
-    for (command, bytes) in methods.into_iter() {
-        match command {
-            Command::SetLoggerMode => {
-                let _ = proto_service.set_logger_mode(bytes);
-            }
-            Command::InitSession => {
-                let _ = proto_service.init_session(bytes);
-            }
-            Command::DeinitSession => {
-                let _ = proto_service.deinit_session(bytes);
-            }
-            Command::StartRanging => {
-                let _ = proto_service.start_ranging(bytes);
-            }
-            Command::StopRanging => {
-                let _ = proto_service.stop_ranging(bytes);
-            }
-            Command::Reconfigure => {
-                let _ = proto_service.reconfigure(bytes);
-            }
-            Command::UpdateControllerMulticastList => {
-                let _ = proto_service.update_controller_multicast_list(bytes);
-            }
-            Command::AndroidSetCountryCode => {
-                let _ = proto_service.android_set_country_code(bytes);
-            }
-            Command::SendVendorCmd => {
-                let _ = proto_service.raw_uci_cmd(bytes);
-            }
-            Command::SessionParams => {
-                let _ = proto_service.session_params(bytes);
-            }
-        }
-    }
-});
diff --git a/src/rust/uwb_core/protos/uwb_service.proto b/src/rust/uwb_core/protos/uwb_service.proto
deleted file mode 100644
index 71b2f05..0000000
--- a/src/rust/uwb_core/protos/uwb_service.proto
+++ /dev/null
@@ -1,678 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// This file defines the requests and responses of the UwbService's methods.
-// Most of the elements are referred to the FiRa Consortium UWB Command
-// Interface Generic Techinal Specification Version 1.1.0.
-//
-// Note: Due to the protobuf's restriction: the first field of enum must be
-// zero, the value of some enum fields are not the same as the UCI
-// specification. Also, the default value of some fields defined at UCI
-// specification is not zero. The client should set all the fields when creating
-// protobuf structure, instead of relying the default value of protobuf.
-
-syntax = "proto3";
-package uwb_core;
-
-// The status code of the method response, containing variants of error::Error
-// and OK.
-enum Status {
-  // The method is executed successfully.
-  OK = 0;
-
-  // The provided parameters are invalid, or the method is not allowed to be
-  // called in the current state.
-  BAD_PARAMETERS = 1;
-
-  // The maximum number of sessions has been reached.
-  MAX_SESSIONS_EXCEEDED = 2;
-
-  // Max ranging round retries reached.
-  MAX_RR_RETRY_REACHED = 3;
-
-  // Fails due to a protocol specific reason.
-  PROTOCOL_SPECIFIC = 4;
-
-  // The remote device has requested to change the session.
-  REMOTE_REQUEST = 5;
-
-  // The response or notification is not received in timeout.
-  TIMEOUT = 6;
-
-  // The command should be retried.
-  COMMAND_RETRY = 7;
-
-  // Duplicated SessionId.
-  DUPLICATED_SESSION_ID = 8;
-
-  //Regulation UWB off
-  REGULATION_UWB_OFF = 9;
-
-  // The unknown error.
-  UNKNOWN = 10;
-}
-
-// Represent uwb_uci_packets::StatusCode.
-enum StatusCode {
-  UCI_STATUS_OK = 0;
-  UCI_STATUS_REJECTED = 1;
-  UCI_STATUS_FAILED = 2;
-  UCI_STATUS_SYNTAX_ERROR = 3;
-  UCI_STATUS_INVALID_PARAM = 4;
-  UCI_STATUS_INVALID_RANGE = 5;
-  UCI_STATUS_INVALID_MSG_SIZE = 6;
-  UCI_STATUS_UNKNOWN_GID = 7;
-  UCI_STATUS_UNKNOWN_OID = 8;
-  UCI_STATUS_READ_ONLY = 9;
-  UCI_STATUS_COMMAND_RETRY = 10;
-  UCI_STATUS_UNKNOWN = 11;
-
-  UCI_STATUS_SESSION_NOT_EXIST = 17;
-  UCI_STATUS_SESSION_DUPLICATE = 18;
-  UCI_STATUS_SESSION_ACTIVE = 19;
-  UCI_STATUS_MAX_SESSIONS_EXCEEDED = 20;
-  UCI_STATUS_SESSION_NOT_CONFIGURED = 21;
-  UCI_STATUS_ACTIVE_SESSIONS_ONGOING = 22;
-  UCI_STATUS_MULTICAST_LIST_FULL = 23;
-  UCI_STATUS_ADDRESS_NOT_FOUND = 24;
-  UCI_STATUS_ADDRESS_ALREADY_PRESENT = 25;
-  UCI_STATUS_OK_NEGATIVE_DISTANCE_REPORT = 27;
-
-  UCI_STATUS_RANGING_TX_FAILED = 32;
-  UCI_STATUS_RANGING_RX_TIMEOUT = 33;
-  UCI_STATUS_RANGING_RX_PHY_DEC_FAILED = 34;
-  UCI_STATUS_RANGING_RX_PHY_TOA_FAILED = 35;
-  UCI_STATUS_RANGING_RX_PHY_STS_FAILED = 36;
-  UCI_STATUS_RANGING_RX_MAC_DEC_FAILED = 37;
-  UCI_STATUS_RANGING_RX_MAC_IE_DEC_FAILED = 38;
-  UCI_STATUS_RANGING_RX_MAC_IE_MISSING = 39;
-  UCI_STATUS_ERROR_ROUND_INDEX_NOT_ACTIVATED = 40;
-  UCI_STATUS_ERROR_NUMBER_OF_ACTIVE_RANGING_ROUNDS_EXCEEDED = 41;
-  UCI_STATUS_ERROR_DL_TDOA_DEVICE_ADDRESS_NOT_MATCHING_IN_REPLY_TIME_LIST = 42;
-
-  UCI_STATUS_DATA_MAX_TX_PSDU_SIZE_EXCEEDED = 48;
-  UCI_STATUS_DATA_RX_CRC_ERROR = 49;
-
-  UCI_STATUS_ERROR_CCC_SE_BUSY = 80;
-  UCI_STATUS_ERROR_CCC_LIFECYCLE = 81;
-  UCI_STATUS_ERROR_STOPPED_DUE_TO_OTHER_SESSION_CONFLICT = 82;
-  UCI_STATUS_REGULATION_UWB_OFF = 83;
-  // All vendor specific status code will be mapped to UCI_STATUS_VENDOR_SPECIFIC.
-  UCI_STATUS_RFU_OR_VENDOR_SPECIFIC = 255;
-}
-
-// Represent uwb_uci_packets::DeviceState.
-enum DeviceState {
-    DEVICE_STATE_READY = 0;
-    DEVICE_STATE_ACTIVE = 1;
-    DEVICE_STATE_ERROR = 2;
-}
-
-// Represent uwb_uci_packets::SessionState.
-enum SessionState {
-  INIT = 0;
-  DEINIT = 1;
-  ACTIVE = 2;
-  IDLE = 3;
-}
-
-// Represent uwb_uci_packets::ReasonCode.
-enum ReasonCode {
-  STATE_CHANGE_WITH_SESSION_MANAGEMENT_COMMANDS = 0;
-  MAX_RANGING_ROUND_RETRY_COUNT_REACHED = 1;
-  MAX_NUMBER_OF_MEASUREMENTS_REACHED = 2;
-  SESSION_SUSPENDED_DUE_TO_INBAND_SIGNAL = 3;
-  SESSION_RESUMED_DUE_TO_INBAND_SIGNAL = 4;
-  SESSION_STOPPED_DUE_TO_INBAND_SIGNAL = 5;
-  ERROR_INVALID_UL_TDOA_RANDOM_WINDOW = 29;
-  ERROR_MIN_RFRAMES_PER_RR_NOT_SUPPORTED = 30;
-  ERROR_INTER_FRAME_INTERVAL_NOT_SUPPORTED = 31;
-  ERROR_SLOT_LENGTH_NOT_SUPPORTED = 32;
-  ERROR_INSUFFICIENT_SLOTS_PER_RR = 33;
-  ERROR_MAC_ADDRESS_MODE_NOT_SUPPORTED = 34;
-  ERROR_INVALID_RANGING_DURATION = 35;
-  ERROR_INVALID_STS_CONFIG = 36;
-  ERROR_INVALID_RFRAME_CONFIG = 37;
-  ERROR_HUS_NOT_ENOUGH_SLOTS = 38;
-  ERROR_HUS_CFP_PHASE_TOO_SHORT = 39;
-  ERROR_HUS_CAP_PHASE_TOO_SHORT = 40;
-  ERROR_HUS_OTHERS = 41;
-  ERROR_STATUS_SESSION_KEY_NOT_FOUND = 42;
-  ERROR_STATUS_SUB_SESSION_KEY_NOT_FOUND = 43;
-  ERROR_INVALID_PREAMBLE_CODE_INDEX = 44;
-  ERROR_INVALID_SFD_ID = 45;
-  ERROR_INVALID_PSDU_DATA_RATE = 46;
-  ERROR_INVALID_PHR_DATA_RATE = 47;
-  ERROR_INVALID_PREAMBLE_DURATION = 48;
-  ERROR_INVALID_STS_LENGTH = 49;
-  ERROR_INVALID_NUM_OF_STS_SEGMENTS = 50;
-  ERROR_INVALID_NUM_OF_CONTROLEES = 51;
-  ERROR_MAX_RANGING_REPLY_TIME_EXCEEDED = 52;
-  ERROR_INVALID_DST_ADDRESS_LIST = 53;
-  ERROR_INVALID_OR_NOT_FOUND_SUB_SESSION_ID = 54;
-  ERROR_INVALID_RESULT_REPORT_CONFIG = 55;
-  ERROR_INVALID_RANGING_ROUND_CONTROL_CONFIG = 56;
-  ERROR_INVALID_RANGING_ROUND_USAGE = 57;
-  ERROR_INVALID_MULTI_NODE_MODE = 58;
-  ERROR_RDS_FETCH_FAILURE = 59;
-  ERROR_REF_UWB_SESSION_DOES_NOT_EXIST = 60;
-  ERROR_REF_UWB_SESSION_RANGING_DURATION_MISMATCH = 61;
-  ERROR_REF_UWB_SESSION_INVALID_OFFSET_TIME = 62;
-  ERROR_REF_UWB_SESSION_LOST = 63;
-  ERROR_INVALID_CHANNEL_WITH_AOA = 128;
-  ERROR_STOPPED_DUE_TO_OTHER_SESSION_CONFLICT = 129;
-  ERROR_DT_ANCHOR_RANGING_ROUNDS_NOT_CONFIGURED = 130;
-  ERROR_DT_TAG_RANGING_ROUNDS_NOT_CONFIGURED = 131;
-  SESSION_STOPPED_DUE_TO_MAX_STS_INDEX_VALUE = 162;
-  // All vendor reason code will be mapped to ERROR_VENDOR_SPECIFIC.
-  ERROR_RFU_OR_VENDOR_SPECIFIC = 255;
-}
-
-// Represent uwb_uci_packets::RangingMeasurementType.
-enum RangingMeasurementType {
-  ONE_WAY = 0;
-  TWO_WAY = 1;
-  DL_TDOA = 2;
-  OWR_AOA = 3;
-}
-
-// Represent uwb_uci_packets::SessionType.
-enum SessionType {
-  FIRA_RANGING_SESSION = 0x00;
-  FIRA_RANGING_AND_IN_BAND_DATA_SESSION = 0x01;
-  FIRA_DATA_TRANSFER = 0x02;
-  FIRA_RANGING_ONLY_PHASE = 0x03;
-  FIRA_IN_BAND_DATA_PHASE = 0x04;
-  FIRA_RANGING_WITH_DATA_PHASE = 0x05;
-  FIRA_HUS_PRIMARY_SESSION = 0x9F;
-  CCC = 0xA0;
-  RADAR_SESSION = 0xA1;
-  ALIRO = 0xA2;
-  DEVICE_TEST_MODE = 0xD0;
-}
-
-// Represent uwb_uci_packets::UpdateMulticastListAction.
-enum UpdateMulticastListAction {
-  ADD_CONTROLEE = 0;
-  REMOVE_CONTROLEE = 1;
-  ADD_CONTROLEE_WITH_SHORT_SUB_SESSION_KEY = 2;
-  ADD_CONTROLEE_WITH_LONG_SUB_SESSION_KEY = 3;
-}
-
-// Represent uwb_uci_packets::MacAddressIndicator.
-enum MacAddressIndicator {
-  SHORT_ADDRESS = 0x00;
-  EXTENDED_ADDRESS = 0x01;
-}
-
-// Represent uwb_core::params::fira_app_config_params::DeviceType.
-enum DeviceType {
-  CONTROLEE = 0;
-  CONTROLLER = 1;
-}
-
-// Represent uwb_core::params::fira_app_config_params::RangingRoundUsage.
-enum RangingRoundUsage {
-  SS_TWR = 0;
-  DS_TWR = 1;
-  SS_TWR_NON = 2;
-  DS_TWR_NON = 3;
-}
-
-// Represent uwb_core::params::fira_app_config_params::StsConfig.
-enum StsConfig {
-  STATIC = 0;
-  DYNAMIC = 1;
-  DYNAMIC_FOR_CONTROLEE_INDIVIDUAL_KEY = 2;
-}
-
-// Represent uwb_core::params::fira_app_config_params::MultiNodeMode.
-enum MultiNodeMode {
-  UNICAST = 0;
-  ONE_TO_MANY = 1;
-  MANY_TO_MANY = 2;
-}
-
-// Represent uwb_core::params::fira_app_config_params::UwbChannel.
-enum UwbChannel {
-  CHANNEL_5 = 0;
-  CHANNEL_6 = 1;
-  CHANNEL_8 = 2;
-  CHANNEL_9 = 3;
-  CHANNEL_10 = 4;
-  CHANNEL_12 = 5;
-  CHANNEL_13 = 6;
-  CHANNEL_14 = 7;
-}
-
-// Represent uwb_core::params::fira_app_config_params::MacFcsType.
-enum MacFcsType {
-  CRC_16 = 0;
-  CRC_32 = 1;
-}
-
-// Represent uwb_core::params::fira_app_config_params::AoaResultRequest.
-enum AoaResultRequest {
-  NO_AOA_REPORT = 0;
-  REQ_AOA_RESULTS = 1;
-  REQ_AOA_RESULTS_AZIMUTH_ONLY = 2;
-  REQ_AOA_RESULTS_ELEVATION_ONLY = 3;
-  REQ_AOA_RESULTS_INTERLEAVED = 4;
-}
-
-// Represent uwb_core::params::fira_app_config_params::RangeDataNtfConfig.
-enum RangeDataNtfConfig {
-  RANGE_DATA_NTF_CONFIG_DISABLE = 0;
-  RANGE_DATA_NTF_CONFIG_ENABLE = 1;
-  RANGE_DATA_NTF_CONFIG_ENABLE_PROXIMITY = 2;
-}
-
-// Represent uwb_core::params::fira_app_config_params::DeviceRole.
-enum DeviceRole {
-  RESPONDER = 0;
-  INITIATOR = 1;
-}
-
-// Represent uwb_core::params::fira_app_config_params::RframeConfig.
-enum RframeConfig {
-  SP0 = 0;
-  SP1 = 1;
-  SP3 = 3;
-}
-
-// Represent uwb_core::params::fira_app_config_params::PsduDataRate.
-enum PsduDataRate {
-  RATE_6M_81 = 0;
-  RATE_7M_80 = 1;
-  RATE_27M_2 = 2;
-  RATE_31M_2 = 3;
-  RATE_850K = 4;
-}
-
-// Represent uwb_core::params::fira_app_config_params::PreambleDuration.
-enum PreambleDuration {
-  T32_SYMBOLS = 0;
-  T64_SYMBOLS = 1;
-}
-
-// Represent uwb_core::params::fira_app_config_params::RangingTimeStruct.
-enum RangingTimeStruct {
-  INTERVAL_BASED_SCHEDULING = 0;
-  BLOCK_BASED_SCHEDULING = 1;
-}
-
-// Represent uwb_core::params::fira_app_config_params::TxAdaptivePayloadPower.
-enum TxAdaptivePayloadPower {
-  TX_ADAPTIVE_PAYLOAD_POWER_DISABLE = 0;
-  TX_ADAPTIVE_PAYLOAD_POWER_ENABLE = 1;
-}
-
-// Represent uwb_core::params::fira_app_config_params::PrfMode.
-enum PrfMode {
-  BPRF = 0;
-  HPRF_WITH_124_8_MHZ = 1;
-  HPRF_WITH_249_6_MHZ = 2;
-}
-
-// Represent uwb_core::params::fira_app_config_params::ScheduledMode.
-enum ScheduledMode {
-  TIME_SCHEDULED_RANGING = 0;
-}
-
-// Represent uwb_core::params::fira_app_config_params::KeyRotation.
-enum KeyRotation {
-  KEY_ROTATION_DISABLE = 0;
-  KEY_ROTATION_ENABLE = 1;
-}
-
-// Represent uwb_core::params::fira_app_config_params::MacAddressMode.
-enum MacAddressMode {
-  MAC_ADDRESS_2_BYTES = 0;
-  MAC_ADDRESS_8_BYTES_2_BYTES_HEADER = 1;
-  MAC_ADDRESS_8_BYTES = 2;
-}
-
-// Represent uwb_core::params::fira_app_config_params::HoppingMode.
-enum HoppingMode {
-  HOPPING_MODE_DISABLE = 0;
-  FIRA_HOPPING_ENABLE = 1;
-}
-
-// Represent uwb_core::params::fira_app_config_params::BprfPhrDataRate.
-enum BprfPhrDataRate {
-  BPRF_PHR_DATA_RATE_850K = 0;
-  BPRF_PHR_DATA_RATE_6M_81 = 1;
-}
-
-// Represent uwb_core::params::fira_app_config_params::StsLength.
-enum StsLength {
-  LENGTH_32 = 0;
-  LENGTH_64 = 1;
-  LENGTH_128 = 2;
-}
-
-// Represent uwb_core::uci::uci_logger::UciLoggerMode.
-enum UciLoggerMode {
-  UCI_LOGGER_MODE_DISABLED = 0;
-  UCI_LOGGER_MODE_UNFILTERED = 1;
-  UCI_LOGGER_MODE_FILTERED = 2;
-}
-
-// Represent uwb_core::params::fira_app_config_params::RangingRoundControl.
-message RangingRoundControl {
-  bool ranging_result_report_message = 1;
-  bool control_message = 2;
-  bool measurement_report_message = 3;
-}
-
-// Represent uwb_core::params::fira_app_config_params::ResultReportConfig.
-message ResultReportConfig {
-  bool tof = 1;
-  bool aoa_azimuth = 2;
-  bool aoa_elevation = 3;
-  bool aoa_fom = 4;
-}
-
-// Represent uwb_core::params::fira_app_config_params::FiraAppConfigParams.
-message FiraAppConfigParams {
-  DeviceType device_type = 1;
-  RangingRoundUsage ranging_round_usage = 2;
-  StsConfig sts_config = 3;
-  MultiNodeMode multi_node_mode = 4;
-  UwbChannel channel_number = 5;
-  bytes device_mac_address = 6;
-  repeated bytes dst_mac_address = 7;
-  uint32 slot_duration_rstu = 8;
-  uint32 ranging_duration_ms = 9;
-  MacFcsType mac_fcs_type = 10;
-  RangingRoundControl ranging_round_control = 11;
-  AoaResultRequest aoa_result_request = 12;
-  RangeDataNtfConfig range_data_ntf_config = 13;
-  uint32 range_data_ntf_proximity_near_cm = 14;
-  uint32 range_data_ntf_proximity_far_cm = 15;
-  DeviceRole device_role = 16;
-  RframeConfig rframe_config = 17;
-  uint32 preamble_code_index = 18;
-  uint32 sfd_id = 19;
-  PsduDataRate psdu_data_rate = 20;
-  PreambleDuration preamble_duration = 21;
-  RangingTimeStruct ranging_time_struct = 22;
-  uint32 slots_per_rr = 23;
-  TxAdaptivePayloadPower tx_adaptive_payload_power = 24;
-  uint32 responder_slot_index = 25;
-  PrfMode prf_mode = 26;
-  ScheduledMode scheduled_mode = 27;
-  KeyRotation key_rotation = 28;
-  uint32 key_rotation_rate = 29;
-  uint32 session_priority = 30;
-  MacAddressMode mac_address_mode = 31;
-  bytes vendor_id = 32;
-  bytes static_sts_iv = 33;
-  uint32 number_of_sts_segments = 34;
-  uint32 max_rr_retry = 35;
-  uint32 uwb_initiation_time_ms = 36;
-  HoppingMode hopping_mode = 37;
-  uint32 block_stride_length = 38;
-  ResultReportConfig result_report_config = 39;
-  uint32 in_band_termination_attempt_count = 40;
-  uint32 sub_session_id = 41;
-  BprfPhrDataRate bprf_phr_data_rate = 42;
-  uint32 max_number_of_measurements = 43;
-  StsLength sts_length = 44;
-  uint32 number_of_range_measurements = 45;
-  uint32 number_of_aoa_azimuth_measurements = 46;
-  uint32 number_of_aoa_elevation_measurements = 47;
-}
-
-// Represent uwb_uci_packets::Controlee.
-message Controlee {
-  uint32 short_address = 1;
-  uint32 subsession_id = 2;
-}
-
-// Represent uwb_uci_packets::ShortAddressTwoWayRangingMeasurement or
-// uwb_uci_packets::ExtendedAddressTwoWayRangingMeasurement.
-message TwoWayRangingMeasurement {
-  uint64 mac_address = 1;
-  StatusCode status = 2;
-  uint32 nlos = 3;
-  uint32 distance = 4;
-  uint32 aoa_azimuth = 5;
-  uint32 aoa_azimuth_fom = 6;
-  uint32 aoa_elevation = 7;
-  uint32 aoa_elevation_fom = 8;
-  uint32 aoa_destination_azimuth = 9;
-  uint32 aoa_destination_azimuth_fom = 10;
-  uint32 aoa_destination_elevation = 11;
-  uint32 aoa_destination_elevation_fom = 12;
-  uint32 slot_index = 13;
-  uint32 rssi = 14;
-}
-
-// Represent uwb_uci_packets::ShortAddressOwrAoaRangingMeasurement or
-// uwb_uci_packets::ExtendedAddressOwrAoaRangingMeasurement.
-message OwrAoaRangingMeasurement {
-  uint64 mac_address = 1;
-  StatusCode status = 2;
-  uint32 nlos = 3;
-  uint32 block_index = 4;
-  uint32 frame_sequence_number = 5;
-  uint32 aoa_azimuth = 6;
-  uint32 aoa_azimuth_fom = 7;
-  uint32 aoa_elevation = 8;
-  uint32 aoa_elevation_fom = 9;
-}
-
-// Represent uwb_uci_packets::ShortAddressDlTdoaRangingMeasurement or
-// uwb_uci_packets::ExtendedAddressDlTdoaRangingMeasurement.
-message DlTDoARangingMeasurement {
-  uint64 mac_address = 1;
-  StatusCode status = 2;
-  uint32 message_control = 3;
-  uint32 block_index = 4;
-  uint32 round_index = 5;
-  uint32 nlos = 6;
-  uint32 aoa_azimuth = 7;
-  uint32 aoa_azimuth_fom = 8;
-  uint32 aoa_elevation = 9;
-  uint32 aoa_elevation_fom = 10;
-  uint32 rssi = 11;
-  uint64 tx_timestamp = 12;
-  uint64 rx_timestamp = 13;
-  uint32 anchor_cfo = 14;
-  uint32 cfo = 15;
-  uint32 initiator_reply_time = 16;
-  uint32 responder_reply_time = 17;
-  uint32 initiator_responder_tof = 18;
-  repeated uint32 dt_anchor_location = 19;
-  repeated uint32 ranging_rounds = 20;
-}
-
-// Represent uwb_core::uci::notification::SessionRangeData;
-message SessionRangeData {
-  uint32 sequence_number = 1;
-  uint32 session_id = 2;
-  uint32 current_ranging_interval_ms = 3;
-  RangingMeasurementType ranging_measurement_type = 4;
-  repeated TwoWayRangingMeasurement twoway_ranging_measurements = 5;
-  repeated DlTDoARangingMeasurement dltdoa_ranging_measurements = 6;
-  OwrAoaRangingMeasurement owraoa_ranging_measurement = 7;
-}
-
-// Represent uwb_uci_packets::PowerStats;
-message PowerStats {
-  StatusCode status = 1;
-  uint32 idle_time_ms = 2;
-  uint32 tx_time_ms = 3;
-  uint32 rx_time_ms = 4;
-  uint32 total_wake_count = 5;
-}
-
-// Response of the UwbService::enable() method.
-message EnableResponse {
-  Status status = 1;
-}
-
-// Response of the UwbService::disable() method.
-message DisableResponse {
-  Status status = 1;
-}
-
-// Argument of the UwbService::SetLoggerMode() method.
-message SetLoggerModeRequest {
-  UciLoggerMode logger_mode = 1;
-}
-
-// Response of the UwbService::SetLoggerMode() method.
-message SetLoggerModeResponse {
-  Status status = 1;
-}
-
-// Argument of the UwbService::InitSession() method.
-message InitSessionRequest {
-  uint32 session_id = 1;
-  SessionType session_type = 2;
-  FiraAppConfigParams params = 3;
-}
-
-// Response of the UwbService::InitSession() method.
-message InitSessionResponse {
-  Status status = 1;
-}
-
-// Argument of the UwbService::DeinitSession() method.
-message DeinitSessionRequest {
-  uint32 session_id = 1;
-}
-
-// Response of the UwbService::DeinitSession() method.
-message DeinitSessionResponse {
-  Status status = 1;
-}
-
-// Argument of the UwbService::StartRanging() method.
-message StartRangingRequest {
-  uint32 session_id = 1;
-}
-
-// Response of the UwbService::StartRanging() method.
-message StartRangingResponse {
-  Status status = 1;
-}
-
-// Argument of the UwbService::StopRanging() method.
-message StopRangingRequest {
-  uint32 session_id = 1;
-}
-
-// Response of the UwbService::StopRanging() method.
-message StopRangingResponse {
-  Status status = 1;
-}
-
-// Argument of the UwbService::SessionParams() method.
-message SessionParamsRequest {
-  uint32 session_id = 1;
-}
-
-// Response of the UwbService::SessionParams() method.
-message SessionParamsResponse {
-  Status status = 1;
-  FiraAppConfigParams params = 2;
-}
-
-// Argument of the UwbService::Reconfigure() method.
-message ReconfigureRequest {
-  uint32 session_id = 1;
-  FiraAppConfigParams params = 2;
-}
-
-// Response of the UwbService::Reconfigure() method.
-message ReconfigureResponse {
-  Status status = 1;
-}
-
-// Argument of the UwbService::UpdateControllerMulticastList() method.
-message UpdateControllerMulticastListRequest {
-  uint32 session_id = 1;
-  UpdateMulticastListAction action = 2;
-  repeated Controlee controlees = 3;
-}
-
-// Response of the UwbService::UpdateControllerMulticastList() method.
-message UpdateControllerMulticastListResponse {
-  Status status = 1;
-}
-
-// Argument of the UwbService::AndroidSetCountryCode() method.
-message AndroidSetCountryCodeRequest {
-  string country_code = 1;
-}
-
-// Response of the UwbService::AndroidSetCountryCode() method.
-message AndroidSetCountryCodeResponse {
-  Status status = 1;
-}
-
-// Response of the UwbService::AndroidGetPowerStats() method.
-message AndroidGetPowerStatsResponse {
-  Status status = 1;
-  PowerStats power_stats = 2;
-}
-
-// Argument of the UwbService::SendVendorCmd() method.
-message SendVendorCmdRequest {
-  uint32 gid = 1;
-  uint32 oid = 2;
-  bytes payload = 3;
-  uint32 mt = 4;
-}
-
-// Response of the UwbService::SendVendorCmd() method.
-message SendVendorCmdResponse {
-  Status status = 1;
-  uint32 gid = 2;
-  uint32 oid = 3;
-  bytes payload = 4;
-}
-
-// Argument of the UwbServiceCallback::onServiceReset() method.
-message ServiceResetSignal {
-  bool success = 1;
-}
-
-// Argument of the UwbServiceCallback::onUciDeviceStatusChanged() method.
-message UciDeviceStatusChangedSignal {
-  DeviceState state = 1;
-}
-
-// Argument of the UwbServiceCallback::onSessionStateChanged() method.
-message SessionStateChangedSignal {
-  uint32 session_id = 1;
-  SessionState session_state = 2;
-  ReasonCode reason_code = 3;
-}
-
-// Argument of the UwbServiceCallback::onRangeDataReceived() method.
-message RangeDataReceivedSignal {
-  uint32 session_id = 1;
-  SessionRangeData range_data = 2;
-}
-
-// Argument of the UwbServiceCallback::onVendorNotificationReceived() method.
-message VendorNotificationReceivedSignal {
-  uint32 gid = 1;
-  uint32 oid = 2;
-  bytes payload = 3;
-}
diff --git a/src/rust/uwb_core/rustfmt.toml b/src/rust/uwb_core/rustfmt.toml
deleted file mode 100644
index 5831856..0000000
--- a/src/rust/uwb_core/rustfmt.toml
+++ /dev/null
@@ -1,4 +0,0 @@
-edition = "2018"
-use_small_heuristics = "Max"
-newline_style = "Unix"
-max_width = 100
\ No newline at end of file
diff --git a/src/rust/uwb_core/src/error.rs b/src/rust/uwb_core/src/error.rs
deleted file mode 100644
index 5889448..0000000
--- a/src/rust/uwb_core/src/error.rs
+++ /dev/null
@@ -1,68 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module defines the error type and the result type for this library.
-
-/// The error type for the uwb_core library.
-#[non_exhaustive] // Adding new enum fields doesn't break the downstream build.
-#[derive(Clone, Debug, thiserror::Error, PartialEq, Eq)]
-pub enum Error {
-    /// The provided parameters are invalid, or the method is not allowed to be called in the
-    /// current state.
-    #[error("Bad parameters")]
-    BadParameters,
-    /// Error across Foreign Function Interface.
-    #[error("Error across Foreign Function Interface")]
-    ForeignFunctionInterface,
-    /// The maximum number of sessions has been reached.
-    #[error("The maximum number of sessions has been reached")]
-    MaxSessionsExceeded,
-    /// Max ranging round retries reached.
-    #[error("Max ranging round retries reached")]
-    MaxRrRetryReached,
-    /// Fails due to a protocol specific reason.
-    #[error("The session fails with a protocol specific reason")]
-    ProtocolSpecific,
-    /// The remote device has requested to change the session.
-    #[error("The remote device has requested to change the session")]
-    RemoteRequest,
-    /// The response or notification is not received in timeout.
-    #[error("The response or notification is not received in timeout")]
-    Timeout,
-    /// The command should be retried.
-    #[error("The command should be retried")]
-    CommandRetry,
-    /// Duplicated SessionId.
-    #[error("Duplicated SessionId")]
-    DuplicatedSessionId,
-    /// Packet Tx Error
-    #[error("The packet send failed with an error")]
-    PacketTxError,
-    /// Country code regulation UWB Off
-    #[error("The country code command failed with a UWB regulatory error")]
-    RegulationUwbOff,
-    /// The unknown error.
-    #[error("The unknown error")]
-    Unknown,
-
-    /// The result of the mock method is not assigned
-    #[cfg(any(test, feature = "mock-utils"))]
-    #[error("The result of the mock method is not assigned")]
-    MockUndefined,
-}
-
-/// The result type for the uwb_core library.
-///
-/// This type is broadly used by the methods in this library which may produce an error.
-pub type Result<T> = std::result::Result<T, Error>;
diff --git a/src/rust/uwb_core/src/lib.rs b/src/rust/uwb_core/src/lib.rs
deleted file mode 100644
index 8f1eb1f..0000000
--- a/src/rust/uwb_core/src/lib.rs
+++ /dev/null
@@ -1,25 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! The library provides the core logic of Ultra-wide band (UWB) technology.
-
-pub(crate) mod session;
-pub(crate) mod utils;
-
-pub mod error;
-pub mod params;
-#[cfg(feature = "proto")]
-pub mod proto;
-pub mod service;
-pub mod uci;
diff --git a/src/rust/uwb_core/src/params.rs b/src/rust/uwb_core/src/params.rs
deleted file mode 100644
index ad994f3..0000000
--- a/src/rust/uwb_core/src/params.rs
+++ /dev/null
@@ -1,32 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module provides the types of the parameters or returned data of the public interfaces.
-
-pub(super) mod utils;
-
-pub mod aliro_app_config_params;
-pub mod app_config_params;
-pub mod ccc_app_config_params;
-pub mod ccc_started_app_config_params;
-pub mod fira_app_config_params;
-pub mod uci_packets;
-
-// Re-export params from all of the sub-modules.
-pub use aliro_app_config_params::*;
-pub use app_config_params::*;
-pub use ccc_app_config_params::*;
-pub use ccc_started_app_config_params::*;
-pub use fira_app_config_params::*;
-pub use uci_packets::*;
diff --git a/src/rust/uwb_core/src/params/aliro_app_config_params.rs b/src/rust/uwb_core/src/params/aliro_app_config_params.rs
deleted file mode 100644
index 76e1a63..0000000
--- a/src/rust/uwb_core/src/params/aliro_app_config_params.rs
+++ /dev/null
@@ -1,399 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, item 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#![allow(missing_docs)]
-
-use std::collections::HashMap;
-
-use log::error;
-
-use crate::params::app_config_params::{AppConfigParams, AppConfigTlvMap};
-use crate::params::fira_app_config_params::{
-    DeviceRole, DeviceType, KeyRotation, MultiNodeMode, RangeDataNtfConfig, StsConfig,
-};
-use crate::params::uci_packets::{AppConfigTlvType, SessionState};
-use crate::params::utils::{u16_to_bytes, u32_to_bytes, u8_to_bytes, validate};
-use crate::utils::{builder_field, getter_field};
-use num_derive::{FromPrimitive, ToPrimitive};
-
-const CHAP_IN_RSTU: u16 = 400; // 1 Chap = 400 RSTU.
-pub(super) const MINIMUM_BLOCK_DURATION_MS: u32 = 96;
-
-// The constant AppConfigTlv values for ALIRO.
-const ALIRO_DEVICE_TYPE: DeviceType = DeviceType::Controlee;
-const ALIRO_STS_CONFIG: StsConfig = StsConfig::Dynamic;
-const ALIRO_MULTI_NODE_MODE: MultiNodeMode = MultiNodeMode::OneToMany;
-const ALIRO_RANGE_DATA_NTF_CONFIG: RangeDataNtfConfig = RangeDataNtfConfig::Disable;
-const ALIRO_DEVICE_ROLE: DeviceRole = DeviceRole::Initiator;
-const ALIRO_KEY_ROTATION: KeyRotation = KeyRotation::Enable;
-const ALIRO_URSK_TTL: u16 = 0x2D0;
-
-const DEFAULT_PROTOCOL_VERSION: AliroProtocolVersion = AliroProtocolVersion { major: 1, minor: 0 };
-
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct AliroAppConfigParams {
-    protocol_version: AliroProtocolVersion,
-    uwb_config: AliroUwbConfig,
-    pulse_shape_combo: AliroPulseShapeCombo,
-    ran_multiplier: u32,
-    channel_number: AliroUwbChannel,
-    chaps_per_slot: AliroChapsPerSlot,
-    num_responder_nodes: u8,
-    slots_per_rr: u8,
-    sync_code_index: u8,
-    hopping_mode: AliroHoppingMode,
-}
-
-#[allow(missing_docs)]
-impl AliroAppConfigParams {
-    // Generate the getter methods for all the fields.
-    getter_field!(protocol_version, AliroProtocolVersion);
-    getter_field!(uwb_config, AliroUwbConfig);
-    getter_field!(pulse_shape_combo, AliroPulseShapeCombo);
-    getter_field!(ran_multiplier, u32);
-    getter_field!(channel_number, AliroUwbChannel);
-    getter_field!(chaps_per_slot, AliroChapsPerSlot);
-    getter_field!(num_responder_nodes, u8);
-    getter_field!(slots_per_rr, u8);
-    getter_field!(sync_code_index, u8);
-    getter_field!(hopping_mode, AliroHoppingMode);
-
-    pub fn is_config_updatable(config_map: &AppConfigTlvMap, session_state: SessionState) -> bool {
-        match session_state {
-            SessionState::SessionStateIdle => {
-                // Only ran_multiplier can be updated at idle state.
-                config_map.keys().all(|key| key == &AppConfigTlvType::RangingDuration)
-            }
-            _ => false,
-        }
-    }
-
-    pub fn generate_config_map(&self) -> AppConfigTlvMap {
-        debug_assert!(self.is_valid().is_some());
-
-        HashMap::from([
-            (AppConfigTlvType::DeviceType, u8_to_bytes(ALIRO_DEVICE_TYPE as u8)),
-            (AppConfigTlvType::StsConfig, u8_to_bytes(ALIRO_STS_CONFIG as u8)),
-            (AppConfigTlvType::MultiNodeMode, u8_to_bytes(ALIRO_MULTI_NODE_MODE as u8)),
-            (AppConfigTlvType::ChannelNumber, u8_to_bytes(self.channel_number as u8)),
-            (AppConfigTlvType::NoOfControlee, u8_to_bytes(self.num_responder_nodes)),
-            (
-                AppConfigTlvType::SlotDuration,
-                u16_to_bytes((self.chaps_per_slot as u16) * CHAP_IN_RSTU),
-            ),
-            (
-                AppConfigTlvType::RangingDuration,
-                u32_to_bytes(self.ran_multiplier * MINIMUM_BLOCK_DURATION_MS),
-            ),
-            (AppConfigTlvType::RngDataNtf, u8_to_bytes(ALIRO_RANGE_DATA_NTF_CONFIG as u8)),
-            (AppConfigTlvType::DeviceRole, u8_to_bytes(ALIRO_DEVICE_ROLE as u8)),
-            (AppConfigTlvType::PreambleCodeIndex, u8_to_bytes(self.sync_code_index)),
-            (AppConfigTlvType::SlotsPerRr, u8_to_bytes(self.slots_per_rr)),
-            (AppConfigTlvType::KeyRotation, u8_to_bytes(ALIRO_KEY_ROTATION as u8)),
-            (AppConfigTlvType::HoppingMode, u8_to_bytes(self.hopping_mode as u8)),
-            // Vendor-space parameters, currently using the same TagId as CCC.
-            (AppConfigTlvType::CccRangingProtocolVer, self.protocol_version.clone().into()),
-            (AppConfigTlvType::CccUwbConfigId, u16_to_bytes(self.uwb_config as u16)),
-            (AppConfigTlvType::CccPulseshapeCombo, self.pulse_shape_combo.clone().into()),
-            (AppConfigTlvType::CccUrskTtl, u16_to_bytes(ALIRO_URSK_TTL)),
-        ])
-    }
-
-    fn is_valid(&self) -> Option<()> {
-        validate(
-            (1..=32).contains(&self.sync_code_index),
-            "sync_code_index should be between 1 to 32",
-        )?;
-
-        self.ran_multiplier.checked_mul(MINIMUM_BLOCK_DURATION_MS).or_else(|| {
-            error!("ran_multiplier * MINIMUM_BLOCK_DURATION_MS overflows");
-            None
-        })?;
-
-        Some(())
-    }
-}
-
-pub struct AliroAppConfigParamsBuilder {
-    protocol_version: AliroProtocolVersion,
-    uwb_config: Option<AliroUwbConfig>,
-    pulse_shape_combo: Option<AliroPulseShapeCombo>,
-    ran_multiplier: Option<u32>,
-    channel_number: Option<AliroUwbChannel>,
-    chaps_per_slot: Option<AliroChapsPerSlot>,
-    num_responder_nodes: Option<u8>,
-    slots_per_rr: Option<u8>,
-    sync_code_index: Option<u8>,
-    hopping_mode: Option<AliroHoppingMode>,
-}
-
-#[allow(clippy::new_without_default)]
-impl AliroAppConfigParamsBuilder {
-    pub fn new() -> Self {
-        Self {
-            protocol_version: DEFAULT_PROTOCOL_VERSION,
-            uwb_config: None,
-            pulse_shape_combo: None,
-            ran_multiplier: None,
-            channel_number: None,
-            chaps_per_slot: None,
-            num_responder_nodes: None,
-            slots_per_rr: None,
-            sync_code_index: None,
-            hopping_mode: None,
-        }
-    }
-
-    pub fn build(&self) -> Option<AppConfigParams> {
-        let params = AliroAppConfigParams {
-            protocol_version: self.protocol_version.clone(),
-            uwb_config: self.uwb_config?,
-            pulse_shape_combo: self.pulse_shape_combo.clone()?,
-            ran_multiplier: self.ran_multiplier?,
-            channel_number: self.channel_number?,
-            chaps_per_slot: self.chaps_per_slot?,
-            num_responder_nodes: self.num_responder_nodes?,
-            slots_per_rr: self.slots_per_rr?,
-            sync_code_index: self.sync_code_index?,
-            hopping_mode: self.hopping_mode?,
-        };
-        params.is_valid()?;
-        Some(AppConfigParams::Aliro(params))
-    }
-
-    pub fn from_params(params: &AppConfigParams) -> Option<Self> {
-        match params {
-            AppConfigParams::Aliro(params) => Some(Self {
-                protocol_version: params.protocol_version.clone(),
-                uwb_config: Some(params.uwb_config),
-                pulse_shape_combo: Some(params.pulse_shape_combo.clone()),
-                ran_multiplier: Some(params.ran_multiplier),
-                channel_number: Some(params.channel_number),
-                chaps_per_slot: Some(params.chaps_per_slot),
-                num_responder_nodes: Some(params.num_responder_nodes),
-                slots_per_rr: Some(params.slots_per_rr),
-                sync_code_index: Some(params.sync_code_index),
-                hopping_mode: Some(params.hopping_mode),
-            }),
-            _ => None,
-        }
-    }
-
-    // Generate the setter methods for all the fields.
-    builder_field!(protocol_version, AliroProtocolVersion);
-    builder_field!(uwb_config, AliroUwbConfig, Some);
-    builder_field!(pulse_shape_combo, AliroPulseShapeCombo, Some);
-    builder_field!(ran_multiplier, u32, Some);
-    builder_field!(channel_number, AliroUwbChannel, Some);
-    builder_field!(chaps_per_slot, AliroChapsPerSlot, Some);
-    builder_field!(num_responder_nodes, u8, Some);
-    builder_field!(slots_per_rr, u8, Some);
-    builder_field!(sync_code_index, u8, Some);
-    builder_field!(hopping_mode, AliroHoppingMode, Some);
-}
-
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct AliroProtocolVersion {
-    pub major: u8,
-    pub minor: u8,
-}
-
-impl From<AliroProtocolVersion> for Vec<u8> {
-    fn from(item: AliroProtocolVersion) -> Self {
-        vec![item.major, item.minor]
-    }
-}
-
-#[repr(u16)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum AliroUwbConfig {
-    Config0 = 0,
-    Config1 = 1,
-}
-
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct AliroPulseShapeCombo {
-    pub initiator_tx: AliroPulseShape,
-    pub responder_tx: AliroPulseShape,
-}
-
-impl From<AliroPulseShapeCombo> for Vec<u8> {
-    fn from(item: AliroPulseShapeCombo) -> Self {
-        vec![((item.initiator_tx as u8) << 4) | (item.responder_tx as u8)]
-    }
-}
-
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum AliroPulseShape {
-    SymmetricalRootRaisedCosine = 0x0,
-    PrecursorFree = 0x1,
-    PrecursorFreeSpecial = 0x2,
-}
-
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum AliroUwbChannel {
-    Channel5 = 5,
-    Channel9 = 9,
-}
-
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum AliroHoppingConfigMode {
-    None = 0,
-    Continuous = 1,
-    Adaptive = 2,
-}
-
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum AliroHoppingSequence {
-    Default = 0,
-    Aes = 1,
-}
-
-#[repr(u16)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum AliroChapsPerSlot {
-    Value3 = 3,
-    Value4 = 4,
-    Value6 = 6,
-    Value8 = 8,
-    Value9 = 9,
-    Value12 = 12,
-    Value24 = 24,
-}
-
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum AliroHoppingMode {
-    Disable = 0,
-    AdaptiveDefault = 2,
-    ContinuousDefault = 3,
-    AdaptiveAes = 4,
-    ContinuousAes = 5,
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_ok() {
-        let protocol_version = AliroProtocolVersion { major: 2, minor: 1 };
-        let uwb_config = AliroUwbConfig::Config0;
-        let pulse_shape_combo = AliroPulseShapeCombo {
-            initiator_tx: AliroPulseShape::PrecursorFree,
-            responder_tx: AliroPulseShape::PrecursorFreeSpecial,
-        };
-        let ran_multiplier = 3;
-        let channel_number = AliroUwbChannel::Channel9;
-        let chaps_per_slot = AliroChapsPerSlot::Value9;
-        let num_responder_nodes = 1;
-        let slots_per_rr = 3;
-        let sync_code_index = 12;
-        let hopping_mode = AliroHoppingMode::ContinuousAes;
-
-        let params = AliroAppConfigParamsBuilder::new()
-            .protocol_version(protocol_version)
-            .uwb_config(uwb_config)
-            .pulse_shape_combo(pulse_shape_combo.clone())
-            .ran_multiplier(ran_multiplier)
-            .channel_number(channel_number)
-            .chaps_per_slot(chaps_per_slot)
-            .num_responder_nodes(num_responder_nodes)
-            .slots_per_rr(slots_per_rr)
-            .sync_code_index(sync_code_index)
-            .hopping_mode(hopping_mode)
-            .build()
-            .unwrap();
-
-        // Verify the generated TLV.
-        let config_map = params.generate_config_map();
-        let expected_config_map = HashMap::from([
-            (AppConfigTlvType::DeviceType, u8_to_bytes(ALIRO_DEVICE_TYPE as u8)),
-            (AppConfigTlvType::StsConfig, u8_to_bytes(ALIRO_STS_CONFIG as u8)),
-            (AppConfigTlvType::MultiNodeMode, u8_to_bytes(ALIRO_MULTI_NODE_MODE as u8)),
-            (AppConfigTlvType::ChannelNumber, u8_to_bytes(channel_number as u8)),
-            (AppConfigTlvType::NoOfControlee, u8_to_bytes(num_responder_nodes)),
-            (AppConfigTlvType::SlotDuration, u16_to_bytes((chaps_per_slot as u16) * CHAP_IN_RSTU)),
-            (
-                AppConfigTlvType::RangingDuration,
-                u32_to_bytes(ran_multiplier * MINIMUM_BLOCK_DURATION_MS),
-            ),
-            (AppConfigTlvType::RngDataNtf, u8_to_bytes(ALIRO_RANGE_DATA_NTF_CONFIG as u8)),
-            (AppConfigTlvType::DeviceRole, u8_to_bytes(ALIRO_DEVICE_ROLE as u8)),
-            (AppConfigTlvType::PreambleCodeIndex, u8_to_bytes(sync_code_index)),
-            (AppConfigTlvType::SlotsPerRr, u8_to_bytes(slots_per_rr)),
-            (AppConfigTlvType::KeyRotation, u8_to_bytes(ALIRO_KEY_ROTATION as u8)),
-            (AppConfigTlvType::HoppingMode, u8_to_bytes(hopping_mode as u8)),
-            // Vendor-space parameters, currently using the same TagId as CCC.
-            (AppConfigTlvType::CccRangingProtocolVer, vec![2, 1]),
-            (AppConfigTlvType::CccUwbConfigId, u16_to_bytes(uwb_config as u16)),
-            (AppConfigTlvType::CccPulseshapeCombo, pulse_shape_combo.into()),
-            (AppConfigTlvType::CccUrskTtl, u16_to_bytes(ALIRO_URSK_TTL)),
-        ]);
-        assert_eq!(config_map, expected_config_map);
-
-        // Update the value from the params.
-        let updated_ran_multiplier = 5;
-        assert_ne!(ran_multiplier, updated_ran_multiplier);
-        let expected_updated_config_map = HashMap::from([(
-            AppConfigTlvType::RangingDuration,
-            u32_to_bytes(updated_ran_multiplier * MINIMUM_BLOCK_DURATION_MS),
-        )]);
-
-        let updated_params1 = AliroAppConfigParamsBuilder::from_params(&params)
-            .unwrap()
-            .ran_multiplier(updated_ran_multiplier)
-            .build()
-            .unwrap();
-        let updated_config_map1 = updated_params1
-            .generate_updated_config_map(&params, SessionState::SessionStateIdle)
-            .unwrap();
-        assert_eq!(updated_config_map1, expected_updated_config_map);
-    }
-
-    #[test]
-    fn test_update_config() {
-        let mut builder = AliroAppConfigParamsBuilder::new();
-        builder
-            .protocol_version(AliroProtocolVersion { major: 2, minor: 1 })
-            .uwb_config(AliroUwbConfig::Config0)
-            .pulse_shape_combo(AliroPulseShapeCombo {
-                initiator_tx: AliroPulseShape::PrecursorFree,
-                responder_tx: AliroPulseShape::PrecursorFreeSpecial,
-            })
-            .ran_multiplier(3)
-            .channel_number(AliroUwbChannel::Channel9)
-            .chaps_per_slot(AliroChapsPerSlot::Value9)
-            .num_responder_nodes(1)
-            .slots_per_rr(3)
-            .sync_code_index(12)
-            .hopping_mode(AliroHoppingMode::ContinuousAes);
-        let params = builder.build().unwrap();
-
-        builder.ran_multiplier(5);
-        let updated_params = builder.build().unwrap();
-        // ran_multiplier can be updated at idle state.
-        assert!(updated_params
-            .generate_updated_config_map(&params, SessionState::SessionStateIdle)
-            .is_some());
-        // ran_multiplier cannot be updated at active state.
-        assert!(updated_params
-            .generate_updated_config_map(&params, SessionState::SessionStateActive)
-            .is_none());
-    }
-}
diff --git a/src/rust/uwb_core/src/params/app_config_params.rs b/src/rust/uwb_core/src/params/app_config_params.rs
deleted file mode 100644
index 5361316..0000000
--- a/src/rust/uwb_core/src/params/app_config_params.rs
+++ /dev/null
@@ -1,138 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#![allow(missing_docs)]
-
-use std::collections::HashMap;
-
-use crate::params::aliro_app_config_params::AliroAppConfigParams;
-use crate::params::ccc_app_config_params::CccAppConfigParams;
-use crate::params::ccc_started_app_config_params::CccStartedAppConfigParams;
-use crate::params::fira_app_config_params::FiraAppConfigParams;
-use crate::params::uci_packets::{AppConfigTlv, AppConfigTlvType, SessionState, SessionType};
-
-pub(super) type AppConfigTlvMap = HashMap<AppConfigTlvType, Vec<u8>>;
-
-/// The application configuration parameters of the UWB session. It is used to generate the
-/// parameters for the SESSION_SET_APP_CONFIG_CMD, or converted from the result of the
-/// SESSION_GET_APP_CONFIG_CMD.
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub enum AppConfigParams {
-    Fira(FiraAppConfigParams),
-    Ccc(CccAppConfigParams),
-    CccStarted(CccStartedAppConfigParams),
-    Aliro(AliroAppConfigParams),
-}
-
-impl AppConfigParams {
-    /// Generate the TLV list from the params.
-    pub fn generate_tlvs(&self) -> Vec<AppConfigTlv> {
-        Self::config_map_to_tlvs(self.generate_config_map())
-    }
-
-    /// Generate the updated TLV list from the difference between this and the previous params.
-    pub fn generate_updated_tlvs(
-        &self,
-        prev_params: &Self,
-        session_state: SessionState,
-    ) -> Option<Vec<AppConfigTlv>> {
-        Some(Self::config_map_to_tlvs(
-            self.generate_updated_config_map(prev_params, session_state)?,
-        ))
-    }
-
-    fn config_map_to_tlvs(config_map: AppConfigTlvMap) -> Vec<AppConfigTlv> {
-        config_map.into_iter().map(|(cfg_id, v)| AppConfigTlv::new(cfg_id, v)).collect()
-    }
-
-    pub(super) fn generate_config_map(&self) -> AppConfigTlvMap {
-        match self {
-            Self::Fira(params) => params.generate_config_map(),
-            Self::Ccc(params) => params.generate_config_map(),
-            Self::Aliro(params) => params.generate_config_map(),
-            _ => HashMap::new(),
-        }
-    }
-
-    pub(super) fn generate_updated_config_map(
-        &self,
-        prev_params: &Self,
-        session_state: SessionState,
-    ) -> Option<AppConfigTlvMap> {
-        let config_map = self.generate_config_map();
-        let prev_config_map = prev_params.generate_config_map();
-
-        match (self, prev_params) {
-            (Self::Fira(_), Self::Fira(_)) => {
-                let updated_config_map = Self::diff_config_map(config_map, prev_config_map);
-                if FiraAppConfigParams::is_config_updatable(&updated_config_map, session_state) {
-                    Some(updated_config_map)
-                } else {
-                    None
-                }
-            }
-            (Self::Ccc(_), Self::Ccc(_)) => {
-                let updated_config_map = Self::diff_config_map(config_map, prev_config_map);
-                if CccAppConfigParams::is_config_updatable(&updated_config_map, session_state) {
-                    Some(updated_config_map)
-                } else {
-                    None
-                }
-            }
-            (Self::Aliro(_), Self::Aliro(_)) => {
-                let updated_config_map = Self::diff_config_map(config_map, prev_config_map);
-                if AliroAppConfigParams::is_config_updatable(&updated_config_map, session_state) {
-                    Some(updated_config_map)
-                } else {
-                    None
-                }
-            }
-            _ => None,
-        }
-    }
-
-    pub fn is_type_matched(&self, session_type: SessionType) -> bool {
-        match self {
-            Self::Fira(_) => {
-                session_type == SessionType::FiraDataTransferSession
-                    || session_type == SessionType::FiraRangingSession
-                    || session_type == SessionType::FiraRangingAndInBandDataSession
-                    || session_type == SessionType::FiraRangingOnlyPhase
-                    || session_type == SessionType::FiraInBandDataPhase
-                    || session_type == SessionType::FiraRangingWithDataPhase
-            }
-            Self::Ccc(_) | Self::CccStarted(_) => session_type == SessionType::Ccc,
-            Self::Aliro(_) => session_type == SessionType::Aliro,
-        }
-    }
-
-    fn diff_config_map(
-        config_map: AppConfigTlvMap,
-        prev_config_map: AppConfigTlvMap,
-    ) -> AppConfigTlvMap {
-        // The key sets of both map should be the same.
-        debug_assert!(
-            config_map.len() == prev_config_map.len()
-                && config_map.keys().all(|key| prev_config_map.contains_key(key))
-        );
-
-        let mut updated_config_map = HashMap::new();
-        for (key, value) in config_map.into_iter() {
-            if !matches!(prev_config_map.get(&key), Some(prev_value) if prev_value == &value) {
-                updated_config_map.insert(key, value);
-            }
-        }
-        updated_config_map
-    }
-}
diff --git a/src/rust/uwb_core/src/params/ccc_app_config_params.rs b/src/rust/uwb_core/src/params/ccc_app_config_params.rs
deleted file mode 100644
index 2e8e0ca..0000000
--- a/src/rust/uwb_core/src/params/ccc_app_config_params.rs
+++ /dev/null
@@ -1,397 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, item 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#![allow(missing_docs)]
-
-use std::collections::HashMap;
-
-use log::error;
-
-use crate::params::app_config_params::{AppConfigParams, AppConfigTlvMap};
-use crate::params::fira_app_config_params::{
-    DeviceRole, DeviceType, KeyRotation, MultiNodeMode, RangeDataNtfConfig, StsConfig,
-};
-use crate::params::uci_packets::{AppConfigTlvType, SessionState};
-use crate::params::utils::{u16_to_bytes, u32_to_bytes, u8_to_bytes, validate};
-use crate::utils::{builder_field, getter_field};
-use num_derive::{FromPrimitive, ToPrimitive};
-
-const CHAP_IN_RSTU: u16 = 400; // 1 Chap = 400 RSTU.
-pub(super) const MINIMUM_BLOCK_DURATION_MS: u32 = 96;
-
-// The constant AppConfigTlv values for CCC.
-const CCC_DEVICE_TYPE: DeviceType = DeviceType::Controlee;
-const CCC_STS_CONFIG: StsConfig = StsConfig::Dynamic;
-const CCC_MULTI_NODE_MODE: MultiNodeMode = MultiNodeMode::OneToMany;
-const CCC_RANGE_DATA_NTF_CONFIG: RangeDataNtfConfig = RangeDataNtfConfig::Disable;
-const CCC_DEVICE_ROLE: DeviceRole = DeviceRole::Initiator;
-const CCC_KEY_ROTATION: KeyRotation = KeyRotation::Enable;
-const CCC_URSK_TTL: u16 = 0x2D0;
-
-const DEFAULT_PROTOCOL_VERSION: CccProtocolVersion = CccProtocolVersion { major: 1, minor: 0 };
-
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct CccAppConfigParams {
-    protocol_version: CccProtocolVersion,
-    uwb_config: CccUwbConfig,
-    pulse_shape_combo: CccPulseShapeCombo,
-    ran_multiplier: u32,
-    channel_number: CccUwbChannel,
-    chaps_per_slot: ChapsPerSlot,
-    num_responder_nodes: u8,
-    slots_per_rr: u8,
-    sync_code_index: u8,
-    hopping_mode: CccHoppingMode,
-}
-
-#[allow(missing_docs)]
-impl CccAppConfigParams {
-    // Generate the getter methods for all the fields.
-    getter_field!(protocol_version, CccProtocolVersion);
-    getter_field!(uwb_config, CccUwbConfig);
-    getter_field!(pulse_shape_combo, CccPulseShapeCombo);
-    getter_field!(ran_multiplier, u32);
-    getter_field!(channel_number, CccUwbChannel);
-    getter_field!(chaps_per_slot, ChapsPerSlot);
-    getter_field!(num_responder_nodes, u8);
-    getter_field!(slots_per_rr, u8);
-    getter_field!(sync_code_index, u8);
-    getter_field!(hopping_mode, CccHoppingMode);
-
-    pub fn is_config_updatable(config_map: &AppConfigTlvMap, session_state: SessionState) -> bool {
-        match session_state {
-            SessionState::SessionStateIdle => {
-                // Only ran_multiplier can be updated at idle state.
-                config_map.keys().all(|key| key == &AppConfigTlvType::RangingDuration)
-            }
-            _ => false,
-        }
-    }
-
-    pub fn generate_config_map(&self) -> AppConfigTlvMap {
-        debug_assert!(self.is_valid().is_some());
-
-        HashMap::from([
-            (AppConfigTlvType::DeviceType, u8_to_bytes(CCC_DEVICE_TYPE as u8)),
-            (AppConfigTlvType::StsConfig, u8_to_bytes(CCC_STS_CONFIG as u8)),
-            (AppConfigTlvType::MultiNodeMode, u8_to_bytes(CCC_MULTI_NODE_MODE as u8)),
-            (AppConfigTlvType::ChannelNumber, u8_to_bytes(self.channel_number as u8)),
-            (AppConfigTlvType::NoOfControlee, u8_to_bytes(self.num_responder_nodes)),
-            (
-                AppConfigTlvType::SlotDuration,
-                u16_to_bytes((self.chaps_per_slot as u16) * CHAP_IN_RSTU),
-            ),
-            (
-                AppConfigTlvType::RangingDuration,
-                u32_to_bytes(self.ran_multiplier * MINIMUM_BLOCK_DURATION_MS),
-            ),
-            (AppConfigTlvType::RngDataNtf, u8_to_bytes(CCC_RANGE_DATA_NTF_CONFIG as u8)),
-            (AppConfigTlvType::DeviceRole, u8_to_bytes(CCC_DEVICE_ROLE as u8)),
-            (AppConfigTlvType::PreambleCodeIndex, u8_to_bytes(self.sync_code_index)),
-            (AppConfigTlvType::SlotsPerRr, u8_to_bytes(self.slots_per_rr)),
-            (AppConfigTlvType::KeyRotation, u8_to_bytes(CCC_KEY_ROTATION as u8)),
-            (AppConfigTlvType::HoppingMode, u8_to_bytes(self.hopping_mode as u8)),
-            (AppConfigTlvType::CccRangingProtocolVer, self.protocol_version.clone().into()),
-            (AppConfigTlvType::CccUwbConfigId, u16_to_bytes(self.uwb_config as u16)),
-            (AppConfigTlvType::CccPulseshapeCombo, self.pulse_shape_combo.clone().into()),
-            (AppConfigTlvType::CccUrskTtl, u16_to_bytes(CCC_URSK_TTL)),
-        ])
-    }
-
-    fn is_valid(&self) -> Option<()> {
-        validate(
-            (1..=32).contains(&self.sync_code_index),
-            "sync_code_index should be between 1 to 32",
-        )?;
-
-        self.ran_multiplier.checked_mul(MINIMUM_BLOCK_DURATION_MS).or_else(|| {
-            error!("ran_multiplier * MINIMUM_BLOCK_DURATION_MS overflows");
-            None
-        })?;
-
-        Some(())
-    }
-}
-
-pub struct CccAppConfigParamsBuilder {
-    protocol_version: CccProtocolVersion,
-    uwb_config: Option<CccUwbConfig>,
-    pulse_shape_combo: Option<CccPulseShapeCombo>,
-    ran_multiplier: Option<u32>,
-    channel_number: Option<CccUwbChannel>,
-    chaps_per_slot: Option<ChapsPerSlot>,
-    num_responder_nodes: Option<u8>,
-    slots_per_rr: Option<u8>,
-    sync_code_index: Option<u8>,
-    hopping_mode: Option<CccHoppingMode>,
-}
-
-#[allow(clippy::new_without_default)]
-impl CccAppConfigParamsBuilder {
-    pub fn new() -> Self {
-        Self {
-            protocol_version: DEFAULT_PROTOCOL_VERSION,
-            uwb_config: None,
-            pulse_shape_combo: None,
-            ran_multiplier: None,
-            channel_number: None,
-            chaps_per_slot: None,
-            num_responder_nodes: None,
-            slots_per_rr: None,
-            sync_code_index: None,
-            hopping_mode: None,
-        }
-    }
-
-    pub fn build(&self) -> Option<AppConfigParams> {
-        let params = CccAppConfigParams {
-            protocol_version: self.protocol_version.clone(),
-            uwb_config: self.uwb_config?,
-            pulse_shape_combo: self.pulse_shape_combo.clone()?,
-            ran_multiplier: self.ran_multiplier?,
-            channel_number: self.channel_number?,
-            chaps_per_slot: self.chaps_per_slot?,
-            num_responder_nodes: self.num_responder_nodes?,
-            slots_per_rr: self.slots_per_rr?,
-            sync_code_index: self.sync_code_index?,
-            hopping_mode: self.hopping_mode?,
-        };
-        params.is_valid()?;
-        Some(AppConfigParams::Ccc(params))
-    }
-
-    pub fn from_params(params: &AppConfigParams) -> Option<Self> {
-        match params {
-            AppConfigParams::Ccc(params) => Some(Self {
-                protocol_version: params.protocol_version.clone(),
-                uwb_config: Some(params.uwb_config),
-                pulse_shape_combo: Some(params.pulse_shape_combo.clone()),
-                ran_multiplier: Some(params.ran_multiplier),
-                channel_number: Some(params.channel_number),
-                chaps_per_slot: Some(params.chaps_per_slot),
-                num_responder_nodes: Some(params.num_responder_nodes),
-                slots_per_rr: Some(params.slots_per_rr),
-                sync_code_index: Some(params.sync_code_index),
-                hopping_mode: Some(params.hopping_mode),
-            }),
-            _ => None,
-        }
-    }
-
-    // Generate the setter methods for all the fields.
-    builder_field!(protocol_version, CccProtocolVersion);
-    builder_field!(uwb_config, CccUwbConfig, Some);
-    builder_field!(pulse_shape_combo, CccPulseShapeCombo, Some);
-    builder_field!(ran_multiplier, u32, Some);
-    builder_field!(channel_number, CccUwbChannel, Some);
-    builder_field!(chaps_per_slot, ChapsPerSlot, Some);
-    builder_field!(num_responder_nodes, u8, Some);
-    builder_field!(slots_per_rr, u8, Some);
-    builder_field!(sync_code_index, u8, Some);
-    builder_field!(hopping_mode, CccHoppingMode, Some);
-}
-
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct CccProtocolVersion {
-    pub major: u8,
-    pub minor: u8,
-}
-
-impl From<CccProtocolVersion> for Vec<u8> {
-    fn from(item: CccProtocolVersion) -> Self {
-        vec![item.major, item.minor]
-    }
-}
-
-#[repr(u16)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum CccUwbConfig {
-    Config0 = 0,
-    Config1 = 1,
-}
-
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct CccPulseShapeCombo {
-    pub initiator_tx: PulseShape,
-    pub responder_tx: PulseShape,
-}
-
-impl From<CccPulseShapeCombo> for Vec<u8> {
-    fn from(item: CccPulseShapeCombo) -> Self {
-        vec![((item.initiator_tx as u8) << 4) | (item.responder_tx as u8)]
-    }
-}
-
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum PulseShape {
-    SymmetricalRootRaisedCosine = 0x0,
-    PrecursorFree = 0x1,
-    PrecursorFreeSpecial = 0x2,
-}
-
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum CccUwbChannel {
-    Channel5 = 5,
-    Channel9 = 9,
-}
-
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum HoppingConfigMode {
-    None = 0,
-    Continuous = 1,
-    Adaptive = 2,
-}
-
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum HoppingSequence {
-    Default = 0,
-    Aes = 1,
-}
-
-#[repr(u16)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum ChapsPerSlot {
-    Value3 = 3,
-    Value4 = 4,
-    Value6 = 6,
-    Value8 = 8,
-    Value9 = 9,
-    Value12 = 12,
-    Value24 = 24,
-}
-
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum CccHoppingMode {
-    Disable = 0,
-    AdaptiveDefault = 2,
-    ContinuousDefault = 3,
-    AdaptiveAes = 4,
-    ContinuousAes = 5,
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_ok() {
-        let protocol_version = CccProtocolVersion { major: 2, minor: 1 };
-        let uwb_config = CccUwbConfig::Config0;
-        let pulse_shape_combo = CccPulseShapeCombo {
-            initiator_tx: PulseShape::PrecursorFree,
-            responder_tx: PulseShape::PrecursorFreeSpecial,
-        };
-        let ran_multiplier = 3;
-        let channel_number = CccUwbChannel::Channel9;
-        let chaps_per_slot = ChapsPerSlot::Value9;
-        let num_responder_nodes = 1;
-        let slots_per_rr = 3;
-        let sync_code_index = 12;
-        let hopping_mode = CccHoppingMode::ContinuousAes;
-
-        let params = CccAppConfigParamsBuilder::new()
-            .protocol_version(protocol_version)
-            .uwb_config(uwb_config)
-            .pulse_shape_combo(pulse_shape_combo.clone())
-            .ran_multiplier(ran_multiplier)
-            .channel_number(channel_number)
-            .chaps_per_slot(chaps_per_slot)
-            .num_responder_nodes(num_responder_nodes)
-            .slots_per_rr(slots_per_rr)
-            .sync_code_index(sync_code_index)
-            .hopping_mode(hopping_mode)
-            .build()
-            .unwrap();
-
-        // Verify the generated TLV.
-        let config_map = params.generate_config_map();
-        let expected_config_map = HashMap::from([
-            (AppConfigTlvType::DeviceType, u8_to_bytes(CCC_DEVICE_TYPE as u8)),
-            (AppConfigTlvType::StsConfig, u8_to_bytes(CCC_STS_CONFIG as u8)),
-            (AppConfigTlvType::MultiNodeMode, u8_to_bytes(CCC_MULTI_NODE_MODE as u8)),
-            (AppConfigTlvType::ChannelNumber, u8_to_bytes(channel_number as u8)),
-            (AppConfigTlvType::NoOfControlee, u8_to_bytes(num_responder_nodes)),
-            (AppConfigTlvType::SlotDuration, u16_to_bytes((chaps_per_slot as u16) * CHAP_IN_RSTU)),
-            (
-                AppConfigTlvType::RangingDuration,
-                u32_to_bytes(ran_multiplier * MINIMUM_BLOCK_DURATION_MS),
-            ),
-            (AppConfigTlvType::RngDataNtf, u8_to_bytes(CCC_RANGE_DATA_NTF_CONFIG as u8)),
-            (AppConfigTlvType::DeviceRole, u8_to_bytes(CCC_DEVICE_ROLE as u8)),
-            (AppConfigTlvType::PreambleCodeIndex, u8_to_bytes(sync_code_index)),
-            (AppConfigTlvType::SlotsPerRr, u8_to_bytes(slots_per_rr)),
-            (AppConfigTlvType::KeyRotation, u8_to_bytes(CCC_KEY_ROTATION as u8)),
-            (AppConfigTlvType::HoppingMode, u8_to_bytes(hopping_mode as u8)),
-            (AppConfigTlvType::CccRangingProtocolVer, vec![2, 1]),
-            (AppConfigTlvType::CccUwbConfigId, u16_to_bytes(uwb_config as u16)),
-            (AppConfigTlvType::CccPulseshapeCombo, pulse_shape_combo.into()),
-            (AppConfigTlvType::CccUrskTtl, u16_to_bytes(CCC_URSK_TTL)),
-        ]);
-        assert_eq!(config_map, expected_config_map);
-
-        // Update the value from the params.
-        let updated_ran_multiplier = 5;
-        assert_ne!(ran_multiplier, updated_ran_multiplier);
-        let expected_updated_config_map = HashMap::from([(
-            AppConfigTlvType::RangingDuration,
-            u32_to_bytes(updated_ran_multiplier * MINIMUM_BLOCK_DURATION_MS),
-        )]);
-
-        let updated_params1 = CccAppConfigParamsBuilder::from_params(&params)
-            .unwrap()
-            .ran_multiplier(updated_ran_multiplier)
-            .build()
-            .unwrap();
-        let updated_config_map1 = updated_params1
-            .generate_updated_config_map(&params, SessionState::SessionStateIdle)
-            .unwrap();
-        assert_eq!(updated_config_map1, expected_updated_config_map);
-    }
-
-    #[test]
-    fn test_update_config() {
-        let mut builder = CccAppConfigParamsBuilder::new();
-        builder
-            .protocol_version(CccProtocolVersion { major: 2, minor: 1 })
-            .uwb_config(CccUwbConfig::Config0)
-            .pulse_shape_combo(CccPulseShapeCombo {
-                initiator_tx: PulseShape::PrecursorFree,
-                responder_tx: PulseShape::PrecursorFreeSpecial,
-            })
-            .ran_multiplier(3)
-            .channel_number(CccUwbChannel::Channel9)
-            .chaps_per_slot(ChapsPerSlot::Value9)
-            .num_responder_nodes(1)
-            .slots_per_rr(3)
-            .sync_code_index(12)
-            .hopping_mode(CccHoppingMode::ContinuousAes);
-        let params = builder.build().unwrap();
-
-        builder.ran_multiplier(5);
-        let updated_params = builder.build().unwrap();
-        // ran_multiplier can be updated at idle state.
-        assert!(updated_params
-            .generate_updated_config_map(&params, SessionState::SessionStateIdle)
-            .is_some());
-        // ran_multiplier cannot be updated at active state.
-        assert!(updated_params
-            .generate_updated_config_map(&params, SessionState::SessionStateActive)
-            .is_none());
-    }
-}
diff --git a/src/rust/uwb_core/src/params/ccc_started_app_config_params.rs b/src/rust/uwb_core/src/params/ccc_started_app_config_params.rs
deleted file mode 100644
index 97039a1..0000000
--- a/src/rust/uwb_core/src/params/ccc_started_app_config_params.rs
+++ /dev/null
@@ -1,78 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, item 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#![allow(missing_docs)]
-
-use crate::params::app_config_params::AppConfigTlvMap;
-use crate::params::ccc_app_config_params::MINIMUM_BLOCK_DURATION_MS;
-use crate::params::uci_packets::AppConfigTlvType;
-use crate::params::utils::{bytes_to_u32, bytes_to_u64, bytes_to_u8};
-
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct CccStartedAppConfigParams {
-    pub sts_index: u32,
-    pub hop_mode_key: u32,
-    pub uwb_time0: u64,
-    pub ran_multiplier: u32,
-    pub sync_code_index: u8,
-}
-
-impl CccStartedAppConfigParams {
-    pub fn from_config_map(mut config_map: AppConfigTlvMap) -> Option<Self> {
-        Some(Self {
-            sts_index: bytes_to_u32(config_map.remove(&AppConfigTlvType::StsIndex)?)?,
-            hop_mode_key: bytes_to_u32(config_map.remove(&AppConfigTlvType::CccHopModeKey)?)?,
-            uwb_time0: bytes_to_u64(config_map.remove(&AppConfigTlvType::CccUwbTime0)?)?,
-            ran_multiplier: bytes_to_u32(config_map.remove(&AppConfigTlvType::RangingDuration)?)?
-                / MINIMUM_BLOCK_DURATION_MS,
-            sync_code_index: bytes_to_u8(config_map.remove(&AppConfigTlvType::PreambleCodeIndex)?)?,
-        })
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    use std::collections::HashMap;
-
-    use crate::params::utils::{u32_to_bytes, u64_to_bytes, u8_to_bytes};
-
-    #[test]
-    fn test_from_config_map() {
-        let sts_index = 3;
-        let hop_mode_key = 5;
-        let uwb_time0 = 7;
-        let ran_multiplier = 4;
-        let sync_code_index = 9;
-
-        let config_map = HashMap::from([
-            (AppConfigTlvType::StsIndex, u32_to_bytes(sts_index)),
-            (AppConfigTlvType::CccHopModeKey, u32_to_bytes(hop_mode_key)),
-            (AppConfigTlvType::CccUwbTime0, u64_to_bytes(uwb_time0)),
-            (
-                AppConfigTlvType::RangingDuration,
-                u32_to_bytes(ran_multiplier * MINIMUM_BLOCK_DURATION_MS),
-            ),
-            (AppConfigTlvType::PreambleCodeIndex, u8_to_bytes(sync_code_index)),
-        ]);
-        let params = CccStartedAppConfigParams::from_config_map(config_map).unwrap();
-
-        assert_eq!(params.sts_index, sts_index);
-        assert_eq!(params.hop_mode_key, hop_mode_key);
-        assert_eq!(params.uwb_time0, uwb_time0);
-        assert_eq!(params.ran_multiplier, ran_multiplier);
-        assert_eq!(params.sync_code_index, sync_code_index);
-    }
-}
diff --git a/src/rust/uwb_core/src/params/fira_app_config_params.rs b/src/rust/uwb_core/src/params/fira_app_config_params.rs
deleted file mode 100644
index de0321a..0000000
--- a/src/rust/uwb_core/src/params/fira_app_config_params.rs
+++ /dev/null
@@ -1,1376 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module defines the UCI application config parameters for the FiRa ranging session.
-
-use std::collections::{HashMap, HashSet};
-use std::convert::{TryFrom, TryInto};
-
-use log::warn;
-use num_derive::{FromPrimitive, ToPrimitive};
-use zeroize::Zeroize;
-
-use crate::params::app_config_params::{AppConfigParams, AppConfigTlvMap};
-use crate::params::uci_packets::{AppConfigTlvType, SessionState, SubSessionId};
-use crate::params::utils::{u16_to_bytes, u32_to_bytes, u8_to_bytes, validate};
-use crate::utils::{builder_field, getter_field};
-
-// The default value of each parameters.
-const DEFAULT_RANGING_ROUND_USAGE: RangingRoundUsage = RangingRoundUsage::DsTwr;
-const DEFAULT_STS_CONFIG: StsConfig = StsConfig::Static;
-const DEFAULT_CHANNEL_NUMBER: UwbChannel = UwbChannel::Channel9;
-const DEFAULT_SLOT_DURATION_RSTU: u16 = 2400;
-const DEFAULT_RANGING_DURATION_MS: u32 = 200;
-const DEFAULT_MAC_FCS_TYPE: MacFcsType = MacFcsType::Crc16;
-const DEFAULT_RANGING_ROUND_CONTROL: RangingRoundControl = RangingRoundControl {
-    ranging_result_report_message: true,
-    control_message: true,
-    measurement_report_message: false,
-};
-const DEFAULT_AOA_RESULT_REQUEST: AoaResultRequest = AoaResultRequest::ReqAoaResults;
-const DEFAULT_RANGE_DATA_NTF_CONFIG: RangeDataNtfConfig = RangeDataNtfConfig::Enable;
-const DEFAULT_RANGE_DATA_NTF_PROXIMITY_NEAR_CM: u16 = 0;
-const DEFAULT_RANGE_DATA_NTF_PROXIMITY_FAR_CM: u16 = 20000;
-const DEFAULT_RFRAME_CONFIG: RframeConfig = RframeConfig::SP3;
-const DEFAULT_PREAMBLE_CODE_INDEX: u8 = 10;
-const DEFAULT_SFD_ID: u8 = 2;
-const DEFAULT_PSDU_DATA_RATE: PsduDataRate = PsduDataRate::Rate6m81;
-const DEFAULT_PREAMBLE_DURATION: PreambleDuration = PreambleDuration::T64Symbols;
-const DEFAULT_RANGING_TIME_STRUCT: RangingTimeStruct = RangingTimeStruct::BlockBasedScheduling;
-const DEFAULT_SLOTS_PER_RR: u8 = 25;
-const DEFAULT_TX_ADAPTIVE_PAYLOAD_POWER: TxAdaptivePayloadPower = TxAdaptivePayloadPower::Disable;
-const DEFAULT_RESPONDER_SLOT_INDEX: u8 = 1;
-const DEFAULT_PRF_MODE: PrfMode = PrfMode::Bprf;
-const DEFAULT_SCHEDULED_MODE: ScheduledMode = ScheduledMode::TimeScheduledRanging;
-const DEFAULT_KEY_ROTATION: KeyRotation = KeyRotation::Disable;
-const DEFAULT_KEY_ROTATION_RATE: u8 = 0;
-const DEFAULT_SESSION_PRIORITY: u8 = 50;
-const DEFAULT_MAC_ADDRESS_MODE: MacAddressMode = MacAddressMode::MacAddress2Bytes;
-const DEFAULT_NUMBER_OF_STS_SEGMENTS: u8 = 1;
-const DEFAULT_MAX_RR_RETRY: u16 = 0;
-const DEFAULT_UWB_INITIATION_TIME_MS: u32 = 0;
-const DEFAULT_HOPPING_MODE: HoppingMode = HoppingMode::Disable;
-const DEFAULT_BLOCK_STRIDE_LENGTH: u8 = 0;
-const DEFAULT_RESULT_REPORT_CONFIG: ResultReportConfig =
-    ResultReportConfig { tof: true, aoa_azimuth: false, aoa_elevation: false, aoa_fom: false };
-const DEFAULT_IN_BAND_TERMINATION_ATTEMPT_COUNT: u8 = 1;
-const DEFAULT_SUB_SESSION_ID: u32 = 0;
-const DEFAULT_BPRF_PHR_DATA_RATE: BprfPhrDataRate = BprfPhrDataRate::Rate850k;
-const DEFAULT_MAX_NUMBER_OF_MEASUREMENTS: u16 = 0;
-const DEFAULT_STS_LENGTH: StsLength = StsLength::Length64;
-const DEFAULT_NUMBER_OF_RANGE_MEASUREMENTS: u8 = 0;
-const DEFAULT_NUMBER_OF_AOA_AZIMUTH_MEASUREMENTS: u8 = 0;
-const DEFAULT_NUMBER_OF_AOA_ELEVATION_MEASUREMENTS: u8 = 0;
-
-/// The FiRa's application configuration parameters.
-/// Ref: FiRa Consortium UWB Command Interface Generic Techinal Specification Version 1.1.0.
-#[derive(Clone, PartialEq, Eq)]
-pub struct FiraAppConfigParams {
-    // FiRa standard config.
-    device_type: DeviceType,
-    ranging_round_usage: RangingRoundUsage,
-    sts_config: StsConfig,
-    multi_node_mode: MultiNodeMode,
-    channel_number: UwbChannel,
-    device_mac_address: UwbAddress,
-    dst_mac_address: Vec<UwbAddress>,
-    slot_duration_rstu: u16,
-    ranging_duration_ms: u32,
-    mac_fcs_type: MacFcsType,
-    ranging_round_control: RangingRoundControl,
-    aoa_result_request: AoaResultRequest,
-    range_data_ntf_config: RangeDataNtfConfig,
-    range_data_ntf_proximity_near_cm: u16,
-    range_data_ntf_proximity_far_cm: u16,
-    device_role: DeviceRole,
-    rframe_config: RframeConfig,
-    preamble_code_index: u8,
-    sfd_id: u8,
-    psdu_data_rate: PsduDataRate,
-    preamble_duration: PreambleDuration,
-    ranging_time_struct: RangingTimeStruct,
-    slots_per_rr: u8,
-    tx_adaptive_payload_power: TxAdaptivePayloadPower,
-    responder_slot_index: u8,
-    prf_mode: PrfMode,
-    scheduled_mode: ScheduledMode,
-    key_rotation: KeyRotation,
-    key_rotation_rate: u8,
-    session_priority: u8,
-    mac_address_mode: MacAddressMode,
-    vendor_id: [u8; 2],
-    static_sts_iv: [u8; 6],
-    number_of_sts_segments: u8,
-    max_rr_retry: u16,
-    uwb_initiation_time_ms: u32,
-    hopping_mode: HoppingMode,
-    block_stride_length: u8,
-    result_report_config: ResultReportConfig,
-    in_band_termination_attempt_count: u8,
-    sub_session_id: SubSessionId,
-    bprf_phr_data_rate: BprfPhrDataRate,
-    max_number_of_measurements: u16,
-    sts_length: StsLength,
-
-    // Android-specific app config.
-    number_of_range_measurements: u8,
-    number_of_aoa_azimuth_measurements: u8,
-    number_of_aoa_elevation_measurements: u8,
-}
-
-/// Explicitly implement Debug trait to prevent logging PII data.
-impl std::fmt::Debug for FiraAppConfigParams {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
-        static REDACTED_STR: &str = "redacted";
-
-        f.debug_struct("FiraAppConfigParams")
-            .field("device_type", &self.device_type)
-            .field("ranging_round_usage", &self.ranging_round_usage)
-            .field("sts_config", &self.sts_config)
-            .field("multi_node_mode", &self.multi_node_mode)
-            .field("channel_number", &self.channel_number)
-            .field("device_mac_address", &self.device_mac_address)
-            .field("dst_mac_address", &self.dst_mac_address)
-            .field("slot_duration_rstu", &self.slot_duration_rstu)
-            .field("ranging_duration_ms", &self.ranging_duration_ms)
-            .field("mac_fcs_type", &self.mac_fcs_type)
-            .field("ranging_round_control", &self.ranging_round_control)
-            .field("aoa_result_request", &self.aoa_result_request)
-            .field("range_data_ntf_config", &self.range_data_ntf_config)
-            .field("range_data_ntf_proximity_near_cm", &self.range_data_ntf_proximity_near_cm)
-            .field("range_data_ntf_proximity_far_cm", &self.range_data_ntf_proximity_far_cm)
-            .field("device_role", &self.device_role)
-            .field("rframe_config", &self.rframe_config)
-            .field("preamble_code_index", &self.preamble_code_index)
-            .field("sfd_id", &self.sfd_id)
-            .field("psdu_data_rate", &self.psdu_data_rate)
-            .field("preamble_duration", &self.preamble_duration)
-            .field("ranging_time_struct", &self.ranging_time_struct)
-            .field("slots_per_rr", &self.slots_per_rr)
-            .field("tx_adaptive_payload_power", &self.tx_adaptive_payload_power)
-            .field("responder_slot_index", &self.responder_slot_index)
-            .field("prf_mode", &self.prf_mode)
-            .field("scheduled_mode", &self.scheduled_mode)
-            .field("key_rotation", &self.key_rotation)
-            .field("key_rotation_rate", &self.key_rotation_rate)
-            .field("session_priority", &self.session_priority)
-            .field("mac_address_mode", &self.mac_address_mode)
-            .field("vendor_id", &REDACTED_STR) // vendor_id field is PII.
-            .field("static_sts_iv", &REDACTED_STR) // static_sts_iv field is PII.
-            .field("number_of_sts_segments", &self.number_of_sts_segments)
-            .field("max_rr_retry", &self.max_rr_retry)
-            .field("uwb_initiation_time_ms", &self.uwb_initiation_time_ms)
-            .field("hopping_mode", &self.hopping_mode)
-            .field("block_stride_length", &self.block_stride_length)
-            .field("result_report_config", &self.result_report_config)
-            .field("in_band_termination_attempt_count", &self.in_band_termination_attempt_count)
-            .field("sub_session_id", &self.sub_session_id)
-            .field("bprf_phr_data_rate", &self.bprf_phr_data_rate)
-            .field("max_number_of_measurements", &self.max_number_of_measurements)
-            .field("sts_length", &self.sts_length)
-            .field("number_of_range_measurements", &self.number_of_range_measurements)
-            .field("number_of_aoa_azimuth_measurements", &self.number_of_aoa_azimuth_measurements)
-            .field(
-                "number_of_aoa_elevation_measurements",
-                &self.number_of_aoa_elevation_measurements,
-            )
-            .finish()
-    }
-}
-
-impl Drop for FiraAppConfigParams {
-    fn drop(&mut self) {
-        self.vendor_id.zeroize();
-        self.static_sts_iv.zeroize();
-        self.sub_session_id.zeroize();
-    }
-}
-
-#[allow(missing_docs)]
-impl FiraAppConfigParams {
-    // Generate the getter methods for all the fields.
-    getter_field!(device_type, DeviceType);
-    getter_field!(ranging_round_usage, RangingRoundUsage);
-    getter_field!(sts_config, StsConfig);
-    getter_field!(multi_node_mode, MultiNodeMode);
-    getter_field!(channel_number, UwbChannel);
-    getter_field!(device_mac_address, UwbAddress);
-    getter_field!(dst_mac_address, Vec<UwbAddress>);
-    getter_field!(slot_duration_rstu, u16);
-    getter_field!(ranging_duration_ms, u32);
-    getter_field!(mac_fcs_type, MacFcsType);
-    getter_field!(ranging_round_control, RangingRoundControl);
-    getter_field!(aoa_result_request, AoaResultRequest);
-    getter_field!(range_data_ntf_config, RangeDataNtfConfig);
-    getter_field!(range_data_ntf_proximity_near_cm, u16);
-    getter_field!(range_data_ntf_proximity_far_cm, u16);
-    getter_field!(device_role, DeviceRole);
-    getter_field!(rframe_config, RframeConfig);
-    getter_field!(preamble_code_index, u8);
-    getter_field!(sfd_id, u8);
-    getter_field!(psdu_data_rate, PsduDataRate);
-    getter_field!(preamble_duration, PreambleDuration);
-    getter_field!(ranging_time_struct, RangingTimeStruct);
-    getter_field!(slots_per_rr, u8);
-    getter_field!(tx_adaptive_payload_power, TxAdaptivePayloadPower);
-    getter_field!(responder_slot_index, u8);
-    getter_field!(prf_mode, PrfMode);
-    getter_field!(scheduled_mode, ScheduledMode);
-    getter_field!(key_rotation, KeyRotation);
-    getter_field!(key_rotation_rate, u8);
-    getter_field!(session_priority, u8);
-    getter_field!(mac_address_mode, MacAddressMode);
-    getter_field!(vendor_id, [u8; 2]);
-    getter_field!(static_sts_iv, [u8; 6]);
-    getter_field!(number_of_sts_segments, u8);
-    getter_field!(max_rr_retry, u16);
-    getter_field!(uwb_initiation_time_ms, u32);
-    getter_field!(hopping_mode, HoppingMode);
-    getter_field!(block_stride_length, u8);
-    getter_field!(result_report_config, ResultReportConfig);
-    getter_field!(in_band_termination_attempt_count, u8);
-    getter_field!(sub_session_id, u32);
-    getter_field!(bprf_phr_data_rate, BprfPhrDataRate);
-    getter_field!(max_number_of_measurements, u16);
-    getter_field!(sts_length, StsLength);
-    getter_field!(number_of_range_measurements, u8);
-    getter_field!(number_of_aoa_azimuth_measurements, u8);
-    getter_field!(number_of_aoa_elevation_measurements, u8);
-
-    /// validate if the params are valid.
-    fn is_valid(&self) -> Option<()> {
-        if self.device_type == DeviceType::Controlee {
-            if self.ranging_round_control.ranging_result_report_message {
-                warn!("The RRRM bit is ignored by a controlee");
-            }
-            if self.ranging_round_control.measurement_report_message {
-                warn!("The MRM bit is ignored by a controlee");
-            }
-            if self.hopping_mode != HoppingMode::Disable {
-                warn!("hopping_mode is ignored by a controlee");
-            }
-            if self.block_stride_length != 0 {
-                warn!("block_stride_length is ignored by a controlee");
-            }
-        }
-        if self.ranging_time_struct != RangingTimeStruct::BlockBasedScheduling
-            && self.block_stride_length != 0
-        {
-            warn!(
-                "block_stride_length is ignored when ranging_time_struct not BlockBasedScheduling"
-            );
-        }
-        if self.prf_mode != PrfMode::Bprf && self.bprf_phr_data_rate != BprfPhrDataRate::Rate850k {
-            warn!("BPRF_PHR_DATA_RATE is ignored when prf_mode not BPRF");
-        }
-
-        validate(
-            (1..=8).contains(&self.dst_mac_address.len()),
-            "The length of dst_mac_address should be between 1 to 8",
-        )?;
-        validate(
-            (0..=15).contains(&self.key_rotation_rate),
-            "key_rotation_rate should be between 0 to 15",
-        )?;
-        validate(
-            (1..=100).contains(&self.session_priority),
-            "session_priority should be between 1 to 100",
-        )?;
-        validate(
-            (0..=10000).contains(&self.uwb_initiation_time_ms),
-            "uwb_initiation_time_ms should be between 0 to 10000",
-        )?;
-        validate(
-            (1..=10).contains(&self.in_band_termination_attempt_count),
-            "in_band_termination_attempt_count should be between 1 to 10",
-        )?;
-
-        match self.mac_address_mode {
-            MacAddressMode::MacAddress2Bytes | MacAddressMode::MacAddress8Bytes2BytesHeader => {
-                validate(
-                    matches!(self.device_mac_address, UwbAddress::Short(_)),
-                    "device_mac_address should be short address",
-                )?;
-                validate(
-                    self.dst_mac_address.iter().all(|addr| matches!(addr, UwbAddress::Short(_))),
-                    "dst_mac_address should be short address",
-                )?;
-            }
-            MacAddressMode::MacAddress8Bytes => {
-                validate(
-                    matches!(self.device_mac_address, UwbAddress::Extended(_)),
-                    "device_mac_address should be extended address",
-                )?;
-                validate(
-                    self.dst_mac_address.iter().all(|addr| matches!(addr, UwbAddress::Extended(_))),
-                    "dst_mac_address should be extended address",
-                )?;
-            }
-        }
-
-        match self.prf_mode {
-            PrfMode::Bprf => {
-                validate(
-                    (9..=12).contains(&self.preamble_code_index),
-                    "preamble_code_index should be between 9 to 12 when BPRF",
-                )?;
-                validate([0, 2].contains(&self.sfd_id), "sfd_id should be 0 or 2 when BPRF")?;
-                validate(
-                    self.preamble_duration == PreambleDuration::T64Symbols,
-                    "preamble_duration should be 64 symbols when BPRF",
-                )?;
-            }
-            _ => {
-                validate(
-                    (25..=32).contains(&self.preamble_code_index),
-                    "preamble_code_index should be between 25 to 32 when HPRF",
-                )?;
-                validate(
-                    (1..=4).contains(&self.sfd_id),
-                    "sfd_id should be between 1 to 4 when HPRF",
-                )?;
-            }
-        }
-
-        match self.rframe_config {
-            RframeConfig::SP0 => {
-                validate(
-                    self.number_of_sts_segments == 0,
-                    "number_of_sts_segments should be 0 when SP0",
-                )?;
-            }
-            RframeConfig::SP1 | RframeConfig::SP3 => match self.prf_mode {
-                PrfMode::Bprf => {
-                    validate(
-                        self.number_of_sts_segments == 1,
-                        "number_of_sts_segments should be 1 when SP1/SP3 and BPRF",
-                    )?;
-                }
-                _ => {
-                    validate(
-                        [1, 2, 3, 4].contains(&self.number_of_sts_segments),
-                        "number_of_sts_segments should be between 1 to 4 when SP1/SP3 and HPRF",
-                    )?;
-                }
-            },
-        }
-
-        match self.aoa_result_request {
-            AoaResultRequest::ReqAoaResultsInterleaved => {
-                validate(
-                    self.is_any_number_of_measurement_set(),
-                    "At least one of the ratio params should be set for interleaving mode",
-                );
-            }
-            _ => {
-                validate(
-                    !self.is_any_number_of_measurement_set(),
-                    "All of the ratio params should not be set for non-interleaving mode",
-                );
-            }
-        }
-
-        Some(())
-    }
-
-    fn is_any_number_of_measurement_set(&self) -> bool {
-        self.number_of_range_measurements != DEFAULT_NUMBER_OF_RANGE_MEASUREMENTS
-            || self.number_of_aoa_azimuth_measurements != DEFAULT_NUMBER_OF_AOA_AZIMUTH_MEASUREMENTS
-            || self.number_of_aoa_elevation_measurements
-                != DEFAULT_NUMBER_OF_AOA_ELEVATION_MEASUREMENTS
-    }
-
-    /// Determine if the |config_map| is updatable in the state |session_state|.
-    pub fn is_config_updatable(config_map: &AppConfigTlvMap, session_state: SessionState) -> bool {
-        match session_state {
-            SessionState::SessionStateActive => {
-                let avalible_list = HashSet::from([
-                    AppConfigTlvType::RangingDuration,
-                    AppConfigTlvType::RngDataNtf,
-                    AppConfigTlvType::RngDataNtfProximityNear,
-                    AppConfigTlvType::RngDataNtfProximityFar,
-                    AppConfigTlvType::BlockStrideLength,
-                ]);
-                config_map.keys().all(|key| avalible_list.contains(key))
-            }
-            SessionState::SessionStateIdle => true,
-            _ => false,
-        }
-    }
-
-    /// Generate the AppConfigTlv HashMap from the FiraAppConfigParams instance.
-    pub fn generate_config_map(&self) -> AppConfigTlvMap {
-        debug_assert!(self.is_valid().is_some());
-
-        HashMap::from([
-            (AppConfigTlvType::DeviceType, u8_to_bytes(self.device_type as u8)),
-            (AppConfigTlvType::RangingRoundUsage, u8_to_bytes(self.ranging_round_usage as u8)),
-            (AppConfigTlvType::StsConfig, u8_to_bytes(self.sts_config as u8)),
-            (AppConfigTlvType::MultiNodeMode, u8_to_bytes(self.multi_node_mode as u8)),
-            (AppConfigTlvType::ChannelNumber, u8_to_bytes(self.channel_number as u8)),
-            (AppConfigTlvType::NoOfControlee, u8_to_bytes(self.dst_mac_address.len() as u8)),
-            (AppConfigTlvType::DeviceMacAddress, self.device_mac_address.clone().into()),
-            (AppConfigTlvType::DstMacAddress, addresses_to_bytes(self.dst_mac_address.clone())),
-            (AppConfigTlvType::SlotDuration, u16_to_bytes(self.slot_duration_rstu)),
-            (AppConfigTlvType::RangingDuration, u32_to_bytes(self.ranging_duration_ms)),
-            (AppConfigTlvType::MacFcsType, u8_to_bytes(self.mac_fcs_type as u8)),
-            (
-                AppConfigTlvType::RangingRoundControl,
-                u8_to_bytes(self.ranging_round_control.as_u8()),
-            ),
-            (AppConfigTlvType::AoaResultReq, u8_to_bytes(self.aoa_result_request as u8)),
-            (AppConfigTlvType::RngDataNtf, u8_to_bytes(self.range_data_ntf_config as u8)),
-            (
-                AppConfigTlvType::RngDataNtfProximityNear,
-                u16_to_bytes(self.range_data_ntf_proximity_near_cm),
-            ),
-            (
-                AppConfigTlvType::RngDataNtfProximityFar,
-                u16_to_bytes(self.range_data_ntf_proximity_far_cm),
-            ),
-            (AppConfigTlvType::DeviceRole, u8_to_bytes(self.device_role as u8)),
-            (AppConfigTlvType::RframeConfig, u8_to_bytes(self.rframe_config as u8)),
-            (AppConfigTlvType::PreambleCodeIndex, u8_to_bytes(self.preamble_code_index)),
-            (AppConfigTlvType::SfdId, u8_to_bytes(self.sfd_id)),
-            (AppConfigTlvType::PsduDataRate, u8_to_bytes(self.psdu_data_rate as u8)),
-            (AppConfigTlvType::PreambleDuration, u8_to_bytes(self.preamble_duration as u8)),
-            (AppConfigTlvType::RangingTimeStruct, u8_to_bytes(self.ranging_time_struct as u8)),
-            (AppConfigTlvType::SlotsPerRr, u8_to_bytes(self.slots_per_rr)),
-            (
-                AppConfigTlvType::TxAdaptivePayloadPower,
-                u8_to_bytes(self.tx_adaptive_payload_power as u8),
-            ),
-            (AppConfigTlvType::ResponderSlotIndex, u8_to_bytes(self.responder_slot_index)),
-            (AppConfigTlvType::PrfMode, u8_to_bytes(self.prf_mode as u8)),
-            (AppConfigTlvType::ScheduledMode, u8_to_bytes(self.scheduled_mode as u8)),
-            (AppConfigTlvType::KeyRotation, u8_to_bytes(self.key_rotation as u8)),
-            (AppConfigTlvType::KeyRotationRate, u8_to_bytes(self.key_rotation_rate)),
-            (AppConfigTlvType::SessionPriority, u8_to_bytes(self.session_priority)),
-            (AppConfigTlvType::MacAddressMode, u8_to_bytes(self.mac_address_mode as u8)),
-            (AppConfigTlvType::VendorId, self.vendor_id.to_vec()),
-            (AppConfigTlvType::StaticStsIv, self.static_sts_iv.to_vec()),
-            (AppConfigTlvType::NumberOfStsSegments, u8_to_bytes(self.number_of_sts_segments)),
-            (AppConfigTlvType::MaxRrRetry, u16_to_bytes(self.max_rr_retry)),
-            (AppConfigTlvType::UwbInitiationTime, u32_to_bytes(self.uwb_initiation_time_ms)),
-            (AppConfigTlvType::HoppingMode, u8_to_bytes(self.hopping_mode as u8)),
-            (AppConfigTlvType::BlockStrideLength, u8_to_bytes(self.block_stride_length)),
-            (AppConfigTlvType::ResultReportConfig, u8_to_bytes(self.result_report_config.as_u8())),
-            (
-                AppConfigTlvType::InBandTerminationAttemptCount,
-                u8_to_bytes(self.in_band_termination_attempt_count),
-            ),
-            (AppConfigTlvType::SubSessionId, u32_to_bytes(self.sub_session_id)),
-            (AppConfigTlvType::BprfPhrDataRate, u8_to_bytes(self.bprf_phr_data_rate as u8)),
-            (
-                AppConfigTlvType::MaxNumberOfMeasurements,
-                u16_to_bytes(self.max_number_of_measurements),
-            ),
-            (AppConfigTlvType::StsLength, u8_to_bytes(self.sts_length as u8)),
-            (
-                AppConfigTlvType::NbOfRangeMeasurements,
-                u8_to_bytes(self.number_of_range_measurements),
-            ),
-            (
-                AppConfigTlvType::NbOfAzimuthMeasurements,
-                u8_to_bytes(self.number_of_aoa_azimuth_measurements),
-            ),
-            (
-                AppConfigTlvType::NbOfElevationMeasurements,
-                u8_to_bytes(self.number_of_aoa_elevation_measurements),
-            ),
-        ])
-    }
-}
-
-/// The builder pattern for the FiraAppConfigParams.
-pub struct FiraAppConfigParamsBuilder {
-    device_type: Option<DeviceType>,
-    ranging_round_usage: RangingRoundUsage,
-    sts_config: StsConfig,
-    multi_node_mode: Option<MultiNodeMode>,
-    channel_number: UwbChannel,
-    device_mac_address: Option<UwbAddress>,
-    dst_mac_address: Vec<UwbAddress>,
-    slot_duration_rstu: u16,
-    ranging_duration_ms: u32,
-    mac_fcs_type: MacFcsType,
-    ranging_round_control: RangingRoundControl,
-    aoa_result_request: AoaResultRequest,
-    range_data_ntf_config: RangeDataNtfConfig,
-    range_data_ntf_proximity_near_cm: u16,
-    range_data_ntf_proximity_far_cm: u16,
-    device_role: Option<DeviceRole>,
-    rframe_config: RframeConfig,
-    preamble_code_index: u8,
-    sfd_id: u8,
-    psdu_data_rate: PsduDataRate,
-    preamble_duration: PreambleDuration,
-    ranging_time_struct: RangingTimeStruct,
-    slots_per_rr: u8,
-    tx_adaptive_payload_power: TxAdaptivePayloadPower,
-    responder_slot_index: u8,
-    prf_mode: PrfMode,
-    scheduled_mode: ScheduledMode,
-    key_rotation: KeyRotation,
-    key_rotation_rate: u8,
-    session_priority: u8,
-    mac_address_mode: MacAddressMode,
-    vendor_id: Option<[u8; 2]>,
-    static_sts_iv: Option<[u8; 6]>,
-    number_of_sts_segments: u8,
-    max_rr_retry: u16,
-    uwb_initiation_time_ms: u32,
-    hopping_mode: HoppingMode,
-    block_stride_length: u8,
-    result_report_config: ResultReportConfig,
-    in_band_termination_attempt_count: u8,
-    sub_session_id: u32,
-    bprf_phr_data_rate: BprfPhrDataRate,
-    max_number_of_measurements: u16,
-    sts_length: StsLength,
-    number_of_range_measurements: u8,
-    number_of_aoa_azimuth_measurements: u8,
-    number_of_aoa_elevation_measurements: u8,
-}
-
-#[allow(clippy::new_without_default)]
-#[allow(missing_docs)]
-impl FiraAppConfigParamsBuilder {
-    /// Fill the default value of each field if exists, otherwise put None.
-    pub fn new() -> Self {
-        Self {
-            device_type: None,
-            ranging_round_usage: DEFAULT_RANGING_ROUND_USAGE,
-            sts_config: DEFAULT_STS_CONFIG,
-            multi_node_mode: None,
-            channel_number: DEFAULT_CHANNEL_NUMBER,
-            device_mac_address: None,
-            dst_mac_address: vec![],
-            slot_duration_rstu: DEFAULT_SLOT_DURATION_RSTU,
-            ranging_duration_ms: DEFAULT_RANGING_DURATION_MS,
-            mac_fcs_type: DEFAULT_MAC_FCS_TYPE,
-            ranging_round_control: DEFAULT_RANGING_ROUND_CONTROL,
-            aoa_result_request: DEFAULT_AOA_RESULT_REQUEST,
-            range_data_ntf_config: DEFAULT_RANGE_DATA_NTF_CONFIG,
-            range_data_ntf_proximity_near_cm: DEFAULT_RANGE_DATA_NTF_PROXIMITY_NEAR_CM,
-            range_data_ntf_proximity_far_cm: DEFAULT_RANGE_DATA_NTF_PROXIMITY_FAR_CM,
-            device_role: None,
-            rframe_config: DEFAULT_RFRAME_CONFIG,
-            preamble_code_index: DEFAULT_PREAMBLE_CODE_INDEX,
-            sfd_id: DEFAULT_SFD_ID,
-            psdu_data_rate: DEFAULT_PSDU_DATA_RATE,
-            preamble_duration: DEFAULT_PREAMBLE_DURATION,
-            ranging_time_struct: DEFAULT_RANGING_TIME_STRUCT,
-            slots_per_rr: DEFAULT_SLOTS_PER_RR,
-            tx_adaptive_payload_power: DEFAULT_TX_ADAPTIVE_PAYLOAD_POWER,
-            responder_slot_index: DEFAULT_RESPONDER_SLOT_INDEX,
-            prf_mode: DEFAULT_PRF_MODE,
-            scheduled_mode: DEFAULT_SCHEDULED_MODE,
-            key_rotation: DEFAULT_KEY_ROTATION,
-            key_rotation_rate: DEFAULT_KEY_ROTATION_RATE,
-            session_priority: DEFAULT_SESSION_PRIORITY,
-            mac_address_mode: DEFAULT_MAC_ADDRESS_MODE,
-            vendor_id: None,
-            static_sts_iv: None,
-            number_of_sts_segments: DEFAULT_NUMBER_OF_STS_SEGMENTS,
-            max_rr_retry: DEFAULT_MAX_RR_RETRY,
-            uwb_initiation_time_ms: DEFAULT_UWB_INITIATION_TIME_MS,
-            hopping_mode: DEFAULT_HOPPING_MODE,
-            block_stride_length: DEFAULT_BLOCK_STRIDE_LENGTH,
-            result_report_config: DEFAULT_RESULT_REPORT_CONFIG,
-            in_band_termination_attempt_count: DEFAULT_IN_BAND_TERMINATION_ATTEMPT_COUNT,
-            sub_session_id: DEFAULT_SUB_SESSION_ID,
-            bprf_phr_data_rate: DEFAULT_BPRF_PHR_DATA_RATE,
-            max_number_of_measurements: DEFAULT_MAX_NUMBER_OF_MEASUREMENTS,
-            sts_length: DEFAULT_STS_LENGTH,
-            number_of_range_measurements: DEFAULT_NUMBER_OF_RANGE_MEASUREMENTS,
-            number_of_aoa_azimuth_measurements: DEFAULT_NUMBER_OF_AOA_AZIMUTH_MEASUREMENTS,
-            number_of_aoa_elevation_measurements: DEFAULT_NUMBER_OF_AOA_ELEVATION_MEASUREMENTS,
-        }
-    }
-
-    pub fn from_params(params: &AppConfigParams) -> Option<Self> {
-        match params {
-            AppConfigParams::Fira(params) => Some(Self {
-                device_type: Some(params.device_type),
-                ranging_round_usage: params.ranging_round_usage,
-                sts_config: params.sts_config,
-                multi_node_mode: Some(params.multi_node_mode),
-                channel_number: params.channel_number,
-                device_mac_address: Some(params.device_mac_address.clone()),
-                dst_mac_address: params.dst_mac_address.clone(),
-                slot_duration_rstu: params.slot_duration_rstu,
-                ranging_duration_ms: params.ranging_duration_ms,
-                mac_fcs_type: params.mac_fcs_type,
-                ranging_round_control: params.ranging_round_control.clone(),
-                aoa_result_request: params.aoa_result_request,
-                range_data_ntf_config: params.range_data_ntf_config,
-                range_data_ntf_proximity_near_cm: params.range_data_ntf_proximity_near_cm,
-                range_data_ntf_proximity_far_cm: params.range_data_ntf_proximity_far_cm,
-                device_role: Some(params.device_role),
-                rframe_config: params.rframe_config,
-                preamble_code_index: params.preamble_code_index,
-                sfd_id: params.sfd_id,
-                psdu_data_rate: params.psdu_data_rate,
-                preamble_duration: params.preamble_duration,
-                ranging_time_struct: params.ranging_time_struct,
-                slots_per_rr: params.slots_per_rr,
-                tx_adaptive_payload_power: params.tx_adaptive_payload_power,
-                responder_slot_index: params.responder_slot_index,
-                prf_mode: params.prf_mode,
-                scheduled_mode: params.scheduled_mode,
-                key_rotation: params.key_rotation,
-                key_rotation_rate: params.key_rotation_rate,
-                session_priority: params.session_priority,
-                mac_address_mode: params.mac_address_mode,
-                vendor_id: Some(params.vendor_id),
-                static_sts_iv: Some(params.static_sts_iv),
-                number_of_sts_segments: params.number_of_sts_segments,
-                max_rr_retry: params.max_rr_retry,
-                uwb_initiation_time_ms: params.uwb_initiation_time_ms,
-                hopping_mode: params.hopping_mode,
-                block_stride_length: params.block_stride_length,
-                result_report_config: params.result_report_config.clone(),
-                in_band_termination_attempt_count: params.in_band_termination_attempt_count,
-                sub_session_id: params.sub_session_id,
-                bprf_phr_data_rate: params.bprf_phr_data_rate,
-                max_number_of_measurements: params.max_number_of_measurements,
-                sts_length: params.sts_length,
-                number_of_range_measurements: params.number_of_range_measurements,
-                number_of_aoa_azimuth_measurements: params.number_of_aoa_azimuth_measurements,
-                number_of_aoa_elevation_measurements: params.number_of_aoa_elevation_measurements,
-            }),
-            _ => None,
-        }
-    }
-
-    pub fn build(&self) -> Option<AppConfigParams> {
-        let params = FiraAppConfigParams {
-            device_type: self.device_type?,
-            ranging_round_usage: self.ranging_round_usage,
-            sts_config: self.sts_config,
-            multi_node_mode: self.multi_node_mode?,
-            channel_number: self.channel_number,
-            device_mac_address: self.device_mac_address.clone()?,
-            dst_mac_address: self.dst_mac_address.clone(),
-            slot_duration_rstu: self.slot_duration_rstu,
-            ranging_duration_ms: self.ranging_duration_ms,
-            mac_fcs_type: self.mac_fcs_type,
-            ranging_round_control: self.ranging_round_control.clone(),
-            aoa_result_request: self.aoa_result_request,
-            range_data_ntf_config: self.range_data_ntf_config,
-            range_data_ntf_proximity_near_cm: self.range_data_ntf_proximity_near_cm,
-            range_data_ntf_proximity_far_cm: self.range_data_ntf_proximity_far_cm,
-            device_role: self.device_role?,
-            rframe_config: self.rframe_config,
-            preamble_code_index: self.preamble_code_index,
-            sfd_id: self.sfd_id,
-            psdu_data_rate: self.psdu_data_rate,
-            preamble_duration: self.preamble_duration,
-            ranging_time_struct: self.ranging_time_struct,
-            slots_per_rr: self.slots_per_rr,
-            tx_adaptive_payload_power: self.tx_adaptive_payload_power,
-            responder_slot_index: self.responder_slot_index,
-            prf_mode: self.prf_mode,
-            scheduled_mode: self.scheduled_mode,
-            key_rotation: self.key_rotation,
-            key_rotation_rate: self.key_rotation_rate,
-            session_priority: self.session_priority,
-            mac_address_mode: self.mac_address_mode,
-            vendor_id: self.vendor_id?,
-            static_sts_iv: self.static_sts_iv?,
-            number_of_sts_segments: self.number_of_sts_segments,
-            max_rr_retry: self.max_rr_retry,
-            uwb_initiation_time_ms: self.uwb_initiation_time_ms,
-            hopping_mode: self.hopping_mode,
-            block_stride_length: self.block_stride_length,
-            result_report_config: self.result_report_config.clone(),
-            in_band_termination_attempt_count: self.in_band_termination_attempt_count,
-            sub_session_id: self.sub_session_id,
-            bprf_phr_data_rate: self.bprf_phr_data_rate,
-            max_number_of_measurements: self.max_number_of_measurements,
-            sts_length: self.sts_length,
-            number_of_range_measurements: self.number_of_range_measurements,
-            number_of_aoa_azimuth_measurements: self.number_of_aoa_azimuth_measurements,
-            number_of_aoa_elevation_measurements: self.number_of_aoa_elevation_measurements,
-        };
-
-        params.is_valid()?;
-        Some(AppConfigParams::Fira(params))
-    }
-
-    // Generate the setter methods for all the fields.
-    builder_field!(device_type, DeviceType, Some);
-    builder_field!(ranging_round_usage, RangingRoundUsage);
-    builder_field!(sts_config, StsConfig);
-    builder_field!(multi_node_mode, MultiNodeMode, Some);
-    builder_field!(channel_number, UwbChannel);
-    builder_field!(device_mac_address, UwbAddress, Some);
-    builder_field!(dst_mac_address, Vec<UwbAddress>);
-    builder_field!(slot_duration_rstu, u16);
-    builder_field!(ranging_duration_ms, u32);
-    builder_field!(mac_fcs_type, MacFcsType);
-    builder_field!(ranging_round_control, RangingRoundControl);
-    builder_field!(aoa_result_request, AoaResultRequest);
-    builder_field!(range_data_ntf_config, RangeDataNtfConfig);
-    builder_field!(range_data_ntf_proximity_near_cm, u16);
-    builder_field!(range_data_ntf_proximity_far_cm, u16);
-    builder_field!(device_role, DeviceRole, Some);
-    builder_field!(rframe_config, RframeConfig);
-    builder_field!(preamble_code_index, u8);
-    builder_field!(sfd_id, u8);
-    builder_field!(psdu_data_rate, PsduDataRate);
-    builder_field!(preamble_duration, PreambleDuration);
-    builder_field!(ranging_time_struct, RangingTimeStruct);
-    builder_field!(slots_per_rr, u8);
-    builder_field!(tx_adaptive_payload_power, TxAdaptivePayloadPower);
-    builder_field!(responder_slot_index, u8);
-    builder_field!(prf_mode, PrfMode);
-    builder_field!(scheduled_mode, ScheduledMode);
-    builder_field!(key_rotation, KeyRotation);
-    builder_field!(key_rotation_rate, u8);
-    builder_field!(session_priority, u8);
-    builder_field!(mac_address_mode, MacAddressMode);
-    builder_field!(vendor_id, [u8; 2], Some);
-    builder_field!(static_sts_iv, [u8; 6], Some);
-    builder_field!(number_of_sts_segments, u8);
-    builder_field!(max_rr_retry, u16);
-    builder_field!(uwb_initiation_time_ms, u32);
-    builder_field!(hopping_mode, HoppingMode);
-    builder_field!(block_stride_length, u8);
-    builder_field!(result_report_config, ResultReportConfig);
-    builder_field!(in_band_termination_attempt_count, u8);
-    builder_field!(sub_session_id, u32);
-    builder_field!(bprf_phr_data_rate, BprfPhrDataRate);
-    builder_field!(max_number_of_measurements, u16);
-    builder_field!(sts_length, StsLength);
-    builder_field!(number_of_range_measurements, u8);
-    builder_field!(number_of_aoa_azimuth_measurements, u8);
-    builder_field!(number_of_aoa_elevation_measurements, u8);
-}
-
-/// The device type.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum DeviceType {
-    /// Controlee
-    Controlee = 0,
-    /// Controller
-    Controller = 1,
-}
-
-/// The mode of ranging round usage.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum RangingRoundUsage {
-    /// SS-TWR with Deferred Mode
-    SsTwr = 1,
-    /// DS-TWR with Deferred Mode (default)
-    DsTwr = 2,
-    /// SS-TWR with Non-deferred Mode
-    SsTwrNon = 3,
-    /// DS-TWR with Non-deferred Mode
-    DsTwrNon = 4,
-}
-
-/// This parameter indicates how the system shall generate the STS.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum StsConfig {
-    /// Static STS (default)
-    Static = 0,
-    /// Dynamic STS
-    Dynamic = 1,
-    /// Dynamic STS for Responder specific Sub-session Key
-    DynamicForControleeIndividualKey = 2,
-}
-
-/// The mode of multi node.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum MultiNodeMode {
-    /// Single device to Single device (Unicast)
-    Unicast = 0,
-    /// One to Many
-    OneToMany = 1,
-    /// Many to Many
-    ManyToMany = 2,
-}
-
-/// The UWB channel number. (default = 9)
-#[allow(missing_docs)]
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum UwbChannel {
-    Channel5 = 5,
-    Channel6 = 6,
-    Channel8 = 8,
-    Channel9 = 9,
-    Channel10 = 10,
-    Channel12 = 12,
-    Channel13 = 13,
-    Channel14 = 14,
-}
-
-/// The UWB address.
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub enum UwbAddress {
-    /// The short MAC address (2 bytes)
-    Short([u8; 2]),
-    /// The extended MAC address (8 bytes)
-    Extended([u8; 8]),
-}
-
-impl From<UwbAddress> for Vec<u8> {
-    fn from(item: UwbAddress) -> Self {
-        match item {
-            UwbAddress::Short(addr) => addr.to_vec(),
-            UwbAddress::Extended(addr) => addr.to_vec(),
-        }
-    }
-}
-
-impl TryFrom<Vec<u8>> for UwbAddress {
-    type Error = &'static str;
-    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
-        match value.len() {
-            2 => Ok(UwbAddress::Short(value.try_into().unwrap())),
-            8 => Ok(UwbAddress::Extended(value.try_into().unwrap())),
-            _ => Err("Invalid address length"),
-        }
-    }
-}
-
-fn addresses_to_bytes(addresses: Vec<UwbAddress>) -> Vec<u8> {
-    addresses.into_iter().flat_map(Into::<Vec<u8>>::into).collect()
-}
-
-/// CRC type in MAC footer.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum MacFcsType {
-    /// CRC 16 (default)
-    Crc16 = 0,
-    /// CRC 32
-    Crc32 = 1,
-}
-
-/// This parameter is used to tell the UWBS which messages will be included in a Ranging Round.
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct RangingRoundControl {
-    /// Ranging Result Report Message (RRRM)
-    ///
-    /// If set to true (default), a Controller shall schedule an RRRM in the Ranging Device
-    /// Management List (RDML).
-    /// If set to false, a Controller shall not schedule an RRRM in the RDML.
-    /// This field shall be ignored by a Controlee; Controlees shall follow the message sequence
-    /// provided in the RDML.
-    pub ranging_result_report_message: bool,
-    /// Control Message (CM)
-    ///
-    /// If set to true (default), a Controller shall send a separate CM and a Controlee shall expect
-    /// a separate CM.
-    /// If set to false, a Controller shall not send a separate CM and a Controlee shall not expect
-    /// a separate CM.
-    pub control_message: bool,
-    /// Measurement Report Message (MRM)
-    ///
-    /// If set to false (default), the controller shall schedule the MRM to be sent from the
-    /// initiator to the Responder(s) in the RDML.
-    /// If set to true, the controller shall schedule the MRM to be sent from the responder(s) to
-    /// the initiator in the RDML.
-    /// This field shall be ignored by a controlee. The controlees shall follow the message sequence
-    /// provided in the RDML
-    pub measurement_report_message: bool,
-}
-
-impl RangingRoundControl {
-    const RANGING_RESULT_REPORT_MESSAGE_BIT_OFFSET: u8 = 0;
-    const CONTROL_MESSAGE_BIT_OFFSET: u8 = 1;
-    const MEASUREMENT_REPORT_MESSAGE_BIT_OFFSET: u8 = 7;
-
-    fn as_u8(&self) -> u8 {
-        let mut value = 0_u8;
-        if self.ranging_result_report_message {
-            value |= 1 << Self::RANGING_RESULT_REPORT_MESSAGE_BIT_OFFSET;
-        }
-        if self.control_message {
-            value |= 1 << Self::CONTROL_MESSAGE_BIT_OFFSET;
-        }
-        if self.measurement_report_message {
-            value |= 1 << Self::MEASUREMENT_REPORT_MESSAGE_BIT_OFFSET;
-        }
-        value
-    }
-}
-
-/// This parameter is used to configure AOA results in the range data notification.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum AoaResultRequest {
-    /// Disable AOA
-    NoAoaReport = 0,
-    /// Enable AOA (default)
-    ReqAoaResults = 1,
-    /// Enable only AOA Azimuth
-    ReqAoaResultsAzimuthOnly = 2,
-    /// Enable only AOA Elevation
-    ReqAoaResultsElevationOnly = 3,
-    /// Enable AOA interleaved
-    ReqAoaResultsInterleaved = 0xF0,
-}
-
-/// This config is used to enable/disable the range data notification.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum RangeDataNtfConfig {
-    /// Disable range data notification
-    Disable = 0,
-    /// Enable range data notification (default)
-    Enable = 1,
-    /// Enable range data notification while in proximity range
-    EnableProximity = 2,
-}
-
-/// The device role.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum DeviceRole {
-    /// Responder of the session
-    Responder = 0,
-    /// Initiator of the session
-    Initiator = 1,
-}
-
-/// Rframe config.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum RframeConfig {
-    /// SP0
-    SP0 = 0,
-    /// SP1
-    SP1 = 1,
-    /// SP3 (default)
-    SP3 = 3,
-}
-
-/// This value configures the data rate.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum PsduDataRate {
-    /// 6.81 Mbps (default)
-    Rate6m81 = 0,
-    /// 7.80 Mbps
-    Rate7m80 = 1,
-    /// 27.2 Mbps
-    Rate27m2 = 2,
-    /// 31.2 Mbps
-    Rate31m2 = 3,
-    /// 850Kbps
-    Rate850k = 4,
-}
-
-/// Preamble duration is same as Preamble Symbol Repetitions (PSR).
-///
-/// Two configurations are possible. BPRF uses only 64 symbols. HPRF can use both.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum PreambleDuration {
-    /// 32 symbols
-    T32Symbols = 0,
-    /// 64 symbols (default)
-    T64Symbols = 1,
-}
-
-/// The type of ranging time scheduling.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum RangingTimeStruct {
-    /// Interval Based Scheduling
-    IntervalBasedScheduling = 0,
-    /// Block Based Scheduling (default)
-    BlockBasedScheduling = 1,
-}
-
-/// This configuration is used to enable/disable adaptive payload power for TX.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum TxAdaptivePayloadPower {
-    /// Disable (default)
-    Disable = 0,
-    /// Enable
-    Enable = 1,
-}
-
-/// This parameter is used to configure the mean PRF.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum PrfMode {
-    /// 62.4 MHz PRF. BPRF mode (default)
-    Bprf = 0,
-    /// 124.8 MHz PRF. HPRF mode
-    HprfWith124_8MHz = 1,
-    /// 249.6 MHz PRF. HPRF mode with data rate 27.2 and 31.2 Mbps
-    HprfWith249_6MHz = 2,
-}
-
-/// This parameter is used to set the Multinode Ranging Type.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum ScheduledMode {
-    /// Time scheduled ranging (default)
-    TimeScheduledRanging = 1,
-}
-
-/// This configuration is used to enable/disable the key rotation feature during Dynamic STS
-/// ranging.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum KeyRotation {
-    /// Disable (default)
-    Disable = 0,
-    /// Enable
-    Enable = 1,
-}
-
-/// MAC Addressing mode to be used in UWBS.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum MacAddressMode {
-    /// MAC address is 2 bytes and 2 bytes to be used in MAC header (default)
-    MacAddress2Bytes = 0,
-    /// MAC address is 8 bytes and 2 bytes to be used in MAC header
-    MacAddress8Bytes2BytesHeader = 1,
-    /// MAC address is 8 bytes and 8 bytes to be used in MAC header
-    MacAddress8Bytes = 2,
-}
-
-/// This parameter is used to enable/disable the hopping.
-///
-/// Note: This config is applicable only for controller and ignored in case of controlee.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum HoppingMode {
-    /// Hopping Diable (default)
-    Disable = 0,
-    /// FiRa Hopping Enable
-    FiraHoppingEnable = 1,
-}
-
-/// This config is used to enable/disable the result reports to be included in the RRRM.
-///
-/// The ToF Report, AoA Azimuth Report and AoA Elevation Report parameters from the FiRa UWB MAC are
-/// negotiated OOB.
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct ResultReportConfig {
-    /// TOF report (false: Disable, true: Enable)
-    pub tof: bool,
-    /// AOA azimuth report (false: Disable, true: Enable)
-    pub aoa_azimuth: bool,
-    /// AOA elevation report (false: Disable, true: Enable)
-    pub aoa_elevation: bool,
-    /// AOA FOM report (false: Disable, true: Enable)
-    pub aoa_fom: bool,
-}
-
-impl ResultReportConfig {
-    const TOF_BIT_OFFSET: u8 = 0;
-    const AOA_AZIMUTH_BIT_OFFSET: u8 = 1;
-    const AOA_ELEVATION_BIT_OFFSET: u8 = 2;
-    const AOA_FOM_BIT_OFFSET: u8 = 3;
-
-    fn as_u8(&self) -> u8 {
-        let mut value = 0_u8;
-        if self.tof {
-            value |= 1 << Self::TOF_BIT_OFFSET;
-        }
-        if self.aoa_azimuth {
-            value |= 1 << Self::AOA_AZIMUTH_BIT_OFFSET;
-        }
-        if self.aoa_elevation {
-            value |= 1 << Self::AOA_ELEVATION_BIT_OFFSET;
-        }
-        if self.aoa_fom {
-            value |= 1 << Self::AOA_FOM_BIT_OFFSET;
-        }
-
-        value
-    }
-}
-
-/// The data rate for BPRF mode.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum BprfPhrDataRate {
-    /// 850 kbps (default)
-    Rate850k = 0,
-    /// 6.81 Mbps
-    Rate6m81 = 1,
-}
-
-/// The number of symbols in an STS segment.
-#[repr(u8)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive)]
-pub enum StsLength {
-    /// 32 symbols
-    Length32 = 0,
-    /// 64 symbols (default)
-    Length64 = 1,
-    /// 128 symbols
-    Length128 = 2,
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    use crate::utils::init_test_logging;
-
-    #[test]
-    fn test_ok() {
-        init_test_logging();
-
-        let device_type = DeviceType::Controlee;
-        let ranging_round_usage = RangingRoundUsage::SsTwr;
-        let sts_config = StsConfig::DynamicForControleeIndividualKey;
-        let multi_node_mode = MultiNodeMode::ManyToMany;
-        let channel_number = UwbChannel::Channel10;
-        let device_mac_address = [1, 2, 3, 4, 5, 6, 7, 8];
-        let dst_mac_address1 = [2, 2, 3, 4, 5, 6, 7, 8];
-        let dst_mac_address2 = [3, 2, 3, 4, 5, 6, 7, 8];
-        let slot_duration_rstu = 0x0A28;
-        let ranging_duration_ms = 100;
-        let mac_fcs_type = MacFcsType::Crc32;
-        let ranging_round_control = RangingRoundControl {
-            ranging_result_report_message: false,
-            control_message: true,
-            measurement_report_message: false,
-        };
-        let aoa_result_request = AoaResultRequest::ReqAoaResultsInterleaved;
-        let range_data_ntf_config = RangeDataNtfConfig::EnableProximity;
-        let range_data_ntf_proximity_near_cm = 50;
-        let range_data_ntf_proximity_far_cm = 200;
-        let device_role = DeviceRole::Initiator;
-        let rframe_config = RframeConfig::SP1;
-        let preamble_code_index = 25;
-        let sfd_id = 3;
-        let psdu_data_rate = PsduDataRate::Rate7m80;
-        let preamble_duration = PreambleDuration::T32Symbols;
-        let slots_per_rr = 10;
-        let tx_adaptive_payload_power = TxAdaptivePayloadPower::Enable;
-        let prf_mode = PrfMode::HprfWith124_8MHz;
-        let key_rotation = KeyRotation::Enable;
-        let key_rotation_rate = 15;
-        let session_priority = 100;
-        let mac_address_mode = MacAddressMode::MacAddress8Bytes;
-        let vendor_id = [0xFE, 0xDC];
-        let static_sts_iv = [0xDF, 0xCE, 0xAB, 0x12, 0x34, 0x56];
-        let number_of_sts_segments = 2;
-        let max_rr_retry = 3;
-        let uwb_initiation_time_ms = 100;
-        let result_report_config =
-            ResultReportConfig { tof: true, aoa_azimuth: true, aoa_elevation: true, aoa_fom: true };
-        let in_band_termination_attempt_count = 8;
-        let sub_session_id = 24;
-        let sts_length = StsLength::Length128;
-        let number_of_range_measurements = 1;
-        let number_of_aoa_azimuth_measurements = 2;
-        let number_of_aoa_elevation_measurements = 3;
-
-        let mut builder = FiraAppConfigParamsBuilder::new();
-        builder
-            .device_type(device_type)
-            .ranging_round_usage(ranging_round_usage)
-            .sts_config(sts_config)
-            .multi_node_mode(multi_node_mode)
-            .channel_number(channel_number)
-            .device_mac_address(UwbAddress::Extended(device_mac_address))
-            .dst_mac_address(vec![
-                UwbAddress::Extended(dst_mac_address1),
-                UwbAddress::Extended(dst_mac_address2),
-            ])
-            .slot_duration_rstu(slot_duration_rstu)
-            .ranging_duration_ms(ranging_duration_ms)
-            .mac_fcs_type(mac_fcs_type)
-            .ranging_round_control(ranging_round_control.clone())
-            .aoa_result_request(aoa_result_request)
-            .range_data_ntf_config(range_data_ntf_config)
-            .range_data_ntf_proximity_near_cm(range_data_ntf_proximity_near_cm)
-            .range_data_ntf_proximity_far_cm(range_data_ntf_proximity_far_cm)
-            .device_role(device_role)
-            .rframe_config(rframe_config)
-            .preamble_code_index(preamble_code_index)
-            .sfd_id(sfd_id)
-            .psdu_data_rate(psdu_data_rate)
-            .preamble_duration(preamble_duration)
-            .slots_per_rr(slots_per_rr)
-            .tx_adaptive_payload_power(tx_adaptive_payload_power)
-            .prf_mode(prf_mode)
-            .key_rotation(key_rotation)
-            .key_rotation_rate(key_rotation_rate)
-            .session_priority(session_priority)
-            .mac_address_mode(mac_address_mode)
-            .vendor_id(vendor_id)
-            .static_sts_iv(static_sts_iv)
-            .number_of_sts_segments(number_of_sts_segments)
-            .max_rr_retry(max_rr_retry)
-            .uwb_initiation_time_ms(uwb_initiation_time_ms)
-            .result_report_config(result_report_config.clone())
-            .in_band_termination_attempt_count(in_band_termination_attempt_count)
-            .sub_session_id(sub_session_id)
-            .sts_length(sts_length)
-            .number_of_range_measurements(number_of_range_measurements)
-            .number_of_aoa_azimuth_measurements(number_of_aoa_azimuth_measurements)
-            .number_of_aoa_elevation_measurements(number_of_aoa_elevation_measurements);
-        let params = builder.build().unwrap();
-
-        // Verify the generated TLV.
-        let config_map = params.generate_config_map();
-        let expected_config_map = HashMap::from([
-            (AppConfigTlvType::DeviceType, vec![device_type as u8]),
-            (AppConfigTlvType::RangingRoundUsage, vec![ranging_round_usage as u8]),
-            (AppConfigTlvType::StsConfig, vec![sts_config as u8]),
-            (AppConfigTlvType::MultiNodeMode, vec![multi_node_mode as u8]),
-            (AppConfigTlvType::ChannelNumber, vec![channel_number as u8]),
-            (AppConfigTlvType::NoOfControlee, vec![2]),
-            (AppConfigTlvType::DeviceMacAddress, device_mac_address.to_vec()),
-            (
-                AppConfigTlvType::DstMacAddress,
-                [dst_mac_address1, dst_mac_address2].concat().to_vec(),
-            ),
-            (AppConfigTlvType::SlotDuration, slot_duration_rstu.to_le_bytes().to_vec()),
-            (AppConfigTlvType::RangingDuration, ranging_duration_ms.to_le_bytes().to_vec()),
-            (AppConfigTlvType::MacFcsType, vec![mac_fcs_type as u8]),
-            (AppConfigTlvType::RangingRoundControl, vec![ranging_round_control.as_u8()]),
-            (AppConfigTlvType::AoaResultReq, vec![aoa_result_request as u8]),
-            (AppConfigTlvType::RngDataNtf, vec![range_data_ntf_config as u8]),
-            (
-                AppConfigTlvType::RngDataNtfProximityNear,
-                range_data_ntf_proximity_near_cm.to_le_bytes().to_vec(),
-            ),
-            (
-                AppConfigTlvType::RngDataNtfProximityFar,
-                range_data_ntf_proximity_far_cm.to_le_bytes().to_vec(),
-            ),
-            (AppConfigTlvType::DeviceRole, vec![device_role as u8]),
-            (AppConfigTlvType::RframeConfig, vec![rframe_config as u8]),
-            (AppConfigTlvType::PreambleCodeIndex, vec![preamble_code_index]),
-            (AppConfigTlvType::SfdId, vec![sfd_id]),
-            (AppConfigTlvType::PsduDataRate, vec![psdu_data_rate as u8]),
-            (AppConfigTlvType::PreambleDuration, vec![preamble_duration as u8]),
-            (AppConfigTlvType::RangingTimeStruct, vec![DEFAULT_RANGING_TIME_STRUCT as u8]),
-            (AppConfigTlvType::SlotsPerRr, vec![slots_per_rr]),
-            (AppConfigTlvType::TxAdaptivePayloadPower, vec![tx_adaptive_payload_power as u8]),
-            (AppConfigTlvType::ResponderSlotIndex, vec![DEFAULT_RESPONDER_SLOT_INDEX]),
-            (AppConfigTlvType::PrfMode, vec![prf_mode as u8]),
-            (AppConfigTlvType::ScheduledMode, vec![DEFAULT_SCHEDULED_MODE as u8]),
-            (AppConfigTlvType::KeyRotation, vec![key_rotation as u8]),
-            (AppConfigTlvType::KeyRotationRate, vec![key_rotation_rate]),
-            (AppConfigTlvType::SessionPriority, vec![session_priority]),
-            (AppConfigTlvType::MacAddressMode, vec![mac_address_mode as u8]),
-            (AppConfigTlvType::VendorId, vendor_id.to_vec()),
-            (AppConfigTlvType::StaticStsIv, static_sts_iv.to_vec()),
-            (AppConfigTlvType::NumberOfStsSegments, vec![number_of_sts_segments]),
-            (AppConfigTlvType::MaxRrRetry, max_rr_retry.to_le_bytes().to_vec()),
-            (AppConfigTlvType::UwbInitiationTime, uwb_initiation_time_ms.to_le_bytes().to_vec()),
-            (AppConfigTlvType::HoppingMode, vec![DEFAULT_HOPPING_MODE as u8]),
-            (AppConfigTlvType::BlockStrideLength, vec![DEFAULT_BLOCK_STRIDE_LENGTH]),
-            (AppConfigTlvType::ResultReportConfig, vec![result_report_config.as_u8()]),
-            (
-                AppConfigTlvType::InBandTerminationAttemptCount,
-                vec![in_band_termination_attempt_count],
-            ),
-            (AppConfigTlvType::BprfPhrDataRate, vec![DEFAULT_BPRF_PHR_DATA_RATE as u8]),
-            (
-                AppConfigTlvType::MaxNumberOfMeasurements,
-                DEFAULT_MAX_NUMBER_OF_MEASUREMENTS.to_le_bytes().to_vec(),
-            ),
-            (AppConfigTlvType::StsLength, vec![sts_length as u8]),
-            (AppConfigTlvType::SubSessionId, sub_session_id.to_le_bytes().to_vec()),
-            (AppConfigTlvType::NbOfRangeMeasurements, vec![number_of_range_measurements]),
-            (AppConfigTlvType::NbOfAzimuthMeasurements, vec![number_of_aoa_azimuth_measurements]),
-            (
-                AppConfigTlvType::NbOfElevationMeasurements,
-                vec![number_of_aoa_elevation_measurements],
-            ),
-        ]);
-        assert_eq!(config_map, expected_config_map);
-
-        // Update the value from the original builder.
-        let updated_key_rotation_rate = 10;
-        assert_ne!(key_rotation_rate, updated_key_rotation_rate);
-        let expected_updated_config_map =
-            HashMap::from([(AppConfigTlvType::KeyRotationRate, vec![updated_key_rotation_rate])]);
-
-        let updated_params1 = builder.key_rotation_rate(updated_key_rotation_rate).build().unwrap();
-        let updated_config_map1 = updated_params1
-            .generate_updated_config_map(&params, SessionState::SessionStateIdle)
-            .unwrap();
-        assert_eq!(updated_config_map1, expected_updated_config_map);
-
-        // Update the value from the params.
-        let updated_params2 = FiraAppConfigParamsBuilder::from_params(&params)
-            .unwrap()
-            .key_rotation_rate(updated_key_rotation_rate)
-            .build()
-            .unwrap();
-        let updated_config_map2 = updated_params2
-            .generate_updated_config_map(&params, SessionState::SessionStateIdle)
-            .unwrap();
-        assert_eq!(updated_config_map2, expected_updated_config_map);
-    }
-
-    #[test]
-    fn test_update_config() {
-        let mut builder = FiraAppConfigParamsBuilder::new();
-        builder
-            .device_type(DeviceType::Controller)
-            .multi_node_mode(MultiNodeMode::Unicast)
-            .device_mac_address(UwbAddress::Short([1, 2]))
-            .dst_mac_address(vec![UwbAddress::Short([3, 4])])
-            .device_role(DeviceRole::Initiator)
-            .vendor_id([0xFE, 0xDC])
-            .static_sts_iv([0xDF, 0xCE, 0xAB, 0x12, 0x34, 0x56]);
-        let params = builder.build().unwrap();
-
-        builder.multi_node_mode(MultiNodeMode::OneToMany);
-        let updated_params = builder.build().unwrap();
-        // MultiNodeMode can be updated at idle state.
-        assert!(updated_params
-            .generate_updated_config_map(&params, SessionState::SessionStateIdle)
-            .is_some());
-        // MultiNodeMode cannot be updated at active state.
-        assert!(updated_params
-            .generate_updated_config_map(&params, SessionState::SessionStateActive)
-            .is_none());
-    }
-
-    #[test]
-    fn test_redacted_pii_fields() {
-        let mut builder = FiraAppConfigParamsBuilder::new();
-        builder
-            .device_type(DeviceType::Controller)
-            .multi_node_mode(MultiNodeMode::Unicast)
-            .device_mac_address(UwbAddress::Short([1, 2]))
-            .dst_mac_address(vec![UwbAddress::Short([3, 4])])
-            .device_role(DeviceRole::Initiator)
-            .vendor_id([0xFE, 0xDC])
-            .static_sts_iv([0xDF, 0xCE, 0xAB, 0x12, 0x34, 0x56]);
-        let params = builder.build().unwrap();
-
-        let format_str = format!("{params:?}");
-        assert!(format_str.contains("vendor_id: \"redacted\""));
-        assert!(format_str.contains("static_sts_iv: \"redacted\""));
-    }
-}
diff --git a/src/rust/uwb_core/src/params/uci_packets.rs b/src/rust/uwb_core/src/params/uci_packets.rs
deleted file mode 100644
index 54e7ae2..0000000
--- a/src/rust/uwb_core/src/params/uci_packets.rs
+++ /dev/null
@@ -1,359 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module defines the parameters or responses of the UciManager's methods. Most of them are
-//! re-exported from the uwb_uci_packets crate.
-
-use std::collections::{hash_map::RandomState, HashMap};
-use std::iter::FromIterator;
-
-use num_derive::{FromPrimitive, ToPrimitive};
-
-// Re-export enums and structs from uwb_uci_packets.
-pub use uwb_uci_packets::{
-    AppConfigStatus, AppConfigTlv as RawAppConfigTlv, AppConfigTlvType, BitsPerSample, CapTlv,
-    CapTlvType, Controlee, ControleePhaseList, ControleeStatusV1, ControleeStatusV2, Controlees,
-    ControllerPhaseList, CreditAvailability, DataRcvStatusCode, DataTransferNtfStatusCode,
-    DataTransferPhaseConfigUpdateStatusCode, DeviceConfigId, DeviceConfigStatus, DeviceConfigTlv,
-    DeviceState, ExtendedAddressDlTdoaRangingMeasurement, ExtendedAddressOwrAoaRangingMeasurement,
-    ExtendedAddressTwoWayRangingMeasurement, GroupId, MacAddressIndicator, MessageType,
-    MulticastUpdateStatusCode, PowerStats, RadarConfigStatus, RadarConfigTlv, RadarConfigTlvType,
-    RadarDataType, RangingMeasurementType, ReasonCode, ResetConfig, RfTestConfigStatus,
-    RfTestConfigTlv, RfTestConfigTlvType, SessionState, SessionType,
-    SessionUpdateControllerMulticastListNtfV1Payload,
-    SessionUpdateControllerMulticastListNtfV2Payload,
-    SessionUpdateControllerMulticastListRspV1Payload,
-    SessionUpdateControllerMulticastListRspV2Payload, ShortAddressDlTdoaRangingMeasurement,
-    ShortAddressOwrAoaRangingMeasurement, ShortAddressTwoWayRangingMeasurement, StatusCode,
-    UpdateMulticastListAction,
-};
-pub(crate) use uwb_uci_packets::{UciControlPacket, UciDataPacket, UciDataPacketHal};
-
-use crate::error::Error;
-
-/// The type of the session identifier.
-pub type SessionId = u32;
-/// The type of the sub-session identifier.
-pub type SubSessionId = u32;
-/// The type of the session handle.
-pub type SessionHandle = u32;
-/// Generic type used to represent either a session id or session handle.
-pub type SessionToken = u32;
-
-/// Wrap the original AppConfigTlv type to redact the PII fields when logging.
-#[derive(Clone, PartialEq)]
-pub struct AppConfigTlv {
-    tlv: RawAppConfigTlv,
-}
-
-/// Controlee Status Enum compatible with different Fira version.
-pub enum ControleeStatusList {
-    /// Controlee status defined in Fira 1.x.
-    V1(Vec<ControleeStatusV1>),
-    /// Controlee status defined in Fira 2.0.
-    V2(Vec<ControleeStatusV2>),
-}
-
-/// UCI major version
-#[derive(FromPrimitive, ToPrimitive, PartialEq, Clone, PartialOrd, Ord, Eq)]
-#[repr(u8)]
-pub enum UCIMajorVersion {
-    /// Version 1.x
-    V1 = 1,
-    /// Version 2.0
-    V2 = 2,
-    /// Version 3.0
-    V3 = 3,
-}
-
-impl std::fmt::Debug for AppConfigTlv {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
-        static REDACTED_STR: &str = "redacted";
-
-        let mut ds = f.debug_struct("AppConfigTlv");
-        ds.field("cfg_id", &self.tlv.cfg_id);
-        if self.tlv.cfg_id == AppConfigTlvType::VendorId
-            || self.tlv.cfg_id == AppConfigTlvType::StaticStsIv
-        {
-            ds.field("v", &REDACTED_STR);
-        } else {
-            ds.field("v", &self.tlv.v);
-        }
-        ds.finish()
-    }
-}
-
-impl AppConfigTlv {
-    /// Create a wrapper of uwb_uci_packets::AppConfigTlv.
-    ///
-    /// The argument is the same as the uwb_uci_packets::AppConfigTlv's struct.
-    pub fn new(cfg_id: AppConfigTlvType, v: Vec<u8>) -> Self {
-        Self { tlv: RawAppConfigTlv { cfg_id, v } }
-    }
-
-    /// Consumes the outter wrapper type, returning the wrapped uwb_uci_packets::AppConfigTlv.
-    pub fn into_inner(self) -> RawAppConfigTlv {
-        self.tlv
-    }
-}
-
-impl From<RawAppConfigTlv> for AppConfigTlv {
-    fn from(tlv: RawAppConfigTlv) -> Self {
-        Self { tlv }
-    }
-}
-
-impl std::ops::Deref for AppConfigTlv {
-    type Target = RawAppConfigTlv;
-    fn deref(&self) -> &Self::Target {
-        &self.tlv
-    }
-}
-
-impl std::ops::DerefMut for AppConfigTlv {
-    fn deref_mut(&mut self) -> &mut Self::Target {
-        &mut self.tlv
-    }
-}
-
-/// Compare if two AppConfigTlv array are equal. Convert the array to HashMap before comparing
-/// because the order of TLV elements doesn't matter.
-#[allow(dead_code)]
-pub fn app_config_tlvs_eq(a: &[AppConfigTlv], b: &[AppConfigTlv]) -> bool {
-    app_config_tlvs_to_map(a) == app_config_tlvs_to_map(b)
-}
-
-fn app_config_tlvs_to_map(
-    tlvs: &[AppConfigTlv],
-) -> HashMap<AppConfigTlvType, &Vec<u8>, RandomState> {
-    HashMap::from_iter(tlvs.iter().map(|config| (config.cfg_id, &config.v)))
-}
-
-/// Compare if two DeviceConfigTlv array are equal. Convert the array to HashMap before comparing
-/// because the order of TLV elements doesn't matter.
-#[allow(dead_code)]
-pub fn device_config_tlvs_eq(a: &[DeviceConfigTlv], b: &[DeviceConfigTlv]) -> bool {
-    device_config_tlvs_to_map(a) == device_config_tlvs_to_map(b)
-}
-
-fn device_config_tlvs_to_map(
-    tlvs: &[DeviceConfigTlv],
-) -> HashMap<DeviceConfigId, &Vec<u8>, RandomState> {
-    HashMap::from_iter(tlvs.iter().map(|config| (config.cfg_id, &config.v)))
-}
-
-/// Compare if two RadarConfigTlv array are equal. Convert the array to HashMap before comparing
-/// because the order of TLV elements doesn't matter.
-#[allow(dead_code)]
-pub fn radar_config_tlvs_eq(a: &[RadarConfigTlv], b: &[RadarConfigTlv]) -> bool {
-    radar_config_tlvs_to_map(a) == radar_config_tlvs_to_map(b)
-}
-
-fn radar_config_tlvs_to_map(
-    tlvs: &[RadarConfigTlv],
-) -> HashMap<RadarConfigTlvType, &Vec<u8>, RandomState> {
-    HashMap::from_iter(tlvs.iter().map(|config| (config.cfg_id, &config.v)))
-}
-
-/// Compare if two RfTestConfigTlv array are equal. Convert the array to HashMap before comparing
-/// because the order of TLV elements doesn't matter.
-#[allow(dead_code)]
-pub fn rf_test_config_tlvs_eq(a: &[RfTestConfigTlv], b: &[RfTestConfigTlv]) -> bool {
-    rf_test_config_tlvs_to_map(a) == rf_test_config_tlvs_to_map(b)
-}
-
-fn rf_test_config_tlvs_to_map(
-    tlvs: &[RfTestConfigTlv],
-) -> HashMap<RfTestConfigTlvType, &Vec<u8>, RandomState> {
-    HashMap::from_iter(tlvs.iter().map(|config| (config.cfg_id, &config.v)))
-}
-
-/// The response of the UciManager::core_set_config() method.
-#[derive(Debug, Clone, PartialEq)]
-pub struct CoreSetConfigResponse {
-    /// The status code of the response.
-    pub status: StatusCode,
-    /// The status of each config TLV.
-    pub config_status: Vec<DeviceConfigStatus>,
-}
-
-/// The response of the UciManager::session_set_app_config() method.
-#[derive(Debug, Clone, PartialEq)]
-pub struct SetAppConfigResponse {
-    /// The status code of the response.
-    pub status: StatusCode,
-    /// The status of each config TLV.
-    pub config_status: Vec<AppConfigStatus>,
-}
-
-/// The response of the UciManager::android_set_radar_config() method.
-#[derive(Debug, Clone, PartialEq)]
-pub struct AndroidRadarConfigResponse {
-    /// The status code of the response.
-    pub status: StatusCode,
-    /// The status of each config TLV.
-    pub config_status: Vec<RadarConfigStatus>,
-}
-
-/// The response from UciManager::(session_update_controller_multicast_list() method.
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct SessionUpdateControllerMulticastResponse {
-    /// The status code of the response.
-    pub status: StatusCode,
-    /// Controlee Status
-    pub status_list: Vec<ControleeStatusV2>,
-}
-
-/// The response from UciManager::session_update_dt_tag_ranging_rounds() method.
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct SessionUpdateDtTagRangingRoundsResponse {
-    /// The status code of the response.
-    pub status: StatusCode,
-    /// Indexes of unsuccessful ranging rounds.
-    pub ranging_round_indexes: Vec<u8>,
-}
-
-/// The response of the UciManager::android_set_rf_test_config() method.
-#[derive(Debug, Clone, PartialEq)]
-pub struct RfTestConfigResponse {
-    /// The status code of the response.
-    pub status: StatusCode,
-    /// The status of each config TLV.
-    pub config_status: Vec<RfTestConfigStatus>,
-}
-
-/// The country code struct that contains 2 uppercase ASCII characters.
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct CountryCode([u8; 2]);
-
-impl CountryCode {
-    const UNKNOWN_COUNTRY_CODE: &'static [u8] = "00".as_bytes();
-
-    /// Create a CountryCode instance.
-    pub fn new(code: &[u8; 2]) -> Option<Self> {
-        if code != CountryCode::UNKNOWN_COUNTRY_CODE
-            && !code.iter().all(|x| (*x as char).is_ascii_alphabetic())
-        {
-            None
-        } else {
-            Some(Self((*code).to_ascii_uppercase().try_into().ok()?))
-        }
-    }
-}
-
-impl From<CountryCode> for [u8; 2] {
-    fn from(item: CountryCode) -> [u8; 2] {
-        item.0
-    }
-}
-
-impl TryFrom<String> for CountryCode {
-    type Error = Error;
-    fn try_from(item: String) -> Result<Self, Self::Error> {
-        let code = item.as_bytes().try_into().map_err(|_| Error::BadParameters)?;
-        Self::new(code).ok_or(Error::BadParameters)
-    }
-}
-
-/// The response of the UciManager::core_get_device_info() method.
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct GetDeviceInfoResponse {
-    /// Status
-    pub status: StatusCode,
-    /// The UCI version.
-    pub uci_version: u16,
-    /// The MAC version.
-    pub mac_version: u16,
-    /// The physical version.
-    pub phy_version: u16,
-    /// The UCI test version.
-    pub uci_test_version: u16,
-    /// The vendor spec info.
-    pub vendor_spec_info: Vec<u8>,
-}
-
-/// The raw UCI message for the vendor commands.
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct RawUciMessage {
-    /// The group id of the message.
-    pub gid: u32,
-    /// The opcode of the message.
-    pub oid: u32,
-    /// The payload of the message.
-    pub payload: Vec<u8>,
-}
-
-impl From<UciControlPacket> for RawUciMessage {
-    fn from(packet: UciControlPacket) -> Self {
-        Self {
-            gid: packet.get_group_id().into(),
-            oid: packet.get_opcode() as u32,
-            payload: packet.to_raw_payload(),
-        }
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_redacted_app_config_tlv() {
-        // The value of VendorId and StaticStsIv should be redacted.
-        let tlv = AppConfigTlv::new(AppConfigTlvType::VendorId, vec![12, 34]);
-        let format_str = format!("{tlv:?}");
-        assert!(format_str.contains("v: \"redacted\""));
-
-        let tlv = AppConfigTlv::new(AppConfigTlvType::StaticStsIv, vec![12, 34]);
-        let format_str = format!("{tlv:?}");
-        assert!(format_str.contains("v: \"redacted\""));
-
-        // The value of DeviceType should be printed normally.
-        let tlv = AppConfigTlv::new(AppConfigTlvType::DeviceType, vec![12, 34]);
-        let format_str = format!("{tlv:?}");
-        assert_eq!(format_str, "AppConfigTlv { cfg_id: DeviceType, v: [12, 34] }");
-    }
-
-    #[test]
-    fn test_country_code() {
-        let _country_code_ascii: CountryCode = String::from("US").try_into().unwrap();
-        let _country_code_unknown: CountryCode = String::from("00").try_into().unwrap();
-        let country_code_invalid_1: Result<CountryCode, Error> = String::from("0S").try_into();
-        country_code_invalid_1.unwrap_err();
-        let country_code_invalid_2: Result<CountryCode, Error> = String::from("ÀÈ").try_into();
-        country_code_invalid_2.unwrap_err();
-    }
-
-    #[test]
-    fn test_rf_test_config_tlvs_eq() {
-        let tlv1 = RfTestConfigTlv { cfg_id: RfTestConfigTlvType::NumPackets, v: vec![10, 20] };
-        let tlv2 = RfTestConfigTlv { cfg_id: RfTestConfigTlvType::TStart, v: vec![30, 40] };
-
-        let array1 = vec![tlv1.clone(), tlv2.clone()];
-        let array2 = vec![tlv2.clone(), tlv1.clone()]; // Different order
-
-        // Test that arrays with the same elements in different orders are equal.
-        assert!(rf_test_config_tlvs_eq(&array1, &array2));
-
-        let tlv3 = RfTestConfigTlv {
-            cfg_id: RfTestConfigTlvType::TWin,
-            v: vec![70, 80], // Different value
-        };
-
-        let array3 = vec![tlv1.clone(), tlv3.clone()];
-
-        // Test that arrays with different elements are not equal.
-        assert!(!rf_test_config_tlvs_eq(&array1, &array3));
-    }
-}
diff --git a/src/rust/uwb_core/src/params/utils.rs b/src/rust/uwb_core/src/params/utils.rs
deleted file mode 100644
index 16b882a..0000000
--- a/src/rust/uwb_core/src/params/utils.rs
+++ /dev/null
@@ -1,101 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::convert::TryInto;
-
-use log::error;
-
-pub fn u8_to_bytes(value: u8) -> Vec<u8> {
-    value.to_le_bytes().to_vec()
-}
-
-pub fn u16_to_bytes(value: u16) -> Vec<u8> {
-    value.to_le_bytes().to_vec()
-}
-
-pub fn u32_to_bytes(value: u32) -> Vec<u8> {
-    value.to_le_bytes().to_vec()
-}
-
-#[allow(dead_code)]
-pub fn u64_to_bytes(value: u64) -> Vec<u8> {
-    value.to_le_bytes().to_vec()
-}
-
-pub fn bytes_to_u8(value: Vec<u8>) -> Option<u8> {
-    Some(u8::from_le_bytes(value.try_into().ok()?))
-}
-
-pub fn bytes_to_u16(value: Vec<u8>) -> Option<u16> {
-    Some(u16::from_le_bytes(value.try_into().ok()?))
-}
-
-pub fn bytes_to_u32(value: Vec<u8>) -> Option<u32> {
-    Some(u32::from_le_bytes(value.try_into().ok()?))
-}
-
-pub fn bytes_to_u64(value: Vec<u8>) -> Option<u64> {
-    Some(u64::from_le_bytes(value.try_into().ok()?))
-}
-
-pub fn validate(value: bool, err_msg: &str) -> Option<()> {
-    match value {
-        true => Some(()),
-        false => {
-            error!("{}", err_msg);
-            None
-        }
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_convert_u8_bytes() {
-        let value: u8 = 0x57;
-        let arr = u8_to_bytes(value);
-
-        assert_eq!(arr, vec![0x57]);
-        assert_eq!(bytes_to_u8(arr), Some(value));
-    }
-
-    #[test]
-    fn test_convert_u16_bytes() {
-        let value: u16 = 0x1357;
-        let arr = u16_to_bytes(value);
-
-        assert_eq!(arr, vec![0x57, 0x13]);
-        assert_eq!(bytes_to_u16(arr), Some(value));
-    }
-
-    #[test]
-    fn test_convert_u32_bytes() {
-        let value: u32 = 0x12345678;
-        let arr = u32_to_bytes(value);
-
-        assert_eq!(arr, vec![0x78, 0x56, 0x34, 0x12]);
-        assert_eq!(bytes_to_u32(arr), Some(value));
-    }
-
-    #[test]
-    fn test_convert_u64_bytes() {
-        let value: u64 = 0x0123456789ABCDEF;
-        let arr = u64_to_bytes(value);
-
-        assert_eq!(arr, vec![0xEF, 0xCD, 0xAB, 0x89, 0x67, 0x45, 0x23, 0x01]);
-        assert_eq!(bytes_to_u64(arr), Some(value));
-    }
-}
diff --git a/src/rust/uwb_core/src/proto.rs b/src/rust/uwb_core/src/proto.rs
deleted file mode 100644
index 7cf2740..0000000
--- a/src/rust/uwb_core/src/proto.rs
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Provide the protobuf bindings and the conversion between the elements of uwb_core and protobuf.
-
-// Include the protobuf bindings generated from protoc_rust to "pub mod bindings;".
-include!(concat!(env!("OUT_DIR"), "/proto_bindings.rs"));
-
-pub(crate) mod mappings;
-pub mod utils;
diff --git a/src/rust/uwb_core/src/proto/mappings.rs b/src/rust/uwb_core/src/proto/mappings.rs
deleted file mode 100644
index 095d2d9..0000000
--- a/src/rust/uwb_core/src/proto/mappings.rs
+++ /dev/null
@@ -1,1305 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Provide the conversion between the uwb_core's elements and protobuf bindings.
-
-use std::convert::{TryFrom, TryInto};
-
-use zeroize::Zeroize;
-
-use crate::error::{Error, Result};
-use crate::params::fira_app_config_params::{
-    AoaResultRequest, BprfPhrDataRate, DeviceRole, DeviceType, FiraAppConfigParams,
-    FiraAppConfigParamsBuilder, HoppingMode, KeyRotation, MacAddressMode, MacFcsType,
-    MultiNodeMode, PreambleDuration, PrfMode, PsduDataRate, RangeDataNtfConfig,
-    RangingRoundControl, RangingRoundUsage, RangingTimeStruct, ResultReportConfig, RframeConfig,
-    ScheduledMode, StsConfig, StsLength, TxAdaptivePayloadPower, UwbAddress, UwbChannel,
-};
-use crate::params::uci_packets::{
-    Controlee, DeviceState, ExtendedAddressDlTdoaRangingMeasurement,
-    ExtendedAddressOwrAoaRangingMeasurement, ExtendedAddressTwoWayRangingMeasurement,
-    MacAddressIndicator, PowerStats, RangingMeasurementType, ReasonCode, SessionState, SessionType,
-    ShortAddressDlTdoaRangingMeasurement, ShortAddressOwrAoaRangingMeasurement,
-    ShortAddressTwoWayRangingMeasurement, StatusCode, UpdateMulticastListAction,
-};
-use crate::params::AppConfigParams;
-use crate::proto::bindings::{
-    AoaResultRequest as ProtoAoaResultRequest, BprfPhrDataRate as ProtoBprfPhrDataRate,
-    Controlee as ProtoControlee, DeviceRole as ProtoDeviceRole, DeviceState as ProtoDeviceState,
-    DeviceType as ProtoDeviceType, DlTDoARangingMeasurement as ProtoDlTDoARangingMeasurement,
-    FiraAppConfigParams as ProtoFiraAppConfigParams, HoppingMode as ProtoHoppingMode,
-    KeyRotation as ProtoKeyRotation, MacAddressIndicator as ProtoMacAddressIndicator,
-    MacAddressMode as ProtoMacAddressMode, MacFcsType as ProtoMacFcsType,
-    MultiNodeMode as ProtoMultiNodeMode, OwrAoaRangingMeasurement as ProtoOwrAoaRangingMeasurement,
-    PowerStats as ProtoPowerStats, PreambleDuration as ProtoPreambleDuration,
-    PrfMode as ProtoPrfMode, PsduDataRate as ProtoPsduDataRate,
-    RangeDataNtfConfig as ProtoRangeDataNtfConfig,
-    RangingMeasurementType as ProtoRangingMeasurementType,
-    RangingRoundControl as ProtoRangingRoundControl, RangingRoundUsage as ProtoRangingRoundUsage,
-    RangingTimeStruct as ProtoRangingTimeStruct, ReasonCode as ProtoReasonCode,
-    ResultReportConfig as ProtoResultReportConfig, RframeConfig as ProtoRframeConfig,
-    ScheduledMode as ProtoScheduledMode, SessionRangeData as ProtoSessionRangeData,
-    SessionState as ProtoSessionState, SessionType as ProtoSessionType, Status as ProtoStatus,
-    StatusCode as ProtoStatusCode, StsConfig as ProtoStsConfig, StsLength as ProtoStsLength,
-    TwoWayRangingMeasurement as ProtoTwoWayRangingMeasurement,
-    TxAdaptivePayloadPower as ProtoTxAdaptivePayloadPower, UciLoggerMode as ProtoUciLoggerMode,
-    UpdateMulticastListAction as ProtoUpdateMulticastListAction, UwbChannel as ProtoUwbChannel,
-};
-use crate::uci::notification::{RangingMeasurements, SessionRangeData};
-use crate::uci::uci_logger::UciLoggerMode;
-use protobuf::{EnumOrUnknown, MessageField};
-
-/// Generate the conversion functions between 2 enum types, which field is 1-to-1 mapping.
-///
-/// Example:
-/// ```
-/// enum EnumA {
-///     Value1,
-///     Value2,
-/// }
-/// enum EnumB {
-///     Foo,
-///     Bar,
-/// }
-/// // This macro generates `From<EnumA> for EnumB` and `From<EnumB> for EnumA`.
-/// uwb_core::enum_mapping! {
-///     EnumA => EnumB,
-///     Value1 => Foo,
-///     Value2 => Bar,
-/// }
-/// ```
-#[macro_export]
-macro_rules! enum_mapping {
-    ( $enum_a:ty => $enum_b:ty, $( $field_a:ident => $field_b:ident, )+ ) => {
-        impl From<$enum_a> for $enum_b {
-            fn from(item: $enum_a) -> $enum_b {
-                match item {
-                    $(
-                        <$enum_a>::$field_a => <$enum_b>::$field_b,
-                    )*
-                }
-            }
-        }
-        impl From<$enum_b> for $enum_a {
-            fn from(item: $enum_b) -> $enum_a {
-                match item {
-                    $(
-                        <$enum_b>::$field_b => <$enum_a>::$field_a,
-                    )*
-                }
-            }
-        }
-    };
-}
-
-impl From<ProtoStatusCode> for StatusCode {
-    fn from(item: ProtoStatusCode) -> Self {
-        match item {
-            ProtoStatusCode::UCI_STATUS_OK => StatusCode::UciStatusOk,
-            ProtoStatusCode::UCI_STATUS_REJECTED => StatusCode::UciStatusRejected,
-            ProtoStatusCode::UCI_STATUS_FAILED => StatusCode::UciStatusFailed,
-            ProtoStatusCode::UCI_STATUS_SYNTAX_ERROR => StatusCode::UciStatusSyntaxError,
-            ProtoStatusCode::UCI_STATUS_INVALID_PARAM => StatusCode::UciStatusInvalidParam,
-            ProtoStatusCode::UCI_STATUS_INVALID_RANGE => StatusCode::UciStatusInvalidRange,
-            ProtoStatusCode::UCI_STATUS_INVALID_MSG_SIZE => StatusCode::UciStatusInvalidMsgSize,
-            ProtoStatusCode::UCI_STATUS_UNKNOWN_GID => StatusCode::UciStatusUnknownGid,
-            ProtoStatusCode::UCI_STATUS_UNKNOWN_OID => StatusCode::UciStatusUnknownOid,
-            ProtoStatusCode::UCI_STATUS_READ_ONLY => StatusCode::UciStatusReadOnly,
-            ProtoStatusCode::UCI_STATUS_COMMAND_RETRY => StatusCode::UciStatusCommandRetry,
-            ProtoStatusCode::UCI_STATUS_UNKNOWN => StatusCode::UciStatusUnknown,
-            ProtoStatusCode::UCI_STATUS_SESSION_NOT_EXIST => StatusCode::UciStatusSessionNotExist,
-            ProtoStatusCode::UCI_STATUS_SESSION_DUPLICATE => StatusCode::UciStatusSessionDuplicate,
-            ProtoStatusCode::UCI_STATUS_SESSION_ACTIVE => StatusCode::UciStatusSessionActive,
-            ProtoStatusCode::UCI_STATUS_MAX_SESSIONS_EXCEEDED => {
-                StatusCode::UciStatusMaxSessionsExceeded
-            }
-            ProtoStatusCode::UCI_STATUS_SESSION_NOT_CONFIGURED => {
-                StatusCode::UciStatusSessionNotConfigured
-            }
-            ProtoStatusCode::UCI_STATUS_ACTIVE_SESSIONS_ONGOING => {
-                StatusCode::UciStatusActiveSessionsOngoing
-            }
-            ProtoStatusCode::UCI_STATUS_MULTICAST_LIST_FULL => {
-                StatusCode::UciStatusMulticastListFull
-            }
-            ProtoStatusCode::UCI_STATUS_ADDRESS_NOT_FOUND => StatusCode::UciStatusAddressNotFound,
-            ProtoStatusCode::UCI_STATUS_ADDRESS_ALREADY_PRESENT => {
-                StatusCode::UciStatusAddressAlreadyPresent
-            }
-            ProtoStatusCode::UCI_STATUS_OK_NEGATIVE_DISTANCE_REPORT => {
-                StatusCode::UciStatusOkNegativeDistanceReport
-            }
-            ProtoStatusCode::UCI_STATUS_RANGING_TX_FAILED => StatusCode::UciStatusRangingTxFailed,
-            ProtoStatusCode::UCI_STATUS_RANGING_RX_TIMEOUT => {
-                StatusCode::UciStatusRangingRxTimeout
-            }
-            ProtoStatusCode::UCI_STATUS_RANGING_RX_PHY_DEC_FAILED => {
-                StatusCode::UciStatusRangingRxPhyDecFailed
-            }
-            ProtoStatusCode::UCI_STATUS_RANGING_RX_PHY_TOA_FAILED => {
-                StatusCode::UciStatusRangingRxPhyToaFailed
-            }
-            ProtoStatusCode::UCI_STATUS_RANGING_RX_PHY_STS_FAILED => {
-                StatusCode::UciStatusRangingRxPhyStsFailed
-            }
-            ProtoStatusCode::UCI_STATUS_RANGING_RX_MAC_DEC_FAILED => {
-                StatusCode::UciStatusRangingRxMacDecFailed
-            }
-            ProtoStatusCode::UCI_STATUS_RANGING_RX_MAC_IE_DEC_FAILED => {
-                StatusCode::UciStatusRangingRxMacIeDecFailed
-            }
-            ProtoStatusCode::UCI_STATUS_RANGING_RX_MAC_IE_MISSING => {
-                StatusCode::UciStatusRangingRxMacIeMissing
-            }
-            ProtoStatusCode::UCI_STATUS_ERROR_ROUND_INDEX_NOT_ACTIVATED => {
-                StatusCode::UciStatusErrorRoundIndexNotActivated
-            }
-            ProtoStatusCode::UCI_STATUS_ERROR_NUMBER_OF_ACTIVE_RANGING_ROUNDS_EXCEEDED => {
-                    StatusCode::UciStatusErrorNumberOfActiveRangingRoundsExceeded
-            }
-            ProtoStatusCode::UCI_STATUS_ERROR_DL_TDOA_DEVICE_ADDRESS_NOT_MATCHING_IN_REPLY_TIME_LIST =>
-                    StatusCode::UciStatusErrorDlTdoaDeviceAddressNotMatchingInReplyTimeList,
-            ProtoStatusCode::UCI_STATUS_DATA_MAX_TX_PSDU_SIZE_EXCEEDED => {
-                StatusCode::UciStatusDataMaxTxPsduSizeExceeded
-            }
-            ProtoStatusCode::UCI_STATUS_DATA_RX_CRC_ERROR => StatusCode::UciStatusDataRxCrcError,
-            ProtoStatusCode::UCI_STATUS_ERROR_CCC_SE_BUSY => StatusCode::UciStatusErrorCccSeBusy,
-            ProtoStatusCode::UCI_STATUS_ERROR_CCC_LIFECYCLE => {
-                StatusCode::UciStatusErrorCccLifecycle
-            }
-            ProtoStatusCode::UCI_STATUS_ERROR_STOPPED_DUE_TO_OTHER_SESSION_CONFLICT => {
-                StatusCode::UciStatusErrorStoppedDueToOtherSessionConflict
-            }
-            ProtoStatusCode::UCI_STATUS_REGULATION_UWB_OFF => StatusCode::UciStatusRegulationUwbOff,
-            _ =>  StatusCode::VendorSpecificStatusCode2,
-        }
-    }
-}
-
-impl From<StatusCode> for ProtoStatusCode {
-    fn from(item: StatusCode) -> Self {
-        match item {
-            StatusCode::UciStatusOk => ProtoStatusCode::UCI_STATUS_OK,
-            StatusCode::UciStatusRejected => ProtoStatusCode::UCI_STATUS_REJECTED,
-            StatusCode::UciStatusFailed => ProtoStatusCode::UCI_STATUS_FAILED,
-            StatusCode::UciStatusSyntaxError => ProtoStatusCode::UCI_STATUS_SYNTAX_ERROR,
-            StatusCode::UciStatusInvalidParam => ProtoStatusCode::UCI_STATUS_INVALID_PARAM,
-            StatusCode::UciStatusInvalidRange => ProtoStatusCode::UCI_STATUS_INVALID_RANGE,
-            StatusCode::UciStatusInvalidMsgSize => ProtoStatusCode::UCI_STATUS_INVALID_MSG_SIZE,
-            StatusCode::UciStatusUnknownGid => ProtoStatusCode::UCI_STATUS_UNKNOWN_GID,
-            StatusCode::UciStatusUnknownOid => ProtoStatusCode::UCI_STATUS_UNKNOWN_OID,
-            StatusCode::UciStatusReadOnly => ProtoStatusCode::UCI_STATUS_READ_ONLY,
-            StatusCode::UciStatusCommandRetry => ProtoStatusCode::UCI_STATUS_COMMAND_RETRY,
-            StatusCode::UciStatusUnknown => ProtoStatusCode::UCI_STATUS_UNKNOWN,
-            StatusCode::UciStatusSessionNotExist => ProtoStatusCode::UCI_STATUS_SESSION_NOT_EXIST,
-            StatusCode::UciStatusSessionDuplicate => ProtoStatusCode::UCI_STATUS_SESSION_DUPLICATE,
-            StatusCode::UciStatusSessionActive => ProtoStatusCode::UCI_STATUS_SESSION_ACTIVE,
-            StatusCode::UciStatusMaxSessionsExceeded => {
-                ProtoStatusCode::UCI_STATUS_MAX_SESSIONS_EXCEEDED
-            }
-            StatusCode::UciStatusSessionNotConfigured => {
-                ProtoStatusCode::UCI_STATUS_SESSION_NOT_CONFIGURED
-            }
-            StatusCode::UciStatusActiveSessionsOngoing => {
-                ProtoStatusCode::UCI_STATUS_ACTIVE_SESSIONS_ONGOING
-            }
-            StatusCode::UciStatusMulticastListFull => {
-                ProtoStatusCode::UCI_STATUS_MULTICAST_LIST_FULL
-            }
-            StatusCode::UciStatusAddressNotFound => {
-                ProtoStatusCode::UCI_STATUS_ADDRESS_NOT_FOUND
-            }
-            StatusCode::UciStatusAddressAlreadyPresent => {
-                ProtoStatusCode::UCI_STATUS_ADDRESS_ALREADY_PRESENT
-            }
-            StatusCode::UciStatusOkNegativeDistanceReport => {
-                ProtoStatusCode::UCI_STATUS_OK_NEGATIVE_DISTANCE_REPORT
-            }
-            StatusCode::UciStatusRangingTxFailed => {
-                ProtoStatusCode::UCI_STATUS_RANGING_TX_FAILED
-            }
-            StatusCode::UciStatusRangingRxTimeout => {
-                ProtoStatusCode::UCI_STATUS_RANGING_RX_TIMEOUT
-            }
-            StatusCode::UciStatusRangingRxPhyDecFailed => {
-                ProtoStatusCode::UCI_STATUS_RANGING_RX_PHY_DEC_FAILED
-            }
-            StatusCode::UciStatusRangingRxPhyToaFailed => {
-                ProtoStatusCode::UCI_STATUS_RANGING_RX_PHY_TOA_FAILED
-            }
-            StatusCode::UciStatusRangingRxPhyStsFailed => {
-                ProtoStatusCode::UCI_STATUS_RANGING_RX_PHY_STS_FAILED
-            }
-            StatusCode::UciStatusRangingRxMacDecFailed => {
-                ProtoStatusCode::UCI_STATUS_RANGING_RX_MAC_DEC_FAILED
-            }
-            StatusCode::UciStatusRangingRxMacIeDecFailed => {
-                ProtoStatusCode::UCI_STATUS_RANGING_RX_MAC_IE_DEC_FAILED
-            }
-            StatusCode::UciStatusRangingRxMacIeMissing => {
-                ProtoStatusCode::UCI_STATUS_RANGING_RX_MAC_IE_MISSING
-            }
-            StatusCode::UciStatusErrorRoundIndexNotActivated => {
-                ProtoStatusCode::UCI_STATUS_ERROR_ROUND_INDEX_NOT_ACTIVATED
-            }
-            StatusCode::UciStatusErrorNumberOfActiveRangingRoundsExceeded => {
-                ProtoStatusCode::UCI_STATUS_ERROR_NUMBER_OF_ACTIVE_RANGING_ROUNDS_EXCEEDED
-            }
-            StatusCode::UciStatusErrorDlTdoaDeviceAddressNotMatchingInReplyTimeList => {
-                ProtoStatusCode::UCI_STATUS_ERROR_DL_TDOA_DEVICE_ADDRESS_NOT_MATCHING_IN_REPLY_TIME_LIST
-            }
-            StatusCode::UciStatusDataMaxTxPsduSizeExceeded => {
-                ProtoStatusCode::UCI_STATUS_DATA_MAX_TX_PSDU_SIZE_EXCEEDED
-            }
-            StatusCode::UciStatusDataRxCrcError => {
-                ProtoStatusCode::UCI_STATUS_DATA_RX_CRC_ERROR
-            }
-            StatusCode::UciStatusErrorCccSeBusy => {
-                ProtoStatusCode::UCI_STATUS_ERROR_CCC_SE_BUSY
-            }
-            StatusCode::UciStatusErrorCccLifecycle => {
-                ProtoStatusCode::UCI_STATUS_ERROR_CCC_LIFECYCLE
-            }
-            StatusCode::UciStatusErrorStoppedDueToOtherSessionConflict => {
-                ProtoStatusCode::UCI_STATUS_ERROR_STOPPED_DUE_TO_OTHER_SESSION_CONFLICT
-            }
-            StatusCode::UciStatusRegulationUwbOff => {
-                ProtoStatusCode::UCI_STATUS_REGULATION_UWB_OFF
-            }
-            _ => ProtoStatusCode::UCI_STATUS_RFU_OR_VENDOR_SPECIFIC,
-        }
-    }
-}
-
-enum_mapping! {
-    ProtoDeviceState => DeviceState,
-    DEVICE_STATE_READY => DeviceStateReady,
-    DEVICE_STATE_ACTIVE => DeviceStateActive,
-    DEVICE_STATE_ERROR => DeviceStateError,
-}
-
-enum_mapping! {
-    ProtoSessionState => SessionState,
-    INIT => SessionStateInit,
-    DEINIT => SessionStateDeinit,
-    ACTIVE => SessionStateActive,
-    IDLE => SessionStateIdle,
-}
-
-impl From<ProtoReasonCode> for ReasonCode {
-    fn from(item: ProtoReasonCode) -> Self {
-        match item {
-            ProtoReasonCode::STATE_CHANGE_WITH_SESSION_MANAGEMENT_COMMANDS => {
-                ReasonCode::StateChangeWithSessionManagementCommands
-            }
-            ProtoReasonCode::MAX_RANGING_ROUND_RETRY_COUNT_REACHED => {
-                ReasonCode::MaxRangingRoundRetryCountReached
-            }
-            ProtoReasonCode::MAX_NUMBER_OF_MEASUREMENTS_REACHED => {
-                ReasonCode::MaxNumberOfMeasurementsReached
-            }
-            ProtoReasonCode::SESSION_SUSPENDED_DUE_TO_INBAND_SIGNAL => {
-                ReasonCode::SessionSuspendedDueToInbandSignal
-            }
-            ProtoReasonCode::SESSION_RESUMED_DUE_TO_INBAND_SIGNAL => {
-                ReasonCode::SessionResumedDueToInbandSignal
-            }
-            ProtoReasonCode::SESSION_STOPPED_DUE_TO_INBAND_SIGNAL => {
-                ReasonCode::SessionStoppedDueToInbandSignal
-            }
-            ProtoReasonCode::ERROR_INVALID_UL_TDOA_RANDOM_WINDOW => {
-                ReasonCode::ErrorInvalidUlTdoaRandomWindow
-            }
-            ProtoReasonCode::ERROR_MIN_RFRAMES_PER_RR_NOT_SUPPORTED => {
-                ReasonCode::ErrorMinRframesPerRrNotSupported
-            }
-            ProtoReasonCode::ERROR_INTER_FRAME_INTERVAL_NOT_SUPPORTED => {
-                ReasonCode::ErrorInterFrameIntervalNotSupported
-            }
-            ProtoReasonCode::ERROR_SLOT_LENGTH_NOT_SUPPORTED => {
-                ReasonCode::ErrorSlotLengthNotSupported
-            }
-            ProtoReasonCode::ERROR_INSUFFICIENT_SLOTS_PER_RR => {
-                ReasonCode::ErrorInsufficientSlotsPerRr
-            }
-            ProtoReasonCode::ERROR_MAC_ADDRESS_MODE_NOT_SUPPORTED => {
-                ReasonCode::ErrorMacAddressModeNotSupported
-            }
-            ProtoReasonCode::ERROR_INVALID_RANGING_DURATION => {
-                ReasonCode::ErrorInvalidRangingDuration
-            }
-            ProtoReasonCode::ERROR_INVALID_STS_CONFIG => ReasonCode::ErrorInvalidStsConfig,
-            ProtoReasonCode::ERROR_INVALID_RFRAME_CONFIG => ReasonCode::ErrorInvalidRframeConfig,
-            ProtoReasonCode::ERROR_HUS_NOT_ENOUGH_SLOTS => ReasonCode::ErrorHusNotEnoughSlots,
-            ProtoReasonCode::ERROR_HUS_CFP_PHASE_TOO_SHORT => ReasonCode::ErrorHusCfpPhaseTooShort,
-            ProtoReasonCode::ERROR_HUS_CAP_PHASE_TOO_SHORT => ReasonCode::ErrorHusCapPhaseTooShort,
-            ProtoReasonCode::ERROR_HUS_OTHERS => ReasonCode::ErrorHusOthers,
-            ProtoReasonCode::ERROR_STATUS_SESSION_KEY_NOT_FOUND => {
-                ReasonCode::ErrorStatusSessionKeyNotFound
-            }
-            ProtoReasonCode::ERROR_STATUS_SUB_SESSION_KEY_NOT_FOUND => {
-                ReasonCode::ErrorStatusSubSessionKeyNotFound
-            }
-            ProtoReasonCode::ERROR_INVALID_PREAMBLE_CODE_INDEX => {
-                ReasonCode::ErrorInvalidPreambleCodeIndex
-            }
-            ProtoReasonCode::ERROR_INVALID_SFD_ID => ReasonCode::ErrorInvalidSfdId,
-            ProtoReasonCode::ERROR_INVALID_PSDU_DATA_RATE => ReasonCode::ErrorInvalidPsduDataRate,
-            ProtoReasonCode::ERROR_INVALID_PHR_DATA_RATE => ReasonCode::ErrorInvalidPhrDataRate,
-            ProtoReasonCode::ERROR_INVALID_PREAMBLE_DURATION => {
-                ReasonCode::ErrorInvalidPreambleDuration
-            }
-            ProtoReasonCode::ERROR_INVALID_STS_LENGTH => ReasonCode::ErrorInvalidStsLength,
-            ProtoReasonCode::ERROR_INVALID_NUM_OF_STS_SEGMENTS => {
-                ReasonCode::ErrorInvalidNumOfStsSegments
-            }
-            ProtoReasonCode::ERROR_INVALID_NUM_OF_CONTROLEES => {
-                ReasonCode::ErrorInvalidNumOfControlees
-            }
-            ProtoReasonCode::ERROR_MAX_RANGING_REPLY_TIME_EXCEEDED => {
-                ReasonCode::ErrorMaxRangingReplyTimeExceeded
-            }
-            ProtoReasonCode::ERROR_INVALID_DST_ADDRESS_LIST => {
-                ReasonCode::ErrorInvalidDstAddressList
-            }
-            ProtoReasonCode::ERROR_INVALID_OR_NOT_FOUND_SUB_SESSION_ID => {
-                ReasonCode::ErrorInvalidOrNotFoundSubSessionId
-            }
-            ProtoReasonCode::ERROR_INVALID_RESULT_REPORT_CONFIG => {
-                ReasonCode::ErrorInvalidResultReportConfig
-            }
-            ProtoReasonCode::ERROR_INVALID_RANGING_ROUND_USAGE => {
-                ReasonCode::ErrorInvalidRangingRoundUsage
-            }
-            ProtoReasonCode::ERROR_INVALID_MULTI_NODE_MODE => ReasonCode::ErrorInvalidMultiNodeMode,
-            ProtoReasonCode::ERROR_RDS_FETCH_FAILURE => ReasonCode::ErrorRdsFetchFailure,
-            ProtoReasonCode::ERROR_REF_UWB_SESSION_DOES_NOT_EXIST => {
-                ReasonCode::ErrorRefUwbSessionDoesNotExist
-            }
-            ProtoReasonCode::ERROR_REF_UWB_SESSION_RANGING_DURATION_MISMATCH => {
-                ReasonCode::ErrorRefUwbSessionRangingDurationMismatch
-            }
-            ProtoReasonCode::ERROR_REF_UWB_SESSION_INVALID_OFFSET_TIME => {
-                ReasonCode::ErrorRefUwbSessionInvalidOffsetTime
-            }
-            ProtoReasonCode::ERROR_REF_UWB_SESSION_LOST => ReasonCode::ErrorRefUwbSessionLost,
-            ProtoReasonCode::ERROR_INVALID_CHANNEL_WITH_AOA => {
-                ReasonCode::ErrorInvalidChannelWithAoa
-            }
-            ProtoReasonCode::ERROR_STOPPED_DUE_TO_OTHER_SESSION_CONFLICT => {
-                ReasonCode::ErrorStoppedDueToOtherSessionConflict
-            }
-            ProtoReasonCode::SESSION_STOPPED_DUE_TO_MAX_STS_INDEX_VALUE => {
-                ReasonCode::SessionStoppedDueToMaxStsIndexValue
-            }
-            _ => ReasonCode::VendorSpecificReasonCode2,
-        }
-    }
-}
-
-impl From<ReasonCode> for ProtoReasonCode {
-    fn from(item: ReasonCode) -> Self {
-        match item {
-            ReasonCode::StateChangeWithSessionManagementCommands => {
-                ProtoReasonCode::STATE_CHANGE_WITH_SESSION_MANAGEMENT_COMMANDS
-            }
-            ReasonCode::MaxRangingRoundRetryCountReached => {
-                ProtoReasonCode::MAX_RANGING_ROUND_RETRY_COUNT_REACHED
-            }
-            ReasonCode::MaxNumberOfMeasurementsReached => {
-                ProtoReasonCode::MAX_NUMBER_OF_MEASUREMENTS_REACHED
-            }
-            ReasonCode::SessionSuspendedDueToInbandSignal => {
-                ProtoReasonCode::SESSION_SUSPENDED_DUE_TO_INBAND_SIGNAL
-            }
-            ReasonCode::SessionResumedDueToInbandSignal => {
-                ProtoReasonCode::SESSION_RESUMED_DUE_TO_INBAND_SIGNAL
-            }
-            ReasonCode::SessionStoppedDueToInbandSignal => {
-                ProtoReasonCode::SESSION_STOPPED_DUE_TO_INBAND_SIGNAL
-            }
-            ReasonCode::ErrorInvalidUlTdoaRandomWindow => {
-                ProtoReasonCode::ERROR_INVALID_UL_TDOA_RANDOM_WINDOW
-            }
-            ReasonCode::ErrorMinRframesPerRrNotSupported => {
-                ProtoReasonCode::ERROR_MIN_RFRAMES_PER_RR_NOT_SUPPORTED
-            }
-            ReasonCode::ErrorInterFrameIntervalNotSupported => {
-                ProtoReasonCode::ERROR_INTER_FRAME_INTERVAL_NOT_SUPPORTED
-            }
-            ReasonCode::ErrorSlotLengthNotSupported => {
-                ProtoReasonCode::ERROR_SLOT_LENGTH_NOT_SUPPORTED
-            }
-            ReasonCode::ErrorInsufficientSlotsPerRr => {
-                ProtoReasonCode::ERROR_INSUFFICIENT_SLOTS_PER_RR
-            }
-            ReasonCode::ErrorMacAddressModeNotSupported => {
-                ProtoReasonCode::ERROR_MAC_ADDRESS_MODE_NOT_SUPPORTED
-            }
-            ReasonCode::ErrorInvalidRangingDuration => {
-                ProtoReasonCode::ERROR_INVALID_RANGING_DURATION
-            }
-            ReasonCode::ErrorInvalidStsConfig => ProtoReasonCode::ERROR_INVALID_STS_CONFIG,
-            ReasonCode::ErrorInvalidRframeConfig => ProtoReasonCode::ERROR_INVALID_RFRAME_CONFIG,
-            ReasonCode::ErrorHusNotEnoughSlots => ProtoReasonCode::ERROR_HUS_NOT_ENOUGH_SLOTS,
-            ReasonCode::ErrorHusCfpPhaseTooShort => ProtoReasonCode::ERROR_HUS_CFP_PHASE_TOO_SHORT,
-            ReasonCode::ErrorHusCapPhaseTooShort => ProtoReasonCode::ERROR_HUS_CAP_PHASE_TOO_SHORT,
-            ReasonCode::ErrorHusOthers => ProtoReasonCode::ERROR_HUS_OTHERS,
-            ReasonCode::ErrorStatusSessionKeyNotFound => {
-                ProtoReasonCode::ERROR_STATUS_SESSION_KEY_NOT_FOUND
-            }
-            ReasonCode::ErrorStatusSubSessionKeyNotFound => {
-                ProtoReasonCode::ERROR_STATUS_SUB_SESSION_KEY_NOT_FOUND
-            }
-            ReasonCode::ErrorInvalidPreambleCodeIndex => {
-                ProtoReasonCode::ERROR_INVALID_PREAMBLE_CODE_INDEX
-            }
-            ReasonCode::ErrorInvalidSfdId => ProtoReasonCode::ERROR_INVALID_SFD_ID,
-            ReasonCode::ErrorInvalidPsduDataRate => ProtoReasonCode::ERROR_INVALID_PSDU_DATA_RATE,
-            ReasonCode::ErrorInvalidPhrDataRate => ProtoReasonCode::ERROR_INVALID_PHR_DATA_RATE,
-            ReasonCode::ErrorInvalidPreambleDuration => {
-                ProtoReasonCode::ERROR_INVALID_PREAMBLE_DURATION
-            }
-            ReasonCode::ErrorInvalidStsLength => ProtoReasonCode::ERROR_INVALID_STS_LENGTH,
-            ReasonCode::ErrorInvalidNumOfStsSegments => {
-                ProtoReasonCode::ERROR_INVALID_NUM_OF_STS_SEGMENTS
-            }
-            ReasonCode::ErrorInvalidNumOfControlees => {
-                ProtoReasonCode::ERROR_INVALID_NUM_OF_CONTROLEES
-            }
-            ReasonCode::ErrorMaxRangingReplyTimeExceeded => {
-                ProtoReasonCode::ERROR_MAX_RANGING_REPLY_TIME_EXCEEDED
-            }
-            ReasonCode::ErrorInvalidDstAddressList => {
-                ProtoReasonCode::ERROR_INVALID_DST_ADDRESS_LIST
-            }
-            ReasonCode::ErrorInvalidOrNotFoundSubSessionId => {
-                ProtoReasonCode::ERROR_INVALID_OR_NOT_FOUND_SUB_SESSION_ID
-            }
-            ReasonCode::ErrorInvalidResultReportConfig => {
-                ProtoReasonCode::ERROR_INVALID_RESULT_REPORT_CONFIG
-            }
-            ReasonCode::ErrorInvalidRangingRoundUsage => {
-                ProtoReasonCode::ERROR_INVALID_RANGING_ROUND_USAGE
-            }
-            ReasonCode::ErrorInvalidMultiNodeMode => ProtoReasonCode::ERROR_INVALID_MULTI_NODE_MODE,
-            ReasonCode::ErrorRdsFetchFailure => ProtoReasonCode::ERROR_RDS_FETCH_FAILURE,
-            ReasonCode::ErrorRefUwbSessionDoesNotExist => {
-                ProtoReasonCode::ERROR_REF_UWB_SESSION_DOES_NOT_EXIST
-            }
-            ReasonCode::ErrorRefUwbSessionRangingDurationMismatch => {
-                ProtoReasonCode::ERROR_REF_UWB_SESSION_RANGING_DURATION_MISMATCH
-            }
-            ReasonCode::ErrorRefUwbSessionInvalidOffsetTime => {
-                ProtoReasonCode::ERROR_REF_UWB_SESSION_INVALID_OFFSET_TIME
-            }
-            ReasonCode::ErrorRefUwbSessionLost => ProtoReasonCode::ERROR_REF_UWB_SESSION_LOST,
-            ReasonCode::ErrorInvalidChannelWithAoa => {
-                ProtoReasonCode::ERROR_INVALID_CHANNEL_WITH_AOA
-            }
-            ReasonCode::ErrorStoppedDueToOtherSessionConflict => {
-                ProtoReasonCode::ERROR_STOPPED_DUE_TO_OTHER_SESSION_CONFLICT
-            }
-            ReasonCode::ErrorDtAnchorRangingRoundsNotConfigured => {
-                ProtoReasonCode::ERROR_DT_ANCHOR_RANGING_ROUNDS_NOT_CONFIGURED
-            }
-            ReasonCode::ErrorDtTagRangingRoundsNotConfigured => {
-                ProtoReasonCode::ERROR_DT_TAG_RANGING_ROUNDS_NOT_CONFIGURED
-            }
-            _ => ProtoReasonCode::ERROR_RFU_OR_VENDOR_SPECIFIC,
-        }
-    }
-}
-
-enum_mapping! {
-    ProtoUciLoggerMode => UciLoggerMode,
-    UCI_LOGGER_MODE_DISABLED => Disabled,
-    UCI_LOGGER_MODE_UNFILTERED => Unfiltered,
-    UCI_LOGGER_MODE_FILTERED => Filtered,
-}
-
-enum_mapping! {
-    ProtoRangingMeasurementType => RangingMeasurementType,
-    ONE_WAY => OneWay,
-    TWO_WAY => TwoWay,
-    DL_TDOA => DlTdoa,
-    OWR_AOA => OwrAoa,
-}
-
-enum_mapping! {
-    ProtoSessionType => SessionType,
-    FIRA_RANGING_SESSION => FiraRangingSession,
-    FIRA_DATA_TRANSFER => FiraDataTransferSession,
-    FIRA_RANGING_AND_IN_BAND_DATA_SESSION => FiraRangingAndInBandDataSession,
-    FIRA_RANGING_ONLY_PHASE => FiraRangingOnlyPhase,
-    FIRA_IN_BAND_DATA_PHASE => FiraInBandDataPhase,
-    FIRA_RANGING_WITH_DATA_PHASE => FiraRangingWithDataPhase,
-    FIRA_HUS_PRIMARY_SESSION => FiraHusPrimarySession,
-    CCC => Ccc,
-    RADAR_SESSION => RadarSession,
-    ALIRO => Aliro,
-    DEVICE_TEST_MODE => DeviceTestMode,
-}
-
-enum_mapping! {
-    ProtoDeviceType => DeviceType,
-    CONTROLEE => Controlee,
-    CONTROLLER => Controller,
-}
-
-enum_mapping! {
-    ProtoRangingRoundUsage => RangingRoundUsage,
-    SS_TWR => SsTwr,
-    DS_TWR => DsTwr,
-    SS_TWR_NON => SsTwrNon,
-    DS_TWR_NON => DsTwrNon,
-}
-
-enum_mapping! {
-    ProtoStsConfig => StsConfig,
-    STATIC => Static,
-    DYNAMIC => Dynamic,
-    DYNAMIC_FOR_CONTROLEE_INDIVIDUAL_KEY => DynamicForControleeIndividualKey,
-}
-
-enum_mapping! {
-    ProtoMultiNodeMode => MultiNodeMode,
-    UNICAST => Unicast,
-    ONE_TO_MANY => OneToMany,
-    MANY_TO_MANY => ManyToMany,
-}
-
-enum_mapping! {
-    ProtoUwbChannel => UwbChannel,
-    CHANNEL_5 => Channel5,
-    CHANNEL_6 => Channel6,
-    CHANNEL_8 => Channel8,
-    CHANNEL_9 => Channel9,
-    CHANNEL_10 => Channel10,
-    CHANNEL_12 => Channel12,
-    CHANNEL_13 => Channel13,
-    CHANNEL_14 => Channel14,
-}
-
-enum_mapping! {
-    ProtoMacFcsType => MacFcsType,
-    CRC_16 => Crc16,
-    CRC_32 => Crc32,
-}
-
-enum_mapping! {
-    ProtoAoaResultRequest => AoaResultRequest,
-    NO_AOA_REPORT => NoAoaReport,
-    REQ_AOA_RESULTS => ReqAoaResults,
-    REQ_AOA_RESULTS_AZIMUTH_ONLY => ReqAoaResultsAzimuthOnly,
-    REQ_AOA_RESULTS_ELEVATION_ONLY => ReqAoaResultsElevationOnly,
-    REQ_AOA_RESULTS_INTERLEAVED => ReqAoaResultsInterleaved,
-}
-
-enum_mapping! {
-    ProtoRangeDataNtfConfig => RangeDataNtfConfig,
-    RANGE_DATA_NTF_CONFIG_DISABLE => Disable,
-    RANGE_DATA_NTF_CONFIG_ENABLE => Enable,
-    RANGE_DATA_NTF_CONFIG_ENABLE_PROXIMITY => EnableProximity,
-}
-
-enum_mapping! {
-    ProtoDeviceRole => DeviceRole,
-    RESPONDER => Responder,
-    INITIATOR => Initiator,
-}
-
-enum_mapping! {
-    ProtoRframeConfig => RframeConfig,
-    SP0 => SP0,
-    SP1 => SP1,
-    SP3 => SP3,
-}
-
-enum_mapping! {
-    ProtoPsduDataRate => PsduDataRate,
-    RATE_6M_81 => Rate6m81,
-    RATE_7M_80 => Rate7m80,
-    RATE_27M_2 => Rate27m2,
-    RATE_31M_2 => Rate31m2,
-    RATE_850K => Rate850k,
-}
-
-enum_mapping! {
-    ProtoPreambleDuration => PreambleDuration,
-    T32_SYMBOLS => T32Symbols,
-    T64_SYMBOLS => T64Symbols,
-}
-
-enum_mapping! {
-    ProtoRangingTimeStruct => RangingTimeStruct,
-    INTERVAL_BASED_SCHEDULING => IntervalBasedScheduling,
-    BLOCK_BASED_SCHEDULING => BlockBasedScheduling,
-}
-
-enum_mapping! {
-    ProtoTxAdaptivePayloadPower => TxAdaptivePayloadPower,
-    TX_ADAPTIVE_PAYLOAD_POWER_DISABLE => Disable,
-    TX_ADAPTIVE_PAYLOAD_POWER_ENABLE => Enable,
-}
-
-enum_mapping! {
-    ProtoPrfMode => PrfMode,
-    BPRF => Bprf,
-    HPRF_WITH_124_8_MHZ => HprfWith124_8MHz,
-    HPRF_WITH_249_6_MHZ => HprfWith249_6MHz,
-}
-
-enum_mapping! {
-    ProtoScheduledMode => ScheduledMode,
-    TIME_SCHEDULED_RANGING => TimeScheduledRanging,
-}
-
-enum_mapping! {
-    ProtoKeyRotation => KeyRotation,
-    KEY_ROTATION_DISABLE => Disable,
-    KEY_ROTATION_ENABLE => Enable,
-}
-
-enum_mapping! {
-    ProtoMacAddressMode => MacAddressMode,
-    MAC_ADDRESS_2_BYTES => MacAddress2Bytes,
-    MAC_ADDRESS_8_BYTES_2_BYTES_HEADER => MacAddress8Bytes2BytesHeader,
-    MAC_ADDRESS_8_BYTES => MacAddress8Bytes,
-}
-
-enum_mapping! {
-    ProtoHoppingMode => HoppingMode,
-    HOPPING_MODE_DISABLE => Disable,
-    FIRA_HOPPING_ENABLE => FiraHoppingEnable,
-}
-
-enum_mapping! {
-    ProtoBprfPhrDataRate => BprfPhrDataRate,
-    BPRF_PHR_DATA_RATE_850K => Rate850k,
-    BPRF_PHR_DATA_RATE_6M_81 => Rate6m81,
-}
-
-enum_mapping! {
-    ProtoStsLength => StsLength,
-    LENGTH_32 => Length32,
-    LENGTH_64 => Length64,
-    LENGTH_128 => Length128,
-}
-
-enum_mapping! {
-    ProtoUpdateMulticastListAction => UpdateMulticastListAction,
-    ADD_CONTROLEE => AddControlee,
-    REMOVE_CONTROLEE => RemoveControlee,
-    ADD_CONTROLEE_WITH_SHORT_SUB_SESSION_KEY => AddControleeWithShortSubSessionKey,
-    ADD_CONTROLEE_WITH_LONG_SUB_SESSION_KEY => AddControleeWithLongSubSessionKey,
-}
-
-enum_mapping! {
-    ProtoMacAddressIndicator => MacAddressIndicator,
-    SHORT_ADDRESS => ShortAddress,
-    EXTENDED_ADDRESS => ExtendedAddress,
-}
-
-pub enum ProtoRangingMeasurements {
-    TwoWay(Vec<ProtoTwoWayRangingMeasurement>),
-    OwrAoa(ProtoOwrAoaRangingMeasurement),
-    DlTDoa(Vec<ProtoDlTDoARangingMeasurement>),
-}
-
-impl<T> From<Result<T>> for ProtoStatus {
-    fn from(item: Result<T>) -> Self {
-        match item {
-            Ok(_) => Self::OK,
-            Err(Error::BadParameters) => Self::BAD_PARAMETERS,
-            Err(Error::MaxSessionsExceeded) => Self::MAX_SESSIONS_EXCEEDED,
-            Err(Error::MaxRrRetryReached) => Self::MAX_RR_RETRY_REACHED,
-            Err(Error::ProtocolSpecific) => Self::PROTOCOL_SPECIFIC,
-            Err(Error::RemoteRequest) => Self::REMOTE_REQUEST,
-            Err(Error::Timeout) => Self::TIMEOUT,
-            Err(Error::CommandRetry) => Self::COMMAND_RETRY,
-            Err(Error::DuplicatedSessionId) => Self::DUPLICATED_SESSION_ID,
-            Err(Error::RegulationUwbOff) => Self::REGULATION_UWB_OFF,
-            Err(_) => Self::UNKNOWN,
-        }
-    }
-}
-
-impl From<ShortAddressTwoWayRangingMeasurement> for ProtoTwoWayRangingMeasurement {
-    fn from(item: ShortAddressTwoWayRangingMeasurement) -> Self {
-        let mut result = Self::new();
-        result.mac_address = item.mac_address.into();
-        result.status = EnumOrUnknown::new(item.status.into());
-        result.nlos = item.nlos.into();
-        result.distance = item.distance.into();
-        result.aoa_azimuth = item.aoa_azimuth.into();
-        result.aoa_azimuth_fom = item.aoa_azimuth_fom.into();
-        result.aoa_elevation = item.aoa_elevation.into();
-        result.aoa_elevation_fom = item.aoa_elevation_fom.into();
-        result.aoa_destination_azimuth = item.aoa_destination_azimuth.into();
-        result.aoa_destination_azimuth_fom = item.aoa_destination_azimuth_fom.into();
-        result.aoa_destination_elevation = item.aoa_destination_elevation.into();
-        result.aoa_destination_elevation_fom = item.aoa_destination_elevation_fom.into();
-        result.slot_index = item.slot_index.into();
-        result.rssi = item.rssi.into();
-        result
-    }
-}
-
-impl From<ExtendedAddressTwoWayRangingMeasurement> for ProtoTwoWayRangingMeasurement {
-    fn from(item: ExtendedAddressTwoWayRangingMeasurement) -> Self {
-        let mut result = Self::new();
-        result.mac_address = item.mac_address;
-        result.status = EnumOrUnknown::new(item.status.into());
-        result.nlos = item.nlos.into();
-        result.distance = item.distance.into();
-        result.aoa_azimuth = item.aoa_azimuth.into();
-        result.aoa_azimuth_fom = item.aoa_azimuth_fom.into();
-        result.aoa_elevation = item.aoa_elevation.into();
-        result.aoa_elevation_fom = item.aoa_elevation_fom.into();
-        result.aoa_destination_azimuth = item.aoa_destination_azimuth.into();
-        result.aoa_destination_azimuth_fom = item.aoa_destination_azimuth_fom.into();
-        result.aoa_destination_elevation = item.aoa_destination_elevation.into();
-        result.aoa_destination_elevation_fom = item.aoa_destination_elevation_fom.into();
-        result.slot_index = item.slot_index.into();
-        result.rssi = item.rssi.into();
-        result
-    }
-}
-
-impl From<ShortAddressOwrAoaRangingMeasurement> for ProtoOwrAoaRangingMeasurement {
-    fn from(item: ShortAddressOwrAoaRangingMeasurement) -> Self {
-        let mut result = Self::new();
-        result.mac_address = item.mac_address.into();
-        result.status = EnumOrUnknown::new(item.status.into());
-        result.nlos = item.nlos.into();
-        result.block_index = item.block_index.into();
-        result.frame_sequence_number = item.frame_sequence_number.into();
-        result.aoa_azimuth = item.aoa_azimuth.into();
-        result.aoa_azimuth_fom = item.aoa_azimuth_fom.into();
-        result.aoa_elevation = item.aoa_elevation.into();
-        result.aoa_elevation_fom = item.aoa_elevation_fom.into();
-        result
-    }
-}
-
-impl From<ExtendedAddressOwrAoaRangingMeasurement> for ProtoOwrAoaRangingMeasurement {
-    fn from(item: ExtendedAddressOwrAoaRangingMeasurement) -> Self {
-        let mut result = Self::new();
-        result.mac_address = item.mac_address;
-        result.status = EnumOrUnknown::new(item.status.into());
-        result.nlos = item.nlos.into();
-        result.block_index = item.block_index.into();
-        result.frame_sequence_number = item.frame_sequence_number.into();
-        result.aoa_azimuth = item.aoa_azimuth.into();
-        result.aoa_azimuth_fom = item.aoa_azimuth_fom.into();
-        result.aoa_elevation = item.aoa_elevation.into();
-        result.aoa_elevation_fom = item.aoa_elevation_fom.into();
-        result
-    }
-}
-
-impl From<ShortAddressDlTdoaRangingMeasurement> for ProtoDlTDoARangingMeasurement {
-    fn from(item: ShortAddressDlTdoaRangingMeasurement) -> Self {
-        let mut result = Self::new();
-        result.mac_address = item.mac_address.into();
-        result.status = EnumOrUnknown::new(
-            StatusCode::try_from(item.measurement.status)
-                .unwrap_or(StatusCode::UciStatusFailed)
-                .into(),
-        );
-        result.message_control = item.measurement.message_control.into();
-        result.block_index = item.measurement.block_index.into();
-        result.round_index = item.measurement.round_index.into();
-        result.nlos = item.measurement.nlos.into();
-        result.aoa_azimuth = item.measurement.aoa_azimuth.into();
-        result.aoa_azimuth_fom = item.measurement.aoa_azimuth_fom.into();
-        result.aoa_elevation = item.measurement.aoa_elevation.into();
-        result.aoa_elevation_fom = item.measurement.aoa_elevation_fom.into();
-        result.rssi = item.measurement.rssi.into();
-        result.tx_timestamp = item.measurement.tx_timestamp;
-        result.rx_timestamp = item.measurement.rx_timestamp;
-        result.anchor_cfo = item.measurement.anchor_cfo.into();
-        result.cfo = item.measurement.cfo.into();
-        result.initiator_reply_time = item.measurement.initiator_reply_time;
-        result.responder_reply_time = item.measurement.responder_reply_time;
-        result.initiator_responder_tof = item.measurement.initiator_responder_tof.into();
-        result.dt_anchor_location = item
-            .measurement
-            .dt_anchor_location
-            .into_iter()
-            .map(|val| val as u32)
-            .collect::<Vec<u32>>();
-        result.ranging_rounds =
-            item.measurement.ranging_rounds.into_iter().map(|val| val as u32).collect::<Vec<u32>>();
-        result
-    }
-}
-
-impl From<ExtendedAddressDlTdoaRangingMeasurement> for ProtoDlTDoARangingMeasurement {
-    fn from(item: ExtendedAddressDlTdoaRangingMeasurement) -> Self {
-        let mut result = Self::new();
-        result.mac_address = item.mac_address;
-        result.status = EnumOrUnknown::new(
-            StatusCode::try_from(item.measurement.status)
-                .unwrap_or(StatusCode::UciStatusFailed)
-                .into(),
-        );
-        result.message_control = item.measurement.message_control.into();
-        result.block_index = item.measurement.block_index.into();
-        result.round_index = item.measurement.round_index.into();
-        result.nlos = item.measurement.nlos.into();
-        result.aoa_azimuth = item.measurement.aoa_azimuth.into();
-        result.aoa_azimuth_fom = item.measurement.aoa_azimuth_fom.into();
-        result.aoa_elevation = item.measurement.aoa_elevation.into();
-        result.aoa_elevation_fom = item.measurement.aoa_elevation_fom.into();
-        result.rssi = item.measurement.rssi.into();
-        result.tx_timestamp = item.measurement.tx_timestamp;
-        result.rx_timestamp = item.measurement.rx_timestamp;
-        result.anchor_cfo = item.measurement.anchor_cfo.into();
-        result.cfo = item.measurement.cfo.into();
-        result.initiator_reply_time = item.measurement.initiator_reply_time;
-        result.responder_reply_time = item.measurement.responder_reply_time;
-        result.initiator_responder_tof = item.measurement.initiator_responder_tof.into();
-        result.dt_anchor_location = item
-            .measurement
-            .dt_anchor_location
-            .into_iter()
-            .map(|val| val as u32)
-            .collect::<Vec<u32>>();
-        result.ranging_rounds =
-            item.measurement.ranging_rounds.into_iter().map(|val| val as u32).collect::<Vec<u32>>();
-        result
-    }
-}
-
-impl From<SessionRangeData> for ProtoSessionRangeData {
-    fn from(item: SessionRangeData) -> Self {
-        let mut result = Self::new();
-        result.sequence_number = item.sequence_number;
-        result.session_id = item.session_token;
-        result.current_ranging_interval_ms = item.current_ranging_interval_ms;
-        result.ranging_measurement_type = EnumOrUnknown::new(item.ranging_measurement_type.into());
-        match to_proto_ranging_measurements(item.ranging_measurements) {
-            ProtoRangingMeasurements::TwoWay(twoway_measurements) => {
-                result.twoway_ranging_measurements = twoway_measurements;
-            }
-            ProtoRangingMeasurements::OwrAoa(owraoa_measurement) => {
-                result.owraoa_ranging_measurement = MessageField::from(Some(owraoa_measurement));
-            }
-            ProtoRangingMeasurements::DlTDoa(dltdoa_measurements) => {
-                result.dltdoa_ranging_measurements = dltdoa_measurements;
-            }
-        }
-        result
-    }
-}
-
-fn to_proto_ranging_measurements(item: RangingMeasurements) -> ProtoRangingMeasurements {
-    match item {
-        RangingMeasurements::ShortAddressTwoWay(arr) => {
-            ProtoRangingMeasurements::TwoWay(arr.into_iter().map(|item| item.into()).collect())
-        }
-        RangingMeasurements::ExtendedAddressTwoWay(arr) => {
-            ProtoRangingMeasurements::TwoWay(arr.into_iter().map(|item| item.into()).collect())
-        }
-        RangingMeasurements::ShortAddressOwrAoa(r) => ProtoRangingMeasurements::OwrAoa(r.into()),
-        RangingMeasurements::ExtendedAddressOwrAoa(r) => ProtoRangingMeasurements::OwrAoa(r.into()),
-        RangingMeasurements::ShortAddressDltdoa(arr) => {
-            ProtoRangingMeasurements::DlTDoa(arr.into_iter().map(|item| item.into()).collect())
-        }
-        RangingMeasurements::ExtendedAddressDltdoa(arr) => {
-            ProtoRangingMeasurements::DlTDoa(arr.into_iter().map(|item| item.into()).collect())
-        }
-    }
-}
-
-impl From<ProtoRangingRoundControl> for RangingRoundControl {
-    fn from(item: ProtoRangingRoundControl) -> Self {
-        Self {
-            ranging_result_report_message: item.ranging_result_report_message,
-            control_message: item.control_message,
-            measurement_report_message: item.measurement_report_message,
-        }
-    }
-}
-
-impl From<RangingRoundControl> for ProtoRangingRoundControl {
-    fn from(item: RangingRoundControl) -> Self {
-        let mut res = Self::new();
-        res.ranging_result_report_message = item.ranging_result_report_message;
-        res.control_message = item.control_message;
-        res.measurement_report_message = item.measurement_report_message;
-        res
-    }
-}
-
-impl From<ProtoResultReportConfig> for ResultReportConfig {
-    fn from(item: ProtoResultReportConfig) -> Self {
-        Self {
-            tof: item.tof,
-            aoa_azimuth: item.aoa_azimuth,
-            aoa_elevation: item.aoa_elevation,
-            aoa_fom: item.aoa_fom,
-        }
-    }
-}
-
-impl From<ResultReportConfig> for ProtoResultReportConfig {
-    fn from(item: ResultReportConfig) -> Self {
-        let mut res = Self::new();
-        res.tof = item.tof;
-        res.aoa_azimuth = item.aoa_azimuth;
-        res.aoa_elevation = item.aoa_elevation;
-        res.aoa_fom = item.aoa_fom;
-        res
-    }
-}
-
-fn to_uwb_address(bytes: Vec<u8>, mode: ProtoMacAddressMode) -> Option<UwbAddress> {
-    match mode {
-        ProtoMacAddressMode::MAC_ADDRESS_2_BYTES
-        | ProtoMacAddressMode::MAC_ADDRESS_8_BYTES_2_BYTES_HEADER => {
-            Some(UwbAddress::Short(bytes.try_into().ok()?))
-        }
-        ProtoMacAddressMode::MAC_ADDRESS_8_BYTES => {
-            Some(UwbAddress::Extended(bytes.try_into().ok()?))
-        }
-    }
-}
-
-impl TryFrom<ProtoControlee> for Controlee {
-    type Error = String;
-    fn try_from(item: ProtoControlee) -> std::result::Result<Self, Self::Error> {
-        Ok(Self {
-            short_address: item.short_address.to_ne_bytes()[0..2]
-                .try_into()
-                .map_err(|_| "Failed to convert short_address")?,
-            subsession_id: item.subsession_id,
-        })
-    }
-}
-
-impl From<PowerStats> for ProtoPowerStats {
-    fn from(item: PowerStats) -> Self {
-        let mut res = Self::new();
-        res.status = ProtoStatusCode::from(item.status).into();
-        res.idle_time_ms = item.idle_time_ms;
-        res.tx_time_ms = item.tx_time_ms;
-        res.rx_time_ms = item.rx_time_ms;
-        res.total_wake_count = item.total_wake_count;
-        res
-    }
-}
-
-impl From<FiraAppConfigParams> for ProtoFiraAppConfigParams {
-    fn from(item: FiraAppConfigParams) -> Self {
-        let mut res = Self::new();
-        res.device_type = EnumOrUnknown::new((*item.device_type()).into());
-        res.ranging_round_usage = ProtoRangingRoundUsage::from(*item.ranging_round_usage()).into();
-        res.sts_config = ProtoStsConfig::from(*item.sts_config()).into();
-        res.multi_node_mode = ProtoMultiNodeMode::from(*item.multi_node_mode()).into();
-        res.channel_number = ProtoUwbChannel::from(*item.channel_number()).into();
-        res.device_mac_address = item.device_mac_address().clone().into();
-        res.dst_mac_address =
-            item.dst_mac_address().clone().into_iter().map(|addr| addr.into()).collect::<Vec<_>>();
-        res.slot_duration_rstu = (*item.slot_duration_rstu()).into();
-        res.ranging_duration_ms = *item.ranging_duration_ms();
-        res.mac_fcs_type = ProtoMacFcsType::from(*item.mac_fcs_type()).into();
-        res.ranging_round_control = MessageField::from(Some(ProtoRangingRoundControl::from(
-            item.ranging_round_control().clone(),
-        )));
-        res.aoa_result_request = ProtoAoaResultRequest::from(*item.aoa_result_request()).into();
-        res.range_data_ntf_config =
-            ProtoRangeDataNtfConfig::from(*item.range_data_ntf_config()).into();
-        res.range_data_ntf_proximity_near_cm = (*item.range_data_ntf_proximity_near_cm()).into();
-        res.range_data_ntf_proximity_far_cm = (*item.range_data_ntf_proximity_far_cm()).into();
-        res.device_role = ProtoDeviceRole::from(*item.device_role()).into();
-        res.rframe_config = ProtoRframeConfig::from(*item.rframe_config()).into();
-        res.preamble_code_index = (*item.preamble_code_index()).into();
-        res.sfd_id = (*item.sfd_id()).into();
-        res.psdu_data_rate = ProtoPsduDataRate::from(*item.psdu_data_rate()).into();
-        res.preamble_duration = ProtoPreambleDuration::from(*item.preamble_duration()).into();
-        res.ranging_time_struct = ProtoRangingTimeStruct::from(*item.ranging_time_struct()).into();
-        res.slots_per_rr = (*item.slots_per_rr()).into();
-        res.tx_adaptive_payload_power =
-            ProtoTxAdaptivePayloadPower::from(*item.tx_adaptive_payload_power()).into();
-        res.responder_slot_index = (*item.responder_slot_index()).into();
-        res.prf_mode = ProtoPrfMode::from(*item.prf_mode()).into();
-        res.scheduled_mode = ProtoScheduledMode::from(*item.scheduled_mode()).into();
-        res.key_rotation = ProtoKeyRotation::from(*item.key_rotation()).into();
-        res.key_rotation_rate = (*item.key_rotation_rate()).into();
-        res.session_priority = (*item.session_priority()).into();
-        res.mac_address_mode = ProtoMacAddressMode::from(*item.mac_address_mode()).into();
-        res.vendor_id = (*item.vendor_id()).into();
-        res.static_sts_iv = (*item.static_sts_iv()).into();
-        res.number_of_sts_segments = (*item.number_of_sts_segments()).into();
-        res.max_rr_retry = (*item.max_rr_retry()).into();
-        res.uwb_initiation_time_ms = *item.uwb_initiation_time_ms();
-        res.hopping_mode = ProtoHoppingMode::from(*item.hopping_mode()).into();
-        res.block_stride_length = (*item.block_stride_length()).into();
-        res.result_report_config = MessageField::from(Some(ProtoResultReportConfig::from(
-            item.result_report_config().clone(),
-        )));
-        res.in_band_termination_attempt_count = (*item.in_band_termination_attempt_count()).into();
-        res.sub_session_id = *item.sub_session_id();
-        res.bprf_phr_data_rate = ProtoBprfPhrDataRate::from(*item.bprf_phr_data_rate()).into();
-        res.max_number_of_measurements = (*item.max_number_of_measurements()).into();
-        res.sts_length = ProtoStsLength::from(*item.sts_length()).into();
-        res.number_of_range_measurements = (*item.number_of_range_measurements()).into();
-        res.number_of_aoa_azimuth_measurements =
-            (*item.number_of_aoa_azimuth_measurements()).into();
-        res.number_of_aoa_elevation_measurements =
-            (*item.number_of_aoa_elevation_measurements()).into();
-
-        res
-    }
-}
-
-impl TryFrom<ProtoFiraAppConfigParams> for AppConfigParams {
-    type Error = String;
-    fn try_from(mut item: ProtoFiraAppConfigParams) -> std::result::Result<Self, Self::Error> {
-        let device_mac_address = to_uwb_address(
-            item.device_mac_address.clone(),
-            item.mac_address_mode.enum_value().map_err(|_| "Failed to read mac_address_mode")?,
-        )
-        .ok_or("Failed to convert device_mac_address")?;
-        let mut dst_mac_address = vec![];
-        for addr in item.dst_mac_address.clone().into_iter() {
-            let addr = to_uwb_address(
-                addr,
-                item.mac_address_mode
-                    .enum_value()
-                    .map_err(|_| "Failed to convert mac_address_mode")?,
-            )
-            .ok_or("Failed to convert dst_mac_address")?;
-            dst_mac_address.push(addr);
-        }
-
-        let mut builder = FiraAppConfigParamsBuilder::new();
-        builder
-            .device_type(
-                item.device_type.enum_value().map_err(|_| "Failed to convert device_type")?.into(),
-            )
-            .ranging_round_usage(
-                item.ranging_round_usage
-                    .enum_value()
-                    .map_err(|_| "Failed to convert ranging_round_usage")?
-                    .into(),
-            )
-            .sts_config(
-                item.sts_config.enum_value().map_err(|_| "Failed to convert sts_config")?.into(),
-            )
-            .multi_node_mode(
-                item.multi_node_mode
-                    .enum_value()
-                    .map_err(|_| "Failed to convert multi_node_mode")?
-                    .into(),
-            )
-            .channel_number(
-                item.channel_number
-                    .enum_value()
-                    .map_err(|_| "Failed to convert channel_number")?
-                    .into(),
-            )
-            .device_mac_address(device_mac_address)
-            .dst_mac_address(dst_mac_address)
-            .slot_duration_rstu(
-                item.slot_duration_rstu
-                    .try_into()
-                    .map_err(|_| "Failed to convert slot_duration_rstu")?,
-            )
-            .ranging_duration_ms(item.ranging_duration_ms)
-            .mac_fcs_type(
-                item.mac_fcs_type
-                    .enum_value()
-                    .map_err(|_| "Failed to convert mac_fcs_type")?
-                    .into(),
-            )
-            .ranging_round_control(
-                item.ranging_round_control.take().ok_or("ranging_round_control is empty")?.into(),
-            )
-            .aoa_result_request(
-                item.aoa_result_request
-                    .enum_value()
-                    .map_err(|_| "Failed to convert aoa_result_request")?
-                    .into(),
-            )
-            .range_data_ntf_config(
-                item.range_data_ntf_config
-                    .enum_value()
-                    .map_err(|_| "Failed to convert range_data_ntf_config")?
-                    .into(),
-            )
-            .range_data_ntf_proximity_near_cm(
-                item.range_data_ntf_proximity_near_cm
-                    .try_into()
-                    .map_err(|_| "Failed to convert range_data_ntf_proximity_near_cm")?,
-            )
-            .range_data_ntf_proximity_far_cm(
-                item.range_data_ntf_proximity_far_cm
-                    .try_into()
-                    .map_err(|_| "Failed to convert range_data_ntf_proximity_far_cm")?,
-            )
-            .device_role(
-                item.device_role.enum_value().map_err(|_| "Failed to convert device_role")?.into(),
-            )
-            .rframe_config(
-                item.rframe_config
-                    .enum_value()
-                    .map_err(|_| "Failed to convert rframe_config")?
-                    .into(),
-            )
-            .preamble_code_index(
-                item.preamble_code_index
-                    .try_into()
-                    .map_err(|_| "Failed to convert preamble_code_index")?,
-            )
-            .sfd_id(item.sfd_id.try_into().map_err(|_| "Failed to convert sfd_id")?)
-            .psdu_data_rate(
-                item.psdu_data_rate
-                    .enum_value()
-                    .map_err(|_| "Failed to convert psdu_data_rate")?
-                    .into(),
-            )
-            .preamble_duration(
-                item.preamble_duration
-                    .enum_value()
-                    .map_err(|_| "Failed to convert preamble_duration")?
-                    .into(),
-            )
-            .ranging_time_struct(
-                item.ranging_time_struct
-                    .enum_value()
-                    .map_err(|_| "Failed to convert ranging_time_struct")?
-                    .into(),
-            )
-            .slots_per_rr(
-                item.slots_per_rr.try_into().map_err(|_| "Failed to convert slots_per_rr")?,
-            )
-            .tx_adaptive_payload_power(
-                item.tx_adaptive_payload_power
-                    .enum_value()
-                    .map_err(|_| "Failed to convert tx_adaptive_payload_power")?
-                    .into(),
-            )
-            .responder_slot_index(
-                item.responder_slot_index
-                    .try_into()
-                    .map_err(|_| "Failed to convert responder_slot_index")?,
-            )
-            .prf_mode(item.prf_mode.enum_value().map_err(|_| "Failed to convert prf_mode")?.into())
-            .scheduled_mode(
-                item.scheduled_mode
-                    .enum_value()
-                    .map_err(|_| "Failed to convert scheduled_mode")?
-                    .into(),
-            )
-            .key_rotation(
-                item.key_rotation
-                    .enum_value()
-                    .map_err(|_| "Failed to convert key_rotation")?
-                    .into(),
-            )
-            .key_rotation_rate(
-                item.key_rotation_rate
-                    .try_into()
-                    .map_err(|_| "Failed to convert key_rotation_rate")?,
-            )
-            .session_priority(
-                item.session_priority
-                    .try_into()
-                    .map_err(|_| "Failed to convert session_priority")?,
-            )
-            .mac_address_mode(
-                item.mac_address_mode
-                    .enum_value()
-                    .map_err(|_| "Failed to convert mac_address_mode")?
-                    .into(),
-            )
-            .vendor_id(
-                item.vendor_id.clone().try_into().map_err(|_| "Failed to convert vendor_id")?,
-            )
-            .static_sts_iv(
-                item.static_sts_iv
-                    .clone()
-                    .try_into()
-                    .map_err(|_| "Failed to convert static_sts_iv")?,
-            )
-            .number_of_sts_segments(
-                item.number_of_sts_segments
-                    .try_into()
-                    .map_err(|_| "Failed to convert number_of_sts_segments")?,
-            )
-            .max_rr_retry(
-                item.max_rr_retry.try_into().map_err(|_| "Failed to convert max_rr_retry")?,
-            )
-            .uwb_initiation_time_ms(item.uwb_initiation_time_ms)
-            .hopping_mode(item.hopping_mode.unwrap().into())
-            .block_stride_length(
-                item.block_stride_length
-                    .try_into()
-                    .map_err(|_| "Failed to convert block_stride_length")?,
-            )
-            .result_report_config(
-                item.result_report_config.take().ok_or("ranging_round_control is empty")?.into(),
-            )
-            .in_band_termination_attempt_count(
-                item.in_band_termination_attempt_count
-                    .try_into()
-                    .map_err(|_| "Failed to convert in_band_termination_attempt_count")?,
-            )
-            .sub_session_id(item.sub_session_id)
-            .bprf_phr_data_rate(
-                item.bprf_phr_data_rate
-                    .enum_value()
-                    .map_err(|_| "Failed to convert bprf_phr_data_rate")?
-                    .into(),
-            )
-            .max_number_of_measurements(
-                item.max_number_of_measurements
-                    .try_into()
-                    .map_err(|_| "Failed to convert max_number_of_measurements")?,
-            )
-            .sts_length(
-                item.sts_length.enum_value().map_err(|_| "Failed to convert sts_length")?.into(),
-            )
-            .number_of_range_measurements(
-                item.number_of_range_measurements
-                    .try_into()
-                    .map_err(|_| "Failed to convert number_of_range_measurements")?,
-            )
-            .number_of_aoa_azimuth_measurements(
-                item.number_of_aoa_azimuth_measurements
-                    .try_into()
-                    .map_err(|_| "Failed to convert number_of_aoa_azimuth_measurements")?,
-            )
-            .number_of_aoa_elevation_measurements(
-                item.number_of_aoa_elevation_measurements
-                    .try_into()
-                    .map_err(|_| "Failed to convert number_of_aoa_elevation_measurements")?,
-            );
-
-        Ok(builder.build().ok_or("Failed to build FiraAppConfigParam from builder")?)
-    }
-}
-
-impl Drop for ProtoFiraAppConfigParams {
-    fn drop(&mut self) {
-        // Zero out the sensitive data before releasing memory.
-        self.vendor_id.zeroize();
-        self.static_sts_iv.zeroize();
-        self.sub_session_id.zeroize();
-    }
-}
diff --git a/src/rust/uwb_core/src/proto/utils.rs b/src/rust/uwb_core/src/proto/utils.rs
deleted file mode 100644
index e1ffc9e..0000000
--- a/src/rust/uwb_core/src/proto/utils.rs
+++ /dev/null
@@ -1,36 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Provide the conversion between the elements of uwb_core and protobuf.
-
-use log::error;
-use protobuf::Message;
-
-use crate::error::{Error, Result};
-
-/// Convert the protobuf message to a byte buffers. Return dbus::MethodErr when conversion fails.
-pub fn write_to_bytes<M: Message>(msg: &M) -> Result<Vec<u8>> {
-    msg.write_to_bytes().map_err(|e| {
-        error!("Failed to write protobuf {} to bytes: {:?}", M::NAME, e);
-        Error::Unknown
-    })
-}
-
-/// Parse the byte buffer to the protobuf message. Return dbus::MethodErr when failed to parse.
-pub fn parse_from_bytes<M: Message>(bytes: &[u8]) -> Result<M> {
-    M::parse_from_bytes(bytes).map_err(|e| {
-        error!("Failed to parse {:?}: {:?}", M::NAME, e);
-        Error::BadParameters
-    })
-}
diff --git a/src/rust/uwb_core/src/service.rs b/src/rust/uwb_core/src/service.rs
deleted file mode 100644
index 979cad2..0000000
--- a/src/rust/uwb_core/src/service.rs
+++ /dev/null
@@ -1,33 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module provides the public interface of the UWB core library.
-
-#[cfg(feature = "proto")]
-pub mod proto_uwb_service;
-pub mod uwb_service;
-pub mod uwb_service_builder;
-pub mod uwb_service_callback_builder;
-
-#[cfg(test)]
-mod mock_uwb_service_callback;
-
-// Re-export the public elements.
-#[cfg(feature = "proto")]
-pub use proto_uwb_service::{ProtoUwbService, ProtoUwbServiceCallback};
-pub use uwb_service::{
-    NopUwbServiceCallback, UwbService, UwbServiceCallback, UwbServiceCallbackBuilder,
-};
-pub use uwb_service_builder::{default_runtime, UwbServiceBuilder};
-pub use uwb_service_callback_builder::UwbServiceCallbackSendBuilder;
diff --git a/src/rust/uwb_core/src/service/mock_uwb_service_callback.rs b/src/rust/uwb_core/src/service/mock_uwb_service_callback.rs
deleted file mode 100644
index 12f182f..0000000
--- a/src/rust/uwb_core/src/service/mock_uwb_service_callback.rs
+++ /dev/null
@@ -1,130 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::collections::VecDeque;
-use std::sync::{Arc, Mutex};
-
-use tokio::sync::Notify;
-use tokio::time::{timeout, Duration};
-
-use crate::params::{DeviceState, ReasonCode, SessionId, SessionState};
-use crate::service::uwb_service::UwbServiceCallback;
-use crate::uci::SessionRangeData;
-
-#[derive(Clone, Default)]
-pub(crate) struct MockUwbServiceCallback {
-    expected_calls: Arc<Mutex<VecDeque<ExpectedCall>>>,
-    expect_call_consumed: Arc<Notify>,
-}
-
-impl MockUwbServiceCallback {
-    pub fn new() -> Self {
-        Default::default()
-    }
-
-    pub fn expect_on_service_reset(&mut self, success: bool) {
-        self.push_expected_call(ExpectedCall::ServiceReset { success });
-    }
-
-    pub fn expect_on_uci_device_status_changed(&mut self, state: DeviceState) {
-        self.push_expected_call(ExpectedCall::UciDeviceStatus { state });
-    }
-
-    pub fn expect_on_session_state_changed(
-        &mut self,
-        session_id: SessionId,
-        session_state: SessionState,
-        reason_code: ReasonCode,
-    ) {
-        self.push_expected_call(ExpectedCall::SessionState {
-            session_id,
-            session_state,
-            reason_code,
-        });
-    }
-
-    pub fn expect_on_range_data_received(
-        &mut self,
-        session_id: SessionId,
-        range_data: SessionRangeData,
-    ) {
-        self.push_expected_call(ExpectedCall::RangeData { session_id, range_data });
-    }
-
-    pub fn expect_on_vendor_notification_received(&mut self, gid: u32, oid: u32, payload: Vec<u8>) {
-        self.push_expected_call(ExpectedCall::VendorNotification { gid, oid, payload });
-    }
-
-    pub async fn wait_expected_calls_done(&mut self) -> bool {
-        while !self.expected_calls.lock().unwrap().is_empty() {
-            if timeout(Duration::from_secs(1), self.expect_call_consumed.notified()).await.is_err()
-            {
-                return false;
-            }
-        }
-        true
-    }
-
-    fn push_expected_call(&mut self, call: ExpectedCall) {
-        self.expected_calls.lock().unwrap().push_back(call);
-    }
-
-    fn pop_expected_call(&mut self) -> ExpectedCall {
-        let call = self.expected_calls.lock().unwrap().pop_front().unwrap();
-        self.expect_call_consumed.notify_one();
-        call
-    }
-}
-
-impl UwbServiceCallback for MockUwbServiceCallback {
-    fn on_service_reset(&mut self, success: bool) {
-        assert_eq!(self.pop_expected_call(), ExpectedCall::ServiceReset { success });
-    }
-
-    fn on_uci_device_status_changed(&mut self, state: DeviceState) {
-        assert_eq!(self.pop_expected_call(), ExpectedCall::UciDeviceStatus { state });
-    }
-
-    fn on_session_state_changed(
-        &mut self,
-        session_id: SessionId,
-        session_state: SessionState,
-        reason_code: ReasonCode,
-    ) {
-        assert_eq!(
-            self.pop_expected_call(),
-            ExpectedCall::SessionState { session_id, session_state, reason_code }
-        );
-    }
-
-    fn on_range_data_received(&mut self, session_id: SessionId, range_data: SessionRangeData) {
-        assert_eq!(self.pop_expected_call(), ExpectedCall::RangeData { session_id, range_data });
-    }
-
-    fn on_vendor_notification_received(&mut self, gid: u32, oid: u32, payload: Vec<u8>) {
-        assert_eq!(
-            self.pop_expected_call(),
-            ExpectedCall::VendorNotification { gid, oid, payload }
-        );
-    }
-}
-
-#[derive(PartialEq, Debug)]
-pub(crate) enum ExpectedCall {
-    ServiceReset { success: bool },
-    UciDeviceStatus { state: DeviceState },
-    SessionState { session_id: SessionId, session_state: SessionState, reason_code: ReasonCode },
-    RangeData { session_id: SessionId, range_data: SessionRangeData },
-    VendorNotification { gid: u32, oid: u32, payload: Vec<u8> },
-}
diff --git a/src/rust/uwb_core/src/service/proto_uwb_service.rs b/src/rust/uwb_core/src/service/proto_uwb_service.rs
deleted file mode 100644
index 7c1362b..0000000
--- a/src/rust/uwb_core/src/service/proto_uwb_service.rs
+++ /dev/null
@@ -1,360 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module provides a thin adapter of UwbService and UwbServiceCallback that encodes the
-//! arguments to protobuf.
-
-use log::{debug, error};
-use protobuf::EnumOrUnknown;
-
-use crate::error::{Error, Result};
-use crate::params::{AppConfigParams, DeviceState, ReasonCode, SessionId, SessionState};
-use crate::proto::bindings::{
-    AndroidGetPowerStatsResponse, AndroidSetCountryCodeRequest, AndroidSetCountryCodeResponse,
-    DeinitSessionRequest, DeinitSessionResponse, DisableResponse, EnableResponse,
-    InitSessionRequest, InitSessionResponse, RangeDataReceivedSignal, ReconfigureRequest,
-    ReconfigureResponse, SendVendorCmdRequest, SendVendorCmdResponse, ServiceResetSignal,
-    SessionParamsRequest, SessionParamsResponse, SessionStateChangedSignal, SetLoggerModeRequest,
-    SetLoggerModeResponse, StartRangingRequest, StartRangingResponse, Status as ProtoStatus,
-    StopRangingRequest, StopRangingResponse, UciDeviceStatusChangedSignal,
-    UpdateControllerMulticastListRequest, UpdateControllerMulticastListResponse,
-    VendorNotificationReceivedSignal,
-};
-use crate::proto::utils::{parse_from_bytes, write_to_bytes};
-use crate::service::uwb_service::{UwbService, UwbServiceCallback};
-use crate::uci::notification::SessionRangeData;
-
-/// A thin adapter of UwbService. The argument and the response of each method are protobuf-encoded
-/// buffer. The definition of the protobuf is at protos/uwb_core_protos.proto.
-///
-/// For the naming of the protobuf struct, the argument of a method `do_something()` will be called
-/// `DoSomethingRequest`, and the result will be called `DoSomethingResponse`.
-pub struct ProtoUwbService {
-    service: UwbService,
-}
-
-impl ProtoUwbService {
-    /// Create a ProtoUwbService.
-    pub fn new(service: UwbService) -> Self {
-        Self { service }
-    }
-
-    /// Set UCI log mode.
-    pub fn set_logger_mode(&self, request: &[u8]) -> Result<Vec<u8>> {
-        let request = parse_from_bytes::<SetLoggerModeRequest>(request)?;
-        let mut resp = SetLoggerModeResponse::new();
-        let res = self.service.set_logger_mode(
-            request
-                .logger_mode
-                .enum_value()
-                .map_err(|e| {
-                    error!("Failed to convert logger_mode: {e}");
-                    Error::BadParameters
-                })?
-                .into(),
-        );
-        resp.status = Into::<crate::proto::bindings::Status>::into(res).into();
-        write_to_bytes(&resp)
-    }
-
-    /// Enable the UWB service.
-    pub fn enable(&self) -> Result<Vec<u8>> {
-        let mut resp = EnableResponse::new();
-        resp.status = EnumOrUnknown::new(self.service.enable().into());
-        write_to_bytes(&resp)
-    }
-
-    /// Disable the UWB service.
-    pub fn disable(&self) -> Result<Vec<u8>> {
-        let mut resp = DisableResponse::new();
-        resp.status = EnumOrUnknown::new(self.service.disable().into());
-        write_to_bytes(&resp)
-    }
-
-    /// Initialize a new ranging session with the given parameters.
-    ///
-    /// Note: Currently the protobuf only support Fira parameters, but not support CCC parameters.
-    pub fn init_session(&self, request: &[u8]) -> Result<Vec<u8>> {
-        let mut request = parse_from_bytes::<InitSessionRequest>(request)?;
-        let params = request
-            .params
-            .take()
-            .ok_or_else(|| {
-                error!("InitSessionRequest.params is empty");
-                Error::BadParameters
-            })?
-            .try_into()
-            .map_err(|e| {
-                error!("Failed to convert to AppConfigParams: {}", e);
-                Error::BadParameters
-            })?;
-
-        let mut resp = InitSessionResponse::new();
-        resp.status = EnumOrUnknown::new(
-            self.service
-                .init_session(
-                    request.session_id,
-                    request
-                        .session_type
-                        .enum_value()
-                        .map_err(|e| {
-                            error!("Failed to convert session_type: {:?}", e);
-                            Error::BadParameters
-                        })?
-                        .into(),
-                    params,
-                )
-                .into(),
-        );
-        write_to_bytes(&resp)
-    }
-
-    /// Destroy the session.
-    pub fn deinit_session(&self, request: &[u8]) -> Result<Vec<u8>> {
-        let request = parse_from_bytes::<DeinitSessionRequest>(request)?;
-        let mut resp = DeinitSessionResponse::new();
-        resp.status = EnumOrUnknown::new(self.service.deinit_session(request.session_id).into());
-        write_to_bytes(&resp)
-    }
-
-    /// Start ranging of the session.
-    pub fn start_ranging(&self, request: &[u8]) -> Result<Vec<u8>> {
-        let request = parse_from_bytes::<StartRangingRequest>(request)?;
-        // Currently we only support FiRa session, not CCC. For FiRa session, the returned
-        // AppConfigParams is the same as the configured one before start_ranging(). Therefore, we
-        // don't reply the AppConfigParams received from uwb_core.
-        let mut resp = StartRangingResponse::new();
-        resp.status = EnumOrUnknown::new(self.service.start_ranging(request.session_id).into());
-        write_to_bytes(&resp)
-    }
-
-    /// Stop ranging.
-    pub fn stop_ranging(&self, request: &[u8]) -> Result<Vec<u8>> {
-        let request = parse_from_bytes::<StopRangingRequest>(request)?;
-        let mut resp = StopRangingResponse::new();
-        resp.status = EnumOrUnknown::new(self.service.stop_ranging(request.session_id).into());
-        write_to_bytes(&resp)
-    }
-
-    /// Reconfigure the parameters of the session.
-    pub fn reconfigure(&self, request: &[u8]) -> Result<Vec<u8>> {
-        let mut request = parse_from_bytes::<ReconfigureRequest>(request)?;
-        let params = request
-            .params
-            .take()
-            .ok_or_else(|| {
-                error!("ReconfigureRequest.params is empty");
-                Error::BadParameters
-            })?
-            .try_into()
-            .map_err(|e| {
-                error!("Failed to convert to AppConfigParams: {}", e);
-                Error::BadParameters
-            })?;
-
-        let mut resp = ReconfigureResponse::new();
-        resp.status =
-            EnumOrUnknown::new(self.service.reconfigure(request.session_id, params).into());
-        write_to_bytes(&resp)
-    }
-
-    /// Update the list of the controlees to the ongoing session.
-    pub fn update_controller_multicast_list(&self, request: &[u8]) -> Result<Vec<u8>> {
-        let request = parse_from_bytes::<UpdateControllerMulticastListRequest>(request)?;
-        let mut controlees = vec![];
-        for controlee in request.controlees.into_iter() {
-            let controlee = controlee.try_into().map_err(|e| {
-                error!("Failed to convert Controlee: {:?}", e);
-                Error::BadParameters
-            })?;
-            controlees.push(controlee);
-        }
-
-        let mut resp = UpdateControllerMulticastListResponse::new();
-        resp.status = EnumOrUnknown::new(
-            self.service
-                .update_controller_multicast_list(
-                    request.session_id,
-                    request
-                        .action
-                        .enum_value()
-                        .map_err(|e| {
-                            error!("Failed to convert action: {:?}", e);
-                            Error::BadParameters
-                        })?
-                        .into(),
-                    controlees,
-                )
-                .into(),
-        );
-        write_to_bytes(&resp)
-    }
-
-    /// Set the country code. Android-specific method.
-    pub fn android_set_country_code(&self, request: &[u8]) -> Result<Vec<u8>> {
-        let request = parse_from_bytes::<AndroidSetCountryCodeRequest>(request)?;
-        let country_code = request.country_code.try_into()?;
-
-        let mut resp = AndroidSetCountryCodeResponse::new();
-        resp.status =
-            EnumOrUnknown::new(self.service.android_set_country_code(country_code).into());
-        write_to_bytes(&resp)
-    }
-
-    /// Get the power statistics. Android-specific method.
-    pub fn android_get_power_stats(&self) -> Result<Vec<u8>> {
-        let mut resp = AndroidGetPowerStatsResponse::new();
-        match self.service.android_get_power_stats() {
-            Ok(power_stats) => {
-                resp.status = EnumOrUnknown::new(Ok(()).into());
-                resp.power_stats = Some(power_stats.into()).into();
-            }
-            Err(e) => {
-                let err: Result<()> = Err(e);
-                resp.status = crate::proto::bindings::Status::from(err).into();
-            }
-        }
-        write_to_bytes(&resp)
-    }
-
-    /// Send a raw UCI message.
-    pub fn raw_uci_cmd(&self, request: &[u8]) -> Result<Vec<u8>> {
-        let request = parse_from_bytes::<SendVendorCmdRequest>(request)?;
-        let mut resp = SendVendorCmdResponse::new();
-        match self.service.raw_uci_cmd(request.mt, request.gid, request.oid, request.payload) {
-            Ok(msg) => {
-                resp.status = EnumOrUnknown::new(Ok(()).into());
-                resp.gid = msg.gid;
-                resp.oid = msg.oid;
-                resp.payload = msg.payload;
-            }
-            Err(e) => {
-                let err: Result<()> = Err(e);
-                resp.status = (Into::<crate::proto::bindings::Status>::into(err)).into();
-            }
-        }
-        write_to_bytes(&resp)
-    }
-
-    /// Get app config params for the given session id
-    pub fn session_params(&self, request: &[u8]) -> Result<Vec<u8>> {
-        let request = parse_from_bytes::<SessionParamsRequest>(request)?;
-        let mut resp = SessionParamsResponse::new();
-        match self.service.session_params(request.session_id) {
-            Ok(AppConfigParams::Fira(params)) => {
-                resp.status =
-                    EnumOrUnknown::from(Into::<crate::proto::bindings::Status>::into(Ok(())));
-                resp.params = Some(params.into()).into();
-            }
-            Ok(params) => {
-                error!("Received non-Fira session parameters: {:?}", params);
-                resp.status = ProtoStatus::UNKNOWN.into();
-            }
-            Err(e) => {
-                let err: Result<()> = Err(e);
-                resp.status = Into::<crate::proto::bindings::Status>::into(err).into();
-            }
-        }
-        write_to_bytes(&resp)
-    }
-}
-
-/// The trait that provides the same callbacks of UwbServiceCallback. It has the blanket
-/// implementation of UwbServiceCallback trait that converts the arguments to one protobuf-encoded
-/// payload.
-///
-/// For the naming of the protobuf struct, the payload of a callback `on_something_happened()`
-/// will be called `SomethingHappenedSignal`.
-pub trait ProtoUwbServiceCallback: 'static {
-    /// Notify the UWB service has been reset due to internal error. All the sessions are closed.
-    fn on_service_reset(&mut self, payload: Vec<u8>);
-    /// Notify the status of the UCI device.
-    fn on_uci_device_status_changed(&mut self, payload: Vec<u8>);
-    /// Notify the state of the session is changed.
-    fn on_session_state_changed(&mut self, payload: Vec<u8>);
-    /// Notify the ranging data of the session is received.
-    fn on_range_data_received(&mut self, payload: Vec<u8>);
-    /// Notify the vendor notification is received.
-    fn on_vendor_notification_received(&mut self, payload: Vec<u8>);
-}
-
-impl<C: ProtoUwbServiceCallback> UwbServiceCallback for C {
-    fn on_service_reset(&mut self, success: bool) {
-        debug!("UwbService is reset, success: {}", success);
-        let mut msg = ServiceResetSignal::new();
-        msg.success = success;
-        if let Ok(payload) = write_to_bytes(&msg) {
-            ProtoUwbServiceCallback::on_service_reset(self, payload);
-        } else {
-            error!("Failed to call on_service_reset()");
-        }
-    }
-
-    fn on_uci_device_status_changed(&mut self, state: DeviceState) {
-        debug!("UCI device status is changed: {:?}", state);
-        let mut msg = UciDeviceStatusChangedSignal::new();
-        msg.state = EnumOrUnknown::new(state.into());
-        if let Ok(payload) = write_to_bytes(&msg) {
-            ProtoUwbServiceCallback::on_uci_device_status_changed(self, payload);
-        } else {
-            error!("Failed to call on_uci_device_status_changed()");
-        }
-    }
-
-    fn on_session_state_changed(
-        &mut self,
-        session_id: SessionId,
-        session_state: SessionState,
-        reason_code: ReasonCode,
-    ) {
-        debug!(
-            "Session {:?}'s state is changed to {:?}, reason: {:?}",
-            session_id, session_state, reason_code
-        );
-        let mut msg = SessionStateChangedSignal::new();
-        msg.session_id = session_id;
-        msg.session_state = EnumOrUnknown::new(session_state.into());
-        msg.reason_code = EnumOrUnknown::new(reason_code.into());
-        if let Ok(payload) = write_to_bytes(&msg) {
-            ProtoUwbServiceCallback::on_session_state_changed(self, payload);
-        } else {
-            error!("Failed to call on_session_state_changed()");
-        }
-    }
-
-    fn on_range_data_received(&mut self, session_id: SessionId, range_data: SessionRangeData) {
-        debug!("Received range data {:?} from Session {:?}", range_data, session_id);
-        let mut msg = RangeDataReceivedSignal::new();
-        msg.session_id = session_id;
-        msg.range_data = Some(range_data.into()).into();
-        if let Ok(payload) = write_to_bytes(&msg) {
-            ProtoUwbServiceCallback::on_range_data_received(self, payload);
-        } else {
-            error!("Failed to call on_range_data_received()");
-        }
-    }
-
-    fn on_vendor_notification_received(&mut self, gid: u32, oid: u32, payload: Vec<u8>) {
-        debug!("Received vendor notification: gid={}, oid={}, payload={:?}", gid, oid, payload);
-        let mut msg = VendorNotificationReceivedSignal::new();
-        msg.gid = gid;
-        msg.oid = oid;
-        msg.payload = payload;
-        if let Ok(payload) = write_to_bytes(&msg) {
-            ProtoUwbServiceCallback::on_vendor_notification_received(self, payload);
-        } else {
-            error!("Failed to call on_vendor_notification_received()");
-        }
-    }
-}
diff --git a/src/rust/uwb_core/src/service/uwb_service.rs b/src/rust/uwb_core/src/service/uwb_service.rs
deleted file mode 100644
index 012fbda..0000000
--- a/src/rust/uwb_core/src/service/uwb_service.rs
+++ /dev/null
@@ -1,865 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module defines the UwbService and its related components.
-
-use log::{debug, error, warn};
-use tokio::runtime::{Builder, Handle};
-use tokio::sync::{mpsc, oneshot};
-use tokio::task;
-
-use crate::error::{Error, Result};
-use crate::params::app_config_params::AppConfigParams;
-use crate::params::uci_packets::{
-    Controlee, CountryCode, DeviceState, PowerStats, RawUciMessage, ReasonCode, SessionId,
-    SessionState, SessionType, UpdateMulticastListAction,
-};
-use crate::session::session_manager::{SessionManager, SessionNotification};
-use crate::uci::notification::{CoreNotification, SessionRangeData};
-use crate::uci::uci_logger::UciLoggerMode;
-use crate::uci::uci_manager::UciManager;
-use crate::utils::clean_mpsc_receiver;
-
-/// Callback builder
-pub trait UwbServiceCallbackBuilder<C: UwbServiceCallback>: 'static + Send {
-    /// Builds UwbServiceCallback. The build operation Consumes Builder.
-    fn build(self) -> Option<C>;
-}
-
-/// The callback of the UwbService which is used to send the notification to UwbService's caller.
-pub trait UwbServiceCallback: 'static {
-    /// Notify the UWB service has been reset due to internal error. All the sessions are closed.
-    /// `success` indicates the reset is successful or not.
-    fn on_service_reset(&mut self, success: bool);
-
-    /// Notify the status of the UCI device.
-    fn on_uci_device_status_changed(&mut self, state: DeviceState);
-
-    /// Notify the state of the session with the id |session_id| is changed.
-    fn on_session_state_changed(
-        &mut self,
-        session_id: SessionId,
-        session_state: SessionState,
-        reason_code: ReasonCode,
-    );
-
-    /// Notify the ranging data of the session with the id |session_id| is received.
-    fn on_range_data_received(&mut self, session_id: SessionId, range_data: SessionRangeData);
-
-    /// Notify the vendor notification is received.
-    fn on_vendor_notification_received(&mut self, gid: u32, oid: u32, payload: Vec<u8>);
-
-    // TODO(b/270443790): In the future, add a callback here to notify the Data Rx packet.
-}
-
-/// A placeholder implementation for UwbServiceCallback that does nothing.
-pub struct NopUwbServiceCallback {}
-impl UwbServiceCallback for NopUwbServiceCallback {
-    fn on_service_reset(&mut self, _success: bool) {}
-    fn on_uci_device_status_changed(&mut self, _state: DeviceState) {}
-    fn on_session_state_changed(
-        &mut self,
-        _session_id: SessionId,
-        _session_state: SessionState,
-        _reason_code: ReasonCode,
-    ) {
-    }
-    fn on_range_data_received(&mut self, _session_id: SessionId, _range_data: SessionRangeData) {}
-    fn on_vendor_notification_received(&mut self, _gid: u32, _oid: u32, _payload: Vec<u8>) {}
-}
-
-/// The entry class (a.k.a top shim) of the core library. The class accepts requests from the
-/// client, and delegates the requests to other components. It should provide the
-/// backward-compatible interface for the client of the library.
-pub struct UwbService {
-    /// The handle of the working runtime. All the commands are executed inside the runtime.
-    ///
-    /// Note that the caller should guarantee that the working runtime outlives the UwbService.
-    runtime_handle: Handle,
-    /// Used to send the command to UwbServiceActor.
-    cmd_sender: mpsc::UnboundedSender<(Command, ResponseSender)>,
-}
-
-impl UwbService {
-    /// Create a new UwbService instance.
-    pub(super) fn new<C, B, U>(
-        runtime_handle: Handle,
-        callback_builder: B,
-        uci_manager: U,
-    ) -> Option<Self>
-    where
-        C: UwbServiceCallback,
-        B: UwbServiceCallbackBuilder<C>,
-        U: UciManager,
-    {
-        let (cmd_sender, cmd_receiver) = mpsc::unbounded_channel();
-        let (service_status_sender, mut service_status_receiver) =
-            mpsc::unbounded_channel::<bool>();
-        std::thread::spawn(move || {
-            let actor_runtime = match Builder::new_current_thread().enable_all().build() {
-                Ok(ar) => ar,
-                Err(err) => {
-                    error!("Failed to build Tokio Runtime! {:?}", err);
-                    // unwrap safe since receiver is in scope
-                    service_status_sender.send(false).unwrap();
-                    return;
-                }
-            };
-
-            let callback = match callback_builder.build() {
-                Some(cb) => {
-                    // unwrap safe since receiver is in scope
-                    service_status_sender.send(true).unwrap();
-                    cb
-                }
-                None => {
-                    error!("Unable to build callback");
-                    service_status_sender.send(false).unwrap();
-                    return;
-                }
-            };
-
-            let mut actor = UwbServiceActor::new(cmd_receiver, callback, uci_manager);
-            let local = task::LocalSet::new();
-            local.spawn_local(async move {
-                task::spawn_local(async move { actor.run().await }).await.unwrap();
-            });
-            actor_runtime.block_on(local);
-        });
-
-        match service_status_receiver.blocking_recv() {
-            Some(true) => Some(Self { runtime_handle, cmd_sender }),
-            _ => None,
-        }
-    }
-
-    /// Set UCI log mode.
-    pub fn set_logger_mode(&self, logger_mode: UciLoggerMode) -> Result<()> {
-        self.block_on_cmd(Command::SetLoggerMode { logger_mode })?;
-        Ok(())
-    }
-
-    /// Enable the UWB service.
-    pub fn enable(&self) -> Result<()> {
-        self.block_on_cmd(Command::Enable)?;
-        Ok(())
-    }
-
-    /// Disable the UWB service.
-    pub fn disable(&self) -> Result<()> {
-        self.block_on_cmd(Command::Disable)?;
-        Ok(())
-    }
-
-    /// Initialize a new ranging session with the given parameters.
-    pub fn init_session(
-        &self,
-        session_id: SessionId,
-        session_type: SessionType,
-        params: AppConfigParams,
-    ) -> Result<()> {
-        self.block_on_cmd(Command::InitSession { session_id, session_type, params })?;
-        Ok(())
-    }
-
-    /// Destroy the session.
-    pub fn deinit_session(&self, session_id: SessionId) -> Result<()> {
-        self.block_on_cmd(Command::DeinitSession { session_id })?;
-        Ok(())
-    }
-
-    /// Start ranging of the session.
-    pub fn start_ranging(&self, session_id: SessionId) -> Result<AppConfigParams> {
-        match self.block_on_cmd(Command::StartRanging { session_id })? {
-            Response::AppConfigParams(params) => Ok(params),
-            _ => panic!("start_ranging() should return AppConfigParams"),
-        }
-    }
-
-    /// Stop ranging.
-    pub fn stop_ranging(&self, session_id: SessionId) -> Result<()> {
-        self.block_on_cmd(Command::StopRanging { session_id })?;
-        Ok(())
-    }
-
-    /// Reconfigure the parameters of the session.
-    pub fn reconfigure(&self, session_id: SessionId, params: AppConfigParams) -> Result<()> {
-        self.block_on_cmd(Command::Reconfigure { session_id, params })?;
-        Ok(())
-    }
-
-    /// Update the list of the controlees to the ongoing session.
-    pub fn update_controller_multicast_list(
-        &self,
-        session_id: SessionId,
-        action: UpdateMulticastListAction,
-        controlees: Vec<Controlee>,
-    ) -> Result<()> {
-        self.block_on_cmd(Command::UpdateControllerMulticastList {
-            session_id,
-            action,
-            controlees,
-        })?;
-        Ok(())
-    }
-
-    /// Set the country code. Android-specific method.
-    pub fn android_set_country_code(&self, country_code: CountryCode) -> Result<()> {
-        self.block_on_cmd(Command::AndroidSetCountryCode { country_code })?;
-        Ok(())
-    }
-
-    /// Get the power statistics. Android-specific method.
-    pub fn android_get_power_stats(&self) -> Result<PowerStats> {
-        match self.block_on_cmd(Command::AndroidGetPowerStats)? {
-            Response::PowerStats(stats) => Ok(stats),
-            _ => panic!("android_get_power_stats() should return PowerStats"),
-        }
-    }
-
-    /// Send a raw UCI message.
-    pub fn raw_uci_cmd(
-        &self,
-        mt: u32,
-        gid: u32,
-        oid: u32,
-        payload: Vec<u8>,
-    ) -> Result<RawUciMessage> {
-        match self.block_on_cmd(Command::RawUciCmd { mt, gid, oid, payload })? {
-            Response::RawUciMessage(msg) => Ok(msg),
-            _ => panic!("raw_uci_cmd() should return RawUciMessage"),
-        }
-    }
-
-    /// Get app config params for the given session id
-    pub fn session_params(&self, session_id: SessionId) -> Result<AppConfigParams> {
-        match self.block_on_cmd(Command::GetParams { session_id })? {
-            Response::AppConfigParams(params) => Ok(params),
-            _ => panic!("session_params() should return AppConfigParams"),
-        }
-    }
-
-    /// Send the |cmd| to UwbServiceActor and wait until receiving the response.
-    fn block_on_cmd(&self, cmd: Command) -> Result<Response> {
-        let (result_sender, result_receiver) = oneshot::channel();
-        self.cmd_sender.send((cmd, result_sender)).map_err(|cmd| {
-            error!("Failed to send cmd: {:?}", cmd.0);
-            Error::Unknown
-        })?;
-
-        self.runtime_handle.block_on(async move {
-            result_receiver.await.unwrap_or_else(|e| {
-                error!("Failed to receive the result for cmd: {:?}", e);
-                Err(Error::Unknown)
-            })
-        })
-    }
-
-    /// Run an future task on the runtime. This method is only exposed for the testing.
-    #[cfg(test)]
-    fn block_on_for_testing<F: std::future::Future>(&self, future: F) -> F::Output {
-        self.runtime_handle.block_on(future)
-    }
-}
-
-struct UwbServiceActor<C: UwbServiceCallback, U: UciManager> {
-    cmd_receiver: mpsc::UnboundedReceiver<(Command, ResponseSender)>,
-    callback: C,
-    uci_manager: U,
-    session_manager: Option<SessionManager>,
-    core_notf_receiver: mpsc::UnboundedReceiver<CoreNotification>,
-    session_notf_receiver: mpsc::UnboundedReceiver<SessionNotification>,
-    vendor_notf_receiver: mpsc::UnboundedReceiver<RawUciMessage>,
-}
-
-impl<C: UwbServiceCallback, U: UciManager> UwbServiceActor<C, U> {
-    fn new(
-        cmd_receiver: mpsc::UnboundedReceiver<(Command, ResponseSender)>,
-        callback: C,
-        uci_manager: U,
-    ) -> Self {
-        Self {
-            cmd_receiver,
-            callback,
-            uci_manager,
-            session_manager: None,
-            core_notf_receiver: mpsc::unbounded_channel().1,
-            session_notf_receiver: mpsc::unbounded_channel().1,
-            vendor_notf_receiver: mpsc::unbounded_channel().1,
-        }
-    }
-
-    async fn run(&mut self) {
-        loop {
-            tokio::select! {
-                cmd = self.cmd_receiver.recv() => {
-                    match cmd {
-                        None => {
-                            debug!("UwbService is about to drop.");
-                            break;
-                        },
-                        Some((cmd, result_sender)) => {
-                            let result = self.handle_cmd(cmd).await;
-                            let timeout_occurs = matches!(result, Err(Error::Timeout));
-                            let _ = result_sender.send(result);
-
-                            // The UCI HAL might be stuck at a weird state when the timeout occurs.
-                            // Reset the HAL and clear the internal state, and hope the HAL goes
-                            // back to the normal situation.
-                            if timeout_occurs {
-                                warn!("The command timeout, reset the service.");
-                                self.reset_service().await;
-                            }
-                        }
-                    }
-                }
-                Some(core_notf) = self.core_notf_receiver.recv() => {
-                    self.handle_core_notification(core_notf).await;
-                }
-                Some(session_notf) = self.session_notf_receiver.recv() => {
-                    self.handle_session_notification(session_notf).await;
-                }
-                Some(vendor_notf) = self.vendor_notf_receiver.recv() => {
-                    self.handle_vendor_notification(vendor_notf).await;
-                }
-            }
-        }
-    }
-
-    async fn handle_cmd(&mut self, cmd: Command) -> Result<Response> {
-        match cmd {
-            Command::SetLoggerMode { logger_mode } => {
-                self.uci_manager.set_logger_mode(logger_mode).await?;
-                Ok(Response::Null)
-            }
-            Command::Enable => {
-                self.enable_service().await?;
-                Ok(Response::Null)
-            }
-            Command::Disable => {
-                self.disable_service(false).await?;
-                Ok(Response::Null)
-            }
-            Command::InitSession { session_id, session_type, params } => {
-                if let Some(session_manager) = self.session_manager.as_mut() {
-                    session_manager.init_session(session_id, session_type, params).await?;
-                    Ok(Response::Null)
-                } else {
-                    error!("The service is not enabled yet");
-                    Err(Error::BadParameters)
-                }
-            }
-            Command::DeinitSession { session_id } => {
-                if let Some(session_manager) = self.session_manager.as_mut() {
-                    session_manager.deinit_session(session_id).await?;
-                    Ok(Response::Null)
-                } else {
-                    error!("The service is not enabled yet");
-                    Err(Error::BadParameters)
-                }
-            }
-            Command::StartRanging { session_id } => {
-                if let Some(session_manager) = self.session_manager.as_mut() {
-                    let params = session_manager.start_ranging(session_id).await?;
-                    Ok(Response::AppConfigParams(params))
-                } else {
-                    error!("The service is not enabled yet");
-                    Err(Error::BadParameters)
-                }
-            }
-            Command::StopRanging { session_id } => {
-                if let Some(session_manager) = self.session_manager.as_mut() {
-                    session_manager.stop_ranging(session_id).await?;
-                    Ok(Response::Null)
-                } else {
-                    error!("The service is not enabled yet");
-                    Err(Error::BadParameters)
-                }
-            }
-            Command::Reconfigure { session_id, params } => {
-                if let Some(session_manager) = self.session_manager.as_mut() {
-                    session_manager.reconfigure(session_id, params).await?;
-                    Ok(Response::Null)
-                } else {
-                    error!("The service is not enabled yet");
-                    Err(Error::BadParameters)
-                }
-            }
-            Command::UpdateControllerMulticastList { session_id, action, controlees } => {
-                if let Some(session_manager) = self.session_manager.as_mut() {
-                    session_manager
-                        .update_controller_multicast_list(session_id, action, controlees)
-                        .await?;
-                    Ok(Response::Null)
-                } else {
-                    error!("The service is not enabled yet");
-                    Err(Error::BadParameters)
-                }
-            }
-            Command::AndroidSetCountryCode { country_code } => {
-                self.uci_manager.android_set_country_code(country_code).await?;
-                Ok(Response::Null)
-            }
-            Command::AndroidGetPowerStats => {
-                let stats = self.uci_manager.android_get_power_stats().await?;
-                Ok(Response::PowerStats(stats))
-            }
-            Command::RawUciCmd { mt, gid, oid, payload } => {
-                let msg = self.uci_manager.raw_uci_cmd(mt, gid, oid, payload).await?;
-                Ok(Response::RawUciMessage(msg))
-            }
-            Command::GetParams { session_id } => {
-                if let Some(session_manager) = self.session_manager.as_mut() {
-                    let params = session_manager.session_params(session_id).await?;
-                    Ok(Response::AppConfigParams(params))
-                } else {
-                    error!("The service is not enabled yet");
-                    Err(Error::BadParameters)
-                }
-            }
-        }
-    }
-
-    async fn handle_core_notification(&mut self, notf: CoreNotification) {
-        debug!("Receive core notification: {:?}", notf);
-        match notf {
-            CoreNotification::DeviceStatus(state) => {
-                if state == DeviceState::DeviceStateError {
-                    warn!("Received DeviceStateError notification, reset the service");
-                    self.reset_service().await;
-                } else {
-                    self.callback.on_uci_device_status_changed(state);
-                }
-            }
-            CoreNotification::GenericError(_status) => {}
-        }
-    }
-
-    async fn handle_session_notification(&mut self, notf: SessionNotification) {
-        match notf {
-            SessionNotification::SessionState { session_id, session_state, reason_code } => {
-                self.callback.on_session_state_changed(session_id, session_state, reason_code);
-            }
-            SessionNotification::RangeData { session_id, range_data } => {
-                self.callback.on_range_data_received(session_id, range_data);
-            }
-        }
-    }
-
-    async fn handle_vendor_notification(&mut self, notf: RawUciMessage) {
-        self.callback.on_vendor_notification_received(notf.gid, notf.oid, notf.payload);
-    }
-
-    async fn enable_service(&mut self) -> Result<()> {
-        if self.session_manager.is_some() {
-            debug!("The service is already enabled, skip.");
-            return Ok(());
-        }
-
-        let (core_notf_sender, core_notf_receiver) = mpsc::unbounded_channel();
-        let (uci_session_notf_sender, uci_session_notf_receiver) = mpsc::unbounded_channel();
-        let (vendor_notf_sender, vendor_notf_receiver) = mpsc::unbounded_channel();
-        self.uci_manager.set_core_notification_sender(core_notf_sender).await;
-        self.uci_manager.set_session_notification_sender(uci_session_notf_sender).await;
-        self.uci_manager.set_vendor_notification_sender(vendor_notf_sender).await;
-        self.uci_manager.open_hal().await?;
-
-        let (session_notf_sender, session_notf_receiver) = mpsc::unbounded_channel();
-        self.core_notf_receiver = core_notf_receiver;
-        self.session_notf_receiver = session_notf_receiver;
-        self.vendor_notf_receiver = vendor_notf_receiver;
-        self.session_manager = Some(SessionManager::new(
-            self.uci_manager.clone(),
-            uci_session_notf_receiver,
-            session_notf_sender,
-        ));
-        Ok(())
-    }
-
-    async fn disable_service(&mut self, force: bool) -> Result<()> {
-        self.core_notf_receiver = mpsc::unbounded_channel().1;
-        self.session_notf_receiver = mpsc::unbounded_channel().1;
-        self.vendor_notf_receiver = mpsc::unbounded_channel().1;
-        self.session_manager = None;
-        self.uci_manager.close_hal(force).await?;
-        Ok(())
-    }
-
-    async fn reset_service(&mut self) {
-        let _ = self.disable_service(true).await;
-        let result = self.enable_service().await;
-        if result.is_err() {
-            error!("Failed to reset the service.");
-        }
-        self.callback.on_service_reset(result.is_ok());
-    }
-}
-
-impl<C: UwbServiceCallback, U: UciManager> Drop for UwbServiceActor<C, U> {
-    fn drop(&mut self) {
-        // mpsc receivers are about to be dropped. Clean shutdown the mpsc message.
-        clean_mpsc_receiver(&mut self.core_notf_receiver);
-        clean_mpsc_receiver(&mut self.session_notf_receiver);
-        clean_mpsc_receiver(&mut self.vendor_notf_receiver);
-    }
-}
-
-#[derive(Debug)]
-enum Command {
-    SetLoggerMode {
-        logger_mode: UciLoggerMode,
-    },
-    Enable,
-    Disable,
-    InitSession {
-        session_id: SessionId,
-        session_type: SessionType,
-        params: AppConfigParams,
-    },
-    DeinitSession {
-        session_id: SessionId,
-    },
-    StartRanging {
-        session_id: SessionId,
-    },
-    StopRanging {
-        session_id: SessionId,
-    },
-    Reconfigure {
-        session_id: SessionId,
-        params: AppConfigParams,
-    },
-    UpdateControllerMulticastList {
-        session_id: SessionId,
-        action: UpdateMulticastListAction,
-        controlees: Vec<Controlee>,
-    },
-    AndroidSetCountryCode {
-        country_code: CountryCode,
-    },
-    AndroidGetPowerStats,
-    RawUciCmd {
-        mt: u32,
-        gid: u32,
-        oid: u32,
-        payload: Vec<u8>,
-    },
-    GetParams {
-        session_id: SessionId,
-    },
-}
-
-#[derive(Debug)]
-enum Response {
-    Null,
-    AppConfigParams(AppConfigParams),
-    PowerStats(PowerStats),
-    RawUciMessage(RawUciMessage),
-}
-type ResponseSender = oneshot::Sender<Result<Response>>;
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    use tokio::runtime::Runtime;
-
-    use crate::params::uci_packets::{SessionState, SetAppConfigResponse, StatusCode};
-    use crate::params::GetDeviceInfoResponse;
-    use crate::service::mock_uwb_service_callback::MockUwbServiceCallback;
-    use crate::service::uwb_service_builder::default_runtime;
-    use crate::service::uwb_service_callback_builder::UwbServiceCallbackSendBuilder;
-    use crate::session::session_manager::test_utils::{
-        generate_params, range_data_notf, session_range_data, session_status_notf,
-    };
-    use crate::uci::mock_uci_manager::MockUciManager;
-    use crate::uci::notification::UciNotification;
-    use uwb_uci_packets::StatusCode::UciStatusOk;
-
-    const GET_DEVICE_INFO_RSP: GetDeviceInfoResponse = GetDeviceInfoResponse {
-        status: UciStatusOk,
-        uci_version: 0,
-        mac_version: 0,
-        phy_version: 0,
-        uci_test_version: 0,
-        vendor_spec_info: vec![],
-    };
-
-    fn setup_uwb_service(
-        uci_manager: MockUciManager,
-    ) -> (UwbService, MockUwbServiceCallback, Runtime) {
-        let runtime = default_runtime().unwrap();
-        let callback = MockUwbServiceCallback::new();
-        let callback_builder = UwbServiceCallbackSendBuilder::new(callback.clone());
-        let service =
-            UwbService::new(runtime.handle().to_owned(), callback_builder, uci_manager).unwrap();
-        (service, callback, runtime)
-    }
-
-    #[test]
-    fn test_open_close_uci() {
-        let mut uci_manager = MockUciManager::new();
-        uci_manager.expect_open_hal(vec![], Ok(GET_DEVICE_INFO_RSP));
-        uci_manager.expect_close_hal(false, Ok(()));
-        let (service, _, _runtime) = setup_uwb_service(uci_manager);
-
-        let result = service.enable();
-        assert!(result.is_ok());
-        let result = service.disable();
-        assert!(result.is_ok());
-    }
-
-    #[test]
-    fn test_session_e2e() {
-        let session_id = 0x123;
-        let session_type = SessionType::FiraRangingSession;
-        let params = generate_params();
-        let tlvs = params.generate_tlvs();
-        let range_data = session_range_data(session_id);
-
-        let mut uci_manager = MockUciManager::new();
-        uci_manager.expect_open_hal(vec![], Ok(GET_DEVICE_INFO_RSP));
-        uci_manager.expect_session_init(
-            session_id,
-            session_type,
-            vec![session_status_notf(session_id, SessionState::SessionStateInit)],
-            Ok(()),
-        );
-        uci_manager.expect_session_set_app_config(
-            session_id,
-            tlvs,
-            vec![session_status_notf(session_id, SessionState::SessionStateIdle)],
-            Ok(SetAppConfigResponse { status: StatusCode::UciStatusOk, config_status: vec![] }),
-        );
-        uci_manager.expect_range_start(
-            session_id,
-            vec![
-                session_status_notf(session_id, SessionState::SessionStateActive),
-                range_data_notf(range_data.clone()),
-            ],
-            Ok(()),
-        );
-        uci_manager.expect_range_stop(
-            session_id,
-            vec![session_status_notf(session_id, SessionState::SessionStateIdle)],
-            Ok(()),
-        );
-        uci_manager.expect_session_deinit(
-            session_id,
-            vec![session_status_notf(session_id, SessionState::SessionStateDeinit)],
-            Ok(()),
-        );
-
-        let (service, mut callback, _runtime) = setup_uwb_service(uci_manager.clone());
-        service.enable().unwrap();
-
-        // Initialize a normal session.
-        callback.expect_on_session_state_changed(
-            session_id,
-            SessionState::SessionStateInit,
-            ReasonCode::StateChangeWithSessionManagementCommands,
-        );
-        callback.expect_on_session_state_changed(
-            session_id,
-            SessionState::SessionStateIdle,
-            ReasonCode::StateChangeWithSessionManagementCommands,
-        );
-        let result = service.init_session(session_id, session_type, params);
-        assert!(result.is_ok());
-        assert!(service.block_on_for_testing(callback.wait_expected_calls_done()));
-
-        // Start the ranging process, and should receive the range data.
-        callback.expect_on_session_state_changed(
-            session_id,
-            SessionState::SessionStateActive,
-            ReasonCode::StateChangeWithSessionManagementCommands,
-        );
-        callback.expect_on_range_data_received(session_id, range_data);
-        let result = service.start_ranging(session_id);
-        assert!(result.is_ok());
-        assert!(service.block_on_for_testing(callback.wait_expected_calls_done()));
-
-        // Stop the ranging process.
-        callback.expect_on_session_state_changed(
-            session_id,
-            SessionState::SessionStateIdle,
-            ReasonCode::StateChangeWithSessionManagementCommands,
-        );
-        let result = service.stop_ranging(session_id);
-        assert!(result.is_ok());
-        assert!(service.block_on_for_testing(callback.wait_expected_calls_done()));
-
-        // Deinitialize the session, and should receive the deinitialized notification.
-        callback.expect_on_session_state_changed(
-            session_id,
-            SessionState::SessionStateDeinit,
-            ReasonCode::StateChangeWithSessionManagementCommands,
-        );
-        let result = service.deinit_session(session_id);
-        assert!(result.is_ok());
-        assert!(service.block_on_for_testing(callback.wait_expected_calls_done()));
-
-        // Verify if all of the expected uci_manager method are called.
-        assert!(service.block_on_for_testing(uci_manager.wait_expected_calls_done()));
-    }
-
-    #[test]
-    fn test_session_api_without_enabled() {
-        let session_id = 0x123;
-        let session_type = SessionType::FiraRangingSession;
-        let params = generate_params();
-        let action = UpdateMulticastListAction::AddControlee;
-        let short_address: [u8; 2] = [0x12, 0x34];
-        let controlees = vec![Controlee { short_address, subsession_id: 0x24 }];
-
-        let uci_manager = MockUciManager::new();
-        let (service, _, _runtime) = setup_uwb_service(uci_manager);
-
-        let result = service.init_session(session_id, session_type, params.clone());
-        assert!(result.is_err());
-        let result = service.deinit_session(session_id);
-        assert!(result.is_err());
-        let result = service.start_ranging(session_id);
-        assert!(result.is_err());
-        let result = service.stop_ranging(session_id);
-        assert!(result.is_err());
-        let result = service.reconfigure(session_id, params);
-        assert!(result.is_err());
-        let result = service.update_controller_multicast_list(session_id, action, controlees);
-        assert!(result.is_err());
-    }
-
-    #[test]
-    fn test_android_set_country_code() {
-        let country_code = CountryCode::new(b"US").unwrap();
-        let mut uci_manager = MockUciManager::new();
-        uci_manager.expect_android_set_country_code(country_code.clone(), Ok(()));
-        let (service, _, _runtime) = setup_uwb_service(uci_manager);
-
-        let result = service.android_set_country_code(country_code);
-        assert!(result.is_ok());
-    }
-
-    #[test]
-    fn test_android_get_power_stats() {
-        let stats = PowerStats {
-            status: StatusCode::UciStatusOk,
-            idle_time_ms: 123,
-            tx_time_ms: 456,
-            rx_time_ms: 789,
-            total_wake_count: 5,
-        };
-        let mut uci_manager = MockUciManager::new();
-        uci_manager.expect_android_get_power_stats(Ok(stats.clone()));
-        let (service, _, _runtime) = setup_uwb_service(uci_manager);
-
-        let result = service.android_get_power_stats().unwrap();
-        assert_eq!(result, stats);
-    }
-
-    #[test]
-    fn test_send_raw_cmd() {
-        let mt = 0x01;
-        let gid = 0x09;
-        let oid = 0x35;
-        let cmd_payload = vec![0x12, 0x34];
-        let resp_payload = vec![0x56, 0x78];
-
-        let mut uci_manager = MockUciManager::new();
-        uci_manager.expect_raw_uci_cmd(
-            mt,
-            gid,
-            oid,
-            cmd_payload.clone(),
-            Ok(RawUciMessage { gid, oid, payload: resp_payload.clone() }),
-        );
-        let (service, _, _runtime) = setup_uwb_service(uci_manager);
-
-        let result = service.raw_uci_cmd(mt, gid, oid, cmd_payload).unwrap();
-        assert_eq!(result, RawUciMessage { gid, oid, payload: resp_payload });
-    }
-
-    #[test]
-    fn test_vendor_notification() {
-        let gid = 5;
-        let oid = 7;
-        let payload = vec![0x13, 0x47];
-
-        let mut uci_manager = MockUciManager::new();
-        uci_manager.expect_open_hal(
-            vec![UciNotification::Vendor(RawUciMessage { gid, oid, payload: payload.clone() })],
-            Ok(GET_DEVICE_INFO_RSP),
-        );
-        let (service, mut callback, _runtime) = setup_uwb_service(uci_manager);
-
-        callback.expect_on_vendor_notification_received(gid, oid, payload);
-        service.enable().unwrap();
-        assert!(service.block_on_for_testing(callback.wait_expected_calls_done()));
-    }
-
-    #[test]
-    fn test_core_device_status_notification() {
-        let state = DeviceState::DeviceStateReady;
-
-        let mut uci_manager = MockUciManager::new();
-        uci_manager.expect_open_hal(
-            vec![UciNotification::Core(CoreNotification::DeviceStatus(state))],
-            Ok(GET_DEVICE_INFO_RSP),
-        );
-        let (service, mut callback, _runtime) = setup_uwb_service(uci_manager);
-        callback.expect_on_uci_device_status_changed(state);
-        service.enable().unwrap();
-        assert!(service.block_on_for_testing(callback.wait_expected_calls_done()));
-    }
-
-    #[test]
-    fn test_reset_service_after_timeout() {
-        let mut uci_manager = MockUciManager::new();
-        // The first open_hal() returns timeout.
-        uci_manager.expect_open_hal(vec![], Err(Error::Timeout));
-        // Then UwbService should close_hal() and open_hal() to reset the HAL.
-        uci_manager.expect_close_hal(true, Ok(()));
-        uci_manager.expect_open_hal(vec![], Ok(GET_DEVICE_INFO_RSP));
-        let (service, mut callback, _runtime) = setup_uwb_service(uci_manager.clone());
-
-        callback.expect_on_service_reset(true);
-        let result = service.enable();
-        assert_eq!(result, Err(Error::Timeout));
-        assert!(service.block_on_for_testing(callback.wait_expected_calls_done()));
-
-        assert!(service.block_on_for_testing(uci_manager.wait_expected_calls_done()));
-    }
-
-    #[test]
-    fn test_reset_service_when_error_state() {
-        let mut uci_manager = MockUciManager::new();
-        // The first open_hal() send DeviceStateError notification.
-        uci_manager.expect_open_hal(
-            vec![UciNotification::Core(CoreNotification::DeviceStatus(
-                DeviceState::DeviceStateError,
-            ))],
-            Ok(GET_DEVICE_INFO_RSP),
-        );
-        // Then UwbService should close_hal() and open_hal() to reset the HAL.
-        uci_manager.expect_close_hal(true, Ok(()));
-        uci_manager.expect_open_hal(vec![], Ok(GET_DEVICE_INFO_RSP));
-        let (service, mut callback, _runtime) = setup_uwb_service(uci_manager.clone());
-
-        callback.expect_on_service_reset(true);
-        let result = service.enable();
-        assert_eq!(result, Ok(()));
-        assert!(service.block_on_for_testing(callback.wait_expected_calls_done()));
-        assert!(service.block_on_for_testing(uci_manager.wait_expected_calls_done()));
-    }
-}
diff --git a/src/rust/uwb_core/src/service/uwb_service_builder.rs b/src/rust/uwb_core/src/service/uwb_service_builder.rs
deleted file mode 100644
index 20a4f2b..0000000
--- a/src/rust/uwb_core/src/service/uwb_service_builder.rs
+++ /dev/null
@@ -1,132 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module defines the UwbServiceBuilder, the builder of the UwbService.
-
-use tokio::runtime::{Handle, Runtime};
-
-use crate::service::uwb_service::{UwbService, UwbServiceCallback, UwbServiceCallbackBuilder};
-use crate::uci::uci_hal::UciHal;
-use crate::uci::uci_logger::UciLoggerMode;
-use crate::uci::uci_logger_factory::UciLoggerFactory;
-use crate::uci::uci_manager::UciManagerImpl;
-use crate::utils::consuming_builder_field;
-
-/// Create the default runtime for UwbService.
-pub fn default_runtime() -> Option<Runtime> {
-    tokio::runtime::Builder::new_multi_thread().thread_name("UwbService").enable_all().build().ok()
-}
-
-/// The builder of UwbService, used to keep the backward compatibility when adding new parameters
-/// of creating a UwbService instance.
-pub struct UwbServiceBuilder<B, C, U, L>
-where
-    B: UwbServiceCallbackBuilder<C>,
-    C: UwbServiceCallback,
-    U: UciHal,
-    L: UciLoggerFactory,
-{
-    runtime_handle: Option<Handle>,
-    callback_builder: Option<B>,
-    uci_hal: Option<U>,
-    uci_logger_factory: Option<L>,
-    uci_logger_mode: UciLoggerMode,
-    // Circuimvents unused parameter "C" error
-    phantom: std::marker::PhantomData<C>,
-}
-
-impl<B, C, U, L> Default for UwbServiceBuilder<B, C, U, L>
-where
-    B: UwbServiceCallbackBuilder<C>,
-    C: UwbServiceCallback,
-    U: UciHal,
-    L: UciLoggerFactory,
-{
-    fn default() -> Self {
-        Self {
-            runtime_handle: None,
-            callback_builder: None,
-            uci_hal: None,
-            uci_logger_factory: None,
-            uci_logger_mode: UciLoggerMode::Disabled,
-            phantom: std::marker::PhantomData,
-        }
-    }
-}
-
-impl<B, C, U, L> UwbServiceBuilder<B, C, U, L>
-where
-    B: UwbServiceCallbackBuilder<C>,
-    C: UwbServiceCallback,
-    U: UciHal,
-    L: UciLoggerFactory,
-{
-    /// Create a new builder.
-    pub fn new() -> Self {
-        Default::default()
-    }
-
-    // Setter methods of each field.
-    consuming_builder_field!(runtime_handle, Handle, Some);
-    consuming_builder_field!(callback_builder, B, Some);
-    consuming_builder_field!(uci_hal, U, Some);
-    consuming_builder_field!(uci_logger_factory, L, Some);
-    consuming_builder_field!(uci_logger_mode, UciLoggerMode);
-
-    /// Build the UwbService.
-    pub fn build(mut self) -> Option<UwbService> {
-        let runtime_handle = self.runtime_handle.take()?;
-        let uci_hal = self.uci_hal.take()?;
-        let mut uci_logger_factory = self.uci_logger_factory.take()?;
-        let uci_logger = uci_logger_factory.build_logger("default")?;
-        let uci_logger_mode = self.uci_logger_mode;
-        let uci_manager = runtime_handle
-            .block_on(async move { UciManagerImpl::new(uci_hal, uci_logger, uci_logger_mode) });
-        UwbService::new(runtime_handle, self.callback_builder.take()?, uci_manager)
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use crate::service::mock_uwb_service_callback::MockUwbServiceCallback;
-    use crate::service::uwb_service_callback_builder::UwbServiceCallbackSendBuilder;
-    use crate::uci::mock_uci_hal::MockUciHal;
-    use crate::uci::uci_logger_factory::NopUciLoggerFactory;
-
-    #[test]
-    fn test_build_fail() {
-        let result = UwbServiceBuilder::<
-            UwbServiceCallbackSendBuilder<MockUwbServiceCallback>,
-            MockUwbServiceCallback,
-            MockUciHal,
-            NopUciLoggerFactory,
-        >::new()
-        .build();
-        assert!(result.is_none());
-    }
-
-    #[test]
-    fn test_build_ok() {
-        let runtime = default_runtime().unwrap();
-        let callback = MockUwbServiceCallback::new();
-        let result = UwbServiceBuilder::new()
-            .runtime_handle(runtime.handle().to_owned())
-            .callback_builder(UwbServiceCallbackSendBuilder::new(callback))
-            .uci_hal(MockUciHal::new())
-            .uci_logger_factory(NopUciLoggerFactory::default())
-            .build();
-        assert!(result.is_some());
-    }
-}
diff --git a/src/rust/uwb_core/src/service/uwb_service_callback_builder.rs b/src/rust/uwb_core/src/service/uwb_service_callback_builder.rs
deleted file mode 100644
index 155c9ec..0000000
--- a/src/rust/uwb_core/src/service/uwb_service_callback_builder.rs
+++ /dev/null
@@ -1,40 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module implements the UwbServiceCallbackBuilder, intended to be used
-//! in cases where UwbServiceCallback is [Send](std::marker::Send).
-//! If UwbServiceCallback is [!Send](std::marker::Send) a custom implementation
-//! needs to be handed to UwbServiceBuilder instead.
-use crate::service::uwb_service::{UwbServiceCallback, UwbServiceCallbackBuilder};
-
-/// This struct defines a builder for UwbServiceCallbacks that are [Send](std::marker::Send).
-pub struct UwbServiceCallbackSendBuilder<C: UwbServiceCallback + Send> {
-    callback: C,
-}
-
-impl<C: UwbServiceCallback + Send> UwbServiceCallbackSendBuilder<C> {
-    /// Creates a new UwbServiceCallbackBuilder with the given UwbServiceCallback
-    /// that is [Send](std::marker::Send).
-    pub fn new(callback: C) -> Self {
-        Self { callback }
-    }
-}
-
-impl<C: UwbServiceCallback + Send> UwbServiceCallbackBuilder<C>
-    for UwbServiceCallbackSendBuilder<C>
-{
-    fn build(self) -> Option<C> {
-        Some(self.callback)
-    }
-}
diff --git a/src/rust/uwb_core/src/session.rs b/src/rust/uwb_core/src/session.rs
deleted file mode 100644
index db23f5f..0000000
--- a/src/rust/uwb_core/src/session.rs
+++ /dev/null
@@ -1,19 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module provides the functionalities related to the UWB ranging session.
-
-mod uwb_session;
-
-pub(crate) mod session_manager;
diff --git a/src/rust/uwb_core/src/session/session_manager.rs b/src/rust/uwb_core/src/session/session_manager.rs
deleted file mode 100644
index b03964c..0000000
--- a/src/rust/uwb_core/src/session/session_manager.rs
+++ /dev/null
@@ -1,1170 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::collections::BTreeMap;
-
-use log::{debug, error, warn};
-use tokio::sync::{mpsc, oneshot};
-
-use crate::error::{Error, Result};
-use crate::params::app_config_params::AppConfigParams;
-use crate::params::uci_packets::{
-    Controlee, ControleeStatusList, ReasonCode, SessionId, SessionState, SessionType,
-    UpdateMulticastListAction,
-};
-use crate::session::uwb_session::{Response as SessionResponse, ResponseSender, UwbSession};
-use crate::uci::notification::{SessionNotification as UciSessionNotification, SessionRangeData};
-use crate::uci::uci_manager::UciManager;
-use crate::utils::clean_mpsc_receiver;
-
-const MAX_SESSION_COUNT: usize = 5;
-
-/// The notifications that are sent from SessionManager to its caller.
-#[derive(Debug, PartialEq)]
-pub(crate) enum SessionNotification {
-    SessionState { session_id: SessionId, session_state: SessionState, reason_code: ReasonCode },
-    RangeData { session_id: SessionId, range_data: SessionRangeData },
-}
-
-/// The SessionManager organizes the state machine of the existing UWB ranging sessions, sends
-/// the session-related requests to the UciManager, and handles the session notifications from the
-/// UciManager.
-/// Using the actor model, SessionManager delegates the requests to SessionManagerActor.
-pub(crate) struct SessionManager {
-    cmd_sender: mpsc::UnboundedSender<(SessionCommand, ResponseSender)>,
-}
-
-impl SessionManager {
-    pub fn new<T: UciManager>(
-        uci_manager: T,
-        uci_notf_receiver: mpsc::UnboundedReceiver<UciSessionNotification>,
-        session_notf_sender: mpsc::UnboundedSender<SessionNotification>,
-    ) -> Self {
-        let (cmd_sender, cmd_receiver) = mpsc::unbounded_channel();
-        let mut actor = SessionManagerActor::new(
-            cmd_receiver,
-            uci_manager,
-            uci_notf_receiver,
-            session_notf_sender,
-        );
-        tokio::spawn(async move { actor.run().await });
-
-        Self { cmd_sender }
-    }
-
-    pub async fn init_session(
-        &mut self,
-        session_id: SessionId,
-        session_type: SessionType,
-        params: AppConfigParams,
-    ) -> Result<()> {
-        let result = self
-            .send_cmd(SessionCommand::InitSession { session_id, session_type, params })
-            .await
-            .map(|_| ());
-        if result.is_err() && result != Err(Error::DuplicatedSessionId) {
-            let _ = self.deinit_session(session_id).await;
-        }
-        result
-    }
-
-    pub async fn deinit_session(&mut self, session_id: SessionId) -> Result<()> {
-        self.send_cmd(SessionCommand::DeinitSession { session_id }).await?;
-        Ok(())
-    }
-
-    pub async fn start_ranging(&mut self, session_id: SessionId) -> Result<AppConfigParams> {
-        match self.send_cmd(SessionCommand::StartRanging { session_id }).await? {
-            SessionResponse::AppConfigParams(params) => Ok(params),
-            _ => panic!("start_ranging() should reply AppConfigParams result"),
-        }
-    }
-
-    pub async fn stop_ranging(&mut self, session_id: SessionId) -> Result<()> {
-        self.send_cmd(SessionCommand::StopRanging { session_id }).await?;
-        Ok(())
-    }
-
-    pub async fn reconfigure(
-        &mut self,
-        session_id: SessionId,
-        params: AppConfigParams,
-    ) -> Result<()> {
-        self.send_cmd(SessionCommand::Reconfigure { session_id, params }).await?;
-        Ok(())
-    }
-
-    pub async fn update_controller_multicast_list(
-        &mut self,
-        session_id: SessionId,
-        action: UpdateMulticastListAction,
-        controlees: Vec<Controlee>,
-    ) -> Result<()> {
-        self.send_cmd(SessionCommand::UpdateControllerMulticastList {
-            session_id,
-            action,
-            controlees,
-        })
-        .await?;
-        Ok(())
-    }
-
-    pub async fn session_params(&mut self, session_id: SessionId) -> Result<AppConfigParams> {
-        match self.send_cmd(SessionCommand::GetParams { session_id }).await? {
-            SessionResponse::AppConfigParams(params) => Ok(params),
-            _ => panic!("session_params() should reply AppConfigParams result"),
-        }
-    }
-
-    // Send the |cmd| to the SessionManagerActor.
-    async fn send_cmd(&self, cmd: SessionCommand) -> Result<SessionResponse> {
-        let (result_sender, result_receiver) = oneshot::channel();
-        self.cmd_sender.send((cmd, result_sender)).map_err(|cmd| {
-            error!("Failed to send cmd: {:?}", cmd.0);
-            Error::Unknown
-        })?;
-        result_receiver.await.unwrap_or_else(|e| {
-            error!("Failed to receive the result for cmd: {:?}", e);
-            Err(Error::Unknown)
-        })
-    }
-}
-
-struct SessionManagerActor<T: UciManager> {
-    // Receive the commands and the corresponding response senders from SessionManager.
-    cmd_receiver: mpsc::UnboundedReceiver<(SessionCommand, ResponseSender)>,
-    // Send the notification to SessionManager's caller.
-    session_notf_sender: mpsc::UnboundedSender<SessionNotification>,
-
-    // The UciManager for delegating UCI requests.
-    uci_manager: T,
-    // Receive the notification from |uci_manager|.
-    uci_notf_receiver: mpsc::UnboundedReceiver<UciSessionNotification>,
-
-    active_sessions: BTreeMap<SessionId, UwbSession>,
-}
-
-impl<T: UciManager> SessionManagerActor<T> {
-    fn new(
-        cmd_receiver: mpsc::UnboundedReceiver<(SessionCommand, ResponseSender)>,
-        uci_manager: T,
-        uci_notf_receiver: mpsc::UnboundedReceiver<UciSessionNotification>,
-        session_notf_sender: mpsc::UnboundedSender<SessionNotification>,
-    ) -> Self {
-        Self {
-            cmd_receiver,
-            session_notf_sender,
-            uci_manager,
-            uci_notf_receiver,
-            active_sessions: BTreeMap::new(),
-        }
-    }
-
-    async fn run(&mut self) {
-        loop {
-            tokio::select! {
-                cmd = self.cmd_receiver.recv() => {
-                    match cmd {
-                        None => {
-                            debug!("SessionManager is about to drop.");
-                            break;
-                        },
-                        Some((cmd, result_sender)) => {
-                            self.handle_cmd(cmd, result_sender);
-                        }
-                    }
-                }
-
-                Some(notf) = self.uci_notf_receiver.recv() => {
-                    self.handle_uci_notification(notf);
-                }
-            }
-        }
-    }
-
-    fn handle_cmd(&mut self, cmd: SessionCommand, result_sender: ResponseSender) {
-        match cmd {
-            SessionCommand::InitSession { session_id, session_type, params } => {
-                if self.active_sessions.contains_key(&session_id) {
-                    warn!("Session {} already exists", session_id);
-                    let _ = result_sender.send(Err(Error::DuplicatedSessionId));
-                    return;
-                }
-                if self.active_sessions.len() == MAX_SESSION_COUNT {
-                    warn!("The amount of active sessions already reached {}", MAX_SESSION_COUNT);
-                    let _ = result_sender.send(Err(Error::MaxSessionsExceeded));
-                    return;
-                }
-
-                if !params.is_type_matched(session_type) {
-                    warn!(
-                        "session_type {:?} doesn't match with the params {:?}",
-                        session_type, params
-                    );
-                    let _ = result_sender.send(Err(Error::BadParameters));
-                    return;
-                }
-
-                let mut session =
-                    UwbSession::new(self.uci_manager.clone(), session_id, session_type);
-                session.initialize(params, result_sender);
-
-                // We store the session first. If the initialize() fails, then SessionManager will
-                // call deinit_session() to remove it.
-                self.active_sessions.insert(session_id, session);
-            }
-            SessionCommand::DeinitSession { session_id } => {
-                match self.active_sessions.remove(&session_id) {
-                    None => {
-                        warn!("Session {} doesn't exist", session_id);
-                        let _ = result_sender.send(Err(Error::BadParameters));
-                    }
-                    Some(mut session) => {
-                        session.deinitialize(result_sender);
-                    }
-                }
-            }
-            SessionCommand::StartRanging { session_id } => {
-                match self.active_sessions.get_mut(&session_id) {
-                    None => {
-                        warn!("Session {} doesn't exist", session_id);
-                        let _ = result_sender.send(Err(Error::BadParameters));
-                    }
-                    Some(session) => {
-                        session.start_ranging(result_sender);
-                    }
-                }
-            }
-            SessionCommand::StopRanging { session_id } => {
-                match self.active_sessions.get_mut(&session_id) {
-                    None => {
-                        warn!("Session {} doesn't exist", session_id);
-                        let _ = result_sender.send(Err(Error::BadParameters));
-                    }
-                    Some(session) => {
-                        session.stop_ranging(result_sender);
-                    }
-                }
-            }
-            SessionCommand::Reconfigure { session_id, params } => {
-                match self.active_sessions.get_mut(&session_id) {
-                    None => {
-                        warn!("Session {} doesn't exist", session_id);
-                        let _ = result_sender.send(Err(Error::BadParameters));
-                    }
-                    Some(session) => {
-                        session.reconfigure(params, result_sender);
-                    }
-                }
-            }
-            SessionCommand::UpdateControllerMulticastList { session_id, action, controlees } => {
-                match self.active_sessions.get_mut(&session_id) {
-                    None => {
-                        warn!("Session {} doesn't exist", session_id);
-                        let _ = result_sender.send(Err(Error::BadParameters));
-                    }
-                    Some(session) => {
-                        session.update_controller_multicast_list(action, controlees, result_sender);
-                    }
-                }
-            }
-            SessionCommand::GetParams { session_id } => {
-                match self.active_sessions.get_mut(&session_id) {
-                    None => {
-                        warn!("Session {} doesn't exist", session_id);
-                        let _ = result_sender.send(Err(Error::BadParameters));
-                    }
-                    Some(session) => {
-                        session.params(result_sender);
-                    }
-                }
-            }
-        }
-    }
-
-    fn handle_uci_notification(&mut self, notf: UciSessionNotification) {
-        match notf {
-            UciSessionNotification::Status {
-                session_id: _,
-                session_token,
-                session_state,
-                reason_code,
-            } => {
-                let reason_code = match ReasonCode::try_from(reason_code) {
-                    Ok(r) => r,
-                    Err(_) => {
-                        error!(
-                            "Received unknown reason_code {:?} in UciSessionNotification",
-                            reason_code
-                        );
-                        return;
-                    }
-                };
-                if session_state == SessionState::SessionStateDeinit {
-                    debug!("Session {} is deinitialized", session_token);
-                    let _ = self.active_sessions.remove(&session_token);
-                    let _ = self.session_notf_sender.send(SessionNotification::SessionState {
-                        session_id: session_token,
-                        session_state,
-                        reason_code,
-                    });
-                    return;
-                }
-
-                match self.active_sessions.get_mut(&session_token) {
-                    Some(session) => {
-                        session.on_session_status_changed(session_state);
-                        let _ = self.session_notf_sender.send(SessionNotification::SessionState {
-                            session_id: session_token,
-                            session_state,
-                            reason_code,
-                        });
-                    }
-                    None => {
-                        warn!(
-                            "Received notification of the unknown Session {}: {:?}, {:?}",
-                            session_token, session_state, reason_code
-                        );
-                    }
-                }
-            }
-            UciSessionNotification::UpdateControllerMulticastListV1 {
-                session_token,
-                remaining_multicast_list_size: _,
-                status_list,
-            } => match self.active_sessions.get_mut(&session_token) {
-                Some(session) => session
-                    .on_controller_multicast_list_updated(ControleeStatusList::V1(status_list)),
-                None => {
-                    warn!(
-                        "Received the notification of the unknown Session {}: {:?}",
-                        session_token, status_list
-                    );
-                }
-            },
-            UciSessionNotification::UpdateControllerMulticastListV2 {
-                session_token,
-                status_list,
-            } => match self.active_sessions.get_mut(&session_token) {
-                Some(session) => session
-                    .on_controller_multicast_list_updated(ControleeStatusList::V2(status_list)),
-                None => {
-                    warn!(
-                        "Received the notification of the unknown Session {}: {:?}",
-                        session_token, status_list
-                    );
-                }
-            },
-            UciSessionNotification::SessionInfo(range_data) => {
-                if self.active_sessions.contains_key(&range_data.session_token) {
-                    let _ = self.session_notf_sender.send(SessionNotification::RangeData {
-                        session_id: range_data.session_token,
-                        range_data,
-                    });
-                } else {
-                    warn!("Received range data of the unknown Session: {:?}", range_data);
-                }
-            }
-            UciSessionNotification::DataCredit { session_token, credit_availability: _ } => {
-                match self.active_sessions.get(&session_token) {
-                    Some(_) => {
-                        /*
-                         * TODO(b/270443790): Handle the DataCredit notification in the new
-                         * code flow.
-                         */
-                    }
-                    None => {
-                        warn!(
-                            "Received the Data Credit notification for an unknown Session {}",
-                            session_token
-                        );
-                    }
-                }
-            }
-            UciSessionNotification::DataTransferStatus {
-                session_token,
-                uci_sequence_number: _,
-                status: _,
-                tx_count: _,
-            } => {
-                match self.active_sessions.get(&session_token) {
-                    Some(_) => {
-                        /*
-                         * TODO(b/270443790): Handle the DataTransferStatus notification in the
-                         * new code flow.
-                         */
-                    }
-                    None => {
-                        warn!(
-                            "Received a Data Transfer Status notification for unknown Session {}",
-                            session_token
-                        );
-                    }
-                }
-            }
-            UciSessionNotification::DataTransferPhaseConfig { session_token, status } => {
-                match self.active_sessions.get_mut(&session_token) {
-                    Some(_) => {
-                        /*
-                         *TODO
-                         */
-                    }
-                    None => {
-                        warn!(
-                            "Received data transfer phase configuration notification of the unknown
-                            Session {:?}",
-                            status
-                        );
-                    }
-                }
-            }
-        }
-    }
-}
-
-impl<T: UciManager> Drop for SessionManagerActor<T> {
-    fn drop(&mut self) {
-        // mpsc receiver is about to be dropped. Clean shutdown the mpsc message.
-        clean_mpsc_receiver(&mut self.uci_notf_receiver);
-    }
-}
-
-#[derive(Debug)]
-enum SessionCommand {
-    InitSession {
-        session_id: SessionId,
-        session_type: SessionType,
-        params: AppConfigParams,
-    },
-    DeinitSession {
-        session_id: SessionId,
-    },
-    StartRanging {
-        session_id: SessionId,
-    },
-    StopRanging {
-        session_id: SessionId,
-    },
-    Reconfigure {
-        session_id: SessionId,
-        params: AppConfigParams,
-    },
-    UpdateControllerMulticastList {
-        session_id: SessionId,
-        action: UpdateMulticastListAction,
-        controlees: Vec<Controlee>,
-    },
-    GetParams {
-        session_id: SessionId,
-    },
-}
-
-#[cfg(test)]
-pub(crate) mod test_utils {
-    use super::*;
-
-    use crate::params::ccc_app_config_params::*;
-    use crate::params::fira_app_config_params::*;
-    use crate::params::uci_packets::{
-        RangingMeasurementType, ReasonCode, ShortAddressTwoWayRangingMeasurement, StatusCode,
-    };
-    use crate::params::GetDeviceInfoResponse;
-    use crate::uci::mock_uci_manager::MockUciManager;
-    use crate::uci::notification::{RangingMeasurements, UciNotification};
-    use crate::utils::init_test_logging;
-    use uwb_uci_packets::StatusCode::UciStatusOk;
-
-    const GET_DEVICE_INFO_RSP: GetDeviceInfoResponse = GetDeviceInfoResponse {
-        status: UciStatusOk,
-        uci_version: 0,
-        mac_version: 0,
-        phy_version: 0,
-        uci_test_version: 0,
-        vendor_spec_info: vec![],
-    };
-
-    pub(crate) fn generate_params() -> AppConfigParams {
-        FiraAppConfigParamsBuilder::new()
-            .device_type(DeviceType::Controller)
-            .multi_node_mode(MultiNodeMode::Unicast)
-            .device_mac_address(UwbAddress::Short([1, 2]))
-            .dst_mac_address(vec![UwbAddress::Short([3, 4])])
-            .device_role(DeviceRole::Initiator)
-            .vendor_id([0xFE, 0xDC])
-            .static_sts_iv([0xDF, 0xCE, 0xAB, 0x12, 0x34, 0x56])
-            .build()
-            .unwrap()
-    }
-
-    pub(crate) fn generate_ccc_params() -> AppConfigParams {
-        CccAppConfigParamsBuilder::new()
-            .protocol_version(CccProtocolVersion { major: 2, minor: 1 })
-            .uwb_config(CccUwbConfig::Config0)
-            .pulse_shape_combo(CccPulseShapeCombo {
-                initiator_tx: PulseShape::PrecursorFree,
-                responder_tx: PulseShape::PrecursorFreeSpecial,
-            })
-            .ran_multiplier(3)
-            .channel_number(CccUwbChannel::Channel9)
-            .chaps_per_slot(ChapsPerSlot::Value9)
-            .num_responder_nodes(1)
-            .slots_per_rr(3)
-            .sync_code_index(12)
-            .hopping_mode(CccHoppingMode::ContinuousAes)
-            .build()
-            .unwrap()
-    }
-
-    // TODO(b/321757248): Add a unit test generate_aliro_params().
-
-    pub(crate) fn session_range_data(session_id: SessionId) -> SessionRangeData {
-        SessionRangeData {
-            sequence_number: 1,
-            session_token: session_id,
-            current_ranging_interval_ms: 3,
-            ranging_measurement_type: RangingMeasurementType::TwoWay,
-            hus_primary_session_id: 0,
-            ranging_measurements: RangingMeasurements::ShortAddressTwoWay(vec![
-                ShortAddressTwoWayRangingMeasurement {
-                    mac_address: 0x123,
-                    status: StatusCode::UciStatusOk,
-                    nlos: 0,
-                    distance: 4,
-                    aoa_azimuth: 5,
-                    aoa_azimuth_fom: 6,
-                    aoa_elevation: 7,
-                    aoa_elevation_fom: 8,
-                    aoa_destination_azimuth: 9,
-                    aoa_destination_azimuth_fom: 10,
-                    aoa_destination_elevation: 11,
-                    aoa_destination_elevation_fom: 12,
-                    slot_index: 0,
-                    rssi: u8::MAX,
-                },
-            ]),
-            rcr_indicator: 0,
-            raw_ranging_data: vec![0x12, 0x34],
-        }
-    }
-
-    pub(crate) fn session_status_notf(
-        session_id: SessionId,
-        session_state: SessionState,
-    ) -> UciNotification {
-        UciNotification::Session(UciSessionNotification::Status {
-            session_id: 0x0,
-            session_token: session_id,
-            session_state,
-            reason_code: ReasonCode::StateChangeWithSessionManagementCommands.into(),
-        })
-    }
-
-    pub(crate) fn range_data_notf(range_data: SessionRangeData) -> UciNotification {
-        UciNotification::Session(UciSessionNotification::SessionInfo(range_data))
-    }
-
-    pub(super) async fn setup_session_manager<F>(
-        setup_uci_manager_fn: F,
-    ) -> (SessionManager, MockUciManager, mpsc::UnboundedReceiver<SessionNotification>)
-    where
-        F: FnOnce(&mut MockUciManager),
-    {
-        init_test_logging();
-        let (uci_notf_sender, uci_notf_receiver) = mpsc::unbounded_channel();
-        let (session_notf_sender, session_notf_receiver) = mpsc::unbounded_channel();
-        let mut uci_manager = MockUciManager::new();
-        uci_manager.expect_open_hal(vec![], Ok(GET_DEVICE_INFO_RSP));
-        setup_uci_manager_fn(&mut uci_manager);
-        uci_manager.set_session_notification_sender(uci_notf_sender).await;
-        let _ = uci_manager.open_hal().await;
-
-        (
-            SessionManager::new(uci_manager.clone(), uci_notf_receiver, session_notf_sender),
-            uci_manager,
-            session_notf_receiver,
-        )
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::test_utils::*;
-    use super::*;
-
-    use std::collections::HashMap;
-
-    use crate::params::ccc_started_app_config_params::CccStartedAppConfigParams;
-    use crate::params::uci_packets::{
-        AppConfigTlv, AppConfigTlvType, ControleeStatusV1, Controlees, MulticastUpdateStatusCode,
-        ReasonCode, SessionUpdateControllerMulticastResponse, SetAppConfigResponse, StatusCode,
-    };
-    use crate::params::utils::{u32_to_bytes, u64_to_bytes, u8_to_bytes};
-    use crate::params::{FiraAppConfigParamsBuilder, KeyRotation};
-    use crate::uci::notification::UciNotification;
-
-    #[tokio::test]
-    async fn test_init_deinit_session() {
-        let session_id = 0x123;
-        let session_type = SessionType::FiraRangingSession;
-        let params = generate_params();
-
-        let tlvs = params.generate_tlvs();
-        let (mut session_manager, mut mock_uci_manager, mut session_notf_receiver) =
-            setup_session_manager(move |uci_manager| {
-                uci_manager.expect_session_init(
-                    session_id,
-                    session_type,
-                    vec![session_status_notf(session_id, SessionState::SessionStateInit)],
-                    Ok(()),
-                );
-                uci_manager.expect_session_set_app_config(
-                    session_id,
-                    tlvs,
-                    vec![session_status_notf(session_id, SessionState::SessionStateIdle)],
-                    Ok(SetAppConfigResponse {
-                        status: StatusCode::UciStatusOk,
-                        config_status: vec![],
-                    }),
-                );
-                uci_manager.expect_session_deinit(
-                    session_id,
-                    vec![session_status_notf(session_id, SessionState::SessionStateDeinit)],
-                    Ok(()),
-                );
-            })
-            .await;
-
-        // Deinit a session before initialized should fail.
-        let result = session_manager.deinit_session(session_id).await;
-        assert_eq!(result, Err(Error::BadParameters));
-
-        // Initialize a normal session should be successful.
-        let result = session_manager.init_session(session_id, session_type, params.clone()).await;
-        assert_eq!(result, Ok(()));
-        let session_notf = session_notf_receiver.recv().await.unwrap();
-        assert_eq!(
-            session_notf,
-            SessionNotification::SessionState {
-                session_id,
-                session_state: SessionState::SessionStateInit,
-                reason_code: ReasonCode::StateChangeWithSessionManagementCommands
-            }
-        );
-        let session_notf = session_notf_receiver.recv().await.unwrap();
-        assert_eq!(
-            session_notf,
-            SessionNotification::SessionState {
-                session_id,
-                session_state: SessionState::SessionStateIdle,
-                reason_code: ReasonCode::StateChangeWithSessionManagementCommands
-            }
-        );
-
-        // Initialize a session multiple times without deinitialize should fail.
-        let result = session_manager.init_session(session_id, session_type, params).await;
-        assert_eq!(result, Err(Error::DuplicatedSessionId));
-
-        // Deinitialize the session should be successful, and should receive the deinitialized
-        // notification.
-        let result = session_manager.deinit_session(session_id).await;
-        assert_eq!(result, Ok(()));
-        let session_notf = session_notf_receiver.recv().await.unwrap();
-        assert_eq!(
-            session_notf,
-            SessionNotification::SessionState {
-                session_id,
-                session_state: SessionState::SessionStateDeinit,
-                reason_code: ReasonCode::StateChangeWithSessionManagementCommands
-            }
-        );
-
-        // Deinit a session after deinitialized should fail.
-        let result = session_manager.deinit_session(session_id).await;
-        assert_eq!(result, Err(Error::BadParameters));
-
-        assert!(mock_uci_manager.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_init_session_timeout() {
-        let session_id = 0x123;
-        let session_type = SessionType::FiraRangingSession;
-        let params = generate_params();
-
-        let (mut session_manager, mut mock_uci_manager, _) =
-            setup_session_manager(move |uci_manager| {
-                let notfs = vec![]; // Not sending SessionStatus notification.
-                uci_manager.expect_session_init(session_id, session_type, notfs, Ok(()));
-            })
-            .await;
-
-        let result = session_manager.init_session(session_id, session_type, params).await;
-        assert_eq!(result, Err(Error::Timeout));
-
-        assert!(mock_uci_manager.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_start_stop_ranging() {
-        let session_id = 0x123;
-        let session_type = SessionType::FiraRangingSession;
-        let params = generate_params();
-        let tlvs = params.generate_tlvs();
-
-        let (mut session_manager, mut mock_uci_manager, _) =
-            setup_session_manager(move |uci_manager| {
-                uci_manager.expect_session_init(
-                    session_id,
-                    session_type,
-                    vec![session_status_notf(session_id, SessionState::SessionStateInit)],
-                    Ok(()),
-                );
-                uci_manager.expect_session_set_app_config(
-                    session_id,
-                    tlvs,
-                    vec![session_status_notf(session_id, SessionState::SessionStateIdle)],
-                    Ok(SetAppConfigResponse {
-                        status: StatusCode::UciStatusOk,
-                        config_status: vec![],
-                    }),
-                );
-                uci_manager.expect_range_start(
-                    session_id,
-                    vec![session_status_notf(session_id, SessionState::SessionStateActive)],
-                    Ok(()),
-                );
-                uci_manager.expect_range_stop(
-                    session_id,
-                    vec![session_status_notf(session_id, SessionState::SessionStateIdle)],
-                    Ok(()),
-                );
-            })
-            .await;
-
-        let result = session_manager.init_session(session_id, session_type, params.clone()).await;
-        assert_eq!(result, Ok(()));
-        let result = session_manager.start_ranging(session_id).await;
-        assert_eq!(result, Ok(params));
-        let result = session_manager.stop_ranging(session_id).await;
-        assert_eq!(result, Ok(()));
-
-        assert!(mock_uci_manager.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_ccc_start_ranging() {
-        let session_id = 0x123;
-        let session_type = SessionType::Ccc;
-        // params that is passed to UciManager::session_set_app_config().
-        let params = generate_ccc_params();
-        let tlvs = params.generate_tlvs();
-        // The params that is received from UciManager::session_get_app_config().
-        let received_config_map = HashMap::from([
-            (AppConfigTlvType::StsIndex, u32_to_bytes(3)),
-            (AppConfigTlvType::CccHopModeKey, u32_to_bytes(5)),
-            (AppConfigTlvType::CccUwbTime0, u64_to_bytes(7)),
-            (AppConfigTlvType::RangingDuration, u32_to_bytes(96)),
-            (AppConfigTlvType::PreambleCodeIndex, u8_to_bytes(9)),
-        ]);
-        let received_tlvs = received_config_map
-            .iter()
-            .map(|(key, value)| AppConfigTlv::new(*key, value.clone()))
-            .collect();
-        let started_params =
-            CccStartedAppConfigParams::from_config_map(received_config_map).unwrap();
-
-        let (mut session_manager, mut mock_uci_manager, _) =
-            setup_session_manager(move |uci_manager| {
-                uci_manager.expect_session_init(
-                    session_id,
-                    session_type,
-                    vec![session_status_notf(session_id, SessionState::SessionStateInit)],
-                    Ok(()),
-                );
-                uci_manager.expect_session_set_app_config(
-                    session_id,
-                    tlvs,
-                    vec![session_status_notf(session_id, SessionState::SessionStateIdle)],
-                    Ok(SetAppConfigResponse {
-                        status: StatusCode::UciStatusOk,
-                        config_status: vec![],
-                    }),
-                );
-                uci_manager.expect_range_start(
-                    session_id,
-                    vec![session_status_notf(session_id, SessionState::SessionStateActive)],
-                    Ok(()),
-                );
-                uci_manager.expect_session_get_app_config(session_id, vec![], Ok(received_tlvs));
-            })
-            .await;
-
-        let result = session_manager.init_session(session_id, session_type, params.clone()).await;
-        assert_eq!(result, Ok(()));
-        let result = session_manager.start_ranging(session_id).await;
-        assert_eq!(result, Ok(AppConfigParams::CccStarted(started_params)));
-
-        assert!(mock_uci_manager.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_update_controller_multicast_list() {
-        let session_id = 0x123;
-        let session_type = SessionType::FiraRangingSession;
-        let params = generate_params();
-        let tlvs = params.generate_tlvs();
-        let action = UpdateMulticastListAction::AddControlee;
-        let short_address: [u8; 2] = [0x12, 0x34];
-        let controlees = vec![Controlee { short_address, subsession_id: 0x24 }];
-
-        let controlees_clone = controlees.clone();
-        let (mut session_manager, mut mock_uci_manager, _) =
-            setup_session_manager(move |uci_manager| {
-                let multicast_list_notf = vec![UciNotification::Session(
-                    UciSessionNotification::UpdateControllerMulticastListV1 {
-                        session_token: session_id,
-                        remaining_multicast_list_size: 1,
-                        status_list: vec![ControleeStatusV1 {
-                            mac_address: [0x34, 0x12],
-                            subsession_id: 0x24,
-                            status: MulticastUpdateStatusCode::StatusOkMulticastListUpdate,
-                        }],
-                    },
-                )];
-                uci_manager.expect_session_init(
-                    session_id,
-                    session_type,
-                    vec![session_status_notf(session_id, SessionState::SessionStateInit)],
-                    Ok(()),
-                );
-                uci_manager.expect_session_set_app_config(
-                    session_id,
-                    tlvs,
-                    vec![session_status_notf(session_id, SessionState::SessionStateIdle)],
-                    Ok(SetAppConfigResponse {
-                        status: StatusCode::UciStatusOk,
-                        config_status: vec![],
-                    }),
-                );
-                uci_manager.expect_session_update_controller_multicast_list(
-                    session_id,
-                    action,
-                    Controlees::NoSessionKey(controlees_clone),
-                    multicast_list_notf,
-                    Ok(SessionUpdateControllerMulticastResponse {
-                        status: StatusCode::UciStatusOk,
-                        status_list: vec![],
-                    }),
-                );
-            })
-            .await;
-
-        let result = session_manager.init_session(session_id, session_type, params).await;
-        assert_eq!(result, Ok(()));
-        let result =
-            session_manager.update_controller_multicast_list(session_id, action, controlees).await;
-        assert_eq!(result, Ok(()));
-
-        assert!(mock_uci_manager.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_ccc_update_controller_multicast_list() {
-        let session_id = 0x123;
-        let session_type = SessionType::Ccc;
-        let params = generate_ccc_params();
-        let tlvs = params.generate_tlvs();
-        let action = UpdateMulticastListAction::AddControlee;
-        let short_address: [u8; 2] = [0x12, 0x34];
-        let controlees = vec![Controlee { short_address, subsession_id: 0x24 }];
-
-        let (mut session_manager, mut mock_uci_manager, _) =
-            setup_session_manager(move |uci_manager| {
-                uci_manager.expect_session_init(
-                    session_id,
-                    session_type,
-                    vec![session_status_notf(session_id, SessionState::SessionStateInit)],
-                    Ok(()),
-                );
-                uci_manager.expect_session_set_app_config(
-                    session_id,
-                    tlvs,
-                    vec![session_status_notf(session_id, SessionState::SessionStateIdle)],
-                    Ok(SetAppConfigResponse {
-                        status: StatusCode::UciStatusOk,
-                        config_status: vec![],
-                    }),
-                );
-            })
-            .await;
-
-        let result = session_manager.init_session(session_id, session_type, params).await;
-        assert_eq!(result, Ok(()));
-        // CCC session doesn't support update_controller_multicast_list.
-        let result =
-            session_manager.update_controller_multicast_list(session_id, action, controlees).await;
-        assert_eq!(result, Err(Error::BadParameters));
-
-        assert!(mock_uci_manager.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_update_controller_multicast_list_without_notification() {
-        let session_id = 0x123;
-        let session_type = SessionType::FiraRangingSession;
-        let params = generate_params();
-        let tlvs = params.generate_tlvs();
-        let action = UpdateMulticastListAction::AddControlee;
-        let short_address: [u8; 2] = [0x12, 0x34];
-        let controlees = vec![Controlee { short_address, subsession_id: 0x24 }];
-
-        let controlees_clone = controlees.clone();
-        let (mut session_manager, mut mock_uci_manager, _) =
-            setup_session_manager(move |uci_manager| {
-                uci_manager.expect_session_init(
-                    session_id,
-                    session_type,
-                    vec![session_status_notf(session_id, SessionState::SessionStateInit)],
-                    Ok(()),
-                );
-                uci_manager.expect_session_set_app_config(
-                    session_id,
-                    tlvs,
-                    vec![session_status_notf(session_id, SessionState::SessionStateIdle)],
-                    Ok(SetAppConfigResponse {
-                        status: StatusCode::UciStatusOk,
-                        config_status: vec![],
-                    }),
-                );
-                uci_manager.expect_session_update_controller_multicast_list(
-                    session_id,
-                    action,
-                    uwb_uci_packets::Controlees::NoSessionKey(controlees_clone),
-                    vec![], // Not sending notification.
-                    Ok(SessionUpdateControllerMulticastResponse {
-                        status: StatusCode::UciStatusOk,
-                        status_list: vec![],
-                    }),
-                );
-            })
-            .await;
-
-        let result = session_manager.init_session(session_id, session_type, params).await;
-        assert_eq!(result, Ok(()));
-        // This method should timeout waiting for the notification.
-        let result =
-            session_manager.update_controller_multicast_list(session_id, action, controlees).await;
-        assert_eq!(result, Err(Error::Timeout));
-
-        assert!(mock_uci_manager.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_receive_session_range_data() {
-        let session_id = 0x123;
-        let session_type = SessionType::FiraRangingSession;
-        let params = generate_params();
-        let tlvs = params.generate_tlvs();
-        let range_data = session_range_data(session_id);
-        let range_data_clone = range_data.clone();
-
-        let (mut session_manager, mut mock_uci_manager, mut session_notf_receiver) =
-            setup_session_manager(move |uci_manager| {
-                uci_manager.expect_session_init(
-                    session_id,
-                    session_type,
-                    vec![session_status_notf(session_id, SessionState::SessionStateInit)],
-                    Ok(()),
-                );
-                uci_manager.expect_session_set_app_config(
-                    session_id,
-                    tlvs,
-                    vec![
-                        session_status_notf(session_id, SessionState::SessionStateIdle),
-                        range_data_notf(range_data_clone),
-                    ],
-                    Ok(SetAppConfigResponse {
-                        status: StatusCode::UciStatusOk,
-                        config_status: vec![],
-                    }),
-                );
-            })
-            .await;
-
-        let result = session_manager.init_session(session_id, session_type, params).await;
-        assert_eq!(result, Ok(()));
-        let session_notf = session_notf_receiver.recv().await.unwrap();
-        assert_eq!(
-            session_notf,
-            SessionNotification::SessionState {
-                session_id,
-                session_state: SessionState::SessionStateInit,
-                reason_code: ReasonCode::StateChangeWithSessionManagementCommands
-            }
-        );
-        let session_notf = session_notf_receiver.recv().await.unwrap();
-        assert_eq!(
-            session_notf,
-            SessionNotification::SessionState {
-                session_id,
-                session_state: SessionState::SessionStateIdle,
-                reason_code: ReasonCode::StateChangeWithSessionManagementCommands
-            }
-        );
-
-        let session_notf = session_notf_receiver.recv().await.unwrap();
-        assert_eq!(session_notf, SessionNotification::RangeData { session_id, range_data });
-
-        assert!(mock_uci_manager.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_reconfigure_app_config() {
-        let session_id = 0x123;
-        let session_type = SessionType::FiraRangingSession;
-
-        let initial_params = generate_params();
-        let initial_tlvs = initial_params.generate_tlvs();
-
-        let non_default_key_rotation_val = KeyRotation::Enable;
-        let idle_params = FiraAppConfigParamsBuilder::from_params(&initial_params)
-            .unwrap()
-            .key_rotation(non_default_key_rotation_val)
-            .build()
-            .unwrap();
-        let idle_tlvs = idle_params
-            .generate_updated_tlvs(&initial_params, SessionState::SessionStateIdle)
-            .unwrap();
-
-        let non_default_block_stride_val = 2u8;
-        let active_params = FiraAppConfigParamsBuilder::from_params(&idle_params)
-            .unwrap()
-            .block_stride_length(non_default_block_stride_val)
-            .build()
-            .unwrap();
-        let active_tlvs = active_params
-            .generate_updated_tlvs(&idle_params, SessionState::SessionStateIdle)
-            .unwrap();
-
-        let (mut session_manager, mut mock_uci_manager, _) =
-            setup_session_manager(move |uci_manager| {
-                uci_manager.expect_session_init(
-                    session_id,
-                    session_type,
-                    vec![session_status_notf(session_id, SessionState::SessionStateInit)],
-                    Ok(()),
-                );
-                uci_manager.expect_session_set_app_config(
-                    session_id,
-                    initial_tlvs,
-                    vec![session_status_notf(session_id, SessionState::SessionStateIdle)],
-                    Ok(SetAppConfigResponse {
-                        status: StatusCode::UciStatusOk,
-                        config_status: vec![],
-                    }),
-                );
-                uci_manager.expect_session_set_app_config(
-                    session_id,
-                    idle_tlvs,
-                    vec![],
-                    Ok(SetAppConfigResponse {
-                        status: StatusCode::UciStatusOk,
-                        config_status: vec![],
-                    }),
-                );
-                uci_manager.expect_range_start(
-                    session_id,
-                    vec![session_status_notf(session_id, SessionState::SessionStateActive)],
-                    Ok(()),
-                );
-                uci_manager.expect_session_set_app_config(
-                    session_id,
-                    active_tlvs,
-                    vec![],
-                    Ok(SetAppConfigResponse {
-                        status: StatusCode::UciStatusOk,
-                        config_status: vec![],
-                    }),
-                );
-            })
-            .await;
-
-        // Reconfiguring without first initing a session should fail.
-        let result = session_manager.reconfigure(session_id, initial_params.clone()).await;
-        assert_eq!(result, Err(Error::BadParameters));
-
-        let result =
-            session_manager.init_session(session_id, session_type, initial_params.clone()).await;
-        assert_eq!(result, Ok(()));
-
-        // Reconfiguring any parameters during idle state should succeed.
-        let result = session_manager.reconfigure(session_id, idle_params.clone()).await;
-        assert_eq!(result, Ok(()));
-
-        let result = session_manager.start_ranging(session_id).await;
-        assert_eq!(result, Ok(idle_params));
-
-        // Reconfiguring most parameters during active state should fail.
-        let result = session_manager.reconfigure(session_id, initial_params).await;
-        assert_eq!(result, Err(Error::BadParameters));
-
-        // Only some parameters are allowed to be reconfigured during active state.
-        let result = session_manager.reconfigure(session_id, active_params).await;
-        assert_eq!(result, Ok(()));
-
-        assert!(mock_uci_manager.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_params() {
-        let session_id = 0x123;
-        let session_type = SessionType::FiraRangingSession;
-
-        let params = generate_params();
-        let tlvs = params.generate_tlvs();
-
-        let (mut session_manager, mut mock_uci_manager, _) =
-            setup_session_manager(move |uci_manager| {
-                uci_manager.expect_session_init(
-                    session_id,
-                    session_type,
-                    vec![session_status_notf(session_id, SessionState::SessionStateInit)],
-                    Ok(()),
-                );
-                uci_manager.expect_session_set_app_config(
-                    session_id,
-                    tlvs,
-                    vec![session_status_notf(session_id, SessionState::SessionStateIdle)],
-                    Ok(SetAppConfigResponse {
-                        status: StatusCode::UciStatusOk,
-                        config_status: vec![],
-                    }),
-                );
-            })
-            .await;
-
-        // Getting session params without initing a session should fail
-        let result = session_manager.session_params(session_id).await;
-        assert_eq!(result, Err(Error::BadParameters));
-
-        let result = session_manager.init_session(session_id, session_type, params.clone()).await;
-        result.unwrap();
-
-        // Getting session params after they've been properly set should succeed
-        let result = session_manager.session_params(session_id).await;
-        assert_eq!(result, Ok(params));
-
-        assert!(mock_uci_manager.wait_expected_calls_done().await);
-    }
-}
diff --git a/src/rust/uwb_core/src/session/uwb_session.rs b/src/rust/uwb_core/src/session/uwb_session.rs
deleted file mode 100644
index 6b1556e..0000000
--- a/src/rust/uwb_core/src/session/uwb_session.rs
+++ /dev/null
@@ -1,407 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::collections::HashMap;
-use std::iter::FromIterator;
-use std::time::Duration;
-
-use log::{debug, error, warn};
-use tokio::sync::{mpsc, oneshot, watch};
-use tokio::time::timeout;
-
-use crate::error::{Error, Result};
-use crate::params::app_config_params::AppConfigParams;
-use crate::params::ccc_started_app_config_params::CccStartedAppConfigParams;
-use crate::params::uci_packets::{
-    Controlee, ControleeStatusList, Controlees, MulticastUpdateStatusCode, SessionId, SessionState,
-    SessionType, UpdateMulticastListAction,
-};
-use crate::uci::error::status_code_to_result;
-use crate::uci::uci_manager::UciManager;
-
-const NOTIFICATION_TIMEOUT_MS: u64 = 1000;
-
-#[derive(Debug)]
-pub(super) enum Response {
-    Null,
-    AppConfigParams(AppConfigParams),
-}
-pub(super) type ResponseSender = oneshot::Sender<Result<Response>>;
-
-pub(super) struct UwbSession {
-    cmd_sender: mpsc::UnboundedSender<(Command, ResponseSender)>,
-    state_sender: watch::Sender<SessionState>,
-    controlee_status_notf_sender: Option<oneshot::Sender<ControleeStatusList>>,
-}
-
-impl UwbSession {
-    pub fn new<T: UciManager>(
-        uci_manager: T,
-        session_id: SessionId,
-        session_type: SessionType,
-    ) -> Self {
-        let (cmd_sender, cmd_receiver) = mpsc::unbounded_channel();
-        let (state_sender, mut state_receiver) = watch::channel(SessionState::SessionStateDeinit);
-        // Mark the initial value of state as seen.
-        let _ = state_receiver.borrow_and_update();
-
-        let mut actor = UwbSessionActor::new(
-            cmd_receiver,
-            state_receiver,
-            uci_manager,
-            session_id,
-            session_type,
-        );
-        tokio::spawn(async move { actor.run().await });
-
-        Self { cmd_sender, state_sender, controlee_status_notf_sender: None }
-    }
-
-    pub fn initialize(&mut self, params: AppConfigParams, result_sender: ResponseSender) {
-        let _ = self.cmd_sender.send((Command::Initialize { params }, result_sender));
-    }
-
-    pub fn deinitialize(&mut self, result_sender: ResponseSender) {
-        let _ = self.cmd_sender.send((Command::Deinitialize, result_sender));
-    }
-
-    pub fn start_ranging(&mut self, result_sender: ResponseSender) {
-        let _ = self.cmd_sender.send((Command::StartRanging, result_sender));
-    }
-
-    pub fn stop_ranging(&mut self, result_sender: ResponseSender) {
-        let _ = self.cmd_sender.send((Command::StopRanging, result_sender));
-    }
-
-    pub fn reconfigure(&mut self, params: AppConfigParams, result_sender: ResponseSender) {
-        let _ = self.cmd_sender.send((Command::Reconfigure { params }, result_sender));
-    }
-
-    pub fn update_controller_multicast_list(
-        &mut self,
-        action: UpdateMulticastListAction,
-        controlees: Vec<Controlee>,
-        result_sender: ResponseSender,
-    ) {
-        let (notf_sender, notf_receiver) = oneshot::channel();
-        self.controlee_status_notf_sender = Some(notf_sender);
-        let _ = self.cmd_sender.send((
-            Command::UpdateControllerMulticastList { action, controlees, notf_receiver },
-            result_sender,
-        ));
-    }
-
-    pub fn params(&mut self, result_sender: ResponseSender) {
-        let _ = self.cmd_sender.send((Command::GetParams, result_sender));
-    }
-
-    pub fn on_session_status_changed(&mut self, state: SessionState) {
-        let _ = self.state_sender.send(state);
-    }
-
-    pub fn on_controller_multicast_list_updated(&mut self, status_list: ControleeStatusList) {
-        if let Some(sender) = self.controlee_status_notf_sender.take() {
-            let _ = sender.send(status_list);
-        }
-    }
-}
-
-struct UwbSessionActor<T: UciManager> {
-    cmd_receiver: mpsc::UnboundedReceiver<(Command, ResponseSender)>,
-    state_receiver: watch::Receiver<SessionState>,
-    uci_manager: T,
-    session_id: SessionId,
-    session_type: SessionType,
-    params: Option<AppConfigParams>,
-}
-
-impl<T: UciManager> UwbSessionActor<T> {
-    fn new(
-        cmd_receiver: mpsc::UnboundedReceiver<(Command, ResponseSender)>,
-        state_receiver: watch::Receiver<SessionState>,
-        uci_manager: T,
-        session_id: SessionId,
-        session_type: SessionType,
-    ) -> Self {
-        Self { cmd_receiver, state_receiver, uci_manager, session_id, session_type, params: None }
-    }
-
-    async fn run(&mut self) {
-        loop {
-            tokio::select! {
-                cmd = self.cmd_receiver.recv() => {
-                    match cmd {
-                        None => {
-                            debug!("UwbSession is about to drop.");
-                            break;
-                        }
-                        Some((cmd, result_sender)) => {
-                            let result = match cmd {
-                                Command::Initialize { params } => self.initialize(params).await,
-                                Command::Deinitialize => self.deinitialize().await,
-                                Command::StartRanging => self.start_ranging().await,
-                                Command::StopRanging => self.stop_ranging().await,
-                                Command::Reconfigure { params } => self.reconfigure(params).await,
-                                Command::UpdateControllerMulticastList {
-                                    action,
-                                    controlees,
-                                    notf_receiver,
-                                } => {
-                                    self.update_controller_multicast_list(
-                                        action,
-                                        controlees,
-                                        notf_receiver,
-                                    )
-                                    .await
-                                },
-                                Command::GetParams => self.params().await,
-                            };
-                            let _ = result_sender.send(result);
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    async fn initialize(&mut self, params: AppConfigParams) -> Result<Response> {
-        debug_assert!(*self.state_receiver.borrow() == SessionState::SessionStateDeinit);
-
-        // TODO(b/279669973): Support CR-461 fully here. Need to wait for session init rsp.
-        // But, that does not seem to be fully plumbed up in session_manager yet.
-        self.uci_manager.session_init(self.session_id, self.session_type).await?;
-        self.wait_state(SessionState::SessionStateInit).await?;
-
-        self.reconfigure(params).await?;
-        self.wait_state(SessionState::SessionStateIdle).await?;
-
-        Ok(Response::Null)
-    }
-
-    async fn deinitialize(&mut self) -> Result<Response> {
-        self.uci_manager.session_deinit(self.session_id).await?;
-        Ok(Response::Null)
-    }
-
-    async fn start_ranging(&mut self) -> Result<Response> {
-        let state = *self.state_receiver.borrow();
-        match state {
-            SessionState::SessionStateActive => {
-                warn!("Session {} is already running", self.session_id);
-                Err(Error::BadParameters)
-            }
-            SessionState::SessionStateIdle => {
-                self.uci_manager.range_start(self.session_id).await?;
-                self.wait_state(SessionState::SessionStateActive).await?;
-
-                let params = if self.session_type != SessionType::Ccc {
-                    // self.params should be Some() in this state.
-                    self.params.clone().unwrap()
-                } else {
-                    // Get the CCC specific app config after ranging started.
-                    let tlvs = self
-                        .uci_manager
-                        .session_get_app_config(self.session_id, vec![])
-                        .await
-                        .map_err(|e| {
-                            error!("Failed to get CCC app config after start ranging: {:?}", e);
-                            e
-                        })?;
-                    let config_map = HashMap::from_iter(tlvs.into_iter().map(|tlv| {
-                        let tlv = tlv.into_inner();
-                        (tlv.cfg_id, tlv.v.clone())
-                    }));
-                    let params = CccStartedAppConfigParams::from_config_map(config_map)
-                        .ok_or_else(|| {
-                            error!("Failed to generate CccStartedAppConfigParams");
-                            Error::Unknown
-                        })?;
-                    AppConfigParams::CccStarted(params)
-                };
-                Ok(Response::AppConfigParams(params))
-            }
-            _ => {
-                error!("Session {} cannot start running at {:?}", self.session_id, state);
-                Err(Error::BadParameters)
-            }
-        }
-    }
-
-    async fn stop_ranging(&mut self) -> Result<Response> {
-        let state = *self.state_receiver.borrow();
-        match state {
-            SessionState::SessionStateIdle => {
-                warn!("Session {} is already stopped", self.session_id);
-                Ok(Response::Null)
-            }
-            SessionState::SessionStateActive => {
-                self.uci_manager.range_stop(self.session_id).await?;
-                self.wait_state(SessionState::SessionStateIdle).await?;
-
-                Ok(Response::Null)
-            }
-            _ => {
-                error!("Session {} cannot stop running at {:?}", self.session_id, state);
-                Err(Error::BadParameters)
-            }
-        }
-    }
-
-    async fn reconfigure(&mut self, params: AppConfigParams) -> Result<Response> {
-        debug_assert!(*self.state_receiver.borrow() != SessionState::SessionStateDeinit);
-
-        let state = *self.state_receiver.borrow();
-        let tlvs = match self.params.as_ref() {
-            Some(prev_params) => {
-                if let Some(tlvs) = params.generate_updated_tlvs(prev_params, state) {
-                    tlvs
-                } else {
-                    error!("Cannot update the app config at state {:?}: {:?}", state, params);
-                    return Err(Error::BadParameters);
-                }
-            }
-            None => params.generate_tlvs(),
-        };
-
-        let result = self.uci_manager.session_set_app_config(self.session_id, tlvs).await?;
-        for config_status in result.config_status.iter() {
-            warn!(
-                "AppConfig {:?} is not applied: {:?}",
-                config_status.cfg_id, config_status.status
-            );
-        }
-        if let Err(e) = status_code_to_result(result.status) {
-            error!("Failed to set app_config. StatusCode: {:?}", result.status);
-            return Err(e);
-        }
-
-        self.params = Some(params);
-        Ok(Response::Null)
-    }
-
-    async fn update_controller_multicast_list(
-        &mut self,
-        action: UpdateMulticastListAction,
-        controlees: Vec<Controlee>,
-        notf_receiver: oneshot::Receiver<ControleeStatusList>,
-    ) -> Result<Response> {
-        if self.session_type == SessionType::Ccc {
-            error!("Cannot update multicast list for CCC session");
-            return Err(Error::BadParameters);
-        }
-
-        let state = *self.state_receiver.borrow();
-        if !matches!(state, SessionState::SessionStateIdle | SessionState::SessionStateActive) {
-            error!("Cannot update multicast list at state {:?}", state);
-            return Err(Error::BadParameters);
-        }
-
-        self.uci_manager
-            .session_update_controller_multicast_list(
-                self.session_id,
-                action,
-                Controlees::NoSessionKey(controlees),
-                false,
-                false,
-            )
-            .await?;
-
-        // Wait for the notification of the update status.
-        let results = timeout(Duration::from_millis(NOTIFICATION_TIMEOUT_MS), notf_receiver)
-            .await
-            .map_err(|_| {
-                error!("Timeout waiting for the multicast list notification");
-                Error::Timeout
-            })?
-            .map_err(|_| {
-                error!("oneshot sender is dropped.");
-                Error::Unknown
-            })?;
-
-        // Check the update status for adding new controlees.
-        if action == UpdateMulticastListAction::AddControlee {
-            match results {
-                ControleeStatusList::V1(res) => {
-                    for result in res.iter() {
-                        if result.status != MulticastUpdateStatusCode::StatusOkMulticastListUpdate {
-                            error!("Failed to update multicast list: {:?}", result);
-                            return Err(Error::Unknown);
-                        }
-                    }
-                }
-                ControleeStatusList::V2(res) => {
-                    for result in res.iter() {
-                        if result.status != MulticastUpdateStatusCode::StatusOkMulticastListUpdate {
-                            error!("Failed to update multicast list: {:?}", result);
-                            return Err(Error::Unknown);
-                        }
-                    }
-                }
-            }
-        }
-
-        Ok(Response::Null)
-    }
-
-    async fn wait_state(&mut self, expected_state: SessionState) -> Result<()> {
-        // Wait for the notification of the session status.
-        timeout(Duration::from_millis(NOTIFICATION_TIMEOUT_MS), self.state_receiver.changed())
-            .await
-            .map_err(|_| {
-                error!("Timeout waiting for the session status notification");
-                Error::Timeout
-            })?
-            .map_err(|_| {
-                debug!("UwbSession is about to drop.");
-                Error::Unknown
-            })?;
-
-        // Check if the latest session status is expected or not.
-        let state = *self.state_receiver.borrow();
-        if state != expected_state {
-            error!(
-                "Transit to wrong Session state {:?}. The expected state is {:?}",
-                state, expected_state
-            );
-            return Err(Error::BadParameters);
-        }
-
-        Ok(())
-    }
-
-    async fn params(&mut self) -> Result<Response> {
-        match &self.params {
-            None => Err(Error::BadParameters),
-            Some(params) => Ok(Response::AppConfigParams(params.clone())),
-        }
-    }
-}
-
-enum Command {
-    Initialize {
-        params: AppConfigParams,
-    },
-    Deinitialize,
-    StartRanging,
-    StopRanging,
-    Reconfigure {
-        params: AppConfigParams,
-    },
-    UpdateControllerMulticastList {
-        action: UpdateMulticastListAction,
-        controlees: Vec<Controlee>,
-        notf_receiver: oneshot::Receiver<ControleeStatusList>,
-    },
-    GetParams,
-}
diff --git a/src/rust/uwb_core/src/uci.rs b/src/rust/uwb_core/src/uci.rs
deleted file mode 100644
index 82577d8..0000000
--- a/src/rust/uwb_core/src/uci.rs
+++ /dev/null
@@ -1,50 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module provides the functionalities related to UWB Command Interface (UCI).
-
-mod command;
-mod message;
-mod pcapng_block;
-mod response;
-mod timeout_uci_hal;
-
-pub(crate) mod error;
-pub(crate) mod notification;
-pub(crate) mod uci_manager;
-
-pub mod pcapng_uci_logger_factory;
-pub mod uci_hal;
-pub mod uci_logger;
-pub mod uci_logger_factory;
-pub mod uci_logger_pcapng;
-pub mod uci_manager_sync;
-
-#[cfg(test)]
-pub(crate) mod mock_uci_hal;
-#[cfg(test)]
-pub(crate) mod mock_uci_logger;
-#[cfg(any(test, feature = "mock-utils"))]
-pub mod mock_uci_manager;
-
-// Re-export the public elements.
-pub use command::UciCommand;
-pub use notification::{
-    CoreNotification, DataRcvNotification, RadarDataRcvNotification, RadarSweepData,
-    RangingMeasurements, RfTestNotification, RfTestPerRxData, SessionNotification, SessionRangeData,
-    UciNotification,
-};
-pub use uci_hal::{NopUciHal, UciHal, UciHalPacket};
-pub use uci_logger_factory::{NopUciLoggerFactory, UciLoggerFactory};
-pub use uci_manager::UciManagerImpl;
diff --git a/src/rust/uwb_core/src/uci/command.rs b/src/rust/uwb_core/src/uci/command.rs
deleted file mode 100644
index 9bc0aef..0000000
--- a/src/rust/uwb_core/src/uci/command.rs
+++ /dev/null
@@ -1,628 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::convert::TryFrom;
-
-use bytes::Bytes;
-use log::error;
-
-use crate::error::{Error, Result};
-use crate::params::uci_packets::{
-    AppConfigTlv, AppConfigTlvType, Controlees, CountryCode, DeviceConfigId, DeviceConfigTlv,
-    RadarConfigTlv, RadarConfigTlvType, ResetConfig, RfTestConfigTlv, SessionId, SessionToken,
-    SessionType, UpdateMulticastListAction,
-};
-use uwb_uci_packets::{
-    build_data_transfer_phase_config_cmd, build_session_update_controller_multicast_list_cmd,
-    ControleePhaseList, ControllerPhaseList, GroupId, MessageType,
-};
-
-/// The enum to represent the UCI commands. The definition of each field should follow UCI spec.
-#[allow(missing_docs)]
-#[derive(Debug, Clone, PartialEq)]
-pub enum UciCommand {
-    DeviceReset {
-        reset_config: ResetConfig,
-    },
-    CoreGetDeviceInfo,
-    CoreGetCapsInfo,
-    CoreSetConfig {
-        config_tlvs: Vec<DeviceConfigTlv>,
-    },
-    CoreGetConfig {
-        cfg_id: Vec<DeviceConfigId>,
-    },
-    CoreQueryTimeStamp,
-    SessionInit {
-        session_id: SessionId,
-        session_type: SessionType,
-    },
-    SessionDeinit {
-        session_token: SessionToken,
-    },
-    SessionSetAppConfig {
-        session_token: SessionToken,
-        config_tlvs: Vec<AppConfigTlv>,
-    },
-    SessionGetAppConfig {
-        session_token: SessionToken,
-        app_cfg: Vec<AppConfigTlvType>,
-    },
-    SessionGetCount,
-    SessionGetState {
-        session_token: SessionToken,
-    },
-    SessionUpdateControllerMulticastList {
-        session_token: SessionToken,
-        action: UpdateMulticastListAction,
-        controlees: Controlees,
-        is_multicast_list_ntf_v2_supported: bool,
-        is_multicast_list_rsp_v2_supported: bool,
-    },
-    SessionUpdateDtTagRangingRounds {
-        session_token: u32,
-        ranging_round_indexes: Vec<u8>,
-    },
-    SessionQueryMaxDataSize {
-        session_token: SessionToken,
-    },
-    SessionStart {
-        session_token: SessionToken,
-    },
-    SessionStop {
-        session_token: SessionToken,
-    },
-    SessionGetRangingCount {
-        session_token: SessionToken,
-    },
-    SessionSetHybridControllerConfig {
-        session_token: SessionToken,
-        number_of_phases: u8,
-        phase_list: Vec<ControllerPhaseList>,
-    },
-    SessionSetHybridControleeConfig {
-        session_token: SessionToken,
-        controlee_phase_list: Vec<ControleePhaseList>,
-    },
-    SessionDataTransferPhaseConfig {
-        session_token: SessionToken,
-        dtpcm_repetition: u8,
-        data_transfer_control: u8,
-        dtpml_size: u8,
-        mac_address: Vec<u8>,
-        slot_bitmap: Vec<u8>,
-        stop_data_transfer: Vec<u8>,
-    },
-    AndroidSetCountryCode {
-        country_code: CountryCode,
-    },
-    AndroidGetPowerStats,
-    AndroidSetRadarConfig {
-        session_token: SessionToken,
-        config_tlvs: Vec<RadarConfigTlv>,
-    },
-    AndroidGetRadarConfig {
-        session_token: SessionToken,
-        radar_cfg: Vec<RadarConfigTlvType>,
-    },
-    RawUciCmd {
-        mt: u32,
-        gid: u32,
-        oid: u32,
-        payload: Vec<u8>,
-    },
-    SessionSetRfTestConfig {
-        session_token: SessionToken,
-        config_tlvs: Vec<RfTestConfigTlv>,
-    },
-    TestPeriodicTx {
-        psdu_data: Vec<u8>,
-    },
-    TestPerRx {
-        psdu_data: Vec<u8>,
-    },
-    StopRfTest,
-}
-
-impl TryFrom<UciCommand> for uwb_uci_packets::UciControlPacket {
-    type Error = Error;
-    fn try_from(cmd: UciCommand) -> std::result::Result<Self, Self::Error> {
-        let packet = match cmd {
-            // UCI Session Config Commands
-            UciCommand::SessionInit { session_id, session_type } => {
-                uwb_uci_packets::SessionInitCmdBuilder { session_id, session_type }.build().into()
-            }
-            UciCommand::SessionDeinit { session_token } => {
-                uwb_uci_packets::SessionDeinitCmdBuilder { session_token }.build().into()
-            }
-            UciCommand::CoreGetDeviceInfo => {
-                uwb_uci_packets::GetDeviceInfoCmdBuilder {}.build().into()
-            }
-            UciCommand::CoreGetCapsInfo => uwb_uci_packets::GetCapsInfoCmdBuilder {}.build().into(),
-            UciCommand::SessionGetState { session_token } => {
-                uwb_uci_packets::SessionGetStateCmdBuilder { session_token }.build().into()
-            }
-            UciCommand::SessionUpdateControllerMulticastList {
-                session_token,
-                action,
-                controlees,
-                ..
-            } => build_session_update_controller_multicast_list_cmd(
-                session_token,
-                action,
-                controlees,
-            )
-            .map_err(|_| Error::BadParameters)?
-            .into(),
-            UciCommand::CoreSetConfig { config_tlvs } => {
-                uwb_uci_packets::SetConfigCmdBuilder { tlvs: config_tlvs }.build().into()
-            }
-            UciCommand::CoreGetConfig { cfg_id } => uwb_uci_packets::GetConfigCmdBuilder {
-                cfg_id: cfg_id.into_iter().map(u8::from).collect(),
-            }
-            .build()
-            .into(),
-            UciCommand::CoreQueryTimeStamp {} => {
-                uwb_uci_packets::CoreQueryTimeStampCmdBuilder {}.build().into()
-            }
-            UciCommand::SessionSetAppConfig { session_token, config_tlvs } => {
-                uwb_uci_packets::SessionSetAppConfigCmdBuilder {
-                    session_token,
-                    tlvs: config_tlvs.into_iter().map(|tlv| tlv.into_inner()).collect(),
-                }
-                .build()
-                .into()
-            }
-            UciCommand::SessionGetAppConfig { session_token, app_cfg } => {
-                uwb_uci_packets::SessionGetAppConfigCmdBuilder {
-                    session_token,
-                    app_cfg: app_cfg.into_iter().map(u8::from).collect(),
-                }
-                .build()
-                .into()
-            }
-            UciCommand::AndroidSetRadarConfig { session_token, config_tlvs } => {
-                uwb_uci_packets::AndroidSetRadarConfigCmdBuilder {
-                    session_token,
-                    tlvs: config_tlvs,
-                }
-                .build()
-                .into()
-            }
-            UciCommand::AndroidGetRadarConfig { session_token, radar_cfg } => {
-                uwb_uci_packets::AndroidGetRadarConfigCmdBuilder {
-                    session_token,
-                    tlvs: radar_cfg.into_iter().map(u8::from).collect(),
-                }
-                .build()
-                .into()
-            }
-            UciCommand::SessionUpdateDtTagRangingRounds {
-                session_token,
-                ranging_round_indexes,
-            } => uwb_uci_packets::SessionUpdateDtTagRangingRoundsCmdBuilder {
-                session_token,
-                ranging_round_indexes,
-            }
-            .build()
-            .into(),
-            UciCommand::AndroidGetPowerStats => {
-                uwb_uci_packets::AndroidGetPowerStatsCmdBuilder {}.build().into()
-            }
-            UciCommand::RawUciCmd { mt, gid, oid, payload } => {
-                build_raw_uci_cmd_packet(mt, gid, oid, payload)?
-            }
-            UciCommand::SessionGetCount => {
-                uwb_uci_packets::SessionGetCountCmdBuilder {}.build().into()
-            }
-            UciCommand::AndroidSetCountryCode { country_code } => {
-                uwb_uci_packets::AndroidSetCountryCodeCmdBuilder {
-                    country_code: country_code.into(),
-                }
-                .build()
-                .into()
-            }
-            UciCommand::DeviceReset { reset_config } => {
-                uwb_uci_packets::DeviceResetCmdBuilder { reset_config }.build().into()
-            }
-            // UCI Session Control Commands
-            UciCommand::SessionStart { session_token } => {
-                uwb_uci_packets::SessionStartCmdBuilder { session_token }.build().into()
-            }
-            UciCommand::SessionStop { session_token } => {
-                uwb_uci_packets::SessionStopCmdBuilder { session_token }.build().into()
-            }
-            UciCommand::SessionGetRangingCount { session_token } => {
-                uwb_uci_packets::SessionGetRangingCountCmdBuilder { session_token }.build().into()
-            }
-            UciCommand::SessionQueryMaxDataSize { session_token } => {
-                uwb_uci_packets::SessionQueryMaxDataSizeCmdBuilder { session_token }.build().into()
-            }
-            UciCommand::SessionSetHybridControllerConfig {
-                session_token,
-                number_of_phases,
-                phase_list,
-            } => uwb_uci_packets::SessionSetHybridControllerConfigCmdBuilder {
-                session_token,
-                number_of_phases,
-                phase_list,
-            }
-            .build()
-            .into(),
-            UciCommand::SessionSetHybridControleeConfig { session_token, controlee_phase_list } => {
-                uwb_uci_packets::SessionSetHybridControleeConfigCmdBuilder {
-                    session_token,
-                    controlee_phase_list,
-                }
-                .build()
-                .into()
-            }
-            UciCommand::SessionDataTransferPhaseConfig {
-                session_token,
-                dtpcm_repetition,
-                data_transfer_control,
-                dtpml_size,
-                mac_address,
-                slot_bitmap,
-                stop_data_transfer,
-            } => build_data_transfer_phase_config_cmd(
-                session_token,
-                dtpcm_repetition,
-                data_transfer_control,
-                dtpml_size,
-                mac_address,
-                slot_bitmap,
-                stop_data_transfer,
-            )
-            .map_err(|_| Error::BadParameters)?
-            .into(),
-            UciCommand::SessionSetRfTestConfig { session_token, config_tlvs } => {
-                uwb_uci_packets::SessionSetRfTestConfigCmdBuilder {
-                    session_token,
-                    tlvs: config_tlvs,
-                }
-                .build()
-                .into()
-            }
-            UciCommand::TestPeriodicTx { psdu_data } => {
-                uwb_uci_packets::TestPeriodicTxCmdBuilder { psdu_data }.build().into()
-            }
-            UciCommand::TestPerRx { psdu_data } => {
-                uwb_uci_packets::TestPerRxCmdBuilder { psdu_data }.build().into()
-            }
-            UciCommand::StopRfTest {} => uwb_uci_packets::StopRfTestCmdBuilder {}.build().into(),
-        };
-        Ok(packet)
-    }
-}
-
-fn build_raw_uci_cmd_packet(
-    mt: u32,
-    gid: u32,
-    oid: u32,
-    payload: Vec<u8>,
-) -> Result<uwb_uci_packets::UciControlPacket> {
-    let group_id = u8::try_from(gid).or(Err(0)).and_then(GroupId::try_from).map_err(|_| {
-        error!("Invalid GroupId: {}", gid);
-        Error::BadParameters
-    })?;
-    let payload = if payload.is_empty() { None } else { Some(Bytes::from(payload)) };
-    let opcode = u8::try_from(oid).map_err(|_| {
-        error!("Invalid opcod: {}", oid);
-        Error::BadParameters
-    })?;
-    let message_type =
-        u8::try_from(mt).or(Err(0)).and_then(MessageType::try_from).map_err(|_| {
-            error!("Invalid MessageType: {}", mt);
-            Error::BadParameters
-        })?;
-    match uwb_uci_packets::build_uci_control_packet(message_type, group_id, opcode, payload) {
-        Some(cmd) => Ok(cmd),
-        None => Err(Error::BadParameters),
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_build_raw_uci_cmd() {
-        let payload = vec![0x01, 0x02];
-        let cmd_packet = build_raw_uci_cmd_packet(1, 9, 0, payload.clone()).unwrap();
-        assert_eq!(payload, cmd_packet.to_raw_payload());
-    }
-
-    #[test]
-    fn test_convert_uci_cmd_to_packets() {
-        let mut cmd = UciCommand::DeviceReset { reset_config: ResetConfig::UwbsReset };
-        let mut packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::DeviceResetCmdBuilder { reset_config: ResetConfig::UwbsReset }
-                .build()
-                .into()
-        );
-
-        cmd = UciCommand::CoreGetDeviceInfo {};
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(packet, uwb_uci_packets::GetDeviceInfoCmdBuilder {}.build().into());
-
-        cmd = UciCommand::CoreGetCapsInfo {};
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(packet, uwb_uci_packets::GetCapsInfoCmdBuilder {}.build().into());
-
-        let device_cfg_tlv = DeviceConfigTlv { cfg_id: DeviceConfigId::DeviceState, v: vec![0] };
-        cmd = UciCommand::CoreSetConfig { config_tlvs: vec![device_cfg_tlv.clone()] };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::SetConfigCmdBuilder { tlvs: vec![device_cfg_tlv] }.build().into()
-        );
-
-        cmd = UciCommand::CoreGetConfig { cfg_id: vec![DeviceConfigId::DeviceState] };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(packet, uwb_uci_packets::GetConfigCmdBuilder { cfg_id: vec![0] }.build().into());
-
-        cmd = UciCommand::SessionInit {
-            session_id: 1,
-            session_type: SessionType::FiraRangingSession,
-        };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::SessionInitCmdBuilder {
-                session_id: 1,
-                session_type: SessionType::FiraRangingSession
-            }
-            .build()
-            .into()
-        );
-
-        cmd = UciCommand::SessionDeinit { session_token: 1 };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::SessionDeinitCmdBuilder { session_token: 1 }.build().into()
-        );
-
-        cmd = UciCommand::SessionSetAppConfig { session_token: 1, config_tlvs: vec![] };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::SessionSetAppConfigCmdBuilder { session_token: 1, tlvs: vec![] }
-                .build()
-                .into()
-        );
-
-        cmd = UciCommand::SessionGetAppConfig { session_token: 1, app_cfg: vec![] };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::SessionGetAppConfigCmdBuilder { session_token: 1, app_cfg: vec![] }
-                .build()
-                .into()
-        );
-
-        cmd = UciCommand::SessionGetCount {};
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(packet, uwb_uci_packets::SessionGetCountCmdBuilder {}.build().into());
-
-        cmd = UciCommand::SessionGetState { session_token: 1 };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::SessionGetStateCmdBuilder { session_token: 1 }.build().into()
-        );
-
-        cmd = UciCommand::SessionUpdateControllerMulticastList {
-            session_token: 1,
-            action: UpdateMulticastListAction::AddControlee,
-            controlees: Controlees::NoSessionKey(vec![]),
-            is_multicast_list_ntf_v2_supported: false,
-            is_multicast_list_rsp_v2_supported: false,
-        };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            build_session_update_controller_multicast_list_cmd(
-                1,
-                UpdateMulticastListAction::AddControlee,
-                Controlees::NoSessionKey(vec![])
-            )
-            .map_err(|_| Error::BadParameters)
-            .unwrap()
-            .into()
-        );
-
-        cmd = UciCommand::SessionUpdateDtTagRangingRounds {
-            session_token: 1,
-            ranging_round_indexes: vec![0],
-        };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::SessionUpdateDtTagRangingRoundsCmdBuilder {
-                session_token: 1,
-                ranging_round_indexes: vec![0]
-            }
-            .build()
-            .into()
-        );
-
-        cmd = UciCommand::SessionQueryMaxDataSize { session_token: 1 };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::SessionQueryMaxDataSizeCmdBuilder { session_token: 1 }.build().into()
-        );
-
-        cmd = UciCommand::SessionStart { session_token: 1 };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::SessionStartCmdBuilder { session_token: 1 }.build().into()
-        );
-
-        cmd = UciCommand::SessionStop { session_token: 1 };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::SessionStopCmdBuilder { session_token: 1 }.build().into()
-        );
-
-        cmd = UciCommand::SessionGetRangingCount { session_token: 1 };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::SessionGetRangingCountCmdBuilder { session_token: 1 }.build().into()
-        );
-
-        let country_code: [u8; 2] = [85, 83];
-        cmd = UciCommand::AndroidSetCountryCode {
-            country_code: CountryCode::new(&country_code).unwrap(),
-        };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::AndroidSetCountryCodeCmdBuilder { country_code }.build().into()
-        );
-
-        cmd = UciCommand::AndroidGetPowerStats {};
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd).unwrap();
-        assert_eq!(packet, uwb_uci_packets::AndroidGetPowerStatsCmdBuilder {}.build().into());
-
-        cmd = UciCommand::AndroidSetRadarConfig { session_token: 1, config_tlvs: vec![] };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::AndroidSetRadarConfigCmdBuilder { session_token: 1, tlvs: vec![] }
-                .build()
-                .into()
-        );
-
-        cmd = UciCommand::AndroidGetRadarConfig { session_token: 1, radar_cfg: vec![] };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::AndroidGetRadarConfigCmdBuilder { session_token: 1, tlvs: vec![] }
-                .build()
-                .into()
-        );
-
-        cmd = UciCommand::CoreQueryTimeStamp {};
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd).unwrap();
-        assert_eq!(packet, uwb_uci_packets::CoreQueryTimeStampCmdBuilder {}.build().into());
-
-        cmd = UciCommand::RawUciCmd { mt: 1, gid: 0xa, oid: 0, payload: vec![0, 1, 2, 3] };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd).unwrap();
-        assert_eq!(
-            packet,
-            build_raw_uci_cmd_packet(1, 0xa, 0, vec![0, 1, 2, 3])
-                .expect("Failed to build raw cmd packet.")
-        );
-
-        let phase_list_short_mac_address = vec![uwb_uci_packets::ControllerPhaseList {
-            session_token: 0x1324_3546,
-            start_slot_index: 0x1111,
-            end_slot_index: 0x1121,
-            control: 0x01,
-            mac_address: [0x1, 0x2].to_vec(),
-        }];
-        cmd = UciCommand::SessionSetHybridControllerConfig {
-            session_token: 1,
-            number_of_phases: 0,
-            phase_list: vec![uwb_uci_packets::ControllerPhaseList {
-                session_token: 0x1324_3546,
-                start_slot_index: 0x1111,
-                end_slot_index: 0x1121,
-                control: 0x01,
-                mac_address: [0x1, 0x2].to_vec(),
-            }],
-        };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd).unwrap();
-        let phase_list_clone = phase_list_short_mac_address.clone();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::SessionSetHybridControllerConfigCmdBuilder {
-                session_token: 1,
-                number_of_phases: 0,
-                phase_list: phase_list_clone,
-            }
-            .build()
-            .into()
-        );
-
-        cmd = UciCommand::SessionSetHybridControleeConfig {
-            session_token: 1,
-            controlee_phase_list: vec![],
-        };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::SessionSetHybridControleeConfigCmdBuilder {
-                controlee_phase_list: vec![],
-                session_token: 1,
-            }
-            .build()
-            .into()
-        );
-
-        cmd = UciCommand::SessionDataTransferPhaseConfig {
-            session_token: 1,
-            dtpcm_repetition: 0,
-            data_transfer_control: 2,
-            dtpml_size: 1,
-            mac_address: vec![0, 1],
-            slot_bitmap: vec![2, 3],
-            stop_data_transfer: vec![0],
-        };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::SessionDataTransferPhaseConfigCmdBuilder {
-                session_token: 1,
-                dtpcm_repetition: 0,
-                data_transfer_control: 2,
-                dtpml_size: 1,
-                payload: Some(vec![0x00, 0x01, 0x02, 0x03, 0x00].into()),
-            }
-            .build()
-            .into()
-        );
-
-        cmd = UciCommand::SessionSetRfTestConfig { session_token: 1, config_tlvs: vec![] };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::SessionSetRfTestConfigCmdBuilder { session_token: 1, tlvs: vec![] }
-                .build()
-                .into()
-        );
-
-        cmd = UciCommand::TestPeriodicTx { psdu_data: vec![0] };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::TestPeriodicTxCmdBuilder { psdu_data: vec![0] }.build().into()
-        );
-
-        cmd = UciCommand::TestPerRx { psdu_data: vec![0] };
-        packet = uwb_uci_packets::UciControlPacket::try_from(cmd.clone()).unwrap();
-        assert_eq!(
-            packet,
-            uwb_uci_packets::TestPerRxCmdBuilder { psdu_data: vec![0] }.build().into()
-        );
-    }
-}
diff --git a/src/rust/uwb_core/src/uci/error.rs b/src/rust/uwb_core/src/uci/error.rs
deleted file mode 100644
index ed5850a..0000000
--- a/src/rust/uwb_core/src/uci/error.rs
+++ /dev/null
@@ -1,35 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use crate::error::{Error, Result};
-use crate::params::uci_packets::StatusCode;
-
-pub(crate) fn status_code_to_result(status: StatusCode) -> Result<()> {
-    match status {
-        StatusCode::UciStatusOk => Ok(()),
-        StatusCode::UciStatusMaxSessionsExceeded => Err(Error::MaxSessionsExceeded),
-        StatusCode::UciStatusInvalidParam
-        | StatusCode::UciStatusInvalidRange
-        | StatusCode::UciStatusInvalidMsgSize => Err(Error::BadParameters),
-        StatusCode::UciStatusSessionDuplicate => Err(Error::DuplicatedSessionId),
-        StatusCode::UciStatusFailed
-        | StatusCode::UciStatusSessionNotExist
-        | StatusCode::UciStatusSessionNotConfigured
-        | StatusCode::UciStatusErrorCccSeBusy
-        | StatusCode::UciStatusErrorCccLifecycle => Err(Error::ProtocolSpecific),
-        StatusCode::UciStatusCommandRetry => Err(Error::CommandRetry),
-        StatusCode::UciStatusRegulationUwbOff => Err(Error::RegulationUwbOff),
-        _ => Err(Error::Unknown),
-    }
-}
diff --git a/src/rust/uwb_core/src/uci/message.rs b/src/rust/uwb_core/src/uci/message.rs
deleted file mode 100644
index a01febf..0000000
--- a/src/rust/uwb_core/src/uci/message.rs
+++ /dev/null
@@ -1,55 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::convert::{TryFrom, TryInto};
-
-use log::error;
-
-use crate::error::Error;
-use crate::uci::notification::UciNotification;
-use crate::uci::response::UciResponse;
-
-use crate::params::UCIMajorVersion;
-
-#[derive(Debug)]
-pub(super) enum UciMessage {
-    Response(UciResponse),
-    Notification(UciNotification),
-}
-
-impl TryFrom<(uwb_uci_packets::UciControlPacket, UCIMajorVersion, bool, bool)> for UciMessage {
-    type Error = Error;
-    fn try_from(
-        pair: (uwb_uci_packets::UciControlPacket, UCIMajorVersion, bool, bool),
-    ) -> Result<Self, Self::Error> {
-        let packet = pair.0;
-        let uci_fira_major_ver = pair.1;
-        let is_multicast_list_ntf_v2_supported = pair.2;
-        let is_multicast_list_rsp_v2_supported = pair.3;
-        match packet.specialize() {
-            uwb_uci_packets::UciControlPacketChild::UciResponse(evt) => Ok(UciMessage::Response(
-                (evt, uci_fira_major_ver, is_multicast_list_rsp_v2_supported).try_into()?,
-            )),
-            uwb_uci_packets::UciControlPacketChild::UciNotification(evt) => {
-                Ok(UciMessage::Notification(
-                    (evt, uci_fira_major_ver, is_multicast_list_ntf_v2_supported).try_into()?,
-                ))
-            }
-            _ => {
-                error!("Unknown packet for converting to UciMessage: {:?}", packet);
-                Err(Error::Unknown)
-            }
-        }
-    }
-}
diff --git a/src/rust/uwb_core/src/uci/mock_uci_hal.rs b/src/rust/uwb_core/src/uci/mock_uci_hal.rs
deleted file mode 100644
index 4b170f1..0000000
--- a/src/rust/uwb_core/src/uci/mock_uci_hal.rs
+++ /dev/null
@@ -1,240 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::collections::VecDeque;
-use std::sync::{Arc, Mutex};
-use std::time::Duration;
-
-use async_trait::async_trait;
-use log::error;
-use tokio::sync::{mpsc, Notify};
-use tokio::time::timeout;
-
-use crate::error::{Error, Result};
-use crate::params::uci_packets::SessionId;
-use crate::uci::command::UciCommand;
-use crate::uci::uci_hal::{UciHal, UciHalPacket};
-
-/// The mock implementation of UciHal.
-#[derive(Default, Clone)]
-pub struct MockUciHal {
-    // Wrap inside Arc<Mutex<>> so that the MockUciHal.clone(s) refer to the same object.
-    packet_sender: Arc<Mutex<Option<mpsc::UnboundedSender<UciHalPacket>>>>,
-    expected_calls: Arc<Mutex<VecDeque<ExpectedCall>>>,
-    expect_call_consumed: Arc<Notify>,
-}
-
-impl MockUciHal {
-    pub fn new() -> Self {
-        Default::default()
-    }
-
-    pub fn expected_open(&mut self, packets: Option<Vec<UciHalPacket>>, out: Result<()>) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::Open { packets, out });
-    }
-
-    pub fn expected_close(&mut self, out: Result<()>) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::Close { out });
-    }
-
-    pub fn expected_send_command(
-        &mut self,
-        expected_cmd: UciCommand,
-        packets: Vec<UciHalPacket>,
-        out: Result<()>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::SendCommand {
-            expected_cmd,
-            packets,
-            out,
-        });
-    }
-
-    pub fn expected_send_packet(
-        &mut self,
-        expected_packet_tx: UciHalPacket,
-        inject_packets_rx: Vec<UciHalPacket>,
-        out: Result<()>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::SendPacket {
-            expected_packet_tx,
-            inject_packets_rx,
-            out,
-        });
-    }
-
-    pub fn expected_notify_session_initialized(
-        &mut self,
-        expected_session_id: SessionId,
-        out: Result<()>,
-    ) {
-        self.expected_calls
-            .lock()
-            .unwrap()
-            .push_back(ExpectedCall::NotifySessionInitialized { expected_session_id, out });
-    }
-
-    pub async fn wait_expected_calls_done(&mut self) -> bool {
-        while !self.expected_calls.lock().unwrap().is_empty() {
-            if timeout(Duration::from_secs(1), self.expect_call_consumed.notified()).await.is_err()
-            {
-                return false;
-            }
-        }
-        true
-    }
-
-    // Receive a UCI packet (eg: UCI DATA_MESSAGE_RCV), from UWBS to Host.
-    pub fn receive_packet(&mut self, packet: UciHalPacket) -> Result<()> {
-        if let Some(ref ps) = *self.packet_sender.lock().unwrap() {
-            match ps.send(packet) {
-                Ok(_) => Ok(()),
-                Err(_) => Err(Error::Unknown),
-            }
-        } else {
-            error!("MockUciHal unable to Rx packet from HAL as channel closed");
-            Err(Error::MockUndefined)
-        }
-    }
-}
-
-#[async_trait]
-impl UciHal for MockUciHal {
-    async fn open(&mut self, packet_sender: mpsc::UnboundedSender<UciHalPacket>) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::Open { packets, out }) => {
-                self.expect_call_consumed.notify_one();
-                if let Some(packets) = packets {
-                    for msg in packets.into_iter() {
-                        let _ = packet_sender.send(msg);
-                    }
-                }
-                if out.is_ok() {
-                    self.packet_sender.lock().unwrap().replace(packet_sender);
-                }
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn close(&mut self) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::Close { out }) => {
-                self.expect_call_consumed.notify_one();
-                if out.is_ok() {
-                    *self.packet_sender.lock().unwrap() = None;
-                }
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn send_command(&mut self, cmd: UciCommand) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SendCommand { expected_cmd, packets, out })
-                if expected_cmd == cmd =>
-            {
-                self.expect_call_consumed.notify_one();
-                let mut packet_sender_opt = self.packet_sender.lock().unwrap();
-                let packet_sender = packet_sender_opt.as_mut().unwrap();
-                for msg in packets.into_iter() {
-                    let _ = packet_sender.send(msg);
-                }
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn send_packet(&mut self, packet_tx: UciHalPacket) -> Result<()> {
-        // send_packet() will be directly called for sending UCI Data packets.
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SendPacket { expected_packet_tx, inject_packets_rx, out })
-                if expected_packet_tx == packet_tx =>
-            {
-                self.expect_call_consumed.notify_one();
-                let mut packet_sender_opt = self.packet_sender.lock().unwrap();
-                let packet_sender = packet_sender_opt.as_mut().unwrap();
-                for msg in inject_packets_rx.into_iter() {
-                    let _ = packet_sender.send(msg);
-                }
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn notify_session_initialized(&mut self, session_id: SessionId) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::NotifySessionInitialized { expected_session_id, out })
-                if expected_session_id == session_id =>
-            {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-}
-
-enum ExpectedCall {
-    Open {
-        packets: Option<Vec<UciHalPacket>>,
-        out: Result<()>,
-    },
-    Close {
-        out: Result<()>,
-    },
-    SendCommand {
-        expected_cmd: UciCommand,
-        packets: Vec<UciHalPacket>,
-        out: Result<()>,
-    },
-    SendPacket {
-        expected_packet_tx: UciHalPacket,
-        inject_packets_rx: Vec<UciHalPacket>,
-        out: Result<()>,
-    },
-    NotifySessionInitialized {
-        expected_session_id: SessionId,
-        out: Result<()>,
-    },
-}
diff --git a/src/rust/uwb_core/src/uci/mock_uci_logger.rs b/src/rust/uwb_core/src/uci/mock_uci_logger.rs
deleted file mode 100644
index 52d6044..0000000
--- a/src/rust/uwb_core/src/uci/mock_uci_logger.rs
+++ /dev/null
@@ -1,68 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::convert::TryFrom;
-
-use pdl_runtime::Packet;
-use tokio::sync::mpsc;
-use uwb_uci_packets::{UciControlPacket, UciDataPacket};
-
-use crate::error::{Error, Result};
-use crate::uci::uci_logger::UciLogger;
-
-/// Mock implementation of UciLogger
-#[derive(Debug, PartialEq, Eq, Clone)]
-pub(crate) enum UciLogEvent {
-    Packet(Vec<u8>),
-    HalOpen(Result<()>),
-    HalClose(Result<()>),
-}
-
-impl TryFrom<UciLogEvent> for Vec<u8> {
-    type Error = Error;
-    fn try_from(value: UciLogEvent) -> Result<Self> {
-        match value {
-            UciLogEvent::Packet(packet) => Ok(packet),
-            _ => Err(Error::BadParameters),
-        }
-    }
-}
-
-pub(crate) struct MockUciLogger {
-    log_sender: mpsc::UnboundedSender<UciLogEvent>,
-}
-
-impl MockUciLogger {
-    pub(crate) fn new(log_sender: mpsc::UnboundedSender<UciLogEvent>) -> Self {
-        Self { log_sender }
-    }
-}
-
-impl UciLogger for MockUciLogger {
-    fn log_hal_close(&mut self, result: Result<()>) {
-        let _ = self.log_sender.send(UciLogEvent::HalClose(result));
-    }
-
-    fn log_hal_open(&mut self, result: Result<()>) {
-        let _ = self.log_sender.send(UciLogEvent::HalOpen(result));
-    }
-
-    fn log_uci_control_packet(&mut self, packet: UciControlPacket) {
-        let _ = self.log_sender.send(UciLogEvent::Packet(packet.encode_to_vec().unwrap()));
-    }
-
-    fn log_uci_data_packet(&mut self, packet: &UciDataPacket) {
-        let _ = self.log_sender.send(UciLogEvent::Packet(packet.encode_to_vec().unwrap()));
-    }
-}
diff --git a/src/rust/uwb_core/src/uci/mock_uci_manager.rs b/src/rust/uwb_core/src/uci/mock_uci_manager.rs
deleted file mode 100644
index 55fcabb..0000000
--- a/src/rust/uwb_core/src/uci/mock_uci_manager.rs
+++ /dev/null
@@ -1,1521 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module offers a mocked version of UciManager for testing.
-//!
-//! The mocked version of UciManager mimics the behavior of the UCI manager and
-//! stacks below it, such that tests can be run on a target without the UWB
-//! hardware.
-use std::collections::VecDeque;
-use std::sync::{Arc, Mutex};
-use std::time::Duration;
-
-use async_trait::async_trait;
-use tokio::sync::{mpsc, Notify};
-use tokio::time::timeout;
-
-use crate::error::{Error, Result};
-use crate::params::uci_packets::{
-    app_config_tlvs_eq, device_config_tlvs_eq, radar_config_tlvs_eq, rf_test_config_tlvs_eq,
-    AndroidRadarConfigResponse, AppConfigTlv, AppConfigTlvType, CapTlv, ControleePhaseList,
-    Controlees, ControllerPhaseList, CoreSetConfigResponse, CountryCode, DeviceConfigId,
-    DeviceConfigTlv, GetDeviceInfoResponse, PowerStats, RadarConfigTlv, RadarConfigTlvType,
-    RawUciMessage, ResetConfig, RfTestConfigResponse, RfTestConfigTlv, SessionId, SessionState,
-    SessionToken, SessionType, SessionUpdateControllerMulticastResponse,
-    SessionUpdateDtTagRangingRoundsResponse, SetAppConfigResponse, UpdateMulticastListAction,
-};
-use crate::uci::notification::{
-    CoreNotification, DataRcvNotification, RadarDataRcvNotification, RfTestNotification,
-    SessionNotification, UciNotification,
-};
-use crate::uci::uci_logger::UciLoggerMode;
-use crate::uci::uci_manager::UciManager;
-
-#[derive(Clone)]
-/// Mock version of UciManager for testing.
-pub struct MockUciManager {
-    expected_calls: Arc<Mutex<VecDeque<ExpectedCall>>>,
-    expect_call_consumed: Arc<Notify>,
-    core_notf_sender: mpsc::UnboundedSender<CoreNotification>,
-    session_notf_sender: mpsc::UnboundedSender<SessionNotification>,
-    vendor_notf_sender: mpsc::UnboundedSender<RawUciMessage>,
-    data_rcv_notf_sender: mpsc::UnboundedSender<DataRcvNotification>,
-    radar_data_rcv_notf_sender: mpsc::UnboundedSender<RadarDataRcvNotification>,
-    rf_test_notf_sender: mpsc::UnboundedSender<RfTestNotification>,
-}
-
-#[allow(dead_code)]
-impl MockUciManager {
-    /// Constructor.
-    pub fn new() -> Self {
-        Self {
-            expected_calls: Default::default(),
-            expect_call_consumed: Default::default(),
-            core_notf_sender: mpsc::unbounded_channel().0,
-            session_notf_sender: mpsc::unbounded_channel().0,
-            vendor_notf_sender: mpsc::unbounded_channel().0,
-            data_rcv_notf_sender: mpsc::unbounded_channel().0,
-            radar_data_rcv_notf_sender: mpsc::unbounded_channel().0,
-            rf_test_notf_sender: mpsc::unbounded_channel().0,
-        }
-    }
-
-    /// Wait until expected calls are done.
-    ///
-    /// Returns false if calls are pending after 1 second.
-    pub async fn wait_expected_calls_done(&mut self) -> bool {
-        while !self.expected_calls.lock().unwrap().is_empty() {
-            if timeout(Duration::from_secs(1), self.expect_call_consumed.notified()).await.is_err()
-            {
-                return false;
-            }
-        }
-        true
-    }
-
-    /// Prepare Mock to expect for open_hal.
-    ///
-    /// MockUciManager expects call, returns out as response, followed by notfs sent.
-    pub fn expect_open_hal(
-        &mut self,
-        notfs: Vec<UciNotification>,
-        out: Result<GetDeviceInfoResponse>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::OpenHal { notfs, out });
-    }
-
-    /// Prepare Mock to expect for close_call.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response.
-    pub fn expect_close_hal(&mut self, expected_force: bool, out: Result<()>) {
-        self.expected_calls
-            .lock()
-            .unwrap()
-            .push_back(ExpectedCall::CloseHal { expected_force, out });
-    }
-
-    /// Prepare Mock to expect device_reset.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response.
-    pub fn expect_device_reset(&mut self, expected_reset_config: ResetConfig, out: Result<()>) {
-        self.expected_calls
-            .lock()
-            .unwrap()
-            .push_back(ExpectedCall::DeviceReset { expected_reset_config, out });
-    }
-
-    /// Prepare Mock to expect core_get_device_info.
-    ///
-    /// MockUciManager expects call, returns out as response.
-    pub fn expect_core_get_device_info(&mut self, out: Result<GetDeviceInfoResponse>) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::CoreGetDeviceInfo { out });
-    }
-
-    /// Prepare Mock to expect core_get_caps_info.
-    ///
-    /// MockUciManager expects call, returns out as response.
-    pub fn expect_core_get_caps_info(&mut self, out: Result<Vec<CapTlv>>) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::CoreGetCapsInfo { out });
-    }
-
-    /// Prepare Mock to expect core_set_config.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response.
-    pub fn expect_core_set_config(
-        &mut self,
-        expected_config_tlvs: Vec<DeviceConfigTlv>,
-        out: Result<CoreSetConfigResponse>,
-    ) {
-        self.expected_calls
-            .lock()
-            .unwrap()
-            .push_back(ExpectedCall::CoreSetConfig { expected_config_tlvs, out });
-    }
-
-    /// Prepare Mock to expect core_get_config.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response.
-    pub fn expect_core_get_config(
-        &mut self,
-        expected_config_ids: Vec<DeviceConfigId>,
-        out: Result<Vec<DeviceConfigTlv>>,
-    ) {
-        self.expected_calls
-            .lock()
-            .unwrap()
-            .push_back(ExpectedCall::CoreGetConfig { expected_config_ids, out });
-    }
-
-    /// Prepare Mock to expect core_query_uwb_timestamp.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response.
-    pub fn expect_core_query_uwb_timestamp(&mut self, out: Result<u64>) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::CoreQueryTimeStamp { out });
-    }
-
-    /// Prepare Mock to expect session_init.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response, followed by notfs
-    /// sent.
-    pub fn expect_session_init(
-        &mut self,
-        expected_session_id: SessionId,
-        expected_session_type: SessionType,
-        notfs: Vec<UciNotification>,
-        out: Result<()>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::SessionInit {
-            expected_session_id,
-            expected_session_type,
-            notfs,
-            out,
-        });
-    }
-
-    /// Prepare Mock to expect session_deinit.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response, followed by notfs
-    /// sent.
-    pub fn expect_session_deinit(
-        &mut self,
-        expected_session_id: SessionId,
-        notfs: Vec<UciNotification>,
-        out: Result<()>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::SessionDeinit {
-            expected_session_id,
-            notfs,
-            out,
-        });
-    }
-
-    /// Prepare Mock to expect session_set_app_config.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response, followed by notfs
-    /// sent.
-    pub fn expect_session_set_app_config(
-        &mut self,
-        expected_session_id: SessionId,
-        expected_config_tlvs: Vec<AppConfigTlv>,
-        notfs: Vec<UciNotification>,
-        out: Result<SetAppConfigResponse>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::SessionSetAppConfig {
-            expected_session_id,
-            expected_config_tlvs,
-            notfs,
-            out,
-        });
-    }
-
-    /// Prepare Mock to expect session_get_app_config.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response.
-    pub fn expect_session_get_app_config(
-        &mut self,
-        expected_session_id: SessionId,
-        expected_config_ids: Vec<AppConfigTlvType>,
-        out: Result<Vec<AppConfigTlv>>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::SessionGetAppConfig {
-            expected_session_id,
-            expected_config_ids,
-            out,
-        });
-    }
-
-    /// Prepare Mock to expect session_get_count.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response.
-    pub fn expect_session_get_count(&mut self, out: Result<u8>) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::SessionGetCount { out });
-    }
-
-    /// Prepare Mock to expect session_get_state.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response.
-    pub fn expect_session_get_state(
-        &mut self,
-        expected_session_id: SessionId,
-        out: Result<SessionState>,
-    ) {
-        self.expected_calls
-            .lock()
-            .unwrap()
-            .push_back(ExpectedCall::SessionGetState { expected_session_id, out });
-    }
-
-    /// Prepare Mock to expect update_controller_multicast_list.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response, followed by notfs
-    /// sent.
-    pub fn expect_session_update_controller_multicast_list(
-        &mut self,
-        expected_session_id: SessionId,
-        expected_action: UpdateMulticastListAction,
-        expected_controlees: Controlees,
-        notfs: Vec<UciNotification>,
-        out: Result<SessionUpdateControllerMulticastResponse>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(
-            ExpectedCall::SessionUpdateControllerMulticastList {
-                expected_session_id,
-                expected_action,
-                expected_controlees,
-                notfs,
-                out,
-            },
-        );
-    }
-
-    /// Prepare Mock to expect session_update_active_rounds_dt_tag.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response.
-    pub fn expect_session_update_dt_tag_ranging_rounds(
-        &mut self,
-        expected_session_id: u32,
-        expected_ranging_round_indexes: Vec<u8>,
-        out: Result<SessionUpdateDtTagRangingRoundsResponse>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(
-            ExpectedCall::SessionUpdateDtTagRangingRounds {
-                expected_session_id,
-                expected_ranging_round_indexes,
-                out,
-            },
-        );
-    }
-
-    /// Prepare Mock to expect for session_query_max_data_size.
-    ///
-    /// MockUciManager expects call, returns out as response.
-    pub fn expect_session_query_max_data_size(
-        &mut self,
-        expected_session_id: SessionId,
-        out: Result<u16>,
-    ) {
-        self.expected_calls
-            .lock()
-            .unwrap()
-            .push_back(ExpectedCall::SessionQueryMaxDataSize { expected_session_id, out });
-    }
-
-    /// Prepare Mock to expect range_start.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response, followed by notfs
-    /// sent.
-    pub fn expect_range_start(
-        &mut self,
-        expected_session_id: SessionId,
-        notfs: Vec<UciNotification>,
-        out: Result<()>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::RangeStart {
-            expected_session_id,
-            notfs,
-            out,
-        });
-    }
-
-    /// Prepare Mock to expect range_stop.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response, followed by notfs
-    /// sent.
-    pub fn expect_range_stop(
-        &mut self,
-        expected_session_id: SessionId,
-        notfs: Vec<UciNotification>,
-        out: Result<()>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::RangeStop {
-            expected_session_id,
-            notfs,
-            out,
-        });
-    }
-
-    /// Prepare Mock to expect range_get_ranging_count.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response.
-    pub fn expect_range_get_ranging_count(
-        &mut self,
-        expected_session_id: SessionId,
-        out: Result<usize>,
-    ) {
-        self.expected_calls
-            .lock()
-            .unwrap()
-            .push_back(ExpectedCall::RangeGetRangingCount { expected_session_id, out });
-    }
-
-    /// Prepare Mock to expect android_set_country_code.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response.
-    pub fn expect_android_set_country_code(
-        &mut self,
-        expected_country_code: CountryCode,
-        out: Result<()>,
-    ) {
-        self.expected_calls
-            .lock()
-            .unwrap()
-            .push_back(ExpectedCall::AndroidSetCountryCode { expected_country_code, out });
-    }
-
-    /// Prepare Mock to expect android_set_country_code.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response.
-    pub fn expect_android_get_power_stats(&mut self, out: Result<PowerStats>) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::AndroidGetPowerStats { out });
-    }
-
-    /// Prepare Mock to expect android_set_radar_config.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response, followed by notfs
-    /// sent.
-    pub fn expect_android_set_radar_config(
-        &mut self,
-        expected_session_id: SessionId,
-        expected_config_tlvs: Vec<RadarConfigTlv>,
-        notfs: Vec<UciNotification>,
-        out: Result<AndroidRadarConfigResponse>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::AndroidSetRadarConfig {
-            expected_session_id,
-            expected_config_tlvs,
-            notfs,
-            out,
-        });
-    }
-
-    /// Prepare Mock to expect android_get_app_config.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response.
-    pub fn expect_android_get_radar_config(
-        &mut self,
-        expected_session_id: SessionId,
-        expected_config_ids: Vec<RadarConfigTlvType>,
-        out: Result<Vec<RadarConfigTlv>>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::AndroidGetRadarConfig {
-            expected_session_id,
-            expected_config_ids,
-            out,
-        });
-    }
-
-    /// Prepare Mock to expect raw_uci_cmd.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response.
-    pub fn expect_raw_uci_cmd(
-        &mut self,
-        expected_mt: u32,
-        expected_gid: u32,
-        expected_oid: u32,
-        expected_payload: Vec<u8>,
-        out: Result<RawUciMessage>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::RawUciCmd {
-            expected_mt,
-            expected_gid,
-            expected_oid,
-            expected_payload,
-            out,
-        });
-    }
-
-    /// Prepare Mock to expect send_data_packet.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response.
-    pub fn expect_send_data_packet(
-        &mut self,
-        expected_session_id: SessionId,
-        expected_address: Vec<u8>,
-        expected_uci_sequence_num: u16,
-        expected_app_payload_data: Vec<u8>,
-        out: Result<()>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::SendDataPacket {
-            expected_session_id,
-            expected_address,
-            expected_uci_sequence_num,
-            expected_app_payload_data,
-            out,
-        });
-    }
-
-    /// Prepare Mock to expect session_set_hybrid_controller_config.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response
-    pub fn expect_session_set_hybrid_controller_config(
-        &mut self,
-        expected_session_id: SessionId,
-        expected_number_of_phases: u8,
-        expected_phase_list: Vec<ControllerPhaseList>,
-        out: Result<()>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(
-            ExpectedCall::SessionSetHybridControllerConfig {
-                expected_session_id,
-                expected_number_of_phases,
-                expected_phase_list,
-                out,
-            },
-        );
-    }
-
-    /// Prepare Mock to expect session_set_hybrid_controlee_config.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response
-    pub fn expect_session_set_hybrid_controlee_config(
-        &mut self,
-        expected_session_id: SessionId,
-        expected_controlee_phase_list: Vec<ControleePhaseList>,
-        out: Result<()>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(
-            ExpectedCall::SessionSetHybridControleeConfig {
-                expected_session_id,
-                expected_controlee_phase_list,
-                out,
-            },
-        );
-    }
-
-    /// Prepare Mock to expect session_data_transfer_phase_config
-    /// MockUciManager expects call with parameters, returns out as response
-    #[allow(clippy::too_many_arguments)]
-    pub fn expect_session_data_transfer_phase_config(
-        &mut self,
-        expected_session_id: SessionId,
-        expected_dtpcm_repetition: u8,
-        expected_data_transfer_control: u8,
-        expected_dtpml_size: u8,
-        expected_mac_address: Vec<u8>,
-        expected_slot_bitmap: Vec<u8>,
-        expected_stop_data_transfer: Vec<u8>,
-        out: Result<()>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(
-            ExpectedCall::SessionDataTransferPhaseConfig {
-                expected_session_id,
-                expected_dtpcm_repetition,
-                expected_data_transfer_control,
-                expected_dtpml_size,
-                expected_mac_address,
-                expected_slot_bitmap,
-                expected_stop_data_transfer,
-                out,
-            },
-        );
-    }
-
-    /// Prepare Mock to expect session_set_rf_test_config.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response, followed by notfs
-    /// sent.
-    pub fn expect_session_set_rf_test_config(
-        &mut self,
-        expected_session_id: SessionId,
-        expected_config_tlvs: Vec<RfTestConfigTlv>,
-        notfs: Vec<UciNotification>,
-        out: Result<RfTestConfigResponse>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::SessionSetRfTestConfig {
-            expected_session_id,
-            expected_config_tlvs,
-            notfs,
-            out,
-        });
-    }
-
-    /// Prepare Mock to expect rf_test_periodic_tx.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response, followed by notfs
-    /// sent.
-    pub fn expect_test_periodic_tx(
-        &mut self,
-        expected_psdu_data: Vec<u8>,
-        notfs: Vec<UciNotification>,
-        out: Result<()>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::TestPeriodicTx {
-            expected_psdu_data,
-            notfs,
-            out,
-        });
-    }
-
-    /// Prepare Mock to expect rf_test_per_rx.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response, followed by notfs
-    /// sent.
-    pub fn expect_test_per_rx(
-        &mut self,
-        expected_psdu_data: Vec<u8>,
-        notfs: Vec<UciNotification>,
-        out: Result<()>,
-    ) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::TestPerRx {
-            expected_psdu_data,
-            notfs,
-            out,
-        });
-    }
-
-    /// Prepare Mock to expect StopRfTest.
-    ///
-    /// MockUciManager expects call with parameters, returns out as response
-    pub fn expect_stop_rf_test(&mut self, out: Result<()>) {
-        self.expected_calls.lock().unwrap().push_back(ExpectedCall::StopRfTest { out });
-    }
-
-    /// Call Mock to send notifications.
-    fn send_notifications(&self, notfs: Vec<UciNotification>) {
-        for notf in notfs.into_iter() {
-            match notf {
-                UciNotification::Core(notf) => {
-                    let _ = self.core_notf_sender.send(notf);
-                }
-                UciNotification::Session(notf) => {
-                    let _ = self.session_notf_sender.send(notf);
-                }
-                UciNotification::Vendor(notf) => {
-                    let _ = self.vendor_notf_sender.send(notf);
-                }
-                UciNotification::RfTest(notf) => {
-                    let _ = self.rf_test_notf_sender.send(notf);
-                }
-            }
-        }
-    }
-}
-
-impl Default for MockUciManager {
-    fn default() -> Self {
-        Self::new()
-    }
-}
-
-#[async_trait]
-impl UciManager for MockUciManager {
-    async fn set_logger_mode(&self, _logger_mode: UciLoggerMode) -> Result<()> {
-        Ok(())
-    }
-    async fn set_core_notification_sender(
-        &mut self,
-        core_notf_sender: mpsc::UnboundedSender<CoreNotification>,
-    ) {
-        self.core_notf_sender = core_notf_sender;
-    }
-    async fn set_session_notification_sender(
-        &mut self,
-        session_notf_sender: mpsc::UnboundedSender<SessionNotification>,
-    ) {
-        self.session_notf_sender = session_notf_sender;
-    }
-    async fn set_vendor_notification_sender(
-        &mut self,
-        vendor_notf_sender: mpsc::UnboundedSender<RawUciMessage>,
-    ) {
-        self.vendor_notf_sender = vendor_notf_sender;
-    }
-    async fn set_data_rcv_notification_sender(
-        &mut self,
-        data_rcv_notf_sender: mpsc::UnboundedSender<DataRcvNotification>,
-    ) {
-        self.data_rcv_notf_sender = data_rcv_notf_sender;
-    }
-    async fn set_radar_data_rcv_notification_sender(
-        &mut self,
-        radar_data_rcv_notf_sender: mpsc::UnboundedSender<RadarDataRcvNotification>,
-    ) {
-        self.radar_data_rcv_notf_sender = radar_data_rcv_notf_sender;
-    }
-
-    async fn set_rf_test_notification_sender(
-        &mut self,
-        rf_test_notf_sender: mpsc::UnboundedSender<RfTestNotification>,
-    ) {
-        self.rf_test_notf_sender = rf_test_notf_sender;
-    }
-
-    async fn open_hal(&self) -> Result<GetDeviceInfoResponse> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::OpenHal { notfs, out }) => {
-                self.expect_call_consumed.notify_one();
-                self.send_notifications(notfs);
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn close_hal(&self, force: bool) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::CloseHal { expected_force, out }) if expected_force == force => {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn device_reset(&self, reset_config: ResetConfig) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::DeviceReset { expected_reset_config, out })
-                if expected_reset_config == reset_config =>
-            {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn core_get_device_info(&self) -> Result<GetDeviceInfoResponse> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::CoreGetDeviceInfo { out }) => {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn core_get_caps_info(&self) -> Result<Vec<CapTlv>> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::CoreGetCapsInfo { out }) => {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn core_set_config(
-        &self,
-        config_tlvs: Vec<DeviceConfigTlv>,
-    ) -> Result<CoreSetConfigResponse> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::CoreSetConfig { expected_config_tlvs, out })
-                if device_config_tlvs_eq(&expected_config_tlvs, &config_tlvs) =>
-            {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn core_get_config(
-        &self,
-        config_ids: Vec<DeviceConfigId>,
-    ) -> Result<Vec<DeviceConfigTlv>> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::CoreGetConfig { expected_config_ids, out })
-                if expected_config_ids == config_ids =>
-            {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn core_query_uwb_timestamp(&self) -> Result<u64> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::CoreQueryTimeStamp { out }) => {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn session_init(&self, session_id: SessionId, session_type: SessionType) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SessionInit {
-                expected_session_id,
-                expected_session_type,
-                notfs,
-                out,
-            }) if expected_session_id == session_id && expected_session_type == session_type => {
-                self.expect_call_consumed.notify_one();
-                self.send_notifications(notfs);
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn session_deinit(&self, session_id: SessionId) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SessionDeinit { expected_session_id, notfs, out })
-                if expected_session_id == session_id =>
-            {
-                self.expect_call_consumed.notify_one();
-                self.send_notifications(notfs);
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn session_set_app_config(
-        &self,
-        session_id: SessionId,
-        config_tlvs: Vec<AppConfigTlv>,
-    ) -> Result<SetAppConfigResponse> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SessionSetAppConfig {
-                expected_session_id,
-                expected_config_tlvs,
-                notfs,
-                out,
-            }) if expected_session_id == session_id
-                && app_config_tlvs_eq(&expected_config_tlvs, &config_tlvs) =>
-            {
-                self.expect_call_consumed.notify_one();
-                self.send_notifications(notfs);
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn session_get_app_config(
-        &self,
-        session_id: SessionId,
-        config_ids: Vec<AppConfigTlvType>,
-    ) -> Result<Vec<AppConfigTlv>> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SessionGetAppConfig {
-                expected_session_id,
-                expected_config_ids,
-                out,
-            }) if expected_session_id == session_id && expected_config_ids == config_ids => {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn session_get_count(&self) -> Result<u8> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SessionGetCount { out }) => {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn session_get_state(&self, session_id: SessionId) -> Result<SessionState> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SessionGetState { expected_session_id, out })
-                if expected_session_id == session_id =>
-            {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn session_update_controller_multicast_list(
-        &self,
-        session_id: SessionId,
-        action: UpdateMulticastListAction,
-        controlees: Controlees,
-        _is_multicast_list_ntf_v2_supported: bool,
-        _is_multicast_list_rsp_v2_supported: bool,
-    ) -> Result<SessionUpdateControllerMulticastResponse> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SessionUpdateControllerMulticastList {
-                expected_session_id,
-                expected_action,
-                expected_controlees,
-                notfs,
-                out,
-            }) if expected_session_id == session_id
-                && expected_action == action
-                && expected_controlees == controlees =>
-            {
-                self.expect_call_consumed.notify_one();
-                self.send_notifications(notfs);
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn session_data_transfer_phase_config(
-        &self,
-        session_id: SessionId,
-        dtpcm_repetition: u8,
-        data_transfer_control: u8,
-        dtpml_size: u8,
-        mac_address: Vec<u8>,
-        slot_bitmap: Vec<u8>,
-        stop_data_transfer: Vec<u8>,
-    ) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SessionDataTransferPhaseConfig {
-                expected_session_id,
-                expected_dtpcm_repetition,
-                expected_data_transfer_control,
-                expected_dtpml_size,
-                expected_mac_address,
-                expected_slot_bitmap,
-                expected_stop_data_transfer,
-                out,
-            }) if expected_session_id == session_id
-                && expected_dtpcm_repetition == dtpcm_repetition
-                && expected_data_transfer_control == data_transfer_control
-                && expected_dtpml_size == dtpml_size
-                && expected_mac_address == mac_address
-                && expected_slot_bitmap == slot_bitmap
-                && expected_stop_data_transfer == stop_data_transfer =>
-            {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn session_update_dt_tag_ranging_rounds(
-        &self,
-        session_id: u32,
-        ranging_round_indexes: Vec<u8>,
-    ) -> Result<SessionUpdateDtTagRangingRoundsResponse> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SessionUpdateDtTagRangingRounds {
-                expected_session_id,
-                expected_ranging_round_indexes,
-                out,
-            }) if expected_session_id == session_id
-                && expected_ranging_round_indexes == ranging_round_indexes =>
-            {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn session_query_max_data_size(&self, session_id: SessionId) -> Result<u16> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SessionQueryMaxDataSize { expected_session_id, out })
-                if expected_session_id == session_id =>
-            {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn range_start(&self, session_id: SessionId) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::RangeStart { expected_session_id, notfs, out })
-                if expected_session_id == session_id =>
-            {
-                self.expect_call_consumed.notify_one();
-                self.send_notifications(notfs);
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn range_stop(&self, session_id: SessionId) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::RangeStop { expected_session_id, notfs, out })
-                if expected_session_id == session_id =>
-            {
-                self.expect_call_consumed.notify_one();
-                self.send_notifications(notfs);
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn range_get_ranging_count(&self, session_id: SessionId) -> Result<usize> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::RangeGetRangingCount { expected_session_id, out })
-                if expected_session_id == session_id =>
-            {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn android_set_country_code(&self, country_code: CountryCode) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::AndroidSetCountryCode { expected_country_code, out })
-                if expected_country_code == country_code =>
-            {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn android_get_power_stats(&self) -> Result<PowerStats> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::AndroidGetPowerStats { out }) => {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn android_set_radar_config(
-        &self,
-        session_id: SessionId,
-        config_tlvs: Vec<RadarConfigTlv>,
-    ) -> Result<AndroidRadarConfigResponse> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::AndroidSetRadarConfig {
-                expected_session_id,
-                expected_config_tlvs,
-                notfs,
-                out,
-            }) if expected_session_id == session_id
-                && radar_config_tlvs_eq(&expected_config_tlvs, &config_tlvs) =>
-            {
-                self.expect_call_consumed.notify_one();
-                self.send_notifications(notfs);
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn android_get_radar_config(
-        &self,
-        session_id: SessionId,
-        config_ids: Vec<RadarConfigTlvType>,
-    ) -> Result<Vec<RadarConfigTlv>> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::AndroidGetRadarConfig {
-                expected_session_id,
-                expected_config_ids,
-                out,
-            }) if expected_session_id == session_id && expected_config_ids == config_ids => {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn raw_uci_cmd(
-        &self,
-        mt: u32,
-        gid: u32,
-        oid: u32,
-        payload: Vec<u8>,
-    ) -> Result<RawUciMessage> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::RawUciCmd {
-                expected_mt,
-                expected_gid,
-                expected_oid,
-                expected_payload,
-                out,
-            }) if expected_mt == mt
-                && expected_gid == gid
-                && expected_oid == oid
-                && expected_payload == payload =>
-            {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn send_data_packet(
-        &self,
-        session_id: SessionId,
-        address: Vec<u8>,
-        uci_sequence_num: u16,
-        app_payload_data: Vec<u8>,
-    ) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SendDataPacket {
-                expected_session_id,
-                expected_address,
-                expected_uci_sequence_num,
-                expected_app_payload_data,
-                out,
-            }) if expected_session_id == session_id
-                && expected_address == address
-                && expected_uci_sequence_num == uci_sequence_num
-                && expected_app_payload_data == app_payload_data =>
-            {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn get_session_token_from_session_id(
-        &self,
-        _session_id: SessionId,
-    ) -> Result<SessionToken> {
-        Ok(1) // No uci call here, no mock required.
-    }
-
-    async fn session_set_hybrid_controller_config(
-        &self,
-        session_id: SessionId,
-        number_of_phases: u8,
-        phase_lists: Vec<ControllerPhaseList>,
-    ) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SessionSetHybridControllerConfig {
-                expected_session_id,
-                expected_number_of_phases,
-                expected_phase_list,
-                out,
-            }) if expected_session_id == session_id
-                && expected_number_of_phases == number_of_phases
-                && expected_phase_list == phase_lists =>
-            {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn session_set_hybrid_controlee_config(
-        &self,
-        session_id: SessionId,
-        controlee_phase_list: Vec<ControleePhaseList>,
-    ) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SessionSetHybridControleeConfig {
-                expected_session_id,
-                expected_controlee_phase_list,
-                out,
-            }) if expected_session_id == session_id
-                && expected_controlee_phase_list.len() == controlee_phase_list.len()
-                && expected_controlee_phase_list == controlee_phase_list =>
-            {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn session_set_rf_test_config(
-        &self,
-        session_id: SessionId,
-        config_tlvs: Vec<RfTestConfigTlv>,
-    ) -> Result<RfTestConfigResponse> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::SessionSetRfTestConfig {
-                expected_session_id,
-                expected_config_tlvs,
-                notfs,
-                out,
-            }) if expected_session_id == session_id
-                && rf_test_config_tlvs_eq(&expected_config_tlvs, &config_tlvs) =>
-            {
-                self.expect_call_consumed.notify_one();
-                self.send_notifications(notfs);
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn rf_test_periodic_tx(&self, psdu_data: Vec<u8>) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::TestPeriodicTx { expected_psdu_data, notfs, out })
-                if expected_psdu_data == psdu_data =>
-            {
-                self.expect_call_consumed.notify_one();
-                self.send_notifications(notfs);
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn rf_test_per_rx(&self, psdu_data: Vec<u8>) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::TestPerRx { expected_psdu_data, notfs, out })
-            if expected_psdu_data == psdu_data =>
-                {
-                    self.expect_call_consumed.notify_one();
-                    self.send_notifications(notfs);
-                    out
-                }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-
-    async fn stop_rf_test(&self) -> Result<()> {
-        let mut expected_calls = self.expected_calls.lock().unwrap();
-        match expected_calls.pop_front() {
-            Some(ExpectedCall::StopRfTest { out }) => {
-                self.expect_call_consumed.notify_one();
-                out
-            }
-            Some(call) => {
-                expected_calls.push_front(call);
-                Err(Error::MockUndefined)
-            }
-            None => Err(Error::MockUndefined),
-        }
-    }
-}
-
-#[derive(Clone)]
-enum ExpectedCall {
-    OpenHal {
-        notfs: Vec<UciNotification>,
-        out: Result<GetDeviceInfoResponse>,
-    },
-    CloseHal {
-        expected_force: bool,
-        out: Result<()>,
-    },
-    DeviceReset {
-        expected_reset_config: ResetConfig,
-        out: Result<()>,
-    },
-    CoreGetDeviceInfo {
-        out: Result<GetDeviceInfoResponse>,
-    },
-    CoreGetCapsInfo {
-        out: Result<Vec<CapTlv>>,
-    },
-    CoreSetConfig {
-        expected_config_tlvs: Vec<DeviceConfigTlv>,
-        out: Result<CoreSetConfigResponse>,
-    },
-    CoreGetConfig {
-        expected_config_ids: Vec<DeviceConfigId>,
-        out: Result<Vec<DeviceConfigTlv>>,
-    },
-    CoreQueryTimeStamp {
-        out: Result<u64>,
-    },
-    SessionInit {
-        expected_session_id: SessionId,
-        expected_session_type: SessionType,
-        notfs: Vec<UciNotification>,
-        out: Result<()>,
-    },
-    SessionDeinit {
-        expected_session_id: SessionId,
-        notfs: Vec<UciNotification>,
-        out: Result<()>,
-    },
-    SessionSetAppConfig {
-        expected_session_id: SessionId,
-        expected_config_tlvs: Vec<AppConfigTlv>,
-        notfs: Vec<UciNotification>,
-        out: Result<SetAppConfigResponse>,
-    },
-    SessionGetAppConfig {
-        expected_session_id: SessionId,
-        expected_config_ids: Vec<AppConfigTlvType>,
-        out: Result<Vec<AppConfigTlv>>,
-    },
-    SessionGetCount {
-        out: Result<u8>,
-    },
-    SessionGetState {
-        expected_session_id: SessionId,
-        out: Result<SessionState>,
-    },
-    SessionUpdateControllerMulticastList {
-        expected_session_id: SessionId,
-        expected_action: UpdateMulticastListAction,
-        expected_controlees: Controlees,
-        notfs: Vec<UciNotification>,
-        out: Result<SessionUpdateControllerMulticastResponse>,
-    },
-    SessionUpdateDtTagRangingRounds {
-        expected_session_id: u32,
-        expected_ranging_round_indexes: Vec<u8>,
-        out: Result<SessionUpdateDtTagRangingRoundsResponse>,
-    },
-    SessionQueryMaxDataSize {
-        expected_session_id: SessionId,
-        out: Result<u16>,
-    },
-    RangeStart {
-        expected_session_id: SessionId,
-        notfs: Vec<UciNotification>,
-        out: Result<()>,
-    },
-    RangeStop {
-        expected_session_id: SessionId,
-        notfs: Vec<UciNotification>,
-        out: Result<()>,
-    },
-    RangeGetRangingCount {
-        expected_session_id: SessionId,
-        out: Result<usize>,
-    },
-    AndroidSetCountryCode {
-        expected_country_code: CountryCode,
-        out: Result<()>,
-    },
-    AndroidGetPowerStats {
-        out: Result<PowerStats>,
-    },
-    AndroidSetRadarConfig {
-        expected_session_id: SessionId,
-        expected_config_tlvs: Vec<RadarConfigTlv>,
-        notfs: Vec<UciNotification>,
-        out: Result<AndroidRadarConfigResponse>,
-    },
-    AndroidGetRadarConfig {
-        expected_session_id: SessionId,
-        expected_config_ids: Vec<RadarConfigTlvType>,
-        out: Result<Vec<RadarConfigTlv>>,
-    },
-    RawUciCmd {
-        expected_mt: u32,
-        expected_gid: u32,
-        expected_oid: u32,
-        expected_payload: Vec<u8>,
-        out: Result<RawUciMessage>,
-    },
-    SendDataPacket {
-        expected_session_id: SessionId,
-        expected_address: Vec<u8>,
-        expected_uci_sequence_num: u16,
-        expected_app_payload_data: Vec<u8>,
-        out: Result<()>,
-    },
-    SessionSetHybridControllerConfig {
-        expected_session_id: SessionId,
-        expected_number_of_phases: u8,
-        expected_phase_list: Vec<ControllerPhaseList>,
-        out: Result<()>,
-    },
-    SessionSetHybridControleeConfig {
-        expected_session_id: SessionId,
-        expected_controlee_phase_list: Vec<ControleePhaseList>,
-        out: Result<()>,
-    },
-    SessionDataTransferPhaseConfig {
-        expected_session_id: SessionId,
-        expected_dtpcm_repetition: u8,
-        expected_data_transfer_control: u8,
-        expected_dtpml_size: u8,
-        expected_mac_address: Vec<u8>,
-        expected_slot_bitmap: Vec<u8>,
-        expected_stop_data_transfer: Vec<u8>,
-        out: Result<()>,
-    },
-    SessionSetRfTestConfig {
-        expected_session_id: SessionId,
-        expected_config_tlvs: Vec<RfTestConfigTlv>,
-        notfs: Vec<UciNotification>,
-        out: Result<RfTestConfigResponse>,
-    },
-    TestPeriodicTx {
-        expected_psdu_data: Vec<u8>,
-        notfs: Vec<UciNotification>,
-        out: Result<()>,
-    },
-    TestPerRx {
-        expected_psdu_data: Vec<u8>,
-        notfs: Vec<UciNotification>,
-        out: Result<()>,
-    },
-    StopRfTest {
-        out: Result<()>,
-    },
-}
diff --git a/src/rust/uwb_core/src/uci/notification.rs b/src/rust/uwb_core/src/uci/notification.rs
deleted file mode 100644
index 0c71d18..0000000
--- a/src/rust/uwb_core/src/uci/notification.rs
+++ /dev/null
@@ -1,1621 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::convert::{TryFrom, TryInto};
-
-use log::{debug, error};
-use pdl_runtime::Packet;
-use uwb_uci_packets::{
-    parse_diagnostics_ntf, radar_bytes_per_sample_value, RadarDataRcv, RadarSweepDataRaw,
-    UCI_PACKET_HEADER_LEN, UCI_RADAR_SEQUENCE_NUMBER_LEN, UCI_RADAR_TIMESTAMP_LEN,
-    UCI_RADAR_VENDOR_DATA_LEN_LEN,
-};
-
-use crate::error::{Error, Result};
-use crate::params::fira_app_config_params::UwbAddress;
-use crate::params::uci_packets::{
-    BitsPerSample, ControleeStatusV1, ControleeStatusV2, CreditAvailability, DataRcvStatusCode,
-    DataTransferNtfStatusCode, DataTransferPhaseConfigUpdateStatusCode, DeviceState,
-    ExtendedAddressDlTdoaRangingMeasurement, ExtendedAddressOwrAoaRangingMeasurement,
-    ExtendedAddressTwoWayRangingMeasurement, RadarDataType, RangingMeasurementType, RawUciMessage,
-    SessionId, SessionState, SessionToken, SessionUpdateControllerMulticastListNtfV1Payload,
-    SessionUpdateControllerMulticastListNtfV2Payload, ShortAddressDlTdoaRangingMeasurement,
-    ShortAddressOwrAoaRangingMeasurement, ShortAddressTwoWayRangingMeasurement, StatusCode,
-    UCIMajorVersion,
-};
-
-/// enum of all UCI notifications with structured fields.
-#[derive(Debug, Clone, PartialEq)]
-pub enum UciNotification {
-    /// CoreNotification equivalent.
-    Core(CoreNotification),
-    /// SessionNotification equivalent.
-    Session(SessionNotification),
-    /// UciVendor_X_Notification equivalent.
-    Vendor(RawUciMessage),
-    /// RfTestNotification equivalent
-    RfTest(RfTestNotification),
-}
-
-/// UCI CoreNotification.
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub enum CoreNotification {
-    /// DeviceStatusNtf equivalent.
-    DeviceStatus(DeviceState),
-    /// GenericErrorPacket equivalent.
-    GenericError(StatusCode),
-}
-
-/// UCI SessionNotification.
-#[derive(Debug, Clone, PartialEq)]
-pub enum SessionNotification {
-    /// SessionStatusNtf equivalent.
-    Status {
-        /// SessionId : u32
-        session_id: SessionId,
-        /// SessionToken : u32
-        session_token: SessionToken,
-        /// uwb_uci_packets::SessionState.
-        session_state: SessionState,
-        /// uwb_uci_packets::Reasoncode.
-        reason_code: u8,
-    },
-    /// SessionUpdateControllerMulticastListNtfV1 equivalent.
-    UpdateControllerMulticastListV1 {
-        /// SessionToken : u32
-        session_token: SessionToken,
-        /// count of controlees: u8
-        remaining_multicast_list_size: usize,
-        /// list of controlees.
-        status_list: Vec<ControleeStatusV1>,
-    },
-    /// SessionUpdateControllerMulticastListNtfV2 equivalent.
-    UpdateControllerMulticastListV2 {
-        /// SessionToken : u32
-        session_token: SessionToken,
-        /// list of controlees.
-        status_list: Vec<ControleeStatusV2>,
-    },
-    /// (Short/Extended)Mac()SessionInfoNtf equivalent
-    SessionInfo(SessionRangeData),
-    /// DataCreditNtf equivalent.
-    DataCredit {
-        /// SessionToken : u32
-        session_token: SessionToken,
-        /// Credit Availability (for sending Data packets on UWB Session)
-        credit_availability: CreditAvailability,
-    },
-    /// DataTransferStatusNtf equivalent.
-    DataTransferStatus {
-        /// SessionToken : u32
-        session_token: SessionToken,
-        /// Sequence Number: u16
-        uci_sequence_number: u16,
-        /// Data Transfer Status Code
-        status: DataTransferNtfStatusCode,
-        /// Transmission count
-        tx_count: u8,
-    },
-    /// SessionDataTransferPhaseConfigNtf equivalent.
-    DataTransferPhaseConfig {
-        /// SessionToken : u32
-        session_token: SessionToken,
-        /// status
-        status: DataTransferPhaseConfigUpdateStatusCode,
-    },
-}
-
-/// UCI RfTest Notification.
-#[derive(Debug, Clone, PartialEq)]
-pub enum RfTestNotification {
-    ///TestPeriodicTxNtf equivalent
-    TestPeriodicTxNtf {
-        /// Status
-        status: StatusCode,
-        /// The raw data of the notification message.
-        /// It's not at FiRa specification, only used by vendor's extension.
-        raw_notification_data: Vec<u8>,
-    },
-    /// TestPerRxNtf equivalent
-    TestPerRxNtf(RfTestPerRxData),
-}
-
-/// The session range data.
-#[derive(Debug, Clone, PartialEq)]
-pub struct SessionRangeData {
-    /// The sequence counter that starts with 0 when the session is started.
-    pub sequence_number: u32,
-
-    /// The identifier of the session.
-    pub session_token: SessionToken,
-
-    /// The current ranging interval setting in the unit of ms.
-    pub current_ranging_interval_ms: u32,
-
-    /// The ranging measurement type.
-    pub ranging_measurement_type: RangingMeasurementType,
-
-    /// Hus primary session Session Id
-    pub hus_primary_session_id: SessionToken,
-
-    /// The ranging measurement data.
-    pub ranging_measurements: RangingMeasurements,
-
-    /// Indication that a RCR was sent/received in the current ranging round.
-    pub rcr_indicator: u8,
-
-    /// The raw data of the notification message.
-    /// (b/243555651): It's not at FiRa specification, only used by vendor's extension.
-    pub raw_ranging_data: Vec<u8>,
-}
-
-/// PER RX NTF Data
-#[derive(Debug, Clone, PartialEq)]
-pub struct RfTestPerRxData {
-    /// Status
-    pub status: StatusCode,
-
-    /// Number of RX attempts.
-    pub attempts: u32,
-
-    /// Number of times signal was detected.
-    pub acq_detect: u32,
-
-    /// Number of times signal was rejected.
-    pub acq_reject: u32,
-
-    /// Number of times RX did not go beyound ACQ stage.
-    pub rx_fail: u32,
-
-    /// Number of times sync CIR ready event was received.
-    pub sync_cir_ready: u32,
-
-    /// Number of times RX was stuck at either ACQ detect or sync CIR ready.
-    pub sfd_fail: u32,
-
-    /// Number of times SFD was found.
-    pub sfd_found: u32,
-
-    /// Number of times PHR decode failed.
-    pub phr_dec_error: u32,
-
-    /// Number of times PHR bits in error.
-    pub phr_bit_error: u32,
-
-    /// Number of times payload decode failed.
-    pub psdu_dec_error: u32,
-
-    /// Number of times payload bits in error.
-    pub psdu_bit_error: u32,
-
-    /// Number of times STS detection was successful.
-    pub sts_found: u32,
-
-    /// Number of times end of frame event was triggered.
-    pub eof: u32,
-
-    /// The raw data of the notification message.
-    /// It's not at FiRa specification, only used by vendor's extension.
-    pub raw_notification_data: Vec<u8>,
-}
-
-/// The ranging measurements.
-#[derive(Debug, Clone, PartialEq)]
-pub enum RangingMeasurements {
-    /// A Two-Way measurement with short address.
-    ShortAddressTwoWay(Vec<ShortAddressTwoWayRangingMeasurement>),
-
-    /// A Two-Way measurement with extended address.
-    ExtendedAddressTwoWay(Vec<ExtendedAddressTwoWayRangingMeasurement>),
-
-    /// Dl-TDoA measurement with short address.
-    ShortAddressDltdoa(Vec<ShortAddressDlTdoaRangingMeasurement>),
-
-    /// Dl-TDoA measurement with extended address.
-    ExtendedAddressDltdoa(Vec<ExtendedAddressDlTdoaRangingMeasurement>),
-
-    /// OWR for AoA measurement with short address.
-    ShortAddressOwrAoa(ShortAddressOwrAoaRangingMeasurement),
-
-    /// OWR for AoA measurement with extended address.
-    ExtendedAddressOwrAoa(ExtendedAddressOwrAoaRangingMeasurement),
-}
-
-/// The DATA_RCV packet
-#[derive(Debug, Clone, std::cmp::PartialEq)]
-pub struct DataRcvNotification {
-    /// The identifier of the session on which data transfer is happening.
-    pub session_token: SessionToken,
-
-    /// The status of the data rx.
-    pub status: StatusCode,
-
-    /// The sequence number of the data packet.
-    pub uci_sequence_num: u16,
-
-    /// MacAddress of the sender of the application data.
-    pub source_address: UwbAddress,
-
-    /// Application Payload Data
-    pub payload: Vec<u8>,
-}
-
-/// The Radar sweep data struct
-#[derive(Debug, Clone, std::cmp::PartialEq)]
-pub struct RadarSweepData {
-    /// Counter of a single radar sweep per receiver. Starting
-    /// with 0 when the radar session is started.
-    pub sequence_number: u32,
-
-    /// Timestamp when this radar sweep is received. Unit is
-    /// based on the PRF.
-    pub timestamp: u32,
-
-    /// The radar vendor specific data.
-    pub vendor_specific_data: Vec<u8>,
-
-    /// The radar sample data.
-    pub sample_data: Vec<u8>,
-}
-
-/// The RADAR_DATA_RCV packet
-#[derive(Debug, Clone, std::cmp::PartialEq)]
-pub struct RadarDataRcvNotification {
-    /// The identifier of the session on which radar data transfer is happening.
-    pub session_token: SessionToken,
-
-    /// The status of the radar data rx.
-    pub status: DataRcvStatusCode,
-
-    /// The radar data type.
-    pub radar_data_type: RadarDataType,
-
-    /// The number of sweeps.
-    pub number_of_sweeps: u8,
-
-    /// Number of samples captured for each radar sweep.
-    pub samples_per_sweep: u8,
-
-    /// Bits per sample in the radar sweep.
-    pub bits_per_sample: BitsPerSample,
-
-    /// Defines the start offset with respect to 0cm distance. Unit in samples.
-    pub sweep_offset: u16,
-
-    /// Radar sweep data.
-    pub sweep_data: Vec<RadarSweepData>,
-}
-
-impl From<&uwb_uci_packets::RadarSweepDataRaw> for RadarSweepData {
-    fn from(evt: &uwb_uci_packets::RadarSweepDataRaw) -> Self {
-        Self {
-            sequence_number: evt.sequence_number,
-            timestamp: evt.timestamp,
-            vendor_specific_data: evt.vendor_specific_data.clone(),
-            sample_data: evt.sample_data.clone(),
-        }
-    }
-}
-
-impl TryFrom<uwb_uci_packets::UciDataPacket> for RadarDataRcvNotification {
-    type Error = Error;
-    fn try_from(evt: uwb_uci_packets::UciDataPacket) -> std::result::Result<Self, Self::Error> {
-        match evt.specialize() {
-            uwb_uci_packets::UciDataPacketChild::RadarDataRcv(evt) => parse_radar_data(evt),
-            _ => Err(Error::Unknown),
-        }
-    }
-}
-
-fn parse_radar_data(data: RadarDataRcv) -> Result<RadarDataRcvNotification> {
-    let session_token = data.get_session_handle();
-    let status = data.get_status();
-    let radar_data_type = data.get_radar_data_type();
-    let number_of_sweeps = data.get_number_of_sweeps();
-    let samples_per_sweep = data.get_samples_per_sweep();
-    let bits_per_sample = data.get_bits_per_sample();
-    let bytes_per_sample_value = radar_bytes_per_sample_value(bits_per_sample);
-    let sweep_offset = data.get_sweep_offset();
-
-    Ok(RadarDataRcvNotification {
-        session_token,
-        status,
-        radar_data_type,
-        number_of_sweeps,
-        samples_per_sweep,
-        bits_per_sample,
-        sweep_offset,
-        sweep_data: parse_radar_sweep_data(
-            number_of_sweeps,
-            samples_per_sweep,
-            bytes_per_sample_value,
-            data.get_sweep_data().clone(),
-        )?,
-    })
-}
-
-fn parse_radar_sweep_data(
-    number_of_sweeps: u8,
-    samples_per_sweep: u8,
-    bytes_per_sample_value: u8,
-    data: Vec<u8>,
-) -> Result<Vec<RadarSweepData>> {
-    let mut radar_sweep_data: Vec<RadarSweepData> = Vec::new();
-    let mut sweep_data_cursor = 0;
-    for _ in 0..number_of_sweeps {
-        let vendor_data_len_index =
-            sweep_data_cursor + UCI_RADAR_SEQUENCE_NUMBER_LEN + UCI_RADAR_TIMESTAMP_LEN;
-        if data.len() <= vendor_data_len_index {
-            error!("Invalid radar sweep data length for vendor, data: {:?}", &data);
-            return Err(Error::BadParameters);
-        }
-        let vendor_specific_data_len = data[vendor_data_len_index] as usize;
-        let sweep_data_len = UCI_RADAR_SEQUENCE_NUMBER_LEN
-            + UCI_RADAR_TIMESTAMP_LEN
-            + UCI_RADAR_VENDOR_DATA_LEN_LEN
-            + vendor_specific_data_len
-            + samples_per_sweep as usize * bytes_per_sample_value as usize;
-        if data.len() < sweep_data_cursor + sweep_data_len {
-            error!("Invalid radar sweep data length, data: {:?}", &data);
-            return Err(Error::BadParameters);
-        }
-        radar_sweep_data.push(
-            (&RadarSweepDataRaw::parse(
-                &data[sweep_data_cursor..sweep_data_cursor + sweep_data_len],
-            )
-            .map_err(|e| {
-                error!("Failed to parse raw Radar Sweep Data {:?}, data: {:?}", e, &data);
-                Error::BadParameters
-            })?)
-                .into(),
-        );
-
-        sweep_data_cursor += sweep_data_len;
-    }
-
-    Ok(radar_sweep_data)
-}
-
-impl TryFrom<uwb_uci_packets::UciDataPacket> for DataRcvNotification {
-    type Error = Error;
-    fn try_from(evt: uwb_uci_packets::UciDataPacket) -> std::result::Result<Self, Self::Error> {
-        match evt.specialize() {
-            uwb_uci_packets::UciDataPacketChild::UciDataRcv(evt) => Ok(DataRcvNotification {
-                session_token: evt.get_session_token(),
-                status: evt.get_status(),
-                uci_sequence_num: evt.get_uci_sequence_number(),
-                source_address: UwbAddress::Extended(evt.get_source_mac_address().to_le_bytes()),
-                payload: evt.get_data().to_vec(),
-            }),
-            _ => Err(Error::Unknown),
-        }
-    }
-}
-
-impl UciNotification {
-    pub(crate) fn need_retry(&self) -> bool {
-        matches!(
-            self,
-            Self::Core(CoreNotification::GenericError(StatusCode::UciStatusCommandRetry))
-        )
-    }
-}
-
-impl TryFrom<(uwb_uci_packets::UciNotification, UCIMajorVersion, bool)> for UciNotification {
-    type Error = Error;
-    fn try_from(
-        pair: (uwb_uci_packets::UciNotification, UCIMajorVersion, bool),
-    ) -> std::result::Result<Self, Self::Error> {
-        use uwb_uci_packets::UciNotificationChild;
-        let evt = pair.0;
-        let uci_fira_major_ver = pair.1;
-        let is_multicast_list_ntf_v2_supported = pair.2;
-
-        match evt.specialize() {
-            UciNotificationChild::CoreNotification(evt) => Ok(Self::Core(evt.try_into()?)),
-            UciNotificationChild::SessionConfigNotification(evt) => Ok(Self::Session(
-                (evt, uci_fira_major_ver, is_multicast_list_ntf_v2_supported).try_into()?,
-            )),
-            UciNotificationChild::SessionControlNotification(evt) => {
-                Ok(Self::Session(evt.try_into()?))
-            }
-            UciNotificationChild::AndroidNotification(evt) => evt.try_into(),
-            UciNotificationChild::UciVendor_9_Notification(evt) => vendor_notification(evt.into()),
-            UciNotificationChild::UciVendor_A_Notification(evt) => vendor_notification(evt.into()),
-            UciNotificationChild::UciVendor_B_Notification(evt) => vendor_notification(evt.into()),
-            UciNotificationChild::UciVendor_E_Notification(evt) => vendor_notification(evt.into()),
-            UciNotificationChild::UciVendor_F_Notification(evt) => vendor_notification(evt.into()),
-            UciNotificationChild::TestNotification(evt) => Ok(Self::RfTest(evt.try_into()?)),
-            _ => {
-                error!("Unknown UciNotification: {:?}", evt);
-                Err(Error::Unknown)
-            }
-        }
-    }
-}
-
-impl TryFrom<uwb_uci_packets::CoreNotification> for CoreNotification {
-    type Error = Error;
-    fn try_from(evt: uwb_uci_packets::CoreNotification) -> std::result::Result<Self, Self::Error> {
-        use uwb_uci_packets::CoreNotificationChild;
-        match evt.specialize() {
-            CoreNotificationChild::DeviceStatusNtf(evt) => {
-                Ok(Self::DeviceStatus(evt.get_device_state()))
-            }
-            CoreNotificationChild::GenericError(evt) => Ok(Self::GenericError(evt.get_status())),
-            _ => {
-                error!("Unknown CoreNotification: {:?}", evt);
-                Err(Error::Unknown)
-            }
-        }
-    }
-}
-
-impl TryFrom<(uwb_uci_packets::SessionConfigNotification, UCIMajorVersion, bool)>
-    for SessionNotification
-{
-    type Error = Error;
-    fn try_from(
-        pair: (uwb_uci_packets::SessionConfigNotification, UCIMajorVersion, bool),
-    ) -> std::result::Result<Self, Self::Error> {
-        use uwb_uci_packets::SessionConfigNotificationChild;
-        let evt = pair.0;
-        let uci_fira_major_ver = pair.1;
-        let is_multicast_list_ntf_v2_supported = pair.2;
-        match evt.specialize() {
-            SessionConfigNotificationChild::SessionStatusNtf(evt) => Ok(Self::Status {
-                //no sessionId recieved, assign from sessionIdToToken map in uci_manager
-                session_id: 0,
-                session_token: evt.get_session_token(),
-                session_state: evt.get_session_state(),
-                reason_code: evt.get_reason_code(),
-            }),
-            SessionConfigNotificationChild::SessionUpdateControllerMulticastListNtf(evt)
-                if uci_fira_major_ver == UCIMajorVersion::V1
-                    || !is_multicast_list_ntf_v2_supported =>
-            {
-                let payload = evt.get_payload();
-                let multicast_update_list_payload_v1 =
-                    SessionUpdateControllerMulticastListNtfV1Payload::parse(payload).map_err(
-                        |e| {
-                            error!(
-                                "Failed to parse Multicast list ntf v1 {:?}, payload: {:?}",
-                                e, &payload
-                            );
-                            Error::BadParameters
-                        },
-                    )?;
-                Ok(Self::UpdateControllerMulticastListV1 {
-                    session_token: evt.get_session_token(),
-                    remaining_multicast_list_size: multicast_update_list_payload_v1
-                        .remaining_multicast_list_size
-                        as usize,
-                    status_list: multicast_update_list_payload_v1.controlee_status,
-                })
-            }
-            SessionConfigNotificationChild::SessionUpdateControllerMulticastListNtf(evt)
-                if uci_fira_major_ver >= UCIMajorVersion::V2 =>
-            {
-                let payload = evt.get_payload();
-                let multicast_update_list_payload_v2 =
-                    SessionUpdateControllerMulticastListNtfV2Payload::parse(payload).map_err(
-                        |e| {
-                            error!(
-                                "Failed to parse Multicast list ntf v2 {:?}, payload: {:?}",
-                                e, &payload
-                            );
-                            Error::BadParameters
-                        },
-                    )?;
-                Ok(Self::UpdateControllerMulticastListV2 {
-                    session_token: evt.get_session_token(),
-                    status_list: multicast_update_list_payload_v2.controlee_status,
-                })
-            }
-            SessionConfigNotificationChild::SessionDataTransferPhaseConfigNtf(evt) => {
-                Ok(Self::DataTransferPhaseConfig {
-                    session_token: evt.get_session_token(),
-                    status: evt.get_status(),
-                })
-            }
-            _ => {
-                error!("Unknown SessionConfigNotification: {:?}", evt);
-                Err(Error::Unknown)
-            }
-        }
-    }
-}
-
-impl TryFrom<uwb_uci_packets::SessionControlNotification> for SessionNotification {
-    type Error = Error;
-    fn try_from(
-        evt: uwb_uci_packets::SessionControlNotification,
-    ) -> std::result::Result<Self, Self::Error> {
-        use uwb_uci_packets::SessionControlNotificationChild;
-        match evt.specialize() {
-            SessionControlNotificationChild::SessionInfoNtf(evt) => evt.try_into(),
-            SessionControlNotificationChild::DataCreditNtf(evt) => Ok(Self::DataCredit {
-                session_token: evt.get_session_token(),
-                credit_availability: evt.get_credit_availability(),
-            }),
-            SessionControlNotificationChild::DataTransferStatusNtf(evt) => {
-                Ok(Self::DataTransferStatus {
-                    session_token: evt.get_session_token(),
-                    uci_sequence_number: evt.get_uci_sequence_number(),
-                    status: evt.get_status(),
-                    tx_count: evt.get_tx_count(),
-                })
-            }
-            _ => {
-                error!("Unknown SessionControlNotification: {:?}", evt);
-                Err(Error::Unknown)
-            }
-        }
-    }
-}
-
-impl TryFrom<uwb_uci_packets::SessionInfoNtf> for SessionNotification {
-    type Error = Error;
-    fn try_from(evt: uwb_uci_packets::SessionInfoNtf) -> std::result::Result<Self, Self::Error> {
-        let raw_ranging_data = evt.encode_to_bytes().unwrap()[UCI_PACKET_HEADER_LEN..].to_vec();
-        use uwb_uci_packets::SessionInfoNtfChild;
-        let ranging_measurements = match evt.specialize() {
-            SessionInfoNtfChild::ShortMacTwoWaySessionInfoNtf(evt) => {
-                RangingMeasurements::ShortAddressTwoWay(
-                    evt.get_two_way_ranging_measurements().clone(),
-                )
-            }
-            SessionInfoNtfChild::ExtendedMacTwoWaySessionInfoNtf(evt) => {
-                RangingMeasurements::ExtendedAddressTwoWay(
-                    evt.get_two_way_ranging_measurements().clone(),
-                )
-            }
-            SessionInfoNtfChild::ShortMacOwrAoaSessionInfoNtf(evt) => {
-                if evt.get_owr_aoa_ranging_measurements().clone().len() == 1 {
-                    RangingMeasurements::ShortAddressOwrAoa(
-                        match evt.get_owr_aoa_ranging_measurements().clone().pop() {
-                            Some(r) => r,
-                            None => {
-                                error!(
-                                    "Unable to parse ShortAddress OwrAoA measurement: {:?}",
-                                    evt
-                                );
-                                return Err(Error::BadParameters);
-                            }
-                        },
-                    )
-                } else {
-                    error!("Wrong count of OwrAoA ranging measurements {:?}", evt);
-                    return Err(Error::BadParameters);
-                }
-            }
-            SessionInfoNtfChild::ExtendedMacOwrAoaSessionInfoNtf(evt) => {
-                if evt.get_owr_aoa_ranging_measurements().clone().len() == 1 {
-                    RangingMeasurements::ExtendedAddressOwrAoa(
-                        match evt.get_owr_aoa_ranging_measurements().clone().pop() {
-                            Some(r) => r,
-                            None => {
-                                error!(
-                                    "Unable to parse ExtendedAddress OwrAoA measurement: {:?}",
-                                    evt
-                                );
-                                return Err(Error::BadParameters);
-                            }
-                        },
-                    )
-                } else {
-                    error!("Wrong count of OwrAoA ranging measurements {:?}", evt);
-                    return Err(Error::BadParameters);
-                }
-            }
-            SessionInfoNtfChild::ShortMacDlTDoASessionInfoNtf(evt) => {
-                match ShortAddressDlTdoaRangingMeasurement::parse(
-                    evt.get_dl_tdoa_measurements(),
-                    evt.get_no_of_ranging_measurements(),
-                ) {
-                    Some(v) => {
-                        if v.len() == evt.get_no_of_ranging_measurements().into() {
-                            RangingMeasurements::ShortAddressDltdoa(v)
-                        } else {
-                            error!("Wrong count of ranging measurements {:?}", evt);
-                            return Err(Error::BadParameters);
-                        }
-                    }
-                    None => return Err(Error::BadParameters),
-                }
-            }
-            SessionInfoNtfChild::ExtendedMacDlTDoASessionInfoNtf(evt) => {
-                match ExtendedAddressDlTdoaRangingMeasurement::parse(
-                    evt.get_dl_tdoa_measurements(),
-                    evt.get_no_of_ranging_measurements(),
-                ) {
-                    Some(v) => {
-                        if v.len() == evt.get_no_of_ranging_measurements().into() {
-                            RangingMeasurements::ExtendedAddressDltdoa(v)
-                        } else {
-                            error!("Wrong count of ranging measurements {:?}", evt);
-                            return Err(Error::BadParameters);
-                        }
-                    }
-                    None => return Err(Error::BadParameters),
-                }
-            }
-            _ => {
-                error!("Unknown SessionInfoNtf: {:?}", evt);
-                return Err(Error::Unknown);
-            }
-        };
-        Ok(Self::SessionInfo(SessionRangeData {
-            sequence_number: evt.get_sequence_number(),
-            session_token: evt.get_session_token(),
-            current_ranging_interval_ms: evt.get_current_ranging_interval(),
-            ranging_measurement_type: evt.get_ranging_measurement_type(),
-            hus_primary_session_id: evt.get_hus_primary_session_id(),
-            ranging_measurements,
-            rcr_indicator: evt.get_rcr_indicator(),
-            raw_ranging_data,
-        }))
-    }
-}
-
-impl TryFrom<uwb_uci_packets::AndroidNotification> for UciNotification {
-    type Error = Error;
-    fn try_from(
-        evt: uwb_uci_packets::AndroidNotification,
-    ) -> std::result::Result<Self, Self::Error> {
-        use uwb_uci_packets::AndroidNotificationChild;
-
-        // (b/241336806): Currently we don't process the diagnostic packet, just log it only.
-        if let AndroidNotificationChild::AndroidRangeDiagnosticsNtf(ntf) = evt.specialize() {
-            debug!("Received diagnostic packet: {:?}", parse_diagnostics_ntf(ntf));
-        } else {
-            error!("Received unknown AndroidNotification: {:?}", evt);
-        }
-        Err(Error::Unknown)
-    }
-}
-
-fn vendor_notification(evt: uwb_uci_packets::UciNotification) -> Result<UciNotification> {
-    Ok(UciNotification::Vendor(RawUciMessage {
-        gid: evt.get_group_id().into(),
-        oid: evt.get_opcode().into(),
-        payload: get_vendor_uci_payload(evt)?,
-    }))
-}
-
-impl TryFrom<uwb_uci_packets::TestNotification> for RfTestNotification {
-    type Error = Error;
-    fn try_from(evt: uwb_uci_packets::TestNotification) -> std::result::Result<Self, Self::Error> {
-        use uwb_uci_packets::TestNotificationChild;
-        let raw_ntf_data = evt.clone().encode_to_bytes().unwrap()[UCI_PACKET_HEADER_LEN..].to_vec();
-        match evt.specialize() {
-            TestNotificationChild::TestPeriodicTxNtf(evt) => Ok(Self::TestPeriodicTxNtf {
-                status: evt.get_status(),
-                raw_notification_data: raw_ntf_data,
-            }),
-            TestNotificationChild::TestPerRxNtf(evt) => Ok(Self::TestPerRxNtf (RfTestPerRxData {
-                status: evt.get_status(),
-                attempts: evt.get_attempts(),
-                acq_detect: evt.get_acq_detect(),
-                acq_reject: evt.get_acq_reject(),
-                rx_fail: evt.get_rx_fail(),
-                sync_cir_ready: evt.get_sync_cir_ready(),
-                sfd_fail: evt.get_sfd_fail(),
-                sfd_found: evt.get_sfd_found(),
-                phr_dec_error: evt.get_phr_dec_error(),
-                phr_bit_error: evt.get_phr_bit_error(),
-                psdu_dec_error: evt.get_psdu_dec_error(),
-                psdu_bit_error: evt.get_psdu_bit_error(),
-                sts_found: evt.get_sts_found(),
-                eof: evt.get_eof(),
-                raw_notification_data: raw_ntf_data,
-            })),
-            _ => {
-                error!("Unknown RfTestNotification: {:?}", evt);
-                Err(Error::Unknown)
-            }
-        }
-    }
-}
-
-fn get_vendor_uci_payload(evt: uwb_uci_packets::UciNotification) -> Result<Vec<u8>> {
-    match evt.specialize() {
-        uwb_uci_packets::UciNotificationChild::UciVendor_9_Notification(evt) => {
-            match evt.specialize() {
-                uwb_uci_packets::UciVendor_9_NotificationChild::Payload(payload) => {
-                    Ok(payload.to_vec())
-                }
-                uwb_uci_packets::UciVendor_9_NotificationChild::None => Ok(Vec::new()),
-            }
-        }
-        uwb_uci_packets::UciNotificationChild::UciVendor_A_Notification(evt) => {
-            match evt.specialize() {
-                uwb_uci_packets::UciVendor_A_NotificationChild::Payload(payload) => {
-                    Ok(payload.to_vec())
-                }
-                uwb_uci_packets::UciVendor_A_NotificationChild::None => Ok(Vec::new()),
-            }
-        }
-        uwb_uci_packets::UciNotificationChild::UciVendor_B_Notification(evt) => {
-            match evt.specialize() {
-                uwb_uci_packets::UciVendor_B_NotificationChild::Payload(payload) => {
-                    Ok(payload.to_vec())
-                }
-                uwb_uci_packets::UciVendor_B_NotificationChild::None => Ok(Vec::new()),
-            }
-        }
-        uwb_uci_packets::UciNotificationChild::UciVendor_E_Notification(evt) => {
-            match evt.specialize() {
-                uwb_uci_packets::UciVendor_E_NotificationChild::Payload(payload) => {
-                    Ok(payload.to_vec())
-                }
-                uwb_uci_packets::UciVendor_E_NotificationChild::None => Ok(Vec::new()),
-            }
-        }
-        uwb_uci_packets::UciNotificationChild::UciVendor_F_Notification(evt) => {
-            match evt.specialize() {
-                uwb_uci_packets::UciVendor_F_NotificationChild::Payload(payload) => {
-                    Ok(payload.to_vec())
-                }
-                uwb_uci_packets::UciVendor_F_NotificationChild::None => Ok(Vec::new()),
-            }
-        }
-        _ => {
-            error!("Unknown UciVendor packet: {:?}", evt);
-            Err(Error::Unknown)
-        }
-    }
-}
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use bytes::{BufMut, BytesMut};
-
-    #[test]
-    fn test_ranging_measurements_trait() {
-        let empty_short_ranging_measurements = RangingMeasurements::ShortAddressTwoWay(vec![]);
-        assert_eq!(empty_short_ranging_measurements, empty_short_ranging_measurements);
-        let extended_ranging_measurements = RangingMeasurements::ExtendedAddressTwoWay(vec![
-            ExtendedAddressTwoWayRangingMeasurement {
-                mac_address: 0x1234_5678_90ab,
-                status: StatusCode::UciStatusOk,
-                nlos: 0,
-                distance: 4,
-                aoa_azimuth: 5,
-                aoa_azimuth_fom: 6,
-                aoa_elevation: 7,
-                aoa_elevation_fom: 8,
-                aoa_destination_azimuth: 9,
-                aoa_destination_azimuth_fom: 10,
-                aoa_destination_elevation: 11,
-                aoa_destination_elevation_fom: 12,
-                slot_index: 0,
-                rssi: u8::MAX,
-            },
-        ]);
-        assert_eq!(extended_ranging_measurements, extended_ranging_measurements.clone());
-        let empty_extended_ranging_measurements =
-            RangingMeasurements::ExtendedAddressTwoWay(vec![]);
-        assert_eq!(empty_short_ranging_measurements, empty_short_ranging_measurements);
-        //short and extended measurements are unequal even if both are empty:
-        assert_ne!(empty_short_ranging_measurements, empty_extended_ranging_measurements);
-    }
-    #[test]
-    fn test_core_notification_casting_from_generic_error() {
-        let generic_error_packet = uwb_uci_packets::GenericErrorBuilder {
-            status: uwb_uci_packets::StatusCode::UciStatusRejected,
-        }
-        .build();
-        let core_notification =
-            uwb_uci_packets::CoreNotification::try_from(generic_error_packet).unwrap();
-        let core_notification = CoreNotification::try_from(core_notification).unwrap();
-        let uci_notification_from_generic_error = UciNotification::Core(core_notification);
-        assert_eq!(
-            uci_notification_from_generic_error,
-            UciNotification::Core(CoreNotification::GenericError(
-                uwb_uci_packets::StatusCode::UciStatusRejected
-            ))
-        );
-    }
-    #[test]
-    fn test_core_notification_casting_from_device_status_ntf() {
-        let device_status_ntf_packet = uwb_uci_packets::DeviceStatusNtfBuilder {
-            device_state: uwb_uci_packets::DeviceState::DeviceStateActive,
-        }
-        .build();
-        let core_notification =
-            uwb_uci_packets::CoreNotification::try_from(device_status_ntf_packet).unwrap();
-        let uci_notification = CoreNotification::try_from(core_notification).unwrap();
-        let uci_notification_from_device_status_ntf = UciNotification::Core(uci_notification);
-        assert_eq!(
-            uci_notification_from_device_status_ntf,
-            UciNotification::Core(CoreNotification::DeviceStatus(
-                uwb_uci_packets::DeviceState::DeviceStateActive
-            ))
-        );
-    }
-
-    #[test]
-    fn test_session_notification_casting_from_extended_mac_two_way_session_info_ntf() {
-        let extended_measurement = uwb_uci_packets::ExtendedAddressTwoWayRangingMeasurement {
-            mac_address: 0x1234_5678_90ab,
-            status: StatusCode::UciStatusOk,
-            nlos: 0,
-            distance: 4,
-            aoa_azimuth: 5,
-            aoa_azimuth_fom: 6,
-            aoa_elevation: 7,
-            aoa_elevation_fom: 8,
-            aoa_destination_azimuth: 9,
-            aoa_destination_azimuth_fom: 10,
-            aoa_destination_elevation: 11,
-            aoa_destination_elevation_fom: 12,
-            slot_index: 0,
-            rssi: u8::MAX,
-        };
-        let extended_two_way_session_info_ntf =
-            uwb_uci_packets::ExtendedMacTwoWaySessionInfoNtfBuilder {
-                sequence_number: 0x10,
-                session_token: 0x11,
-                rcr_indicator: 0x12,
-                current_ranging_interval: 0x13,
-                hus_primary_session_id: 0x00,
-                two_way_ranging_measurements: vec![extended_measurement.clone()],
-                vendor_data: vec![],
-            }
-            .build();
-        let raw_ranging_data = extended_two_way_session_info_ntf.encode_to_bytes().unwrap()
-            [UCI_PACKET_HEADER_LEN..]
-            .to_vec();
-        let range_notification =
-            uwb_uci_packets::SessionInfoNtf::try_from(extended_two_way_session_info_ntf).unwrap();
-        let session_notification = SessionNotification::try_from(range_notification).unwrap();
-        let uci_notification_from_extended_two_way_session_info_ntf =
-            UciNotification::Session(session_notification);
-        assert_eq!(
-            uci_notification_from_extended_two_way_session_info_ntf,
-            UciNotification::Session(SessionNotification::SessionInfo(SessionRangeData {
-                sequence_number: 0x10,
-                session_token: 0x11,
-                ranging_measurement_type: uwb_uci_packets::RangingMeasurementType::TwoWay,
-                hus_primary_session_id: 0x00,
-                current_ranging_interval_ms: 0x13,
-                ranging_measurements: RangingMeasurements::ExtendedAddressTwoWay(vec![
-                    extended_measurement
-                ]),
-                rcr_indicator: 0x12,
-                raw_ranging_data,
-            }))
-        );
-    }
-
-    #[test]
-    fn test_session_notification_casting_from_short_mac_two_way_session_info_ntf() {
-        let short_measurement = uwb_uci_packets::ShortAddressTwoWayRangingMeasurement {
-            mac_address: 0x1234,
-            status: StatusCode::UciStatusOk,
-            nlos: 0,
-            distance: 4,
-            aoa_azimuth: 5,
-            aoa_azimuth_fom: 6,
-            aoa_elevation: 7,
-            aoa_elevation_fom: 8,
-            aoa_destination_azimuth: 9,
-            aoa_destination_azimuth_fom: 10,
-            aoa_destination_elevation: 11,
-            aoa_destination_elevation_fom: 12,
-            slot_index: 0,
-            rssi: u8::MAX,
-        };
-        let short_two_way_session_info_ntf = uwb_uci_packets::ShortMacTwoWaySessionInfoNtfBuilder {
-            sequence_number: 0x10,
-            session_token: 0x11,
-            rcr_indicator: 0x12,
-            current_ranging_interval: 0x13,
-            hus_primary_session_id: 0x00,
-            two_way_ranging_measurements: vec![short_measurement.clone()],
-            vendor_data: vec![0x02, 0x01],
-        }
-        .build();
-        let raw_ranging_data = short_two_way_session_info_ntf.encode_to_bytes().unwrap()
-            [UCI_PACKET_HEADER_LEN..]
-            .to_vec();
-        let range_notification =
-            uwb_uci_packets::SessionInfoNtf::try_from(short_two_way_session_info_ntf).unwrap();
-        let session_notification = SessionNotification::try_from(range_notification).unwrap();
-        let uci_notification_from_short_two_way_session_info_ntf =
-            UciNotification::Session(session_notification);
-        assert_eq!(
-            uci_notification_from_short_two_way_session_info_ntf,
-            UciNotification::Session(SessionNotification::SessionInfo(SessionRangeData {
-                sequence_number: 0x10,
-                session_token: 0x11,
-                ranging_measurement_type: uwb_uci_packets::RangingMeasurementType::TwoWay,
-                hus_primary_session_id: 0x00,
-                current_ranging_interval_ms: 0x13,
-                ranging_measurements: RangingMeasurements::ShortAddressTwoWay(vec![
-                    short_measurement
-                ]),
-                rcr_indicator: 0x12,
-                raw_ranging_data,
-            }))
-        );
-    }
-
-    #[test]
-    fn test_session_notification_casting_from_extended_mac_owr_aoa_session_info_ntf() {
-        let extended_measurement = uwb_uci_packets::ExtendedAddressOwrAoaRangingMeasurement {
-            mac_address: 0x1234_5678_90ab,
-            status: StatusCode::UciStatusOk,
-            nlos: 0,
-            frame_sequence_number: 1,
-            block_index: 1,
-            aoa_azimuth: 5,
-            aoa_azimuth_fom: 6,
-            aoa_elevation: 7,
-            aoa_elevation_fom: 8,
-        };
-        let extended_owr_aoa_session_info_ntf =
-            uwb_uci_packets::ExtendedMacOwrAoaSessionInfoNtfBuilder {
-                sequence_number: 0x10,
-                session_token: 0x11,
-                rcr_indicator: 0x12,
-                current_ranging_interval: 0x13,
-                hus_primary_session_id: 0x00,
-                owr_aoa_ranging_measurements: vec![extended_measurement.clone()],
-                vendor_data: vec![],
-            }
-            .build();
-        let raw_ranging_data = extended_owr_aoa_session_info_ntf.encode_to_bytes().unwrap()
-            [UCI_PACKET_HEADER_LEN..]
-            .to_vec();
-        let range_notification =
-            uwb_uci_packets::SessionInfoNtf::try_from(extended_owr_aoa_session_info_ntf).unwrap();
-        let session_notification = SessionNotification::try_from(range_notification).unwrap();
-        let uci_notification_from_extended_owr_aoa_session_info_ntf =
-            UciNotification::Session(session_notification);
-        assert_eq!(
-            uci_notification_from_extended_owr_aoa_session_info_ntf,
-            UciNotification::Session(SessionNotification::SessionInfo(SessionRangeData {
-                sequence_number: 0x10,
-                session_token: 0x11,
-                ranging_measurement_type: uwb_uci_packets::RangingMeasurementType::OwrAoa,
-                hus_primary_session_id: 0x00,
-                current_ranging_interval_ms: 0x13,
-                ranging_measurements: RangingMeasurements::ExtendedAddressOwrAoa(
-                    extended_measurement
-                ),
-                rcr_indicator: 0x12,
-                raw_ranging_data,
-            }))
-        );
-    }
-
-    #[test]
-    fn test_session_notification_casting_from_short_mac_owr_aoa_session_info_ntf() {
-        let short_measurement = uwb_uci_packets::ShortAddressOwrAoaRangingMeasurement {
-            mac_address: 0x1234,
-            status: StatusCode::UciStatusOk,
-            nlos: 0,
-            frame_sequence_number: 1,
-            block_index: 1,
-            aoa_azimuth: 5,
-            aoa_azimuth_fom: 6,
-            aoa_elevation: 7,
-            aoa_elevation_fom: 8,
-        };
-        let short_owr_aoa_session_info_ntf = uwb_uci_packets::ShortMacOwrAoaSessionInfoNtfBuilder {
-            sequence_number: 0x10,
-            session_token: 0x11,
-            rcr_indicator: 0x12,
-            current_ranging_interval: 0x13,
-            hus_primary_session_id: 0x00,
-            owr_aoa_ranging_measurements: vec![short_measurement.clone()],
-            vendor_data: vec![],
-        }
-        .build();
-        let raw_ranging_data = short_owr_aoa_session_info_ntf.encode_to_bytes().unwrap()
-            [UCI_PACKET_HEADER_LEN..]
-            .to_vec();
-        let range_notification =
-            uwb_uci_packets::SessionInfoNtf::try_from(short_owr_aoa_session_info_ntf).unwrap();
-        let session_notification = SessionNotification::try_from(range_notification).unwrap();
-        let uci_notification_from_short_owr_aoa_session_info_ntf =
-            UciNotification::Session(session_notification);
-        assert_eq!(
-            uci_notification_from_short_owr_aoa_session_info_ntf,
-            UciNotification::Session(SessionNotification::SessionInfo(SessionRangeData {
-                sequence_number: 0x10,
-                session_token: 0x11,
-                ranging_measurement_type: uwb_uci_packets::RangingMeasurementType::OwrAoa,
-                hus_primary_session_id: 0x00,
-                current_ranging_interval_ms: 0x13,
-                ranging_measurements: RangingMeasurements::ShortAddressOwrAoa(short_measurement),
-                rcr_indicator: 0x12,
-                raw_ranging_data,
-            }))
-        );
-    }
-
-    #[test]
-    fn test_session_notification_casting_from_session_status_ntf() {
-        let session_status_ntf = uwb_uci_packets::SessionStatusNtfBuilder {
-            session_token: 0x20,
-            session_state: uwb_uci_packets::SessionState::SessionStateActive,
-            reason_code: uwb_uci_packets::ReasonCode::StateChangeWithSessionManagementCommands
-                .into(),
-        }
-        .build();
-        let session_notification_packet =
-            uwb_uci_packets::SessionConfigNotification::try_from(session_status_ntf).unwrap();
-        let uci_fira_major_version = UCIMajorVersion::V1;
-        let session_notification = SessionNotification::try_from((
-            session_notification_packet,
-            uci_fira_major_version,
-            false,
-        ))
-        .unwrap();
-        let uci_notification_from_session_status_ntf =
-            UciNotification::Session(session_notification);
-        assert_eq!(
-            uci_notification_from_session_status_ntf,
-            UciNotification::Session(SessionNotification::Status {
-                session_id: 0x0,
-                session_token: 0x20,
-                session_state: uwb_uci_packets::SessionState::SessionStateActive,
-                reason_code: uwb_uci_packets::ReasonCode::StateChangeWithSessionManagementCommands
-                    .into(),
-            })
-        );
-    }
-
-    fn write_multicast_ntf_v1_payload(
-        payload: &SessionUpdateControllerMulticastListNtfV1Payload,
-        buffer: &mut BytesMut,
-    ) {
-        buffer.put_u8(payload.remaining_multicast_list_size);
-        buffer.put_u8(payload.controlee_status.len() as u8);
-        for elem in &payload.controlee_status {
-            write_v1_controlee_status(elem, buffer);
-        }
-    }
-
-    fn write_v1_controlee_status(status: &ControleeStatusV1, buffer: &mut BytesMut) {
-        for elem in &status.mac_address {
-            buffer.put_u8(*elem);
-        }
-        buffer.put_u32_le(status.subsession_id);
-        buffer.put_u8(u8::from(status.status));
-    }
-
-    fn write_multicast_ntf_v2_payload(
-        payload: &SessionUpdateControllerMulticastListNtfV2Payload,
-        buffer: &mut BytesMut,
-    ) {
-        buffer.put_u8(payload.controlee_status.len() as u8);
-        for elem in &payload.controlee_status {
-            write_v2_controlee_status(elem, buffer);
-        }
-    }
-
-    fn write_v2_controlee_status(status: &ControleeStatusV2, buffer: &mut BytesMut) {
-        for elem in &status.mac_address {
-            buffer.put_u8(*elem);
-        }
-        buffer.put_u8(u8::from(status.status));
-    }
-
-    #[test]
-    fn test_session_notification_casting_from_session_update_controller_multicast_list_ntf_v1_packet(
-    ) {
-        let controlee_status_v1 = uwb_uci_packets::ControleeStatusV1 {
-            mac_address: [0x0c, 0xa8],
-            subsession_id: 0x30,
-            status: uwb_uci_packets::MulticastUpdateStatusCode::StatusOkMulticastListUpdate,
-        };
-        let another_controlee_status_v1 = uwb_uci_packets::ControleeStatusV1 {
-            mac_address: [0x0c, 0xa9],
-            subsession_id: 0x31,
-            status: uwb_uci_packets::MulticastUpdateStatusCode::StatusErrorKeyFetchFail,
-        };
-        let payload = uwb_uci_packets::SessionUpdateControllerMulticastListNtfV1Payload {
-            remaining_multicast_list_size: 0x2,
-            controlee_status: vec![
-                controlee_status_v1.clone(),
-                another_controlee_status_v1.clone(),
-            ],
-        };
-        let mut buf = BytesMut::new();
-        write_multicast_ntf_v1_payload(&payload, &mut buf);
-        let session_update_controller_multicast_list_ntf_v1 =
-            uwb_uci_packets::SessionUpdateControllerMulticastListNtfBuilder {
-                session_token: 0x32,
-                payload: Some(buf.freeze()),
-            }
-            .build();
-        let session_notification_packet = uwb_uci_packets::SessionConfigNotification::try_from(
-            session_update_controller_multicast_list_ntf_v1,
-        )
-        .unwrap();
-        let uci_fira_major_version = UCIMajorVersion::V1;
-        let session_notification = SessionNotification::try_from((
-            session_notification_packet,
-            uci_fira_major_version,
-            false,
-        ))
-        .unwrap();
-        let uci_notification_from_session_update_controller_multicast_list_ntf =
-            UciNotification::Session(session_notification);
-        assert_eq!(
-            uci_notification_from_session_update_controller_multicast_list_ntf,
-            UciNotification::Session(SessionNotification::UpdateControllerMulticastListV1 {
-                session_token: 0x32,
-                remaining_multicast_list_size: 0x2,
-                status_list: vec![controlee_status_v1, another_controlee_status_v1],
-            })
-        );
-    }
-
-    #[test]
-    fn test_cast_failed_from_session_update_controller_multicast_list_ntf_v1_packet_v2_payload() {
-        let controlee_status_v2 = uwb_uci_packets::ControleeStatusV2 {
-            mac_address: [0x0c, 0xa8],
-            status: uwb_uci_packets::MulticastUpdateStatusCode::StatusOkMulticastListUpdate,
-        };
-        let another_controlee_status_v2 = uwb_uci_packets::ControleeStatusV2 {
-            mac_address: [0x0c, 0xa9],
-            status: uwb_uci_packets::MulticastUpdateStatusCode::StatusErrorKeyFetchFail,
-        };
-        let payload = uwb_uci_packets::SessionUpdateControllerMulticastListNtfV2Payload {
-            controlee_status: vec![controlee_status_v2, another_controlee_status_v2],
-        };
-        let mut buf = BytesMut::new();
-        write_multicast_ntf_v2_payload(&payload, &mut buf);
-        let session_update_controller_multicast_list_ntf_v1 =
-            uwb_uci_packets::SessionUpdateControllerMulticastListNtfBuilder {
-                session_token: 0x32,
-                payload: Some(buf.freeze()),
-            }
-            .build();
-        let session_notification_packet = uwb_uci_packets::SessionConfigNotification::try_from(
-            session_update_controller_multicast_list_ntf_v1,
-        )
-        .unwrap();
-        let uci_fira_major_version = UCIMajorVersion::V1;
-        let session_notification = SessionNotification::try_from((
-            session_notification_packet,
-            uci_fira_major_version,
-            false,
-        ));
-        assert_eq!(session_notification, Err(Error::BadParameters));
-    }
-
-    #[test]
-    fn test_cast_failed_from_session_update_controller_multicast_list_ntf_v2_packet_v1_payload() {
-        let controlee_status_v1 = uwb_uci_packets::ControleeStatusV1 {
-            mac_address: [0x0c, 0xa8],
-            subsession_id: 0x30,
-            status: uwb_uci_packets::MulticastUpdateStatusCode::StatusOkMulticastListUpdate,
-        };
-        let payload = uwb_uci_packets::SessionUpdateControllerMulticastListNtfV1Payload {
-            remaining_multicast_list_size: 0x4,
-            controlee_status: vec![controlee_status_v1],
-        };
-        let mut buf = BytesMut::new();
-        write_multicast_ntf_v1_payload(&payload, &mut buf);
-        let session_update_controller_multicast_list_ntf_v1 =
-            uwb_uci_packets::SessionUpdateControllerMulticastListNtfBuilder {
-                session_token: 0x32,
-                payload: Some(buf.freeze()),
-            }
-            .build();
-        let session_notification_packet = uwb_uci_packets::SessionConfigNotification::try_from(
-            session_update_controller_multicast_list_ntf_v1,
-        )
-        .unwrap();
-        let uci_fira_major_version = UCIMajorVersion::V2;
-        let session_notification = SessionNotification::try_from((
-            session_notification_packet,
-            uci_fira_major_version,
-            true,
-        ));
-        assert_eq!(session_notification, Err(Error::BadParameters));
-    }
-
-    #[test]
-    fn test_session_notification_casting_from_session_update_controller_multicast_list_ntf_v2_packet(
-    ) {
-        let controlee_status_v2 = uwb_uci_packets::ControleeStatusV2 {
-            mac_address: [0x0c, 0xa8],
-            status: uwb_uci_packets::MulticastUpdateStatusCode::StatusOkMulticastListUpdate,
-        };
-        let another_controlee_status_v2 = uwb_uci_packets::ControleeStatusV2 {
-            mac_address: [0x0c, 0xa9],
-            status: uwb_uci_packets::MulticastUpdateStatusCode::StatusErrorKeyFetchFail,
-        };
-        let payload = uwb_uci_packets::SessionUpdateControllerMulticastListNtfV2Payload {
-            controlee_status: vec![
-                controlee_status_v2.clone(),
-                another_controlee_status_v2.clone(),
-            ],
-        };
-        let mut buf = BytesMut::new();
-        write_multicast_ntf_v2_payload(&payload, &mut buf);
-        let session_update_controller_multicast_list_ntf_v2 =
-            uwb_uci_packets::SessionUpdateControllerMulticastListNtfBuilder {
-                session_token: 0x32,
-                payload: Some(buf.freeze()),
-            }
-            .build();
-        let session_notification_packet = uwb_uci_packets::SessionConfigNotification::try_from(
-            session_update_controller_multicast_list_ntf_v2,
-        )
-        .unwrap();
-        let uci_fira_major_version = UCIMajorVersion::V2;
-        let session_notification = SessionNotification::try_from((
-            session_notification_packet,
-            uci_fira_major_version,
-            true,
-        ))
-        .unwrap();
-        let uci_notification_from_session_update_controller_multicast_list_ntf =
-            UciNotification::Session(session_notification);
-        assert_eq!(
-            uci_notification_from_session_update_controller_multicast_list_ntf,
-            UciNotification::Session(SessionNotification::UpdateControllerMulticastListV2 {
-                session_token: 0x32,
-                status_list: vec![controlee_status_v2, another_controlee_status_v2],
-            })
-        );
-    }
-
-    #[test]
-    fn test_session_notification_casting_from_session_data_transfer_phase_config_ntf_packet() {
-        let session_data_transfer_phase_config_ntf =
-            uwb_uci_packets::SessionDataTransferPhaseConfigNtfBuilder {
-                session_token: 0x32,
-                status: DataTransferPhaseConfigUpdateStatusCode::UciDtpcmConfigSuccessStatusOk,
-            }
-            .build();
-        let session_notification_packet = uwb_uci_packets::SessionConfigNotification::try_from(
-            session_data_transfer_phase_config_ntf,
-        )
-        .unwrap();
-        let uci_fira_major_version = UCIMajorVersion::V1;
-        let session_notification = SessionNotification::try_from((
-            session_notification_packet,
-            uci_fira_major_version,
-            false,
-        ))
-        .unwrap();
-        let uci_notification_from_session_data_transfer_phase_config_ntf =
-            UciNotification::Session(session_notification);
-        assert_eq!(
-            uci_notification_from_session_data_transfer_phase_config_ntf,
-            UciNotification::Session(SessionNotification::DataTransferPhaseConfig {
-                session_token: 0x32,
-                status: DataTransferPhaseConfigUpdateStatusCode::UciDtpcmConfigSuccessStatusOk
-            })
-        );
-    }
-
-    #[test]
-    fn test_session_notification_casting_from_short_mac_dl_tdoa_session_info_ntf_packet() {
-        let dl_tdoa_measurements = vec![
-            0x0a, 0x01, 0x33, 0x05, // 2(Mac address), Status, Message Type
-            0x53, 0x05, 0x02, 0x05, // 2(Message control), 2(Block Index)
-            0x07, 0x09, 0x0a, 0x01, // Round Index, NLoS, 2(AoA Azimuth)
-            0x02, 0x05, 0x07, 0x09, // AoA Azimuth FOM, 2(AoA Elevation), AoA Elevation FOM
-            0x0a, 0x01, 0x02, 0x05, // RSSI, 3(Tx Timestamp..)
-            0x07, 0x09, 0x0a, 0x01, // 4(Tx Timestamp..)
-            0x02, 0x05, 0x07, 0x09, // Tx Timestamp, 3(Rx Timestamp..)
-            0x05, 0x07, 0x09, 0x0a, // 2(Rx Timestamp), 2(Anchor Cfo)
-            0x01, 0x02, 0x05, 0x07, // 2(Cfo), 2(Initiator Reply Time..)
-            0x09, 0x05, 0x07, 0x09, // 2(Initiator Reply Time), 2(Responder Reply Time..)
-            0x0a, 0x01, 0x02, 0x05, // 2(Responder Reply Time), 2(Initiator-Responder ToF)
-            0x07, 0x09, 0x07, 0x09, // 4(Anchor Location..)
-            0x05, 0x07, 0x09, 0x0a, // 4(Anchor Location..)
-            0x01, 0x02, 0x05, 0x07, // 2(Anchor Location..), 2(Active Ranging Rounds..)
-            0x09, 0x0a, 0x01, 0x02, // 4(Active Ranging Rounds..)
-            0x05, 0x07, 0x09, 0x05, // 4(Active Ranging Rounds)
-        ];
-        let short_mac_dl_tdoa_session_info_ntf =
-            uwb_uci_packets::ShortMacDlTDoASessionInfoNtfBuilder {
-                current_ranging_interval: 0x13,
-                hus_primary_session_id: 0x00,
-                dl_tdoa_measurements: dl_tdoa_measurements.clone(),
-                no_of_ranging_measurements: 1,
-                rcr_indicator: 0x12,
-                sequence_number: 0x10,
-                session_token: 0x11,
-            }
-            .build();
-        let raw_ranging_data = short_mac_dl_tdoa_session_info_ntf.encode_to_bytes().unwrap()
-            [UCI_PACKET_HEADER_LEN..]
-            .to_vec();
-        let short_measurement =
-            ShortAddressDlTdoaRangingMeasurement::parse(&dl_tdoa_measurements, 1).unwrap();
-        let range_notification_packet =
-            uwb_uci_packets::SessionInfoNtf::try_from(short_mac_dl_tdoa_session_info_ntf).unwrap();
-        let session_notification =
-            SessionNotification::try_from(range_notification_packet).unwrap();
-        let uci_notification_from_short_mac_dl_tdoa_session_info_ntf =
-            UciNotification::Session(session_notification);
-        assert_eq!(
-            uci_notification_from_short_mac_dl_tdoa_session_info_ntf,
-            UciNotification::Session(SessionNotification::SessionInfo(SessionRangeData {
-                sequence_number: 0x10,
-                session_token: 0x11,
-                ranging_measurement_type: uwb_uci_packets::RangingMeasurementType::DlTdoa,
-                current_ranging_interval_ms: 0x13,
-                hus_primary_session_id: 0x00,
-                ranging_measurements: RangingMeasurements::ShortAddressDltdoa(short_measurement),
-                rcr_indicator: 0x12,
-                raw_ranging_data,
-            }))
-        );
-    }
-
-    #[test]
-    fn test_session_notification_casting_from_extended_mac_dltdoa_session_info_ntf_packet() {
-        let dl_tdoa_measurements = vec![
-            // All Fields in Little Endian (LE)
-            0x0a, 0x01, 0x33, 0x05, // 4(Mac address..)
-            0x33, 0x05, 0x02, 0x05, // 4(Mac address)
-            0x07, 0x09, 0x0a, 0x01, // Status, Message Type, 2(Message control),
-            0x02, 0x05, 0x07, 0x09, // 2(Block Index), Round Index, NLoS,
-            0x0a, 0x01, 0x02, 0x05, // 2(AoA Azimuth), AoA Azimuth FOM, 1(AoA Elevation..)
-            0x07, 0x09, 0x0a, // 1(AoA Elevation), AoA Elevation FOM, RSSI,
-            0x01, 0x02, 0x05, 0x07, // 4(Tx Timestamp..)
-            0x09, 0x05, 0x07, 0x09, // 4(Tx Timestamp),
-            0x0a, 0x01, 0x02, 0x05, // 4(Rx Timestamp..)
-            0x07, 0x09, 0x05, 0x07, // 4(Rx Timestamp)
-            0x09, 0x0a, 0x01, 0x02, // 2(Anchor Cfo), 2(Cfo),
-            0x05, 0x07, 0x09, 0x05, // 4(Initiator Reply Time)
-            0x07, 0x09, 0x0a, 0x01, // 4(Responder Reply Time),
-            0x02, 0x05, 0x02, 0x05, // 2(Initiator-Responder ToF), 2(Active Ranging Rounds)
-        ];
-        let extended_mac_dl_tdoa_session_info_ntf =
-            uwb_uci_packets::ExtendedMacDlTDoASessionInfoNtfBuilder {
-                current_ranging_interval: 0x13,
-                hus_primary_session_id: 0x00,
-                dl_tdoa_measurements: dl_tdoa_measurements.clone(),
-                no_of_ranging_measurements: 1,
-                rcr_indicator: 0x12,
-                sequence_number: 0x10,
-                session_token: 0x11,
-            }
-            .build();
-        let raw_ranging_data = extended_mac_dl_tdoa_session_info_ntf.encode_to_bytes().unwrap()
-            [UCI_PACKET_HEADER_LEN..]
-            .to_vec();
-        let short_measurement =
-            ExtendedAddressDlTdoaRangingMeasurement::parse(&dl_tdoa_measurements, 1).unwrap();
-        let range_notification_packet =
-            uwb_uci_packets::SessionInfoNtf::try_from(extended_mac_dl_tdoa_session_info_ntf)
-                .unwrap();
-        let session_notification =
-            SessionNotification::try_from(range_notification_packet).unwrap();
-        let uci_notification_from_extended_mac_dl_tdoa_session_info_ntf =
-            UciNotification::Session(session_notification);
-        assert_eq!(
-            uci_notification_from_extended_mac_dl_tdoa_session_info_ntf,
-            UciNotification::Session(SessionNotification::SessionInfo(SessionRangeData {
-                sequence_number: 0x10,
-                session_token: 0x11,
-                ranging_measurement_type: uwb_uci_packets::RangingMeasurementType::DlTdoa,
-                current_ranging_interval_ms: 0x13,
-                hus_primary_session_id: 0x00,
-                ranging_measurements: RangingMeasurements::ExtendedAddressDltdoa(short_measurement),
-                rcr_indicator: 0x12,
-                raw_ranging_data,
-            }))
-        );
-    }
-
-    #[test]
-    #[allow(non_snake_case)] //override snake case for vendor_A
-    fn test_vendor_notification_casting() {
-        let vendor_9_empty_notification: uwb_uci_packets::UciNotification =
-            uwb_uci_packets::UciVendor_9_NotificationBuilder { opcode: 0x40, payload: None }
-                .build()
-                .into();
-        let vendor_A_nonempty_notification: uwb_uci_packets::UciNotification =
-            uwb_uci_packets::UciVendor_A_NotificationBuilder {
-                opcode: 0x41,
-                payload: Some(bytes::Bytes::from_static(b"Placeholder notification.")),
-            }
-            .build()
-            .into();
-        let vendor_B_nonempty_notification: uwb_uci_packets::UciNotification =
-            uwb_uci_packets::UciVendor_B_NotificationBuilder {
-                opcode: 0x41,
-                payload: Some(bytes::Bytes::from_static(b"Placeholder notification.")),
-            }
-            .build()
-            .into();
-        let vendor_E_nonempty_notification: uwb_uci_packets::UciNotification =
-            uwb_uci_packets::UciVendor_E_NotificationBuilder {
-                opcode: 0x41,
-                payload: Some(bytes::Bytes::from_static(b"Placeholder notification.")),
-            }
-            .build()
-            .into();
-        let vendor_F_nonempty_notification: uwb_uci_packets::UciNotification =
-            uwb_uci_packets::UciVendor_F_NotificationBuilder {
-                opcode: 0x41,
-                payload: Some(bytes::Bytes::from_static(b"Placeholder notification.")),
-            }
-            .build()
-            .into();
-        let uci_fira_major_version = UCIMajorVersion::V1;
-        let uci_notification_from_vendor_9 = UciNotification::try_from((
-            vendor_9_empty_notification,
-            uci_fira_major_version.clone(),
-            false,
-        ))
-        .unwrap();
-        let uci_notification_from_vendor_A = UciNotification::try_from((
-            vendor_A_nonempty_notification,
-            uci_fira_major_version.clone(),
-            false,
-        ))
-        .unwrap();
-        let uci_notification_from_vendor_B = UciNotification::try_from((
-            vendor_B_nonempty_notification,
-            uci_fira_major_version.clone(),
-            false,
-        ))
-        .unwrap();
-        let uci_notification_from_vendor_E = UciNotification::try_from((
-            vendor_E_nonempty_notification,
-            uci_fira_major_version.clone(),
-            false,
-        ))
-        .unwrap();
-        let uci_notification_from_vendor_F = UciNotification::try_from((
-            vendor_F_nonempty_notification,
-            uci_fira_major_version,
-            false,
-        ))
-        .unwrap();
-        assert_eq!(
-            uci_notification_from_vendor_9,
-            UciNotification::Vendor(RawUciMessage {
-                gid: 0x9, // per enum GroupId in uci_packets.pdl
-                oid: 0x40,
-                payload: vec![],
-            })
-        );
-        assert_eq!(
-            uci_notification_from_vendor_A,
-            UciNotification::Vendor(RawUciMessage {
-                gid: 0xa,
-                oid: 0x41,
-                payload: b"Placeholder notification.".to_owned().into(),
-            })
-        );
-        assert_eq!(
-            uci_notification_from_vendor_B,
-            UciNotification::Vendor(RawUciMessage {
-                gid: 0xb,
-                oid: 0x41,
-                payload: b"Placeholder notification.".to_owned().into(),
-            })
-        );
-        assert_eq!(
-            uci_notification_from_vendor_E,
-            UciNotification::Vendor(RawUciMessage {
-                gid: 0xe,
-                oid: 0x41,
-                payload: b"Placeholder notification.".to_owned().into(),
-            })
-        );
-        assert_eq!(
-            uci_notification_from_vendor_F,
-            UciNotification::Vendor(RawUciMessage {
-                gid: 0xf,
-                oid: 0x41,
-                payload: b"Placeholder notification.".to_owned().into(),
-            })
-        );
-    }
-
-    #[test]
-    fn test_rf_test_notification_casting_from_rf_periodic_tx_ntf() {
-        let test_periodic_tx_ntf_packet = uwb_uci_packets::TestPeriodicTxNtfBuilder {
-            status: uwb_uci_packets::StatusCode::UciStatusOk,
-            vendor_data: vec![],
-        }
-        .build();
-        let raw_notification_data = test_periodic_tx_ntf_packet.clone().encode_to_bytes().unwrap()
-            [UCI_PACKET_HEADER_LEN..]
-            .to_vec();
-        let rf_test_notification =
-            uwb_uci_packets::TestNotification::try_from(test_periodic_tx_ntf_packet).unwrap();
-        let uci_notification = RfTestNotification::try_from(rf_test_notification).unwrap();
-        let uci_notification_from_periodic_tx_ntf = UciNotification::RfTest(uci_notification);
-        let status = uwb_uci_packets::StatusCode::UciStatusOk;
-        assert_eq!(
-            uci_notification_from_periodic_tx_ntf,
-            UciNotification::RfTest(RfTestNotification::TestPeriodicTxNtf {
-                status,
-                raw_notification_data
-            })
-        );
-    }
-
-    #[test]
-    fn test_rf_test_notification_casting_from_rf_per_rx_ntf() {
-        let test_per_rx_ntf_packet = uwb_uci_packets::TestPerRxNtfBuilder {
-            status: uwb_uci_packets::StatusCode::UciStatusOk,
-            attempts: 1,
-            acq_detect: 2,
-            acq_reject: 3,
-            rx_fail: 4,
-            sync_cir_ready: 5,
-            sfd_fail: 6,
-            sfd_found: 7,
-            phr_dec_error: 8,
-            phr_bit_error: 9,
-            psdu_dec_error: 10,
-            psdu_bit_error: 11,
-            sts_found: 12,
-            eof: 13,
-            vendor_data: vec![],
-        }
-            .build();
-        let raw_notification_data = test_per_rx_ntf_packet.clone().encode_to_bytes().unwrap()
-            [UCI_PACKET_HEADER_LEN..]
-            .to_vec();
-        let rf_test_notification =
-            uwb_uci_packets::TestNotification::try_from(test_per_rx_ntf_packet).unwrap();
-        let uci_notification = RfTestNotification::try_from(rf_test_notification).unwrap();
-        let uci_notification_from_per_rx_ntf = UciNotification::RfTest(uci_notification);
-        let status = uwb_uci_packets::StatusCode::UciStatusOk;
-        let attempts = 1;
-        let acq_detect = 2;
-        let acq_reject = 3;
-        let rx_fail = 4;
-        let sync_cir_ready = 5;
-        let sfd_fail = 6;
-        let sfd_found = 7;
-        let phr_dec_error = 8;
-        let phr_bit_error = 9;
-        let psdu_dec_error = 10;
-        let psdu_bit_error = 11;
-        let sts_found = 12;
-        let eof = 13;
-        assert_eq!(
-            uci_notification_from_per_rx_ntf,
-            UciNotification::RfTest(RfTestNotification::TestPerRxNtf(RfTestPerRxData {
-                status,
-                attempts,
-                acq_detect,
-                acq_reject,
-                rx_fail,
-                sync_cir_ready,
-                sfd_fail,
-                sfd_found,
-                phr_dec_error,
-                phr_bit_error,
-                psdu_dec_error,
-                psdu_bit_error,
-                sts_found,
-                eof,
-                raw_notification_data
-            }))
-        );
-    }
-}
diff --git a/src/rust/uwb_core/src/uci/pcapng_block.rs b/src/rust/uwb_core/src/uci/pcapng_block.rs
deleted file mode 100644
index 6fcc670..0000000
--- a/src/rust/uwb_core/src/uci/pcapng_block.rs
+++ /dev/null
@@ -1,446 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Builders for PCAPNG blocks.
-
-use std::convert::TryInto;
-use std::time::SystemTime;
-
-use log::debug;
-use num_derive::{FromPrimitive, ToPrimitive};
-use num_traits::cast::ToPrimitive;
-
-/// Supported PCAPNG block types.
-#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, Eq, Clone)]
-#[repr(u32)]
-pub enum BlockType {
-    SectionHeader = 0x0A0D_0D0A,
-    InterfaceDescription = 0x1,
-    EnhancedPacket = 0x6,
-}
-
-/// BlockOption is an option to be attached to a block.
-#[derive(Clone, PartialEq, Eq)]
-pub struct BlockOption {
-    option_code: u16,
-    option_content: Vec<u8>,
-}
-
-impl BlockOption {
-    /// Constructor.
-    pub fn new(option_code: u16, option_content: Vec<u8>) -> Self {
-        Self { option_code, option_content }
-    }
-
-    /// Constructor for end_of_opt option.
-    fn end_of_opt() -> Self {
-        Self { option_code: 0, option_content: vec![] }
-    }
-
-    /// To little endian bytes.
-    fn into_le_bytes(mut self) -> Option<Vec<u8>> {
-        let option_length = self.option_content.len();
-        // padded to multiple of 4.
-        let padded_option_length = integer_ceil(option_length, 4);
-        let pad_length = padded_option_length - option_length;
-        let mut bytes = Vec::<u8>::new();
-        bytes.extend_from_slice(&u16::to_le_bytes(self.option_code));
-        bytes.extend_from_slice(&u16::to_le_bytes(option_length.try_into().ok()?));
-        bytes.append(&mut self.option_content);
-        bytes.extend_from_slice(&vec![0; pad_length]);
-        Some(bytes)
-    }
-
-    /// Size of option in bytes.
-    fn byte_size(&self) -> usize {
-        let option_length = self.option_content.len();
-        // padded to multiple of 4.
-        let padded_option_length = integer_ceil(option_length, 4);
-        padded_option_length + 4 // 4 bytes for option_code and option_length
-    }
-}
-
-/// Builds the little endian block with BlockType and BlockOptions added, and block size counted.
-fn wrap_little_endian_block(
-    block_type: BlockType,
-    mut block_core: Vec<u8>,
-    block_options: Vec<BlockOption>,
-) -> Option<Vec<u8>> {
-    static BLOCK_SIZE_OFFSET: usize = 12;
-    let mut option_bytes = Vec::<u8>::new();
-    if !block_options.is_empty() {
-        for block_option in block_options {
-            option_bytes.append(block_option.into_le_bytes()?.as_mut());
-        }
-        // When option is present, opt_endofopt (option_code 0, length 0) MUST present at end.
-        option_bytes.append(BlockOption::end_of_opt().into_le_bytes()?.as_mut());
-    };
-    let block_size = BLOCK_SIZE_OFFSET + block_core.len() + option_bytes.len();
-    let mut bytes = Vec::<u8>::new();
-    bytes.extend_from_slice(&u32::to_le_bytes(block_type.to_u32().unwrap()));
-    bytes.extend_from_slice(&u32::to_le_bytes(block_size.try_into().ok()?));
-    bytes.append(&mut block_core);
-    bytes.append(&mut option_bytes);
-    bytes.extend_from_slice(&u32::to_le_bytes(block_size.try_into().ok()?));
-    Some(bytes)
-}
-
-/// Generic Block Builder.
-pub trait BlockBuilder {
-    /// Builds the block into little endian bytes.
-    ///
-    /// Returns a PCAPNG block on success.
-    /// Fails if the content cannot be converted to a valid PCAPNG block.
-    fn into_le_bytes(self) -> Option<Vec<u8>>;
-}
-
-/// Builds HeaderBlock.
-pub struct HeaderBlockBuilder {}
-
-impl HeaderBlockBuilder {
-    /// Constructor.
-    #[allow(unused)]
-    pub fn new() -> Self {
-        Self {}
-    }
-}
-
-impl BlockBuilder for HeaderBlockBuilder {
-    fn into_le_bytes(self) -> Option<Vec<u8>> {
-        let mut block_core = Vec::<u8>::new();
-        // Byte-Order Magic
-        block_core.extend_from_slice(&u32::to_le_bytes(0x1A2B3C4D));
-        // Major Version 1, Minor Version 0
-        block_core.extend_from_slice(&u16::to_le_bytes(1));
-        block_core.extend_from_slice(&u16::to_le_bytes(0));
-        // Section Length (not specified)
-        block_core.extend_from_slice(&u64::to_le_bytes(0xFFFF_FFFF_FFFF_FFFF));
-        wrap_little_endian_block(BlockType::SectionHeader, block_core, vec![])
-    }
-}
-
-/// Builds Interface Description Block that is unique to chip.
-pub struct InterfaceDescriptionBlockBuilder {
-    /// LinkType.
-    link_type: u16,
-    /// SnapLen.
-    snap_len: u32,
-    /// Options for block.
-    block_options: Vec<BlockOption>,
-}
-
-impl Default for InterfaceDescriptionBlockBuilder {
-    fn default() -> Self {
-        Self {
-            link_type: 299, // FiRa UCI
-            snap_len: 0,    // unlimited
-            block_options: vec![],
-        }
-    }
-}
-
-impl InterfaceDescriptionBlockBuilder {
-    /// Constructor.
-    #[allow(unused)]
-    pub fn new() -> Self {
-        InterfaceDescriptionBlockBuilder::default()
-    }
-
-    /// Set LinkType.
-    #[allow(unused)]
-    pub fn link_type(mut self, link_type: u16) -> Self {
-        self.link_type = link_type;
-        self
-    }
-
-    /// Set SnapLen.
-    #[allow(unused)]
-    pub fn snap_len(mut self, snap_length: u32) -> Self {
-        self.snap_len = snap_length;
-        self
-    }
-
-    /// Append an option.
-    #[allow(unused)]
-    pub fn append_option(mut self, block_option: BlockOption) -> Self {
-        self.block_options.push(block_option);
-        self
-    }
-}
-
-impl BlockBuilder for InterfaceDescriptionBlockBuilder {
-    fn into_le_bytes(self) -> Option<Vec<u8>> {
-        let mut block_core = Vec::<u8>::new();
-        block_core.extend_from_slice(&u16::to_le_bytes(self.link_type)); // LinkType
-        block_core.extend_from_slice(&u16::to_le_bytes(0)); // Reserved
-        block_core.extend_from_slice(&u32::to_le_bytes(self.snap_len)); // SnapLen
-        wrap_little_endian_block(BlockType::InterfaceDescription, block_core, self.block_options)
-    }
-}
-
-pub struct EnhancedPacketBlockBuilder {
-    interface_id: u32,
-    timestamp: u64,
-    packet: Vec<u8>,
-    block_options: Vec<BlockOption>,
-    max_block_size: Option<usize>,
-}
-
-impl Default for EnhancedPacketBlockBuilder {
-    fn default() -> Self {
-        let timestamp = match SystemTime::now().duration_since(SystemTime::UNIX_EPOCH) {
-            // as_micros return u128. However, u64 will not overflow until year 586524.
-            Ok(duration) => duration.as_micros() as u64,
-            Err(e) => {
-                debug!("UCI log: system time is before Unix Epoch: {:?}", e);
-                0u64
-            }
-        };
-        Self {
-            interface_id: 0,
-            timestamp,
-            packet: vec![],
-            block_options: vec![],
-            max_block_size: None,
-        }
-    }
-}
-
-impl EnhancedPacketBlockBuilder {
-    /// Constructor.
-    #[allow(unused)]
-    pub fn new() -> Self {
-        EnhancedPacketBlockBuilder::default()
-    }
-
-    /// Set interface ID.
-    #[allow(unused)]
-    pub fn interface_id(mut self, interface_id: u32) -> Self {
-        self.interface_id = interface_id;
-        self
-    }
-
-    /// Set timestamp.
-    #[allow(unused)]
-    pub fn timestamp(mut self, timestamp: u64) -> Self {
-        self.timestamp = timestamp;
-        self
-    }
-
-    /// Set packet.
-    #[allow(unused)]
-    pub fn packet(mut self, packet: Vec<u8>) -> Self {
-        self.packet = packet;
-        self
-    }
-
-    /// Sets maximum block size permitted (optional). Truncated down to nearest multiple of 4.
-    #[allow(unused)]
-    pub fn max_block_size(mut self, max_block_size: usize) -> Self {
-        self.max_block_size = Some(integer_floor(max_block_size, 4));
-        self
-    }
-
-    /// Append an option.
-    #[allow(unused)]
-    pub fn append_option(mut self, block_option: BlockOption) -> Self {
-        self.block_options.push(block_option);
-        self
-    }
-
-    /// Returns maximum packet byte size if value is valid.
-    fn max_truncated_packet_length(&self) -> Option<u32> {
-        static EPB_SIZE_OFFSET: usize = 32;
-        if self.max_block_size.is_none() {
-            return Some(u32::MAX);
-        }
-        let max_block_size = self.max_block_size.unwrap();
-        let options_byte_length: usize = if !self.block_options.is_empty() {
-            self.block_options
-                .iter()
-                .map(|block_option| -> usize { block_option.byte_size() })
-                .sum::<usize>()
-                + 4 // opt_endofopt of size 4 is compulsory for nonempty options.
-        } else {
-            0
-        };
-        match max_block_size > EPB_SIZE_OFFSET + options_byte_length {
-            true => Some((max_block_size - EPB_SIZE_OFFSET - options_byte_length).try_into().ok()?),
-            false => None,
-        }
-    }
-}
-
-impl BlockBuilder for EnhancedPacketBlockBuilder {
-    /// Builds the block into little endian bytes.
-    ///
-    /// Fails if packet is larger than u32::MAX, or max_packet_length is too small such that the
-    /// package is does not fit with all content truncated.
-    fn into_le_bytes(mut self) -> Option<Vec<u8>> {
-        let max_packet_length = self.max_truncated_packet_length()?;
-        let original_packet_length: u32 = self.packet.len().try_into().ok()?;
-        let captured_packet_length = if max_packet_length >= original_packet_length {
-            // padding:
-            let pad_length = integer_ceil(self.packet.len(), 4) - self.packet.len();
-            self.packet.append(vec![0; pad_length].as_mut());
-            original_packet_length
-        } else {
-            // truncating:
-            self.packet.truncate(max_packet_length.try_into().ok()?);
-            self.packet.len().try_into().ok()?
-        };
-        let mut block_core = Vec::<u8>::new();
-        // interface ID
-        block_core.extend_from_slice(&u32::to_le_bytes(self.interface_id));
-        // High timestamp
-        block_core.extend_from_slice(&u32::to_le_bytes((self.timestamp >> 32) as u32));
-        // Low timestamp
-        block_core.extend_from_slice(&u32::to_le_bytes(self.timestamp as u32));
-        // Captured Packet Length
-        block_core.extend_from_slice(&u32::to_le_bytes(captured_packet_length));
-        // Original Packet Length
-        block_core.extend_from_slice(&u32::to_le_bytes(original_packet_length));
-        block_core.append(&mut self.packet);
-        wrap_little_endian_block(BlockType::EnhancedPacket, block_core, self.block_options)
-    }
-}
-
-fn integer_ceil<T: num_traits::PrimInt>(value: T, step: T) -> T {
-    (value + (step - T::one())) / step * step
-}
-
-fn integer_floor<T: num_traits::PrimInt>(value: T, step: T) -> T {
-    value / step * step
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_option_length_count() {
-        let aligned_option = BlockOption::new(0x1, "ABCDEFGH".to_owned().into_bytes());
-        assert_eq!(aligned_option.byte_size(), aligned_option.into_le_bytes().unwrap().len());
-        let unaligned_option = BlockOption::new(0x1, "ABCDEF".to_owned().into_bytes());
-        assert_eq!(unaligned_option.byte_size(), unaligned_option.into_le_bytes().unwrap().len());
-    }
-
-    #[test]
-    fn test_padded_enhanced_packet_build() {
-        let uci_packet: Vec<u8> = vec![0x41, 0x03, 0x00, 0x02, 0x00, 0x00];
-        let timestamp: u64 = 0x0102_0304_0506_0708;
-        let interface_id: u32 = 0;
-        let enhanced_packet_block = EnhancedPacketBlockBuilder::new()
-            .interface_id(interface_id)
-            .timestamp(timestamp)
-            .packet(uci_packet)
-            .into_le_bytes()
-            .unwrap();
-
-        let expected_block: Vec<u8> = vec![
-            0x06, 0x00, 0x00, 0x00, // block type
-            // packet is of length 6, padded to 8, with total length 40=0x28
-            0x28, 0x00, 0x00, 0x00, // block length
-            0x00, 0x00, 0x00, 0x00, // interface id
-            0x04, 0x03, 0x02, 0x01, // timestamp high
-            0x08, 0x07, 0x06, 0x05, // timestemp low
-            0x06, 0x00, 0x00, 0x00, // captured length
-            0x06, 0x00, 0x00, 0x00, // original length
-            0x41, 0x03, 0x00, 0x02, // packet (padded)
-            0x00, 0x00, 0x00, 0x00, // packet (padded)
-            0x28, 0x00, 0x00, 0x00, // block length
-        ];
-        assert_eq!(&enhanced_packet_block, &expected_block);
-    }
-
-    #[test]
-    fn test_aligned_enhanced_packet_build() {
-        let uci_packet: Vec<u8> = vec![0x41, 0x03, 0x00, 0x04, 0x01, 0x01, 0x01, 0x00];
-        let timestamp: u64 = 0x0102_0304_0506_0708;
-        let interface_id: u32 = 0;
-        let enhanced_packet_block = EnhancedPacketBlockBuilder::new()
-            .interface_id(interface_id)
-            .timestamp(timestamp)
-            .packet(uci_packet)
-            .into_le_bytes()
-            .unwrap();
-
-        let expected_block: Vec<u8> = vec![
-            0x06, 0x00, 0x00, 0x00, // block type
-            // packet is of length 6, padded to 8, with total length 40=0x28
-            0x28, 0x00, 0x00, 0x00, // block length
-            0x00, 0x00, 0x00, 0x00, // interface id
-            0x04, 0x03, 0x02, 0x01, // timestamp high
-            0x08, 0x07, 0x06, 0x05, // timestemp low
-            0x08, 0x00, 0x00, 0x00, // captured length
-            0x08, 0x00, 0x00, 0x00, // original length
-            0x41, 0x03, 0x00, 0x04, // packet (aligned)
-            0x01, 0x01, 0x01, 0x00, // packet (aligned)
-            0x28, 0x00, 0x00, 0x00, // block length
-        ];
-        assert_eq!(&enhanced_packet_block, &expected_block);
-    }
-    #[test]
-    fn test_truncated_enhanced_packet_build() {
-        let uci_packet: Vec<u8> = vec![0x41, 0x03, 0x00, 0x02, 0x00, 0x00];
-        let timestamp: u64 = 0x0102_0304_0506_0708;
-        let interface_id: u32 = 0;
-        let enhanced_packet_block = EnhancedPacketBlockBuilder::new()
-            .interface_id(interface_id)
-            .timestamp(timestamp)
-            .packet(uci_packet)
-            .max_block_size(0x24)
-            .into_le_bytes()
-            .unwrap();
-
-        let expected_block: Vec<u8> = vec![
-            0x06, 0x00, 0x00, 0x00, // block type
-            // packet is of length 6, truncated to 4, with total length 36=0x24
-            0x24, 0x00, 0x00, 0x00, // block length
-            0x00, 0x00, 0x00, 0x00, // interface id
-            0x04, 0x03, 0x02, 0x01, // timestamp high
-            0x08, 0x07, 0x06, 0x05, // timestemp low
-            0x04, 0x00, 0x00, 0x00, // captured length
-            0x06, 0x00, 0x00, 0x00, // original length
-            0x41, 0x03, 0x00, 0x02, // packet (truncated)
-            0x24, 0x00, 0x00, 0x00, // block length
-        ];
-        assert_eq!(&enhanced_packet_block, &expected_block);
-    }
-
-    #[test]
-    fn test_interface_description_block_with_options_build() {
-        let comment_opt = BlockOption::new(0x1, "ABCDEF".to_owned().into_bytes());
-        let link_type: u16 = 299; // 0x12b
-        let snap_len: u32 = 0;
-        let interface_description_block = InterfaceDescriptionBlockBuilder::new()
-            .link_type(link_type)
-            .snap_len(snap_len)
-            .append_option(comment_opt)
-            .into_le_bytes()
-            .unwrap();
-        let expected_block: Vec<u8> = vec![
-            0x01, 0x00, 0x00, 0x00, // block type
-            0x24, 0x00, 0x00, 0x00, // block length
-            0x2b, 0x01, 0x00, 0x00, // link type, reserved
-            0x00, 0x00, 0x00, 0x00, // SnapLen
-            0x01, 0x00, 0x06, 0x00, // option code, padded length
-            0x41, 0x42, 0x43, 0x44, // option (ABCD)
-            0x45, 0x46, 0x00, 0x00, // option (EF)
-            0x00, 0x00, 0x00, 0x00, // option code, padded length (opt_endofopt)
-            0x24, 0x00, 0x00, 0x00, // block length
-        ];
-        assert_eq!(&interface_description_block, &expected_block);
-    }
-}
diff --git a/src/rust/uwb_core/src/uci/pcapng_uci_logger_factory.rs b/src/rust/uwb_core/src/uci/pcapng_uci_logger_factory.rs
deleted file mode 100644
index 9bcadf3..0000000
--- a/src/rust/uwb_core/src/uci/pcapng_uci_logger_factory.rs
+++ /dev/null
@@ -1,749 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, item 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This file defines PcapngUciLoggerFactory, which implements UciLoggerFactory
-//! trait and logging UCI packets into PCAPNG format.
-
-use std::fs;
-use std::io::Write;
-use std::path::{Path, PathBuf};
-
-use log::{debug, error};
-use tokio::runtime::Handle;
-use tokio::sync::mpsc;
-
-use crate::uci::pcapng_block::{
-    BlockBuilder, BlockOption, HeaderBlockBuilder, InterfaceDescriptionBlockBuilder,
-};
-use crate::uci::uci_logger_factory::UciLoggerFactory;
-use crate::uci::uci_logger_pcapng::UciLoggerPcapng;
-use crate::utils::consuming_builder_field;
-
-const DEFAULT_LOG_DIR: &str = "/var/log/uwb";
-const DEFAULT_FILE_PREFIX: &str = "uwb_uci";
-const DEFAULT_BUFFER_SIZE: usize = 10240; // 10 KB
-const DEFAUL_FILE_SIZE: usize = 1048576; // 1 MB
-
-/// The PCAPNG log file factory.
-pub struct PcapngUciLoggerFactory {
-    /// log_writer references to LogWriterActor.
-    log_writer: LogWriter,
-    /// Maps recording chip-id to interface-id for UciLoggerPcapng.
-    ///
-    /// Map is forwarded LogWriterActor, the "actor" that log_writer owns which performs
-    /// actual writing of files which needs this map to build the InterfaceDescriptionBlock.
-    /// Since PCAPNG format defines the interface ID by the order of appearance of IDB inside file,
-    /// the "map" is a vector whose index coincides with the interface ID.
-    chip_interface_id_map: Vec<String>,
-}
-
-impl UciLoggerFactory for PcapngUciLoggerFactory {
-    type Logger = UciLoggerPcapng;
-
-    /// PcapngUciLoggerFactory builds UciLoggerPcapng.
-    fn build_logger(&mut self, chip_id: &str) -> Option<UciLoggerPcapng> {
-        let chip_interface_id = match self.chip_interface_id_map.iter().position(|c| c == chip_id) {
-            Some(id) => id as u32,
-            None => {
-                let id = self.chip_interface_id_map.len() as u32;
-                self.chip_interface_id_map.push(chip_id.to_owned());
-                if self.log_writer.send_chip(chip_id.to_owned(), id).is_none() {
-                    error!("UCI log: associated LogWriterActor is dead");
-                    return None;
-                }
-                id
-            }
-        };
-        Some(UciLoggerPcapng::new(self.log_writer.clone(), chip_interface_id))
-    }
-}
-
-/// Builder for PCAPNG log file factory.
-pub struct PcapngUciLoggerFactoryBuilder {
-    /// Buffer size.
-    buffer_size: usize,
-    /// Max file size:
-    file_size: usize,
-    /// Filename prefix for log file.
-    filename_prefix: String,
-    /// Directory for log file.
-    log_path: PathBuf,
-    /// Range for the rotating index of log files.
-    rotate_range: usize,
-    /// Tokio Runtime Handle for driving Log.
-    runtime_handle: Option<Handle>,
-}
-impl Default for PcapngUciLoggerFactoryBuilder {
-    fn default() -> Self {
-        Self {
-            buffer_size: DEFAULT_BUFFER_SIZE,
-            file_size: DEFAUL_FILE_SIZE,
-            filename_prefix: DEFAULT_FILE_PREFIX.to_owned(),
-            log_path: PathBuf::from(DEFAULT_LOG_DIR),
-            rotate_range: 8,
-            runtime_handle: None,
-        }
-    }
-}
-
-impl PcapngUciLoggerFactoryBuilder {
-    /// Constructor.
-    pub fn new() -> Self {
-        PcapngUciLoggerFactoryBuilder::default()
-    }
-
-    // Setter methods of each field.
-    consuming_builder_field!(runtime_handle, Handle, Some);
-    consuming_builder_field!(filename_prefix, String);
-    consuming_builder_field!(rotate_range, usize);
-    consuming_builder_field!(log_path, PathBuf);
-    consuming_builder_field!(buffer_size, usize);
-    consuming_builder_field!(file_size, usize);
-
-    /// Builds PcapngUciLoggerFactory
-    pub fn build(self) -> Option<PcapngUciLoggerFactory> {
-        let file_factory = FileFactory::new(
-            self.log_path,
-            self.filename_prefix,
-            self.buffer_size,
-            self.rotate_range,
-        );
-        let log_writer = LogWriter::new(file_factory, self.file_size, self.runtime_handle?)?;
-        let manager = PcapngUciLoggerFactory { log_writer, chip_interface_id_map: Vec::new() };
-        Some(manager)
-    }
-}
-
-#[derive(Clone, Debug)]
-pub(crate) enum PcapngLoggerMessage {
-    ByteStream(Vec<u8>),
-    NewChip((String, u32)),
-    Flush(mpsc::UnboundedSender<bool>),
-}
-
-/// LogWriterActor performs the log writing and file operations asynchronously.
-struct LogWriterActor {
-    /// Maps chip id to interface id. The content follows the content of the component in
-    /// PcapngUciLoggerFactory with the same name.
-    chip_interface_id_map: Vec<String>,
-    current_file: Option<BufferedFile>,
-    file_factory: FileFactory,
-    file_size_limit: usize,
-    log_receiver: mpsc::UnboundedReceiver<PcapngLoggerMessage>,
-}
-
-impl LogWriterActor {
-    /// write data to file.
-    fn write_once(&mut self, data: Vec<u8>) -> Option<()> {
-        // Create new file if the file is not created, or does not fit incoming data:
-        if self.current_file.is_none()
-            || data.len() + self.current_file.as_ref().unwrap().file_size() > self.file_size_limit
-        {
-            self.current_file = Some(
-                self.file_factory
-                    .build_file_with_metadata(&self.chip_interface_id_map, self.file_size_limit)?,
-            );
-        }
-        self.current_file.as_mut().unwrap().buffered_write(data)
-    }
-
-    /// Handle single new chip: stores chip in chip_interface_id_map and:
-    ///
-    /// a. Nothing extra if current_file is not created yet.
-    /// b. If current file exists:
-    ///    Insert IDB in current file if it fits, otherwise switch to new file.
-    fn handle_new_chip(&mut self, chip_id: String, interface_id: u32) -> Option<()> {
-        if self.chip_interface_id_map.contains(&chip_id)
-            || self.chip_interface_id_map.len() as u32 != interface_id
-        {
-            error!(
-                "UCI log: unexpected chip_id {} with associated interface id {}",
-                &chip_id, interface_id
-            );
-            return None;
-        }
-        self.chip_interface_id_map.push(chip_id.clone());
-
-        if let Some(current_file) = &mut self.current_file {
-            let idb_data = into_interface_description_block(chip_id)?;
-            if idb_data.len() + current_file.file_size() <= self.file_size_limit {
-                current_file.buffered_write(idb_data)?;
-            } else {
-                self.current_file =
-                    Some(self.file_factory.build_file_with_metadata(
-                        &self.chip_interface_id_map,
-                        self.file_size_limit,
-                    )?);
-            }
-        }
-        Some(())
-    }
-
-    async fn run(&mut self) {
-        debug!("UCI log: LogWriterActor started");
-        loop {
-            match self.log_receiver.recv().await {
-                Some(PcapngLoggerMessage::NewChip((chip_id, interface_id))) => {
-                    if self.handle_new_chip(chip_id.clone(), interface_id).is_none() {
-                        error!("UCI log: failed logging new chip {}", &chip_id);
-                        break;
-                    }
-                }
-                Some(PcapngLoggerMessage::ByteStream(data)) => {
-                    if self.write_once(data).is_none() {
-                        match &self.current_file {
-                            Some(current_file) => {
-                                error!(
-                                    "UCI log: failed writting packet to log file {:?}",
-                                    current_file.file
-                                );
-                            }
-                            None => {
-                                error!("UCI log: failed writting packet to log file: no log file.");
-                            }
-                        }
-                        break;
-                    }
-                }
-                Some(PcapngLoggerMessage::Flush(flush_sender)) => {
-                    if self.current_file.is_some() {
-                        match self.current_file.as_mut().unwrap().flush_file() {
-                            Some(_) => {
-                                let _ = flush_sender.send(true);
-                            }
-                            None => {
-                                error!("UCI log: failed flushing the file");
-                                let _ = flush_sender.send(false);
-                            }
-                        }
-                    } else {
-                        error!("UCI log: current_file not present");
-                        let _ = flush_sender.send(false);
-                    }
-                }
-                None => {
-                    debug!("UCI log: LogWriterActor dropping.");
-                    break;
-                }
-            }
-        }
-    }
-}
-
-/// Handle to LogWriterActor.
-#[derive(Clone)]
-pub(crate) struct LogWriter {
-    log_sender: Option<mpsc::UnboundedSender<PcapngLoggerMessage>>,
-}
-
-impl LogWriter {
-    /// Constructs LogWriter and its actor.
-    ///
-    /// runtime_handle must be a Handle to a multithread runtime that outlives LogWriterActor
-    fn new(
-        file_factory: FileFactory,
-        file_size_limit: usize,
-        runtime_handle: Handle,
-    ) -> Option<Self> {
-        let chip_interface_id_map = Vec::new();
-        let (log_sender, log_receiver) = mpsc::unbounded_channel();
-        let mut log_writer_actor = LogWriterActor {
-            chip_interface_id_map,
-            current_file: None,
-            file_factory,
-            file_size_limit,
-            log_receiver,
-        };
-        runtime_handle.spawn(async move { log_writer_actor.run().await });
-        Some(LogWriter { log_sender: Some(log_sender) })
-    }
-
-    pub fn send_bytes(&mut self, bytes: Vec<u8>) -> Option<()> {
-        let log_sender = self.log_sender.as_ref()?;
-        match log_sender.send(PcapngLoggerMessage::ByteStream(bytes)) {
-            Ok(_) => Some(()),
-            Err(e) => {
-                error!("UCI log: LogWriterActor dead unexpectedly, sender error: {:?}", e);
-                self.log_sender = None;
-                None
-            }
-        }
-    }
-
-    pub fn flush(&mut self) -> Option<mpsc::UnboundedReceiver<bool>> {
-        let log_sender = self.log_sender.as_ref()?;
-        let (flush_sender, flush_receiver) = mpsc::unbounded_channel();
-        match log_sender.send(PcapngLoggerMessage::Flush(flush_sender)) {
-            Ok(_) => Some(flush_receiver),
-            Err(e) => {
-                error!("UCI log: LogWriterActor dead unexpectedly, sender error: {:?}", e);
-                self.log_sender = None;
-                None
-            }
-        }
-    }
-
-    fn send_chip(&mut self, chip_id: String, interface_id: u32) -> Option<()> {
-        let log_sender = self.log_sender.as_ref()?;
-        match log_sender.send(PcapngLoggerMessage::NewChip((chip_id, interface_id))) {
-            Ok(_) => Some(()),
-            Err(e) => {
-                error!("UCI log: LogWriterActor dead unexpectedly, sender error: {:?}", e);
-                self.log_sender = None;
-                None
-            }
-        }
-    }
-}
-
-fn into_interface_description_block(chip_id: String) -> Option<Vec<u8>> {
-    let if_name_option = BlockOption::new(0x2, chip_id.into_bytes());
-    InterfaceDescriptionBlockBuilder::new().append_option(if_name_option).into_le_bytes()
-}
-
-/// FileFactory builds next BufferedFile.
-///
-/// The most recent log file is {fileprefix}.pcapng. The archived log files have their index
-/// increased: {fileprefix}_{n}.pcapng where n = 0..(rotate_range-1).
-struct FileFactory {
-    log_directory: PathBuf,
-    filename_prefix: String,
-    rotate_range: usize,
-    buffer_size: usize,
-}
-
-impl FileFactory {
-    /// Constructor.
-    fn new(
-        log_directory: PathBuf,
-        filename_prefix: String,
-        buffer_size: usize,
-        rotate_range: usize,
-    ) -> FileFactory {
-        Self { log_directory, filename_prefix, rotate_range, buffer_size }
-    }
-
-    /// Builds pcapng file from a file factory, and prepares it with necessary header and metadata.
-    fn build_file_with_metadata(
-        &mut self,
-        chip_interface_id_map: &[String],
-        file_size_limit: usize,
-    ) -> Option<BufferedFile> {
-        let mut current_file = self.build_empty_file()?;
-        let mut metadata = Vec::new();
-        metadata.append(&mut HeaderBlockBuilder::new().into_le_bytes()?);
-        for chip_id in chip_interface_id_map.iter() {
-            metadata.append(&mut into_interface_description_block(chip_id.to_owned())?);
-        }
-        if metadata.len() > file_size_limit {
-            error!(
-                "UCI log: log file size limit is too small ({}) for file header and metadata ({})",
-                file_size_limit,
-                metadata.len()
-            );
-        }
-        current_file.buffered_write(metadata)?;
-        Some(current_file)
-    }
-
-    /// Builds next file as an empty BufferedFile.
-    fn build_empty_file(&mut self) -> Option<BufferedFile> {
-        self.rotate_file()?;
-        let file_path = self.get_file_path(0);
-        BufferedFile::new(&self.log_directory, &file_path, self.buffer_size)
-    }
-
-    /// get file path for log files of given index.
-    fn get_file_path(&self, index: usize) -> PathBuf {
-        let file_basename = if index == 0 {
-            format!("{}.pcapng", self.filename_prefix)
-        } else {
-            format!("{}_{}.pcapng", self.filename_prefix, index)
-        };
-        self.log_directory.join(file_basename)
-    }
-
-    /// Vacates {filename_prefix}_0.pcapng for new log.
-    fn rotate_file(&self) -> Option<()> {
-        for source_idx in (0..self.rotate_range - 1).rev() {
-            let target_idx = source_idx + 1;
-            let source_path = self.get_file_path(source_idx);
-            let target_path = self.get_file_path(target_idx);
-            if source_path.is_dir() {
-                error!("UCI log: expect {:?} to be a filename, but is a directory", &source_path);
-                return None;
-            }
-            if source_path.is_file() && fs::rename(&source_path, &target_path).is_err() {
-                error!(
-                    "UCI log: failed to rename {} to {} while rotating log file.",
-                    source_path.display(),
-                    target_path.display(),
-                );
-                return None;
-            }
-        }
-        Some(())
-    }
-}
-
-struct BufferedFile {
-    file: fs::File,
-    written_size: usize,
-    buffer_size: usize,
-    buffer: Vec<u8>,
-}
-
-impl BufferedFile {
-    /// Constructor.
-    pub fn new(log_dir: &Path, file_path: &Path, buffer_size: usize) -> Option<Self> {
-        if file_path.is_file() {
-            if let Err(e) = fs::remove_file(file_path) {
-                error!("UCI Log: failed to remove {}: {:?}", file_path.display(), e);
-            };
-        }
-        if !log_dir.is_dir() {
-            if let Err(e) = fs::create_dir_all(log_dir) {
-                error!(
-                    "UCI Log: failed to create log directory {}. Error: {:?}",
-                    log_dir.display(),
-                    e
-                );
-            }
-        }
-
-        let file = match fs::OpenOptions::new().write(true).create_new(true).open(file_path) {
-            Ok(f) => f,
-            Err(e) => {
-                error!(
-                    "UCI Log: failed to create log file {} for write: {:?}",
-                    file_path.display(),
-                    e
-                );
-                return None;
-            }
-        };
-        Some(Self { file, written_size: 0, buffer_size, buffer: Vec::new() })
-    }
-
-    /// Returns the file size received.
-    pub fn file_size(&self) -> usize {
-        self.written_size + self.buffer.len()
-    }
-
-    /// Writes data to file with buffering.
-    pub fn buffered_write(&mut self, mut data: Vec<u8>) -> Option<()> {
-        if self.buffer.len() + data.len() >= self.buffer_size {
-            self.flush_buffer();
-        }
-        self.buffer.append(&mut data);
-        Some(())
-    }
-
-    /// Clears buffer.
-    fn flush_buffer(&mut self) -> Option<()> {
-        self.file.write_all(&self.buffer).ok()?;
-        self.written_size += self.buffer.len();
-        self.buffer.clear();
-
-        self.file.flush().ok()
-    }
-
-    pub fn flush_file(&mut self) -> Option<()> {
-        // Flush the buffer and then the file to storage.
-        self.flush_buffer();
-        self.file.sync_all().ok();
-        Some(())
-    }
-}
-
-/// Manual Drop implementation.
-impl Drop for BufferedFile {
-    fn drop(&mut self) {
-        // Flush buffer before Closing file.
-        self.flush_buffer();
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    use std::fs;
-
-    use tempfile::tempdir;
-    use tokio::runtime::Builder;
-    use uwb_uci_packets::UciVendor_A_NotificationBuilder;
-
-    use crate::uci::uci_logger::UciLogger;
-
-    /// Gets block info from a little-endian PCAPNG file bytestream.
-    ///
-    /// Returns a vector of (block type, block length) if the bytestream is valid PCAPNG.
-    fn get_block_info(datastream: Vec<u8>) -> Option<Vec<(u32, u32)>> {
-        if datastream.len() % 4 != 0 || datastream.is_empty() {
-            return None;
-        }
-        let mut block_info = Vec::new();
-        let mut offset = 0usize;
-        while offset < datastream.len() - 1 {
-            let (_read, unread) = datastream.split_at(offset);
-            if unread.len() < 8 {
-                return None;
-            }
-            let (type_bytes, unread) = unread.split_at(4);
-            let block_type = u32::from_le_bytes(type_bytes.try_into().unwrap());
-            let (length_bytes, _unread) = unread.split_at(4);
-            let block_length = u32::from_le_bytes(length_bytes.try_into().unwrap());
-            offset += block_length as usize;
-            if offset > datastream.len() {
-                return None;
-            }
-            block_info.push((block_type, block_length));
-        }
-        Some(block_info)
-    }
-
-    async fn flush_loggers(loggers: Vec<UciLoggerPcapng>) {
-        for mut logger in loggers {
-            let flush_receiver = logger.flush();
-            flush_receiver.unwrap().recv().await;
-        }
-    }
-
-    #[test]
-    fn test_no_file_write() {
-        let dir = tempdir().unwrap();
-
-        let runtime = Builder::new_multi_thread().enable_all().build().unwrap();
-        let mut file_manager = PcapngUciLoggerFactoryBuilder::new()
-            .buffer_size(1024)
-            .filename_prefix("log".to_owned())
-            .log_path(dir.as_ref().to_owned())
-            .runtime_handle(runtime.handle().to_owned())
-            .build()
-            .unwrap();
-        let logger_0 = file_manager.build_logger("logger 0").unwrap();
-        let logger_1 = file_manager.build_logger("logger 1").unwrap();
-
-        // Flush the loggers so that the files are created.
-        runtime.block_on(flush_loggers(vec![logger_0, logger_1]));
-
-        // Expect no log file created as no packet is received.
-        let log_path = dir.as_ref().to_owned().join("log.pcapng");
-        assert!(fs::read(log_path).is_err());
-    }
-
-    #[test]
-    fn test_no_preexisting_dir_created() {
-        let dir_root = Path::new("./uwb_test_dir_123");
-        let dir = dir_root.join("this/path/doesnt/exist");
-        let log_path = dir.join("log.pcapng");
-
-        let runtime = Builder::new_multi_thread().enable_all().build().unwrap();
-        let mut file_manager = PcapngUciLoggerFactoryBuilder::new()
-            .buffer_size(1024)
-            .filename_prefix("log".to_owned())
-            .log_path(dir.clone())
-            .runtime_handle(runtime.handle().to_owned())
-            .build()
-            .unwrap();
-        let mut logger_0 = file_manager.build_logger("logger 0").unwrap();
-        let packet_0 = UciVendor_A_NotificationBuilder { opcode: 0, payload: None }.build();
-        logger_0.log_uci_control_packet(packet_0.into());
-
-        // Flush all the loggers so that the files are created and all packets written.
-        runtime.block_on(flush_loggers(vec![logger_0]));
-
-        // Expect the dir was created.
-        assert!(dir.is_dir());
-        // Expect the log file exists.
-        assert!(log_path.is_file());
-        // Clear test dir
-        let _ = fs::remove_dir_all(dir_root);
-    }
-
-    #[test]
-    fn test_single_file_write() {
-        let dir = tempdir().unwrap();
-        let runtime = Builder::new_multi_thread().enable_all().build().unwrap();
-        let mut file_manager = PcapngUciLoggerFactoryBuilder::new()
-            .buffer_size(1024)
-            .filename_prefix("log".to_owned())
-            .log_path(dir.as_ref().to_owned())
-            .runtime_handle(runtime.handle().to_owned())
-            .build()
-            .unwrap();
-        let mut logger_0 = file_manager.build_logger("logger 0").unwrap();
-        let packet_0 = UciVendor_A_NotificationBuilder { opcode: 0, payload: None }.build();
-        logger_0.log_uci_control_packet(packet_0.into());
-        let mut logger_1 = file_manager.build_logger("logger 1").unwrap();
-        let packet_1 = UciVendor_A_NotificationBuilder { opcode: 1, payload: None }.build();
-        logger_1.log_uci_control_packet(packet_1.into());
-        let packet_2 = UciVendor_A_NotificationBuilder { opcode: 2, payload: None }.build();
-        logger_0.log_uci_control_packet(packet_2.into());
-
-        // Flush all the loggers so that the files are created and all packets written.
-        runtime.block_on(flush_loggers(vec![logger_0, logger_1]));
-
-        // Expect file log.pcapng consist of SHB->IDB(logger 0)->EPB(packet 0)->IDB(logger 1)
-        // ->EPB(packet 1)->EPB(packet 2)
-        let log_path = dir.as_ref().to_owned().join("log.pcapng");
-        assert!(log_path.is_file());
-        let log_content = fs::read(log_path).unwrap();
-        let block_info = get_block_info(log_content).unwrap();
-        assert_eq!(block_info.len(), 6);
-        assert_eq!(block_info[0].0, 0x0A0D_0D0A); // SHB
-        assert_eq!(block_info[1].0, 0x1); // IDB
-        assert_eq!(block_info[2].0, 0x6); // EPB
-        assert_eq!(block_info[3].0, 0x1); // IDB
-        assert_eq!(block_info[4].0, 0x6); // EPB
-        assert_eq!(block_info[5].0, 0x6); // EPB
-    }
-
-    #[test]
-    fn test_file_switch_epb_unfit_case() {
-        let dir = tempdir().unwrap();
-        let runtime = Builder::new_multi_thread().enable_all().build().unwrap();
-        let mut file_manager_140 = PcapngUciLoggerFactoryBuilder::new()
-            .buffer_size(1024)
-            .filename_prefix("log".to_owned())
-            .log_path(dir.as_ref().to_owned())
-            .file_size(140)
-            .runtime_handle(runtime.handle().to_owned())
-            .build()
-            .unwrap();
-        let mut logger_0 = file_manager_140.build_logger("logger 0").unwrap();
-        let packet_0 = UciVendor_A_NotificationBuilder { opcode: 0, payload: None }.build();
-        logger_0.log_uci_control_packet(packet_0.into());
-        let mut logger_1 = file_manager_140.build_logger("logger 1").unwrap();
-        let packet_1 = UciVendor_A_NotificationBuilder { opcode: 1, payload: None }.build();
-        logger_1.log_uci_control_packet(packet_1.into());
-        let packet_2 = UciVendor_A_NotificationBuilder { opcode: 2, payload: None }.build();
-        logger_0.log_uci_control_packet(packet_2.into());
-
-        // Flush all the loggers so that the files are created and all packets written.
-        runtime.block_on(flush_loggers(vec![logger_0, logger_1]));
-
-        // Expect (Old to new):
-        // File 2: SHB->IDB->EPB->IDB (cannot fit next)
-        // File 1: SHB->IDB->IDB->EPB (cannot fit next)
-        // File 0: SHB->IDB->IDB->EPB
-        let log_path = dir.as_ref().to_owned().join("log_2.pcapng");
-        assert!(log_path.is_file());
-        let log_content = fs::read(log_path).unwrap();
-        let block_info = get_block_info(log_content).unwrap();
-        assert_eq!(block_info.len(), 4);
-        assert_eq!(block_info[0].0, 0x0A0D_0D0A); // SHB
-        assert_eq!(block_info[1].0, 0x1); // IDB
-        assert_eq!(block_info[2].0, 0x6); // EPB
-        assert_eq!(block_info[3].0, 0x1); // IDB
-        let log_path = dir.as_ref().to_owned().join("log_1.pcapng");
-        assert!(log_path.is_file());
-        let log_content = fs::read(log_path).unwrap();
-        let block_info = get_block_info(log_content).unwrap();
-        assert_eq!(block_info.len(), 4);
-        assert_eq!(block_info[0].0, 0x0A0D_0D0A); // SHB
-        assert_eq!(block_info[1].0, 0x1); // IDB
-        assert_eq!(block_info[2].0, 0x1); // IDB
-        assert_eq!(block_info[3].0, 0x6); // EPB
-        let log_path = dir.as_ref().to_owned().join("log.pcapng");
-        assert!(log_path.is_file());
-        let log_content = fs::read(log_path).unwrap();
-        let block_info = get_block_info(log_content).unwrap();
-        assert_eq!(block_info.len(), 4);
-        assert_eq!(block_info[0].0, 0x0A0D_0D0A); // SHB
-        assert_eq!(block_info[1].0, 0x1); // IDB
-        assert_eq!(block_info[2].0, 0x1); // IDB
-        assert_eq!(block_info[3].0, 0x6); // EPB
-    }
-
-    #[test]
-    fn test_file_switch_idb_unfit_case() {
-        let dir = tempdir().unwrap();
-        let runtime = Builder::new_multi_thread().enable_all().build().unwrap();
-        let mut file_manager_144 = PcapngUciLoggerFactoryBuilder::new()
-            .buffer_size(1024)
-            .filename_prefix("log".to_owned())
-            .log_path(dir.as_ref().to_owned())
-            .file_size(144)
-            .runtime_handle(runtime.handle().to_owned())
-            .build()
-            .unwrap();
-        let mut logger_0 = file_manager_144.build_logger("logger 0").unwrap();
-        let packet_0 = UciVendor_A_NotificationBuilder { opcode: 0, payload: None }.build();
-        logger_0.log_uci_control_packet(packet_0.into());
-        let packet_2 = UciVendor_A_NotificationBuilder { opcode: 2, payload: None }.build();
-        logger_0.log_uci_control_packet(packet_2.into());
-        let mut logger_1 = file_manager_144.build_logger("logger 1").unwrap();
-        let packet_1 = UciVendor_A_NotificationBuilder { opcode: 1, payload: None }.build();
-        logger_1.log_uci_control_packet(packet_1.into());
-
-        // Flush all the loggers so that the files are created and all packets written.
-        runtime.block_on(flush_loggers(vec![logger_0, logger_1]));
-
-        // Expect (Old to new):
-        // File 1: SHB->IDB->EPB->EPB (cannot fit next)
-        // File 0: SHB->IDB->IDB->EPB
-        let log_path = dir.as_ref().to_owned().join("log_1.pcapng");
-        assert!(log_path.is_file());
-        let log_content = fs::read(log_path).unwrap();
-        let block_info = get_block_info(log_content).unwrap();
-        assert_eq!(block_info.len(), 4);
-        assert_eq!(block_info[0].0, 0x0A0D_0D0A); // SHB
-        assert_eq!(block_info[1].0, 0x1); // IDB
-        assert_eq!(block_info[2].0, 0x6); // EPB
-        assert_eq!(block_info[3].0, 0x6); // EPB
-        let log_path = dir.as_ref().to_owned().join("log.pcapng");
-        assert!(log_path.is_file());
-        let log_content = fs::read(log_path).unwrap();
-        let block_info = get_block_info(log_content).unwrap();
-        assert_eq!(block_info.len(), 4);
-        assert_eq!(block_info[0].0, 0x0A0D_0D0A); // SHB
-        assert_eq!(block_info[1].0, 0x1); // IDB
-        assert_eq!(block_info[2].0, 0x1); // IDB
-        assert_eq!(block_info[3].0, 0x6); // EPB
-    }
-
-    // Program shall not panic even if log writing has failed for some reason.
-    #[test]
-    fn test_log_fail_safe() {
-        let dir = tempdir().unwrap();
-        let runtime = Builder::new_multi_thread().enable_all().build().unwrap();
-        let mut file_manager_96 = PcapngUciLoggerFactoryBuilder::new()
-            .buffer_size(1024)
-            .filename_prefix("log".to_owned())
-            .log_path(dir.as_ref().to_owned())
-            .file_size(96) // Fails logging, as metadata takes 100
-            .runtime_handle(runtime.handle().to_owned())
-            .build()
-            .unwrap();
-        let mut logger_0 = file_manager_96.build_logger("logger 0").unwrap();
-        let packet_0 = UciVendor_A_NotificationBuilder { opcode: 0, payload: None }.build();
-        logger_0.log_uci_control_packet(packet_0.into());
-        let packet_2 = UciVendor_A_NotificationBuilder { opcode: 2, payload: None }.build();
-        logger_0.log_uci_control_packet(packet_2.into());
-        let mut logger_1 = file_manager_96.build_logger("logger 1").unwrap();
-        let packet_1 = UciVendor_A_NotificationBuilder { opcode: 1, payload: None }.build();
-        logger_1.log_uci_control_packet(packet_1.into());
-
-        // Flush all the loggers so that the files are created and all packets written.
-        runtime.block_on(flush_loggers(vec![logger_0, logger_1]));
-
-        // Verify existence of the log files.
-        let log_path = dir.as_ref().to_owned().join("log_1.pcapng");
-        assert!(log_path.is_file());
-        let log_path = dir.as_ref().to_owned().join("log.pcapng");
-        assert!(log_path.is_file());
-    }
-}
diff --git a/src/rust/uwb_core/src/uci/response.rs b/src/rust/uwb_core/src/uci/response.rs
deleted file mode 100644
index df50c40..0000000
--- a/src/rust/uwb_core/src/uci/response.rs
+++ /dev/null
@@ -1,512 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::convert::{TryFrom, TryInto};
-
-use log::error;
-
-use crate::error::{Error, Result};
-use crate::params::uci_packets::{
-    AndroidRadarConfigResponse, AppConfigTlv, CapTlv, CoreSetConfigResponse, DeviceConfigTlv,
-    GetDeviceInfoResponse, PowerStats, RadarConfigTlv, RawUciMessage, RfTestConfigResponse,
-    SessionHandle, SessionState, SessionUpdateControllerMulticastListRspV1Payload,
-    SessionUpdateControllerMulticastListRspV2Payload, SessionUpdateControllerMulticastResponse,
-    SessionUpdateDtTagRangingRoundsResponse, SetAppConfigResponse, StatusCode, UCIMajorVersion,
-    UciControlPacket,
-};
-use crate::uci::error::status_code_to_result;
-
-#[derive(Debug, Clone, PartialEq)]
-pub(super) enum UciResponse {
-    SetLoggerMode,
-    SetNotification,
-    OpenHal,
-    CloseHal,
-    DeviceReset(Result<()>),
-    CoreGetDeviceInfo(Result<GetDeviceInfoResponse>),
-    CoreGetCapsInfo(Result<Vec<CapTlv>>),
-    CoreSetConfig(CoreSetConfigResponse),
-    CoreGetConfig(Result<Vec<DeviceConfigTlv>>),
-    CoreQueryTimeStamp(Result<u64>),
-    SessionInit(Result<Option<SessionHandle>>),
-    SessionDeinit(Result<()>),
-    SessionSetAppConfig(SetAppConfigResponse),
-    SessionGetAppConfig(Result<Vec<AppConfigTlv>>),
-    SessionGetCount(Result<u8>),
-    SessionGetState(Result<SessionState>),
-    SessionUpdateControllerMulticastList(Result<SessionUpdateControllerMulticastResponse>),
-    SessionUpdateDtTagRangingRounds(Result<SessionUpdateDtTagRangingRoundsResponse>),
-    SessionQueryMaxDataSize(Result<u16>),
-    SessionStart(Result<()>),
-    SessionStop(Result<()>),
-    SessionGetRangingCount(Result<usize>),
-    AndroidSetCountryCode(Result<()>),
-    AndroidGetPowerStats(Result<PowerStats>),
-    AndroidSetRadarConfig(AndroidRadarConfigResponse),
-    AndroidGetRadarConfig(Result<Vec<RadarConfigTlv>>),
-    RawUciCmd(Result<RawUciMessage>),
-    SendUciData(Result<()>),
-    SessionSetHybridControllerConfig(Result<()>),
-    SessionSetHybridControleeConfig(Result<()>),
-    SessionDataTransferPhaseConfig(Result<()>),
-    SessionSetRfTestConfig(RfTestConfigResponse),
-    RfTest(Result<()>),
-}
-
-impl UciResponse {
-    pub fn need_retry(&self) -> bool {
-        match self {
-            Self::SetNotification | Self::OpenHal | Self::CloseHal | Self::SetLoggerMode => false,
-            Self::DeviceReset(result) => Self::matches_result_retry(result),
-            Self::CoreGetDeviceInfo(result) => Self::matches_result_retry(result),
-            Self::CoreGetCapsInfo(result) => Self::matches_result_retry(result),
-            Self::CoreGetConfig(result) => Self::matches_result_retry(result),
-            Self::CoreQueryTimeStamp(result) => Self::matches_result_retry(result),
-            Self::SessionInit(result) => Self::matches_result_retry(result),
-            Self::SessionDeinit(result) => Self::matches_result_retry(result),
-            Self::SessionGetAppConfig(result) => Self::matches_result_retry(result),
-            Self::SessionGetCount(result) => Self::matches_result_retry(result),
-            Self::SessionGetState(result) => Self::matches_result_retry(result),
-            Self::SessionUpdateControllerMulticastList(result) => {
-                Self::matches_result_retry(result)
-            }
-            Self::SessionUpdateDtTagRangingRounds(result) => Self::matches_result_retry(result),
-            Self::SessionStart(result) => Self::matches_result_retry(result),
-            Self::SessionStop(result) => Self::matches_result_retry(result),
-            Self::SessionGetRangingCount(result) => Self::matches_result_retry(result),
-            Self::AndroidSetCountryCode(result) => Self::matches_result_retry(result),
-            Self::AndroidGetPowerStats(result) => Self::matches_result_retry(result),
-            Self::AndroidGetRadarConfig(result) => Self::matches_result_retry(result),
-            Self::AndroidSetRadarConfig(resp) => Self::matches_status_retry(&resp.status),
-            Self::RawUciCmd(result) => Self::matches_result_retry(result),
-            Self::SessionSetHybridControllerConfig(result) => Self::matches_result_retry(result),
-            Self::SessionSetHybridControleeConfig(result) => Self::matches_result_retry(result),
-            Self::SessionDataTransferPhaseConfig(result) => Self::matches_result_retry(result),
-            Self::CoreSetConfig(resp) => Self::matches_status_retry(&resp.status),
-            Self::SessionSetAppConfig(resp) => Self::matches_status_retry(&resp.status),
-
-            Self::SessionQueryMaxDataSize(result) => Self::matches_result_retry(result),
-            Self::SessionSetRfTestConfig(resp) => Self::matches_status_retry(&resp.status),
-            Self::RfTest(result) => Self::matches_result_retry(result),
-            // TODO(b/273376343): Implement retry logic for Data packet send.
-            Self::SendUciData(_result) => false,
-        }
-    }
-
-    fn matches_result_retry<T>(result: &Result<T>) -> bool {
-        matches!(result, Err(Error::CommandRetry))
-    }
-    fn matches_status_retry(status: &StatusCode) -> bool {
-        matches!(status, StatusCode::UciStatusCommandRetry)
-    }
-}
-
-impl TryFrom<(uwb_uci_packets::UciResponse, UCIMajorVersion, bool)> for UciResponse {
-    type Error = Error;
-    fn try_from(
-        pair: (uwb_uci_packets::UciResponse, UCIMajorVersion, bool),
-    ) -> std::result::Result<Self, Self::Error> {
-        let evt = pair.0;
-        let uci_fira_major_ver = pair.1;
-        let is_multicast_list_rsp_v2_supported = pair.2;
-        use uwb_uci_packets::UciResponseChild;
-        match evt.specialize() {
-            UciResponseChild::CoreResponse(evt) => evt.try_into(),
-            UciResponseChild::SessionConfigResponse(evt) => {
-                (evt, uci_fira_major_ver, is_multicast_list_rsp_v2_supported).try_into()
-            }
-            UciResponseChild::SessionControlResponse(evt) => evt.try_into(),
-            UciResponseChild::AndroidResponse(evt) => evt.try_into(),
-            UciResponseChild::TestResponse(evt) => evt.try_into(),
-            UciResponseChild::UciVendor_9_Response(evt) => raw_response(evt.into()),
-            UciResponseChild::UciVendor_A_Response(evt) => raw_response(evt.into()),
-            UciResponseChild::UciVendor_B_Response(evt) => raw_response(evt.into()),
-            UciResponseChild::UciVendor_E_Response(evt) => raw_response(evt.into()),
-            UciResponseChild::UciVendor_F_Response(evt) => raw_response(evt.into()),
-            _ => Err(Error::Unknown),
-        }
-    }
-}
-
-impl TryFrom<uwb_uci_packets::CoreResponse> for UciResponse {
-    type Error = Error;
-    fn try_from(evt: uwb_uci_packets::CoreResponse) -> std::result::Result<Self, Self::Error> {
-        use uwb_uci_packets::CoreResponseChild;
-        match evt.specialize() {
-            CoreResponseChild::GetDeviceInfoRsp(evt) => Ok(UciResponse::CoreGetDeviceInfo(
-                status_code_to_result(evt.get_status()).map(|_| GetDeviceInfoResponse {
-                    status: evt.get_status(),
-                    uci_version: evt.get_uci_version(),
-                    mac_version: evt.get_mac_version(),
-                    phy_version: evt.get_phy_version(),
-                    uci_test_version: evt.get_uci_test_version(),
-                    vendor_spec_info: evt.get_vendor_spec_info().clone(),
-                }),
-            )),
-            CoreResponseChild::GetCapsInfoRsp(evt) => Ok(UciResponse::CoreGetCapsInfo(
-                status_code_to_result(evt.get_status()).map(|_| evt.get_tlvs().clone()),
-            )),
-            CoreResponseChild::DeviceResetRsp(evt) => {
-                Ok(UciResponse::DeviceReset(status_code_to_result(evt.get_status())))
-            }
-            CoreResponseChild::SetConfigRsp(evt) => {
-                Ok(UciResponse::CoreSetConfig(CoreSetConfigResponse {
-                    status: evt.get_status(),
-                    config_status: evt.get_cfg_status().clone(),
-                }))
-            }
-
-            CoreResponseChild::GetConfigRsp(evt) => Ok(UciResponse::CoreGetConfig(
-                status_code_to_result(evt.get_status()).map(|_| evt.get_tlvs().clone()),
-            )),
-            CoreResponseChild::CoreQueryTimeStampRsp(evt) => Ok(UciResponse::CoreQueryTimeStamp(
-                status_code_to_result(evt.get_status()).map(|_| evt.get_timeStamp()),
-            )),
-            _ => Err(Error::Unknown),
-        }
-    }
-}
-
-impl TryFrom<(uwb_uci_packets::SessionConfigResponse, UCIMajorVersion, bool)> for UciResponse {
-    type Error = Error;
-    fn try_from(
-        pair: (uwb_uci_packets::SessionConfigResponse, UCIMajorVersion, bool),
-    ) -> std::result::Result<Self, Self::Error> {
-        use uwb_uci_packets::SessionConfigResponseChild;
-        let evt = pair.0;
-        let uci_fira_major_ver = pair.1;
-        let is_multicast_list_rsp_v2_supported = pair.2;
-        match evt.specialize() {
-            SessionConfigResponseChild::SessionInitRsp(evt) => {
-                Ok(UciResponse::SessionInit(status_code_to_result(evt.get_status()).map(|_| None)))
-            }
-            SessionConfigResponseChild::SessionInitRsp_V2(evt) => Ok(UciResponse::SessionInit(
-                status_code_to_result(evt.get_status()).map(|_| Some(evt.get_session_handle())),
-            )),
-            SessionConfigResponseChild::SessionDeinitRsp(evt) => {
-                Ok(UciResponse::SessionDeinit(status_code_to_result(evt.get_status())))
-            }
-            SessionConfigResponseChild::SessionGetCountRsp(evt) => {
-                Ok(UciResponse::SessionGetCount(
-                    status_code_to_result(evt.get_status()).map(|_| evt.get_session_count()),
-                ))
-            }
-            SessionConfigResponseChild::SessionGetStateRsp(evt) => {
-                Ok(UciResponse::SessionGetState(
-                    status_code_to_result(evt.get_status()).map(|_| evt.get_session_state()),
-                ))
-            }
-            SessionConfigResponseChild::SessionUpdateControllerMulticastListRsp(evt)
-                if uci_fira_major_ver == UCIMajorVersion::V1
-                    || !is_multicast_list_rsp_v2_supported =>
-            {
-                error!(
-                    "Tryfrom: SessionConfigResponse:: SessionUpdateControllerMulticastListRspV1 "
-                );
-                let payload = evt.get_payload();
-                let multicast_update_list_rsp_payload_v1 =
-                    SessionUpdateControllerMulticastListRspV1Payload::parse(payload).map_err(
-                        |e| {
-                            error!(
-                                "Failed to parse Multicast list rsp v1 {:?}, payload: {:?}",
-                                e, &payload
-                            );
-                            Error::BadParameters
-                        },
-                    )?;
-
-                Ok(UciResponse::SessionUpdateControllerMulticastList(Ok(
-                    SessionUpdateControllerMulticastResponse {
-                        status: multicast_update_list_rsp_payload_v1.status,
-                        status_list: vec![],
-                    },
-                )))
-            }
-            SessionConfigResponseChild::SessionUpdateControllerMulticastListRsp(evt)
-                if uci_fira_major_ver >= UCIMajorVersion::V2 =>
-            {
-                error!(
-                    "Tryfrom: SessionConfigResponse:: SessionUpdateControllerMulticastListRspV2 "
-                );
-                let payload = evt.get_payload();
-                let multicast_update_list_rsp_payload_v2 =
-                    SessionUpdateControllerMulticastListRspV2Payload::parse(payload).map_err(
-                        |e| {
-                            error!(
-                                "Failed to parse Multicast list rsp v2 {:?}, payload: {:?}",
-                                e, &payload
-                            );
-                            Error::BadParameters
-                        },
-                    )?;
-                Ok(UciResponse::SessionUpdateControllerMulticastList(Ok(
-                    SessionUpdateControllerMulticastResponse {
-                        status: multicast_update_list_rsp_payload_v2.status,
-                        status_list: multicast_update_list_rsp_payload_v2.controlee_status,
-                    },
-                )))
-            }
-            SessionConfigResponseChild::SessionUpdateDtTagRangingRoundsRsp(evt) => {
-                Ok(UciResponse::SessionUpdateDtTagRangingRounds(Ok(
-                    SessionUpdateDtTagRangingRoundsResponse {
-                        status: evt.get_status(),
-                        ranging_round_indexes: evt.get_ranging_round_indexes().to_vec(),
-                    },
-                )))
-            }
-            SessionConfigResponseChild::SessionSetAppConfigRsp(evt) => {
-                Ok(UciResponse::SessionSetAppConfig(SetAppConfigResponse {
-                    status: evt.get_status(),
-                    config_status: evt.get_cfg_status().clone(),
-                }))
-            }
-            SessionConfigResponseChild::SessionGetAppConfigRsp(evt) => {
-                Ok(UciResponse::SessionGetAppConfig(
-                    status_code_to_result(evt.get_status()).map(|_| {
-                        evt.get_tlvs().clone().into_iter().map(|tlv| tlv.into()).collect()
-                    }),
-                ))
-            }
-            SessionConfigResponseChild::SessionQueryMaxDataSizeRsp(evt) => {
-                Ok(UciResponse::SessionQueryMaxDataSize(
-                    status_code_to_result(evt.get_status()).map(|_| evt.get_max_data_size()),
-                ))
-            }
-            SessionConfigResponseChild::SessionSetHybridControllerConfigRsp(evt) => {
-                Ok(UciResponse::SessionSetHybridControllerConfig(status_code_to_result(
-                    evt.get_status(),
-                )))
-            }
-            SessionConfigResponseChild::SessionSetHybridControleeConfigRsp(evt) => {
-                Ok(UciResponse::SessionSetHybridControleeConfig(status_code_to_result(
-                    evt.get_status(),
-                )))
-            }
-            SessionConfigResponseChild::SessionDataTransferPhaseConfigRsp(evt) => {
-                Ok(UciResponse::SessionDataTransferPhaseConfig(status_code_to_result(
-                    evt.get_status(),
-                )))
-            }
-            _ => Err(Error::Unknown),
-        }
-    }
-}
-
-impl TryFrom<uwb_uci_packets::SessionControlResponse> for UciResponse {
-    type Error = Error;
-    fn try_from(
-        evt: uwb_uci_packets::SessionControlResponse,
-    ) -> std::result::Result<Self, Self::Error> {
-        use uwb_uci_packets::SessionControlResponseChild;
-        match evt.specialize() {
-            SessionControlResponseChild::SessionStartRsp(evt) => {
-                Ok(UciResponse::SessionStart(status_code_to_result(evt.get_status())))
-            }
-            SessionControlResponseChild::SessionStopRsp(evt) => {
-                Ok(UciResponse::SessionStop(status_code_to_result(evt.get_status())))
-            }
-            SessionControlResponseChild::SessionGetRangingCountRsp(evt) => {
-                Ok(UciResponse::SessionGetRangingCount(
-                    status_code_to_result(evt.get_status()).map(|_| evt.get_count() as usize),
-                ))
-            }
-            _ => Err(Error::Unknown),
-        }
-    }
-}
-
-impl TryFrom<uwb_uci_packets::AndroidResponse> for UciResponse {
-    type Error = Error;
-    fn try_from(evt: uwb_uci_packets::AndroidResponse) -> std::result::Result<Self, Self::Error> {
-        use uwb_uci_packets::AndroidResponseChild;
-        match evt.specialize() {
-            AndroidResponseChild::AndroidSetCountryCodeRsp(evt) => {
-                Ok(UciResponse::AndroidSetCountryCode(status_code_to_result(evt.get_status())))
-            }
-            AndroidResponseChild::AndroidGetPowerStatsRsp(evt) => {
-                Ok(UciResponse::AndroidGetPowerStats(
-                    status_code_to_result(evt.get_stats().status).map(|_| evt.get_stats().clone()),
-                ))
-            }
-            AndroidResponseChild::AndroidSetRadarConfigRsp(evt) => {
-                Ok(UciResponse::AndroidSetRadarConfig(AndroidRadarConfigResponse {
-                    status: evt.get_status(),
-                    config_status: evt.get_cfg_status().clone(),
-                }))
-            }
-            AndroidResponseChild::AndroidGetRadarConfigRsp(evt) => {
-                Ok(UciResponse::AndroidGetRadarConfig(
-                    status_code_to_result(evt.get_status()).map(|_| evt.get_tlvs().clone()),
-                ))
-            }
-            _ => Err(Error::Unknown),
-        }
-    }
-}
-
-impl TryFrom<uwb_uci_packets::TestResponse> for UciResponse {
-    type Error = Error;
-    fn try_from(evt: uwb_uci_packets::TestResponse) -> std::result::Result<Self, Self::Error> {
-        use uwb_uci_packets::TestResponseChild;
-        match evt.specialize() {
-            TestResponseChild::SessionSetRfTestConfigRsp(evt) => {
-                Ok(UciResponse::SessionSetRfTestConfig(RfTestConfigResponse {
-                    status: evt.get_status(),
-                    config_status: evt.get_cfg_status().clone(),
-                }))
-            }
-            TestResponseChild::TestPeriodicTxRsp(evt) => {
-                Ok(UciResponse::RfTest(status_code_to_result(evt.get_status())))
-            }
-            TestResponseChild::TestPerRxRsp(evt) => {
-                Ok(UciResponse::RfTest(status_code_to_result(evt.get_status())))
-            }
-            TestResponseChild::StopRfTestRsp(evt) => {
-                Ok(UciResponse::RfTest(status_code_to_result(evt.get_status())))
-            }
-            _ => Err(Error::Unknown),
-        }
-    }
-}
-
-fn raw_response(evt: uwb_uci_packets::UciResponse) -> Result<UciResponse> {
-    let gid: u32 = evt.get_group_id().into();
-    let oid: u32 = evt.get_opcode().into();
-    let packet: UciControlPacket = evt.into();
-    Ok(UciResponse::RawUciCmd(Ok(RawUciMessage { gid, oid, payload: packet.to_raw_payload() })))
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_uci_response_casting_from_uci_vendor_response_packet() {
-        let mut uci_vendor_rsp_packet = uwb_uci_packets::UciResponse::try_from(
-            uwb_uci_packets::UciVendor_9_ResponseBuilder {
-                opcode: 0x00,
-                payload: Some(vec![0x0, 0x1, 0x2, 0x3].into()),
-            }
-            .build(),
-        )
-        .unwrap();
-        let uci_fira_major_version = UCIMajorVersion::V1;
-        let mut uci_response = UciResponse::try_from((
-            uci_vendor_rsp_packet.clone(),
-            uci_fira_major_version.clone(),
-            false,
-        ))
-        .unwrap();
-        assert_eq!(
-            uci_response,
-            UciResponse::RawUciCmd(Ok(RawUciMessage {
-                gid: 0x9,
-                oid: 0x0,
-                payload: vec![0x0, 0x1, 0x2, 0x3],
-            }))
-        );
-
-        uci_vendor_rsp_packet = uwb_uci_packets::UciResponse::try_from(
-            uwb_uci_packets::UciVendor_A_ResponseBuilder {
-                opcode: 0x00,
-                payload: Some(vec![0x0, 0x1, 0x2, 0x3].into()),
-            }
-            .build(),
-        )
-        .unwrap();
-        uci_response = UciResponse::try_from((
-            uci_vendor_rsp_packet.clone(),
-            uci_fira_major_version.clone(),
-            false,
-        ))
-        .unwrap();
-        assert_eq!(
-            uci_response,
-            UciResponse::RawUciCmd(Ok(RawUciMessage {
-                gid: 0xA,
-                oid: 0x0,
-                payload: vec![0x0, 0x1, 0x2, 0x3],
-            }))
-        );
-
-        uci_vendor_rsp_packet = uwb_uci_packets::UciResponse::try_from(
-            uwb_uci_packets::UciVendor_B_ResponseBuilder {
-                opcode: 0x00,
-                payload: Some(vec![0x0, 0x1, 0x2, 0x3].into()),
-            }
-            .build(),
-        )
-        .unwrap();
-        uci_response = UciResponse::try_from((
-            uci_vendor_rsp_packet.clone(),
-            uci_fira_major_version.clone(),
-            false,
-        ))
-        .unwrap();
-        assert_eq!(
-            uci_response,
-            UciResponse::RawUciCmd(Ok(RawUciMessage {
-                gid: 0xB,
-                oid: 0x0,
-                payload: vec![0x0, 0x1, 0x2, 0x3],
-            }))
-        );
-
-        uci_vendor_rsp_packet = uwb_uci_packets::UciResponse::try_from(
-            uwb_uci_packets::UciVendor_E_ResponseBuilder {
-                opcode: 0x00,
-                payload: Some(vec![0x0, 0x1, 0x2, 0x3].into()),
-            }
-            .build(),
-        )
-        .unwrap();
-        uci_response = UciResponse::try_from((
-            uci_vendor_rsp_packet.clone(),
-            uci_fira_major_version.clone(),
-            false,
-        ))
-        .unwrap();
-        assert_eq!(
-            uci_response,
-            UciResponse::RawUciCmd(Ok(RawUciMessage {
-                gid: 0xE,
-                oid: 0x0,
-                payload: vec![0x0, 0x1, 0x2, 0x3],
-            }))
-        );
-
-        uci_vendor_rsp_packet = uwb_uci_packets::UciResponse::try_from(
-            uwb_uci_packets::UciVendor_F_ResponseBuilder {
-                opcode: 0x00,
-                payload: Some(vec![0x0, 0x1, 0x2, 0x3].into()),
-            }
-            .build(),
-        )
-        .unwrap();
-        uci_response = UciResponse::try_from((
-            uci_vendor_rsp_packet.clone(),
-            uci_fira_major_version.clone(),
-            false,
-        ))
-        .unwrap();
-        assert_eq!(
-            uci_response,
-            UciResponse::RawUciCmd(Ok(RawUciMessage {
-                gid: 0xF,
-                oid: 0x0,
-                payload: vec![0x0, 0x1, 0x2, 0x3],
-            }))
-        );
-    }
-}
diff --git a/src/rust/uwb_core/src/uci/timeout_uci_hal.rs b/src/rust/uwb_core/src/uci/timeout_uci_hal.rs
deleted file mode 100644
index 53c1bcb..0000000
--- a/src/rust/uwb_core/src/uci/timeout_uci_hal.rs
+++ /dev/null
@@ -1,126 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::future::Future;
-use std::time::Duration;
-
-use async_trait::async_trait;
-use tokio::sync::mpsc;
-use tokio::time::timeout;
-
-use crate::error::{Error, Result};
-use crate::params::uci_packets::SessionId;
-use crate::uci::command::UciCommand;
-use crate::uci::uci_hal::{UciHal, UciHalPacket};
-
-const HAL_API_TIMEOUT_MS: u64 = 1000;
-// TODO(b/279175027): Reduce this once vendor fixes their initialization sequence.
-const HAL_OPEN_TIMEOUT_MS: u64 = 20000; // Extra time may be needed for starting UWB stack.
-
-pub(crate) struct TimeoutUciHal<T: UciHal>(T);
-
-impl<T: UciHal> TimeoutUciHal<T> {
-    pub fn new(hal: T) -> Self {
-        Self(hal)
-    }
-
-    async fn call_with_timeout(
-        future: impl Future<Output = Result<()>>,
-        duration: u64,
-    ) -> Result<()> {
-        match timeout(Duration::from_millis(duration), future).await {
-            Ok(result) => result,
-            Err(_) => Err(Error::Timeout),
-        }
-    }
-}
-
-#[async_trait]
-impl<T: UciHal> UciHal for TimeoutUciHal<T> {
-    async fn open(&mut self, packet_sender: mpsc::UnboundedSender<UciHalPacket>) -> Result<()> {
-        Self::call_with_timeout(self.0.open(packet_sender), HAL_OPEN_TIMEOUT_MS).await
-    }
-
-    async fn close(&mut self) -> Result<()> {
-        Self::call_with_timeout(self.0.close(), HAL_API_TIMEOUT_MS).await
-    }
-
-    async fn notify_session_initialized(&mut self, session_id: SessionId) -> Result<()> {
-        Self::call_with_timeout(self.0.notify_session_initialized(session_id), HAL_API_TIMEOUT_MS)
-            .await
-    }
-
-    async fn send_command(&mut self, cmd: UciCommand) -> Result<()> {
-        Self::call_with_timeout(self.0.send_command(cmd), HAL_API_TIMEOUT_MS).await
-    }
-
-    async fn send_packet(&mut self, packet: UciHalPacket) -> Result<()> {
-        Self::call_with_timeout(self.0.send_packet(packet), HAL_API_TIMEOUT_MS).await
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    use std::matches;
-
-    use tokio::time::sleep;
-
-    use crate::utils::init_test_logging;
-
-    struct FakeUciHal;
-
-    #[async_trait]
-    impl UciHal for FakeUciHal {
-        async fn open(&mut self, _: mpsc::UnboundedSender<UciHalPacket>) -> Result<()> {
-            Ok(())
-        }
-        async fn close(&mut self) -> Result<()> {
-            Err(Error::Unknown)
-        }
-        async fn send_packet(&mut self, _: UciHalPacket) -> Result<()> {
-            sleep(Duration::MAX).await;
-            Ok(())
-        }
-    }
-
-    fn setup_hal() -> TimeoutUciHal<FakeUciHal> {
-        init_test_logging();
-        TimeoutUciHal::new(FakeUciHal {})
-    }
-
-    #[tokio::test]
-    async fn test_ok() {
-        let mut hal = setup_hal();
-        let (sender, _receiver) = mpsc::unbounded_channel();
-
-        assert!(matches!(hal.open(sender).await, Ok(())));
-    }
-
-    #[tokio::test]
-    async fn test_fail() {
-        let mut hal = setup_hal();
-
-        assert!(matches!(hal.close().await, Err(Error::Unknown)));
-    }
-
-    #[tokio::test]
-    async fn test_timeout() {
-        let mut hal = setup_hal();
-        let cmd = vec![];
-
-        assert!(matches!(hal.send_packet(cmd).await, Err(Error::Timeout)));
-    }
-}
diff --git a/src/rust/uwb_core/src/uci/uci_hal.rs b/src/rust/uwb_core/src/uci/uci_hal.rs
deleted file mode 100644
index adc69b3..0000000
--- a/src/rust/uwb_core/src/uci/uci_hal.rs
+++ /dev/null
@@ -1,120 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module defines the UciHal trait, used for the UCI hardware abstration layer.
-
-use std::convert::TryInto;
-
-use async_trait::async_trait;
-use pdl_runtime::Packet;
-use tokio::sync::mpsc;
-use uwb_uci_packets::{UciControlPacket, UciControlPacketHal};
-
-use crate::error::Result;
-use crate::params::uci_packets::SessionId;
-use crate::uci::command::UciCommand;
-
-/// The byte buffer of a UCI packet that is used to communicate with the UciHal trait.
-/// The format of the byte buffer should follow the UCI packet spec.
-pub type UciHalPacket = Vec<u8>;
-
-/// The trait for the UCI hardware abstration layer. The client of this library should implement
-/// this trait and inject into the library.
-/// Note: Each method should be completed in 1000 ms.
-#[async_trait]
-pub trait UciHal: 'static + Send + Sync {
-    /// Open the UCI HAL and power on the UWB Subsystem.
-    ///
-    /// All the other API should be called after the open() completes successfully. Once the method
-    /// completes successfully, the UciHal instance should store |packet_sender| and send the UCI
-    /// packets (responses, notifications, data) back to the caller via the |packet_sender|.
-    async fn open(&mut self, packet_sender: mpsc::UnboundedSender<UciHalPacket>) -> Result<()>;
-
-    /// Close the UCI HAL.
-    ///
-    /// After calling this method, the instance would drop |packet_sender| received from open()
-    /// method.
-    async fn close(&mut self) -> Result<()>;
-
-    /// Write the UCI command to the UWB Subsystem.
-    ///
-    /// The caller should call this method after the response of the previous send_command() is
-    /// received.
-    async fn send_command(&mut self, cmd: UciCommand) -> Result<()> {
-        // A UCI command message may consist of multiple UCI packets when the payload is over the
-        // maximum packet size. We convert the command into list of UciHalPacket, then send the
-        // packets via send_packet().
-        let packet: UciControlPacket = cmd.try_into()?;
-        let fragmented_packets: Vec<UciControlPacketHal> = packet.into();
-        for packet in fragmented_packets.into_iter() {
-            self.send_packet(packet.encode_to_vec().unwrap()).await?;
-        }
-        Ok(())
-    }
-
-    /// Write the UCI packet to the UWB Subsystem.
-    async fn send_packet(&mut self, packet: UciHalPacket) -> Result<()>;
-
-    /// Notify the HAL that the UWB session is initialized successfully.
-    async fn notify_session_initialized(&mut self, _session_id: SessionId) -> Result<()> {
-        Ok(())
-    }
-}
-
-/// A placeholder implementation for UciHal that do nothing.
-pub struct NopUciHal {}
-#[async_trait]
-impl UciHal for NopUciHal {
-    async fn open(&mut self, _packet_sender: mpsc::UnboundedSender<UciHalPacket>) -> Result<()> {
-        Ok(())
-    }
-    async fn close(&mut self) -> Result<()> {
-        Ok(())
-    }
-    async fn send_packet(&mut self, _packet: UciHalPacket) -> Result<()> {
-        Ok(())
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    struct MockUciHal {
-        pub packets: Vec<UciHalPacket>,
-    }
-
-    #[async_trait]
-    impl UciHal for MockUciHal {
-        async fn open(&mut self, _: mpsc::UnboundedSender<UciHalPacket>) -> Result<()> {
-            Ok(())
-        }
-        async fn close(&mut self) -> Result<()> {
-            Ok(())
-        }
-        async fn send_packet(&mut self, packet: UciHalPacket) -> Result<()> {
-            self.packets.push(packet);
-            Ok(())
-        }
-    }
-
-    // Verify if UciHal::send_command() split the packets correctly.
-    #[tokio::test]
-    async fn test_send_command() {
-        let mut hal = MockUciHal { packets: vec![] };
-        let _ = hal.send_command(UciCommand::CoreGetDeviceInfo).await;
-        let expected_packets = vec![vec![0x20, 0x02, 0x00, 0x00]];
-        assert_eq!(hal.packets, expected_packets);
-    }
-}
diff --git a/src/rust/uwb_core/src/uci/uci_logger.rs b/src/rust/uwb_core/src/uci/uci_logger.rs
deleted file mode 100644
index a6060d9..0000000
--- a/src/rust/uwb_core/src/uci/uci_logger.rs
+++ /dev/null
@@ -1,288 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Trait definition for UciLogger.
-use std::convert::TryFrom;
-
-use pdl_runtime::Packet;
-use uwb_uci_packets::{
-    AppConfigTlv, AppConfigTlvType, SessionConfigCommandChild, SessionConfigResponseChild,
-    SessionGetAppConfigRspBuilder, SessionSetAppConfigCmdBuilder, UciCommandChild,
-    UciControlPacket, UciControlPacketChild, UciDataPacket, UciResponse, UciResponseChild,
-    UCI_PACKET_HAL_HEADER_LEN,
-};
-
-use crate::error::{Error, Result};
-use crate::uci::UciCommand;
-
-/// UCI Log mode.
-#[derive(Clone, Debug, PartialEq, Eq)]
-pub enum UciLoggerMode {
-    /// Log is disabled.
-    Disabled,
-    /// Logs all uci packets without filtering PII information.
-    Unfiltered,
-    /// Logs uci packets, with PII filtered.
-    Filtered,
-}
-
-impl TryFrom<String> for UciLoggerMode {
-    type Error = Error;
-    /// Parse log mode from string.
-    fn try_from(log_mode_string: String) -> Result<UciLoggerMode> {
-        match log_mode_string.as_str() {
-            "disabled" => Ok(UciLoggerMode::Disabled),
-            "unfiltered" => Ok(UciLoggerMode::Unfiltered),
-            "filtered" => Ok(UciLoggerMode::Filtered),
-            _ => Err(Error::BadParameters),
-        }
-    }
-}
-
-/// Trait definition for the thread-safe uci logger
-pub trait UciLogger: 'static + Send + Sync {
-    /// Logs Uci Control Packet.
-    fn log_uci_control_packet(&mut self, packet: UciControlPacket);
-    /// Logs Uci Data Packet. This is being passed as a reference since most of the time logging is
-    /// disabled, and so this will avoid copying the data payload.
-    fn log_uci_data_packet(&mut self, packet: &UciDataPacket);
-    /// Logs hal open event.
-    fn log_hal_open(&mut self, result: Result<()>);
-    /// Logs hal close event.
-    fn log_hal_close(&mut self, result: Result<()>);
-}
-
-fn filter_tlv(mut tlv: AppConfigTlv) -> AppConfigTlv {
-    if tlv.cfg_id == AppConfigTlvType::VendorId || tlv.cfg_id == AppConfigTlvType::StaticStsIv {
-        tlv.v = vec![0; tlv.v.len()];
-    }
-    tlv
-}
-
-fn filter_uci_command(cmd: UciControlPacket) -> UciControlPacket {
-    match cmd.specialize() {
-        UciControlPacketChild::UciCommand(control_cmd) => match control_cmd.specialize() {
-            UciCommandChild::SessionConfigCommand(session_cmd) => match session_cmd.specialize() {
-                SessionConfigCommandChild::SessionSetAppConfigCmd(set_config_cmd) => {
-                    let session_token = set_config_cmd.get_session_token();
-                    let tlvs = set_config_cmd.get_tlvs().to_owned();
-                    let filtered_tlvs = tlvs.into_iter().map(filter_tlv).collect();
-                    SessionSetAppConfigCmdBuilder { session_token, tlvs: filtered_tlvs }
-                        .build()
-                        .into()
-                }
-                _ => session_cmd.into(),
-            },
-            _ => cmd,
-        },
-        _ => cmd,
-    }
-}
-
-fn filter_uci_response(rsp: UciResponse) -> UciResponse {
-    match rsp.specialize() {
-        UciResponseChild::SessionConfigResponse(session_rsp) => match session_rsp.specialize() {
-            SessionConfigResponseChild::SessionGetAppConfigRsp(rsp) => {
-                let status = rsp.get_status();
-                let tlvs = rsp.get_tlvs().to_owned();
-                let filtered_tlvs = tlvs.into_iter().map(filter_tlv).collect();
-                SessionGetAppConfigRspBuilder { status, tlvs: filtered_tlvs }.build().into()
-            }
-            _ => session_rsp.into(),
-        },
-        _ => rsp,
-    }
-}
-
-// Log only the Data Packet header bytes, so that we don't log any PII (payload bytes).
-fn filter_uci_data(
-    packet: &UciDataPacket,
-) -> std::result::Result<UciDataPacket, pdl_runtime::DecodeError> {
-    // Initialize a (zeroed out) Vec to the same length as the data packet, and then copy over
-    // only the Data Packet header bytes into it. This masks out all the payload bytes to 0.
-    let data_packet_bytes: Vec<u8> = packet.encode_to_vec().unwrap();
-    let mut filtered_data_packet_bytes: Vec<u8> = vec![0; data_packet_bytes.len()];
-    for (i, &b) in data_packet_bytes[..UCI_PACKET_HAL_HEADER_LEN].iter().enumerate() {
-        filtered_data_packet_bytes[i] = b;
-    }
-    UciDataPacket::parse(&filtered_data_packet_bytes)
-}
-
-/// Wrapper struct that filters messages feeded to UciLogger.
-pub(crate) struct UciLoggerWrapper<T: UciLogger> {
-    mode: UciLoggerMode,
-    logger: T,
-}
-impl<T: UciLogger> UciLoggerWrapper<T> {
-    pub fn new(logger: T, mode: UciLoggerMode) -> Self {
-        Self { mode, logger }
-    }
-
-    pub fn set_logger_mode(&mut self, mode: UciLoggerMode) {
-        self.mode = mode;
-    }
-
-    /// Logs hal open event.
-    pub fn log_hal_open(&mut self, result: &Result<()>) {
-        if self.mode != UciLoggerMode::Disabled {
-            self.logger.log_hal_open(result.clone());
-        }
-    }
-
-    /// Logs hal close event.
-    pub fn log_hal_close(&mut self, result: &Result<()>) {
-        if self.mode != UciLoggerMode::Disabled {
-            self.logger.log_hal_close(result.clone());
-        }
-    }
-
-    pub fn log_uci_command(&mut self, cmd: &UciCommand) {
-        match self.mode {
-            UciLoggerMode::Disabled => (),
-            UciLoggerMode::Unfiltered => {
-                if let Ok(packet) = UciControlPacket::try_from(cmd.clone()) {
-                    self.logger.log_uci_control_packet(packet);
-                };
-            }
-            UciLoggerMode::Filtered => {
-                if let Ok(packet) = UciControlPacket::try_from(cmd.clone()) {
-                    self.logger.log_uci_control_packet(filter_uci_command(packet));
-                };
-            }
-        }
-    }
-
-    pub fn log_uci_response_or_notification(&mut self, packet: &UciControlPacket) {
-        match self.mode {
-            UciLoggerMode::Disabled => (),
-            UciLoggerMode::Unfiltered => self.logger.log_uci_control_packet(packet.clone()),
-            UciLoggerMode::Filtered => match packet.clone().specialize() {
-                uwb_uci_packets::UciControlPacketChild::UciResponse(packet) => {
-                    self.logger.log_uci_control_packet(filter_uci_response(packet).into())
-                }
-                uwb_uci_packets::UciControlPacketChild::UciNotification(packet) => {
-                    self.logger.log_uci_control_packet(packet.into())
-                }
-                _ => (),
-            },
-        }
-    }
-
-    pub fn log_uci_data(&mut self, packet: &UciDataPacket) {
-        if self.mode == UciLoggerMode::Disabled {
-            return;
-        }
-        if let Ok(filtered_packet) = filter_uci_data(packet) {
-            self.logger.log_uci_data_packet(&filtered_packet);
-        }
-    }
-}
-
-/// A placeholder UciLogger implementation that does nothing.
-#[derive(Default)]
-pub struct NopUciLogger {}
-
-impl UciLogger for NopUciLogger {
-    fn log_uci_control_packet(&mut self, _packet: UciControlPacket) {}
-
-    fn log_uci_data_packet(&mut self, _packet: &UciDataPacket) {}
-
-    fn log_hal_open(&mut self, _result: Result<()>) {}
-
-    fn log_hal_close(&mut self, _result: Result<()>) {}
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    use std::convert::TryInto;
-
-    use tokio::sync::mpsc;
-
-    use crate::params::uci_packets::StatusCode;
-    use crate::uci::mock_uci_logger::{MockUciLogger, UciLogEvent};
-    use uwb_uci_packets::{DataPacketFormat, MessageType, UciDataPacketBuilder};
-
-    #[test]
-    fn test_log_command_filter() -> Result<()> {
-        let set_config_cmd = UciCommand::SessionSetAppConfig {
-            session_token: 0x1,
-            config_tlvs: vec![
-                // Filtered to 0-filled of same length
-                AppConfigTlv { cfg_id: AppConfigTlvType::VendorId, v: vec![0, 1, 2] }.into(),
-                // Invariant after filter
-                AppConfigTlv { cfg_id: AppConfigTlvType::AoaResultReq, v: vec![0, 1, 2, 3] }.into(),
-            ],
-        };
-        let (log_sender, mut log_receiver) = mpsc::unbounded_channel::<UciLogEvent>();
-        let mut logger =
-            UciLoggerWrapper::new(MockUciLogger::new(log_sender), UciLoggerMode::Filtered);
-        logger.log_uci_command(&set_config_cmd);
-        assert_eq!(
-            TryInto::<Vec<u8>>::try_into(log_receiver.blocking_recv().unwrap())?,
-            vec!(
-                0x21, 0x3, 0, 0x10, 0, 0, 0, 0x1, 0, 0, 0, 0x2, // other info
-                0x27, 0x3, 0, 0, 0, // filtered vendor ID
-                0xd, 0x4, 0, 0x1, 0x2, 0x3 // unfiltered tlv
-            )
-        );
-        Ok(())
-    }
-
-    #[test]
-    fn test_log_response_filter() -> Result<()> {
-        let unfiltered_rsp: UciControlPacket = SessionGetAppConfigRspBuilder {
-            status: StatusCode::UciStatusOk,
-            tlvs: vec![
-                AppConfigTlv { cfg_id: AppConfigTlvType::StaticStsIv, v: vec![0, 1, 2] },
-                AppConfigTlv { cfg_id: AppConfigTlvType::AoaResultReq, v: vec![0, 1, 2, 3] },
-            ],
-        }
-        .build()
-        .into();
-        let (log_sender, mut log_receiver) = mpsc::unbounded_channel::<UciLogEvent>();
-        let mut logger =
-            UciLoggerWrapper::new(MockUciLogger::new(log_sender), UciLoggerMode::Filtered);
-        logger.log_uci_response_or_notification(&unfiltered_rsp);
-        assert_eq!(
-            TryInto::<Vec<u8>>::try_into(log_receiver.blocking_recv().unwrap())?,
-            vec!(
-                0x41, 0x4, 0, 0xd, 0, 0, 0, 0, 0x2, // other info
-                0x28, 0x3, 0, 0, 0, //filtered StaticStsIv
-                0xd, 0x4, 0, 0x1, 0x2, 0x3 // unfiltered tlv
-            )
-        );
-        Ok(())
-    }
-
-    #[test]
-    fn test_log_data_filter() -> Result<()> {
-        let unfiltered_data_packet: UciDataPacket = UciDataPacketBuilder {
-            data_packet_format: DataPacketFormat::DataSnd,
-            message_type: MessageType::Data,
-            payload: Some(vec![0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8].into()),
-        }
-        .build();
-        let (log_sender, mut log_receiver) = mpsc::unbounded_channel::<UciLogEvent>();
-        let mut logger =
-            UciLoggerWrapper::new(MockUciLogger::new(log_sender), UciLoggerMode::Filtered);
-        logger.log_uci_data(&unfiltered_data_packet);
-        assert_eq!(
-            TryInto::<Vec<u8>>::try_into(log_receiver.blocking_recv().unwrap())?,
-            vec!(0x1, 0x0, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)
-        );
-        Ok(())
-    }
-}
diff --git a/src/rust/uwb_core/src/uci/uci_logger_factory.rs b/src/rust/uwb_core/src/uci/uci_logger_factory.rs
deleted file mode 100644
index 7938c77..0000000
--- a/src/rust/uwb_core/src/uci/uci_logger_factory.rs
+++ /dev/null
@@ -1,43 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, item 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This file defines UciLoggerFactory, which manages the shared log file for multiple UciManager
-//! instances.
-
-use crate::uci::uci_logger::{NopUciLogger, UciLogger};
-
-/// Trait definition for UciLoggerFactory, which builds UciLoggers that shares a single log file
-/// created by this struct.
-/// structs implementing trait shall be ready to accept log at initialization, and the Loggers built
-/// shall remain valid after the factory goes out of scope.
-pub trait UciLoggerFactory {
-    /// Type of UciLogger used.
-    type Logger: UciLogger;
-    /// Builds a UciLogger whose log would route to this UciLoggerFactory.
-    ///
-    /// If a logger with same name is built, the returned UciLogger should work as a clone of the
-    /// previous one.
-    fn build_logger(&mut self, chip_id: &str) -> Option<Self::Logger>;
-}
-
-/// The UciLoggerFactory implementation that always builds NopUciLogger.
-#[derive(Default)]
-pub struct NopUciLoggerFactory {}
-impl UciLoggerFactory for NopUciLoggerFactory {
-    type Logger = NopUciLogger;
-
-    fn build_logger(&mut self, _chip_id: &str) -> Option<NopUciLogger> {
-        Some(NopUciLogger::default())
-    }
-}
diff --git a/src/rust/uwb_core/src/uci/uci_logger_pcapng.rs b/src/rust/uwb_core/src/uci/uci_logger_pcapng.rs
deleted file mode 100644
index ca67601..0000000
--- a/src/rust/uwb_core/src/uci/uci_logger_pcapng.rs
+++ /dev/null
@@ -1,103 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Implements UciLoggerPcapng, a UciLogger with PCAPNG format log.
-
-use log::warn;
-use pdl_runtime::Packet;
-use tokio::sync::mpsc;
-use uwb_uci_packets::{UciControlPacket, UciDataPacket};
-
-use crate::uci::pcapng_block::{BlockBuilder, BlockOption, EnhancedPacketBlockBuilder};
-use crate::uci::pcapng_uci_logger_factory::LogWriter;
-use crate::uci::uci_logger::UciLogger;
-/// A UCI logger that saves UCI packets and HAL events as PCAPNG file.
-///
-/// UciLoggerPcapng is built by PcapngUciLoggerFactory.
-pub struct UciLoggerPcapng {
-    log_writer: LogWriter,
-    interface_id: u32, // Unique to each UWB chip per log session.
-}
-
-impl UciLoggerPcapng {
-    /// Constructor.
-    pub(crate) fn new(log_writer: LogWriter, interface_id: u32) -> Self {
-        Self { log_writer, interface_id }
-    }
-
-    fn send_block_bytes(&mut self, bytes: Vec<u8>) {
-        if self.log_writer.send_bytes(bytes).is_none() {
-            warn!("UCI log: Logging to LogWritter failed.")
-        }
-    }
-
-    /// Flush the logs.
-    pub fn flush(&mut self) -> Option<mpsc::UnboundedReceiver<bool>> {
-        self.log_writer.flush()
-    }
-}
-
-impl UciLogger for UciLoggerPcapng {
-    fn log_uci_control_packet(&mut self, packet: UciControlPacket) {
-        let block_bytes = match EnhancedPacketBlockBuilder::new()
-            .interface_id(self.interface_id)
-            .packet(packet.encode_to_vec().unwrap())
-            .into_le_bytes()
-        {
-            Some(b) => b,
-            None => return,
-        };
-        self.send_block_bytes(block_bytes);
-    }
-
-    fn log_uci_data_packet(&mut self, packet: &UciDataPacket) {
-        let packet_header_bytes = match EnhancedPacketBlockBuilder::new()
-            .interface_id(self.interface_id)
-            .packet(packet.encode_to_vec().unwrap())
-            .into_le_bytes()
-        {
-            Some(b) => b,
-            None => return,
-        };
-        self.send_block_bytes(packet_header_bytes);
-    }
-
-    fn log_hal_open(&mut self, result: crate::error::Result<()>) {
-        let block_option = match result {
-            Ok(_) => BlockOption::new(0x1, "HAL OPEN: OKAY".to_owned().into_bytes()),
-            Err(_) => BlockOption::new(0x1, "HAL OPEN: FAIL".to_owned().into_bytes()),
-        };
-        let block_bytes = EnhancedPacketBlockBuilder::new()
-            .interface_id(self.interface_id)
-            .append_option(block_option)
-            .into_le_bytes()
-            .unwrap(); // Constant Block except for timestamp, which do not throw error.
-        self.send_block_bytes(block_bytes);
-    }
-
-    fn log_hal_close(&mut self, result: crate::error::Result<()>) {
-        let block_option = match result {
-            Ok(_) => BlockOption::new(0x1, "HAL CLOSE: OKAY".to_owned().into_bytes()),
-            Err(_) => BlockOption::new(0x1, "HAL CLOSE: FAIL".to_owned().into_bytes()),
-        };
-        let block_bytes = EnhancedPacketBlockBuilder::new()
-            .interface_id(self.interface_id)
-            .append_option(block_option)
-            .into_le_bytes()
-            .unwrap();
-        // packet and max_packet_length field are not assigned, into_le_bytes() must return
-        // a valid result.
-        self.send_block_bytes(block_bytes);
-    }
-}
diff --git a/src/rust/uwb_core/src/uci/uci_manager.rs b/src/rust/uwb_core/src/uci/uci_manager.rs
deleted file mode 100644
index 87b6638..0000000
--- a/src/rust/uwb_core/src/uci/uci_manager.rs
+++ /dev/null
@@ -1,4467 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::convert::TryInto;
-use std::sync::Arc;
-use std::time::Duration;
-
-use async_trait::async_trait;
-use log::{debug, error, info, warn};
-use num_traits::FromPrimitive;
-use tokio::sync::{mpsc, oneshot, Mutex};
-
-use crate::error::{Error, Result};
-use crate::params::uci_packets::{
-    AndroidRadarConfigResponse, AppConfigTlv, AppConfigTlvType, CapTlv, CapTlvType, Controlees,
-    CoreSetConfigResponse, CountryCode, CreditAvailability, DeviceConfigId, DeviceConfigTlv,
-    DeviceState, GetDeviceInfoResponse, GroupId, MessageType, PowerStats, RadarConfigTlv,
-    RadarConfigTlvType, RawUciMessage, ResetConfig, RfTestConfigResponse, RfTestConfigTlv,
-    SessionId, SessionState, SessionToken, SessionType, SessionUpdateControllerMulticastResponse,
-    SessionUpdateDtTagRangingRoundsResponse, SetAppConfigResponse, UciDataPacket, UciDataPacketHal,
-    UpdateMulticastListAction,
-};
-use crate::params::utils::{bytes_to_u16, bytes_to_u64};
-use crate::params::UCIMajorVersion;
-use crate::uci::command::UciCommand;
-use crate::uci::message::UciMessage;
-use crate::uci::notification::{
-    CoreNotification, DataRcvNotification, RadarDataRcvNotification, RfTestNotification,
-    SessionNotification, SessionRangeData, UciNotification,
-};
-use crate::uci::response::UciResponse;
-use crate::uci::timeout_uci_hal::TimeoutUciHal;
-use crate::uci::uci_hal::{UciHal, UciHalPacket};
-use crate::uci::uci_logger::{UciLogger, UciLoggerMode, UciLoggerWrapper};
-use crate::utils::{clean_mpsc_receiver, PinSleep};
-use pdl_runtime::Packet;
-use std::collections::{HashMap, VecDeque};
-use uwb_uci_packets::{
-    fragment_data_msg_send, ControleePhaseList, ControllerPhaseList, RawUciControlPacket,
-    UciDataSnd, UciDefragPacket,
-};
-
-const UCI_TIMEOUT_MS: u64 = 2000;
-const MAX_RETRY_COUNT: usize = 3;
-// Initialize to a safe (minimum) value for a Data packet fragment's payload size.
-const MAX_DATA_PACKET_PAYLOAD_SIZE: usize = 255;
-
-/// The UciManager organizes the state machine of the UWB HAL, and provides the interface which
-/// abstracts the UCI commands, responses, and notifications.
-#[async_trait]
-pub trait UciManager: 'static + Send + Sync + Clone {
-    async fn set_logger_mode(&self, logger_mode: UciLoggerMode) -> Result<()>;
-    // Set the sendor of the UCI notificaions.
-    async fn set_core_notification_sender(
-        &mut self,
-        core_notf_sender: mpsc::UnboundedSender<CoreNotification>,
-    );
-    async fn set_session_notification_sender(
-        &mut self,
-        session_notf_sender: mpsc::UnboundedSender<SessionNotification>,
-    );
-    async fn set_vendor_notification_sender(
-        &mut self,
-        vendor_notf_sender: mpsc::UnboundedSender<RawUciMessage>,
-    );
-    async fn set_data_rcv_notification_sender(
-        &mut self,
-        data_rcv_notf_sender: mpsc::UnboundedSender<DataRcvNotification>,
-    );
-    async fn set_radar_data_rcv_notification_sender(
-        &mut self,
-        radar_data_rcv_notf_sender: mpsc::UnboundedSender<RadarDataRcvNotification>,
-    );
-    async fn set_rf_test_notification_sender(
-        &mut self,
-        rf_test_notf_sender: mpsc::UnboundedSender<RfTestNotification>,
-    );
-
-    // Open the UCI HAL.
-    // All the UCI commands should be called after the open_hal() completes successfully.
-    async fn open_hal(&self) -> Result<GetDeviceInfoResponse>;
-
-    // Close the UCI HAL.
-    async fn close_hal(&self, force: bool) -> Result<()>;
-
-    // Send the standard UCI Commands.
-    async fn device_reset(&self, reset_config: ResetConfig) -> Result<()>;
-    async fn core_get_device_info(&self) -> Result<GetDeviceInfoResponse>;
-    async fn core_get_caps_info(&self) -> Result<Vec<CapTlv>>;
-    async fn core_set_config(
-        &self,
-        config_tlvs: Vec<DeviceConfigTlv>,
-    ) -> Result<CoreSetConfigResponse>;
-    async fn core_get_config(
-        &self,
-        config_ids: Vec<DeviceConfigId>,
-    ) -> Result<Vec<DeviceConfigTlv>>;
-    async fn core_query_uwb_timestamp(&self) -> Result<u64>;
-    async fn session_init(&self, session_id: SessionId, session_type: SessionType) -> Result<()>;
-    async fn session_deinit(&self, session_id: SessionId) -> Result<()>;
-    async fn session_set_app_config(
-        &self,
-        session_id: SessionId,
-        config_tlvs: Vec<AppConfigTlv>,
-    ) -> Result<SetAppConfigResponse>;
-    async fn session_get_app_config(
-        &self,
-        session_id: SessionId,
-        config_ids: Vec<AppConfigTlvType>,
-    ) -> Result<Vec<AppConfigTlv>>;
-    async fn session_get_count(&self) -> Result<u8>;
-    async fn session_get_state(&self, session_id: SessionId) -> Result<SessionState>;
-    async fn session_update_controller_multicast_list(
-        &self,
-        session_id: SessionId,
-        action: UpdateMulticastListAction,
-        controlees: Controlees,
-        is_multicast_list_ntf_v2_supported: bool,
-        is_multicast_list_rsp_v2_supported: bool,
-    ) -> Result<SessionUpdateControllerMulticastResponse>;
-
-    // Update ranging rounds for DT Tag
-    async fn session_update_dt_tag_ranging_rounds(
-        &self,
-        session_id: u32,
-        ranging_round_indexes: Vec<u8>,
-    ) -> Result<SessionUpdateDtTagRangingRoundsResponse>;
-
-    async fn session_query_max_data_size(&self, session_id: SessionId) -> Result<u16>;
-
-    async fn range_start(&self, session_id: SessionId) -> Result<()>;
-    async fn range_stop(&self, session_id: SessionId) -> Result<()>;
-    async fn range_get_ranging_count(&self, session_id: SessionId) -> Result<usize>;
-
-    // Send the Android-specific UCI commands
-    async fn android_set_country_code(&self, country_code: CountryCode) -> Result<()>;
-    async fn android_get_power_stats(&self) -> Result<PowerStats>;
-    async fn android_set_radar_config(
-        &self,
-        session_id: SessionId,
-        config_tlvs: Vec<RadarConfigTlv>,
-    ) -> Result<AndroidRadarConfigResponse>;
-    async fn android_get_radar_config(
-        &self,
-        session_id: SessionId,
-        config_ids: Vec<RadarConfigTlvType>,
-    ) -> Result<Vec<RadarConfigTlv>>;
-
-    // Send a raw uci command.
-    async fn raw_uci_cmd(
-        &self,
-        mt: u32,
-        gid: u32,
-        oid: u32,
-        payload: Vec<u8>,
-    ) -> Result<RawUciMessage>;
-
-    // Send a Data packet.
-    async fn send_data_packet(
-        &self,
-        session_id: SessionId,
-        address: Vec<u8>,
-        uci_sequence_number: u16,
-        app_payload_data: Vec<u8>,
-    ) -> Result<()>;
-
-    // set Data transfer phase config
-    #[allow(clippy::too_many_arguments)]
-    async fn session_data_transfer_phase_config(
-        &self,
-        session_id: SessionId,
-        dtpcm_repetition: u8,
-        data_transfer_control: u8,
-        dtpml_size: u8,
-        mac_address: Vec<u8>,
-        slot_bitmap: Vec<u8>,
-        stop_data_transfer: Vec<u8>,
-    ) -> Result<()>;
-
-    // Get Session token from session id
-    async fn get_session_token_from_session_id(
-        &self,
-        session_id: SessionId,
-    ) -> Result<SessionToken>;
-
-    /// Send UCI command for setting hybrid controller config
-    async fn session_set_hybrid_controller_config(
-        &self,
-        session_id: SessionId,
-        number_of_phases: u8,
-        phase_list: Vec<ControllerPhaseList>,
-    ) -> Result<()>;
-
-    /// Send UCI command for setting hybrid controlee config
-    async fn session_set_hybrid_controlee_config(
-        &self,
-        session_id: SessionId,
-        controlee_phase_list: Vec<ControleePhaseList>,
-    ) -> Result<()>;
-    async fn session_set_rf_test_config(
-        &self,
-        session_id: SessionId,
-        config_tlvs: Vec<RfTestConfigTlv>,
-    ) -> Result<RfTestConfigResponse>;
-    async fn rf_test_periodic_tx(&self, psdu_data: Vec<u8>) -> Result<()>;
-    async fn rf_test_per_rx(&self, psdu_data: Vec<u8>) -> Result<()>;
-    async fn stop_rf_test(&self) -> Result<()>;
-}
-
-/// UciManagerImpl is the main implementation of UciManager. Using the actor model, UciManagerImpl
-/// delegates the requests to UciManagerActor.
-#[derive(Clone)]
-pub struct UciManagerImpl {
-    cmd_sender: mpsc::UnboundedSender<(UciManagerCmd, oneshot::Sender<Result<UciResponse>>)>,
-
-    // FIRA version 2 introduces a UWBS generated session handle to use as identifier for all
-    // session related commands. This map stores the app provided session id to UWBS generated
-    // session handle mapping if provided, else reuses session id.
-    session_id_to_token_map: Arc<Mutex<HashMap<SessionId, SessionToken>>>,
-}
-
-impl UciManagerImpl {
-    /// Constructor. Need to be called in an async context.
-    pub(crate) fn new<T: UciHal, U: UciLogger>(
-        hal: T,
-        logger: U,
-        logger_mode: UciLoggerMode,
-    ) -> Self {
-        let (cmd_sender, cmd_receiver) = mpsc::unbounded_channel();
-        let session_id_to_token_map: Arc<Mutex<HashMap<SessionId, SessionToken>>> =
-            Arc::new(Mutex::new(HashMap::new()));
-        let mut actor = UciManagerActor::new(
-            hal,
-            logger,
-            logger_mode,
-            cmd_receiver,
-            session_id_to_token_map.clone(),
-        );
-        tokio::spawn(async move { actor.run().await });
-
-        Self { cmd_sender, session_id_to_token_map }
-    }
-
-    // Send the |cmd| to the UciManagerActor.
-    async fn send_cmd(&self, cmd: UciManagerCmd) -> Result<UciResponse> {
-        let (result_sender, result_receiver) = oneshot::channel();
-        match self.cmd_sender.send((cmd, result_sender)) {
-            Ok(()) => result_receiver.await.unwrap_or(Err(Error::Unknown)),
-            Err(cmd) => {
-                error!("Failed to send cmd: {:?}", cmd.0);
-                Err(Error::Unknown)
-            }
-        }
-    }
-
-    async fn get_session_token(&self, session_id: &SessionId) -> Result<SessionToken> {
-        self.session_id_to_token_map
-            .lock()
-            .await
-            .get(session_id)
-            .ok_or(Error::BadParameters)
-            .copied()
-    }
-}
-
-#[async_trait]
-impl UciManager for UciManagerImpl {
-    async fn set_logger_mode(&self, logger_mode: UciLoggerMode) -> Result<()> {
-        match self.send_cmd(UciManagerCmd::SetLoggerMode { logger_mode }).await {
-            Ok(UciResponse::SetLoggerMode) => Ok(()),
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-    async fn set_core_notification_sender(
-        &mut self,
-        core_notf_sender: mpsc::UnboundedSender<CoreNotification>,
-    ) {
-        let _ = self.send_cmd(UciManagerCmd::SetCoreNotificationSender { core_notf_sender }).await;
-    }
-    async fn set_session_notification_sender(
-        &mut self,
-        session_notf_sender: mpsc::UnboundedSender<SessionNotification>,
-    ) {
-        let _ = self
-            .send_cmd(UciManagerCmd::SetSessionNotificationSender { session_notf_sender })
-            .await;
-    }
-    async fn set_vendor_notification_sender(
-        &mut self,
-        vendor_notf_sender: mpsc::UnboundedSender<RawUciMessage>,
-    ) {
-        let _ =
-            self.send_cmd(UciManagerCmd::SetVendorNotificationSender { vendor_notf_sender }).await;
-    }
-    async fn set_data_rcv_notification_sender(
-        &mut self,
-        data_rcv_notf_sender: mpsc::UnboundedSender<DataRcvNotification>,
-    ) {
-        let _ = self
-            .send_cmd(UciManagerCmd::SetDataRcvNotificationSender { data_rcv_notf_sender })
-            .await;
-    }
-    async fn set_radar_data_rcv_notification_sender(
-        &mut self,
-        radar_data_rcv_notf_sender: mpsc::UnboundedSender<RadarDataRcvNotification>,
-    ) {
-        let _ = self
-            .send_cmd(UciManagerCmd::SetRadarDataRcvNotificationSender {
-                radar_data_rcv_notf_sender,
-            })
-            .await;
-    }
-
-    async fn set_rf_test_notification_sender(
-        &mut self,
-        rf_test_notf_sender: mpsc::UnboundedSender<RfTestNotification>,
-    ) {
-        let _ =
-            self.send_cmd(UciManagerCmd::SetRfTestNotificationSender { rf_test_notf_sender }).await;
-    }
-
-    async fn open_hal(&self) -> Result<GetDeviceInfoResponse> {
-        match self.send_cmd(UciManagerCmd::OpenHal).await {
-            Ok(UciResponse::OpenHal) => {
-                // According to the UCI spec: "The Host shall send CORE_GET_DEVICE_INFO_CMD to
-                // retrieve the device information.", we call get_device_info() after successfully
-                // opening the HAL.
-                let device_info = match self.core_get_device_info().await {
-                    Ok(resp) => resp,
-                    Err(e) => {
-                        return Err(e);
-                    }
-                };
-                debug!("UCI device info: {:?}", device_info);
-
-                Ok(device_info)
-            }
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn close_hal(&self, force: bool) -> Result<()> {
-        match self.send_cmd(UciManagerCmd::CloseHal { force }).await {
-            Ok(UciResponse::CloseHal) => Ok(()),
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn device_reset(&self, reset_config: ResetConfig) -> Result<()> {
-        let cmd = UciCommand::DeviceReset { reset_config };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::DeviceReset(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn core_get_device_info(&self) -> Result<GetDeviceInfoResponse> {
-        let cmd = UciCommand::CoreGetDeviceInfo;
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::CoreGetDeviceInfo(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn core_get_caps_info(&self) -> Result<Vec<CapTlv>> {
-        let cmd = UciCommand::CoreGetCapsInfo;
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::CoreGetCapsInfo(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn core_set_config(
-        &self,
-        config_tlvs: Vec<DeviceConfigTlv>,
-    ) -> Result<CoreSetConfigResponse> {
-        let cmd = UciCommand::CoreSetConfig { config_tlvs };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::CoreSetConfig(resp)) => Ok(resp),
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn core_get_config(&self, cfg_id: Vec<DeviceConfigId>) -> Result<Vec<DeviceConfigTlv>> {
-        let cmd = UciCommand::CoreGetConfig { cfg_id };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::CoreGetConfig(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn core_query_uwb_timestamp(&self) -> Result<u64> {
-        let cmd = UciCommand::CoreQueryTimeStamp;
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::CoreQueryTimeStamp(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn session_init(&self, session_id: SessionId, session_type: SessionType) -> Result<()> {
-        let cmd = UciCommand::SessionInit { session_id, session_type };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionInit(resp)) => resp.map(|_| {}),
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn session_deinit(&self, session_id: SessionId) -> Result<()> {
-        let cmd =
-            UciCommand::SessionDeinit { session_token: self.get_session_token(&session_id).await? };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionDeinit(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn session_set_app_config(
-        &self,
-        session_id: SessionId,
-        config_tlvs: Vec<AppConfigTlv>,
-    ) -> Result<SetAppConfigResponse> {
-        let cmd = UciCommand::SessionSetAppConfig {
-            session_token: self.get_session_token(&session_id).await?,
-            config_tlvs,
-        };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionSetAppConfig(resp)) => Ok(resp),
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn session_get_app_config(
-        &self,
-        session_id: SessionId,
-        app_cfg: Vec<AppConfigTlvType>,
-    ) -> Result<Vec<AppConfigTlv>> {
-        let cmd = UciCommand::SessionGetAppConfig {
-            session_token: self.get_session_token(&session_id).await?,
-            app_cfg,
-        };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionGetAppConfig(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn session_get_count(&self) -> Result<u8> {
-        let cmd = UciCommand::SessionGetCount;
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionGetCount(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn session_get_state(&self, session_id: SessionId) -> Result<SessionState> {
-        let cmd = UciCommand::SessionGetState {
-            session_token: self.get_session_token(&session_id).await?,
-        };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionGetState(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn session_update_controller_multicast_list(
-        &self,
-        session_id: SessionId,
-        action: UpdateMulticastListAction,
-        controlees: Controlees,
-        is_multicast_list_ntf_v2_supported: bool,
-        is_multicast_list_rsp_v2_supported: bool,
-    ) -> Result<SessionUpdateControllerMulticastResponse> {
-        let controlees_len = match controlees {
-            Controlees::NoSessionKey(ref controlee_vec) => controlee_vec.len(),
-            Controlees::ShortSessionKey(ref controlee_vec) => controlee_vec.len(),
-            Controlees::LongSessionKey(ref controlee_vec) => controlee_vec.len(),
-        };
-        if !(1..=8).contains(&controlees_len) {
-            warn!("Number of controlees should be between 1 to 8");
-            return Err(Error::BadParameters);
-        }
-        let cmd = UciCommand::SessionUpdateControllerMulticastList {
-            session_token: self.get_session_token(&session_id).await?,
-            action,
-            controlees,
-            is_multicast_list_ntf_v2_supported,
-            is_multicast_list_rsp_v2_supported,
-        };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionUpdateControllerMulticastList(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn session_update_dt_tag_ranging_rounds(
-        &self,
-        session_id: u32,
-        ranging_round_indexes: Vec<u8>,
-    ) -> Result<SessionUpdateDtTagRangingRoundsResponse> {
-        let cmd = UciCommand::SessionUpdateDtTagRangingRounds {
-            session_token: self.get_session_token(&session_id).await?,
-            ranging_round_indexes,
-        };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionUpdateDtTagRangingRounds(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn session_query_max_data_size(&self, session_id: SessionId) -> Result<u16> {
-        let cmd = UciCommand::SessionQueryMaxDataSize {
-            session_token: self.get_session_token(&session_id).await?,
-        };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionQueryMaxDataSize(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn range_start(&self, session_id: SessionId) -> Result<()> {
-        let cmd =
-            UciCommand::SessionStart { session_token: self.get_session_token(&session_id).await? };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionStart(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn range_stop(&self, session_id: SessionId) -> Result<()> {
-        let cmd =
-            UciCommand::SessionStop { session_token: self.get_session_token(&session_id).await? };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionStop(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn range_get_ranging_count(&self, session_id: SessionId) -> Result<usize> {
-        let cmd = UciCommand::SessionGetRangingCount {
-            session_token: self.get_session_token(&session_id).await?,
-        };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionGetRangingCount(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn android_set_country_code(&self, country_code: CountryCode) -> Result<()> {
-        let cmd = UciCommand::AndroidSetCountryCode { country_code };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::AndroidSetCountryCode(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn android_get_power_stats(&self) -> Result<PowerStats> {
-        let cmd = UciCommand::AndroidGetPowerStats;
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::AndroidGetPowerStats(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn android_set_radar_config(
-        &self,
-        session_id: SessionId,
-        config_tlvs: Vec<RadarConfigTlv>,
-    ) -> Result<AndroidRadarConfigResponse> {
-        let cmd = UciCommand::AndroidSetRadarConfig {
-            session_token: self.get_session_token(&session_id).await?,
-            config_tlvs,
-        };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::AndroidSetRadarConfig(resp)) => Ok(resp),
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn android_get_radar_config(
-        &self,
-        session_id: SessionId,
-        radar_cfg: Vec<RadarConfigTlvType>,
-    ) -> Result<Vec<RadarConfigTlv>> {
-        let cmd = UciCommand::AndroidGetRadarConfig {
-            session_token: self.get_session_token(&session_id).await?,
-            radar_cfg,
-        };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::AndroidGetRadarConfig(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn raw_uci_cmd(
-        &self,
-        mt: u32,
-        gid: u32,
-        oid: u32,
-        payload: Vec<u8>,
-    ) -> Result<RawUciMessage> {
-        let cmd = UciCommand::RawUciCmd { mt, gid, oid, payload };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::RawUciCmd(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    // Send a data packet to the UWBS (use the UciManagerActor).
-    async fn send_data_packet(
-        &self,
-        session_id: SessionId,
-        dest_mac_address_bytes: Vec<u8>,
-        uci_sequence_number: u16,
-        data: Vec<u8>,
-    ) -> Result<()> {
-        debug!(
-            "send_data_packet(): will Tx a data packet, session_id {}, sequence_number {}",
-            session_id, uci_sequence_number
-        );
-        let dest_mac_address = bytes_to_u64(dest_mac_address_bytes).ok_or(Error::BadParameters)?;
-        let data_snd_packet = uwb_uci_packets::UciDataSndBuilder {
-            session_token: self.get_session_token(&session_id).await?,
-            dest_mac_address,
-            uci_sequence_number,
-            data,
-        }
-        .build();
-
-        match self.send_cmd(UciManagerCmd::SendUciData { data_snd_packet }).await {
-            Ok(UciResponse::SendUciData(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    // set Data transfer phase config
-    async fn session_data_transfer_phase_config(
-        &self,
-        session_id: SessionId,
-        dtpcm_repetition: u8,
-        data_transfer_control: u8,
-        dtpml_size: u8,
-        mac_address: Vec<u8>,
-        slot_bitmap: Vec<u8>,
-        stop_data_transfer: Vec<u8>,
-    ) -> Result<()> {
-        let cmd = UciCommand::SessionDataTransferPhaseConfig {
-            session_token: self.get_session_token(&session_id).await?,
-            dtpcm_repetition,
-            data_transfer_control,
-            dtpml_size,
-            mac_address,
-            slot_bitmap,
-            stop_data_transfer,
-        };
-
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionDataTransferPhaseConfig(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    // Get session token from session id (no uci call).
-    async fn get_session_token_from_session_id(
-        &self,
-        session_id: SessionId,
-    ) -> Result<SessionToken> {
-        Ok(self.get_session_token(&session_id).await?)
-    }
-
-    /// Send UCI command for setting hybrid controller config
-    async fn session_set_hybrid_controller_config(
-        &self,
-        session_id: SessionId,
-        number_of_phases: u8,
-        phase_list: Vec<ControllerPhaseList>,
-    ) -> Result<()> {
-        let cmd = UciCommand::SessionSetHybridControllerConfig {
-            session_token: self.get_session_token(&session_id).await?,
-            number_of_phases,
-            phase_list,
-        };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionSetHybridControllerConfig(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    /// Send UCI command for setting hybrid controlee config
-    async fn session_set_hybrid_controlee_config(
-        &self,
-        session_id: SessionId,
-        controlee_phase_list: Vec<ControleePhaseList>,
-    ) -> Result<()> {
-        let cmd = UciCommand::SessionSetHybridControleeConfig {
-            session_token: self.get_session_token(&session_id).await?,
-            controlee_phase_list,
-        };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionSetHybridControleeConfig(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn session_set_rf_test_config(
-        &self,
-        session_id: SessionId,
-        config_tlvs: Vec<RfTestConfigTlv>,
-    ) -> Result<RfTestConfigResponse> {
-        let cmd = UciCommand::SessionSetRfTestConfig {
-            session_token: self.get_session_token(&session_id).await?,
-            config_tlvs,
-        };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::SessionSetRfTestConfig(resp)) => Ok(resp),
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn rf_test_periodic_tx(&self, psdu_data: Vec<u8>) -> Result<()> {
-        let cmd = UciCommand::TestPeriodicTx { psdu_data };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::RfTest(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn rf_test_per_rx(&self, psdu_data: Vec<u8>) -> Result<()> {
-        let cmd = UciCommand::TestPerRx { psdu_data };
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::RfTest(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-
-    async fn stop_rf_test(&self) -> Result<()> {
-        let cmd = UciCommand::StopRfTest;
-        match self.send_cmd(UciManagerCmd::SendUciCommand { cmd }).await {
-            Ok(UciResponse::RfTest(resp)) => resp,
-            Ok(_) => Err(Error::Unknown),
-            Err(e) => Err(e),
-        }
-    }
-}
-
-struct UciManagerActor<T: UciHal, U: UciLogger> {
-    // The UCI HAL.
-    hal: TimeoutUciHal<T>,
-    // UCI Log.
-    logger: UciLoggerWrapper<U>,
-    // Receive the commands and the corresponding response senders from UciManager.
-    cmd_receiver: mpsc::UnboundedReceiver<(UciManagerCmd, oneshot::Sender<Result<UciResponse>>)>,
-
-    // Set to true when |hal| is opened successfully.
-    is_hal_opened: bool,
-    // Receive response, notification and data packets from |mut hal|. Only used when |hal| is opened
-    // successfully.
-    packet_receiver: mpsc::UnboundedReceiver<UciHalPacket>,
-    // Defrag the UCI packets.
-    defrager: uwb_uci_packets::PacketDefrager,
-
-    // The response sender of UciManager's open_hal() method. Used to wait for the device ready
-    // notification.
-    open_hal_result_sender: Option<oneshot::Sender<Result<UciResponse>>>,
-
-    // Store per-session CreditAvailability. This should be initialized when a UWB session becomes
-    // ACTIVE, and updated every time a Data packet fragment is sent or a DataCreditNtf is received.
-    data_credit_map: HashMap<SessionToken, CreditAvailability>,
-
-    // Store the Uci Data packet fragments to be sent to the UWBS, keyed by the SessionId. This
-    // helps to retrieve the next packet fragment to be sent, when the UWBS is ready to accept it.
-    data_packet_fragments_map: HashMap<SessionToken, VecDeque<UciDataPacketHal>>,
-
-    // The timeout of waiting for the notification of device ready notification.
-    wait_device_status_timeout: PinSleep,
-
-    // Used for the logic of retrying the command. Only valid when waiting for the response of a
-    // UCI command.
-    uci_cmd_retryer: Option<UciCmdRetryer>,
-    // The timeout of waiting for the response. Only used when waiting for the response of a UCI
-    // command.
-    wait_resp_timeout: PinSleep,
-
-    // Used for the logic of retrying the DataSnd packet. Only valid when waiting for the
-    // DATA_TRANSFER_STATUS_NTF.
-    uci_data_snd_retryer: Option<UciDataSndRetryer>,
-
-    // Used to identify if response corresponds to the last vendor command, if so return
-    // a raw packet as a response to the sender.
-    last_raw_cmd: Option<RawUciControlPacket>,
-
-    // Send the notifications to the caller of UciManager.
-    core_notf_sender: mpsc::UnboundedSender<CoreNotification>,
-    session_notf_sender: mpsc::UnboundedSender<SessionNotification>,
-    vendor_notf_sender: mpsc::UnboundedSender<RawUciMessage>,
-    data_rcv_notf_sender: mpsc::UnboundedSender<DataRcvNotification>,
-    radar_data_rcv_notf_sender: mpsc::UnboundedSender<RadarDataRcvNotification>,
-    rf_test_notf_sender: mpsc::UnboundedSender<RfTestNotification>,
-
-    // Used to store the last init session id to help map the session handle sent
-    // in session int response can be correctly mapped.
-    last_init_session_id: Option<SessionId>,
-    // FIRA version 2 introduces a UWBS generated session handle to use as identifier for all
-    // session related commands. This map stores the app provided session id to UWBS generated
-    // session handle mapping if provided, else reuses session id.
-    session_id_to_token_map: Arc<Mutex<HashMap<SessionId, SessionToken>>>,
-
-    // Used to store the UWBS response for the UCI CMD CORE_GET_DEVICE_INFO. This will help us
-    // identify the UWBS supported UCI version and change our behavior accordingly.
-    get_device_info_rsp: Option<GetDeviceInfoResponse>,
-
-    // The maximum payload size that can be sent in one Data packet fragment to the UWBS. The UCI
-    // DATA_MSG_SEND packets (from Host to UWBS), larger than this should be fragmented into
-    // multiple packets with this as the payload size.
-    max_data_packet_payload_size: usize,
-
-    // The flag that indicate whether multicast list ntf v2 is supported.
-    is_multicast_list_ntf_v2_supported: bool,
-
-    // The flag that indicate whether multicast list rsp v2 is supported.
-    is_multicast_list_rsp_v2_supported: bool,
-}
-
-impl<T: UciHal, U: UciLogger> UciManagerActor<T, U> {
-    fn new(
-        hal: T,
-        logger: U,
-        logger_mode: UciLoggerMode,
-        cmd_receiver: mpsc::UnboundedReceiver<(
-            UciManagerCmd,
-            oneshot::Sender<Result<UciResponse>>,
-        )>,
-        session_id_to_token_map: Arc<Mutex<HashMap<SessionId, SessionToken>>>,
-    ) -> Self {
-        Self {
-            hal: TimeoutUciHal::new(hal),
-            logger: UciLoggerWrapper::new(logger, logger_mode),
-            cmd_receiver,
-            is_hal_opened: false,
-            packet_receiver: mpsc::unbounded_channel().1,
-            defrager: Default::default(),
-            open_hal_result_sender: None,
-            data_credit_map: HashMap::new(),
-            data_packet_fragments_map: HashMap::new(),
-            wait_device_status_timeout: PinSleep::new(Duration::MAX),
-            uci_cmd_retryer: None,
-            uci_data_snd_retryer: None,
-            wait_resp_timeout: PinSleep::new(Duration::MAX),
-            last_raw_cmd: None,
-            core_notf_sender: mpsc::unbounded_channel().0,
-            session_notf_sender: mpsc::unbounded_channel().0,
-            vendor_notf_sender: mpsc::unbounded_channel().0,
-            data_rcv_notf_sender: mpsc::unbounded_channel().0,
-            radar_data_rcv_notf_sender: mpsc::unbounded_channel().0,
-            rf_test_notf_sender: mpsc::unbounded_channel().0,
-            last_init_session_id: None,
-            session_id_to_token_map,
-            get_device_info_rsp: None,
-            max_data_packet_payload_size: MAX_DATA_PACKET_PAYLOAD_SIZE,
-            is_multicast_list_ntf_v2_supported: false,
-            is_multicast_list_rsp_v2_supported: false,
-        }
-    }
-
-    async fn run(&mut self) {
-        loop {
-            tokio::select! {
-                // Handle the next command. Only when the previous command already received the
-                // response.
-                cmd = self.cmd_receiver.recv(), if !self.is_waiting_resp() => {
-                    match cmd {
-                        None => {
-                            debug!("UciManager is about to drop.");
-                            break;
-                        },
-                        Some((cmd, result_sender)) => {
-                            self.handle_cmd(cmd, result_sender).await;
-                        }
-                    }
-                }
-
-                // Handle the UCI response, notification or data packet from HAL. Only when HAL
-                // is opened.
-                packet = self.packet_receiver.recv(), if self.is_hal_opened => {
-                    self.handle_hal_packet(packet).await;
-                }
-
-                // Timeout waiting for the response of the UCI command.
-                _ = &mut self.wait_resp_timeout, if self.is_waiting_resp() => {
-                    if let Some(uci_cmd_retryer) = self.uci_cmd_retryer.take() {
-                        uci_cmd_retryer.send_result(Err(Error::Timeout));
-                    }
-                }
-
-                // Timeout waiting for the notification of the device status.
-                _ = &mut self.wait_device_status_timeout, if self.is_waiting_device_status() => {
-                    if let Some(result_sender) = self.open_hal_result_sender.take() {
-                        let _ = result_sender.send(Err(Error::Timeout));
-                    }
-                }
-            }
-        }
-
-        if self.is_hal_opened {
-            debug!("The HAL is still opened when exit, close the HAL");
-            let _ = self.hal.close().await;
-            self.on_hal_closed().await;
-        }
-    }
-
-    async fn insert_session_token(&self, session_id: SessionId, session_token: SessionToken) {
-        self.session_id_to_token_map.lock().await.insert(session_id, session_token);
-    }
-
-    async fn remove_session_token(&self, session_token: &SessionToken) {
-        self.session_id_to_token_map.lock().await.retain(|_, val| *val != *session_token);
-    }
-
-    async fn get_session_id(&self, session_token: &SessionToken) -> Result<SessionId> {
-        self.session_id_to_token_map
-            .lock()
-            .await
-            .iter()
-            .find_map(|(key, &val)| if val == *session_token { Some(key) } else { None })
-            .ok_or(Error::BadParameters)
-            .copied()
-    }
-
-    fn save_session_id_if_init_cmd(&mut self, cmd: &UciCommand) {
-        // Store the last init session id to help map the session handle sent
-        // in session init response.
-        if let UciCommand::SessionInit { session_id, .. } = cmd {
-            self.last_init_session_id = Some(*session_id);
-        }
-    }
-
-    async fn store_session_token_if_init_resp(&mut self, resp: &UciResponse) -> Result<()> {
-        // Store the session_id to session_token mapping for this new session.
-        if let UciResponse::SessionInit(session_init_resp) = resp {
-            let session_id = match self.last_init_session_id.take() {
-                Some(session_id) => session_id,
-                None => {
-                    return Err(Error::Unknown);
-                }
-            };
-            if let Ok(opt_session_handle) = session_init_resp {
-                let session_handle = match opt_session_handle {
-                    // Session Handle provided by UWBS, use as token for further commands.
-                    Some(session_handle) => {
-                        info!(
-                            "session handle: {:?} provided for session id: {:?}",
-                            session_handle, session_id
-                        );
-                        *session_handle
-                    }
-                    // Session Handle not provided by UWBS, reuse session id as token for further commands.
-                    None => session_id,
-                };
-                self.insert_session_token(session_id, session_handle).await;
-            }
-        }
-        Ok(())
-    }
-
-    // Store the GET_DEVICE_INFO RSP from UWBS.
-    fn store_if_uwbs_device_info(&mut self, resp: &UciResponse) {
-        if let UciResponse::CoreGetDeviceInfo(Ok(get_device_info_rsp)) = resp {
-            self.get_device_info_rsp = Some(get_device_info_rsp.clone());
-        }
-    }
-
-    fn get_uwbs_uci_major_version(&mut self) -> Option<u8> {
-        if let Some(core_get_device_info_rsp) = &self.get_device_info_rsp {
-            // Byte 0 : Major UCI version
-            // Calling unwrap() will be safe here as with the bitmask, the value will be within u8.
-            return Some((core_get_device_info_rsp.uci_version & 0xFF).try_into().unwrap());
-        }
-        None
-    }
-
-    #[allow(unknown_lints)]
-    #[allow(clippy::unnecessary_fallible_conversions)]
-    fn store_if_uwbs_caps_info(&mut self, resp: &UciResponse) {
-        if let UciResponse::CoreGetCapsInfo(Ok(tlvs)) = resp {
-            if let Some(core_get_device_info_rsp) = &self.get_device_info_rsp {
-                let major_uci_version = core_get_device_info_rsp.uci_version & 0xFF; // Byte 0
-                let tlvtag = if major_uci_version >= 2 {
-                    CapTlvType::SupportedV1FiraMacVersionRangeV2MaxDataPayloadSize
-                } else {
-                    CapTlvType::SupportedV1MaxDataPacketPayloadSizeV2AoaSupport
-                };
-                for tlv in tlvs {
-                    if tlv.t == tlvtag {
-                        // Convert the 2-byte UWBS capability value (stored as Vec<u8>) into usize.
-                        self.max_data_packet_payload_size = match bytes_to_u16(tlv.v.clone()) {
-                            Some(u16size) => match u16size.try_into() {
-                                Ok(size) => size,
-                                Err(_) => MAX_DATA_PACKET_PAYLOAD_SIZE,
-                            },
-                            None => MAX_DATA_PACKET_PAYLOAD_SIZE,
-                        };
-                    }
-                }
-            }
-        }
-    }
-
-    async fn handle_cmd(
-        &mut self,
-        cmd: UciManagerCmd,
-        result_sender: oneshot::Sender<Result<UciResponse>>,
-    ) {
-        debug!("Received cmd: {:?}", cmd);
-
-        match cmd {
-            UciManagerCmd::SetLoggerMode { logger_mode } => {
-                self.logger.set_logger_mode(logger_mode);
-                let _ = result_sender.send(Ok(UciResponse::SetLoggerMode));
-            }
-            UciManagerCmd::SetCoreNotificationSender { core_notf_sender } => {
-                self.core_notf_sender = core_notf_sender;
-                let _ = result_sender.send(Ok(UciResponse::SetNotification));
-            }
-            UciManagerCmd::SetSessionNotificationSender { session_notf_sender } => {
-                self.session_notf_sender = session_notf_sender;
-                let _ = result_sender.send(Ok(UciResponse::SetNotification));
-            }
-            UciManagerCmd::SetVendorNotificationSender { vendor_notf_sender } => {
-                self.vendor_notf_sender = vendor_notf_sender;
-                let _ = result_sender.send(Ok(UciResponse::SetNotification));
-            }
-            UciManagerCmd::SetDataRcvNotificationSender { data_rcv_notf_sender } => {
-                self.data_rcv_notf_sender = data_rcv_notf_sender;
-                let _ = result_sender.send(Ok(UciResponse::SetNotification));
-            }
-            UciManagerCmd::SetRadarDataRcvNotificationSender { radar_data_rcv_notf_sender } => {
-                self.radar_data_rcv_notf_sender = radar_data_rcv_notf_sender;
-                let _ = result_sender.send(Ok(UciResponse::SetNotification));
-            }
-            UciManagerCmd::SetRfTestNotificationSender { rf_test_notf_sender } => {
-                self.rf_test_notf_sender = rf_test_notf_sender;
-                let _ = result_sender.send(Ok(UciResponse::SetNotification));
-            }
-            UciManagerCmd::OpenHal => {
-                if self.is_hal_opened {
-                    warn!("The UCI HAL is already opened, skip.");
-                    let _ = result_sender.send(Err(Error::BadParameters));
-                    return;
-                }
-
-                let (packet_sender, packet_receiver) = mpsc::unbounded_channel();
-                let result = self.hal.open(packet_sender).await;
-                self.logger.log_hal_open(&result);
-                match result {
-                    Ok(()) => {
-                        self.on_hal_open(packet_receiver);
-                        self.wait_device_status_timeout =
-                            PinSleep::new(Duration::from_millis(UCI_TIMEOUT_MS));
-                        self.open_hal_result_sender.replace(result_sender);
-                    }
-                    Err(e) => {
-                        error!("Failed to open hal: {:?}", e);
-                        let _ = result_sender.send(Err(e));
-                    }
-                }
-            }
-
-            UciManagerCmd::CloseHal { force } => {
-                if force {
-                    debug!("Force closing the UCI HAL");
-                    let close_result = self.hal.close().await;
-                    self.logger.log_hal_close(&close_result);
-                    self.on_hal_closed().await;
-                    let _ = result_sender.send(Ok(UciResponse::CloseHal));
-                } else {
-                    if !self.is_hal_opened {
-                        warn!("The UCI HAL is already closed, skip.");
-                        let _ = result_sender.send(Err(Error::BadParameters));
-                        return;
-                    }
-
-                    let result = self.hal.close().await;
-                    self.logger.log_hal_close(&result);
-                    if result.is_ok() {
-                        self.on_hal_closed().await;
-                    }
-                    let _ = result_sender.send(result.map(|_| UciResponse::CloseHal));
-                }
-            }
-
-            UciManagerCmd::SendUciCommand { cmd } => {
-                debug_assert!(self.uci_cmd_retryer.is_none());
-
-                self.save_session_id_if_init_cmd(&cmd);
-
-                // Remember that this command is a raw UCI command, we'll use this later
-                // to send a raw UCI response.
-                if let UciCommand::RawUciCmd { mt: _, gid, oid, payload: _ } = cmd.clone() {
-                    let gid_u8 = u8::try_from(gid);
-                    if gid_u8.is_err() || GroupId::try_from(gid_u8.unwrap()).is_err() {
-                        error!("Received an invalid GID={} for RawUciCmd", gid);
-                        let _ = result_sender.send(Err(Error::BadParameters));
-                        return;
-                    }
-
-                    let oid_u8 = u8::try_from(oid);
-                    if oid_u8.is_err() {
-                        error!("Received an invalid OID={} for RawUciCmd", oid);
-                        let _ = result_sender.send(Err(Error::BadParameters));
-                        return;
-                    }
-                    self.last_raw_cmd = Some(RawUciControlPacket {
-                        mt: u8::from(MessageType::Command),
-                        gid: gid_u8.unwrap(), // Safe as we check gid_u8.is_err() above.
-                        oid: oid_u8.unwrap(), // Safe as we check uid_i8.is_err() above.
-                        payload: Vec::new(),  // There's no need to store the Raw UCI CMD's payload.
-                    });
-                }
-
-                if let UciCommand::SessionUpdateControllerMulticastList {
-                    session_token: _,
-                    action: _,
-                    controlees: _,
-                    is_multicast_list_ntf_v2_supported,
-                    is_multicast_list_rsp_v2_supported,
-                } = cmd.clone()
-                {
-                    self.is_multicast_list_ntf_v2_supported = is_multicast_list_ntf_v2_supported;
-                    self.is_multicast_list_rsp_v2_supported = is_multicast_list_rsp_v2_supported;
-                }
-
-                self.uci_cmd_retryer =
-                    Some(UciCmdRetryer { cmd, result_sender, retry_count: MAX_RETRY_COUNT });
-
-                // Reset DataSndRetryer so if a CORE_GENERIC_ERROR_NTF with STATUS_UCI_PACKET_RETRY
-                // is received, only this UCI CMD packet will be retried.
-                let _ = self.uci_data_snd_retryer.take();
-
-                self.retry_uci_cmd().await;
-            }
-
-            UciManagerCmd::SendUciData { data_snd_packet } => {
-                let result = self.handle_data_snd_packet(data_snd_packet).await;
-                let _ = result_sender.send(result);
-            }
-        }
-    }
-
-    async fn retry_uci_cmd(&mut self) {
-        if let Some(mut uci_cmd_retryer) = self.uci_cmd_retryer.take() {
-            if !uci_cmd_retryer.could_retry() {
-                error!("Out of retries for Uci Cmd packet");
-                uci_cmd_retryer.send_result(Err(Error::Timeout));
-                return;
-            }
-
-            match self.send_uci_command(uci_cmd_retryer.cmd.clone()).await {
-                Ok(_) => {
-                    self.wait_resp_timeout = PinSleep::new(Duration::from_millis(UCI_TIMEOUT_MS));
-                    self.uci_cmd_retryer = Some(uci_cmd_retryer);
-                }
-                Err(e) => {
-                    error!("Uci Cmd send resulted in error:{}", e);
-                    uci_cmd_retryer.send_result(Err(e));
-                }
-            }
-        }
-    }
-
-    async fn retry_uci_data_snd(&mut self) {
-        if let Some(mut uci_data_snd_retryer) = self.uci_data_snd_retryer.take() {
-            let data_packet_session_token = uci_data_snd_retryer.data_packet_session_token;
-            if !uci_data_snd_retryer.could_retry() {
-                error!(
-                    "Out of retries for Uci DataSnd packet, last DataSnd packet session_id:{}",
-                    data_packet_session_token
-                );
-                return;
-            }
-
-            match self
-                .hal
-                .send_packet(uci_data_snd_retryer.data_packet.encode_to_vec().unwrap())
-                .await
-            {
-                Ok(_) => {
-                    self.uci_data_snd_retryer = Some(uci_data_snd_retryer);
-                }
-                Err(e) => {
-                    error!(
-                        "DataSnd packet fragment session_id:{} retry failed with error:{}",
-                        data_packet_session_token, e
-                    );
-                }
-            }
-        }
-    }
-
-    async fn send_uci_command(&mut self, cmd: UciCommand) -> Result<()> {
-        if !self.is_hal_opened {
-            warn!("The UCI HAL is already closed, skip.");
-            return Err(Error::BadParameters);
-        }
-        let result = self.hal.send_command(cmd.clone()).await;
-        if result.is_ok() {
-            self.logger.log_uci_command(&cmd);
-        }
-        result
-    }
-
-    async fn handle_data_snd_packet(&mut self, data_snd_packet: UciDataSnd) -> Result<UciResponse> {
-        // Verify that there's an entry for the Session in the CreditAvailability map.
-        let data_packet_session_token = data_snd_packet.get_session_token();
-        let data_packet_sequence_number = data_snd_packet.get_uci_sequence_number();
-
-        if !self.data_credit_map.contains_key(&data_packet_session_token) {
-            error!(
-                "DataSnd packet session_token:{}, sequence_number:{} cannot be sent as unknown \
-                credit availability for the session",
-                data_packet_session_token, data_packet_sequence_number
-            );
-            return Err(Error::PacketTxError);
-        }
-
-        // Enqueue the data packet fragments, from the data packet to be sent to UWBS.
-        let mut packet_fragments: Vec<UciDataPacketHal> =
-            fragment_data_msg_send(data_snd_packet, self.max_data_packet_payload_size);
-        if packet_fragments.is_empty() {
-            error!(
-                "DataSnd packet session_token:{}, sequence number:{} could not be split into fragments",
-                data_packet_session_token, data_packet_sequence_number
-            );
-            return Err(Error::PacketTxError);
-        }
-
-        match self.data_packet_fragments_map.get_mut(&data_packet_session_token) {
-            Some(q) => {
-                for p in packet_fragments.drain(..) {
-                    q.push_back(p);
-                }
-            }
-            None => {
-                error!(
-                    "DataSnd packet fragments map not found for session_token:{}",
-                    data_packet_session_token
-                );
-                return Err(Error::PacketTxError);
-            }
-        }
-
-        self.send_data_packet_fragment(data_packet_session_token).await
-    }
-
-    async fn send_data_packet_fragment(
-        &mut self,
-        data_packet_session_token: SessionToken,
-    ) -> Result<UciResponse> {
-        // Check if a credit is available before sending this data packet fragment. If not, return
-        // for now, and send this packet later when the credit becomes available (indicated by
-        // receiving a DataCreditNtf).
-        let credit = self.data_credit_map.get(&data_packet_session_token);
-        if credit.is_none() {
-            error!(
-                "DataSnd packet fragment cannot be sent for session_token:{} as unknown \
-                credit availability for the session",
-                data_packet_session_token
-            );
-            return Err(Error::PacketTxError);
-        }
-        if credit == Some(&CreditAvailability::CreditNotAvailable) {
-            return Ok(UciResponse::SendUciData(Ok(())));
-        }
-
-        // We have credit available, let's send the packet to UWBS.
-        let hal_data_packet_fragment =
-            match self.data_packet_fragments_map.get_mut(&data_packet_session_token) {
-                Some(q) => {
-                    match q.pop_front() {
-                        Some(p) => p,
-                        None => {
-                            // No more packets left to send.
-                            return Ok(UciResponse::SendUciData(Ok(())));
-                        }
-                    }
-                }
-                None => {
-                    return Err(Error::PacketTxError);
-                }
-            };
-
-        // Create and save a retryer for sending this data packet fragment.
-        self.uci_data_snd_retryer = Some(UciDataSndRetryer {
-            data_packet: hal_data_packet_fragment.clone(),
-            data_packet_session_token,
-            retry_count: MAX_RETRY_COUNT,
-        });
-
-        let result = self.hal.send_packet(hal_data_packet_fragment.encode_to_vec().unwrap()).await;
-        if result.is_err() {
-            error!(
-                "Result {:?} of sending data packet fragment SessionToken: {} to HAL",
-                result, data_packet_session_token
-            );
-            return Err(Error::PacketTxError);
-        }
-
-        // Update the map after the successful write.
-        self.data_credit_map
-            .insert(data_packet_session_token, CreditAvailability::CreditNotAvailable);
-        Ok(UciResponse::SendUciData(Ok(())))
-    }
-
-    async fn handle_hal_packet(&mut self, packet: Option<UciHalPacket>) {
-        let defrag_packet = match packet {
-            Some(rx_packet) => {
-                self.defrager.defragment_packet(&rx_packet, self.last_raw_cmd.clone())
-            }
-            None => {
-                warn!("UciHal dropped the packet_sender unexpectedly.");
-                self.on_hal_closed().await;
-                return;
-            }
-        };
-        let defrag_packet = match defrag_packet {
-            Some(p) => p,
-            None => return,
-        };
-
-        match defrag_packet {
-            UciDefragPacket::Control(packet) => {
-                self.logger.log_uci_response_or_notification(&packet);
-
-                // Use a safe value of Fira 1.x as the UWBS UCI version.
-                let uci_fira_major_version = self.get_uwbs_uci_major_version().unwrap_or(1);
-                match (
-                    packet,
-                    UCIMajorVersion::from_u8(uci_fira_major_version)
-                        .map_or(UCIMajorVersion::V1, |v| v),
-                    self.is_multicast_list_ntf_v2_supported,
-                    self.is_multicast_list_rsp_v2_supported,
-                )
-                    .try_into()
-                {
-                    Ok(UciMessage::Response(resp)) => {
-                        self.handle_response(resp).await;
-                    }
-                    Ok(UciMessage::Notification(notf)) => {
-                        self.handle_notification(notf).await;
-                    }
-                    Err(e) => {
-                        error!("Failed to parse received message: {:?}", e);
-                    }
-                }
-            }
-            UciDefragPacket::Data(packet) => {
-                self.logger.log_uci_data(&packet);
-                self.handle_data_rcv(packet).await;
-            }
-            UciDefragPacket::Raw(result, raw_uci_control_packet) => {
-                // Handle response to raw UCI cmd. We want to send it back as
-                // raw UCI message instead of standard response message.
-                let resp = match result {
-                    Ok(()) => {
-                        // We should receive only a valid UCI response packet here.
-                        UciResponse::RawUciCmd(Ok(RawUciMessage {
-                            gid: raw_uci_control_packet.gid.into(),
-                            oid: raw_uci_control_packet.oid.into(),
-                            payload: raw_uci_control_packet.payload,
-                        }))
-                    }
-                    // TODO: Implement conversion between Error::InvalidPacketError (returned by
-                    // lib.rs and defined in the PDL uci_packets.rs) and the uwb_core::Error enums.
-                    Err(_) => UciResponse::RawUciCmd(Err(Error::Unknown)),
-                };
-                self.handle_response(resp).await;
-                self.last_raw_cmd = None;
-            }
-        }
-    }
-
-    async fn handle_response(&mut self, resp: UciResponse) {
-        if resp.need_retry() {
-            self.retry_uci_cmd().await;
-            return;
-        }
-
-        if let Err(_e) = self.store_session_token_if_init_resp(&resp).await {
-            error!("Session init response received without a sesson id stored! Something has gone badly wrong: {:?}", resp);
-            return;
-        }
-        self.store_if_uwbs_device_info(&resp);
-        self.store_if_uwbs_caps_info(&resp);
-
-        if let Some(uci_cmd_retryer) = self.uci_cmd_retryer.take() {
-            uci_cmd_retryer.send_result(Ok(resp));
-        } else {
-            warn!("Received an UCI response unexpectedly: {:?}", resp);
-        }
-    }
-
-    async fn handle_notification(&mut self, notf: UciNotification) {
-        if notf.need_retry() {
-            // Retry sending both last sent UCI CMD and UCI DataSnd packet since the notification
-            // could be for either of them.
-            self.retry_uci_cmd().await;
-            self.retry_uci_data_snd().await;
-            return;
-        }
-
-        match notf {
-            UciNotification::Core(core_notf) => {
-                if let CoreNotification::DeviceStatus(status) = core_notf {
-                    if let Some(result_sender) = self.open_hal_result_sender.take() {
-                        let result = match status {
-                            DeviceState::DeviceStateReady | DeviceState::DeviceStateActive => {
-                                Ok(UciResponse::OpenHal)
-                            }
-                            _ => Err(Error::Unknown),
-                        };
-                        let _ = result_sender.send(result);
-                    }
-                }
-                let _ = self.core_notf_sender.send(core_notf);
-            }
-            UciNotification::Session(orig_session_notf) => {
-                let mod_session_notf = {
-                    match self.add_session_id_to_session_status_ntf(orig_session_notf.clone()).await
-                    {
-                        Ok(session_notf) => session_notf,
-                        Err(e) => {
-                            error!("Failed to find corresponding session id, discarding session notification {:?}: {:?}", orig_session_notf, e);
-                            return;
-                        }
-                    }
-                };
-                match orig_session_notf {
-                    SessionNotification::Status {
-                        session_id: _,
-                        session_token,
-                        session_state,
-                        reason_code: _,
-                    } => self.handle_session_state_notification(session_token, session_state).await,
-                    SessionNotification::DataCredit { session_token, credit_availability } => {
-                        if !self.data_credit_map.contains_key(&session_token) {
-                            // Currently just log, as this is unexpected (the entry should exist once
-                            // the ranging session is Active and be removed once it is Idle).
-                            debug!(
-                                "Received a DataCreditNtf for non-existent session_token: {}",
-                                session_token
-                            );
-                        }
-                        self.data_credit_map.insert(session_token, credit_availability);
-                        if credit_availability == CreditAvailability::CreditAvailable {
-                            if let Err(e) = self.send_data_packet_fragment(session_token).await {
-                                error!(
-                                    "Sending data packet fragment failed with Err:{}, after a\
-                                   DataCreditNtf is received, for session_token:{}",
-                                    e, session_token
-                                );
-                            }
-                        } else {
-                            // Log as this should usually not happen (it's not an error).
-                            debug!(
-                            "Received a DataCreditNtf with no credit available for session_token:{}",
-                            session_token
-                        );
-                        }
-                        return; // We consume these here and don't need to send to upper layer.
-                    }
-                    SessionNotification::DataTransferStatus {
-                        session_token: _,
-                        uci_sequence_number: _,
-                        status: _,
-                        tx_count: _,
-                    } => {
-                        // Reset the UciDataSnd Retryer since we received a DataTransferStatusNtf.
-                        let _ = self.uci_data_snd_retryer.take();
-                    }
-                    _ => {}
-                }
-                let _ = self.session_notf_sender.send(mod_session_notf);
-            }
-            UciNotification::RfTest(rftest_notf) => {
-                let _ = self.rf_test_notf_sender.send(rftest_notf);
-            }
-            UciNotification::Vendor(vendor_notf) => {
-                let _ = self.vendor_notf_sender.send(vendor_notf);
-            }
-        }
-    }
-
-    // Modify session_token field in all session related notifications with session id.
-    // TODO: Sharing of structs across UCI (PDL) & JNI layer like this makes this ugly. Ideally
-    // the struct sent to JNI layer should only contain |session_id| and at uci layer
-    // it could be |session_id| or |session_handle|.
-    async fn add_session_id_to_session_status_ntf(
-        &self,
-        session_notification: SessionNotification,
-    ) -> Result<SessionNotification> {
-        match session_notification {
-            SessionNotification::Status {
-                session_id: _,
-                session_token,
-                session_state,
-                reason_code,
-            } => Ok(SessionNotification::Status {
-                session_id: self.get_session_id(&session_token).await?,
-                session_token,
-                session_state,
-                reason_code,
-            }),
-            SessionNotification::UpdateControllerMulticastListV1 {
-                session_token,
-                remaining_multicast_list_size,
-                status_list,
-            } => Ok(SessionNotification::UpdateControllerMulticastListV1 {
-                session_token: self.get_session_id(&session_token).await?,
-                remaining_multicast_list_size,
-                status_list,
-            }),
-            SessionNotification::UpdateControllerMulticastListV2 { session_token, status_list } => {
-                Ok(SessionNotification::UpdateControllerMulticastListV2 {
-                    session_token: self.get_session_id(&session_token).await?,
-                    status_list,
-                })
-            }
-            SessionNotification::SessionInfo(session_range_data) => {
-                Ok(SessionNotification::SessionInfo(SessionRangeData {
-                    sequence_number: session_range_data.sequence_number,
-                    session_token: self.get_session_id(&session_range_data.session_token).await?,
-                    current_ranging_interval_ms: session_range_data.current_ranging_interval_ms,
-                    ranging_measurement_type: session_range_data.ranging_measurement_type,
-                    hus_primary_session_id: session_range_data.hus_primary_session_id,
-                    ranging_measurements: session_range_data.ranging_measurements,
-                    rcr_indicator: session_range_data.rcr_indicator,
-                    raw_ranging_data: session_range_data.raw_ranging_data,
-                }))
-            }
-            SessionNotification::DataTransferStatus {
-                session_token,
-                uci_sequence_number,
-                status,
-                tx_count,
-            } => Ok(SessionNotification::DataTransferStatus {
-                session_token: self.get_session_id(&session_token).await?,
-                uci_sequence_number,
-                status,
-                tx_count,
-            }),
-            SessionNotification::DataCredit { session_token, credit_availability } => {
-                Ok(SessionNotification::DataCredit {
-                    session_token: self.get_session_id(&session_token).await?,
-                    credit_availability,
-                })
-            }
-            SessionNotification::DataTransferPhaseConfig { session_token, status } => {
-                Ok(SessionNotification::DataTransferPhaseConfig {
-                    session_token: self.get_session_id(&session_token).await?,
-                    status,
-                })
-            }
-        }
-    }
-
-    async fn handle_session_state_notification(
-        &mut self,
-        session_token: SessionToken,
-        session_state: SessionState,
-    ) {
-        match session_state {
-            SessionState::SessionStateInit => {
-                if let Err(e) = self.hal.notify_session_initialized(session_token).await {
-                    warn!("notify_session_initialized() failed: {:?}", e);
-                }
-            }
-            SessionState::SessionStateActive => {
-                self.data_credit_map.insert(session_token, CreditAvailability::CreditAvailable);
-                self.data_packet_fragments_map.insert(session_token, VecDeque::new());
-            }
-            SessionState::SessionStateIdle => {
-                self.data_credit_map.remove(&session_token);
-                self.data_packet_fragments_map.remove(&session_token);
-            }
-            SessionState::SessionStateDeinit => {
-                self.remove_session_token(&session_token).await;
-            }
-        }
-    }
-
-    async fn handle_data_rcv(&mut self, packet: UciDataPacket) {
-        if let Ok(data) = DataRcvNotification::try_from(packet.clone()) {
-            match self.get_session_id(&data.session_token).await {
-                Ok(session_id) => {
-                    let _ = self.data_rcv_notf_sender.send(DataRcvNotification {
-                        session_token: session_id,
-                        status: data.status,
-                        uci_sequence_num: data.uci_sequence_num,
-                        source_address: data.source_address,
-                        payload: data.payload,
-                    });
-                }
-                Err(e) => {
-                    error!("Unable to find session Id, error {:?}", e);
-                }
-            }
-        } else if let Ok(data) = RadarDataRcvNotification::try_from(packet.clone()) {
-            match self.get_session_id(&data.session_token).await {
-                Ok(session_id) => {
-                    let _ = self.radar_data_rcv_notf_sender.send(RadarDataRcvNotification {
-                        session_token: session_id,
-                        status: data.status,
-                        radar_data_type: data.radar_data_type,
-                        number_of_sweeps: data.number_of_sweeps,
-                        samples_per_sweep: data.samples_per_sweep,
-                        bits_per_sample: data.bits_per_sample,
-                        sweep_offset: data.sweep_offset,
-                        sweep_data: data.sweep_data,
-                    });
-                }
-                Err(e) => {
-                    error!("Unable to find session Id, error {:?}", e);
-                }
-            }
-        } else {
-            error!("Unable to parse incoming Data packet, packet {:?}", packet);
-        }
-    }
-
-    fn on_hal_open(&mut self, packet_receiver: mpsc::UnboundedReceiver<UciHalPacket>) {
-        self.is_hal_opened = true;
-        self.packet_receiver = packet_receiver;
-    }
-
-    async fn on_hal_closed(&mut self) {
-        self.session_id_to_token_map.lock().await.clear();
-        self.is_hal_opened = false;
-        self.packet_receiver = mpsc::unbounded_channel().1;
-        self.last_raw_cmd = None;
-    }
-
-    fn is_waiting_resp(&self) -> bool {
-        self.uci_cmd_retryer.is_some()
-    }
-    fn is_waiting_device_status(&self) -> bool {
-        self.open_hal_result_sender.is_some()
-    }
-}
-
-impl<T: UciHal, U: UciLogger> Drop for UciManagerActor<T, U> {
-    fn drop(&mut self) {
-        // mpsc receiver is about to be dropped. Clean shutdown the mpsc message.
-        clean_mpsc_receiver(&mut self.packet_receiver);
-    }
-}
-
-struct UciCmdRetryer {
-    cmd: UciCommand,
-    result_sender: oneshot::Sender<Result<UciResponse>>,
-    retry_count: usize,
-}
-
-impl UciCmdRetryer {
-    fn could_retry(&mut self) -> bool {
-        if self.retry_count == 0 {
-            return false;
-        }
-        self.retry_count -= 1;
-        true
-    }
-
-    fn send_result(self, result: Result<UciResponse>) {
-        let _ = self.result_sender.send(result);
-    }
-}
-
-struct UciDataSndRetryer {
-    // Store the last-sent DataSnd packet fragment across all the active UWB session, as the UCI
-    // spec states that the "last UCI packet should be re-transmitted from Host".
-    //
-    // TODO(b/273376343): The spec is open to a race condition in the scenario of multiple active
-    // sessions, as there can be outstanding DataSnd packet fragments across them. We could do an
-    // alternative implementation of sending all of them.
-    data_packet: UciDataPacketHal,
-    data_packet_session_token: SessionToken,
-    retry_count: usize,
-}
-
-impl UciDataSndRetryer {
-    fn could_retry(&mut self) -> bool {
-        if self.retry_count == 0 {
-            return false;
-        }
-        self.retry_count -= 1;
-        true
-    }
-}
-
-#[derive(Debug)]
-enum UciManagerCmd {
-    SetLoggerMode {
-        logger_mode: UciLoggerMode,
-    },
-    SetCoreNotificationSender {
-        core_notf_sender: mpsc::UnboundedSender<CoreNotification>,
-    },
-    SetSessionNotificationSender {
-        session_notf_sender: mpsc::UnboundedSender<SessionNotification>,
-    },
-    SetVendorNotificationSender {
-        vendor_notf_sender: mpsc::UnboundedSender<RawUciMessage>,
-    },
-    SetDataRcvNotificationSender {
-        data_rcv_notf_sender: mpsc::UnboundedSender<DataRcvNotification>,
-    },
-    SetRadarDataRcvNotificationSender {
-        radar_data_rcv_notf_sender: mpsc::UnboundedSender<RadarDataRcvNotification>,
-    },
-    SetRfTestNotificationSender {
-        rf_test_notf_sender: mpsc::UnboundedSender<RfTestNotification>,
-    },
-    OpenHal,
-    CloseHal {
-        force: bool,
-    },
-    SendUciCommand {
-        cmd: UciCommand,
-    },
-    SendUciData {
-        data_snd_packet: UciDataSnd,
-    },
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    use bytes::Bytes;
-    use pdl_runtime::Packet;
-    use tokio::macros::support::Future;
-    use uwb_uci_packets::{
-        Controlee_V2_0_16_Byte_Version, Controlee_V2_0_32_Byte_Version, SessionGetCountCmdBuilder,
-        SessionGetCountRspBuilder,
-    };
-
-    use crate::params::uci_packets::{
-        AppConfigStatus, AppConfigTlvType, BitsPerSample, CapTlvType, Controlee, DataRcvStatusCode,
-        DataTransferNtfStatusCode, RadarDataType, RfTestConfigTlvType, StatusCode,
-    };
-    use crate::params::UwbAddress;
-    use crate::uci::mock_uci_hal::MockUciHal;
-    use crate::uci::mock_uci_logger::{MockUciLogger, UciLogEvent};
-    use crate::uci::notification::CoreNotification;
-    use crate::uci::notification::RadarSweepData;
-    use crate::uci::uci_logger::NopUciLogger;
-    use crate::utils::init_test_logging;
-    use bytes::{BufMut, BytesMut};
-    use uwb_uci_packets::ControleeStatusV2;
-    use uwb_uci_packets::SessionUpdateControllerMulticastListRspV1Payload;
-    use uwb_uci_packets::SessionUpdateControllerMulticastListRspV2Payload;
-
-    fn into_uci_hal_packets<T: Into<uwb_uci_packets::UciControlPacket>>(
-        builder: T,
-    ) -> Vec<UciHalPacket> {
-        let packets: Vec<uwb_uci_packets::UciControlPacketHal> = builder.into().into();
-        packets.into_iter().map(|packet| packet.encode_to_vec().unwrap()).collect()
-    }
-
-    // Construct a UCI packet, with the header fields and payload bytes.
-    fn build_uci_packet(mt: u8, pbf: u8, gid: u8, oid: u8, mut payload: Vec<u8>) -> Vec<u8> {
-        let len: u16 = payload.len() as u16;
-        let mut bytes: Vec<u8> = vec![(mt & 0x7) << 5 | (pbf & 0x1) << 4 | (gid & 0xF), oid & 0x3F];
-        if mt == 0 {
-            // UCI Data packet
-            // Store 16-bit payload length in LSB format.
-            bytes.push((len & 0xFF).try_into().unwrap());
-            bytes.push((len >> 8).try_into().unwrap());
-        } else {
-            // One byte RFU, followed by one-byte payload length.
-            bytes.push(0);
-            bytes.push((len & 0xFF).try_into().unwrap());
-        }
-        bytes.append(&mut payload);
-        bytes
-    }
-
-    fn setup_hal_for_open(hal: &mut MockUciHal) {
-        // Setup Open the hal.
-        let notf = into_uci_hal_packets(uwb_uci_packets::DeviceStatusNtfBuilder {
-            device_state: uwb_uci_packets::DeviceState::DeviceStateReady,
-        });
-        hal.expected_open(Some(notf), Ok(()));
-
-        // Setup Get the device info.
-        let cmd = UciCommand::CoreGetDeviceInfo;
-        let resp = into_uci_hal_packets(uwb_uci_packets::GetDeviceInfoRspBuilder {
-            status: uwb_uci_packets::StatusCode::UciStatusOk,
-            uci_version: 0x1234,
-            mac_version: 0x5678,
-            phy_version: 0x90ab,
-            uci_test_version: 0x1357,
-            vendor_spec_info: vec![0x1, 0x2],
-        });
-        hal.expected_send_command(cmd, resp, Ok(()));
-    }
-
-    async fn setup_uci_manager_with_open_hal<F, Fut>(
-        setup_hal_fn: F,
-        uci_logger_mode: UciLoggerMode,
-        log_sender: mpsc::UnboundedSender<UciLogEvent>,
-    ) -> (UciManagerImpl, MockUciHal)
-    where
-        F: FnOnce(MockUciHal) -> Fut,
-        Fut: Future<Output = ()>,
-    {
-        init_test_logging();
-
-        let mut hal = MockUciHal::new();
-        // Open the hal.
-        setup_hal_for_open(&mut hal);
-
-        // Verify open_hal() is working.
-        let uci_manager =
-            UciManagerImpl::new(hal.clone(), MockUciLogger::new(log_sender), uci_logger_mode);
-        let result = uci_manager.open_hal().await;
-        assert!(result.is_ok());
-        assert!(hal.wait_expected_calls_done().await);
-
-        setup_hal_fn(hal.clone()).await;
-
-        (uci_manager, hal)
-    }
-
-    async fn setup_uci_manager_with_open_hal_nop_logger<F, Fut>(
-        setup_hal_fn: F,
-        uci_logger_mode: UciLoggerMode,
-    ) -> (UciManagerImpl, MockUciHal)
-    where
-        F: FnOnce(MockUciHal) -> Fut,
-        Fut: Future<Output = ()>,
-    {
-        init_test_logging();
-
-        let mut hal = MockUciHal::new();
-        // Open the hal.
-        setup_hal_for_open(&mut hal);
-
-        // Verify open_hal() is working.
-        let uci_manager =
-            UciManagerImpl::new(hal.clone(), NopUciLogger::default(), uci_logger_mode);
-        let result = uci_manager.open_hal().await;
-        assert!(result.is_ok());
-        assert!(hal.wait_expected_calls_done().await);
-
-        setup_hal_fn(hal.clone()).await;
-
-        (uci_manager, hal)
-    }
-
-    #[tokio::test]
-    async fn test_open_hal_without_notification() {
-        init_test_logging();
-
-        let mut hal = MockUciHal::new();
-        hal.expected_open(None, Ok(()));
-        let uci_manager =
-            UciManagerImpl::new(hal.clone(), NopUciLogger::default(), UciLoggerMode::Disabled);
-
-        let result = uci_manager.open_hal().await;
-        assert!(matches!(result, Err(Error::Timeout)));
-        assert!(hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_close_hal_explicitly() {
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                hal.expected_close(Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let result = uci_manager.close_hal(false).await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_close_hal_when_exit() {
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                // UciManager should close the hal if the hal is still opened when exit.
-                hal.expected_close(Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        drop(uci_manager);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_close_hal_without_open_hal() {
-        init_test_logging();
-
-        let mut hal = MockUciHal::new();
-        let uci_manager =
-            UciManagerImpl::new(hal.clone(), NopUciLogger::default(), UciLoggerMode::Disabled);
-
-        let result = uci_manager.close_hal(false).await;
-        assert!(matches!(result, Err(Error::BadParameters)));
-        assert!(hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_device_reset_ok() {
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::DeviceReset { reset_config: ResetConfig::UwbsReset };
-                let resp = into_uci_hal_packets(uwb_uci_packets::DeviceResetRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                });
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let result = uci_manager.device_reset(ResetConfig::UwbsReset).await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_priority_device_status_error_ntf() {
-        // Send DEVICE_STATE_ERROR notification while waiting for remaining fragments,
-        // verify that notification is processed on priority without waiting for the
-        // further fragmen
-        let mt: u8 = 0x3;
-        let pbf_not_set: u8 = 0x00;
-        let gid_core: u8 = 0x0;
-        let oid_device_status: u8 = 0x1;
-        let payload_1 = vec![0xFF];
-        let pbf_set: u8 = 0x1;
-        let gid_session: u8 = 0x02;
-        let oid_session_ntf: u8 = 0x03;
-        let payload_range_dat = vec![0, 251];
-        let dev_state_err_packet =
-            build_uci_packet(mt, pbf_not_set, gid_core, oid_device_status, payload_1);
-        let range_data_ntf_packet =
-            build_uci_packet(mt, pbf_set, gid_session, oid_session_ntf, payload_range_dat);
-        let (mut uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |_| async move {},
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let (session_notification_sender, mut session_notification_receiver) =
-            mpsc::unbounded_channel::<SessionNotification>();
-        uci_manager.set_session_notification_sender(session_notification_sender).await;
-        let result = mock_hal.receive_packet(range_data_ntf_packet);
-        assert!(result.is_ok());
-
-        let device_status_ntf_packet = uwb_uci_packets::DeviceStatusNtfBuilder {
-            device_state: uwb_uci_packets::DeviceState::DeviceStateError,
-        }
-        .build();
-        let core_notification =
-            uwb_uci_packets::CoreNotification::try_from(device_status_ntf_packet).unwrap();
-        let expected_uci_notification = CoreNotification::try_from(core_notification).unwrap();
-
-        let (core_notification_sender, mut core_notification_receiver) =
-            mpsc::unbounded_channel::<CoreNotification>();
-        uci_manager.set_core_notification_sender(core_notification_sender).await;
-
-        let result = mock_hal.receive_packet(dev_state_err_packet);
-        assert!(result.is_ok());
-
-        let result =
-            tokio::time::timeout(Duration::from_millis(100), core_notification_receiver.recv())
-                .await;
-        assert!(result.is_ok());
-        assert_eq!(result.unwrap(), Some(expected_uci_notification));
-        assert!(mock_hal.wait_expected_calls_done().await);
-
-        // DEVICE_STATE_ERROR is received in middle while waiting for the fragmented packet,
-        // no fragmented packet will be processed
-        assert!(session_notification_receiver.try_recv().is_err());
-    }
-
-    #[tokio::test]
-    async fn test_core_get_device_info_ok() {
-        let status = StatusCode::UciStatusOk;
-        let uci_version = 0x1234;
-        let mac_version = 0x5678;
-        let phy_version = 0x90ab;
-        let uci_test_version = 0x1357;
-        let vendor_spec_info = vec![0x1, 0x2];
-        let vendor_spec_info_clone = vendor_spec_info.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::CoreGetDeviceInfo;
-                let resp = into_uci_hal_packets(uwb_uci_packets::GetDeviceInfoRspBuilder {
-                    status,
-                    uci_version,
-                    mac_version,
-                    phy_version,
-                    uci_test_version,
-                    vendor_spec_info: vendor_spec_info_clone,
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let expected_result = GetDeviceInfoResponse {
-            status,
-            uci_version,
-            mac_version,
-            phy_version,
-            uci_test_version,
-            vendor_spec_info,
-        };
-        let result = uci_manager.core_get_device_info().await.unwrap();
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_core_get_caps_info_fira_v1_0_ok() {
-        let tlv = CapTlv {
-            t: CapTlvType::SupportedV1FiraPhyVersionRangeV2MaxMessageSize,
-            v: vec![0x12, 0x34, 0x56],
-        };
-        let tlv_clone = tlv.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::CoreGetCapsInfo;
-                let resp = into_uci_hal_packets(uwb_uci_packets::GetCapsInfoRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    tlvs: vec![tlv_clone],
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let result = uci_manager.core_get_caps_info().await.unwrap();
-        assert_eq!(result[0], tlv);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_core_set_config_ok() {
-        let tlv = DeviceConfigTlv {
-            cfg_id: uwb_uci_packets::DeviceConfigId::DeviceState,
-            v: vec![0x12, 0x34, 0x56],
-        };
-        let tlv_clone = tlv.clone();
-        let status = StatusCode::UciStatusOk;
-        let config_status = vec![];
-        let config_status_clone = config_status.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::CoreSetConfig { config_tlvs: vec![tlv_clone] };
-                let resp = into_uci_hal_packets(uwb_uci_packets::SetConfigRspBuilder {
-                    status,
-                    cfg_status: config_status_clone,
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let expected_result = CoreSetConfigResponse { status, config_status };
-        let result = uci_manager.core_set_config(vec![tlv]).await.unwrap();
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_core_get_config_ok() {
-        let cfg_id = DeviceConfigId::DeviceState;
-        let tlv = DeviceConfigTlv { cfg_id, v: vec![0x12, 0x34, 0x56] };
-        let tlv_clone = tlv.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::CoreGetConfig { cfg_id: vec![cfg_id] };
-                let resp = into_uci_hal_packets(uwb_uci_packets::GetConfigRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    tlvs: vec![tlv_clone],
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let expected_result = vec![tlv];
-        let result = uci_manager.core_get_config(vec![cfg_id]).await.unwrap();
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    fn setup_hal_for_session_initialize(
-        hal: &mut MockUciHal,
-        session_type: SessionType,
-        session_id: u32,
-        session_token: u32,
-    ) {
-        // Setup for hal open.
-        setup_hal_for_open(hal);
-
-        // Setup session init.
-        let cmd = UciCommand::SessionInit { session_id, session_type };
-        let mut resp = if session_id == session_token {
-            into_uci_hal_packets(uwb_uci_packets::SessionInitRspBuilder {
-                status: uwb_uci_packets::StatusCode::UciStatusOk,
-            })
-        } else {
-            // This is testing FIRA v2 flow where a session handle is provided by UWBS.
-            into_uci_hal_packets(uwb_uci_packets::SessionInitRsp_V2Builder {
-                status: uwb_uci_packets::StatusCode::UciStatusOk,
-                session_handle: session_token,
-            })
-        };
-        let mut notf = into_uci_hal_packets(uwb_uci_packets::SessionStatusNtfBuilder {
-            session_token,
-            session_state: uwb_uci_packets::SessionState::SessionStateInit,
-            reason_code: uwb_uci_packets::ReasonCode::StateChangeWithSessionManagementCommands
-                .into(),
-        });
-        resp.append(&mut notf);
-        hal.expected_send_command(cmd, resp, Ok(()));
-        hal.expected_notify_session_initialized(session_token, Ok(()));
-    }
-
-    async fn setup_uci_manager_with_session_initialized<F, Fut>(
-        setup_hal_fn: F,
-        uci_logger_mode: UciLoggerMode,
-        log_sender: mpsc::UnboundedSender<UciLogEvent>,
-        session_id: u32,
-        session_token: u32,
-    ) -> (UciManagerImpl, MockUciHal)
-    where
-        F: FnOnce(MockUciHal) -> Fut,
-        Fut: Future<Output = ()>,
-    {
-        let session_type = SessionType::FiraRangingSession;
-
-        init_test_logging();
-
-        let mut hal = MockUciHal::new();
-        setup_hal_for_session_initialize(&mut hal, session_type, session_id, session_token);
-
-        // Verify open_hal() is working.
-        let uci_manager =
-            UciManagerImpl::new(hal.clone(), MockUciLogger::new(log_sender), uci_logger_mode);
-        let result = uci_manager.open_hal().await;
-        assert!(result.is_ok());
-
-        // Verify session is initialized.
-        let result = uci_manager.session_init(session_id, session_type).await;
-        assert!(result.is_ok());
-        assert!(hal.wait_expected_calls_done().await);
-
-        setup_hal_fn(hal.clone()).await;
-
-        (uci_manager, hal)
-    }
-
-    async fn setup_uci_manager_with_session_initialized_nop_logger<F, Fut>(
-        setup_hal_fn: F,
-        uci_logger_mode: UciLoggerMode,
-        session_id: u32,
-        session_token: u32,
-    ) -> (UciManagerImpl, MockUciHal)
-    where
-        F: FnOnce(MockUciHal) -> Fut,
-        Fut: Future<Output = ()>,
-    {
-        let session_type = SessionType::FiraRangingSession;
-
-        init_test_logging();
-
-        let mut hal = MockUciHal::new();
-        setup_hal_for_session_initialize(&mut hal, session_type, session_id, session_token);
-
-        // Verify open_hal() is working.
-        let uci_manager =
-            UciManagerImpl::new(hal.clone(), NopUciLogger::default(), uci_logger_mode);
-        let result = uci_manager.open_hal().await;
-        assert!(result.is_ok());
-
-        // Verify session is initialized.
-        let result = uci_manager.session_init(session_id, session_type).await;
-        assert!(result.is_ok());
-        assert!(hal.wait_expected_calls_done().await);
-
-        setup_hal_fn(hal.clone()).await;
-
-        (uci_manager, hal)
-    }
-
-    #[tokio::test]
-    async fn test_session_init_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let (_, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |_hal| async move {},
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_init_v2_ok() {
-        let session_id = 0x123;
-        let session_token = 0x321; // different session handle
-        let (_, mut mock_hal) = setup_uci_manager_with_session_initialized_nop_logger(
-            |_hal| async move {},
-            UciLoggerMode::Disabled,
-            session_id,
-            session_token,
-        )
-        .await;
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_deinit_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionDeinit { session_token };
-                let resp = into_uci_hal_packets(uwb_uci_packets::SessionDeinitRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager.session_deinit(session_id).await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_deinit_v2_ok() {
-        let session_id = 0x123;
-        let session_token = 0x321; // different session handle
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized_nop_logger(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionDeinit { session_token };
-                let resp = into_uci_hal_packets(uwb_uci_packets::SessionDeinitRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager.session_deinit(session_id).await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_set_app_config_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let config_tlv = AppConfigTlv::new(AppConfigTlvType::DeviceType, vec![0x12, 0x34, 0x56]);
-        let config_tlv_clone = config_tlv.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionSetAppConfig {
-                    session_token,
-                    config_tlvs: vec![config_tlv_clone],
-                };
-                let resp = into_uci_hal_packets(uwb_uci_packets::SessionSetAppConfigRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    cfg_status: vec![],
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let expected_result =
-            SetAppConfigResponse { status: StatusCode::UciStatusOk, config_status: vec![] };
-        let result =
-            uci_manager.session_set_app_config(session_id, vec![config_tlv]).await.unwrap();
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_set_app_config_v2_ok() {
-        let session_id = 0x123;
-        let session_token = 0x321;
-        let config_tlv = AppConfigTlv::new(AppConfigTlvType::DeviceType, vec![0x12, 0x34, 0x56]);
-        let config_tlv_clone = config_tlv.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized_nop_logger(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionSetAppConfig {
-                    session_token,
-                    config_tlvs: vec![config_tlv_clone],
-                };
-                let resp = into_uci_hal_packets(uwb_uci_packets::SessionSetAppConfigRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    cfg_status: vec![],
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let expected_result =
-            SetAppConfigResponse { status: StatusCode::UciStatusOk, config_status: vec![] };
-        let result =
-            uci_manager.session_set_app_config(session_id, vec![config_tlv]).await.unwrap();
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_get_app_config_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let config_id = AppConfigTlvType::DeviceType;
-        let tlv = AppConfigTlv::new(AppConfigTlvType::DeviceType, vec![0x12, 0x34, 0x56]);
-        let tlv_clone = tlv.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |mut hal| async move {
-                let cmd =
-                    UciCommand::SessionGetAppConfig { session_token, app_cfg: vec![config_id] };
-                let resp = into_uci_hal_packets(uwb_uci_packets::SessionGetAppConfigRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    tlvs: vec![tlv_clone.into_inner()],
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let expected_result = vec![tlv];
-        let result = uci_manager.session_get_app_config(session_id, vec![config_id]).await.unwrap();
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_set_hybrid_controller_config_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let number_of_phases = 0x02;
-        let phase_list_short_mac_address = vec![
-            uwb_uci_packets::ControllerPhaseList {
-                session_token: 0x11,
-                start_slot_index: 0x12,
-                end_slot_index: 0x13,
-                control: 0x01,
-                mac_address: [0x11, 0x22].to_vec(),
-            },
-            uwb_uci_packets::ControllerPhaseList {
-                session_token: 0x21,
-                start_slot_index: 0x22,
-                end_slot_index: 0x23,
-                control: 0x01,
-                mac_address: [0x11, 0x33].to_vec(),
-            },
-        ];
-        let phase_list_extended_mac_address = vec![
-            uwb_uci_packets::ControllerPhaseList {
-                session_token: 0x11,
-                start_slot_index: 0x12,
-                end_slot_index: 0x13,
-                control: 0x01,
-                mac_address: [0x11, 0x22, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38].to_vec(),
-            },
-            uwb_uci_packets::ControllerPhaseList {
-                session_token: 0x21,
-                start_slot_index: 0x22,
-                end_slot_index: 0x23,
-                control: 0x01,
-                mac_address: [0x11, 0x22, 0x33, 0x34, 0x35, 0x36, 0x37, 0x39].to_vec(),
-            },
-        ];
-        let phase_list_clone_short = phase_list_short_mac_address.clone();
-
-        // short mac address
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_active(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionSetHybridControllerConfig {
-                    session_token,
-                    number_of_phases,
-                    phase_list: phase_list_clone_short,
-                };
-                let resp = into_uci_hal_packets(
-                    uwb_uci_packets::SessionSetHybridControllerConfigRspBuilder {
-                        status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    },
-                );
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager
-            .session_set_hybrid_controller_config(
-                session_token,
-                number_of_phases,
-                phase_list_short_mac_address,
-            )
-            .await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-
-        // extended mac address
-        let phase_list_clone_extended = phase_list_extended_mac_address.clone();
-        //phase_list_clone.clone_from(&phase_list_extended_mac_address);
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_active(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionSetHybridControllerConfig {
-                    session_token,
-                    number_of_phases,
-                    phase_list: phase_list_clone_extended,
-                };
-                let resp = into_uci_hal_packets(
-                    uwb_uci_packets::SessionSetHybridControllerConfigRspBuilder {
-                        status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    },
-                );
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager
-            .session_set_hybrid_controller_config(
-                session_token,
-                number_of_phases,
-                phase_list_extended_mac_address,
-            )
-            .await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_set_hybrid_controlee_config_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let phase_list = vec![
-            ControleePhaseList { session_token: 0x12 },
-            ControleePhaseList { session_token: 0x14 },
-        ];
-        let phase_list_clone = phase_list.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_active(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionSetHybridControleeConfig {
-                    session_token,
-                    controlee_phase_list: phase_list_clone,
-                };
-                let resp = into_uci_hal_packets(
-                    uwb_uci_packets::SessionSetHybridControleeConfigRspBuilder {
-                        status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    },
-                );
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result =
-            uci_manager.session_set_hybrid_controlee_config(session_token, phase_list).await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_data_transfer_phase_config_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let dtpcm_repetition = 0x00;
-        let data_transfer_control = 0x00;
-        let dtpml_size = 0x02;
-        let mac_address = vec![0x22, 0x11, 0x44, 0x33];
-        let slot_bitmap = vec![0xF0, 0x0F];
-        let stop_data_transfer = vec![0x00, 0x01];
-        let mac_address_clone = mac_address.clone();
-        let slot_bitmap_clone = slot_bitmap.clone();
-        let stop_data_transfer_clone = stop_data_transfer.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_active(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionDataTransferPhaseConfig {
-                    session_token,
-                    dtpcm_repetition,
-                    data_transfer_control,
-                    dtpml_size,
-                    mac_address,
-                    slot_bitmap,
-                    stop_data_transfer,
-                };
-                let resp = into_uci_hal_packets(
-                    uwb_uci_packets::SessionDataTransferPhaseConfigRspBuilder {
-                        status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    },
-                );
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager
-            .session_data_transfer_phase_config(
-                session_token,
-                dtpcm_repetition,
-                data_transfer_control,
-                dtpml_size,
-                mac_address_clone,
-                slot_bitmap_clone,
-                stop_data_transfer_clone,
-            )
-            .await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_get_count_ok() {
-        let session_count = 5;
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionGetCount;
-                let resp = into_uci_hal_packets(uwb_uci_packets::SessionGetCountRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    session_count,
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let result = uci_manager.session_get_count().await.unwrap();
-        assert_eq!(result, session_count);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_get_state_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let session_state = SessionState::SessionStateActive;
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionGetState { session_token };
-                let resp = into_uci_hal_packets(uwb_uci_packets::SessionGetStateRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    session_state,
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager.session_get_state(session_id).await.unwrap();
-        assert_eq!(result, session_state);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    fn write_multicast_rsp_v1_payload(
-        payload: &SessionUpdateControllerMulticastListRspV1Payload,
-        buffer: &mut BytesMut,
-    ) {
-        buffer.put_u8(payload.status.into());
-    }
-
-    fn write_v2_controlee_status(status: &ControleeStatusV2, buffer: &mut BytesMut) {
-        for elem in &status.mac_address {
-            buffer.put_u8(*elem);
-        }
-        buffer.put_u8(u8::from(status.status));
-    }
-
-    fn write_multicast_rsp_v2_payload(
-        payload: &SessionUpdateControllerMulticastListRspV2Payload,
-        buffer: &mut BytesMut,
-    ) {
-        buffer.put_u8(payload.status.into());
-        buffer.put_u8(payload.controlee_status.len() as u8);
-        for elem in &payload.controlee_status {
-            write_v2_controlee_status(elem, buffer);
-        }
-    }
-
-    #[tokio::test]
-    async fn test_session_update_controller_multicast_list_v1_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let action = UpdateMulticastListAction::AddControlee;
-        let short_address: [u8; 2] = [0x45, 0x67];
-        let controlee = Controlee { short_address, subsession_id: 0x90ab };
-        let controlee_clone = controlee.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionUpdateControllerMulticastList {
-                    session_token,
-                    action,
-                    controlees: Controlees::NoSessionKey(vec![controlee_clone]),
-                    is_multicast_list_ntf_v2_supported: false,
-                    is_multicast_list_rsp_v2_supported: false,
-                };
-                let pload = SessionUpdateControllerMulticastListRspV1Payload {
-                    status: StatusCode::UciStatusOk,
-                };
-                let mut buf = BytesMut::new();
-                write_multicast_rsp_v1_payload(&pload, &mut buf);
-                let resp = into_uci_hal_packets(
-                    uwb_uci_packets::SessionUpdateControllerMulticastListRspBuilder {
-                        payload: Some(buf.freeze()),
-                    },
-                );
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager
-            .session_update_controller_multicast_list(
-                session_id,
-                action,
-                uwb_uci_packets::Controlees::NoSessionKey(vec![controlee]),
-                false,
-                false,
-            )
-            .await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_update_controller_multicast_list_v2_short_subsession_key_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let action = UpdateMulticastListAction::AddControleeWithShortSubSessionKey;
-        let short_address: [u8; 2] = [0x45, 0x67];
-        let controlee = Controlee_V2_0_16_Byte_Version {
-            short_address,
-            subsession_key: [
-                0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,
-                0xcd, 0xef,
-            ],
-            subsession_id: 0x90ab,
-        };
-        let controlee_clone = controlee.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized_nop_logger(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionUpdateControllerMulticastList {
-                    session_token,
-                    action,
-                    controlees: Controlees::ShortSessionKey(vec![controlee_clone]),
-                    is_multicast_list_ntf_v2_supported: true,
-                    is_multicast_list_rsp_v2_supported: true,
-                };
-                let pload = SessionUpdateControllerMulticastListRspV2Payload {
-                    status: StatusCode::UciStatusOk,
-                    controlee_status: vec![],
-                };
-                let mut buf = BytesMut::new();
-                write_multicast_rsp_v2_payload(&pload, &mut buf);
-                let resp = into_uci_hal_packets(
-                    uwb_uci_packets::SessionUpdateControllerMulticastListRspBuilder {
-                        payload: Some(buf.freeze()),
-                    },
-                );
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager
-            .session_update_controller_multicast_list(
-                session_id,
-                action,
-                uwb_uci_packets::Controlees::ShortSessionKey(vec![controlee]),
-                true,
-                true,
-            )
-            .await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_update_controller_multicast_list_v2_long_subsession_key_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let action = UpdateMulticastListAction::AddControleeWithLongSubSessionKey;
-        let short_address: [u8; 2] = [0x45, 0x67];
-        let controlee = Controlee_V2_0_32_Byte_Version {
-            short_address,
-            subsession_key: [
-                0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,
-                0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78,
-                0x90, 0xab, 0xcd, 0xef,
-            ],
-            subsession_id: 0x90ab,
-        };
-        let controlee_clone = controlee.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionUpdateControllerMulticastList {
-                    session_token,
-                    action,
-                    controlees: Controlees::LongSessionKey(vec![controlee_clone]),
-                    is_multicast_list_ntf_v2_supported: true,
-                    is_multicast_list_rsp_v2_supported: true,
-                };
-                let pload = SessionUpdateControllerMulticastListRspV2Payload {
-                    status: StatusCode::UciStatusOk,
-                    controlee_status: vec![],
-                };
-                let mut buf = BytesMut::new();
-                write_multicast_rsp_v2_payload(&pload, &mut buf);
-                let resp = into_uci_hal_packets(
-                    uwb_uci_packets::SessionUpdateControllerMulticastListRspBuilder {
-                        payload: Some(buf.freeze()),
-                    },
-                );
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager
-            .session_update_controller_multicast_list(
-                session_id,
-                action,
-                uwb_uci_packets::Controlees::LongSessionKey(vec![controlee]),
-                true,
-                true,
-            )
-            .await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_query_max_data_size_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let max_data_size = 100;
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionQueryMaxDataSize { session_token };
-                let resp =
-                    into_uci_hal_packets(uwb_uci_packets::SessionQueryMaxDataSizeRspBuilder {
-                        max_data_size,
-                        session_token: 0x10,
-                        status: StatusCode::UciStatusOk,
-                    });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager.session_query_max_data_size(session_id).await.unwrap();
-
-        assert_eq!(result, max_data_size);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_core_query_uwb_timestamp_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let time_stamp = 200;
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |mut hal| async move {
-                let cmd = UciCommand::CoreQueryTimeStamp {};
-                let resp = into_uci_hal_packets(uwb_uci_packets::CoreQueryTimeStampRspBuilder {
-                    status: StatusCode::UciStatusOk,
-                    timeStamp: time_stamp,
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager.core_query_uwb_timestamp().await.unwrap();
-
-        assert_eq!(result, time_stamp);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_set_active_dt_tag_ranging_rounds() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-
-        let ranging_rounds = SessionUpdateDtTagRangingRoundsResponse {
-            status: StatusCode::UciStatusErrorRoundIndexNotActivated,
-            ranging_round_indexes: vec![3],
-        };
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionUpdateDtTagRangingRounds {
-                    session_token,
-                    ranging_round_indexes: vec![3, 5],
-                };
-                let resp = into_uci_hal_packets(
-                    uwb_uci_packets::SessionUpdateDtTagRangingRoundsRspBuilder {
-                        status: StatusCode::UciStatusErrorRoundIndexNotActivated,
-                        ranging_round_indexes: vec![3],
-                    },
-                );
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result =
-            uci_manager.session_update_dt_tag_ranging_rounds(session_id, vec![3, 5]).await.unwrap();
-
-        assert_eq!(result, ranging_rounds);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_range_start_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionStart { session_token };
-                let resp = into_uci_hal_packets(uwb_uci_packets::SessionStartRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager.range_start(session_id).await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_range_stop_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionStop { session_token };
-                let resp = into_uci_hal_packets(uwb_uci_packets::SessionStopRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager.range_stop(session_id).await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_range_get_ranging_count_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let count = 3;
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionGetRangingCount { session_token };
-                let resp =
-                    into_uci_hal_packets(uwb_uci_packets::SessionGetRangingCountRspBuilder {
-                        status: uwb_uci_packets::StatusCode::UciStatusOk,
-                        count,
-                    });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager.range_get_ranging_count(session_id).await.unwrap();
-        assert_eq!(result, count as usize);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_android_set_country_code_ok() {
-        let country_code = CountryCode::new(b"US").unwrap();
-        let country_code_clone = country_code.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::AndroidSetCountryCode { country_code: country_code_clone };
-                let resp = into_uci_hal_packets(uwb_uci_packets::AndroidSetCountryCodeRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let result = uci_manager.android_set_country_code(country_code).await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_android_get_power_stats_ok() {
-        let power_stats = PowerStats {
-            status: StatusCode::UciStatusOk,
-            idle_time_ms: 123,
-            tx_time_ms: 456,
-            rx_time_ms: 789,
-            total_wake_count: 5,
-        };
-        let power_stats_clone = power_stats.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::AndroidGetPowerStats;
-                let resp = into_uci_hal_packets(uwb_uci_packets::AndroidGetPowerStatsRspBuilder {
-                    stats: power_stats_clone,
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let result = uci_manager.android_get_power_stats().await.unwrap();
-        assert_eq!(result, power_stats);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_android_set_radar_config_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let config_tlv =
-            RadarConfigTlv { cfg_id: RadarConfigTlvType::SamplesPerSweep, v: vec![0x12, 0x34] };
-        let config_tlv_clone = config_tlv.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |mut hal| async move {
-                let cmd = UciCommand::AndroidSetRadarConfig {
-                    session_token,
-                    config_tlvs: vec![config_tlv_clone],
-                };
-                let resp = into_uci_hal_packets(uwb_uci_packets::AndroidSetRadarConfigRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    cfg_status: vec![],
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let expected_result =
-            AndroidRadarConfigResponse { status: StatusCode::UciStatusOk, config_status: vec![] };
-        let result =
-            uci_manager.android_set_radar_config(session_id, vec![config_tlv]).await.unwrap();
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_android_get_radar_config_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let config_id = RadarConfigTlvType::SamplesPerSweep;
-        let tlv =
-            RadarConfigTlv { cfg_id: RadarConfigTlvType::SamplesPerSweep, v: vec![0x12, 0x34] };
-        let tlv_clone = tlv.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |mut hal| async move {
-                let cmd =
-                    UciCommand::AndroidGetRadarConfig { session_token, radar_cfg: vec![config_id] };
-                let resp = into_uci_hal_packets(uwb_uci_packets::AndroidGetRadarConfigRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    tlvs: vec![tlv_clone],
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let expected_result = vec![tlv];
-        let result =
-            uci_manager.android_get_radar_config(session_id, vec![config_id]).await.unwrap();
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_raw_uci_cmd_vendor_gid_ok() {
-        let mt = 0x1;
-        let gid = 0xF; // Vendor reserved GID.
-        let oid = 0x3;
-        let cmd_payload = vec![0x11, 0x22, 0x33, 0x44];
-        let cmd_payload_clone = cmd_payload.clone();
-        let resp_payload = vec![0x55, 0x66, 0x77, 0x88];
-        let resp_payload_clone = resp_payload.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::RawUciCmd { mt, gid, oid, payload: cmd_payload_clone };
-                let resp = into_uci_hal_packets(uwb_uci_packets::UciVendor_F_ResponseBuilder {
-                    opcode: oid as u8,
-                    payload: Some(Bytes::from(resp_payload_clone)),
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let expected_result = RawUciMessage { gid, oid, payload: resp_payload };
-        let result = uci_manager.raw_uci_cmd(mt, gid, oid, cmd_payload).await.unwrap();
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_raw_uci_cmd_fira_gid_ok() {
-        let mt = 0x1;
-        let gid = 0x1; // SESSION_CONFIG GID.
-        let oid = 0x3;
-        let cmd_payload = vec![0x11, 0x22, 0x33, 0x44];
-        let cmd_payload_clone = cmd_payload.clone();
-        let resp_payload = vec![0x00, 0x01, 0x07, 0x00];
-        let status = StatusCode::UciStatusOk;
-        let cfg_id = AppConfigTlvType::DstMacAddress;
-        let app_config = AppConfigStatus { cfg_id, status };
-        let cfg_status = vec![app_config];
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal_nop_logger(
-            |mut hal| async move {
-                let cmd = UciCommand::RawUciCmd { mt, gid, oid, payload: cmd_payload_clone };
-                let resp = into_uci_hal_packets(uwb_uci_packets::SessionSetAppConfigRspBuilder {
-                    status,
-                    cfg_status,
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-        )
-        .await;
-
-        let expected_result = RawUciMessage { gid, oid, payload: resp_payload };
-        let result = uci_manager.raw_uci_cmd(mt, gid, oid, cmd_payload).await.unwrap();
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_raw_uci_cmd_undefined_mt_ok() {
-        let mt = 0x4;
-        let gid = 0x1; // SESSION_CONFIG GID.
-        let oid = 0x3;
-        let cmd_payload = vec![0x11, 0x22, 0x33, 0x44];
-        let cmd_payload_clone = cmd_payload.clone();
-        let resp_payload = vec![0x00, 0x01, 0x07, 0x00];
-        let status = StatusCode::UciStatusOk;
-        let cfg_id = AppConfigTlvType::DstMacAddress;
-        let app_config = AppConfigStatus { cfg_id, status };
-        let cfg_status = vec![app_config];
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::RawUciCmd { mt, gid, oid, payload: cmd_payload_clone };
-                let resp = into_uci_hal_packets(uwb_uci_packets::SessionSetAppConfigRspBuilder {
-                    status,
-                    cfg_status,
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let expected_result = RawUciMessage { gid, oid, payload: resp_payload };
-        let result = uci_manager.raw_uci_cmd(mt, gid, oid, cmd_payload).await.unwrap();
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_raw_uci_cmd_custom_payload_format() {
-        // Send a raw UCI command with a FiRa defined GID, OID (SESSION_SET_APP_CONFIG), and the
-        // UCI HAL returns a UCI response with a custom payload format. The UCI response packet
-        // should still be successfully parsed and returned, since it's a Raw UCI RSP.
-        let cmd_mt: u8 = 0x1;
-        let gid: u8 = 0x1; // Session Config.
-        let oid: u8 = 0x3; // SESSION_SET_APP_CONFIG
-        let cmd_payload = vec![0x11, 0x22, 0x33, 0x44];
-        let cmd_payload_clone = cmd_payload.clone();
-        let resp_mt: u8 = 0x2;
-        let resp_payload = vec![0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08];
-        let resp_payload_clone = resp_payload.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::RawUciCmd {
-                    mt: cmd_mt.into(),
-                    gid: gid.into(),
-                    oid: oid.into(),
-                    payload: cmd_payload_clone,
-                };
-                let resp = build_uci_packet(resp_mt, 0, gid, oid, resp_payload_clone);
-                hal.expected_send_command(cmd, vec![resp], Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let expected_result =
-            Ok(RawUciMessage { gid: gid.into(), oid: oid.into(), payload: resp_payload });
-        let result =
-            uci_manager.raw_uci_cmd(cmd_mt.into(), gid.into(), oid.into(), cmd_payload).await;
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_raw_uci_cmd_fragmented_responses() {
-        // Send a raw UCI command with a FiRa defined GID, OID (SESSION_SET_APP_CONFIG), and the
-        // UCI HAL returns a UCI response with a custom payload format, in 2 UCI packet fragments.
-        let cmd_mt: u8 = 0x1;
-        let gid: u8 = 0x1; // Session Config.
-        let oid: u8 = 0x3; // SESSION_SET_APP_CONFIG
-        let cmd_payload = vec![0x11, 0x22, 0x33, 0x44];
-        let cmd_payload_clone = cmd_payload.clone();
-        let resp_mt: u8 = 0x2;
-        let resp_payload_fragment_1 = vec![0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08];
-        let resp_payload_fragment_2 = vec![0x09, 0x0a, 0x0b];
-        let mut resp_payload_expected = resp_payload_fragment_1.clone();
-        resp_payload_expected.extend(resp_payload_fragment_2.clone());
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::RawUciCmd {
-                    mt: cmd_mt.into(),
-                    gid: gid.into(),
-                    oid: oid.into(),
-                    payload: cmd_payload_clone,
-                };
-                let resp_fragment_1 = build_uci_packet(
-                    resp_mt,
-                    /* pbf = */ 1,
-                    gid,
-                    oid,
-                    resp_payload_fragment_1,
-                );
-                let resp_fragment_2 = build_uci_packet(
-                    resp_mt,
-                    /* pbf = */ 0,
-                    gid,
-                    oid,
-                    resp_payload_fragment_2,
-                );
-                hal.expected_send_command(cmd, vec![resp_fragment_1, resp_fragment_2], Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let expected_result =
-            Ok(RawUciMessage { gid: gid.into(), oid: oid.into(), payload: resp_payload_expected });
-        let result =
-            uci_manager.raw_uci_cmd(cmd_mt.into(), gid.into(), oid.into(), cmd_payload).await;
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_raw_uci_cmd_wrong_gid() {
-        // Send a raw UCI command with CORE GID, but UCI HAL returns a UCI response with
-        // SESSION_CONFIG GID. In this case, UciManager should return Error::Unknown, as the
-        // RawUciSignature fields (GID, OID) of the CMD and RSP packets don't match.
-
-        let mt = 0x1;
-        let gid = 0x0; // CORE GID.
-        let oid = 0x1;
-        let cmd_payload = vec![0x11, 0x22, 0x33, 0x44];
-        let cmd_payload_clone = cmd_payload.clone();
-        let status = StatusCode::UciStatusOk;
-        let cfg_id = AppConfigTlvType::DstMacAddress;
-        let app_config = AppConfigStatus { cfg_id, status };
-        let cfg_status = vec![app_config];
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::RawUciCmd { mt, gid, oid, payload: cmd_payload_clone };
-                let resp = into_uci_hal_packets(uwb_uci_packets::SessionSetAppConfigRspBuilder {
-                    status,
-                    cfg_status,
-                });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let expected_result = Err(Error::Unknown);
-        let result = uci_manager.raw_uci_cmd(mt, gid, oid, cmd_payload).await;
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_raw_uci_cmd_out_of_range_gid() {
-        // Send a raw UCI command with a GID value outside it's 8-bit size. This should result in
-        // an error since the input GID value cannot be encoded into the UCI packet.
-        let mt = 0x1;
-        let gid = 0x1FF;
-        let oid = 0x1;
-        let cmd_payload = vec![0x11, 0x22, 0x33, 0x44];
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal_nop_logger(
-            move |_hal| async {},
-            UciLoggerMode::Disabled,
-        )
-        .await;
-
-        let expected_result = Err(Error::BadParameters);
-        let result = uci_manager.raw_uci_cmd(mt, gid, oid, cmd_payload).await;
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_raw_uci_cmd_out_of_range_oid() {
-        // Send a raw UCI command with a valid GID (CORE), but an OID value outside it's 8-bit
-        // size. This should result in an error since the input OID value cannot be encoded into
-        // the UCI packet.
-        let mt = 0x1;
-        let gid = 0x0; // CORE GID.
-        let oid = 0x1FF;
-        let cmd_payload = vec![0x11, 0x22, 0x33, 0x44];
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |_hal| async move {},
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let expected_result = Err(Error::BadParameters);
-        let result = uci_manager.raw_uci_cmd(mt, gid, oid, cmd_payload).await;
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_raw_uci_cmd_uwbs_response_notification() {
-        // Send a raw UCI command with a FiRa defined GID, OID (SESSION_SET_APP_CONFIG), and the
-        // UCI HAL returns a valid UCI Notification packet before the raw UCI response.
-        let cmd_mt: u8 = 0x1;
-        let gid: u8 = 0x1; // Session Config.
-        let oid: u8 = 0x3; // SESSION_SET_APP_CONFIG
-        let cmd_payload = vec![0x11, 0x22, 0x33, 0x44];
-        let cmd_payload_clone = cmd_payload.clone();
-        let session_token = 0x123;
-        let resp_mt: u8 = 0x2;
-        let resp_payload = vec![0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08];
-        let resp_payload_clone = resp_payload.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::RawUciCmd {
-                    mt: cmd_mt.into(),
-                    gid: gid.into(),
-                    oid: oid.into(),
-                    payload: cmd_payload_clone,
-                };
-                let raw_resp = build_uci_packet(resp_mt, 0, gid, oid, resp_payload_clone);
-                let mut responses =
-                    into_uci_hal_packets(uwb_uci_packets::SessionStatusNtfBuilder {
-                        session_token,
-                        session_state: uwb_uci_packets::SessionState::SessionStateInit,
-                        reason_code:
-                            uwb_uci_packets::ReasonCode::StateChangeWithSessionManagementCommands
-                                .into(),
-                    });
-                responses.push(raw_resp);
-                hal.expected_send_command(cmd, responses, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let expected_result =
-            Ok(RawUciMessage { gid: gid.into(), oid: oid.into(), payload: resp_payload });
-        let result =
-            uci_manager.raw_uci_cmd(cmd_mt.into(), gid.into(), oid.into(), cmd_payload).await;
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_raw_uci_cmd_uwbs_response_undefined_mt() {
-        // Send a raw UCI command with a FiRa defined GID, OID (SESSION_SET_APP_CONFIG), and the
-        // UCI HAL returns a UCI packet with an undefined MessageType in response.
-        let cmd_mt: u8 = 0x1;
-        let gid: u8 = 0x1; // Session Config.
-        let oid: u8 = 0x3; // SESSION_SET_APP_CONFIG
-        let cmd_payload = vec![0x11, 0x22, 0x33, 0x44];
-        let cmd_payload_clone = cmd_payload.clone();
-        let resp_mt: u8 = 0x7; // Undefined MessageType
-        let resp_payload = vec![0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08];
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal_nop_logger(
-            |mut hal| async move {
-                let cmd = UciCommand::RawUciCmd {
-                    mt: cmd_mt.into(),
-                    gid: gid.into(),
-                    oid: oid.into(),
-                    payload: cmd_payload_clone,
-                };
-                let resp = build_uci_packet(resp_mt, /* pbf = */ 0, gid, oid, resp_payload);
-                hal.expected_send_command(cmd, vec![resp], Ok(()));
-            },
-            UciLoggerMode::Disabled,
-        )
-        .await;
-
-        let expected_result = Err(Error::Unknown);
-        let result =
-            uci_manager.raw_uci_cmd(cmd_mt.into(), gid.into(), oid.into(), cmd_payload).await;
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    fn setup_hal_for_session_active(
-        hal: &mut MockUciHal,
-        session_type: SessionType,
-        session_id: u32,
-        session_token: u32,
-    ) {
-        // Setup session init.
-        setup_hal_for_session_initialize(hal, session_type, session_id, session_token);
-
-        // Setup session active.
-        let cmd = UciCommand::SessionStart { session_token };
-        let mut responses = into_uci_hal_packets(uwb_uci_packets::SessionStartRspBuilder {
-            status: uwb_uci_packets::StatusCode::UciStatusOk,
-        });
-        responses.append(&mut into_uci_hal_packets(uwb_uci_packets::SessionStatusNtfBuilder {
-            session_token,
-            session_state: SessionState::SessionStateActive,
-            reason_code: 0, /* ReasonCode::StateChangeWithSessionManagementCommands */
-        }));
-        hal.expected_send_command(cmd, responses, Ok(()));
-    }
-
-    async fn setup_uci_manager_with_session_active<F, Fut>(
-        setup_hal_fn: F,
-        uci_logger_mode: UciLoggerMode,
-        log_sender: mpsc::UnboundedSender<UciLogEvent>,
-        session_id: u32,
-        session_token: u32,
-    ) -> (UciManagerImpl, MockUciHal)
-    where
-        F: FnOnce(MockUciHal) -> Fut,
-        Fut: Future<Output = ()>,
-    {
-        let session_type = SessionType::FiraRangingSession;
-
-        init_test_logging();
-
-        let mut hal = MockUciHal::new();
-        setup_hal_for_session_active(&mut hal, session_type, session_id, session_token);
-
-        // Verify open_hal() is working.
-        let uci_manager =
-            UciManagerImpl::new(hal.clone(), MockUciLogger::new(log_sender), uci_logger_mode);
-        let result = uci_manager.open_hal().await;
-        assert!(result.is_ok());
-
-        // Verify session is initialized.
-        let result = uci_manager.session_init(session_id, session_type).await;
-        assert!(result.is_ok());
-
-        // Verify session is started.
-        let result = uci_manager.range_start(session_id).await;
-        assert!(result.is_ok());
-        assert!(hal.wait_expected_calls_done().await);
-
-        setup_hal_fn(hal.clone()).await;
-
-        (uci_manager, hal)
-    }
-
-    async fn setup_uci_manager_with_session_active_nop_logger<F, Fut>(
-        setup_hal_fn: F,
-        uci_logger_mode: UciLoggerMode,
-        session_id: u32,
-        session_token: u32,
-    ) -> (UciManagerImpl, MockUciHal)
-    where
-        F: FnOnce(MockUciHal) -> Fut,
-        Fut: Future<Output = ()>,
-    {
-        let session_type = SessionType::FiraRangingSession;
-
-        init_test_logging();
-
-        let mut hal = MockUciHal::new();
-        setup_hal_for_session_active(&mut hal, session_type, session_id, session_token);
-
-        // Verify open_hal() is working.
-        let uci_manager =
-            UciManagerImpl::new(hal.clone(), NopUciLogger::default(), uci_logger_mode);
-        let result = uci_manager.open_hal().await;
-        assert!(result.is_ok());
-
-        // Verify session is initialized.
-        let result = uci_manager.session_init(session_id, session_type).await;
-        assert!(result.is_ok());
-
-        // Verify session is started.
-        let result = uci_manager.range_start(session_id).await;
-        assert!(result.is_ok());
-        assert!(hal.wait_expected_calls_done().await);
-
-        setup_hal_fn(hal.clone()).await;
-
-        (uci_manager, hal)
-    }
-
-    // Test Data packet receive for a single packet (on an active UWB session).
-    #[tokio::test]
-    async fn test_data_packet_recv_ok() {
-        let mt_data = 0x0;
-        let pbf = 0x0;
-        let dpf = 0x2;
-        let oid = 0x0;
-        let session_id = 0x3;
-        let session_token = 0x5;
-        let uci_sequence_num = 0xa;
-        let source_address = UwbAddress::Extended([0xa0, 0xb0, 0xc0, 0xd0, 0xa1, 0xb1, 0xc1, 0xd1]);
-        let app_data = vec![0x01, 0x02, 0x03];
-        let data_rcv_payload = vec![
-            0x05, 0x00, 0x00, 0x00, // SessionToken
-            0x00, // StatusCode
-            0xa0, 0xb0, 0xc0, 0xd0, 0xa1, 0xb1, 0xc1, 0xd1, // MacAddress
-            0x0a, 0x00, // UciSequenceNumber
-            0x03, 0x00, // AppDataLen
-            0x01, 0x02, 0x03, // AppData
-        ];
-
-        // Setup the DataPacketRcv (Rx by HAL) and the expected DataRcvNotification.
-        let data_packet_rcv = build_uci_packet(mt_data, pbf, dpf, oid, data_rcv_payload);
-        let expected_data_rcv_notification = DataRcvNotification {
-            session_token: session_id,
-            status: StatusCode::UciStatusOk,
-            uci_sequence_num,
-            source_address,
-            payload: app_data,
-        };
-
-        // Setup an active UWBS session over which the DataPacket will be received by the Host.
-        let (mut uci_manager, mut mock_hal) = setup_uci_manager_with_session_active(
-            |_| async move {},
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let (data_rcv_notification_sender, mut data_rcv_notification_receiver) =
-            mpsc::unbounded_channel::<DataRcvNotification>();
-        uci_manager.set_data_rcv_notification_sender(data_rcv_notification_sender).await;
-
-        // Inject the UCI DataPacketRcv into HAL.
-        let result = mock_hal.receive_packet(data_packet_rcv);
-        assert!(result.is_ok());
-
-        // UciManager should send a DataRcvNotification (for the valid Rx packet).
-        let result =
-            tokio::time::timeout(Duration::from_millis(100), data_rcv_notification_receiver.recv())
-                .await;
-        assert!(result.is_ok());
-        assert_eq!(result.unwrap(), Some(expected_data_rcv_notification));
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    // Test Data packet receive for two packet fragments (on an active UWB session).
-    #[tokio::test]
-    async fn test_data_packet_recv_fragmented_packets_ok() {
-        let mt_data = 0x0;
-        let pbf_fragment_1 = 0x1;
-        let pbf_fragment_2 = 0x0;
-        let dpf = 0x2;
-        let oid = 0x0;
-        let session_id = 0x3;
-        let session_token = 0x5;
-        let uci_sequence_num = 0xa;
-        let source_address = UwbAddress::Extended([0xa0, 0xb0, 0xc0, 0xd0, 0xa1, 0xb1, 0xc1, 0xd1]);
-        let app_data_len = 300;
-        let app_data_fragment_1_len = 200;
-        let mut data_rcv_payload_fragment_1: Vec<u8> = vec![
-            0x05, 0x00, 0x00, 0x00, // SessionToken
-            0x00, // StatusCode
-            0xa0, 0xb0, 0xc0, 0xd0, 0xa1, 0xb1, 0xc1, 0xd1, // MacAddress
-            0x0a, 0x00, // UciSequenceNumber
-            0x2c, 0x01, // AppData Length (300)
-        ];
-
-        // Setup the application data (payload) for the 2 DataPacketRcv fragments.
-        let mut app_data: Vec<u8> = Vec::new();
-        for i in 0..app_data_len {
-            app_data.push((i & 0xff).try_into().unwrap());
-        }
-        data_rcv_payload_fragment_1.extend_from_slice(&app_data[0..app_data_fragment_1_len]);
-        let mut data_rcv_payload_fragment_2: Vec<u8> = Vec::new();
-        data_rcv_payload_fragment_2.extend_from_slice(&app_data[app_data_fragment_1_len..]);
-
-        // Setup the DataPacketRcv fragments (Rx by HAL) and the expected DataRcvNotification.
-        let data_packet_rcv_fragment_1 =
-            build_uci_packet(mt_data, pbf_fragment_1, dpf, oid, data_rcv_payload_fragment_1);
-        let data_packet_rcv_fragment_2 =
-            build_uci_packet(mt_data, pbf_fragment_2, dpf, oid, data_rcv_payload_fragment_2);
-        let expected_data_rcv_notification = DataRcvNotification {
-            session_token: session_id,
-            status: StatusCode::UciStatusOk,
-            uci_sequence_num,
-            source_address,
-            payload: app_data,
-        };
-
-        // Setup an active UWBS session over which the DataPacket will be received by the Host.
-        let (mut uci_manager, mut mock_hal) = setup_uci_manager_with_session_active_nop_logger(
-            |_| async move {},
-            UciLoggerMode::Disabled,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let (data_rcv_notification_sender, mut data_rcv_notification_receiver) =
-            mpsc::unbounded_channel::<DataRcvNotification>();
-        uci_manager.set_data_rcv_notification_sender(data_rcv_notification_sender).await;
-
-        // Inject the 2 UCI DataPacketRcv into HAL.
-        let result = mock_hal.receive_packet(data_packet_rcv_fragment_1);
-        assert!(result.is_ok());
-        let result = mock_hal.receive_packet(data_packet_rcv_fragment_2);
-        assert!(result.is_ok());
-
-        // UciManager should send a DataRcvNotification (for the valid Rx packet).
-        let result =
-            tokio::time::timeout(Duration::from_millis(100), data_rcv_notification_receiver.recv())
-                .await;
-        assert!(result.is_ok());
-        assert_eq!(result.unwrap(), Some(expected_data_rcv_notification));
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_data_packet_recv_bad_payload_len_failure() {}
-
-    // Test Radar Data packet receive for a single packet (on an active UWB session).
-    #[tokio::test]
-    async fn test_radar_data_packet_recv_ok() {
-        let mt_data = 0x0;
-        let pbf = 0x0;
-        let dpf = 0xf;
-        let oid = 0x0;
-        let session_id = 0x3;
-        let session_token = 0x5;
-        let radar_data_type = RadarDataType::RadarSweepSamples;
-        let number_of_sweeps = 0x02;
-        let samples_per_sweep = 0x02;
-        let bits_per_sample = BitsPerSample::Value32;
-        let sweep_offset = 0x0;
-        let sequence_number_1 = 0xa;
-        let sequence_number_2 = 0xb;
-        let timestamp_1 = 0xc;
-        let timestamp_2 = 0xd;
-        let vendor_specific_data_1 = vec![0x0b];
-        let vendor_specific_data_2 = vec![0x0b, 0x0c];
-        let sample_data_1 = vec![0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa];
-        let sample_data_2 = vec![0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8];
-        let radar_data_rcv_payload = vec![
-            0x05, 0x00, 0x00, 0x00, // session_handle
-            0x00, // status
-            0x00, // radar data type
-            0x02, // number of sweeps
-            0x02, // samples per sweep
-            0x00, // bits per sample
-            0x00, 0x00, // sweep offset
-            0x10, 0x11, // sweep data size
-            // sweep data 1
-            0x0a, 0x00, 0x00, 0x00, // sequence number
-            0x0c, 0x00, 0x00, 0x00, // timestamp
-            0x01, // vendor specific data length
-            0x0b, // vendor specific data
-            0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, // sample data
-            // sweep data 2
-            0x0b, 0x00, 0x00, 0x00, // sequence number
-            0x0d, 0x00, 0x00, 0x00, // timestamp
-            0x02, // vendor specific data length
-            0x0b, 0x0c, // vendor specific data
-            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // sample data
-        ];
-
-        // Setup the DataPacketRcv (Rx by HAL) and the expected DataRcvNotification.
-        let radar_data_packet_rcv =
-            build_uci_packet(mt_data, pbf, dpf, oid, radar_data_rcv_payload);
-        let expected_radar_data_rcv_notification = RadarDataRcvNotification {
-            session_token: session_id,
-            status: DataRcvStatusCode::UciStatusSuccess,
-            radar_data_type,
-            number_of_sweeps,
-            samples_per_sweep,
-            bits_per_sample,
-            sweep_offset,
-            sweep_data: vec![
-                RadarSweepData {
-                    sequence_number: sequence_number_1,
-                    timestamp: timestamp_1,
-                    vendor_specific_data: vendor_specific_data_1,
-                    sample_data: sample_data_1,
-                },
-                RadarSweepData {
-                    sequence_number: sequence_number_2,
-                    timestamp: timestamp_2,
-                    vendor_specific_data: vendor_specific_data_2,
-                    sample_data: sample_data_2,
-                },
-            ],
-        };
-
-        // Setup an active UWBS session over which the DataPacket will be received by the Host.
-        let (mut uci_manager, mut mock_hal) = setup_uci_manager_with_session_active(
-            |_| async move {},
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let (radar_data_rcv_notification_sender, mut radar_data_rcv_notification_receiver) =
-            mpsc::unbounded_channel::<RadarDataRcvNotification>();
-        uci_manager
-            .set_radar_data_rcv_notification_sender(radar_data_rcv_notification_sender)
-            .await;
-
-        // Inject the UCI DataPacketRcv into HAL.
-        let result = mock_hal.receive_packet(radar_data_packet_rcv);
-        assert!(result.is_ok());
-
-        // UciManager should send a DataRcvNotification (for the valid Rx packet).
-        let result = tokio::time::timeout(
-            Duration::from_millis(100),
-            radar_data_rcv_notification_receiver.recv(),
-        )
-        .await;
-        assert!(result.is_ok());
-        assert_eq!(result.unwrap(), Some(expected_radar_data_rcv_notification));
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_data_packet_send_ok() {
-        // Test Data packet send for a single packet (on a UWB session).
-        let mt_data = 0x0;
-        let pbf = 0x0;
-        let dpf = 0x1;
-        let oid = 0x0;
-        let session_id = 0x5;
-        let session_token = 0x5;
-        let dest_mac_address = vec![0xa0, 0xb0, 0xc0, 0xd0, 0xa1, 0xb1, 0xc1, 0xd1];
-        let uci_sequence_number: u16 = 0xa;
-        let app_data = vec![0x01, 0x02, 0x03];
-        let expected_data_snd_payload = vec![
-            0x05, 0x00, 0x00, 0x00, // SessionID
-            0xa0, 0xb0, 0xc0, 0xd0, 0xa1, 0xb1, 0xc1, 0xd1, // MacAddress
-            0x0a, 0x00, // UciSequenceNumber
-            0x03, 0x00, // AppDataLen
-            0x01, 0x02, 0x03, // AppData
-        ];
-        let status = DataTransferNtfStatusCode::UciDataTransferStatusRepetitionOk;
-        let tx_count = 0x00;
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_active_nop_logger(
-            |mut hal| async move {
-                // Now setup the notifications that should be received after a Data packet send.
-                let data_packet_snd =
-                    build_uci_packet(mt_data, pbf, dpf, oid, expected_data_snd_payload);
-                let mut ntfs = into_uci_hal_packets(uwb_uci_packets::DataCreditNtfBuilder {
-                    session_token,
-                    credit_availability: CreditAvailability::CreditAvailable,
-                });
-                ntfs.append(&mut into_uci_hal_packets(
-                    uwb_uci_packets::DataTransferStatusNtfBuilder {
-                        session_token,
-                        uci_sequence_number,
-                        status,
-                        tx_count,
-                    },
-                ));
-                hal.expected_send_packet(data_packet_snd, ntfs, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager
-            .send_data_packet(session_id, dest_mac_address, uci_sequence_number, app_data)
-            .await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-
-        // TODO(b/276320369): Verify that session_notf_sender is called (once implemented), as a
-        // DataTransferStatusNtf is received in this test scenario.
-    }
-
-    // Test the Host sending a DATA packet to UWBS that needs to be fragmented, where the
-    // fragment size is based on a default value (MAX_PAYLOAD_LEN).
-    #[tokio::test]
-    async fn test_data_packet_send_fragmented_packet_ok_uses_default_fragment_size() {
-        // Don't setup UWBS returning a response to CORE_GET_DEVICE_INFO and CORE_GET_CAPS_INFO;
-        // this simulates the scenario of the default UCI data packet fragment size being used.
-
-        // Test Data packet send for a set of data packet fragments (on a UWB session).
-        let mt_data = 0x0;
-        let pbf_fragment_1 = 0x1;
-        let pbf_fragment_2 = 0x0;
-        let dpf = 0x1;
-        let oid = 0x0;
-        let session_id = 0x5;
-        let session_token = 0x5;
-        let dest_mac_address = vec![0xa0, 0xb0, 0xc0, 0xd0, 0xa1, 0xb1, 0xc1, 0xd1];
-        let uci_sequence_number: u16 = 0xa;
-        let app_data_len = 300; // Larger than MAX_PAYLOAD_LEN=255, so fragmentation occurs.
-        let mut app_data = Vec::new();
-        let mut expected_data_snd_payload_fragment_1 = vec![
-            0x05, 0x00, 0x00, 0x00, // SessionID
-            0xa0, 0xb0, 0xc0, 0xd0, 0xa1, 0xb1, 0xc1, 0xd1, // MacAddress
-            0x0a, 0x00, // UciSequenceNumber
-            0x2c, 0x01, // AppDataLen = 300
-        ];
-        let mut expected_data_snd_payload_fragment_2 = Vec::new();
-        let status = DataTransferNtfStatusCode::UciDataTransferStatusRepetitionOk;
-        let tx_count = 0x00;
-
-        // Setup the app data for both the Tx data packet and expected packet fragments.
-        let app_data_len_fragment_1 = 255 - expected_data_snd_payload_fragment_1.len();
-        for i in 0..app_data_len {
-            app_data.push((i & 0xff).try_into().unwrap());
-            if i < app_data_len_fragment_1 {
-                expected_data_snd_payload_fragment_1.push((i & 0xff).try_into().unwrap());
-            } else {
-                expected_data_snd_payload_fragment_2.push((i & 0xff).try_into().unwrap());
-            }
-        }
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_active(
-            |mut hal| async move {
-                // Expected data packet fragment #1 (UCI Header + Initial App data bytes).
-                let data_packet_snd_fragment_1 = build_uci_packet(
-                    mt_data,
-                    pbf_fragment_1,
-                    dpf,
-                    oid,
-                    expected_data_snd_payload_fragment_1,
-                );
-                let ntfs = into_uci_hal_packets(uwb_uci_packets::DataCreditNtfBuilder {
-                    session_token,
-                    credit_availability: CreditAvailability::CreditAvailable,
-                });
-                hal.expected_send_packet(data_packet_snd_fragment_1, ntfs, Ok(()));
-
-                // Expected data packet fragment #2 (UCI Header + Remaining App data bytes).
-                let data_packet_snd_fragment_2 = build_uci_packet(
-                    mt_data,
-                    pbf_fragment_2,
-                    dpf,
-                    oid,
-                    expected_data_snd_payload_fragment_2,
-                );
-                let mut ntfs = into_uci_hal_packets(uwb_uci_packets::DataCreditNtfBuilder {
-                    session_token,
-                    credit_availability: CreditAvailability::CreditAvailable,
-                });
-                ntfs.append(&mut into_uci_hal_packets(
-                    uwb_uci_packets::DataTransferStatusNtfBuilder {
-                        session_token,
-                        uci_sequence_number,
-                        status,
-                        tx_count,
-                    },
-                ));
-                hal.expected_send_packet(data_packet_snd_fragment_2, ntfs, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager
-            .send_data_packet(session_id, dest_mac_address, uci_sequence_number, app_data)
-            .await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    async fn run_test_data_packet_send_fragmented_packet_uwbs_max_data_payload_size(
-        uci_version: u16,
-        uwbs_caps_info_tlv: CapTlv,
-    ) {
-        let status = StatusCode::UciStatusOk;
-        let mac_version = 0;
-        let phy_version = 0;
-        let uci_test_version = 0;
-        let vendor_spec_info = vec![0x1, 0x2];
-        let uwbs_device_info_rsp = GetDeviceInfoResponse {
-            status,
-            uci_version,
-            mac_version,
-            phy_version,
-            uci_test_version,
-            vendor_spec_info: vendor_spec_info.clone(),
-        };
-
-        let uwbs_caps_info_tlv_clone = uwbs_caps_info_tlv.clone();
-
-        // Test Data packet send for a set of data packet fragments (on a UWB session).
-        let mt_data = 0x0;
-        let pbf_fragment_1 = 0x1;
-        let pbf_fragment_2 = 0x0;
-        let dpf = 0x1;
-        let oid = 0x0;
-        let session_id = 0x5;
-        let session_token = 0x5;
-        let dest_mac_address = vec![0xa0, 0xb0, 0xc0, 0xd0, 0xa1, 0xb1, 0xc1, 0xd1];
-        let uci_sequence_number: u16 = 0xa;
-        let max_data_packet_payload_size = 275;
-        let app_data_len = 300; // > max_data_packet_payload_size, so fragmentation occurs.
-        let mut app_data = Vec::new();
-        let mut expected_data_snd_payload_fragment_1 = vec![
-            0x05, 0x00, 0x00, 0x00, // SessionID
-            0xa0, 0xb0, 0xc0, 0xd0, 0xa1, 0xb1, 0xc1, 0xd1, // MacAddress
-            0x0a, 0x00, // UciSequenceNumber
-            0x2c, 0x01, // AppDataLen = 300
-        ];
-        let mut expected_data_snd_payload_fragment_2 = Vec::new();
-        let data_status = DataTransferNtfStatusCode::UciDataTransferStatusRepetitionOk;
-        let tx_count = 0x00;
-
-        // Setup the app data for both the Tx data packet and expected packet fragments.
-        let app_data_len_fragment_1 =
-            max_data_packet_payload_size - expected_data_snd_payload_fragment_1.len();
-        for i in 0..app_data_len {
-            app_data.push((i & 0xff).try_into().unwrap());
-            if i < app_data_len_fragment_1 {
-                expected_data_snd_payload_fragment_1.push((i & 0xff).try_into().unwrap());
-            } else {
-                expected_data_snd_payload_fragment_2.push((i & 0xff).try_into().unwrap());
-            }
-        }
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_active_nop_logger(
-            |mut hal| async move {
-                // Expected UCI CMD CORE_GET_DEVICE_INFO
-                let cmd = UciCommand::CoreGetDeviceInfo;
-                let resp = into_uci_hal_packets(uwb_uci_packets::GetDeviceInfoRspBuilder {
-                    status,
-                    uci_version,
-                    mac_version,
-                    phy_version,
-                    uci_test_version,
-                    vendor_spec_info,
-                });
-                hal.expected_send_command(cmd, resp, Ok(()));
-
-                // Expected UCI CMD CORE_GET_CAPS_INFO
-                let cmd = UciCommand::CoreGetCapsInfo;
-                let resp = into_uci_hal_packets(uwb_uci_packets::GetCapsInfoRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    tlvs: vec![uwbs_caps_info_tlv_clone],
-                });
-                hal.expected_send_command(cmd, resp, Ok(()));
-
-                // Expected data packet fragment #1 (UCI Header + Initial App data bytes).
-                let data_packet_snd_fragment_1 = build_uci_packet(
-                    mt_data,
-                    pbf_fragment_1,
-                    dpf,
-                    oid,
-                    expected_data_snd_payload_fragment_1,
-                );
-                let ntfs = into_uci_hal_packets(uwb_uci_packets::DataCreditNtfBuilder {
-                    session_token,
-                    credit_availability: CreditAvailability::CreditAvailable,
-                });
-                hal.expected_send_packet(data_packet_snd_fragment_1, ntfs, Ok(()));
-
-                // Expected data packet fragment #2 (UCI Header + Remaining App data bytes).
-                let data_packet_snd_fragment_2 = build_uci_packet(
-                    mt_data,
-                    pbf_fragment_2,
-                    dpf,
-                    oid,
-                    expected_data_snd_payload_fragment_2,
-                );
-                let mut ntfs = into_uci_hal_packets(uwb_uci_packets::DataCreditNtfBuilder {
-                    session_token,
-                    credit_availability: CreditAvailability::CreditAvailable,
-                });
-                ntfs.append(&mut into_uci_hal_packets(
-                    uwb_uci_packets::DataTransferStatusNtfBuilder {
-                        session_token,
-                        uci_sequence_number,
-                        status: data_status,
-                        tx_count,
-                    },
-                ));
-                hal.expected_send_packet(data_packet_snd_fragment_2, ntfs, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        // First send the UCI CMD CORE_GET_DEVICE_INFO, so the UWBS returns it's UCI version.
-        let result = uci_manager.core_get_device_info().await.unwrap();
-        assert_eq!(result, uwbs_device_info_rsp);
-
-        // Next send the UCI CMD CORE_GET_CAPS_INFO, so the UWBS returns it's capabilities.
-        let result = uci_manager.core_get_caps_info().await.unwrap();
-        assert_eq!(result[0], uwbs_caps_info_tlv);
-
-        let result = uci_manager
-            .send_data_packet(session_id, dest_mac_address, uci_sequence_number, app_data)
-            .await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    // Test the Host sending a DATA packet to UWBS that needs to be fragmented, where the
-    // fragment size is based on the UWBS MAX_DATA_PACKET_PAYLOAD_SIZE capability value.
-    #[tokio::test]
-    async fn test_data_packet_send_fragmented_packet_ok_fira_v1_uwbs_max_data_payload_size() {
-        let uci_version = 0x1001;
-        let uwbs_caps_info_tlv = CapTlv {
-            t: CapTlvType::SupportedV1MaxDataPacketPayloadSizeV2AoaSupport,
-            v: vec![0x13, 0x01],
-        };
-
-        run_test_data_packet_send_fragmented_packet_uwbs_max_data_payload_size(
-            uci_version,
-            uwbs_caps_info_tlv,
-        )
-        .await;
-    }
-
-    // Test the Host sending a DATA packet to UWBS that needs to be fragmented, where the
-    // fragment size is based on the UWBS MAX_DATA_PACKET_PAYLOAD_SIZE capability value.
-    #[tokio::test]
-    async fn test_data_packet_send_fragmented_packet_ok_fira_v2_uwbs_max_data_payload_size() {
-        let uci_version = 0x2002; // UCI version: Fira 2.x
-        let uwbs_caps_info_tlv = CapTlv {
-            t: CapTlvType::SupportedV1FiraMacVersionRangeV2MaxDataPayloadSize,
-            v: vec![0x13, 0x01],
-        };
-
-        run_test_data_packet_send_fragmented_packet_uwbs_max_data_payload_size(
-            uci_version,
-            uwbs_caps_info_tlv,
-        )
-        .await;
-    }
-
-    #[tokio::test]
-    async fn test_data_packet_send_retry_ok() {
-        // Test Data packet send for a single packet (on a UWB session).
-        let mt_data = 0x0;
-        let pbf = 0x0;
-        let dpf = 0x1;
-        let oid = 0x0;
-        let session_id = 0x5;
-        let session_token = 0x5;
-        let tx_count = 0x01;
-        let dest_mac_address = vec![0xa0, 0xb0, 0xc0, 0xd0, 0xa1, 0xb1, 0xc1, 0xd1];
-        let uci_sequence_number: u16 = 0xa;
-        let app_data = vec![0x01, 0x02, 0x03];
-        let expected_data_snd_payload = vec![
-            0x05, 0x00, 0x00, 0x00, // SessionID
-            0xa0, 0xb0, 0xc0, 0xd0, 0xa1, 0xb1, 0xc1, 0xd1, // MacAddress
-            0x0a, 0x00, // UciSequenceNumber
-            0x03, 0x00, // AppDataLen
-            0x01, 0x02, 0x03, // AppData
-        ];
-        let status = DataTransferNtfStatusCode::UciDataTransferStatusRepetitionOk;
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_active(
-            |mut hal| async move {
-                // Setup receiving a CORE_GENERIC_ERROR_NTF with STATUS_COMMAND_RETRY after a
-                // failed Data packet send attempt.
-                let data_packet_snd =
-                    build_uci_packet(mt_data, pbf, dpf, oid, expected_data_snd_payload);
-                let error_ntf = into_uci_hal_packets(uwb_uci_packets::GenericErrorBuilder {
-                    status: StatusCode::UciStatusCommandRetry,
-                });
-                hal.expected_send_packet(data_packet_snd.clone(), error_ntf, Ok(()));
-
-                // Setup the notifications that should be received after the Data packet send
-                // is successfully retried.
-                let mut ntfs = into_uci_hal_packets(uwb_uci_packets::DataCreditNtfBuilder {
-                    session_token,
-                    credit_availability: CreditAvailability::CreditAvailable,
-                });
-                ntfs.append(&mut into_uci_hal_packets(
-                    uwb_uci_packets::DataTransferStatusNtfBuilder {
-                        session_token,
-                        uci_sequence_number,
-                        status,
-                        tx_count,
-                    },
-                ));
-                hal.expected_send_packet(data_packet_snd, ntfs, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let result = uci_manager
-            .send_data_packet(session_id, dest_mac_address, uci_sequence_number, app_data)
-            .await;
-        assert!(result.is_ok());
-        assert!(mock_hal.wait_expected_calls_done().await);
-
-        // TODO(b/276320369): Verify that session_notf_sender is called (once implemented), as a
-        // DataTransferStatusNtf is received in this test scenario.
-    }
-
-    // TODO(b/276320369): Listing down the Data Packet Tx scenarios below, will add unit tests
-    // for them in subsequent CLs.
-
-    // Sending one data packet should succeed, when no DataCreditNtf is received.
-    #[tokio::test]
-    async fn test_data_packet_send_missing_data_credit_ntf_success() {}
-
-    // Sending the second data packet should fail, when no DataCreditNtf is received after
-    // sending the first data packet.
-    #[tokio::test]
-    async fn test_data_packet_send_missing_data_credit_ntf_subsequent_send_failure() {}
-
-    #[tokio::test]
-    async fn test_data_packet_send_data_credit_ntf_bad_session_id() {}
-
-    #[tokio::test]
-    async fn test_data_packet_send_data_credit_ntf_no_credit_available() {}
-
-    #[tokio::test]
-    async fn test_data_packet_send_missing_data_transfer_status_ntf() {}
-
-    #[tokio::test]
-    async fn test_data_packet_send_data_transfer_status_ntf_bad_session_id() {}
-
-    #[tokio::test]
-    async fn test_data_packet_send_data_transfer_status_ntf_bad_uci_sequence_number() {}
-
-    // Tests for the multiple Status values that indicate success
-    #[tokio::test]
-    async fn test_data_packet_send_data_transfer_status_ntf_status_ok() {}
-
-    #[tokio::test]
-    async fn test_data_packet_send_data_transfer_status_ntf_status_repetition_ok() {}
-
-    // Tests for some of the multiple Status values that indicate error.
-    #[tokio::test]
-    async fn test_data_packet_send_data_transfer_status_ntf_status_error() {}
-
-    #[tokio::test]
-    async fn test_session_get_count_retry_no_response() {
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionGetCount;
-                hal.expected_send_command(cmd, vec![], Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let result = uci_manager.session_get_count().await;
-        assert!(matches!(result, Err(Error::Timeout)));
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_get_count_timeout() {
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionGetCount;
-                hal.expected_send_command(cmd, vec![], Err(Error::Timeout));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let result = uci_manager.session_get_count().await;
-        assert!(matches!(result, Err(Error::Timeout)));
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_get_count_retry_too_many_times() {
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionGetCount;
-                let retry_resp = into_uci_hal_packets(uwb_uci_packets::SessionGetCountRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusCommandRetry,
-                    session_count: 0,
-                });
-
-                for _ in 0..MAX_RETRY_COUNT {
-                    hal.expected_send_command(cmd.clone(), retry_resp.clone(), Ok(()));
-                }
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let result = uci_manager.session_get_count().await;
-        assert!(matches!(result, Err(Error::Timeout)));
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_get_count_retry_notification() {
-        let session_count = 5;
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionGetCount;
-                let retry_resp = into_uci_hal_packets(uwb_uci_packets::SessionGetCountRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusCommandRetry,
-                    session_count: 0,
-                });
-                let resp = into_uci_hal_packets(uwb_uci_packets::SessionGetCountRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    session_count,
-                });
-
-                hal.expected_send_command(cmd.clone(), retry_resp.clone(), Ok(()));
-                hal.expected_send_command(cmd.clone(), retry_resp, Ok(()));
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-        )
-        .await;
-
-        let result = uci_manager.session_get_count().await.unwrap();
-        assert_eq!(result, session_count);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_log_manager_interaction() {
-        let (log_sender, mut log_receiver) = mpsc::unbounded_channel::<UciLogEvent>();
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_open_hal(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionGetCount;
-                let resp1 = into_uci_hal_packets(uwb_uci_packets::SessionGetCountRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    session_count: 1,
-                });
-                let resp2 = into_uci_hal_packets(uwb_uci_packets::SessionGetCountRspBuilder {
-                    status: uwb_uci_packets::StatusCode::UciStatusOk,
-                    session_count: 2,
-                });
-                hal.expected_send_command(cmd.clone(), resp1, Ok(()));
-                hal.expected_send_command(cmd, resp2, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            log_sender,
-        )
-        .await;
-
-        // Under Disabled mode, initialization and first command and response are not logged.
-        uci_manager.session_get_count().await.unwrap();
-        assert!(log_receiver.try_recv().is_err());
-
-        // Second command and response after change in logger mode are logged.
-        uci_manager.set_logger_mode(UciLoggerMode::Filtered).await.unwrap();
-        uci_manager.session_get_count().await.unwrap();
-        let packet: Vec<u8> = log_receiver.recv().await.unwrap().try_into().unwrap();
-        let cmd_packet: Vec<u8> = SessionGetCountCmdBuilder {}.build().encode_to_vec().unwrap();
-        assert_eq!(&packet, &cmd_packet);
-        let packet: Vec<u8> = log_receiver.recv().await.unwrap().try_into().unwrap();
-        let rsp_packet: Vec<u8> =
-            SessionGetCountRspBuilder { status: StatusCode::UciStatusOk, session_count: 2 }
-                .build()
-                .encode_to_vec()
-                .unwrap();
-        assert_eq!(&packet, &rsp_packet);
-
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-
-    #[tokio::test]
-    async fn test_session_set_rf_config_ok() {
-        let session_id = 0x123;
-        let session_token = 0x123;
-        let config_tlv =
-            RfTestConfigTlv { cfg_id: RfTestConfigTlvType::NumPackets, v: vec![0x12, 0x34, 0x56] };
-        let config_tlv_clone = config_tlv.clone();
-
-        let (uci_manager, mut mock_hal) = setup_uci_manager_with_session_initialized(
-            |mut hal| async move {
-                let cmd = UciCommand::SessionSetRfTestConfig {
-                    session_token,
-                    config_tlvs: vec![config_tlv_clone],
-                };
-                let resp =
-                    into_uci_hal_packets(uwb_uci_packets::SessionSetRfTestConfigRspBuilder {
-                        status: uwb_uci_packets::StatusCode::UciStatusOk,
-                        cfg_status: vec![],
-                    });
-
-                hal.expected_send_command(cmd, resp, Ok(()));
-            },
-            UciLoggerMode::Disabled,
-            mpsc::unbounded_channel::<UciLogEvent>().0,
-            session_id,
-            session_token,
-        )
-        .await;
-
-        let expected_result =
-            RfTestConfigResponse { status: StatusCode::UciStatusOk, config_status: vec![] };
-        let result =
-            uci_manager.session_set_rf_test_config(session_id, vec![config_tlv]).await.unwrap();
-        assert_eq!(result, expected_result);
-        assert!(mock_hal.wait_expected_calls_done().await);
-    }
-}
diff --git a/src/rust/uwb_core/src/uci/uci_manager_sync.rs b/src/rust/uwb_core/src/uci/uci_manager_sync.rs
deleted file mode 100644
index 5158905..0000000
--- a/src/rust/uwb_core/src/uci/uci_manager_sync.rs
+++ /dev/null
@@ -1,683 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! This module offers a synchornized interface at UCI level.
-//!
-//! The module is designed with the replacement for Android UCI JNI adaptation in mind. The handling
-//! of UciNotifications is different in UciManager and UciManagerSyncImpl as the sync version has
-//! its behavior aligned with the Android JNI UCI, and routes the UciNotifications to
-//! NotificationManager.
-
-use log::{debug, error};
-use tokio::runtime::{Builder as RuntimeBuilder, Handle};
-use tokio::sync::mpsc;
-use tokio::task;
-
-use crate::error::{Error, Result};
-use crate::params::{
-    AndroidRadarConfigResponse, AppConfigTlv, AppConfigTlvType, CapTlv, CoreSetConfigResponse,
-    CountryCode, DeviceConfigId, DeviceConfigTlv, GetDeviceInfoResponse, PowerStats,
-    RadarConfigTlv, RadarConfigTlvType, RawUciMessage, ResetConfig, RfTestConfigResponse,
-    RfTestConfigTlv, SessionId, SessionState, SessionType,
-    SessionUpdateControllerMulticastResponse, SessionUpdateDtTagRangingRoundsResponse,
-    SetAppConfigResponse, UpdateMulticastListAction,
-};
-#[cfg(any(test, feature = "mock-utils"))]
-use crate::uci::mock_uci_manager::MockUciManager;
-use crate::uci::notification::{
-    CoreNotification, DataRcvNotification, RadarDataRcvNotification, RfTestNotification,
-    SessionNotification,
-};
-use crate::uci::uci_hal::UciHal;
-use crate::uci::uci_logger::{UciLogger, UciLoggerMode};
-use crate::uci::uci_manager::{UciManager, UciManagerImpl};
-use uwb_uci_packets::{ControleePhaseList, Controlees, ControllerPhaseList};
-
-/// The NotificationManager processes UciNotification relayed from UciManagerSync in a sync fashion.
-/// The UciManagerSync assumes the NotificationManager takes the responsibility to properly handle
-/// the notifications, including tracking the state of HAL. UciManagerSync and lower levels only
-/// redirect and categorize the notifications. The notifications are processed through callbacks.
-/// NotificationManager can be !Send and !Sync, as interfacing with other programs may require.
-pub trait NotificationManager: 'static {
-    /// Callback for CoreNotification.
-    fn on_core_notification(&mut self, core_notification: CoreNotification) -> Result<()>;
-
-    /// Callback for SessionNotification.
-    fn on_session_notification(&mut self, session_notification: SessionNotification) -> Result<()>;
-
-    /// Callback for RawUciMessage.
-    fn on_vendor_notification(&mut self, vendor_notification: RawUciMessage) -> Result<()>;
-
-    /// Callback for DataRcvNotification.
-    fn on_data_rcv_notification(
-        &mut self,
-        data_rcv_notification: DataRcvNotification,
-    ) -> Result<()>;
-
-    /// Callback for RadarDataRcvNotification.
-    fn on_radar_data_rcv_notification(
-        &mut self,
-        radar_data_rcv_notification: RadarDataRcvNotification,
-    ) -> Result<()>;
-
-    /// Callback for RF Test notification.
-    fn on_rf_test_notification(&mut self, rftest_notification: RfTestNotification) -> Result<()>;
-}
-
-/// Builder for NotificationManager. Builder is sent between threads.
-pub trait NotificationManagerBuilder: 'static + Send + Sync {
-    /// Type of NotificationManager built.
-    type NotificationManager: NotificationManager;
-    /// Builds NotificationManager. The build operation Consumes Builder.
-    fn build(self) -> Option<Self::NotificationManager>;
-}
-
-struct NotificationDriver<U: NotificationManager> {
-    core_notification_receiver: mpsc::UnboundedReceiver<CoreNotification>,
-    session_notification_receiver: mpsc::UnboundedReceiver<SessionNotification>,
-    vendor_notification_receiver: mpsc::UnboundedReceiver<RawUciMessage>,
-    data_rcv_notification_receiver: mpsc::UnboundedReceiver<DataRcvNotification>,
-    radar_data_rcv_notification_receiver: mpsc::UnboundedReceiver<RadarDataRcvNotification>,
-    rf_test_notification_receiver: mpsc::UnboundedReceiver<RfTestNotification>,
-    notification_manager: U,
-}
-impl<U: NotificationManager> NotificationDriver<U> {
-    fn new(
-        core_notification_receiver: mpsc::UnboundedReceiver<CoreNotification>,
-        session_notification_receiver: mpsc::UnboundedReceiver<SessionNotification>,
-        vendor_notification_receiver: mpsc::UnboundedReceiver<RawUciMessage>,
-        data_rcv_notification_receiver: mpsc::UnboundedReceiver<DataRcvNotification>,
-        radar_data_rcv_notification_receiver: mpsc::UnboundedReceiver<RadarDataRcvNotification>,
-        rf_test_notification_receiver: mpsc::UnboundedReceiver<RfTestNotification>,
-        notification_manager: U,
-    ) -> Self {
-        Self {
-            core_notification_receiver,
-            session_notification_receiver,
-            vendor_notification_receiver,
-            data_rcv_notification_receiver,
-            radar_data_rcv_notification_receiver,
-            rf_test_notification_receiver,
-            notification_manager,
-        }
-    }
-    async fn run(&mut self) {
-        loop {
-            tokio::select! {
-                Some(ntf) = self.core_notification_receiver.recv() =>{
-                    self.notification_manager.on_core_notification(ntf).unwrap_or_else(|e|{
-                        error!("NotificationDriver: CoreNotification callback error: {:?}",e);
-                    });
-                }
-                Some(ntf) = self.session_notification_receiver.recv() =>{
-                    self.notification_manager.on_session_notification(ntf).unwrap_or_else(|e|{
-                        error!("NotificationDriver: SessionNotification callback error: {:?}",e);
-                    });
-                }
-                Some(ntf) = self.vendor_notification_receiver.recv() =>{
-                    self.notification_manager.on_vendor_notification(ntf).unwrap_or_else(|e|{
-                        error!("NotificationDriver: RawUciMessage callback error: {:?}",e);
-                });
-                }
-                Some(data) = self.data_rcv_notification_receiver.recv() =>{
-                    self.notification_manager.on_data_rcv_notification(data).unwrap_or_else(|e|{
-                        error!("NotificationDriver: OnDataRcv callback error: {:?}",e);
-                });
-                }
-                Some(data) = self.radar_data_rcv_notification_receiver.recv() =>{
-                    self.notification_manager.on_radar_data_rcv_notification(data).unwrap_or_else(|e|{
-                        error!("NotificationDriver: OnRadarDataRcv callback error: {:?}",e);
-                });
-                }
-                Some(ntf) = self.rf_test_notification_receiver.recv() =>{
-                    self.notification_manager.on_rf_test_notification(ntf).unwrap_or_else(|e|{
-                        error!("NotificationDriver: RF notification callback error: {:?}",e);
-                });
-                }
-                else =>{
-                    debug!("NotificationDriver dropping.");
-                    break;
-                }
-            }
-        }
-    }
-}
-
-/// The UciManagerSync provides a synchornized version of UciManager.
-///
-/// Note the processing of UciNotification is different:
-/// set_X_notification_sender methods are removed. Instead, the method
-/// redirect_notification(NotificationManagerBuilder) is introduced to avoid the
-/// exposure of async tokio::mpsc.
-pub struct UciManagerSync<U: UciManager> {
-    runtime_handle: Handle,
-    uci_manager: U,
-}
-impl<U: UciManager> UciManagerSync<U> {
-    /// Redirects notification to a new NotificationManager using the notification_manager_builder.
-    /// The NotificationManager will live on a separate thread.
-    pub fn redirect_notification<T: NotificationManagerBuilder>(
-        &mut self,
-        notification_manager_builder: T,
-    ) -> Result<()> {
-        let (core_notification_sender, core_notification_receiver) =
-            mpsc::unbounded_channel::<CoreNotification>();
-        let (session_notification_sender, session_notification_receiver) =
-            mpsc::unbounded_channel::<SessionNotification>();
-        let (vendor_notification_sender, vendor_notification_receiver) =
-            mpsc::unbounded_channel::<RawUciMessage>();
-        let (data_rcv_notification_sender, data_rcv_notification_receiver) =
-            mpsc::unbounded_channel::<DataRcvNotification>();
-        let (radar_data_rcv_notification_sender, radar_data_rcv_notification_receiver) =
-            mpsc::unbounded_channel::<RadarDataRcvNotification>();
-        let (rftest_notification_sender, rf_test_notification_receiver) =
-            mpsc::unbounded_channel::<RfTestNotification>();
-        self.runtime_handle.to_owned().block_on(async {
-            self.uci_manager.set_core_notification_sender(core_notification_sender).await;
-            self.uci_manager.set_session_notification_sender(session_notification_sender).await;
-            self.uci_manager.set_vendor_notification_sender(vendor_notification_sender).await;
-            self.uci_manager.set_data_rcv_notification_sender(data_rcv_notification_sender).await;
-            self.uci_manager
-                .set_radar_data_rcv_notification_sender(radar_data_rcv_notification_sender)
-                .await;
-            self.uci_manager.set_rf_test_notification_sender(rftest_notification_sender).await;
-        });
-        // The potentially !Send NotificationManager is created in a separate thread.
-        let (driver_status_sender, mut driver_status_receiver) = mpsc::unbounded_channel::<bool>();
-        std::thread::spawn(move || {
-            let notification_runtime =
-                match RuntimeBuilder::new_current_thread().enable_all().build() {
-                    Ok(nr) => nr,
-                    Err(_) => {
-                        // unwrap safe since receiver is in scope
-                        driver_status_sender.send(false).unwrap();
-                        return;
-                    }
-                };
-
-            let local = task::LocalSet::new();
-            let notification_manager = match notification_manager_builder.build() {
-                Some(nm) => {
-                    // unwrap safe since receiver is in scope
-                    driver_status_sender.send(true).unwrap();
-                    nm
-                }
-                None => {
-                    // unwrap safe since receiver is in scope
-                    driver_status_sender.send(false).unwrap();
-                    return;
-                }
-            };
-            let mut notification_driver = NotificationDriver::new(
-                core_notification_receiver,
-                session_notification_receiver,
-                vendor_notification_receiver,
-                data_rcv_notification_receiver,
-                radar_data_rcv_notification_receiver,
-                rf_test_notification_receiver,
-                notification_manager,
-            );
-            local.spawn_local(async move {
-                task::spawn_local(async move { notification_driver.run().await }).await.unwrap();
-            });
-            notification_runtime.block_on(local);
-        });
-        match driver_status_receiver.blocking_recv() {
-            Some(true) => Ok(()),
-            _ => Err(Error::Unknown),
-        }
-    }
-
-    /// Set logger mode.
-    pub fn set_logger_mode(&self, logger_mode: UciLoggerMode) -> Result<()> {
-        self.runtime_handle.block_on(self.uci_manager.set_logger_mode(logger_mode))
-    }
-    /// Start UCI HAL and blocking until UCI commands can be sent.
-    pub fn open_hal(&self) -> Result<GetDeviceInfoResponse> {
-        self.runtime_handle.block_on(self.uci_manager.open_hal())
-    }
-
-    /// Stop the UCI HAL.
-    pub fn close_hal(&self, force: bool) -> Result<()> {
-        self.runtime_handle.block_on(self.uci_manager.close_hal(force))
-    }
-
-    // Methods for sending UCI commands. Functions are blocked until UCI response is received.
-    /// Send UCI command for device reset.
-    pub fn device_reset(&self, reset_config: ResetConfig) -> Result<()> {
-        self.runtime_handle.block_on(self.uci_manager.device_reset(reset_config))
-    }
-
-    /// Send UCI command for getting device info.
-    pub fn core_get_device_info(&self) -> Result<GetDeviceInfoResponse> {
-        self.runtime_handle.block_on(self.uci_manager.core_get_device_info())
-    }
-
-    /// Send UCI command for getting capability info
-    pub fn core_get_caps_info(&self) -> Result<Vec<CapTlv>> {
-        self.runtime_handle.block_on(self.uci_manager.core_get_caps_info())
-    }
-
-    /// Send UCI command for setting core configuration.
-    pub fn core_set_config(
-        &self,
-        config_tlvs: Vec<DeviceConfigTlv>,
-    ) -> Result<CoreSetConfigResponse> {
-        self.runtime_handle.block_on(self.uci_manager.core_set_config(config_tlvs))
-    }
-
-    /// Send UCI command for getting core configuration.
-    pub fn core_get_config(&self, config_ids: Vec<DeviceConfigId>) -> Result<Vec<DeviceConfigTlv>> {
-        self.runtime_handle.block_on(self.uci_manager.core_get_config(config_ids))
-    }
-
-    /// Send UCI command for getting uwbs timestamp.
-    pub fn core_query_uwb_timestamp(&self) -> Result<u64> {
-        self.runtime_handle.block_on(self.uci_manager.core_query_uwb_timestamp())
-    }
-
-    /// Send UCI command for initiating session.
-    pub fn session_init(&self, session_id: SessionId, session_type: SessionType) -> Result<()> {
-        self.runtime_handle.block_on(self.uci_manager.session_init(session_id, session_type))
-    }
-
-    /// Send UCI command for deinitiating session.
-    pub fn session_deinit(&self, session_id: SessionId) -> Result<()> {
-        self.runtime_handle.block_on(self.uci_manager.session_deinit(session_id))
-    }
-
-    /// Send UCI command for setting app config.
-    pub fn session_set_app_config(
-        &self,
-        session_id: SessionId,
-        config_tlvs: Vec<AppConfigTlv>,
-    ) -> Result<SetAppConfigResponse> {
-        self.runtime_handle
-            .block_on(self.uci_manager.session_set_app_config(session_id, config_tlvs))
-    }
-
-    /// Send UCI command for getting app config.
-    pub fn session_get_app_config(
-        &self,
-        session_id: SessionId,
-        config_ids: Vec<AppConfigTlvType>,
-    ) -> Result<Vec<AppConfigTlv>> {
-        self.runtime_handle
-            .block_on(self.uci_manager.session_get_app_config(session_id, config_ids))
-    }
-
-    /// Send UCI command for getting count of sessions.
-    pub fn session_get_count(&self) -> Result<u8> {
-        self.runtime_handle.block_on(self.uci_manager.session_get_count())
-    }
-
-    /// Send UCI command for getting state of session.
-    pub fn session_get_state(&self, session_id: SessionId) -> Result<SessionState> {
-        self.runtime_handle.block_on(self.uci_manager.session_get_state(session_id))
-    }
-
-    /// Send UCI command for updating multicast list for multicast session.
-    pub fn session_update_controller_multicast_list(
-        &self,
-        session_id: SessionId,
-        action: UpdateMulticastListAction,
-        controlees: Controlees,
-        is_multicast_list_ntf_v2_supported: bool,
-        is_multicast_list_rsp_v2_supported: bool,
-    ) -> Result<SessionUpdateControllerMulticastResponse> {
-        self.runtime_handle.block_on(self.uci_manager.session_update_controller_multicast_list(
-            session_id,
-            action,
-            controlees,
-            is_multicast_list_ntf_v2_supported,
-            is_multicast_list_rsp_v2_supported,
-        ))
-    }
-
-    /// Update ranging rounds for DT Tag
-    pub fn session_update_dt_tag_ranging_rounds(
-        &self,
-        session_id: u32,
-        ranging_round_indexes: Vec<u8>,
-    ) -> Result<SessionUpdateDtTagRangingRoundsResponse> {
-        self.runtime_handle.block_on(
-            self.uci_manager
-                .session_update_dt_tag_ranging_rounds(session_id, ranging_round_indexes),
-        )
-    }
-
-    /// Send UCI command for getting max data size for session.
-    pub fn session_query_max_data_size(&self, session_id: SessionId) -> Result<u16> {
-        self.runtime_handle.block_on(self.uci_manager.session_query_max_data_size(session_id))
-    }
-
-    /// Send UCI command for starting ranging of the session.
-    pub fn range_start(&self, session_id: SessionId) -> Result<()> {
-        self.runtime_handle.block_on(self.uci_manager.range_start(session_id))
-    }
-
-    /// Send UCI command for stopping ranging of the session.
-    pub fn range_stop(&self, session_id: SessionId) -> Result<()> {
-        self.runtime_handle.block_on(self.uci_manager.range_stop(session_id))
-    }
-
-    /// Send UCI command for getting ranging count.
-    pub fn range_get_ranging_count(&self, session_id: SessionId) -> Result<usize> {
-        self.runtime_handle.block_on(self.uci_manager.range_get_ranging_count(session_id))
-    }
-
-    /// Set the country code. Android-specific method.
-    pub fn android_set_country_code(&self, country_code: CountryCode) -> Result<()> {
-        self.runtime_handle.block_on(self.uci_manager.android_set_country_code(country_code))
-    }
-
-    /// Get the power statistics. Android-specific method.
-    pub fn android_get_power_stats(&self) -> Result<PowerStats> {
-        self.runtime_handle.block_on(self.uci_manager.android_get_power_stats())
-    }
-
-    /// Set radar config. Android-specific method.
-    pub fn android_set_radar_config(
-        &self,
-        session_id: SessionId,
-        config_tlvs: Vec<RadarConfigTlv>,
-    ) -> Result<AndroidRadarConfigResponse> {
-        self.runtime_handle
-            .block_on(self.uci_manager.android_set_radar_config(session_id, config_tlvs))
-    }
-
-    /// Get radar config. Android-specific method.
-    pub fn android_get_radar_config(
-        &self,
-        session_id: SessionId,
-        config_ids: Vec<RadarConfigTlvType>,
-    ) -> Result<Vec<RadarConfigTlv>> {
-        self.runtime_handle
-            .block_on(self.uci_manager.android_get_radar_config(session_id, config_ids))
-    }
-
-    /// Send a raw UCI command.
-    pub fn raw_uci_cmd(
-        &self,
-        mt: u32,
-        gid: u32,
-        oid: u32,
-        payload: Vec<u8>,
-    ) -> Result<RawUciMessage> {
-        self.runtime_handle.block_on(self.uci_manager.raw_uci_cmd(mt, gid, oid, payload))
-    }
-
-    /// Send a data packet
-    pub fn send_data_packet(
-        &self,
-        session_id: SessionId,
-        address: Vec<u8>,
-        uci_sequence_num: u16,
-        app_payload_data: Vec<u8>,
-    ) -> Result<()> {
-        self.runtime_handle.block_on(self.uci_manager.send_data_packet(
-            session_id,
-            address,
-            uci_sequence_num,
-            app_payload_data,
-        ))
-    }
-
-    /// Get session token for session id.
-    pub fn get_session_token(&self, session_id: SessionId) -> Result<u32> {
-        self.runtime_handle.block_on(self.uci_manager.get_session_token_from_session_id(session_id))
-    }
-
-    /// Send UCI command for setting hybrid controller configuration
-    pub fn session_set_hybrid_controller_config(
-        &self,
-        session_id: SessionId,
-        number_of_phases: u8,
-        phase_list: Vec<ControllerPhaseList>,
-    ) -> Result<()> {
-        self.runtime_handle.block_on(self.uci_manager.session_set_hybrid_controller_config(
-            session_id,
-            number_of_phases,
-            phase_list,
-        ))
-    }
-
-    /// Send UCI command for setting hybrid controlee configuration
-    pub fn session_set_hybrid_controlee_config(
-        &self,
-        session_id: SessionId,
-        controlee_phase_list: Vec<ControleePhaseList>,
-    ) -> Result<()> {
-        self.runtime_handle.block_on(
-            self.uci_manager.session_set_hybrid_controlee_config(session_id, controlee_phase_list),
-        )
-    }
-
-    /// Send UCI command for session data transfer phase config
-    #[allow(clippy::too_many_arguments)]
-    pub fn session_data_transfer_phase_config(
-        &self,
-        session_id: SessionId,
-        dtpcm_repetition: u8,
-        data_transfer_control: u8,
-        dtpml_size: u8,
-        mac_address: Vec<u8>,
-        slot_bitmap: Vec<u8>,
-        stop_data_transfer: Vec<u8>,
-    ) -> Result<()> {
-        self.runtime_handle.block_on(self.uci_manager.session_data_transfer_phase_config(
-            session_id,
-            dtpcm_repetition,
-            data_transfer_control,
-            dtpml_size,
-            mac_address,
-            slot_bitmap,
-            stop_data_transfer,
-        ))
-    }
-
-    /// Set rf test config.
-    pub fn session_set_rf_test_app_config(
-        &self,
-        session_id: SessionId,
-        config_tlvs: Vec<RfTestConfigTlv>,
-    ) -> Result<RfTestConfigResponse> {
-        self.runtime_handle
-            .block_on(self.uci_manager.session_set_rf_test_config(session_id, config_tlvs))
-    }
-
-    /// Test Periodic tx command
-    pub fn rf_test_periodic_tx(&self, psdu_data: Vec<u8>) -> Result<()> {
-        self.runtime_handle.block_on(self.uci_manager.rf_test_periodic_tx(psdu_data))
-    }
-
-    /// Test Per rx command
-    pub fn rf_test_per_rx(&self, psdu_data: Vec<u8>) -> Result<()> {
-        self.runtime_handle.block_on(self.uci_manager.rf_test_per_rx(psdu_data))
-    }
-
-    /// Test stop rf test command
-    pub fn stop_rf_test(&self) -> Result<()> {
-        self.runtime_handle.block_on(self.uci_manager.stop_rf_test())
-    }
-}
-
-impl UciManagerSync<UciManagerImpl> {
-    /// Constructor.
-    ///
-    /// UciHal and NotificationManagerBuilder required at construction as they are required before
-    /// open_hal is called. runtime_handle must be a Handle to a multithread runtime that outlives
-    /// UciManagerSyncImpl.
-    ///
-    /// Implementation note: An explicit decision is made to not use UciManagerImpl as a parameter.
-    /// UciManagerImpl::new() appears to be sync, but needs an async context to be called, but the
-    /// user is unlikely to be aware of this technicality.
-    pub fn new<H, B, L>(
-        hal: H,
-        notification_manager_builder: B,
-        logger: L,
-        logger_mode: UciLoggerMode,
-        runtime_handle: Handle,
-    ) -> Result<Self>
-    where
-        H: UciHal,
-        B: NotificationManagerBuilder,
-        L: UciLogger,
-    {
-        // UciManagerImpl::new uses tokio::spawn, so it is called inside the runtime as async fn.
-        let uci_manager =
-            runtime_handle.block_on(async { UciManagerImpl::new(hal, logger, logger_mode) });
-        let mut uci_manager_sync = UciManagerSync { runtime_handle, uci_manager };
-        uci_manager_sync.redirect_notification(notification_manager_builder)?;
-        Ok(uci_manager_sync)
-    }
-}
-
-#[cfg(any(test, feature = "mock-utils"))]
-impl UciManagerSync<MockUciManager> {
-    /// Constructor for mock version.
-    pub fn new_mock<T: NotificationManagerBuilder>(
-        uci_manager: MockUciManager,
-        runtime_handle: Handle,
-        notification_manager_builder: T,
-    ) -> Result<Self> {
-        let mut uci_manager_sync = UciManagerSync { uci_manager, runtime_handle };
-        uci_manager_sync.redirect_notification(notification_manager_builder)?;
-        Ok(uci_manager_sync)
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    use std::cell::RefCell;
-    use std::rc::Rc;
-
-    use tokio::runtime::Builder;
-    use uwb_uci_packets::DeviceState::DeviceStateReady;
-
-    use crate::params::uci_packets::GetDeviceInfoResponse;
-    use crate::uci::mock_uci_manager::MockUciManager;
-    use crate::uci::{CoreNotification, UciNotification};
-    use uwb_uci_packets::StatusCode::UciStatusOk;
-
-    /// Mock NotificationManager forwarding notifications received.
-    /// The nonsend_counter is deliberately !send to check UciManagerSync::redirect_notification.
-    struct MockNotificationManager {
-        notf_sender: mpsc::UnboundedSender<UciNotification>,
-        // nonsend_counter is an example of a !Send property.
-        nonsend_counter: Rc<RefCell<usize>>,
-    }
-
-    impl NotificationManager for MockNotificationManager {
-        fn on_core_notification(&mut self, core_notification: CoreNotification) -> Result<()> {
-            self.nonsend_counter.replace_with(|&mut prev| prev + 1);
-            self.notf_sender
-                .send(UciNotification::Core(core_notification))
-                .map_err(|_| Error::Unknown)
-        }
-        fn on_session_notification(
-            &mut self,
-            session_notification: SessionNotification,
-        ) -> Result<()> {
-            self.nonsend_counter.replace_with(|&mut prev| prev + 1);
-            self.notf_sender
-                .send(UciNotification::Session(session_notification))
-                .map_err(|_| Error::Unknown)
-        }
-        fn on_vendor_notification(&mut self, vendor_notification: RawUciMessage) -> Result<()> {
-            self.nonsend_counter.replace_with(|&mut prev| prev + 1);
-            self.notf_sender
-                .send(UciNotification::Vendor(vendor_notification))
-                .map_err(|_| Error::Unknown)
-        }
-        fn on_data_rcv_notification(&mut self, _data_rcv_notf: DataRcvNotification) -> Result<()> {
-            self.nonsend_counter.replace_with(|&mut prev| prev + 1);
-            Ok(())
-        }
-        fn on_radar_data_rcv_notification(
-            &mut self,
-            _data_rcv_notf: RadarDataRcvNotification,
-        ) -> Result<()> {
-            self.nonsend_counter.replace_with(|&mut prev| prev + 1);
-            Ok(())
-        }
-        fn on_rf_test_notification(
-            &mut self,
-            rftest_notification: RfTestNotification,
-        ) -> Result<()> {
-            self.nonsend_counter.replace_with(|&mut prev| prev + 1);
-            self.notf_sender
-                .send(UciNotification::RfTest(rftest_notification))
-                .map_err(|_| Error::Unknown)
-        }
-    }
-
-    /// Builder for MockNotificationManager.
-    struct MockNotificationManagerBuilder {
-        notf_sender: mpsc::UnboundedSender<UciNotification>,
-        // initial_count is an example for a parameter undetermined at compile time.
-    }
-
-    impl MockNotificationManagerBuilder {
-        /// Constructor for builder.
-        fn new(notf_sender: mpsc::UnboundedSender<UciNotification>) -> Self {
-            Self { notf_sender }
-        }
-    }
-
-    impl NotificationManagerBuilder for MockNotificationManagerBuilder {
-        type NotificationManager = MockNotificationManager;
-
-        fn build(self) -> Option<Self::NotificationManager> {
-            Some(MockNotificationManager {
-                notf_sender: self.notf_sender,
-                nonsend_counter: Rc::new(RefCell::new(0)),
-            })
-        }
-    }
-
-    #[test]
-    /// Tests that the Command, Response, and Notification pipeline are functional.
-    fn test_sync_uci_basic_sequence() {
-        let test_rt = Builder::new_multi_thread().enable_all().build().unwrap();
-        let (notf_sender, mut notf_receiver) = mpsc::unbounded_channel::<UciNotification>();
-        let mut uci_manager_impl = MockUciManager::new();
-        let get_device_info_rsp = GetDeviceInfoResponse {
-            status: UciStatusOk,
-            uci_version: 0,
-            mac_version: 0,
-            phy_version: 0,
-            uci_test_version: 0,
-            vendor_spec_info: vec![],
-        };
-
-        uci_manager_impl.expect_open_hal(
-            vec![UciNotification::Core(CoreNotification::DeviceStatus(DeviceStateReady))],
-            Ok(get_device_info_rsp.clone()),
-        );
-        uci_manager_impl.expect_core_get_device_info(Ok(get_device_info_rsp));
-        let uci_manager_sync = UciManagerSync::new_mock(
-            uci_manager_impl,
-            test_rt.handle().to_owned(),
-            MockNotificationManagerBuilder::new(notf_sender),
-        )
-        .unwrap();
-        assert!(uci_manager_sync.open_hal().is_ok());
-        let device_state = test_rt.block_on(async { notf_receiver.recv().await });
-        assert!(device_state.is_some());
-        assert!(uci_manager_sync.core_get_device_info().is_ok());
-    }
-}
diff --git a/src/rust/uwb_core/src/utils.rs b/src/rust/uwb_core/src/utils.rs
deleted file mode 100644
index 9c0464b..0000000
--- a/src/rust/uwb_core/src/utils.rs
+++ /dev/null
@@ -1,112 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::future::Future;
-use std::pin::Pin;
-use std::task::{Context, Poll};
-use std::time::Duration;
-
-use tokio::sync::mpsc::UnboundedReceiver;
-use tokio::time::{sleep, Sleep};
-
-/// Pinned Sleep instance. It can be used in tokio::select! macro.
-pub(super) struct PinSleep(Pin<Box<Sleep>>);
-
-impl PinSleep {
-    pub fn new(duration: Duration) -> Self {
-        Self(Box::pin(sleep(duration)))
-    }
-}
-
-impl Future for PinSleep {
-    type Output = ();
-
-    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
-        self.0.as_mut().poll(cx)
-    }
-}
-
-/// Generate the setter method for the field of the struct for the builder pattern.
-macro_rules! builder_field {
-    ($field:ident, $ty:ty, $wrap:expr) => {
-        /// Set the $field field.
-        pub fn $field(&mut self, value: $ty) -> &mut Self {
-            self.$field = $wrap(value);
-            self
-        }
-    };
-    ($field:ident, $ty:ty) => {
-        builder_field!($field, $ty, ::std::convert::identity);
-    };
-}
-pub(crate) use builder_field;
-
-/// Generate the setter method for the field of the struct for the consuming builder pattern.
-macro_rules! consuming_builder_field {
-    ($field:ident, $ty:ty, $wrap:expr) => {
-        /// Set the $field field.
-        pub fn $field(mut self, value: $ty) -> Self {
-            self.$field = $wrap(value);
-            self
-        }
-    };
-    ($field:ident, $ty:ty) => {
-        consuming_builder_field!($field, $ty, ::std::convert::identity);
-    };
-}
-pub(crate) use consuming_builder_field;
-
-/// Generate the getter method for the field of the struct.
-macro_rules! getter_field {
-    ($field:ident, $ty:ty) => {
-        pub fn $field(&self) -> &$ty {
-            &self.$field
-        }
-    };
-}
-pub(crate) use getter_field;
-
-/// Clean shutdown a mpsc receiver.
-///
-/// Call this function before dropping the receiver if the sender is not dropped yet.
-pub fn clean_mpsc_receiver<T>(receiver: &mut UnboundedReceiver<T>) {
-    receiver.close();
-    while receiver.try_recv().is_ok() {}
-}
-
-#[cfg(test)]
-pub fn init_test_logging() {
-    let _ = env_logger::builder().is_test(true).try_init();
-}
-
-#[cfg(test)]
-mod tests {
-    struct Foo {
-        value: u32,
-    }
-
-    impl Foo {
-        pub fn new(value: u32) -> Self {
-            Self { value }
-        }
-
-        getter_field!(value, u32);
-    }
-
-    #[test]
-    fn test_getter_field() {
-        let foo = Foo::new(5);
-        assert_eq!(foo.value(), &5);
-    }
-}
diff --git a/src/rust/uwb_uci_packets/Cargo.toml b/src/rust/uwb_uci_packets/Cargo.toml
deleted file mode 100644
index 6a47937..0000000
--- a/src/rust/uwb_uci_packets/Cargo.toml
+++ /dev/null
@@ -1,12 +0,0 @@
-[package]
-name = "uwb_uci_packets"
-version = "0.0.1"
-edition = "2021"
-
-[dependencies]
-bytes = "*"
-log = "*"
-num-derive = "*"
-num-traits = "*"
-thiserror = "*"
-zeroize = "1.5.1"
diff --git a/src/rust/uwb_uci_packets/build.rs b/src/rust/uwb_uci_packets/build.rs
deleted file mode 100644
index 240c3f2..0000000
--- a/src/rust/uwb_uci_packets/build.rs
+++ /dev/null
@@ -1,48 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::path::Path;
-use std::process::Command;
-
-fn main() {
-    let out_dir = std::env::var_os("OUT_DIR").unwrap();
-    let generated_file = "uci_packets.rs";
-    let dst_path = Path::new(&out_dir).join(generated_file);
-
-    if Path::new(generated_file).exists() {
-        // Copy the rust code directly if the file exists.
-        let result = std::fs::copy(generated_file, &dst_path);
-        eprintln!("{} exists, copy to {:?}: {:?}", generated_file, dst_path, result);
-        return;
-    }
-
-    // The binary should be compiled by `m pdlc` before calling cargo.
-    let output = Command::new("env")
-        .arg("pdlc")
-        .arg("--output-format")
-        .arg("rust")
-        .arg("uci_packets.pdl")
-        .output()
-        .unwrap();
-
-    std::fs::write(&dst_path, &output.stdout)
-        .expect(&format!("Could not write {}", dst_path.display()));
-
-    eprintln!(
-        "Status: {}, stdout: {}, stderr: {}",
-        output.status,
-        String::from_utf8_lossy(output.stdout.as_slice()),
-        String::from_utf8_lossy(output.stderr.as_slice())
-    );
-}
diff --git a/src/rust/uwb_uci_packets/src/debug_display.rs b/src/rust/uwb_uci_packets/src/debug_display.rs
deleted file mode 100644
index 3736182..0000000
--- a/src/rust/uwb_uci_packets/src/debug_display.rs
+++ /dev/null
@@ -1,80 +0,0 @@
-use std::{fmt::Debug, ops::Deref, path::Display};
-
-use crate::{ParsedFrameReport, PathSample, SegmentMetricsValue};
-
-pub struct DebugOverride<T>(T);
-
-impl<T> DebugOverride<T> {
-    fn take(self) -> T {
-        self.0
-    }
-}
-
-impl<T> From<T> for DebugOverride<T> {
-    fn from(value: T) -> Self {
-        DebugOverride::<T>(value)
-    }
-}
-
-impl<T> Deref for DebugOverride<T> {
-    type Target = T;
-
-    fn deref(&self) -> &T {
-        &self.0
-    }
-}
-
-impl Debug for ParsedFrameReport {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        f.debug_struct("FrameReport")
-            .field("uwb_msg_id", &self.uwb_msg_id)
-            .field("action", &self.action)
-            .field("antenna_set", &self.antenna_set)
-            .field("rssi", &self.rssi)
-            .field("aoa", &self.aoa)
-            .field("cir", &self.cir)
-            .field("segment_metrics", &self.segment_metrics.iter().map(DebugOverride))
-            .finish()
-    }
-}
-
-impl Debug for DebugOverride<Vec<SegmentMetricsValue>> {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        f.debug_tuple("").field(&self.0).finish()
-    }
-}
-
-impl Debug for DebugOverride<&SegmentMetricsValue> {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        f.debug_struct("")
-            .field("receiver/segment", &self.0.receiver_and_segment)
-            .field("rf_noise_floor", &f32::from(QFormat::<8, 8>(self.0.rf_noise_floor)))
-            .field("segment_rsl", &f32::from(QFormat::<8, 8>(self.0.segment_rsl)))
-            .field("first_path", &DebugOverride(&self.0.first_path))
-            .field("peak_path", &DebugOverride(&self.0.peak_path))
-            .finish()
-    }
-}
-
-impl Debug for DebugOverride<&PathSample> {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        f.debug_struct("")
-            .field("index", &self.0.index)
-            .field("rsl", &f32::from(QFormat::<8, 8>(self.0.rsl)))
-            .field("time_ns", &f32::from(QFormat::<6, 9>(self.0.time_ns)))
-            .finish()
-    }
-}
-
-#[derive(Copy, Clone)]
-pub struct QFormat<const I: u8, const F: u8>(u16);
-
-impl<const I: u8, const F: u8> From<QFormat<I, F>> for f32 {
-    fn from(value: QFormat<I, F>) -> Self {
-        let int_part = (value.0 >> F);
-        let frac_mask = (1 << F) - 1;
-        let frac_part = value.0 & frac_mask;
-        let frac = 2.0_f32.powf(-f32::from(F)) * f32::from(frac_part);
-        f32::from(int_part) + frac
-    }
-}
diff --git a/src/rust/uwb_uci_packets/src/lib.rs b/src/rust/uwb_uci_packets/src/lib.rs
deleted file mode 100644
index 929f5c1..0000000
--- a/src/rust/uwb_uci_packets/src/lib.rs
+++ /dev/null
@@ -1,1394 +0,0 @@
-// Copyright 2022, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#![allow(clippy::all)]
-#![allow(non_upper_case_globals)]
-#![allow(non_camel_case_types)]
-#![allow(non_snake_case)]
-#![allow(unused)]
-#![allow(missing_docs)]
-
-use std::cmp;
-
-use log::error;
-use num_derive::FromPrimitive;
-use num_traits::FromPrimitive;
-use zeroize::Zeroize;
-
-mod debug_display;
-
-include!(concat!(env!("OUT_DIR"), "/uci_packets.rs"));
-
-const MAX_PAYLOAD_LEN: usize = 255;
-// TODO: Use a PDL struct to represent the headers and avoid hardcoding
-// lengths below.
-// Real UCI packet header len.
-pub const UCI_PACKET_HAL_HEADER_LEN: usize = 4;
-// Unfragmented UCI packet header len.
-pub const UCI_PACKET_HEADER_LEN: usize = 7;
-// Unfragmented UCI DATA_MESSAGE_SND packet header len.
-const UCI_DATA_SND_PACKET_HEADER_LEN: usize = 6;
-
-// Opcode field byte position (within UCI packet header) and mask (of bits to be used).
-const UCI_HEADER_MT_BYTE_POSITION: usize = 0;
-const UCI_HEADER_MT_BIT_SHIFT: u8 = 5;
-const UCI_HEADER_MT_MASK: u8 = 0x7;
-
-const UCI_HEADER_PBF_BYTE_POSITION: usize = 0;
-const UCI_HEADER_PBF_BIT_SHIFT: u8 = 4;
-const UCI_HEADER_PBF_MASK: u8 = 0x1;
-
-const UCI_CONTROL_HEADER_GID_BYTE_POSITION: usize = 0;
-const UCI_CONTROL_HEADER_GID_MASK: u8 = 0xF;
-
-const UCI_CONTROL_HEADER_OID_BYTE_POSITION: usize = 1;
-const UCI_CONTROL_HEADER_OID_MASK: u8 = 0x3F;
-
-// Radar field lengths
-pub const UCI_RADAR_SEQUENCE_NUMBER_LEN: usize = 4;
-pub const UCI_RADAR_TIMESTAMP_LEN: usize = 4;
-pub const UCI_RADAR_VENDOR_DATA_LEN_LEN: usize = 1;
-
-#[derive(Debug, Clone, PartialEq, FromPrimitive)]
-pub enum TimeStampLength {
-    Timestamp40Bit = 0x0,
-    Timestamp64Bit = 0x1,
-}
-
-#[derive(Debug, Clone, PartialEq, FromPrimitive)]
-pub enum DTAnchorLocationType {
-    NotIncluded = 0x0,
-    Wgs84 = 0x1,
-    Relative = 0x2,
-}
-
-#[allow(dead_code)]
-#[derive(Debug, Clone, PartialEq)]
-pub struct DlTdoaRangingMeasurement {
-    pub status: u8,
-    pub message_type: u8,
-    pub message_control: u16,
-    pub block_index: u16,
-    pub round_index: u8,
-    pub nlos: u8,
-    pub aoa_azimuth: u16,
-    pub aoa_azimuth_fom: u8,
-    pub aoa_elevation: u16,
-    pub aoa_elevation_fom: u8,
-    pub rssi: u8,
-    pub tx_timestamp: u64,
-    pub rx_timestamp: u64,
-    pub anchor_cfo: u16,
-    pub cfo: u16,
-    pub initiator_reply_time: u32,
-    pub responder_reply_time: u32,
-    pub initiator_responder_tof: u16,
-    pub dt_anchor_location: Vec<u8>,
-    pub ranging_rounds: Vec<u8>,
-    total_size: usize,
-}
-
-impl DlTdoaRangingMeasurement {
-    pub fn parse_one(bytes: &[u8]) -> Option<Self> {
-        let mut ptr = 0;
-        let status = extract_u8(bytes, &mut ptr, 1)?;
-        let message_type = extract_u8(bytes, &mut ptr, 1)?;
-        let message_control = extract_u16(bytes, &mut ptr, 2)?;
-        let block_index = extract_u16(bytes, &mut ptr, 2)?;
-        let round_index = extract_u8(bytes, &mut ptr, 1)?;
-        let nlos = extract_u8(bytes, &mut ptr, 1)?;
-        let aoa_azimuth = extract_u16(bytes, &mut ptr, 2)?;
-        let aoa_azimuth_fom = extract_u8(bytes, &mut ptr, 1)?;
-        let aoa_elevation = extract_u16(bytes, &mut ptr, 2)?;
-        let aoa_elevation_fom = extract_u8(bytes, &mut ptr, 1)?;
-        let rssi = extract_u8(bytes, &mut ptr, 1)?;
-        let tx_timestamp_length = (message_control >> 1) & 0x1;
-        let tx_timestamp = match TimeStampLength::from_u16(tx_timestamp_length)? {
-            TimeStampLength::Timestamp40Bit => extract_u64(bytes, &mut ptr, 5)?,
-            TimeStampLength::Timestamp64Bit => extract_u64(bytes, &mut ptr, 8)?,
-        };
-        let rx_timestamp_length = (message_control >> 3) & 0x1;
-        let rx_timestamp = match TimeStampLength::from_u16(rx_timestamp_length)? {
-            TimeStampLength::Timestamp40Bit => extract_u64(bytes, &mut ptr, 5)?,
-            TimeStampLength::Timestamp64Bit => extract_u64(bytes, &mut ptr, 8)?,
-        };
-        let anchor_cfo = extract_u16(bytes, &mut ptr, 2)?;
-        let cfo = extract_u16(bytes, &mut ptr, 2)?;
-        let initiator_reply_time = extract_u32(bytes, &mut ptr, 4)?;
-        let responder_reply_time = extract_u32(bytes, &mut ptr, 4)?;
-        let initiator_responder_tof = extract_u16(bytes, &mut ptr, 2)?;
-        let dt_location_type = (message_control >> 5) & 0x3;
-        let dt_anchor_location = match DTAnchorLocationType::from_u16(dt_location_type)? {
-            DTAnchorLocationType::Wgs84 => extract_vec(bytes, &mut ptr, 12)?,
-            DTAnchorLocationType::Relative => extract_vec(bytes, &mut ptr, 10)?,
-            _ => vec![],
-        };
-        let active_ranging_rounds = ((message_control >> 7) & 0xf) as u8;
-        let ranging_round = extract_vec(bytes, &mut ptr, active_ranging_rounds as usize)?;
-
-        Some(DlTdoaRangingMeasurement {
-            status,
-            message_type,
-            message_control,
-            block_index,
-            round_index,
-            nlos,
-            aoa_azimuth,
-            aoa_azimuth_fom,
-            aoa_elevation,
-            aoa_elevation_fom,
-            rssi,
-            tx_timestamp,
-            rx_timestamp,
-            anchor_cfo,
-            cfo,
-            initiator_reply_time,
-            responder_reply_time,
-            initiator_responder_tof,
-            dt_anchor_location: dt_anchor_location.to_vec(),
-            ranging_rounds: ranging_round.to_vec(),
-            total_size: ptr,
-        })
-    }
-    pub fn get_total_size(&self) -> usize {
-        self.total_size
-    }
-}
-
-#[derive(Debug, Clone, PartialEq)]
-pub struct ShortAddressDlTdoaRangingMeasurement {
-    pub mac_address: u16,
-    pub measurement: DlTdoaRangingMeasurement,
-}
-
-impl ShortAddressDlTdoaRangingMeasurement {
-    /// Parse the `payload` byte buffer from PDL to the vector of measurement.
-    pub fn parse(bytes: &[u8], no_of_ranging_measurement: u8) -> Option<Vec<Self>> {
-        let mut ptr = 0;
-        let mut measurements = vec![];
-        let mut count = 0;
-        while (count < no_of_ranging_measurement) {
-            let mac_address = extract_u16(bytes, &mut ptr, 2)?;
-            let rem = &bytes[ptr..];
-            let measurement = DlTdoaRangingMeasurement::parse_one(rem);
-            match measurement {
-                Some(measurement) => {
-                    ptr += measurement.get_total_size();
-                    measurements
-                        .push(ShortAddressDlTdoaRangingMeasurement { mac_address, measurement });
-                    count = count + 1;
-                }
-                None => return None,
-            }
-        }
-        Some(measurements)
-    }
-}
-
-#[derive(Debug, Clone, PartialEq)]
-pub struct ExtendedAddressDlTdoaRangingMeasurement {
-    pub mac_address: u64,
-    pub measurement: DlTdoaRangingMeasurement,
-}
-
-impl ExtendedAddressDlTdoaRangingMeasurement {
-    /// Parse the `payload` byte buffer from PDL to the vector of measurement.
-    pub fn parse(bytes: &[u8], no_of_ranging_measurement: u8) -> Option<Vec<Self>> {
-        let mut ptr = 0;
-        let mut measurements = vec![];
-        let mut count = 0;
-        while (count < no_of_ranging_measurement) {
-            let mac_address = extract_u64(bytes, &mut ptr, 8)?;
-            let rem = &bytes[ptr..];
-            let measurement = DlTdoaRangingMeasurement::parse_one(rem);
-            match measurement {
-                Some(measurement) => {
-                    ptr += measurement.get_total_size();
-                    measurements
-                        .push(ExtendedAddressDlTdoaRangingMeasurement { mac_address, measurement });
-                    count = count + 1;
-                }
-                None => return None,
-            }
-        }
-        Some(measurements)
-    }
-}
-
-pub fn extract_vec(bytes: &[u8], ptr: &mut usize, consumed_size: usize) -> Option<Vec<u8>> {
-    if bytes.len() < *ptr + consumed_size {
-        return None;
-    }
-
-    let res = bytes[*ptr..*ptr + consumed_size].to_vec();
-    *ptr += consumed_size;
-    Some(res)
-}
-
-/// Generate the function that extracts the value from byte buffers.
-macro_rules! generate_extract_func {
-    ($func_name:ident, $type:ty) => {
-        /// Extract the value from |byte[ptr..ptr + consumed_size]| in little endian.
-        fn $func_name(bytes: &[u8], ptr: &mut usize, consumed_size: usize) -> Option<$type> {
-            const type_size: usize = std::mem::size_of::<$type>();
-            if consumed_size > type_size {
-                return None;
-            }
-
-            let extracted_bytes = extract_vec(bytes, ptr, consumed_size)?;
-            let mut le_bytes = [0; type_size];
-            le_bytes[0..consumed_size].copy_from_slice(&extracted_bytes);
-            Some(<$type>::from_le_bytes(le_bytes))
-        }
-    };
-}
-
-generate_extract_func!(extract_u8, u8);
-generate_extract_func!(extract_u16, u16);
-generate_extract_func!(extract_u32, u32);
-generate_extract_func!(extract_u64, u64);
-
-// The GroupIdOrDataPacketFormat enum has all the values defined in both the GroupId and
-// DataPacketFormat enums. It represents the same bits in UCI packet header - the GID field in
-// a UCI control packet, and the DataPacketFormat field in a UCI data packet. Hence the unwrap()
-// calls in the conversions below should always succeed (as long as care is taken in future, to
-// keep the two enums in sync, for any additional values defined in the UCI spec).
-impl From<GroupId> for GroupIdOrDataPacketFormat {
-    fn from(gid: GroupId) -> Self {
-        GroupIdOrDataPacketFormat::try_from(u8::from(gid)).unwrap()
-    }
-}
-
-impl From<GroupIdOrDataPacketFormat> for GroupId {
-    fn from(gid_or_dpf: GroupIdOrDataPacketFormat) -> Self {
-        GroupId::try_from(u8::from(gid_or_dpf)).unwrap()
-    }
-}
-
-impl From<DataPacketFormat> for GroupIdOrDataPacketFormat {
-    fn from(dpf: DataPacketFormat) -> Self {
-        GroupIdOrDataPacketFormat::try_from(u8::from(dpf)).unwrap()
-    }
-}
-
-// The GroupIdOrDataPacketFormat enum has more values defined (for the GroupId bits) than the
-// DataPacketFormat enum. Hence this is implemented as TryFrom() instead of From().
-impl TryFrom<GroupIdOrDataPacketFormat> for DataPacketFormat {
-    type Error = DecodeError;
-
-    fn try_from(gid_or_dpf: GroupIdOrDataPacketFormat) -> Result<Self, DecodeError> {
-        DataPacketFormat::try_from(u8::from(gid_or_dpf)).or(Err(DecodeError::InvalidPacketError))
-    }
-}
-
-// Container for UCI packet header fields.
-struct UciControlPacketHeader {
-    message_type: MessageType,
-    group_id: GroupId,
-    opcode: u8,
-}
-
-impl UciControlPacketHeader {
-    fn new(message_type: MessageType, group_id: GroupId, opcode: u8) -> Result<Self, DecodeError> {
-        if !is_uci_control_packet(message_type) {
-            return Err(DecodeError::InvalidPacketError);
-        }
-
-        Ok(UciControlPacketHeader {
-            message_type: message_type,
-            group_id: group_id,
-            opcode: opcode,
-        })
-    }
-}
-
-// Helper methods to extract the UCI Packet header fields.
-fn get_mt_from_uci_packet(packet: &[u8]) -> u8 {
-    (packet[UCI_HEADER_MT_BYTE_POSITION] >> UCI_HEADER_MT_BIT_SHIFT) & UCI_HEADER_MT_MASK
-}
-
-fn get_pbf_from_uci_packet(packet: &[u8]) -> u8 {
-    (packet[UCI_HEADER_PBF_BYTE_POSITION] >> UCI_HEADER_PBF_BIT_SHIFT) & UCI_HEADER_PBF_MASK
-}
-
-fn get_gid_from_uci_control_packet(packet: &[u8]) -> u8 {
-    packet[UCI_CONTROL_HEADER_GID_BYTE_POSITION] & UCI_CONTROL_HEADER_GID_MASK
-}
-
-fn get_oid_from_uci_control_packet(packet: &[u8]) -> u8 {
-    packet[UCI_CONTROL_HEADER_OID_BYTE_POSITION] & UCI_CONTROL_HEADER_OID_MASK
-}
-
-// This function parses the packet bytes to return the Control Packet Opcode (OID) field. The
-// caller should check that the packet bytes represent a UCI control packet. The code will not
-// panic because UciPacketHal::encode_to_bytes() should always be larger then the place we access.
-fn get_opcode_from_uci_control_packet(packet: &UciPacketHal) -> u8 {
-    get_oid_from_uci_control_packet(&packet.encode_to_bytes().unwrap())
-}
-
-fn is_uci_control_packet(message_type: MessageType) -> bool {
-    match message_type {
-        MessageType::Command
-        | MessageType::Response
-        | MessageType::Notification
-        | MessageType::ReservedForTesting1
-        | MessageType::ReservedForTesting2 => true,
-        _ => false,
-    }
-}
-
-pub fn build_uci_control_packet(
-    message_type: MessageType,
-    group_id: GroupId,
-    opcode: u8,
-    payload: Option<Bytes>,
-) -> Option<UciControlPacket> {
-    if !is_uci_control_packet(message_type) {
-        error!("Only control packets are allowed, MessageType: {message_type:?}");
-        return None;
-    }
-    Some(UciControlPacketBuilder { group_id, message_type, opcode, payload }.build())
-}
-
-// Ensure that the new packet fragment belong to the same packet.
-fn is_same_control_packet(header: &UciControlPacketHeader, packet: &UciPacketHal) -> bool {
-    is_uci_control_packet(header.message_type)
-        && header.message_type == packet.get_message_type()
-        && header.group_id == packet.get_group_id_or_data_packet_format().into()
-        && header.opcode == get_opcode_from_uci_control_packet(packet)
-}
-
-fn is_device_state_err_control_packet(packet: &UciPacketHal) -> bool {
-    packet.get_message_type() == MessageType::Notification.into()
-        && packet.get_group_id_or_data_packet_format() == GroupIdOrDataPacketFormat::Core.into()
-        && get_opcode_from_uci_control_packet(packet) == CoreOpCode::CoreDeviceStatusNtf.into()
-        && packet.encode_to_vec().unwrap()[UCI_PACKET_HAL_HEADER_LEN]
-            == DeviceState::DeviceStateError.into()
-}
-
-impl UciControlPacket {
-    // For some usage, we need to get the raw payload.
-    pub fn to_raw_payload(self) -> Vec<u8> {
-        self.encode_to_bytes().unwrap().slice(UCI_PACKET_HEADER_LEN..).to_vec()
-    }
-}
-
-// Helper to convert from vector of |UciPacketHal| to |UciControlPacket|. An example
-// usage is to convert a list UciPacketHAL fragments to one UciPacket, during de-fragmentation.
-impl TryFrom<Vec<UciPacketHal>> for UciControlPacket {
-    type Error = DecodeError;
-
-    fn try_from(packets: Vec<UciPacketHal>) -> Result<Self, DecodeError> {
-        if packets.is_empty() {
-            return Err(DecodeError::InvalidPacketError);
-        }
-
-        // Store header info from the first packet.
-        let header = UciControlPacketHeader::new(
-            packets[0].get_message_type(),
-            packets[0].get_group_id_or_data_packet_format().into(),
-            get_opcode_from_uci_control_packet(&packets[0]),
-        )?;
-
-        // Create the reassembled payload.
-        let mut payload_buf = BytesMut::new();
-        for packet in packets {
-            // Ensure that the new fragment is part of the same packet.
-            if !is_same_control_packet(&header, &packet) {
-                // if DEVICE_STATE_ERROR notification is received while waiting for remaining fragments,
-                // process it and send to upper layer for device recovery
-                if is_device_state_err_control_packet(&packet) {
-                    error!("Received device reset error: {:?}", packet);
-                    return UciControlPacket::parse(
-                        &UciControlPacketBuilder {
-                            message_type: packet.get_message_type(),
-                            group_id: packet.get_group_id_or_data_packet_format().into(),
-                            opcode: get_opcode_from_uci_control_packet(&packet),
-                            payload: Some(
-                                packet
-                                    .encode_to_bytes()
-                                    .unwrap()
-                                    .slice(UCI_PACKET_HAL_HEADER_LEN..),
-                            ),
-                        }
-                        .build()
-                        .encode_to_bytes()
-                        .unwrap(),
-                    );
-                }
-                error!("Received unexpected fragment: {:?}", packet);
-                return Err(DecodeError::InvalidPacketError);
-            }
-            // get payload by stripping the header.
-            payload_buf.extend_from_slice(
-                &packet.encode_to_bytes().unwrap().slice(UCI_PACKET_HAL_HEADER_LEN..),
-            )
-        }
-
-        // Create assembled |UciControlPacket| and convert to bytes again since we need to
-        // reparse the packet after defragmentation to get the appropriate message.
-        UciControlPacket::parse(
-            &UciControlPacketBuilder {
-                message_type: header.message_type,
-                group_id: header.group_id,
-                opcode: header.opcode,
-                payload: Some(payload_buf.into()),
-            }
-            .build()
-            .encode_to_bytes()
-            .unwrap(),
-        )
-    }
-}
-
-#[derive(Debug, Clone)]
-pub struct RawUciControlPacket {
-    pub mt: u8,
-    pub gid: u8,
-    pub oid: u8,
-    pub payload: Vec<u8>,
-}
-
-impl RawUciControlPacket {
-    // Match the GID and OID to confirm the UCI packet (represented by header) is
-    // the same as the stored signature. We don't match the MT because they can be
-    // different (eg: CMD/RSP pair).
-    pub fn is_same_signature_bytes(&self, header: &[u8]) -> bool {
-        let gid = get_gid_from_uci_control_packet(header);
-        let oid = get_oid_from_uci_control_packet(header);
-        gid == self.gid && oid == self.oid
-    }
-}
-
-fn is_uci_data_packet(message_type: MessageType) -> bool {
-    message_type == MessageType::Data
-}
-
-fn is_data_rcv_or_radar_format(data_packet_format: DataPacketFormat) -> bool {
-    data_packet_format == DataPacketFormat::DataRcv
-        || data_packet_format == DataPacketFormat::RadarDataMessage
-}
-
-fn try_into_data_payload(
-    packet: UciPacketHal,
-    expected_data_packet_format: DataPacketFormat,
-) -> Result<Bytes, DecodeError> {
-    let dpf: DataPacketFormat = packet.get_group_id_or_data_packet_format().try_into()?;
-    if is_uci_data_packet(packet.get_message_type()) && dpf == expected_data_packet_format {
-        Ok(packet.encode_to_bytes().unwrap().slice(UCI_PACKET_HAL_HEADER_LEN..))
-    } else {
-        error!("Received unexpected data packet fragment: {:?}", packet);
-        Err(DecodeError::InvalidPacketError)
-    }
-}
-
-// Helper to convert from vector of |UciPacketHal| to |UciDataPacket|. An example
-// usage is to convert a list UciPacketHAL fragments to one UciPacket, during de-fragmentation.
-impl TryFrom<Vec<UciPacketHal>> for UciDataPacket {
-    type Error = DecodeError;
-
-    fn try_from(packets: Vec<UciPacketHal>) -> Result<Self, DecodeError> {
-        if packets.is_empty() {
-            return Err(DecodeError::InvalidPacketError);
-        }
-
-        let dpf: DataPacketFormat = packets[0].get_group_id_or_data_packet_format().try_into()?;
-        if !is_data_rcv_or_radar_format(dpf) {
-            error!("Unexpected data packet format {:?}", dpf);
-        }
-
-        // Create the reassembled payload.
-        let mut payload_buf = Bytes::new();
-        for packet in packets {
-            // Ensure that the fragment is a Data Rcv packet.
-            // Get payload by stripping the header.
-            payload_buf = [payload_buf, try_into_data_payload(packet, dpf)?].concat().into();
-        }
-
-        // Create assembled |UciDataPacket| and convert to bytes again since we need to
-        // reparse the packet after defragmentation to get the appropriate message.
-        UciDataPacket::parse(
-            &UciDataPacketBuilder {
-                message_type: MessageType::Data,
-                data_packet_format: dpf,
-                payload: Some(payload_buf.into()),
-            }
-            .build()
-            .encode_to_bytes()
-            .unwrap(),
-        )
-    }
-}
-
-// Helper to convert from |UciControlPacket| to vector of |UciControlPacketHal|s. An
-// example usage is to do this conversion for fragmentation (from Host to UWBS).
-impl From<UciControlPacket> for Vec<UciControlPacketHal> {
-    fn from(packet: UciControlPacket) -> Self {
-        // Store header info.
-        let header = match UciControlPacketHeader::new(
-            packet.get_message_type(),
-            packet.get_group_id(),
-            packet.get_opcode(),
-        ) {
-            Ok(hdr) => hdr,
-            _ => {
-                error!(
-                    "Unable to parse UciControlPacketHeader from UciControlPacket: {:?}",
-                    packet
-                );
-                return Vec::new();
-            }
-        };
-
-        let mut fragments = Vec::new();
-        // get payload by stripping the header.
-        let payload = packet.encode_to_bytes().unwrap().slice(UCI_PACKET_HEADER_LEN..);
-        if payload.is_empty() {
-            fragments.push(
-                UciControlPacketHalBuilder {
-                    message_type: header.message_type,
-                    group_id_or_data_packet_format: header.group_id.into(),
-                    opcode: header.opcode,
-                    packet_boundary_flag: PacketBoundaryFlag::Complete,
-                    payload: None,
-                }
-                .build(),
-            );
-        } else {
-            let mut fragments_iter = payload.chunks(MAX_PAYLOAD_LEN).peekable();
-            while let Some(fragment) = fragments_iter.next() {
-                // Set the last fragment complete if this is last fragment.
-                let pbf = if let Some(nxt_fragment) = fragments_iter.peek() {
-                    PacketBoundaryFlag::NotComplete
-                } else {
-                    PacketBoundaryFlag::Complete
-                };
-                fragments.push(
-                    UciControlPacketHalBuilder {
-                        message_type: header.message_type,
-                        group_id_or_data_packet_format: header.group_id.into(),
-                        opcode: header.opcode,
-                        packet_boundary_flag: pbf,
-                        payload: Some(Bytes::from(fragment.to_owned())),
-                    }
-                    .build(),
-                );
-            }
-        }
-        fragments
-    }
-}
-
-// Helper to convert From<UciDataSnd> into Vec<UciDataPacketHal>. An
-// example usage is for fragmentation in the Data Packet Tx flow.
-pub fn fragment_data_msg_send(packet: UciDataSnd, max_payload_len: usize) -> Vec<UciDataPacketHal> {
-    let mut fragments = Vec::new();
-    let dpf = packet.get_data_packet_format().into();
-
-    // get payload by stripping the header.
-    let payload = packet.encode_to_bytes().unwrap().slice(UCI_DATA_SND_PACKET_HEADER_LEN..);
-    if payload.is_empty() {
-        fragments.push(
-            UciDataPacketHalBuilder {
-                group_id_or_data_packet_format: dpf,
-                packet_boundary_flag: PacketBoundaryFlag::Complete,
-                payload: None,
-            }
-            .build(),
-        );
-    } else {
-        let mut fragments_iter = payload.chunks(max_payload_len).peekable();
-        while let Some(fragment) = fragments_iter.next() {
-            // Set the last fragment complete if this is last fragment.
-            let pbf = if let Some(nxt_fragment) = fragments_iter.peek() {
-                PacketBoundaryFlag::NotComplete
-            } else {
-                PacketBoundaryFlag::Complete
-            };
-            fragments.push(
-                UciDataPacketHalBuilder {
-                    group_id_or_data_packet_format: dpf,
-                    packet_boundary_flag: pbf,
-                    payload: Some(Bytes::from(fragment.to_owned())),
-                }
-                .build(),
-            );
-        }
-    }
-    fragments
-}
-
-#[derive(Default, Debug)]
-pub struct PacketDefrager {
-    // Cache to store incoming fragmented packets in the middle of reassembly.
-    // Will be empty if there is no reassembly in progress.
-    // TODO(b/261762781): Prefer this to be UciControlPacketHal
-    control_fragment_cache: Vec<UciPacketHal>,
-    // TODO(b/261762781): Prefer this to be UciDataPacketHal
-    data_fragment_cache: Vec<UciPacketHal>,
-    // Raw packet payload bytes cache
-    raw_fragment_cache: Vec<u8>,
-}
-
-pub enum UciDefragPacket {
-    Control(UciControlPacket),
-    Data(UciDataPacket),
-    Raw(Result<(), DecodeError>, RawUciControlPacket),
-}
-
-impl PacketDefrager {
-    pub fn defragment_packet(
-        &mut self,
-        msg: &[u8],
-        last_raw_cmd: Option<RawUciControlPacket>,
-    ) -> Option<UciDefragPacket> {
-        if let Some(raw_cmd) = last_raw_cmd {
-            let mt_u8 = get_mt_from_uci_packet(msg);
-            match MessageType::try_from(u8::from(mt_u8)) {
-                Ok(mt) => match mt {
-                    // Parse only a UCI response packet as a Raw packet.
-                    MessageType::Response => {
-                        return self.defragment_raw_uci_response_packet(msg, raw_cmd);
-                    }
-                    _ => { /* Fallthrough to de-frag as a normal UCI packet below */ }
-                },
-                Err(_) => {
-                    error!("Rx packet from HAL has unrecognized MT={}", mt_u8);
-                    return Some(UciDefragPacket::Raw(
-                        Err(DecodeError::InvalidPacketError),
-                        RawUciControlPacket { mt: mt_u8, gid: 0, oid: 0, payload: Vec::new() },
-                    ));
-                }
-            };
-        }
-
-        let packet = UciPacketHal::parse(msg)
-            .or_else(|e| {
-                error!("Failed to parse packet: {:?}", e);
-                Err(e)
-            })
-            .ok()?;
-
-        let pbf = packet.get_packet_boundary_flag();
-
-        // TODO(b/261762781): The current implementation allows for the possibility that we receive
-        // interleaved Control/Data HAL packets, and so uses separate caches for them. In the
-        // future, if we determine that interleaving is not possible, this can be simplified.
-        if is_uci_control_packet(packet.get_message_type()) {
-            // Add the incoming fragment to the control packet cache.
-            self.control_fragment_cache.push(packet);
-            if pbf == PacketBoundaryFlag::NotComplete {
-                // Wait for remaining fragments.
-                return None;
-            }
-
-            // All fragments received, defragment the control packet.
-            match self.control_fragment_cache.drain(..).collect::<Vec<_>>().try_into() {
-                Ok(packet) => Some(UciDefragPacket::Control(packet)),
-                Err(e) => {
-                    error!("Failed to defragment control packet: {:?}", e);
-                    None
-                }
-            }
-        } else {
-            // Add the incoming fragment to the data packet cache.
-            self.data_fragment_cache.push(packet);
-            if pbf == PacketBoundaryFlag::NotComplete {
-                // Wait for remaining fragments.
-                return None;
-            }
-
-            // All fragments received, defragment the data packet.
-            match self.data_fragment_cache.drain(..).collect::<Vec<_>>().try_into() {
-                Ok(packet) => Some(UciDefragPacket::Data(packet)),
-                Err(e) => {
-                    error!("Failed to defragment data packet: {:?}", e);
-                    None
-                }
-            }
-        }
-    }
-
-    fn defragment_raw_uci_response_packet(
-        &mut self,
-        msg: &[u8],
-        raw_cmd: RawUciControlPacket,
-    ) -> Option<UciDefragPacket> {
-        let mt_u8 = get_mt_from_uci_packet(msg);
-        let pbf = get_pbf_from_uci_packet(msg);
-        let gid = get_gid_from_uci_control_packet(msg);
-        let oid = get_oid_from_uci_control_packet(msg);
-        if raw_cmd.is_same_signature_bytes(msg) {
-            // Store only the packet payload bytes (UCI header should not be stored).
-            self.raw_fragment_cache.extend_from_slice(&msg[UCI_PACKET_HAL_HEADER_LEN..]);
-
-            if pbf == u8::from(PacketBoundaryFlag::NotComplete) {
-                return None;
-            }
-
-            // All fragments received, defragment and return the Raw packet's payload bytes.
-            return Some(UciDefragPacket::Raw(
-                Ok(()),
-                RawUciControlPacket {
-                    mt: mt_u8,
-                    gid,
-                    oid,
-                    payload: self.raw_fragment_cache.drain(..).collect(),
-                },
-            ));
-        } else {
-            error!(
-                "Rx packet from HAL (MT={}, PBF={}, GID={}, OID={}) has non-matching\
-                   RawCmd signature",
-                mt_u8, pbf, gid, oid
-            );
-            return Some(UciDefragPacket::Raw(
-                Err(DecodeError::InvalidPacketError),
-                RawUciControlPacket { mt: mt_u8, gid, oid, payload: Vec::new() },
-            ));
-        }
-    }
-}
-
-#[allow(dead_code)]
-#[derive(Debug, Clone)]
-pub struct ParsedDiagnosticNtfPacket {
-    session_token: u32,
-    sequence_number: u32,
-    frame_reports: Vec<ParsedFrameReport>,
-}
-
-#[allow(dead_code)]
-#[derive(Clone)]
-pub struct ParsedFrameReport {
-    uwb_msg_id: u8,
-    action: u8,
-    antenna_set: u8,
-    rssi: Vec<u8>,
-    aoa: Vec<AoaMeasurement>,
-    cir: Vec<CirValue>,
-    segment_metrics: Vec<SegmentMetricsValue>,
-}
-
-pub fn parse_diagnostics_ntf(
-    evt: AndroidRangeDiagnosticsNtf,
-) -> Result<ParsedDiagnosticNtfPacket, DecodeError> {
-    let session_token = evt.get_session_token();
-    let sequence_number = evt.get_sequence_number();
-    let mut parsed_frame_reports = Vec::new();
-    for report in evt.get_frame_reports() {
-        let mut rssi_vec = Vec::new();
-        let mut aoa_vec = Vec::new();
-        let mut cir_vec = Vec::new();
-        let mut segment_metrics_vec = Vec::new();
-        for tlv in &report.frame_report_tlvs {
-            match FrameReportTlvPacket::parse(
-                &[vec![tlv.t as u8, tlv.v.len() as u8, (tlv.v.len() >> 8) as u8], tlv.v.clone()]
-                    .concat(),
-            ) {
-                Ok(pkt) => match pkt.specialize() {
-                    FrameReportTlvPacketChild::Rssi(rssi) => {
-                        rssi_vec.append(&mut rssi.get_rssi().clone())
-                    }
-                    FrameReportTlvPacketChild::Aoa(aoa) => {
-                        aoa_vec.append(&mut aoa.get_aoa().clone())
-                    }
-                    FrameReportTlvPacketChild::Cir(cir) => {
-                        cir_vec.append(&mut cir.get_cir_value().clone())
-                    }
-                    FrameReportTlvPacketChild::SegmentMetrics(sm) => {
-                        segment_metrics_vec.append(&mut sm.get_segment_metrics().clone())
-                    }
-                    _ => return Err(DecodeError::InvalidPacketError),
-                },
-                Err(e) => {
-                    error!("Failed to parse the packet {:?}", e);
-                    return Err(DecodeError::InvalidPacketError);
-                }
-            }
-        }
-        parsed_frame_reports.push(ParsedFrameReport {
-            uwb_msg_id: report.uwb_msg_id,
-            action: report.action,
-            antenna_set: report.antenna_set,
-            rssi: rssi_vec,
-            aoa: aoa_vec,
-            cir: cir_vec,
-            segment_metrics: segment_metrics_vec,
-        });
-    }
-    Ok(ParsedDiagnosticNtfPacket {
-        session_token,
-        sequence_number,
-        frame_reports: parsed_frame_reports,
-    })
-}
-
-#[derive(Debug, Clone, PartialEq)]
-pub enum Controlees {
-    NoSessionKey(Vec<Controlee>),
-    ShortSessionKey(Vec<Controlee_V2_0_16_Byte_Version>),
-    LongSessionKey(Vec<Controlee_V2_0_32_Byte_Version>),
-}
-
-// TODO(ziyiw): Replace these functions after making uwb_uci_packets::Controlee::write_to() public.
-pub fn write_controlee(controlee: &Controlee) -> BytesMut {
-    let mut buffer = BytesMut::new();
-    buffer.extend_from_slice(&controlee.short_address);
-    let subsession_id = controlee.subsession_id;
-    buffer.extend_from_slice(&subsession_id.to_le_bytes()[0..4]);
-    buffer
-}
-
-pub fn write_controlee_2_0_16byte(controlee: &Controlee_V2_0_16_Byte_Version) -> BytesMut {
-    let mut buffer = BytesMut::new();
-    buffer.extend_from_slice(&controlee.short_address);
-    let subsession_id = controlee.subsession_id;
-    buffer.extend_from_slice(&subsession_id.to_le_bytes()[0..4]);
-    buffer.extend_from_slice(&controlee.subsession_key);
-    buffer
-}
-
-pub fn write_controlee_2_0_32byte(controlee: &Controlee_V2_0_32_Byte_Version) -> BytesMut {
-    let mut buffer = BytesMut::new();
-    buffer.extend_from_slice(&controlee.short_address);
-    let subsession_id = controlee.subsession_id;
-    buffer.extend_from_slice(&subsession_id.to_le_bytes()[0..4]);
-    buffer.extend_from_slice(&controlee.subsession_key);
-    buffer
-}
-
-/// Generate the SessionUpdateControllerMulticastListCmd packet.
-///
-/// This function can build the packet with/without message control, which
-/// is indicated by action parameter.
-pub fn build_session_update_controller_multicast_list_cmd(
-    session_token: u32,
-    action: UpdateMulticastListAction,
-    controlees: Controlees,
-) -> Result<SessionUpdateControllerMulticastListCmd, DecodeError> {
-    let mut controlees_buf = BytesMut::new();
-    match controlees {
-        Controlees::NoSessionKey(controlee_v1) => {
-            controlees_buf.extend_from_slice(&(controlee_v1.len() as u8).to_le_bytes());
-            for controlee in controlee_v1 {
-                controlees_buf.extend_from_slice(&write_controlee(&controlee));
-            }
-        }
-        Controlees::ShortSessionKey(controlee_v2)
-            if action == UpdateMulticastListAction::AddControleeWithShortSubSessionKey =>
-        {
-            controlees_buf.extend_from_slice(&(controlee_v2.len() as u8).to_le_bytes());
-            for controlee in controlee_v2 {
-                controlees_buf.extend_from_slice(&write_controlee_2_0_16byte(&controlee));
-            }
-        }
-        Controlees::LongSessionKey(controlee_v2)
-            if action == UpdateMulticastListAction::AddControleeWithLongSubSessionKey =>
-        {
-            controlees_buf.extend_from_slice(&(controlee_v2.len() as u8).to_le_bytes());
-            for controlee in controlee_v2 {
-                controlees_buf.extend_from_slice(&write_controlee_2_0_32byte(&controlee));
-            }
-        }
-        _ => return Err(DecodeError::InvalidPacketError),
-    }
-    Ok(SessionUpdateControllerMulticastListCmdBuilder {
-        session_token,
-        action,
-        payload: Some(controlees_buf.freeze()),
-    }
-    .build())
-}
-
-/// building Data transfer phase config command
-pub fn build_data_transfer_phase_config_cmd(
-    session_token: u32,
-    dtpcm_repetition: u8,
-    data_transfer_control: u8,
-    dtpml_size: u8,
-    mac_address: Vec<u8>,
-    slot_bitmap: Vec<u8>,
-    stop_data_transfer: Vec<u8>,
-) -> Result<SessionDataTransferPhaseConfigCmd, DecodeError> {
-    let mut dtpml_buffer = BytesMut::new();
-
-    //calculate mac address mode from data transfer control
-    let mac_address_mode = data_transfer_control & 0x01;
-
-    // Calculate mac address size based on address mode
-    let mac_address_size = match mac_address_mode {
-        SHORT_ADDRESS => 2,
-        EXTENDED_ADDRESS => 8,
-        _ => return Err(DecodeError::InvalidPacketError),
-    };
-
-    // Calculate slot bitmap size from data transfer control
-    let slot_bitmap_size = 1 << ((data_transfer_control & 0x0F) >> 1);
-
-    // Prepare segmented vectors for mac_address
-    let mac_address_vec: Vec<_> =
-        mac_address.chunks(mac_address_size).map(|chunk| chunk.to_owned()).collect();
-
-    // Prepare segmented vectors for slot_bitmap
-    let slot_bitmap_vec: Vec<_> =
-        slot_bitmap.chunks(slot_bitmap_size).map(|chunk| chunk.to_owned()).collect();
-
-    // Validate sizes of mac_address and slot_bitmap
-    if slot_bitmap_vec.len() != dtpml_size.into() || mac_address_vec.len() != dtpml_size.into() {
-        return Err(DecodeError::InvalidPacketError);
-    }
-
-    // Prepare segmented vectors for stop_data_transfer
-    let stop_data_transfer_vector: Vec<_> =
-        stop_data_transfer.chunks(1).map(|chunk| chunk.to_owned()).collect();
-
-    // Combine segmented vectors into dtpml_buffer
-    for ((elem1, elem2), elem3) in mac_address_vec
-        .into_iter()
-        .zip(slot_bitmap_vec.into_iter())
-        .zip(stop_data_transfer.into_iter())
-    {
-        dtpml_buffer.extend_from_slice(&elem1);
-        dtpml_buffer.extend_from_slice(&elem2);
-        dtpml_buffer.extend_from_slice(&[elem3]);
-    }
-
-    Ok(SessionDataTransferPhaseConfigCmdBuilder {
-        session_token,
-        dtpcm_repetition,
-        data_transfer_control,
-        dtpml_size,
-        payload: Some(dtpml_buffer.freeze()),
-    }
-    .build())
-}
-
-impl Drop for AppConfigTlv {
-    fn drop(&mut self) {
-        if self.cfg_id == AppConfigTlvType::VendorId || self.cfg_id == AppConfigTlvType::StaticStsIv
-        {
-            self.v.zeroize();
-        }
-    }
-}
-
-// Radar data 'bits per sample' field isn't a raw value, instead it's an enum
-// that maps to the raw value. We need this mapping to get the max sample size
-// length.
-pub fn radar_bytes_per_sample_value(bps: BitsPerSample) -> u8 {
-    match bps {
-        BitsPerSample::Value32 => 4,
-        BitsPerSample::Value48 => 6,
-        BitsPerSample::Value64 => 8,
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_parse_diagnostics_ntf() {
-        let rssi_vec = vec![0x01, 0x02, 0x03];
-        let rssi = RssiBuilder { rssi: rssi_vec.clone() }.build();
-        let aoa_1 = AoaMeasurement { tdoa: 1, pdoa: 2, aoa: 3, fom: 4, t: 1 };
-        let aoa_2 = AoaMeasurement { tdoa: 5, pdoa: 6, aoa: 7, fom: 8, t: 2 };
-        let aoa = AoaBuilder { aoa: vec![aoa_1.clone(), aoa_2.clone()] }.build();
-        let cir_vec = vec![CirValue {
-            first_path_index: 1,
-            first_path_snr: 2,
-            first_path_ns: 3,
-            peak_path_index: 4,
-            peak_path_snr: 5,
-            peak_path_ns: 6,
-            first_path_sample_offset: 7,
-            samples_number: 2,
-            sample_window: vec![0, 1, 2, 3],
-        }];
-        let cir = CirBuilder { cir_value: cir_vec.clone() }.build();
-        let segment_metrics_vec = vec![SegmentMetricsValue {
-            receiver_and_segment: ReceiverAndSegmentValue::parse(&[1]).unwrap(),
-            rf_noise_floor: 2,
-            segment_rsl: 3,
-            first_path: PathSample { index: 4, rsl: 5, time_ns: 6 },
-            peak_path: PathSample { index: 7, rsl: 8, time_ns: 9 },
-        }];
-        let segment_metrics =
-            SegmentMetricsBuilder { segment_metrics: segment_metrics_vec.clone() }.build();
-        let mut frame_reports = Vec::new();
-        let tlvs = vec![
-            FrameReportTlv { t: rssi.get_t(), v: rssi.get_rssi().to_vec() },
-            FrameReportTlv { t: aoa.get_t(), v: aoa.encode_to_vec().unwrap()[3..].to_vec() },
-            FrameReportTlv { t: cir.get_t(), v: cir.encode_to_vec().unwrap()[3..].to_vec() },
-            FrameReportTlv {
-                t: segment_metrics.get_t(),
-                v: segment_metrics.encode_to_vec().unwrap()[3..].to_vec(),
-            },
-        ];
-        let frame_report =
-            FrameReport { uwb_msg_id: 1, action: 1, antenna_set: 1, frame_report_tlvs: tlvs };
-        frame_reports.push(frame_report);
-        let packet = AndroidRangeDiagnosticsNtfBuilder {
-            session_token: 1,
-            sequence_number: 1,
-            frame_reports,
-        }
-        .build();
-        let mut parsed_packet = parse_diagnostics_ntf(packet).unwrap();
-        let parsed_frame_report = parsed_packet.frame_reports.pop().unwrap();
-        assert_eq!(rssi_vec, parsed_frame_report.rssi);
-        assert_eq!(aoa_1, parsed_frame_report.aoa[0]);
-        assert_eq!(aoa_2, parsed_frame_report.aoa[1]);
-        assert_eq!(cir_vec, parsed_frame_report.cir);
-        assert_eq!(segment_metrics_vec, parsed_frame_report.segment_metrics);
-    }
-
-    #[test]
-    fn test_write_controlee() {
-        let short_address: [u8; 2] = [2, 3];
-        let controlee: Controlee = Controlee { short_address, subsession_id: 3 };
-        let bytes = write_controlee(&controlee);
-        let parsed_controlee = Controlee::parse(&bytes).unwrap();
-        assert_eq!(controlee, parsed_controlee);
-    }
-
-    #[test]
-    fn test_build_multicast_update_packet() {
-        let short_address: [u8; 2] = [0x12, 0x34];
-        let controlee = Controlee { short_address, subsession_id: 0x1324_3546 };
-        let packet: UciControlPacket = build_session_update_controller_multicast_list_cmd(
-            0x1425_3647,
-            UpdateMulticastListAction::AddControlee,
-            Controlees::NoSessionKey(vec![controlee; 1]),
-        )
-        .unwrap()
-        .into();
-        let packet_fragments: Vec<UciControlPacketHal> = packet.into();
-        let uci_packet = packet_fragments[0].encode_to_vec();
-        assert_eq!(
-            uci_packet,
-            Ok(vec![
-                0x21, 0x07, 0x00, 0x0c, // 2(packet info), RFU, payload length(12)
-                0x47, 0x36, 0x25, 0x14, // 4(session id (LE))
-                0x00, 0x01, 0x12, 0x34, // action, # controlee, 2(short address (LE))
-                0x46, 0x35, 0x24, 0x13, // 4(subsession id (LE))
-            ])
-        );
-    }
-
-    #[test]
-    fn test_build_multicast_update_packet_v2_short_session_key() {
-        let short_address: [u8; 2] = [0x12, 0x34];
-        let controlee = Controlee_V2_0_16_Byte_Version {
-            short_address,
-            subsession_id: 0x1324_3546,
-            subsession_key: [
-                0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,
-                0xcd, 0xef,
-            ],
-        };
-        let packet: UciControlPacket = build_session_update_controller_multicast_list_cmd(
-            0x1425_3647,
-            UpdateMulticastListAction::AddControleeWithShortSubSessionKey,
-            Controlees::ShortSessionKey(vec![controlee; 1]),
-        )
-        .unwrap()
-        .into();
-        let packet_fragments: Vec<UciControlPacketHal> = packet.into();
-        let uci_packet = packet_fragments[0].encode_to_vec();
-        assert_eq!(
-            uci_packet,
-            Ok(vec![
-                0x21, 0x07, 0x00, 0x1c, // 2(packet info), RFU, payload length(28)
-                0x47, 0x36, 0x25, 0x14, // 4(session id (LE))
-                0x02, 0x01, 0x12, 0x34, // action, # controlee, 2(short address (LE))
-                0x46, 0x35, 0x24, 0x13, // 4(subsession id (LE))
-                0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,
-                0xcd, 0xef, // 16(subsession key(LE))
-            ])
-        );
-    }
-
-    #[test]
-    fn test_build_multicast_update_packet_v2_long_session_key() {
-        let short_address: [u8; 2] = [0x12, 0x34];
-        let controlee = Controlee_V2_0_32_Byte_Version {
-            short_address,
-            subsession_id: 0x1324_3546,
-            subsession_key: [
-                0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,
-                0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78,
-                0x90, 0xab, 0xcd, 0xef,
-            ],
-        };
-        let packet: UciControlPacket = build_session_update_controller_multicast_list_cmd(
-            0x1425_3647,
-            UpdateMulticastListAction::AddControleeWithLongSubSessionKey,
-            Controlees::LongSessionKey(vec![controlee; 1]),
-        )
-        .unwrap()
-        .into();
-        let packet_fragments: Vec<UciControlPacketHal> = packet.into();
-        let uci_packet = packet_fragments[0].encode_to_vec();
-        assert_eq!(
-            uci_packet,
-            Ok(vec![
-                0x21, 0x07, 0x00, 0x2c, // 2(packet info), RFU, payload length(44)
-                0x47, 0x36, 0x25, 0x14, // 4(session id (LE))
-                0x03, 0x01, 0x12, 0x34, // action, # controlee, 2(short address (LE))
-                0x46, 0x35, 0x24, 0x13, // 4(subsession id (LE))
-                0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,
-                0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78,
-                0x90, 0xab, 0xcd, 0xef, // 32(subsession key(LE))
-            ])
-        );
-    }
-
-    #[test]
-    fn test_to_raw_payload() {
-        let payload = vec![0x11, 0x22, 0x33];
-        let payload_clone = payload.clone();
-        let packet = UciControlPacketBuilder {
-            group_id: GroupId::Test,
-            message_type: MessageType::Response,
-            opcode: 0x5,
-            payload: Some(payload_clone.into()),
-        }
-        .build();
-
-        assert_eq!(payload, packet.to_raw_payload());
-    }
-
-    #[test]
-    fn test_to_raw_payload_empty() {
-        let payload: Vec<u8> = vec![];
-        let packet = UciControlPacketBuilder {
-            group_id: GroupId::Test,
-            message_type: MessageType::Response,
-            opcode: 0x5,
-            payload: None,
-        }
-        .build();
-
-        assert_eq!(payload, packet.to_raw_payload());
-    }
-
-    #[cfg(test)]
-    mod tests {
-        use crate::{extract_u16, extract_u32, extract_u64, extract_u8, extract_vec};
-        #[test]
-        fn test_extract_func() {
-            let bytes = [0x1, 0x3, 0x5, 0x7, 0x9, 0x2, 0x4, 0x05, 0x07, 0x09, 0x0a];
-            let mut ptr = 0;
-
-            let u8_val = extract_u8(&bytes, &mut ptr, 1);
-            assert_eq!(u8_val, Some(0x1));
-            assert_eq!(ptr, 1);
-
-            let u16_val = extract_u16(&bytes, &mut ptr, 2);
-            assert_eq!(u16_val, Some(0x0503));
-            assert_eq!(ptr, 3);
-
-            let u32_val = extract_u32(&bytes, &mut ptr, 3);
-            assert_eq!(u32_val, Some(0x020907));
-            assert_eq!(ptr, 6);
-
-            let u64_val = extract_u64(&bytes, &mut ptr, 5);
-            assert_eq!(u64_val, Some(0x0a09070504));
-            assert_eq!(ptr, 11);
-
-            let vec = extract_vec(&bytes, &mut ptr, 3);
-            assert_eq!(vec, None);
-            assert_eq!(ptr, 11);
-        }
-    }
-
-    #[test]
-    fn test_short_dltdoa_ranging_measurement() {
-        let bytes = [
-            // All Fields in Little Endian (LE)
-            // First measurement
-            0x0a, 0x01, 0x33, 0x05, // 2(Mac address), Status, Message Type
-            0x53, 0x05, 0x02, 0x05, // 2(Message control), 2(Block Index)
-            0x07, 0x09, 0x0a, 0x01, // Round Index, NLoS, 2(AoA Azimuth)
-            0x02, 0x05, 0x07, 0x09, // AoA Azimuth FOM, 2(AoA Elevation), AoA Elevation FOM
-            0x0a, 0x01, 0x02, 0x05, // RSSI, 3(Tx Timestamp..)
-            0x07, 0x09, 0x0a, 0x01, // 4(Tx Timestamp..)
-            0x02, 0x05, 0x07, 0x09, // Tx Timestamp, 3(Rx Timestamp..)
-            0x05, 0x07, 0x09, 0x0a, // 2(Rx Timestamp), 2(Anchor Cfo)
-            0x01, 0x02, 0x05, 0x07, // 2(Cfo), 2(Initiator Reply Time..)
-            0x09, 0x05, 0x07, 0x09, // 2(Initiator Reply Time), 2(Responder Reply Time..)
-            0x0a, 0x01, 0x02, 0x05, // 2(Responder Reply Time), 2(Initiator-Responder ToF)
-            0x07, 0x09, 0x07, 0x09, // 4(Anchor Location..)
-            0x05, 0x07, 0x09, 0x0a, // 4(Anchor Location..)
-            0x01, 0x02, 0x05, 0x07, // 2(Anchor Location..), 2(Active Ranging Rounds..)
-            0x09, 0x0a, 0x01, 0x02, // 4(Active Ranging Rounds..)
-            0x05, 0x07, 0x09, 0x05, // 4(Active Ranging Rounds)
-            // Second measurement
-            0x0a, 0x01, 0x33, 0x05, // 2(Mac address), Status, Message Type
-            0x33, 0x05, 0x02, 0x05, // 2(Message control), 2(Block Index)
-            0x07, 0x09, 0x0a, 0x01, // Round Index, NLoS, 2(AoA Azimuth)
-            0x02, 0x05, 0x07, 0x09, // AoA Azimuth FOM, 2(AoA Elevation), AoA Elevation FOM
-            0x0a, 0x01, 0x02, 0x05, // RSSI, 3(Tx Timestamp..)
-            0x07, 0x09, 0x0a, 0x01, // 4(Tx Timestamp..)
-            0x02, 0x05, 0x07, 0x09, // Tx Timestamp, 3(Rx Timestamp..)
-            0x05, 0x07, 0x09, 0x0a, // 2(Rx Timestamp), 2(Anchor Cfo)
-            0x01, 0x02, 0x05, 0x07, // 2(Cfo), 2(Initiator Reply Time..)
-            0x09, 0x05, 0x07, 0x09, // 2(Initiator Reply Time), 2(Responder Reply Time..)
-            0x0a, 0x01, 0x02, 0x05, // 2(Responder Reply Time), 2(Initiator-Responder ToF)
-            0x07, 0x09, 0x07, 0x09, // 4(Anchor Location..)
-            0x05, 0x07, 0x09, 0x0a, // 4(Anchor Location..)
-            0x01, 0x02, 0x01, 0x02, // 4(Anchor Location)
-            0x05, 0x07, 0x09, 0x0a, // 4(Active Ranging Rounds..)
-            0x01, 0x02, 0x05, 0x07, // 4(Active Ranging Rounds..)
-            0x09, 0x05, // 2(Active Ranging Rounds)
-        ];
-
-        let measurements = ShortAddressDlTdoaRangingMeasurement::parse(&bytes, 2).unwrap();
-        assert_eq!(measurements.len(), 2);
-        let measurement_1 = &measurements[0].measurement;
-        let mac_address_1 = &measurements[0].mac_address;
-        assert_eq!(*mac_address_1, 0x010a);
-        assert_eq!(measurement_1.status, 0x33);
-        assert_eq!(measurement_1.message_type, 0x05);
-        assert_eq!(measurement_1.message_control, 0x0553);
-        assert_eq!(measurement_1.block_index, 0x0502);
-        assert_eq!(measurement_1.round_index, 0x07);
-        assert_eq!(measurement_1.nlos, 0x09);
-        assert_eq!(measurement_1.aoa_azimuth, 0x010a);
-        assert_eq!(measurement_1.aoa_azimuth_fom, 0x02);
-        assert_eq!(measurement_1.aoa_elevation, 0x0705);
-        assert_eq!(measurement_1.aoa_elevation_fom, 0x09);
-        assert_eq!(measurement_1.rssi, 0x0a);
-        assert_eq!(measurement_1.tx_timestamp, 0x02010a0907050201);
-        assert_eq!(measurement_1.rx_timestamp, 0x0705090705);
-        assert_eq!(measurement_1.anchor_cfo, 0x0a09);
-        assert_eq!(measurement_1.cfo, 0x0201);
-        assert_eq!(measurement_1.initiator_reply_time, 0x05090705);
-        assert_eq!(measurement_1.responder_reply_time, 0x010a0907);
-        assert_eq!(measurement_1.initiator_responder_tof, 0x0502);
-        assert_eq!(
-            measurement_1.dt_anchor_location,
-            vec![0x07, 0x09, 0x07, 0x09, 0x05, 0x07, 0x09, 0x0a, 0x01, 0x02]
-        );
-        assert_eq!(
-            measurement_1.ranging_rounds,
-            vec![0x05, 0x07, 0x09, 0x0a, 0x01, 0x02, 0x05, 0x07, 0x09, 0x05,]
-        );
-
-        let measurement_2 = &measurements[1].measurement;
-        let mac_address_2 = &measurements[1].mac_address;
-        assert_eq!(*mac_address_2, 0x010a);
-        assert_eq!(measurement_2.status, 0x33);
-        assert_eq!(measurement_2.message_type, 0x05);
-        assert_eq!(measurement_2.message_control, 0x0533);
-        assert_eq!(measurement_2.block_index, 0x0502);
-        assert_eq!(measurement_2.round_index, 0x07);
-        assert_eq!(measurement_2.nlos, 0x09);
-        assert_eq!(measurement_2.aoa_azimuth, 0x010a);
-        assert_eq!(measurement_2.aoa_azimuth_fom, 0x02);
-        assert_eq!(measurement_2.aoa_elevation, 0x0705);
-        assert_eq!(measurement_2.aoa_elevation_fom, 0x09);
-        assert_eq!(measurement_2.rssi, 0x0a);
-        assert_eq!(measurement_2.tx_timestamp, 0x02010a0907050201);
-        assert_eq!(measurement_2.rx_timestamp, 0x0705090705);
-        assert_eq!(measurement_2.anchor_cfo, 0x0a09);
-        assert_eq!(measurement_2.cfo, 0x0201);
-        assert_eq!(measurement_2.initiator_reply_time, 0x05090705);
-        assert_eq!(measurement_2.responder_reply_time, 0x010a0907);
-        assert_eq!(measurement_2.initiator_responder_tof, 0x0502);
-        assert_eq!(
-            measurement_2.dt_anchor_location,
-            vec![0x07, 0x09, 0x07, 0x09, 0x05, 0x07, 0x09, 0x0a, 0x01, 0x02, 0x01, 0x02]
-        );
-        assert_eq!(
-            measurement_2.ranging_rounds,
-            vec![0x05, 0x07, 0x09, 0x0a, 0x01, 0x02, 0x05, 0x07, 0x09, 0x05,]
-        );
-    }
-
-    #[test]
-    fn test_extended_dltdoa_ranging_measurement() {
-        let bytes = [
-            // All Fields in Little Endian (LE)
-            /* First measurement  */
-            0x0a, 0x01, 0x33, 0x05, // 4(Mac address..)
-            0x33, 0x05, 0x02, 0x05, // 4(Mac address)
-            0x07, 0x09, 0x0a, 0x01, // Status, Message Type, 2(Message control),
-            0x02, 0x05, 0x07, 0x09, // 2(Block Index), Round Index, NLoS,
-            0x0a, 0x01, 0x02, 0x05, // 2(AoA Azimuth), AoA Azimuth FOM, 1(AoA Elevation..)
-            0x07, 0x09, 0x0a, // 1(AoA Elevation), AoA Elevation FOM, RSSI,
-            0x01, 0x02, 0x05, 0x07, // 4(Tx Timestamp..)
-            0x09, 0x05, 0x07, 0x09, // 4(Tx Timestamp),
-            0x0a, 0x01, 0x02, 0x05, // 4(Rx Timestamp..)
-            0x07, 0x09, 0x05, 0x07, // 4(Rx Timestamp)
-            0x09, 0x0a, 0x01, 0x02, // 2(Anchor Cfo), 2(Cfo),
-            0x05, 0x07, 0x09, 0x05, // 4(Initiator Reply Time)
-            0x07, 0x09, 0x0a, 0x01, // 4(Responder Reply Time),
-            0x02, 0x05, 0x02, 0x05, // 2(Initiator-Responder ToF), 2(Active Ranging Rounds)
-        ];
-
-        let measurements = ExtendedAddressDlTdoaRangingMeasurement::parse(&bytes, 1).unwrap();
-        assert_eq!(measurements.len(), 1);
-        let measurement = &measurements[0].measurement;
-        let mac_address = &measurements[0].mac_address;
-        assert_eq!(*mac_address, 0x050205330533010a);
-        assert_eq!(measurement.message_control, 0x010a);
-        assert_eq!(measurement.block_index, 0x0502);
-        assert_eq!(measurement.round_index, 0x07);
-        assert_eq!(measurement.nlos, 0x09);
-        assert_eq!(measurement.aoa_azimuth, 0x010a);
-        assert_eq!(measurement.aoa_azimuth_fom, 0x02);
-        assert_eq!(measurement.aoa_elevation, 0x0705);
-        assert_eq!(measurement.aoa_elevation_fom, 0x09);
-        assert_eq!(measurement.rssi, 0x0a);
-        assert_eq!(measurement.tx_timestamp, 0x0907050907050201);
-        assert_eq!(measurement.rx_timestamp, 0x070509070502010a);
-        assert_eq!(measurement.anchor_cfo, 0x0a09);
-        assert_eq!(measurement.cfo, 0x0201);
-        assert_eq!(measurement.initiator_reply_time, 0x05090705);
-        assert_eq!(measurement.responder_reply_time, 0x010a0907);
-        assert_eq!(measurement.initiator_responder_tof, 0x0502);
-        assert_eq!(measurement.dt_anchor_location, vec![]);
-        assert_eq!(measurement.ranging_rounds, vec![0x02, 0x05]);
-    }
-
-    #[test]
-    fn test_build_data_transfer_phase_config_cmd() {
-        let packet: UciControlPacket = build_data_transfer_phase_config_cmd(
-            0x1234_5678,
-            0x0,
-            0x2,
-            1,
-            vec![0, 1],
-            vec![2, 3],
-            vec![0x00],
-        )
-        .unwrap()
-        .into();
-        let packet_fragments: Vec<UciControlPacketHal> = packet.into();
-        let uci_packet = packet_fragments[0].encode_to_vec();
-        assert_eq!(
-            uci_packet,
-            Ok(vec![
-                0x21, 0x0e, 0x00, 0x0c, // 2(packet info), RFU, payload length(12)
-                0x78, 0x56, 0x34, 0x12, // 4(session id (LE))
-                0x00, 0x02, 0x01, // dtpcm_repetition, data_transfer_control, dtpml_size
-                0x00, 0x01, 0x02, 0x03, // payload
-                0x00, //stop_data_transfer
-            ])
-        );
-    }
-}
diff --git a/src/rust/uwb_uci_packets/uci_packets.pdl b/src/rust/uwb_uci_packets/uci_packets.pdl
deleted file mode 100644
index b23cb3e..0000000
--- a/src/rust/uwb_uci_packets/uci_packets.pdl
+++ /dev/null
@@ -1,1832 +0,0 @@
-little_endian_packets
-
-enum PacketBoundaryFlag : 1 {
-    COMPLETE = 0x00,
-    NOT_COMPLETE = 0x01,
-}
-
-enum GroupId : 4 {
-    CORE = 0x00,
-    SESSION_CONFIG = 0x01,
-    SESSION_CONTROL = 0x02,
-    DATA_CONTROL = 0x03,
-    TEST = 0x0d,
-    VENDOR_RESERVED_9 = 0x09,
-    VENDOR_RESERVED_A = 0x0a,
-    VENDOR_RESERVED_B = 0x0b,
-    VENDOR_ANDROID    = 0x0c,
-    VENDOR_RESERVED_E = 0x0e,
-    VENDOR_RESERVED_F = 0x0f,
-}
-
-enum DataPacketFormat: 4 {
-    DATA_SND = 0x01,
-    DATA_RCV = 0x02,
-    RADAR_DATA_MESSAGE = 0x0f,
-}
-
-// Define a merged enum across GroupId & DataPacketFormat as they are at the same bits in
-// |UciPacketHal|.
-enum GroupIdOrDataPacketFormat : 4 {
-    CORE = 0x00,
-    SESSION_CONFIG_OR_DATA_SND = 0x01,
-    SESSION_CONTROL_OR_DATA_RCV = 0x02,
-    DATA_CONTROL = 0x03,
-    TEST = 0x0d,
-    VENDOR_RESERVED_9 = 0x09,
-    VENDOR_RESERVED_A = 0x0a,
-    VENDOR_RESERVED_B = 0x0b,
-    VENDOR_ANDROID    = 0x0c,
-    VENDOR_RESERVED_E = 0x0e,
-    VENDOR_RESERVED_F = 0x0f,
-}
-
-enum CoreOpCode : 6 {
-    CORE_DEVICE_RESET = 0x00,
-    CORE_DEVICE_STATUS_NTF = 0x01,
-    CORE_DEVICE_INFO = 0x02,
-    CORE_GET_CAPS_INFO = 0x03,
-    CORE_SET_CONFIG = 0x04,
-    CORE_GET_CONFIG = 0x05,
-    CORE_DEVICE_SUSPEND = 0x06,
-    CORE_GENERIC_ERROR_NTF = 0x07,
-    CORE_QUERY_UWBS_TIMESTAMP = 0x08,
-}
-
-enum SessionConfigOpCode : 6 {
-    SESSION_INIT = 0x00,
-    SESSION_DEINIT = 0x01,
-    SESSION_STATUS_NTF = 0x02,
-    SESSION_SET_APP_CONFIG = 0x03,
-    SESSION_GET_APP_CONFIG = 0x04,
-    SESSION_GET_COUNT = 0x05,
-    SESSION_GET_STATE = 0x06,
-    SESSION_UPDATE_CONTROLLER_MULTICAST_LIST = 0x07,
-    SESSION_UPDATE_ACTIVE_ROUNDS_ANCHOR = 0x08,
-    SESSION_UPDATE_ACTIVE_ROUNDS_DT_TAG = 0x09,
-    SESSION_SET_INITIATOR_DT_ANCHOR_RR_RDM_LIST = 0x0a,
-    SESSION_QUERY_DATA_SIZE_IN_RANGING = 0x0b,
-    SESSION_SET_HUS_CONTROLLER_CONFIG = 0x0c,
-    SESSION_SET_HUS_CONTROLEE_CONFIG = 0x0d,
-    SESSION_DATA_TRANSFER_PHASE_CONFIGURATION = 0x0e,
-}
-
-enum SessionControlOpCode : 6 {
-    SESSION_START = 0x00,
-    SESSION_STOP = 0x01,
-    SESSION_RESERVED = 0x02,
-    SESSION_GET_RANGING_COUNT = 0x03,
-    SESSION_DATA_CREDIT_NTF = 0x04,
-    SESSION_DATA_TRANSFER_STATUS_NTF = 0x05,
-}
-
-enum AppDataOpCode : 6 {
-    APP_DATA_TX = 0x00,
-    APP_DATA_RX = 0x01,
-}
-
-// Android vendor commands
-enum AndroidOpCode : 6 {
-    ANDROID_GET_POWER_STATS = 0x0,
-    ANDROID_SET_COUNTRY_CODE = 0x1,
-    ANDROID_FIRA_RANGE_DIAGNOSTICS = 0x2,
-    ANDROID_RADAR_SET_APP_CONFIG = 0x11,
-    ANDROID_RADAR_GET_APP_CONFIG = 0x12,
-}
-
-enum TestOpCode : 6 {
-    RF_TEST_CONFIG_SET  = 0x0,
-    RF_TEST_CONFIG_GET  = 0x1,
-    RF_TEST_PERIODIC_TX = 0x2,
-    RF_TEST_PER_RX = 0x3,
-    RF_TEST_RX = 0x5,
-    RF_TEST_LOOPBACK = 0x6,
-    RF_TEST_STOP_SESSION = 0x07,
-}
-
-enum StatusCode : 8 {
-    // Generic Status Codes
-    UCI_STATUS_OK = 0x00,
-    UCI_STATUS_REJECTED = 0x01,
-    UCI_STATUS_FAILED = 0x02,
-    UCI_STATUS_SYNTAX_ERROR = 0x03,
-    UCI_STATUS_INVALID_PARAM = 0x04,
-    UCI_STATUS_INVALID_RANGE = 0x05,
-    UCI_STATUS_INVALID_MSG_SIZE = 0x06,
-    UCI_STATUS_UNKNOWN_GID = 0x07,
-    UCI_STATUS_UNKNOWN_OID = 0x08,
-    UCI_STATUS_READ_ONLY = 0x09,
-    UCI_STATUS_COMMAND_RETRY = 0x0A,
-    UCI_STATUS_UNKNOWN = 0x0B,
-    UCI_STATUS_NOT_APPLICABLE = 0x0C,
-    RFU_STATUS_CODE_RANGE_1 = 0x0D..0x10,
-
-    // UWB Session Specific Status Codes
-    UCI_STATUS_SESSION_NOT_EXIST = 0x11,
-    UCI_STATUS_SESSION_DUPLICATE = 0x12,
-    UCI_STATUS_SESSION_ACTIVE = 0x13,
-    UCI_STATUS_MAX_SESSIONS_EXCEEDED = 0x14,
-    UCI_STATUS_SESSION_NOT_CONFIGURED = 0x15,
-    UCI_STATUS_ACTIVE_SESSIONS_ONGOING = 0x16,
-    UCI_STATUS_MULTICAST_LIST_FULL = 0x17,
-    UCI_STATUS_ADDRESS_NOT_FOUND = 0x18,
-    UCI_STATUS_ADDRESS_ALREADY_PRESENT = 0x19,
-    UCI_STATUS_ERROR_UWB_INITIATION_TIME_TOO_OLD = 0x1A,
-    UCI_STATUS_OK_NEGATIVE_DISTANCE_REPORT = 0x1B,
-    RFU_STATUS_CODE_RANGE_2 = 0x1C..0x1F,
-
-    // UWB Ranging Session Specific Status Codes
-    UCI_STATUS_RANGING_TX_FAILED = 0x20,
-    UCI_STATUS_RANGING_RX_TIMEOUT = 0x21,
-    UCI_STATUS_RANGING_RX_PHY_DEC_FAILED = 0x22,
-    UCI_STATUS_RANGING_RX_PHY_TOA_FAILED = 0x23,
-    UCI_STATUS_RANGING_RX_PHY_STS_FAILED = 0x24,
-    UCI_STATUS_RANGING_RX_MAC_DEC_FAILED = 0x25,
-    UCI_STATUS_RANGING_RX_MAC_IE_DEC_FAILED = 0x26,
-    UCI_STATUS_RANGING_RX_MAC_IE_MISSING = 0x27,
-    UCI_STATUS_ERROR_ROUND_INDEX_NOT_ACTIVATED = 0x28,
-    UCI_STATUS_ERROR_NUMBER_OF_ACTIVE_RANGING_ROUNDS_EXCEEDED = 0x29,
-    UCI_STATUS_ERROR_DL_TDOA_DEVICE_ADDRESS_NOT_MATCHING_IN_REPLY_TIME_LIST = 0x2A,
-    RFU_STATUS_CODE_RANGE_3 = 0x2B..0x2F,
-
-    // UWB Data Session Specific Status Codes
-    UCI_STATUS_DATA_MAX_TX_PSDU_SIZE_EXCEEDED = 0x30,
-    UCI_STATUS_DATA_RX_CRC_ERROR = 0x31,
-    RFU_STATUS_CODE_RANGE_4 = 0x32..0x4F,
-
-    // Vendor Specific Status Codes
-    VENDOR_SPECIFIC_STATUS_CODE_RANGE_1 = 0x50..0xFE {
-        UCI_STATUS_ERROR_CCC_SE_BUSY = 0x50,
-        UCI_STATUS_ERROR_CCC_LIFECYCLE = 0x51,
-        UCI_STATUS_ERROR_STOPPED_DUE_TO_OTHER_SESSION_CONFLICT = 0x52,
-        UCI_STATUS_REGULATION_UWB_OFF = 0x53,
-    },
-
-    // For internal usage, we will use 0xFF as default.
-    VENDOR_SPECIFIC_STATUS_CODE_2 = 0xFF,
-}
-
-// This needs a separate StatusCode as the Status code values in the DATA_RCV packet have
-// different values from the generic StatusCode above.
-enum DataRcvStatusCode : 8 {
-    UCI_STATUS_SUCCESS = 0x00,
-    UCI_STATUS_ERROR = 0x01,
-    UCI_STATUS_UNKNOWN = 0x02,
-}
-
-enum CreditAvailability : 8 {
-    CREDIT_NOT_AVAILABLE = 0,
-    CREDIT_AVAILABLE = 1,
-}
-
-// The UCI spec defines these status codes for a DATA_TRANSFER_STATUS_NTF packet.
-enum DataTransferNtfStatusCode : 8 {
-    UCI_DATA_TRANSFER_STATUS_REPETITION_OK = 0x00,
-    UCI_DATA_TRANSFER_STATUS_OK = 0x01,
-    UCI_DATA_TRANSFER_STATUS_ERROR_DATA_TRANSFER = 0x02,
-    UCI_DATA_TRANSFER_STATUS_ERROR_NO_CREDIT_AVAILABLE = 0x03,
-    UCI_DATA_TRANSFER_STATUS_ERROR_REJECTED = 0x04,
-    UCI_DATA_TRANSFER_STATUS_SESSION_TYPE_NOT_SUPPORTED = 0x05,
-    UCI_DATA_TRANSFER_STATUS_ERROR_DATA_TRANSFER_IS_ONGOING = 0x06,
-    UCI_DATA_TRANSFER_STATUS_INVALID_FORMAT = 0x07,
-}
-
-// The UCI spec defines these status codes for a SESSION_DATA_TRANSFER_PHASE_CONFIG_NTF packet.
-enum DataTransferPhaseConfigUpdateStatusCode : 8 {
-    UCI_DTPCM_CONFIG_SUCCESS_STATUS_OK = 0x00,
-    UCI_DTPCM_STATUS_ERROR_DUPLICATE_SLOT_ASSIGMENT = 0x01,
-}
-
-enum ResetConfig : 8 {
-    UWBS_RESET = 0x00,
-}
-
-enum DeviceConfigId : 8 {
-    DEVICE_STATE = 0x00,
-    LOW_POWER_MODE = 0x01,
-}
-
-enum AppConfigTlvType : 8 {
-    DEVICE_TYPE = 0x00,
-    RANGING_ROUND_USAGE = 0x01,
-    STS_CONFIG = 0x02,
-    MULTI_NODE_MODE = 0x03,
-    CHANNEL_NUMBER = 0x04,
-    NO_OF_CONTROLEE = 0x05,
-    DEVICE_MAC_ADDRESS = 0x06,
-    DST_MAC_ADDRESS = 0x07,
-    SLOT_DURATION = 0x08,
-    RANGING_DURATION = 0x09,
-    STS_INDEX = 0x0A,
-    MAC_FCS_TYPE = 0x0B,
-    RANGING_ROUND_CONTROL = 0x0C,
-    AOA_RESULT_REQ = 0x0D,
-    RNG_DATA_NTF = 0x0E,
-    RNG_DATA_NTF_PROXIMITY_NEAR = 0x0F,
-    RNG_DATA_NTF_PROXIMITY_FAR = 0x10,
-    DEVICE_ROLE = 0x11,
-    RFRAME_CONFIG = 0x12,
-    RSSI_REPORTING = 0x13,
-    PREAMBLE_CODE_INDEX = 0x14,
-    SFD_ID = 0x15,
-    PSDU_DATA_RATE = 0x16,
-    PREAMBLE_DURATION = 0x17,
-    LINK_LAYER_MODE = 0x18,
-    DATA_REPETITION_COUNT = 0x19,
-    RANGING_TIME_STRUCT = 0x1A,
-    SLOTS_PER_RR = 0x1B,
-    TX_ADAPTIVE_PAYLOAD_POWER = 0x1C,
-    // TODO: Ensure this value is correct in the final 2.0 specification.
-    RNG_DATA_NTF_AOA_BOUND = 0x1D,
-    RESPONDER_SLOT_INDEX = 0x1E,
-    PRF_MODE = 0x1F,
-    CAP_SIZE_RANGE = 0x20,
-    TX_JITTER_WINDOW_SIZE = 0x21,
-    SCHEDULED_MODE = 0x22,
-    KEY_ROTATION = 0x23,
-    KEY_ROTATION_RATE = 0x24,
-    SESSION_PRIORITY = 0x25,
-    MAC_ADDRESS_MODE = 0x26,
-    VENDOR_ID = 0x27,
-    STATIC_STS_IV = 0x28,
-    NUMBER_OF_STS_SEGMENTS = 0x29,
-    MAX_RR_RETRY = 0x2A,
-    UWB_INITIATION_TIME = 0x2B,
-    HOPPING_MODE = 0x2C,
-    BLOCK_STRIDE_LENGTH = 0x2D,
-    RESULT_REPORT_CONFIG = 0x2E,
-    IN_BAND_TERMINATION_ATTEMPT_COUNT = 0x2F,
-    SUB_SESSION_ID = 0x30,
-    BPRF_PHR_DATA_RATE = 0x31,
-    MAX_NUMBER_OF_MEASUREMENTS = 0x32,
-    UL_TDOA_TX_INTERVAL = 0x33,
-    UL_TDOA_RANDOM_WINDOW = 0x34,
-    STS_LENGTH = 0x35,
-    SUSPEND_RANGING_ROUNDS = 0x36,
-    UL_TDOA_NTF_REPORT_CONFIG = 0x37,
-    UL_TDOA_DEVICE_ID = 0x38,
-    UL_TDOA_TX_TIMESTAMP = 0x39,
-    MIN_FRAMES_PER_RR = 0x3A,
-    MTU_SIZE = 0x3B,
-    INTER_FRAME_INTERVAL = 0x3C,
-    DL_TDOA_RANGING_METHOD  = 0x3D,
-    DL_TDOA_TX_TIMESTAMP_CONF = 0x3E,
-    DL_TDOA_HOP_COUNT = 0x3F,
-    DL_TDOA_ANCHOR_CFO = 0x40,
-    DL_TDOA_ANCHOR_LOCATION = 0x41,
-    DL_TDOA_TX_ACTIVE_RANGING_ROUNDS = 0x42,
-    DL_TDOA_BLOCK_STRIDING = 0x43,
-    DL_TDOA_TIME_REFERENCE_ANCHOR = 0x44,
-    SESSION_KEY = 0x45,
-    SUBSESSION_KEY = 0x46,
-    SESSION_DATA_TRANSFER_STATUS_NTF_CONFIG = 0x47,
-    SESSION_TIME_BASE = 0x48,
-    DL_TDOA_RESPONDER_TOF = 0x49,
-    SECURE_RANGING_NEFA_LEVEL = 0x4A,
-    SECURE_RANGING_CSW_LENGTH = 0x4B,
-    APPLICATION_DATA_ENDPOINT = 0x4C,
-    OWR_AOA_MEASUREMENT_NTF_PERIOD = 0x4D,
-    RFU_APP_CFG_TLV_TYPE_RANGE = 0x4E..0x9F,
-
-    VENDOR_SPECIFIC_APP_CFG_TLV_TYPE_RANGE_1 = 0xA0..0xDF {
-        // CCC specific
-        CCC_HOP_MODE_KEY = 0xA0,
-        CCC_UWB_TIME0 = 0xA1,
-        CCC_RANGING_PROTOCOL_VER = 0xA3,
-        CCC_UWB_CONFIG_ID = 0xA4,
-        CCC_PULSESHAPE_COMBO = 0xA5,
-        CCC_URSK_TTL = 0xA6,
-        CCC_LAST_INDEX_USED  = 0xA8,
-        ALIRO_MAC_MODE = 0xA9,
-    },
-
-    // Reserved for extension IDs.
-    RFU_APP_CFG_TLV_TYPE_RANGE_4 = 0xE0..0xE2,
-
-    VENDOR_SPECIFIC_APP_CFG_TLV_TYPE_RANGE_2 = 0xE3..0xFF {
-        // Interleaving ratio if AOA_RESULT_REQ is set to 0xF0.
-        NB_OF_RANGE_MEASUREMENTS = 0xE3,
-        NB_OF_AZIMUTH_MEASUREMENTS = 0xE4,
-        NB_OF_ELEVATION_MEASUREMENTS = 0xE5,
-        ENABLE_DIAGNOSTICS = 0xE8,
-        DIAGRAMS_FRAME_REPORTS_FIELDS = 0xE9,
-        ANTENNA_MODE = 0xEA,
-    },
-}
-
-enum FrameReportTlvType : 8 {
-    RSSI = 0x0,
-    AOA = 0x1,
-    CIR = 0x2,
-    SEGMENT_METRICS = 0x6,
-}
-
-enum CapTlvType : 8 {
-    // Defining the parameters for both Fira v1.0 and v2.0 in one enum, as PDL
-    // does not allow to define two separate enum fields with the same value.
-    SUPPORTED_V1_FIRA_PHY_VERSION_RANGE_V2_MAX_MESSAGE_SIZE = 0x0,
-    SUPPORTED_V1_FIRA_MAC_VERSION_RANGE_V2_MAX_DATA_PAYLOAD_SIZE = 0x1,
-    SUPPORTED_V1_DEVICE_ROLES_V2_FIRA_PHY_VERSION_RANGE = 0x2,
-    SUPPORTED_V1_RANGING_METHOD_V2_FIRA_MAC_VERSION_RANGE = 0x3,
-    SUPPORTED_V1_STS_CONFIG_V2_DEVICE_TYPE = 0x4,
-    SUPPORTED_V1_MULTI_NODE_MODES_V2_DEVICE_ROLES = 0x5,
-    SUPPORTED_V1_RANGING_TIME_STRUCT_V2_RANGING_METHOD = 0x6,
-    SUPPORTED_V1_SCHEDULED_MODE_V2_STS_CONFIG = 0x7,
-    SUPPORTED_V1_HOPPING_MODE_V2_MULTI_NODE_MODE = 0x8,
-    SUPPORTED_V1_BLOCK_STRIDING_V2_RANGING_TIME_STRUCT = 0x9,
-    SUPPORTED_V1_UWB_INITIATION_TIME_V2_SCHEDULE_MODE = 0x0A,
-    SUPPORTED_V1_CHANNELS_V2_HOPPING_MODE = 0x0B,
-    SUPPORTED_V1_RFRAME_CONFIG_V2_BLOCK_STRIDING = 0x0C,
-    SUPPORTED_V1_CC_CONSTRAINT_LENGTH_V2_UWB_INITIATION_TIME = 0x0D,
-    SUPPORTED_V1_BPRF_PARAMETER_SETS_V2_CHANNELS = 0x0E,
-    SUPPORTED_V1_HPRF_PARAMETER_SETS_V2_RFRAME_CONFIG = 0x0F,
-    SUPPORTED_V1_AOA_V2_CC_CONSTRAINT_LENGTH = 0x10,
-    SUPPORTED_V1_EXTENDED_MAC_ADDRESS_V2_BPRF_PARAMETER_SETS = 0x11,
-    SUPPORTED_V1_MAX_MESSAGE_SIZE_V2_HPRF_PARAMETER_SETS = 0x12,
-    SUPPORTED_V1_MAX_DATA_PACKET_PAYLOAD_SIZE_V2_AOA_SUPPORT = 0x13,
-    SUPPORTED_V2_EXTENDED_MAC_ADDRESS = 0x14,
-    SUPPORTED_V2_ASSIGNED = 0x15,
-    SUPPORTED_V2_SESSION_KEY_LENGTH = 0x16,
-    SUPPORTED_V2_DT_ANCHOR_MAX_ACTIVE_RR = 0x17,
-    SUPPORTED_V2_DT_TAG_MAX_ACTIVE_RR = 0x18,
-    SUPPORTED_V2_DT_TAG_BLOCK_SHIPPING = 0x19,
-    SUPPORTED_V2_PSDU_LENGTH_SUPPORT = 0x1A,
-    RFU_CAP_TLV_TYPE_RANGE_1 = 0x1B..0x9F,
-
-    VENDOR_SPECIFIC_CAP_TLV_TYPE_RANGE_1 = 0xA0..0xBF {
-        // CCC specific
-        CCC_SUPPORTED_CHAPS_PER_SLOT = 0xA0,
-        CCC_SUPPORTED_SYNC_CODES = 0xA1,
-        CCC_SUPPORTED_HOPPING_CONFIG_MODES_AND_SEQUENCES = 0xA2,
-        CCC_SUPPORTED_CHANNELS = 0xA3,
-        CCC_SUPPORTED_VERSIONS = 0xA4,
-        CCC_SUPPORTED_UWB_CONFIGS = 0xA5,
-        CCC_SUPPORTED_PULSE_SHAPE_COMBOS = 0xA6,
-        CCC_SUPPORTED_RAN_MULTIPLIER = 0xA7,
-        CCC_SUPPORTED_MAX_RANGING_SESSION_NUMBER = 0xA8,
-        CCC_SUPPORTED_MIN_UWB_INITIATION_TIME_MS = 0xA9,
-        CCC_PRIORITIZED_CHANNEL_LIST = 0xAA,
-        CCC_SUPPORTED_UWBS_MAX_PPM = 0xAB,
-        ALIRO_SUPPORTED_MAC_MODES = 0xAC,
-
-        // RADAR specific
-        RADAR_SUPPORT = 0xB0
-    },
-
-    SUPPORTED_POWER_STATS = 0xC0,
-    VENDOR_SPECIFIC_CAP_TLV_TYPE_RANGE_2 = 0xC1..0xDF,
-    RFU_CAP_TLV_TYPE_RANGE_2 = 0xE0..0xE2,
-
-    VENDOR_SPECIFIC_CAP_TLV_TYPE_RANGE_3 = 0xE3..0xFF {
-        SUPPORTED_AOA_RESULT_REQ_ANTENNA_INTERLEAVING = 0xE3,
-        SUPPORTED_MIN_RANGING_INTERVAL_MS = 0xE4,
-        SUPPORTED_RANGE_DATA_NTF_CONFIG = 0xE5,
-        SUPPORTED_RSSI_REPORTING = 0xE6,
-        SUPPORTED_DIAGNOSTICS = 0xE7,
-        SUPPORTED_MIN_SLOT_DURATION_RSTU = 0xE8,
-        SUPPORTED_MAX_RANGING_SESSION_NUMBER = 0xE9,
-    },
-}
-
-
-// AOA result request type.
-// Values set for AOA_RESULT_REQ config ID.
-enum AoaResultReqType : 8 {
-    AOA_DISABLE = 0x0,
-    AOA_ENABLE = 0x01,
-    AOA_ENABLE_AZIMUTH = 0x02,
-    AOA_ENABLE_ELEVATION = 0x03,
-    AOA_ENABLE_INTERLEAVED = 0xF0,
-}
-
-enum DeviceState : 8 {
-    DEVICE_STATE_READY = 0x01,
-    DEVICE_STATE_ACTIVE = 0x02,
-    DEVICE_STATE_ERROR = 0xff,
-}
-
-enum SessionState : 8 {
-    SESSION_STATE_INIT = 0x00,
-    SESSION_STATE_DEINIT = 0x01,
-    SESSION_STATE_ACTIVE = 0x02,
-    SESSION_STATE_IDLE = 0x03,
-}
-
-enum ReasonCode : 8 {
-    STATE_CHANGE_WITH_SESSION_MANAGEMENT_COMMANDS = 0x00,
-    MAX_RANGING_ROUND_RETRY_COUNT_REACHED = 0x01,
-    MAX_NUMBER_OF_MEASUREMENTS_REACHED = 0x02,
-    SESSION_SUSPENDED_DUE_TO_INBAND_SIGNAL = 0x03,
-    SESSION_RESUMED_DUE_TO_INBAND_SIGNAL = 0x04,
-    SESSION_STOPPED_DUE_TO_INBAND_SIGNAL = 0x05,
-    RFU_REASON_CODE_RANGE_1 = 0x06..0x1C,
-    ERROR_INVALID_UL_TDOA_RANDOM_WINDOW = 0x1D,
-    ERROR_MIN_RFRAMES_PER_RR_NOT_SUPPORTED = 0x1E,
-    ERROR_INTER_FRAME_INTERVAL_NOT_SUPPORTED = 0x1F,
-    ERROR_SLOT_LENGTH_NOT_SUPPORTED = 0x20,
-    ERROR_INSUFFICIENT_SLOTS_PER_RR = 0x21,
-    ERROR_MAC_ADDRESS_MODE_NOT_SUPPORTED = 0x22,
-    ERROR_INVALID_RANGING_DURATION = 0x23,
-    ERROR_INVALID_STS_CONFIG = 0x24,
-    ERROR_INVALID_RFRAME_CONFIG = 0x25,
-    ERROR_HUS_NOT_ENOUGH_SLOTS = 0x26,
-    ERROR_HUS_CFP_PHASE_TOO_SHORT = 0x27,
-    ERROR_HUS_CAP_PHASE_TOO_SHORT = 0x28,
-    ERROR_HUS_OTHERS = 0x29,
-    ERROR_STATUS_SESSION_KEY_NOT_FOUND = 0x2A,
-    ERROR_STATUS_SUB_SESSION_KEY_NOT_FOUND = 0x2B,
-    ERROR_INVALID_PREAMBLE_CODE_INDEX = 0x2C,
-    ERROR_INVALID_SFD_ID = 0x2D,
-    ERROR_INVALID_PSDU_DATA_RATE = 0x2E,
-    ERROR_INVALID_PHR_DATA_RATE = 0x2F,
-    ERROR_INVALID_PREAMBLE_DURATION = 0x30,
-    ERROR_INVALID_STS_LENGTH = 0x31,
-    ERROR_INVALID_NUM_OF_STS_SEGMENTS = 0x32,
-    ERROR_INVALID_NUM_OF_CONTROLEES = 0x33,
-    ERROR_MAX_RANGING_REPLY_TIME_EXCEEDED = 0x34,
-    ERROR_INVALID_DST_ADDRESS_LIST = 0x35,
-    ERROR_INVALID_OR_NOT_FOUND_SUB_SESSION_ID = 0x36,
-    ERROR_INVALID_RESULT_REPORT_CONFIG = 0x37,
-    ERROR_INVALID_RANGING_ROUND_CONTROL_CONFIG = 0x38,
-    ERROR_INVALID_RANGING_ROUND_USAGE = 0x39,
-    ERROR_INVALID_MULTI_NODE_MODE = 0x3A,
-    ERROR_RDS_FETCH_FAILURE = 0x3B,
-    ERROR_REF_UWB_SESSION_DOES_NOT_EXIST = 0x3C,
-    ERROR_REF_UWB_SESSION_RANGING_DURATION_MISMATCH = 0x3D,
-    ERROR_REF_UWB_SESSION_INVALID_OFFSET_TIME = 0x3E,
-    ERROR_REF_UWB_SESSION_LOST = 0x3F,
-    RFU_REASON_CODE_RANGE_2 = 0x40..0x7F {
-        ERROR_DT_ANCHOR_RANGING_ROUNDS_NOT_CONFIGURED = 0x40,
-        ERROR_DT_TAG_RANGING_ROUNDS_NOT_CONFIGURED = 0x41,
-    },
-    VENDOR_SPECIFIC_REASON_CODE_RANGE_1 = 0x80..0xA1 {
-        ERROR_INVALID_CHANNEL_WITH_AOA = 0x80,
-        ERROR_STOPPED_DUE_TO_OTHER_SESSION_CONFLICT = 0x81,
-    },
-    SESSION_STOPPED_DUE_TO_MAX_STS_INDEX_VALUE = 0xA2,
-    VENDOR_SPECIFIC_REASON_CODE_RANGE_2 = 0xA3..0xFE,
-    // For internal usage, we will use 0xFF as default.
-    VENDOR_SPECIFIC_REASON_CODE_2 = 0xFF,
-}
-
-enum MulticastUpdateStatusCode : 8 {
-    STATUS_OK_MULTICAST_LIST_UPDATE = 0x00,
-    STATUS_ERROR_MULTICAST_LIST_FULL = 0x01,
-    STATUS_ERROR_KEY_FETCH_FAIL = 0x02,
-    STATUS_ERROR_SUB_SESSION_ID_NOT_FOUND = 0x03,
-    STATUS_ERROR_SUB_SESSION_KEY_NOT_FOUND = 0x04,
-    STATUS_ERROR_SUB_SESSION_KEY_NOT_APPLICABLE = 0x05,
-    STATUS_ERROR_SESSION_KEY_NOT_FOUND = 0x06,
-    STATUS_ERROR_ADDRESS_NOT_FOUND = 0x07,
-    STATUS_ERROR_ADDRESS_ALREADY_PRESENT = 0x08,
-    RFU_STATUS_CODE_RANGE_1 = 0x09..0xFF,
-}
-
-enum MacAddressIndicator : 8 {
-    SHORT_ADDRESS = 0x00,
-    EXTENDED_ADDRESS = 0x01,
-}
-
-enum SessionType: 8 {
-    FIRA_RANGING_SESSION = 0x00,
-    FIRA_RANGING_AND_IN_BAND_DATA_SESSION = 0x01,
-    FIRA_DATA_TRANSFER_SESSION = 0x02,
-    FIRA_RANGING_ONLY_PHASE = 0x03,
-    FIRA_IN_BAND_DATA_PHASE = 0x04,
-    FIRA_RANGING_WITH_DATA_PHASE = 0x05,
-    FIRA_HUS_PRIMARY_SESSION = 0x9F,
-    CCC = 0xA0,
-    RADAR_SESSION = 0xA1,
-    ALIRO = 0xA2,
-    DEVICE_TEST_MODE = 0xD0,
-}
-
-enum MessageType: 3 {
-    DATA = 0x00,
-    COMMAND = 0x01,
-    RESPONSE = 0x02,
-    NOTIFICATION = 0x03,
-    RESERVED_FOR_TESTING_1 = 0x04,
-    RESERVED_FOR_TESTING_2 = 0x05,
-}
-
-enum RfTestConfigTlvType : 8 {
-    NUM_PACKETS = 0x00,
-    T_GAP = 0x01,
-    T_START = 0x02,
-    T_WIN = 0x03,
-    RANDOMIZE_PSDU = 0x04,
-    PHR_RANGING_BIT = 0x05,
-    RMARKER_TX_START = 0x06,
-    RMARKER_RX_START = 0x07,
-    STS_INDEX_AUTO_INCR = 0x08,
-    STS_DETECT_BITMAP = 0x09,
-    RFU_TEST_APP_CFG_TLV_TYPE_RANGE = 0x0A..0xFF,
-}
-
-// UCI packet description in compliance with the FIRA UCI spec.
-// Only this packet should be sent/expected across the HAL interface.
-packet UciPacketHal {
-    group_id_or_data_packet_format: GroupIdOrDataPacketFormat,
-    packet_boundary_flag: PacketBoundaryFlag,
-    message_type: MessageType,
-    _body_
-}
-
-// The UciDataPacketHal must be declared before the UciControlPacketHal for correct parsing to
-// happen. This is required as the Data packet specifies a value for the 'message_type' constraint,
-// while the Control packet does not (as it encompasses multiple 'message_type' values).
-packet UciDataPacketHal: UciPacketHal (message_type = DATA) {
-    _reserved_: 8,
-    _size_(_payload_): 16,
-    _payload_,
-}
-
-packet UciControlPacketHal: UciPacketHal {
-    opcode: 6,
-    _reserved_: 2,
-    _reserved_: 8,
-    _size_(_payload_): 8,
-    _payload_,
-}
-
-// This control packet definition is used throughout the stack that holds a complete
-// (i.e unfragmented) UCI command/response/notification.
-//
-// UciControlPacket needs to be converted to one or more UciControlPacketHal fragments before
-// sending to the HAL. One or more UciControlPacketHal fragments needs to be converted to
-// UciControlPacket when receiving from the HAL.
-//
-// TODO(b/202760099): Handle fragmentation more cleanly in the PDL.
-packet UciControlPacket {
-    group_id: GroupId,
-    // This field is different from |UciControlPacketHal| to provide a placeholder for PBF flag.
-    _reserved_: 1,
-    message_type: MessageType,
-    opcode: 6,
-    _reserved_: 2,
-    _reserved_: 8,
-     // This field is different from |UciControlPacketHal| to allow holding a large unfragmented
-     // packet.
-    _size_(_payload_): 32,
-    _payload_,
-}
-
-// This data packet definition is used throughout the stack that holds a complete
-// (i.e unfragmented) UCI data packet.
-//
-// UciDataPacket needs to be converted to one or more UciDataPacketHal fragments before sending to
-// the HAL. One or more UciDataPacketHal fragments needs to be converted to UciDataPacket when
-// receiving from the HAL.
-//
-// TODO(b/202760099): Handle fragmentation more cleanly in the PDL.
-packet UciDataPacket {
-    data_packet_format: DataPacketFormat,
-    // This field is different from |UciDataPacketHal| to provide a placeholder for PBF flag.
-    _reserved_: 1,
-    message_type: MessageType,
-    _reserved_: 8,
-     // This field is different from |UciDataPacketHal| to allow holding large unfragmented packet.
-    _size_(_payload_): 32,
-    _payload_,
-}
-
-packet UciDataSnd : UciDataPacket (data_packet_format = DATA_SND, message_type = DATA) {
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    dest_mac_address: 64,
-    uci_sequence_number: 16,
-    _size_(data): 16,
-    data: 8[]
-}
-
-packet UciDataRcv : UciDataPacket (data_packet_format = DATA_RCV, message_type = DATA) {
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    status: StatusCode,
-    source_mac_address: 64,
-    uci_sequence_number: 16,
-    _size_(data): 16,
-    data: 8[]
-}
-
-packet UciCommand : UciControlPacket (message_type = COMMAND) {
-    _payload_,
-}
-
-packet UciResponse : UciControlPacket (message_type = RESPONSE) {
-    _payload_,
-}
-
-packet UciNotification : UciControlPacket (message_type = NOTIFICATION) {
-    _payload_,
-}
-
-packet CoreCommand : UciCommand (group_id = CORE) {
-    _body_,
-}
-
-packet CoreResponse : UciResponse (group_id = CORE) {
-    _body_,
-}
-
-packet CoreNotification : UciNotification (group_id = CORE) {
-    _body_,
-}
-
-packet SessionConfigCommand : UciCommand (group_id = SESSION_CONFIG) {
-    _body_,
-}
-
-packet SessionConfigResponse : UciResponse (group_id = SESSION_CONFIG) {
-    _body_,
-}
-
-packet SessionConfigNotification : UciNotification (group_id = SESSION_CONFIG) {
-    _body_,
-}
-
-packet SessionControlCommand : UciCommand (group_id = SESSION_CONTROL) {
-    _body_,
-}
-
-packet SessionControlResponse : UciResponse (group_id = SESSION_CONTROL) {
-    _body_,
-}
-
-packet SessionControlNotification : UciNotification (group_id = SESSION_CONTROL) {
-    _body_,
-}
-
-packet AndroidCommand : UciCommand (group_id = VENDOR_ANDROID) {
-    _body_,
-}
-
-packet AndroidResponse : UciResponse (group_id = VENDOR_ANDROID) {
-    _body_,
-}
-
-packet AndroidNotification : UciNotification (group_id = VENDOR_ANDROID) {
-    _body_,
-}
-
-packet TestCommand : UciCommand (group_id = TEST) {
-    _body_,
-}
-
-packet TestResponse : UciResponse (group_id = TEST) {
-    _body_,
-}
-
-packet TestNotification : UciNotification (group_id = TEST) {
-    _body_,
-}
-
-// TODO: b/202760099: Use the correspnding opcode enum instead of the raw value in the |opcode| field.
-packet DeviceResetCmd : CoreCommand (opcode = 0x0) { //CORE_DEVICE_RESET
-    reset_config: ResetConfig,
-}
-
-test DeviceResetCmd {
-    "\x20\x00\x00\x01\x00\x00\x00\x00",
-}
-
-packet DeviceResetRsp : CoreResponse (opcode = 0x0) { //CORE_DEVICE_RESET
-    status: StatusCode,
-}
-
-test DeviceResetRsp {
-    "\x40\x00\x00\x01\x00\x00\x00\x00",
-}
-
-packet DeviceStatusNtf : CoreNotification (opcode = 0x1) { //CORE_DEVICE_STATUS_NTF
-    device_state: DeviceState,
-}
-
-test DeviceStatusNtf {
-    "\x60\x01\x00\x01\x00\x00\x00\x01",
-}
-
-packet GetDeviceInfoCmd : CoreCommand (opcode = 0x2) { //CORE_DEVICE_INFO
-}
-
-test GetDeviceInfoCmd {
-    "\x20\x02\x00\x00\x00\x00\x00",
-}
-
-packet GetDeviceInfoRsp : CoreResponse (opcode = 0x2) { //CORE_DEVICE_INFO
-    status: StatusCode,
-    uci_version: 16,
-    mac_version: 16,
-    phy_version: 16,
-    uci_test_version: 16,
-    _count_(vendor_spec_info): 8,
-    vendor_spec_info: 8[],
-}
-
-test GetDeviceInfoRsp {
-    "\x40\x02\x00\x0b\x00\x00\x00\x01\x01\x00\x02\x00\x03\x00\x04\x00\x01\x0a",
-}
-
-packet GetCapsInfoCmd : CoreCommand (opcode = 0x3) { //CORE_GET_CAPS_INFO
-}
-
-test GetCapsInfoCmd {
-    "\x20\x03\x00\x00\x00\x00\x00",
-}
-
-struct CapTlv {
-    t: CapTlvType,
-    _count_(v): 8,
-    v: 8[],
-}
-
-
-packet GetCapsInfoRsp : CoreResponse (opcode = 0x3) { //CORE_GET_CAPS_INFO
-    status: StatusCode,
-    _count_(tlvs): 8,
-    tlvs: CapTlv[],
-}
-
-test GetCapsInfoRsp {
-    "\x40\x03\x00\x05\x00\x00\x00\x00\x01\x00\x01\x01",
-}
-
-struct DeviceConfigTlv {
-    cfg_id: DeviceConfigId,
-    _count_(v): 8,
-    v: 8[],
-}
-
-packet SetConfigCmd : CoreCommand (opcode = 0x4) { //CORE_SET_CONFIG
-    _count_(tlvs): 8,
-    tlvs: DeviceConfigTlv[],
-}
-
-test SetConfigCmd {
-    "\x20\x04\x00\x03\x00\x00\x00\x01\x01\x00",
-}
-
-struct DeviceConfigStatus {
-    cfg_id: DeviceConfigId,
-    status: StatusCode,
-}
-
-packet SetConfigRsp : CoreResponse (opcode = 0x4) { //CORE_SET_CONFIG
-    status: StatusCode,
-    _count_(cfg_status): 8,
-    cfg_status: DeviceConfigStatus[],
-}
-
-test SetConfigRsp {
-    "\x40\x04\x00\x04\x00\x00\x00\x01\x01\x01\x01",
-    "\x40\x04\x00\x04\x00\x00\x00\x01\x01\x01\x0B",
-}
-
-packet GetConfigCmd : CoreCommand (opcode = 0x5) { //CORE_GET_CONFIG
-    _count_(cfg_id): 8,
-    cfg_id: 8[], // DeviceConfigId (Infra does not allow array of enums)
-}
-
-test GetConfigCmd {
-    "\x20\x05\x00\x02\x00\x00\x00\x01\x01",
-}
-
-packet GetConfigRsp : CoreResponse (opcode = 0x5) { //CORE_GET_CONFIG
-    status: StatusCode,
-    _count_(tlvs): 8,
-    tlvs: DeviceConfigTlv[]
-}
-
-test GetConfigRsp {
-    "\x40\x05\x00\x05\x00\x00\x00\x01\x01\x00\x01\x01",
-}
-
-packet GenericError : CoreNotification (opcode = 0x7) { //CORE_GENERIC_ERROR_NTF
-    status: StatusCode,
-}
-
-test GenericError {
-    "\x60\x07\x00\x01\x00\x00\x00\x01",
-}
-
-
-packet CoreQueryTimeStampCmd : CoreCommand (opcode = 0x8) { //CORE_QUERY_UWBS_TIMESTAMP
-}
-
-test CoreQueryTimeStampCmd {
-    "\x20\x08\x00\\x00",
-}
-
-packet CoreQueryTimeStampRsp : CoreResponse (opcode = 0x8) { //CORE_QUERY_UWBS_TIMESTAMP
-    status: StatusCode,
-    timeStamp: 64,
-}
-
-test CoreQueryTimeStampRsp {
-    "\x40\x08\x00\x09\x00\x00\x00\x01\x01\x00\x01\x01\x01",
-}
-
-packet SessionInitCmd : SessionConfigCommand (opcode = 0x0) { //SESSION_INIT
-    session_id: 32,
-    session_type: SessionType,
-}
-
-test SessionInitCmd {
-    "\x21\x00\x00\x05\x00\x00\x00\x01\x02\x03\x04\x01",
-}
-
-// FIRA version 2 introduces a new version of SESSION_INIT_RSP which
-// includes UWBS generated session handle.
-packet SessionInitRsp_V2 : SessionConfigResponse (opcode = 0x0) { //SESSION_INIT
-    status: StatusCode,
-    session_handle: 32,
-}
-
-test SessionInitRsp_V2 {
-    "\x41\x00\x00\x01\x00\x00\x00\x11\x00\x00\x00\x01",
-}
-
-packet SessionInitRsp : SessionConfigResponse (opcode = 0x0) { //SESSION_INIT
-    status: StatusCode,
-}
-
-test SessionInitRsp {
-    "\x41\x00\x00\x01\x00\x00\x00\x11",
-}
-
-packet SessionDeinitCmd : SessionConfigCommand (opcode = 0x1) { //SESSION_DEINIT
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-}
-
-test SessionDeinitCmd {
-    "\x21\x01\x00\x04\x00\x00\x00\x01\x02\x03\x04",
-}
-
-packet SessionDeinitRsp : SessionConfigResponse (opcode = 0x1) { //SESSION_DEINIT
-    status: StatusCode,
-}
-
-test SessionDeinitRsp {
-    "\x41\x01\x00\x01\x00\x00\x00\x00",
-}
-
-packet SessionStatusNtf : SessionConfigNotification (opcode = 0x2) { //SESSION_STATUS_NTF
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    session_state: SessionState,
-    // TODO(b/272775225): Switch back to the enum type ReasonCode, once PDL supports defining a
-    // range inside an enum (for the vendor-specific space), in b/267339120.
-    reason_code: 8,
-}
-
-test SessionStatusNtf {
-    "\x61\x02\x00\x06\x00\x00\x00\x01\x02\x03\x04\x02\x21",
-    "\x61\x02\x00\x06\x00\x00\x00\x01\x02\x03\x04\x01\x82", // Vendor Specific Reason Code
-}
-
-struct AppConfigTlv {
-    cfg_id: AppConfigTlvType,
-    _count_(v): 8,
-    v: 8[],
-}
-
-packet SessionSetAppConfigCmd : SessionConfigCommand (opcode = 0x3) { //SESSION_SET_APP_CONFIG
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    _count_(tlvs): 8,
-    tlvs: AppConfigTlv[]
-}
-
-test SessionSetAppConfigCmd {
-    "\x21\x03\x00\x05\x00\x00\x00\x01\x02\x03\x04\x00",
-}
-
-struct AppConfigStatus {
-    cfg_id: AppConfigTlvType,
-    status: StatusCode,
-}
-
-packet SessionSetAppConfigRsp : SessionConfigResponse (opcode = 0x3) { //SESSION_SET_APP_CONFIG
-    status: StatusCode,
-    _count_(cfg_status): 8,
-    cfg_status: AppConfigStatus[],
-}
-
-test SessionSetAppConfigRsp {
-    "\x41\x03\x00\x04\x00\x00\x00\x01\x01\x01\x00",
-}
-
-packet SessionGetAppConfigCmd : SessionConfigCommand (opcode = 0x4) { //SESSION_GET_APP_CONFIG
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    _count_(app_cfg): 8,
-    app_cfg: 8[], // AppConfigTlvType (Infra does not allow array of enums)
-}
-
-test SessionGetAppConfigCmd {
-    "\x21\x04\x00\x05\x00\x00\x00\x01\x02\x03\x04\x00",
-}
-
-packet SessionGetAppConfigRsp : SessionConfigResponse (opcode = 0x4) { //SESSION_GET_APP_CONFIG
-    status: StatusCode,
-    _count_(tlvs): 8,
-    tlvs: AppConfigTlv[],
-}
-
-test SessionGetAppConfigRsp {
-    "\x41\x04\x00\x02\x00\x00\x00\x01\x00",
-}
-
-packet SessionGetCountCmd : SessionConfigCommand (opcode = 0x5) { //SESSION_GET_COUNT
-}
-
-test SessionGetCountCmd {
-    "\x21\x05\x00\x00\x00\x00\x00",
-}
-
-packet SessionGetCountRsp : SessionConfigResponse (opcode = 0x5) { //SESSION_GET_COUNT
-    status: StatusCode,
-    session_count: 8,
-}
-
-test SessionGetCountRsp {
-    "\x41\x05\x00\x02\x00\x00\x00\x00\x01",
-}
-
-packet SessionGetStateCmd : SessionConfigCommand (opcode = 0x6) { //SESSION_GET_STATE
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-}
-
-test SessionGetStateCmd {
-    "\x21\x06\x00\x04\x00\x00\x00\x00\x01\x02\x03",
-}
-
-packet SessionGetStateRsp : SessionConfigResponse (opcode = 0x6) { //SESSION_GET_STATE
-    status: StatusCode,
-    session_state: SessionState,
-}
-
-test SessionGetStateRsp {
-    "\x41\x06\x00\x02\x00\x00\x00\x00\x01",
-}
-
-packet SessionUpdateDtTagRangingRoundsCmd : SessionConfigCommand (opcode = 0x9) { //SESSION_UPDATE_ACTIVE_ROUNDS_DT_TAG
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    _count_(ranging_round_indexes): 8,
-    ranging_round_indexes: 8[],
-}
-
-test SessionUpdateDtTagRangingRoundsCmd {
-    "\x21\x09\x00\x0a\x00\x00\x00\x03\x03\x0f\x0c\x05\x08\x00\x00\x00\x00",
-}
-
-packet SessionUpdateDtTagRangingRoundsRsp : SessionConfigResponse (opcode = 0x9) { //SESSION_UPDATE_ACTIVE_ROUNDS_DT_TAG
-    status: StatusCode,
-    _count_(ranging_round_indexes): 8,
-    ranging_round_indexes: 8[],
-}
-
-test SessionUpdateDtTagRangingRoundsRsp {
-    "\x41\x09\x00\x03\x00\x00\x00\x01\x01\x01",
-}
-
-struct Controlee {
-    short_address: 8[2],
-    subsession_id: 32,
-}
-
-struct Controlee_V2_0_16_Byte_Version {
-    short_address: 8[2],
-    subsession_id: 32,
-    subsession_key: 8[16],
-}
-
-struct Controlee_V2_0_32_Byte_Version {
-    short_address: 8[2],
-    subsession_id: 32,
-    subsession_key: 8[32],
-}
-
-enum UpdateMulticastListAction: 8 {
-    ADD_CONTROLEE = 0x00,
-    REMOVE_CONTROLEE = 0x01,
-    ADD_CONTROLEE_WITH_SHORT_SUB_SESSION_KEY = 0x02,
-    ADD_CONTROLEE_WITH_LONG_SUB_SESSION_KEY = 0x03,
-}
-
-packet SessionUpdateControllerMulticastListCmd : SessionConfigCommand (opcode = 0x7) { //SESSION_UPDATE_CONTROLLER_MULTICAST_LIST
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    action: UpdateMulticastListAction,
-    _payload_,
-}
-
-
-struct SessionUpdateControllerMulticastListCmdPayload {
-    _count_(controlees): 8,
-    controlees: Controlee[],
-}
-
-struct SessionUpdateControllerMulticastListCmd_2_0_16_Byte_Payload {
-    _count_(controlees): 8,
-    controlees: Controlee_V2_0_16_Byte_Version[],
-}
-
-struct SessionUpdateControllerMulticastListCmd_2_0_32_Byte_Payload {
-    _count_(controlees): 8,
-    controlees: Controlee_V2_0_32_Byte_Version[],
-}
-
-packet SessionUpdateControllerMulticastListRsp : SessionConfigResponse (opcode = 0x7) { //SESSION_UPDATE_CONTROLLER_MULTICAST_LIST
-    _payload_,
-}
-
-test SessionUpdateControllerMulticastListRsp {
-    "\x41\x07\x00\x01\x00\x00\x00\x00",
-}
-
-struct SessionUpdateControllerMulticastListRspV1Payload {
-    status: StatusCode,
-}
-
-struct SessionUpdateControllerMulticastListRspV2Payload {
-    status: StatusCode,
-    _count_(controlee_status): 8,
-    controlee_status: ControleeStatusV2[],
-}
-
-struct ControleeStatusV1 {
-    mac_address: 8[2],
-    subsession_id: 32,
-    status: MulticastUpdateStatusCode,
-}
-
-struct ControleeStatusV2 {
-    mac_address: 8[2],
-    status: MulticastUpdateStatusCode,
-}
-
-packet SessionUpdateControllerMulticastListNtf : SessionConfigNotification (opcode = 0x7) { //SESSION_UPDATE_CONTROLLER_MULTICAST_LIST
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    _payload_,
-}
-
-test SessionUpdateControllerMulticastListNtf {
-    "\x61\x07\x00\x06\x00\x00\x00\x00\x01\x02\x03\x04\x00",
-}
-
-struct SessionUpdateControllerMulticastListNtfV1Payload {
-    remaining_multicast_list_size: 8,
-    _count_(controlee_status): 8,
-    controlee_status: ControleeStatusV1[],
-}
-
-struct SessionUpdateControllerMulticastListNtfV2Payload {
-    _count_(controlee_status): 8,
-    controlee_status: ControleeStatusV2[],
-}
-
-packet DataCreditNtf : SessionControlNotification (opcode = 0x04) { // SESSION_DATA_CREDIT_NTF
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    credit_availability: CreditAvailability,
-}
-
-test DataCreditNtf {
-    "\x62\x04\x00\x05\x00\x00\x00\x00\x00\x00\x01\x01",
-}
-
-packet DataTransferStatusNtf : SessionControlNotification (opcode = 0x05) { // SESSION_DATA_TRANSFER_STATUS_NTF
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    uci_sequence_number: 16,
-    status: DataTransferNtfStatusCode,
-    tx_count: 8,
-}
-
-test DataTransferStatusNtf {
-    "\x62\x05\x00\x06\x00\x00\x00\x00\x00\x00\x01\x01\x00\x00",
-}
-
-packet SessionQueryMaxDataSizeCmd : SessionConfigCommand (opcode = 0xB) { //QUERY_MAX_DATA_SIZE
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-}
-
-test SessionQueryMaxDataSizeCmd {
- "\x21\x0B\x00\x04\x00\x00\x00\x00",
-}
-
-packet SessionQueryMaxDataSizeRsp : SessionConfigResponse (opcode = 0xB) { //QUER_MAX_DATA_SIZE
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    status: StatusCode,
-    max_data_size: 16,
-}
-
-test SessionQueryMaxDataSizeRsp {
-  "\x41\x0B\x00\x06\x00\x00\x00\x00\x00\x0E7\0x07",
-}
-
-packet SessionDataTransferPhaseConfigCmd : SessionConfigCommand (opcode = 0x0e) { //SESSION_DATA_TRANSFER_PHASE_CONFIGURATION
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    dtpcm_repetition: 8,
-    data_transfer_control: 8,
-    dtpml_size: 8,
-    _payload_,
-}
-
-packet SessionDataTransferPhaseConfigRsp : SessionConfigResponse (opcode = 0x0e) { //SESSION_DATA_TRANSFER_PHASE_CONFIGURATION
-    status: StatusCode,
-}
-
-packet SessionDataTransferPhaseConfigNtf : SessionConfigNotification (opcode = 0x0e) { //SESSION_DATA_TRANSFER_PHASE_CONFIGURATION
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    status: DataTransferPhaseConfigUpdateStatusCode,
-}
-
-test SessionDataTransferPhaseConfigNtf {
-    "\x61\x0E\x00\x05\x00\x00\x00\x00\x00"
-}
-
-struct ControllerPhaseList {
-    session_token: 32,
-    start_slot_index: 16,
-    end_slot_index: 16,
-    control: 8,
-    mac_address: 8[],
-}
-
-packet SessionSetHybridControllerConfigCmd : SessionConfigCommand (opcode = 0x0C) { //SESSION_SET_HUS_CONTROLLER_CONFIG
-    session_token: 32,
-    number_of_phases: 8,
-    phase_list: ControllerPhaseList[],
-}
-
-test SessionSetHybridControllerConfigCmd {
-"\x21\x0C\x00\x23\x03\x00\x00\x01\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x05\x01\x00\x19\x00\x00\x30\x00\x02\x00\x00\x03\x1A\x00\x32\x00\x00\x30\x00",
-}
-
-packet SessionSetHybridControllerConfigRsp : SessionConfigResponse (opcode = 0x0C) { //SESSION_SET_HUS_CONTROLLER_CONFIG
-    status: StatusCode,
-}
-
-test SessionSetHybridControllerConfigRsp {
-     "\x41\x0C\x00\x01\x00"
-}
-
-struct ControleePhaseList {
-    session_token: 32,
-}
-
-packet SessionSetHybridControleeConfigCmd : SessionConfigCommand (opcode = 0x0D) { //SESSION_SET_HUS_CONTROLEE_CONFIG
-    session_token: 32,
-    _count_(controlee_phase_list): 8,
-    controlee_phase_list: ControleePhaseList[],
-}
-
-test SessionSetHybridControleeConfigCmd {
-    "\x21\x0D\x00\x0F\x03\x00\x00\x01\x02\x01\x00\x00\x05\x02\x02\x00\x00\x03\x02",
-}
-
-packet SessionSetHybridControleeConfigRsp : SessionConfigResponse (opcode = 0x0D) { //SESSION_SET_HUS_CONTROLEE_CONFIG
-    status: StatusCode,
-}
-
-test SessionSetHybridControleeConfigRsp {
-     "\x41\x0D\x00\x01\x00"
-}
-
-packet SessionStartCmd : SessionControlCommand (opcode = 0x0) { //RANGE_START
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-}
-
-test SessionStartCmd {
-    "\x22\x00\x00\x04\x00\x00\x00\x00\x01\x02\x03",
-}
-
-packet SessionStartRsp : SessionControlResponse (opcode = 0x0) { //RANGE_START
-    status: StatusCode,
-}
-
-test SessionStartRsp {
-    "\x42\x00\x00\x01\x00\x00\x00\x00",
-}
-
-struct ShortAddressTwoWayRangingMeasurement {
-    mac_address: 16,
-    status: StatusCode,
-    nlos: 8,
-    distance: 16,
-    aoa_azimuth: 16,
-    aoa_azimuth_fom: 8,
-    aoa_elevation: 16,
-    aoa_elevation_fom: 8,
-    aoa_destination_azimuth: 16,
-    aoa_destination_azimuth_fom: 8,
-    aoa_destination_elevation: 16,
-    aoa_destination_elevation_fom: 8,
-    slot_index: 8,
-    rssi: 8,
-    // b/272301550: The pdl compiler cannot handle individual fields
-    // larger than 64 bit. The work around is to split the 88 bit
-    // field into two.
-    _reserved_: 64,
-    _reserved_: 24,
-}
-
-struct ExtendedAddressTwoWayRangingMeasurement {
-    mac_address: 64,
-    status: StatusCode,
-    nlos: 8,
-    distance: 16,
-    aoa_azimuth: 16,
-    aoa_azimuth_fom: 8,
-    aoa_elevation: 16,
-    aoa_elevation_fom: 8,
-    aoa_destination_azimuth: 16,
-    aoa_destination_azimuth_fom: 8,
-    aoa_destination_elevation: 16,
-    aoa_destination_elevation_fom: 8,
-    slot_index: 8,
-    rssi: 8,
-    _reserved_: 40,
-}
-
-struct ShortAddressOwrAoaRangingMeasurement {
-    mac_address: 16,
-    status: StatusCode,
-    nlos: 8,
-    frame_sequence_number: 8,
-    block_index: 16,
-    aoa_azimuth: 16,
-    aoa_azimuth_fom: 8,
-    aoa_elevation: 16,
-    aoa_elevation_fom: 8,
-}
-
-struct ExtendedAddressOwrAoaRangingMeasurement {
-    mac_address: 64,
-    status: StatusCode,
-    nlos: 8,
-    frame_sequence_number: 8,
-    block_index: 16,
-    aoa_azimuth: 16,
-    aoa_azimuth_fom: 8,
-    aoa_elevation: 16,
-    aoa_elevation_fom: 8,
-}
-
-enum RangingMeasurementType : 8 {
-    ONE_WAY = 0x0,
-    TWO_WAY = 0x1,
-    DL_TDOA = 0x02,
-    OWR_AOA = 0x03,
-}
-
-packet SessionInfoNtf : SessionControlNotification (opcode = 0x0) { // SESSION_INFO
-    sequence_number: 32,
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    rcr_indicator: 8,
-    current_ranging_interval: 32,
-    ranging_measurement_type: RangingMeasurementType,
-    _reserved_: 8,
-    mac_address_indicator: MacAddressIndicator,
-    hus_primary_session_id: 32,
-    _reserved_: 32,
-    _body_,
-}
-
-packet ShortMacTwoWaySessionInfoNtf : SessionInfoNtf (ranging_measurement_type = TWO_WAY, mac_address_indicator = SHORT_ADDRESS) {
-    _count_(two_way_ranging_measurements) : 8,
-    two_way_ranging_measurements : ShortAddressTwoWayRangingMeasurement[],
-    vendor_data: 8[],
-}
-
-test ShortMacTwoWaySessionInfoNtf {
-    "\x62\x00\x00\x19\x00\x00\x00\x00\x02\x03\x04\x05\x06\x07\x08\x00\x0a\x01\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
-}
-
-packet ExtendedMacTwoWaySessionInfoNtf : SessionInfoNtf (ranging_measurement_type = TWO_WAY, mac_address_indicator = EXTENDED_ADDRESS) {
-    _count_(two_way_ranging_measurements) : 8,
-    two_way_ranging_measurements : ExtendedAddressTwoWayRangingMeasurement[],
-    vendor_data: 8[],
-}
-
-test ExtendedMacTwoWaySessionInfoNtf {
-    "\x62\x00\x00\x19\x00\x00\x00\x00\x02\x03\x04\x05\x06\x07\x08\x00\x0a\x01\x01\x01\x01\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00",
-}
-
-packet ShortMacDlTDoASessionInfoNtf : SessionInfoNtf (ranging_measurement_type = DL_TDOA, mac_address_indicator = SHORT_ADDRESS) {
-    no_of_ranging_measurements : 8,
-    dl_tdoa_measurements : 8[],
-}
-
-test ShortMacDlTDoASessionInfoNtf {
-     "\x62\x00\x00\x19\x00\x00\x00\x00\x02\x03\x04\x05\x06\x07\x08\x00\x0a\x02\x01\x01\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
-}
-
-packet ExtendedMacDlTDoASessionInfoNtf : SessionInfoNtf (ranging_measurement_type = DL_TDOA, mac_address_indicator = EXTENDED_ADDRESS) {
-    no_of_ranging_measurements : 8,
-    dl_tdoa_measurements : 8[],
-}
-
-test ExtendedMacDlTDoASessionInfoNtf {
-     "\x62\x00\x00\x19\x00\x00\x00\x00\x02\x03\x04\x05\x06\x07\x08\x00\x0a\x01\x01\x01\x02\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00",
-}
-
-packet ShortMacOwrAoaSessionInfoNtf : SessionInfoNtf (ranging_measurement_type = OWR_AOA, mac_address_indicator = SHORT_ADDRESS) {
-    _count_(owr_aoa_ranging_measurements) : 8,
-    owr_aoa_ranging_measurements : ShortAddressOwrAoaRangingMeasurement[],
-    vendor_data: 8[],
-}
-
-test ShortMacOwrAoaSessionInfoNtf {
-    "\x62\x00\x00\x19\x00\x00\x00\x00\x02\x03\x04\x05\x06\x07\x08\x00\x0a\x01\x01\x01\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
-    "\x62\x00\x00\x26\x00\x00\x00\x00\x02\x03\x04\x05\x06\x07\x08\x00\x0a\x01\x01\x01\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\xaa\xbb\x00\x00\x01\x01\x00\x03\x04\x60\x05\x06\x50",
-}
-
-packet ExtendedMacOwrAoaSessionInfoNtf : SessionInfoNtf (ranging_measurement_type = OWR_AOA, mac_address_indicator = EXTENDED_ADDRESS) {
-    _count_(owr_aoa_ranging_measurements) : 8,
-    owr_aoa_ranging_measurements : ExtendedAddressOwrAoaRangingMeasurement[],
-    vendor_data: 8[],
-}
-
-test ExtendedMacOwrAoaSessionInfoNtf {
-    "\x62\x00\x00\x19\x00\x00\x00\x00\x02\x03\x04\x05\x06\x07\x08\x00\x0a\x01\x01\x01\x03\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00",
-    "\x62\x00\x00\x2c\x00\x00\x00\x00\x02\x03\x04\x05\x06\x07\x08\x00\x0a\x01\x01\x01\x03\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01\xaa\xbb\xcc\xdd\x01\x02\x03\x04\x00\x00\x01\x01\x00\x03\x04\x60\x05\x06\x50",
-}
-
-packet SessionStopCmd : SessionControlCommand (opcode = 0x1) { // SESSION_STOP
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-}
-
-test SessionStopCmd {
-    "\x22\x01\x00\x04\x00\x00\x00\x00\x02\x03\x04",
-}
-
-packet SessionStopRsp : SessionControlResponse (opcode = 0x1) { // SESSION_STOP
-    status: StatusCode,
-}
-
-test SessionStopRsp {
-    "\x42\x01\x00\x01\x00\x00\x00\x00",
-}
-
-packet SessionGetRangingCountCmd : SessionControlCommand (opcode = 0x3) { // SESSION_GET_RANGING_COUNT
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-}
-
-test SessionGetRangingCountCmd {
-    "\x22\x03\x00\x04\x00\x00\x00\x00\x02\x03\x04",
-}
-
-packet SessionGetRangingCountRsp : SessionControlResponse (opcode = 0x3) { // SESSION_GET_RANGING_COUNT
-    status: StatusCode,
-    count: 32,
-}
-
-test SessionGetRangingCountRsp {
-    "\x42\x03\x00\x05\x00\x00\x00\x00\x02\x03\x04\x05",
-}
-
-packet AndroidGetPowerStatsCmd: AndroidCommand (opcode = 0x0) { //ANDROID_GET_POWER_STATS
-}
-
-test AndroidGetPowerStatsCmd {
-    "\x2c\x00\x00\x00\x00\x00\x00",
-}
-
-struct PowerStats {
-    status: StatusCode,
-    idle_time_ms: 32,
-    tx_time_ms: 32,
-    rx_time_ms: 32,
-    total_wake_count:32,
-}
-
-packet AndroidGetPowerStatsRsp : AndroidResponse (opcode = 0x0) { //ANDROID_GET_POWER_STATS
-    stats: PowerStats,
-}
-
-test AndroidGetPowerStatsRsp {
-    "\x4c\x00\x00\x11\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
-}
-
-packet AndroidSetCountryCodeCmd: AndroidCommand (opcode = 0x1) { //ANDROID_SET_COUNTRY_CODE
-    country_code : 8[2],
-}
-
-// Set country code to US.
-test AndroidSetCountryCodeCmd {
-    "\x2c\x01\x00\x02\x00\x00\x00\x55\x53",
-}
-
-packet AndroidSetCountryCodeRsp : AndroidResponse (opcode = 0x1) { //ANDROID_SET_COUNTRY_CODE
-    status: StatusCode,
-}
-
-test AndroidSetCountryCodeRsp {
-    "\x4c\x01\x00\x01\x00\x00\x00\x00",
-}
-
-struct FrameReportTlv {
-    t: FrameReportTlvType,
-    _size_(v): 16,
-    v: 8[],
-}
-
-packet FrameReportTlvPacket {
-    t: FrameReportTlvType,
-    _size_(_body_): 16,
-    _body_,
-}
-
-packet Rssi : FrameReportTlvPacket (t = RSSI) {
-    rssi: 8[],
-}
-
-struct AoaMeasurement {
-    tdoa: 16,
-    pdoa: 16,
-    aoa: 16,
-    fom: 8,
-    t: 8,
-}
-
-packet Aoa : FrameReportTlvPacket (t = AOA) {
-    aoa: AoaMeasurement[],
-}
-
-test Aoa {
-    "\x01\x08\x00\x00\x01\x00\x01\x00\x01\x01\x01",
-}
-
-struct CirValue {
-    first_path_index : 16,
-    first_path_snr: 16,
-    first_path_ns: 16,
-    peak_path_index: 16,
-    peak_path_snr: 16,
-    peak_path_ns: 16,
-    first_path_sample_offset: 8,
-    samples_number: 8,
-    _size_(sample_window): 16,
-    sample_window: 8[],
-}
-
-packet Cir : FrameReportTlvPacket (t = CIR) {
-    _count_(cir_value): 8,
-    cir_value: CirValue[],
-}
-
-test Cir {
-    "\x02\x15\x00\x01\x01\x02\x01\x02\x01\x02\x01\x02\x01\x02\x01\x02\x00\x02\x04\x00\x01\x02\x03\x04",
-}
-
-packet SegmentMetrics : FrameReportTlvPacket (t = SEGMENT_METRICS) {
-    segment_metrics: SegmentMetricsValue[],
-}
-
-enum SegmentIdValue: 3 {
-    Ipatov = 0,
-    Sts0 = 1,
-    Sts1 = 2,
-    Sts2 = 3,
-    Sts3 = 4,
-}
-
-struct ReceiverAndSegmentValue {
-    segment_id: SegmentIdValue,
-    receiver_is_controller: 1,
-    receiver_id: 4,
-}
-
-struct PathSample {
-    index: 16,
-    rsl: 16, // Q8.8
-    time_ns: 16, // Q6.9
-}
-
-struct SegmentMetricsValue {
-    receiver_and_segment: ReceiverAndSegmentValue,
-    rf_noise_floor: 16, // Q8.8
-    segment_rsl: 16, // Q8.8
-    first_path: PathSample,
-    peak_path: PathSample,
-}
-
-test SegmentMetrics {
-    "\x08\xB0\xFF\x04\x3C\xE1\x02\xA1\xFF\x52\xB8\xE3\x02\xC4\xFF\xC0\xB8",
-}
-
-struct FrameReport {
-    uwb_msg_id: 8,
-    action: 8,
-    antenna_set: 8,
-    _count_(frame_report_tlvs): 8,
-    frame_report_tlvs: FrameReportTlv[],
-}
-
-packet AndroidRangeDiagnosticsNtf : AndroidNotification (opcode = 0x2) { //FIRA_RANGE_DIAGNOSTICS
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    sequence_number: 32,
-    _count_(frame_reports): 8,
-    frame_reports: FrameReport[],
-}
-
-test AndroidRangeDiagnosticsNtf {
-    "\x6c\x02\x00\x11\x00\x00\x00\x01\x01\x01\x01\x02\x02\x02\x02\x01\x00\x01\x02\x01\x00\x01\x00\x00",
-    "\x6c\x02\x00\x34\x00\x00\x00\x01\x01\x01\x01\x02\x02\x02\x02\x01\x00\x01\x02\x03\x01\x08\x00\x01\x02\x01\x02\x01\x02\x01\x01\x02\x15\x00\x01\x01\x02\x01\x02\x01\x02\x01\x02\x01\x02\x01\x02\x00\x02\x04\x00\x01\x02\x03\x04\x00\x01\x00\x00",
-}
-
-packet UciVendor_9_Response : UciResponse (group_id = VENDOR_RESERVED_9) {
-    _payload_,
-}
-
-packet UciVendor_A_Response : UciResponse (group_id = VENDOR_RESERVED_A) {
-    _payload_,
-}
-
-packet UciVendor_B_Response : UciResponse (group_id = VENDOR_RESERVED_B) {
-    _payload_,
-}
-
-packet UciVendor_E_Response : UciResponse (group_id = VENDOR_RESERVED_E) {
-    _payload_,
-}
-
-packet UciVendor_F_Response : UciResponse (group_id = VENDOR_RESERVED_F) {
-    _payload_,
-}
-
-packet UciVendor_9_Notification : UciNotification (group_id = VENDOR_RESERVED_9) {
-    _payload_,
-}
-
-packet UciVendor_A_Notification : UciNotification (group_id = VENDOR_RESERVED_A) {
-    _payload_,
-}
-
-packet UciVendor_B_Notification : UciNotification (group_id = VENDOR_RESERVED_B) {
-    _payload_,
-}
-
-packet UciVendor_E_Notification : UciNotification (group_id = VENDOR_RESERVED_E) {
-    _payload_,
-}
-
-packet UciVendor_F_Notification : UciNotification (group_id = VENDOR_RESERVED_F) {
-    _payload_,
-}
-
-enum RadarDataType : 8 {
-    RADAR_SWEEP_SAMPLES = 0x00,
-}
-
-enum RadarConfigTlvType : 8 {
-    RADAR_TIMING_PARAMS = 0x00,
-    SAMPLES_PER_SWEEP = 0x01,
-    CHANNEL_NUMBER = 0x02,
-    SWEEP_OFFSET = 0x03,
-    RFRAME_CONFIG = 0x04,
-    PREAMBLE_DURATION = 0x05,
-    PREAMBLE_CODE_INDEX = 0x06,
-    SESSION_PRIORITY = 0x07,
-    BITS_PER_SAMPLE = 0x08,
-    PRF_MODE = 0x09,
-    NUMBER_OF_BURSTS = 0x0A,
-    RADAR_DATA_TYPE = 0x0B,
-
-    RFU_RADAR_APP_CFG_TLV_TYPE_RANGE = 0x0C..0x9F,
-
-    VENDOR_SPECIFIC_RADAR_APP_CFG_TLV_TYPE_RANGE = 0xA0..0xDF,
-}
-
-struct RadarConfigTlv {
-    cfg_id: RadarConfigTlvType,
-    _count_(v): 8,
-    v: 8[],
-}
-
-struct RadarConfigStatus {
-    cfg_id: RadarConfigTlvType,
-    status: StatusCode,
-}
-
-packet AndroidSetRadarConfigCmd: AndroidCommand (opcode = 0x11) {
-    session_token: 32,
-    _count_(tlvs): 8,
-    tlvs: RadarConfigTlv[]
-}
-
-packet AndroidSetRadarConfigRsp : AndroidResponse (opcode = 0x11) {
-    status: StatusCode,
-    _count_(cfg_status): 8,
-    cfg_status: RadarConfigStatus[],
-}
-
-packet AndroidGetRadarConfigCmd: AndroidCommand (opcode = 0x12) {
-    session_token: 32,
-    _count_(tlvs): 8,
-    tlvs: 8[], // RadarConfigTlvType (Infra does not allow array of enums)
-}
-
-packet AndroidGetRadarConfigRsp : AndroidResponse (opcode = 0x12) {
-    status: StatusCode,
-    _count_(tlvs): 8,
-    tlvs: RadarConfigTlv[],
-}
-
-enum BitsPerSample : 8 {
-    VALUE_32 = 0x00,
-    VALUE_48 = 0x01,
-    VALUE_64 = 0x02
-}
-
-struct RadarSweepDataRaw {
-    sequence_number: 32,
-    timestamp: 32,
-    _count_(vendor_specific_data): 8,
-    vendor_specific_data: 8[],
-    sample_data: 8[],
-}
-
-packet RadarDataRcv : UciDataPacket (data_packet_format = RADAR_DATA_MESSAGE, message_type = DATA) {
-    session_handle: 32,
-    status: DataRcvStatusCode,
-    radar_data_type: RadarDataType,
-    number_of_sweeps: 8,
-    samples_per_sweep: 8,
-    bits_per_sample: BitsPerSample,
-    sweep_offset: 16,
-    sweep_data_size: 16,
-    sweep_data: 8[],
-}
-
-struct RfTestConfigTlv {
-    cfg_id: RfTestConfigTlvType,
-    _count_(v): 8,
-    v: 8[],
-}
-
-packet SessionSetRfTestConfigCmd : TestCommand (opcode = 0x00) {  // RF_TEST_CONFIG_SET
-    session_token: 32, // Session ID or Session Handle (based on UWBS version)
-    _count_(tlvs): 8,
-    tlvs: RfTestConfigTlv[]
-}
-
-test SessionSetRfTestConfigCmd {
-    "\x2D\x00\x00\x08\x01\x00\x00\x0D\x01\x08\x01\x00",
-}
-
-struct RfTestConfigStatus {
-    cfg_id: RfTestConfigTlvType,
-    status: StatusCode,
-}
-
-packet SessionSetRfTestConfigRsp : TestResponse (opcode = 0x00) { // RF_TEST_CONFIG_SET
-    status: StatusCode,
-    _count_(cfg_status): 8,
-    cfg_status: RfTestConfigStatus[],
-}
-
-test SessionSetRfTestConfigRsp {
-    "\x4D\x00\x00\x02\x00\x00",
-}
-
-packet TestPeriodicTxCmd : TestCommand (opcode = 0x02) { // RF_TEST_PERIODIC_TX
-    psdu_data : 8[],
-}
-
-test TestPeriodicTxCmd {
-    "\x2D\x02\x00\x0a\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09",
-}
-
-packet TestPeriodicTxRsp : TestResponse (opcode = 0x02) { // RF_TEST_PERIODIC_TX
-    status: StatusCode,
-}
-
-test TestPeriodicTxRsp {
-    "\x4D\x02\x00\x01\x00",
-}
-
-packet TestPeriodicTxNtf : TestNotification (opcode = 0x02) { // RF_TEST_PERIODIC_TX
-    status: StatusCode,
-    vendor_data: 8[],
-}
-
-test TestPeriodicTxNtf {
-    "\x6D\x02\x00\x01\x00",
-}
-
-packet TestPerRxCmd : TestCommand (opcode = 0x03) { // RF_TEST_PER_RX
-    psdu_data : 8[],
-}
-
-test TestPerRxCmd {
-    "\x2D\x03\x00\x0a\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09",
-}
-
-packet TestPerRxRsp : TestResponse (opcode = 0x03) { // RF_TEST_PER_RX
-    status: StatusCode,
-}
-
-test TestPerRxRsp {
-    "\x4D\x03\x00\x01\x00",
-}
-
-packet TestPerRxNtf : TestNotification (opcode = 0x03) { // RF_TEST_PER_RX
-    status: StatusCode,
-    attempts: 32,
-    acq_detect: 32,
-    acq_reject: 32,
-    rx_fail: 32,
-    sync_cir_ready: 32,
-    sfd_fail: 32,
-    sfd_found: 32,
-    phr_dec_error: 32,
-    phr_bit_error: 32,
-    psdu_dec_error: 32,
-    psdu_bit_error: 32,
-    sts_found: 32,
-    eof: 32,
-    vendor_data: 8[],
-}
-
-test TestPerRxNtf {
-    "\x6D\x03\x00\x35\x00\xE8\x03\x00\x00\x0C\x04\x00\x00\x24\x00\x00\x00\x00\x00\x00\x00\xE8\x03\x00\x00\x00\x00\xE8\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xE8\x03\x00\x00"
-}
-
-packet TestRxCmd : TestCommand (opcode = 0x05) { // RF_TEST_RX
-    psdu_data : 8[],
-}
-
-test TestRxCmd {
-    "\x2D\x05\x00\x0a\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09",
-}
-
-packet TestRxRsp : TestResponse (opcode = 0x05) { // RF_TEST_RX
-    status: StatusCode,
-}
-
-test TestRxRsp {
-    "\x4D\x05\x00\x01\x00",
-}
-
-packet TestRxNtf : TestNotification (opcode = 0x05) { // RF_TEST_RX
-    status: StatusCode,
-    rx_done_ts_int: 32,
-    rx_done_ts_frac: 16,
-    aoa_azimuth: 16,
-    aoa_elevation: 16,
-    toa_gap: 8,
-    phr: 16,
-    _count_(psdu_data): 16,
-    psdu_data: 8[],
-    vendor_data: 8[],
-}
-
-test TestRxNtf {
-    "\x6D\x05\x00\x14\x00\x52\x21\x00\x00\x00\x00\x00\x00\x00\x00\x0F\x12\x0A\x04\x00\xAB\xCD\xAB\xCD"
-}
-
-packet TestLoopbackCmd : TestCommand (opcode = 0x06) { // RF_TEST_LOOPBACK
-    psdu_data : 8[],
-}
-
-test TestLoopbackCmd {
-    "\x2D\x06\x00\x0a\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09",
-}
-
-packet TestLoopbackRsp : TestResponse (opcode = 0x06) { // RF_TEST_LOOPBACK
-    status: StatusCode,
-}
-
-test TestLoopbackRsp {
-    "\x4D\x06\x00\x01\x00",
-}
-
-packet TestLoopbackNtf : TestNotification (opcode = 0x06) { // RF_TEST_LOOPBACK
-    status: StatusCode,
-    tx_ts_int: 32,
-    tx_ts_frac: 16,
-    rx_ts_int: 32,
-    rx_ts_frac: 16,
-    aoa_azimuth: 16,
-    aoa_elevation: 16,
-    phr: 16,
-    _count_(psdu_data): 16,
-    psdu_data: 8[],
-    vendor_data: 8[],
-}
-
-test TestLoopbackNtf {
-    "\x6D\x06\x00\x19\x00\x00\x00\x00\x00\x00\x00\x52\x21\x05\x00\x25\x00\x00\x00\x00\x00\x12\x0A\x04\x00\xAB\xCD\xAB\xCD"
-}
-
-packet StopRfTestCmd : TestCommand (opcode = 0x07) { // RF_TEST_STOP_SESSION
-}
-
-test StopRfTestCmd {
-    "\x2D\x07\x00\x00",
-}
-
-packet StopRfTestRsp : TestResponse (opcode = 0x07) {  // RF_TEST_STOP_SESSION
-    status: StatusCode,
-}
-
-test StopRfTestRsp {
-    "\x4D\x07\x00\x01\x00",
-}
diff --git a/src/tests/libuwb_core_cargo_test.sh b/src/tests/libuwb_core_cargo_test.sh
deleted file mode 100755
index 8430992..0000000
--- a/src/tests/libuwb_core_cargo_test.sh
+++ /dev/null
@@ -1,45 +0,0 @@
-#!/usr/bin/env sh
-
-# Copyright 2022 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# The directory of this script.
-ROOT_DIR="$(dirname "$(realpath "$0")")"
-# The temporary artifacts directory.
-TEMP_DIR="$(mktemp -d)"
-
-cleanup() {
-    rm -rf "${TEMP_DIR}"
-}
-
-# Unpack the artifacts zip.
-if ! unzip "${ROOT_DIR}/uwb_core_artifacts.zip" -d ${TEMP_DIR}; then
-  echo "Failed to unzip the uwb_core_artifacts.zip"
-  cleanup
-  exit 1
-fi
-
-# Install the cargo inside TEMP_DIR.
-export RUSTUP_HOME="${TEMP_DIR}/.rustup"
-export CARGO_HOME="${TEMP_DIR}/.cargo"
-curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | \
-    sh -s -- -y --no-modify-path
-
-# Build the uwb_core source code.
-cd "${TEMP_DIR}"
-"${CARGO_HOME}/bin/cargo" test -vv
-return_code=$?
-
-cleanup
-exit "${return_code}"
diff --git a/src/tests/libuwb_core_cargo_test.xml b/src/tests/libuwb_core_cargo_test.xml
deleted file mode 100644
index 2f08524..0000000
--- a/src/tests/libuwb_core_cargo_test.xml
+++ /dev/null
@@ -1,21 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright 2022 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<configuration description="Runs uwb_core artifacts test">
-    <test class="com.android.tradefed.testtype.binary.ExecutableHostTest" >
-      <option name="binary" value="libuwb_core_cargo_test"/>
-      <option name="per-binary-timeout" value="10m" />
-    </test>
-</configuration>
diff --git a/src/uwb_rust_test_config_template.xml b/src/uwb_rust_test_config_template.xml
deleted file mode 100644
index 6a76181..0000000
--- a/src/uwb_rust_test_config_template.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2022 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<configuration description="Configuration for {MODULE} Rust tests">
-   <target_preparer class="com.android.tradefed.targetprep.RootTargetPreparer"/>
-   <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
-       <option name="cleanup" value="true" />
-       <option name="push" value="{MODULE}->/data/local/tmp/{MODULE}" />
-       <option name="append-bitness" value="true" />
-   </target_preparer>
-   <test class="com.android.tradefed.testtype.rust.RustBinaryTest" >
-       <option name="test-device-path" value="/data/local/tmp" />
-       <option name="module-name" value="{MODULE}" />
-   </test>
-   <object type="module_controller"
-           class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
-       <option name="mainline-module-package-name" value="com.google.android.uwb" />
-   </object>
-</configuration>
```

