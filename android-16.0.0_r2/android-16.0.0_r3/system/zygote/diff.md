```diff
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..1cfe632
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,4 @@
+/target
+/.vscode
+
+/rustfmt.toml
diff --git a/CONTRIB.md b/CONTRIB.md
new file mode 100644
index 0000000..74a5bc8
--- /dev/null
+++ b/CONTRIB.md
@@ -0,0 +1,12 @@
+This document contains details and notes on the development process for the Native Zygote project.
+
+# Lessons from Managed Zygote
+
+* Avoid large argument lists for functions
+  * See Process.java, ZygoteProcess.java, and com_android_internal_os_Zygote.cpp
+* Avoid making the Zygote aware of how many other Zygotes there are on the system and its role as a primary or secondary Zygote
+* Encode the Zygote configuration in System Properties; don't detect secondary Zygotes by attempting to connect to their sockets
+  * Using the sockets to detect a secondary Zygote means that we can't differentiate a frozen/crashed secondary Zygote from a system configured without them
+* Don't create named, special case AppZygotes (e.g. WebView Zygote); instead implement them on top of a more general AppZygote framework
+* Use a `signalfd` instead of a regular signal handler; this will allow the signals to be handled as part of the normal poll loop
+* Ensure that logging operations don't open sockets unexpectedly
\ No newline at end of file
diff --git a/Cargo.lock b/Cargo.lock
new file mode 100644
index 0000000..9f4b938
--- /dev/null
+++ b/Cargo.lock
@@ -0,0 +1,551 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+version = 4
+
+[[package]]
+name = "aho-corasick"
+version = "1.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "anstream"
+version = "0.6.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8acc5369981196006228e28809f761875c0327210a891e941f4c683b3a99529b"
+dependencies = [
+ "anstyle",
+ "anstyle-parse",
+ "anstyle-query",
+ "anstyle-wincon",
+ "colorchoice",
+ "is_terminal_polyfill",
+ "utf8parse",
+]
+
+[[package]]
+name = "anstyle"
+version = "1.0.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "55cc3b69f167a1ef2e161439aa98aed94e6028e5f9a59be9a6ffb47aef1651f9"
+
+[[package]]
+name = "anstyle-parse"
+version = "0.2.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3b2d16507662817a6a20a9ea92df6652ee4f94f914589377d69f3b21bc5798a9"
+dependencies = [
+ "utf8parse",
+]
+
+[[package]]
+name = "anstyle-query"
+version = "1.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "79947af37f4177cfead1110013d678905c37501914fba0efea834c3fe9a8d60c"
+dependencies = [
+ "windows-sys",
+]
+
+[[package]]
+name = "anstyle-wincon"
+version = "3.0.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ca3534e77181a9cc07539ad51f2141fe32f6c3ffd4df76db8ad92346b003ae4e"
+dependencies = [
+ "anstyle",
+ "once_cell",
+ "windows-sys",
+]
+
+[[package]]
+name = "anyhow"
+version = "1.0.98"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e16d2d3311acee920a9eb8d33b8cbc1787ce4a264e85f964c2404b969bdcd487"
+
+[[package]]
+name = "arrayvec"
+version = "0.7.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"
+
+[[package]]
+name = "bitflags"
+version = "2.9.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1b8e56985ec62d17e9c1001dc89c88ecd7dc08e47eba5ec7c29c7b5eeecde967"
+
+[[package]]
+name = "cfg-if"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
+
+[[package]]
+name = "clap"
+version = "4.5.38"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ed93b9805f8ba930df42c2590f05453d5ec36cbb85d018868a5b24d31f6ac000"
+dependencies = [
+ "clap_builder",
+ "clap_derive",
+]
+
+[[package]]
+name = "clap_builder"
+version = "4.5.38"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "379026ff283facf611b0ea629334361c4211d1b12ee01024eec1591133b04120"
+dependencies = [
+ "anstream",
+ "anstyle",
+ "clap_lex",
+ "strsim",
+]
+
+[[package]]
+name = "clap_derive"
+version = "4.5.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09176aae279615badda0765c0c0b3f6ed53f4709118af73cf4655d85d1530cd7"
+dependencies = [
+ "heck",
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "clap_lex"
+version = "0.7.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f46ad14479a25103f283c0f10005961cf086d8dc42205bb44c46ac563475dca6"
+
+[[package]]
+name = "colorchoice"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5b63caa9aa9397e2d9480a9b13673856c78d8ac123288526c37d7839f2a86990"
+
+[[package]]
+name = "either"
+version = "1.15.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"
+
+[[package]]
+name = "env_filter"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "186e05a59d4c50738528153b83b0b0194d3a29507dfec16eccd4b342903397d0"
+dependencies = [
+ "log",
+ "regex",
+]
+
+[[package]]
+name = "env_home"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c7f84e12ccf0a7ddc17a6c41c93326024c42920d7ee630d04950e6926645c0fe"
+
+[[package]]
+name = "env_logger"
+version = "0.10.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4cd405aab171cb85d6735e5c8d9db038c17d3ca007a4d2c25f337935c3d90580"
+dependencies = [
+ "humantime",
+ "is-terminal",
+ "log",
+ "regex",
+ "termcolor",
+]
+
+[[package]]
+name = "errno"
+version = "0.3.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cea14ef9355e3beab063703aa9dab15afd25f0667c341310c1e5274bb1d0da18"
+dependencies = [
+ "libc",
+ "windows-sys",
+]
+
+[[package]]
+name = "escape8259"
+version = "0.5.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5692dd7b5a1978a5aeb0ce83b7655c58ca8efdcb79d21036ea249da95afec2c6"
+
+[[package]]
+name = "flatbuffers"
+version = "25.2.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1045398c1bfd89168b5fd3f1fc11f6e70b34f6f66300c87d44d3de849463abf1"
+dependencies = [
+ "bitflags",
+ "rustc_version",
+]
+
+[[package]]
+name = "heck"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"
+
+[[package]]
+name = "hermit-abi"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f154ce46856750ed433c8649605bf7ed2de3bc35fd9d2a9f30cddd873c80cb08"
+
+[[package]]
+name = "humantime"
+version = "2.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9b112acc8b3adf4b107a8ec20977da0273a8c386765a3ec0229bd500a1443f9f"
+
+[[package]]
+name = "is-terminal"
+version = "0.4.16"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e04d7f318608d35d4b61ddd75cbdaee86b023ebe2bd5a66ee0915f0bf93095a9"
+dependencies = [
+ "hermit-abi",
+ "libc",
+ "windows-sys",
+]
+
+[[package]]
+name = "is_terminal_polyfill"
+version = "1.70.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"
+
+[[package]]
+name = "libc"
+version = "0.2.172"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d750af042f7ef4f724306de029d18836c26c1765a54a6a3f094cbd23a7267ffa"
+
+[[package]]
+name = "libloading"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6a793df0d7afeac54f95b471d3af7f0d4fb975699f972341a4b76988d49cdf0c"
+dependencies = [
+ "cfg-if",
+ "windows-targets",
+]
+
+[[package]]
+name = "libtest-mimic"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5297962ef19edda4ce33aaa484386e0a5b3d7f2f4e037cbeee00503ef6b29d33"
+dependencies = [
+ "anstream",
+ "anstyle",
+ "clap",
+ "escape8259",
+]
+
+[[package]]
+name = "linux-raw-sys"
+version = "0.9.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cd945864f07fe9f5371a27ad7b52a172b4b499999f1d97574c9fa68373937e12"
+
+[[package]]
+name = "log"
+version = "0.4.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"
+
+[[package]]
+name = "logger"
+version = "0.1.0"
+dependencies = [
+ "env_filter",
+ "env_logger",
+ "log",
+]
+
+[[package]]
+name = "memchr"
+version = "2.7.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"
+
+[[package]]
+name = "memmark"
+version = "0.1.0"
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
+name = "proc-macro2"
+version = "1.0.95"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "quote"
+version = "1.0.40"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
+dependencies = [
+ "proc-macro2",
+]
+
+[[package]]
+name = "regex"
+version = "1.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-automata",
+ "regex-syntax",
+]
+
+[[package]]
+name = "regex-automata"
+version = "0.4.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-syntax",
+]
+
+[[package]]
+name = "regex-syntax"
+version = "0.8.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"
+
+[[package]]
+name = "rustc_version"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
+dependencies = [
+ "semver",
+]
+
+[[package]]
+name = "rustix"
+version = "1.0.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c71e83d6afe7ff64890ec6b71d6a69bb8a610ab78ce364b3352876bb4c801266"
+dependencies = [
+ "bitflags",
+ "errno",
+ "libc",
+ "linux-raw-sys",
+ "windows-sys",
+]
+
+[[package]]
+name = "semver"
+version = "1.0.26"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "56e6fa9c48d24d85fb3de5ad847117517440f6beceb7798af16b4a87d616b8d0"
+
+[[package]]
+name = "static_assertions"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"
+
+[[package]]
+name = "strsim"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"
+
+[[package]]
+name = "syn"
+version = "2.0.101"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8ce2b7fc941b3a24138a0a7cf8e858bfc6a992e7978a068a5c760deb0ed43caf"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "unicode-ident",
+]
+
+[[package]]
+name = "termcolor"
+version = "1.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
+dependencies = [
+ "winapi-util",
+]
+
+[[package]]
+name = "unicode-ident"
+version = "1.0.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"
+
+[[package]]
+name = "utf8parse"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"
+
+[[package]]
+name = "which"
+version = "7.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "24d643ce3fd3e5b54854602a080f34fb10ab75e0b813ee32d00ca2b44fa74762"
+dependencies = [
+ "either",
+ "env_home",
+ "rustix",
+ "winsafe",
+]
+
+[[package]]
+name = "winapi-util"
+version = "0.1.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
+dependencies = [
+ "windows-sys",
+]
+
+[[package]]
+name = "windows-sys"
+version = "0.59.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
+dependencies = [
+ "windows-targets",
+]
+
+[[package]]
+name = "windows-targets"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
+dependencies = [
+ "windows_aarch64_gnullvm",
+ "windows_aarch64_msvc",
+ "windows_i686_gnu",
+ "windows_i686_gnullvm",
+ "windows_i686_msvc",
+ "windows_x86_64_gnu",
+ "windows_x86_64_gnullvm",
+ "windows_x86_64_msvc",
+]
+
+[[package]]
+name = "windows_aarch64_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"
+
+[[package]]
+name = "windows_aarch64_msvc"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"
+
+[[package]]
+name = "windows_i686_gnu"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"
+
+[[package]]
+name = "windows_i686_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"
+
+[[package]]
+name = "windows_i686_msvc"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"
+
+[[package]]
+name = "windows_x86_64_gnu"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"
+
+[[package]]
+name = "windows_x86_64_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"
+
+[[package]]
+name = "windows_x86_64_msvc"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"
+
+[[package]]
+name = "winsafe"
+version = "0.0.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d135d17ab770252ad95e9a872d365cf3090e3be864a34ab46f48555993efc904"
+
+[[package]]
+name = "zerocopy"
+version = "0.8.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a1702d9583232ddb9174e01bb7c15a2ab8fb1bc6f227aa1233858c351a3ba0cb"
+dependencies = [
+ "zerocopy-derive",
+]
+
+[[package]]
+name = "zerocopy-derive"
+version = "0.8.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "28a6e20d751156648aa063f3800b706ee209a32c0b4d9f24be3d980b01be55ef"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "zygote"
+version = "0.1.0"
+dependencies = [
+ "anyhow",
+ "arrayvec",
+ "clap",
+ "flatbuffers",
+ "libc",
+ "libloading",
+ "libtest-mimic",
+ "log",
+ "logger",
+ "rustix",
+ "static_assertions",
+ "which",
+ "zerocopy",
+]
diff --git a/Cargo.toml b/Cargo.toml
new file mode 100644
index 0000000..7cc972d
--- /dev/null
+++ b/Cargo.toml
@@ -0,0 +1,3 @@
+[workspace]
+resolver = "3"
+members = ["memmark", "zygote"]
diff --git a/OWNERS b/OWNERS
new file mode 100644
index 0000000..bf3cfad
--- /dev/null
+++ b/OWNERS
@@ -0,0 +1,2 @@
+chriswailes@google.com
+jdduke@google.com
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..718784d
--- /dev/null
+++ b/README.md
@@ -0,0 +1,7 @@
+This project implements a process-server architecture similar to Android's Zygote.
+
+This server is responsible for:
+* Preloading/initializing shared resources
+* Maintaining file descriptor hygiene
+* Forking new processes
+* Transitioning new processes to appropriate security contexts
\ No newline at end of file
diff --git a/TASKS.md b/TASKS.md
new file mode 100644
index 0000000..7d65ecf
--- /dev/null
+++ b/TASKS.md
@@ -0,0 +1,23 @@
+# Tasks
+
+See b/411209346 to track the high-level development progress for this project.
+
+* [ ] Eliminate all instances of `String` or ensure that they are arena allocated via `alloc-api`.
+* [ ] Make `introspection::get_open_file_descriptors` return an iterator
+* [ ] Implement a safe wrapper for reading the string from a `libc::dirent` struct.
+* [ ] Add support for selecting the species at compile time
+* [ ] Make each species a crate feature
+* [ ] Enforce maximum lengths for all message argument strings
+* [ ] Tune buffer sizes
+* [X] Report the PID of the created process back through the command socket
+* [X] Support ABI query messages
+* [ ] Load Zygote server configuration from file (Serde?)
+* [X] Create new process group when launching the server
+* [X] Add option to set process name
+* [X] Add an option to set the child process priority
+* [ ] Add new "preload-list" argument to Zygote server
+* [X] Add support for secondary uid/gid to be used during preloading
+* [ ] Take `cgroup` as argument in spawn messages
+* [X] Purge memory allocator after preloading
+* [ ] Add an `UnknownMessageType` response message
+* [ ] Add an `UnsupportedMessageType` response message
\ No newline at end of file
diff --git a/TESTING.md b/TESTING.md
new file mode 100644
index 0000000..71b3aa8
--- /dev/null
+++ b/TESTING.md
@@ -0,0 +1,11 @@
+To test this project you can run either of the following commands:
+
+```
+cargo test --features test
+``
+
+or
+
+```
+atest zygote_next_unit_tests zygote_next_integration_test_fd_no_panic
+```
\ No newline at end of file
diff --git a/memmark/Android.bp b/memmark/Android.bp
new file mode 100644
index 0000000..7250b7c
--- /dev/null
+++ b/memmark/Android.bp
@@ -0,0 +1,34 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+rust_library {
+    name: "libmemmark",
+    crate_name: "memmark",
+    host_supported: true,
+    edition: "2021",
+    srcs: [
+        "src/lib.rs",
+    ],
+    shared: {
+        enabled: true,
+        srcs: [
+            "src/lib.rs",
+        ],
+    },
+}
diff --git a/memmark/Cargo.toml b/memmark/Cargo.toml
new file mode 100644
index 0000000..a086a16
--- /dev/null
+++ b/memmark/Cargo.toml
@@ -0,0 +1,11 @@
+[package]
+name = "memmark"
+version = "0.1.0"
+edition = "2021"
+
+[lib]
+name = "memmark"
+path = "src/lib.rs"
+crate-type = ["dylib"]
+
+[dependencies]
diff --git a/memmark/src/lib.rs b/memmark/src/lib.rs
new file mode 100644
index 0000000..befab3e
--- /dev/null
+++ b/memmark/src/lib.rs
@@ -0,0 +1,27 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! A library Zygote "application" used to test memory interactions between the
+//! Zygote and its child processes.
+
+/// Entry point for the MemMark Zygote LibApp.
+#[no_mangle]
+pub fn zygote_entry(args: Vec<String>) -> i32 {
+    println!("Hello from MemMark!");
+
+    println!("Arguments: {:?}", args);
+
+    0
+}
diff --git a/zygote/Android.bp b/zygote/Android.bp
new file mode 100644
index 0000000..c02f779
--- /dev/null
+++ b/zygote/Android.bp
@@ -0,0 +1,192 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+genrule {
+    name: "libzygote_schemas",
+    tools: ["flatc"],
+    cmd: "$(location flatc) --rust --filename-suffix '' -o $$(dirname $(out)) $(in)",
+    srcs: [
+        "schemas/messages.fbs",
+    ],
+    out: [
+        "src/messages.rs",
+    ],
+}
+
+rust_library {
+    name: "libzygote",
+    crate_name: "zygote",
+    host_supported: true,
+    edition: "2021",
+    srcs: [
+        "src/lib.rs",
+        ":libzygote_schemas",
+    ],
+    rustlibs: [
+        "libanyhow",
+        "libarrayvec",
+        "libclap",
+        "libflatbuffers",
+        "liblibc",
+        "liblibloading",
+        "liblogger",
+        "liblog_rust",
+        "libstatic_assertions",
+        "libzerocopy",
+    ],
+}
+
+rust_library {
+    name: "libzygote_test",
+    crate_name: "zygote",
+    host_supported: true,
+    edition: "2021",
+    features: [
+        "test",
+    ],
+    srcs: [
+        "src/lib.rs",
+        ":libzygote_schemas",
+    ],
+    rustlibs: [
+        "libanyhow",
+        "libarrayvec",
+        "libclap",
+        "libflatbuffers",
+        "liblibc",
+        "liblibloading",
+        "liblogger",
+        "liblog_rust",
+        "libstatic_assertions",
+        "libzerocopy",
+    ],
+}
+
+rust_binary {
+    name: "zygote_next",
+    host_supported: true,
+    edition: "2021",
+    srcs: [
+        "src/bin/zygote.rs",
+    ],
+    rustlibs: [
+        "libanyhow",
+        "libclap",
+        "liblogger",
+        "liblog_rust",
+        "libzygote",
+    ],
+}
+
+rust_binary {
+    name: "zygote_cli",
+    host_supported: true,
+    edition: "2021",
+    srcs: [
+        "src/bin/zygote_cli.rs",
+    ],
+    rustlibs: [
+        "libanyhow",
+        "libclap",
+        "libflatbuffers",
+        "liblibc",
+        "liblibloading",
+        "liblogger",
+        "liblog_rust",
+        "libzygote",
+    ],
+}
+
+rust_binary {
+    name: "zygote_launch",
+    host_supported: true,
+    edition: "2021",
+    srcs: [
+        "src/bin/zygote_launch.rs",
+    ],
+    rustlibs: [
+        "libanyhow",
+        "libclap",
+        "libflatbuffers",
+        "liblibc",
+        "liblibloading",
+        "liblogger",
+        "liblog_rust",
+        "libzygote",
+    ],
+}
+
+rust_test_host {
+    name: "zygote_next_unit_tests",
+    edition: "2021",
+    features: [
+        "test",
+    ],
+    srcs: [
+        "src/lib.rs",
+        ":libzygote_schemas",
+    ],
+    rustlibs: [
+        "libanyhow",
+        "libarrayvec",
+        "libclap",
+        "libflatbuffers",
+        "liblibc",
+        "liblibloading",
+        "liblogger",
+        "liblog_rust",
+        "libstatic_assertions",
+        "libzerocopy",
+    ],
+}
+
+rust_test_host {
+    name: "zygote_next_integration_test_fd_no_panic",
+    edition: "2021",
+    test_harness: false,
+    cfgs: [
+        "test",
+    ],
+    features: [
+        "test",
+    ],
+    srcs: [
+        "tests/file_descriptors/calm.rs",
+    ],
+    rustlibs: [
+        "librustix",
+        "liblibc",
+        "liblibtest_mimic",
+        "libzygote_test",
+    ],
+}
+
+phony {
+    name: "zygote_all",
+    required: [
+        "libmemmark",
+        "libzygote",
+        "libzygote_test",
+        "zygote_cli",
+        "zygote_launch",
+        "zygote_next",
+        "zygote_next_unit_tests",
+        "zygote_next_integration_test_fd_no_panic",
+    ],
+}
diff --git a/zygote/Cargo.toml b/zygote/Cargo.toml
new file mode 100644
index 0000000..93a87e7
--- /dev/null
+++ b/zygote/Cargo.toml
@@ -0,0 +1,47 @@
+[package]
+name = "zygote"
+version = "0.1.0"
+edition = "2021"
+
+[features]
+default = ["test"]
+test = []
+
+[dependencies]
+anyhow = "1.0.97"
+arrayvec = "0.7.6"
+clap = { version = "4.5.0", features = ["derive"] }
+flatbuffers = "25.1.24"
+libc = "0.2.161"
+libloading = "0.8.6"
+log = { version = "0.4", features = ["std"] }
+logger = { path = "../../logging/rust" }
+static_assertions = "1.1.0"
+zerocopy = "0.8.21"
+
+[build-dependencies]
+which = "7.0.3"
+
+[dev-dependencies]
+libtest-mimic = "0.8.1"
+rustix = { version = "1.0.2", features = [
+    "alloc",
+    "event",
+    "fs",
+    "libc",
+    "libc_errno",
+    "mm",
+    "std",
+    "use-libc",
+    "use-libc-auxv",
+] }
+which = "7.0.3"
+
+[[test]]
+name = "file_descriptor_tests_no_panic"
+path = "tests/file_descriptors/calm.rs"
+test = true
+bench = false
+doc = false
+harness = false
+required-features = ["test"]
diff --git a/zygote/build.rs b/zygote/build.rs
new file mode 100644
index 0000000..7aba424
--- /dev/null
+++ b/zygote/build.rs
@@ -0,0 +1,34 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+use which::which;
+
+const SCHEMA_PATH: &str = "schemas/messages.fbs";
+
+fn main() {
+    let out_dir = std::env::var("OUT_DIR").unwrap();
+
+    if which("flatc").is_err() {
+        panic!("Unable to find FlatBuffer compiler `flatc`");
+    }
+
+    std::process::Command::new("flatc")
+        .args(&["--rust", "--filename-suffix", "", "-o", &out_dir, SCHEMA_PATH])
+        .status()
+        .unwrap();
+
+    println!("cargo::rerun-if-changed={}", SCHEMA_PATH);
+    println!("cargo::rustc-check-cfg=cfg(soong)");
+}
diff --git a/zygote/schemas/messages.fbs b/zygote/schemas/messages.fbs
new file mode 100644
index 0000000..d62db0d
--- /dev/null
+++ b/zygote/schemas/messages.fbs
@@ -0,0 +1,50 @@
+// Zygote management messages
+
+table Ack {}
+
+table Exit {}
+
+table IdentityQuery {}
+
+table IdentityQueryResponse {
+    name: string (required);
+    species: string (required);
+    arch: string (required);
+}
+
+table SpawnAndroidNative {
+    package: string (required);
+}
+
+table SpawnMock {
+    name: string (required);
+}
+
+table SpawnLibApp {
+    path: string (required);
+    args: [string] (required);
+}
+
+table SpawnResponse {
+    pid: int32;
+}
+
+table Stat {}
+
+union Message {
+    Ack,
+    Exit,
+    IdentityQuery,
+    IdentityQueryResponse,
+    SpawnAndroidNative,
+    SpawnLibApp,
+    SpawnMock,
+    SpawnResponse,
+    Stat,
+}
+
+table Parcel {
+    message: Message;
+}
+
+root_type Parcel;
\ No newline at end of file
diff --git a/zygote/src/bin/zygote.rs b/zygote/src/bin/zygote.rs
new file mode 100644
index 0000000..a1f0d74
--- /dev/null
+++ b/zygote/src/bin/zygote.rs
@@ -0,0 +1,52 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Implementation of a fully native Zygote architecture.
+//!
+//! This executable can be used to preload and initialize resources before
+//! forking child processes.
+
+use anyhow::Result;
+use clap::Parser;
+
+use zygote::{config, server, sys};
+
+fn main() -> Result<()> {
+    if let Some(thunk) = run_server() {
+        thunk()
+    }
+
+    Ok(())
+}
+
+/// Parse configuration values, instantiate the server, and run it.
+///
+/// The server is constructed in, and the child-side thunk returned from, this
+/// frame to ensure that the configuration and server resources are dropped
+/// before the thunk is evaluated.
+fn run_server() -> Option<impl FnOnce()> {
+    let config = config::Server::parse();
+
+    logger::init(
+        logger::Config::default()
+            .with_tag_on_device(config.name.clone())
+            .with_max_level(config.log_level),
+    );
+
+    log::info!("Starting Zygote server ({}) with PID {}", config.name, sys::getpid());
+
+    let mut server = server::Server::new(config);
+    server.serve()
+}
diff --git a/zygote/src/bin/zygote_cli.rs b/zygote/src/bin/zygote_cli.rs
new file mode 100644
index 0000000..2fc7be3
--- /dev/null
+++ b/zygote/src/bin/zygote_cli.rs
@@ -0,0 +1,82 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Command line interface tool for issuing commands to a Zygote
+
+use anyhow::{anyhow, bail, Context};
+use clap::Parser;
+
+use zygote::{
+    config,
+    messages::{self, build_message, Message},
+    sys,
+};
+
+fn main() -> anyhow::Result<()> {
+    let config = config::Cli::parse();
+
+    logger::init(
+        logger::Config::default().with_tag_on_device("zygote_cli").with_max_level(config.log_level),
+    );
+
+    let finished_builder = build_message(&config.command_name, &config.command_args)
+        .context("Invalid message type or arguments.")?;
+
+    let socket_path = std::path::Path::new(&config.socket);
+    let client_socket = if socket_path.exists() {
+        let client_socket = sys::socket(libc::AF_UNIX, libc::SOCK_SEQPACKET, 0)?;
+        let socket_addr =
+            sys::bound_socket_address(&config.socket, libc::AF_UNIX as libc::sa_family_t);
+
+        sys::connect(client_socket, &socket_addr)?;
+
+        client_socket
+    } else {
+        bail!("Zygote server socket path does not exist");
+    };
+
+    sys::sendmsg(client_socket, finished_builder.finished_data())?;
+
+    let (_, response) = sys::recvmsg::<{ messages::MESSAGE_BUFFER_SIZE }>(client_socket)?;
+
+    let parcel = flatbuffers::root::<messages::Parcel>(&response)?;
+    match parcel.message_type() {
+        Message::Ack => {
+            log::info!("Message acknowledged");
+        }
+        Message::IdentityQueryResponse => {
+            let identity_query_response = parcel
+                .message_as_identity_query_response()
+                .ok_or(anyhow!("Could not unpack IdentityQueryResponse"))?;
+
+            log::info!("Identity query successful: {:?}", identity_query_response);
+            println!("{:?}", identity_query_response);
+        }
+        Message::SpawnResponse => {
+            let spawn_response = parcel
+                .message_as_spawn_response()
+                .ok_or(anyhow!("Could not unpack SpawnResponse"))?;
+
+            log::info!("Spawn successful; New process pid: {}", spawn_response.pid());
+        }
+        Message(tag) => {
+            log::error!("Unexpected response message type: {}", tag);
+        }
+    }
+
+    sys::close(client_socket)?;
+
+    Ok(())
+}
diff --git a/zygote/src/bin/zygote_launch.rs b/zygote/src/bin/zygote_launch.rs
new file mode 100644
index 0000000..c8bda5f
--- /dev/null
+++ b/zygote/src/bin/zygote_launch.rs
@@ -0,0 +1,46 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Command line utility for launching processes using Zygote species.
+
+use clap::Parser;
+
+use zygote::{config, messages};
+
+fn main() {
+    let config = config::Launch::parse();
+
+    logger::init(
+        logger::Config::default()
+            .with_tag_on_device("zygote_launch")
+            .with_max_level(config.log_level),
+    );
+
+    let command_name = config.species.message_type_spawn().variant_name().unwrap().to_string();
+    let spawn_message = messages::build_message(&command_name, &config.spawn_args).unwrap();
+
+    let mut message_buffer = messages::MESSAGE_BUFFER_INIT;
+    message_buffer.as_mut_slice()[0..spawn_message.finished_data().len()]
+        .copy_from_slice(spawn_message.finished_data());
+
+    // SAFETY: The contents of this SpawnMessage were parsed from the command
+    //         line.  It is assumed that the caller of this program has
+    //         permission to take any actions specified by those spawn
+    //         arguments.  Any resulting actions will be taken with the
+    //         permissions of the current process.
+    let spawn_message = unsafe { messages::SpawnMessage::new(message_buffer) };
+
+    config.species.gestate(spawn_message, config.priority_final);
+}
diff --git a/zygote/src/config.rs b/zygote/src/config.rs
new file mode 100644
index 0000000..2eb805d
--- /dev/null
+++ b/zygote/src/config.rs
@@ -0,0 +1,138 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This module provides classes and functions for configuring a Zygote
+//! process.
+
+use anyhow::{bail, Result};
+use clap::Parser;
+use log::LevelFilter;
+
+use crate::species::SpeciesRef;
+
+const ENV_VAR_SOCKET: &str = "ZYGOTE_SOCKET";
+
+/// Configuration values used by the Zygote command line interface.  This API
+/// is temporary as the message types evolve.
+#[derive(Parser)]
+pub struct Cli {
+    /// Controls verbosity of logging; defaults to Warn
+    #[arg(long, alias("verbose"), short_alias('v'), num_args(0..=1), default_value("2"), default_missing_value("4"), value_parser(log_level_parser))]
+    pub log_level: LevelFilter,
+
+    /// A path to the target Zygote's server socket; Abstract sockets are not
+    /// currently supported.
+    #[arg(long, short, required(true))]
+    pub socket: String,
+
+    /// Name of command to send; accepted values: exit, spawn, stat
+    #[arg(required(true))]
+    pub command_name: String,
+
+    /// Additional arguments that might be used by the command
+    #[arg(trailing_var_arg(true))]
+    pub command_args: Vec<String>,
+}
+
+/// Configuration values used by the Zygote launch utility.  This API is
+/// temporary as the message types evolve.
+#[derive(Parser)]
+pub struct Launch {
+    /// Controls verbosity of logging; defaults to Warn
+    #[arg(long, alias("verbose"), short_alias('v'), num_args(0..=1), default_value("2"), default_missing_value("4"), value_parser(log_level_parser))]
+    pub log_level: LevelFilter,
+
+    /// Final scheduling priority for child processes immediately after forking
+    #[arg(long, value_parser(clap::value_parser!(i32).range(-20..20)))]
+    pub priority_final: Option<i32>,
+
+    /// Additional arguments that might be used by the command
+    #[arg(trailing_var_arg(true))]
+    pub spawn_args: Vec<String>,
+
+    /// A runtime-defined reference to Species-specific behavior
+    /// implementations.
+    #[arg(long)]
+    pub species: SpeciesRef,
+}
+
+/// Configuration values used to determine the runtime behavior of a Zygote
+/// server.  Parsing implementations are derived using the `clap` crate.
+#[derive(Parser)]
+pub struct Server {
+    /// Controls verbosity of logging; defaults to Warn
+    #[arg(long, alias("verbose"), short_alias('v'), num_args(0..=1), default_value("2"), default_missing_value("4"), value_parser(log_level_parser))]
+    pub log_level: LevelFilter,
+
+    /// Process name for the Zygote
+    #[arg(long, short, default_value("zygote"))]
+    pub name: String,
+
+    /// Effective GID to use when preloading shared libraries
+    #[arg(long, value_parser(clap::value_parser!(libc::gid_t).range(0..)))]
+    pub preload_gid: Option<libc::gid_t>,
+
+    /// Libraries to be preloaded by the server
+    #[arg(long("preload-library"), short('l'), action(clap::ArgAction::Append))]
+    pub preload_libraries: Vec<String>,
+
+    /// Effective UID to use when preloading shared libraries
+    #[arg(long, value_parser(clap::value_parser!(libc::uid_t).range(0..)))]
+    pub preload_uid: Option<libc::uid_t>,
+
+    /// Initial scheduling priority for child processes immediately after
+    /// forking
+    #[arg(long, value_parser(clap::value_parser!(i32).range(-20..20)))]
+    pub priority_initial: Option<i32>,
+
+    /// Final scheduling priority for child processes immediately before
+    /// entering application code
+    #[arg(long, value_parser(clap::value_parser!(i32).range(-20..20)))]
+    pub priority_final: Option<i32>,
+
+    /// A string representing a valid server socket FD or a location to bind a
+    /// new socket
+    #[arg(long, default_value = "default", value_parser(socket_arg_parser))]
+    pub socket: String,
+
+    /// A runtime-defined reference to Species-specific behavior
+    /// implementations.
+    #[arg(long)]
+    pub species: SpeciesRef,
+}
+
+fn log_level_parser(parse_arg: &str) -> Result<LevelFilter> {
+    match parse_arg {
+        "0" => Ok(LevelFilter::Off),
+        "1" => Ok(LevelFilter::Error),
+        "2" => Ok(LevelFilter::Warn),
+        "3" => Ok(LevelFilter::Info),
+        "4" => Ok(LevelFilter::Debug),
+        "5" => Ok(LevelFilter::Trace),
+        level => bail!("Invalid log level: {}", level),
+    }
+}
+
+fn socket_arg_parser(parse_arg: &str) -> Result<String> {
+    if parse_arg == "default" {
+        if let Ok(env_arg) = std::env::var(ENV_VAR_SOCKET) {
+            Ok(env_arg)
+        } else {
+            Ok("".to_owned())
+        }
+    } else {
+        Ok(parse_arg.to_owned())
+    }
+}
diff --git a/zygote/src/file_descriptors.rs b/zygote/src/file_descriptors.rs
new file mode 100644
index 0000000..33029a8
--- /dev/null
+++ b/zygote/src/file_descriptors.rs
@@ -0,0 +1,656 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This module implements a file descriptor hygiene registry that is used to
+//! ensure that:
+//!   * Every file descriptor opened by the process is registered
+//!   * File descriptors that are opened are allowed to be open
+//!   * File descriptors are either duped or closed appropriate after forking
+
+// TODO: Figure out a strategy for the dynamic allocations currently involved
+//       in string handling.
+
+use core::{
+    ffi::{c_int, CStr},
+    fmt,
+};
+use std::{
+    cmp::Ordering,
+    convert::TryFrom,
+    os::fd::{AsRawFd, RawFd},
+};
+
+use anyhow::{anyhow, bail, Context, Result};
+use arrayvec::{ArrayString, ArrayVec};
+use zerocopy::IntoBytes;
+
+use crate::{
+    introspection::{self, debug_assert_single_threaded, get_proc_fd_link_info},
+    species::SpeciesRef,
+    sys::{self, AsCStr, CStringBuffer},
+};
+
+const DYNAMIC_ALLOW_LIST_SIZE: usize = 64;
+const REGISTRY_SIZE: usize = 512;
+
+/// Path to the null character device for Unix-like systems
+pub const DEV_NULL_PATH: &str = "/dev/null";
+/// Path to the null character device for Unix-like systems, represented as a
+/// null-terminated C string.
+pub const DEV_NULL_PATH_C: &CStr = c"/dev/null";
+/// Path to the urandom character device for Unix-like systems
+pub const DEV_URANDOM_PATH: &str = "/dev/urandom";
+
+/// Metadata string reported via Proc for SignalFDs
+const PROC_METADATA_SIGNALFD: &CStr = c"anon_inode:[signalfd]";
+
+/// File paths used by the Zygote that are allowed to be registered
+static ALLOWED_FILE_PATHS: &[&str] = &[DEV_NULL_PATH, DEV_URANDOM_PATH];
+
+/// Socket paths used by the Zygote that are allowed to be registered
+static ALLOWED_SOCKET_PATHS: &[&str] = &[];
+
+/// Information necessary to identify and perform actions for supported file
+/// types.
+#[derive(Eq, PartialEq)]
+enum FileDescriptorInfo {
+    AbstractSocket {
+        name: ArrayString<{ sys::BUFFER_SIZE_STRINGS }>,
+    },
+    BoundSocket {
+        path: ArrayString<{ sys::BUFFER_SIZE_STRINGS }>,
+    },
+    Fifo,
+    File {
+        dev: u64,
+        inode: u64,
+        path: CStringBuffer,
+        fd_flags: c_int,
+        /// Flags set via the [`libc::open`] function
+        fs_flags_open: c_int,
+        /// Flags set via the [`libc::fcntl`] function
+        fs_flags_fcntl: c_int,
+        offset: libc::off64_t,
+    },
+    SignalFd,
+}
+
+impl fmt::Display for FileDescriptorInfo {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match self {
+            Self::AbstractSocket { name } => write!(f, "Abstract Socket ({})", name),
+            Self::BoundSocket { path } => write!(f, "Bound Socket ({})", path),
+            Self::Fifo => write!(f, "FIFO"),
+            Self::File { path, .. } => write!(f, "File ({:?})", path.as_cstr()),
+            Self::SignalFd => write!(f, "SignalFD"),
+        }
+    }
+}
+
+/// Support construction of FileDescriptorInfo structs from raw file
+/// descriptors.  Supported file types are:
+///   * Regular files
+///   * Character files
+///   * FIFO files
+///   * Sockets
+impl TryFrom<RawFd> for FileDescriptorInfo {
+    type Error = anyhow::Error;
+
+    fn try_from(fd: RawFd) -> Result<Self> {
+        let stat = sys::fstat(fd)?;
+
+        // The file descriptor registry supports regular files, character
+        // devices, sockets, and pipes. Character devices must provide a
+        // guarantee of sensible behavior when reopened.
+        //
+        // S_ISDIR : Not supported. (We could if we wanted to, but it's unused).
+        // S_ISLINK : Not supported.
+        // S_ISBLK : Not supported.
+        match sys::get_file_type(stat) {
+            libc::S_IFIFO => Ok(FileDescriptorInfo::Fifo),
+            libc::S_IFCHR | libc::S_IFREG => Self::get_file_info(fd, &stat),
+            libc::S_IFSOCK => Self::get_socket_info(fd),
+            file_type => {
+                let proc_metadata_buffer = get_proc_fd_link_info(fd).unwrap();
+                let proc_metadata_cstr = proc_metadata_buffer.as_cstr().unwrap();
+
+                if proc_metadata_cstr == PROC_METADATA_SIGNALFD {
+                    Ok(FileDescriptorInfo::SignalFd)
+                } else {
+                    Err(anyhow!(
+                        "Unable to generate info for file descriptor {}. Type: '{:?}' Metadata: '{:?}'",
+                        fd,
+                        file_type,
+                        proc_metadata_cstr,
+                    ))
+                }
+            }
+        }
+    }
+}
+
+impl FileDescriptorInfo {
+    /// Gather information about the provided file descriptor from procfs,
+    /// fcntl, and lseek64.  Combine this new information with the provided
+    /// stat data to build a new FileInfo struct.
+    fn get_file_info(fd: RawFd, stat: &libc::stat) -> Result<FileDescriptorInfo> {
+        let link_path = get_proc_fd_link_info(fd)?;
+
+        // File descriptor flags : currently on FD_CLOEXEC. We can set these
+        // using F_SETFD - we're single threaded at this point of execution so
+        // there won't be any races.
+        let fd_flags = sys::fcntl_getfd(fd)
+            .with_context(|| format!("Unable to call fcntl(F_GETFD) for FD {}", fd))?;
+
+        // File status flags :
+        // - File access mode : (O_RDONLY, O_WRONLY...) we'll pass these through
+        //   to the open() call.
+        //
+        // - File creation flags : (O_CREAT, O_EXCL...) - there's not much we can
+        //   do about these, since the file has already been created. We shall ignore
+        //   them here.
+        //
+        // - Other flags : We'll have to set these via F_SETFL. On linux, F_SETFL
+        //   can only set O_APPEND, O_ASYNC, O_DIRECT, O_NOATIME, and O_NONBLOCK.
+        //   In particular, it can't set O_SYNC and O_DSYNC. We'll have to test for
+        //   their presence and pass them in to open().
+        let fs_flags = sys::fcntl_getfl(fd)
+            .with_context(|| format!("Unable to call fcntl(F_GETFL) for FD {}", fd))?;
+
+        // File offset : Ignore the offset for non seekable files.
+        let offset = sys::lseek64(fd, 0, libc::SEEK_CUR).unwrap_or_default();
+
+        let fs_flags_open_bitmask =
+            libc::O_RDONLY | libc::O_WRONLY | libc::O_RDWR | libc::O_DSYNC | libc::O_SYNC;
+        let fs_flags_open = fs_flags & fs_flags_open_bitmask;
+        let fs_flags_rest = fs_flags & !fs_flags_open_bitmask;
+
+        Ok(FileDescriptorInfo::File {
+            dev: stat.st_dev,
+            inode: stat.st_ino as _,
+            path: link_path,
+            fd_flags,
+            fs_flags_open,
+            fs_flags_fcntl: fs_flags_rest,
+            offset,
+        })
+    }
+
+    /// Get the socket name and parse it into either a Abstract or Bound
+    /// SocketInfo struct.
+    fn get_socket_info(fd: RawFd) -> Result<FileDescriptorInfo> {
+        let (addr, path_len) = sys::getsockname(fd)?;
+        let sun_bytes: &[u8] = &addr.sun_path.as_bytes()[..path_len];
+
+        match sun_bytes {
+            [0, text @ ..] => Ok(FileDescriptorInfo::AbstractSocket {
+                name: ArrayString::from(CStr::from_bytes_until_nul(text)?.to_str()?).unwrap(),
+            }),
+            text => Ok(FileDescriptorInfo::BoundSocket {
+                path: ArrayString::from(CStr::from_bytes_with_nul(text)?.to_str()?).unwrap(),
+            }),
+        }
+    }
+}
+
+/// Use `procfs` to assert that a provided file descriptor is open and either
+/// has has a file path equal to `target` or is an abstract socket with
+/// `target` as its name.
+#[cfg(feature = "test")]
+#[track_caller]
+pub fn assert_fd_open_to(fd: RawFd, target: &str) {
+    assert!(crate::introspection::get_proc_fd_path(fd).exists());
+
+    match FileDescriptorInfo::try_from(fd).unwrap() {
+        FileDescriptorInfo::AbstractSocket { name } => assert_eq!(name.as_str(), target),
+        FileDescriptorInfo::BoundSocket { path, .. } => {
+            assert_eq!(path.as_str(), target)
+        }
+        FileDescriptorInfo::File { path, .. } => {
+            assert_eq!(path.as_cstr().unwrap().to_str().unwrap(), target)
+        }
+        _ => panic!(
+            "File descriptor {} refers to kernel object without a file system path",
+            fd.as_raw_fd()
+        ),
+    }
+}
+
+/// Tags used by the registry to specify what operations to perform when
+/// [`FileDescriptorRegistry::execute_actions`] is called.
+#[derive(Debug, Eq, PartialEq)]
+pub enum Action {
+    /// Close the file when `execute_action` is called
+    Close,
+    /// Use the `dup3` call to make the file descriptor point to /dev/null
+    DupeNull,
+    /// Do nothing with the file descriptor
+    Ignore,
+    /// Re-open the file when `execute_action` is called, thus ensuring that
+    /// child processes point to a unique kernel file structure
+    Reopen,
+}
+
+struct FileDescriptorEntry {
+    fd: RawFd,
+    info: FileDescriptorInfo,
+    action: Action,
+}
+
+impl FileDescriptorEntry {
+    /// Handle Close, DupeNull, and Reopen actions for the associated file
+    /// descriptor.  This function shall only be called after a fork even in
+    /// the context of the child process.
+    fn execute(&self, dev_null_fd: RawFd) {
+        match self.action {
+            Action::Close => {
+                sys::close(self.fd).unwrap();
+            }
+            Action::DupeNull => {
+                sys::dup3(dev_null_fd, self.fd, libc::O_CLOEXEC)
+                    .unwrap_or_else(|_| panic!("Failed to dup3 fd {} to /dev/null", self.fd));
+            }
+            Action::Ignore => {
+                // Nothing to see here
+            }
+            Action::Reopen => match &self.info {
+                FileDescriptorInfo::File {
+                    path,
+                    fd_flags,
+                    fs_flags_open,
+                    fs_flags_fcntl: fs_flags_rest,
+                    offset,
+                    ..
+                } => {
+                    let new_fd =
+                        sys::open(path.as_cstr().unwrap(), *fs_flags_open).unwrap_or_else(|_| {
+                            panic!(
+                                "Failed to open new file descriptor to existing path: {:?}",
+                                path.as_cstr()
+                            )
+                        });
+
+                    sys::fcntl_setfd(new_fd, *fd_flags).unwrap_or_else(|errno| {
+                        panic!("Failed to set descriptor flags for new file descriptor (path: {:?}, flags: {:?}): {}", path.as_cstr(), fd_flags, errno);
+                    });
+
+                    sys::fcntl_setfl(new_fd, *fs_flags_rest).unwrap_or_else(|errno| {
+                        panic!("Failed to set status flags for new file descriptor (path: {:?}, flags: {:?}): {}", path.as_cstr(), fs_flags_rest, errno);
+                    });
+
+                    sys::lseek64(new_fd, *offset, libc::SEEK_SET).unwrap_or_else(|errno| {
+                        panic!("Failed to set seek head for new file descriptor (path: {:?}, offset: {}): {}", path.as_cstr(), offset, errno);
+                    });
+
+                    // TODO: Move bit-twiddling into a function
+                    let dup_flags = if (fd_flags & libc::FD_CLOEXEC) == libc::FD_CLOEXEC {
+                        libc::O_CLOEXEC
+                    } else {
+                        0
+                    };
+
+                    sys::dup3(new_fd, self.fd, dup_flags).unwrap_or_else(|errno| {
+                        panic!("Failed to dup3 a new file descriptor to existing descriptor (path: {:?}, existing: {}, new: {:?}): {}", path.as_cstr(), self.fd, new_fd, errno);
+                    });
+
+                    sys::close(new_fd).unwrap();
+                }
+                _ => {
+                    panic!("Invalid file type ({}) registered with `Reopen` action", &self.info);
+                }
+            },
+        }
+    }
+
+    /// Close the file descriptor if it is registered with `DupeNull`, `Close`,
+    /// or `Reopen` actions.
+    fn override_and_close(&mut self) {
+        match self.action {
+            Action::Close | Action::DupeNull | Action::Reopen => {
+                sys::close(self.fd).unwrap();
+            }
+            Action::Ignore => {
+                // Nothing to do here
+            }
+        }
+    }
+}
+
+// TODO: Either arena-allocate the strings or switch to using ArrayString
+
+/// A struct for associating file descriptor information with [`Action`]s.
+/// This can be used to ensure file descriptors are accounted for and handled
+/// appropriately when the Zygote forks a new process.
+pub struct FileDescriptorRegistry {
+    species: SpeciesRef,
+    data: ArrayVec<FileDescriptorEntry, REGISTRY_SIZE>,
+    allowed_file_paths: ArrayVec<String, DYNAMIC_ALLOW_LIST_SIZE>,
+    allowed_socket_names: ArrayVec<String, DYNAMIC_ALLOW_LIST_SIZE>,
+    allowed_socket_paths: ArrayVec<String, DYNAMIC_ALLOW_LIST_SIZE>,
+}
+
+impl FileDescriptorRegistry {
+    /// Construct a new registry for a given species.  The Species reference
+    /// is used to query for species specific allowed files and sockets.
+    pub fn new(species: SpeciesRef) -> Self {
+        let mut registry = Self {
+            species,
+            data: ArrayVec::new(),
+            allowed_file_paths: ArrayVec::new(),
+            allowed_socket_names: ArrayVec::new(),
+            allowed_socket_paths: ArrayVec::new(),
+        };
+
+        // Register the stdio file descriptors
+        registry.register(0, Action::Ignore);
+        registry.register(1, Action::Ignore);
+        registry.register(2, Action::Ignore);
+
+        registry
+    }
+
+    /// Queries the Zygote and species abstract socket allow lists
+    fn abstract_socket_is_allowed(&self, name: &str) -> bool {
+        self.allowed_socket_names.contains(&name.to_owned())
+            || self.species.abstract_socket_is_allowed(name)
+    }
+
+    /// Adds a file path to the allow list
+    pub fn allow_file(&mut self, path: String) {
+        self.allowed_file_paths.push(path);
+    }
+
+    /// Adds a socket name to the allow list
+    pub fn allow_abstract_socket(&mut self, name: String) {
+        self.allowed_socket_names.push(name);
+    }
+
+    /// Adds a socket path to the allow list
+    pub fn allow_bound_socket(&mut self, name: String) {
+        self.allowed_socket_paths.push(name);
+    }
+
+    /// Iterate over all open file descriptors and compare them to the
+    /// descriptors in the registry.  Return [`Err`] if:
+    ///   * There are any files open that are not in the registry
+    ///   * There are files descriptors in the registry that are no longer open
+    ///   * A file descriptor's saved state is not equal to the current state
+    ///
+    /// If the audit is successful the function returns the number of open
+    /// file descriptors.
+    pub fn audit(&self) -> Result<usize> {
+        debug_assert_single_threaded();
+
+        let open_fds: Vec<RawFd> = introspection::get_open_file_descriptors().unwrap();
+        for index in 0..std::cmp::max(self.data.len(), open_fds.len()) {
+            if open_fds.len() <= index || self.data[index].fd < open_fds[index] {
+                bail!(
+                    "File descriptor {} ({}) was CLOSED unexpectedly.",
+                    self.data[index].fd,
+                    self.data[index].info
+                );
+            } else if self.data.len() <= index || self.data[index].fd > open_fds[index] {
+                bail!(
+                    "File descriptor {} ({}) was OPENED unexpectedly.",
+                    open_fds[index],
+                    FileDescriptorInfo::try_from(open_fds[index]).unwrap()
+                );
+            } else
+            /* if self.data[index].fd == open_fds[index] */
+            {
+                let current_info = FileDescriptorInfo::try_from(open_fds[index]).unwrap();
+                if self.data[index].info != current_info {
+                    bail!(
+                        "File descriptor {} ({}) has been REOPENED or MODIFIED",
+                        self.data[index].fd,
+                        self.data[index].info
+                    );
+                }
+            }
+        }
+
+        Ok(self.data.len())
+    }
+
+    /// Queries the Zygote and species bound socket allow lists
+    fn bound_socket_is_allowed(&self, path: &str) -> bool {
+        ALLOWED_SOCKET_PATHS.contains(&path)
+            || self.allowed_socket_paths.contains(&path.to_owned())
+            || self.species.bound_socket_is_allowed(path)
+    }
+
+    /// Iterate through the registry and perform all Close, DupeNull, and
+    /// Reopen actions.  This should be performed immediately after a fork
+    /// event.
+    pub fn execute_actions(&self) {
+        debug_assert_single_threaded();
+
+        let dev_null_fd = sys::open(DEV_NULL_PATH_C, libc::O_RDWR | libc::O_CLOEXEC).unwrap();
+
+        for entry in &self.data {
+            entry.execute(dev_null_fd);
+        }
+    }
+
+    /// Queries the Zygote and species allowed files lists.
+    fn file_is_allowed(&self, path: &CStr) -> bool {
+        ALLOWED_FILE_PATHS.contains(&path.to_str().unwrap())
+            || self.allowed_file_paths.contains(&path.to_str().unwrap().to_owned())
+            || self.species.file_is_allowed(path)
+    }
+
+    /// Searches through the sorted list of file descriptors (starting from
+    /// `index_state`) to check if a given descriptor is registered.
+    fn is_registered(&self, fd: RawFd, index_state: &mut usize, index_end: usize) -> bool {
+        while *index_state < index_end {
+            match self.data[*index_state].fd.cmp(&fd) {
+                Ordering::Less => *index_state += 1,
+                Ordering::Equal => {
+                    *index_state += 1;
+                    return true;
+                }
+                _ => return false,
+            }
+        }
+
+        false
+    }
+
+    /// Close all file descriptors registered with `DupeNull`, `Close`, and
+    /// `Reopen` actions.
+    pub fn override_and_close(&mut self) {
+        debug_assert_single_threaded();
+
+        for entry in &mut self.data {
+            entry.override_and_close();
+        }
+    }
+
+    /// Adds a file descriptor to the registry and associates it with the
+    /// provided action.
+    pub fn register(&mut self, fd: RawFd, action: Action) {
+        debug_assert_single_threaded();
+
+        match self.data.binary_search_by(|entry| entry.fd.cmp(&fd.as_raw_fd())) {
+            Ok(_) => {
+                panic!(
+                    "Attempting to register an already registered file descriptor: {}",
+                    fd.as_raw_fd()
+                );
+            }
+            Err(insert_index) => {
+                self.data.insert(
+                    insert_index,
+                    FileDescriptorEntry {
+                        fd: fd.as_raw_fd(),
+                        info: FileDescriptorInfo::try_from(fd.as_raw_fd()).unwrap(),
+                        action,
+                    },
+                );
+            }
+        }
+    }
+
+    /// Remove the given file descriptor from the registry
+    pub fn remove(&mut self, fd: RawFd) -> Result<()> {
+        self.data.remove(
+            self.data
+                .as_slice()
+                .binary_search_by(|entry| entry.fd.cmp(&fd))
+                .or_else(|_| bail!("File descriptor is not registered: {}", fd))?,
+        );
+
+        Ok(())
+    }
+
+    /// Iterate through all open file descriptors and register any unregistered
+    /// descriptors using a default action.
+    pub fn register_new(&mut self) {
+        debug_assert_single_threaded();
+        assert!(self.data.is_sorted_by_key(|entry| entry.fd));
+
+        let mut registry_index: usize = 0;
+        let num_preexisting_entries = self.data.len();
+
+        let open_fds: Vec<RawFd> = introspection::get_open_file_descriptors().unwrap();
+
+        for fd in open_fds {
+            if self.is_registered(fd, &mut registry_index, num_preexisting_entries) {
+                continue;
+            }
+
+            let info = FileDescriptorInfo::try_from(fd).unwrap();
+            let action = match info {
+                FileDescriptorInfo::AbstractSocket { ref name } => {
+                    if self.abstract_socket_is_allowed(name) {
+                        Action::DupeNull
+                    } else {
+                        panic!("Abstract socket name not found in allow list ({}): {}", fd, name);
+                    }
+                }
+                FileDescriptorInfo::BoundSocket { ref path, .. } => {
+                    if self.bound_socket_is_allowed(path) {
+                        Action::DupeNull
+                    } else {
+                        panic!("Bound socket name not found in allow list ({}): {}", fd, path);
+                    }
+                }
+                FileDescriptorInfo::Fifo => {
+                    panic!("Unregistered FIFO fd found: {}", fd);
+                }
+                FileDescriptorInfo::File { ref path, .. } => {
+                    if self.file_is_allowed(path.as_cstr().unwrap()) {
+                        self.species
+                            .get_file_action(path.as_cstr().unwrap())
+                            .unwrap_or(Action::Reopen)
+                    } else {
+                        panic!("File path not found on allow list ({}): {:?}", fd, path);
+                    }
+                }
+                FileDescriptorInfo::SignalFd => {
+                    panic!("Unregistered signal fd found: {}", fd);
+                }
+            };
+
+            self.data.push(FileDescriptorEntry { fd, info, action });
+        }
+
+        if self.data.len() != num_preexisting_entries {
+            self.data.sort_by_key(|entry| entry.fd);
+        }
+    }
+
+    // TODO: This is a debugging/development function and should be deleted
+    //       before shipping the native Zygote.
+
+    /// Debugging function
+    pub fn scan() {
+        debug_assert_single_threaded();
+
+        println!("Scanning open file descriptors:");
+
+        for fd in introspection::get_open_file_descriptors().unwrap() {
+            println!("\t{} -> {}", fd, FileDescriptorInfo::try_from(fd).unwrap());
+        }
+    }
+
+    /// Return the number of registered file descriptors.
+    pub fn size(&self) -> usize {
+        self.data.len()
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use std::{fs::File, os::fd::AsRawFd};
+
+    use super::FileDescriptorInfo;
+    use crate::{
+        introspection::get_executable_path,
+        sys::{self, create_abstract_socket, create_bound_socket, AsCStr},
+        test::manage_test,
+    };
+
+    #[test]
+    #[rustfmt::skip]
+    fn test_file_descriptor_info() {
+        manage_test(|| {
+            // Test stdin
+            assert!(
+                matches!(
+                    super::FileDescriptorInfo::try_from(0).unwrap(),
+                    super::FileDescriptorInfo::File { .. } |
+                    super::FileDescriptorInfo::Fifo));
+
+            // Test FileInfo
+            let exec_path = get_executable_path().unwrap();
+            assert!(
+                matches!(
+                    FileDescriptorInfo::try_from(File::open(&exec_path).unwrap().as_raw_fd()).unwrap(),
+                    FileDescriptorInfo::File { path, .. } if path.as_cstr().unwrap().to_str().unwrap() == exec_path.to_str().unwrap()));
+
+            // Test FifoInfo
+            let (pipe0, pipe1) = sys::pipe().unwrap();
+            assert!(
+                matches!(
+                    FileDescriptorInfo::try_from(pipe0).unwrap(),
+                    FileDescriptorInfo::Fifo));
+            assert!(
+                matches!(
+                    FileDescriptorInfo::try_from(pipe1).unwrap(),
+                    FileDescriptorInfo::Fifo));
+
+            // Test AbstractSocket
+            let abstract_socket_fd = create_abstract_socket(crate::test::SOCKET_NAME_1, libc::SOCK_DGRAM).unwrap();
+            let info = FileDescriptorInfo::try_from(abstract_socket_fd).unwrap();
+            assert!(
+                matches!(
+                    info,
+                    FileDescriptorInfo::AbstractSocket { name } if name.to_string() == crate::test::SOCKET_NAME_1));
+
+            // Test BoundSocket
+            let bound_socket_fd = create_bound_socket(crate::test::SOCKET_PATH_1, libc::SOCK_DGRAM).unwrap();
+            assert!(
+                matches!(
+                    FileDescriptorInfo::try_from(bound_socket_fd).unwrap(),
+                    FileDescriptorInfo::BoundSocket { path, .. } if path.to_string() == crate::test::SOCKET_PATH_1));
+
+            sys::close(pipe0).unwrap();
+            sys::close(pipe1).unwrap();
+            sys::close(abstract_socket_fd).unwrap();
+            sys::close(bound_socket_fd).unwrap();
+        });
+    }
+}
diff --git a/zygote/src/introspection.rs b/zygote/src/introspection.rs
new file mode 100644
index 0000000..891e66a
--- /dev/null
+++ b/zygote/src/introspection.rs
@@ -0,0 +1,237 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This module provides support for querying the `/proc/` file system for
+//! information about the current process.
+
+use core::{debug_assert, ffi::CStr, iter::Iterator};
+use std::{
+    fs::File,
+    io::{Read, Write},
+    os::fd::RawFd,
+    path::Path,
+};
+
+use anyhow::{anyhow, Context, Result};
+use arrayvec::ArrayVec;
+
+use crate::sys;
+
+/// Prefix to the /proc/ directory containing information about open file
+/// descriptors.
+///
+/// See: `man proc_pid_fd`
+const PROC_SELF_FD_DIR_STR: &str = "/proc/self/fd";
+const PROC_SELF_FD_DIR_CSTR: &std::ffi::CStr = c"/proc/self/fd";
+
+#[cfg(test)]
+const PROC_SELF_EXE: &str = "/proc/self/exe";
+
+/// Panic if the [`Result`] is [`Err`].
+#[macro_export]
+macro_rules! assert_ok {
+    ($result:expr) => {
+        match $result {
+            Ok(_) => {}
+            Err(err_val) => {
+                panic!("Unexpected error: {:?}", err_val);
+            }
+        }
+    };
+}
+
+/// Panic if the [`Result`] is [`Err`].
+#[macro_export]
+macro_rules! debug_assert_ok {
+    ($result:expr) => {
+        if cfg!(debug_assertions) {
+            assert_ok!($result);
+        }
+    };
+}
+
+/// Panic if there is more than one thread in the current process.
+#[track_caller]
+pub fn assert_single_threaded() {
+    assert_eq!(ProcStat::get().unwrap().num_threads, 1);
+}
+
+/// Panic if there is more than one thread in the current process.
+#[track_caller]
+pub fn debug_assert_single_threaded() {
+    debug_assert_eq!(ProcStat::get().unwrap().num_threads, 1);
+}
+
+/// Panic if a given file descriptor *IS NOT* open
+#[cfg(feature = "test")]
+#[track_caller]
+pub fn assert_fd_open(fd: RawFd) {
+    assert!(get_proc_fd_path(fd).exists());
+}
+
+/// Panic if a given file descriptor *IS* open
+#[cfg(feature = "test")]
+#[track_caller]
+pub fn assert_fd_closed(fd: RawFd) {
+    assert!(!get_proc_fd_path(fd).exists());
+}
+
+/// Query procfs for the path of the current executable
+#[cfg(test)]
+pub(crate) fn get_executable_path() -> std::io::Result<std::path::PathBuf> {
+    std::fs::read_link(PROC_SELF_EXE)
+}
+
+// TODO: Update to return an iterator
+
+/// Read the contents of the /proc/self/fd directory to get a list of open
+/// file descriptors.
+pub(crate) fn get_open_file_descriptors() -> Result<Vec<RawFd>> {
+    let proc_self_fds_path = Path::new(PROC_SELF_FD_DIR_CSTR.to_str()?);
+    assert!(proc_self_fds_path.exists());
+
+    // The `std::fs::read_dir` function will open two file descriptors when
+    // called and there is no way to gain access to their values.  Manually
+    // opening and iterating over the directory allows us to avoid adding
+    // transient file descriptor to the registry.
+    let proc_self_fds_dir = sys::opendir(PROC_SELF_FD_DIR_CSTR)?;
+    let proc_self_fds_fd = sys::dirfd(&proc_self_fds_dir)?;
+
+    let mut fd_vec = Vec::<RawFd>::new();
+    while let Some(dir_entry) = sys::readdir(&proc_self_fds_dir) {
+        // TODO: Provide a safe abstraction via the sys module
+        // SAFETY: Libc guarantees that the dir_entry->d_name member contains
+        //         a valid C string.
+        let dir_entry_str =
+            unsafe { std::ffi::CStr::from_ptr((*dir_entry.as_ptr()).d_name.as_ptr()) };
+
+        if !dir_entry_str.is_empty() {
+            let first_char = dir_entry_str
+                .to_bytes()
+                .first()
+                .ok_or(anyhow!("Failed to read directory entry name"))?;
+
+            if first_char.is_ascii_digit() {
+                let open_fd = dir_entry_str
+                    .to_str()?
+                    .parse()
+                    .context("Failed to parse proc file descriptor entry")?;
+
+                if proc_self_fds_fd != open_fd {
+                    fd_vec.push(open_fd);
+                }
+            }
+        }
+    }
+
+    sys::closedir(proc_self_fds_dir)?;
+
+    debug_assert!(fd_vec.is_sorted());
+
+    Ok(fd_vec)
+}
+
+/// Read file descriptor information from procfs into a CStringBuffer.
+pub(crate) fn get_proc_fd_link_info(fd: RawFd) -> Result<sys::CStringBuffer> {
+    let mut path_cstr_buff = ArrayVec::<u8, { sys::BUFFER_SIZE_STRINGS }>::new();
+    write!(path_cstr_buff, "{}/{}\0", PROC_SELF_FD_DIR_STR, fd)?;
+    let path_cstr = CStr::from_bytes_until_nul(path_cstr_buff.as_slice()).unwrap();
+
+    sys::readlink(path_cstr).with_context(|| format!("Unable to read procfs symlink for fd {}", fd))
+}
+
+/// Construct PathBuf pointing to an entry in /proc/self/fd.  The entry may or
+/// may not exist.
+pub fn get_proc_fd_path(fd: RawFd) -> std::path::PathBuf {
+    std::path::Path::new(PROC_SELF_FD_DIR_STR).join(fd.to_string())
+}
+
+/// Information gathered from /proc/self/stat.
+///
+/// See: `man proc_pid_stat`
+pub struct ProcStat {
+    /// Process ID
+    pub pid: u32,
+    /// Process group ID
+    pub pgrp: u32,
+    /// Number of minor faults
+    pub minflt: u64,
+    /// Number of minor faults in waited-for children
+    pub cminflt: u64,
+    /// Number of major faults
+    pub majflt: u64,
+    /// Number of major faults in waited-for children
+    pub cmajflt: u64,
+    /// User time
+    pub utime: u64,
+    /// System time
+    pub stime: u64,
+    /// Number of threads in the process
+    pub num_threads: u64,
+    /// Virtual memory size in bytes
+    pub vsize: u64,
+    /// Resident set size in number of pages
+    pub rss: u64,
+}
+
+impl ProcStat {
+    const PROC_STAT_BUFFER_SIZE: usize = 512;
+    const PROC_STAT_PATH_STR: &str = "/proc/self/stat";
+    const PROC_STAT_NUM_ENTRIES: usize = 52;
+
+    /// Query procfs for statistics on the current process.
+    #[rustfmt::skip]
+    pub fn get() -> Result<Self> {
+        let mut proc_file = File::open(Self::PROC_STAT_PATH_STR)?;
+        let mut proc_buf: [u8; Self::PROC_STAT_BUFFER_SIZE] = [0; Self::PROC_STAT_BUFFER_SIZE];
+
+        let read_len = proc_file.read(&mut proc_buf)?;
+        let text = String::from_utf8_lossy(&proc_buf[0..read_len]);
+
+        let (text_left, text_right) = text.rsplit_once(") ").ok_or(anyhow!("Malformed /proc/self/stat output"))?;
+        let (pid_str, _) = text_left.split_once(" (").ok_or(anyhow!("Malformed /proc/self/stat output"))?;
+        let rest = text_right
+            .split_whitespace()
+            .collect::<ArrayVec<&str, { Self::PROC_STAT_NUM_ENTRIES }>>();
+
+        assert_eq!(rest.len(), Self::PROC_STAT_NUM_ENTRIES - 2);
+
+        Ok(Self {
+            pid:         pid_str.parse()?,
+            pgrp:        rest[ 2].parse()?,
+            minflt:      rest[ 7].parse()?,
+            cminflt:     rest[ 8].parse()?,
+            majflt:      rest[ 9].parse()?,
+            cmajflt:     rest[10].parse()?,
+            utime:       rest[11].parse()?,
+            stime:       rest[12].parse()?,
+            num_threads: rest[17].parse()?,
+            vsize:       rest[20].parse()?,
+            rss:         rest[21].parse()?,
+        })
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use crate::test::manage_test;
+
+    #[test]
+    fn test_open_file_descriptors() {
+        manage_test(|| {
+            assert_eq!(super::get_open_file_descriptors().unwrap(), vec![0, 1, 2]);
+        });
+    }
+}
diff --git a/zygote/src/lib.rs b/zygote/src/lib.rs
new file mode 100644
index 0000000..51d2aba
--- /dev/null
+++ b/zygote/src/lib.rs
@@ -0,0 +1,30 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Implementation of a fully native Zygote architecture.
+//!
+//! This library contains the logic used by the Zygote executable.
+
+#[cfg(any(test, feature = "test"))]
+pub mod test;
+
+pub mod config;
+pub mod file_descriptors;
+pub mod introspection;
+pub mod libc_fill;
+pub mod messages;
+pub mod server;
+pub mod species;
+pub mod sys;
diff --git a/zygote/src/libc_fill.rs b/zygote/src/libc_fill.rs
new file mode 100644
index 0000000..f2c9173
--- /dev/null
+++ b/zygote/src/libc_fill.rs
@@ -0,0 +1,60 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This module provides extern definitions for `libc` functions that are not
+//! defined by the `libc` crate for some platforms.
+
+#[cfg(target_os = "android")]
+use core::ffi::{c_int, c_uint, c_void};
+
+#[cfg(target_os = "android")]
+unsafe extern "C" {
+    /// Return the current process's FDSan error level
+    ///
+    /// # Safety
+    /// This function is not thread safe.
+    ///
+    /// See: https://android.googlesource.com/platform/bionic/+/master/docs/fdsan.md
+    pub fn android_fdsan_get_error_level() -> c_uint;
+
+    /// Sets the process's FDSan error level and returns the previous value
+    ///
+    /// # Safety
+    /// This function is not thread safe.
+    ///
+    /// See: https://android.googlesource.com/platform/bionic/+/master/docs/fdsan.md
+    pub fn android_fdsan_set_error_level(level: c_uint) -> c_uint;
+
+    /// Set Android-specific allocation options.
+    ///
+    /// See: https://cs.android.com/android/platform/superproject/main/+/main:bionic/libc/bionic/android_mallopt.cpp
+    pub fn android_mallopt(opcode: c_int, arg: *mut c_void, arg_size: usize) -> bool;
+
+    /// Reset the thread's stack protection salt
+    ///
+    /// The caller should not return after calling this function.  If it does,
+    /// and stack protection is enabled, the program will crash.
+    ///
+    /// See: https://cs.android.com/android/platform/superproject/main/+/main:bionic/libc/bionic/__libc_init_main_thread.cpp;l=104
+    pub safe fn android_reset_stack_guards();
+
+    /// This variant of `dup` is used by
+    /// [`file_descriptor::FileDescriptorEntry::execute`] to ensure that the
+    /// correct flags (e.g. libc::O_CLOEXEC) are set during the duplication
+    /// operation.
+    ///
+    /// See `man dup`
+    pub fn dup3(oldfd: c_int, newfd: c_int, flags: c_int) -> c_int;
+}
diff --git a/zygote/src/messages.rs b/zygote/src/messages.rs
new file mode 100644
index 0000000..a0e8c3c
--- /dev/null
+++ b/zygote/src/messages.rs
@@ -0,0 +1,298 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Generated Rust bindings for the Flatbuffer schema defined in `schemas/messages.fbs`
+
+#[allow(dead_code, missing_docs, unsafe_op_in_unsafe_fn, unused_imports, clippy::all)]
+mod inner {
+    include!(concat!(env!("OUT_DIR"), "/messages.rs"));
+}
+
+use anyhow::{bail, Result};
+use clap::Parser;
+use flatbuffers::UnionWIPOffset;
+
+/// Default size for all message parsing and passing.
+pub const MESSAGE_BUFFER_SIZE: usize = 512;
+/// Zero-initialized message buffer
+pub const MESSAGE_BUFFER_INIT: [u8; MESSAGE_BUFFER_SIZE] = [0; MESSAGE_BUFFER_SIZE];
+/// Statically allocated arrays used for receiving messages.
+pub type MessageBuffer = [u8; MESSAGE_BUFFER_SIZE];
+
+// Export types from the inner module.
+pub use inner::{
+    Ack, AckArgs, Exit, ExitArgs, IdentityQuery, IdentityQueryArgs, IdentityQueryResponse,
+    IdentityQueryResponseArgs, Message, Parcel, ParcelArgs, SpawnAndroidNative,
+    SpawnAndroidNativeArgs, SpawnLibApp, SpawnLibAppArgs, SpawnMock, SpawnMockArgs, SpawnResponse,
+    SpawnResponseArgs, Stat, StatArgs,
+};
+
+/// Trait for types that can be serialized to a FlatBuffer message.
+pub trait ToFlatBuffer {
+    /// Serialize a message into the provided FlatBufferBuilder.
+    fn build_message(
+        &self,
+        builder: &mut flatbuffers::FlatBufferBuilder,
+    ) -> (Message, flatbuffers::WIPOffset<UnionWIPOffset>);
+
+    /// Build a flatbuffer message.
+    fn build<'a>(&self) -> flatbuffers::FlatBufferBuilder<'a> {
+        let mut builder = flatbuffers::FlatBufferBuilder::<'a>::with_capacity(MESSAGE_BUFFER_SIZE);
+
+        let (message_type, message) = self.build_message(&mut builder);
+
+        let parcel =
+            Parcel::create(&mut builder, &ParcelArgs { message_type, message: Some(message) });
+
+        builder.finish(parcel, None);
+
+        builder
+    }
+}
+
+/// Helper struct for constructing Ack messages.
+#[derive(Debug)]
+pub struct AckBuilder;
+
+impl ToFlatBuffer for AckBuilder {
+    fn build_message(
+        &self,
+        builder: &mut flatbuffers::FlatBufferBuilder,
+    ) -> (Message, flatbuffers::WIPOffset<UnionWIPOffset>) {
+        (Message::Ack, Ack::create(builder, &AckArgs {}).as_union_value())
+    }
+}
+
+/// Helper struct for constructing Exit messages.
+#[derive(Debug)]
+pub struct ExitBuilder;
+
+impl ToFlatBuffer for ExitBuilder {
+    fn build_message(
+        &self,
+        builder: &mut flatbuffers::FlatBufferBuilder,
+    ) -> (Message, flatbuffers::WIPOffset<UnionWIPOffset>) {
+        (Message::Exit, Exit::create(builder, &ExitArgs {}).as_union_value())
+    }
+}
+
+/// Helper struct for constructing IdentityQuery messages.
+#[derive(Debug)]
+pub struct IdentityQueryBuilder;
+
+impl ToFlatBuffer for IdentityQueryBuilder {
+    fn build_message(
+        &self,
+        builder: &mut flatbuffers::FlatBufferBuilder,
+    ) -> (Message, flatbuffers::WIPOffset<UnionWIPOffset>) {
+        (
+            Message::IdentityQuery,
+            IdentityQuery::create(builder, &IdentityQueryArgs {}).as_union_value(),
+        )
+    }
+}
+
+/// Helper struct for constructing IdentityQueryResponse messages.
+#[derive(Debug)]
+pub struct IdentityQueryResponseBuilder<'a> {
+    /// Name of the Zygote server process
+    pub name: &'a String,
+    /// Name of the Zygote server's species
+    pub species: &'static str,
+    /// Name of the Zygote server's architecture
+    pub arch: &'static str,
+}
+
+impl ToFlatBuffer for IdentityQueryResponseBuilder<'_> {
+    fn build_message(
+        &self,
+        builder: &mut flatbuffers::FlatBufferBuilder,
+    ) -> (Message, flatbuffers::WIPOffset<UnionWIPOffset>) {
+        let packed_name = builder.create_string(self.name.as_str());
+        let packed_species = builder.create_string(self.species);
+        let packed_arch = builder.create_string(self.arch);
+
+        (
+            Message::IdentityQueryResponse,
+            IdentityQueryResponse::create(
+                builder,
+                &IdentityQueryResponseArgs {
+                    name: Some(packed_name),
+                    species: Some(packed_species),
+                    arch: Some(packed_arch),
+                },
+            )
+            .as_union_value(),
+        )
+    }
+}
+
+/// Helper struct for constructing SpawnAndroidNative messages.
+#[derive(Debug, Parser)]
+pub struct SpawnAndroidNativeBuilder {
+    #[arg(required(true))]
+    package: String,
+}
+
+impl ToFlatBuffer for SpawnAndroidNativeBuilder {
+    fn build_message(
+        &self,
+        builder: &mut flatbuffers::FlatBufferBuilder,
+    ) -> (Message, flatbuffers::WIPOffset<UnionWIPOffset>) {
+        let packed_package = builder.create_string(self.package.as_str());
+
+        (
+            Message::SpawnAndroidNative,
+            SpawnAndroidNative::create(
+                builder,
+                &SpawnAndroidNativeArgs { package: Some(packed_package) },
+            )
+            .as_union_value(),
+        )
+    }
+}
+
+/// Helper struct for constructing SpawnLibApp messages.
+#[derive(Debug, Parser)]
+pub struct SpawnLibAppBuilder {
+    #[arg(required(true))]
+    path: String,
+
+    #[arg(trailing_var_arg(true))]
+    args: Vec<String>,
+}
+
+impl ToFlatBuffer for SpawnLibAppBuilder {
+    fn build_message(
+        &self,
+        builder: &mut flatbuffers::FlatBufferBuilder,
+    ) -> (Message, flatbuffers::WIPOffset<UnionWIPOffset>) {
+        let packed_path = builder.create_string(self.path.as_str());
+        let packed_args_strings: Vec<_> =
+            self.args.iter().map(|arg| builder.create_string(arg.as_str())).collect();
+        let packed_args_vector = builder.create_vector(&packed_args_strings);
+
+        (
+            Message::SpawnLibApp,
+            SpawnLibApp::create(
+                builder,
+                &SpawnLibAppArgs { path: Some(packed_path), args: Some(packed_args_vector) },
+            )
+            .as_union_value(),
+        )
+    }
+}
+
+/// Helper struct for constructing SpawnMock messages.
+#[derive(Debug, Parser)]
+pub struct SpawnMockBuilder {
+    #[arg(required(true))]
+    name: String,
+}
+
+impl ToFlatBuffer for SpawnMockBuilder {
+    fn build_message(
+        &self,
+        builder: &mut flatbuffers::FlatBufferBuilder,
+    ) -> (Message, flatbuffers::WIPOffset<UnionWIPOffset>) {
+        let packed_name = builder.create_string(self.name.as_str());
+
+        (
+            Message::SpawnMock,
+            SpawnMock::create(builder, &SpawnMockArgs { name: Some(packed_name) }).as_union_value(),
+        )
+    }
+}
+
+/// Helper struct for constructing SpawnResponse messages.
+#[derive(Debug)]
+pub struct SpawnResponseBuilder {
+    /// The pid of the spawned process.
+    pub pid: i32,
+}
+
+impl ToFlatBuffer for SpawnResponseBuilder {
+    fn build_message(
+        &self,
+        builder: &mut flatbuffers::FlatBufferBuilder,
+    ) -> (Message, flatbuffers::WIPOffset<UnionWIPOffset>) {
+        (
+            Message::SpawnResponse,
+            SpawnResponse::create(builder, &SpawnResponseArgs { pid: self.pid }).as_union_value(),
+        )
+    }
+}
+
+/// Helper struct for constructing Stat messages.
+#[derive(Debug)]
+pub struct StatBuilder;
+
+impl ToFlatBuffer for StatBuilder {
+    fn build_message(
+        &self,
+        builder: &mut flatbuffers::FlatBufferBuilder,
+    ) -> (Message, flatbuffers::WIPOffset<UnionWIPOffset>) {
+        (Message::Stat, Stat::create(builder, &StatArgs {}).as_union_value())
+    }
+}
+
+/// A wrapper class used to ensure that the process server and species code
+/// document the invariants and safety checks that they rely upon when handling
+/// spawn messages.
+#[repr(transparent)]
+pub struct SpawnMessage {
+    buffer: MessageBuffer,
+}
+
+impl SpawnMessage {
+    /// Constructor
+    ///
+    /// # Safety
+    /// Once consumed, the contents of the MessageBuffer can be used to access
+    /// file system resources and execute code.  For this reason, the contents
+    /// of the MessageBuffer must come from a trusted source that is authorized
+    /// to execute commands in the current process's context.
+    pub unsafe fn new(message_buffer: MessageBuffer) -> SpawnMessage {
+        SpawnMessage { buffer: message_buffer }
+    }
+}
+
+impl AsRef<MessageBuffer> for SpawnMessage {
+    fn as_ref(&self) -> &MessageBuffer {
+        &self.buffer
+    }
+}
+
+/// Build a flatbuffer message from a message name and arguments.
+pub fn build_message<'a>(
+    message_name: &'a String,
+    message_args: &'a [String],
+) -> Result<flatbuffers::FlatBufferBuilder<'a>> {
+    let extra_args_iter = std::iter::once(message_name).chain(message_args.iter());
+
+    match message_name.as_str() {
+        "Exit" => Ok(ExitBuilder {}.build()),
+        "IdentityQuery" => Ok(IdentityQueryBuilder {}.build()),
+        "SpawnAndroidNative" => {
+            Ok(SpawnAndroidNativeBuilder::try_parse_from(extra_args_iter)?.build())
+        }
+        "SpawnLibApp" => Ok(SpawnLibAppBuilder::try_parse_from(extra_args_iter)?.build()),
+        "SpawnMock" => Ok(SpawnMockBuilder::try_parse_from(extra_args_iter)?.build()),
+        "Stat" => Ok(StatBuilder {}.build()),
+        _ => {
+            bail!("Invalid message type: {}", message_name)
+        }
+    }
+}
diff --git a/zygote/src/server.rs b/zygote/src/server.rs
new file mode 100644
index 0000000..1769cda
--- /dev/null
+++ b/zygote/src/server.rs
@@ -0,0 +1,713 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Implementation of a fully native Zygote architecture.
+//!
+//! This executable can be used to preload and initialize resources before
+//! forking child processes.
+
+use std::ffi::OsStr;
+use std::{os::fd::RawFd, path::Path};
+
+use anyhow::{anyhow, bail, Result};
+use arrayvec::ArrayVec;
+use flatbuffers::{self};
+use libloading::os::unix::{Library, RTLD_GLOBAL, RTLD_NOW};
+use log::{error, info, warn};
+
+use crate::{
+    assert_ok, config, debug_assert_ok,
+    file_descriptors::{self, FileDescriptorRegistry},
+    introspection::{debug_assert_single_threaded, get_proc_fd_path},
+    messages::{self, Message, MessageBuffer, Parcel, ToFlatBuffer, MESSAGE_BUFFER_SIZE},
+    species::SpeciesRef,
+    sys::{
+        self, LibcResult,
+        LoopControl::{self, *},
+        LoopExit, PollFd,
+    },
+};
+
+const BUFFER_SIZE_CLIENT_SOCKETS: usize = 16;
+const BUFFER_SIZE_POLL: usize = 64;
+const SERVER_SOCKET_BACKLOG: core::ffi::c_int = 10;
+const ZYGOTE_SOCKET_PREFIX: &str = "/dev/socket/";
+
+type PollBuffer = ArrayVec<PollFd, BUFFER_SIZE_POLL>;
+
+impl std::convert::From<&mut Server> for PollBuffer {
+    fn from(server: &mut Server) -> PollBuffer {
+        let mut poll_buffer = PollBuffer::new();
+
+        poll_buffer.push(PollFd::new(server.signal_fd, libc::POLLIN));
+        poll_buffer.push(PollFd::new(server.server_socket, libc::POLLIN));
+
+        for client_socket in &server.client_sockets {
+            poll_buffer.push(PollFd::new(*client_socket, libc::POLLIN));
+        }
+
+        poll_buffer
+    }
+}
+
+struct PollPartition<'a> {
+    pub signal: &'a PollFd,
+    pub server: &'a PollFd,
+    pub clients: &'a [PollFd],
+}
+
+trait Partition<'a> {
+    fn partition(&'a self) -> PollPartition<'a>;
+}
+
+impl<'a> Partition<'a> for PollBuffer {
+    fn partition(&'a self) -> PollPartition<'a> {
+        PollPartition::<'a> {
+            signal: &self[0],
+            server: &self[1],
+            clients: if self.len() > 2 { &self[2..] } else { &[] },
+        }
+    }
+}
+
+#[derive(Debug)]
+enum ServerControl<T> {
+    Continue,
+    Shutdown,
+    Trampoline(T),
+}
+
+impl<T> ServerControl<T> {
+    #[allow(dead_code)]
+    pub fn is_continue(&self) -> bool {
+        matches!(self, ServerControl::Continue)
+    }
+
+    pub fn is_exit(&self) -> bool {
+        matches!(self, ServerControl::Shutdown)
+    }
+
+    #[allow(dead_code)]
+    pub fn is_trampoline(&self) -> bool {
+        matches!(self, ServerControl::Trampoline(_))
+    }
+}
+
+enum ClientLoopControl<T> {
+    Child(T),
+    NextSocket,
+    Error(RawFd, sys::Errno),
+    Shutdown,
+}
+
+/// The main data structure for the Zygote process server.
+pub struct Server {
+    name: String,
+    species: SpeciesRef,
+    pid: libc::pid_t,
+
+    registry: FileDescriptorRegistry,
+
+    signal_fd: RawFd,
+    server_socket: RawFd,
+    client_sockets: ArrayVec<RawFd, BUFFER_SIZE_CLIENT_SOCKETS>,
+
+    priority_initial: Option<i32>,
+    priority_final: Option<i32>,
+    server_socket_path: Option<String>,
+
+    preload_uid: Option<libc::uid_t>,
+    preload_gid: Option<libc::gid_t>,
+}
+
+impl Server {
+    /// Create a new Zygote process server from a [`crate::config::Config`]
+    /// reference.
+    ///
+    /// Add a destructor to clean up the socket if we create it.
+    pub fn new(config: config::Server) -> Self {
+        let mut registry = FileDescriptorRegistry::new(config.species);
+
+        let (server_socket, server_socket_path) = Self::get_server_socket(&config).unwrap();
+        registry.register(server_socket, file_descriptors::Action::Close);
+
+        let sigset = sys::build_sigset(&[libc::SIGCHLD, libc::SIGINT, libc::SIGTERM]).unwrap();
+        sys::sigprocmask(libc::SIG_BLOCK, &sigset).unwrap();
+        let signal_fd = sys::signalfd(-1, &sigset, libc::SFD_NONBLOCK).unwrap();
+        registry.register(signal_fd, file_descriptors::Action::Close);
+
+        let server = Self {
+            name: config.name,
+            species: config.species,
+            pid: sys::getpid(),
+
+            registry,
+
+            signal_fd,
+            server_socket,
+            client_sockets: ArrayVec::new(),
+
+            priority_initial: config.priority_initial,
+            priority_final: config.priority_final,
+            server_socket_path,
+
+            preload_uid: config.preload_uid,
+            preload_gid: config.preload_gid,
+        };
+
+        sys::prctl_set_name(&server.name);
+
+        // Create a new process group for this Zygote server process and its
+        // children.  The following list contains the possible error codes
+        // returned and why they are not applicable to this call site:
+        //  * EACCESS: Not possible; calling on self
+        //  * EINVAL: Both arguments are literals >= 0
+        //  * EPERM: Not applicable; we're creating a new process group, not
+        //           moving between existing ones
+        //  * EPERM: Not applicable; calling on self
+        if let Err(errno) = sys::setpgid(0, 0) {
+            error!("Failed to create process group for Zygote server: {}", errno);
+            std::process::exit(1);
+        }
+
+        server.preload(&config.preload_libraries);
+
+        #[cfg(target_os = "android")]
+        if let Err(errno) = sys::mallopt(libc::M_PURGE_ALL, 0) {
+            error!("Failed to mallopt(M_PURGE_ALL): {}", errno);
+        }
+
+        server
+    }
+
+    /// Produce a socket file descriptor by one of the following methods:
+    ///   * Using the provided integer as a file descriptor
+    ///   * Opening a new socket and binding it to the provided path
+    ///   * Opening a new socket and binding it to a default path
+    fn get_server_socket(config: &config::Server) -> Result<(RawFd, Option<String>)> {
+        if config.socket.is_empty() {
+            let mut socket_path = std::path::PathBuf::from(ZYGOTE_SOCKET_PREFIX);
+            socket_path.push(config.name.clone());
+
+            std::fs::create_dir_all(ZYGOTE_SOCKET_PREFIX).unwrap();
+            let socket_fd =
+                sys::create_bound_socket(socket_path.to_str().unwrap(), libc::SOCK_SEQPACKET)?;
+            sys::fcntl_setfl(socket_fd, libc::O_NONBLOCK)?;
+            sys::listen(socket_fd, SERVER_SOCKET_BACKLOG)?;
+
+            Ok((socket_fd, Some(socket_path.to_str().unwrap().to_owned())))
+        } else if let Ok(fd) = config.socket.parse::<RawFd>() {
+            if !get_proc_fd_path(fd).exists() {
+                bail!("Provided integer argument does not refer to an open file: {}", fd);
+            }
+
+            let stat = sys::fstat(fd).unwrap();
+            if sys::get_file_type(stat) != libc::S_IFSOCK {
+                bail!("Provided file descriptor does not refer to a valid socket: {}", fd);
+            }
+
+            sys::fcntl_setfl(fd, libc::O_NONBLOCK)?;
+            sys::listen(fd, SERVER_SOCKET_BACKLOG)?;
+
+            Ok((fd, None))
+        } else {
+            let arg_path = Path::new(&config.socket);
+
+            if arg_path.exists() {
+                bail!("Socket argument paths already exists: {}", &config.socket);
+            }
+
+            std::fs::create_dir_all(
+                arg_path.parent().ok_or(anyhow!("Socket path must have a parent directory"))?,
+            )?;
+
+            let socket_fd = sys::create_bound_socket(&config.socket, libc::SOCK_SEQPACKET)?;
+            sys::fcntl_setfl(socket_fd, libc::O_NONBLOCK)?;
+            sys::listen(socket_fd, SERVER_SOCKET_BACKLOG)?;
+
+            Ok((socket_fd, Some(config.socket.clone())))
+        }
+    }
+
+    /// Check each of the polled file descriptors to check if we should read
+    /// from them.
+    ///
+    /// The function's return value indicates if the server should terminate
+    /// after this call.
+    fn check_poll_events(
+        &mut self,
+        partition: PollPartition<'_>,
+    ) -> ServerControl<impl FnOnce() + use<>> {
+        if self.check_signalfd_events(&partition).is_exit() {
+            return ServerControl::Shutdown;
+        }
+
+        self.check_server_socket_events(&partition);
+        self.check_client_sockets_events(&partition)
+    }
+
+    fn check_client_sockets_events(
+        &mut self,
+        partition: &PollPartition<'_>,
+    ) -> ServerControl<impl FnOnce() + use<>> {
+        for client_pollfd in partition.clients {
+            // POLLERR and POLLNVAL should never occur for a client socket.
+            let checked_pollfd = client_pollfd.check().unwrap_or_else(|(fd, error_events)| {
+                panic!("Received polling error for client socket {}: {:?}", fd, error_events)
+            });
+
+            let pollin_result = checked_pollfd.handle_event(libc::POLLIN, &mut |fd| {
+                sys::call_until_would_block(
+                    || sys::recvmsg::<MESSAGE_BUFFER_SIZE>(fd),
+                    &mut |(readlen, message_buffer): (isize, MessageBuffer)| {
+                        if readlen == 0 {
+                            return Break(ClientLoopControl::NextSocket);
+                        }
+
+                        let parcel = flatbuffers::root::<Parcel>(&message_buffer).unwrap();
+
+                        self.dispatch_message_handler(fd, message_buffer, parcel)
+                    },
+                )
+                // TODO: Add more extensive error handling.
+                .unwrap()
+            });
+
+            match pollin_result {
+                None => {
+                    // No event was registered for this file descriptor
+                }
+                Some(LoopExit::WouldBlock) => {
+                    // All available messages were read from the socket
+                }
+                Some(LoopExit::Early(control)) => {
+                    match control {
+                        ClientLoopControl::Child(thunk) => {
+                            // We are in the child process and should exit the
+                            // server with the thunk.
+                            return ServerControl::Trampoline(thunk);
+                        }
+                        ClientLoopControl::NextSocket => {
+                            // Zero-length read from socket, continue and wait for SIGHUP
+                        }
+                        ClientLoopControl::Error(fd, errno) => {
+                            error!(
+                                "Error encountered while responding to client socket {fd}: {errno}"
+                            );
+
+                            self.remove_client_socket(fd);
+                            continue;
+                        }
+                        ClientLoopControl::Shutdown => return ServerControl::Shutdown,
+                    }
+                }
+            }
+
+            let _ = checked_pollfd.handle_event(libc::POLLHUP, |fd| {
+                info!("client socket disconnected: {fd}");
+                self.remove_client_socket(fd);
+            });
+        }
+
+        // Continue the server loop
+        ServerControl::Continue
+    }
+
+    fn check_server_socket_events(&mut self, partition: &PollPartition<'_>) {
+        // POLLERR and POLLNVAL should never occur for the server socket.
+        let checked_pollfd = partition.server.check().unwrap_or_else(|(_, error_events)| {
+            panic!("Received polling error for server socket: {error_events:?}");
+        });
+
+        checked_pollfd.handle_event(libc::POLLIN, &mut |fd| {
+            sys::call_until_would_block(|| sys::accept(fd), &mut |new_client_fd| {
+                info!(
+                    "Accepted new client socket connection from PID {}",
+                    sys::get_socket_creds(new_client_fd).unwrap().pid
+                );
+
+                sys::fcntl_setfl(new_client_fd, libc::O_NONBLOCK).unwrap();
+
+                self.client_sockets.push(new_client_fd);
+                self.registry.register(new_client_fd, file_descriptors::Action::Close);
+
+                // Continue reading
+                LoopControl::<()>::Continue
+            })
+            // TODO: Add more extensive error handling.
+            .unwrap();
+        });
+
+        // We don't need to check to see if a POLLIN event was handled as not
+        // receiving any new connections is valid.
+
+        // No need to check for POLLHUP as it should never occur for a
+        // listen socket.
+    }
+
+    fn check_signalfd_events(
+        &mut self,
+        partition: &PollPartition<'_>,
+    ) -> ServerControl<impl FnOnce()> {
+        // POLLERR and POLLNVAL should never occur for a signalfd.
+        let checked_pollfd = partition.signal.check().unwrap_or_else(|(_, error_events)| {
+            panic!("Received polling error for signalfd: {error_events:?}");
+        });
+
+        checked_pollfd
+            .handle_event(libc::POLLIN, &mut |fd| {
+                sys::call_until_would_block(
+                    || sys::read_exact::<libc::signalfd_siginfo>(fd),
+                    &mut |siginfo: libc::signalfd_siginfo| {
+                        match siginfo.ssi_signo as i32 {
+                            libc::SIGCHLD => {
+                                info!(
+                                    "Received SIGCHLD from PID {} with status {}",
+                                    siginfo.ssi_pid, siginfo.ssi_status
+                                );
+
+                                // Continue reading
+                                Continue
+                            }
+                            libc::SIGINT => {
+                                info!("Received SIGINT FROM PID {}", siginfo.ssi_pid);
+
+                                // Terminate early
+                                Break(libc::SIGINT)
+                            }
+                            libc::SIGTERM => {
+                                info!("Received SIGTERM FROM PID {}", siginfo.ssi_pid);
+
+                                // Terminate early
+                                Break(libc::SIGTERM)
+                            }
+                            signo => {
+                                // This should never happen as only SIGCHLD,
+                                // SIGINT, and SIGTERM are added to the signalfd's
+                                // mask.
+                                panic!("Unhandled signal received: {signo}");
+                            }
+                        }
+                    },
+                )
+                // TODO: Add more extensive error handling.
+                .unwrap()
+            })
+            // The server should exit early iff the handler exited
+            // early due to receiving a SIGINT or SIGTERM.
+            .map_or(ServerControl::<fn()>::Continue, |loop_control| match loop_control {
+                LoopExit::Early(_) => ServerControl::Shutdown,
+                LoopExit::WouldBlock => ServerControl::Continue,
+            })
+    }
+
+    fn dispatch_message_handler(
+        &mut self,
+        fd: RawFd,
+        message_buffer: MessageBuffer,
+        parcel: Parcel<'_>,
+    ) -> LoopControl<ClientLoopControl<impl FnOnce()>> {
+        match parcel.message_type() {
+            Message::Exit => self.handle_message_exit(fd),
+            Message::IdentityQuery => self.handle_message_identity_query(fd),
+            msg if msg == self.species.message_type_spawn() => {
+                self.handle_message_spawn(fd, message_buffer)
+            }
+            Message::Stat => self.handle_message_stat(fd),
+            msg @ Message(tag) if tag < Message::ENUM_MAX => {
+                error!("Message not supported by this species: {}", msg.variant_name().unwrap());
+
+                // Continue the `recvmsg` loop
+                Continue
+            }
+            Message(tag) => {
+                error!("Invalid message variant encountered: {tag}");
+
+                // Continue the `recvmsg` loop
+                Continue
+            }
+        }
+    }
+
+    fn handle_message_exit<Thunk: FnOnce()>(
+        &mut self,
+        fd: RawFd,
+    ) -> LoopControl<ClientLoopControl<Thunk>> {
+        info!("Received client: (Exit {})", sys::get_socket_creds(fd).unwrap().pid);
+
+        let ack_msg = messages::AckBuilder {}.build();
+        if let Err(errno) = Self::send_response(fd, ack_msg.finished_data()) {
+            warn!("Failed to acknowledge Exit message: {errno}")
+        }
+
+        Break(ClientLoopControl::Shutdown)
+    }
+
+    fn handle_message_identity_query<Thunk: FnOnce()>(
+        &self,
+        fd: RawFd,
+    ) -> LoopControl<ClientLoopControl<Thunk>> {
+        info!("Received client: (IdentityQuery {})", sys::get_socket_creds(fd).unwrap().pid);
+
+        let response = messages::IdentityQueryResponseBuilder {
+            name: &self.name,
+            species: self.species.name(),
+            arch: std::env::consts::ARCH,
+        }
+        .build();
+
+        match Self::send_response(fd, response.finished_data()) {
+            Ok(_) => Continue,
+            Err(errno) => {
+                error!("Failed to send IdentityQuery response: {errno}");
+                Break(ClientLoopControl::Error(fd, errno))
+            }
+        }
+    }
+
+    fn handle_message_spawn(
+        &mut self,
+        fd: RawFd,
+        message_buffer: MessageBuffer,
+    ) -> LoopControl<ClientLoopControl<impl FnOnce() + use<>>> {
+        // The server does not spawn any threads.  Preloaded library
+        // initializers should not start any threads.  Any threads created by
+        // species-specific code during initialization must be terminated when
+        // control is returned to the process-server.
+        debug_assert_single_threaded();
+        debug_assert_ok!(self.registry.audit());
+
+        let parcel = flatbuffers::root::<Parcel>(&message_buffer).unwrap();
+        info!("Received message: ({:?})", parcel.message_type());
+
+        #[cfg(target_os = "android")]
+        // SAFETY: This is called in a single-threaded context
+        let fds_error_level = unsafe { sys::android::fdsan_get_error_level() };
+
+        // SAFETY: This is called in a single-threaded context.
+        //
+        //         The `fork()` function can produce the following errors:
+        //         EAGAIN, ENOMEM, ENOSYS, ERESTARTNOINTR.
+        //
+        //         The Zygote can not recover from EAGAIN or ENOMEM.  ENOSYS
+        //         will not trigger as the Zygote is designed for systems that
+        //         provide `fork()`.  ERESTARTNOINTR will not trigger during
+        //         normal operations as signals are handled via a signalfd and
+        //         not asynchronous signal handlers.
+        let new_pid = unsafe { sys::fork() }.unwrap();
+
+        if new_pid == 0 {
+            // Child process
+
+            if let Some(priority) = self.priority_initial {
+                if sys::setpriority(libc::PRIO_PROCESS, 0, priority).is_err() {
+                    // EINVAL, EPERM, and ESRCH only apply when setting the
+                    // priority of other processes.
+                    warn!("Insufficient permissions to set priority: {}", priority);
+                }
+            }
+
+            // SAFETY: The contents of this message were received from a bound
+            //         UNIX Domain socket.  Processes with permission to read
+            //         and write to this socket are considered authorized to
+            //         spawn processes from this server.
+            //
+            //         The message data will only be read in the child process
+            //         once the server and configuration structs are dropped.
+            //         This ensures that all file descriptor registry actions
+            //         are taken before control is passed to the species code.
+            let spawn_message = unsafe { messages::SpawnMessage::new(message_buffer) };
+
+            // Creating these local copies avoids capturing additional
+            // references.
+
+            let species: SpeciesRef = self.species;
+            let priority_final = self.priority_final;
+
+            Break(ClientLoopControl::Child(move || {
+                debug_assert_single_threaded();
+
+                #[cfg(target_os = "android")]
+                {
+                    sys::android::reset_stack_guards();
+
+                    // SAFETY: This is called in a single-threaded context
+                    unsafe {
+                        sys::android::fdsan_set_error_level(fds_error_level);
+                    }
+
+                    if sys::android::set_zygote_child().is_err() {
+                        error!("Failed to android_mallopt(M_SET_ZYGOTE_CHILD)");
+                    }
+
+                    if let Err(errno) = sys::mallopt(libc::M_DECAY_TIME, 1) {
+                        error!("Failed to mallopt(M_DECAY_TIME): {}", errno);
+                    }
+                }
+
+                species.gestate(spawn_message, priority_final)
+            }))
+        } else {
+            // Server process
+            info!("Spawned process {}", new_pid);
+            let response = messages::SpawnResponseBuilder { pid: new_pid }.build();
+            match Self::send_response(fd, response.finished_data()) {
+                Ok(_) => Continue,
+                Err(errno) => {
+                    error!("Failed to send Spawn response: {}", errno);
+                    Break(ClientLoopControl::Error(fd, errno))
+                }
+            }
+        }
+    }
+
+    fn handle_message_stat<Thunk: FnOnce()>(
+        &mut self,
+        fd: RawFd,
+    ) -> LoopControl<ClientLoopControl<Thunk>> {
+        info!("Received client: (Stat)");
+
+        let ack_msg = messages::AckBuilder {}.build();
+        match Self::send_response(fd, ack_msg.finished_data()) {
+            Ok(_) => {
+                // Continue the `recvmsg` loop
+                Continue
+            }
+            Err(errno) => {
+                error!("Failed to send Stat response: {}", errno);
+                Break(ClientLoopControl::Error(fd, errno))
+            }
+        }
+    }
+
+    fn preload<T: AsRef<OsStr>>(&self, libraries: &Vec<T>) {
+        let _eid_context = sys::EffectiveIdContext::enter(self.preload_uid, self.preload_gid)
+            .unwrap_or_else(|errno| {
+                error!(
+                    "Failed to set effective UID/GID ({:?}/{:?}): {}",
+                    self.preload_uid, self.preload_gid, errno
+                );
+                std::process::exit(1);
+            });
+
+        for library_path in libraries {
+            // SAFETY: The Zygote process-server is designed to load and
+            //         execute code from shared libraries.  If a Zygote process
+            //         is launched with permissions to access these files and
+            //         the user has specified them in the preload set then the
+            //         user acknowledges that the object will be loaded, static
+            //         initializers will be called, and the contained functions
+            //         may be called.
+            let dlopen_result =
+                unsafe { Library::open(Some(library_path), RTLD_GLOBAL | RTLD_NOW) };
+
+            match dlopen_result {
+                Ok(library) => {
+                    info!("Preloaded library SUCCESS: {:?}", library_path.as_ref());
+
+                    // Extract to contained handle to prevent the library from
+                    // being closed as we exit the current scope.
+                    let _ = library.into_raw();
+                }
+                Err(err) => {
+                    error!("Preload library FAILURE: {:?} : {}", library_path.as_ref(), err);
+                }
+            };
+        }
+    }
+
+    fn remove_client_socket(&mut self, fd: RawFd) {
+        self.registry.remove(fd).unwrap();
+        self.client_sockets
+            .remove(self.client_sockets.iter().position(|&search_fd| search_fd == fd).unwrap());
+        // Silently ignore EBADF and EIO.
+        let _ = sys::close(fd);
+    }
+
+    /// Send the provided response to on the file descriptor and panic on
+    /// errors that indicate an irrecoverable bug.
+    ///
+    /// The following errors will cause a panic:
+    /// * [`libc::EACCES`]
+    /// * [`libc::EALREADY`]
+    /// * [`libc::EBADF`]
+    /// * [`libc::EDESTADDRREQ`]
+    /// * [`libc::EFAULT`]
+    /// * [`libc::EINVAL`]
+    /// * [`libc::EISCONN`]
+    /// * [`libc::EMSGSIZE`]
+    /// * [`libc::ENOBUFS`]
+    /// * [`libc::ENOMEM`]
+    /// * [`libc::ENOTCONN`]
+    /// * [`libc::ENOTSOCK`]
+    /// * [`libc::EOPNOTSUPP`]
+    /// * [`libc::EPIPE`]
+    ///
+    /// The following errors will be returned to the caller:
+    /// * [`libc::EAGAIN`]
+    /// * [`libc::EWOULDBLOCK`]
+    /// * [`libc::ECONNRESET`]
+    fn send_response(fd: RawFd, buffer: &[u8]) -> LibcResult<()> {
+        match sys::sendmsg(fd, buffer) {
+            Ok(_) => Ok(()),
+            Err(errno) if errno.matches(&[libc::EAGAIN | libc::EWOULDBLOCK | libc::ECONNRESET]) => {
+                Err(errno)
+            }
+            Err(errno) => panic!("Unexpected error when sending response on fd {fd}: {errno}"),
+        }
+    }
+
+    /// Execute the main server loop until the server receives a SIGTERM or
+    /// [`crate::messages::Exit`] message.
+    ///
+    /// The child process thunk is returned to allow the caller to drop the
+    /// server before control flow is transferred to the species-specific
+    /// code.  This allows resources to be cleaned up and possibly sensitive
+    /// data to be deallocated.
+    pub fn serve(&mut self) -> Option<impl FnOnce()> {
+        loop {
+            let mut poll_array = PollBuffer::from(&mut *self);
+
+            // Discard the number of ready file descriptors for now.
+            sys::poll(&mut poll_array, -1).unwrap();
+
+            match self.check_poll_events(poll_array.partition()) {
+                ServerControl::Continue => {}
+                ServerControl::Shutdown => {
+                    return None;
+                }
+                ServerControl::Trampoline(thunk) => {
+                    return Some(thunk);
+                }
+            }
+        }
+    }
+}
+
+impl Drop for Server {
+    fn drop(&mut self) {
+        if self.pid == sys::getpid() {
+            // Clean up the server code in the server process
+            self.registry.override_and_close();
+
+            if let Some(path) = &self.server_socket_path {
+                std::fs::remove_file(path).unwrap();
+            }
+        } else {
+            // Clean up the server code in the child process
+            self.registry.execute_actions();
+        }
+    }
+}
diff --git a/zygote/src/species.rs b/zygote/src/species.rs
new file mode 100644
index 0000000..b449a61
--- /dev/null
+++ b/zygote/src/species.rs
@@ -0,0 +1,125 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! "Species" are an abstraction over the preloaded resources, process
+//! creation details, and control flow transfer mechanism utilized by different
+//! clients of the Zygote process server architecture.
+
+use core::ffi::CStr;
+use std::str::FromStr;
+
+use crate::messages;
+
+pub mod android_native;
+pub mod lib_app;
+#[cfg(any(test, feature = "test"))]
+pub mod mock;
+
+/// An entry structure for file allow lists.  This is marked as test-only
+/// because the only current user is the mock testing class.
+#[cfg(any(test, feature = "test"))]
+pub(crate) struct FileAllowListEntry {
+    data: &'static CStr,
+
+    // TODO: Ensure that this data is erased from the final binary
+    _reviewer: &'static str,
+    _reviewed: &'static str,
+}
+
+/// A constructor for [`FileAllowListEntry`] structs
+#[cfg(any(test, feature = "test"))]
+pub(crate) const fn file_entry(
+    data: &'static CStr,
+    _reviewer: &'static str,
+    _reviewed: &'static str,
+) -> FileAllowListEntry {
+    FileAllowListEntry { data, _reviewer, _reviewed }
+}
+
+/// An entry structure for socket allow lists.  This is marked as test-only
+/// because the only current user is the mock testing class.
+#[cfg(any(test, feature = "test"))]
+pub(crate) struct SocketAllowListEntry {
+    data: &'static str,
+
+    // TODO: Ensure that this data is erased from the final binary
+    _reviewer: &'static str,
+    _reviewed: &'static str,
+}
+
+/// A constructor for [`SocketAllowListEntry`] structs.
+#[cfg(any(test, feature = "test"))]
+pub(crate) const fn socket_entry(
+    data: &'static str,
+    _reviewer: &'static str,
+    _reviewed: &'static str,
+) -> SocketAllowListEntry {
+    SocketAllowListEntry { data, _reviewer, _reviewed }
+}
+
+/// A reference type for a statically allocated Species VTable.
+pub type SpeciesRef = &'static (dyn Species + Sync);
+
+/// All production species.
+#[cfg(not(any(test, feature = "test")))]
+const SPECIES_LIST: &[SpeciesRef] = &[&android_native::App, &lib_app::App];
+
+/// All production and test species.
+#[cfg(any(test, feature = "test"))]
+const SPECIES_LIST: &[SpeciesRef] = &[&android_native::App, &lib_app::App, &mock::Turtle];
+
+/// A collection of callbacks implemented by Zygote payloads that determine
+/// runtime behaviors such as preloading, process creation, and transfer
+/// of control flow.
+pub trait Species {
+    /// Returns true if an abstract socket name is allowed to be registered
+    fn abstract_socket_is_allowed(&self, name: &str) -> bool;
+    /// Returns true if a bound socket path is allowed to be registered
+    fn bound_socket_is_allowed(&self, name: &str) -> bool;
+    /// Return the [`messages::Command`] tag corresponding to this
+    /// species' Spawn command
+    fn message_type_spawn(&self) -> messages::Message;
+    /// Returns the name of the species
+    fn name(&self) -> &'static str;
+    /// Returns true if the file is allowed to be registered
+    fn file_is_allowed(&self, path: &CStr) -> bool;
+    /// Take over control flow for the new process
+    fn gestate(&self, spawn_message: messages::SpawnMessage, priority_final: Option<i32>) -> !;
+    /// Returns the default action for a given file path
+    fn get_file_action(&self, path: &CStr) -> Option<crate::file_descriptors::Action>;
+
+    // Helper functions
+
+    /// A simple test to check of a provided path string is absolute or not.
+    fn path_is_absolute(&self, path_str: &str) -> bool {
+        path_str.starts_with("/") && !path_str.contains("/../")
+    }
+}
+
+impl FromStr for SpeciesRef {
+    type Err = String;
+
+    /// Iterates through [`SPECIES_LIST`] to find a reference to a species with
+    /// the provided name.
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        for species in SPECIES_LIST {
+            if species.name() == s {
+                return Ok(*species);
+            }
+        }
+
+        Err(format!("No species defined with name '{}'", s))
+    }
+}
diff --git a/zygote/src/species/android_native.rs b/zygote/src/species/android_native.rs
new file mode 100644
index 0000000..828dac4
--- /dev/null
+++ b/zygote/src/species/android_native.rs
@@ -0,0 +1,60 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Implementation of the Species trait for Android Native Applications.
+
+use core::ffi::CStr;
+
+use crate::{
+    file_descriptors::Action,
+    messages::{self, Message},
+    species::Species,
+};
+
+/// Behaviors for launching native Android applications.
+pub struct App;
+
+impl Species for App {
+    fn abstract_socket_is_allowed(&self, _name: &str) -> bool {
+        false
+    }
+
+    fn bound_socket_is_allowed(&self, _path: &str) -> bool {
+        false
+    }
+
+    fn message_type_spawn(&self) -> Message {
+        Message::SpawnAndroidNative
+    }
+
+    fn name(&self) -> &'static str {
+        "android-native-app"
+    }
+
+    fn file_is_allowed(&self, _path: &CStr) -> bool {
+        false
+    }
+
+    fn gestate(&self, spawn_message: messages::SpawnMessage, _priority_final: Option<i32>) -> ! {
+        let parcel = flatbuffers::root::<messages::Parcel>(spawn_message.as_ref()).unwrap();
+        let spawn_cmd = parcel.message_as_spawn_android_native().unwrap();
+        println!("Hello from the child process.  My name is {}", spawn_cmd.package());
+        std::process::exit(0)
+    }
+
+    fn get_file_action(&self, _path: &CStr) -> Option<Action> {
+        None
+    }
+}
diff --git a/zygote/src/species/lib_app.rs b/zygote/src/species/lib_app.rs
new file mode 100644
index 0000000..612aaa5
--- /dev/null
+++ b/zygote/src/species/lib_app.rs
@@ -0,0 +1,112 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Implementation of the Species trait for LibApp.  This species will locate,
+//! load, and enter a shared library that correctly define the `zygote_entry`
+//! function.
+
+use core::ffi::CStr;
+
+use libloading::os::unix::{Library, Symbol, RTLD_GLOBAL, RTLD_NOW};
+use log::{error, info, warn};
+
+use crate::{
+    file_descriptors::Action,
+    messages::{self, Message},
+    species::Species,
+    sys,
+};
+
+/// Name of the entry symbol for LibApps
+const LIBAPP_ENTRY_SYMBOL_NAME: &CStr = c"zygote_entry";
+
+/// Behaviors for launching native Android applications.
+pub struct App;
+
+impl Species for App {
+    fn abstract_socket_is_allowed(&self, _name: &str) -> bool {
+        false
+    }
+
+    fn bound_socket_is_allowed(&self, _path: &str) -> bool {
+        false
+    }
+
+    fn message_type_spawn(&self) -> Message {
+        Message::SpawnLibApp
+    }
+
+    fn name(&self) -> &'static str {
+        "lib-app"
+    }
+
+    fn file_is_allowed(&self, _path: &CStr) -> bool {
+        false
+    }
+
+    fn gestate(&self, spawn_message: messages::SpawnMessage, priority_final: Option<i32>) -> ! {
+        let parcel = flatbuffers::root::<messages::Parcel>(spawn_message.as_ref()).unwrap();
+        let spawn_cmd = parcel.message_as_spawn_lib_app().unwrap();
+
+        let library_path_str = spawn_cmd.path();
+        let library_path = std::path::Path::new(library_path_str);
+
+        let library_args = spawn_cmd.args().iter().map(|arg| arg.to_owned()).collect();
+
+        if !library_path.exists() {
+            error!("No library found at the specified path: {}", spawn_cmd.path());
+            std::process::exit(1);
+        }
+
+        info!("Path to library application: {}", spawn_cmd.path());
+
+        // SAFETY: The library path is obtained from the SpawnMessage which
+        //         originates from a trusted source.  The path has been
+        //         verified to exist and the result of the `dlopen()` call is
+        //         checked.
+        let library = unsafe { Library::open(Some(library_path), RTLD_NOW | RTLD_GLOBAL) }
+            .unwrap_or_else(|err| {
+                error!("Failure to load shared library ({:?}): {}", library_path, err);
+                std::process::exit(1);
+            });
+
+        info!("Successfully loaded shared library");
+        let entry_function: Symbol<unsafe fn(Vec<String>) -> i32> =
+            // SAFETY: The symbol name is part of the API for LibApps.
+            unsafe { library.get(LIBAPP_ENTRY_SYMBOL_NAME.to_bytes()) }.unwrap_or_else(|err| {
+                error!("Symbol `zygote_entry` not found in shared library: {}", err);
+                std::process::exit(1);
+            });
+
+        if let Some(priority) = priority_final {
+            if sys::setpriority(libc::PRIO_PROCESS, 0, priority).is_err() {
+                // EINVAL, EPERM, and ESRCH only apply when setting the
+                // priority of other processes.
+                warn!("Insufficient permissions to set priority: {}", priority);
+            }
+        }
+
+        // SAFETY: The function signature is part of the API for LibApps.  An
+        //         improper signature will result in undefined behavior.  From
+        //         this point forward the library may execute arbitrary code.
+        unsafe {
+            std::process::exit(entry_function(library_args));
+        }
+    }
+
+    fn get_file_action(&self, _path: &CStr) -> Option<Action> {
+        None
+    }
+}
diff --git a/zygote/src/species/mock.rs b/zygote/src/species/mock.rs
new file mode 100644
index 0000000..a6324c7
--- /dev/null
+++ b/zygote/src/species/mock.rs
@@ -0,0 +1,77 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! A mock species implementation used for testing.
+
+use core::ffi::CStr;
+
+use crate::{
+    file_descriptors::Action,
+    messages::{self, Message},
+    species::{file_entry, socket_entry, FileAllowListEntry, SocketAllowListEntry, Species},
+};
+
+#[rustfmt::skip]
+static ALLOWED_FILE_PATHS: [FileAllowListEntry; 1] = [
+    file_entry(crate::test::MOCK_FILE_PATH_1, "testname", "2025-02-19"),
+];
+
+#[rustfmt::skip]
+static ALLOWED_SOCKET_NAMES: [SocketAllowListEntry; 1] = [
+    socket_entry(crate::test::SOCKET_NAME_1, "testname", "2025-02-19"),
+];
+
+#[rustfmt::skip]
+static ALLOWED_SOCKET_PATHS: [SocketAllowListEntry; 1] = [
+    socket_entry(crate::test::SOCKET_PATH_1, "testname", "2025-02-19"),
+];
+
+/// Behaviors for testing the Zygote process server.
+///
+/// See: https://en.wikipedia.org/wiki/Mock_Turtle
+pub struct Turtle;
+
+impl Species for Turtle {
+    fn abstract_socket_is_allowed(&self, name: &str) -> bool {
+        ALLOWED_SOCKET_NAMES.iter().any(|entry| entry.data == name)
+    }
+
+    fn bound_socket_is_allowed(&self, path: &str) -> bool {
+        ALLOWED_SOCKET_PATHS.iter().any(|entry| entry.data == path)
+    }
+
+    fn message_type_spawn(&self) -> Message {
+        Message::SpawnMock
+    }
+
+    fn name(&self) -> &'static str {
+        "mock"
+    }
+
+    fn file_is_allowed(&self, path_str: &CStr) -> bool {
+        ALLOWED_FILE_PATHS.iter().any(|entry| entry.data == path_str)
+    }
+
+    fn gestate(&self, spawn_message: messages::SpawnMessage, _priority_final: Option<i32>) -> ! {
+        let parcel = flatbuffers::root::<messages::Parcel>(spawn_message.as_ref()).unwrap();
+        let spawn_cmd = parcel.message_as_spawn_mock().unwrap();
+        println!("Hello from the child process.  My name is {}", spawn_cmd.name());
+        std::process::exit(0)
+    }
+
+    fn get_file_action(&self, _path: &CStr) -> Option<Action> {
+        None
+    }
+}
diff --git a/zygote/src/sys.rs b/zygote/src/sys.rs
new file mode 100644
index 0000000..948a9b8
--- /dev/null
+++ b/zygote/src/sys.rs
@@ -0,0 +1,1263 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This module provides safe wrappers around unsafe libc calls.
+
+use core::{
+    ffi::{c_char, c_int, c_short, c_void, CStr},
+    mem::{self, offset_of},
+};
+use std::{
+    fmt::{self, Debug, Display, Formatter},
+    mem::MaybeUninit,
+    os::fd::RawFd,
+    ptr::NonNull,
+};
+
+use anyhow::Result;
+use static_assertions::const_assert;
+use zerocopy::FromBytes;
+
+#[cfg(target_os = "android")]
+use crate::libc_fill;
+
+/// Platform-dependent type alias for use with [`libc::getpriority`] and
+/// [`libc::setpriority`].
+#[allow(non_camel_case_types)]
+#[cfg(not(any(target_os = "android", target_env = "musl")))]
+pub type which_t = core::ffi::c_uint;
+
+/// Platform-dependent type alias for use with [`libc::getpriority`] and
+/// [`libc::setpriority`].
+#[allow(non_camel_case_types)]
+#[cfg(any(target_os = "android", target_env = "musl"))]
+pub type which_t = c_int;
+
+/// Number of bytes to allocate for string buffers.  The value 512 was selected
+/// because it was large enough to fit all strings that were observed during
+/// testing.  Testing should be performed to see if a smaller value can be
+/// used.
+pub const BUFFER_SIZE_STRINGS: usize = 512;
+const_assert!(
+    BUFFER_SIZE_STRINGS
+        >= std::mem::size_of::<libc::sockaddr_un>() - offset_of!(libc::sockaddr_un, sun_path)
+);
+
+// TODO: Consider making this an ArrayVec
+/// Buffers used for static string allocations
+pub type CStringBuffer = [u8; BUFFER_SIZE_STRINGS];
+const BUFFER_INIT_CSTRING: CStringBuffer = [0u8; BUFFER_SIZE_STRINGS];
+
+/// Helper trait for converting types into `CStr`s
+pub trait AsCStr {
+    /// Create a CStr object referencing this character buffer
+    fn as_cstr(&self) -> Result<&CStr>;
+}
+
+impl<const N: usize> AsCStr for [u8; N] {
+    fn as_cstr(&self) -> Result<&CStr> {
+        Ok(CStr::from_bytes_until_nul(self)?)
+    }
+}
+
+impl AsCStr for &[u8] {
+    fn as_cstr(&self) -> Result<&CStr> {
+        Ok(CStr::from_bytes_until_nul(self)?)
+    }
+}
+
+/// Wrapper struct for UNIX-like error numbers
+#[derive(Eq, PartialEq)]
+pub struct Errno {
+    code: c_int,
+}
+
+impl Errno {
+    /// Test equality with a libc error number
+    pub fn is(&self, query_code: c_int) -> bool {
+        self.code == query_code
+    }
+
+    /// Test if the wrapped code matches any of the provided error numbers
+    pub fn matches<const N: usize>(&self, query_codes: &[c_int; N]) -> bool {
+        query_codes.iter().any(|&query_code| self.code == query_code)
+    }
+}
+
+impl From<Errno> for std::fmt::Error {
+    fn from(_: Errno) -> std::fmt::Error {
+        std::fmt::Error
+    }
+}
+
+impl Display for Errno {
+    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), fmt::Error> {
+        write!(f, "Errno: {:?}", strerror(self.code)?.as_cstr())
+    }
+}
+
+impl Debug for Errno {
+    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), fmt::Error> {
+        f.debug_struct("Errno").field("code", &strerror(self.code)?.as_cstr()).finish()
+    }
+}
+
+impl std::error::Error for Errno {}
+
+/// Obtain the location of the `errno` variable from `libc` and dereference it
+pub(crate) fn errno() -> Errno {
+    Errno {
+        #[cfg(not(target_os = "android"))]
+        // SAFETY: Reads from the thread's errno address should never fail
+        code: unsafe { *libc::__errno_location() },
+
+        #[cfg(target_os = "android")]
+        // SAFETY: Reads from the thread's errno address should never fail
+        code: unsafe { *libc::__errno() },
+    }
+}
+
+/// Write 0 to the `errno` `libc` global
+fn errno_clear() {
+    #[cfg(not(target_os = "android"))]
+    // SAFETY: Writes to the thread's errno address should never fail
+    unsafe {
+        *libc::__errno_location() = 0
+    }
+
+    #[cfg(target_os = "android")]
+    // SAFETY: Writes to the thread's errno address should never fail
+    unsafe {
+        *libc::__errno() = 0
+    }
+}
+
+/// A Result type that uses Errno for the Error type
+pub type LibcResult<T> = std::result::Result<T, Errno>;
+
+/// A wrapper struct for [`libc::pollfd`] that ensures error codes are checked
+/// before events are handled.
+#[repr(transparent)]
+pub struct PollFd(libc::pollfd);
+
+impl PollFd {
+    /// Initialize a new [`libc::pollfd`] wrapper struct with the provided file
+    /// descriptor and events.
+    pub fn new(fd: RawFd, events: c_short) -> Self {
+        Self(libc::pollfd { fd, events, revents: 0 })
+    }
+
+    /// Returns `Err` in the presence of errors, else `Some(PollFdChecked)`.
+    pub fn check(&self) -> Result<PollFdChecked<'_>, (RawFd, c_short)> {
+        const ERROR_MASK: c_short = libc::POLLERR | libc::POLLNVAL;
+        if self.0.revents & ERROR_MASK != 0 {
+            Err((self.0.fd, self.0.revents & ERROR_MASK))
+        } else {
+            Ok(PollFdChecked(&self.0))
+        }
+    }
+}
+
+/// A struct used to wrap a [`libc::pollfd`] struct that has been checked for
+/// errors.
+#[repr(transparent)]
+pub struct PollFdChecked<'a>(&'a libc::pollfd);
+
+impl PollFdChecked<'_> {
+    /// If the specified event occurred the result of calling the handler will
+    /// be returned; otherwise, None.
+    pub fn handle_event<T>(
+        &self,
+        event: c_short,
+        mut handler: impl FnMut(RawFd) -> T,
+    ) -> Option<T> {
+        if self.0.revents & event == event {
+            Some(handler(self.0.fd))
+        } else {
+            None
+        }
+    }
+}
+
+// TODO: Consider adding [`closedir`] as a destructor.
+/// Wrapper class for a `libc::DIR` pointer
+pub struct LibcDir {
+    inner: NonNull<libc::DIR>,
+}
+
+/// Helper functions for LibcDir.
+impl LibcDir {
+    /// Module-private constructor for [`LibcDir`]
+    fn from_raw(inner: NonNull<libc::DIR>) -> Self {
+        Self { inner }
+    }
+}
+
+/// Types for which any bit pattern is valid
+///
+/// # Safety
+/// Any type this is implemented for must accept all bit patterns.
+pub unsafe trait LibcFromBytes {}
+
+macro_rules! from_bytes_c {
+    ($($t:ty),*) => {
+        $(
+        // SAFETY: This is a C-origin type, all values are legal.
+        unsafe impl LibcFromBytes for $t {}
+        )*
+    }
+}
+
+from_bytes_c!(libc::ucred, libc::signalfd_siginfo);
+
+// SAFETY: Passing raw byte arrays to `libc` calls is safe.  This leaves the
+//         safety of casting to and from bytes up to the caller.
+unsafe impl<const N: usize> LibcFromBytes for [u8; N] {}
+
+/// Convert an integer return value from a `libc` call into a [`LibcResult`]
+/// type.  If the return value is -1 the Error type will contain the resulting
+/// `errno` value.
+fn libc_result_from_int<T: Eq + From<i8>>(retval: T) -> LibcResult<T> {
+    if retval == T::from(-1) {
+        Err(errno())
+    } else {
+        Ok(retval)
+    }
+}
+
+/// Test an integer `libc` return value and returns the auxiliary value if
+/// is not equal to -1 and the `errno` value if it is.  The payload thunk is
+/// only evaluated when `retval` does not indicate an error.
+fn libc_result_from_int_with_payload<T: Eq + From<i8>, P>(
+    retval: T,
+    payload: impl FnOnce() -> P,
+) -> LibcResult<P> {
+    if retval == T::from(-1) {
+        Err(errno())
+    } else {
+        Ok(payload())
+    }
+}
+
+/// Test an integer `libc` return value and return `void` if it is not equal to
+/// -1 and the `errno` value if it is.
+fn libc_result_from_int_with_void<T: Eq + From<i8>>(retval: T) -> LibcResult<()> {
+    if retval == T::from(-1) {
+        Err(errno())
+    } else {
+        Ok(())
+    }
+}
+
+/// Converts a pointer into a [`LibcResult`] type, returning an [`Errno`] if it
+/// is `null` and converting it into the desired return type if it isn't.
+fn libc_result_from_ptr<T, U, C: Fn(NonNull<T>) -> U>(
+    retval: *mut T,
+    constructor: C,
+) -> LibcResult<U> {
+    NonNull::new(retval).map(constructor).ok_or(errno())
+}
+
+/*
+ * Libc helpers
+ */
+
+/// A macro for retrying libc calls that result in an EINTR errno.
+macro_rules! retry_eintr {
+    ($libc_call:expr) => {
+        loop {
+            match $libc_call {
+                Err(errno) if errno.is(libc::EINTR) => {
+                    continue;
+                }
+                result => {
+                    break result;
+                }
+            }
+        }
+    };
+}
+
+/// Construct an abstract socket name inside a [`libc::sockaddr_un`] struct
+/// from the provided name and family.
+pub fn abstract_socket_address(name: &str, family: libc::sa_family_t) -> libc::sockaddr_un {
+    let mut socket_addr = libc::sockaddr_un { sun_family: family, sun_path: [0; 108] };
+    let name_view = &name.as_bytes()[0..std::cmp::min(name.len(), socket_addr.sun_path.len() - 1)];
+
+    // Abstract socket names begin with a null character, so start copying the
+    // name at index 1.
+    socket_addr.sun_path[1..name_view.len() + 1]
+        .copy_from_slice(<[c_char]>::ref_from_bytes(name_view).unwrap());
+
+    socket_addr
+}
+
+/// Construct a bound socket name inside a [`libc::sockaddr_un`] struct from
+/// the provided name and family.
+pub fn bound_socket_address(path: &str, family: libc::sa_family_t) -> libc::sockaddr_un {
+    let mut socket_addr = libc::sockaddr_un { sun_family: family, sun_path: [0; 108] };
+    let name_view = &path.as_bytes()[0..std::cmp::min(path.len(), socket_addr.sun_path.len() - 1)];
+
+    socket_addr.sun_path[0..name_view.len()]
+        .copy_from_slice(<[c_char]>::ref_from_bytes(name_view).unwrap());
+
+    socket_addr
+}
+
+/// Construct a [`libc::sigset_t`] containing the provided signals.
+pub fn build_sigset(signals: &[c_int]) -> LibcResult<libc::sigset_t> {
+    let mut sigset = sigemptyset()?;
+
+    for signum in signals {
+        sigaddset(&mut sigset, *signum)?;
+    }
+
+    Ok(sigset)
+}
+
+/// Type for specifying control flow in [`call_until_would_block`]
+pub enum LoopControl<T> {
+    /// Tell [`call_until_would_block`] to execute the action again.
+    Continue,
+    /// Tell [`call_until_would_block`] to exit the loop and return the
+    /// provided value.
+    Break(T),
+}
+
+/// Type for indicating the exit conditions for [`call_until_would_block`]
+pub enum LoopExit<T> {
+    /// Indicate that the loop exited early with the provided value
+    Early(T),
+    /// Indicate that the loop exited because the action would have blocked.
+    WouldBlock,
+}
+
+impl<T> LoopExit<T> {
+    /// Return true if `self` is [`LoopExit::Early`].
+    pub fn exited_early(&self) -> bool {
+        match self {
+            Self::WouldBlock => false,
+            Self::Early(_) => true,
+        }
+    }
+
+    /// Return true if `self` is [`Loop::WouldBLock`]
+    pub fn would_block(&self) -> bool {
+        match self {
+            Self::WouldBlock => true,
+            Self::Early(_) => false,
+        }
+    }
+}
+
+/// This function calls the `task()` thunk and checks the LibcResult.  If the
+/// thunk exited with either `EAGAIN` or `EWOULDBLOCK` the function will
+/// immediately return a [`LoopExit::WouldBlock`] value.  If any other error
+/// was returned by the thunk it will be returned by this function.  If the
+/// thunk completed successfully the handler will be called and, based on the
+/// return value, the function will either return or continue.  If the function
+/// returns early the [`LoopStatus::Break`] value will be forwarded in a
+/// [`LoopExit::Early`] variant.
+pub fn call_until_would_block<T, U>(
+    task: impl Fn() -> LibcResult<T>,
+    mut handler: impl FnMut(T) -> LoopControl<U>,
+) -> LibcResult<LoopExit<U>> {
+    loop {
+        match task() {
+            Ok(result) => match handler(result) {
+                LoopControl::Continue => continue,
+                LoopControl::Break(val) => return Ok(LoopExit::Early(val)),
+            },
+            Err(errno) if errno.is(libc::EAGAIN) || errno.is(libc::EWOULDBLOCK) => {
+                // Task would block
+                return Ok(LoopExit::WouldBlock);
+            }
+            Err(errno) => {
+                return Err(errno);
+            }
+        }
+    }
+}
+
+/// Create a new UNIX domain datagram abstract socket with the provided name
+pub fn create_abstract_socket(name: &str, protocol: c_int) -> Result<RawFd> {
+    let socket_fd = socket(libc::AF_UNIX, protocol, 0)?;
+    let socket_addr = abstract_socket_address(name, libc::AF_UNIX as libc::sa_family_t);
+
+    bind(socket_fd, &socket_addr)?;
+
+    Ok(socket_fd)
+}
+
+/// Create a new UNIX domain datagram socket and bind it to the provided file
+/// system path
+pub fn create_bound_socket(path: &str, protocol: c_int) -> Result<RawFd> {
+    let socket_fd = socket(libc::AF_UNIX, protocol, 0)?;
+    let socket_addr = bound_socket_address(path, libc::AF_UNIX as libc::sa_family_t);
+
+    bind(socket_fd, &socket_addr)?;
+
+    Ok(socket_fd)
+}
+
+/// Select the file-type bits from the `mode` value
+pub fn get_file_type(stat: libc::stat) -> libc::mode_t {
+    (stat.st_mode as libc::mode_t) & libc::S_IFMT
+}
+
+/// Get the PID, UID, and GID for the remote end of a UNIX domain socket.
+pub fn get_socket_creds(fd: RawFd) -> LibcResult<libc::ucred> {
+    getsockopt(fd, libc::SOL_SOCKET, libc::SO_PEERCRED)
+}
+
+/// Attempt to read `size_of::<T>()` bytes.  If the correct number of bytes
+/// were read the function returns `Ok(T)`, otherwise an `Err(Errno)` is
+/// returned with the `code` set to 0.
+pub fn read_exact<T: LibcFromBytes>(fd: RawFd) -> LibcResult<T> {
+    read::<T>(fd).and_then(|(read_len, result)| {
+        if read_len == std::mem::size_of::<T>() as isize {
+            Ok(result)
+        } else {
+            Err(Errno { code: 0 })
+        }
+    })
+}
+
+pub(crate) struct EffectiveIdContext {
+    ruid: libc::uid_t,
+    rgid: libc::gid_t,
+
+    euid: Option<libc::uid_t>,
+    egid: Option<libc::gid_t>,
+}
+
+impl EffectiveIdContext {
+    pub fn enter(
+        euid: Option<libc::uid_t>,
+        egid: Option<libc::gid_t>,
+    ) -> Result<EffectiveIdContext> {
+        if let Some(euid) = euid {
+            // Pass the bit pattern of twos-complement `-1` as the real UID to
+            // leave it unchanged.
+            setreuid(-1i32 as libc::uid_t, euid)?;
+        }
+
+        if let Some(egid) = egid {
+            // Pass the bit pattern of twos-complement `-1` as the real GID to
+            // leave it unchanged.
+            setregid(-1i32 as libc::gid_t, egid)?;
+        }
+
+        Ok(EffectiveIdContext { ruid: getuid(), rgid: getgid(), euid, egid })
+    }
+
+    pub fn exit(&self) -> Result<()> {
+        if self.euid.is_some() {
+            // Pass the bit pattern of twos-complement `-1` as the real UID to
+            // leave it unchanged.
+            setreuid(-1i32 as libc::uid_t, self.ruid)?;
+        }
+
+        if self.egid.is_some() {
+            // Pass the bit pattern of twos-complement `-1` as the real GID to
+            // leave it unchanged.
+            setregid(-1i32 as libc::gid_t, self.rgid)?;
+        }
+
+        Ok(())
+    }
+}
+
+impl Drop for EffectiveIdContext {
+    fn drop(&mut self) {
+        self.exit().unwrap()
+    }
+}
+
+/*
+ * Libc wrappers
+ */
+
+/// A safe wrapper around [`libc::accept`].
+///
+/// Because we are only interested in UNIX domain sockets, which have no useful
+/// peer address information, we do not pass in a [`libc::sockaddr`] buffer.
+///
+/// See: `man accept`
+pub fn accept(fd: RawFd) -> LibcResult<RawFd> {
+    // SAFETY: If the file descriptor is invalid `accept()` will return -1 and
+    //         we will extract errno and wrap it in a LibcResult.
+    libc_result_from_int(unsafe { libc::accept(fd, std::ptr::null_mut(), std::ptr::null_mut()) })
+}
+
+/// A safe wrapper around [`libc::bind`].
+///
+/// See: `man bind`
+pub fn bind<SockAddrType>(fd: RawFd, sockaddr: &SockAddrType) -> LibcResult<()> {
+    // SAFETY: The pointer argument to `libc::bind` is guaranteed to reference
+    //         allocated memory and the return value is checked and wrapped in
+    //         a LibcResult.
+    libc_result_from_int_with_void(unsafe {
+        libc::bind(
+            fd,
+            (sockaddr as *const SockAddrType) as *const libc::sockaddr,
+            std::mem::size_of::<SockAddrType>() as libc::socklen_t,
+        )
+    })
+}
+
+/// A safe wrapper around [`libc::close`].
+///
+/// The [`libc::EINTR`] signal is handled internally using the [`retry_eintr!`]
+/// macro.
+///
+/// See: `man close`
+pub fn close(fd: RawFd) -> LibcResult<c_int> {
+    // SAFETY: If the file descriptor is invalid `close()` will return -1 and
+    //         we will extract errno and wrap it in a LibcResult.
+    retry_eintr!(libc_result_from_int(unsafe { libc::close(fd) }))
+}
+
+/// A safe wrapper around [`libc::closedir`].
+///
+/// See: `man closedir`
+pub fn closedir(dir: LibcDir) -> LibcResult<()> {
+    // SAFETY: The LibcDir argument can only be constructed by the `opendir`
+    //         function which also checks to ensure that the pointer is
+    //         non-null.  If the LibcDir object *does* contain an invalid
+    //         pointer then `libc` will return `-1` and a LibcResult::Err value
+    //         will be returned wrapping `errno`.
+    libc_result_from_int_with_void(unsafe { libc::closedir(dir.inner.as_ptr()) })
+}
+
+/// A safe wrapper around [`libc::connect`].
+///
+/// See: `man connect`
+pub fn connect<SockAddrType>(fd: RawFd, sockaddr: &SockAddrType) -> LibcResult<()> {
+    // SAFETY: The pointer argument to `libc::connect` is guaranteed to reference
+    //         allocated memory and the return value is checked and wrapped in
+    //         a LibcResult.
+    libc_result_from_int_with_void(unsafe {
+        libc::connect(
+            fd,
+            (sockaddr as *const SockAddrType) as *const libc::sockaddr,
+            std::mem::size_of::<SockAddrType>() as libc::socklen_t,
+        )
+    })
+}
+
+/// A safe wrapper around [`libc::dirfd`].
+///
+/// See: `man dirfd`
+pub fn dirfd(dir: &LibcDir) -> LibcResult<RawFd> {
+    // SAFETY: The LibcDir argument can only be constructed by the `opendir`
+    //         function which also checks to ensure that the pointer is
+    //         non-null.  If the LibcDir object *does* contain an invalid
+    //         pointer then `libc` will return `-1` and a LibcResult::Err value
+    //         will be returned wrapping `errno`.
+    libc_result_from_int(unsafe { libc::dirfd(dir.inner.as_ptr()) })
+}
+
+/// A safe wrapper around [`libc::dup3`].
+///
+/// See: `man dup3`
+pub fn dup3(old_fd: RawFd, new_fd: RawFd, flags: c_int) -> LibcResult<()> {
+    #[cfg(not(target_os = "android"))]
+    // SAFETY: Invalid arguments will result in an error code being returned
+    //         that will be wrapped by a LibcResult.
+    return retry_eintr!(libc_result_from_int_with_void(unsafe {
+        libc::dup3(old_fd, new_fd, flags)
+    }));
+
+    #[cfg(target_os = "android")]
+    // SAFETY: Invalid arguments will result in an error code being returned
+    //         that will be wrapped by a LibcResult.
+    return retry_eintr!(libc_result_from_int_with_void(unsafe {
+        libc_fill::dup3(old_fd, new_fd, flags)
+    }));
+}
+
+/// A safe wrapper around [`libc::fcntl`], passing [`libc::F_GETFD`] as the
+/// `op`.
+///
+/// See: `man fcntl`
+pub fn fcntl_getfd(fd: RawFd) -> LibcResult<c_int> {
+    // SAFETY: An invalid file descriptor will result in an error code being
+    //         returned that will be wrapped by a LibcResult.
+    libc_result_from_int(unsafe { libc::fcntl(fd, libc::F_GETFD) })
+}
+
+/// A safe wrapper around [`libc::fcntl`], passing [`libc::F_GETFL`] as the
+/// `op`.
+///
+/// See: `man fcntl`
+pub fn fcntl_getfl(fd: RawFd) -> LibcResult<c_int> {
+    // SAFETY: An invalid file descriptor will result in an error code being
+    //         returned that will be wrapped by a LibcResult.
+    libc_result_from_int(unsafe { libc::fcntl(fd, libc::F_GETFL) })
+}
+
+/// A safe wrapper around [`libc::fcntl`], passing [`libc::F_SETFD`] as the
+/// `op`.
+///
+/// See: `man fcntl`
+pub fn fcntl_setfd(fd: RawFd, flags: c_int) -> LibcResult<()> {
+    // SAFETY: Invalid arguments will result in an error code being returned
+    //         that will be wrapped by a LibcResult.
+    libc_result_from_int_with_void(unsafe { libc::fcntl(fd, libc::F_SETFD, flags) })
+}
+
+/// A safe wrapper around [`libc::fcntl`], passing [`libc::F_SETFL`] as the
+/// `op`.
+///
+/// See: `man fcntl`
+pub fn fcntl_setfl(fd: RawFd, flags: c_int) -> LibcResult<()> {
+    // SAFETY: Invalid arguments will result in an error code being returned
+    //         that will be wrapped by a LibcResult.
+    libc_result_from_int_with_void(unsafe { libc::fcntl(fd, libc::F_SETFL, flags) })
+}
+
+/// A safe wrapper around [`libc::fork`].
+///
+/// # Safety
+/// This function results in undefined behavior if it is called from a process
+/// with multiple threads.  The calling process *MUST* be single threaded for
+/// calls to this function to be safe.
+///
+/// See: `man fork`
+pub unsafe fn fork() -> LibcResult<libc::pid_t> {
+    // SAFETY: The `libc::fork` function takes no pointers and the return
+    //         value is checked and wrapped in a LibcResult.
+    libc_result_from_int(unsafe { libc::fork() })
+}
+
+/// A safe wrapper around [`libc::fstat`].
+///
+/// See: `man fstat`
+pub fn fstat(fd: RawFd) -> LibcResult<libc::stat> {
+    let mut buffer = MaybeUninit::<libc::stat>::uninit();
+
+    libc_result_from_int_with_payload(
+        // SAFETY: The stat buffer pointer is guaranteed to point to a valid
+        //         memory address due to its allocation inside this function's
+        //         stack.  The return value is checked and wrapped in a
+        //         LibcResult.
+        unsafe { libc::fstat(fd, buffer.as_mut_ptr().cast()) },
+        // SAFETY: The `libc::fstat` function fully initializes the stat
+        //         struct.
+        || unsafe { buffer.assume_init() },
+    )
+}
+
+/// A safe wrapper around [`libc::getegid`].
+///
+/// See: `man getegid`
+pub fn getegid() -> libc::gid_t {
+    // SAFETY: The `libc::getegid` function can not fail.
+    unsafe { libc::getegid() }
+}
+
+/// A safe wrapper around [`libc::geteuid`].
+///
+/// See: `man geteuid`
+pub fn geteuid() -> libc::uid_t {
+    // SAFETY: The `libc::geteuid` function can not fail.
+    unsafe { libc::geteuid() }
+}
+
+/// A safe wrapper around [`libc::getpriority`]
+///
+/// See: `man getpriority`
+pub fn getpriority(which: which_t, who: libc::id_t) -> LibcResult<c_int> {
+    errno_clear();
+
+    // SAFETY: `errno` is cleared before calling the function and checked upon
+    //         return.
+    let result: c_int = unsafe { libc::getpriority(which, who) };
+    if errno().code == 0 {
+        Ok(result)
+    } else {
+        Err(errno())
+    }
+}
+
+/// A safe wrapper around [`libc::getgid`].
+///
+/// See `man getgid`
+pub fn getgid() -> libc::gid_t {
+    // SAFETY: The `libc::getgid` function can not fail.
+    unsafe { libc::getgid() }
+}
+
+/// A safe wrapper around [`libc::getpid`].
+///
+/// See: `man getpid`
+pub fn getpid() -> libc::pid_t {
+    // SAFETY: The `libc::getpid` function can not fail.
+    unsafe { libc::getpid() }
+}
+
+/// A safe wrapper around [`libc::getsockopt`].
+///
+/// See: `man getsockopt`
+pub fn getsockopt<T: LibcFromBytes>(fd: RawFd, level: c_int, optname: c_int) -> LibcResult<T> {
+    let mut optval = MaybeUninit::<T>::zeroed();
+    let mut optlen = std::mem::size_of::<T>() as libc::socklen_t;
+
+    libc_result_from_int_with_payload(
+        // SAFETY: The `optval` and `optlen` arguments are valid pointers to
+        //         memory allocated in this function.  The return value is
+        //         checked and wrapped in a LibcResult.
+        unsafe {
+            libc::getsockopt(
+                fd,
+                level,
+                optname,
+                optval.as_mut_ptr() as *mut libc::c_void,
+                &mut optlen,
+            )
+        },
+        // SAFETY: The call to `libc::getsockopt` will initialize this region.
+        || unsafe { optval.assume_init() },
+    )
+}
+
+/// A safe wrapper around [`libc::getsockname`].
+///
+/// An Errno error with code `0` will be returned if the socket family is not
+/// `AF_UNIX`.
+///
+/// See: `man getsockname`
+pub fn getsockname(fd: RawFd) -> LibcResult<(libc::sockaddr_un, usize)> {
+    let mut addr = std::mem::MaybeUninit::<libc::sockaddr_un>::zeroed();
+    let mut addr_len = std::mem::size_of::<libc::sockaddr_un>() as libc::socklen_t;
+
+    // SAFETY: The address buffer pointer is guaranteed to reference valid
+    //         memory that has been zeroed out.  This ensures that the any
+    //         strings contained in the buffer will be valid null-terminated
+    //         C strings.  The return value is checked and wrapped in a
+    //         LibcResult.
+    libc_result_from_int(unsafe {
+        libc::getsockname(fd, addr.as_mut_ptr().cast(), &mut addr_len)
+    })?;
+
+    debug_assert!(addr_len <= std::mem::size_of::<libc::sockaddr_un>() as libc::socklen_t);
+
+    if addr_len as usize == std::mem::size_of::<libc::sa_family_t>() {
+        return Err(Errno { code: 0 });
+    }
+
+    // SAFETY: The memory had been zero initialized before `libc::getsockname`
+    //         filled in any relevant data.  All strings should be valid C
+    //         strings.
+    let addr = unsafe { addr.assume_init() };
+
+    if addr.sun_family != libc::AF_UNIX as u16 {
+        return Err(Errno { code: 0 });
+    }
+
+    let path_len = addr_len as usize - offset_of!(libc::sockaddr_un, sun_path);
+
+    Ok((addr, path_len))
+}
+
+/// A safe wrapper around [`libc::getuid`].
+///
+/// See: `man getuid`
+pub fn getuid() -> libc::uid_t {
+    // SAFETY: The `libc::getuid` function can not fail.
+    unsafe { libc::getuid() }
+}
+
+/// A safe wrapper around [`libc::listen`].
+///
+/// See: `man listen`
+pub fn listen(fd: RawFd, backlog: c_int) -> LibcResult<()> {
+    // SAFETY: The `libc::listen` function takes no pointers and the return
+    //         value is checked and wrapped in a LibcResult.
+    libc_result_from_int_with_void(unsafe { libc::listen(fd, backlog) })
+}
+
+/// A safe wrapper around [`libc::lseek64`].
+///
+/// See: `man lseek64`
+pub fn lseek64(fd: RawFd, offset: libc::off64_t, whence: c_int) -> LibcResult<libc::off64_t> {
+    // SAFETY: The `libc::lseek64` function takes no pointers and the return
+    //         value is checked and wrapped in a LibcResult.
+    libc_result_from_int(unsafe { libc::lseek64(fd, offset, whence) })
+}
+
+/// A safe wrapper around [`libc::mallopt`].
+///
+/// See: `man mallopt`
+#[cfg(not(target_env = "musl"))]
+pub fn mallopt(cmd: c_int, arg: c_int) -> LibcResult<()> {
+    // SAFETY: This function takes no pointer arguments and the return value
+    //         is checked and wrapped in a LibcResult.
+    let retval = unsafe { libc::mallopt(cmd, arg) };
+
+    // This function returns 1 on success and 0 on error.
+    if retval == 0 {
+        Err(errno())
+    } else {
+        Ok(())
+    }
+}
+
+/// A safe wrapper around [`libc::open`].
+///
+/// See: `man open`
+pub fn open(path: &CStr, flags: c_int) -> LibcResult<RawFd> {
+    // SAFETY: Path points to a valid, null-terminated C string and the return
+    //         value is checked and wrapped in a LibcResult.
+    retry_eintr!(libc_result_from_int(unsafe { libc::open(path.as_ptr().cast(), flags) }))
+}
+
+/// A safe wrapper around [`libc::opendir`].
+///
+/// See: `man opendir`
+pub fn opendir(path: &CStr) -> LibcResult<LibcDir> {
+    // SAFETY: Path points to a valid, null-terminated C string and the return
+    //         value is checked and wrapped in a LibcResult.  The pointer
+    //         itself has been verified as non-null and is thus wrapped in a
+    //         LibcResult.
+    libc_result_from_ptr(unsafe { libc::opendir(path.as_ptr()) }, LibcDir::from_raw)
+}
+
+/// A safe wrapper around [`libc::pipe`].
+///
+/// See: `man pipe`
+pub fn pipe() -> LibcResult<(RawFd, RawFd)> {
+    let mut pipes = [0; 2];
+    libc_result_from_int_with_payload(
+        // SAFETY: The file descriptor buffer is guaranteed to point to valid
+        //         memory and the return value is checked before the resulting
+        //         pipes are wrapped in a LibcResult.
+        unsafe { libc::pipe(pipes.as_mut_ptr()) },
+        || (pipes[0], pipes[1]),
+    )
+}
+
+/// A safe wrapper around [`libc::poll`].
+///
+/// See `man poll`
+pub fn poll(pollfds: &mut [PollFd], timeout: c_int) -> LibcResult<c_int> {
+    // SAFETY: The `pollfds` pointer is valid because it is derived from a
+    //         a valid slice reference and the length argument is obtained from
+    //         the provided slice.  The return value is checked and wrapped in
+    //         a LibcResult.
+    //
+    //         The cast between `*mut PollFd` and `*mut libc::pollfd` is safe
+    //         due to the use of `#[repr(transparent)]` on PollFd.
+    libc_result_from_int(unsafe {
+        libc::poll(
+            pollfds.as_mut_ptr() as *mut libc::pollfd,
+            pollfds.len() as libc::nfds_t,
+            timeout,
+        )
+    })
+}
+
+/// A safe wrapper around the [`libc::prctl`] `PR_SET_NAME` operation.
+///
+/// See: `man PR_SET_NAME`
+pub fn prctl_set_name<S: AsRef<[u8]>>(name: &S) {
+    let mut name_buffer = [0u8; 16];
+    let copy_len = std::cmp::min(name.as_ref().len(), name_buffer.len() - 1);
+    name_buffer[..copy_len].copy_from_slice(&name.as_ref()[..copy_len]);
+
+    // SAFETY: The only error that can be returned by the `libc::prctl`
+    //         `PR_SET_NAME` operation is `EINVAL`.  This error can not occur
+    //         for this operation as the pointer argument refers to a 16-byte
+    //         buffer allocated in this stack frame.
+    unsafe { libc::prctl(libc::PR_SET_NAME, name_buffer.as_ptr() as *const c_void) };
+}
+
+/// A safe wrapper around [`libc::read`].
+///
+/// See: `man read`
+pub fn read<T: LibcFromBytes>(fd: RawFd) -> LibcResult<(isize, T)> {
+    let mut buffer = MaybeUninit::<T>::zeroed();
+
+    // SAFETY: The `buff` pointer is valid because it is derived from a value
+    //         allocated in this function and the `count` argument is
+    //         calculated using `size_of()`.  The return value is checked and
+    //         wrapped in a LibcResult.
+    retry_eintr!(libc_result_from_int(unsafe {
+        libc::read(fd, buffer.as_mut_ptr() as *mut c_void, std::mem::size_of::<T>())
+    }))
+    // SAFETY: The buffer was zero-initialized when it was allocated.  The call
+    //         to `libc::read` will have rewritten the first `retval` bytes of
+    //         the buffer.
+    .and_then(|retval| Ok((retval, unsafe { buffer.assume_init() })))
+}
+
+/// A safe wrapper around [`libc::readdir`].
+///
+/// See: `man readdir`
+pub fn readdir(dir: &LibcDir) -> Option<NonNull<libc::dirent>> {
+    // SAFETY: The pointer to the directory is guaranteed to be NonNull and the
+    //         return value is checked and wrapped in a LibcResult.  The
+    //         pointer itself has been verified as non-null and is thus wrapped
+    //         in a LibcResult.
+    libc_result_from_ptr(unsafe { libc::readdir(dir.inner.as_ptr()) }, std::convert::identity).ok()
+}
+
+/// A safe wrapper around [`libc::readlink`].
+///
+/// See: `man readlink`
+pub fn readlink(path_name: &CStr) -> LibcResult<CStringBuffer> {
+    let mut link_buffer: CStringBuffer = BUFFER_INIT_CSTRING;
+
+    libc_result_from_int_with_payload(
+        // SAFETY: The path name is guaranteed to be a valid null-terminated C
+        //         string.  The link buffer is guaranteed to be a
+        //         zero-initialized buffer and the size_of function is used to
+        //         provide the buffer length to the libc call.  The return
+        //         value is checked and wrapped in a LibcResult.
+        unsafe {
+            libc::readlink(
+                path_name.as_ptr(),
+                link_buffer.as_mut_ptr().cast(),
+                std::mem::size_of::<CStringBuffer>(),
+            )
+        },
+        || link_buffer,
+    )
+}
+
+/// A limited wrapper around [`libc::recvmsg`].
+///
+/// This wrapper only provides functionality for receiving a single buffer from
+/// a UNIX-domain datagram session socket.
+///
+/// The [`libc::EINTR`] signal is handled internally using the [`retry_eintr!`]
+/// macro.
+///
+/// See `man recvmsg` and `man readv`
+pub fn recvmsg<const BUFFER_SIZE: usize>(fd: RawFd) -> LibcResult<(isize, [u8; BUFFER_SIZE])> {
+    let mut buffer = [0; BUFFER_SIZE];
+
+    // Usage of `mem::zeroed()` is required as implementations of `msghdr`
+    // can include private fields (e.g. aarch64-musl).
+    //
+    // SAFETY: The man page for recvmsg specifies that it is valid to zero-
+    //         initialize a msghdr struct.
+    let mut msghdr: libc::msghdr = unsafe { mem::zeroed() };
+
+    let mut io_vec =
+        libc::iovec { iov_base: buffer.as_mut_ptr() as *mut c_void, iov_len: buffer.len() };
+
+    msghdr.msg_iov = &mut io_vec;
+    msghdr.msg_iovlen = 1;
+
+    // SAFETY: All of the pointers passed to `libc::recvmsg` point to regions
+    //         allocated inside this function.  The return value is checked and
+    //         wrapped in a LibcResult.
+    retry_eintr!(libc_result_from_int(unsafe { libc::recvmsg(fd, &mut msghdr, 0) }))
+        .and_then(|retval| Ok((retval, buffer)))
+}
+
+/// A limited wrapper around [`libc::sendmsg`].
+///
+/// This wrapper only provides functionality for sending a single buffer over a
+/// UNIX-domain datagram session socket.
+///
+/// The [`libc::EINTR`] signal is handled internally using the [`retry_eintr!`]
+/// macro.
+///
+/// See: `man sendmsg`
+pub fn sendmsg(socket_fd: RawFd, buffer: &[u8]) -> LibcResult<isize> {
+    // Usage of `mem::zeroed()` is required as implementations of `msghdr`
+    // can include private fields (e.g. aarch64-musl).
+    //
+    // SAFETY: The man page for sendmsg specifies that it is valid to zero-
+    //         initialize a msghdr struct.
+    let mut msghdr: libc::msghdr = unsafe { mem::zeroed() };
+
+    let mut io_vec =
+        libc::iovec { iov_base: buffer.as_ptr() as *mut c_void, iov_len: buffer.len() };
+
+    msghdr.msg_iov = &mut io_vec;
+    msghdr.msg_iovlen = 1;
+
+    // SAFETY: All of the pointers passed to `libc::sendmsg` point to regions
+    //         allocated inside this function.  The return value is checked and
+    //         wrapped in a LibcResult.
+    retry_eintr!(libc_result_from_int(unsafe { libc::sendmsg(socket_fd, &msghdr, 0) }))
+}
+
+/// A safe wrapper around [`libc::setpgid`].
+///
+/// See: `man setpgid`
+pub fn setpgid(pid: libc::pid_t, pgid: libc::pid_t) -> LibcResult<()> {
+    // SAFETY: The `libc::setpgid` function takes no pointers and the return
+    //         value is checked and wrapped in a LibcResult.
+    libc_result_from_int_with_void(unsafe { libc::setpgid(pid, pgid) })
+}
+
+/// A safe wrapper around [`libc::setpriority`]
+///
+/// See: `man setpriority`
+pub fn setpriority(which: which_t, who: libc::id_t, prio: c_int) -> LibcResult<c_int> {
+    errno_clear();
+
+    // SAFETY: `errno` is cleared before calling the function and checked upon
+    //         return.
+    let result: c_int = unsafe { libc::setpriority(which, who, prio) };
+    if errno().code == 0 {
+        Ok(result)
+    } else {
+        Err(errno())
+    }
+}
+
+/// A safe wrapper around [`libc::setregid`]
+///
+/// See: `man setregid`
+pub fn setregid(rgid: libc::gid_t, egid: libc::gid_t) -> LibcResult<()> {
+    // SAFETY: The `libc::setregid` function takes no pointers and the return
+    //         value is checked and wrapped in a LibcResult.
+    libc_result_from_int_with_void(unsafe { libc::setregid(rgid, egid) })
+}
+
+/// A safe wrapper around [`libc::setreuid`]
+///
+/// See : `man setreuid`
+pub fn setreuid(ruid: libc::uid_t, euid: libc::uid_t) -> LibcResult<()> {
+    // SAFETY: The `libc::setreuid` function takes no pointers and the return
+    //         value is checked and wrapped in a LibcResult.
+    libc_result_from_int_with_void(unsafe { libc::setreuid(ruid, euid) })
+}
+
+/// A safe wrapper around [`libc::sigaddset`]
+///
+/// See: `man sigsetops`
+pub fn sigaddset(sigset: &mut libc::sigset_t, signum: c_int) -> LibcResult<()> {
+    // SAFETY: The argument pointer is constructed from a valid reference.  The
+    //         return value is checked and wrapped in a LibcResult.
+    libc_result_from_int_with_void(unsafe { libc::sigaddset(sigset, signum) })
+}
+
+/// A safe wrapper around [`libc::sigemptyset`]
+///
+/// See: `man sigsetops`
+pub fn sigemptyset() -> LibcResult<libc::sigset_t> {
+    let mut sigset = MaybeUninit::<libc::sigset_t>::uninit();
+
+    libc_result_from_int_with_payload(
+        // SAFETY: The passed in pointer is valid and points to a location
+        //         allocated on the previous line.
+        unsafe { libc::sigemptyset(sigset.as_mut_ptr()) },
+        // SAFETY: Libc guarantees that this signal set is now initialized.
+        || unsafe { sigset.assume_init() },
+    )
+}
+
+/// A safe wrapper around [`libc::signalfd`].
+///
+/// See: `man signalfd`
+pub fn signalfd(fd: RawFd, sigset: &libc::sigset_t, flags: c_int) -> LibcResult<RawFd> {
+    // SAFETY: The sigset pointer is guaranteed to be valid because it is
+    //         passed in as a reference.  Invalid argument values will
+    //         result in an error being returned by `libc::signalfd`.  The
+    //         return value is checked and wrapped in a LibcResult.
+    libc_result_from_int(unsafe { libc::signalfd(fd, sigset, flags) })
+}
+
+/// A safe wrapper around [`libc::sigprocmask`]
+///
+/// See `man sigprocmask`
+pub fn sigprocmask(how: c_int, sigset: &libc::sigset_t) -> LibcResult<libc::sigset_t> {
+    let mut sigset_out = MaybeUninit::<libc::sigset_t>::uninit();
+
+    libc_result_from_int_with_payload(
+        // SAFETY: The pointer arguments are guaranteed to be valid memory
+        //         addresses as they are created from references.  The return
+        //         value is checked and wrapped in a LibcResult.
+        unsafe { libc::sigprocmask(how, sigset, sigset_out.as_mut_ptr()) },
+        // SAFETY: Lib guarantees that this memory now contains a valid
+        //         libc::sigset_t.
+        || unsafe { sigset_out.assume_init() },
+    )
+}
+
+/// A safe wrapper around [`libc::socket`].
+///
+/// See: `man socket`
+pub fn socket(domain: c_int, ty: c_int, protocol: c_int) -> LibcResult<RawFd> {
+    // SAFETY: Invalid argument values will result in a error being returned
+    //         by `libc::socket`.  The return value is checked and wrapped in
+    //         a LibcResult.
+    libc_result_from_int(unsafe { libc::socket(domain, ty, protocol) })
+}
+
+/// A safe wrapper around [`libc::strerror_r`].
+///
+/// This function uses `strerror_r` because `strerror` is not thread-safe.
+///
+/// See: `man strerror`
+pub fn strerror(code: c_int) -> LibcResult<CStringBuffer> {
+    let mut buffer: CStringBuffer = BUFFER_INIT_CSTRING;
+
+    // SAFETY: The pointer argument refers to memory allocated in this function.
+    let retval = unsafe { libc::strerror_r(code, buffer.as_mut_ptr().cast(), buffer.len()) };
+
+    if retval == 0 {
+        Ok(buffer)
+    } else {
+        Err(Errno { code: retval })
+    }
+}
+
+/// Android-specific functionality
+#[cfg(target_os = "android")]
+pub mod android {
+    use core::ffi::{c_uint, c_void};
+
+    use anyhow::{anyhow, Result};
+
+    use crate::libc_fill;
+
+    /// Error levels for Android's File Descriptor Sanitizer
+    ///
+    /// See: https://android.googlesource.com/platform/bionic/+/master/docs/fdsan.md
+    #[repr(C)]
+    pub enum FDSanErrorLevel {
+        /// No errors
+        Disabled = 0,
+        /// Warn once(ish) on error, and then downgrade to [`Disabled`]
+        WarnOnce,
+        /// Warn always on error
+        WarnAlways,
+        /// Abort on error
+        Fatal,
+    }
+
+    fn fdsan_error_level(level: c_uint) -> FDSanErrorLevel {
+        match level {
+            0 => FDSanErrorLevel::Disabled,
+            1 => FDSanErrorLevel::WarnOnce,
+            2 => FDSanErrorLevel::WarnAlways,
+            3 => FDSanErrorLevel::Fatal,
+            _ => panic!("Invalid result returned from libc"),
+        }
+    }
+
+    /// Operations supported by [`mallopt`]
+    ///
+    /// See: https://cs.android.com/android/platform/superproject/main/+/main:bionic/libc/platform/bionic/malloc.h;l=54
+    #[derive(Clone, Copy, Debug)]
+    #[repr(C)]
+    pub enum MalloptOpcode {
+        /// Marks the calling process as a profileable zygote child, possibly
+        /// initializing profiling infrastructure.
+        InitZygoteChildProfiling = 1,
+        /// Reset malloc hooks
+        ResetHooks = 2,
+        /// Set an upper bound on the total size in bytes of all allocations
+        /// made using the memory allocation APIs.
+        ///   arg = size_t*
+        ///   arg_size = sizeof(size_t)
+        SetAllocationLimitBytes = 3,
+        /// Called after the zygote forks to indicate this is a child.
+        SetZygoteChild = 4,
+        /// Options to dump backtraces of allocations. These options only
+        /// work when malloc debug has been enabled.
+        ///
+        /// Writes the backtrace information of all current allocations to a file.
+        /// NOTE: arg_size has to be sizeof(FILE*) because FILE is an opaque type.
+        ///   arg = FILE*
+        ///   arg_size = sizeof(FILE*)
+        WriteMallocLeekInfoToFile = 5,
+        /// Get information about the backtraces of all
+        ///   arg = android_mallopt_leak_info_t*
+        ///   arg_size = sizeof(android_mallopt_leak_info_t)
+        GetMallocLeakInfo = 6,
+        /// Free the memory allocated and returned by M_GET_MALLOC_LEAK_INFO.
+        ///   arg = android_mallopt_leak_info_t*
+        ///   arg_size = sizeof(android_mallopt_leak_info_t)
+        FreeMallocLeakInfo = 7,
+        /// Query whether the current process is considered to be profileable by
+        /// the Android platform. Result is assigned to the arg pointer's
+        /// destination.
+        ///   arg = bool*
+        ///   arg_size = sizeof(bool)
+        GetProcessProfileable = 9,
+        /// Maybe enable GWP-ASan. Set *arg to force GWP-ASan to be turned on,
+        /// otherwise this mallopt() will internally decide whether to sample
+        /// the process. The program must be single threaded at the point when
+        /// the android_mallopt function is called.
+        ///   arg = android_mallopt_gwp_asan_options_t*
+        ///   arg_size = sizeof(android_mallopt_gwp_asan_options_t)
+        InitializeGwpAsan = 10,
+        /// Query whether memtag stack is enabled for this process.
+        MemtagStackIsOn = 11,
+        /// Query whether the current process has the decay time enabled so
+        /// that the memory from allocations are not immediately released to the
+        /// OS. Result is assigned to the arg pointer's destination.
+        ///   arg = bool*
+        ///   arg_size = sizeof(bool)
+        GetDecayTimeEnabled = 12,
+    }
+
+    /// A safe wrapper around [`libc_fill::android_fdsan_get_error_level`]
+    ///
+    /// # Safety
+    /// This function is not thread safe.
+    ///
+    /// See: https://android.googlesource.com/platform/bionic/+/master/docs/fdsan.md
+    pub unsafe fn fdsan_get_error_level() -> FDSanErrorLevel {
+        // SAFETY: This function takes not arguments and always succeeds.
+        fdsan_error_level(unsafe { libc_fill::android_fdsan_get_error_level() })
+    }
+
+    /// A safe wrapper around [`libc_fill::android_fdsan_get_error_level`]
+    ///
+    /// # Safety
+    /// This function is not thread safe.
+    ///
+    /// See: https://android.googlesource.com/platform/bionic/+/master/docs/fdsan.md
+    pub unsafe fn fdsan_set_error_level(level: FDSanErrorLevel) -> FDSanErrorLevel {
+        // SAFETY: This function takes an integer argument and always succeeds.
+        fdsan_error_level(unsafe { libc_fill::android_fdsan_set_error_level(level as c_uint) })
+    }
+
+    /// A safe wrapper around [`libc_fill::android_mallopt`] and the
+    /// M_SET_ZYGOTE_CHILD opcode
+    pub fn set_zygote_child() -> Result<()> {
+        // SAFETY: This opcode takes no arguments so a nullptr is passed
+        //         instead.
+        unsafe {
+            libc_fill::android_mallopt(
+                MalloptOpcode::SetZygoteChild as _,
+                std::ptr::null_mut(),
+                std::mem::size_of::<c_void>(),
+            )
+        }
+        .then_some(())
+        .ok_or_else(|| anyhow!("Call to android_mallopt failed: Opcode = M_SET_ZYGOTE_CHILD"))
+    }
+
+    /// Reset the thread local stack protection salt.
+    ///
+    /// The caller should not return after calling this function.  If it does,
+    /// and stack protection is enabled, the program will crash.
+    ///
+    /// TODO: Make this function take a `noreturn` thunk.
+    pub fn reset_stack_guards() {
+        libc_fill::android_reset_stack_guards();
+    }
+}
diff --git a/zygote/src/test.rs b/zygote/src/test.rs
new file mode 100644
index 0000000..faee538
--- /dev/null
+++ b/zygote/src/test.rs
@@ -0,0 +1,84 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This module contains functions and data used by tests.
+
+use core::ffi::CStr;
+use std::{ffi::OsStr, panic, sync::Mutex};
+
+pub(crate) static MUTEX: Mutex<()> = Mutex::new(());
+
+/// Path to a file in the system temp directory used for testing
+pub const MOCK_FILE_PATH_1: &CStr = c"/tmp/mock_file_1";
+/// Path to a file in the system temp directory used for testing
+pub const MOCK_FILE_PATH_2: &CStr = c"/tmp/mock_file_2";
+/// Path to a file in the system temp directory used for testing
+pub const MOCK_FILE_PATH_3: &CStr = c"/tmp/mock_file_3";
+
+/// Abstract socket name used for testing
+pub const SOCKET_NAME_1: &str = "test_socket_abstract_1";
+/// Abstract socket name used for testing
+pub const SOCKET_NAME_2: &str = "test_socket_abstract_2";
+/// Abstract socket name used for testing
+pub const SOCKET_NAME_3: &str = "test_socket_abstract_3";
+
+/// Path to a socket in the system temp directory used for testing
+pub const SOCKET_PATH_1: &str = "/tmp/test_socket_bound_1";
+/// Path to a socket in the system temp directory used for testing
+pub const SOCKET_PATH_2: &str = "/tmp/test_socket_bound_2";
+/// Path to a socket in the system temp directory used for testing
+pub const SOCKET_PATH_3: &str = "/tmp/test_socket_bound_3";
+
+/// Ensure that all test resources are removed from the system after a test run
+pub fn cleanup() {
+    let test_file_paths = [MOCK_FILE_PATH_1, MOCK_FILE_PATH_2, MOCK_FILE_PATH_3];
+
+    let test_socket_paths = [SOCKET_PATH_1, SOCKET_PATH_2, SOCKET_PATH_3];
+
+    close_all(test_file_paths.iter().map(|s| s.to_str().unwrap()));
+    close_all(test_socket_paths.iter());
+}
+
+/// Unlink any of the provided file paths if they exist
+fn close_all<T: AsRef<OsStr>>(paths: impl std::iter::Iterator<Item = T>) {
+    for path_str in paths {
+        let path = std::path::Path::new(&path_str);
+        if path.exists() {
+            std::fs::remove_file(path).unwrap();
+        }
+    }
+}
+
+/// Acquire the global test serialization lock before running the provided
+/// test.  This ensures that tests evaluating behavior that requires a serial
+/// environment don't interfere with each other.
+#[track_caller]
+pub fn manage_test<F: FnOnce() + panic::UnwindSafe>(test_body: F) {
+    let _guard = serialize_test();
+
+    let unwind_result = panic::catch_unwind(test_body);
+    cleanup();
+    assert!(unwind_result.is_ok());
+}
+
+/// Acquire the global test serialization lock.
+pub(crate) fn serialize_test<'a>() -> std::sync::MutexGuard<'a, ()> {
+    loop {
+        match crate::test::MUTEX.lock() {
+            Ok(guard) => break guard,
+            Err(..) => crate::test::MUTEX.clear_poison(),
+        }
+    }
+}
diff --git a/zygote/tests/file_descriptors/calm.rs b/zygote/tests/file_descriptors/calm.rs
new file mode 100644
index 0000000..df9cbba
--- /dev/null
+++ b/zygote/tests/file_descriptors/calm.rs
@@ -0,0 +1,136 @@
+//
+// Copyright (C) 2025 The Android Open-Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Non-panicking tests of the file descriptor registry.  These tests need to
+//! be run without a test harness to avoid having unknown file descriptors
+//! open during execution.
+
+use core::{assert_eq, ops::Deref};
+use std::{fs::File, os::fd::AsRawFd};
+
+use rustix::fd::IntoRawFd;
+
+use zygote::{
+    assert_ok,
+    file_descriptors::{self, assert_fd_open_to, Action, FileDescriptorRegistry},
+    introspection::{assert_fd_closed, assert_single_threaded},
+    sys, test,
+};
+
+// Command-line arguments to ignore, because they are not supported by libtest-mimic.
+const IGNORED_ARGS: [&str; 2] = ["-Zunstable-options", "--report-time"];
+
+fn test_file_descriptor_registry() -> Result<(), std::io::Error> {
+    assert_single_threaded();
+
+    test::manage_test(|| {
+        /*
+         * Initialize registry
+         */
+
+        let mut registry = FileDescriptorRegistry::new(&zygote::species::mock::Turtle);
+        assert_eq!(registry.size(), 3);
+        assert_ok!(registry.audit());
+
+        /*
+         * Create and register resources
+         */
+
+        // Test registration of FIFO descriptors
+        let (pipe0, pipe1) = sys::pipe().unwrap();
+        registry.register(pipe0, Action::Close);
+        registry.register(pipe1, Action::Close);
+
+        // Test automatic registration and global file allow list
+        let urandom_fd = File::open(file_descriptors::DEV_URANDOM_PATH).unwrap().into_raw_fd();
+
+        // Test automatic registration and species file allow list
+        let mock_file_1 = File::create(test::MOCK_FILE_PATH_1.to_str().unwrap()).unwrap();
+
+        // Test automatic registration and dynamic file allow list
+        let mock_file_2 = File::create(test::MOCK_FILE_PATH_2.to_str().unwrap()).unwrap();
+        registry.allow_file(test::MOCK_FILE_PATH_2.to_str().unwrap().to_owned());
+
+        // Test automatic registration and species bound socket allow list
+        let bound_socket_1 =
+            sys::create_bound_socket(test::SOCKET_PATH_1, libc::SOCK_DGRAM).unwrap();
+
+        // Test automatic registration and dynamic bound socket allow list
+        let bound_socket_2 =
+            sys::create_bound_socket(test::SOCKET_PATH_2, libc::SOCK_DGRAM).unwrap();
+        registry.allow_bound_socket(test::SOCKET_PATH_2.into());
+
+        // Test automatic registration and species abstract socket allow list
+        let abstract_socket_1 =
+            sys::create_abstract_socket(test::SOCKET_NAME_1, libc::SOCK_DGRAM).unwrap();
+
+        // Test automatic registration and dynamic abstract socket allow list
+        let abstract_socket_2 =
+            sys::create_abstract_socket(test::SOCKET_NAME_2, libc::SOCK_DGRAM).unwrap();
+        registry.allow_abstract_socket(test::SOCKET_NAME_2.into());
+
+        // Manually register an abstract socket for testing the Ignore action
+        let abstract_socket_3 =
+            sys::create_abstract_socket(test::SOCKET_NAME_3, libc::SOCK_DGRAM).unwrap();
+        registry.register(abstract_socket_3.as_raw_fd(), Action::Ignore);
+
+        // Test automatic registration of new file descriptors.
+        registry.register_new();
+
+        /*
+         * Test action handling
+         */
+
+        registry.execute_actions();
+
+        // Test that the FIFO descriptors have been closed
+        assert_fd_closed(pipe0);
+        assert_fd_closed(pipe1);
+
+        // Test that urandom, mock_file_1, and mock_file_2 have been re-opened
+        assert_fd_open_to(urandom_fd, file_descriptors::DEV_URANDOM_PATH);
+        assert_fd_open_to(mock_file_1.as_raw_fd(), test::MOCK_FILE_PATH_1.to_str().unwrap());
+        assert_fd_open_to(mock_file_2.as_raw_fd(), test::MOCK_FILE_PATH_2.to_str().unwrap());
+
+        // Test that our default action abstract and bound sockets have been duped
+        // to /dev/null
+        assert_fd_open_to(bound_socket_1, file_descriptors::DEV_NULL_PATH);
+        assert_fd_open_to(bound_socket_2, file_descriptors::DEV_NULL_PATH);
+        assert_fd_open_to(abstract_socket_1, file_descriptors::DEV_NULL_PATH);
+        assert_fd_open_to(abstract_socket_2, file_descriptors::DEV_NULL_PATH);
+
+        // Test that abstract_socket_3 is still open
+        assert_fd_open_to(abstract_socket_3, test::SOCKET_NAME_3);
+    });
+
+    Ok(())
+}
+
+fn main() -> Result<(), std::io::Error> {
+    let args = libtest_mimic::Arguments {
+        // Force single-threaded execution to ensure file descriptor operations
+        // do not interfere with one another.
+        test_threads: Some(1),
+        ..libtest_mimic::Arguments::from_iter(
+            std::env::args().filter(|arg| !IGNORED_ARGS.contains(&arg.deref())),
+        )
+    };
+
+    let tests = vec![libtest_mimic::Trial::test("file_descriptor_registry_test", || {
+        Ok(test_file_descriptor_registry()?)
+    })];
+
+    libtest_mimic::run(&args, tests).exit();
+}
```

